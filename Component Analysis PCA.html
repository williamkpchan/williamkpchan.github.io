<!doctype html>
<head lang="en-US" prefix="og: http://ogp.me/ns#">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="mystyle.css">
<script src="jquery.min.js"></script>
<script>
$(document).ready(function(){
    $('h2, h3').click(function(){
    window.scrollTo(0,0);
    return false;
    });
});
</script>

</head>
<body>


<h1 itemprop="name" class="entry-title">Practical Guide to Principal Component Analysis (PCA) in R &#038; Python</h1>

<h2>Introduction</h2>
<blockquote>
<p style="text-align: center;">Too much of anything is good for nothing!</p>
</blockquote>
<p style="text-align: justify;">What happens when a data set has too many variables ? Here are few possible situations which you might come across:</p>
<ol>
<li>You find that most of the variables are correlated.</li>
<li>You lose patience and decide to run a model on whole data. This returns poor accuracy and you feel terrible.</li>
<li>You become indecisive about what to do</li>
<li>You start thinking of some strategic method to find few important variables</li>
</ol>
<p style="text-align: justify;">Trust me, dealing with such situations isn&#8217;t as difficult as it sounds. Statistical techniques such as <b class="redword">factor analysis, principal component analysis</b> help to overcome such difficulties.</p>
<p style="text-align: justify;">In this post, I&#8217;ve explained the concept of principal component analysis in detail. I&#8217;ve kept the explanation to be simple and informative. For practical understanding, I&#8217;ve also demonstrated using this technique in R with interpretations.</p>
<p style="text-align: justify;"><em>Note: Understanding this concept requires prior knowledge of statistics. </em></p>
<p><em>Update (as on 28th July): Process of Predictive Modeling with PCA Components in R is added below.</em></p>

<h2>What is Principal Component Analysis ?</h2>
<p style="text-align: justify;">In simple words, principal component analysis is a method of extracting important variables (in form of components) from a large set of variables available in a data set. It extracts low dimensional set of features from a high dimensional data set with a motive to capture as much information as possible. With fewer variables, visualization also becomes much more meaningful. PCA is more useful when dealing with 3 or higher dimensional data.</p>
<p style="text-align: justify;">It is always performed on a symmetric correlation or covariance matrix. This means the matrix should be numeric and have standardized data.</p>
<p style="text-align: justify;">Let&#8217;s understand it using an example:</p>
<p style="text-align: justify;">Let&#8217;s say we have a data set of dimension 300 (<em>n</em>) × 50 (<em>p</em>). <em>n</em> represents the number of observations and <em>p</em> represents number of predictors. Since we have a large p = 50, there can be <code>p(p-1)/2</code> scatter plots i.e more than 1000 plots possible to analyze the variable relationship. Wouldn&#8217;t is be a tedious job to perform exploratory analysis on this data ?</p>
<p style="text-align: justify;">In this case, it would be a lucid approach to select a subset of <em>p</em> <em>(p &lt;&lt; 50)</em> predictor which captures as much information. Followed by plotting the observation in the resultant low dimensional space.</p>
<p style="text-align: justify;">The image below shows the transformation of a high dimensional data (3 dimension) to low dimensional data (2 dimension) using PCA. Not to forget, each resultant dimension is a linear combination of <em>p</em> features</p>
<p style="text-align: center;"><img class="alignnone size-full wp-image-24144" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1.png" alt="1" width="1079" height="428" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1.png 1079w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1-300x119.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1-768x305.png 768w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1-1024x406.png 1024w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/1-1-850x337.png 850w" sizes="(max-width: 1079px) 100vw, 1079px" />Source: <a href="http://www.nlpca.org/pca_principal_component_analysis.html" target="_blank" rel="nofollow">nlpca</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>What are principal components ?</h2>
<p style="text-align: justify;">A principal component is a normalized linear combination of the original predictors in a data set. In image above, <em>PC1</em> and <em>PC2</em> are the principal components. Let&#8217;s say we have a set of predictors as <code>X¹, X²...,X<sup>p</sup></code></p>
<p>The principal component can be written as:</p>
<p style="text-align: center;"><code>Z¹ = Φ¹¹X¹ + Φ²¹X² + Φ³¹X³ + .... +</code>Φ<sup>p</sup><code>¹X<sup>p</sup></code></p>
<p>where,</p>
<ul>
<li>Z¹ is first principal component</li>
<li style="text-align: justify;"><code>Φ<sup>p</sup>¹</code> is the loading vector comprising of loadings (<code>Φ¹, Φ²..</code>) of first principal component. The loadings are constrained to a sum of square equals to 1. This is because large magnitude of loadings may lead to large variance. It also defines the direction of the principal component (Z¹) along which data varies the most. It results in a line in <em>p</em> dimensional space which is closest to the <em>n</em> observations. Closeness is measured using average squared euclidean distance.</li>
<li><code>X¹..X<sup>p</sup></code> are normalized predictors. Normalized predictors have mean equals to zero and standard deviation equals to one.</li>
</ul>
<p>Therefore,</p>
<p style="text-align: justify;"><strong>First principal component</strong> is a linear combination of original predictor variables which captures the maximum variance in the data set. It determines the direction of highest variability in the data. Larger the variability captured in first component, larger the information captured by component. No other component can have variability higher than first principal component.</p>
<p style="text-align: justify;">The first principal component results in a line which is closest to the data i.e. it minimizes the sum of squared distance between a data point and the line.</p>
<p>Similarly, we can compute the second principal component also.</p>
<p>&nbsp;</p>
<p style="text-align: justify;"><strong>Second principal component</strong> (<code>Z²</code>) is also a linear combination of original predictors which captures the remaining variance in the data set and is uncorrelated with <code>Z¹</code>. In other words, the correlation between first and second component should is zero. It can be represented as:</p>
<p style="text-align: center;"><code>Z² = Φ¹²X¹ + Φ²²X² + Φ³²X³ + .... + Φ<sup>p2</sup><code>X<sup>p</sup></code></code></p>
<p style="text-align: justify;">If the two components are uncorrelated, their directions should be orthogonal (image below). This image is based on a simulated data with 2 predictors. Notice the direction of the components, as expected they are orthogonal. This suggests the correlation b/w these components in zero.</p>
<p style="text-align: justify;"><img class="alignnone wp-image-24145 size-full" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/2-1-e1458494877196.png" alt="2" width="847" height="473" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/2-1-e1458494877196.png 847w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/2-1-e1458494877196-300x168.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/2-1-e1458494877196-768x429.png 768w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/2-1-e1458494877196-257x144.png 257w" sizes="(max-width: 847px) 100vw, 847px" />All succeeding principal component follows a similar concept i.e. they capture the remaining variation without being correlated with the previous component. In general, for <em>n × p</em> dimensional data, min(<em>n-1, p)</em> principal component can be constructed.</p>
<p style="text-align: justify;">The directions of these components are identified in an unsupervised way i.e. the response variable(Y) is not used to determine the component direction. Therefore, it is an unsupervised approach.</p>
<p style="text-align: justify;"><em>Note: Partial least square (PLS) is a supervised alternative to PCA. PLS assigns higher weight to variables which are strongly related to response variable to determine principal components.</em></p>
<p>&nbsp;</p>
<h2>Why is normalization of variables necessary ?</h2>
<p style="text-align: justify;">The principal components are supplied with normalized version of original predictors. This is because, the original predictors may have different scales. For example: Imagine a data set with variables&#8217; measuring units as gallons, kilometers, light years etc. It is definite that the scale of variances in these variables will be large.</p>
<p style="text-align: justify;">Performing PCA on un-normalized variables will lead to insanely large loadings for variables with high variance. In turn, this will lead to dependence of a principal component on the variable with high variance. This is undesirable.</p>
<p style="text-align: justify;">As shown in image below, PCA was run on a data set twice (with unscaled and scaled predictors). This data set has ~40 variables. You can see, first principal component is dominated by a variable Item_MRP. And, second principal component is dominated by a variable Item_Weight. This domination prevails due to high value of variance associated with a variable. When the variables are scaled, we get a much better representation of variables in 2D space.</p>
<p><img class="size-full wp-image-24148 aligncenter" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/6-1.png" alt="6" width="727" height="407" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/6-1.png 727w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/6-1-300x168.png 300w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/6-1-257x144.png 257w" sizes="(max-width: 727px) 100vw, 727px" /></p>
<p>&nbsp;</p>
<h2>Implement PCA in R &amp; Python (with interpretation)</h2>
<p style="text-align: justify;">How many principal components to choose ? I could dive deep in theory, but it would be better to answer these question practically.</p>
<p>For this demonstration, I&#8217;ll be using the data set from <a href="http://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii" target="_blank" rel="nofollow">Big Mart Prediction Challenge III</a>.</p>
<p style="text-align: justify;">Remember, PCA can be applied only on numerical data. Therefore, if the data has categorical variables they must be converted to numerical. Also, make sure you have done the basic data cleaning prior to implementing this technique. Let&#8217;s quickly finish with initial data loading and cleaning steps:</p>
<p><code>#directory path</code><br />
<code> &gt; path &lt;- ".../Data/Big_Mart_Sales"</code></p>
<p><code>#set working directory</code><br />
<code> &gt; setwd(path)</code></p>
<p><code>#load train and test file</code><br />
<code> &gt; train &lt;- read.csv("train_Big.csv")</code><br />
<code> &gt; test &lt;- read.csv("test_Big.csv")</code></p>
<p><code>#add a column</code><br />
<code> &gt; test$Item_Outlet_Sales &lt;- 1</code></p>
<p><code>#combine the data set</code><br />
<code> &gt; combi &lt;- rbind(train, test)</code></p>
<p><code>#impute missing values with median</code><br />
<code> &gt; combi$Item_Weight[is.na(combi$Item_Weight)] &lt;- median(combi$Item_Weight, na.rm = TRUE)</code></p>
<p><code>#impute 0 with median</code><br />
<code> &gt; combi$Item_Visibility &lt;- ifelse(combi$Item_Visibility == 0, median(combi$Item_Visibility),                                   combi$Item_Visibility)</code></p>
<p><code>#find mode and impute</code><br />
<code> &gt; table(combi$Outlet_Size, combi$Outlet_Type)</code><br />
<code> &gt; levels(combi$Outlet_Size)[1] &lt;- "Other"</code></p>
<p style="text-align: justify;">Till here, we&#8217;ve imputed missing values. Now we are left with removing the dependent (response) variable and other identifier variables( if any). As we said above, we are practicing an unsupervised learning technique, hence response variable must be removed.</p>
<p><code>#remove the dependent and identifier variables</code><br />
<code> &gt; my_data &lt;- subset(combi, select = -c(Item_Outlet_Sales, Item_Identifier,                                       Outlet_Identifier))</code></p>
<p>Let&#8217;s check the available variables ( a.k.a predictors) in the data set.</p>
<p><code>#check available variables</code><br />
<code> &gt; colnames(my_data)</code></p>
<p>Since PCA works on numeric variables, let&#8217;s see if we have any variable other than numeric.</p>
<p><code>#check variable class</code><br />
<code> &gt; str(my_data)</code></p>
<p><code>'data.frame': 14204 obs. of 9 variables:</code><br />
<code> $ Item_Weight : num 9.3 5.92 17.5 19.2 8.93 ...</code><br />
<code> $ Item_Fat_Content : Factor w/ 5 levels "LF","low fat",..: 3 5 3 5 3 5 5 3 5 5 ...</code><br />
<code> $ Item_Visibility : num 0.016 0.0193 0.0168 0.054 0.054 ...</code><br />
<code> $ Item_Type : Factor w/ 16 levels "Baking Goods",..: 5 15 11 7 10 1 14 14 6 6 ...</code><br />
<code> $ Item_MRP : num 249.8 48.3 141.6 182.1 53.9 ...</code><br />
<code> $ Outlet_Establishment_Year: int 1999 2009 1999 1998 1987 2009 1987 1985 2002 2007 ...</code><br />
<code> $ Outlet_Size : Factor w/ 4 levels "Other","High",..: 3 3 3 1 2 3 2 3 1 1 ...</code><br />
<code> $ Outlet_Location_Type : Factor w/ 3 levels "Tier 1","Tier 2",..: 1 3 1 3 3 3 3 3 2 2 ...</code><br />
<code> $ Outlet_Type : Factor w/ 4 levels "Grocery Store",..: 2 3 2 1 2 3 2 4 2 2 ...</code></p>
<p style="text-align: justify;">Sadly, 6 out of 9 variables are categorical in nature. We have some additional work to do now. We&#8217;ll convert these categorical variables into numeric using one hot encoding.</p>
<p><code>#load library</code><br />
<code>&gt; library(dummies)</code></p>
<p><code>#create a dummy data frame</code><br />
<code>&gt; new_my_data &lt;- dummy.data.frame(my_data, names = c("Item_Fat_Content","Item_Type",</code><br />
<code>                                "Outlet_Establishment_Year","Outlet_Size",</code><br />
<code>                                "Outlet_Location_Type","Outlet_Type"))</code></p>
<p style="text-align: justify;">To check, if we now have a data set of integer values, simple write:</p>
<p><code>#check the data set</code><br />
<code>&gt; str(new_my_data)</code></p>
<p>And, we now have all the numerical values. Let&#8217;s divide the data into test and train.</p>
<p><code>#divide the new data</code><br />
<code>&gt; pca.train &lt;- new_my_data[1:nrow(train),]</code><br />
<code>&gt; pca.test &lt;- new_my_data[-(1:nrow(train)),]</code></p>
<p>We can now go ahead with PCA.</p>
<p style="text-align: justify;">The base R function prcomp() is used to perform PCA. By default, it centers the variable to have mean equals to zero. With parameter <code>scale. = T</code>, we normalize the variables to have standard deviation equals to 1.</p>
<p><code>#principal component analysis</code><br />
<code> &gt; prin_comp &lt;- prcomp(pca.train, scale. = T)</code><br />
<code> &gt; names(prin_comp)</code><br />
<code> [1] "sdev"     "rotation" "center"   "scale"    "x"</code></p>
<p>The prcomp() function results in 5 useful measures:</p>
<p style="text-align: justify;">1. <em>center</em> and <em>scale</em> refers to respective mean and standard deviation of the variables that are used for normalization prior to implementing PCA</p>
<p><code>#outputs the mean of variables</code><br />
<code> prin_comp$center</code></p>
<p><code>#outputs the standard deviation of variables</code><br />
<code> prin_comp$scale</code></p>
<p style="text-align: justify;">2. The rotation measure provides the principal component loading. Each column of rotation matrix contains the principal component loading vector. This is the most important measure we should be interested in.</p>
<p><code>&gt; prin_comp$rotation</code></p>
<p style="text-align: justify;">This returns 44 principal components loadings. Is that correct ? Absolutely. In a data set, the maximum number of principal component loadings is a minimum of (n-1, p). Let&#8217;s look at first 4 principal components and first 5 rows.</p>
<p><code>&gt; prin_comp$rotation[1:5,1:4]</code><br />
<code>                                PC1            PC2            PC3             PC4</code><br />
<code>Item_Weight                0.0054429225   -0.001285666   0.011246194   0.011887106</code><br />
<code>Item_Fat_ContentLF        -0.0021983314    0.003768557  -0.009790094  -0.016789483</code><br />
<code>Item_Fat_Contentlow fat   -0.0019042710    0.001866905  -0.003066415  -0.018396143</code><br />
<code>Item_Fat_ContentLow Fat    0.0027936467   -0.002234328   0.028309811   0.056822747</code><br />
<code>Item_Fat_Contentreg        0.0002936319    0.001120931   0.009033254  -0.001026615</code></p>
<p style="text-align: justify;">3. In order to compute the principal component score vector, we don&#8217;t need to multiply the loading with data. Rather, the matrix x has the principal component score vectors in a 8523 × 44 dimension.</p>
<p>&gt; dim(prin_comp$x)<br />
[1] 8523    44</p>
<p>Let&#8217;s plot the resultant principal components.</p>
<p><code>&gt; biplot(prin_comp, scale = 0)</code></p>
<p><img class="size-full wp-image-24149 aligncenter" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/4-1.png" alt="4" width="654" height="668" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/4-1.png 654w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/4-1-294x300.png 294w" sizes="(max-width: 654px) 100vw, 654px" /></p>
<p style="text-align: justify;">The parameter <code>scale = 0</code> ensures that arrows are scaled to represent the loadings. To make inference from image above, focus on the extreme ends (top, bottom, left, right) of this graph.</p>
<p style="text-align: justify;">We infer than first principal component corresponds to a measure of Outlet_TypeSupermarket, Outlet_Establishment_Year 2007. Similarly, it can be said that the second component corresponds to a measure of Outlet_Location_TypeTier1, Outlet_Sizeother. For exact measure of a variable in a component, you should look at rotation matrix(above) again.</p>
<p style="text-align: justify;">4. The prcomp() function also provides the facility to compute standard deviation of each principal component. <em>sdev</em> refers to the standard deviation of principal components.</p>
<p><code>#compute standard deviation of each principal component</code><br />
<code> &gt; std_dev &lt;- prin_comp$sdev</code></p>
<p><code>#compute variance</code><br />
<code> &gt; pr_var &lt;- std_dev^2</code></p>
<p><code>#check variance of first 10 components</code><br />
<code> &gt; pr_var[1:10]</code><br />
<code> [1] 4.563615 3.217702 2.744726 2.541091 2.198152 2.015320 1.932076 1.256831</code><br />
<code> [9] 1.203791 1.168101</code></p>
<p style="text-align: justify;">We aim to find the components which explain the maximum variance. This is because, we want to retain as much information as possible using these components. So, higher is the explained variance, higher will be the information contained in those components.</p>
<p style="text-align: justify;">To compute the proportion of variance explained by each component, we simply divide the variance by sum of total variance. This results in:</p>
<p><code>#proportion of variance explained</code><br />
<code> &gt; prop_varex &lt;- pr_var/sum(pr_var)</code><br />
<code> &gt; prop_varex[1:20]</code><br />
<code> [1] 0.10371853 0.07312958 0.06238014 0.05775207 0.04995800 0.04580274</code><br />
<code> [7] 0.04391081 0.02856433 0.02735888 0.02654774 0.02559876 0.02556797</code><br />
<code> [13] 0.02549516 0.02508831 0.02493932 0.02490938 0.02468313 0.02446016</code><br />
<code> [19] 0.02390367 0.02371118</code></p>
<p style="text-align: justify;">This shows that first principal component explains 10.3% variance. Second component explains 7.3% variance. Third component explains 6.2% variance and so on. So, how do we decide how many components should we select for modeling stage ?</p>
<p style="text-align: justify;">The answer to this question is provided by a scree plot. A scree plot is used to access components or factors which explains the most of variability in the data. It represents values in descending order.</p>
<p><code>#scree plot</code><br />
<code>&gt; plot(prop_varex, xlab = "Principal Component",</code><br />
<code>             ylab = "Proportion of Variance Explained",</code><br />
<code>             type = "b")</code></p>
<p><img class="aligncenter wp-image-24150 size-full" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/7-1-e1458531438291.png" alt="scree plot principal component analysis" width="659" height="405" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/7-1-e1458531438291.png 659w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/7-1-e1458531438291-300x184.png 300w" sizes="(max-width: 659px) 100vw, 659px" /></p>
<p style="text-align: justify;">The plot above shows that ~ 30 components explains around 98.4% variance in the data set. In order words, using PCA we have reduced 44 predictors to 30 without compromising on explained variance. This is the power of PCA&gt; Let&#8217;s do a confirmation check, by plotting a cumulative variance plot. This will give us a clear picture of number of components.</p>
<p><code>#cumulative scree plot</code><br />
<code> &gt; plot(cumsum(prop_varex), xlab = "Principal Component",</code><br />
<code>              ylab = "Cumulative Proportion of Variance Explained",</code><br />
<code>              type = "b")</code></p>
<p><img class="wp-image-24151 size-full aligncenter" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/8-1-e1458532011651.png" alt="8" width="653" height="402" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/8-1-e1458532011651.png 653w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/8-1-e1458532011651-300x185.png 300w" sizes="(max-width: 653px) 100vw, 653px" /></p>
<p style="text-align: justify;">This plot shows that 30 components results in variance close to ~ 98%. Therefore, in this case, we&#8217;ll select number of components as 30 [PC1 to PC30] and proceed to the modeling stage. This completes the steps to implement PCA on train data. For modeling, we&#8217;ll use these 30 components as predictor variables and follow the normal procedures.</p>
<p>&nbsp;</p>
<h3>Predictive Modeling with PCA Components</h3>
<p style="text-align: justify;">After we&#8217;ve calculated the principal components on training set, let&#8217;s now understand the process of predicting on test data using these components. The process is simple. Just like we&#8217;ve obtained PCA components on training set, we&#8217;ll get another bunch of components on testing set. Finally, we train the model.</p>
<p>But, few important points to understand:</p>
<ol>
<li style="text-align: justify;">We should not combine the train and test set to obtain PCA components of whole data at once. Because, this would violate the entire assumption of generalization since test data would get &#8216;leaked&#8217; into the training set. In other words, the test data set would no longer remain &#8216;unseen&#8217;. Eventually, this will hammer down the generalization capability of the model.</li>
<li style="text-align: justify;">We should not perform PCA on test and train data sets separately. Because, the resultant vectors from train and test PCAs will have different directions ( due to unequal variance). Due to this, we&#8217;ll end up comparing data registered on different axes. Therefore, the resulting vectors from train and test data should have same axes.</li>
</ol>
<p style="text-align: justify;">So, what should we do?</p>
<p style="text-align: justify;">We should do exactly the same transformation to the test set as we did to training set, including the center and scaling feature. Let&#8217;s do it in R:</p>
<p><code>#add a training set with principal components</code><br />
<code>&gt; train.data &lt;- data.frame(Item_Outlet_Sales = train$Item_Outlet_Sales, prin_comp$x)</code></p>
<p><code>#we are interested in first 30 PCAs</code><br />
<code>&gt; train.data &lt;- train.data[,1:31]</code></p>
<p><code>#run a decision tree</code><br />
<code>&gt; install.packages("rpart")</code><br />
<code>&gt; library(rpart)</code><br />
<code>&gt; rpart.model &lt;- rpart(Item_Outlet_Sales ~ .,data = train.data, method = "anova")</code><br />
<code>&gt; rpart.model</code></p>
<p><code>#transform test into PCA</code><br />
<code>&gt; test.data &lt;- predict(prin_comp, newdata = pca.test)</code><br />
<code>&gt; test.data &lt;- as.data.frame(test.data)</code></p>
<p><code>#select the first 30 components</code><br />
<code>&gt; test.data &lt;- test.data[,1:30]</code></p>
<p><code>#make prediction on test data</code><br />
<code>&gt; rpart.prediction &lt;- predict(rpart.model, test.data)</code></p>
<p><code>#For fun, finally check your score of leaderboard</code><br />
<code>&gt; sample &lt;- read.csv("SampleSubmission_TmnO39y.csv")</code><br />
<code>&gt; final.sub &lt;- data.frame(Item_Identifier = sample$Item_Identifier, Outlet_Identifier = sample$Outlet_Identifier, Item_Outlet_Sales = rpart.prediction)</code><br />
<code>&gt; write.csv(final.sub, "pca.csv",row.names = F)</code></p>
<p style="text-align: justify;">That&#8217;s the complete modeling process after PCA extraction. I&#8217;m sure you wouldn&#8217;t be happy with your leaderboard rank after you upload the solution. Try using random forest!</p>
<p>&nbsp;</p>
<p style="text-align: justify;"><strong>For Python Users:</strong> To implement PCA in python, simply import PCA from sklearn library. The interpretation remains same as explained for R users above. Ofcourse, the result is some as derived after using R. The data set used for Python is a cleaned version where missing values have been imputed, and categorical variables are converted into numeric. The modeling process remains same, as explained for R users above.</p>
<p><code>import numpy as np</code><br />
<code> from sklearn.decomposition import PCA</code><br />
<code> import pandas as pd</code><br />
<code> import matplotlib.pyplot as plt</code><br />
<code> from sklearn.preprocessing import scale</code><br />
<code> %matplotlib inline</code></p>
<p><code>#Load data set</code><br />
<code> data = pd.read_csv('Big_Mart_PCA.csv')</code></p>
<p><code>#convert it to numpy arrays</code><br />
<code> X=data.values</code></p>
<p><code>#Scaling the values</code><br />
<code> X = scale(X)</code></p>
<p><code>pca = PCA(n_components=44)</code></p>
<p><code>pca.fit(X)</code></p>
<p><code>#The amount of variance that each PC explains</code><br />
<code> var= pca.explained_variance_ratio_</code></p>
<p><code>#Cumulative Variance explains</code><br />
<code> var1=np.cumsum(np.round(pca.explained_variance_ratio_, decimals=4)*100)</code></p>
<p><code>print var1</code><br />
<code> [  10.37   17.68   23.92   29.7    34.7    39.28   43.67   46.53   49.27</code><br />
<code> 51.92   54.48   57.04   59.59   62.1    64.59   67.08   69.55   72.</code><br />
<code> 74.39   76.76   79.1    81.44   83.77   86.06   88.33   90.59   92.7</code><br />
<code> 94.76   96.78   98.44  100.01  100.01  100.01  100.01  100.01  100.01</code><br />
<code> 100.01  100.01  100.01  100.01  100.01  100.01  100.01  100.01]</code></p>
<p><code>plt.plot(var1</code>)</p>
<p><img class="size-full wp-image-24152 aligncenter" src="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/9-1.png" alt="9" width="376" height="251" srcset="https://www.analyticsvidhya.com/wp-content/uploads/2016/03/9-1.png 376w, https://www.analyticsvidhya.com/wp-content/uploads/2016/03/9-1-300x200.png 300w" sizes="(max-width: 376px) 100vw, 376px" /></p>
<p><code>#Looking at above plot I'm taking 30 variables</code><br />
<code> pca = PCA(n_components=30)</code><br />
<code> pca.fit(X)</code><br />
<code> X1=pca.fit_transform(X)</code></p>
<p><code>print X1</code></p>
<p>For more information on PCA in python, visit <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html" target="_blank" rel="nofollow">scikit learn documentation</a>.</p>
<p>&nbsp;</p>
<h2>Points to Remember</h2>
<ol>
<li>PCA is used to overcome features redundancy in a data set.</li>
<li>These features are low dimensional in nature.</li>
<li>These features a.k.a components are a resultant of normalized linear combination of original predictor variables.</li>
<li>These components aim to capture as much information as possible with high explained variance.</li>
<li>The first component has the highest variance followed by second, third and so on.</li>
<li>The components must be uncorrelated (remember orthogonal direction ? ). See above.</li>
<li>Normalizing data becomes extremely important when the predictors are measured in different units.</li>
<li>PCA works best on data set having 3 or higher dimensions. Because, with higher dimensions, it becomes increasingly difficult to make interpretations from the resultant cloud of data.</li>
<li>PCA is applied on a data set with numeric variables.</li>
<li>PCA is a tool which helps to produce better visualizations of high dimensional data.</li>
</ol>
<p>&nbsp;</p>
<h2>End Notes</h2>
<p style="text-align: justify;">This brings me to the end of this tutorial. Without delving deep into mathematics, I&#8217;ve tried to make you familiar with most important concepts required to use this technique. It&#8217;s simple but needs special attention while deciding the number of components.  Practically, we should strive to retain only first few k components</p>
<p style="text-align: justify;">The idea behind pca is to construct some principal components( Z &lt;&lt; Xp ) which satisfactorily explains most of the variability in the data, as well as relationship with the response variable.</p>
<p style="text-align: justify;">Did you like reading this article ? Did you understand this technique ? Do share your suggestions / opinions in the comments section below.</p>
<h3 style="text-align: justify;">You can test your skills and knowledge. Check out <a href="http://datahack.analyticsvidhya.com/contest/all" target="_blank" rel="nofollow">Live<b> Competitions</b></a> and compete with best Data Scientists from all over the world.</h3>

 
</body>
</html>