<base target="_blank"><html><head><title>selenium</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var topicEnd = "<br>";
  var bookid = "selenium"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>selenium</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br></div>
<pre><br><br>


<center><h2>Scraping with Selenium</h2></center>

<h2>How it works</h2>
Selenium is a web automation tool.

While not developed specifically for web scraping, Selenium does it pretty dang well.

Selenium literally “drives” your browser, so it can see anything you see when you right click and inspect element in Chrome or Firefox.

This vastly widens the universe of content that can be extracted from automation, but can be slow as all content must be rendered in the browser.  

There are headless (invisible browsers with no GUI) such as <a href="http://phantomjs.org/" target="_blank">phantomjs</a> that 
speed some of this up.  That said, I’ve found that Selenium works best for targeted extraction where the user knows exactly what they want.

<h2>Example</h2>
I set out to collect tickers for all mutual funds in the asset allocation fund type.  Fidelity provides a list of all these funds <a href="https://www.fidelity.com/fund-screener/evaluator.shtml#!&amp;ntf=N&amp;ft=BAL_all&amp;msrV=advanced&amp;sortBy=FUND_MST_MSTAR_CTGY_NM&amp;pgNo=1" target="_blank">here</a>.

1,586 funds as of today in 80 conveniently paginated URLs.  Each URL ends in <code>&amp;pgNo=5</code> to indicate you want page 5 (or whatever number between 1 and 80).

In my browser, when I hover my mouse over one of the fund names in the table, I see the 5 character ticker I’m looking for.

I also see the tickers directly on the webpage when I click the link to each fund.

<a href="https://fundresearch.fidelity.com/mutual-funds/summary/72201F433" target="_blank">Here</a> for example, where it says PSLDX in the top left.

However, if possible I’d like to scrape the tickers from the table rather than the individual fund pages.

This would mean 80 pages to scrape rather than 1,586.

<h2>Take 1: traditional http request</h2>
When possible, it makes sense to use the simple traditional methods.  So I first tried to extract these tickers with the popular <code>httr</code> R package

by making standard http requests.


<code>library(&#39;httr&#39;)
url &lt;- &#39;https://www.fidelity.com/fund-screener/evaluator.shtml#!&amp;ft=BAL_all&amp;ntf=N&amp;expand=%24FundType&amp;rsk=5&#39;
page &lt;- GET(url)</code>

Success…


<code>print(http_status(page))</code>


<code>## $category
## [1] &quot;success&quot;
## 
## $message
## [1] &quot;success: (200) OK&quot;</code>

But did our http request return the information we want?


<code>page_text &lt;- content(page, as=&#39;text&#39;)</code>

Nope – can’t find the tickers (one of them anyway). 


<code>grepl(&#39;GMMAX&#39;, page_text, ignore.case=T)</code>


<code>## [1] FALSE</code>

Nope – can’t even find the fund name that I see in the table from the webpage in my browser. 


<code>grepl(&#39;Aberdeen&#39;, page_text, ignore.case=T)</code>


<code>## [1] FALSE</code>

It appears that the content of interest is being generated dynamically with Javascript and Ajax on this webpage.

So the raw HTML of this page doesn’t help us much.

My plan B was to grab the url for each fund from the table, navigate to that fund’s page, and extract the ticker from there.

However these links weren’t in our http response.  I noticed that the URLs for each fund followed a simple consistent structure.  

<a href="https://fundresearch.fidelity.com/mutual-funds/summary/72201F433" target="_blank">https://fundresearch.fidelity.com/mutual-funds/summary/72201F433</a> for example.

I thought maybe I could find 72201F433 which looks like some sort of fund ID in a list with all fund IDs in the http response.

No dice.  Plan C – Selenium.

<h2>Take 2: Selenium</h2>
I used the <a href="http://www.github.com/ropensci/RSelenium/" target="_blank">RSelenium</a> R package for this mini project.  There are also Selenium bindings for Python, Java, C#, Javascript and Ruby which make replicating this process in your programming language of choice relatively straightforward.

<strong>Step 1: Fire up Selenium</strong>


<code>library(&#39;RSelenium&#39;)
checkForServer() # search for and download Selenium Server java binary.  Only need to run once.
startServer() # run Selenium Server binary
remDr &lt;- remoteDriver(browserName=&quot;firefox&quot;, port=4444) # instantiate remote driver to connect to Selenium Server
remDr$open(silent=T) # open web browser</code>

<strong>Step 2: Start scraping</strong>

To figure which DOM elements I wanted Selenium extract, I used the Chrome Developer Tools which can be invoked by right clicking a fund in the table and selecting Inspect Element.  The HTML displayed here contains exactly what we want, what we didn’t see with our http request.

Since I want to grab all the funds at once, I tell Selenium to select the whole table.  Going a few levels up from the individual cell in the table I’ve selected, I see that <code>&lt;tbody&gt;</code> is the HTML tag that contains the entire table, so I tell Selenium to find this element.  I use the nifty <code>highlightElement</code> function to confirm graphically in the browser that this is what I think it is.

Then it’s business as usual.  I parse the string output from Selenium into an HTML tree and use XPath to parse the table for just the fund name and ticker.


<code>library(&#39;XML&#39;)
master &lt;- c()
n &lt;- 5 # number of pages to scrape.  80 pages in total.  I just scraped 5 pages for this example.
for(i in 1:n) {
  site &lt;- paste0(&quot;https://www.fidelity.com/fund-screener/evaluator.shtml#!&amp;ntf=N&amp;ft=BAL_all&amp;msrV=advanced&amp;sortBy=FUND_MST_MSTAR_CTGY_NM&amp;pgNo=&quot;,i) # create URL for each page to scrape
  remDr$navigate(site) # navigates to webpage
  
  elem &lt;- remDr$findElement(using=&quot;id&quot;, value=&quot;tbody&quot;) # get big table in text string
  elem$highlightElement() # just for interactive use in browser.  not necessary.
  elemtxt &lt;- elem$getElementAttribute(&quot;outerHTML&quot;)[[1]] # gets us the HTML
  elemxml &lt;- htmlTreeParse(elemtxt, useInternalNodes=T) # parse string into HTML tree to allow for querying with XPath
  fundList &lt;- unlist(xpathApply(elemxml, &#39;//input[@title]&#39;, xmlGetAttr, &#39;title&#39;)) # parses out just the fund name and ticker using XPath
  master &lt;- c(master, fundList) # append fund lists from each page together
}

head(master)</code>


<code>## [1] &quot;FidelityAA Global Balanced Fund (FGBLX)&quot;                    
## [2] &quot;FidelityAA Global Strategies Fund (FDYSX)&quot;                  
## [3] &quot;Fidelity FreedomA 2055 Fund (FDEEX)&quot;                       
## [4] &quot;Aberdeen Dynamic Allocation Fund Class A (GMMAX)&quot;           
## [5] &quot;Aberdeen Dynamic Allocation Fund Class C (GMMCX)&quot;           
## [6] &quot;AllianceBernstein Real Asset Strategy Advisor Class (AMTYX)&quot;</code>

<strong>Step 3: Extract ticker</strong>

Nothing fancy here – just separating the ticker from the fund name.


<code>master2 &lt;- data.frame(sapply(master, function(x) substr(x, nchar(x)-5, nchar(x)-1)))
master2$name &lt;- sapply(master, function(x) substr(x, 0, nchar(x)-8))
names(master2) &lt;- c(&#39;ticker&#39;, &#39;name&#39;)

head(master2)</code>


<code>##   ticker                                                name
## 1  FGBLX                     FidelityAA Global Balanced Fund
## 2  FDYSX                   FidelityAA Global Strategies Fund
## 3  FDEEX                        Fidelity FreedomAA 2055 Fund
## 4  GMMAX            Aberdeen Dynamic Allocation Fund Class A
## 5  GMMCX            Aberdeen Dynamic Allocation Fund Class C
## 6  AMTYX AllianceBernstein Real Asset Strategy Advisor Class</code>

<h2>What else can Selenium do?</h2>
My little example makes use of the simple functionality provided by Selenium for web scraping – rendering HTML that is dynamically generated with Javascript or Ajax.  Since Selenium is actually a web automation tool, one can be much more sophisticated by using it to automate a human navigating a webpage with mouse clicks and writing and submitting forms.  This can be a huge time saver for researchers that rely on front-end interfaces on the web to extract data in chunks.

<a href="http://thiagomarzagao.com/2013/11/12/webscraping-with-selenium-part-1/" target="_blank">Here’s</a> a basic example using Python.

<a href="http://cran.r-project.org/web/packages/RSelenium/vignettes/RSelenium-basics.html" target="_blank">Here’s</a> a basic example using R.

<h2>Getting setup</h2>
On the several computers I use, I’ve found setup ranging from seamless to frustrating.

The most frustrating issue I encountered while setting up on my Mac was this error message:


<code>&gt; remDr$open()

[1] &quot;Connecting to remote server&quot;
Error:    Summary: UnknownError
 	 Detail: An unknown server-side error occurred while processing the command.
 	 class: java.lang.IllegalStateException</code>

I was able to resolve it by killing all processes running on port 4444 and trying again.

At the terminal:


<code>lsof -i :4444</code>

Kill PIDs of any processes listed.  For example:


<code>kill 30681</code>

<h2>How to Use GeckoDriver in Selenium</h2> 
<div id="GeckoDrivertoc" class="toc"><a href="#GeckoDrivertopic-0" target="_self">What is Gecko?</a><br><a href="#GeckoDrivertopic-1" target="_self">What is a Web Browser Engine?</a><br><a href="#GeckoDrivertopic-2" target="_self">What is GeckoDriver?</a><br><a href="#GeckoDrivertopic-3" target="_self">Why does Selenium need GeckoDriver?</a><br><a href="#GeckoDrivertopic-4" target="_self">How to use GeckoDriver in Selenium Project?</a><br><a href="#GeckoDrivertopic-5" target="_self">GeckoDriver and TestNG</a><br><a href="#GeckoDrivertopic-6" target="_self">Steps to Add a Path in System’s PATH Environmental Variable</a><br><a href="#GeckoDrivertopic-7" target="_self">Issues without Gecko Driver</a><br><a href="#GeckoDrivertopic-8" target="_self">Additional Information about GeckoDriver</a><br><a href="#GeckoDrivertopic-9" target="_self"><b>Conclusion</b></a><br></div></center><br><br>

<h3 id="GeckoDrivertopic-0">What is Gecko?</h3>

Gecko is a web browser engine. 
There are several applications that require Gecko. 
Specifically, the applications which are developed by Mozilla Foundation and the Mozilla Corporation. 
Gecko is also a need for many open source software projects. 
Gecko is written in C++ and JavaScript.

Latest versions are written in Rust also. 
Gecko is a free and an open source web browser engine.

<h3 id="GeckoDrivertopic-1">What is a Web Browser Engine?</h3>

Web Browser Engine is nothing but a software program. 
The main function of this program is collecting the content (like HTML, XML, images) &amp; formatting the information (like CSS) and display this formatted content on the screen. 
Web Browser Engine is also called as Layout Engine or Rendering Engine.

Applications like Web browsers, email clients, e-book readers, on-line help systems etc. 
need displaying of web content. 
And to display the web content, the web browser engine is required and it is a part of all these applications. 
There are different web browser engines for each web browsers.

<b>The following table shows web browsers and what web browser engines, they are using.</b>

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/11/Table-of-Browsers-and-Web-browser-engines.jpg">

<b>Gecko runs on the following operating system without emulation:</b>

Windows
Mac OS
Linux
BSD
Unix

It cannot run on a Symbian OS.

<h3 id="GeckoDrivertopic-2">What is GeckoDriver?</h3>

GeckoDriver is a connecting link to the Firefox browser for your <a href="https://www.softwaretestinghelp.com/selenium-tutorial-1/" target="_blank" rel="noopener">scripts in Selenium</a>. 
GeckoDriver is a proxy that helps to communicate with the Gecko-based browsers (e.g. 
Firefox), for which it provides HTTP API.

<h3 id="GeckoDrivertopic-3">Why does Selenium need GeckoDriver?</h3>

Firefox (version 47 and above) has done some changes to it and for some security reasons, it doesn’t allow any third-party driver to directly interact with the browsers. 
Hence we cannot use Selenium2 with the latest versions of Firefox. 
So we need Selenium3.

Selenium3 has Marionette Driver. 
Selenium3 can directly interact with the Firefox browser using a proxy, which is nothing but the GeckoDriver.

<h3 id="GeckoDrivertopic-4">How to use GeckoDriver in Selenium Project?</h3>
Let us consider that you have the latest version of <a href="https://www.softwaretestinghelp.com/selenium-webdriver-selenium-tutorial-8/" target="_blank" rel="noopener">Selenium WebDriver</a> and the Firefox browser.
Then download the GeckoDriver from <a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">here</a>. 
Later, choose the version which is suitable for your computer.

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Gecko-Download.jpg">

<b>Extract files</b> from the compressed folder

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Gecko-Extract-All.jpg">

Add the references of Selenium3 libs in your project through- <b>Right-click on the project =&gt; Build Path =&gt; Configure Build Path =&gt; Libraries =&gt; Add External Jars.</b>

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Add-External-Jars.jpg">

Select <b>Lib folder =&gt; Click Clt + A =&gt; Click Open</b>.

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Select-Library.jpg">

After you <b>click open</b>, you will see the following window:

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Result.jpg">

Then click OK.
Now let us write our code and use the system property to specify the GeckoDriver Path.
<b>Add the below line in your code: </b>
<pre>System.setProperty(“webdriver.gecko.driver”,”Path of the GeckoDriver file”).</pre>

<b>** [ </b>How to copy the address of the extracted file. 
– (Press ’Shift’ from the keyboard and right-click the file, you will get an option. 
Then ‘Copy address of the file’.)]

<b>** [</b>In this copy-pasted path, make sure that there is a double backslash otherwise code will have a syntax error.]

Let us take an example

<b>Example</b>

Here is just a simple script, where we open the Google web page in a Firefox browser and verify the title of the web page.

<b>Code1:</b>

<pre>import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;
publicclass First_Class {

publicstaticvoid main(String[] args) {

System.setProperty("webdriver.gecko.driver","E:\\GekoDriver\\geckodriver-v0.15.0-win64\\geckodriver.exe");

WebDriver driver=new FirefoxDriver();
driver.get("https://www.google.com/");
driver.manage().window().maximize();
String appTitle=driver.getTitle();
String expTitle="Google";
if (appTitle.equals (expTitle)){
System.out.println("Verification Successfull");
}
else{
System.out.println("Verification Failed");

}
driver.close();
System.exit(0);
}
}</pre>

<b>Understanding the Code</b>

<b>#1) import org.openqa.selenium.WebDriver-</b> Here we are importing all the references to the WebDriver interface. 
Later on, this WebDriver interface is required to instantiate a new browser.

<b>#2) import org.openqa.selenium.firefox.FirefoxDriver-</b> Here we are importing all the references to FirefoxDriver class.

<b>#3)</b> <b>setProperty(String key, String value)-</b> Here we are setting the system property by providing the name of the property which is called as Key, and its path which is called as Value.

<b>Key</b>-Name of the system property i.e. 
<em>webdriver.gecko.driver</em>.

<b>Value</b>– Address of Gecko Driver’s exe file.

<b>#4)</b> <b>WebDriver driver=new FirefoxDriver() –</b> In this line of code we are creating the reference variable ‘driver’ of the WebDriver and this reference variable is initiated using FirefoxDriver class. 
A Firefox profile without extensions and plugins will be launched with a Firefox instance.

<b>#5)</b> <b>get(“URL”)-</b> Using this Get method we can open the specified URL in the browser. 
This Get method is called using the WebDriver’s reference variable i.e. 
driver. 
The string is passed to the Get method, which means our application URL is passed into this Get method.

<b>#6) manage().window().maximize()-</b> Using this line of code we are maximizing the browser window. 
As soon as the browser opens the specified URL, it is maximized using this line.

<b>#7) getTitle()–</b> Using this line of code, we will be able to find the title of the web page. 
This method is also called using the WebDriver’s reference variable ‘driver’. 
We are saving this title in the String variable ‘appTitle’.

<b>#8) Comparison–</b> Here we are comparing the appTitle (which will get through <em>driver.getTitle()</em> method) and the <em>expTitle</em> (which is “Google”) using the If statement. 
It is just a simple If-else statement. 
When the “If” condition is satisfied, we are printing the message “Verification Successful” otherwise we are the printing message “Verification Failed”.

<pre><b>if</b> 
(appTitle.equals (expTitle))
{
System.out.println ("Verification Successful");
}
<b>else</b>
{
System.out.println("Verification Failed");
}</pre>

<b>#9)</b> <b>driver.close()–</b> This line of code closes the browser. 
This line closes only the current window.

<b>#10)</b> <b>System.exit(0)–</b> This line of code method is used to terminate running Java Virtual Machine. 
So it is recommended to close all the open windows or files before this line.

<h3 id="GeckoDrivertopic-5">GeckoDriver and TestNG</h3>

There is not much difference in the code, but here I am adding a code just for your reference.

<b>EXAMPLE: </b>

<b>Let’s move to the example. 
Our example is to open the Google.com web page, get its title and print it.</b>

<b>Code2:</b>

<pre>import org.testng.annotations.Test;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.firefox.FirefoxDriver;

publicclass TstNG {

@Test
publicvoid f() {
System.setProperty("webdriver.gecko.driver","E:\\GekoDriver\\geckodriver-v0.15.0-win64\\geckodriver.exe");
WebDriver driver=new FirefoxDriver();
driver.get("https://www.google.com/");
driver.manage().window().maximize();
String appurl=driver.getTitle();
System.out.println(appurl);
driver.close();
// System.exit(0);
}
}</pre>

<b>Points to remember while writing TestNG code:</b>

<b>#1)</b> Use the System.setProperty(String key, String value) method inside the function f() same as the previous example. 
In that example, we wrote it in the main function. 
However, in TestNG, there are no main () functions. 
If you write it outside the function you will get a syntax error.

<b>#2)</b> The second most important thing to remember is System.exit(0). 
There is no need to add this line of code to your TestNG script. 
There is one reason for that which is – after running the TestNG script, an output folder is generated where you can view the generated reports and results, if you add System.exit(0) in your script this folder(output folder) will not get generated and you will not be able to view the reports.

<h3 id="GeckoDrivertopic-6">Steps to Add a Path in System’s PATH Environmental Variable</h3>
On the Windows system right-click on My Computer or This PC.
Select Properties.
Select Advanced system settings.
Click on the Environment Variables button.
From System Variables select PATH.
Click on the Edit button.
Click New button
Paste the path of the GeckoDriver file.
Click OK.
<h3 id="GeckoDrivertopic-7">Issues without Gecko Driver</h3>

<b> You might face some issues like the ones given below.</b>

<b>#1)</b> If you are using an old version of Firefox and Selenium3, then you will get the following exception:

Exception in thread “main” <u>java.lang.IllegalStateException</u>

<b>#2)</b> If you are using the latest version of Firefox and an old version of Selenium, then you will get the following exception:

<em>org.openqa.selenium.firefox.NotConnectedException</em>: Unable to connect to host 127.0.0.1 on port 7055 after 45000ms

<b>#3)</b> If you are using the latest version of Firefox and WebDriver, but not using GeckoDriver, you will get the following exception:

Exception in thread “main” <u>java.lang.IllegalStateException</u>: The path to the driver executable must be set by the webdriver.gecko.driver system property; for more information, see <a href="https://github.com/mozilla/geckodriver" target="_blank" rel="noopener">here</a>. 
The latest version can be downloaded from <a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">here</a>.

<h3 id="GeckoDrivertopic-8">Additional Information about GeckoDriver</h3>

As we know GeckoDriver is a proxy that helps to communicate with Gecko-based browsers (e.g. 
Firefox), for which it provides HTTP API.

This HTTP API can be understood using the WebDriver protocol. 
There are some nodes in the WebDriver protocol which include Local end, Remote end, Intermediary node, and Endpoint node. 
Communication between these nodes is described in the WebDriver protocol.

The Local end is the client-side of the WebDriver protocol. 
The remote end means server-side of the WebDriver protocol. 
The Intermediary node performs the role of a proxy. 
Endpoint node is put into effect by a user agent or a similar program.

<img src="https://www.softwaretestinghelp.com/wp-content/qa/uploads/2017/12/Flowchart.jpg">

Commands and responses sent by the WebDriver to GeckoDriver are translated to Marionette Protocol and then transferred to Marionette Driver by GeckoDriver. 
So we conclude by saying that GeckoDriver is acting as a proxy between these two WebDriver and Marionette.

Marionette is divided into 2 parts, which are the server part and the client part. 
Commands which are sent by the client part are executed by the server part.

This command execution work is performed inside the browser. 
Marionette is nothing but a combination of a gecko component (which is a Marionette server) and an outside component (which is called as Marionette Client). 
GeckoDriver is written in Rust programming language.

<h3 id="GeckoDrivertopic-9"><b>Conclusion</b></h3>

GeckoDriver is an intermediate factor between your Selenium scripts and Gecko-based browsers like Firefox.

GeckoDriver is a proxy to communicate with Gecko-based browsers (<b>E.g. 
</b>Firefox). 
Firefox (version47 and above) has done some changes, which has led to the prevention of supporting third-party drivers to interact directly with the browsers.

This is the primary reason for which we need to use the GeckoDriver. 
The easiest way to use GeckoDriver in your script is to implement the use of <em>System.set property. 
[System.setProperty(“webdriver.gecko.driver”, ”Path of the Gecko Driver file”)].


<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script></em></pre></body>
