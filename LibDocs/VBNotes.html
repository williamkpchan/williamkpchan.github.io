<base target="_blank"><html><head><title>Visual Basic Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Visual Basic Notes"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Visual Basic Notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://www.motobit.com/tips/" class="whitebut ">free vbs code</a>

<a href="http://vbsedit.com/" class="whitebut ">vbsedit</a>

<a href="https://en.wikibooks.org/wiki/Visual_Basic/Getting_Started">Visual Basic Getting Started</a>
. <a href="https://www.vbtutor.net/vbtutor.html">vbtutor</a>
. <a href="http://www.freevbcode.com/listcode.asp?Category=5">vbcode</a>

</div>
<pre>
<br>
<br>
<h2>VB Scraper</h2>
<a href="http://www.wiseowl.co.uk/blog/s393/scraping-websites-vba.htm">scrape from webpages using VBA</a>
<a href="http://stackoverflow.com/questions/27066963/scraping-data-from-website-using-vba">Scraping website using vba</a>

<h2>Visual Basic sample</h2>
counter = 2
Do 
counter=counter+1 
MsgBox("Hello World!" & cstr(counter))
Loop until counter>10

save as test.vbs and click to run

not work:
Beep()
Threading.Thread.Sleep(250)
For Each P As Process In System.Diagnostics.Process.GetProcessesByName("cmd")
      P.Kill()
Next

<h2>System Beep in Batch/VB Script</h2>
WScript.StdOut.Write Chr(7)

<h2>VBS Play Sound</h2>
play MP3 files in VBScript using Windows Media Player scripting object, WMPlayer.OCX

Dim oPlayer
Set oPlayer = CreateObject("WMPlayer.OCX")
oPlayer.URL = "C:\welcome.mp3"  ' Play audio
oPlayer.controls.play 
While oPlayer.playState <> 1 ' 1 = Stopped
  WScript.Sleep 100
Wend ' Release the audio file
oPlayer.close


<h2>VBS script to play sound repeatedly</h2>
strSoundFile = "C:\Temp\test.wav"
Set objShell = CreateObject("Wscript.Shell")
strCommand = "sndrec32 /play /close " & chr(34) & strSoundFile & chr(34)
objShell.Run strCommand, 0, True
Wscript.Sleep 1000

<h2>VBScript Tutorial</h2>
<a href="https://www.tutorialspoint.com/vbscript/">VBScript Tutorial</a>
<br>

<a href="http://www.runoob.com/try/try.php?filename=vbdemo_foreach">VBScript For Each</a>
<br>
<a href="http://www.runoob.com/vbscript/vbscript-examples.html">VBScript 实例</a>
<br>
<h2>to Run VBScript on Windows</h2>

cscript hello.vbs
Execute the VBS script by double-clicking the file

<h2>JavaScript 和 VBScript 的比較</h2>

JavaScript 使用「+」來並排字串，而 VBScript 使用「&」來並排字串。
JavaScript 程式碼會分辨大小寫，VBScript 程式碼則不分大小寫。
一般高階程式碼（如 C/C++ 等），都會分辨大小寫，因此 VBScript 不區分大小寫，是一個主要的缺失。

JavaScript 使用「//」或「/* ... */」來加入註解，而 VBScript 則是使用「'」來加入註解。
一般而言，JavaScript 的每一列敘述後面必須加上分號，VBScript 程式碼則不需要。
更明確地說，JavaScript 若一列只包含一項敘述，則尾端之分號可以省略。
當然如果要將數個 JavaScript 的敘述寫在同一列，就需要在每一個敘述的尾巴加上分號（但最後一個敘述仍然可以省略分號）。
JavaScript 是自由格式（Free Format），因此可以把多個敘述放在同一列，或是把同一列敘述拆放在兩列。
但是 VBScript 則不是自由格式，因此通常是每個敘述放在一列，若要將多個敘述放在同一列，必須使用「:」來分開每一個敘述；
若要將一個敘述拆成多列，必須將「_」至於每一列尾端。
javaScript/example/jsVbsComp02.htm）
JavaScript 的語法接近 C 或 C++ 程式語言，VBScript 則接近於 Basic 程式語言。
JavaScript 適用的瀏覽器包含 IE、Firefox、Opera、Netscape 等，但 VBScript 則只能用在 IE 瀏覽器。
因此若為了跨瀏覽器平台，選用 JavaScript 是正確的抉擇。
JavaScript 和 VBScript 兩者都適用於 ASP（Active Server Pages） 和 WSH（Window Scripting Hosts）。


<h2>VBScript intro and samples</h2>
Windows操作系统
VBScript可以被用来自动地完成重复性的Windows操作系统任务。
在Windows操作系统中，VBScript可以在Windows Script Host的范围内运行。
Windows操作系统可以自动辨认和执行*.VBS和*.WSF两种文件格式，此外Internet Explorer可以执行HTA和CHM文件格式。
VBS和WSF文件完全是文字式的，它们只能通过少数几种对话窗口与用户通讯。
HTA和CHM文件使用HTML格式，它们的程序码可以像HTML一样被编辑和检查。
在WSF、HTA和CHM文件中VBScript和JavaScript的程序码可以任意混合。
HTA文件实际上是加有VBS、JavaScript成分的HTML文件。
CHM文件是一种在线帮助，用户可以使用专门的编辑程序将HTML程序编辑为CHM。

Windows 操作系统也提供一些 VBScript 脚本来进行高级管理功能，例如管理 Windows 激活密钥的 slmgr.vbs（Windows Server License Manager Script）。

网页浏览器（客户端的VBS）
网页中的VBS可以用来控制客户端的网页浏览器（以浏览器执行VBS程序）。
VBS与JavaScript在这一方面是竞争者，它们可以用来实现动态HTML，甚至可以将整个程序结合到网页中来。

至今为止VBS在客户方面未能占优势，因为它只获得Microsoft Internet Explorer的支持（Mozilla Suite可以透过安装一个包来支持VBS），并且IE11起已不再支持VBScript[1]。
而JavaScript则受到所有网页浏览器的支持。
在Internet Explorer中VBS和JavaScript使用同样的权限，它们只能有限地使用Windows操作系统中的对象。

网页服务器（服务器方面的VBS）
在网页服务器方面VBS是微软的Active Server Pages的一部分，它与JavaServer Pages和PHP是竞争对手。
在这里VBS的程序码直接嵌入到HTML页内，这样的网页以ASP结尾。
网页服务器Internet信息服务执行ASP页内的程序部分并将其结果转化为HTML传递给网页浏览器供用户使用。
这样服务器可以进行数据库闻讯并将其结果放到HTML网页中。

示范
Hello World
最简单的例子：

MsgBox "Hello World"
以.vbs文件保存。
再使用cscript.exe或wscript.exe执行。

一个更复杂的例子中，示出了使用MsgBox作为函数（返回一个结果），并使用了三个参数，其中第二个参数使用的是常量。

Dim x
' These three produce the same result. However, the use of constants as in the third line 
' is considered best practice.
x = MsgBox("Hello World:Text",1+64+4096,"Hello World:Title")
x = MsgBox("Hello World:Text",4161,"Hello World:Title")
x = MsgBox("Hello World:Text", vbOKCancel+vbInformation+vbSystemModal, _
           "Hello World:Title")

' Presents the number corresponding to the button pressed. Different constants will produce 
' different behaviours. For example, vbOKCancel specifies two buttons in the dialogue box, 
' whereas vbYesNoCancel specifies three.
x = MsgBox("Hello World:Text", vbYesNoCancel+vbInformation,"Hello World:Title")
MsgBox "The result is " & x

终止任务
VBScript能访问Windows管理规范 (WMI)，就像Windows任务管理器。
以下的代码执行时将会终止（“杀掉”）任何关于notepad.exe的进程。

'Terminate all processes involving the name <strProcessToKill>
Option Explicit
Dim strComputer, strProcessToKill, objWMIService, colProcess, objProcess

strComputer = "."
strProcessToKill = "notepad.exe"
Set objWMIService = GetObject("winmgmts:" _ 
   & "{impersonationLevel=impersonate}!\\" _ 
   & strComputer _ 
   & "\root\cimv2") 
Set colProcess = objWMIService.ExecQuery _
   ("Select * from Win32_Process Where Name = '" & strProcessToKill & "'")
For Each objProcess in colProcess
   MsgBox "... terminating " & objProcess.Name
   objProcess.Terminate()
Next
使用Option Explicit并不是必须的，但它被认为是VBScript的最佳实践。

创建具有唯一的名称的十个文件
这个实例显示如何创建文件并向它添加内容。
它还演示了字符串连接。

For i = 1 to 10
	createFile( i )
Next

Public sub createFile(a)
	Dim fso,myFile
	filePath = "C:\file_name" & a & ".txt"
	Set fso=CreateObject("Scripting.FileSystemObject")
	Set MyFile= fso.CreateTextFile( filePath)
	MyFile.WriteLine("This is a separate file")
	MyFile.close

End Sub

发送按键
SendKeys方法模拟一个或多个按键到活动窗口（模拟在键盘上输入）。
 在该示例中，脚本发送字符串“Hello World！”3次，每次暂停2秒（2000毫秒）。
SendKeys宏可能会在某些程序中失效，因为一些软件（如在安装时输入许可证密钥）将检查是否是真正的按键，而不是虚拟的。

set shl = createobject("wscript.shell")
shl.sendkeys "Hello World!"
wscript.sleep 2000
shl.sendkeys "Hello World!"
wscript.sleep 2000
shl.sendkeys "Hello World!"
wscript.sleep 2000
执行期间，“Hello World!”将显示在命令提示符。

Windows文件操作
对象FileSystemObject执行一些文件操作（例如测试一个文件是否存在），并且还创建一个文本文件（一个TextStream对象）。

myfilename = "C:\Wikipedia - VBScript - Example - Hello World.txt"
MakeHelloWorldFile myfilename

Sub MakeHelloWorldFile (FileName)
'Create a new file in C: drive or overwrite existing file
   Set FSO = CreateObject("Scripting.FileSystemObject")
   If FSO.FileExists(FileName) Then 
      Answer = MsgBox ("File " & FileName & " exists ... OK to overwrite?", vbOKCancel)
      'If button selected is not OK, then quit now
      'vbOK is a language constant
      If Answer <> vbOK Then Exit Sub
   Else
      'Confirm OK to create
      Answer = MsgBox ("File " & FileName & " ... OK to create?", vbOKCancel)
      If Answer <> vbOK Then Exit Sub
   End If
   'Create new file (or replace an existing file)
   Set FileObject = FSO.CreateTextFile (FileName)
   FileObject.WriteLine "Time ... " & Now()
   FileObject.WriteLine "Hello World"
   FileObject.Close()
   MsgBox "File " & FileName & " ... updated."
End Sub
MakeHelloWorldFile将会在按下按钮后于C:\ 驱动器根目录创建（若已经存在则更新）一个小文本文件。

Excel对象操作
Option Explicit '所有变量必须显式声明

Dim app,workbook,sheet
Dim row,col

Set app = WScript.CreateObject("Excel.Application")
app.Visible = True
Set workbook = app.WorkBooks.Add

Set sheet = workbook.Worksheets(1)
'10x10 random value
For row = 1 To 10
  For col = 1 To 10
    sheet.Cells(row,col).Value = CInt(Int((100 * Rnd()) + 1))
  Next
Next

Set sheet = workbook.Worksheets(2)
'10x10 random value
sheet.Range("A1:J10").Formula = "=Int(Rand() * 100 + 1)"

语言
VBScript主要的优点有：
由于VBScript由操作系统，而不是由网页浏览器解释，它的文件比较小。

易学。
在所有2000 / 98SE以后的Windows版本都可直接使用。
可以使用其它程序和可使用的对象（尤其是Microsoft Office）。

缺点有：
现在VBS无法作为电子邮件的附件了。
Microsoft Outlook拒绝接受VBS为附件，收信人无法直接使用VBS附件。

VBS的各种编辑器不受欢迎。
操作系统没有任何特别的保护设施。
VBS程序与其它JS、EXE、BAT或CMD程序一样对待。
操作系统没有监察恶意功能的能力。

<br>
<a href="https://www.robvanderwoude.com/vbstech.php">VBScript Scripting Techniques</a>
<br>

<h2>set delay in vbscript</h2>
<a href="https://stackoverflow.com/questions/1729075/how-to-set-delay-in-vbscript">set delay in vbscript</a>
<br>
WScript.Sleep 1000
MsgBox "TEST"

Note, the number is in Milliseconds, so 1000 is 1 second.


<h2>check battery</h2>
set oLocator = CreateObject("WbemScripting.SWbemLocator")
set oServices = oLocator.ConnectServer(".","root\wmi")
set oResults = oServices.ExecQuery("select * from batteryfullchargedcapacity")
for each oResult in oResults
   iFull = oResult.FullChargedCapacity
next

while (1)
  set oResults = oServices.ExecQuery("select * from batterystatus")
  for each oResult in oResults
    iRemaining = oResult.RemainingCapacity
    bCharging = oResult.Charging
  next
  iPercent = ((iRemaining / iFull) * 100) mod 100
  if bCharging and (iPercent > 94) Then msgbox "Battery is at " & iPercent & "%",vbInformation, "Battery monitor"
  if Not(bCharging) and (iPercent < 30) Then msgbox "Chr(7)Battery is at " & iPercent & "%",vbInformation, "Battery monitor"
  wscript.sleep 300000 ' 5 minutes
wend

<h2>bell character</h2>
Chr(7)


<h2>MsgBox function</h2>
<a href="https://docs.microsoft.com/en-us/office/vba/language/reference/user-interface-help/msgbox-function">MsgBox function</a>
<br>
Dim Msg, Style, Title, Help, Ctxt, Response, MyString
Msg = "Do you want to continue ?"    ' Define message.
Style = vbYesNo + vbCritical + vbDefaultButton2    ' Define buttons.
Title = "MsgBox Demonstration"    ' Define title.
Help = "DEMO.HLP"    ' Define Help file.
Ctxt = 1000    ' Define topic context. 

' Display message.
Response = MsgBox(Msg, Style, Title, Help, Ctxt)
If Response = vbYes Then    ' User chose Yes.
    MyString = "Yes"    ' Perform some action.
Else    ' User chose No.
    MyString = "No"    ' Perform some action.
End If

<h2>Visual Basic Functions</h2>

<a href="https://docs.microsoft.com/en-us/office/vba/language/reference/functions-visual-basic-for-applications">VB Functions</a><br>

Conversion functions
Asc, Chr, CVErr, Format, Hex, Oct, Str, Val

Math functions
Abs, Atn, Cos, Derived math, Exp, Int, Fix, Log, Rnd, Sgn, Sin, Sqr, Tan

Other functions
Array, CallByName, Choose, Command, CreateObject, CurDir, Date, DateAdd, DateDiff, DatePart, DateSerial, DateValue, Day, DDB, Dir, DoEvents, Environ, EOF, Error, FileAttr, FileDateTime, FileLen, Filter, FormatCurrency, FormatDateTime, FormatNumber, FormatPercent, FreeFile, FV, GetAllSettings, GetAttr, GetObject, GetSetting, Hour, IIf, IMEStatus, Input, InputBox, InStr, InStrRev, IPmt, IRR, IsArray, IsDate, IsEmpty, IsError, IsMissing, IsNull, IsNumeric, IsObject, Join, LBound, LCase, Left, Len, Loc, LOF, LTrim, RTrim, and Trim, MacID, MacScript, Mid, Minute, MIRR, Month, MonthName, MsgBox, Now, NPer, NPV, Partition, Pmt, PPmt, PV, QBColor, Rate, Replace, RGB, Right, Round, Second, Seek, Shell, SLN, Space, Spc, Split, StrComp, StrConv, String, StrReverse, Switch, SYD, Tab, Time, Timer, TimeSerial, TimeValue, TypeName, UBound, UCase, VarType, Weekday, WeekdayName, Year

<br>
<h2> Sample VBScript Programs </h2> 
Getting started:
Input string from a user and echo back: <a href="http://courses.washington.edu/css341/zander/Code/simple.vbs"> simple.vbs</a>
Simple html file: <a href="http://courses.washington.edu/css341/zander/Code/simplehtml.html"> simplehtml.html</a>
Get 3 numbers from a user and find the largest: <a href="http://courses.washington.edu/css341/zander/Code/largestNum.vbs"> largestNum.vbs</a>
Put largestNum program in an html file: <a href="http://courses.washington.edu/css341/zander/Code/largestNum.html"> largestNum.html</a>
Put largestNum program in an html file using a table: <a href="http://courses.washington.edu/css341/zander/Code/largestNumTable.html"> largestNumTable.html</a>

If you ever find that you have created an infinite loop (so your script
  keeps running and running and running ...), use ctrl-alt-delete and open
  the Task Manager. Under the "Processes" tab, end the "wscript" process.

Loop examples:
Using mod and division operators in a zero-terminated loop: <a href="http://courses.washington.edu/css341/zander/Code/digits.vbs"> digits.vbs</a>
Using mod and division operators in a loop terminated by string "done": <a href="http://courses.washington.edu/css341/zander/Code/digits2.vbs"> digits2.vbs</a>
Read in numbers until a negative number is found; determine the average: <a href="http://courses.washington.edu/css341/zander/Code/avg.vbs"> avg.vbs</a>
Start with $1, double money everyday until $1,000,000 (practice prob 4): <a href="http://courses.washington.edu/css341/zander/Code/million.vbs"> million.vbs</a>
Find the largest number inputted by a user (practice prob 6): <a href="http://courses.washington.edu/css341/zander/Code/findLarge.vbs"> findLarge.vbs</a>
Display a square of asterisks of a given size (practice prob 9): <a href="http://courses.washington.edu/css341/zander/Code/prob9.vbs"> prob9.vbs</a>

Subroutine/Function examples:
Find the largest number inputted by a user (practice prob 6), without subroutines: <a href="http://courses.washington.edu/css341/zander/Code/findLarge.vbs"> findLarge.vbs</a>
Find the largest number inputted by a user (practice prob 6), using subroutines: <a href="http://courses.washington.edu/css341/zander/Code/findLargeWithSubs.vbs"> findLargeWithSubs.vbs</a>
Sort three numbers, without subroutines: <a href="http://courses.washington.edu/css341/zander/Code/sortThreeNums.vbs"> sortThreeNums.vbs</a>
Sort three numbers, using subroutines: <a href="http://courses.washington.edu/css341/zander/Code/sortThreeNumsWithSubs.vbs"> sortThreeNumsWithSubs.vbs</a>
Demonstrate the difference between ByVal and ByRef: <a href="http://courses.washington.edu/css341/zander/Code/byValbyRef.vbs"> byValbyRef.vbs</a>

Opening files -- MS Excel, text files, and Word doc:
Open a new excel spreadsheet and enter and add two numbers: <a href="http://courses.washington.edu/css341/zander/Code/openNewExcel.vbs"> openNewExcel.vbs</a> 
Open an existing excel spreadsheet: <a href="http://courses.washington.edu/css341/zander/Code/openOldExcel.vbs"> openOldExcel.vbs</a>
Open an existing excel spreadsheet and loop through cells: <a href="http://courses.washington.edu/css341/zander/Code/loopCells.vbs"> loopCells.vbs</a>
Open an existing text file and loop through lines: <a href="http://courses.washington.edu/css341/zander/Code/openText.vbs"> openText.vbs</a>
Open an existing Word doc search for a given string: <a href="http://courses.washington.edu/css341/zander/Code/searchWord.vbs"> searchWord.vbs</a>
Open an existing Powerpoint document and display text of each slide: <a href="http://courses.washington.edu/css341/zander/Code/openPpt.vbs"> openPpt.vbs</a>
Open an existing Powerpoint document and put text of each slide into a word document: <a href="http://courses.washington.edu/css341/zander/Code/pptToWord.vbs"> pptToWord.vbs</a>

Array examples:
Demonstrate simple array manipulation using static arrays: <a href="http://courses.washington.edu/css341/zander/Code/array.vbs"> array.vbs</a>
Demonstrate dynamic arrays: <a href="http://courses.washington.edu/css341/zander/Code/arrayDynamic.vbs"> arrayDynamic.vbs</a>
Find something in an array (linear search) (find grade given name): <a href="http://courses.washington.edu/css341/zander/Code/linearSearch.vbs"> linearSearch.vbs</a>
First open a text file with names, e.g., <a href="http://courses.washington.edu/css341/zander/Code/names.txt"> names.txt</a>
Then open a text file with grades, e.g., <a href="http://courses.washington.edu/css341/zander/Code/grades.txt"> grades.txt</a>
Sort a collection of integers using a bubble sort: <a href="http://courses.washington.edu/css341/zander/Code/bubble.vbs"> bubble.vbs</a>

<a href="http://courses.washington.edu/css341/zander/code.html">Sample VBScript Programs</a>

<a href="http://w3schools.sinsixx.com/vbscript/vbscript_examples.asp.htm">VBScript Examples</a>
<a href="http://www.landofcode.com/vbscript-examples/">VBScript examples</a>
<a href="https://www3.rocketsoftware.com/bluezone/help/v52/en/bzsh/bzaa_aref_sample-vbscript.htm">Sample VBScript</a>

<br>

<h2>simple.vbs</h2>
' Based on code by Kelvin Sung
' File:  simple.vbs
'
' Purpose: Input a string from the user and echo the string back to the user.
'
' Lessons 
' -- comments start with a single quote (')
' -- execution starts from the first line
' -- always say you will explicitly declare variables
' -- variable declarations don't have types
'
' There are two ways we can run this script:
'    1. On a command (console) window type
'		   wscript simple.vbs
'    2. Click on the simple.vbs file


Option Explicit        ' says we must declare variables, we will always use it 

Dim inputString        ' user input string

' Call a function: InputBox
' pass in one parameter: the entire sentence in double-quotes, 
'     often called a string
' Notice: a function returns something, and you MUST parenthecize the parameter
'     in this situation (we'll learn the details later)
inputString = InputBox("Please enter some phrase or sentence. Thanks!")

' Calling a procedure: MsgBox
' pass in one parameter: a string (in double quotes) concatenated with
'     inputString; the '&' connects the two strings together
' Notice there are no parentices around the parameter
MsgBox "You entered:  " & inputString

<h2>largestNum.vbs</h2>
' Based on code by Kelvin Sung
' File:  largestNum.vbs
'
' Purpose:  input three numbers and figure out the maximum of the numbers.
'
' Lessons
' -- the if/then/else construct 
' -- be careful when working with numbers 
' -- continue code to the next line by using the underscore
' -- parameters are separated by a comma

Option Explicit                     ' recall force explicit var declaration

Dim largestNum                      ' variable for largest number
Dim num1, num2, num3                ' variables for the three input numbers

num1 = InputBox("Please enter the first number: ")
num2 = InputBox("Please enter the second number: ")
num3 = InputBox("Please enter the third number: ")

' check to make sure all input are "numeric" - integer/float/double
If IsNumeric(num1) and IsNumeric(num2) and IsNumeric(num3) Then
    ' MsgBox is a subroutine, the first parameter is the "prompt"
    '
    ' if the last character of the line is an underscore, then the line of
    ' code is continued to the next line (CANNOT put comment here)
    '
    ' the second parameter is what button to put on the MsgBox
    '
    ' the third parameter is the "title" for the MsgBox
    '
    ' note, there are more parameters for MsgBox, but we choose to use defaults
    MsgBox "You have entered: " & num1 & " " & num2 & " " & num3, _
           vbOKOnly,  "Entered Values"

    ' the numbers can be integers or floating point number (have dec point),
    ' compare them as "Double" (or floating point numbers)
    largestNum = num1
    If CDbl(num2) > CDbl(largestNum) Then
        largestNum = num2
    End If

    If CDbl(num3) > CDbl(largestNum) Then
        largestNum = num3
    End If

    MsgBox "The largest number entered is: "  & largestNum, vbOKOnly, _
        "Largest Number"
Else
    MsgBox "You must enter three numbers! Try Again", vbOKOnly, "Invalid Input"
End If

<h2>largestNum</h2>
    The &lt:script&gt; tag says we are going to have script code here.

    Notice, we place the &lt;script&gt; inside the &lt;body&gt; section.
    The &lt;script&gt; can be inside or outside any part of the &lt;html&gt; section. 
&lt;script Language="vbscript"&gt;

   Option Explicit

   ' This is the "service" routine for our button: SubmitButton
   ' we are going to service "_onClick" event for this button.
   ' Refer to page 161 of the VBScript reference book for all 
   ' valid events of all controls
   Sub SubmitButton_onClick

      ' Code from largestNum.vbs, but without most comments for easy reading
      ' Note that we no longer have InputBox for input. Handled below.
      ' Below, data type is &VarType(num1.value).
      ' So, num1 is a string, not a number, but num1.value is a number.

      Dim largestNum                   ' variable for largest number

      ' check to make sure all input are "numeric" - integer/float/double
      If IsNumeric(num1.value) and IsNumeric(num2.value) _
                               and IsNumeric(num3.value) Then
         MsgBox "You have entered: " & num1.value & " " & num2.value & " " _
                & num3.value, vbOKOnly, "Entered Values"

         largestNum = num1.value
         If CDbl(num2.value) > CDbl(largestNum) Then
            largestNum = num2.value
         End If

         If CDbl(num3.value) > CDbl(largestNum) Then
            largestNum = num3.value
         End If

         MsgBox "The largest number entered is: "  & largestNum, vbOKOnly, _
                "Largest Number"
      Else
         MsgBox "You must enter three numbers! Try Again", vbOKOnly, _
                "Invalid Input"
      End If
   End Sub
&lt;/script&gt;

First Number: <Input Type="Text" Name="num1" Value="" />
Second Number: <Input Type="Text" Name="num2" Value="" />
Third Number: <Input Type="Text" Name="num3" Value="" />

   Input Type - list of all valid types on page 161 of VBScript Reference book
   Name - variable name for this control
   Value - what to show on the webpage (or the label for this control)

&lt;Input Type="Button" Name="SubmitButton" Value="Submit" &gt;

<h2>largestNumTable</h2>
    The &lt;script&gt; tag says we are going to have script code here.

    Notice, we place the &lt;script&gt; inside the &lt;body&gt; section.
    The &lt;script&gt; can be inside or outside any part of the &lt;html&gt; section. 
&lt;script Language="vbscript"&gt;

   Option Explicit

   ' This is the "service" routine for our button: SubmitButton
   ' we are going to service "_onClick" event for this button.
   ' Refer to page 161 of the VBScript reference book for all 
   ' valid events of all controls
   Sub SubmitButton_onClick

      ' Code from largestNum.vbs, but without most comments for easy reading
      ' Note that we no longer have InputBox for input. Handled below.
      ' Below, data type is &VarType(num1.value).
      ' So, num1 is a string, not a number, but num1.value is a number.

      Dim largestNum                   ' variable for largest number

      ' check to make sure all input are "numeric" - integer/float/double
      If IsNumeric(num1.value) and IsNumeric(num2.value) _
                               and IsNumeric(num3.value) Then
         MsgBox "You have entered: " & num1.value & " " & num2.value & " " _
                & num3.value, vbOKOnly, "Entered Values"

         largestNum = num1.value
         If CDbl(num2.value) > CDbl(largestNum) Then
            largestNum = num2.value
         End If

         If CDbl(num3.value) > CDbl(largestNum) Then
            largestNum = num3.value
         End If

         MsgBox "The largest number entered is: "  & largestNum, vbOKOnly, _
                "Largest Number"
      Else
         MsgBox "You must enter three numbers! Try Again", vbOKOnly, _
                "Invalid Input"
      End If
   End Sub
&lt;/script&gt;

&lt;table&gt;
&lt;tr&gt;
First Number:
&lt;Input Type="Text" Name="num1" Value=""&gt;
&lt;Second Number:&gt;
&lt;Input Type="Text" Name="num2" Value=""&gt;
Third Number:
&lt;Input Type="Text" Name="num3" Value=""&gt;
&lt;/table&gt;

   Input Type - list of all valid types on page 161 of VBScript Reference book
   Name - variable name for this control
   Value - what to show on the webpage (or the label for this control)

&lt;Input Type="Button" Name="SubmitButton" Value="Submit"&gt;

<h2>digits.vbs</h2>
' Based on code by Kelvin Sung
' File:  digits.vbs
'
' example demonstrates mod (modulus, finding remainder) and integer div (\)
' by breaking a five-digit number into individual digits
 
Option Explicit                  ' must declare every variables before use

dim inputNumber                  ' input from user
dim origNumber                   ' save the inputNumber
dim onesDigit, tenDigit, hunDigit, thouDigit, tenThouDigit

do
   inputNumber = InputBox("Please Enter a 5 digit number, zero to end")

   ' check for validity
   if not IsNumeric(inputNumber) then
      MsgBox "You must enter a number. Try Again.", vbOKOnly, "Invalid Input"
   else
      ' check to see if the loop should be terminated
      if inputNumber = 0 then
         exit do
      end if

      ' have obtained a good number, demonstrate different kinds of division
      origNumber = inputNumber
      MsgBox "Using division (/):  " & origNumber & "/100 is  " _
              & origNumber/100
      MsgBox "Using integer division (\):  " & origNumber & "\100 is  " _
              & origNumber\100

      ' extract digits
      tenThouDigit = inputNumber\10000

      inputNumber = inputNumber mod 10000
      thouDigit = inputNumber\1000

      inputNumber = inputNumber mod 1000
      hunDigit = inputNumber\100

      inputNumber = inputNumber mod 100
      tenDigit = inputNumber\10

      onesDigit = inputNumber mod 10

      MsgBox "The digits of  " & origNumber & "  are  " & tenThouDigit & "  " _
              & thouDigit & "  " & hunDigit & "  " & tenDigit & "  " & onesDigit
   end if
loop

MsgBox "All done!"

<h2>digits2.vbs</h2>
' Based on code by Kelvin Sung
' File:  digits2.vbs
'
' example demonstrates mod (modulus, finding remainder) and integer div (\)
' by breaking a five-digit number into individual digits
 
Option Explicit                  ' must declare every variables before use

dim inputNumber                  ' input from user
dim origNumber                   ' save the inputNumber
dim onesDigit, tenDigit, hunDigit, thouDigit, tenThouDigit

do
   inputNumber = InputBox("Please enter a 5 digit number, enter 'done' to end")

   ' check for validity, exit on entry of word "done"
   if not IsNumeric(inputNumber) then
      if inputNumber = "done" then
         exit do
      else
         MsgBox "You must enter a number, try again.", vbOKOnly, "Invalid Input"
      end if
   else
      origNumber = inputNumber
      MsgBox "Using division (/):  " & origNumber & "/100 is  " _
             & origNumber/100
      MsgBox "Using integer division (\):  " & origNumber & "\100 is  " _
             & origNumber\100

      ' separate digits
      tenThouDigit = inputNumber\10000

      inputNumber = inputNumber mod 10000
      thouDigit = inputNumber\1000

      inputNumber = inputNumber mod 1000
      hunDigit = inputNumber\100

      inputNumber = inputNumber mod 100
      tenDigit = inputNumber\10

      onesDigit = inputNumber mod 10

      MsgBox "The digits of  " & origNumber & "  are  " & tenThouDigit & "  " _
             & thouDigit & "  " & hunDigit & "  " & tenDigit & "  " & onesDigit
   end if
loop

MsgBox "All done!"

<h2>avg.vbs</h2>
' File:  avg.vbs
'
' count how many data and compute average
 
Option Explicit                  ' must declare every variables before use

dim inputNumber                  ' input from user
dim count                        ' count data items
dim sum                          ' sum data items
dim avg                          ' average of data items

' initialize 
count = 0
sum = 0
avg = 0

' for every valid data item, sum and count it
do
   inputNumber = InputBox("Please enter one number, negative number to end")

   ' check for validity
   if not IsNumeric(inputNumber) then
      MsgBox "You must enter a number. Try Again.", vbOKOnly, "Invalid Input"
   else
      if inputNumber < 0 then
         exit do
      end if
      sum = sum + inputNumber
      count = count + 1
   end if
loop

' computer average and output
if count <> 0 then
   avg = sum/count
else
   avg = 0
end if
MsgBox "The number of items entered:  " & count & "  has an average of  " & avg 

<h2>million.vbs</h2>
' File:  million.vbs
'
' 4. Suppose you start with $1 and double your money every day. How many days
' does it take to make more than $1000000?
 
Option Explicit                  ' must declare every variables before use

const MAXAMOUNT = 1000000
dim amount                       ' current amount of money
dim sum                          ' total sum of accumulated money
dim days                         ' number of days

' initialize 
amount = 1
sum = 0
days = 0

do until sum > MAXAMOUNT 
   sum = sum + amount
   amount = 2 * amount
   days = days + 1
loop

MsgBox "Start with $1 and double your money everyday. It takes  " _
       & days & "  days to make  " & sum & "  dollars" 

<h2>findLarge.vbs</h2>
' File: findLarge.vbs
'
' 6. In a loop, you input one integer at a time. The word "done" 
' terminates the loop. Find and display the largest number inputted.
 
Option Explicit                  ' force declaration of variables before use

dim inputNumber                  ' input from user
dim outputNums                   ' to show all the numbers user inputs
dim largest                      ' always current largest number
dim doneWithInput                ' whether or not user is done entering input
doneWithInput = false
outputNums = ""

' Loop to get one valid number from the user to initialize largest.
' The var doneWithInput will remember if the user is done before
' ever entering a valid number.
do
   inputNumber = InputBox("Please enter one number, enter 'done' to end")
   ' check for validity, exit on entry of word "done"
   if not IsNumeric(inputNumber) then
      if inputNumber = "done" then
         doneWithInput = true                
         exit do
      else
         MsgBox "You must enter a number, try again.", vbOKOnly, "Invalid Input"
      end if
   else
      largest = inputNumber
      outputNums = outputNums & " " & inputNumber
      exit do
   end if
loop

' If user isn't done, continue getting integers to find the largest.
' Continually compare with the current largest to see if it's larger,
' then it becomes the new current largest.
if not doneWithInput then
   do
      inputNumber = InputBox("Please enter one number, enter 'done' to end")

      ' check for validity, exit on entry of word "done"
      if not IsNumeric(inputNumber) then
         if inputNumber = "done" then
            exit do
         else
            MsgBox "You must enter a number, try again.", vbOKOnly, _
                   "Invalid Input"
         end if
      else  
         ' recall that InputBox returns a string, so convert to
         ' make sure they are treated as numbers, not strings
         if Cdbl(inputNumber) > Cdbl(largest) then
            largest = inputNumber
         end if

         outputNums = outputNums & " " & inputNumber
      end if
   loop
end if

if doneWithInput then
   MsgBox "Can't find the largest because you never entered any numbers!!" 
else
   MsgBox "Of all the numbers, " & outputNums & ", the largest is  " & largest
end if

<h2>prob9.vbs</h2>
' 9. Given some integer number as input, print out a solid square in 
' asterisks the size of that number. E.g., input is 5, output is
' *****
' *****
' *****
' *****
' *****
 
Option Explicit                  ' must declare every variables before use

dim inputNumber                  ' input from user
dim i, j
dim output                           

do
   ' start with no characters in the output string, called the empty string
   output = ""

   inputNumber = InputBox("Please enter one positive number, 'done' to end")

   ' check for validity of input
   if not IsNumeric(inputNumber) then
      if inputNumber = "done" then
         exit do
      else
         MsgBox "You must enter a number. Try Again.", vbOKOnly, "Invalid Input"
      end if

   ' can't have a negative number of asterisks in a box
   elseif inputNumber < 0 then
      MsgBox "You must enter a positive number. Try Again.", vbOKOnly, _
             "Invalid Input"

   else                                     ' have valid inputNumber
      ' i loop yields different lines of asterisks
      for i = 1 to inputNumber

         ' j loop gives all the asterisks in one line
         for j = 1 to inputNumber
            output = output & "*"
         next

         ' after the j loop asterisks are concatenated, need NewLine in output
         output = output & vbNewLine
      next
      MsgBox output
   end if
loop

<h2>findLargeWithSubs.vbs</h2>
' File: findLarge.vbs
'
' 6. In a loop, you input one integer at a time. The word "done" 
' terminates the loop. Find and display the largest number inputted.
 
Option Explicit                  ' force declaration of variables before use

dim outputNums                   ' to show all the numbers user inputs
dim largest                      ' always current largest number
dim doneWithInput                ' whether or not user is done entering input
doneWithInput = false
outputNums = ""

call setFirstLargest(outputNums, doneWithInput, largest)
call findLargestInRest(outputNums, doneWithInput, largest)
if doneWithInput then
   MsgBox "Can't find the largest because you never entered any numbers!!" 
else
   MsgBox "Of all the numbers, " & outputNums & ", the largest is  " & largest
end if


'---------------------------------------------------------------------------- 
' setFirstLargest 
' Loop to get one valid number from the user to initialize largest.
' The var doneWithInput will remember if the user is done before
' ever entering a valid number.
sub setFirstLargest(outputNums, doneWithInput, largest)
   dim inputNumber                  ' input from user
   do
      inputNumber = InputBox("Please enter one number, enter 'done' to end")
      ' check for validity, exit on entry of word "done"
      if not IsNumeric(inputNumber) then
         if inputNumber = "done" then
            doneWithInput = true                
            exit do
         else
            MsgBox "You must enter a number, try again.", vbOKOnly, _
                   "Invalid Input"
         end if
      else
         largest = inputNumber
         outputNums = outputNums & " " & inputNumber
         exit do
      end if
   loop
end sub

'---------------------------------------------------------------------------- 
' findLargestInRest
' If user isn't done, continue getting integers to find the largest.
' Continually compare with the current largest to see if it's larger,
' then it becomes the new current largest.
sub findLargestInRest(outputNums, doneWithInput, largest)
   dim inputNumber                  ' input from user
   if not doneWithInput then
      do
         inputNumber = InputBox("Please enter one number, enter 'done' to end")

         ' check for validity, exit on entry of word "done"
         if not IsNumeric(inputNumber) then
            if inputNumber = "done" then
               exit do
            else
               MsgBox "You must enter a number, try again.", vbOKOnly, _
                      "Invalid Input"
            end if
         else  
            ' recall that InputBox returns a string, so convert to
            ' make sure they are treated as numbers, not strings
            if Cdbl(inputNumber) > Cdbl(largest) then
               largest = inputNumber
            end if

            outputNums = outputNums & " " & inputNumber
         end if
      loop
   end if
end sub
<h2>sortThreeNums.vbs</h2>
' File: sortThreeNums.vbs
' Sort three Numbers

   Option Explicit

   dim num1, num2, num3            ' used for input
   dim largeNum                   ' variable for largest number
   dim middleNum                  ' variable for second largest number
   dim smallNum                   ' variable for smallest number
   dim temp

   num1 = InputBox("Please enter the first number")
   num2 = InputBox("Please enter the second number")
   num3 = InputBox("Please enter the third number")

   ' check to make sure all input are "numeric" - integer/float/double
   if IsNumeric(num1) and IsNumeric(num2) and IsNumeric(num3) then
      MsgBox "You have entered: " & num1 & " " & num2 & " " _
             & num3, vbOKOnly, "Entered Values"

      largeNum = CDbl(num1) 
      middleNum = CDbl(num2)
      smallNum = CDbl(num3)

      if largeNum < middleNum then
         temp = largeNum
         largeNum = middleNum
         middleNum = temp
      end if

      if largeNum < smallNum then
         temp = largeNum
         largeNum = smallNum
         smallNum = temp
      end if

      if middleNum < smallNum then
         temp = middleNum
         middleNum = smallNum
         smallNum = temp
      end if

      MsgBox "The numbers sorted: " & smallNum & "  " & middleNum & "  " _
             & largeNum, vbOKOnly, "Sorted Numbers"  
   else
      MsgBox "You must enter three numbers! Try Again", vbOKOnly, _
             "Invalid Input"
   end if

<h2>sortThreeNumsWithSubs.vbs</h2>
' File: sortThreeNumsWithSubs.vbs
' Sort three Numbers

   Option Explicit

   dim num1, num2, num3            ' used for input
   dim largeNum                   ' variable for largest number
   dim middleNum                  ' variable for second largest number
   dim smallNum                   ' variable for smallest number

   num1 = InputBox("Please enter the first number")
   num2 = InputBox("Please enter the second number")
   num3 = InputBox("Please enter the third number")

   ' check to make sure all input are "numeric" - integer/float/double
   if IsNumeric(num1) and IsNumeric(num2) and IsNumeric(num3) then
      MsgBox "You have entered: " & num1 & " " & num2 & " " _
             & num3, vbOKOnly, "Entered Values"

      largeNum = CDbl(num1) 
      middleNum = CDbl(num2)
      smallNum = CDbl(num3)

      call compareAndSwap(largeNum, middleNum)
      call compareAndSwap(largeNum, smallNum)
      call compareAndSwap(middleNum, smallNum)

      MsgBox "The numbers sorted: " & smallNum & "  " & middleNum & "  " _
             & largeNum, vbOKOnly, "Sorted Numbers"  
   else
      MsgBox "You must enter three numbers! Try Again", vbOKOnly, _
             "Invalid Input"
   end if

   '----------------------------------------------------------------------
   ' compareAndSwap
   ' Compare num1 to num2 and swap if they are out of order.
   ' Result is that at the end of the routine, num1 is always less than num2.
   sub compareAndSwap(num1, num2)
      dim temp
      if num1 < num2 then
         temp = num1
         num1 = num2
         num2 = temp
      end if
   end sub

<h2>byValbyRef.vbs</h2>
' File: byValbyRef.vbs
' demonstrate difference between byVal parameter and byRef parameter

option explicit

dim a, b, c, d
a = 2
b = 3
c = 2
d = 3

call byValSub(a, b)
call byRefSub(c, d)

MsgBox "a = " & a & "  b = " & b & "  c = " & c & "  d = " & d

'----------------------------------------------------------------------------
' byValSub
' Parameters that are pass by value make a copy of the value passed to
' the parameter and if the parameter is changed, it is only changed
' locally, meaning within the subprogram.
SUB byValSub(ByVal num1, ByVal num2)
   num1 = 10
   num2 = 20
end SUB

'----------------------------------------------------------------------------
' byRefSub
' Parameters that are pass by reference are sent the memory address of the
' sender. If the parameter is changed, it is changed at the sending location.
SUB byRefSub(ByRef num1, ByRef num2)
   num1 = 10
   num2 = 20
end SUB

<h2>openNewExcel.vbs</h2>
' Based on code by Kelvin Sung
' File: openNewExcel.vbs
'
' Enter two numbers from the user and add them up using Microsoft Excel 
' Shows How to open an MicroSoft Excel ActiveX service through VB
 
Option Explicit                ' force variable declarations

' Excel.Document - is a predefined name for "ActiveX" services provided by Excel
' (xlAppl is our "connection" to all functions MS Excell provides)
'
' "set" -  new VBScript for us (only can "set" non-VB types, i.e., "objects")
' For example, 
'     dim num
'     set num = 123    ' is an ERROR !!!)
'
' If you forget to use "set", e.g.,
'     xlAppl = CreateObject("Excel.Application")
' it will compile, but when it runs, we'll get a run-time error:
'     "Object Required: .... "
'
' Also note that if you encounter errors after Excel is opened,
' you have to manually close the excel application 
dim xlAppl
set xlAppl = CreateObject("Excel.Application")

' We do not need to let the user see what is going on, 
' can switch the visibility on/off
xlAppl.Application.Visible = false

' Now create a new excel document to work with,
' MS Excel refers to its documents (files) as "Workbook"
dim newDocument
set newDocument = xlAppl.Application.Workbooks.Add()

' Each excel document can have many work sheets, 
' we will activate the first one and work with it ...
dim activeSheet
set activeSheet = xlAppl.Worksheets("Sheet1")

' we can use the value returned by MsgBox, to let user decide what to see
dim choice
choice = MsgBox("Do you want to look at the Excel Page?", vbYesNo)
if choice = vbYes then
   xlAppl.Application.Visible = true
end if

' now we are ready, let's enter number and add the numbers up
' for the user
'
dim num1, num2
num1 = InputBox("Please enter a number: ")
num2 = InputBox("Please enter another number: ")

' put num values in first and second rows, put sum in third row, first column
activeSheet.Cells(1, 1).Value = num1
activeSheet.Cells(2, 1).Value = num2
activeSheet.Cells(3, 1).Value = "=Sum(A1:A2)"

dim answer
answer = activeSheet.Cells(3,1).Value

MsgBox num1 & "+" & num2 & " is: " & answer
	
' When I want to quit, let me quit, do not ask me if I want to save my work
xlAppl.Application.DisplayAlerts = true

' and quit
xlAppl.Application.Quit

<h2>openOldExcel.vbs</h2>
' Based on code by Kelvin Sung
' File: openOldExcel.vbs
'
' Use Microsoft Office (mso) ActiveX service to open an existing document
'
' Open a document from user input
 
Option Explicit

' We need to go through MS Excel (or MS Office, Word is fine), the 
' application script editor, to find the value to send to the FileDialog.
' Refer to on-line help page for the details.
'
' In this case, MsoFileDialogType.msoFileDialogOpen with a value of one
' is used to open the file.
const msoFileDialogOpen = 1

dim xlAppl
set xlAppl = CreateObject("Excel.Application")

' use Microsoft Office FileDialog to open a file
dim dlgOpen          
set dlgOpen = xlAppl.Application.FileDialog(msoFileDialogOpen)

dim selectedFile
dim dlgAnswer

' only allow the selection of one file
dlgOpen.AllowMultiSelect = false

' -1 says user clicked on "Open"
if (dlgOpen.Show() = -1 ) then
   ' since we disallow multiple select, the first selected item is our file 
   selectedFile = dlgOpen.SelectedItems(1)

   ' now open the file 
   xlAppl.Application.Workbooks.Open(selectedFile)
   msgbox "selectedFile is: " & selectedFile
else
   MsgBox "No document opened!"
end if

xlAppl.Application.DisplayAlerts = false
xlAppl.Application.Quit

<h2>loopCells.vbs</h2>
' Based on code from Kelvin Sung
' File: loopCells.vbs 
' Allow the user to open an existing excel document, and access cells 

Option Explicit           'force all variables to be declared 

' Get information on the "current folder" of this script and open a connection 
' to the "operating environment". 
dim wshShell, currentFolder

' wshShell contains the environment for which we are operating in; 
' use it to retrieve the current work folder
set wshShell = WScript.CreateObject("WScript.Shell")
        
' currentFolder contains the path to the folder where this script is located
currentFolder = wshShell.CurrentDirectory

' open the the msoFileDialog with initial folder setting to the "currentFolder"
dim xlAppl
set xlAppl = CreateObject("Excel.Application")

const msoFileDialogOpen = 1
dim dlgOpen                          ' use MS Office FileDialog to open a file
set dlgOpen = xlAppl.Application.FileDialog(msoFileDialogOpen)

dim selectedFile
dim dlgAnswer

dlgOpen.AllowMultiSelect = false           ' only allow selection of one file
dlgOpen.InitialFileName = currentFolder

if (dlgOpen.Show() = -1) then              ' -1 says user clicked on "Open"
    ' the first selected item will be our file name
    selectedFile = dlgOpen.SelectedItems(1)

    ' now open the file 
    xlAppl.Application.Workbooks.Open(selectedFile)
else
    MsgBox "No document opened!"
end if

' each excel document can have many work sheets, do our work on Sheet1
dim activeSheet
set activeSheet = xlAppl.Worksheets("Sheet1")

'--------------------------------------------------------------------------
' The code to work with the spreadsheet starts here.
dim row                      ' row is row number
dim col                      ' col is column number

' activeSheet.Cells(row, col) is the cell value 
'
' For example, activeSheet.Cells(4, 6) is the cell in row 4, column 6
' The cells are strings, so convert if needed. If you do arithmetic
' with them, they are automatically converted.

' Pause to see the original spreadsheet. 
MsgBox "Notice that there is nothing in column five or six."

' Here is a loop to demonstrate. 
' The loop puts the value of variable row into each cell in rows one
' through ten, column five. It then copies column 5 to column 6.
for row = 1 to 10
   activeSheet.Cells(row, 5) = row 
   activeSheet.Cells(row, 6) = activeSheet.Cells(row, 5) 
next

' To keep the spradsheet open to allow saving 
MsgBox "The End. Click the excel closing box if you wish to save it."

'--------------------------------------------------------------------------
xlAppl.Application.DisplayAlerts = false
xlAppl.Application.Quit

<h2>openText.vbs</h2>
' Based on code by Kelvin Sung
' File: openTextFile.vbs
'
' Define a Function to use MSO FileOpenDial facility
' to help the user select a text file to open

Option Explicit

' ask the scripting runtime environemt for access to files
dim FS 
set FS = CreateObject("Scripting.FileSystemObject")

const FILEFORREADING = 1
dim dataFile
dataFile = selectAFileOrFolder("FILE")

if FS.FileExists(dataFile) then
   ' get the fileHander based on the dataFile
   dim FileHandler
   set FileHandler = FS.GetFile(dataFile)
   
   ' open the file as a inputTextStream so text data can be "streamed"
   dim inputTextStream
   set inputTextStream = FileHandler.OpenAsTextStream(FILEFORREADING)
   
   dim inputLine                         ' a line in the file
   dim lineCount                         ' number of lines in the file
   lineCount = 0

   do while not inputTextStream.AtEndOfStream 
      lineCount = lineCount + 1
      inputLine = inputTextStream.ReadLine
      MsgBox "Line " & lineCount & " content:  " & inputLine
   loop

else
   MsgBox "File: " & dataFile & " does not exists."
end if

'------------------------------------------------------------------------------
' selectAFileOrFolder
' Takes in one input parameter, "FILE" or "FOLDER", and returns its path
' in a string that contains either the selected file or folder path.
FUNCTION selectAFileOrFolder(ByRef fileOrFolder)

   dim WshShell, currentFolder

   ' Open a "connection" to the "operating environment" .
   ' WshShell contains the environment for which we are operating in.
   ' For example, below we will use it to retrieve the current working folder.
   set WshShell = WScript.CreateObject("WScript.Shell")
   
   ' Get the current folder (where this script is opened from).
   ' currentFolder now contains the path to the folder 
   currentFolder = wshShell.CurrentDirectory
   
   ' XlAppl is our "connection" to all functions MS Excel provides
   dim XlAppl
   set XlAppl = WScript.CreateObject("Excel.Application")
    
   ' don't let user see what is going on,
   ' can switch the visibility of MSon/off (TRUE/FALSE)
   XlAppl.Application.Visible = FALSE

   ' specific constants to OFFICE Object. 
   ' VBScript cannot see these constants, so we have
   ' to find out what they are, and re-define them.
   dim msoFileDialogOpen
   if (fileOrFolder = "FILE") then
      msoFileDialogOpen = 1
   end if
   if (fileOrFolder = "FOLDER") then
      msoFileDialogOpen = 4
   end if
   
   ' OpenFile Dialog we use MSO facility, since MSO is implemented in either
   ' Word, Excel, even PowerPoint. It can be used in exactly the same way. 
   ' Notice "set" is used here too.
   dim DlgOpen   
   set DlgOpen = XlAppl.Application.FileDialog(msoFileDialogOpen)

   ' Only allow selection of one file
   ' TRUE:      Allow multiple file selection
   ' FALSE:   Do not allow multiple file selection
   DlgOpen.AllowMultiSelect = FALSE
   
   ' Set up the "Filters" so that we only work with certain types of files.
   '
   ' DlgOpen.Filters.Clear
   ' DlgOpen.Filters.Add "Text Files", "*.txt", 1
   ' Only want to work with Text files
   ' The parameters of Add are:
   '    1st - description of what is the file type
   '    2nd - the extension (don't forget the "*") 
   '    3rd - the position for this entry

   ' Start looking from current working folder
   ' currentFolder contains the path to the folder where this script is located
   DlgOpen.InitialFileName = currentFolder
   
   SelectAFileOrFolder = ""             ' Set the return value to ""

   if (DlgOpen.Show() = -1) then        ' -1 says user clicked on "Open"
      ' first selected item is the file name
      SelectAFileOrFolder = DlgOpen.SelectedItems(1)
   end if
   
   ' TRUE:    Prompt user to save the work
   ' FALSE:   Do not prompt user to save the work
   XlAppl.Application.DisplayAlerts = FALSE
   
   XlAppl.Application.Quit                  ' quit the application
end FUNCTION

<h2>searchWord.vbs</h2>
' Based on code by Kelvin Sung
' File: searchWord.vbs
'
' Shows how to open a MS Word document via ActiveX.
' Ask the user for a string and search for it in the document.
'
' Uses the same MSO FileOpenDialog as used via the excel examples.

Option Explicit

' Very similar to opening an excel document.
'   dim XlAppl
'   set XlAppl = CreateObject("Excel.Application")
dim DOCAppl
set DOCAppl = CreateObject("Word.Application")

dim searchString
dim count

if (Open_OFFICE_Document(DOCAppl, "Word Files", "*.doc")) then

   searchString = "Something"
   do while searchString <> ""
      searchString = InputBox("Enter the string to search [enter to quit]: ")
      if (searchString <> "") then
         count =  countStringInDoc(searchString, DOCAppl)
         if (count > 0) Then
            MsgBox "String [" & searchString & "] is found in the document: " _
                   & count & " times"
         else
            MsgBox "String [" & searchString & "] is NOT found in the document"
         end if
      end if
   loop
    
   DOCAppl.Application.Documents.Close
   DOCAppl.Application.Quit
else
   DOCAppl.Application.Quit
end if


'-----------------------------------------------------------------------------
' Function Name:    countStringInDoc(ByVal searchString)
' Description:      Takes in 1 input parameter, and returns count, the
'                   number of times the string is found in the document
'
' Input Parameters: ByRef searchString,  ByRef applObj
'                      1) searchString -- the string you want to find
'                      2)   applObj -- the application object
'
' Returns Value:    INTEGER: number of times string is found

FUNCTION countStringInDoc(ByVal searchString, ByRef applObj)

   ' set up to search the entire document
   dim findRange
   set findRange = applObj.ActiveDocument.Range()

   ' program Word's search facility
   With findRange
      .Find.Text = searchString        ' assign the string to search
      .Find.Forward = TRUE             ' look in the forward direction
   end With

   dim doneSearching, count
   doneSearching = FALSE
   count = 0

   ' search through the doc, counting occurrences of searchString
   do while not doneSearching
      findRange.Find.Execute()         ' start Word searching
      if (findRange.Find.Found) then
         count = count + 1
      else
         doneSearching = TRUE          ' can't find anymore strings
      end if
   loop

   countStringInDoc = count
end FUNCTION


'-----------------------------------------------------------------------------
' Function Name: Open_OFFICE_Document(ByRef applicationObj, ByRef filterDes,
'                                     ByRef filterExt)
' Description:  Takes in 3 input parameter, and returns
'               TRUE or FALSE, whether the file is being opened.
'
'               It uses the WScript's CreateObject method to establish the 
'               connection with the "Operation Enviroment".
'
'               After setting up the "connection", use the Microsoft Office 
'               OpenFileDialog facility to open a file, through the 
'               "connection".
'
' Input Parameters: ByRef applicationObj, ByRef filterDes, ByRef filterExt
'                   1) applicationObj -- The application object
'                   2) filterDes -- file description type you want to open,
'                      pass by reference as String
'                      e.g., filterDes = "MS Word Files" to work with Word 
'                   3) filterExt -- extension of the file type to open,
'                      pass by reference as String, e.g.,
'                      filterExt = "*.ppt" to work with PowerPoint files
'
' Returns Value:    BOOLEAN, whether the file is being opened or not
' Possible Errors:  The passed in applicationObj is not created correctly
'                   The values of filterDes or filterExt are not inside 
'                   double quotations
FUNCTION Open_OFFICE_Document(ByRef applicationObj, ByRef filterDes, _
                              ByRef filterExt)

   ' Constants specific to _OFFICE_ Object. VBScript cannot see these 
   ' constants, so we have to find out what they are, and redefine them.
   const msoFileDialogOpen = 1

   ' Open a "connection" to the "operating environment" .
   ' WshShell contains the environment for which we are operating in.
   ' For example, below it is used to retrieve the current working folder. 
   dim WshShell
   set WshShell = WScript.CreateObject("WScript.Shell")

   ' OpenFile Dialog we use MSO facility, since MSO is implemented in either
   ' Word, Excel, even PowerPoint, we can use it in exactly the same way. 
   dim DlgOpen
   set DlgOpen = applicationObj.FileDialog(msoFileDialogOpen)

   With DlgOpen
      ' Notice when we want to perform multiple operations based on the
      ' same object, we can use the "With" statement. This is much more
      ' efficient (especially when dealing with ActiveX connection)
      .AllowMultiSelect = False
         ' Only allow selection of one file
         ' TRUE:    Allow multiple file selection
         ' FALSE:   Do not allow multiple file selection
      .InitialFileName = WshShell.CurrentDirectory
         ' Start looking from current working folder
         ' CurrentFolder contains the path to the folder of this script 
      .Filters.Clear                           'clear filter

      ' Set up "Filters", so that we only work with certain types of files.
      ' The parameters of Add are:
      ' 1st - description of what is the file type
      ' 2nd - the extension (don't forget the "*")
      ' 3rd - the position for this entry
      .Filters.Add filterDes, filterExt, 1
   end With

   if ( dlgOpen.Show() = -1 ) then
      ' -1 says user clicked on "Open"
      ' Since we do not allow multiple select, the first selected item 
      ' will be our file name
      dim selectedFile
      selectedFile = dlgOpen.SelectedItems(1)

      ' Open the file, can switch the visibility of MSon/off (true/false)
      ' TRUE:    Show Excel is running
      ' FALSE:   Do not show Excel is running
      applicationObj.Visible = TRUE
      
      '--------     ALTERNATIVES     --------
      Select Case filterExt
         case "*.mdb"
               ' For Access files
               applicationObj.OpenCurrentDatabase selectedFile

         case "*.ppt"
               ' For PowerPoint files
               applicationObj.Presentations.Open selectedFile

         case "*.doc"
               ' For Word files
               applicationObj.Application.Documents.Open selectedFile

         case "*.xls"
               ' For Excel files
               applicationObj.Application.Documents.Open selectedFile
      end select

      Open_OFFICE_Document = TRUE             ' set return to TRUE
   else
      'else if user did not click on "Open"
      Open_OFFICE_Document = FALSE            ' set return to FALSE
   end if

end FUNCTION

<h2>openPpt.vbs</h2>
' Based on code by Kelvin Sung
' File: openPpt.vbs
'
' Open a powerpoint file and display the text from each slide.
' The same MSO FileOpenDialog (as used with Excel) is used.

Option Explicit

' specific constants, vbScript cannot see these constants, so 
' find out what they are, and redefine them
const msoFileDialogOpen = 1

dim WshShell
set WshShell = WScript.CreateObject("WScript.Shell")
   ' For getting our operating environment (e.g. Current Working Folder)

' Very similar to word and excel, remember:
'    dim xlAppl
'    set xlAppl = CreateObject("Excel.Application")
dim pptAppl
set pptAppl = CreateObject("Powerpoint.Application")

' OpenFile Dialog uses MSO facility, since MSO is implemented in both
' Word and Excel, use it in exactly the same way. 
dim dlgOpen
set dlgOpen = pptAppl.FileDialog(msoFileDialogOpen)

if (openPPTDocument()) then
   ' PPT uses ActivePresenation whereas
   '    Word  uses ActiveDocument 
   '    Excel uses ActiveWorkbook
   ' slideShow is the entire powerpoint presentation
   dim slideShow, oneSlide
   set slideShow = pptAppl.ActivePresentation.Slides

   MsgBox "This powerpoint file has: " & slideShow.Count & " number of slides"

   dim count
   for count = 1 To slideShow.Count
      set oneSlide = slideShow.Item(count)         ' one of the slides

      dim slideSections, titleName

      ' look at how many input boxes that are defined for this slide
      set slideSections = oneSlide.Shapes

      ' find the title for this slide
      if (slideSections.HasTitle) then
         titleName = slideSections.Title.TextFrame.TextRange.Text
      else
         titleName = "HAS NO TITLE"
      end if

      dim shapeIndex, slideText
      slideText = ""
      for shapeIndex = 1 to slideSections.Count
         ' Rest of the text for this slide
         dim aSection
         set aSection = slideSections.Item(shapeIndex)
         if (aSection.HasTextFrame) then
            slideText = slideText & aSection.TextFrame.TextRange.Text & vbCrLf
         end if
      next
         
      MsgBox "Slide Number Is: " & oneSlide.SlideNumber & vbCrLf & _
             "Title is: " & titleName & vbCrLf & "Texts In This Slide: " & _
             vbCrLf & slideText
   next
      
   pptAppl.ActivePresentation.Close
   pptAppl.Quit
else
   MsgBox("No PowerPoint Document Selected, Bye Bye")
   pptAppl.Quit
end if

'-----------------------------------------------------------------------------
' FUNCTION: openPPTDocument()
'
' Input:   none (uses the global dlgOpen to let user open a .ppt document)
' Returns: none (changes the global pptAppl variable to have an opened document)
' Error:   Checks to make sure input is a number
'
'   Remark: 
FUNCTION openPPTDocument()

   with dlgOpen
      ' Notice when we want to perform multiple operations based on the
      ' same object, we can use the "with" statement. This is much more
      ' efficient (especially when dealing with ActiveX connection)
      '
      .AllowMultiSelect = FALSE
      .InitialFileName = WshShell.CurrentDirectory
      .Filters.Clear
      .Filters.Add "PowerPoint Files", "*.ppt"
      end with

   openPPTDocument = FALSE
   if (dlgOpen.Show() = -1) then
      dim selectedFile                          ' -1 says user clicked "Open"

      selectedFile = dlgOpen.SelectedItems(1)
      pptAppl.Visible = TRUE                    ' first set ppt to visible
      pptAppl.Presentations.Open selectedFile   ' now open the file 
      openPPTDocument = TRUE
   end if
end FUNCTION

<h2>pptToWord.vbs</h2>
' Based on code by Kelvin Sung
' File: pptToWord.vbs
'
' Open a powerpoint document and put all the text into a word document.

Option Explicit

' specific constants, vbScript cannot see these constants, so 
' find out what they are, and redefine them
const msoFileDialogOpen = 1

' getting the operating environment (e.g., Current Working Folder)
dim WshShell
set WshShell = WScript.CreateObject("WScript.Shell")

dim pptAppl
set pptAppl = CreateObject("Powerpoint.Application")

dim WdAppl
set WdAppl = CreateObject("Word.Application")

WdAppl.Application.Visible = FALSE

' OpenFile Dialog using MSO facility, since MSO is implemented in both
' Word and Excel, use it in exactly the same way. 
dim DlgOpen
set DlgOpen = pptAppl.FileDialog(msoFileDialogOpen)

if (OpenPPTDocument()) then

   ' Powerpoint uses ActivePresenation just as Word uses ActiveDocument 
   ' and Excel uses ActiveWorkbook.
   '
   ' slideShow is now the entire powerpoint presentation
   dim slideShow, oneSlide
   set slideShow = pptAppl.ActivePresentation.Slides

   MsgBox "This powerpoint file has: " & slideShow.Count & " number of slides"

   SavePptToWord slideShow, pptAppl.ActivePresentation.Name

   ' quit powerpoint
   pptAppl.ActivePresentation.Close
   pptAppl.Quit

   ' quit word
   WdAppl.Application.Quit
else
   MsgBox("No PowerPoint Document Selected, Bye Bye")
   pptAppl.Quit
   WdAppl.Application.Quit
end if

'----------------------------------------------------------------------------
' Function: OpenPPTDocument()
'
' Input:   none (uses the global DlgOpen to let user open a .doc document)
' Returns: none (changes the global pptAppl variable to have an opened document
' Error:   Checks to make sure input is a number
 
FUNCTION OpenPPTDocument()

   ' perform multiple operations based on the same object, so use the
   ' "with" statement. This is cleaner, especially with activeX.
   with DlgOpen
      .AllowMultiSelect = FALSE
      .InitialFileName = WshShell.CurrentDirectory
      .Filters.Clear
      .Filters.Add "PowerPoint Files", "*.ppt"
   end with

   OpenPPTDocument = FALSE
   if (dlgOpen.Show() = -1) then
      dim selectedFile                          ' -1 says user clicked "Open"
      selectedFile = dlgOpen.SelectedItems(1)
      pptAppl.Visible = TRUE                    ' set ppt to visible
      pptAppl.Presentations.Open selectedFile   ' now open the file 
      OpenPPTDocument = TRUE
   end if
end FUNCTION

'----------------------------------------------------------------------------
' SUB SavePptToWord slideShow:
'
' Creates an MS Word Doc document with from ppt slideShow content.
' It is formatted somewhat.
SUB SavePptToWord(ByRef slides, ByVal name)
   const wdToggle = 9999998
   ' create a new MS Word Doc
   dim newWdDoc
   set newWdDoc = WdAppl.Documents.Add

   dim sel
   set sel = WdAppl.Application.Selection

   WdAppl.Application.Visible = TRUE      ' get back reference for editing

   with sel
      .Style = WdAppl.Application.ActiveDocument.Styles("Heading 1")
      .TypeText "Content of the Presenation: " + name
      .TypeParagraph
      .TypeParagraph
   end with

   dim count
   for count = 1 to slides.Count
      Set oneSlide = slides.Item(count)       ' one of the slides

      ' look at how many input boxes are defined for this slide
      dim slideSections, titleName
      set slideSections = oneSlide.Shapes

      ' find the title for this slide
      if (slideSections.HasTitle) then
         titleName = slideSections.Title.TextFrame.TextRange.Text
      else
         titleName = "HAS NO TITLE"
      end if

      with sel
         .Style = WdAppl.Application.ActiveDocument.Styles("Heading 2")
         .TypeText "Slide " & Count & ": " & titleName
         .TypeParagraph
      end with

      dim shapeIndex
      for shapeIndex = 1 to slideSections.Count
         ' Rest of the text for this slide
         dim aSection
         set aSection = slideSections.Item(shapeIndex)
         if (aSection.HasTextFrame) then
            with sel
               .TypeText aSection.TextFrame.TextRange.Text 
               .TypeParagraph
            end with
         end if
      next
   next
end SUB

<h2>array.vbs</h2>
' File: array.vbs
'
' Demonstrate very basic array functionality.

Option Explicit

dim i, j                      ' to be used for subscripting arrays

dim A(10)                     ' A has 11 elements: A(0) to A(10)
for i = 0 to 6
   A(i) = 2 * i 
next

' notice there are only have 6 entries in a size 11 array
call printOneArray(A, "This is the A Array")

dim B
B = Array(11, 22, 33, 44)
' This is the same as:  dim B(3) with setting 
'    B(0) = 11
'    B(1) = 22
'    B(2) = 33
'    B(3) = 44
call printOneArray(B, "This is the B Array")

' C is a 2-dimensional array, with 3 rows and 4 columns
' The first subscript is the row, second is column, 
' e.g., C(1,2) is the element in row 1, column 2
dim C(2, 3)
for i = 0 to 2
   for j = 0 to 3
      C(i,j) = i + j 
   next
next
call printTwoDArray(C, "This is the C Array")


'----------------------------------------------------------------------------
' printOneArray
' Takes in 2 input parameters, the array to display and a string which 
' is a description of what is displayed to be used as the MsgBox title. 
' It displays the contents of the array in message box titled description.
SUB printOneArray(ByRef myArray, ByRef description)
   dim output, i
   output = ""
   For i = 0 to UBound(myArray)
      output = output & "myArray(" & i & ") = " & myArray(i) & vbNewLine
   next

   ' concatenate lower and upper bound of the array
   output = output & "Array Lower Bound: " & LBound(myArray) & vbNewLine
   output = output & "Array Upper Bound: " & UBound(myArray) & vbNewLine

   MsgBox output, ,description
end SUB


'----------------------------------------------------------------------------
' printTwoDArray
' Takes in 2 input parameters, the 2D array to display and a string which 
' is a description of what is displayed to be used as the MsgBox title. 
' It displays the contents of the array in message box titled description.
SUB printTwoDArray(ByRef myArray, ByRef description)
   dim output, i, j
   output = ""
   for i = 0 to UBound(myArray, 1)
      for j = 0 to UBound(myArray, 2)
         output = output & "myArray(" & i & "," & j &") = " & _
                            myArray(i,j) & vbNewLine
      next
      output = output & vbNewLine
   next

   ' concatenate lower and upper bound of the array
   ' second parameter of LBound or UBound is the dimension
   output = output & "Array Row Lower Bound: " & LBound(myArray, 1) & vbNewLine
   output = output & "Array Row Upper Bound: " & UBound(myArray, 1) & vbNewLine
   output = output & "Array Col Lower Bound: " & LBound(myArray, 2) & vbNewLine
   output = output & "Array Col Upper Bound: " & UBound(myArray, 2) & vbNewLine

   MsgBox output, ,description
end SUB

<h2>arrayDynamic.vbs</h2>
' File: arrayDynamic.vbs
' Demonstrate dynamic arrays. 

Option Explicit

dim A(), B()            ' A and B have no memory allocated yet

redim A(3), B(5)        ' allocate 4 elements for A, 6 elements for B

call fillArrayWithMult2(A, 0, UBound(A))
call fillArrayWithMult2(B, 0, UBound(B))
call printOneArray(A, "This is the A Array with 4 values")
call printOneArray(B, "This is the B Array with 6 values")

' redimension A to be of size 11 and display
' notice different memory is allocated and you lose all the values
' of the original array A
redim A(10)
call printOneArray(A, "This is the A Array with 10 values, redimensioned")

' fill again and display
call fillArrayWithMult2(A, 0, UBound(A))
call printOneArray(A, "This is the A Array with 10 values, redimensioned")

' preserve the values in B by using "preserve" keyword
redim preserve B(10)
call printOneArray(B, "This is the B Array with 10 values, preserved")

' can fill some or the rest of B
call fillArrayWithMult2(B, 7, 9)
call printOneArray(B, "This is the B Array with 10 values, preserved and more")


'----------------------------------------------------------------------------
' fillArrayWithMult2:
'
SUB fillArrayWithMult2(ByRef myArray, ByVal beginIndex, ByVal endIndex)
   dim i
   for i = beginIndex to endIndex
      myArray(i) = 2 * i 
   next
end SUB


'----------------------------------------------------------------------------
' printOneArray
' Takes in 2 input parameters, the array to display and a string which 
' is a description of what is displayed to be used as the MsgBox title. 
' It displays the contents of the array in message box titled description.
SUB printOneArray(ByRef myArray, ByRef description)
   dim output, i
   output = ""
   for i = 0 to UBound(myArray)
      output = output & "myArray(" & i & ") = " & myArray(i) & vbNewLine
   next

   ' concatenate lower and upper bound of the array
   output = output & "Array Lower Bound: " & LBound(myArray) & vbNewLine
   output = output & "Array Upper Bound: " & UBound(myArray) & vbNewLine

   MsgBox output, ,description
end SUB

<h2>linearSearch.vbs</h2>
' File: linearSearch.vbs
'
' Open a text file to save names into an array.
' Open another text file to save grades into another array.
' Given a name to search for, display the grade.

Option Explicit

dim names(50)                ' holds names 
dim grades(50)               ' holds grades 

dim count                    ' total number of names, subscript 0 to count-1
dim count2                   ' used for filling array with grades
count = 0
count2 = 0

' Fill the names and grades arrays with data from text files that
' are opened in the subroutine. Display the two arrays in MsgBoxes.
call fillArray(names, count)
call fillArray(grades, count2)
call printOneArray(names, "The names")
call printOneArray(grades, "The grades")

dim targetName                        ' name to search for
dim foundGrade                        ' grade associated with name 

' For each name that is entered, locate the name in the names array,
' and display the associated grade from the grades array.
do 
   targetName = inputBox("Enter a name to search for [enter to quit]")
   if targetName = "" then
      exit do
   end if

   ' search the names array for targetName and return the associated grade
   foundGrade = gradeValue(targetName, names, grades, count)
   if foundGrade <> -1 then
      MsgBox(targetName & " has a grade of " & foundGrade)
   else
      MsgBox(targetName & " was not found in the list of names")
   end if
loop


'------------------------------------------------------------------------------
' gradeValue
' Given an array of names and an array of grades with the count of how 
' many are in the array, return the grade of the entered name.
' Return a -1 if the name is not found.
FUNCTION  gradeValue(ByVal targetName, ByRef names, ByRef grades, ByVal count)
   dim i, found
   i = 0
   found = FALSE                           ' have not found name yet
   gradeValue = -1

   ' Look for targetName as long as we are still within the bounds
   ' of the array and the name has not been found yet.
   do while i <= count and not found
      if names(i) = targetName then
         gradeValue = grades(i)
         found = TRUE
      end if
      i = i + 1
   loop
end FUNCTION   


'------------------------------------------------------------------------------
' fillArray
' Open a text file and read the data into an array.
' The count will be the true size of the array (number of elements in use).
SUB fillArray(ByRef myArray, ByRef count)

   ' ask the scripting runtime environemt for access to files
   dim FS 
   set FS = CreateObject("Scripting.FileSystemObject")

   const FILEFORREADING = 1
   dim dataFile
   dataFile = selectAFileOrFolder("FILE")

   if FS.FileExists(dataFile) then
      ' get the fileHander based on the dataFile
      dim FileHandler
      set FileHandler = FS.GetFile(dataFile)
   
      ' open the file as a inputTextStream so text data can be "streamed"
      dim inputTextStream
      set inputTextStream = FileHandler.OpenAsTextStream(FILEFORREADING)

      dim inputLine                         ' a line in the file

      ' As long as we're not at the end of the file, read a line from
      ' the file and place it into myArray.
      do while not inputTextStream.AtEndOfStream 
         inputLine = inputTextStream.ReadLine
         myArray(count) = inputLine 
         count = count + 1
      loop
   else
      MsgBox "File: " & dataFile & " does not exists."
   end if
end SUB


'----------------------------------------------------------------------------
' printOneArray
' Takes in 2 input parameters, the array to display and a string which 
' is a description of what is displayed to be used as the MsgBox title. 
' It displays the contents of the array in message box titled description.
SUB printOneArray(ByRef myArray, ByRef description)
   dim output, i
   output = ""
   For i = 0 to UBound(myArray)
      output = output & "myArray(" & i & ") = " & myArray(i) & vbNewLine
   next

   MsgBox output, ,description
end SUB


'------------------------------------------------------------------------------
' selectAFileOrFolder
' Takes in one input parameter, "FILE" or "FOLDER", and returns its path
' in a string that contains either the selected file or folder path.
FUNCTION selectAFileOrFolder(ByRef fileOrFolder)

   dim WshShell, currentFolder

   ' Open a "connection" to the "operating environment" .
   ' WshShell contains the environment for which we are operating in.
   ' For example, below we will use it to retrieve the current working folder.
   set WshShell = WScript.CreateObject("WScript.Shell")
   
   ' Get the current folder (where this script is opened from).
   ' currentFolder now contains the path to the folder 
   currentFolder = wshShell.CurrentDirectory
   
   ' XlAppl is our "connection" to all functions MS Excel provides
   dim XlAppl
   set XlAppl = WScript.CreateObject("Excel.Application")
    
   ' don't let user see what is going on,
   ' can switch the visibility of MSon/off (TRUE/FALSE)
   XlAppl.Application.Visible = FALSE

   ' specific constants to OFFICE Object. 
   ' VBScript cannot see these constants, so we have
   ' to find out what they are, and re-define them.
   dim msoFileDialogOpen
   if (fileOrFolder = "FILE") then
      msoFileDialogOpen = 1
   end if
   if (fileOrFolder = "FOLDER") then
      msoFileDialogOpen = 4
   end if
   
   ' OpenFile Dialog we use MSO facility, since MSO is implemented in either
   ' Word, Excel, even PowerPoint. It can be used in exactly the same way. 
   ' Notice "set" is used here too.
   dim DlgOpen   
   set DlgOpen = XlAppl.Application.FileDialog(msoFileDialogOpen)

   ' Only allow selection of one file
   ' TRUE:      Allow multiple file selection
   ' FALSE:   Do not allow multiple file selection
   DlgOpen.AllowMultiSelect = FALSE
   
   ' Set up the "Filters" so that we only work with certain types of files.
   '
   ' DlgOpen.Filters.Clear
   ' DlgOpen.Filters.Add "Text Files", "*.txt", 1
   ' Only want to work with Text files
   ' The parameters of Add are:
   '    1st - description of what is the file type
   '    2nd - the extension (don't forget the "*") 
   '    3rd - the position for this entry

   ' Start looking from current working folder
   ' currentFolder contains the path to the folder where this script is located
   DlgOpen.InitialFileName = currentFolder
   
   SelectAFileOrFolder = ""             ' Set the return value to ""

   if (DlgOpen.Show() = -1) then        ' -1 says user clicked on "Open"
      ' first selected item is the file name
      SelectAFileOrFolder = DlgOpen.SelectedItems(1)
   end if
   
   ' TRUE:    Prompt user to save the work
   ' FALSE:   Do not prompt user to save the work
   XlAppl.Application.DisplayAlerts = FALSE
   
   XlAppl.Application.Quit                  ' quit the application
end FUNCTION

<h2>names.txt</h2>
Joe
Sue
Andy
Sally
Jane
Bill
John
Mary

<h2>grades.txt</h2>
82
70
60
95
85
74
92
67


<h2>bubble.vbs</h2>

' File: bubble.vbs
'
' Sort a list of numbers using a bubble sort

Option Explicit

const MINVALUE = 0
const MAXVALUE = 1000

dim a(20)                   ' array to demonstrate bubble sort

' Initialize the random generation system of VB-script.
' After this call, Rnd will return a number between 0 and 1.
Randomize

call fillWithRandomNumbers(a, MINVALUE, MAXVALUE)
call printOneArray(a, "An unsorted array")

call bubbleSort(a)
call printOneArray(a, "A sorted array")


'----------------------------------------------------------------------------
' bubbleSort
' Sort the input array using a bubble sort
SUB bubbleSort(ByRef a())
   dim pass                               ' pass of the sort
   dim done                               ' whether sorted or not 
   dim i, temp

   pass = 0
   done = FALSE

   ' Each pass puts one element into its sorted position,
   ' smallest value bubbles to the top of the array.
   while not done 
      done = TRUE                         ' possibly sorted

      ' compare consecutive elements, swap if out of order
      for i = UBound(a) to pass+1 step -1
         if a(i) < a(i-1) then
            temp = a(i)                      ' swap a(i) and a(i-1)
            a(i) = a(i-1)
            a(i-1) = temp
            done = FALSE                     ' had to swap so still not sorted
         end if
      next
      pass = pass + 1
   wend

end SUB

'----------------------------------------------------------------------------
' printOneArray
' Takes in 2 input parameters, the array to display and a string which
' is a description of what is displayed to be used as the MsgBox title.
' It displays the contents of the array in message box titled description.
SUB printOneArray(ByRef myArray, ByRef description)
   dim output, i
   output = ""
   for i = 0 to UBound(myArray)
      output = output & "myArray(" & i & ") = " & myArray(i) & vbNewLine
   next

   MsgBox output, ,description
end SUB

'----------------------------------------------------------------------------
' RandomNumber
' Given two input parameters, a min value and max value for a range of numbers,
' it will generate and return random number between the parameter values.
FUNCTION RandomNumber(ByVal min, ByVal max)
   RandomNumber = CInt( ((max - min + 1) * Rnd) + min)
end FUNCTION

'----------------------------------------------------------------------------
' fillWithRandomNumbers
' Given an input array, fill it with random numbers generated by a
' random number generator.
SUB fillWithRandomNumbers(ByRef a, ByRef minValue, ByRef maxValue)
   dim index

   'continually generate random numbers to fill the array
   for index = 0 to UBound(a)
      a(index) = RandomNumber(minValue, maxValue)
   next
end SUB

<h2>list all available ProgIDs</h2>
The following VBScript code can be used to list all available ProgIDs:

Option Explicit

Const HKEY_CLASSES_ROOT = &H80000000

Dim arrProgID, lstProgID, objReg, strMsg, strProgID, strSubKey, subKey, subKeys()

Set lstProgID = CreateObject( "System.Collections.ArrayList" )
Set objReg    = GetObject( "winmgmts://./root/default:StdRegProv" )

' List all subkeys of HKEY_CLASSES_ROOT\CLSID
objReg.EnumKey HKEY_CLASSES_ROOT, "CLSID", subKeys

' Loop through the list of subkeys
For Each subKey In subKeys
	' Check each subkey for the existence of a ProgID
	strSubKey = "CLSID\" & subKey & "\ProgID"
	objReg.GetStringValue HKEY_CLASSES_ROOT, strSubKey, "", strProgID
	' If a ProgID exists, add it to the list
	If Not IsNull( strProgID ) Then lstProgID.Add strProgID
Next

' Sort the list of ProgIDs
lstProgID.Sort

' Copy the list to an array (this makes displaying it much easier)
arrProgID = lstProgID.ToArray

' Display the entire array
WScript.Echo Join( arrProgID, vbCrLf )



<h2>StdOut.Write</h2>
Echo text to the screen (Stdout)

Syntax 
      WScript.StdOut.Write("text string to display")
      WScript.StdOut.Write(strMyTextVariable)
Example
  Set objStdOut = WScript.StdOut
  objStdOut.Write "User: "
  objStdOut.Write "Joe Smith"
  objStdOut.WriteBlankLines(1)
  objStdOut.Write "Procurement Dept"

<h2>VBScript Do While Loop</h2>
Dim x
x=1
Do While x&lt;5
document.write("Welcome.")
x=x+1
Loop

Dim x
x=7
Do 
document.write("Welcome.")
x=x+1
Loop While x&lt;5

<h2>VBScript Do Until Loop</h2>
&lt;script type="text/vbscript">
Dim x
x=1
Do Until x=5
document.write("Welcome.")
x=x+1
Loop
&lt;/script>

<h2>VBScript While Loop</h2>
Dim x
x = 1   
While x &lt; 5   
document.write("Welcome.")
x=x+1
Wend  

<h2>VBScript For-Next Loop</h2>
For i = 1 To 5
  document.write("The number is " & i & "
")
Next

<h2>VBScript For-Step-Next Loop</h2>
For i = 1 To 5 Step 2
  document.write("The number is " & i & "&lt;br />")
Next

For i = 1 To 5 Step 2
  If i=3 Then Exit For
  document.write("The number is " & i & "&lt;br />")
Next

<h2>VBScript For-Each-Next Loop</h2>
Dim students(4)
students(0)="John"
students(1)="Hanah"
students(2)="Sarah"
students(3)="Kevin"
students(4)="Emma"

For Each x In students
  document.write(x & "&lt;br />")
Next
Dim name, length
name = InputBox("Enter your name")
length = Len(name)’Gives length of the input string

For i = 1 To length
  txt = Mid(name,i,1)'Returns a specified number of characters from a string, the first parameter is the string, second parameter is the starting position and third parameter is the number of characters to return
  If txt="a" or txt="A" or txt="e" or txt="E" or txt="i" or txt="I" or txt="o" or txt="O" or txt="u" or txt="U" Then 
  counter = counter+1
  End If
Next
document.write("Hi " & name & "!!!Your name contains " & counter & " vowels.")

<h2>Run a vbscript from another vbscript</h2>
<a href="https://stackoverflow.com/questions/1686454/run-a-vbscript-from-another-vbscript" class="whitebut ">Run a vbscript from another vbscript</a>

CreateObject("WScript.Shell").Run "Your-VBScript-Here"

Dim objShell
Set objShell = Wscript.CreateObject("WScript.Shell")
objShell.Run "TestScript.vbs" 

' Using Set is mandatory
Set objShell = Nothing

<h2>Show time</h2>
Show time in form 24 hours
Right("0" & hour(now),2) & ":" & Right("0" & minute(now),2)   = 01:35
Right("0" & hour(now),2)                                      = 01
Right("0" & minute(now),2)                                    = 35

FormatDateTime(Now)                = 2/29/2016 1:02:03 PM
FormatDateTime(Now, vbGeneralDate) = 2/29/2016 1:02:03 PM
FormatDateTime(Now, vbLongDate)    = Monday, February 29, 2016
FormatDateTime(Now, vbShortDate)   = 2/29/2016
FormatDateTime(Now, vbLongTime)    = 1:02:03 PM
FormatDateTime(Now, vbShortTime)   = 13:02
FormatDateTime(now, 4)             = 08:12

Year(Now)   = 2016
Month(Now)  = 2
Day(Now)    = 29
Hour(Now)   = 13
Minute(Now) = 2
Second(Now) = 3

Year(Date)   = 2016
Month(Date)  = 2
Day(Date)    = 29

Hour(Time)   = 13
Minute(Time) = 2
Second(Time) = 3

Function LPad (str, pad, length)
    LPad = String(length - Len(str), pad) & str
End Function

LPad(Month(Date), "0", 2)    = 02
LPad(Day(Date), "0", 2)      = 29
LPad(Hour(Time), "0", 2)     = 13
LPad(Minute(Time), "0", 2)   = 02
LPad(Second(Time), "0", 2)   = 03

Weekday(Now)                     = 2
WeekdayName(Weekday(Now), True)  = Mon
WeekdayName(Weekday(Now), False) = Monday
WeekdayName(Weekday(Now))        = Monday

MonthName(Month(Now), True)  = Feb
MonthName(Month(Now), False) = February
MonthName(Month(Now))        = February

Set os = GetObject("winmgmts:root\cimv2:Win32_OperatingSystem=@")
os.LocalDateTime = 20131204215346.562000-300
Left(os.LocalDateTime, 4)    = 2013 ' year
Mid(os.LocalDateTime, 5, 2)  = 12   ' month
Mid(os.LocalDateTime, 7, 2)  = 04   ' day
Mid(os.LocalDateTime, 9, 2)  = 21   ' hour
Mid(os.LocalDateTime, 11, 2) = 53   ' minute
Mid(os.LocalDateTime, 13, 2) = 46   ' second

Dim wmi : Set wmi = GetObject("winmgmts:root\cimv2")
Set timeZones = wmi.ExecQuery("SELECT Bias, Caption FROM Win32_TimeZone")
For Each tz In timeZones
    tz.Bias    = -300
    tz.Caption = (UTC-05:00) Eastern Time (US & Canada)
Next

<h2>inputbox</h2>
dim v
v = inputbox ("what is ur name?")
msgbox " hello, " & v
beep

to beep multiple times
Beeep(3)

Sub Beeep(itimes)
dim itemp
For itemp = 1 to itimes
beep
next
end sub



<h2>Play a beep in VBS</h2>
From Windows Scripting Host you can do either one of the below:

Set Shell = CreateObject("WScript.Shell")
Shell.Run "sndrec32 /play /close %windir%\media\ding.wav",0

or
Set Shell = CreateObject("WScript.Shell")
Shell.Run "%comspec% /cecho " & Chr(7),0

or
strSoundFile = “C:\Windows\Media\Notify.wav”
Set objShell = CreateObject(“Wscript.Shell”)
strCommand = “sndrec32 /play /close ” & chr(34) & strSoundFile & chr(34)
objShell.Run strCommand, 0, True


To run Sound Recorder from the command-prompt, we need to type in this command:
sndrec32 /play /close “C:\Windows\Media\Notify.wav”

Sample script that plays a sound and pops up a message box:

strSoundFile = “C:\windows\Media\Notify.wav”
Set objShell = CreateObject(“Wscript.Shell”)
strCommand = “sndrec32 /play /close ” & chr(34) & strSoundFile & chr(34)
objShell.Run strCommand, 0, False
Wscript.Sleep 1000
Msgbox “A problem has occurred.”




<br>
<br>
<br>
<br>

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({ elements_selector: ".lazy"});
</script>

</pre>
</body>
</html>
