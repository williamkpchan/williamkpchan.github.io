<base target="_blank"><html><head><title>alligatorIoJs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
  var showTopicNumber = true;
  var bookid = "alligatorIoJs"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>alligatorIoJs</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>

<h2>Binary Heaps and Priority Queues via JavaScript</h2>

While I'm sure we can all agree that <a href="https://alligator.io/js/stacks-queues/">queues</a> are the coolest things since sliced bread, we can actually do much better by mixing them with a variation of <a href="https://alligator.io/js/trees/">trees</a> called heaps. 
With heaps we can structure our data into a more intelligent queue that's sorted by importance rather than order.

<h3>Concepts</h3>
Unlike with <a href="https://alligator.io/js/binary-search-trees/">binary search trees</a>, where we compared and organized our values across siblings, with heaps we only work between parents and their children. 
This gives us two possibilities for heaps, the <code>max heap</code> and the <code>min heap</code>, for whether you're moving from the highest to the lowest values or vice versa. 
For simplicity's sake, we're only going to focus on the max heap, since it's so easy to convert it to a min heap.

Like with binary search trees, binary heaps are only allowed to have two or fewer children to a parent. 
They are also special since they are always balanced because every new node will be added to a level from left to right until full.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/778bd9437204bdd6dcbc13c4b6040bfc7e49c6e5/b29cb/images/js/binary-heaps/binary-heap-tree.png">

Sadly, <a href="https://alligator.io/js/linked-lists-overview/">linked-lists</a> generally aren't the best approach for binary heaps, despite being usually conceptualized as a tree with left and right children, although it's still possible.

Most of the time it's going to be better to handle it as an array, so that's what we're going to cover here. 
The order is as you'd expect with everything left to right on a level before moving to the next level.

This way, we create a very consistent pattern for finding a node's children. 
All of a node's left children will be exactly at a position <code>2n + 1</code> away from their parent, with <code>n</code> being their parent's index, and all right children being <code>2n + 2</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7b96dfaea2a505cc52fc874e978fe34e030197a5/40fff/images/js/binary-heaps/binary-heap-array.png">

<h3>Add Node</h3>
It would seem like adding a new node would be as simple as pushing onto our array, but the tricky part is that we need to compare it with the parents in between itself and the max, then re-order them accordingly.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6304667536823e4543284e2427cbe88b7de7101c/e06f4/images/js/binary-heaps/binary-heap-add-node.gif">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
After we push our new item onto the end of the array we'll need to “bubble up” our larger values. 
First, we need to grab the new item at the end of the array, which we'll break into the index and the new item at that index.

Every time we add an item we're going to use the reverse of our equation for finding children, <code>(n-1)/2</code>, to find its parent. 
If its parent is less than the current node, swap them then save its index which will be the next <code>current</code>. 
This will continue until there are no parents left.

Since it will gradually be moving our <code>index</code> up from the end, as long as it's greater than zero, keep swapping.

<code>class BH {
 constructor() {
   this.values = [];
 }
 add(element) {
   this.values.push(element);
   let index = this.values.length - 1;
   const current = this.values[index];

   while (index > 0) {
     let parentIndex = Math.floor((index - 1) / 2);
     let parent = this.values[parentIndex];

     if (parent &lt;= current) {
       this.values[parentIndex] = current;
       this.values[index] = parent;
       index = parentIndex;
     } else break;
   }
 }
}

const tree = new BH();
tree.add(3);
tree.add(4);
tree.add(31);
tree.add(6);
console.log(tree); // [31, 6, 4, 3]</code>

<h3>Remove Max</h3>
Removing the topmost node is a bit more complicated than you would think. 
We're going to return the first node, our max, then take the last node, the end of our array, and set that as the new max.

We do that so we can use our lowest value as an easy baseline to compare with our other values as we “sink down” back to the bottom of the tree while making our comparisons and swaps along the way.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/57b1bd4f8443e962e37c1f78f306e385539bfaaf/4a91a/images/js/binary-heaps/binary-heap-remove-max.gif">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
The simple part is grabbing our current max value and popping it off before replacing it with the last item, then we can return our original max value after everything else is done.

Once we have a starting index, we want to grab both its right and left children. 
If the left child is a valid item and is larger, then we can save it as <code>swap</code> to run the swap when all the comparisons are done.

The right child is a bit more complicated, we only want one, and the largest, child to be swapped with the parent. 
We'll add a separate requirement that <code>rightChild</code> can only be set as <code>swap</code> if it hasn't been defined yet or it's larger than <code>leftChild</code>.

<code>class BH {
 extractMax() {
   const max = this.values[0];
   const end = this.values.pop();
   this.values[0] = end;

   let index = 0;
   const length = this.values.length;
   const current = this.values[0];
   while (true) {
     let leftChildIndex = 2 * index + 1;
     let rightChildIndex = 2 * index + 2;
     let leftChild, rightChild;
     let swap = null;

     if (leftChildIndex &lt; length) {
       leftChild = this.values[leftChildIndex];
       if (leftChild > current) swap = leftChildIndex;
     }
     if (rightChildIndex &lt; length) {
       rightChild = this.values[rightChildIndex];
       if (
         (swap === null &amp;&amp; rightChild > current) ||
         (swap !== null &amp;&amp; rightChild > leftChild)
       )
         swap = rightChildIndex;
     }

     if (swap === null) break;
     this.values[index] = this.values[swap];
     this.values[swap] = current;
     index = swap;
   }

   return max;
 }
}

const tree = new BH();
tree.add(3);
tree.add(4);
tree.add(31);
tree.add(6);
console.log(tree.extractMax()); // 31</code>

<h3>Priority Queues</h3>
With a few minor tweaks we can mix binary heaps with queues and create a type of queue that organizes our data by importance rather than when it was added.

We can achieve this simply enough by storing nodes instead of single numbers. 
Each node will have a priority level (let's say from 1-5), which it will use to determine the order. 
When the priorities on two nodes are the same, the left child, since it will have been added first, will go first.

All we have to do is use the node's <code>priority</code> every time we make a comparison in an <code>if</code> statement.

<code>class Node {
 constructor(val, priority) {
   this.val = val;
   this.priority = priority;
 }
}

class PQ {
 constructor() {
   this.values = [];
 }
 enqueue(val, priority) {
   let newNode = new Node(val, priority);
   this.values.push(newNode);
   let index = this.values.length - 1;
   const current = this.values[index];

   while (index > 0) {
     let parentIndex = Math.floor((index - 1) / 2);
     let parent = this.values[parentIndex];

     if (parent.priority &lt;= current.priority) {
       this.values[parentIndex] = current;
       this.values[index] = parent;
       index = parentIndex;
     } else break;
   }
 }
 dequeue() {
   const max = this.values[0];
   const end = this.values.pop();
   this.values[0] = end;

   let index = 0;
   const length = this.values.length;
   const current = this.values[0];
   while (true) {
     let leftChildIndex = 2 * index + 1;
     let rightChildIndex = 2 * index + 2;
     let leftChild, rightChild;
     let swap = null;

     if (leftChildIndex &lt; length) {
       leftChild = this.values[leftChildIndex];
       if (leftChild.priority > current.priority) swap = leftChildIndex;
     }
     if (rightChildIndex &lt; length) {
       rightChild = this.values[rightChildIndex];
       if (
         (swap === null &amp;&amp; rightChild.priority > current.priority) ||
         (swap !== null &amp;&amp; rightChild.priority > leftChild.priority)
       )
         swap = rightChildIndex;
     }

     if (swap === null) break;
     this.values[index] = this.values[swap];
     this.values[swap] = current;
     index = swap;
   }

   return max;
 }
}

const tree = new BH();
tree.enqueue(3, 2);
tree.enqueue(4, 5);
tree.enqueue(31, 1);
tree.enqueue(6, 3);
console.log(tree.dequeue()); // 4
console.log(tree.dequeue()); // 6
console.log(tree.dequeue()); // 3
console.log(tree.dequeue()); // 31</code>

<h3>Closing Thoughts</h3>
Just like how we used standard queues for <a href="https://alligator.io/js/tree-traversal/">tree traversal</a> priority queues will be essential for intelligently traversing graphs and more complicated structures.

Converting a max heap to a min heap is as simple as changing our greater than to less than sign in all of our comparisons.

<h2>Mutable Immutable JavaScript</h2>

When I first dived into JavaScript and programming; I never really thought about immutable data. 
I would say animal is panda, then animal is lion.

<code>var animal = 'panda';
animal = 'lion';</code>

I was free to do whatever I wanted with my data! But… things changed… I grew up. 
People started telling me: “you should always <a href="https://alligator.io/js/let-const-variables-es6/">use const</a> if you can”. 
So I obediently did. 
But I didn't really understand why.

<h3>Why Use Immutable Data</h3>
Because sometimes code changes things you don't want to be changed. 
That's a very lame answer I know, let me show you with an example.

Let's say we have an e-commerce site.

Module: checkout.js

<code>// First we import a function called validate address to check if our users entered a valid address
import validateAddress from 'address-validator'

const checkout = (user, cart) => {
//... 
checkout code

var userAddress = user.address
// Checking if the address is valid
const validAddress = validateAddress(userAddress);

// If the address is valid then
if (validAddress) {
 //... 
proceed to checkout
}
}
</code>

Let's say we got our address-validator by installing an <code>npm</code> package.

<code>$ npm install address-validator</code>

Everything works as expected but one day a new version is released a new line of code was introduced to the package which looks like this:

Module: validateAddress.js

<code>const validateAddress = (address) => {
address = '123 My Street, Bring Me Free Goods, USA';
return true;
}</code>

Now the variable <code>userAddress</code> will always be equal to the value of address! You can see how this is a problem.

This specific issue can be solved by using immutability. 
But it can also be solved with proper scoping. 
Try to figure out how!

Of course, malicious code is an edge case. 
But there are many ways in which immutable data can help you write better code. 
For example, a very common mistake is to accidentally mutate the property of an object.

Module: accidental-change.js

<code>const userJack = {name: 'Jack Misteli'};
// I want to make a copy of user to do stuff with it
const user2 = userJack
user2.name = 'Bob'

// Because we didn't do a copy:
// userJack.name === 'bob'</code>

This type of mistake can occur very often.

<h3>Immutability Tools</h3>
The most intuitive immutability tool is to use <code>const</code>.

<code>const animal = 'panda';

// This will throw a TypeError!
panda = 'lion';</code>

<code>const</code> is great. 
However, it sometimes only gives the illusion of immutability!

Module: example-checkout.js

<code>const user = {
name: 'Jack Misteli',
address: '233 Paradise Road',
bankingInfo: 'You wish!'
};

const maliciousAddressValidator = (user) => {
user.address = 'Malicious Road';
return true;
};

const validAddress = maliciousAddressValidator(user);
// Now user.address === 'Malicious Road' !!</code>

There are different ways to solve this problem and introducing immutability is one of them.

First we can use the <a href="https://alligator.io/js/const-vs-obj-freeze/"><code>Object.freeze</code> method</a>.

<code>const user = {
address: '233 Paradise Road'
};
Object.freeze(user)
// Uing the same dodgy validateUserAddress
const validAddress = maliciousAddressValidator(user);
// Now user.address === '233 Paradise Road' !!</code>

One issue with <code>Object.freeze</code> is that you don't affect sub-properties. 
To reach all sub-properties you can write something like:

<code>const superFreeze = (obj) => {
Object.values(obj).forEach(val =>{
 if (typeof val === 'object')
   superFreeze(val)
 })
 Object.freeze(obj)
}</code>

Another solution is to use proxies if you need flexibility.

<h3>Using Property Descriptors</h3>
In many sites, you will see that you can modify property descriptors to create immutable properties. 
And that's true, but you have to make sure that <code>configurable</code> and <code>writeable</code> are set to false.

<code>// Setting up a normal getter
const user = {
get address(){ return '233 Paradise Road' },
};
console.log(Object.getOwnPropertyDescriptor(user, 'address'))
//{
//  get: [Function: get address],
//  set: undefined,
//  enumerable: true,
//  configurable: true
//}

const validAddress = maliciousAddressValidator(user);

// It looks like our data is immutable!
// user.address ===  '233 Paradise Road'
</code>

But the data is still mutable, it is just more difficult to mutate it:

<code>const maliciousAddressValidator = (user) => {
// We don't reassign the value of address directly
// We reconfigure the address property
 Object.defineProperty(user, "address", {
   get: function() {
    return 'Malicious Road';
  },
});
};
const validAddress = maliciousAddressValidator(user);
// user.address === 'Malicious Road'</code>

Arr!

If we set writable and configurable to false we get:

<code>const user = {};
Object.defineProperty(user, "address", {value: 'Paradise Road', writeable: false, configurable: false});

const isValid = maliciousAddressValidator(user)
// This will throw:
// TypeError: Cannot redefine property: address</code>

<h3>Immutable Arrays</h3>
Arrays have the same problem as Objects.

<code>const arr = ['a','b', 'c']
arr[0] = 10
// arr === [ 10, 'b', 'c' ]</code>

Well you can use the same tools we used above.

<code>Object.freeze(arr)
arr[0] = 10
// arr[0] === 'a'

const zoo = []
Object.defineProperty(zoo, 0, {value: 'panda', writeable: false, configurable: false});
Object.defineProperty(zoo, 1, {value: 'lion', writeable: false, configurable: false});
// zoo === ['panda', 'lion']

zoo[0] = 'alligator'
// The value of zoo[0] hasn't changed
// zoo[0] === 'panda</code>

<h3>Other Methods</h3>
There are other tricks to keep your data safe. 
I highly recommend checking out <a href="https://alligator.io/js/proxy-traps/">our article about Proxy Traps</a> to find out other ways to make your data immutable. 
We only scratched the surface here.

In this post, we explored options to introduce immutability without changing the structure and style of our code. 
In future posts, we will explore libraries such as Immutable.js, Immer or Ramda to right immutable code.


<h2>A Brief Tour of the Eleventy Static Site Generator</h2>

Static site generators are very <em>à la mode</em> right now and with the <a href="https://jamstack.org/">JAMStack</a> becoming a more-than-viable alternative for many web projects these days, it's no wonder!

JAMStack or not, static site generators (SSGs) offer some major advantages over more traditional CMSs, and when it comes to SSGs, there are <a href="https://www.staticgen.com/">plenty of options to choose from</a>. 
Jekyll, Hugo, Gatsby, Next.jst, Sapper,… Oh my!

I was recently shopping around to see what would be my best static site generator option for a project of mine called <a href="https://spiral11.com/">Spiral11</a>. 
I was first leaning towards Gatsby because it packs some modern goodies like image optimization, but then I looked further at Eleventy and fell in love.

11ty is easy to use, doesn't get in your way and spits out exactly what you put in, so there's no surprise or hidden code bloat. 
At its most basic, 11ty just compiles files it finds from your working directory into static HTML files. 
Plus, since it's written in JavaScript, you gain access to the whole of <code>npm</code> in terms of packages you can use in your project.

Let's take a tour and see how it works…

<h3>Eleventy Site Setup</h3>
Start by installing Eleventy globally on your machine using npm or Yarn:

<code># with npm
$ npm install -g @11ty/eleventy

# with Yarn
$ yarn global add @11ty/eleventy</code>

Now you can run the <code>eleventy</code> command in any directory that contains valid template files.

For example, say we have a directory called <code>best-site-ever</code>, with an <code>index.md</code> file in it:

index.md

<code>## Chomp Chomp **Chomp** </code>

You can now run <code>eleventy</code> in that directory, you'll see that Eleventy creates a <code>_site</code> directory with an <code>index.html</code> file in it that contains what we expect:

_site/index.html

<code>&lt;h3>Chomp Chomp &lt;strong>Chomp&lt;/strong> &lt;/h3></code>

Speaking of template languages, you have plenty of options. 
You can use Markdown, Nunjucks, Liquid, Mustache,… And you can mix and match, so you can have some files written in Liquid and some in Nunjucks and Eleventy will handle everything just fine.

<h3>eleventy command options</h3>
The <code>eleventy</code> command also accepts a few useful flags. 
For example:
<li>
<em>–watch</em>: Rewrite output files when any of your project files change.</li><li>
<em>–serve</em>: Serve the outputted site via a local web server and watch for changes.</li><li>
<em>–dryrun</em>: Test out the processing without actually outputting any files.</li><li>
<em>–output</em>: Specify a different output location.</li>

That means that very often, when working locally, you'll want to serve and rebuild on changes with the following command:

<code>$ eleventy --serve</code>

<h3>Directory Structure</h3>
With Eleventy you're not only free to choose your favorite template language, but you can also choose your own directory structure.

Say we have another markdown file in our project, but this time it's in two nested sub-directories:

/one/two/blog-post.md

<code>One day *I will write* my 1st blog post!</code>

Now if we run <code>eleventy</code>, the output in <code>_site</code> will look like this:

<code> _site/
 index.html
  one/
    two/
      blog-post/
       index.html</code>

So you'll notice that the directory structure is kept, that the file name is used as the slug/URI and that Eleventy creates a directory for each outputted template with an index.html file within it which contains the HTML output.

What if we wanted our files organized in directories that are reflected differently in the final output? Easy, we can just specify the permalink for a particular template inside a front matter section at the top.

/one/two/blog-post.md

<code>---
permalink: '/blog-post/'
---

One day *I will write* my 1st blog post!</code>

Just run <code>eleventy</code> again and you'll now see that now <code>blog-post</code> appears at the root level in <code>_site</code>. 
This way, specifying a permalink allows you full flexibility.

<h3>Front matter</h3>
Speaking of front matter, you can put all sorts of metadata in it, which will then be available to layouts (more on that later). 
It's in the front matter, for example, that you'll specify things like the title, meta description/excerpt and tags for a post, and most of the keys can be named whatever you'd like.

Here's an example to illustrate:

/one/two/blog-post.md

<code>---
title: "My first blog post "
date: 2020-04-02
excerpt: "This post talks about how one day I'll write a 1st post."
permalink: '/blog-post/'
emotion: happy
tags:
 - blog
 - getting-started
---

One day *I will write* my 1st blog post!</code>

<h3>Collections</h3>
I won't go too deep on the topic here, and I invite you to <a href="https://www.11ty.dev/docs/collections/">read the docs</a> to learn more, but Eleventy uses the tags you provide in the front matter to populate collections, which can be iterated over in other templates like, say, category pages.

There's also a special collection called <code>all</code> which by default includes every single post. 
With the <code>all</code> collection, you may end up with something like a sitemap that includes posts/pages you don't want, so there's an easy way to opt out of having a post or page included in collections:

<code>---
eleventyExcludeFromCollections: true
---</code>

<h3>Layouts</h3>
So far what we've done is just output HTML from the markdown files we've created. 
Most of the time though such markdown files should be wrapped in a layout to provide things like the boilerplate HTML, header, navigation bar, sidebar and footer.

By default layout templates should live in the <code>_includes</code> directory.

Let's create some sample layouts using Nunjucks syntax. 
One will be the default layout with our HTML boilerplate and the other one will be our blog layout:

_includes/default.njk

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
 &lt;meta charset="UTF-8">
 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
 &lt;title>{{ title }} | My Site&lt;/title>
&lt;/head>
&lt;body>
  {{ content | safe }}
&lt;/body>
&lt;/html></code>

_includes/blog.njk

<code>---
layout: default
---

&lt;h1>{{ title }}&lt;/h1>
&lt;div>
 Published on {{ date }}
&lt;/div>

&lt;article>
 {{ content | safe }}
&lt;/article></code>

<hr>
As you can see, a layout can call another layout and our layouts can access the data that's in the front matter of our regular template files.

We can use a layout by specifying it in the front matter of any of our content templates:

<code>---
layout: blog.njk
title: "My first blog post "
date: 2020-04-02
excerpt: "This post talks about how one day I'll write a 1st post."
---

One day *I will write* my 1st blog post!</code>

<h3>Eleventy Configuration</h3>
So far we've done everything without even touching a configuration file, and it goes to show the simplicity of using Eleventy. 
But as your website gains in complexity, you'll surely want to be able to set some configuration options. 
You can do that in an <code>.eleventy.js</code> file at the root of your project.

Here's a sample configuration file which copies our static assets to the output directory and specifies a different output directory name (<code>public</code>):

.eleventy.js

<code>module.exports = eleventyConfig => {
 // Copy our static assets to the output folder
 eleventyConfig.addPassthroughCopy('css');
 eleventyConfig.addPassthroughCopy('js');
 eleventyConfig.addPassthroughCopy('images');

 // Returning something from the configuration function is optional
 return {
   dir: {
     output: 'public'
   }
 };
};</code>

You can do all sorts of things in your config file like minifying the HTML output, using plugins and configuring shortcodes. 
Again, I invite you to <a href="https://www.11ty.dev/docs/config/">look at the docs</a> to learn more about what can be configured. 
But if you start to get overwhelmed at first, just remember that by default Eleventy doesn't even need a config file and can do most of the heavy lifting without one.

<h3>Using a Starter</h3>
So far we've been creating a site from scratch to see how things work, but often you'll want to get started with a good base that's already configured and/or styled in a way that you like. 
You can browse through a <a href="https://www.11ty.dev/docs/starter/">list of 11ty starters here</a>.

I personally really like the <a href="https://skeleventy.netlify.com/">Skeleventy starter</a>, which uses <a href="/css/tailwind-css/">Tailwind CSS</a> for styling and is configured with <a href="https://purgecss.com/">PurgeCSS</a> to get rid of unused styles in production. 
If you're starting a blog, the official <a href="https://github.com/11ty/eleventy-base-blog">Eleventy blog starter</a> would also be a great place to start.

<h3>Learning More</h3>
 That's it for this brief introduction, but I invite you to learn more by checking out these resources:
<li><a href="https://www.11ty.dev/docs/">The official docs</a></li><li>
<a href="https://www.youtube.com/watch?v=j8mJrhhdHWc">This Learn With Jason episode</a> with <a href="https://twitter.com/zachleat">Zach Leatherman</a>, the creator of Eleventy</li>


<h2>How to Detect Idle Browser Tabs with the Page Visibility API</h2>

Do you ever wonder if background tabs/windows are using battery power, or precious CPU time? Using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">Page Visibility API</a>, we can detect when users aren't viewing/interacting with our website to help them save precious computing resources! 

The <em>Page Visibility API</em> was introduced in 2011, and includes several features that were added to the <em>Document</em> object:
<li>
<em>document.hidden</em>: a read-only attribute that returns <code>true</code> when the tab/window is hidden</li><li>
<em>document.visibilityState</em>: a read-only attribute that returns a string value denoting the state of the tab/window: <code>'hidden' | 'visible' | 'prerender'</code>
</li><li>
<em>visibilitychange</em>: an event that's emitted whenever the tab/window's visibility changes</li>

The added benefit of using <em>visibilityState</em> over <em>hidden</em> is that you're able to identify when the browser is in “prerender” phase (eg., when the website is still loading).

Let's look at some examples that use Page Visibility API!

<h3>Practical Example #1</h3>
In this example, we pause the video's playback whenever the tab/window is hidden. 
This is something that you'll see many websites do to prevent users from wasting their network bandwidth.

It uses a simple HTML5 <em>&lt;video></em> embed:

<code>&lt;video id="my-video">
 &lt;source id='mp4' src="cartoon.mp4" type='video/mp4'/>
&lt;/video></code>

Now let's subscribe to the <code>visibilitychange</code> event to automatically pause/play the video:

<code>const onVisibilityChange = () => {
 const video = document.getElementById("my-video");
 return document.hidden
   ? video.pause()
   : video.play();
}

document.addEventListener("visibilitychange", onVisibilityChange);</code>

It's that simple! For non-mobile users, try out the demo below! Click to play the video, then switch tabs:

See the Pen <a href="https://codepen.io/alligatorio/pen/xxGybyM"> Page Visibility API Demo</a> by wle8300 (<a href="https://codepen.io/wle8300">@wle8300</a>) on <a href="https://codepen.io">CodePen</a>.

<h3>Practical Example #2</h3>
The Page Visibility API isn't just for optimizing battery/CPU resources (eg., performance optimization). 
You could use it for  UX enhancement. 


As a quick example, if the user is viewing another tab/window you could use the opportunity to download the remainder of the app's bundle using <a href="https://webpack.js.org/api/module-methods/#import-1">Webpack's dynamic import()</a>:

<code>let loaded = false;
const onVisibilityChange = () => {
 if (!loaded &amp;&amp; document.visibilityState === 'visible') {
   Promise.all([
     import('./lodash'),
     import('./moment'),
     import(/* webpackChunkName: "bundle-[index]"*/ './dist'),
     import(/* webpackPrefetch: 0 */ './images')
   ]).then(() => {
     loaded = true;
   });
 }
};

document.addEventListener('visibilitychange', onVisibilityChange);</code>

Since the browser will cache these assets, the user will have the entire app loaded once they return to the tab/window. 
This minimizes any lag that might have occurred as they navigated your app.

<h3>Conclusion</h3>
A great UX doesn't necessarily mean building innovative features, or captivating animations. 
Sometimes showing the user that we're thinking about them even when they aren't using our webpage can make more of an impression!  

I hope you'll find great ways to use the Page Visibility API to build these optimizing/enhancing strategies!

Visit MDN for documentation on the <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API" alt="link to mdn">Page Visibility API</a>

<h2>What Are Cookies &amp; How to Work With Them Using JavaScript</h2>

   not quite…  Better! The cookie  is one of the web's favorite emoji and it's also one of web's most important technology.

Let's take a look at what it's all about, shall we?

<h3>The Basics of Browser Cookies</h3>
Browser cookies were introduced to the web in order to keep persistent information about the user. 
The first use case was to check if a user had already visited Netscape's website.

Cookies are strings that have a name field, a value field and additional optional attributes. 
The values are strings and you can store whatever you think is best for your application. 
Google Analytics' <code>_ga</code> is probably <code>one of || the</code> most common cookie out there, it usually looks like this:
<li>
<strong>Name</strong>: _ga</li><li>
<strong>Value</strong>: GA1.3.210706468.1583989741</li><li>
<strong>Domain</strong>: .example.com</li><li>
<strong>Path</strong>: /</li><li>
<strong>Expires / Max-Age</strong>: 2022-03-12T05:12:53.000Z</li>

Cookies can store up to 4096 bytes of data (this includes name, value, domain, expiry date and whatever else you can fit in there). 
You can add a limited number of cookies per domain which changes depending on your browser.

<h3>How Are Cookies Created</h3>
There are two main ways to create cookies:
<li>With <em>HTTP</em> you can send <code>Set-Cookie</code> in your HTTP response header. 
Depending on the technologies you are using for your web server; you can use different tools and libraries to manage cookie headers. 
These tools should create HTTP responses which will roughly look like this:</li>
<code>HTTP/2.0 200 OK
Content-type: text/html
Set-Cookie: alligator_name=barry
Set-Cookie: tasty_cookie=strawberry
... 
More http Content</code>

You can add information to your cookies like an expiration date, and security features such as the <em>Secure</em> directive and the <em>HttpOnly</em> flag.

<code>Set-Cookie: cookie_name=cookie_value; Expires=Wed, 17 Sep 2021 07:00:00 GMT; Secure; HttpOnly</code>

The <em>HttpOnly</em> flag means that the cookies cannot be read or modified by the browser. 
And Secure means that the cookie can only be transferred over HTTPS. 
These are really important to protect your application.
<li>With <em>Javascript</em> it's a bit trickier to manage Cookies. 
We have one interface, <code>document.cookie</code>, which stores our cookies and can be reassigned. 
For example on a site that has Google Analytics installed, and in the developer console, we can do:</li>
<code>console.log(document.cookie)
// logs something like "_ga=GA1.3.210706468.1583989741; _gid=GA1.3.1734708005.1583989741"

// This equal sign does not work as you expect
document.cookie = "alligator=alligator_cookie_content;"
console.log(document.cookie)
// logs "_ga=GA1.3.210706468.1583989741; _gid=GA1.3.1734708005.1583989741; alligator=alligator_cookie_content"
// Notice that the previous piece of code appends the new cookie we created

// A rough implementation of a cookie interface could look like this:
const createCookie = (name, value) => document.cookie = name + '=' + value + ';'
// For a real update we would first check if the cookie exists
const updateCookie = (name, value) => document.cookie = name + '=' + value + ';'
const deleteCookie = (name) => document.cookie = name + '=; Max-Age=-1;';  </code>

<h3>Types of Cookies</h3>
<h3>Session cookies</h3>
Session cookies often refer to a type of cookie that exist until the browser is closed. 
To setup a session cookie you just need to NOT specify any expiration date.

For example, you can store your user's name in the cookie. 
Whoever has access to the cookie will have access to the user's name. 
Since it is in the cookie we don't need to add it to our requests.

<code>Session cookies</code> is a confusing expression. 
Session cookies also refer to cookies which you use to manage sessions. 
Cookies that are deleted when the browser is closed are not the only cookies you can use for session management.

<h3>Persistent cookie</h3>
Persistent cookies are not deleted by the browser when the user closes it. 
These cookies have an expiration date that you can set in your server. 
You can set a cookie to expire in a day or ten years.

<h3>Third-party cookie</h3>
We can differentiate cookies that are on the same domain from cookies which come from third-party providers. 
The example we gave earlier with Google Analytics is an example of a third-party cookie. 
Third-party cookies can be used to track user activities. 
To set a third-party cookie, you have to set <code>';domain=thirdpartydomain.com'</code>.

<h3>Cookie Max-Age vs Expire</h3>
Cookies are usually temporary, so you might want to set a precise expiry date. 
You have two strategies:
<li>Use <code>Expires</code> and set a fixed expiration date. 
The date uses the HTTP date formate: <code>&lt;day-name>, &lt;day> &lt;month> &lt;year> &lt;hour>:&lt;minute>:&lt;second> GMT</code>. 
So for example if we want our cookie to expire September 17 2020 we can do:</li>
<code>const jacksBirthday = new Date(2020, 8, 17);
document.cookie = 'jacksage=27; expires =' + jacksBirthday.toUTCString() + ';';</code>
<li>Using ‘Max-Age' is not supported by every browser. 
But it's the soundest solution. 
It forces the cookie to expire a certain amount of time (in seconds) after the client receives it:</li>
<code>// Expires after one day
const oneDayToSeconds = 24 * 60 * 60;
document.cookie =  'daily_cookie=session_identifierXYZ; max-age = ' + oneDayToSeconds + ';';</code>

 That's about it! I hope you now have a better idea of how to use cookies on the client side with JavaScript. 
If you have any question ask us on Twitter. 
Next time, we will see how to manage sessions with cookies and Express.js.


<h2>Quick Tour of date-fns, a Simple JavaScript Date Library</h2>

<a href="https://alligator.io/js/date-object/">Working with dates in JavaScript</a> isn't easy. 
That's why if you look at the <a href="/nodejs/package-json/">package.json</a> files of most apps, you'll usually find a library like <a href="https://alligator.io/js/time-manipulations-momentjs/">Moment.js</a> in there.

<a href="https://momentjs.com/">Moment.js</a> was one of the first libraries to gain notoriety. 
It made parsing/formatting/calculating dates less daunting for developers.

But do you know about a library called <a href="https://date-fns.org/">date-fns</a>?

<em>date-fns</em> is generally considered to be a worthy alternative to <em>Moment.js</em>. 
Not only because it offers the same feature set, but it also appeals to functional programmers.

<h3>Install date-fns</h3>
You can install <em>date-fns</em> with npm/Yarn:

<code># Using npm
$ npm install date-fns

# Or using yarn
$ yarn add date-fns</code>

<h3>Formatting Dates</h3>
Formatting dates is the bread and butter of libraries like Moment.js/date-fns. 
This is because native JavaScript doesn't have a simple way to handle this.

date-fns uses string patterns similar to Moment.js:

<code>const format = require('date-fns/format');
const stPattysDay = new Date('2020/03/17');
const formattedDate1 = format(stPattysDay, 'MM/dd/yyyy');
const formattedDate2 = format(stPattysDay, 'MMMM dd, yyyy');

console.log(formattedDate1);
// => "03/17/2020"

console.log(formattedDate2);
// => "March 17, 2020"</code>

It's that simple! There are lots of <a href="https://date-fns.org/v2.11.0/docs/format">ways to format dates</a> so they look exactly the way you want them to.

<h3>Adding/Subtracting Dates</h3>
Now that we can format dates, what about performing addition/subtractions with them? There are several functions for doing this:
<li><a href="https://date-fns.org/v2.11.0/docs/addDays">addDays</a></li><li><a href="https://date-fns.org/v2.11.0/docs/subDays">subDays</a></li><li><a href="https://date-fns.org/v2.11.0/docs/addWeeks">addWeeks</a></li><li><a href="https://date-fns.org/v2.11.0/docs/subWeeks">subWeeks</a></li><li><a href="https://date-fns.org/v2.11.0/docs/addMonths">addMonths</a></li><li><a href="https://date-fns.org/v2.11.0/docs/subMonths">subMonths</a></li>

In the example below, we add 1 year to a specified date:

<code>const format = require('date-fns/format');
const addYears = require('date-fns/addYears');

const stPattysDay = new Date('2020/03/17');
const stPattysDayNextYear = addYears(stPattysDay, 1);
const formattedDate = format(stPattysDayNextYear, 'MMMM dd, yyyy');

console.log(formattedDate);
// => "March 17, 2021"</code>

<h3>Using Locales</h3>
Formatting is pretty easy, but what about locales? We know that users will be visiting your website from around the world, and we don't want to assume they speak our native language.

For this, we can import specific locale plugins:

<code>const format =  require('date-fns/format');
const russianLocale = require('date-fns/locale/ru');

const stPattysDay = new Date('2020/03/17');
const formattedDate = format(stPattysDay, 'MMMM dd, yyyy', { locale: russianLocale });

console.log(formattedDate);
// => "марта 17, 2020"</code>

<h3>Differences Between 2 Dates</h3>
The ability to calculate the differences between 2 dates is important for a date manipulation library. 
date-fns provides several functions for calculating this.

For example, we can calculate the days from January 1st to Christmas (as well as “business days”!):

<code>const format = require('date-fns/format');
const addYears = require('date-fns/addYears');
const differenceInDays = require('date-fns/differenceInDays');
const differenceInBusinessDays = require('date-fns/differenceInBusinessDays')

const startDate = new Date('2020/01/01');
const endDate = new Date('2020/12/24');
const daysBetween = differenceInDays(endDate, startDate);
const workdaysBetween = differenceInBusinessDays(endDate, startDate);

console.log(daysBetween);
// => 358

console.log(workdaysBetween);
// => 256</code>

<h3> Bonus! date-fns has a Small Footprint </h3>
One of the biggest downsides to using <em>Moment.js</em> is that it's large! There isn't a way to import individual functions because its API only allows for chaining. 
This means you're required to import the entire library:

<code>const moment = require('moment');
const formattedDate = moment(new Date()).format('MM/DD/YYYY');

console.log(formattedDate);
// => "03/17/2020"</code>

With date-fns, you only grab the specific functions you need (a lot like with Lodash):

<code>const format = require('date-fns/format');
const formattedDate = format(new Date(), 'MM/dd/yyyy');

console.log(formattedDate);
// => "03/17/2020"</code>

This makes date-fns a much smaller dependency than Moment.js. 
See the graphic below for the bundle sizes of Moment.js vs date-fns:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1910a0762b0e6433254e62b4010c5e8a00d970d1/4a5ea/images/js/date-fns/momentjs-vs-date-fns.png">
Source: <a href="https://bundlephobia.com">BundlePhobia</a>
 Note that there's a way to <a href="https://stackoverflow.com/a/25426019/1775026">configure webpack</a> to exclude the "locale" plugins. 
This would significantly reduce its bundle size.

<h3>Conclusion</h3>
date-fns seems to be getting a lot more development work than Moment.js at the moment . 
For this reason, it's really well-maintained, and developers get more input into its direction. 
Along with its robust feature set and modern ES6 sensibilities, it's worth giving it a try! 

The <a href="https://date-fns.org/">official docs</a> for date-fns are really great, and have lots of code samples!


<h2>Download Canvas API-Generated Images Using toBlob</h2>

For Purple11, a side project of mine built with Gatsby, I created a simple <a href="https://purple11.com/cloud-texture-generator/">cloud texture generator</a> that uses SVG filters and the Canvas API under the hood. 
The SVG filter part allowed me to easily create the cloud texture effect itself, thanks in great part to the <a href="https://tympanus.net/codrops/2019/02/19/svg-filter-effects-creating-texture-with-feturbulence/">feTurbulence</a> filter, but I'll keep the fascinating topic of <a href="/svg/svg-filters/">SVG filters for another article</a>.

In order to let a user download the generated texture to their machine as a Jpeg file, the inline SVG (with filters applied) first needs to be drawn on a canvas object, because unfortunately there's no way to generate a downloadable file directly from an inline SVG graphic. 
Obviously, you can skip the whole SVG to Canvas part <a href="#creating-a-downloadable-jpeg-or-png-image-using-toblob">directly to the meat of the matter</a> if you're here just to know how to download an image that's been drawn directly using the Canvas API with <code>toBlob</code>.

If you're new to the Canvas API in general and would like to get an overview, <a href="https://alligator.io/js/drawing-shapes-canvas-api/">check out this article</a>.

<h3>Inline SVG to Canvas</h3>
First, you'll want to use a DOM method to select your inline SVG element. 
Say our SVG has an <code>id</code> of <code>my-svg</code>:

<code>const mySVG = document.getElementById('my-svg');</code>

And then you'd use <a href="https://jsgao0.wordpress.com/2016/06/01/export-svg-file-using-xmlserializer/">XMLSerializer</a> to serialize the content of the SVG and <a href="https://developer.mozilla.org/en-US/docs/Glossary/Base64">btoa</a> (binary to ascii) to create a base64 version of it:

<code>const xml = new XMLSerializer().serializeToString(mySVG);
const svg64 = btoa(xml);</code>

You could then generate a downloadable file straight from the base64-encoded string, but the problem I faced is that most browsers impose a limit on the size of such base64-encoded string to be downloaded as a file. 
So I had to pile on from that point to go around that limitation.

Create a new HTML Image element and set its <code>src</code> property to the base64 version of our SVG:

<code>const image = new Image();
const b64Start = 'data:image/svg+xml;base64,';
image.src = b64Start + svg64;</code>

And now that we have an actual HTML image element on the page with a mirror image of our SVG, we can draw it onto a Canvas 2D context.

First, we need to create a Canvas 2D context to the size of our image. 
Assuming that you already have a canvas element on the page with an <code>id</code> of <code>my-canvas</code>:

<code>const canvas = document.getElementById('my-canvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'white';
ctx.fillRect(0, 0, image.naturalWidth, image.naturalHeight);</code>

And we can listen to the <code>onload</code> event on the image element we've created to actually draw it on the our canvas context object:

<code>image.onload = () => {
 ctx.drawImage(image, 0, 0, image.naturalWidth, image.naturalHeight);
};</code>

<hr>
Alright, so now with all of those shenanigans in place we finally have our inline-SVG result drawn into a canvas object. 
We can move on to the fun part and actually generate a downloadable file, thanks to canvas' <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob">toBlob</a> method.

<h3>Creating a Downloadable JPEG or PNG Image using toBlob</h3>
As it's name implies, the <code>toBlob</code> method turns a canvas-drawn image into a blob. 
A blob is a binary representation of a string, which can then be downloaded as a file on your machine.

<code>toBlob</code> first takes a callback function as argument, which receives the blob itself, and in the callback you can proceed with doing whatever you'd like with the blob. 
<code>toBlob</code> can also 2 additional arguments, the mime type (defaults to <code>image/png</code>) and the quality, which expects a number between 0 (0% quality) and 1 (100% quality) that becomes useful when using a lossy mime type like <code>image/jpeg</code>.

For example, this will create a Jpeg blob at 90% quality:

<code>canvas.toBlob(
 blob => {
   // do something with the blob here...
 },
 'image/jpeg',
 0.9,
);</code>

<h3>URL.createObjectURL</h3>
What we can do is create an URL from the now in-memory blob using <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL">URL.createObjectURL</a>.

We could just select an anchor tag on the page and set its <code>href</code> attribute to the URL:

<code>canvas.toBlob(
 blob => {
   const anchor = document.getElementById('download-link');
   anchor.href = URL.createObjectURL(blob);
 },
 'image/jpeg',
 0.9,
);</code>

Then the user would just have to click on the anchor to initiate the file download.

<hr>
But we can do better and have the file download start automatically, so we'll <a href="https://javascript.info/blob#blob-as-url">use a little trick</a> where we programmatically create an anchor element (<code>a</code>), and programmatically click on it to automagically trigger the download:

<code>canvas.toBlob(
 blob => {
   const anchor = document.createElement('a');
   anchor.download = 'my-file-name.jpg'; // optional, but you can give the file a name
   anchor.href = URL.createObjectURL(blob);

   anchor.click(); //  magic!

   URL.revokeObjectURL(anchor.href); // remove it from memory and save on memory! 
 },
 'image/jpeg',
 0.9,
);</code>

You'll notice too that with our auto-downloaded image we can release/clean-up the generated blob to URL mapping from memory because the blob has now been downloaded as a file on the machine so we are done with it.

<h3>Wrapping Up</h3>
Oof, this might seem like a lot of juggling around to get what we need, but this is the kind of setup you'd do once and then get back to focusing on the actual features of your fancy pants app. 
Plus, once what we want saved is drawn into a canvas context, the <code>toBlob</code> method makes it quite easy to allow a file to be saved in whatever format and quality fits the needs of your app best.

Good luck! 


<h2>The getOwnPropertyDescriptors Method in JavaScript</h2>

One of the new feature from the <a href="https://2ality.com/2016/02/ecmascript-2017.html">ECMAScript 2017</a> specification for JavaScript is the <code>getOwnPropertyDescriptors</code> method. 
In a nutshell, this method returns the information for all properties of the given object including the information about getters and setters. 
It allow us to create copies of objects and clone it while copying all properties, including the getters and setters.

In JavaScript, we can create special properties that behave as methods inside the object and behave as a property outside of it. 
They are called <code>get</code> and <code>set</code>.

<code>// object with get and set properties

const gator = {
 name: 'Ben',
 type: 'reptilian',
 get fullName(){
   return `${this.name}${this.type}`;
 },
 set gatorName(name){
   this.name = name;
 }
};  
</code>

If we do <code>console.log(gator)</code> we'll get only the name and the type. 
Yet, we still have the access to the getter fullName, despite the fact it's not visible in the console.

<code>console.log(gator)      // {name: 'Ben',  type: 'reptilian',}
console.log(gator.fullName) // 'Benreptilian'</code>

Notice we call the getter like it was a usual property, not a method.

<h3>Cloning Objects</h3>
We use <code>Object.assign()</code> to clone objects in javaScript. 
If you're not familiar with the Object.assign method, please read the <a href="https://alligator.io/js/dealing-with-objects/">article about how to manage objects</a> in JavaScript. 
The main issue with this method is when we clone objects the result is not exactly as we're expecting. 
The method is not working with getters and setters.

<code>const cayman = {Object.assign({}, gator};
console.log(cayman)         // {name: 'Ben',  type: 'reptilian', fullName: Benreptilian, gatorName: undefined }</code>

So the getter and setter became usual values. 
And if getter is a countered value, the setter will be undefined.

Let's clone the object with the <code>getOwnPropertyDescriptors</code> method instead.

<code>const crocodilian = Object.defineProperties({}, Object.getOwnPropertyDescriptors(gator)));</code>

And now let's compare the descriptors of each object we have:

<code>console.log(Object.getOwnPropertyDescriptors(gator));

/*  name: {value:'Ben', writable: true, enumerable: true, configurable: true},
   type: {value:'reptilian', writable: true, enumerable: true, configurable: true},
   fullName: {get: f, set: undefined, enumerable: '', configurable: ''},
   gatorName: {get: undefined, set: f, enumerable: '', configurable: ''},        
*/

console.log(Object.getOwnPropertyDescriptors(cayman));

/*  name: {value:'Ben', writable: true, enumerable: true, configurable: true},
   type: {value:'reptilian', writable: true, enumerable: true, configurable: true},
   fullName: {value: 'Benreptilian', writable: true, enumerable: '', configurable: ''},
   gatorName: {value: undefined, writable: true, enumerable: '', configurable: ''},        
*/

console.log(Object.getOwnPropertyDescriptors(crocodilian));

/*  name: {value:'Ben', writable: true, enumerable: true, configurable: true},
   type: {value:'reptilian', writable: true, enumerable: true, configurable: true},
   fullName: {get: f, set: undefined, enumerable: '', configurable: ''},
   gatorName: {get: undefined, set: f, enumerable: '', configurable: ''},        
 
*/</code>

<code>gator</code>'s object properties <code>name</code> and <code>type</code> are defined as usual properties, but fullName and gatorName are defined as getter and setter. 
They have no <code>value</code> field, but have <code>get</code> and <code>set</code> fields. 
<code>cayman</code>'s object getter and setter are described now as usual values. 
And with the <code>crocodilian</code> object we manage to save its getters and setters, thanks to <code>getOwnPropertyDescriptors</code>.

The <code>getOwnPropertyDescriptors</code> method helps to avoid data loss and with it we can create deep copies of objects without relying on another utility function.


<h2>Automate JavaScript API Documentation with JSDoc</h2>

<a href="https://github.com/jsdoc/jsdoc">JSDoc</a> is an amazing tool that allows us to generate API documentation for our JavaScript projects. 
Let's go over how to set it up and make use of it.

<h3>Setup</h3>
To get started with JSDoc, you first need to install it on your machine globally like this:

<code>$ npm i -g jsdoc</code>

Or you can also use JSDoc in an npm project locally:

<code>$ npm init
$ npm i --save-dev jsdoc</code>

Then add the following script to your <code>package.json</code> file:

<code>"doc": "jsdoc -d docs --configure jsconf.json main.js"</code>

<code>main.js</code> is our code's entry point. 
The <code>-d</code> flag tells JSDoc in which folder to output the documents. 
<code>--configure</code> tells JSDoc where the configuration file is located.

<h3>What JSDoc does</h3>
When we run the command <code>jsdoc</code>, the program will generate HTML files. 
You can open the HTML files in your browser and navigate it like a regular website.

<h3>Defining types</h3>
The first thing we want to define in our applications are our data types. 
We're going to create a little food application to turn our shopping list into a vegan shopping list.

<code>/**
* @typedef {Object} Food
* @property {string} name - What the food should be called
* @property {('meat' | 'veggie' | 'other')} type - The food's type
*/</code>

In plain English, this code means that we are defining a type called Food which is an Object. 
Food has two properties:
<li>
<code>name</code> which is a string.</li><li>
<code>type</code> which can have one of three values <code>'meat'</code>, <code>'veggie'</code> or `‘other'.</li>

If we run <code>npm run doc</code> we'll get:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5490cf12e4c4590ac24578186589e8e3b0d10516/d56c9/images/js/jsdoc/jsdoc_typedef_food.png">

<h3>Documenting Functions</h3>
Here's how you'd add a comment to a function to document it using JSDoc:

<code>/**
* This function turns a string into a veganized version of the food
* For example 'beef' will turn into 'vegan beef'
* @param {string} food the food item we want to veganize
* @returns {string} the veganized version of our food name
*/
function getVeganFood (food) {
const veganizedFood = 'vegan ' + food;
return  veganizedFood;
}
</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bac369831a9bd058fa909968fab456f3b1635485/e0d40/images/js/jsdoc/jsdoc_getvegan_food.png">

<h3>VSCode Integration</h3>
You can do some really cool things using VSCode's IntelliSense. 
VSCode by default uses JSDoc to prepopulate your documentation. 
VSCode will use our JSDoc type documentation as a type checker and alert you in the case of a mismatch.

Let's create a new function:

<code>/**
* This function will veganize your shopping list
* It will turn every meat option into a veganized version of the meat
* For example if we enter
* @param {Array&lt;Food>} arrayOfFoods Your shopping list
*  @returns {Array&lt;Food>} the veganized version of our shopping list
*/
const veganizeManyFoods = (arrayOfFoods) => {
return arrayOfFoods.map(food=> {
 if (food.type === 'veggie')
  console.log('this is a vegetable!')
 // VS Code automatically check if type is one of "meat", "veggie" or "other"
 // it will send an error because 'cheese' is not a food type
 if (food.type === 'cheese')
  food.name = getVeganFood('cheese');

 if(food.type === 'meat'){
  // VS Code send an error because the food object is not a string
  food.name = getVeganFood(food);
 }
 return food;
});
};

/**
* The list of items we want to purchase
* @type {Array&lt;Food>}
*/
const shoppingList = [{
name:'steak', type: 'meat',
name:'Chocolate Bar', type: 'snack',
name:'Artichoke', type: 'veggie'
}];

/**
* The vegan version of our shopping list
* @type {Array&lt;Food>}
*/
const veganShoppingList = veganizeManyFoods(shoppingList);
// in an idea world this should equal
// [
//   { name: 'vegan steak', type: 'meat' },
//   { name: 'Chocolate Bar', type: 'snack' },
//   { name: 'Artichoke', type: 'veggie' }
// ]
</code>

Here's an animated GIF that shows what it will look like in Visual Studio Code:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6ae32fcc3c5d4dc8adb290db1f955d6b41e23937/da9f1/images/js/jsdoc/jsdoc_vscode_illustration-o.gif">

 This should be enough to get you started with JSDoc. 
I hope that everything is clear. 
I also recommend TypeScript users to check out the <a href="https://typedoc.org/">TypeDoc</a> project. 
TypeDoc uses a very similar grammar and integrates really well with your existing types.


<h2>Using the Fullscreen API</h2>

In this article, we'll cover the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API">Fullscreen API</a> with ample amounts of code snippets, and interactive demos. 
It's a suprisingly easy API to work with!

The <em>Fullscreen API</em> was introduced in 2013, and provides a native way for browsers to enter/exit fullscreen mode. 
This specification brought a slew of JavaScript APIs, and CSS selectors that we can use to refine this immersive user experience.

<h3>Basics of the Fullscreen API</h3>
It's really easy to activate fullscreen mode on the web! Currently, some browsers still require prefixing the <em>requestFullscreen</em> method.

To check which Fullscreen API method is available, you can create a helper function similar to this:

<code>function activateFullscreen(element) {
 if(element.requestFullscreen) {
   element.requestFullscreen();        // W3C spec
 }
 else if (element.mozRequestFullScreen) {
   element.mozRequestFullScreen();     // Firefox
 }
 else if (element.webkitRequestFullscreen) {
   element.webkitRequestFullscreen();  // Safari
 }
 else if(element.msRequestFullscreen) {
   element.msRequestFullscreen();      // IE/Edge
 }
};</code>

The word "request" in <code>requestFullscreen</code> is due to the fact that browsers don't have permissions (by default) to activate fullscreen mode.

Exiting fullscreen is pretty easy, but it also requires a bit of browser detection:

<code>function deactivateFullscreen() {
 if(document.exitFullscreen) {
   document.exitFullscreen();
 } else if (document.mozCancelFullScreen) {
   document.mozCancelFullScreen();
 } else if (document.webkitExitFullscreen) {
   document.webkitExitFullscreen();
 }
};</code>

Using the above function, to activate fullscreen, simply pass the <em>document</em> HTMLElement!

<code>&lt;button
 onclick="activateFullscreen(document.documentElement);"
>
 Go fullscreen!
&lt;/button>

&lt;button
 onclick="deactivateFullscreen();"
>
 Leave fullscreen
&lt;/button></code>

See the Pen <a href="https://codepen.io/wle8300/pen/YzXeapw"> alligatorio-fullscreen-api-1</a> by wle8300 (<a href="https://codepen.io/wle8300">@wle8300</a>) on <a href="https://codepen.io">CodePen</a>.

<h3>Using Fullscreen API on unconventional HTMLElements</h3>
As you might have guessed, other HTML hlements can go into fullscreen mode too, not just <em>document</em>!

In the demo below, try clicking the buttons to make <code>&lt;h1></code>, <code>&lt;img></code>, and <code>&lt;video></code> go into fullscreen mode:

<code>&lt;button
 onclick="activateFullscreen(document.getElementById('my-image'));"
>
 Fullscreen #my-text!
&lt;/button>
&lt;button
 onclick="activateFullscreen(document.getElementById('my-image'))"
>
 Fullscreen #my-image
&lt;/button>
&lt;button
 onclick="activateFullscreen(document.getElementById('my-video'))"
>
 Fullscreen #my-video
&lt;/button>

&lt;h1 id="my-text">Hello world&lt;/h1>
&lt;img id="my-image" src="alligatorio-logo.svg" width="200"/>
&lt;video id="my-video" controls src="big-buck-bunny.mp4" /></code>

See the Pen <a href="https://codepen.io/wle8300/pen/NWqyMBZ"> alligatorio-fullscreen-api-2</a> by wle8300 (<a href="https://codepen.io/wle8300">@wle8300</a>) on <a href="https://codepen.io">CodePen</a>.

<h3>Properties &amp; Events</h3>
There are additional properties that Fullscreen API brings:
<li>
<em>document.fullScreenEnabled</em>: returns a boolean denoting whether the webpage has permissions to enter fullscreen mode</li><li>
<em>document.fullScreenElement</em>: returns a HTMLElement Node (only when fullscreen is activated)</li>

You'll also need to detect the browser:

<code>const fullscreenEnabled = document.fullscreenEnabled
 || document.mozFullScreenEnable
 || document.webkitFullscreenEnabled;
const fullscreenElement = document.fullscreenElement
 || document.mozFullScreenElemen
 || document.webkitFullscreenElement;</code>

There's also an event called <em>fullscreenchange</em> when the user enters/exits fullscreen mode that you can listen to:

<code>const fullscreenElement = document.fullscreenElement
 || document.mozFullScreenElement
 || document.webkitFullscreenElement;

document.addEventListener('fullscreenchange', (event) => {
 if (fullscreenElement) {
   console.log('Entered fullscreen:', document.fullscreenElement);
 } else {
   console.log('Exited fullscreen.');
 }
});</code>

<h3>Styling Fullscreen Elements</h3>
On top of the JavaScript API that's available, there's also a few CSS pseudo-classes you can use:

<code>/* Targets the
 HTML element that's
 in fullscreen mode */
:fullscreen,
:-webkit-full-screen,
:-moz-full-screen,
:-ms-fullscreen {
 /* ... 
*/
}

/* Styling the
 backdrop */
::backdrop {
 /* ... 
*/
}</code>

Here's an example where we add a groovy <em>background-color</em>, and <em>opacity</em> rules to the backdrop:

<code>::backdrop {
 opacity: 0.8;
 background: #DFA612;
}</code>

See the Pen <a href="https://codepen.io/wle8300/pen/gOpvzJE"> alligatorio-fullscreen-api-3</a> by wle8300 (<a href="https://codepen.io/wle8300">@wle8300</a>) on <a href="https://codepen.io">CodePen</a>.

Try clicking the button! You can read more about <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:fullscreen">:fullscreen</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/::backdrop">:backdrop</a> on the Mozilla Developer Network.

The W3C specification alternated between "fullscreen" and "full-screen" so you'll see a discrepancy in older specs, browser prefixes, etc. 
Going forward browsers will stick with "fullscreen"

<hr>
<gator-collapse title="Browser Support"> <a href="http://caniuse.com/#feat=fullscreen">Can I Use fullscreen?</a> Data on support for the fullscreen feature across the major browsers from caniuse.com.
</gator-collapse>


<h2>Binary Search Trees Through JavaScript</h2>

The problem with normal tree structures is that they are unsorted and very unwieldy to work with. 
If you run a search for a file on your computer it'll generally take a pretty long time, this is because your files are unsorted and it has to search through EVERYTHING to get a result. 
We can heavily improve this by upgrading how we organize the values in our trees.

<h3>Prerequisites</h3>
You'll need to know the basic concepts of trees, which you can learn <a href="https://alligator.io/js/trees/">here</a>, we're also going to need to do some very basic tree traversal with a breadth-first search, which you can brush up on <a href="https://alligator.io/js/tree-traversal/">here</a>.

<h3>Concept</h3>
A binary tree is just a normal tree with the limitation of each node only being able to, at most, have two children. 
A binary search tree just has the additional rule that if there's two values then they need to be ordered, in our case from the lower number on the left to the higher on the right.

Searching on a binary search tree is a large improvement on our original <code>O(n)</code> search speed since now to find something we just need to compare what we want to each parent node before moving left or right until we're at what we want, giving us <code>O(logn)</code> for all operations.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/252787627575799cdac59a6d4424df699802f124/c7097/images/js/tree-traversal/binary-search-tree.png" width="600">

<h3>Create</h3>
Very similar to <a href="https://alligator.io/js/linked-lists-overview/">linked lists</a> we can use classes to generate our nodes and tree. 
Each node only really needs a pointer to the left/less and right/greater sides, the value, and I personally like to add a counter since repeated values can only exist once in the tree.

After checking if there's anything already there, we can use a nice little utility function to put our value to a side. 
Very simply, we just need to loop through the tree, if our value is less than the current node move left else move right, if there's nothing there become the new node in that position, if a matching value's already there then we can increment its counter.

<code>class Node {
 constructor(val) {
   this.val = val;
   this.right = null;
   this.left = null;
   this.count = 0;
 };
};

class BST {
 constructor() {
   this.root = null;
 }
 create(val) {
   const newNode = new Node(val);
   if (!this.root) {
     this.root = newNode;
     return this;
   };
   let current = this.root;

   const addSide = side => {
     if (!current[side]) {
       current[side] = newNode;
       return this;
     };
     current = current[side];
   };

   while (true) {
     if (val === current.val) {
       current.count++;
       return this;
     };
     if (val &lt; current.val) addSide('left');
     else addSide('right');
   };
 };
};

let tree = new BST();
tree.add(10);
tree.add(4);
tree.add(4);
tree.add(12);
tree.add(2);
console.log(tree);</code>

<h3>Find</h3>
Finding something is incredibly simple, just move left or right relative to the current value and return <code>true</code> if we hit something that matches.

<code>find(val) {
 if (!this.root) return undefined;
 let current = this.root,
     found = false;

 while (current &amp;&amp; !found) {
   if (val &lt; current.val) current = current.left;
   else if (val > current.val) current = current.right;
   else found = true;
 };

 if (!found) return 'Nothing Found!';
 return current;
};</code>

<h3>Delete</h3>
Deletion are the most complicated operation since we're not working with just leafs but having to restructure, or “rebalance”, all of a node's children. 
There are 2 conditions we have to check for, whether the node is a leaf and if it has children.

First we need a utility function to collect all of the deleted node's children. 
I'll use a basic breadth-first search to push everything into an array which we can then loop through to re-add each item to the tree.

The only difference from a normal search is that it needs to accept a different starting point, so we can limit our search only to the subtree of our deleted node's children.

<code>BFS(start) {
 let data = [],
     queue = [],
     current = start ? this.find(start) : this.root;

 queue.push(current);
 while (queue.length) {
   current = queue.shift();
   data.push(current.val);

   if (current.left) queue.push(current.left);
   if (current.right) queue.push(current.right);
 };

 return data;
}</code>

Since we can't traverse back up to the parent we'll use a variable to store the parent node to <code>current</code> and use that to set <code>current</code> to <code>null</code> after we've saved the children.

In <code>deleteNode</code> we'll collect our node's children, set it on its parent to <code>null</code>, then use <code>create</code> on each of the children, restructuring them properly in the tree. 
Our children array will also include the deleted node, which we can just splice out.

<code>delete(val) {
 if (!this.root) return undefined;
 let current = this.root,
     parent;

 const pickSide = side => {
   if (!current[side]) return 'No node found!';

   parent = current;
   current = current[side];
 };

 const deleteNode = side => {
   if (current.val === val &amp;&amp; current.count > 1) current.count--;
   else if (current.val === val) {
     const children = this.BFS(current.val);
     parent[side] = null;
     children.splice(0, 1);
     children.forEach(child => this.create(child));
   };
 };

 while (current.val !== val) {
   if (val &lt; current.val) {
     pickSide('left');
     deleteNode('left');
   };
   else {
     pickSide('right');
     deleteNode('right');
   };
 };

 return current;
}</code>

<h3>Conclusion</h3>
This would have been the full CRUD operations, as any update is essentially just deleting one node and creating a whole new one somewhere else, which doesn't really need its own method.

We'll be able to do some cooler stuff with binary search trees as we move into binary heaps and priority queues.


<h2>Tree Traversal via JavaScript</h2>

Trees are basically just fancy <a href="https://alligator.io/js/linked-lists-overview/">linked lists</a> and creating and deleting nodes on a tree is incredibly simple. 
Searching on the other hand is a bit more tricky when they're unsorted, so we're going to look into a few different ways to handle searching through an entire tree.

<h3>Prerequisites</h3>
You will need a basic understanding of what <a href="https://alligator.io/js/trees/">trees</a> are and how they work. 
Our particular example with be utilizing a <em>Binary Search Tree</em>, but these are more of techniques and patterns than exact implementations and can be easily adapted for any type of tree.

<h3>Concepts</h3>
With <a href="https://alligator.io/js/binary-search-trees/">binary search trees</a> we could use the same system to create a new node as to find one. 
Standard trees, like your file system, don't follow any particular rules and force us to look at every item through a tree or subtree to find what we want. 
This is why running a search for a particular file can take so long.

There aren't many ways to optimize past <code>O(n)</code> but there are two main “philosophies” for searching through the entire tree, either by searching breadth-first (horizontally between siblings) or depth-first (vertically between parents and children).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7c3616bddd13260b1f6bfeadc98643d02e3fa6cd/d990c/images/js/trees/tree-anatomy.png" width="600">

<h3>Tree</h3>
Since a binary search tree is the easiest to set up, we can just throw together a quick one that can only add nodes.

<code>class Node {
 constructor(val) {
   this.val = val;
   this.right = null;
   this.left = null;
 };
};

class BST {
 constructor() {
   this.root = null;
 };
 create(val) {
   const newNode = new Node(val);
   if (!this.root) {
     this.root = newNode;
     return this;
   };
   let current = this.root;

   const addSide = side => {
     if (!current[side]) {
       current[side] = newNode;
       return this;
     };
     current = current[side];
   };

   while (true) {
     if (val === current.val) return this;
     if (val &lt; current.val) addSide('left');
     else addSide('right');
   };
 };
};

const tree = new BST();
tree.create(20);
tree.create(14);
tree.create(57);
tree.create(9);
tree.create(19);
tree.create(31);
tree.create(62);
tree.create(3);
tree.create(11);
tree.create(72);</code>

<h3>Breadth-First Search</h3>
Breadth-first search is characterized by the fact that it focuses on every item, from left to right, on every level before moving to the next.

There are three main parts to this, the current node, our list of visited nodes, and a basic <a href="https://alligator.io/js/stacks-queues/">queue</a> for keeping track of which nodes we need to look at (we'll just use an array since it'll never get very long).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/252787627575799cdac59a6d4424df699802f124/c7097/images/js/tree-traversal/binary-search-tree.png" width="600">

Let's work through how it would look on this tree.

Whatever is our <code>current</code>, we'll push its children (from left to right) into our queue, so it'll look like <code>[20, 14, 57]</code>. 
Then we'll change <code>current</code> to the next item in the queue and add its left and right children to the end of the queue, <code>[14, 57, 9, 19]</code>.

Our current item can now be removed and added to <code>visited</code> while we move on to the next item, look for its children, and add them to the queue. 
This will repeat until our queue is empty and every value is in <code>visited</code>.

<code>BFS() {
 let visited = [],
     queue = [],
     current = this.root;

 queue.push(current);
 while (queue.length) {
   current = queue.shift();
   visited.push(current.val);

   if (current.left) queue.push(current.left);
   if (current.right) queue.push(current.right);
 };

   return visited;
}

console.log(tree.BFS()); //[ 20, 14, 57, 9, 19, 31, 62, 3, 11, 72 ]</code>

<h3>Depth-First Search</h3>
Depth-first searches are more concerned with completing a traversal down the whole side of the tree to the leafs than completing every level.

There are three main ways to handle this, <code>preOrder</code>, <code>postOrder</code>, and <code>inOrder</code> but they're just very slight modifications of each other to change the output order. 
Better yet, we don't even need to worry about a queue anymore.

Starting from the root, we'll use a short <a href="https://alligator.io/js/understanding-recursion/">recursive function</a> to log our node before moving down to the left as far as possible, logging its path along the way. 
When the left side is done it'll start working on the remaining right values until the whole tree has been logged. 
By the end visited should look like <code>[24, 14, 9, 3, 11, 19, ...]</code>.

<code>preOrder() {
 let visited = [],
     current = this.root;

 let traverse = node => {
   visited.push(node.val);
   if (node.left) traverse(node.left);
   if (node.right) traverse(node.right);
 };

 traverse(current);
 return visited;
}

console.log(tree.preOrder()); // [ 20, 14, 9, 3, 11, 19, 57, 31, 62, 72 ]</code>

As you may have guessed, <code>postOrder</code> is the opposite of <code>preOrder</code>, we're still working vertically but instead of moving from the root to leafs, we'll search from the bottom to top.

We'll start from the bottommost left node and log it and its siblings before moving up to their parent. 
The first half of visited should look like this, <code>[3, 11, 9, 19, 14, ...]</code>, as it works it bubbles up the tree.

We can easily achieve this by pushing our nodes into <code>visited</code> after both traversals are completed.

<code>postOrder() {
 let visited = [],
     current = this.root;

 let traverse = node => {
   if (node.left) traverse(node.left);
   if (node.right) traverse(node.right);
   visited.push(node.val);
 };

 traverse(current);
 return visited;
}

console.log(tree.postOrder()); // [ 3, 11, 9, 19, 14, 31, 72, 62, 57, 20 ]</code>

Similar to <code>postOrder</code>, <code>preOrder</code> visits works from the bottom up but it just visits the parent before any siblings.

Instead of the beginning or end we can push onto our list after we traverse the left side and before the right. 
Our results will look something like this, <code>[3, 9, 11, 14, 19, 20, ...]</code>.

<code>inOrder() {
 let visited = [],
     current = this.root;

 let traverse = node => {
   if (node.left) traverse(node.left);
   visited.push(node.val);
   if (node.right) traverse(node.right);
 };

 traverse(current);
 return visited;
}

console.log(tree.inOrder()); // [ 3, 9, 11, 14, 19, 20, 31, 57, 62, 72 ]</code>

<h3>Closing Thoughts</h3>
Of course all of these algorithms will be <code>O(n)</code> since the point is to look at every node, there isn't much room for cutting corners or clever tricks.

Keep in mind that these aren't exact implementations that need to be memorized but general patterns for solving problems and building more valuable algorithms. 
Once you understand the underlining concepts, they can easily be adapted for any language or framework.


<h2>How to Use localForage for Easy Async Browser Storage</h2>

<a href="https://github.com/localForage/localForage">localForage</a> is a convenient wrapper library that smoothes the rough landscape of browser databases. 
Of which there are several:
<li><em>localStorage</em></li><li><em>IndexedDB</em></li><li>and <em>Web SQL</em>
</li>

Each of these options was initially designed with the same purpose: providing persistent storage in the browser. 
The reality is that each of the options has unique strengths and limitations that could make a simple database task in the browser take hours of reading docs.

To install localForage run: <code>$ npm install localforage</code>

<h3>Benefits of Using localForage</h3>
<em>localForage</em> solves this problem by providing a simple API that imitates <a href="https://alligator.io/js/introduction-localstorage-sessionstorage/">localStorage</a> while including other powerful features from other robust databases (like the ability to store <a href="https://alligator.io/js/file-reader/">blobs</a> that IndexedDB provides).

Below I go over some the benefits you'll find when using localForage, along with some usage examples!

<h3>Imitates localStorage API</h3>
You already know the API for <em>localForage</em> if you know <em>localStorage</em>!

<code>import localForage from 'localforage';
const foo = 'hello world';

// Setting...
localStorage.setItem('myuniquekey', foo);
localForage.setItem('myuniquekey', foo);

// Getting...
localStorage.getItem('myuniquekey');   //=> 'hello world'
localForage.getItem('myuniquekey');    //=> 'hello world'</code>

Many of the <em>localStorage</em> methods like <code>removeItem()</code>, <code>clear()</code>, <code>keys()</code> and <code>length()</code> are available in <em>localForage</em>. 
This makes it almost effortless for webdevs to get going with it!

<h3>No Need to Serialize</h3>
Perhaps one of the greatest benefits with using localForage is that you don't need to serialize your values!

<code>const foo = {
 greeting: 'hello world'
};

localStorage.setItem('myuniquekey', JSON.stringify(foo));
JSON.parse(localStorage.getItem('myuniqekey'));
//=> {
//     greeting: 'hello world'
//   };

localForage.setItem('myuniquekey', foo); // 
localForage.getItem('myuniquekey');
//=> {
//     greeting: 'hello world'
//   };</code>

Storing values with <em>localForage</em> feels more seamless than <em>localStorage</em>. 
This works with a variety of values like <a href="https://localforage.github.io/localForage/#data-api-setitem">arrays, numbers, files, etc</a> and lets you skip the headache of serializing values. 


<h3>localForage is Asynchronous</h3>
<em>localStorage</em> is synchronous. 
This isn't noticeably bad for smaller values like a short string or number, however it's really slow when you need to work with large arrays/objects since they need to be <a href="https://alligator.io/js/json-parse-stringify/">stringified</a>.

<em>localForage</em> is completely asynchronous, and provides a callback or <a href="https://alligator.io/js/promises-es6/">ES6 Promise</a> interface. 
This makes it more performant than any synchronous library because it won't block the <a href="https://alligator.io/js/thread-of-execution/">thread</a>.

<code>const foo = {
 greeting: 'hello world'
};

// ES6 Promise
localForage.setItem('myuniquekey', foo)
 .then((value) => {})    // do something with "foo"
 .catch((error) => {});  // handle errors

// Callback
localForage.setItem('myuniquekey', foo, (error, value) => {});</code>

It's kinda nice that you can choose between the callback or the Promise interface!

<h3>Graceful Degradation</h3>
By default localForage prefers using these databases (in this particular order):

<ol><li>IndexedDB</li><li>WebSQL</li><li>localStorage</li>
</ol>
It will gracefully degrade if that database isn't available. 
For example, WebSQL isn't available on Firefox Desktop, so it would degrade to localStorage instead. 
This happens automatically without any action on your part. 


However, if you'd like to set a different order of fallback databases you can use the <code>setDriver()</code> or <code>config()</code> methods:

<code>import localForage from 'localforage';

// Using setDriver()
localForage.setDriver([
 localForage.INDEXEDDB,
 localForage.LOCALSTORAGE,
 localForage.WEBSQL,
]);

// Using config()
localForage.config({
 driver: [
   localForage.INDEXEDDB,
   localForage.LOCALSTORAGE,
   localForage.WEBSQL,
 ],
 name: 'myApp',     // These fields
 version: 1.0,      // are totally optional
});</code>

If you want to provide an exclusive database for localForage to use, pass a single value instead of an array!

<code>localForage.setDriver(localForage.LOCALSTORAGE);</code>

Note that both the <code>setDriver()</code> and the <code>config()</code> methods should be placed before localForage is used to interact with databases.

<h3>Wrapping Up</h3>
localForage is an easy-to-use and powerful browser storage library! It was developed with the support of Mozilla, and is very well-maintained. 
Visit the <a href="https://localforage.github.io/localForage">docs website</a> for more guidance on how localForage might work for you 


<h2>Implementing a Tab Component from Scratch in Vanilla JavaScript</h2>

Sharpen your development skills by recreating the well known tab component using nothing more then vanilla JavaScript and your unflappable wit!

On the surface, tabs may seem quite boring. 
We all know what they do and use them on a daily basis in our web browsers without giving them much thought, however, designing a modern, reusable tab component that works well on mobile devices using only native browser technologies can actually be quite challenging and is a great opportunity to build some “real world” code.

<h3>Base Requirements</h3>
Our tab component needs to be:
<li>Responsive</li><li>Reusable</li><li>Nestable</li><li>Can set a default tab</li>

Lets get to it! First I'll start with the code, and then a break down what's happening:

<h3>Markup</h3>
Here's the basic HTML markup for our tab component:

<code>&lt;!doctype html>
&lt;html lang="en">
&lt;head>
 &lt;meta charset="utf-8">
 &lt;meta name="viewport" content="width=device-width, initial-scale=1" />
 &lt;title>Gator tabs&lt;/title>
 &lt;link rel="stylesheet" href="index.css">
&lt;/head>
&lt;body>
 &lt;div class="gator-tabs-container">
   &lt;ul class="gator-tabs-header">
     &lt;li>The nest&lt;/li>
     &lt;li class="default-gator-tab">Hello world!&lt;/li>
     &lt;li>Rise of the gator&lt;/li>
   &lt;/ul>
   &lt;ul class="gator-tabs">
     &lt;li class="gator-tabs-container">
       &lt;ul class="gator-tabs-header">
         &lt;li>Nested 1&lt;/li>
         &lt;li class="default-gator-tab">Nested 2&lt;/li>
       &lt;/ul>
       &lt;ul class="gator-tabs">
         &lt;li class="gator-tab">Some eggs in nest one&lt;/li>
         &lt;li class="gator-tab">Some eggs in nest two&lt;/li>
       &lt;/ul>
     &lt;/li>
     &lt;li class="gator-tab">Hello world from tab one!&lt;/li>
     &lt;li class="gator-tab">Believe me I know tabs, I have the best tabs. 
Nobody does tabs like I do.&lt;/li>
     &lt;li class="gator-tab">For now the eggs lay dormant but soon the gators will rise from the swamps.&lt;/li>
   &lt;/ul>
 &lt;/div>
 &lt;script src="main.js">&lt;/script>
&lt;/body>
&lt;/html></code>

<h3>Styling</h3>
And some CSS styles to make it all look good:

<code>
 /* minimal reset */
 * {
   margin:0;
   border:0;
   padding:0;
   box-sizing:border-box;
   list-style:none;
 }
 
 body{
   background-color: #333;
   /* because serifs are gross (IMO) */
   font-family: sans-serif;
 }
 
 .gator-tabs-container{
   display:flex;
   flex-direction:column;
   width:100%;
 }
 
 .gator-tabs-header {
   background-color:#DFA612;
   display:flex;
   flex-wrap:wrap;
   padding:.375rem;
 }
 
 .gator-tabs-header > li {
   color:#fff;
   cursor:pointer;
   flex-grow:1;
   padding:.375rem;
   font-size:1.125rem;
 }
 
 .gator-tabs {
   display:flex;
 }
 
 .gator-tab {
   padding:1rem;
   color:#fff;
 }</code>

<h3>JavaScript Code</h3>
And now let's let the magic happen with some simple JavaScript:

<code>function tabify( element ){
 const header = element.querySelector('.gator-tabs-header');
 const content = element.querySelector('.gator-tabs');
 const tab_headers = [...header.children];
 const tab_contents = [...content.children];
 tab_contents.forEach( x => x.style.display = 'none');
 let current_tab_index = -1;

 function setTab( index ){
   if( current_tab_index > -1 ){
     tab_headers[ current_tab_index ].style.fontWeight = 400;
     tab_contents[ current_tab_index ].style.display = 'none';
   }
   tab_headers[ index ].style.fontWeight = 800;
   tab_contents[ index ].style.display = 'flex';
   current_tab_index = index;
 }

 default_tab_index = tab_headers.findIndex( x => {
   return [...x.classList].indexOf('default-gator-tab') > -1;
 });

 default_tab_index = default_tab_index === -1 ? 0 : default_tab_index;
 setTab( default_tab_index );
 tab_headers.forEach((x,i) => x.onclick = event => setTab(i));
}
 
 // this is where the magic happens!
[...document.querySelectorAll('.gator-tabs-container')]
 .forEach(x => tabify(x));</code>

Here's a screenshot of the app on mobile:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6f4e702762fc45e80ff3eac6e2323fdf4cb51bcf/a189c/images/js/tabs/mobile-gator-tabs.png" width="240" alt="Mobile screenshot of gator tabs">

<h3>Recap/Breakdown</h3>
Our first requirement was to build something responsive and this was easily solved using <a href="/css/flexbox-primer/">Flexbox</a> with the <code>flex-wrap</code> property so the tab headers will now stack on top of each other on mobile.

Making the code reusable may seem tricky at first but by wrapping our code into a function called <code>tabify</code> we can make anything into a tab that satisfied the required class/tag structure. 
This also makes our next requirement, nestable, fall into place automatically.

The last requirement is the ability to set a tab as the default selected when the page opens. 
This was accomplished by adding the <code>default-gator-tab</code> class to the desired tab header and our script will find the index of the first tab header with this class and use it to set the initial tab.

In a previous article, we described <a href="/react/tabs-component/">building tabs using React</a>, but honestly, I'm hard pressed to find any significant advantages React has over plain ol' Javascript in this instance. 
We're able to pass any configuration to our script such as the default tab using class names (instead of props) and we are using about the same amount of code as the React version without the overhead of a framework!

If we wanted to, we could easily extend what we have to include animations or more complex feature but I'll leave that up to you.


<h2>Building a PWA in Vanilla JavaScript - Part 2: Push API</h2>

This is the second part of a three-part series about creating an app that leverages the <a href="https://www.w3.org/TR/push-api/">Web Push API</a> and cron-schedule.

In this installment, we'll cover the Web Push API aspect of the app.

<h3>What are we Building</h3>
We are going to build a simple progressive web app (PWA) which will remind me to take my pills every day .

Our app will have a web server powered by Express.js. 
Express will push notifications to the clients which subscribed to the push notifications. 
It will also serve the frontend.

<h3>What We've Built So Far</h3>
So far, we created an installable Progressive Web App (PWA) and an Express.js Server to serve our static files on <code>http://localhost:3000</code>. 
You can <a href="https://alligator.io/js/vanilla-pwa/">head over to Part 1 here</a> to read all about how we got there.

<h3>How the Push API works</h3>
This part can be a bit scary so you can skip it if you're just looking for some simple code snippets. 
Here's a little chronology (you don't have to follow these steps in this exact order).

<ol><li>We ask our user for her permission to send her some notifications.</li><li>The browser registers a service worker.</li><li>The browser fetches a public key from our Express server.</li><li>The service worker has an interface called <code>pushManager</code>. 
We pass the public key to <code>pushManager's</code> subscribe function which creates a new subscription object.</li>
</ol>
Note: The subscription object has an <code>endpoint</code> key which is the URL from which the push notification will be sent. 
Only the browser can generate these URLs. 
It also contains some authentication information.

<code>{
 "endpoint": "https://fcm.googleapis.com/fcm/send/cyMiHqakiZE:APA91bFUIYbrvtnSGw0dw ...."
 "expirationTime": null
 "keys":{
   // Receive key
   "p256dh":"BJG5rNdalnpu6yuRSuly3H321ljDVYRvDk...",
   // Auth Key
   "auth": "zG9-yhkAzIdknhMW0d89Aw"
 }
}</code>

<ol><li>We send our subscription object to our Express server and store it.</li><li>Now that we have the key on our server we do some very interesting encryption magic with our server's private key (the one which matches the public key in step 3). 
Then we send our encrypted message to the endpoint.</li>
</ol>
If you want to learn more about the encryption process I highly recommend reading about it in <a href="https://blog.mozilla.org/services/2016/08/23/sending-vapid-identified-webpush-notifications-via-mozillas-push-service/">this MDN article</a>.

<ol><li>The push server (managed by Apple, Mozilla, Google,…), will analyze your request, and if it's valid send the push notification to our application.</li><li>Our service worker will catch the notification in the <code>'push'</code> event listener. 
And then we can do whatever we want with that information.</li>
</ol>
Phewww finally done. 
This is all we need to know for the purpose of this article. 
Let's code now!

<h3>Subscribing to a Push Notification in Javascript</h3>
Here's how we subscribe on the client:

<code>(async () => {
 if('serviceWorker' in navigator) {
   // We first get the registration
   const registration = await navigator.serviceWorker.ready;
   // Asking for the subscription object
   let subscription = await registration.pushManager.getSubscription();

   // If we don't have a subscription we have to create and register it!
   if (!subscription) {
     subscription = await subscribe(registration);
   }
   // Implementing an unsubscribe button
   document.getElementById('unsubscribe').onclick = () => unsubscribe();
 }
})()

// We use this function to subscribe to our push notifications
// As soon as you run this code once, it shouldn't run again if the initial subscription went well
// Except if you clear your storage
const subscribe = async (registration) => {
 // First get a public key from our Express server
 const response = await fetch('/vapid-public-key');
 const body = await response.json();
 const publicKey = body.publicKey;

 // this is an annoying part of the process we have to turn our public key
 // into a Uint8Array
 const Uint8ArrayPublicKey = urlBase64ToUint8Array(publicKey);

 // registering a new subscription to our service worker's Push manager
 const subscription = await registration.pushManager.subscribe({
   // don't worry about the userVisible only atm
   userVisibleOnly: true,
   applicationServerKey: Uint8ArrayPublicKey
 });

 // Sending the subscription object to our Express server
 await fetch('/subscribe',
   {
     method: 'POST',
     headers: { 'Content-Type': 'application/json' },
     body: JSON.stringify(subscription.toJSON())
   }
 );
 return subscription;
};

// Let's create an unsubscribe function as well
const unsubscribe = async () => {
 const registration = await navigator.serviceWorker.ready;
 const subscription = await registration.pushManager.getSubscription();

 // This tells our browser that we want to unsubscribe
 await subscription.unsubscribe();

 // This tells our Express server that we want to unsubscribe
 await fetch("/unsubscribe", {
   method: "POST",
   headers: { "Content-Type": "application/json" },
   body: JSON.stringify(subscription.toJSON())
 });
 writeSubscriptionStatus("Unsubscribed");
};

// This simply shows our user that they are unsubscribed
const writeSubscriptionStatus = subscriptionStatus => {
 document.getElementById("status").innerHTML = subscriptionStatus;
};

// I have found this code (or variations of) from; multiple sources
// but I could not find the original author
// here's one such source:
// https://stackoverflow.com/questions/42362235/web-pushnotification-unauthorizedregistration-or-gone-or-unauthorized-sub
const urlBase64ToUint8Array = (base64String) => {
 const padding = '='.repeat((4 - base64String.length % 4) % 4);
 const base64 = (base64String + padding)
   .replace(/\-/g, '+')
   .replace(/_/g, '/');

 const rawData = window.atob(base64);
 const outputArray = new Uint8Array(rawData.length);

 for (let i = 0; i &lt; rawData.length; ++i) {
   outputArray[i] = rawData.charCodeAt(i);
 }
 return outputArray;
};</code>

<h3>Setting up Push Notifications on our Express Server</h3>
There is a lot of complex encryption going on our server. 
So we are going to use a library called <code>web-push</code> to take care of it for us:

<code>$ npm install --save web-push
# or:
$ yarn add web-push</code>

Module: app.js

<code>// ... 
See previous article for the rest of the code
const bodyParser = require('body-parser');

const webPush = require('web-push');

// for this application we use allSubscription object to manage our subscriptions
// this is NOT GOOD for production since it makes our application stateful
const allSubscriptions = {};

// We use webpush to generate our public and private keys
const { publicKey, privateKey } = webPush.generateVAPIDKeys();

// We are giving webpush the required information to encrypt our data
webPush.setVapidDetails(
 'https://jmisteli.com',
 publicKey,
 privateKey
);

// bodyParse.json() allows us to easily read json bodies
app.use(bodyParser.json());

// Send our public key to the client
app.get('/vapid-public-key', (req, res) => res.send({ publicKey }));

// Allows our client to subscribe
app.post('/subscribe', (req, res) => {
 const subscription = req.body;
 registerTasks(subscription);
 res.send('subscribed!');
});

const registerTasks = (subscription) => {
 const endpoint = subscription.endpoint;

 // the endpoints are the keys of our subscriptions object
 // Every 3 seconds we will send a notification with the message 'hey this is a push!'
 const intervalID = setInterval(()=>{
     sendNotification(subscription, 'Hey this is a push!')
 }, 3000);
 allSubscriptions[endpoint] = intervalID;
}

// Allows our client to unsubscribe
app.post('/unsubscribe', (req, res) => {
 const endpoint = req.body.endpoint;
 // We find the client's endpoint and clear the interval associated with it
 const intervalID = allSubscriptions[endpoint];
 clearInterval(intervalID);
 // We delete the key
 delete allSubscriptions[endpoint];
});

// This function takes a subscription object and a payload as an argument
// It will try to encrypt the payload
// then attempt to send a notification via the subscription's endpoint
const sendNotification = async (subscription, payload) => {
 // This means we won't resend a notification if the client is offline
 const options = {
   TTL: 0
 };

 if (!subscription.keys) {
   payload = payload || null;
 }

 // web-push's sendNotification function does all the work for us
 try {
   const res = await webPush.sendNotification(subscription, payload, options);
   console.log(res, 'sent!');
 } catch (e) {
   console.log('error sending', e);
 }
}</code>

<h3>Push Notification Service worker</h3>
And finally here's how we listen for the <code>push</code> even in the service worker on the client:

Module: /public/sw.js

<code>self.addEventListener('push', function (e) {
 const message = e.data;

 // The notificationOptions will shape the look and behavior of our notification
 const notificationOptions = {
   body: `Time is the message: ${message}`,
   // we use the images from the PWA generator we made
   icon: '/images/icons/icon-512x512.png',
   vibrate: [100, 50, 100],
   data: {
     dateOfArrival: Date.now(),
     primaryKey: '2'
   },
   actions: [
     {
       action: 'close',
       title: 'Close'
     }
   ]
 };
 e.waitUntil(
   // We use the service worker's registration `showNotification` function to display the Notification
   self.registration.showNotification(' You got notified! ', notificationOptions)
 );
});</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/615cd271e41e31633d37fdd8bb2db8fbd8a8e5f9/9cae4/images/js/push-notifications/succesfull_pill_notification.png" width="450">

For more details about how the Notifications API work check out <a href="https://alligator.io/js/notifications-api">Going Native with the Web Notifications API</a>.

We are finally done for this section. 
I realize this is a big one so if you have any questions or comments please send us a message <a href="https://twitter.com/alligatorio">on Twitter</a>!


<h2>Exploring Trees via JavaScript</h2>

Trees are hands-down the most common data structure that you already interact with. 
From your file system to the DOM, many of the things your computer does is entirely dependent on generating and manipulating trees.

<h3>What's a Tree?</h3>
In short, a tree is a collection of nodes/values where each node points to descending nodes and all connect to a single parent node. 
Let's look at the tree you're probably most familiar with: the DOM.

At the root of the tree we have the <code>document</code> (actually the window but shhh) and every HTML tag we add creates a new child node under it. 
The main point about trees is that no matter how many nodes we have we could pick anyone at random and always be able to trace our way back to the root or any other element.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/fda3def6ce8a97d8b5e5474ae9c2e3bfb7dd430e/11e27/images/js/trees/dom-tree.png" width="600">

<h3>Valid vs Invalid Trees</h3>
Previously, when we created <a href="https://alligator.io/js/linked-lists-implementation/">linked lists</a> we were technically already making viable trees because they have a root (the head/tail) and each node was connected to a child with the next/prev pointers. 
Starting from any node we could always find our way back to a single root, but it's a bit trivial with just a single chain of nodes.

All of these are valid trees. 
Most of our different structures based off of trees will be pertaining more with how the data inside the trees are organized, but they'll all look something like this.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f78b799d85473eaee58df9666f7fae755e1c59dc/3729c/images/js/trees/valid-trees.png" width="600">

There are some rules we need to follow to have a proper tree. 
A tree cannot reference its own root, for example if we ran a traversal algorithm on a circular linked list then it would quickly become a recursion nightmare. 
We also can't have more than one root or a node with more than one parent.

Finally, a tree must have a directionality to it with everything moving out from the root. 
A cluster of nodes without a direction is actually its own much more complicated structure, graphs, which we'll cover in future articles .

We can't just start linking nodes together and call it a tree, if we break these rules then future data structures and algorithms just won't be possible.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/12ad03acee9f8b4a28b0252dbb82388a45a92e40/99f54/images/js/trees/invalid-trees.png" width="600">

<h3>Tree Anatomy</h3>
While pretty boring it's still necessary to cover the most important terminology you'll constantly see as you learn more about trees.
<li>
<code>Node</code> - Each single object or data point.</li><li>
<code>Root</code> - The first and uppermost node in the tree from which all other nodes are derived from.</li><li>
<code>Edge</code> - A connection between two nodes.</li><li>
<code>Parent</code> - The immediate ancestor of a lower node.</li><li>
<code>child</code> - The immediate descendant of a higher node.</li><li>
<code>Siblings</code> - Two nodes on the same depth with the same parent.</li><li>
<code>Leafs</code> - The bottommost nodes with no children.</li><li>
<code>Depth</code> - The height of the tree measured in levels with the number of edges away from the root, so level 2 is only two edges away from the root.</li><li>
<code>Breadth</code> - The width of the tree measured by the number of leafs.</li><li>
<code>Subtree</code> - A node and its descendants which could be treated as an independent tree. 
For example, if we created a dictionary as a tree and used a search algorithm that looked at each item alphabetically we could use the node for section of the first letter as the root instead of looking at every item in the tree.</li>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7c3616bddd13260b1f6bfeadc98643d02e3fa6cd/d990c/images/js/trees/tree-anatomy.png" width="600">

<h3>Closing Thoughts</h3>
Right now this may seem like a whole lotta fluff but the devil really is in the details. 
As you progress to more elaborate structures it'll become increasingly easier to overlook these details and drown yourself in very hard to debug errors.


<h2>The JavaScript Thread of Execution, Visually Explained</h2>

This is the first in a series of articles looking at how JavaScript works internally. 
I will try to make it interesting and not bore you as I know this stuff can sometimes get really tedious!

Imagine being a pilot and now knowing how a plane flies, every day we run our JavaScript code but do we know how it runs?

<h3>Let's Talk About the JavaScript Thread of Execution</h3>
Ok, let's bang out some simple JavaScript code:

<code>const num = 3;

function addOne(x) {
 const result = x + 1;
 return result;
}

const output = addOne(num);</code>

The code above is nothing to get excited about but will serve us well to demonstrate the thread of execution.

When our JavaScript is executed, the code is being stepped through line by line (single-threaded), so in our code above the first line is:

<code>const num = 3;</code>

<hr>
The next question is, what happens when it steps onto this line? Where does <code>num</code> get stored?

<code>num</code> gets stored in the global memory/execution context, visually it looks like this:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1a5c111868bcf3e4e238fbe9160e20fd73b362c5/af69e/images/js/thread-of-execution/1-o.gif">

So then we move onto the next line:

<code>function addOne(x) {</code>

It's important to note that we are declaring a function here and not executing one. 
Therefore, we store the function name with the value of the entire function.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0a730a0d16e4f0f327e41234a4e8e71e42d7d236/9857a/images/js/thread-of-execution/2-o.gif">

The <code>- f -</code> above is just shorthand for the entire function.

Now we move onto the next line, some of you may think the next line is the body of the function but since we are only declaring the function and not running it, the next line to run is:

<code>const output = addOne(num);</code>

Similar to above, we send the label <code>output</code> to memory but with no value yet as we must run our function.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5283d493c899301e0ae41cdbf23d95e9463f8476/de3f6/images/js/thread-of-execution/3-o.gif">

Now comes the fun part! Actually executing our <code>addOne</code> function.

When a function is executed, it is added to the <code>call stack</code>. 
The <code>call stack</code> always has <code>global</code>/<code>main</code> at the bottom, we now will push on <code>addOne(3)</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/33f1315074e44efcc84856fd6542437115c07cc3/4dccd/images/js/thread-of-execution/4-o.gif">

We also create an <code>execution context</code> for that function. 
Any variable declared in the function will be added to the function's execution context.

The first variables that will be added are the function's arguments, in our case <code>x</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9a9d0c1ab13764aa05e1b1ec149037ee39c4e7a2/2a7f0/images/js/thread-of-execution/5-o.gif">

Now we move onto the next line and store <code>result</code> in the <code>execution context</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/80c75cefe26d1c1411c96b217c196fb7bbdea1f0/bf187/images/js/thread-of-execution/6-o.gif">

On the next line, we hit the <code>return</code> keyword which marks the end of a function. 
We pop <code>addOne()</code> from the <code>call stack</code> and give <code>output</code> a value which is <code>4</code>.

So first pop <code>addOne</code> from the <code>call stack</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dd4557158864a667667bba59e4f901ba181c35aa/4a296/images/js/thread-of-execution/7-o.gif">

Now our last step, assigning the value <code>4</code> to the <code>output</code> variable.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b05c74635aefbc9fac2758e707bef9d04063e86b/76d6d/images/js/thread-of-execution/8-o.gif">

<h3>Done!</h3>
So that's it! I hope this demonstrates how our JavaScript code is stepped through. 
I know I only touched off the <code>call stack</code> and <code>execution context</code> in this article but we will be delving deeper into them in the future.


<h2>Exploring Stacks and Queues via JavaScript</h2>

Very often, a fully decked-out <a href="https://alligator.io/js/linked-lists-implementation/">doubly linked list</a> may just be overkill for what you're trying to achieve. 
In this article, we're going to explore two extremely common minimalist variations to linked lists: <em>stacks</em> and <em>queues</em>.

Stacks and queues are opposite methods of treating incoming data, particularly when they need to be removed in a particular order. 
They are generally considered less as data structures and more as abstract data types, meaning they represent a particular usage rather than an exact structure. 
So they are more of a pattern that is implementable in many different ways with other data structures like arrays, linked lists, and even trees.

<h3>Prerequisites</h3>
Having a basic understanding of linked lists is essential for understand the list implementations, which you can get an overview on <a href="https://alligator.io/js/linked-lists-overview/">here</a>.

While not necessary for understanding stacks and queues, you should already have a grip on the essentials of Big O Notation, which I wrote a <a href="https://alligator.io/js/big-o-notation/">short intro for here</a>.

<h3>Stacks</h3>
Stacks are considered a <em>LIFO</em> structure, meaning <em>last in first out</em>. 
We add items to our stack and if some other condition is met, like a timer ran out or a task was completed, the most recently added item is the first to be removed and is the only one that we can interact with. 
I like to visualize this as washing and drying a stack of plates, as you add to the top of the stack you are restricted to only working with the topmost plate before you have access to the rest.

You've already been using stacks a lot, like with the recursion call stack or the standard JavaScript call stack when you make asynchronous requests. 
The need to strictly control the order of operations in this way is extremely common and will even help us in some less intuitive ways like traversing trees and ranking search results.

The most basic version of this would just be with a simple array. 
Stacks with an array implementation is only <code>O(1)</code>, same as with a linked list since we're only manipulating the tail and nothing needs to be re-indexed. 
We can just use our normal <code>push</code> and <code>pop</code> methods to get this done. 
As long as we only used these two functions to interact with our data we would technically have a functional stack, even if a bit lackluster.

<code>const stack = [];

const add = val => stack.push(val);
const remove = () => stack.pop();

add('one');
add('two');
add('three');
remove();
console.log(stack); // ["one", "two"]</code>

Linked lists are a bit more complicated, we have our normal nodes with only the one pointer and some <code>add</code> and <code>remove</code> methods. 
If there's nothing in the list set it as the head and tail or null, else change the pointer on the item before it. 
It doesn't matter if we're adding/removing on the head or tail, as long as that's the only one we're interacting with.

This method would be preferred if you were hooked up to a database that contained a lot of nodes. 
Since arrays are loaded in at a fixed size, linked lists would be better to load-in only necessary chunks of data.

<code>class Node {
 constructor(val) {
   this.val = val;
   this.next = null;
 }
};

class Stack {
 constructor() {
   this.head = null;
   this.tail = null;
   this.length = 0;
 }
 add(val) {
   const newNode = new Node(val);

   if (!this.head) {
     this.head = newNode;
     this.tail = newNode;
   } else {
     const temp = this.head;
     this.head = newNode;
     this.head.next = temp;
   };

   this.length++;
   return this;
 }
 remove() {
   if (!this.head) return null;

   let temp = this.head;
   this.head = this.head.next;

   this.length--;
   return temp.val;
 }
};

let stack = new Stack()
stack.add('one')
stack.add('two')
stack.add('three')
stack.remove()
console.log(stack) // two -> one</code>

<h3>Queues</h3>
Queues are the reverse of stacks with a <em>FIFO</em> structure, meaning <em>first in first out</em>. 
This is exactly like standing in line, you showed up first so you get to go first.

Likewise we can still do an array implementation, but this time it's different. 
Since we're working from the beginning when we remove something, every removal means our computer needs to loop through the rest of the array and re-index everything, giving us <code>O(n)</code>.

<code>const queue = [];

const add = val => queue.push(val);
const remove = () => queue.shift();

add('one');
add('two');
add('three');
remove();
console.log(queue); // ["two", "three"]</code>

In this case linked lists are almost always superior for dealing with larger amounts of data since it avoids the re-indexing problem.

It doesn't matter which end we add to as long as we remove from the other, in this case we'll add to the tail and remove the head.

<code>class Queue {
 constructor() {
   this.head = null;
   this.tail = null;
   this.length = 0;
 }
 enqueue(val) {
   const newNode = new Node(val);

   if (!this.head) {
     this.head = newNode;
     this.tail = newNode;
   } else {
     this.tail.next = newNode;
     this.tail = newNode;
   };

   this.length++;
   return this;
 }
 dequeue() {
   if (!this.head) return null;
   if (this.head === this.tail) this.last = null;
   let temp = this.head;
   this.head = this.head.next;

   this.length--;
   return temp.val;
 }
}

let queue = new Queue();
queue.enqueue('one');
queue.enqueue('two');
queue.enqueue('three');
queue.dequeue();
console.log(queue); // two -> three</code>

<h3>Closing Thoughts</h3>
This may seem like making splitting hairs from our normal linked lists and arrays, but as we progress to increasingly sophisticated structures, stacks and queues will become an essential component to how we structure and traverse data.


<h2>Intro to Linked Lists via JavaScript - Part 2: Implementation</h2>

Back in <a href="https://alligator.io/js/linked-lists-overview/">Part 1</a> we got a birds-eye look at what linked lists are and why they're necessary for creating more advanced data structures. 
Now we can learn how to start implementing a fully-featured doubly linked list in JavaScript.

Singly linked lists and implementations in other data structures will generally just be more barebones versions of what we'll cover here, so this would be good to bookmark as a general reference.

<h3>Structure</h3>
Like any other class, we can store whatever we want in each node, the only important parts are the <code>next</code> and <code>prev</code> pointers, which should be <code>null</code> by default.

Likewise the only things our list needs are its <code>tail</code>, <code>head</code>, and <code>length</code>. 
We'll need to manually manipulate the length since, unlike arrays, it won't be calculated for us and will be necessary for searching for items.

<code>class Node {
 constructor(val) {
   this.val = val;
   this.next = null;
   this.prev = null;
 };
};

class linkedList {
 constructor() {
   this.head = null;
   this.tail = null;
   this.length = 0;
 };
};</code>

<h3>Create</h3>
Now we can start setting up all of our methods inside our <code>linkedList</code> class. 
Since we don't have any of our normal goodies like <code>push</code> or <code>shift</code> we'll have to create our own versions.

<h3>Head and Tail</h3>
Most of our operations are based more on manipulating the pointers in the surrounding nodes than on the item we want to change. 
To add something isn't just shoving a new node where we want, like with an array, but changing the pointers on the items before or after to point to our new item, then manually incrementing the list's length.

If there isn't anything in the list, we want to set the new item as both the head and tail, since it's the only item. 
To add or remove from the end of the list we'll take the current head/tail we want to replace and set its pointer to our new item or null, change the list's head/tail to our new node or null, then increment the length.

<code>addHead(val) {
 let newNode = new Node(val);

 if (!this.head) {
   this.head = newNode;
   this.tail = this.head;
 };

 this.head.prev = newNode;
 newNode.next = this.head;
 this.head = newNode;

 this.length++;
 return this;
}

addTail(val) {
 let newNode = new Node(val);

 if (!this.head) {
   this.head = newNode;
   this.tail = newNode;
 };

 this.tail.next = newNode;
 newNode.prev = this.tail;
 this.tail = newNode;

 this.length++;
 return this;
}

removeHead() {
 let removed = this.head;
 if (!this.head) return undefined;

 this.head = this.head.next;
 this.head.prev = null;

 this.length--;
 return removed;
}

removeTail() {
 let removed = this.tail;
 if (!this.tail) return undefined;

 if (this.length === 1) {
   this.head = null;
   this.tail = null;
 };

 this.tail = removed.prev;
 this.tail.next = null;

 this.length--;
 return removed;
}</code>

<h3>Find</h3>
Since we don't have an index to get our item by we're going to have some problems with inserting/removing in the middle of the list, so we're going to need our own utility function.

It's very simple, we just need to store the current item and use a <code>for</code> or <code>while</code> loop to use our pointers to update <code>current</code> until we're at the item we want.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b7c181cb6c388f249362800c21d758c27884fa4d/4283a/images/js/linked-lists-implementation/linked-list-find.gif" width="450" alt="Animation: Finding">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
Of course, this gives us an <code>O(n)</code> search time, but since we're using a doubly linked list we can just start from the tail if what we want is past the middle of the list, giving us <code>O(n / 2)</code>.

<code>find(index) {
 let current
 if (index &lt; 0 || index >= this.length) return undefined;

 if (index &lt;= this.length / 2) {
   current = this.head;
   for (let i = 0; i &lt; index; i++) current = current.next;
 } else {
   current = this.tail;
   for (let i = this.length; i > index; i--) current = current.prev;
 }

 return current;
}   </code>

<h3>Insert and Remove</h3>
Now that we have our little utility in place we can use it to find the item in the index we want then set the pointers on it and the item before and after it to our new node, thus “stitching” it into place.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dd1a7d26acd224cbc56992760ca7ee93ce13a3c0/06314/images/js/linked-lists-implementation/linked-list-insert.gif" width="450" alt="Animation: inserting">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
If the index is on the head or tail, we can just reuse our previous methods.

<code>insert(val, index) {
 if (index &lt; 0 || index > this.length) return null;
 if (index === this.length) return this.addTail(val);
 if (index === 0) return this.addHead(val);

 let prev = this.find(index - 1),
     newNode = new Node(val),
     temp = prev.next;

 prev.next = newNode;
 newNode.next = temp;
 newNode.prev = prev;

 this.length++;
 return true;
}</code>

Removing is obviously just the inverse of inserting and a bit simpler. 
Find the node we want to remove and set the pointers on the surrounding nodes to each other, leaving nothing that references the removed node.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/02ba6e7f6d12681dea4f7de39b7a3d1b2bc0791c/ab96a/images/js/linked-lists-implementation/linked-list-remove.gif" width="450" alt="Animation: removing">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
<code>remove(index) {
 if (index &lt; 0 || index >= this.length) return null;
 if (index === this.length) return this.removeTail();
 if (index === 0) return this.removeHead();

 let removed = this.find(index);

 removed.prev.next = removed.next;
 removed.next.prev = removed.prev;

 this.length--;
 return removed;
}</code>

<h3>Update</h3>
This one is so simple it's almost no even worth mentioning, just find the item and reset it's value.

<code>update(val, index) {
 let node = this.find(index);
 if (node) node.val = val;
 return node;
}</code>

<h3>Conclusion</h3>
While this may have seemed like a lot of work, it's good to keep in mind that in many cases you won't need all of it.

I really recommend checking out <a href="http://mauriciosantos.github.io/Buckets-JS/">Buckets.js</a> for when you don't feel like manually making one, although it's always good to understand the concept on a deeper level.


<h2>Intro to Linked Lists via JavaScript - Part 1: Overview</h2>

As your application and data becomes increasingly complex, being restricted to basic arrays will become a major bottleneck in performance and in what you're able to accomplish. 
We're going to need to develop something greater than the most basic out-of-the-box data type that JavaScript offers us. 
With linked lists, we can build the foundation for learning more advanced data structures and algorithms.

<h3>Concept</h3>
Linked lists are a special way of using classes to create chains of connected objects. 
Each of these objects contains two pointers, one to the next node and one to the previous node.

While arrays allow you to access an item directly by its index, which is always <code>O(1)</code>, our nodes don't have indexes so we would need to start from the head or tail of the list and use the pointers to search through each item for the one we want to change, so <code>O(n)</code>.

Why would we ever want a linked list over an array? Arrays are superior when it comes to searching and sorting, because it's easier to directly access and move items. 
Linked lists are much more efficient for inserting and deleting items, particularly at the ends. 
When you insert or remove an item into an array your computer also needs to re-index the rest of the data, giving us <code>O(n)</code>, with linked lists can do it in <code>O(1)</code> plus the search time, which we have a few ways to optimize.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1cbd984b345bbcce54ac16646eca87789e648c54/3348d/images/js/linked-lists-overview/linked-lists-vs-arrays.png" width="500" alt="Linked List Diagram">

Many browsers use a linked list to record your search history, since it's much more practical for moving up and down a chain when the users rarely need to search for anything or see the whole thing.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/47a919d3cf6cd25c520d35ea38fee49324f40552/764bd/images/js/linked-lists-overview/linked-list-diagram.png" width="500" alt="History with Linked List Diagram">

While an array would let you access Google again directly, a linked list forces you to either set it as the new tail or to manually traverse back through to what you want, we cannot jump over anything in between.

<h3>Singly vs Doubly Linked Lists</h3>
There are two main ways we can setup our linked lists, either with one pointer, forcing it into one direction, or two, making it bi-directional.

Searching through a singly linked list requires us to look at each item for what we want, while a doubly linked list can start the search from the head or tail depending on which half the item is on, giving us <code>O(n / 2)</code>.

Doubly linked lists also require more memory since each item has to store pointers for the next and previous items, which can mean a big difference if you're storing a lot of data.

Later, when we implement linked lists in other structures we'll mostly use singly linked lists. 
For example, in stack and queues we only interact with the ends and have very little need to traversing the whole list, so two pointers would just be impractical.

<h3>Why Bother?</h3>
<li>Linked lists act as the foundation for more sophisticated data structures such as stacks, queues, trees, graphs, and heaps. 
All of which have ways to build on the benefits of linked lists while nullifying some of their downsides, depending on your intended usage.</li><li>They have much better performance over arrays when you need to make a lot of additions and deletions and better search times when paired with other techniques such as using <a href="https://www.geeksforgeeks.org/skip-list/">skip lists</a>.</li><li>Easily creating a looped list by setting the next pointer on the tail to the head, such as in a carousel component.</li>

<h3>Conclusion</h3>
Hopefully after this short introduction you're ready to start exploring some better alternatives to your standard arrays. 
Check out <a href="https://alligator.io/js/linked-lists-implementation/">Part 2</a> to learn how to start implementing a fully decked-out doubly linked list in JavaScript.


<h2>JavaScript Interview Questions: Common Gotchas</h2>

In JavaScript there are little technicalities that don't quite make sense at first until you discover them. 
Now, everyone has their own list of JavaScript Gotchas, but things like “JavaScript is case sensitive” isn't a real gotcha. 
To me, that is how it should be. 
It's not a confusing trick. 
It's just technical in that way.

A true “gotcha” to me is when <code>1 == 1</code> and <code>1 == '1'</code> is true, but <code>[] == []</code> is not true. 
Albeit, this is one of the more simple “gotchas”, it still doesn't immediately appear intuitive until you delve into the “why”.

In this guide, we'll go through some of the common gotchas that you might find in a JavaScript interview. 
Interviewers probably won't directly ask these questions, but they might ask you something relative to them or to do a problem involving them.

<h3>var vs. 
let</h3>
This is one of the most basic gotchas - at first the <a href="https://alligator.io/js/var-let-const/"><code>var</code> and <code>let</code></a> keywords seemed so similar to me, I couldn't tell there was any difference. 
But, here is a common way to show the difference:

<code>// let
for(let i=0; i&lt;10; i++) {
 //...
}
console.log(i) // Reference Error: i is not defined

// var
for(var j=0; j&lt;10; j++) {
 //...
}
console.log(j) // 10</code>

One big difference is that <code>let</code> is block-scoped - meaning it's limited to whatever block it is defined in. 
In order for the <code>console.log</code> to know what <code>i</code> is, you would have to <em>hoist</em> the <code>i</code> out of the <code>for</code> loop. 
That's exactly what <code>var</code> does behind the scenes. 
The <code>var</code> keyword is function-scoped, as in, only limited by the parent function. 
And is automatically hoisted outside the block it is declared in.

<h3>Addition vs Concatenation</h3>
<code>1 + 1; // 2, obviously
1 + "1"; // "11"</code>

As you can see, JavaScript converts numbers to strings. 
Or does it?

<code>1 - "1"; // 0 (number)
1 * "1"; // 1 (number)
1 / "1"; // 1 (number)
"1" * "1"; // 1 (yep, still a number)</code>

No, in fact JavaScript converts strings to numbers in most cases. 
In the case of the <code>+</code> operator, it's concatenated instead of added. 
Concatenated, like strings: <code>"your" + "name" // "your name"</code>.

<h3>NaN Gotchas</h3>
<code>NaN</code> stands for “not a number”. 
It's one of the more confusing (“number”s?) to deal with in JavaScript. 
For instance:

<code>NaN === NaN; // false
NaN == NaN; // false as well
typeof NaN; // number
"" == NaN; // false</code>

In fact anything equal to “NaN” is false, event though there are plenty of things that are “not a number”. 
That's why instead you must use <code>isNaN()</code>. 
But even that can be confusing:

<code>isNaN("string"); // true - what we would expect, as a string is not a number
isNaN(123); // false - also expected
// false means it's a number, right?

isNaN(""); // false - hmm...
isNaN("45"); // false - this is a string, I thought
isNaN([]); // false - wait so an empty array is a number?

isNaN([1, 2]); // true
isNaN({}); // true
isNaN(() => {}); // true</code>

<h3>Equality / Truthy vs Falsy</h3>
You may already be familiar with the differences between <code>==</code> and <code>===</code>. 
<code>==</code> checks only the value, while <code>===</code> includes type checking. 
That's why <code>1 === "1"</code> is false, but <code>1 == "1"</code> is true. 
But, did you know this is true: <code>null == undefined</code>. 
But of course, this is loose checking with the <code>==</code>.

There's also the <code>!=</code> which would be saying “not equal”. 
This is true: <code>null !== undefined</code>, but this is false <code>null != undefined</code>. 
Following? Basically, the first one is saying, “null is not exactly equal to undefined”, yet the second says, “null isn't not loosely equal to undefined” (double negative, means they are loosely equal).

But let's look at more comparisons that get even more convoluted. 
These all checkout as true:

<code>false == '0' // true
0 == false   // true
'' == 0      // true
false == ''  // true
[] == ''     // true, but we'll get to this

'1' == true  // true
1 == true    // true
'false' == true // true</code>

These are the confusing comparison checks, but they aren't technically truthy vs. 
falsy. 
They are just value checks, because remember <code>[]==[]</code> results is false and yet, “[]” is a truthy value. 
The way to check for truthy vs falsy, is putting things in an <code>if</code> block. 
For instance:

<code>if ("") {
 console.log(true);
} else {
 console.log(false);
}
// logs false

//But look at this
if ([]) {
 console.log(true);
}
// logs true - an empty array is still truthy

if ([] == "") {
 console.log(true);
}
// logs true - but look at the first one - it logged false</code>

An empty object, <code>{}</code>, also logs true. 
JavaScript is quite interesting when it comes to equality and types, but I suggest using the triple equals <code>===</code> or <code>!==</code> for your comparisons.

Now, the last example is a good picture of a key distinction. 
The loose equality checks, checks for value, not necessarily falsy/truthy. 
<code>if</code> blocks check for falsy/truthy. 
See, in JavaScript this is true: <code>[] == false</code>. 
But as we saw above, an <code>if</code> block checks an empty array as truthy. 
Obviously, <code>if(false)</code> will not go anywhere.

<h3>Automatic Semicolon Insertion</h3>
I've noticed that if I forgot to add a semicolon to end one line of code, it doesn't give me an error. 
Behind the scenes <a href="http://www.bradoncode.com/blog/2015/08/26/javascript-semi-colon-insertion/">Automatic Semicolon Insertion</a> inserts the missing semicolon, which is okay, but could create a bad habit. 
Some statements need the semicolon or JavaScript might not know they have ended, while others, as we will see, haven't ended at all, but JavaScript thought it had.

<code>function increment(num) {
 return
 ++num
}
console.log(increment(3))</code>

Now that's not the best example in the world, but it might surprise you that it returns <code>undefined</code>. 
That's because a semicolon is secretly inserted at the end of “return” and the next line of code is never reached. 
A little bit like this:

<code>function increment(num) {
 return;
 ++num;
}
console.log(increment(3));</code>

<h3>Global Variables</h3>
Finally, JavaScript has this weird behavior of creating global variables out of thin air. 
This circles back to our first gotcha dealing with <code>let</code> vs <code>var</code> keywords.

Remember we said that <code>let</code> is block-scoped, while <code>var</code> is function-scoped? What then is this?

<code>for(i = 0; i &lt; 10; i++) {
 // ...
}
console.log(i); // 10</code>

Notice what we did? There is no definition to the “i” variable: <code>i=0</code>. 
What's the result? A global variable was created. 
This is a dangerous thing, because now our <code>i</code> variable is global.

This is also true in any function: <code>function someFn() { someVar = 0; }</code>. 
The <code>someVar</code> here becomes a global variable and it's akin to saying <code>window.var = 0</code>.

<h3>Conclusion</h3>
JavaScript has some tricky stuff to navigate and the truth is interviewers will quiz you on them, even if you wouldn't practically ever see them in a real-life scenario. 
But, what are you to do?

The good news is, there is plenty of documentation and video-teachings out there to show you these things. 
I would recommend doing a search for things like “JavaScript tough interview questions” or “JavaScript tricky questions”. 
And even if you don't get them in an interview, at least you know them for future problems if they ever come up. 
Plus, you can trick your friends with them as well!

Best of luck and when in doubt, just remember these are things all developers face - you aren't alone!


<h2>Understanding Radix Sort Through JavaScript</h2>

Because of the nature of comparison-based sorting, it's mathematically impossible to improve much beyond <code>O(nlogn)</code>, like with <a href="https://alligator.io/js/understanding-merge-sort/">merge sort</a> and <a href="https://alligator.io/js/quick-sort/">quick sort</a>. 
Instead, we can be a bit more clever and avoid comparisons all together to get something closer to <code>O(n * m)</code>.

<h3>Prerequisites</h3>
A basic understanding of <a href="https://alligator.io/js/big-o-notation/">Big O Notation</a> is essential to think about radix sort relative to other algorithms.

<h3>Concept</h3>
Radix sort, also known as bucket sort, is one of the oldest sorting algorithms and even pre-exists computers. 
It was used to sort punched cards back in the 1880s.

It's based on the idea of having a sub-array, or bucket, for each type of data we need to compare, like A-Z or in our case 0-9. 
We take the first character/digit in each item, add the whole item to it's corresponding bucket, then put them back into an array while retaining their new order.

We can then move on to the next character/digit and repeat the process. 
When an item runs out of characters/digits we'll add it to the first bucket, since everything else is obviously larger/longer. 
When we've done this as many times as the number of digits/characters of the largest item, our array will have been completely sorted without making any pesky comparisons.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0bcfc21862c14fc269d206bf91315058e9f13b34/dc86e/images/js/radix-sort/radix-sort-animation-o.gif">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
<h3>Practice Data</h3>
Since numbers are much simpler, we can practice with an array of them from 1 to 50.

<code>const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];</code>

<h3>Utilities</h3>
Since we're working with numbers, we want to start with the smallest number place and work up, so we'll need a way to get each number at an index starting from the right.

The most intuitive way I've found is to take the number we want, convert it into a string, and select from it as an array with a negative index. 
If a number's not at that index we can just return a zero so it'll be placed in the front of our sorted array.

<code>const getNum = (num, index) => {
 const strNum = String(num);
 let end = strNum.length - 1;
 const foundNum = strNum[end - index];

 if (foundNum === undefined) return 0;
 else return foundNum;
};

console.log(getNum(4353, 2));</code>

Because we're working back one digit at a time we need the algorithm to run as many times as the longest number, so if we have an item with 8 digits, it needs to be ran 8 times. 
Radix sort's average complexity is <code>O(n * m)</code> because it's the amount of items times the amount of times it needs to be ran.

To get how many times it should run we can search through the array for the largest number, then return its length.

<code>const largestNum = arr => {
 let largest = "0";

 arr.forEach(num => {
   const strNum = String(num);

   if (strNum.length > largest.length) largest = strNum;
 });

 return largest.length;
};</code>

<h3>Radix Sort</h3>
Implementation is pretty straight-forward, for every digit place we can use <code>Array.from</code> to create 10 empty buckets. 
For every item they'll be placed in the corresponding bucket, when that's done we'll flatten the array of buckets into a single array to start over with the next character place. 
When we've reached the end of our longest digit our fully sorted array can be returned.

<code>const radixSort = arr => {
 let maxLength = largestNum(arr);

 for (let i = 0; i &lt; maxLength; i++) {
   let buckets = Array.from({ length: 10 }, () => []);

   for (let j = 0; j &lt; arr.length; j++) {
     let num = getNum(arr[j], i);

     if (num !== undefined) buckets[num].push(arr[j]);
   };
   arr = buckets.flat();
 };
 return arr;
};

console.log(radixSort(unsortedArr));</code>

<h3>Conclusion</h3>
While playing around with this, I tried it on an array of 5,000 items, to my utter amazement it was done in only 23 milliseconds! I don't know about you, but I think that's an incredible improvement over the other algorithms we've covered so far.


<h2>How to Build a PWA in Vanilla JavaScript</h2>

This is the first part of a three-part series about creating a Progressive Web App (PWA) which leverages the Web Push API and cron-schedule. 
In this article, we'll cover the basics: the front-end, web app manifest and Service Worker aspect of the app, and we'll be only using pure JavaScript to accomplish this. 
At the end of this post we'll have a working PWA that's cached so it can be accessed while offline.

<h3>What We Are Building</h3>
My physician recently told me to take 3 pills a day. 
On my way back home I told myself: “I am a developer, I automate tasks, let's build an app to help me take my pills”.

We're going to build a simple Progressive Web App (PWA) which will remind me to take my pills every day.

Our app will have a web server powered by Express.js. 
Express will push notifications to the clients which subscribed to the push notifications. 
It will also serve the front-end app.

<h3>Step one: PWA</h3>
The app we're building has to remind us to take pills even when the browser is not opened. 
So we need a <a href="https://alligator.io/js/intro-progressive-web-apps/">Progressive Web App</a>.

<h3>Getting the manifest up and ready</h3>
My first step building a PWA is to generate a manifest using <a href="https://app-manifest.firebaseapp.com/">this generator</a>. 
This tool will create your <code>manifest.json</code> file which holds all basic information about your app. 
It will also create some icons which will show on the user's phones when they download the app.

Just unzip everything inside a folder at the root of our project that we'll call <code>public</code>. 
I decided to call my app Temporas.

Module: public/manifest.js

<code> "name": "Temporas",
 "short_name": "Temporas",
 "theme_color": "#222831",
 "background_color": "#ffad17",
 "display": "standalone",
 "Scope": "",
 "start_url": "/index.html",
 "icons": [
   // A lot of icons
 ]</code>

PWAs rely on <a href="https://alligator.io/js/service-workers/">Service Workers</a>. 
Service workers are little programs that run as soon as they are registered independently from the rest of your JavaScript code. 
Service workers can't interact directly with the DOM but can send messages to the rest of your code (we'll explore this in more detail in part 2 of this series).

<hr>
Now let's create our frontend and register our service worker:

Module: public/index.html

<code>&lt;!DOCTYPE html>
&lt;head>
 &lt;meta name='viewport' content='width=device-width, initial-scale=1'>
 &lt;meta name="theme-color" content="#222831">
 &lt;link rel='manifest' href='./manifest.json'>
 
 &lt;script>
   // Registering our Service worker
   if('serviceWorker' in navigator) {
     navigator.serviceWorker.register('sw.js', { scope: './' })
   }
 &lt;/script>
&lt;/head>
&lt;body>
 &lt;div class="hero">
   &lt;h1>Temporas&lt;/h1>
   &lt;h3>Take your medicine my friend&lt;/h3>
   &lt;div id="status">&lt;/div>
   &lt;button id="unsubscribe">unsubscribe&lt;/button>
 &lt;/div>
&lt;/body></code>

We are now one file away from having an installable web application. 
Let's create our service worker:

Module: public/sw.js

<code>const cacheName = 'Temporas';

// Cache all the files to make a PWA
self.addEventListener('install', e => {
 e.waitUntil(
   caches.open(cacheName).then(cache => {
     // Our application only has two files here index.html and manifest.json
     // but you can add more such as style.css as your app grows
     return cache.addAll([
       './',
       './index.html',
       './manifest.json'
     ]);
   })
 );
});

// Our service worker will intercept all fetch requests
// and check if we have cached the file
// if so it will serve the cached file
self.addEventListener('fetch', event => {
 event.respondWith(
   caches.open(cacheName)
     .then(cache => cache.match(event.request, { ignoreSearch: true }))
     .then(response => {
       return response || fetch(event.request);
     })
 );
});</code>

 We have a PWA 

<h3>Setting up Express.js</h3>
The PWA will not work if you just open <code>/public/index.html</code> in your browser. 
We must serve our content from a web server.

First let's set things up in our command line. 
In your root folder run:

<code>$ npm init
$ npm install express body-parser
$ touch app.js</code>

Inside of <code>package.json</code> replace the <code>scripts</code> field with:

<code>"scripts": {
 "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
 "start": "node app.js"
}</code>

And now let's populate our app:

Module: app.js

<code>const bodyParser = require('body-parser');
const express = require('express');
const app = express();
const port = 3000;

// We want to use JSON to send post request to our application
app.use(bodyParser.json());

// We tell express to serve the folder public as static content
app.use(express.static('public'));

app.get('/public');

app.listen(port, () => console.log(`Listening on port ${port}!`));</code>

Now you can run <code>npm run start</code>. 
Go to http://localhost:3000, kill the server. 
Reload http://localhost:3000 and the app will look like it is still working! You can even turn off your laptop and go back to the web page on that port.

I highly advise disabling the caching mechanism of service workers when you are developing new features. 
It might cause some confusion.

<a href="/nodejs/express-basics/">Here's a good post</a> if you want to learn more about setting up an Express server.

<h3>Checking your PWA</h3>
To test your PWA I highly recommend using the <a href="https://developers.google.com/web/tools/lighthouse">Lighthouse extension</a> to see if everything is working. 
Remember also that when comes the time to deploying your app on the web, it needs to be served over HTTPS to be considered a PWA and to be installable as an app.

You can find all the code in this <a href="https://github.com/alligatorio/Vanilla-JS-PWA">Github repository</a>.


<h2>Understanding Quick Sort via JavaScript</h2>

One problem of working with <a href="https://alligator.io/js/understanding-merge-sort/">merge sorts</a> is that they need to create and store so many arrays in memory with mostly the redundant data. 
If we're limited on memory, we can resort to a <strong>quick sort</strong> to run it “in place”, meaning the changes and results all happen directly with what's being sorted, thus saving on memory.

<h3>Prerequisites</h3>
We're going to be going over the standard recursive version, although you can do this iteratively, so understanding how recursion works will be helpful, which you can <a href="https://alligator.io/js/understanding-recursion/">brush up on here</a>.

<h3>Concept</h3>
Quick sort is definitely one of the less intuitive algorithms, so here's a very simple overview.

We select a number, called our <code>pivot</code>, which we'll compare every number to when we loop through our items. 
The goal is to reorganize the array so it is partitioned into two halves, with everything in each either being less than or greater than our pivot. 
When the pivot is in it's final position we'll move on to doing the same thing with a new pivot, with every pivot being cemented in place until every item has been a pivot at least once.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/faff4457e2340b6da65c299e58ff7c419a91aaa5/f605c/images/js/quick-sort/quick-sort-animation.gif" width="350" alt="Quick Sort Animation">
 Graphic/Animation thanks to <a href="https://visualgo.net">VisuAlgo.net</a>
Like merge sort, the complexity on average is O(nlogn), so it's up to you which you prefer.

<h3>Practice Data</h3>
As always, here's an unsorted array of 50 random numbers to play with. 
I also recommend looking into JavaScript's <a href="https://alligator.io/js/js-performance-api/">performance api</a> to compare it to other algorithms and with different data.

<code>const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];</code>

<h3>Pivot</h3>
Firstly, we'll need our pivot utility function. 
There's 4 main parts to this, our swapper, the loop, the pivot itself, and our pointer.

Our pointer is just a placeholder for our pivot. 
Every time our loop progresses, each item is compared to the pivot and if it is smaller it's swapped with our pointer. 
Every time we do this is to ensure that the pointer is ahead of everything smaller than the pivot and before everything that's larger. 
When everything is complete, and our array is partitioned, then we can assign the pivot to the pointer's index as its final position.

Our swap works by just reassigning the indexes of each item with each other's index, nothing too crazy.

<code>const pivot = (arr, start = 0, end = arr.length + 1) => {
 const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]];

 let pivot = arr[start],
     pointer = start;

 for (let i = start; i &lt; arr.length; i++) {
   if (arr[i] &lt; pivot  ) {
     pointer++;
     swap(arr, pointer, i);
   }
 };
 swap(arr, start, pointer);

 return pointer;
}</code>

<h3>Quick Sort</h3>
Implementation is simultaneously pretty simple and a bit confusing, as recursion tends to be. 
We're going to use our <code>pivot</code> function to get the first sorted item from our array. 
With that, we'll recursively run our <code>quickSort</code> to do the same process on the first half of our partitioned array, which will repeat until there's nothing left to sort, then do the same for the other half. 
When both are done our fully sorted array can be returned.

<code>const quickSort = (arr, start = 0, end = arr.length) => {
 let pivotIndex = pivot(arr, start, end);

 if (start >= end) return arr;
 quickSort(arr, start, pivotIndex);
 quickSort(arr, pivotIndex + 1, end);

 return arr;
};

console.log(quickSort(unsortedArr));</code>

<h3>Conclusion</h3>
Quick sort was definitely one of the most difficult sorting algorithm to wrap my head around. 
Between having 4 changing parts and 2 recursion stacks, this is definitely something you probably shouldn't expect to remember perfectly and may want to bookmark for later reference.


<h2>Going Native with the Web Notifications API</h2>

In my opinion, notifications are ONE of the main features that separate a website from an app, especially now that Progressive Web Applications (PWAs) are all the rage. 
So having notifications showing up will make your site feel even more like a native app.

The Notifications API's interface is through the JavaScript <code>Notification</code> object, which has a lot of properties. 
Some are <em>visual</em>, others <em>programmatic</em>, some are just metadata and others are even <em>audio-sensorial ones</em>!

The visual properties are as follow:

<code>const notificationsProperties = {
 "title": "Picture Time",
 "body": "Time to look at some random pictures",
 "icon": "https://picsum.photos/200",
 "image": "https://picsum.photos/400",
 // A badge is an image we display
 // when there is not enough space to display the notification
 "badge": "https://picsum.photos/300/200",
 // Direction decides if the notification goes
 // from left to right, right to left or let the browser decide
 "dir": "ltr",
 // As part of the direct user experience we also have 
 // Audio- ....
 "silent": ""
 // ... 
sensorial
 "vibrate": [200, 100, 200],
}</code>

<code>title</code>, <code>body</code>, <code>icon</code>, <code>image</code> and <code>badge</code> will all look different depending on the operating system you are using. 
Here is what it looks like on Windows 10:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/560d254a97f97a63cd784570756d91b14a77c053/95da9/images/js/notifications-api/windows-notification-screenshot.jpg">

<hr>
Now let's take a look at our more programmatic properties (feel free to criticize my classification I'm not super happy with it either ).

<code>{
 //...
 onshow: () => console.log("We are showing a Notification"),
 onerror: () => console.log("There was an error showing a Notification"),
 onclose: () => console.log("Closing the Notification"),
 // Informs the user if a notification replaced a previous one
 renotify: null,
 // If set to true the notification will stick to the screen until the user interacts with it
 requireInteraction: true,
 // We'll get into actions later
 actions: []
}</code>

We're not going to explore what you can do with the metadata here. 
But here they are for good measure:

<code>{
 "lang": "",
 "tag": "",
 "timestamp": 1581390179474,
 "data": null
}</code>

<h3>Creating a Notification</h3>
Now that we sort of know what is in a notification, let's take a look on how we can create it:

<code>const notification = new Notification('Stop Working', notificationsProperties);</code>

DONE! It is pretty easy. 
But two important things:
<li>The first one is not very important. 
You might have noticed in our screenshot that the title of the notification was <em>Stop Working</em>. 
But in our options we set : <code>"title": "Picture Time"</code>. 
That is because the title can only be set in the notification constructor which we set as <em>“Stop Working”</em>.</li><li>Second important thing. 
We cannot just force notifications to our users. 
We need to get their permission first. 
If you want to learn more about permissions you might want to check out our article about the (Permission API)[/js/permissions-api/].</li>

Here's a short snippet for dealing with asking for permission:

<code>// Checking if we already have permission to send notifications
const notificationsAllowed = await navigator.permissions.query({name: 'notifications'});

if (notificationsAllowed.state !== 'granted'){
 // Requesting permission
 const permission = await Notification.requestPermission();

 // If the permission is not granted the application won't work
 if (permission !== 'granted') {
   // I am a very sour developer so I replace all of my page with an error message
   // DON'T DO LIKE ME AND BE A FRIENDLY DEV INSTEAD!
   document.body.innerHTML = '&lt;h1> This app can\'t work without notification bye &lt;/h1>';
   return;
 }
}
// Then you can continue with your notification driven code</code>

You can also get the notifications status by running:

<code>const notificationsAllowed = Notification.permission;</code>

<h3>Actions</h3>
Actions are little buttons at the bottom of your notifications. 
We can define them as followed:

<code>actions: [{
 title: 'Show More',
 action: () => {console.log('code to show more images');}
},{
 title: 'Close',
 action: () => { console.log('Bye bye');}
}]</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bd2f49066f07711efb1f261af909e8d8654ba97d/b4743/images/js/notifications-api/windows-notification-screenshot-actions.jpg">

However you can't just add actions to your notification options as we did before. 
We can only register them in a <a href="https://alligator.io/js/service-workers/">service worker</a>:

Module: main.js

<code>if('serviceWorker' in navigator) {
 // First we need to register our service worker
 navigator.serviceWorker.register('serviceWorker.js', { scope: './' })
   .then(async () => {
     //... 
check if notifications are allowed
     // ... 
define notificationsProperties with actions
     const serviceWorkerRegistration = navigator.serviceWorker.ready
     // This will show the notification with the actions
     serviceWorkerRegistration.showNotification('Stop Working', notificationsProperties);
   });
}</code>

And there you are you have notifications which can also work offline!

<hr>
Inside of our Service Worker we can register event listeners to see how our users interact with our notifications:

Module: serviceWorker.js

<code>self.addEventListener('notificationclick', (event) => {
	console.log('our user clicked on the notification!')
   // Send user data analytics   
}, false);</code>

And there you are! I hope you learned a few tricks and will develop some fancy websites/web apps with a native feel .


<h2>4 Methods to Search Through Arrays in JavaScript</h2>

In JavaScript, there are plenty of useful ways to find items in Arrays. 
You could always resort to the basic <code>for</code> loop, but with ES6+ there are plenty of methods to loop over the array and find what you need with ease.

With so many different methods, which one do you use and in which case? For instance, when searching through an array, do you want to know if the element is in the array at all? Do you need the index of the element or the element itself?

With each different method that we'll cover, it's important to understand that they're all built-in methods on the Array.prototype. 
That means you simply need to chain them onto any array with dot notation. 
That also means these methods are not available on objects or anything else other than Arrays (though there is overlap with Strings).

We'll look at the following Array methods:
<li><a href="#includes">Array.includes</a></li><li><a href="#find">Array.find</a></li><li><a href="#indexof">Array.indexOf</a></li><li><a href="#bonus-filter">Array.filter</a></li>

<h3>includes</h3>
<code>const alligator = ["thick scales", 80, "4 foot tail", "rounded snout"];

alligator.includes("thick scales"); // returns true</code>

The <code>.includes()</code> method returns a boolean value and is perfect for telling you whether an element exists in an array or not. 
It gives a simple <code>true</code> or <code>false</code> answer. 
This is the basic syntax:

<code>arr.includes(valueToFind, [fromIndex]);</code>

Now as you see in our example, we only had one parameter - the valueToFind. 
This is the value to match in the array. 
The optional fromIndex is a number, indicating what index you want to start looking from (default is 0, so the entire array is searched). 
So, since in our example the ‘thick scales' item is at the 0 index, the following would be false: <code>alligator.includes('thick scales', 1);</code> since it starts searching from index 1 and on.

Now, there are a few important things to notice. 
This <code>.includes()</code> method uses strict comparison. 
That means, from the example above, the following would return false: <code>alligator.includes('80');</code> That's because though <code>80 == '80'</code> is true, <code>80 === '80'</code> is false - different types won't pass strict comparison.

<h3>find</h3>
How is <code>.find()</code> different from the includes() method? If in our example we only changed the text “includes” to “find” we would get this error:

<code>Uncaught TypeError: thick scales is not a function</code>

That's because the find method requires a function to be passed in. 
That's because the find method isn't going to just use the simple comparison operator like “includes()” does. 
Instead, it will pass each element into your function and see whether it returns true or false. 
So, although this works: <code>alligator.find(() => 'thick scales');</code>, you would probably want to put your own comparison operator in the function for it to return anything relevant.

<code>const alligator = ["thick scales", 80, "4 foot tail", "rounded snout"];

alligator.find(el => el.length &lt; 12); // returns '4 foot tail'</code>

This simple function in our find method looks at each element of the array, with the alias of ‘el' we assigned it, and stops when it finds the first one which is true. 
In our case, true is having a length property of less than 12 (numbers don't have a length property). 
You could of course make this function as complex as needed, making your true condition meet your needs.

Notice as well, this didn't return <code>true</code>. 
The find method doesn't return a boolean, but instead returns the first matching element. 
If there isn't a matching element - as in nothing exists that meets the criteria defined in your function - it will return <code>undefined</code>. 
Also notice that it returns the first, so if there is more than one element in the array that meets the criteria, it will only grab the first instance. 
In our example, if there was another string of length less than 12 after ‘4 feet tall' it wouldn't change our result.

In our example, we only employed the callback with one parameter. 
You can also add parameters to reference the current element's index. 
Another parameter can be the entire array itself, but I find this rarely used. 
Here is an example using the index:

<code>alligator.find((el, idx) => typeof el === "string" &amp;&amp; idx === 2); // returns '4 foot tall'</code>

We know in our array, there are 3 different elements that meet the first condition (typeof el === ‘string'). 
If this was our only condition, it would return the first one, ‘thick scales'. 
But the difference is, only one has the index of 2 and that is ‘4 foot tall'.

Speaking of indexes, a similar array method is <code>.findIndex()</code>. 
This method also receives a function, but as you can guess, it returns the matching element's index instead of the element itself.

<h3>indexOf</h3>
<code>const alligator = ["thick scales", 80, "4 foot tail", "rounded snout"];

alligator.indexOf("rounded snout"); // returns 3</code>

Like the <code>.includes()</code> method, <code>.indexOf()</code> uses strict comparison, not a function as we saw with the <code>.find()</code> method. 
But, unlike <code>includes()</code>, it returns the index of the element, rather than a boolean. 
You can also indicate which index in the array to start searching at.

I find <code>indexOf()</code> to be very useful. 
It's quick and easy, can tell you where the element is in the array, and can tell you whether the element exists. 
How does it tell you if the element exists? Basically, we can know the element exists if it returns a positive number, and if it returns -1 we know the element doesn't exist.

<code>alligator.indexOf("soft and fluffy"); // returns -1
alligator.indexOf(80); // returns 1
alligator.indexOf(80, 2); // returns -1</code>

And as you can see, although we could get the <code>find()</code> or <code>findIndex()</code> methods to give us the same information, this is a whole lot less to write. 
We don't have to write out a function for comparison, as it is already within the <code>indexOf</code> method.

Now, like the others, <code>indexOf()</code> also returns the index of the first matching element it finds. 
JavaScript gives us an alternate array method <code>.lastIndexOf()</code>. 
As you can guess, this does the same thing as <code>indexOf()</code> but starting from the last index of the array and working backward. 
You can also specify a second parameter, but remember the indexes don't change, just because you are using a different method.

<code>const alligator = ["thick scales", 80, "4 foot tail", "rounded snout", 80];

alligator.indexOf(80); // returns 1
alligator.lastIndexOf(80); // returns 4
alligator.indexOf(80, 2); // returns 4
alligator.lastIndexOf(80, 4); // returns 4
alligator.lastIndexOf(80, 3); // returns 1</code>

<h3>Bonus: filter</h3>
<code>const alligator = ["thick scales", 80, "4 foot tail", "rounded snout", 80];

alligator.filter(el => el === 80); //returns [80, 80]</code>

The <code>filter()</code> method is like the <code>find()</code> method, in that it requires a function passed and a condition for what will be returned. 
The main difference is, <code>filter()</code> always returns an array, even if there is only one matching element. 
But it will return all the matching elements, whereas <code>find()</code> only returns the first matching.

The important thing with filter is that it returns all the elements matching your criteria. 
It could only be me, but I can get confused, thinking “these are the elements I want to filter <code>out</code>”, when truthfully, you are indicating the elements you wish to filter <code>in</code>.

<h3>Conclusion</h3>
The easiest method I find to use, when searching for something is the <code>find()</code> method, but as you can see it really depends on your case.
<li>Do you need to know only if it exists? Use <code>.includes()</code>.</li><li>Do you need to get the element itself? Use <code>.find()</code>, or <code>.filter()</code> for multiple items.</li><li>Do you need to find the index of the element? Use <code>.indexOf()</code> or <code>findIndex()</code> for a more complex search.</li>

The arrays in the examples here were very simple. 
You may find yourself with an array of objects. 
Here are some very basic examples below to navigate through the jungle of nested objects:

<code>const jungle = [
 { name: "frog", threat: 0 },
 { name: "monkey", threat: 5 },
 { name: "gorilla", threat: 8 },
 { name: "lion", threat: 10 }
];

// break the object down in order to use .includes() or .indexOf()
const names = jungle.map(el => el.name); // returns ['frog', 'monkey', 'gorilla', 'lion']
console.log(names.includes("gorilla")); // returns true
console.log(names.indexOf("lion")); // returns 3 - which corresponds correctly assuming no sorting was done

// methods we can do on the array of objects
console.log(jungle.find(el => el.threat == 5)); // returns object - {name: "monkey", threat: 5}
console.log(jungle.filter(el => el.threat > 5)); // returns array - [{name: "gorilla", threat: 8}, {name: 'lion', threat: 10}]</code>

<hr>
All in all, these are great methods to get familiar with and before long, you will find yourself a well-trained pro towards JavaScript arrays!


<h2>Understanding Merge Sort Through JavaScript</h2>

Previously, we covered some of the <a href="https://alligator.io/js/bubble-selection-insertion-sort/">beginner sorting algorithms</a> that are able to get the job done but quickly go out of hand with larger datasets. 
Now we get can start digging into some of the more efficient big boy algorithms, like <strong>merge sort</strong>. 
With this, we can move from the <code>O(n^2)</code> algorithms to a much more scalable <code>O(nlogn)</code> solution.

<h3>Prerequisites</h3>
Being able to think about time and space complexity via <a href="https://alligator.io/js/big-o-notation/">Big O Notation</a> will be incredibly helpful. 
We're also going to be looking at recursion-based examples, so you can <a href="https://alligator.io/js/understanding-recursion/">brush up on that here</a>.

<h3>Concept</h3>
Similar to <a href="https://alligator.io/js/linear-vs-binary-search/">binary search</a>, merge sort is a <em>divide and conquer</em> algorithm. 
The goal being to break down our problem into sub-problems and recursively continue to break those down until we have a lot of simple problems that we can easily put back together.

Merge sort is built off the idea of comparing whole arrays instead of individual items. 
First, we need to take the entire array and break it into many sub-arrays by continuously splitting everything in half until everything is alone in its own array. 
Since the amount of sub-arrays will be some multiple of the number of items in our main array, that's what gives us the log in <code>O(nlogn)</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2589a1f5fbe13c680159c228d86c13ff088901bc/edced/images/js/understanding-merge-sort/merge-sort-divide.png" width="350">

From there we can start merging, since both arrays should already be sorted we can easily compare which numbers in each is smaller and put them in the right place. 
This is where the n in <code>O(nlogn)</code> comes from.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/97e6ae754b57904f0120a47cf5be247e11496257/e372d/images/js/understanding-merge-sort/merge-sort-merge.png" width="350">

As you can see one half of the array is completed before the second half, and the first half of each before the next half (the different colors represent different arrays).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/c3fbc318f1a81a61b7aecff9e2dc97986c296bf3/2f8da/images/js/understanding-merge-sort/merge-sort-animation.gif" width="350">
Graphic/Animation thanks to <a href="http://visualgo.net">VisuAlgo.net</a>
<h3>Practice Data</h3>
Here's the array of 50 unsorted items I'll be referring to.

<code>const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];</code>

<h3>Merge</h3>
To simplify our problem we can start by creating a utility function that'll merge two sorted arrays. 
There are many different ways of doing this but I found this the most succinct.

As long as there are items in either array, check if the first item in either array is smaller, then throw it into sorted and remove that item from the array with <code>shift()</code>. 
When that's done, if there's anything leftover, like when one array is larger, concatenate that onto the end.

So both arrays are gradually shrinking until one of them is empty with the leftovers thrown onto the end, since it's already sorted.

<code>const merge = (arr1, arr2) => {
 let sorted = [];

 while (arr1.length &amp;&amp; arr2.length) {
   if (arr1[0] &lt; arr2[0]) sorted.push(arr1.shift());
   else sorted.push(arr2.shift());
 };

 return sorted.concat(arr1.slice().concat(arr2.slice()));
};

console.log(merge([2, 5, 10, 57], [9, 12, 13]));</code>

<h3>Sorting</h3>
This is the easy part, we can use a recursive function to continuously cut our array in half, using <code>slice()</code> to save the data on either side of the center. 
It'll return when we have our 1 item arrays then we'll use our <code>merge</code> utility to start building them back into one large array, with every merge sorting them along the way.

<code>const mergeSort = arr => {
 if (arr.length &lt;= 1) return arr;
 let mid = Math.floor(arr.length / 2),
     left = mergeSort(arr.slice(0, mid)),
     right = mergeSort(arr.slice(mid));

 return merge(left, right); 
};

console.log(mergeSort(unsortedArr));</code>

<h3>Conclusion</h3>
While Merge sort is the best algorithm we've covered so far since it's <code>O(nlogn)</code>, it's good to keep in mind that it works better with larger amounts of data. 
If you don't know how much data you'll need sorted consider using another algorithm, like insertion sort, when the dataset is small enough to get the best of both worlds.


<h2>Creating Custom Forms Using the JavaScript FormData API</h2>

Building a form is easy to do as long as you don't have an edge case. 
Then the bacon fat goes down the drain and your pipes are ruined. 
So you sometimes need some extra tools in your toolbelt to deal with it. 
The <code>FormData API</code> can be one of your tools.

<h3>The Core FormData API</h3>
FormData has a lot of features but the only method that works across all browsers is <code>append</code>. 
Let's say we want to create a social application for people to share their bacon pictures. 
Here we'll create a form that allows users to send a picture with a title and the author's name. 
Our HTML markup will look like this:

<code>&lt;input type="text" name="author"  id="author-input" />
&lt;input type="text" name="title" id="title-input" />
&lt;input type="file" name="picture" id="picture-input" />
&lt;button id="submit-button">SUBMIT&lt;/button></code>

To handle our data we can create the following code:

Module: bacon-form.js

<code>const inputs = document.getElementsByTagName('input');
// This object will keep track of the changes of inputs
const applicationState = {
 title: "",
 author: "",
 picture: ""
}

document.getElementById('submit-button').onclick = async () => {
 // We create a new form object
 const form = new FormData();
 // we append each element to the form
 form.append('title', applicationState.title);
 form.append('author', applicationState.author);
 form.append('picture', applicationState.picture);

 const res = await fetch('https://postman-echo.com/post', {
   method: 'POST',
   mode: 'no-cors',
   body: form
 });
 // ... 
Do something with the response
}

// The rest of this code is functional
// It is not directly related to FormData

// This for loop reflects input changes to the application's state
for (let i = 0; i &lt; inputs.length; i++) {
 const input = inputs[i]
 const inputName = input.name

 input.onchange = (e) => {
   let value = e.target.value
   // updating the application state according to the input the user interacted with
   if (inputName === 'picture' &amp;&amp; e.target.files[0]) {
     setPicture(e.target.files[0]);
   } else {
     applicationState[inputName] = value;
   }
 };
}
// setPicture takes a file reads it as a base64URL and assigns that value to application.picture
const setPicture = (file) => {
 const fr = new FileReader();
 // Reading the data and encoding it as base64 to send it to the server
 fr.readAsDataURL(file);
 // When the data is done loading we assign it to picture
 fr.onloadend = (fileData) => {
   applicationState.picture = fileData.target.result;
 }
}</code>

If this is our input:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4c866e1f128d72c5f08d518cc908358a4a1d8fd6/b7e9e/images/js/formdata/formdata-input-sample.png">

Then we press the submit button we'll roughly get the following request headers:

<code>{
 "Accept-Encoding": "gzip, deflate, br",
 "Connection": "keep-alive",
 "Content-Length": "4369",
 "Content-Type": "multipart/form-data",
 "Host": "postman-echo.com",
 "Origin": "null",
 "Sec-Fetch-Mode": "no-cors",
 "Sec-Fetch-Site": "cross-site"
}
</code>

And the following body:

<code>{
 "title": "Alligator Bacon",
 "author": "Jack Misteli",
 "picture": "data:text/javascript;base64,iVBORw0KGgoAA......."
}</code>

Please note that <code>FormData</code> constructor can take form data as an argument. 
So you could do:

Module: regular-form.html

<code>&lt;form id="user-form">
 &lt;input type="text" name="username">
 &lt;input type="password" name="password">
 &lt;input type="file" name="picture" id="picture-input"/>
 &lt;input type="submit">
&lt;/form>
&lt;script>
 document.getElementById('user-form').onsubmit = async function (e) {
   e.preventDefault();
   // here `this` is the user-form HTML element
   const form = new FormData(this);
   ///... 
send form to server
 }
&lt;/script></code>

Another important gotcha, is that <code>append</code> does not overwrite a key if it already exists.

Module: double-bacon-form.js

<code>const form = new FormData();
form.append('baconType', 'pork');
form.append('baconType', 'vegan');
// When you send your form it will look like this:
// {
//  baconType: pork
//  baconType: vegan
//}</code>

If you want to overwrite a key value you will have to use other functions.

<h3>Advanced Forms</h3>
The <code>FormData</code> constructor and the <code>append</code> method are available in all browsers. 
Most of the other methods are pretty self-descriptive:
<li>
<code>FormData.has(key)</code>: Checks if the key exists in the form.</li><li>
<code>FormData.set(key, value)</code>: Changes the value associated to the key.</li><li>
<code>FormData.delete(key)</code>: Deletes the entry associated with the key.</li><li>
<code>FormData.get(key)</code>: Accesses the first value associated with the key.</li><li>
<code>FormData.getAll(key)</code>: Creates an array of all the values associated with a key.</li><li>
<code>FormData.keys()</code>, <code>FormData.values()</code>, <code>FormData.entries()</code>: Iterators used to get all the keys, associated values or just entries of the FormData.</li>

 That's it if you have any questions you can fire them up on Twitter with a link to the article and I'll do my best to answer them!


<h2>What's new in ECMAScript 2020 (ES2020)</h2>

It's time for yet another update on the ever-changing work of art that is JavaScript. 
In this article, we're going to review some of the latest and greatest features coming with ES2020.

<h3>Installation</h3>
Since many people don't think to update their browsers to make their developer's lives easier, we'll need to use babel to get started using features that are not available across the board for users. 
For simplicity's sake, I'll use the <a href="https://parceljs.org/">Parcel bundler</a> to get everything running as quickly as possible.

<code>$ yarn add parcel-bundler</code>

package.json

<code>"scripts": {
 "start": "parcel index.html"
},</code>

Sadly, at the time of this writing we're too far ahead of our time and there doesn't seem to be a working preset for ES2020. 
If you throw these in a <code>.babelrc</code> file and save, Parcel should handle installing everything for you.

.babelrc

<code>{
 "plugins": [
   "@babel/plugin-proposal-nullish-coalescing-operator",
   "@babel/plugin-proposal-optional-chaining",
   "@babel/plugin-proposal-class-properties",
   "@babel/plugin-proposal-private-methods",
   "@babel/plugin-syntax-bigint"
 ]
}</code>

<h3>Private Class Variables</h3>
One of the main purposes of classes is to contain our code into more reusable modules. 
Because you'll create a class that's used in many different places you may not want everything inside it to be available globally.

Now, by adding a simple hash symbol in front of our variable or function we can reserve them entirely for internal use inside the class.

<code>class Message {
 #message = "Howdy"

 greet() { console.log(this.#message) }
}

const greeting = new Message()

greeting.greet() // Howdy
console.log(greeting.#message) // Private name #message is not defined</code>

<h3>Promise.allSettled</h3>
When we're working with multiple promises, especially when they are reliant on each other, it could be useful to log what's happening to each to debug errors. 
With <code>Promise.allSettled</code>, we can create a new promise that only returns when all of the promises passed to it are complete. 
This will give us access to an array with some data on each promise.

<code>const p1 = new Promise((res, rej) => setTimeout(res, 1000));

const p2 = new Promise((res, rej) => setTimeout(rej, 1000));

Promise.allSettled([p1, p2]).then(data => console.log(data));

// [
//   Object { status: "fulfilled", value: undefined},
//   Object { status: "rejected", reason: undefined}
// ]</code>

<h3>Nullish Coalescing Operator</h3>
Because JavaScript is dynamically typed, you'll need to keep JavaScript's treatment of truthy/falsy values in mind when assigning variables. 
If we have a object with some values, sometimes we want to allow for values that are technically falsy, like an empty string or the number 0. 
Setting default values quickly gets annoying since it'll override what should be valid values.

<code>let person = {
 profile: {
   name: "",
   age: 0
 }
};

console.log(person.profile.name || "Anonymous"); // Anonymous
console.log(person.profile.age || 18); // 18</code>

Instead of double pipes we can use the double question marks operator to be a bit more type strict, which only allows the default when the value is null or undefined.

<code>console.log(person.profile.name ?? "Anonymous"); // ""
console.log(person.profile.age ?? 18); // 0</code>

<h3>Optional Chaining Operator</h3>
Similar to the nullish coalescing operator, JavaScript may not act how we want when dealing with falsy values. 
We can return a value if what we want is undefined, but what if the path to it is undefined?

By adding a question mark before our dot notation we can make any part of a value's path optional so we can still interact with it.

<code>let person = {};

console.log(person.profile.name ?? "Anonymous"); // person.profile is undefined
console.log(person?.profile?.name ?? "Anonymous");
console.log(person?.profile?.age ?? 18);</code>

You can <a href="https://alligator.io/js/v8-optional-chaining-nullish-coalescing/">refer to this post</a> to learn more about Optional Chaining and Nullish Coalescing.

<h3>BigInt</h3>
We won't go into the technical details, but because of how JavaScript handles numbers, when you go high enough things start to get a bit wonky. 
The largest number JavaScript can handle is 2^53, which we can see with <code>MAX_SAFE_INTEGER</code>.

<code>const max = Number.MAX_SAFE_INTEGER;

console.log(max); // 9007199254740991</code>

Anything above that and things start to get a little weird…

<code>console.log(max + 1); // 9007199254740992
console.log(max + 2); // 9007199254740992
console.log(max + 3); // 9007199254740994
console.log(Math.pow(2, 53) == Math.pow(2, 53) + 1); // true</code>

We can get around this with the new <code>BigInt</code> datatype. 
By throwing the letter ‘<code>n</code>' on the end we can start using and interacting with insanely large numbers. 
We're not able to intermix standard numbers with BigInt numbers, so any math will need to be also done with BigInts.

<code>const bigNum = 100000000000000000000000000000n;

console.log(bigNum * 2n); // 200000000000000000000000000000n</code>

<h3>Dynamic Import</h3>
If you had a file full of utility functions, some of them may rarely be used and importing all of their dependencies could just be a waste of resources. 
Now we can use <a href="https://alligator.io/js/async-functions/">async/await</a> to dynamically import our dependencies when we need them.

This will not work with our current Parcel setup, since we're using imports which will only work in a Node.js environment.

math.js

<code>const add = (num1, num2) => num1 + num2;

export { add };</code>

index.js

<code>const doMath = async (num1, num2) => {
 if (num1 &amp;&amp; num2) {
   const math = await import('./math.js');
   console.log(math.add(5, 10));
 };
};

doMath(4, 2);</code>

<h3>Conclusion</h3>
Now you're ready to start amazing or perhaps confusing your coworkers with JavaScript features that aren't even in most browsers, yet (unless they are if you are reading this from the future ).


<h2>Beginner Sorting Algorithms in JavaScript: Bubble, Selection &amp; Insertion Sort</h2>

Having your datasets arranged all willy-nilly will only add more time and resources to manage and search through. 
Whether your data is sorted or not will directly affect what search methods you can use and can mean the difference between a search taking a million operations or taking 10, like with <a href="https://alligator.io/js/linear-vs-binary-search/">Binary Search</a>.

For simplicity's sake, we're only going to focus on sorting an array of numbers from least to greatest, but these algorithms are easily modifiable for other sorting goals. 
Keep in mind that these are more general concepts and patterns and less of a “how-to” for sorting data since your particular implementation may differ a lot but in the end it may conceptually resemble these patterns.

Here's the practice array of 50 random numbers.

<code>const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];</code>

<h3>Prerequisites</h3>
I'm going to be looking at everything through the lens of <a href="https://alligator.io/js/big-o-notation/">Big O Notation</a>, so understanding how complexity grows over time will be very helpful.

<h3>Bubble Sort</h3>
This is the “Hello World” of sorting methods, nothing crazy but it gets the job done.

For each item in the array we want to check if the next item is larger, if it is then swap their indexes in the array. 
To avoid recomparing sorted numbers we'll start from the back of the array while another <code>for loop</code> gets the preceding number. 
This way all of the largest values build up, or “bubbles up”, on the end.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/84a9a4fc63619cd002aa841e98481b48eb5f4821/c2954/images/js/bubble-selection-insertion-sort/o/bubble-sort.gif" width="500" alt="Bubble Sort Animation">
Graphic/Animation thanks to <a href="http://visualgo.net">VisuAlgo.net</a>
<strong>Our version works in reverse from the animation, but it's close enough.</strong>

<code>const bubble = arr => {
 const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]];

 for (let i = arr.length; i > 0; i--) {
   for (let j = 0; j &lt; i - 1; j++) {
     if (arr[j] > arr[j + 1]) swap(arr, j, j + 1);
   };
 };

 return arr;
};

console.log(bubble(unsortedArr));</code>

<h3>Selection Sort</h3>
Selection sort works like the opposite of Bubble sort, while bubble sorting is pushing all of the largest values to the end now we're going to push the minimum values to the start.

Every time it loops over the array it selects the smallest value, if it finds a lower value that then that becomes the new lowest value. 
When the loop is done it'll take that minimum and put it on the front of the array before starting the loop again. 
This way the lowest value of each iteration is stacked onto the front until the whole array is sorted.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/879cceb5909e1d4ee16237097caf2cb3a909ef96/f055b/images/js/bubble-selection-insertion-sort/o/selection-sort.gif" width="500" alt="Selection Sort Animation">
Graphic/Animation thanks to <a href="http://visualgo.net">VisuAlgo.net</a>
<code>const selection = arr => {
 const swap = (list, a, b) => [list[a], list[b]] = [list[b], list[a]];

 arr.forEach((item, i) => {
   let min = i;
   for (let j = i + 1; j &lt; arr.length; j++) {
     if (arr[j] &lt; arr[min]) min = j;
   };
   swap(arr, i, min);
 });

 return arr;
};

console.log(selection(unsortedArr));</code>

<h3>Insertion Sort</h3>
My personal favorite and the most performant of the three, <em>insertion sort</em>, is more similar to how you would sort something by hand.

We look at the array as two parts, the sorted and unsorted, with every time we find a new value we loop back to find its place in the sorted half. 
With each addition our sorted group grows until it is the whole array.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/abefafc9c7b600c8f00ca8136bc24f86dba07fec/adff0/images/js/bubble-selection-insertion-sort/o/insertion-sort.gif" width="500" alt="Insertion Sort Animation">
Graphic/Animation thanks to <a href="http://visualgo.net">VisuAlgo.net</a>
<code>const insertion = arr => {
 arr.forEach((item, i) => {
   let num = arr[i];
   let j;

   for (j = i - 1; j >= 0 &amp;&amp; arr[j] > num; j--) {
     arr[j + 1] = arr[j];
   };
   arr[j + 1] = num;
 });

 return arr;
};

console.log(insertion(unsortedArr));</code>

<h3>Comparison</h3>
One problem with using Big O Notation for comparing algorithms is that it's based on the worse-case scenario, which may be the same across algorithms giving the false illusion that they're equal. 
While Bubble, Selection, and Insertion sorts are all O(n^2), that doesn't tell us much about the average or best case scenario or how they vary with the data structure.

Insertion sort wins every time. 
It also has the benefit of not needing to have the whole array before starting, which allows you to sort things in real-time as data comes in.

<strong>Keep this in mind because you shouldn't decide which algorithm is “best” before considering how your data is already organized.</strong>

<h3>Conclusion</h3>
These three are far from the best solutions to efficiently sorting large amounts of data, but they are some of the most intuitive to dip your toes into what can be an overwhelming ocean. 



<h2>Linear Vs Binary Search via JavaScript</h2>

JavaScript comes with some pretty handy out-of-the-box tools for searching through an array. 
But with a large data set the O(n) methods like <code>indexOf</code>, <code>find</code>, or a basic loop just aren't the best or even feasible. 
Instead, we can use Binary search to go over an array without looking at what we obviously don't need, giving us a O(logn) solution.

<h3>Prerequisites</h3>
I will be using Big O Notation when comparing performance and complexity, which you can <a href="https://alligator.io/js/big-o-notation/">brush up on here</a>.

<h3>Practice Data</h3>
Here are some sorted and unsorted datasets, both with 50 items, that I'll be referencing.

<code>const unsortedArr = [31, 27, 28, 42, 13, 8, 11, 30, 17, 41, 15, 43, 1, 36, 9, 16, 20, 35, 48, 37, 7, 26, 34, 21, 22, 6, 29, 32, 49, 10, 12, 19, 24, 38, 5, 14, 44, 40, 3, 50, 46, 25, 18, 33, 47, 4, 45, 39, 23, 2];

const sortedArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50];</code>

<h3>Linear Search</h3>
This is the standard brute-force solution I'm sure you've already done a thousand times. 
We're just telling it, “I need something, so look through everything one-by-one until you find it”. 
If there's a million times more items, it'll take a million times longer, which nobody is going to put up with. 
Whether the data is sorted or not makes no difference.

<code>const linear = (arr, target) => {
 let steps = 0;

 for (let i = 0; i &lt; arr.length; i++) {
   steps++;
   if (arr[i] === target) return `Found: ${arr[i]} in ${steps} steps`;
 };
};

console.log(linear(unsortedArr, 40)); // 40 steps in 40 Milliseconds
console.log(linear(sortedArr, 40)); // 40 steps in 40 Milliseconds</code>

<h3>Binary Search</h3>
Brute-forcing your way to a result is obviously a very slow and unscalable solution. 
Instead of wasting resources looking at data that's obviously not what we want, we can use a ‘divide-and-conquer' approach to make each operation focus on ignoring what we don't want instead of painfully looking for what we do want.

We have three main components, two pointers and one pivot. 
Each pointer starts at the either end of the array with the pivot in the center. 
Then we check if what we want is higher or lower than our pivot, if higher then the left pointer is moved to the pivot's position while the pivot moved to the new middle. 
We keep running this until our pivot is equal to our target.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/037f96955db38e48d78340c5a1a1d8a8480fae11/43745/images/js/linear-vs-binary-search/binary-search.png" width="450">

With each step we are cutting our data set in half, completely ignoring what we don't need, giving us a time complexity of O(logn). 
If we ran a search for a number in an array of a million items that took ten steps, a billion item search may only take 15-20 steps.

<code>const binary = (arr, target) => {
 let start = 0;
 let end = arr.length;
 let pivot = Math.floor((start + end) / 2);
 let steps = 0;

 for (let i = 0; i &lt; arr.length; i++) {
   if (arr[pivot] !== target) {
     if (target &lt; arr[pivot]) end = pivot;
     else start = pivot;
     pivot = Math.floor((start + end) / 2);
     steps++;
   };

   if (arr[pivot] === target) return `Found: ${target} in ${steps} steps`;
 };

 return 'Nothing Found';
};

console.log(linear(unsortedArr, 40)); // Nothing Found
console.log(binary(arr, 44)); // 5 steps in 8 Milliseconds
console.log(binary(arr, 43)); // 2 steps in 7 Milliseconds</code>

Binary search comes with the big drawback of only allowing us to do this on sorted arrays, but there are other solutions based around pre-sorting your data before a search.

<h3>Conclusion</h3>
This is only one way of applying a binary search but the idea can be reconfigured for various data structures, as long as it's sorted. 
In the future, I hope we can explore using this technique for traversing more advanced datasets at lightning fast speeds .

<h2>Understanding Recursion &amp; Memoization via JavaScript</h2>

In this article, you're going to learn how to use recursive programming, what it is, and how to optimize it for use in algorithms. 
We'll be using JavaScript as our programming language of choice to understand the concept of recursion.

<h3>Prerequisites</h3>
I'll be using Big O Notation to compare optimization strategies, which you can <a href="https://alligator.io/js/big-o-notation/">brush up on here</a>.

<h3>What is Recursion?</h3>
Recursion is any time a function calls itself inside itself, potentially creating a infinite loop. 
If you've ever worked with <a href="https://alligator.io/js/canvas-animations-linear-motion/">canvas animations</a> then you've already used recursion since we use an <code>animate</code> function that updates our animation before rerunning itself.

In the below example, we're passing in a number, doubling it, then passing that value to itself again. 
In theory, this would continue forever but because computers are limited we generally can't have infinite recursion. 
You'll get an error like <code>too much recursion</code> or <code>Maximum call stack size exceeded</code> if you don't include some exit condition to stop the function, in the following case as soon as it's over 100:

<code>const double = num => {
 num = num + num;
 console.log(num);

 if (num > 100) return 'Exit'; // Try removing this
 return double(num);
};

console.log(double(4));</code>

You're probably thinking, “that's cool and all, but can't I just use a loop for anything recursion can do?”. 
Well yes, but actually no. 
Recursion comes in handy when dealing with various searching and sorting algorithms or traversing data structures that are more complicated than simple lists. 
When done correctly, you can also get much better performance, like O(log n) while all loops are O(n).

<h3>Memoization</h3>
You don't have to play around with recursion for long to realize that it's pretty easy to overwhelm your computer. 
This is because most recursive functions are O(n^2) or even O(n!). 
Since JavaScript runs on call stacks every time a new recursive layer is added, a lot of memory and processing power must be used to manage it all, despite most of it being redundant.

Let's try something simple like generating a fibonacci sequence. 
A fibonacci sequence is where every digit is the sum of the two items before it, 0, 1, 1, 2, 3, 5, 8, 12…

<code>const fibonacci = num => {
 if (num &lt; 2) return num;

 return fibonacci(num - 1) + fibonacci(num - 2);
};

for (let i = 0; i &lt; 1000; i++) console.log(fibonacci(i)); // 3 minutes before page crashed...</code>

That's just horrendous. 
Using up resources for 1,000 layers of the same information is too much even for my, relatively, decent computer.

Instead, we can work around this by adding a storage variable, or a “memo”, that will contain our values as the stack progresses. 
Every time our function runs, its value will be added to its corresponding index in the memo and the next layer will refer to that to calculate our result.

<code>const fibonacci = (num, memo) => {
 memo = memo || {};

 if (memo[num]) return memo[num];
 if (num &lt; 2) return num;

 return memo[num] = fibonacci(num - 1, memo) + fibonacci(num - 2, memo);
};

for (let i = 0; i &lt; 1000; i++) console.log(fibonacci(i)); // 143 Milliseconds</code>

<h3>Problem</h3>
Let's try applying this to another recursive function. 
This takes a number and outputs its factorial, so 3! should return 6 because 3x2x1=6.

<code>const factorial = n => {
 let num = n;

 if (n === 0) return 1;
 for (let i = 0; i &lt; n; i++) {
   num = n * factorial(n - 1);
 };

 return num;
};

console.log(factorial(3)); // 7 Milliseconds
console.log(factorial(6)); // 8 Milliseconds
console.log(factorial(9)); // 15 Milliseconds
console.log(factorial(12)); // 11,588 Milliseconds</code>

For me, anything above 12 crashes the page because this function has the complexity of O(n!) as each layer in the stack has to handle the complexity of the one before it.

Instead, let's try memoizing it and see the difference.

<code>const factorial = (n, memo) => {
 memo = memo || {};

 if (memo[n]) return memo[n];
 if (n === 0) return 1;
 for (let i = 0; i &lt; n; i++) {
   memo[n] = n * factorial(n - 1, memo);
 };

 return memo[n];
};

console.log(factorial(12));  // 4 milliseconds
console.log(factorial(120));  // 12 milliseconds
console.log(factorial(1200)); // 24 milliseconds
console.log(factorial(12000));  // 1408 milliseconds</code>

I don't know about you, but I think that's an incredible improvement, it can now handle 10,000 times the computations in 1/8th the time.

<h3>Closing Thoughts</h3>
Recursion is one of those things you need to get very comfortable with because it will return repeatedly, or haunt you, throughout your programming career. 
It will be essential for learning to traverse trees and lists and sort various data sets in the future.

<h2>Exploring JSF*ck</h2>

In 2010 there was an informal competition to create a system of writing JavaScript with the fewest amount of characters. 
From 18 to 8 to now 6 symbols we can, technically, do anything we can do with standard JavaScript. 
With just the <code>!+[]()</code> symbols and a little creativity we can do anything.

If you don't believe my ridiculous claims, then check this out:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f3470a2dd8882be26aee1c9aafb2b66df31b4409/fed0e/images/js/exploring-jsfck/jsfck-example.gif">

That's about 20,000 characters generated with this <a href="http://www.jsfuck.com/">translator</a>. 
It's actually much more doable when written by hand.

<h3>Why?</h3>
Let's admit it, JavaScript is weird. 
<code>"3" + 4</code> is 34, <code>5 + true</code> is 6, and <code>('b' + 'a' + + 'a' + 'a').toLowerCase()</code> outputs banana; this is utter chaos. 
Many consider this completely unacceptable and transition to TypeScript instead, but if you're one of the few that refuses to use strongly typed languages, as I do, then taking advantage of its eccentricities is a good way to build an intuitive understanding of JavaScript's type system.

JSF*ck is more commonly used to create hard to detect malware, but we're obviously not going to cover that .

<h3>JavaScript Types</h3>
While most languages force you to explicitly declare your types, like <code>const int num = 0;</code>, JavaScript relies more on context. 
We have the standard booleans, <code>true</code> and <code>false</code>, but we also get a few also ‘truthy' and ‘falsy' values, which are symbols/variables that aren't booleans but can be coerced and treated at booleans in the right context. 
<code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>false</code>, and empty strings are all falsy, while everything else is truthy by default.

We can manually coerce a type by wrapping it in <code>Boolean()</code>.

<code>console.log(Boolean(4)); // true
console.log(Boolean(0)); // false

console.log(Boolean('')); // false
console.log(Boolean(' ')); // true</code>

Sadly, <code>Boolean</code> isn't part of our six characters, so we'll need a way around it. 
Instead we can use the not operator twice, <code>!!</code>, to force a coercion. 
Using it once forces it into a boolean of the opposite value while the second switches it back to its original boolean value.

<code>console.log(!!4); // true
console.log(!!0); // false

console.log(!!'') // false
console.log(!!' ') // true</code>

Similar to <code>!</code>, we can use a plus to coerce anything into a number or to concatenate with something else.

<code>console.log(+!!4); // 1
console.log(+!!0); // 0

console.log(+!!'') // 0
console.log(+!!' ') // true

console.log(+!!4 + +!!4); // 2
console.log(+!!'' + !!''); // 0</code>

<h3>Numbers</h3>
The only other characters you need at this point are the parenthesis, which are mostly just to assign an order to our expressions.

We don't have access to strings or numbers but we can use empty brackets, since they resolve to true. 
With that we already have access to every number through addition.

<code>console.log(!![]); // true 
console.log(+!![]); // 1

console.log(!![] + !![] + !![] + !![]); // 4</code>

Or to be much less laborious we can wrap our number in brackets, or add brackets <code>+[]</code>, to coerce them into strings. 
We can use their stringified versions concatenate them, since <code>"4" + "2"</code> is 42, and use parenthesis to segment them off into their own units. 
By using converting to numbers to add and converting to strings to concatenate we have every number in a much more readable way.

While it's not ‘true' JSF*ck to use variables, I'll allow it since it makes hand writing so much more legible, sort of.

<code>const four = !![] + !![] + !![] + !![];
const two = !![] + !![];

console.log(([four] + [two]) + ([four] + [two])); // "4242"
console.log(+([four] + [two]) + +([four] + [two])); // 84

// Pure JSF*ck
console.log(+([+!![] + +!![] + +!![] + +!![]] + [+!![] + +!![]]) + +([+!![] + +!![] + +!![] + +!![]] + [+!![] + +!![]])); // 84</code>

<h3>Characters</h3>
Luckily for us, JavaScript allows us to treat strings like arrays, so we're able to get a number by a particular letter's index.

<code>console.log('Hello World'[3]); // l</code>

But we don't have normal characters, so we have to get a bit creative. 
<code>[][[]]</code> will resolve to <code>undefined</code>, we can coerce it into a string with <code>+[]</code> then we can use it as an array to get a few characters. 
Likewise, we can use <code>+[![]]</code> to return <code>NaN</code> since it's turning false as a string into a number.

<code>const undef = [][[]];
console.log((undef + [])[3]); // e

const nan = +[![]];
console.log((nan + [])[2]); // N

// Pure JSF*ck
console.log(([][[]] + [])[+!![] + !![] + !![]]); // e
console.log((+[![]] + [])[+!![] + !![]]); // N</code>

Our selection is still pretty slim, instead we can use this technique to get direct access to a numbers string representation, giving us every character. 
While you would normally access a method through dot syntax, like <code>console.log('Hello world)</code>, you can also use the bracket syntax, <code>console["log"]('Hello world')</code>.

The <code>toString</code> method, when used on numbers, can take the base for the string representation for that number, with 1-10 being numbers and 11-35 being the alphabet. 
Base 2 gives binary and base 36 will give us everything, so we'll go with that.

Here I'm just using our last technique to get the characters needed for <code>toString</code>. 
Although I did need to cheat slightly and use <code>String</code> since getting a capital S turned out to be very difficult ˉ\_(ツ)_/ˉ.

<code>const f = (![] + [])[0]; // f from false
const i = ([][[]] + [])[5]; // i from undefined
const l = (![] + [])[2]; // l from false
const fill = f + i + l + l;
const t = (!![] + [])[0]; // t from true
const o = (!![] + [][fill])[10]; // o from function fill () { native code }
const s = (![] + [])[3]; // s from false
const S = (String + [])[9]; // S from function String() { native code }
const r = (!![] + [])[1]; // r from true
const n = ([][[]] + [])[6]; // n from undefined
const g = (+[] + String)[15]; // g from function String() { native code }

const zero = +![];
const one = +!![];
const two = !![] + !![];
const three = !![] + !![] + !![];
const thirtySix = (three + []) + (three + three) + [];

const toString = t + o + S + t + r + i + n + g;

console.log((10)["toString"](36)); // a
console.log((+((one + []) + (zero + [])))[toString](thirtySix)); // a</code>

<h3>Functions</h3>
Now that you have the tools to build out any string and number you want, we can start writing functions. 
All we have to do is get any function off a string, we've already built out <code>fill</code>, and add our custom function onto its <code>constructor</code>. 
Adding parenthesis on the end will call it, since it's an anonymous function.

For the sake of brevity, let's pretend you already went through he work of collecting and concatenating everything for these strings.

<code>[][fill]["constructor"]("alert('Hello World')")();</code>

<h3>Conclusion</h3>
This may seem incredibly tedious and pointless, and it is, I personally find JSF*ck to be fun to play around with since it gets progressively more customized to you as you handcraft everything you need from the ground up.

There really aren't very many reasons for learning this besides maybe bragging rights, doing all your work in it to ensure your job security for the next 20 years (don't do this ), or just trying to impress the ladies. 
Hopefully this has helped you either have a better understanding of JavaScript's weirdness or convinced you to finally learn TypeScript.


<h2>Reading &amp; Processing Files with the JavaScript FileReader API</h2>

Reading, writing and analyzing files is an essential component of software development. 
For security reasons, in JavaScript, we can't directly access users' files. 
If we had something like <a href="/nodejs/intro-to-fs-module/">fs</a> in Node.js, we could just steal documents from users!

First, to get a file from a user, we need to use an input element:

<code>&lt;input id="my-input" type="file" onChange="handleFileChange"></code>

This tiny piece of code will allow our user to upload files from her machine. 
The <code>handleFileChange</code> function that we'll create will receive some information about the uploaded files, but to be able to manipulate them we need to use the <code>FileReader</code> API.

<h3>Simply Uploading Your File</h3>
Here's a simple piece of code to upload a file using an HTML form.

<code>&lt;form enctype="multipart/form-data" action="/upload" method="post">
 &lt;input id="file-input" type="file" />
&lt;/form></code>

There is only so much you can get from an HTML form POST. 
If you prefer to use JavaScript to make your requests you can do something like this:

<code>let file = document.getElementById("file-input").files[0];
let formData = new FormData();

formData.append("file", file);
fetch('/upload/image', {method: "POST", body: formData});</code>

<h3>File Blob Properties</h3>
In many browsers, Files have Blob properties/functions. 
These functions allows us to read the file. 
We're going to use a file called <code>myFile.txt</code> which looks like this:

<code>File content!</code>

<code>(async () => {
 // .text() transforms the file into a stream and then into a string
 const fileContent = await file.text();
 console.log(fileContent);
 // logs "File content!"

 // .stream() returns a ReadableStream
 const fileContentStream = await file.stream();
 console.log(await streamToText(fileContentStream));
 // logs "File content!"

 const buffer = await file.arrayBuffer();
 console.log(bufferToText(buffer))
 // logs "File content!"

 // .slice() allows you to get slices of the file here we take a slice of the entire file
 const fileSliceBlob = file.slice(0, file.length);
 // we convert to blob to a stream
 const fileSliceBlobStream = await fileSliceBlob.stream();
 console.log(await streamToText(fileSliceBlobStream));
 // logs "File content!"

})()

// We just use this function to convert streams to text
const streamToText = async (blob) => {
 const readableStream = await blob.getReader();
 const chunk = await readableStream.read();
 return new TextDecoder('utf-8').decode(chunk.value);
}

// Not the best way to get text from a file!
const bufferToText = (buffer) => {
 const bufferByteLength = buffer.byteLength;
 const bufferUint8Array = new Uint8Array(buffer, 0, bufferByteLength);
 return new TextDecoder().decode(bufferUint8Array);
}</code>

The problem is that a few important browsers don't support the File Blob properties.

<h3>Some FileReader Code</h3>
The FileReader API is used much more broadly. 
As you will see, we have similar features to the File interface. 
We also have additional features.

<h3>FileReader Lifecycle</h3>
There are 6 main events attached to FileReader:
<li>loadstart: Fires when we start loading a file.</li><li>progress: Fires when the blob is read in memory.</li><li>abort: Fires when we call <code>.abort</code>
</li><li>error: Fires when an error occurs</li><li>load: Fires when the read is successful.</li><li>loadend: Fires when the file is loaded and if error or abort didn't get called or if load starts a new read.</li>

<h3>FileReader Methods</h3>
To start loading our file we have four methods:
<li>
<code>readAsArrayBuffer(file)</code>: Reads the file or blob as an array buffer. 
One use case is to send large files to a service worker.</li><li>
<code>readAsBinaryString(file)</code>: Reads the file as a binary string</li><li>
<code>readAsText(file, format)</code>: Reads the file as USVString (almost like a string), and you can specify an optional format.</li><li>
<code>readAsDataURL(file)</code>: This will return a URL where you can access the file's content, it is Base64 encoded and ready to send to your server</li>

Here is some code you can use to see the FileReader API in action.

<code>&lt;body>
 &lt;input type='file' id='input'>
 &lt;progress value="0" max="100" id="progress-bar">&lt;/progress>
 &lt;div id="status">&lt;/div>
 &lt;script>

 //
 document.getElementById('input').addEventListener('change', (e) => {
   const file = document.getElementById('input').files[0];
   if (file) {
     processFile(file);
   }
 })

 const processFile = (file) => {
   // we define fr as a new instance of FileReader
   const fr = new FileReader();

   fr.readAsDataURL(file);
   // Handle progress, success, and errors
   // fr.onprogress = updateProgress;
   fr.onerror = errorHandler;
   fr.onabort = () => changeStatus('Start Loading');
   fr.onloadstart =   () => changeStatus('Start Loading');
   fr.onload = ()=> {changeStatus('Loaded')};
   fr.onloadend = () => loaded;
   // Here you can perform some operations on the data asynchronously
   fr.onprogress = setProgress;
 }

 // Updates the value of the progress bar
 const setProgress = (e) => {
   // The target is the file reader
   const fr = e.target;
   const loadingPercentage =  100 * e.loaded / e.total;
   document.getElementById('progress-bar').value = loadingPercentage;
 }

 const changeStatus = (status) => {
   document.getElementById('status').innerHTML = status
 }

 const loaded = (e) => {
   changeStatus('Load ended!');
   const fr = e.target
   var result = fr.result;
   console.log('result:')
   console.log(result)
   // Here we can send the result to a server for example
 }

 const errorHandler = (e) => {
   changeStatus("Error: " + e.target.error.name)
 }

&lt;/script>
&lt;/body></code>

You can see the code live <a href="https://otomakan.github.io/jmisteli.github.io/snippets/file-reader/index.html">here</a> (open your developer console) and the source code <a href="https://github.com/alligatorio/jmisteli.github.io/blob/master/snippets/file-reader/index.html">here</a>.

<h3>File Reader on Threads</h3>
FileReader is an asynchronous API because we do not want to block the main thread while reading files. 
For example, we don't want our UI to stop working when the browser is trying to read a very large file. 
However, there is a synchronous version of FileReader called FileReaderSync. 
We can only use FileReaderSync in Web Workers. 
Web workers have their own thread so they won't block the main thread. 
FileReaderSync uses the same methods as FileReader:
<li>FileReaderSync.readAsArrayBuffer()</li><li>FileReaderSync.readAsBinaryString()</li><li>FileReaderSync.readAsText()</li><li>FileReaderSync.readAsDataURL()</li>

There are no event handlers because it's synchronous!


<h2>Understanding Big O Notation via JavaScript</h2>

If you've ever looked into getting a job as a developer you've probably come across this <a href="https://www.youtube.com/watch?v=XKu_SEDAykw">Google interview</a> at some point and wondered ‘what the heck are they talking about?'. 
In this article, we're going to explore what they mean throwing around terms such as ‘quadratic' and ‘n log n'.

In some of these examples I'm going to be referring to these two arrays, one with 5 items and another with 50. 
I'm also going to be using JavaScript's handy <a href="https://alligator.io/js/js-performance-api/">performance API</a> to measure the difference in execution time.

<code>const smArr = [5, 3, 2, 35, 2];

const bigArr = [5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2, 5, 3, 2, 35, 2];</code>

<h3>What is Big O Notation?</h3>
Big O notation is just a way of representing the general growth in the computational difficulty of a task as you increase the data set. 
While there are other notations, O notation is generally the most used because it focuses on the worst-case scenario, which is easier to quantify and think about. 
Worst-case meaning where the most operations are needed to complete the task; if you solve a rubik's cube in one second you can't say you're the best if it only took one turn to complete.

As you learn more about algorithms you'll see these expressions used a lot because writing your code while understanding this relationship can be the difference between an operation being nearly instantaneous or taking minutes and wasting, sometimes enormous amounts of, money on external processors like Firebase.

As you learn more about Big O notation, you'll probably see many different, and better, variations of this graph. 
We want to keep our complexity as low and straight as possible, ideally avoiding anything above O(n).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dad214b7fbfa86f77ffd31dbee9c7016f0b6b795/b3792/images/js/big-o-notation/o-complexity.png" width="400" alt="O notation complexity graph">

<h3>O(1)</h3>
This is the ideal, no matter how many items there are, whether one or one million, the amount of time to complete will remain the same. 
Most operations that perform a single operation are O(1). 
Pushing to an array, getting an item at a particular index, adding a child element, etc, will all take the same amount of time regardless of the array length.

<code>const a1 = performance.now();
smArr.push(27);
const a2 = performance.now();
console.log(`Time: ${a2 - a1}`); // Less than 1 Millisecond

const b1 = performance.now();
bigArr.push(27);
const b2 = performance.now();
console.log(`Time: ${b2 - b1}`); // Less than 1 Millisecond</code>

<h3>O(n)</h3>
By default, all loops are an example of linear growth because there is a one-to-one relationship between the data size and time to completion. 
So an array with 1,000 times more items will take exactly 1,000 times longer.

<code>const a1 = performance.now();
smArr.forEach(item => console.log(item));
const a2 = performance.now();
console.log(`Time: ${a2 - a1}`); // 3 Milliseconds

const b1 = performance.now();
bigArr.forEach(item => console.log(item));
const b2 = performance.now();
console.log(`Time: ${b2 - b1}`); // 13 Milliseconds</code>

<h3>O(n^2)</h3>
Exponential growth is a trap we've all fall into at least once. 
Need to find a matching pair for each item in an array? Putting a loop inside a loop is great way of turning an array of 1,000 items into a million operation search that'll freeze your browser. 
It's always better to have to do 2,000 operations over two separate loops than a million with two nested loops.

<code>const a1 = performance.now();
smArr.forEach(() => {
   arr2.forEach(item => console.log(item));
});
const a2 = performance.now();
console.log(`Time: ${a2 - a1}`); // 8 Milliseconds

const b1 = performance.now();
bigArr.forEach(() => {
   arr2.forEach(item => console.log(item));
});
const b2 = performance.now();
console.log(`Time: ${b2 - b1}`); // 307 Milliseconds</code>

<h3>O(log n)</h3>
The best analogy I've heard to understand logarithmic growth is to imagine looking up a word like ‘notation' in a dictionary. 
You can't search one entry after the other, instead you find the ‘N' section, then maybe the ‘OPQ' page, then search down the list alphabetically until you find a match.

With this ‘divide-and-conquer' approach, the amount of time to find something will still change depending on the size of the dictionary but at nowhere near the rate of O(n). 
Because it searches in progressively more specific sections without looking at most of the data, a search through a thousand items may take less than 10 operations while a million may take less than 20, getting you the most bang for your buck.

In this example, we can do a simple <a href="https://www.geeksforgeeks.org/quick-sort/">quicksort</a>.

<code>const sort = arr => {
 if (arr.length &lt; 2) return arr;

 let pivot = arr[0];
 let left = [];
 let right = [];

 for (let i = 1, total = arr.length; i &lt; total; i++) {
   if (arr[i] &lt; pivot) left.push(arr[i]);
   else right.push(arr[i]);
 };
 return [
   ...sort(left),
   pivot,
   ...sort(right)
 ];
};</code>

<code>sort(smArr); // 0 Milliseconds
sort(bigArr); // 1 Millisecond</code>

<h3>O(n!)</h3>
Finally, one of the worst possibilities, factorial growth. 
The textbook example of this is the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">travelling salesman</a> problem. 
If you have a bunch of cities of varying distance, how do you find the shortest possible route that goes between all of them and returns to the starting point? The brute force method would be to check the distance between every possible configuration between each city, which would be a factorial and quickly get out of hand.

Since that problem gets very complicated very quickly, we'll demonstrate this complexity with a short recursive function. 
This function will multiply a number by its own function taking in itself minus one. 
Every digit in our factorial will run its own function until it reaches 0, with each recursive layer adding its product to our original number. 
So 3 is multiplied by 2 that runs the function to be multiplied by 1 that runs it again to be stopped at 0, returning 6. 
Recursion gets confusing like this pretty easily.

A factorial is just the product of every number up to that number. 
So 6! is 1x2x3x4x5x6 = 720.

<code>const factorial = n => {
 let num = n;

 if (n === 0) return 1
 for (let i = 0; i &lt; n; i++) {
   num = n * factorial(n - 1);
 };

 return num;
};</code>

<code>factorial(1); // 2 Milliseconds
factorial(5); // 3 Milliseconds
factorial(10); // 85 Milliseconds
factorial(12); //  11,942 Milliseconds</code>

I intended on showing <code>factorial(15)</code> instead but anything above 12 was too much and crashed the page, thus proving exactly why this needs to be avoided.

<h3>Closing Thoughts</h3>
keeping your code as performant as possible may seem like an obvious concern, but I'm sure almost every developer has created double or even triple nested loops at least once because ‘it just works'. 
Big O notation is very necessary in expressing and thinking about complexity is a way we never could before.

<h2>How to use the BroadcastChannel API in JavaScript</h2>

The BroadcastChannel API is a new web platform API that lets you communicate between different windows/tabs/iframes of the same origin. 
Using BroadcastChannel may sound fancy and daunting but it is super easy and useful.

<h3>Why use the BroadcastChannel API</h3>
Try to log into one of your favorite websites (I tried it on youtube.com). 
Then, open in a separate tab the same website. 
Normally you will be logged into both pages. 
Then log out on one of your tabs. 
On most sites, it will look like you are logged in one page and logged off the other.

Your windows are in different states: logged-in vs logged-out. 
That's not great and if you are a maniac tabber (like me) it can lead to some confusion.

This can even be a security issue. 
Imagine your user is in a coffee shop using the company dashboard. 
He logs off to take a toilet break and leaves the computer on. 
If the application was opened in multiple tabs one could access the data available in the other tabs (on screen or maybe some JWT token).

<h3>BroadcastChannel API Code</h3>
Here's a very simple example that you can copy paste in a local HTML file:

<code>&lt;!DOCTYPE html>

&lt;body>
 &lt;!-- The title will change to greet the user -->
 &lt;h1 id="title">Hey&lt;/h1>
 &lt;input id="name-field" placeholder="Enter Your Name"/>
&lt;/body>

&lt;script>

var bc = new BroadcastChannel('gator_channel');

(()=>{
 const title = document.getElementById('title');
 const nameField = document.getElementById('name-field');
 const setTitle = (userName) => {
   title.innerHTML = 'Hey ' + userName;
 }

 bc.onmessage = (messageEvent) => {
   // If our broadcast message is 'update_title' then get the new title from localStorage
   if (messageEvent.data === 'update_title') {
     // localStorage is domain specific so when it changes in one window it changes in the other
     setTitle(localStorage.getItem('title'));
   }
 }
 
 // When the page loads check if the title is in our localStorage
 if (localStorage.getItem('title')) {
   setTitle(localStorage.getItem('title'));
 } else {
   setTitle('please tell us your name');
 }

 nameField.onchange = (e) => {
   const inputValue = e.target.value;
   // In the localStorage we set title to the user's input
   localStorage.setItem('title', inputValue);
   // Update the title on the current page 
   setTitle(inputValue);
   // Tell the other pages to update the title
   bc.postMessage('update_title');
 }
})()
&lt;/script></code>

This page has a title and an input. 
When the user enters her name in the input we store the name in the local storage under the key <code>userName</code>. 
Then, we set the title of our application to <code>'Hey' + userName</code>. 
So if the user's name is <code>Sarah</code> the page will show “Hey Sarah”.

If we didn't have a <code>BroadcastChannel</code> when the user enters her name in one window it wouldn't update the other window. 
Without the broadcast channel in our code, the user would have to refresh the second window to update the title.

So in our first line, we create a <code>BroadcastChannel</code> called “gator_channel”. 
We then create a message receiver using the <code>onmessage</code> method. 
We set <code>onmessage</code> to a function that takes one argument (aka an event message). 
Then, in our code, we check that the name of the message is <code>update_title</code>. 
If so, we extract the user name from the <a href="https://alligator.io/js/introduction-localstorage-sessionstorage/">local storage</a>.

Whenever we call <code>postMessage</code> on the broadcast channel, it will call <code>onmessage</code> in the other windows. 
So if I input Jack in window 1, then window 1 will call <code>bc.postMessage('updated_title')</code>. 
This will activate <code>onmessage</code> on window 2 and any other window opened on the same origin.

<h3>Where it Will Work</h3>
Unlike other APIs such as <code>window.postMessage</code>, you don't need to know anything about the other windows or tabs opened. 
The Broadcast Channel will work on any tab or window which is in the same origin (same scheme, host and port).

This means that you can broadcast messages from <code>https://alligator.io/</code> to <code>https://alligator.io/js/broadcast-channels</code>. 
All you need is to have a <code>BroadcastChanel</code> object on both pages using the same channel name:

<code>const bc = new BroadcastChannel('alligator_channel');
bc.onmessage = (eventMessage) => {
 // do something different on each page
}</code>

If the hosts are different it won't work:
<li>https://alligator.io</li><li>https://www.alligator.io</li>

If the ports are different it won't work:
<li>https://alligator.io</li><li>https://alligator.io:8080</li>

If the schemes are different it won't work. 
That is similar to different ports since the standard is that http and https respectively use port 80 and 443:
<li>http://alligator.io</li><li>https://alligator.io</li>

Broadcast channels will not work if one of the windows is in incognito mode or across browsers (e.g. 
Firefox to Chrome).

<h3>Browser compatibility</h3>
According to (caniuse.com)[https://caniuse.com/#feat=broadcastchannel], the BroadcastChannel API is available to about 75.6% of users. 
Safari and Internet Explorer don't have any support for it yet.

To my knowledge, the most popular polyfill is <a href="https://github.com/pubkey/broadcast-channel">this one</a>. 
You can use it almost exactly like the BroadcastChannel API. 
If it detects that the BroadcastChannel API is available it will use it automatically for faster results. 
Otherwise, it will use IndexedDB or LocalStorage.

<h3>What Messages Can We Pass?</h3>
You can pass anything that can be cloned using the structured clone algorithm. 
That includes almost everything except symbols:
<li>All primitive types except symbols (Boolean, Null, Undefined, Number, BigInt, String)</li><li>Boolean and String objects</li><li>Dates</li><li>Regular Expressions</li><li>Blobs</li><li>Files, FileLists</li><li>ArrayBuffers, ArrayBufferViews</li><li>ImageBitmaps, ImageDatas</li><li>Arrays, Objects, Maps and Sets</li>

If you try sending something like a Symbol, you will get an error on the sending side.

<hr>
Let's update our code and use objects instead of strings.

<code>  bc.onmessage = (messageEvent) => {
   const data = messageEvent.data
   // If our broadcast message is 'update_title' then get the new title from localStorage
   switch (data.type) {
     case 'update_title':
       if (data.title){
         setTitle(data.title);
       }
       else
         setTitle(localStorage.getItem('title'));
       break
     default:
       console.log('we received a message')
   }
 };
 // ... 
Skipping Code
 bc.postMessage({type: 'update_title', title: inputValue});</code>

<h3>Things You Can Do with Broadcast Channels</h3>
There are many things we can imagine. 
The most obvious use case is to share states. 
For example, if you use something like Flux or Redux to manage your state, you can broadcast a message so that your store remains the same across tabs. 
We can also imagine building something similar for state machines.

We saw that we can also send large files in different formats. 
We might be able to save some bandwidth by sharing large files such as images across tabs.

<h3>Closing a Broadcast Channel</h3>
Closing a broadcast channel is super easy. 
You simply have to run the <code>close</code> method on your broadcast channel:

<code>bc.close()</code>

You might want to close or open channels depending on the state of your application. 
For instance, when you are logged-in you might have a specific channel to share your application's state. 
You might want to close that channel when you log out.


<h2>String Pluralization in JavaScript Using Simplur</h2>

Handling plural/singular forms of nouns in English can be difficult in software. 
Using a library called <a href="https://www.npmjs.com/package/simplur">Simplur</a> provides you with a simple JavaScript utility to solving this problem!

There are some problems in programming that originate from the human language. 
One of these problems is singular/plural nouns.

A single potato is spelled “potato” but two/more is spelled “potatoes”. 
How do you tackle this with JavaScript?

There are several ways, but they're not particularly elegant…

<code>const shoppingCart = ['guitar', 'bicycle', 'shoes'];

/* 1st approach */
const noun = shoppingCart.length >= 2
 ? 'items'
 : 'item';
const text1 = `You have ${shoppingCart.length} ${noun} in your shopping cart`;
// "You have 3 items in your shopping cart"

/* 2nd approach */
const text2 = `You have ${shoppingCart.length} item(s) in your shopping cart`;
// "You have 3 item(s) in your shopping cart"</code>

While these solution work, a new library called <a href="https://www.npmjs.com/package/simplur">Simplur</a> has a really smart way to solve it 

We're using English examples, but many languages exhibit this same problem where plural nouns are spelled differently than their singular forms.

<h3>Using Simplur</h3>
You can install simplur via npm:

<code>$ npm install simplur</code>

Here's how simplur is used:

<code>import simplur from 'simplur';

const breadCount = 12;
const text = simplur`Get ${breadCount} loa[f|ves] of bread`;
// "Get 12 loaves of bread"</code>

Simplur uses a <a href="https://alligator.io/js/template-literals-es6/">template string</a> that's <a href="https://alligator.io/js/tagged-template-literals/">tagged</a> using the <code>simplur</code> function, and when the number is greater than 1 it uses the second noun form. 
Simple as that!

<h3>Empty Singluar Form</h3>
Simplur also works with nouns that only adds a suffix for its plural form (instead of changing a significant portion of the word):

<code>const shoppingCart = ['shoes'];
const text = simplur`You have ${shoppingCart.length} item[|s] in your shopping cart`;
// "You have 1 item in your shopping cart"</code>

You just need to omit the first form.

<h3>Multiple Noun Forms</h3>
You can include several nouns and simplur will “look ahead”. 
In English, our “demonstratives” like this/that/these/those can be easily handled this way:

<code>const chipmunks = ['alvin', 'simon', 'theodore'];
const text = simplur`[That|Those] ${chipmunks.length} chipmunk[|s] [is|are] getting away!`;
// "Those 3 chipmunks are getting away!"</code>

<h3>Conclusion</h3>
The English language (and most languages) is not a precise instrument and this can lead to interesting programming problems. 
Hopefully you found simplur useful for use in your JavaScript projects!


<h2>A Quick Guide to the String Match Method in JavaScript</h2>

<code>String.prototype.match()</code> (aka: the match method on strings) can allow you to switch out strings or set conditions if a string or any data is matched. 
It then stores that data in a new array.

First the syntax and then the explanation:

<code>let newArray = string.match(condition);</code>

<h3>Terminology</h3>
The string <code>match()</code> method will return an array with the items being matches from a provided <code>regular expression</code> found in the string. 
You can <a href="https://alligator.io/js/regular-expressions-for-regular-people/">read more about regular expressions in JavaScript here</a>.

Remember, when all conditions are matched, those results will be stored in a new <strong>array</strong>.

Take the following example:

<code>const intro = "Hello Alligators, Hello Devs, how are you?"

const regex = /Hello/g;

const greeting = intro.match(regex);</code>

The above will give us an array like this: <code>["Hello", "Hello"]</code>. 
This works fine if we know the exact string we're looking to match, but what about dynamic content or an actual use case?

Here's a simple example that finds repeated letters in a string:

<code>const str = 'See you later, Alligator! Not so soon baboon!';
const matches = str.match(/([a-z])\1+/gi);

console.log('H' + matches.join(""));
// "Heelloooo"</code>

Though these are simple examples, the deeper you learn about regular expressions, the more powerful this string method becomes. 
The simple use of <code>i</code> for insensitive case allows the match method to highlight more entries.

<hr>
The match method has 3 modes…
<li>
<strong>1st</strong>: If the <code>g</code>(global) flag is used for your RegEx, you'll get all results stored in an array.</li><li>
<strong>2nd</strong>: If there are no <code>g</code> flag used, the first match will return an array with keys/values sharing index of the first matched expression, the full input and then the capturing groups. 
In other words, the same result as with using <code>RegExp.exec()</code>.</li>

<code>let newYear = "Happy New Year";
let results = newYear.match(/new/i);
// [ 'New', index: 6, input: 'Happy New Year', groups: undefined ]</code>
<li>
<strong>3rd</strong>: If there's no match, the method returns <code>null</code>, or, with the following code, an empty array:</li>
<code>let results = newYear.match(regex) || [];</code>

<h3>Conclusion</h3>
Match is a fun little method that can be used in a lot of creative ways like pulling out keywords from a paragraph or replacing words if the condition matches the regex. 
Take the time to learn about <em>Regular Expressions</em> in JavaScript. 
It'll make match even more useful for you.

<h2>A Tour of the JavaScript Permissions API</h2>

If you have ever created a web application which requires different features (like push notifications, webcam access, midi access), you probably noticed that their APIs look very different.

<code>// for the geolocation API you need to call getCurrentPosition to check if geolocation is accessible
navigator.geolocation.getCurrentPosition(gotLocation, didNotGetLocation);

// for notifications we can directly check on the Notification object

if (Notification.permission == 'granted')
 // do notification stuff
if (Notification.permission == 'denied')
 // ask for notification access ....
</code>

This is not very handy.

The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API">Permissions API</a> allows us to have overview of the permissions available on our pages. 
What we mean by “permission” is whether we can access a specific feature with our code. 
Features that require permission to access them with code are called powerful features. 
Camera, midi, notifications, geolocation are all powerful features.

All powerful feature's APIs are a bit different. 
Thus, it can be a pain to figure out what is the state of each feature's permissions. 
With the Permissions API, we manage all the permission's statuses with a single interface.

<h3>Permissions API Basics</h3>
The permission API is very experimental at this stage and should be used carefully. 
You should only use it if it is mission critical and you can keep up with future breaking changes. 
For instance, a few browsers used to support <code>navigator.permissions.revoke</code> but it is now deprecated.

At the time of the writing, <code>query</code> is the only property we can access from then <code>permissions</code> interface. 
<code>query</code> takes an object as an argument called a <em>PermissionDescriptor</em>. 
The permission descriptor has one field called <code>name</code>, which is the name of the permission you want to access.

<code>// This query will give us information about the permissions attached to the camera
navigator.permissions.query({name: 'camera'})</code>

The query returns a promise which resolves to a <code>PermissionStatus</code>. 
PermissionStatus has two fields: <code>state</code> and <code>onchange</code>.

<code>navigator.permissions.query({name: 'camera'}).then( permissionStatus => {
 console.log(permissionStatus)
 // in my browser on this page it logs:
 //{
 //   status: "prompt",
 //   onchange: null,
 // }
})</code>

<code>state</code> has 3 possible states: “granted”, “denied” and “prompt”. 
“granted” means that we have access to the feature. 
“denied” means that we won't be able to access the feature. 
“prompt” means that the User-Agent (i.e. 
the browser) will ask the user for permission if we try to access that feature.

Some <code>PermissionDescriptor</code> have additional fields and <a href="https://w3c.github.io/permissions/#geolocation">you can read more about them here</a>. 
For example, <code>camera</code>'s PermissionDescriptor has an additional field called <code>deviceId</code> if you want to target a specific camera. 
Your query might look like this: <code>.query({name: 'camera', deviceId: "my-device-id"})</code>.

<code>onchange</code> is an event listener which activates whenever the permissions of the queried feature changes.

<code>navigator.permissions.query({name:'camera'}).then(res => {
 res.onchange = ((e)=>{
   // detecting if the event is a change
   if (e.type === 'change'){
     // checking what the new permissionStatus state is
     const newState = e.target.state
     if (newState === 'denied') {
       console.log('why did you decide to block us?')
     } else if (newState === 'granted') {
       console.log('We will be together forever!')
     } else {
       console.log('Thanks for reverting things back to normal')
     }
   }
 })
})</code>

<h3>All Permissions API</h3>
There are a lot of different powerful permissions and browser support is very uneven. 
In the following script, you can see all the permissions described by <a href="https://w3c.github.io/permissions/#permission-registry">W3C's editor's draft</a> in the <code>permissionsName</code> variable. 
The <code>getAllPermissions</code> function returns an array with the different permissions available and their state. 
Please note that the result will change depending on your browser, the user's preference and of course the website's setup.

<code>const permissionsNames = [
 "geolocation",
 "notifications",
 "push",
 "midi",
 "camera",
 "microphone",
 "speaker",
 "device-info",
 "background-fetch",
 "background-sync",
 "bluetooth",
 "persistent-storage",
 "ambient-light-sensor",
 "accelerometer",
 "gyroscope",
 "magnetometer",
 "clipboard",
 "display-capture",
 "nfc"
]

const getAllPermissions = async () => {
 const allPermissions = []
 // We use Promise.all to wait until all the permission queries are resolved
 await Promise.all(
   permissionsNames.map(async permissionName => {
       try {
         let permission
         switch (permissionName) {
           case 'push':
             // Not necessary but right now Chrome only supports push messages with  notifications
             permission = await navigator.permissions.query({name: permissionName, userVisibleOnly: true})
             break
           default:
             permission = await navigator.permissions.query({name: permissionName})
         }
         console.log(permission)
         allPermissions.push({permissionName, state: permission.state})
       }
       catch(e){
         allPermissions.push({permissionName, state: 'error', errorMessage: e.toString()})
       }
   })
 )
 return allPermissions
}</code>

If I then run the following code in my developer console on Alligator.io:

<code>(async function () {
 const allPermissions = await getAllPermissions()
 console.log(allPermissions)
})()</code>

Here's a screenshot of what I get at the console:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/328a8fc8d555a3706bc9bb1b68becd4586e285f1/27644/images/js/permissions-api/get-all-permissions.png">

<h3>Permissions in Workers</h3>
So far we only used the <code>navigator.permissions</code> API because it is much easier to write concise examples. 
The Permissions API is also available inside of workers. 
<code>WorkerNavigator.permissions</code> allows us to check permissions inside our workers.

Hopefully you now have a better idea on how to use the Permissions API. 
It's not very complicated, nor is it essential but it does make it much easier for us to manage permissions in our JavaScript-based apps. 
There will probably be some new features and changes to the API and we'll keep you updated!


<h2>How to Use Keyboard Listeners in Vanilla JavaScript</h2>

<style> .keyboard-key { border: 1px solid #aaa; border-radius: 0.3em; background-image: linear-gradient(to bottom, #eee, #f9f9f9, #eee); color: black; box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); padding: 0.12em 0.5em; font-family: inherit; font-size: 0.85em; font-family: "Helvetica", "Arial", sans-serif; }</style>
In this article, you'll learn about how to listen to your user's keyboards to create new and fascinating features for your web apps!

Listening to your user's keyboard is a really handy tool to have. 
We might not think of it this way, but the browser is constantly listening to the keyboard! When you place the text cursor into an <code>&lt;input></code> box, it's listening to the keyboard. 
When you press the ↓ key, your webpage will scroll down.

As a web developer, you're given these same tools too! And it's not difficult either…

<code>// Listening for keyboard event
document.addEventListener('keydown', fn);

// Listening for scrolling event
document.addEventListener('scroll', fn);

// Listening when browser window is resized
document.addEventListener('resize', fn);</code>

Listening to the keyboard is exactly like listening to the <code>scroll</code> and <code>resize</code> browser events. 
In addition to the <code>keydown</code> event, you can also listen for the <code>keyup</code> event (though it's not quite as popular).

<code>// Triggers when key is depressed
document.addEventListener('keydown', fn);

// Triggers when key is released
document.addEventListener('keyup', fn);</code>

<h3>Basic Usage</h3>
Let's look at a short example where we listen for the “d” and “l” keys to be pressed. 
Pressing these keys will change the website from dark/light mode:

<code>document.addEventListener('keydown', function (event) {
 if (event.key === 'd') {
   document.body.style = "color: white; background-color: #111111";
 }
 if (event.key === 'l') {
   document.body.style = '';
 }
});</code>

In the callback function, the <code>event</code> argument is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent">KeyboardEvent</a> that possesses several useful properties/methods. 
The important one we're using is <code>event.key</code> which gives you a plaintext output of the key that's pressed 

<a href="https://glitch.com/embed/#!/embed/alligator-keyboard-event-1?path=public/client.js&amp;previewSize=100&amp;attributionHidden=true">alligator-keyboard-event-1 on Glitch</a>

This article is best viewed on a desktop/laptop computer with a physical keyboard to fully experience the demos

That's it! It's pretty straightforward to listen to the keyboard. 


<h3>Listening for Modifier Keys</h3>
There is an added utility for listening for <a href="#modifier-keys">modifier keys</a>. 
They're useful for invoking combo keystrokes (like Ctrl + s to “save”).

Luckily, you can do it pretty easily with <code>event.ctrlKey</code>!

<code>document.addEventListener('keydown', function (event) {
 // CTRL + S combo
 if (event.ctrlKey &amp;&amp; event.key === 'd') {
   document.body.style = "color: white; background-color: #111111";
 }
 // CTRL + L combo 
 if (event.ctrlKey &amp;&amp; event.key === 'l') {
   document.body.style = '';
 }
});</code>

<a href="https://glitch.com/embed/#!/embed/alligator-keyboard-event-2?path=public/client.js&amp;previewSize=100&amp;attributionHidden=true">alligator-keyboard-event-2 on Glitch</a>

For those that are on Windows/Linux OS, you might have encountered a small problem… Pressing Ctrl + d prompted you to bookmark the URL! This is happening because your browser triggers <em>your own custom keyboard events AND with the browser's default events.</em>

This can be easily fixed using <a href="https://alligator.io/js/preventdefault/">event.preventDefault</a>:

<code>document.addEventListener('keydown', function (event) {
 event.preventDefault();
 // CTRL + S combo
 if (event.ctrlKey &amp;&amp; event.key === 'd') {
   document.body.style = "color: white; background-color: #111111";
 }
 // CTRL + L combo 
 if (event.ctrlKey &amp;&amp; event.key === 'l') {
   document.body.style = '';
 }
});</code>

<a href="https://glitch.com/embed/#!/embed/alligator-keyboard-event-3?path=public/client.js&amp;previewSize=100&amp;attributionHidden=true">alligator-keyboard-event-3 on Glitch</a>

Want to listen for the Alt or Shift keys instead? There's properties for those too!
<li>
<em>event.ctrlKey</em>: the Ctrl key</li><li>
<em>event.altKey</em>: the Alt key</li><li>
<em>event.metaKey</em>: the “meta” key differs based on the OS. 
For example, on Mac OSX it's the  Command key</li><li>
<em>event.shiftkey</em>: the Shift key</li>

Until recently the conventional way to listen to the keyboard was via <code>event.keyCode</code> instead of <code>event.key</code>. 
Many forums/blogs like StackOverflow still heavily feature <code>keyCode</code> however beware... 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" alt="keycode docs">It is deprecated!</a>

<h3>Conclusion</h3>
Listening to the keyboard allows you to build lots of interesting features! You can create a web-based video game, or add keyboard shortcuts to your app so users feel more productive. 
Hopefully this has whet your appetite, and given you a solid foundation for creating keyboard listeners!

Visit <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent" alt="mdn-docs">MDN</a> for full documentation on <code>KeyboardEvent</code>

<h2>V8's V8: Optional Chaining and Nullish Coalescing in JavaScript</h2>

I think the V8 team at Google was waiting for this moment for a long time. 
The 8th version of the <a href="https://alligator.io/js/v8-engine/">V8 engine</a> (the most popular JavaScript engine) is out! This new version comes with some really nice performance improvements and two new cool JavaScript language features: optional chaining and nullish coalescing.

<h3>Optional Chaining</h3>
This is a long-awaited feature. 
Let's say you're working with a terrible API provider. 
Let's call this API CrocosAPI. 
CrocosAPI provides information about all the crocodiles in the world (it's an unstable API every one knows ‘gators are superior to crocs').

This is what our function to get a croc's habitat (some crocodiles live in freshwater, brakish water and/or saltwater)

<code>const getWaterHabitat = async (crocName) => {
 // First we call our made up api
 const crocResponse = await fetch('http://api.crocosapi.io/croc/' + crocName);
 // We get the responses body
 const crocInfo = crocResponse.body;
 // We access the water property of the habitat property
 return crocInfo.habitat.water;
}

// Let's get the water habitat of a crocodile called Barry
const barrysWaterHabitat = getWaterHabitat('Barry');
// this returnsbarrysWaterHabitat == ['freshwater']</code>

Now let's say the developers of CrocosAPI decided to change the structure of their response from:

<code>{
 "personalInfo" : {
   "firstName" : "Barry"
 },
 "habitat": {
   "water": ["freshwater"],
 }
 // ... skipping
}</code>

To:

<code>{
 "personalInfo" : {
   "firstName" : "Barry"
   //  ...
 },
 // We changed 'habitat' to 'environment'
 "environment": {
   "water": ["freshwater"]
 }
 //...
}</code>

Now if we call <code>getWaterHabitat</code> we will get:

<code>TypeError: Cannot read property 'water' of undefined</code>

That's because <code>crocInfo.habitat</code> doesn't exist anymore. 
Now to access <code>crocInfo</code>, we have to access <code>crocInfo.environment.water</code>. 
This means our entire app will crash just because CrocosAPI's developers don't know about versioning. 
So how to avoid that error? Optional chaining of course!

<code>const getWaterHabitat = async (crocName) => {
 const crocResponse = await fetch('http://api.crocosapi.io/croc/' + crocName)
 const crocInfo = crocResponse.body
 // We access the water key with optional chaining
 return crocInfo?.habitat?.water
}

const myCrocsName = 'Barry'
const barrysWaterHabitat = getWaterHabitat('Barry')
// barrysWaterHabitat == undefined</code>

You can also use optional indexing with arrays:

<code>const crocAddress1City = crocInfo?.personalInfo?.addresses?.[0].city
// if  crocInfo.personalInfo.addresses = []
// crocAddress1City === undefined</code>

… And with functions!

<code>// It is hard to make a short example
const getSkinStyle = (option) => {
 const scales = {
   color: 'green',
   texture: 'shiny'
 }
 if (option == 'naked')
   return
 else 
   return scales
}

const crocInfo = {
 name: 'Barry', 
 waterHabitat : 'Freshwaters',
 getSkinStyle : getSkinStyle
}

const barrysSkinColor = crocInfo?.getSkinStyle?.('naked')?.color
// barrysSkinColor === undefined
const larrysSkinColor = crocInfo?.getSkinStyle?.('naked')?.color
// larrysSkinColor === 'green'</code>

…And with dynamic property access. 
Wow, it really is holiday season  (at the time of the writing)!

<code>// habitatType can be "water" or "land"
const getHabitatProperty = (habitatType) => {
 return crocInfo?.habitat?.[habitatType]
}
getHabitatType('water')
// returns  ['freshwater']
getHabitatType('land')
// returns ['forest']</code>

No more type errors anymore, just an <code>undefined</code> value!

As a quick PSA, don't rely on optional chaining as an excuse not to do proper error handling. 
The good thing about the TypeError we get from accessing the property of an undefined value is that:
<li>It's easier to notice unexpected behavior in our applications</li><li>It forces us to write better fallback mechanisms</li>

We should still have some sort of fallback or warning mechanism when trying to access the property of an undefined value.

<h3>Nullish coalescing</h3>
<code>??</code>… No I'm not confused, <code>??</code> is the new short-circuit operator joining the <code>&amp;&amp;</code> and <code>||</code> family. 
If you wrote some React, Vue or Angular you have probably already written or seen something like this.

<code>const name = props.name || 'CrocName Error';
const age = props.age || 'Invalid Age';
const isFemale = props.isFemale || true;
// pass name , age and isFemale to a view</code>

This code will assign the value stored in <code>props.name</code> if it's not falsy. 
If the value is falsy, the value <code>name</code> will equal <code>CrocName Error</code>.

But let's say that for crocodiles who still haven't been named, the API returns an empty string. 
In JavaScript, an empty string is considered falsy so this will happen:

<code>// Let's say we have an anonymous new born boy crocodile
const props  = {
 name: '',
 age: 0,
 isFemale: false
}

const name = props.name || 'CrocName Error';
// name === 'CrocName Error'

const age = props.age || 'Invalid Age';
// age === 'Invalid Age'

const isFemale = props.isFemale || true;
// isFemale === true
</code>

These are not the results we were expecting! We want to separate the scenario where <code>props.name</code> has a <code>null</code> or <code>undefined</code> value to the case where <code>props.name</code> is an empty string. 
We want <code>age</code> to equal <code>0</code> and <code>isFemale</code> to be <code>false</code>. 
That's where <code>??</code> comes to the rescue.

<code>const name = '' ?? 'CrocName Error'
// name === '' 

const age = 0 ?? 'Invalid Age';
// age === 0

const isFemale = false ?? true;
// isFemale === false

// Yay it worked!</code>

<code>||</code> checks if the left hand side operator is falsy. 
<code>??</code> only checks if it is <code>null</code> or <code>undefined</code>. 
Here is a little cheat sheet for you:

<code>// +0, -0, NaN, false, empty strings, null and undefined are all falsy
false ?? true;   // equals false
false || true;   // equals true

0 ?? 1;          // equals 0
0 || 1;          // equals 1

'' ?? 'default'; // equals ''
'' || 'default'; // equals 'default'

// null and undefined are falsy so in this case we  get the same results
null ?? [];      // equals []
null || [];      // equals []

undefined ?? []; // equals []
undefined || []; // equals []</code>

You can also mix operators! Just remember to use parenthesis. 
Try to think about what this would do:

<code>const crocName = (props.name ?? 'CrocName Error') || 'Anonymous Croc';</code>

Let's look at the result of a few values:
<li>
<code>props.name === 'Barry'</code>: <code>crocName === 'Barry'</code>
</li><li>
<code>props.name === ''</code> : <code>crocName ==== 'Anonymous Croc'</code>
</li><li>
<code>props.name === undefined</code> : <code>crocName ==== 'CrocName Error'</code>
</li>

<h3>Nullish Coalescing and Optional Chaining Working Together</h3>
You might have thought of cool ways to use these two features together!

<code>const getCrocName = async (crocId) => {
 // We try to access our unstable API's data
 const crocResponse = await fetch('http://api.crocosapi.io/croc/' + crocId)
 // If croc response or body is undefined 
 const crocInfo = crocResponse?.body ?? 'Croc API did not return a valid response'
 // if crocResponse equals {} then crocInfo == 'Croc API did not return a valid response'

 // checking if crocInfo, personal info or name is undefined/null or if name has a falsy value
 return (crocInfo?.personalInfo?.name ?? 'There was a problem loading the croc\'s name') || 'Anonymous Croc'
 // if crocInfo?.personalInfo?.name === '' we return 'Anonymous Croc'
 //  if crocInfo equals {} we return 'There was a problem loading the croc\'s name'
}</code>

<h3>V8 V8's Performance</h3>
Nowadays we are spoiled with how fast JavaScript is and even more spoiled by recurrent performance updates. 
Once again, V8's engineers improved the performance and memory of their engine. 
If you're interested in learning more about how that is, you can check out <a href="https://v8.dev/blog/v8-release-80">their release post</a>. 
The thing I love about these updates is that it improves our code performance, but we don't have to write anything new!

<h3>Tiny Bonus</h3>
To check if you can use V8 v8 in Node.jd you can run <code>node -p process.versions.v8</code> and see if the version is over 8. 
For now you should use polyfills like <a href="https://github.com/zloirock/core-js/tree/e012e41d4a3c2a7fa184af72749df778f9b2828c">core-js</a> on the web and/or a transpiler. 
If you're using Babel, <code>@babel/plugin-proposal-optional-chaining</code>, <code>@babel/plugin-proposal-nullish-coalescing-operator</code> are available.

Have fun and happy holidays! 


<h2>Parse, Validate, Manipulate, and Display Dates and Times in JavaScript with Day.js</h2>

With it's last release nearly a year ago, the most recent commit over 6 months ago, and hundreds of open bugs and pull requests, it's starting to seem like <a href="https://alligator.io/js/time-manipulations-momentjs/">Moment.js</a> is slowing down and it's time to shop for more actively maintained alternatives. 
Insert Day.js, a minimalist date and time library weighing in at 2kB that provides a mostly Moment.js-compatible API for ease of transition.

<h3>Getting Started with Day.js</h3>
To get started with Day.js in your Node.js project, simply add the dependency with either <code>npm</code> or <code>yarn</code>:

<code>$ npm install dayjs --save
# or
$ yarn add dayjs</code>

Then simply include it in your script:

<code>const dayjs = require('dayjs');</code>

Day.js also works in modern browsers and can be self-hosted or included by way of a CDN provider like <a href="https://cdnjs.com/libraries/dayjs">cdnjs</a>.

<h3>Parsing Dates and Times</h3>
Parsing a date and time string into a Day.js object is easy and supports strings, numbers, native JavaScript <code>Date</code> objects as well as other Day.js objects:

<code>let date = dayjs('2019-12-27');
date = dayjs('20191227');
date = dayjs(new Date(2019, 11, 27));
date = dayjs(day('2019-12-27'));</code>

You can even omit the string entirely to default the Day.js object to the current date and time:

<code>date = dayjs();</code>

<h3>Validating Dates and Times</h3>
Once you've parsed a date and time with Day.js you can leverage the <code>isValid()</code> method to determine if what you passed in was actually something Day.js could parse:

<code>dayjs('2019-12-27').isValid(); // true
dayjs('tomorrow').isValid(); // false</code>

Additionally, if you were to attempt to display a Day.js object that was fed with a date that couldn't be parsed, the return will be <code>Invalid Date</code>.

<h3>Displaying Dates and Times</h3>
The <code>.format()</code> method allows us to take the Day.js object and convert it into a human-readable string. 
It supports your common set of date and time variables, like <code>YYYY</code> for a full year, and <code>MM</code> and <code>mm</code> for month and minutes respectively.

For those times when you want to include additional text that you don't want to be converted to a date or time part, you can “hug” the string with brackets <code>[</code> and <code>]</code>:

<code>dayjs().format('YYYY-MM-DD [at] HH:mm:ss');
dayjs().format('HH:mm:ss [on] YYYY-MM-DD');</code>

<h3>Manipulating Dates and Times</h3>
In a previous section we attempted to pass in the string <code>tomorrow</code> and it was considered an invalid date. 
To be able to get the date and time for tomorrow, we can start with today's date and time, and add a day to it:

<code>dayjs().add(1, 'day').format('YYYY-MM-DD');</code>

In addition to adding a <code>day</code>, you can also add <code>month</code> and <code>year</code> and even time-based intervals like <code>hour</code> and <code>minute</code>:

<code>dayjs().add(1, 'hour').format('YYYY-MM-DD HH:mm:ss');
dayjs().add(30, 'minute').format('YYYY-MM-DD HH:mm:ss');
dayjs().add(3, 'month').format('YYYY-MM-DD HH:mm:ss');
dayjs().add(3, 'year').format('YYYY-MM-DD HH:mm:ss');</code>

You can even chain it to do things like add multiple intervals:

<code>dayjs().add(1, 'hour').add(30, 'minute').format('YYYY-MM-DD HH:mm:ss');</code>

Don't you worry, there's a subtraction method as well:

<code>dayjs().subtract(4, 'hour').format('YYYY-MM-DD HH:mm:ss');</code>

<h3>Comparing Dates and Times</h3>
One of the more complex tasks that comes up pretty regularly in development is the comparison of dates and times. 
Day.js makes it easy be providing helper methods such as <code>isBefore()</code> and <code>isAfter()</code>:

<code>const date1 = dayjs('2020-01-1');
const date2 = dayjs();

if (date1.isBefore(date2)) {
 console.log('Date 1 falls before date 2');
}
else if (date1.isAfter(date2)) {
 console.log('Date 2 falls before date 1');
}
else if (date1.isSame(date2)) {
 console.log('Date 1 and date 2 are the same');
}</code>

<h3>Conclusion</h3>
With it's familiar interfacing and active maintenance (even during the holidays), Day.js seems like a great alternative for Moment.js.

Give it a try on your next project, I know I will be.


<h2>How to Get Started With the JavaScript Performance API</h2>

Performance, performance, performance. 
You can have the best website in the world, but if it takes 2 minutes to load nobody will see it. 
If your website takes 2 minutes to load it probably won't be too hard to figure out why. 
Optimization is trickier when you try to bring down your average load time from 1 second to 0.85 second.

There are a lot of tools which can help you understand how your application works locally. 
The Performance API is here to help us have a granular understanding of our web pages in the wild. 
You can get real data and see how your site works in different browsers, networks, parts of the world and more!

The Performance API is often described as a constellation of APIs. 
There are too many things to describe all of it in a single article. 
In this post, we'll show the most basic features to get you started with performance monitoring.

The API is evolving and there are many new features and deprecations to come. 
Level 2s of all the Performance APIs coming up; some of them are partially implemented, some of them are still drafts. 
So you should regularly check out MDN or the W3C's website for the most recent updates.

<h3>How to Access Performance Data</h3>
<h3>performance.now</h3>
The most basic way to measure a program's performance is to use <code>performance.now()</code>. 
This will return the current time at a sub-millisecond resolution. 
If you want to dig into high-resolution time, I highly recommend reading the <a href="https://w3c.github.io/perf-timing-primer/#high-resolution-time">W3C's Editor's draft on that topic</a>.

<code>performance.now</code> only allows you to measure what's in your JavaScript code (aka user performance). 
Later in this post I'll go over <a href="https://alligator.io/js/js-performance-api/#audit-your-functions">an example on using <code>performance.now</code></a>.

<hr>
To access different DOM and browser events we have 3 functions:
<li>
<code>getEntries()</code> returns all the available performance entries. 
Try running <code>performance.getEntries()</code> on the current page, and you will see a big array. 
Initially, most of the entries will relate to all the images, scripts and other things which are loaded by the page (aka resources).</li>
<code>const tenthEntry = performance.getEntries()[10]
// on Alligator.io it will return the following object
// { initiatorType: "script",
// nextHopProtocol: "h3",
// workerStart: 526.8099999520928,
// redirectStart: 0,
// ....
// decodedBodySize: 0,
// serverTiming: [],
// name: "https://d33wubrfki0l68.cloudfront.net/bundles/e2203d1b1c14952473222bcff4c58a8bd9fef14a.js",
// entryType: "resource",
// startTime: 315.5049999477342,
// duration: 231.48499999661
//}
// We can see this is a resource entry for a script loaded from cloudfront</code>
<li>getEntriesByType() is like <code>getEntries()</code>, but will give you some possibility to filter the results.</li>
There are 6 types that you can query:
<li>frame: Very experimental feature which allows developers to get data about how much work is done by the browser in one event loop. 
If the browser is doing too much work in one loop, the frame rate will drop and the user experience will be poor.</li><li>resource: This relates to all the resources which are downloaded by the site.</li><li>mark: These are custom markers that can be used to calculate the speed of your code.</li><li>measure: Measures allow us to easily measure the difference between two marks.</li><li>paint: The paint entries relate to the pixels displayed on the screen.</li><li>longtask: Long tasks are any task which take over 50ms to execute.</li>

We will dive into some of these types in the next sections. 
Here is a simple example to get started:

<code>const paintEntries = performance.getEntriesByType('paint')
// paint Entries[0] equals {
//    name: "first-paint",
//    entryType: "paint",
//    startTime: 342.160000000149,
//    duration: 0,
//    }
// paintEntries[1] equals {
//    name: "first-contentful-paint",
//    entryType: "paint",
//    startTime: 342.160000000149,
//    duration: 0,
// }</code>
<li>getEntriesByName(entryName) filters all the entries by name.</li>
<code>const nativeLogoPerfEntry = performance.getEntriesByName('https://alligator.io/images/alligator-logo3.svg')[0];
// It will return performance information related to the logo's performance:
// {initiatorType: "img",
// nextHopProtocol: "",
// workerStart: 539.6649999311194,
// ........
// name: "https://alligator.io/images/alligator-logo3.svg",
// entryType: "resource",
// startTime: 539.5149999530986,
// duration: 94.24000000581145
//}</code>

If you are looking for higher level information about the site's performance you can also call <code>performance.toJSON()</code>.

<h3>Audit your functions</h3>
For auditing specific JavaScript functions, the most basic tool is <code>performance.now()</code> which we described above.

Here's a usage example:

<code>const firstNow = performance.now()
// This loop is just to simulate slow calculations
for (let i = 0; i &lt; 100000; i++){
 var ii = Math.sqrt(i)
}
const secondNow = performance.now()

const howLongDidOurLoopTake = secondNow - firstNow
// on my laptop it returns howLongDidOurLoopTake == 4.08500000089407 in milliseconds</code>

The problem with <code>now</code> is that it's a bit difficult to manage if you have many measurements. 
A more useful tool is <code>mark</code> which creates some performance entries which you can query later-on. 
Then you can combine markers and create new entries using <code>measure</code>.

<code>performance.mark('beginSquareRootLoop');
// This loop is just to simulate slow calculations
for (let i = 0; i &lt; 1000000; i++){
 var ii = Math.sqrt(i);
}
performance.mark('endSquareRootLoop');
// Then anywhere in your code you can use

// We create a new entry called measureSquareRootLoop which combines our two marks
performance.measure('measureSquareRootLoop','beginSquareRootLoop', 'endSquareRootLoop');

console.log(performance.getEntriesByName('beginSquareRootLoop'));
// {detail: null,
// name: "beginSquareRootLoop",
// entryType: "mark",
// startTime: 3745.360000000801,
// duration: 0}

console.log(performance.getEntriesByName('measureSquareRootLoop'));
// {detail: null,
// name: "measureSquareRootLoop",
// entryType: "measure",
// startTime: 3745.360000000801, This is the same as beginSquareRootLoop
// duration: 9.904999984428287 shows the time it took to get from beginSquareRootLoop to endSquareRootLoop
//}</code>

<h3>Navigation Data</h3>
Navigation is used to get a granular understanding of the critical steps to build your web page. 
The safest way to access the navigation data is to do:

<code>const navigationEntry = performance.getEntriesByType('navigation')[0]</code>

In my browser, I get:

<code>{
 unloadEventStart: 213.41000002576038,
 unloadEventEnd: 213.41000002576038,
 domInteractive: 975.8100000326522,
 domContentLoadedEventStart: 982.2649999987334,
 domContentLoadedEventEnd: 1217.9650000180118,
 domComplete: 2000.960000033956,
 loadEventStart: 2001.044999982696,
 loadEventEnd: 2008.6500000325032,
 type: "reload",
 redirectCount: 0,
 initiatorType: "navigation",
 nextHopProtocol: "",
 workerStart: 2.5550000136718154,
 redirectStart: 0,
 redirectEnd: 0,
 fetchStart: 2.5599999935366213,
 domainLookupStart: 2.5599999935366213,
 domainLookupEnd: 2.5599999935366213,
 connectStart: 2.5599999935366213,
 connectEnd: 2.5599999935366213,
 secureConnectionStart: 0,
 requestStart: 2.5599999935366213,
 responseStart: 107.46500000823289,
 responseEnd: 214.3950000172481,
 transferSize: 0,
 encodedBodySize: 0,
 decodedBodySize: 0,
 serverTiming: [],
 name: "https://alligator.io/",
 entryType: "navigation",
 startTime: 0,
 duration: 2008.6500000325032
}</code>

We will dive in some more detailed explanations about how to use that data in a future post. 
But in the meantime here is a visualization of the navigation timeline:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/762c655b7a18a956e29182350bc7879f5aa85b94/95616/images/js/js-performance-api/performance-navigation-timeline.jpg">

<h3>Resource</h3>
Anytime a resource is loaded by a page we can find its trace in the <em>Performance Entries</em>. 
All we have to do to get them is run <code>performance.getEntriesByType('resource')</code>. 
This includes images, scripts, CSS files and more. 
So for example if we want to focus on the performance of images on the site we can run:

<code>performance.getEntriesByType('resource').filter(resource=> resource.initiatorType == 'img')</code>

Here's one of the resources found on Alligator.io:

<code>{
   initiatorType: "img",
   nextHopProtocol: "h3",
   workerStart: 551.2149999849498,
   redirectStart: 0,
   redirectEnd: 0,
   fetchStart: 551.3149999896996,
   domainLookupStart: 0,
   domainLookupEnd: 0,
   connectStart: 0,
   connectEnd: 0,
   secureConnectionStart: 0,
   requestStart: 0,
   responseStart: 0,
   responseEnd: 560.1850000093691,
   transferSize: 0,
   encodedBodySize: 0,
   decodedBodySize: 0,
   serverTiming: [],
   name: "https://d33wubrfki0l68.cloudfront.net/39d2d2905588dad289b228deb021d51449f6143d/a3baf/images/logos/gatsby-logo.svg",
   entryType: "resource",
   startTime: 222.0450000022538,
   duration: 338.1400000071153
}</code>

This entry has a lot of 0 values as you can see, that is because we are restricted by CORS (this is a big limit of the resource timing API). 
So the following properties will always return 0: redirectStart, redirectEnd, domainLookupStart, domainLookupEnd, connectStart, connectEnd, secureConnectionStart, requestStart, and responseStart.

<h3>Paint</h3>
The paint API relates to events that draw pixels on the window. 
As we saw in a previous snippet, we have access to <em>First Time to Paint</em> and <em>First Contentful Paint</em>. 
If you've worked with front-end optimization tools like Lighthouse, you might be familiar with these terms. 
The first time to paint is when the first pixel shows up on the user screen. 
The first contentful paint is when an element defined in the DOM is first rendered. 
To optimize the first contentful paint you can reduce render-blocking scripts and stylesheets, use HTTP caching, optimize JavaScript boot-up and more!

These are useful metrics but are pretty limited if you are trying to understand what your users see. 
In order to have a good idea of your user's performance perception, we need to combine multiple metrics.

The performance API is gigantic and is rapidly changing. 
The best place to look for updates is of course Alligator.io, but if you want to explore this topic really in depth you should check out the <a href="https://www.w3.org/webperf/">Web Performance Working Group's</a> page where you can find the latest working drafts and recommendations.


<h2>Looking at All 13 JavaScript Proxy Traps</h2>

Proxies are a really cool JavaScript feature. 
If you like meta programming you probably are already familiar with them. 
In this article we are not going to get in to programming design patterns or get meta or even understand how proxies work.

Usually articles about traps always have the same examples to set private properties with proxies. 
It is a great example. 
However, here we are going to look at all the traps you can use. 
These examples are not meant to be real world use cases, the goal is to help you understand how <code>Proxy</code> traps work.

<h3>Traps? What? It already sounds ominous</h3>
I don't really like the word trap. 
I've read everywhere that the word comes from the domain of operating systems (even Brendan Eich mentions it at JSConfEU 2010). 
However I am not exactly sure why. 
Maybe it's because traps in the context of operating systems are synchronous and can interrupt the normal execution of the program.

Traps are internal method detection tools. 
Whenever you interact with an object, you are calling <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-invariants-of-the-essential-internal-methods">an essential internal method</a>. 
Proxies allow you to intercept the execution of a given internal method.

So when you run:

<code>const profile = {};
profile.firstName = 'Jack';</code>

You are telling your JavaScript engine to call the [[SET]] internal method. 
So the <code>set</code> trap will call a function to execute before <code>profile.firstName</code> is set to <code>'Jack'</code>.

<code>const kickOutJacksHandler = {
 set: function (target, prop, val) {
   if (prop === 'firstName' &amp;&amp; val === 'Jack') {
     return false;
   }
   target[prop] = val;
   return true;
 }
}</code>

Here our <code>set</code> trap will reject any program which tries to create a profile with the first name <code>Jack</code>.

<code>const noJackProfile  = new Proxy ({}, kickOutJacksHandler);
noJackProfile.firstName = 'Charles';
// console will show {} 'firstName' 'Charles'
// noJackProfile.firstName === 'Charles'
//This won't work because we don't allow firstName to equal Jack

newProfileProxy.firstName = 'Jack';
// console will show {firstName: 'Charles'} 'firstName' 'Charles'
// noJackProfile.firstName === 'Charles'</code>

<h3>What can I Proxy?</h3>
Anything that satisfies:

<code>typeof MyThing === 'object'</code>

This means arrays, functions, object and even…

<code>console.log(typeof new Proxy({},{}) === 'object')
// logs 'TRUE' well actually just true... 
I got a bit excited...</code>

PROXIES! You just can't proxy anything if your browser doesn't support it since there are no fully functional polyfills or transpiling options (more on that in another post).

<h3>All the Proxy Traps</h3>
There are 13 traps in JavaScript! I chose not to classify them, I'll present them from what I think are the most useful to less useful (sort of). 
It's not an official classification and feel free to disagree. 
I am not even convinced by my own ranking.

Before we get started, here is a little cheat sheet <a href="https://www.ecma-international.org/ecma-262/9.0/#sec-proxy-object-internal-methods-and-internal-slots">taken from the ECMAScript specification</a>:

<table>
<thead><tr>
<th>Internal Method</th>
<th>Handler Method</th>
</tr></thead>
<tbody>
<tr>
<td>[[Get]]</td>
<td>get</td>
</tr>
<tr>
<td>[[Delete]]</td>
<td>deleteProperty</td>
</tr>
<tr>
<td>[[OwnPropertyKeys]]</td>
<td>ownKeys</td>
</tr>
<tr>
<td>[[HasProperty]]</td>
<td>has</td>
</tr>
<tr>
<td>[[Call]]</td>
<td>apply</td>
</tr>
<tr>
<td>[[DefineOwnProperty]]</td>
<td>defineProperty</td>
</tr>
<tr>
<td>[[GetPrototypeOf]]</td>
<td>getPrototypeOf</td>
</tr>
<tr>
<td>[[SetPrototypeOf]]</td>
<td>setPrototypeOf</td>
</tr>
<tr>
<td>[[IsExtensible]]</td>
<td>isExtensible</td>
</tr>
<tr>
<td>[[PreventExtensions]]</td>
<td>preventExtensions</td>
</tr>
<tr>
<td>[[GetOwnProperty]]</td>
<td>getOwnPropertyDescriptor</td>
</tr>
<tr>
<td>[[Enumerate]]</td>
<td>enumerate</td>
</tr>
<tr>
<td>[[Construct]]</td>
<td>construct</td>
</tr>
</tbody>
</table>
<h3>Get, Set and Delete: The super basic</h3>
We already saw <code>set</code>, let's take a look at <code>get</code> and <code>delete</code>. 
Side note: when you use <code>set</code> or <code>delete</code> you have to return <code>true</code> or <code>false</code> to tell the JavaScript engine if the key should be modified.

<code>const logger = []

const loggerHandler = {
 get: function (target, prop) {
   logger.push(`Someone  accessed '${prop}' on object ${target.name} at ${new Date()}`);
   return target[prop] || target.getItem(prop) || undefined;
 },
}

const secretProtectorHandler = {
 deleteProperty: function (target, prop) {
   // If the key we try to delete contains to substring 'secret' we don't allow the user to delete it
   if (prop.includes('secret')){
     return false;
   }
   return true;
 }
};

const sensitiveDataProxy = new Proxy (
 {name:'Secret JS Object', secretOne: 'I like weird JavaScript Patterns'},
 {...loggerHandler, ...secretProtectorHandler}
);

const {secretOne} = sensitiveDataProxy;
//logger = ['Someone tried to accessed 'secretOne' on object Secret JS Object at Mon Dec 09 2019 23:18:54 GMT+0900 (Japan Standard Time)']

delete sensitiveDataProxy.secretOne;
// returns false it can't be deleted!

// sensitiveDataProxy equals  {name: 'Secret JS Object', secretOne: 'I like weird JavaScript Patterns'}</code>

<h3>Playing With Keys</h3>
Let's say we have a web server that gets some application data to our route. 
We want to keep that data in our controller. 
But maybe we want to make sure it doesn't get misused. 
The <code>ownKeys</code> trap will activate once when we try to access the object's keys.

<code>const createProxiedParameters  = (reqBody, allowed) => {
 return new Proxy (reqBody, {
   ownKeys: function (target) {
     return Object.keys(target).filter(key => allowed.includes(key))
   }
 });
};

const allowedKeys = ['firstName', 'lastName', 'password'];

const reqBody = {lastName:'Misteli', firstName:'Jack', password:'pwd', nefariousCode:'MWUHAHAHAHA'};

const proxiedParameters = createProxiedParameters(reqBody, allowedKeys);

const parametersKeys =  Object.keys(proxiedParameters)
// parametersKeys equals ["lastName", "firstName", "password"]
const parametersValues = parametersKeys.map(key => reqBody[key]);
// parameterValues equals ['Misteli', 'Jack', 'pwd']

for (let key in proxiedParameters) {
 console.log(key, proxiedParameters[key]);
}
// logs:
// lastName Misteli
// firstName Jack
// password pwd

// The trap will also work with these functions
Object.getOwnPropertyNames(proxiedParameters);
// returns ['lastName', 'firstName', 'password']
Object.getOwnPropertySymbols(proxiedParameters);
// returns []</code>

In a real application you should NOT clean your parameters like this. 
However, you can build a more complex system based on proxies.

<h3>Overloading in Arrays</h3>
Have you always dreamt of using the <code>in</code> operator with arrays, but have always been too shy to ask how?

<code>function createInArray(arr) {
 return new Proxy(arr, {
   has: function (target, prop) {
     return target.includes(prop);
   }
 });
};

const myCoolArray  =  createInArray(['cool', 'stuff']);
console.log('cool' in myCoolArray);
// logs true
console.log('not cool' in myCoolArray);
// logs false</code>

The <code>has</code> trap intercepts methods which attempts to check if a property exists in an object using the <code>in</code> operator.

<h3>Control Function Call Rate with Apply</h3>
<code>apply</code> is used to intercept function calls. 
Here we're going to look at a very simple caching proxy.

The <code>createCachedFunction</code> takes a <code>func</code> argument. 
The ‘cachedFunction' has an <code>apply</code> (aka <code>[[Call]]</code>) trap which is called every time we run <code>cachedFunction(arg)</code>. 
Our handler also has a <code>cache</code> property which stores the arguments used to call the function and the result of the function. 
In the <code>[[Call]]</code> / <code>apply</code> trap we check if the function was already called with that argument. 
If so, we return the cached result. 
If not we create a new entry in our cache with the cached result.

This is not a complete solution. 
There are a lot of pitfalls. 
I tried to keep it short to make it easier to understand. 
Our assumption is that the function input and output are a single number or string and that the proxied function always returns the same output for a given input.

<code>const createCachedFunction = (func) => {
 const handler = {
   // cache where we store the arguments we already called and their result
   cache : {},
   // applu is the [[Call]] trap
   apply: function (target, that, args) {
     // we are assuming the function only takes one argument
     const argument = args[0];
     // we check if the function was already called with this argument
     if (this.cache.hasOwnProperty(argument)) {
       console.log('function already called with this argument!');
       return this.cache[argument];
     }
     // if the function was never called we call it and store the result in our cache
     this.cache[argument] = target(...args);
     return this.cache[argument];
   }
 }
 return new Proxy(func, handler);
};

// awesomeSlowFunction returns an awesome version of your argument
// awesomeSlowFunction resolves after 3 seconds
const awesomeSlowFunction = (arg) => {
 const promise = new Promise(function(resolve, reject) {
   window.setTimeout(()=>{
     console.log('Slow function called');
     resolve('awesome ' + arg);
     }, 3000);
   });
 return promise;
};

const cachedFunction = createCachedFunction(awesomeSlowFunction);

const main = async () => {
 const awesomeCode = await cachedFunction('code');
 console.log('awesomeCode value is: ' + awesomeCode);
 // After 3 seconds (the time for setTimeOut to resolve) the output will be :
 // Slow function called
 //  awesomeCode value is: awesome code

 const awesomeYou = await cachedFunction('you');
 console.log('awesomeYou value is: ' + awesomeYou);
   // After 6 seconds (the time for setTimeOut to resolve) the output will be :
 // Slow function called
 //  awesomeYou value is: awesome you

 // We are calling cached function with the same argument
 const awesomeCode2 = await cachedFunction('code');
 console.log('awesomeCode2 value is: ' + awesomeCode2);
 // IMMEDIATELY after awesomeYou resolves the output will be:
 // function already called with this argument!
 // awesomeCode2 value is: awesome code
}

main()</code>

This is a bit tougher to chew than the other code snippets. 
If you don't understand the code try copy/pasting it in your developer console and add some <code>console.log()</code> or try your own delayed functions.

<h3>DefineProperty</h3>
<code>defineProperty</code> is really similar to <code>set</code>, it's called whenever <code>Object.defineProperty</code> is called, but also when you try to set a property using <code>=</code>. 
You get some extra granularity with an additional <code>descriptor</code> argument. 
Here we use <code>defineProperty</code> like a validator. 
We check that new properties are not writeable or enumerable. 
Also we modify the defined property <code>age</code> to check that the age is a number.

<code>const handler = {
 defineProperty: function (target, prop, descriptor) {
   // For some reason we don't accept enumerable or writeable properties 
   console.log(typeof descriptor.value)
   const {enumerable, writable} = descriptor
   if (enumerable === true || writable === true)
     return false;
   // Checking if age is a number
   if (prop === 'age' &amp;&amp; typeof descriptor.value != 'number') {
     return false
   }
   return Object.defineProperty(target, prop, descriptor);
 }
};

const profile = {name: 'bob', friends:['Al']};
const profileProxied = new Proxy(profile, handler);
profileProxied.age = 30;
// Age is enumerable so profileProxied still equals  {name: 'bob', friends:['Al']};

Object.defineProperty(profileProxied, 'age', {value: 23, enumerable: false, writable: false})
//We set enumerable to false so profile.age === 23</code>

<h3>Construct</h3>
<code>apply</code> and call are the two function traps. 
<code>construct</code> intercepts the <code>new</code> operator. 
I find <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">MDN's example</a> on function constructor extension really cool. 
So I will share my simplified version of it.

<code>const extend = (superClass, subClass) => {
 const handler = {
   construct: function (target, args) {
     const newObject = {}
     // we populate the new object with the arguments from
     superClass.call(newObject, ...args);
     subClass.call(newObject, ...args);
     return newObject;
   },
 }
 return  new Proxy(subClass, handler);
}

const Person = function(name) {
 this.name = name;
};

const Boy = extend(Person, function(name, age) {
 this.age = age;
 this.gender = 'M'
});

const Peter = new Boy('Peter', 13);
console.log(Peter.gender);  // 'M'
console.log(Peter.name); // 'Peter'
console.log(Peter.age);  // 13</code>

<h3>Don't Tell Me What to Do!</h3>
<code>Object.isExtensible</code> checks if we can add property to an object and <code>Object.preventExtensions</code> allows us to prevent properties from being added. 
In this code snippet we create a trick or treat transaction. 
Imagine a kid going to a door, asking for treats but he doesn't know what's the maximum amount of candy he can get. 
If he asks how much he can get, the allowance will drop.

<code>function createTrickOrTreatTransaction(limit) {
 const extensibilityHandler = {
   preventExtensions:  function (target) {
     target.full = true;
     // this will prevent the user from even changing the existing values
     return  Object.freeze(target);
   },
   set:  function (target, prop, val) {
     target[prop] = val;
     const candyTotal = Object.values(target).reduce((a,b) => a + b, 0) - target.limit;

     if (target.limit - candyTotal &lt;= 0) {
       // if you try to cheat the system and get more that your candy allowance, we clear your bag
       if (target.limit - candyTotal &lt; 0 )
         target[prop] = 0;
       // Target is frozen so we can't add any more properties

       this.preventExtensions(target);
     }  
   },
   isExtensible: function (target) {
     // Kids can check their candy limit 
     console.log( Object.values(target).reduce((a,b) => a + b, 0) - target.limit);
     // But it will drop their allowance by one
     target.limit -= 1;
     // This will return the sum of all our keys
     return Reflect.isExtensible(target);
   }
 }
 return new Proxy ({limit}, extensibilityHandler);
};

const candyTransaction = createTrickOrTreatTransaction(10);

Object.isExtensible(candyTransaction);
// console will log 10
// Now candyTransaction.limit = 9

candyTransaction.chocolate  = 6;

// The candy provider got tired and decided to interrupt the negotiations early
Object.preventExtensions(candyTransaction);
// now candyTransaction equals to {limit: 9, chocolate: 6, full: true}

candyTransaction.chocolate = 20;
//  candyBag equals to {limit: 9, chocolate: 6, full: true}
// Chocolates did not go change to 20 because we called freeze in the preventExtensions trap

const secondCandyTransaction = createTrickOrTreatTransaction(10);

secondCandyTransaction.reeses = 8;
secondCandyTransaction.nerds = 30;
// secondCandyTransaction equals to {limit: 10, reeses: 8, nerds: 0, full: true}
// This is because we called preventExtensions inside the set function if a kid tries to shove in extra candies

secondCandyTransaction.sourPatch = 30;
// secondCandyTransaction equals to {limit: 10, reeses: 8, nerds: 0, full: true}</code>

<h3>GetOwnPropertyDescriptor</h3>
Wanna see something weird?

<code>let candies = new Proxy({}, {
 // as seen above ownKeys is called once before we iterate
 ownKeys(target) {
   console.log('in own keys', target);
   return ['reeses', 'nerds', 'sour patch'];
 },
// on the other end getOwnPropertyDescriptor at every iteration
 getOwnPropertyDescriptor(target, prop) { 
   console.log('in getOwnPropertyDescriptor', target, prop);
   return {
     enumerable: false,
     configurable: true
   };
 }
});

const candiesObject = Object.keys(candies);
// console will log:
// in own keys {}
// in getOwnPropertyDescriptor {} reeses
// in getOwnPropertyDescriptor {} nerds
// in getOwnPropertyDescriptor {} sour patch
// BUT ! candies == {} and candiesObject == []</code>

This is because we set enumerable as false. 
If you set enumerable to <code>true</code> then <code>candiesObject</code> will be equal to <code>['reeses', 'nerds', 'sour patch']</code>.

<h3>Prototype Get and Set</h3>
Not sure when this will come in handy. 
Not even sure when setPrototypeOf comes handy but here it goes. 
Here we use the setPrototype trap to check if the prototype of our object has been tampered with.

<code>const createSolidPrototype = (proto) => {
 const handler = {
   setPrototypeOf: function (target, props) {
     target.hasBeenTampered = true;
     return false;
   },
   getPrototypeOf: function () {
     console.log('getting prototype')
   },
   getOwnProperty: function() {
     console.log('called: ' + prop);
     return { configurable: true, enumerable: true, value: 10 };
   }
 };
};</code>

<h3>Enumerate</h3>
Enumerate allowed us to intercept the <code>for...in</code>, but unfortunately we can't use it since ECMAScript 2016. 
You can find more about that decision in this <a href="https://github.com/rwaldron/tc39-notes/blob/c4466ea1977d17a0fa607e3ab9ff63504dba004f/meetings/2016-01/jan-28.md">TC39 meeting note</a>.

I tested a script on Firefox 40 just so that you don't say I lied to you when I promised 13 traps.

<code>const alphabeticalOrderer = {
 enumerate: function (target) {
   console.log(target, 'enumerating');
   // We are filtering out any key that has a number or capital letter in it and sorting them
   return Object.keys(target).filter(key=> !/\d|[A-Z]/.test(key)).sort()[Symbol.iterator]();
 }
};

const languages = {
 france: 'French',
 Japan: 'Japanese',
 '43J': '32jll',
 alaska: 'American'
};

const languagesProxy = new Proxy (languages, alphabeticalOrderer);

for (var lang in languagesProxy){
 console.log(lang);
}
// console outputs:
// Object { france: 'French', japan: 'Japanese', 43J: '32jll', alaska: 'American' } enumerating
// alaska
// france

// Usually it would output
// france
// Japan
// 43J
// alaska</code>

You might have noticed that we don't use `Reflect` to make things simpler. 
We will cover <code>reflect</code> in another post. 
It the meantime I hope you had fun. 
We will also build a practical software to get a bit more hands-on next time.

<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>Exploring the indexOf Method for Strings and Arrays in JavaScript</h2>

When you need to find an element in an array or a string, <code>indexOf()</code> is one of your best friends.

<h3>
<code>indexOf</code>  in Arrays</h3>
Code first, explanation later:

Module: findSpencer.js

<code>const zoo = ['', '', '', '', ''];
const spencersIndex = zoo.indexOf('');
// spencersIndex === 2
const spencer = zoo[spencersIndex];
// spencer === ''</code>

In its simplest version, the <code>indexOf</code> method takes one argument which is the element we are trying to find. 
Then it returns the index of the first element it finds in the array which satisfies <code>el === target</code>. 
This means that even if there are two matches in your array, indexOf will only return one result. 
The result is the first occurrence in the array (reading the array from left to right).

When no item in the array satisfies the <code>el === target</code> check, the value of <code>-1</code> is returned.

But let's say we are also looking for Skyler (Spencer's sister). 
Then we can add an extra optional argument to start the search from a different index.

Module: findSkyler.js

<code>const zoo = ['', '', '', '', '',  '']; // Skyler just arrived!
const spencersIndex = zoo.indexOf(''); // === 2 same as before

// We start searching after 
const skylersIndex = zoo.indexOf('', spencersIndex + 1);
// skylersIndex === 5</code>

We can also create a method on the Array prototype that returns all the indices based on indexOf.

Module: indicesOf.js

<code>// Try to think of ways to make indicesOf more performant
Array.prototype.indicesOf = function (target) {
 const result = [];
 let currentIndex = 0;
 while(true) {
   // here this ===  the array on which we call `indicesOf`
   const targetIndex = this.indexOf(target, currentIndex);
   if (targetIndex == -1)
     break;
  
   result.push(targetIndex);

   currentIndex = targetIndex +1;
 }

 return result;
}
const zoo = ['', '', '', '', '',  '']; // Skyler just arrived!
const alligatorsIndices = zoo.indicesOf('');
// alligatorsIndices returns [2, 5]</code>

<h3>What Can't You Find With indexOf?</h3>
You might have noticed that we interrupt the search by using triple equal comparison <code>el === target</code> which is a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness">strict equality comparison</a>. 
This means, for example, that we can't test for arrays, objects or functions other than by reference.

<code>const simpleArray = [1, 2, 3];
const simpleFunction = () => {console.log('hey')};
const simpleObject = {alligator: 'cage'};

const compositeArray = [simpleArray, simpleFunction, simpleObject];

// These all work as expected because we compare by reference
compositeArray.indexOf(simpleArray); // returns 0
compositeArray.indexOf(simpleFunction); // returns 1
compositeArray.indexOf(simpleObject); // returns 2

// These won't work 
compositeArray.indexOf([1, 2, 3]); // returns -1
compositeArray.indexOf(() => {console.log('hey')}); // returns -1
compositeArray.indexOf({alligator: 'cage'}) // returns -1</code>

<h3>A Deep indexOf</h3>
Let's say we want to create a utility to also check for objects, arrays and functions recursively:

Module: inDepthIndexOf.js

<code>Array.prototype.deepIndexOf = function (target) {
 // If the target is an object, array or a function, we give it a special treatment
 if (typeof target === 'object' || typeof target === 'function') {
   // We stringify the target 
   const searchTarget = target.toString()
   // We loop through all of the elements of the array
   for (let index = 0; index &lt; this.length; index++){
     const element = this[index]
     // We check if the element in the array is an object or a function AND if so we check if its' stringified value is equal to our target
     if ((typeof element === 'object' || typeof target === 'function') &amp;&amp; element.toString() === searchTarget) {
       // if we have a match we interrupt the loop and return the index
       return index
     }
   }
   // if nothing matched we return -1
   return -1
 }
 return this.indexOf(target)
}

const simpleArray = [1, 2, 3];
const simpleFunction = () => {console.log('hey')};
const simpleObject = {alligator: 'cage'};

const compositeArray = [simpleArray, simpleFunction, simpleObject];

// These all work as expected because we compare by reference
compositeArray.deepIndexOf(simpleArray); // returns 0
// ... 
You know the rest
// These will work!
compositeArray.deepIndexOf([1, 2, 3]); // returns 0
compositeArray.deepIndexOf(() => {console.log('hey')}); // returns 1
compositeArray.deepIndexOf({alligator: 'cage'}) // returns 2</code>

There are many ways to improve this code. 
If you have some time on your hands, try to think of how to make it more accurate and performant. 
I'd love to read your ideas on Twitter.

<h3>Performance</h3>
Using <code>indexOf</code> is much slower than simply doing a <code>for loop</code>. 
That doesn't mean that <code>indexOf </code> is slow. 
If your array is small you will never see the difference between indexOf() or a for loop. 
If your array is so big that you can notice a difference between the two methods, then you should probably wonder why your array is so big and how you could optimize the search. 
You can find <a href="https://jsperf.com/thor-indexof-vs-for">performance benchmarks on JSPerf</a>.

<code>var spencersIndex
// This is faster than indexOf('') but it is much uglier
for(var index = 0; index &lt; zoo.length; index ++) {
 if (zoo[index] === '')
   spencersIndex = index
}
// spencers Index === 2</code>

<h3>
<code>indexOf</code> in Strings</h3>
You can port all the logic from <code>Array.indexOf</code> to this section. 
Let's code!

Module: whereIsSpencer.js

<code>const whereIsSpencer = "We are all looking for Spencer the alligator. 
Spencer is a dear friend. 
Lookout here comes !"

const spencersIndex = whereIsSpencer.indexOf('Spencer');
// spencersIndex ===  23

// to find find the second occurence of 'Spencer',
// we need to add one to the position of spencer #1
const secondSpencerIndex = whereIsSpencer.indexOf('Spencer', spencersIndex + 1);
// secondSpencerIndex ===  46

const alligatorIndex = whereIsSpencer.indexOf('');
// alligatorIndex ===  91

// Be careful the search is case sensitive!
const lowerCaseSpencer = whereIsSpencer.indexOf('spencer');
// lowerCaseSpencer === -1</code>

Now we can create the same <code>indicesOf</code> function for <code>Array.prototype.string</code>.

Module: indicesOfStrings.js

<code>// This is a bit more concise than the previous indicesOf function
// But it is exactly the same logic
String.prototype.indicesOf = function (target) {
 let currentIndex = this.indexOf(target);
 const allIndices = []
 while(currentIndex != -1) {
   allIndices.push(currentIndex);
   currentIndex =  this.indexOf(target, currentIndex +1 );
 }

 return allIndices;
}

const whereIsSpencer = "We are all looking for Spencer the alligator. 
Spencer is a dear friend. 
Lookout here comes !";

const spencerIndices = whereIsSpencer.indicesOf('Spencer');
// spencerIndices equals [23, 46]</code>

I hope you had fun reading this post! If you have any suggestions, questions or comments feel free to ask away on <a href="https://twitter.com/alligatorio">Twitter</a>.


<h2>Manipulating the DOM in JavaScript with innerText and innerHTML</h2>

Front-end frameworks are all the rage these days. 
Working with a virtual DOM, while much more efficient, can be a ton of overhead when all you need to do is tweak a few elements on an existing static page. 
Fortunately, JavaScript comes with some methods that make it super easy to edit an element's text as well as the HTML inside of an element.

Take that React, Angular, Vue, and whatever hot new framework I failed to mention!

<h3>Getting started</h3>
To follow along at home, all you need is a web browser and a page to manipulate.

To make it easy, we can load up any web page, open up our browser's console and override it with our own HTML document:

<code>document.getElementsByTagName('body')[0].innerHTML = '&lt;div>Alligators rule!!&lt;/div>';</code>

Once you hit enter, the existing page will be completely replaced with a light amount of HTML and a universal truth about everybody's favorite reptile.

<h3>Editing text</h3>
All right, so in the getting started section, we sorta jumped the gun and already used <code>innerHTML</code> to manipulate some elements on the page.

To back it up a small bit, let's start by changing the text of an element on a page. 
To do so, we'll need to select our element and then use <code>innerText</code> to set the content:

<code>document.getElementById('gator').innerText = 'OF COURSE alligators rule!';</code>

Not much to it!

If you wanted to prepend text to an existing string of text, you can use <code>innerText</code> to get the current text and then prepend to it:

<code>const currentText = document.getElementById('gator').innerText;
const nextText = 'Do alligators rule? ' + currentText;
document.getElementById('gator').innerText = nextText;</code>

Appending text is even easier, since we can use <code>+=</code>:

<code>document.getElementById('gator').innerText += ' This definitely true.';</code>

<h3>Editing HTML</h3>
This is all well and good, but the moment we try to introduce HTML, like wrapping the string in <code>&lt;strong></code>, things fall apart.

Since <code>innerText</code> works with the text contents of an element, things like HTML tags end up being shown, as if the <code>&lt;</code> and <code>></code> were encoded as <code>&amp;lt;</code> and <code>&amp;gt;</code>.

No big deal though, when we want to use additional mark up with our string, all we need to do is swap out <code>innerText</code> for <code>innerHTML</code> and be on our way:

<code>document.getElementById('gator').innerHTML = '&lt;strong>OF COURSE&lt;/strong> alligators rule!';</code>

And just like <code>innerHTML</code> we can capture the value to prepend to it, and use <code>+=</code> to append to it:

<code>const currentHTML = document.getElementById('gator').innerHTML;
const nextHTML = 'Do alligators rule? ' + currentHTML;
document.getElementById('gator').innerHTML = nextHTML;

document.getElementById('gator').innerHTML += ' This definitely true.';</code>

That's not all, when using <code>innerHTML</code> we can do more than just edit the text of an element. 
We can also use it to add additional markup, like in the case of an HTML table:

<code>document.getElementById('gator').innerHTML = `
 &lt;table border="1">
   &lt;thead>
     &lt;tr>
       &lt;th>Reptile&lt;/th>
       &lt;th>Awesomeness&lt;/th>
     &lt;/tr>
   &lt;/thead>
   &lt;tbody>
     &lt;tr>
       &lt;td>Alligator&lt;/td>
       &lt;td>9001&lt;/td>
     &lt;/tr>
   &lt;/tbody>
 &lt;/table>
`;</code>

Subsequently, we can use <code>innerHTML</code> to append new rows to the table on the fly:

<code>document.getElementById('tableRows').innerHTML += `
 &lt;tr>
   &lt;td>Snake&lt;/td>
   &lt;td>-1&lt;/td>
 &lt;/tr>
`;</code>

<h3>Conclusion</h3>
Sure, using <code>innerText</code> and <code>innerHTML</code> doesn't come close to the power of a front-end framework that's leveraging a virtual DOM, but hey, it gets the job done.

Fortunately, the days are long gone when <code>innerHTML</code> was the only option available for editing elements with JavaScript. 
Even though we've come a long way, it's always good to know these things so you don't go throwing an entire framework at a trivial problem.

<h2>What's the Spread Operator Used For in JavaScript?</h2>

Learn about the ES6 spread operator, and some practical uses for this powerful JavaScript feature!

The spread operator is a feature of JavaScript introduced with ES6 that <em>gives you access to the insides of an <a href="https://alligator.io/js/iterables/">iterable object</a></em>. 
The term “iterable object” is really just a computer science-y term for a category of data types. 
Specifically: arrays, objects literals, and strings.

<strong>What makes them “iterable”?</strong> These kinds of JavaScript types can be traversed in some sequential fashion. 
For example, you can use a <a href="https://alligator.io/js/for-loops/">for loop</a> on an array, or with object literals you can use <a href="https://alligator.io/js/for-of-for-in-loops/">for…in loops</a>.

The spread operator effectively gives you access to the “stuff” inside these iterable objects. 
Let's look an example to illustrate what that means:

<code>const foo = [
 'hello',
 'bonjour',
 'konnichiwa'
];
const bar = [...foo]; // the three dots "..." are the spread operator syntax!

console.log(bar);
// ['hello', 'bonjour', 'konnichiwa'];</code>

The variable <code>bar</code> got an exact copy from <code>foo</code>! Whoa…

<code>const foo = [
 'hello',
 'bonjour',
 'konnichiwa'
]
const bar = [...foo]</code>

The spread operator essentially scooped out the insides of the <code>foo</code> array and <em>spread the values</em> across the new array in <code>bar</code>.

<hr>
Now that we have a basic idea, let's look at common tasks where the spread operator might be useful.

<h3>Duplicating Iterable Objects</h3>
As we saw earlier, the spread operator is one of the best ways for duplicating an iterable object. 
There are more complex ways to do this, but the conciseness of the spread operator makes it delightfully easy.

<code>const foo = ['hello', 'bonjour', 'konnichiwa'];
const bar = ...foo; // uh-oh :&lt;</code>

Kinda pulled a sneaky on ya. 
You have to drop it into a new set of brackets in <code>bar</code>! 

<code>const foo = ['hello', 'bonjour', 'konnichiwa'];
const bar = [...foo]; // woohoo! :>

console.log(bar);
// ['hello', 'bonjour', 'konnichiwa']</code>

Using the spread operator to duplicate object literals isn't much different than arrays. 
Just remember to BYOB (bring your own brackets):

<code>const foo = {
 english: 'hello',
 french: 'bonjour',
 japanese: 'konnichiwa'
};
const bar = {...foo};

console.log(bar);
// { english: 'hello', french: 'bonjour', japanese: 'konnichiwa' }</code>

<h3>Merging Iterable Objects</h3>
The spread operator can also be used to compose a single value from several other values!

<code>const foo = ['hello', 'bonjour', 'konnichiwa'];
const bar = ['gutentag', 'hello-ey'];
const baz = [...foo, ...bar];

console.log(baz);
// ['hello', 'bonjour', 'konnichiwa', 'gutentag', 'hello-ey']</code>

Now <code>baz</code> is the merged value of both <code>foo</code> and <code>bar</code>. 
You can also place the <em>spreaded</em> array inside another array:

<code>const foo = ['hello', 'bonjour', 'konnichiwa'];
const bar = [...foo, 'gutentag', 'hello-ey'];

console.log(bar);
// ['hello', 'bonjour', 'konnichiwa', 'gutentag', 'hello-ey']</code>

This is where your well-trained JavaScript instincts might think this looks really weird… But remember that the spread operator just holds the “stuff”. 
Where you put that “stuff” is up to you! 

How about object literals? It's very similar to merging arrays:

<code>const foo = {
 english: 'hello',
 french: 'bonjour',
 japanese: 'konnichiwa'
};
const bar = {
 german: 'gutentag',
 canadian: 'hello-ey'
};
const baz = {...foo, ...bar};

console.log(baz);
// { english: 'hello', french: 'bonjour', japanese: 'konnichiwa', german: 'gutentag', canadian: 'hello-ey' }</code>

Boom! This used to be a task for <a href="https://alligator.io/js/dealing-with-objects/#objectassign">Object.assign()</a> but the spread syntax makes this far more concise.

What happens when there's duplicate keys?

<code>const foo = {
 english: 'hello',
 french: 'bonjour',
 japanese: 'konnichiwa'
};
const bar = {
 english: 'howdy',
 german: 'gutentag'
};
const baz = {
 ...foo,
 ...bar,
 canadian: 'hello-ey',
 korean: 'annyeong'
};

console.log(baz);
// { english: 'howdy', french: 'bonjour', japanese: 'konnichiwa', german: 'gutentag', canadian: 'hello-ey', korean: 'annyeong' }</code>

The duplicate keys are overwritten!

Remember that the ellipses <em>go in front of the variable not after</em>: <code>...myVariable</code> not <code>myVariable...</code>

<h3>Feeding Arguments into Functions</h3>
You may encounter this less often, but you can also use the spread operator for feeding arguments into a function.

<code>const cube = [12, 30, 14];

function calcVolume(width, height, depth) {
 return width * height * depth;
};

calcVolume(12, 30, 14);         // basic
calcVolume.apply(null, cube);   // using "apply"
calcVolume(...cube);          // using "spread operator"</code>

The spread operator makes it incredibly easy to feed a series of arguments into functions.

<h3>You Said Something About Strings</h3>
Lastly, you can also use the spread operator with strings since they're also considered an iterable object (it has <code>slice</code>, and <code>length</code> functions!)

<code>const foo = "jumanji";
const bar = [...foo];

console.log(bar);
// [ "j", "u", "m", "a", "n", "j", "i" ]</code>

You may not encounter a need to use the spread operator for strings unless you develop software for natural language processing, or some kinda machine learning. 
I'm not sure… But it definitely works on strings!

<h3>Conclusion</h3>
The spread operator was a highly requested feature that was already available in old-school languages like C++ and Python, and now it's here! It makes some common programming tasks really easy to do, and hopefully you learned practical ways you could use it!

See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">MDN</a> for in-depth documentation on the spread operator.

<h2>Converting Arrays to Strings in JavaScript</h2>

Arrays are a powerful feature of any language. 
They let you house multiple pieces of information easily. 
They will maintain the order of items being added and can even be sorted. 
In modern web browsers, they even handle auto-magically converting themselves into human readable strings.

Even with the modern niceties, it's still good to know how to convert an array to a string for those times when you need to massage an array into another format, or want to do something more than simply comma separating the values (the default behavior).

<h3>Getting Started</h3>
No special tools required. 
You can hack along in either your web browser's console or using the Node.js REPL. 
The commands utilized are baked into the Array Object's prototype.

<h3>To string, or Not to String.</h3>
If you were to run the following in your browser:

<code>alert([1, 2, 3]);</code>

You would receive an alert with the message <code>1,2,3</code> without any additional work on your part. 
If all you need to do is display the contents of an array in this format, this can get you pretty far. 
This even works when referencing array objects inside of template literals.

Under the hood, the array items are being joined together as a string, using the comma <code>,</code> character as the delimiter. 
It's the same as running either of the following:

<code>[1, 2, 3].toString();
[1, 2, 3].join();</code>

Both result in the same <code>1,2,3</code> string.

In fact, that's all that the <code>.toString()</code> method can do for us. 
It accepts no parameters so it's usefulness is fairly limited.

Even though arrays are actually objects in JavaScript, the <code>.toString()</code> method for an array overrides the object's <code>.toString()</code> method, that's why we don't end up with the pesky and way less useful <code>[object Object]</code> string.

<h3>Join Together</h3>
While it's default behavior (without any passed parameters) is the same as <code>.toString()</code>, the <code>.join()</code> method is significantly more robust.

Let's say you wanted to include a space after the comma when creating your string, you can tell <code>.join()</code> the exact string to use:

<code>[1, 2, 3].join(', ');</code>

Prefer to have each array item on it's own line? Pass in a new line character:

<code>[1, 2, 3].join('\n');</code>

Working with HTML and want to use those breaks instead?

<code>[1, 2, 3].join('&lt;br>');</code>

Want HTML breaks AND new lines?… Okay, you get the idea.

The <code>.join()</code> method accepts an optional parameter that lets you define the separator character or characters you'd like to use to join the array items together.

<h3>Speaking of HTML</h3>
One of my favorite <code>.join()</code> tricks, before template literals and JSX made it extremely easy to work with multiple line blocks of markup, was to use <code>.join()</code> to assemble an array of HTML tags into a string:

<code>[
 '&lt;table>',
   '&lt;thead>',
     '&lt;tr>',
       '&lt;th>Name&lt;/th>',
       '&lt;th>Level&lt;/th>',
     '&lt;/tr>',
   '&lt;/thead>',
   '&lt;tbody>',
     '&lt;tr>',
       '&lt;td>Alligator&lt;/td>',
       '&lt;td>9001&lt;/td>',
     '&lt;/tr>',
   '&lt;/tbody>',
 '&lt;/table>',
].join('');</code>

Passing in an empty string to <code>.join()</code> simply joins the array items without any additional characters.

Still pretty handy for dealing with multiple line strings and/or markup when you don't have access to some of the more modern syntax options.

<h3>Conclusion</h3>
Even if all you're trying to do is display a comma separated list of array items to a user, you can still benefit from using the <code>.join()</code> method. 
It gives you more control over the output which will make things easier to read for your users.

Working with a back-end server that doesn't understand arrays being passed-in? Join your array items into a single value and you're good to go!

<h2>Capitalizing Strings in JavaScript</h2>

I love JavaScript, but it's lack of built-in string manipulation in comparison to PHP is lacking. 
Sure, you could pull in a third-party dependency for your string manipulation needs, but oftentimes that carries way more weight than you probably want in your application.

Even though JavaScript lacks the baked-in goodies, it still comes with more than enough functionality to make it easy to handle capitalization tasks.

<h3>Getting started</h3>
Since we're going to be using pure JavaScript, there's nothing additional that will need to be installed. 
In fact, you can easily follow along in your browser's console, or via the Node.js REPL!

<h3>How to capitalize an entire string</h3>
This one's easy and probably already something you already know about. 
To capitalize an entire string, simply call <code>.toUpperCase()</code> on the string:

<code>let myString = 'alligator';
myString.toUpperCase();</code>

Which will convert the lower case string to the upper case, <code>ALLIGATOR</code>.

This can even work on mixed case strings as well:

<code>myString = 'AlliGator';
myString.toUpperCase();</code>

Same result, the string becomes <code>ALLIGATOR</code>.

<h3>How to capitalize the first letter of a string</h3>
Okay, so that first one was easy and things are about to get significantly more complex really quickly.

Because there isn't a built in method on the <code>String</code> prototype to upper case just the first letter of the string, we have to get a bit creative.

The gist of things is that we are going to need to grab the very first letter of the string, capitalize it, then grab the rest of the string, and re-assemble things.

Fortunately, we don't have to walk through each of those steps and can just use a regular expression to grab the first letter and capitalize it, returning the modified string:

<code>myString = 'the quick green alligator...';
myString.replace(/^\w/, (c) => c.toUpperCase());</code>

This will result in the string becoming <code>The quick green alligator...</code>.

This is great as long as your string doesn't have any spaces padding the front of it.

If you aren't sure if you are going to encounter said padding, like when you're dealing with the inconsistencies of user-generated content, you can include the <code>.trim()</code> method to clean things up before capitalizing:

<code>myString = '    the quick green alligator...';
myString.trim().replace(/^\w/, (c) => c.toUpperCase());</code>

<h3>How to capitalize the first letter of each word in a string</h3>
Similar to capitalizing the first letter of a string, there's nothing baked into JavaScript to capitalize the first letter of each word in a string, also called title casing.

We also need to take a similar approach, the string needs to be broken into words, each word needs to be capitalized and then reassembled with spaces in between them.

We could approach this by using <code>.split()</code> and <code>.join()</code> with our capitalization regular expression from earlier sandwiched in between.

Or, we could approach it by simply adding another regular expression to the mix:

<code>myString = 'the quick green alligator...';
myString.replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));</code>

Will give us <code>The Quick Green Alligator...</code>.

Because we're isolating the words themselves, this method is a bit more fault tolerant when it comes to proceeding spacing. 
You may still want to <code>trim()</code> the string though, if you don't want said padding in the resulting string.

If you're working with a string that has words that are MiXeD CaSe, you may also want to include a call to <code>.toLowerCase()</code> to make things consistent.

<code>myString = '  tHE QuICk GrEEn alliGATOR... 
';
myString.trim().toLowerCase().replace(/\w\S*/g, (w) => (w.replace(/^\w/, (c) => c.toUpperCase())));</code>

Still gets us <code>The Quick Green Alligator...</code>.

Granted, this will also lower case any acronyms in the string, so your mileage may vary!

<h3>Conclusion</h3>
Even without additional utility methods, JavaScript's existing toolbox of functionality can make short work of capitalization tasks when working with strings. 
This is primarily thanks to the power of regular expressions because without them, these code examples would have been even longer.


<h2>A Primer On the JavaScript Apply and Call Methods</h2>

In a JavaScript world where <a href="https://alligator.io/js/arrow-functions/">arrow functions</a> are everywhere, object and <a href="https://alligator.io/js/tricks-with-destructuring/">array destructuring</a> are the norm, and functional programming seems to have won the popularity contest; writing about <code>apply</code> and <code>call</code> is hard.

In this world, we don't have any practical use for these functions. 
So you probably don't need to know about it today (except if a job interviewer tries to test your curiosity). 
But who knows? We might need those methods if another programming paradigm replaces functional programing. 
We'll explore that at the end of this post.

<h3>What Are the apply and call Methods</h3>
<code>apply</code> and <code>call</code> are methods used to call functions. 
Done… Next section please. 
They really are that simple! <code>apply</code> and <code>call</code> execute the function they are attached to. 
You can pass two arguments to them:

<ol><li>The <code>this</code> of the function you want to execute.</li><li>A list of arguments.</li>
</ol>
The only difference between <code>call</code> and <code>apply</code> is that <code>call</code> takes a list of arguments and <code>apply</code> takes an array.

<hr>
<h3>Cute Tricks</h3>
Here are a few cute tricks that will help you understand <code>call</code> and <code>apply</code>.

Module: arrayToArguments.js

<code>Math.max(1,322, 89,23, 6)
// this function returns the highest number in the list: 322

// If you have an array
const myNums = [1,322, 89,23, 6]
Math.max.apply(null, myNums)

// My nums is converted to the same list of arguments used above</code>

Module: coolConcat.js

<code>// To merge two arrays before ES6 you had to do something like
let firstStarWars = ["Star Wars", "The Empire Strikes Back", "Return of the Jedi"]
let prequals =  ["The Phantom Menace", "Attack of the Clones", "Revenge of the Sith"]
let allStarWars = firstStarWars.concat(prequals)

// But you can use push with apply, imagine we create the allStarWars
let allStarWars = ["Star Wars", "The Empire Strikes Back", "Return of the Jedi"]

// allStarWars in release chronology
[].push.apply(allStarWars, prequals)
// allStarWars === ["Star Wars", "The Empire Strikes Back", "Return of the Jedi", "The Phantom Menace", "Attack of the Clones", "Revenge of the Sith"]

// allStarWars in story line chronology
[].unshift.apply(allStarWars, prequals)
// allStarWars === ["The Phantom Menace", "Attack of the Clones", "Revenge of the Sith", "Star Wars", "The Empire Strikes Back", "Return of the Jedi"]

// Note that we can replace [] by any array and it will have the exact same effect
// Try changing [] for allStarWars, Array.prototype or any array!</code>

<h3>The Cute Tricks Killer</h3>
With ES6/ES2015 and the spread operator, you can destructure objects and arrays and achieve the same results as above:

Module: dieCuteTricks.js

<code>Math.max(...allNums)
// returns 322

allStarWars.push(...prequals)
// allStarWars === ["Star Wars", "The Empire Strikes Back", "Return of the Jedi", "The Phantom Menace", "Attack of the Clones", "Revenge of the Sith"]</code>

If you are using ES6+, I really don't see any reason anymore to ever use <code>apply</code>. 
You can just use <code>.call(context, ...arguments)</code> and you will achieve the same results. 
Now that <code>apply</code> is out of the picture we can focus on <code>call</code>.

<h3>call Under the Hood</h3>
If you look at the ECMAScript specification you can see that <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.call"><code>call</code> is extremely simple</a>. 
When <code>call</code> is called it makes a few type checks and conversions then executes the target function with the context as well as the arguments.

Module: getPlanets.js

<code>function starWarsResource(resourceType) {
 this.information = {}
 this.resourceType =  resourceType
 this.name
}

function Planet(name) {
 this.name = name
 starWarsResource.call(this, 'planet')
}

const tatooine = new Planet('Tatooine')
// tatooine = {name: "Tatooine", information: {}, resourceType: "planet"}

// Careful look what happens if we pass a different context
function WonkyPlanet(name) {
 starWarsResource.call(null, 'planet')
}

const wonkyPlanet = new WonkyPlanet('earth')
// wonkyPlanet = {}
// But now there is are three global variables called `name`, `information` and `resourceType`

console.log(name)
// This will log 'earth' even if we never wrote `var name = 'earth'`</code>

This is bad to say the least. 
We find a similar effect if we use arrow functions. 
First of all they cannot be constructors, so we cannot describe <code>Planet</code> with an arrow function. 
Arrow function borrow the <code>this</code> from their enclosing lexical context (which usually means from the environment where they are defined).

Module: getPlanets.js

<code>const starWarsResource = (resourceType) => {
 this.information = {}
 this.resourceType = resourceType
}

function WonkyPlanet (name)  {
 // This doesn't work as expected anymore!
 this.name = name
 starWarsResource.call(this, 'planet')
}

const tatooine = new WonkyPlanet('Tatooine')
// tatooine = {}

console.log(name)
// logs "Tatooine"</code>

<code>starWarsResource</code> decided of its own <a href="https://alligator.io/js/variable-scope/">scope</a> and it is the global scope.

<h3>Should I Use call?</h3>
If you are wondering if you should use it, you probably shouldn't. 
There are a lot of modern patterns that allow similar effects to <code>call</code>.

Module: classyPlanets.js

<code>class StarWarsResource {
 constructor(resourceType) {
   this.information = {}
   this.name
   this.resourceType = resourceType
 }
}

class Planet extends StarWarsResource  {
 constructor(name){
   super('planet')
   this.name = name
 }
}

const tatooine = new Planet('Tatooine')
// tatooine = {name: "Tatooine", information: {}, resourceType: "planet"}</code>

This is much cleaner isn't it? Under the hood, the babel transpiler used to use <code>call</code> to build classes, so it's not completely useless. 
You can checkout <a href="https://babeljs.io/en/repl#?babili=false&amp;browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=ATDGBsEMGduBlALpATgdVdASgU2gewFcVQdgBvAKBBFHwDtpEVDRF8UAKFPIknACoBPAA44AlBWo0QiABYBLaADoF9AGYcAtpEQKGwALwUAvtJnyly-pC05zNSyp4FipYWKPAXfd6PsyZiBBYFCwwAAKUPQ4iMA4AB6IOPQAJnBIqBgo2LxuZFIydIzMrOxcNnbiVDIg0IRiXADkItGxTeIOsooqlWTGfQ4hIcVMwMjs-Gr9wDEA7pFtiJxNArr4UzEdQA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Ces2015-loose&amp;prettier=false&amp;targets=&amp;version=7.7.4&amp;externalPlugins=">this link to see how it works</a>.

<h3>call and Functional Programming</h3>
I think the rise of <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> is the main reason why <code>call</code> is not relevant anymore. 
I personally prefer a purely functional style of coding in JavaScript so it doesn't bother me. 
In functional programming we try to avoid any type of object in our code. 
We have functions calling functions calling functions. 
In that perspective, functions have to be pure, states should be independent and objects immutable. 
In other words, functions shouldn't care about context, they should only care about arguments.

That being said, I think it's important not to completely disregard other design patterns. 
Even if I mostly use a functional style, I use different patterns every now and then.

<h3>Experimenting with Functional Calls</h3>
Now I wanted to see how I could incorporate <code>call</code> in a functional perspective. 
And here's what I came up with:

Module: fullStars.js

<code>// This is simply a helper which fetches data from api and returns the body
async function getAndDeserialize(url) {
 const res = await fetch(url)
 const body = await res.json()
 return body
}

// getStarWars info queries the SWAPI star wars API to get details about a Star Wars entity
// The query involves a resourceType (like I want a planet, a person or a starship...)
async function getStarWarsInfo(searchQuery) {
 console.log(this, searchQuery)

 // We extract the variable type
 const resourceType = this.resourceType
 if (!this.resourceType)
   throw new Error('resourceType is not defined!')

 // In the Star Wars API available types include: people, planets, films, starships...
 const stringQuery = `${this.resourceType}/?searchget=${searchQuery}`
 const info = await getAndDeserialize('https://swapi.co/api/' + stringQuery)

 // we set the `information` key to the result of the api call
 this.information = info.results[0]
}

async function setFilmsTitles() {
 // We declare a new key on the context called filmTitles
 this.filmTitles = []
 console.log(this.information)

 // We get the films' urls from the current context
 const filmsUrls = this.information.films

 for(let i = 0; i &lt; filmsUrls.length; i++){
   // Getting film details from the SWAPI API
   const filmObject = await getAndDeserialize(filmsUrls[i])
   // We push the film titles after we get the details from the SWAPI API
   this.filmTitles.push(filmObject.title)
 }
}

async function getFullPerson() {
 this.resourceType = 'people'
 await getStarWarsInfo.call(this, this.name)
 await setFilmsTitles.call(this)
}

async function getFullPlanet() {
 this.resourceType = 'planets'
 await getStarWarsInfo.call(this, this.name)
 await setFilmsTitles.call(this)
}

const luke = {
 name: 'luke'
}

const tattoine = {
 name: 'Tatooine'
}

getFullPerson.call(luke)
getFullPlanet.call(tattoine)

// luke is now: {
//  filmTitles: ["The Empire Strikes Back", "Revenge of the Sith" ...]
//  information:{}eye_color: "blue"
//      films: (5) ["https://swapi.co/api/films/2/", "https://swapi.co/api/films/6/" ...]
//      gender: "male"
//      hair_color: "blond"
//      height: "172"
//      homeworld: "https://swapi.co/api/planets/1/"
//      mass: "77"
//    }
//    name: "luke"
//    resourceType: "people"
//  }

// tattoine is now {
//    filmTitles: (2) ["Revenge of the Sith", "A New Hope"]
//    information: {name: "Alderaan", rotation_period: "24", orbital_period: "364"...}
//    name: "Tatooine"
//    resourceType: "planets"}</code>

This code looks functional because we have functions calling functions. 
But it isn't. 
It's important to remember that in JavaScript a function is an object, a very special object. 
In <code>fullStars.js</code>, we use functions like objects which each have a state so I don't think it's functional.

<code>call</code> requires us to think statefully so it can't be used in a purely functional approach. 
That being said, JavaScript by nature is made of objects as is made clear by the very existence of <code>this</code> in every function. 
Even if your code does not strictly respect functional rules you can still consider it functional. 
In law, we call this opposition the <code>letter and the spirit of the law</code>.

May the force be with you.


<h2>Exploring the JavaScript forEach Method for Looping Over Arrays</h2>

Array.prototype.forEach is a nice little function introduced in ECMAScript 2015. 
It allows us to access each element of an array in order.

<h3>The basics</h3>
Most of us know the alphabet so here's an easy example:

Module: letters.js

<code>const letters = ['a', 'b', 'c'];

letters.forEach((letter, index, arr) => {
 console.log(letter,index, arr);
});

// The console will output
// 'a', 0, ['a', 'b', 'c']
// 'b', 1, ['a', 'b', 'c']
// 'c', 2, ['a', 'b', 'c']</code>

<h3>Under the hood</h3>
Here is a rough JavaScript implementation of the callback flow as described in the <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach">ECMAScript documentation</a>.

Module: myForEach.js

<code>const myForEach = (array, callback) => {
 // Before iterating through the array forEach checks the value of array and sets a len variable
 let k = 0;
 // If the argument passed doesn't have a property len then forEach returns
 if(!array.length)
   return;
 //  checking if callback is callable
 if (typeof callback != 'function')
   return;
 // The user can set a custom this context
 let len = array.length;
 
 // iterating until k reaches the length of the array - 1
 while(k&lt;len){
   // if the array doesn't have a k element at index k then we return
   if(!array[k]){
     return;
   }
   let element = array[k];

   // notice the three elements used in the callback
   callback(element, k, array);

   // Increase k to reach the next item in the array
   k += 1;
 }
 // forEach never returns anything (return undefined is the same as return)
 return undefined;
};</code>

<h3>Modifying the Original Array</h3>
As you can see from <code>myForEach</code> implementation, we get the value of <code>element</code> by assignment:

Module: myForEach.js

<code>let element = array[k];</code>

So what happens if we modify <code>element</code>?

<code>const ruinYourElements = (element, index) => {
 element = '乁(  )「 ';
}

const verySeriousArray = ['business', 'files', 'documents']

verySeriousArray.forEach(ruinYourElements)
// verySeriousArray =  ['business', 'files', 'documents']`
// You failed to ruin my array</code>

In this snippet, <code>element</code> goes from referencing <code>array[k]</code> to referencing <code>'乁(  )「 '</code>. 
<code>array[k]</code> never knows about that reassignment.

BUT! things are different with objects!

<code>const ruiningYourNames = (element, index) => {
 element.name = '乁(  )「 ';
}

const verySeriousArray = [{name:'business'}, {name:'files'}, {name:'documents'}];

verySeriousArray.forEach(ruiningYourNames);
// verySeriousArray =  [{name: '乁(  )「 '}, {name: '乁(  )「 '}, {name: '乁(  )「 '}]
// You succeeded at ruining my array</code>

The changes occur because <code>element</code> still references <code>array[k]</code>. 
If we wanted to prevent such a behavior we would have to <a href="https://alligator.io/js/deep-cloning-JavaScript-objects/">deep clone</a> <code>array[k]</code> in <code>myForEach</code>:

Module: myForEach.js

<code>if(typeof array[k] === 'object'){
 let element = JSON.parse(JSON.stringify(array[k]));
}</code>

If you want to change the value of an element in the original array you have to modify the third argument of the <code>forEach</code> callback: <code>arr</code>:

<code>const ruinYourArray = (element, index, arr) => {
 arr[index] = '乁(  )「 ';
}

const verySeriousArray = ['business', 'files', 'documents']

verySeriousArray.forEach(ruinYourArray)
// verySeriousArray = ['乁(  )「 ', '乁(  )「 ', '乁(  )「 ']
// We successfully ruined the serious array, nobody will be able to do serious business anymore</code>

<h3>How the Loop Works</h3>
<code>forEach</code> will iterate for as long as the initial array's length. 
If the array is 5 items long, it will iterate 5 times, no more.

Module: stickToYourDietPlan.js

<code>const reasonableShoppingList = ['', ''];
reasonableShoppingList.forEach((item)=> {
 // Here is the 10 year old in me trying to highjack my health
 reasonableShoppingList.push('');
 console.log(`bought ${item}`);
})
// console will output:
// bought  bought  
// because forEach called the callback reasonableShoppingList.length = 2 times
// at the end reasonableShoppingList = ['', '', '', ''] so make sure to clean your array before you go shopping again!</code>

The iterations can be interrupted early in two main situations:

1. 
We reached a point of the array which doesn't exist anymore.

Module: letters.js

<code>const pop =  (letter, index, arr) =>{
 console.log(letter, i);
 arr.pop();
}

letters.forEach(pop);
// 'a'
// 'b'
// letters = 'a'</code>

Be careful when you modify arrays! Sometimes you will have some counterintuitive results:

Module: letters.js

<code>letters.forEach((letter, index, arr)=>{
 console.log(letter, index);
 if (letter === 'a')
   arr.shift();
});
// 'a' 0
// 'c' 1
// letters = ['b','c']</code>

Checkout <code>myForEach</code>, think about it, and it should make sense.

2. 
If the callback function crashed

<code>const showCity = (user) => {
 console.log(user.address.city);
}

const users = [
 {
   name:'Sarah',
   address:{
     zipCode: 60633,
     city: 'Chicago'
   }
 },
 {
   name:'Jack'
 },
 {
   name:'Raphael',
   address: {
     city: 'ParadiseCity'
   }
 }
];

users.forEach(showCity);
// Console will output: 'Chicago'.Then we'll get:
// Uncaught TypeError: Cannot read property 'city' of undefined</code>

<h3>Using <code>forEach</code> in Legacy Browsers</h3>
There are still users using legacy browsers which do not support <code>forEach</code>. 
For them, your safest bet is to <a href="https://alligator.io/js/foreach-vs-for-loops/">use for loops</a>. 
But if you want to be able to use all ECMA2015 functionalities, you should use a polyfill or <a href="https://github.com/es-shims/es5-shim/blob/592c8f49d4d6ec0fb2f588bebdd52f6b439903e2/es5-sham.js#L442">es5 shims</a>.

<h3>forEach() vs map()</h3>
As you can see in <code>myForEach</code>, forEach always returns <code>undefined</code> and <a href="https://alligator.io/js/map-array-method/"><code>map</code> returns a new array</a>.

<h3>Asynchronous forEach</h3>
If you enjoy coding with <a href="https://alligator.io/js/async-functions/"><code>async</code> and <code>await</code></a> you might not get the behaviors you expect.

Module: cheeseShopping.js

<code>  // We are going to the cheese shop and ask the vendor what cheese we need for our dish
const cheeseShopping = async (dishes) => {
 const whatCheeseShouldIUse = async (dish) => {
   // We use setTimeout to simulate an API call
   await new Promise(resolve => setTimeout(resolve, 200));

   switch (dish) {
     case 'Pasta':
       return  'Parmesan'
     case 'Gratin':
       return  'Gruyère'
     case 'Cheeseburger':
       return  'American Cheese'
     default:
       return  'Tomme'
   };
 };

 const requiredCheeses = [];

 dishes.forEach( async (dish) => {
   const recommendation = await whatCheeseShouldIUse(dish)
   //  We never reach this code because foreach doesn't wait for await and goes to the next loop
   requiredCheeses.push(recommendation)
 })
 // requiredCheeses = [] 
 
 // this await is useless
 await dishes.forEach( dish => {
   const recommendation =  whatCheeseShouldIUse(dish);
   // Is a promise so we push a promise and not the result of the promise
   requiredCheeses.push(recommendation);
 });
 //requiredCheeses = [Promise, Promise, Promise]
 };
}

const dishes = ['Pasta', 'Cheeseburger', 'Original Cheese Platter'];
cheeseShopping(dishes);</code>

We need to create a custom <code>asyncForEach</code> which waits for each promise to resolve before it moves on. 
Here's an example:

Module: blockingAsyncForEach.js

<code>Array.prototype.asyncForEach = async function (callback) {
 let k = 0;
 while (k &lt; this.length) {
   if(!this[k])
     return;
   let element = this[k];
   // This will pause the execution of the code
   await callback(element, k, this);
   k += 1;
 };
};</code>

<a href="https://alligator.io/js/arrow-functions/">Arrow Functions</a> explains why we need to use <code>function</code> instead of arrow functions.

<code>const cheeseShopping = async (dishes) => {
 // ... 
Skipping some code
 await dishes.asyncforEach( async dish => {
   const recommendation =  await whatCheeseShouldIUse(dish);
   requiredCheeses.push(recommendation);
 })
 //requiredCheeses = ['Parmesan', 'American Cheese', 'Tomme']
 
 return requiredCheeses;
};</code>

Sometimes (often?) you might want to run all <code>async</code> functions at the same time and <code>await</code>s for all of them to resolve. 
<a href="https://alligator.io/js/promise-all-promise-race/">Promise.all()</a> could be very useful in that situation.

<h3>Performance</h3>
forEach loops are slower than a classic <code>for</code> loop but we are talking microseconds over an array of a million elements so don't worry about it. 
Interestingly, the relative performance of <code>map</code> and <code>forEach</code> depends on the version of the browser you're using, Chrome 61.0.3135 (2) has a faster <code>map</code> Chrome 61.0.3136 (1) has a faster <code>forEach</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/66330ef4c946977936d104b44797ed8f9f96ad17/335c2/images/js/foreach-array-method/loop_map_each_different_browers.png">

<h3>The DOM Trap</h3>
Be careful! Not everything that looks like an array is an array:

<code>const divs = document.getElementsByTagName('div');
divs.forEach(doSomething);
// Uncaught TypeError: divs.forEach is not a function</code>

That's because <code>divs</code> is not an array! It is a special object called a DOMCollection which is an iterable object. 
So you can only do:

<code>for (let i = 0; i &lt; divs.length; i++){
 doSomething(divs[i], i);
}</code>

Or mess with HTMLCollection's prototype and add a forEach to force it to behave like the native <code>forEach</code>:

<code>HTMLCollection.prototype.forEach = Array.prototype.forEach;</code>

Or just make the array-like object into a real array first using something like the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">spread operator</a>:

<code>const divs = document.getElementsByTagName('div');
const divsArr = [...divs];
// ...</code>


<h2>Building a Countdown Timer in JavaScript</h2>

Countdown timers can serve many purposes. 
They can communicate to a user how long they've been doing something or how much time until some event happens, like the launch of your new website.

In the sales and marketing context they can be used to create a sense of urgency to encourage the conversion. 
FOMO can be hard to beat, but building a countdown timer in pure JavaScript is easy!

<h3>Getting Started</h3>
Since we're leveraging the power of JavaScript in it's purest form, without any front-end libraries, there's not a ton of bootstrapping that has to be done.

All we need is a <code>.html</code> file with a <code>&lt;div></code> to inject the countdown timer's output into and a <code>&lt;script></code> block that will house our code:

<code>&lt;!DOCTYPE html>
&lt;html>
 &lt;body>
   &lt;div id="countdown">&lt;/div>
   &lt;script>
     // This is where our sweet timer code will go!
   &lt;/script>
 &lt;/body>
&lt;/html></code>

<h3>Calculating the Time Remaining</h3>
To calculate the time remaining, we need to find the difference between the current time and the time that our countdown timer will expire. 
One of the more notable times that we countdown to is New Year's Day, so we'll use the upcoming new year as our end time:

<code>const difference = +new Date("2020-01-01") - +new Date();</code>

The <code>+</code> before the <code>new Date</code> is shorthand to tell JavaScript to cast the object as an integer, which gives us the object's Unix time stamp represented as microseconds since the epoch.

<h3>Formatting to Days, Hours, Minutes and Seconds</h3>
Now that we know the total number of milliseconds until the countdown time expires, we need to convert the number of milliseconds to something a bit more friendly and human readable.

We're going to calculate the total number of hours, minutes and of course, seconds, by doing some math and using the modulus <code>%</code> operator:

<code>const parts = {
 days: Math.floor(difference / (1000 * 60 * 60 * 24)),
 hours: Math.floor((difference / (1000 * 60 * 60)) % 24),
 minutes: Math.floor((difference / 1000 / 60) % 60),
 seconds: Math.floor((difference / 1000) % 60),
};</code>

By rounding the numbers down, we're able to drop the remainder to get the whole number value.

With an object full of the days, hours, minutes and seconds remaining, we can put things together into a string:

<code>const remaining = Object.keys(parts)
 .map((part) => {
   if (!parts[part]) return;
   return `${parts[part]} ${part}`;
 })
 .join(" ");</code>

<h3>Show the Time Remaining on the Page</h3>
With the time parts assembled into a string, we can update our <code>&lt;div></code> to contain the value:

<code>document.getElementById("countdown").innerHTML = remaining;</code>

<h3>Automatically Updating the Timer</h3>
Thus far, we've calculated the time difference between the current time and the time that our countdown expires. 
We've broken that time into hours, minutes and seconds, and then updated the page with the time remaining.

Then time stood still.

Without additional logic to update the page periodically, the timer is stuck in place until the next time the page is loaded. 
Without an update, it's hard to even describe it as a timer.

No big deal, we can easily create an interval to run every second (or 1000ms) and update the timer's display:

<code>setInterval(() => {
 // This is where we'd recalculate the time remaining
}, 1000);</code>

<h3>Putting it All Together</h3>
Obviously that last example was a bit lacking. 
That's because it's time to put it all together into something usable, and even add in some additional niceties like updating the timer on page load (instead of waiting for the first run of the interval) and handling things when the timer has expired:

<code>&lt;!DOCTYPE html>
&lt;html>
 &lt;body>
   &lt;div id="countdown">&lt;/div>
   &lt;script>
     function countdownTimer() {
       const difference = +new Date("2020-01-01") - +new Date();
       let remaining = "Time's up!";

       if (difference > 0) {
         const parts = {
           days: Math.floor(difference / (1000 * 60 * 60 * 24)),
           hours: Math.floor((difference / (1000 * 60 * 60)) % 24),
           minutes: Math.floor((difference / 1000 / 60) % 60),
           seconds: Math.floor((difference / 1000) % 60)
         };

         remaining = Object.keys(parts)
           .map(part => {
             if (!parts[part]) return;
             return `${parts[part]} ${part}`;
           })
           .join(" ");
       }

       document.getElementById("countdown").innerHTML = remaining;
     }

     countdownTimer();
     setInterval(countdownTimer, 1000);
   &lt;/script>
 &lt;/body>
&lt;/html></code>

You can check a working example of this code over on <a href="https://codesandbox.io/s/epic-brown-sdqiu">CodeSandbox</a>.

<h2>Using toLocaleString with Numbers, Arrays or Dates in JavaScript</h2>

<code>toLocaleString</code> is a built-in JavaScript method used to convert the date and time to a string using the system locales. 


It can be used with the following JavaScript types :
<li>Dates/Time</li><li>Numbers</li><li>Objects</li><li>Arrays</li>

<h3>toLocaleString with Dates and Time </h3>
With dates/time objects, <code>toLocaleString</code> has a syntax like this and returns a string :

<code>dateObject.toLocaleString(locales, options)</code>
<li>
<code>locales</code>: An optional string that specifies a language-specific format. 
Some valid values are <em>ar-SA</em> (for Arabic), <em>en-US</em> (for US English), <em>hi-IN</em> (for Hindi), <em>jp-JP</em> (for Japanese), etc.</li><li>
<code>options</code>: An optional object of options. 
Some valid properties that can be included in this are <code>dateStyle</code> with values of <code>full</code>, <code>long</code>, <code>medium</code> and <code>short</code>. 
Other possible properties are <code>timeStyle</code>, <code>weekday</code>, <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code>, etc.</li>

<h3>Example </h3>
<code>const date = new Date();

console.log(date.toLocaleString(`en-US`)); 
// 11/10/2019, 4:32:44 PM

console.log(date.toLocaleString(`hi-IN`));
// 10/11/2019, 4:32:44 pm

console.log(date.toLocaleString(`fr-CH`));
// 10.11.2019 à 16:32:44

const options = {
 weekday: 'long',
 era: 'long'
}

console.log(date.toLocaleString(`en-US`, options)); 
// Sunday Anno Domini

console.log(date.toLocaleString(`hi-IN`, options));
//   

console.log(date.toLocaleString(`fr-CH`, options));
// après Jésus-Christ dimanche</code>

<hr>
<h3>toLocaleString with Numbers </h3>
With numbers, <code>toLocaleString</code> is used to convert the numbers into a locale-specific number representation. 
It has syntax something like the following and returns a <em>string</em> :

<code>number.toLocaleString(locales, options)</code>
<li>
<code>locales</code>: An optional string the specifies the locale.</li><li>
<code>options</code>: An optional object that can contain properties such as <code>localeMatcher</code> with values <code>lookup</code> and <code>best fit</code>. 
Other valied properties are <code>style</code>, <code>currency</code>, <code>useGrouping</code>, <code>minimumSignificantDigits</code>, etc.</li>

<h3>Example </h3>
<code>const number = 12345.678;

console.log(number.toLocaleString('en-US')); 
// 12,345.678

console.log(number.toLocaleString('fr-FR')); 
// 12 345,678

console.log(number.toLocaleString('en-US', {
 style: 'currency',
 currency: 'USD'   // With currency, the currency code is also required
}));  // $12,345.68

console.log(number.toLocaleString('hi-IN', {
 style: 'currency',
 currency: 'INR'
}));  // 12,345.68

console.log(number.toLocaleString('en-US', {
 style: 'currency',
 currency: 'USD',
 maximumSignificantDigits: 2
}));  // $12,000</code>

<hr>
<h3>toLocaleString with Arrays </h3>
With arrays, <code>toLocaleString</code> is used to convert them into a locale-specific representation. 
The syntax is as follows and once again a <em>string</em> is returned :

<code>array.toLocaleString(locales, options)</code>
<li>
<code>locales</code>: An optional string specifying the locale.</li><li>
<code>options</code>: An optional object of the same options available to numbers and dates.</li>

<h3>Example </h3>
<code>const arr = [12345678, new Date(), "alligators"];
console.log(arr.toLocaleString(`fr-FR`,{
 style: 'currency',
 currency: 'EUR',
 era: 'long'
}));

//  12345678,00 €,10 11 2019 après Jésus-Christ à 18:30:03,alligators

const arr2 = [12345678, new Date(), "alligators"];
console.log(arr.toLocaleString(`en-US`,{
 style: 'currency',
 currency: 'USD',
 era: 'long'
}));

//  $12,345,678.00,11 10, 2019 Anno Domini, 6:31:56 PM,alligators</code>

<em>Note:</em> If locale is omitted or left undefined than the default system locale is used. 


<hr>
 Now what's left is to make sure your targeted browsers <a href="https://caniuse.com/#search=toLocaleString">support the toLocaleString method</a>.

<h2>Finally Understand the JavaScript Reduce Method</h2>

<a href="https://alligator.io/js/reduce-array-method/">Reduce</a> is a method that can be difficult to understand especially with all the vague explanations that can be found on the web. 
There are a lot of benefits to understanding <code>reduce</code> as it is often used in state management (think <a href="/redux/redux-intro/">Redux</a>).

The signature for the <code>reduce</code> array method in JavaScript is:

<code>arr.reduce(callback, initialValue);</code>

<h3>Terminology</h3>
Reduce comes with some terminology such as <strong>reducer &amp; accumulator</strong>. 
The <code>accumulator</code> is the value that we end with and the <code>reducer</code> is what action we will perform in order to get to <strong>one value</strong>.

You must remember that a <strong>reducer</strong> will only return one value and one value only hence the name <strong>reduce</strong>.

Take the following classic example:

<code>const value = 0; 

const numbers = [5, 10, 15];

for(let i = 0; i &lt; numbers.length; i++) {
 value += numbers[i];
}</code>

The above will give us <code>30</code> (5 + 10 + 15). 
This works just fine, but we can do this with <code>reduce</code> instead which will save us from mutating our <code>value</code> variable.

The below code will also output <code>30</code>, but will not mutate our <code>value</code> variable (which we have now called <code>initialValue</code>)

<code>/* this is our initial value i.e. 
the starting point*/
const initialValue = 0;

/* numbers array */
const numbers = [5, 10, 15];

/* reducer method that takes in the accumulator and next item */
const reducer = (accumulator, item) => {
 return accumulator + item;
};

/* we give the reduce method our reducer function
 and our initial value */
const total = numbers.reduce(reducer, initialValue)</code>

The above code may look a little confusing, but under the hood there is no magic going on. 
Let's add a <code>console.log</code> in our <code>reducer</code> method that will output the <code>accumulator</code> and the <code>item</code> arguments.

The following screenshot shows what's logged to the console:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/963456ec22e461068ec6a180223722935e8ac85a/9d44e/images/js/finally-understand-reduce/reduce_output.png">

So the first thing we notice is our method is called <code>3</code> times because there are <code>3</code> values in our array. 
Our accumulator begins at <code>0</code> which is our <code>initialValue</code> we passed to <code>reduce</code>. 
On each call to the function the <code>item</code> is added to the <code>accumulator</code>. 
The final call to the method has the <code>accumulator</code> value of <code>15</code> and <code>item</code> is <code>15</code>, <code>15 + 15</code> gives us <code>30</code> which is our final value. 
Remember the <code>reducer</code> method returns the <code>accumulator</code> plus the <code>item</code>.

So that is a simple example of how you would use <code>reduce</code>, now let's dive into more a complicated example.

<h3>Flattening an Array Using Reduce</h3>
Let's say we have the following array:

<code>const numArray = [1, 2, [3, 10, [11, 12]], [1, 2, [3, 4]], 5, 6];</code>

And let's say for some crazy reason, JavaScript has removed the <code>.flat</code> method so we have to flatten this array ourselves.

So we'll write a function to flatten any array no matter how deeply nested the arrays are:

<code>function flattenArray(data) {
 // our initial value this time is a blank array
 const initialValue = [];

 // call reduce on our data
 return data.reduce((total, value) => {
   // if the value is an array then recursively call reduce
   // if the value is not an array then just concat our value
   return total.concat(Array.isArray(value) ? flattenArray(value) : value);
 }, initialValue);
}</code>

If we pass our <code>numArray</code> to this method and log the result we get the following:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/781f5e1855291685d942a01911f7edd64c64ed7c/3064b/images/js/finally-understand-reduce/flatten_array_output.png">

This is a great example on how we can make a very common operation quite simple.

Let's go over one more example.

<h3>Final Example - Changing an Object Structure</h3>
So with the new Pokemon game coming out, let's pretend we have a server that sends us an array of Pokemon objects like so:

<code>const pokemon = [
 { name: "charmander", type: "fire" },
 { name: "squirtle", type: "water" },
 { name: "bulbasaur", type: "grass" }
]</code>

We want to change this object to look like:

<code>const pokemonModified = {
 charmander: { type: "fire" },
 squirtle: { type: "water" },
 bulbasaur: { type: "grass" }
};</code>

To get to that desired output we do the following:

<code>const getMapFromArray = data =>
 data.reduce((acc, item) => {
   // add object key to our object i.e. 
charmander: { type: 'water' }
   acc[item.name] = { type: item.type };
   return acc;
 }, {});</code>

If we call our method like so:

<code>getMapFromArray(pokemon)</code>

We get our desired output:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5fc58bd9423308e1bb46a19d1c47e2570dfb4cf3/54e24/images/js/finally-understand-reduce/pokemon_output.png">

You can check out the <a href="https://codesandbox.io/s/dazzling-bhabha-b9bsj">Codesandbox here</a>.

<h3>Conclusion</h3>
So that is it! Hope you've now learned how the reduce method works.

<h2>Creating a Custom webpack Plugin</h2>

If you've ever worked with webpack, you've probably heard of webpack plugins. 
Plugins are a great option for extending webpack's implementation and architecture. 
If you look at webpack's source code, around 80% of their code is implemented using plugins. 
It helps in separating the core part of webpack, which leads to better code maintenance.

webpack also supports the concepts of <code>loaders</code> which help in extending webpack too and work along with <code>resolvers</code>. 
They are mainly used to transform the source code. 
It's a different topic to cover and I'll probably write an article about how to create a custom loader pretty soon too.

Before going into details about creating custom webpack plugins, we need to know some basic workings of a module bundler and how webpack works under the hood. 
The goal of a basic module bundler is to read the source code, find the dependencies - this is called <strong>dependency resolution</strong>.

During the dependency resolution, the bundler does module mapping (<strong>module map</strong>), bundling them into one file, packaging it into one module. 
webpack does these parts in an advanced way and adds some other steps too in order to make it efficient. 
We can break the architecture of webpack using the following steps:
<li>
<em>Compiler</em>: it has the top-level API and provides hooks for them for controlling the execution of webpack.</li><li>
<em>Compilation or dependency graph</em>: returned by the compiler and it starts creating the dependency graph.</li><li>
<em>Resolver</em>: creates an absolute path for the entry path provided and return details like results, request, path, context, etc.</li><li>
<em>Parser</em>: it creates the AST (abstract syntax tree) and then looks for interesting thing like requires and imports and then creates the dependency object.</li><li>
<em>Module Factories</em>: These objects are passed to the moduleFactory function and creates the module.</li><li>
<em>Templates</em>: it does the data binding of the module object and create the code in the bundled file.</li>

webpack provides hooks for the compiler, parser, and compilations. 
It uses a library called <a href="https://github.com/webpack/tapable">tapable</a>, which is maintained by the webpack team and helps in creating strong and powerful hooks where we can tap into methods.

<h3>What are Hooks and Tapping Into Methods?</h3>
Hooks are similar to events and tapping into them is like listeners listening for an event to fire and run the appropriate method. 
For example when we place DOM-related event listeners like this:

<code>window.addEventListener('load', (event) => {
 loadEventListerner(event)
});</code>

In this, <code>load</code> is an event or hook in which <code>loadEventListener</code> is tapping into.

<h3>How webpack Uses tapable &amp; How Plugins Coming Into the Picture?</h3>
Let's take a real-world example to explain how webpack uses tapable. 
Let's say you are ordering pizza from a pizza delivery app. 
Now there are a series of steps involved with the process it like checking the menu, customizing your order and then finally placing the order by paying for it. 
Now from here onwards and until delivering your pizza to you, the app sends you notifications about the order progress.

In this example, we can now replace the pizza delivery app with <strong>webpack</strong>, yourself with a <strong>webpack plugin</strong> and notifications with hooks created by <strong>tapable</strong>.

webpack creates hooks for the <em>compiler</em>, <em>compilations</em> and <em>parser</em> stages using tapable and then the plugin taps into them or listens for them and acts accordingly.

<em>Enough of these theories and concepts, show me the code !!</em>

For this post, we'll create a simple webpack plugin that checks the size of the bundled file created and logs errors or warnings based on a size limit. 
Those size limits can be passed in the plugin options as well and we'll keep the default size limit to 3KB. 
So whenever the output file plugin is exceeding the size limit, we'll log an error message and if it's below it, we will log a safe message and if it's equal to the size limit, we will simply warn the user.

You can find the <a href="https://github.com/alligatorio/bundlesize-webpack-plugin/tree/aligator-post">code for the plugin here</a>.

<h3>Let's Setup the Project First.</h3>
In your project directory, install webpack using npm or Yarn:

<code>$ npm init -y
$ npm install webpack webpack-cli --save-dev</code>

After this, create an <code>src</code> directory with a <code>index.js</code> file in it, where your input or entry path will point to and create a <code>webpack.config.js</code> file in your project root directory.

Now you can create a directory for your plugin and name it something like <code>bundlesize-webpack-plugin</code> and create a <code>index.js</code> inside that directory.

Your project structure should look something like this:

<code>webpack-Plugin-demo-directory
 |- webpack.config.js
 |- package.json
 |- /src
   |- index.js
 |- /bundlesize-webpack-plugin
   |- index.js</code>

Add the following build script to the <code>scripts</code> in your package.json file:

<code>"build": "webpack"</code>

And in your <code>bundlesize-webpack-plugin/index.js</code> write the following code:

<code>module.exports = class BundlesizeWebpackPlugin {
constructor(options) {
  this.options = options;
}
apply(compiler) {
  console.log("FROM BUNDLESIZE PLUGIN");
}
};</code>

<em>We will discuss this soon.</em>

Now in your <code>webpack.config.js</code>, write the following code:

<code>const { resolve } = require("path");
const bundlesizeplugin = require("./bundlesize-webpack-plugin");

module.exports = {
entry: resolve(__dirname, "src/index.js"),
output: {
  path: resolve(__dirname, "bin"),
  filename: "bundle.js"
},
plugins: [new bundlesizeplugin()]
};</code>

Now run <code>npm run build</code>.

You should see the “FROM BUNDLESIZE PLUGIN” message appear in your terminal.

<em>Great, you've just made a webpack plugin!</em>

<h3>Breaking it down</h3>
Every webpack plugin must have an <code>apply</code> method in them which is called by webpack and webpack gives the compiler instance as an argument to that method.

A plugin can be class-based or can be function-based. 
If the plugin is function-based, the function argument is again compiler as well. 
We'll go with class-based for this article as that is the recommended way.

You can check the webpack's source code and how <a href="https://github.com/webpack/webpack/blob/master/lib/webpack.js#L46-L51">it's implemented here</a>

In the class' constructor, you can see there is an <code>options</code> argument. 
This is used when your plugin accepts some options. 
We'll pass the <code>sizeLimit</code> as an option and if it's not passed the default will be <em>3KB</em>.

So we can now change the constructor method to this:

<code>constructor(options) {
  this.options = options || {
    sizeLimit: 3
  };
}</code>

You can pass the <code>sizeLimit</code> as plugin <code>options</code> as well, like this:

<code>plugins: [
  new bundlesizeplugin({
    sizeLimit: 4
  })
]</code>

In <code>webpack.config.js</code>, we are simply mentioning the entry point and telling webpack to output the bundle file in a folder named <code>bin</code> in a <code>bundle.js</code> file, and telling webpack to use our plugin from the <code>bundlesize-webpack-plugin</code> folder.

Now that we have the project ready, let's check for asset size and compare with the <code>sizeLimit</code>. 
We're going to use the <code>compiler.hooks.done</code> hook which is emitted when the compilation work is done and the bundled file is generated. 
We can get the details about the bundled file that way.

Note that there are some hooks which are asynchronous and we can use an asynchronous tapping method for them. 
You can <a href="https://webpack.js.org/contribute/writing-a-plugin/#async-event-hooks">learn about these here</a>

<code>apply(compiler) {
  compiler.hooks.done.tap("BundleSizePlugin", (stats) => {
    const {
       path,
       filename
    } = stats.compilation.options.output;
  })
}</code>

In this, we are <em>tapping</em> into the <em>done</em> hook or event of the compiler, the first argument in the method is the plugin name which is used by webpack for referencing and the second method is the callback which takes <code>stats</code> as an argument. 
You can check the content of the stats using <code>console.log(stats)</code>, it will show a large object with every possible detail about the compilation and the file available for that hook. 
We are extracting the path and the filename from the output property. 
From now on, it's pretty much just about getting details for the file using Node.js' core library <code>path</code> and <code>fs</code> modules:

<code>apply(compiler) {
  compiler.hooks.done.tap("BundleSizePlugin", stats => {
    const { path, filename } = stats.compilation.options.output;
    const bundlePath = resolve(path, filename);
    const { size } = fs.statSync(bundlePath);
    console.log(size); // size in bytes
  });
}</code>

<em>Simple right?</em>

Now we can convert the size from bytes to kb using using a function like the one from <a href="https://stackoverflow.com/a/18650828/9339537">this StackOverflow answer</a>.

Now simply compare it with the <code>sizeLimit</code> and <code>console.log</code> the appropriate message:

<code>apply(compiler) {
  compiler.hooks.done.tap("BundleSizePlugin", stats => {
    const { path, filename } = stats.compilation.options.output;
    const bundlePath = resolve(path, filename);
    const { size } = fs.statSync(bundlePath);
    const { bundleSize, fullSizeInfo } = formatBytes(size);
    const { sizeLimit } = this.options;
    if (bundleSize &lt; sizeLimit) {
      console.log(
        "Safe:Bundle-Size",
        fullSizeInfo,
        "\n SIZE LIMIT:",
        sizeLimit
      );
    } else {
      if (bundleSize === sizeLimit) {
        console.warn(
          "Warn:Bundle-Size",
          fullSizeInfo,
          "\n SIZE LIMIT:",
          sizeLimit
        );
      } else {
        console.error(
          "Unsafe:Bundle-Size",
          fullSizeInfo,
          "\n SIZE LIMIT:",
          sizeLimit
        );
      }
    }
  });
}</code>

That's it! You now have your own webpack plugin which checks for the bundle size and reports based on the size limit.

You can now publish this on the npm registry.

There are few standards that webpack finds effective to have in plugins. 
You can use <a href="https://github.com/webpack-contrib/webpack-defaults">webpack-default</a> for a good starting point.

Note that the <a href="https://github.com/anikethsaha/bundlesize-webpack-plugin/tree/master#micro-plugin-development-guide">bundlesize-webpack-plugin</a>, which I've published already, is also extending hooks of its own and they are created using tapable. 
You can find the implementation in the master branch.

<h3>Summary</h3>
<li>We went over how webpack works under the hood and how its architecture is implemented</li><li>We learned about hooks and what it means to tap into them</li><li>We saw how plugins come into the system</li><li>We made a simple plugin to check the size of the bundled file</li>



<h2>The V8 Engine and JavaScript Optimization Tips</h2>

<a href="https://v8.dev/">V8</a> is Google's engine for compiling our JavaScript. 
Firefox has it's own engine called SpiderMonkey, it's quite similar to V8 but there are differences. 
We will be discussing the V8 engine in this article.

A couple of facts about the V8 engine:
<li>Written in C++ and used in Chrome and Node.js (and the <a href="https://www.theverge.com/2018/12/6/18128648/microsoft-edge-chrome-chromium-browser-changes">newest release of Microsoft Edge</a>)</li><li>Implements ECMAScript as specified in ECMA-262</li>

<h3>The JavaScript Journey</h3>
So what exactly happens when we send our JavaScript to be parsed by the V8 engine (this is after it is minified, uglified and whatever other crazy stuff you do to your JavaScript code)?

I've created the following diagram that shows all the steps, we will then discuss each step in detail:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f4e082494f0769fe0b51bcb7da7671a71d789d36/ef3a2/images/js/v8-engine/javascript_journey.png">

In this article we'll discuss how the JavaScript code gets parsed and how to get as much of your JavaScript to the Optimizing Compiler as possible. 
The Optimizing Compiler (aka <strong>Turbofan</strong>) takes our JavaScript code and converts it to high performance Machine Code, so the more code we can give it the faster our application will be. 
As a side note, the interpreter in Chrome is called <strong>Ignition.</strong>

<h3>Parsing JavaScript</h3>
So the first treatment of our JavaScript code is to parse it. 
Let's discuss exactly what parsing is.

There are two phases to parsing which are:
<li>
<strong>Eager (full-parse)</strong> - this parses each line right away</li><li>
<strong>Lazy (pre-parse)</strong>- do the bare minimum, parse what we need and leave the rest until later</li>

Which is better? It all depends.

Let's look at some code.

<code>// eager parse declarations right away
const a = 1;
const b = 2;

// lazily parse this as we don't need it right away
function add(a, b) {
 return a + b;
}

// oh looks like we do need add so lets go back and parse it
add(a, b);</code>

So here our variable declarations will be <code>eager parsed</code> but then our function is <code>lazily parsed</code>. 
This is great until we get to <code>add(a, b)</code> as we need our <code>add</code> function right away so it would have been quicker to <code>eager parse</code> <code>add</code> right away.

To <code>eager parse</code> the <code>add</code> function right away, we can do:

<code>// eager parse declarations right away
const a = 1;
const b = 2;

// eager parse this too
var add = (function(a, b) {
 return a + b;
})();

// we can use this right away as we have eager parsed
// already
add(a, b);</code>

This is how most modules you use are created.

<h3>Function Inlining</h3>
Chrome will sometimes essentially rewrite your JavaScript, one example of this is inlining a function that is being used.

Let's take the following code as an example:

<code>const square = (x) => { return x * x }

const callFunction100Times = (func) => {
 for(let i = 0; i &lt; 100; i++) {
   // the func param will be called 100 times
   func(2)
 }
}

callFunction100Times(square)</code>

The above code will be optimized by the V8 engine as follows:

<code>const square = (x) => { return x * x }

const callFunction100Times = (func) => {
 for(let i = 100; i &lt; 100; i++) {
   // the function is inlined so we don't have 
   // to keep calling func
   return x * x
 }
}

callFunction100Times(square)</code>

As you can see from the above, V8 is essentially removing the step where we call <code>func</code> and instead inlining the body of <code>square</code>. 
This is very useful as it will improve the performance of our code.

<h3>Function inlining gotcha</h3>
There is a little gotcha with this approach, let's take the following code example:

<code>const square = (x) => { return x * x }
const cube = (x) => { return x * x * x }

const callFunction100Times = (func) => {
 for(let i = 100; i &lt; 100; i++) {
   // the function is inlined so we don't have 
   // to keep calling func
   func(2)
 }
}

callFunction100Times(square)
callFunction100Times(cube)</code>

So this time after we have called the <code>square</code> function <code>100</code> times, we will then call the <code>cube</code> function <code>100</code> times. 
Before <code>cube</code> can be called, we must first de-optimize the <code>callFunction100Times</code> as we have inlined the <code>square</code> function body. 
In cases like this, the <code>square</code> function will seem like it's faster than the <code>cube</code> function but what is happening is the de-optimization step makes the execution longer.

<h3>Objects</h3>
When it comes to objects, V8 under the hood has a type system to differentiate your objects:

<h3>Monomorphism</h3>
The objects have the same keys with no differences.

<code>// mono example
const person = { name: 'John' }
const person2 = { name: 'Paul' }</code>

<h3>Polymorphism</h3>
The objects share a similar structure with some small differences.

<code>// poly example
const person = { name: 'John' }
const person2 = { name: 'Paul', age: 27 }</code>

<h3>Megamorphism</h3>
The objects are entirely different and cannot be compared.

<code>// mega example
const person = { name: 'John' }
const building = { rooms: ['cafe', 'meeting room A', 'meeting room B'], doors: 27 }</code>

So now we know the different objects in V8, let's see how V8 optimizes our objects.

<h3>Hidden classes</h3>
Hidden classes are how V8 identifies our objects.

Let's break this down into steps.

We declare an object:

<code>const obj = { name: 'John'}</code>

V8 will then declare a <code>classId</code> for this object.

<code>const objClassId = ['name', 1]</code>

Then our object is created as follows:

<code>const obj = {...objClassId, 'John'}</code>

Then when we access the <code>name</code> property on our object like so:

<code>obj.name</code>

V8 does the following lookup:

<code>obj[getProp(obj[0], name)]</code>

This is process V8 goes through when creating our objects, now let's see how we can optimize our objects and reuse <code>classIds</code>.

<h3>Tips for Creating Objects</h3>
If you can, you should <strong>declare your properties in the constructor</strong>. 
This will ensure the object structure stays the same so V8 can then optimize your objects.

<code>class Point {
 constructor(x,y) {
   this.x = x
   this.y = y
 }
}

const p1 = new Point(11, 22) // hidden classId created
const p2 = new Point(33, 44)</code>

You should <strong>keep the property order constant</strong>, take the following example:

<code>const obj = { a: 1 } // hidden class created
obj.b = 3

const obj2 = { b: 3 } // another hidden class created
obj2.a = 1

// this would be better
const obj = { a: 1 } // hidden class created
obj.b = 3

const obj2 = { a: 1 } // hidden class is reused
obj2.b = 3</code>

<h3>General Optimization Tips</h3>
So now let's get into some general tips that will help your JavaScript code be better optimized.

<h3>Fix function argument types</h3>
When arguments are being passed to a function it's important they are the same type. 
Turbofan will give up trying to optimize your JavaScript after 4 tries if the argument types are different.

Take the following example:

<code>function add(x,y) {
 return x + y
}

add(1,2) // monomorphic
add('a', 'b') // polymorphic
add(true, false)
add({},{})
add([],[]) // megamorphic - at this stage, 4+ tries, no optimization will happen</code>

Another tip is to make sure to <strong>declare classes in the global scope</strong>:

<code>// don't do this
function createPoint(x, y) {
 class Point {
   constructor(x,y) {
     this.x = x
     this.y = y
   }
 }

 // new point object created every time
 return new Point(x,y)
}

function length(point) {
 //...
}</code>

<h3>Conclusion</h3>
So I hope you learned a few things about how V8 works under the hood and how to write better optimized JavaScript code.


<h2>Animations with the Canvas API - Part 3: Gravity and Dynamic Rendering</h2>

Over in <a href="https://alligator.io/js/canvas-animations-collisions/">Part 2</a> of this series we created a ball that would ricochet around the screen and change color when it collided with a border. 
Now we're going to use what we learned to make <a href="https://codepen.io/alligatorio/pen/YzzzJjP">this rain animation</a> that dynamically renders drops with particle effect as each drop hits the bottom of our canvas.

<h3>Boilerplate</h3>
Since we're going to be working so close to the bottom of the screen we should hide any horizontal scroll bars with <code>overflow: hidden</code>, and we'll darken it a bit so be a bit less eye burning.

index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
 &lt;head>
   &lt;meta charset="UTF-8"/>
   &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/>
   &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/>
   &lt;title>HTML Canvas&lt;/title>
   &lt;style>
     body {
       overflow: hidden;
       background-color: #1a202c;
     }
   &lt;/style>
 &lt;/head>
 &lt;body>
     
   &lt;canvas>&lt;/canvas>

 &lt;/body>
 &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js">&lt;/script>
 &lt;script src="./canvas.js">&lt;/script>
&lt;/html></code>

canvas.js

<code>// Utilities
const randomNum = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
const randomColor = colors => colors[Math.floor(Math.random() * colors.length)];

// Get canvas element
const canvas = document.querySelector('canvas');
const c = canvas.getContext('2d');

// Make canvas fullscreen
canvas.width = innerWidth;
canvas.height = innerHeight;
addEventListener('resize', () => {
 canvas.width = innerWidth;
 canvas.height = innerHeight;
});

// Control Panel
const gui = new dat.GUI();

const controls = {
 count: 0,
 velocity: 0,
};

gui.add(controls, 'dx', 0, 10);
gui.add(controls, 'dy', 0, 10);

// New Object
class Ball {
 constructor(x, y, radius, color) {
   this.x = x;
   this.y = y;
   this.radius = radius;
   this.color = color;
 }
};

Ball.prototype.draw = function () {
 c.beginPath();
 c.fillStyle = this.color;
 c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
 c.fill();
 c.closePath();
};

Ball.prototype.update = function () {
 this.x += controls.dx;
 this.y += -controls.dy;
 this.draw();
};

const ball = new Ball(innerWidth / 2, innerHeight / 2, 50, 'red');

// Handle changes
const animate = () => {
 requestAnimationFrame(animate);

 c.clearRect(0, 0, canvas.width, canvas.height);

 ball.update();
};

animate();</code>

<h3>Drop</h3>
Let's start by getting our main drops working. 
We just need to store all of the variables for each drop as an object, draw a line on the screen, and add some value to the <code>y</code> position whenever <code>update</code> is ran to make it move downward.

canvas.js

<code>class Drop {
 constructor(x, y, dy, thickness, length, color) {
   this.x = x;
   this.y = y;
   this.dy = dy;
   this.thickness = thickness;
   this.length = length;
   this.color = color;
 }
};

Drop.prototype.draw = function () {
 c.beginPath();
 c.strokeStyle = this.color;
 c.lineWidth = this.thickness;
 c.moveTo(this.x, this.y);
 c.lineTo(this.x, this.y - this.length);
 c.stroke();
 c.closePath();
}

Drop.prototype.update = function () {
 this.y += this.dy;

 this.draw();
}</code>

Let's render one onto the center of the canvas screen to see if it's working.

<code>const drop = new Drop(innerWidth / 2, innerHeight / 2, 2, 5, 30, 'red');

const animate = () => {
 requestAnimationFrame(animate);
 c.clearRect(0, 0, canvas.width, canvas.height);

 drop.update();
};

animate();</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/abf9a9f04eff91bd91dc2a4df81d66c79547c9db/3bb4f/images/js/canvas-animations-gravity/drop.png">

<h3>Ticker</h3>
That's nice, but we're going to need a lot more rendering along the top. 
To have multiple drops we could just make an array, use a <code>for</code> loop to assign random values to each item before pushing them to the array, and use <code>forEach</code> to update each of them per frame. 
But just using a <code>for</code> loop would only render the drops once, which would all move past our canvas out of site. 
So we have to be a bit creative to continually add new drops while removing all drops that move below our screen.

To do this, we're going to make a ticker that will count up by one every frame, every time it's perfectly divisible by some number we'll add a new drop to the array. 
Whatever number we divide it by will control how often new drops are rendered. 
To remove them, and save on processing power, we'll just splice them out of the array when they're past the bottom.

Using the modulo operator (<code>%</code>) we can divide a number and check if the remainder equals 0. 
So the higher it is the less often new drops will be rendered.

While we're here let's give them some color. 
I find that using different values of the same color, along with random thickness and length, helps to give the illusion of some depth. 
I recommend checking out <a href="https://color.adobe.com/explore">Kuler</a> for your color palettes.

canvas.js

<code>const colors = [ '#9C4AFF', '#8C43E6', '#7638C2', '#5E2C99', '#492378'];

let drops = [];
let ticker = 0;
const animate = () => {
 requestAnimationFrame(animate);
 // Try using the 'residue' effect from Part 2
 // c.fillStyle = 'rgba(33, 33, 33, .3)'; //Lower opacity creates a longer tail
 // c.fillRect(0, 0, canvas.width, canvas.height);
 c.clearRect(0, 0, canvas.width, canvas.height);

 drops.forEach((drop, index) => {
   drop.update();
   if (drop.y >= canvas.height) drops.splice(index, 1);
 });

 // Timing between drops
 ticker++;
 let count = controls.count === 0 ? 0 : randomNum(controls.count + 5, controls.count);
 if (ticker % count == 0) {
   const x = randomNum(0, innerWidth);
   const y = 0;
   const dy = controls.velocity === 0 ? 0 : randomNum(controls.velocity, controls.velocity + 10);
   const thickness = randomNum(3, 5);
   const length = randomNum(20, 50);

   drops.push(new Drop(x, y, dy, thickness, length, randomColor(colors)));
 };
};</code>

<h3>Droplets and Gravity</h3>
To create our splash effect as they hit the ground we're going to need some smaller particles that will have a gravity-like effect, arcing out from the main drop. 
Our <code>Droplet</code> class is going to be pretty similar to our main <code>Drop</code>, with a few differences since the droplets will be circles instead of lines.

canvas.js

<code>class Droplet {
 constructor(x, y, dx, dy, radius, color) {
   this.x = x;
   this.y = y;
   this.dx = dx;
   this.dy = dy;
   this.radius = radius;
   this.color = color;
   this.gravity = .1;
 }
};

Droplet.prototype.draw = function () {
 c.beginPath();
 c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
 c.fillStyle = this.color;
 c.fill();
 c.closePath();
};</code>

The main thing we want to worry about is our gravity. 
Gravity causes our downward movement to increase, so we'll want to add this to our <code>dy</code> on the <code>update</code> method. 
So when we generate many droplets moving up, with a negative <code>dy</code> value, and add our gravity value onto it every frame it will slow down, reverse direction, and speed up until it is removed past our canvas. 
I made a simpler example with just the droplets, you can experiment with <a href="https://codepen.io/alligatorio/pen/bGGGmjW">here</a>.

<code>Droplet.prototype.update = function () {
 this.dy += this.gravity;
 this.y += this.dy;
 this.x += this.dx;

 this.draw();
};</code>

And we'll update and remove them just like our main drops.

<code>let droplets = [];
const animate = () => {
 droplets.forEach((droplet, index) => {
   droplet.update();
   if (droplet.y >= canvas.height) droplets.splice(index, 1);
 });
};</code>

<h3>Splash</h3>
Adding our particles is actually very simple, we can just use a <code>for</code> loop to generate them with the main drops position and pass-in some random values for the rest. 
Let's also add some gravity to our drops to make them fall a bit more realistically.

canvas.js

<code>class Drop {
 constructor(x, y, dy, thickness, length, color) {
   this.x = x;
   this.y = y;
   this.dy = dy;
   this.thickness = thickness;
   this.color = color;
   this.length = length;
   this.gravity = .4;
 }
};

Drop.prototype.update = function () {
 // Stops drops if velocity controller is set to 0
 if (this.dy > 0) this.dy += this.gravity;
 this.y += this.dy;

 // It runs splash over the whole length of the drop, to we'll narrow it down to the end.
 if (this.y > canvas.height - 100) this.splash(this.x, this.y + (this.length * 2));

 this.draw();
}

Drop.prototype.splash = function (x, y) {
 for (let i = 0; i &lt; 5; i++) {
   const dx = randomNum(-3, 3);
   const dy = randomNum(-1, -5);
   const radius = randomNum(1, 3);

   droplets.push(new Droplet(x, y, dx, dy, radius, randomColor(colors)));
 };
};</code>

<h3>Conclusion</h3>
While there's still an enormous amount he learn about HTML canvas, hopefully this short series was a gentle enough introduction to its possibilities. 
Most sites are similar in a lot of ways but the ability to create custom animations offers a uniqueness that the most popular automated site builder tools never will.


<h2>Animations with the Canvas API - Part 2: Basic Collisions</h2>

In <a href="https://alligator.io/js/canvas-animations-linear-motion/">Part 1</a> of this series we went over the basics of rendering reusable objects to the canvas, using our GUI for more intuitive controls, and creating the illusion of basic movement with our animation loop. 
In this part we'll get comfortable with creating collision effects with a simple ball that changes colors as it hits the borders of our canvas.

<h3>Boilerplate</h3>
We can just use our project from <code>Part 1</code> as the starting point for most of our animations.

index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
 &lt;head>
   &lt;meta charset="UTF-8"/>
   &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/>
   &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/>
   &lt;title>HTML Canvas&lt;/title>
 &lt;/head>
 &lt;body>
     
   &lt;canvas>&lt;/canvas>

 &lt;/body>
 &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js">&lt;/script>
 &lt;script src="./canvas.js">&lt;/script>
&lt;/html></code>

canvas.js

<code>// Get canvas element
const canvas = document.querySelector('canvas');
const c = canvas.getContext('2d');

// Make canvas fullscreen
canvas.width = innerWidth;
canvas.height = innerHeight;
addEventListener('resize', () => {
 canvas.width = innerWidth;
 canvas.height = innerHeight;
});

// Control Panel
const gui = new dat.GUI();

const controls = {
 dx: 0,
 dy: 0,
};

gui.add(controls, 'dx', 0, 10);
gui.add(controls, 'dy', 0, 10);

// New Object
class Ball {
 constructor(x, y, radius, color) {
   this.x = x;
   this.y = y;
   this.radius = radius;
   this.color = color;
 }
}

Ball.prototype.draw = function () {
 c.beginPath();
 c.fillStyle = this.color;
 c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
 c.fill();
 c.closePath();
};

Ball.prototype.update = function () {
 this.x += controls.dx;
 this.y += -controls.dy;
 this.draw();
};

const ball = new Ball(innerWidth / 2, innerHeight / 2, 50, 'red');

// Render new instances
const init = () => ball.draw();

// Handle changes
const animate = () => {
 requestAnimationFrame(animate);

 c.clearRect(0, 0, canvas.width, canvas.height);

 ball.update();
};

init();
animate();</code>

<h3>Bouncer</h3>
You can preview the our end result <a href="https://codepen.io/alligatorio/pen/xxxKjyJ">here</a>.

To change our behavior on a collision, we just need to add a condition to our <code>update</code> method that will change the ball's behavior whenever it hits a border, in this case, reversing its direction. 
Keep in mind that the browser is looking at the center of our object for its position, so we always want to include the radius into the calculation.

canvas.js

<code>Ball.prototype.update = function() {
 if (this.y + this.radius > canvas.height || this.y - this.radius &lt; 0) {
   controls.dy = -controls.dy;
 }
 this.y -= controls.dy;

 if (this.x + this.radius > canvas.width || this.x - this.radius &lt; 0) {
   controls.dx = -controls.dx;
 }
 this.x += controls.dx;

 this.draw();
};
</code>

<h3>Colors</h3>
Now let's add some more interesting behavior when we hit something, like changing the ball's color. 
First we need an array of colors to choose from and a function to randomly select one for us. 
Whenever we hit a border we can re-assign our color value to a new random one.

I recommend checking out <a href="https://color.adobe.com/explore">Kuler</a> to make your own colors palettes.

<code>// Returns a color between 0 and the length of our color array
const randomColor = colors => colors[Math.floor(Math.random() * colors.length)];

const colors = [
 '#e53935',
 '#d81b60',
 '#8e24aa',
 '#5e35b1',
 '#3949ab',
 '#1e88e5',
 '#039be5',
 '#00acc1',
 '#00897b',
 '#43a047',
 '#ffeb3b',
 '#ef6c00'
];

// Re-assign color on contact
Ball.prototype.update = function () {
 if (this.y + this.radius > canvas.height || this.y - this.radius &lt; 0) {
   this.color = randomColor(colors);
   controls.dy = -controls.dy;
 };
 this.y -= controls.dy;

 if (this.x + this.radius > canvas.width || this.x - this.radius &lt; 0) {
   this.color = randomColor(colors);
   controls.dx = -controls.dx;
 };
 this.x += controls.dx;

 this.draw();
};

// Make it start with a random color
const newBall = new Ball(innerWidth / 2, innerHeight / 2, 50, randomColor(colors));</code>

<h3>Tail</h3>
Now that we have the basic functionality in place we can make it a bit more visually interesting by adding a colored tail that trails behind it. 
We can do this by removing <code>clearRect</code> and filling our whole canvas with a dark RGBA value. 
This creates a ‘residue' effect from anything that moves through it and we can control the residue's intensity with the background's opacity.

<code>const animate = () => {
 requestAnimationFrame(animate);

 c.fillStyle = `rgba(33, 33, 33, ${-controls.tail / 10})`; // Lower opacity creates a longer tail
 c.fillRect(0, 0, canvas.width, canvas.height);

 newBall.update();
};

// We also need to update our controls with some default values
const controls = {
 dx: 5,
 dy: 5,
 tail: -5
};

gui.add(controls, 'dx', 0, 10);
gui.add(controls, 'dy', 0, 10);
gui.add(controls, 'tail', -10, 0);</code>

<h3>Conclusion</h3>
Just like that, we now have a very basic collision system with some special effects. 
In the upcoming Part 3 of this series we'll be using the concepts covered here to create this dynamic <a href="https://codepen.io/alligatorio/pen/JjjPvma">rain animation</a>.

If you had any problems following along, a working example is available on <a href="https://codepen.io/alligatorio/pen/xxxKjyJ">Codepen</a>. 
Feel free to fork it and share what you made.


<h2>Understanding Variable Scope in JavaScript</h2>

The scope is the execution context of a variable or function. 
It defines what data it has access to. 
This concept may seem pretty straightforward, but has some important subtleties.

JavaScript has traditionally had two types of scope: global scope and local scope. 
The purpose of the scope is to provide access to all variables and functions that an execution context has access to.

<h3>Global Scope</h3>
When a variable is declared outside of any function it belongs to the global scope automatically and can be accessed from anywhere in the program, be it a function or any block. 
Also, if desired, in the browser we can create a global variable by declaring it as <code>window.newVariable</code> at any place in a program.

<code>const nestAnimal = 'crocodilian';   // belongs to the Global scope

function getNestInfo(){
 window.eggs = 5;     // as well belongs to the Global scope
}</code>

In fact, in the browser, variables in the global scope belong to the global <code>window</code> object.

JavaScript is a garbage-collected language, it keeps available all variables while executing the program in the context and remove after. 
Let's consider the lifecycle of the variable. 
The variable comes into existence during the execution of the function. 
The variable is used inside the function and then the function ends. 
At that point this variable is no longer needed, so its memory can be reclaimed and JavaScript remove this variable from the memory. 
But global variables remain in the memory for the all the time the application is running and clogs up it, which slows down the program, also it may cause unexpected name conflicts.

That all means that, whenever possible, you should avoid to defining global variables. 
They are only truly needed in very specific cases, so be careful with this.

<h3>Local Scope</h3>
ES6 introduced block-scoped variables using the <a href="https://alligator.io/js/let-const-variables-es6/"><code>const</code> and <code>let</code> keywords</a>. 
With these keywords, local scope is created and exists within the innermost block that surrounds it. 
It could be a function, <code>for</code> loop, <code>while</code> block, <code>if</code> block, etc. 
Such locally scoped variables can be only accessed from within that block.

Each block has its own execution context which defines what data it has access to, as well as how it should behave. 
When code is executed in a context, a scope chain is created. 
It includes all declared variables and functions inside that block, then the data from the containing (parent) context, and so on. 
This pattern continue until the global context is reached.

Let's have a look at an example:

<code>let caymanMood = 'calm';

function changeMood(newMood){
 if (caymanMood === 'calm'){
   caymanMood = newMood;
 } else {
   caymanMood = 'calm';
 }
}

changeMood('happy');</code>

The function <code>changeMood</code> has a scope chain with two objects in it: its own variable object (arguments object <code>newMood</code>) and the global context's variable object <code>caymanMood</code>. 
The function has access to <code>caymanMood</code> because it's part of its scope chain.

<h3>Scope Chain Augmentation</h3>
It's possible to augment the scope chain besides global and local execution contexts. 
We can do this in two ways.
<li>
<em>Point 1</em>: A with statement</li><li>
<em>Point 2</em>: The <code>catch</code> block in a <code>try...catch</code> statement.</li>

<code>function buildNest() {
 const assets = 'grass';
 with(reptilian){
   const building = ability + assets;
 }
 return building;
}</code>

<code>with</code> creates a object that is added to the front of the scope chain, but the thing is when you read the code you can't know for sure which object exactly will be modified. 
Will it be the global variable <code>ability</code> or the variable in this context <code>reptilian.ability</code>. 
So the correct execution of the program can't be guaranteed. 
Use of the <code>with</code> statement is not recommended by the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with">MDN web docs</a> as it may be a source of confusing bugs and compatibility issues.

The <code>catch</code> statement creates a new variable object that contains a declaration for the thrown error object and this error object is added to the front of the scope chain.

<h3>Wrapping Up</h3>
With this, you should now have a slightly better understanding of how local and global scope works in JavaScript and how relying on the closest local context possible is a good idea for writing easily readable and maintainable code.

<h2>Animations with the Canvas API - Part 1: Linear Motion</h2>

In this series, we'll be exploring by example some of the common methods and patterns for creating stunning and interactive JavaScript animations with the HTML canvas element.

<h3>Prerequisites</h3>
Understanding how to render basic shapes is necessary, which I covered <a href="https://alligator.io/js/drawing-shapes-canvas-api/">here</a>.

<h3>Installation</h3>
To help automate our inputs, we'll be using <a href="https://github.com/dataarts/dat.gui">dat.gui</a> to give us real-time control over our variables. 
Since we're using it on our client side, you can just use the CDN.

<code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js">&lt;/script></code>

<h3>Basic Setup</h3>
As our boilerplate, we just need an HTML page with a <code>canvas</code> element and a JavaScript file setting our canvas to full screen. 
We need to set the dimensions in our JavaScript file to avoid a blurring effect that CSS causes.

index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
 &lt;head>
   &lt;meta charset="UTF-8"/>
   &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/>
   &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/>
   &lt;title>HTML Canvas&lt;/title>
 &lt;/head>
 &lt;body>
     
   &lt;canvas>&lt;/canvas>

 &lt;/body>
 &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js">&lt;/script>
 &lt;script src="./canvas.js">&lt;/script>
&lt;/html></code>

canvas.js

<code>const canvas = document.querySelector('canvas');
const c = canvas.getContext('2d');

canvas.width = innerWidth;
canvas.height = innerHeight;
addEventListener('resize', () => {
 canvas.width = innerWidth;
 canvas.height = innerHeight;
});</code>

<h3>GUI Basics</h3>
With our new GUI instance in place, you should already be able to see a <code>Close Controls</code> in the upper right-hand corner of your page. 
All we need is an object to hold all of the our variables and <code>gui.add()</code> to add them to our panel. 
<code>add</code> just takes our object, the variable we want to add, and the minimum and maximum values.

We'll worry about the actual values later, let's just add them to our controls for when we're ready for them.

canvas.js

<code>const gui = new dat.GUI();

const controls = {
 dx: 0, // Speed on the x-axis
 dy: 0, // Speed on the y-axis
};

gui.add(controls, 'dx', 0, 10);
gui.add(controls, 'dy', 0, 10);</code>

<h3>Animation Setup</h3>
The structure for most of your animations is going to be pretty similar. 
We have a class that we want to create, like a circle, with a draw method to render how it should look like and an update function to change its traits like color, position, or size.

Using the native <code>requestAnimationFrame</code> method we can make our browser repeat something very quickly forever, like run our <code>update</code> method. 
So if we were to have our x position set on our class and added 1 to it every time <code>update</code> was called, then we could use <code>requestAnimationFrame</code> to constantly repeat <code>update</code> and create the illusion of our object moving to the right. 
We can then set our x position to change by our dx variable in our GUI (d just means change in physics), so we can change the speed without even touching the code or reloading our screen.

For all of our methods we're going to use prototype instead of adding them onto the class itself. 
That would add the function onto every object while prototype makes all the objects reference the one function, thus better for performance when we are working with hundreds of objects.

Let's start with rendering something to the screen.

canvas.js

<code>class Ball {
 constructor(x, y, radius, color) {
   this.x = x;
   this.y = y;
   this.radius = radius;
   this.color = color;
 }
}

Ball.prototype.draw = function () {
 c.beginPath();
 c.fillStyle = this.color;
 c.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
 c.fill();
 c.closePath();
};

const redBall = new Ball(innerWidth / 2, innerHeight / 2, 50, 'red');

const init = () => redBall.draw();

init();</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d46bfd50a180bc31bd4daa57b94793dbe4a16b6b/7c1bf/images/js/canvas-animations-linear-motion/red-ball.png">

Now to make an animate function, we'll use <code>requestAnimationFrame</code> and pass in its own animate function as an argument, which will infinitely loop over our <code>update</code> method, adding the <code>dx</code> and <code>dy</code> variables from our gui every frame. 
Try <code>console.log</code> after to see how quickly the window updates.

<code>Ball.prototype.update = function () {
 this.x += controls.dx; // We can reference our ball object for gui controls
 this.y += -controls.dy; // Up is generally more intuitive as a positive value, so let's flip it to be a bit easier to handle.
 this.draw();
};

const animate = () => {
 requestAnimationFrame(animate);
 // Since we are creating a new ball every frame we first want to clear the old one.
 c.clearRect(0, 0, canvas.width, canvas.height);

 redBall.update();
};

animate();</code>

With our controls working, we can start tinkering with our min/max values for more control.

<code>gui.add(controls, 'dx', -20, 20);
gui.add(controls, 'dy', -20, 20);</code>

Now you can start playing with your new animation, adding more objects, and drawing more interesting shapes.

<h3>Conclusion</h3>
While very basic, this pattern of creating objects, drawing them to the screen, and changing some variables every frame is the foundation of most animations you'll ever see or make. 
If you wish to explore some more examples, <a href="https://alligator.io/js/canvas-animations-collisions/">in part 2</a>, we start working with collisions.

If you had a trouble getting this to work, I made the Codepen available <a href="https://codepen.io/alligatorio/pen/zYOVdMe">here</a>.


<h2>Draw the Alligator.io SVG Logo with GreenSock</h2>

To get the most out of this article it is important that you have a solid understanding of JavaScript. 
We will be solely focusing on understanding GreenSock in this article, so if you haven't used JavaScript before then get learning and come back!

<h3>What is Greensock?</h3>
<a href="https://greensock.com/">GreenSock</a> is a JavaScript animation library that saves us a lot of pain when creating our animations especially when it comes to cross browser capability. 
GreenSock can also be called GSAP (GreenSock Animation Platform) and I will use both interchangeably. 
GSAP can basically animate any property you throw at it, ranging from CSS properties to SVG attributes.

GSAP has multiple tools you can use, which include:
<li>
<strong>TweenLite</strong> which is, as the name implies, a lightweight version</li><li>
<strong>TweenMax</strong> which is fully packed with all of GSAP's power</li><li>
<strong>TimelineLite &amp;</strong> <strong>TimelineMax</strong> are sequencing tools which helps manage the timing of our animations</li>

GSAP can be installed as an <code>npm</code> module:

<code>$ npm install gsap</code>

Or loaded through a script tag:

<code>&lt;script src="&lt;https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js>">&lt;/script></code>

<h3>GreenSock Basics</h3>
To demonstrate GreenSock I am going to use Codepen. 
You can <a href="https://codepen.io/alligatorio/pen/mdbQBJN">fork the pen here</a> which has GreenSock already set up.

Let's start off basic and animate a red square across the screen using GSAP's <code>to</code> method. 
We create the red square like so:

<code>&lt;style>
 #element {
   height: 150px;
   width: 150px;
   background: red;
 }
&lt;/style>
&lt;div id="element">&lt;/div></code>

To animate this we pass <code>3</code> arguments to the <code>to</code> method, the arguments are:

<code>.to(elToAnimate, duration, propToAnimate)</code>

So in our case the element we want to animate is <code>#element</code>, the duration is <code>1</code> second and since we want to move our square our final argument is an object targeting the <code>x</code> property. 
Our code is:

<code>TweenMax.to("#element", 1, { x: 100 })</code>

This gives us the following:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/25fb2775feed2bdd90419c46804132bab4ed6f80/49e6d/images/js/draw-using-greensock/red-square-moving.gif">

Don't worry about the gif, it's much smoother in real life, as you'll see on Codepen!

Let's say now we want to rotate our square, all we need to do is:

<code>TweenMax.to("#element", 3, { rotation: 360 });</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6c2e35e9f1b07f1241d60569a9cfd90d28c4ee8c/72cc7/images/js/draw-using-greensock/red-square-rotate.gif">

You can make this <code>rotation</code> infinite by adding <code>repeat:-1</code> to our object. 
You can also add in the <code>yoyo</code> property which will alternate the animation between backwards and forwards.

We can start from a different position using the <code>fromTo</code> method. 
This is similar to the <code>to</code> method but we can supply an extra object of where we would like our animation to start. 
If we wanted our square to begin at <code>x:300</code> then we pass this as the third argument to <code>fromTo</code>.

Code wise this looks like as follows:

<code>TweenMax.fromTo("#element", 3, {x: 300}, { x: 100 }); </code>

Visually:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e7b8d21b4bbe7e3f692a14d864cace2701f2acc9/8413a/images/js/draw-using-greensock/red-square-moving-other-way.gif">

We can do more than change the position of our square, we could also target something like the opacity:

<code>TweenMax.fromTo("#element", 5, {opacity: 0}, { opacity: 1 });</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1a0dedf7693f718eebead44f9d3e5fe5735dbe5a/ec96c/images/js/draw-using-greensock/red-square-opacity.gif">

Again we use the <code>fromTo</code> method and start our <code>opacity</code> at <code>0</code> and finish on <code>1</code>.

Ok, I'm sure you are incredibly uninspired right now as let's be honest the above is quite boring. 
Let's do something more interesting, we'll use the <code>Alligator.io</code> logo and do something cool!

<h3>Alligator.io SVG Logo Animation</h3>
I stole the <code>Alligator.io</code> logo from the website, hope Seb doesn't mind. 
<a href="https://codepen.io/alligatorio/pen/zYOMErj">Here is the starter pen with our SVG inside</a>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4f02e350732568c449bccac97c1065692b9150d0/aeb99/images/alligatorio.svg">

So our goal with this animation will be to <code>draw</code> the logo and fade in the green color.

The first thing we need to do is set a <code>stroke-dasharray</code> and <code>stroke-dashoffset</code> on our graphic. 
These are the attributes we use to simulate a drawing effect, you can read more about these properties <a href="https://css-tricks.com/almanac/properties/s/stroke-dasharray/">here</a>.

In our CSS we set the following:

<code>#alligator path {
 stroke-dasharray: 600;
 stroke-dashoffset: 600;
 fill-opacity: 0; // we will animate the fill in
}</code>

With this in place, our alligator has now disappeared. 
Let's go animate it back in using <code>TweenMax</code>.

We use the <code>to</code> method which we used above, then we set our <code>stroke-dashoffset</code> to be <code>0</code>.

<code>TweenMax.to("#alligator path", 15, { "stroke-dashoffset": 0 })</code>

We use the same selector we used in our CSS <code>#alligator path</code>, set a duration of <code>0</code> and then set our <code>stroke-dashoffset</code> to <code>0</code>. 
This gives a really cool drawing effect:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5ca1901bf82e78e7d95c9a4a4e5157c69f24fee2/7a664/images/js/draw-using-greensock/alligator-first-draw-o.gif">

How cool is that?!! 

Now the next thing we need to do is get our color back in. 
We do this by adding an extra property to our object.

<code>TweenMax.to("#alligator path", 15, { "stroke-dashoffset": 0, "fill-opacity": 1 })</code>

The problem we currently have is that the duration is quite long and this looks a little weird with the <code>fill-opacity</code> property. 
Ideally what we want is to first draw, then when that finishes we'll fill in the graphic. 
The old way to achieve this was to have two separate animations with the second animation having a delay that matches the first animation's duration. 
GreenSock gives us the great <code>TimelineMax</code> which does this for us.

<h3>TimelineMax</h3>
The first thing we need to do is create an instance of the <code>TimelineMax</code> class like so:

<code>const tl = new TimelineMax()</code>

Then we call the <code>to</code> method on our instance and pass it our drawing effect:

<code>tl.to("#alligator path", 10, { "stroke-dashoffset": 0 })</code>

Then we call the <code>to</code> method again but this time for our <code>fill-opacity</code>:

<code>tl.to("#alligator path", 5, { "fill-opacity": 1 })</code>

With that in place we then get the following:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9f3954ea546e1c5bbe4b0e9b5cd01cf95d305ca3/64c93/images/js/draw-using-greensock/alligator-io-second-draw-o.gif">

<code>TimelineMax</code> is extremely powerful and this is just scratching the surface, creating sequential animations has never been easier!

<h3>Conclusion</h3>
This is a nice quick intro into GreenSock and the most common methods. 
It's a really powerful tool and if you enjoy making animations then you should really consider using it for your next project!


<h2>Using the Trim String Method in JavaScript</h2>

It's always helpful to have an easy method method on strings to remove trailing or leading whitespace and the <code>trim()</code> method available on JavaScript strings is here to help us with doing exactly that.

Whitespace can anything such as <em>spaces</em>, <em>tabs</em>, <em>no-break spaces</em>, <em>LF (line feeds)</em>, <em>CR (carriage returns)</em>, etc.

Let's quickly go over how to use it.

<h3>String.trim()</h3>
The <code>String.trim</code> method is used to remove the whitespace from both ends of a string.
<li>Parameters: It does not accept any parameter.</li><li>Return type: It returns the string without whitespace.</li>

An example of how to use it is shown below 

<code>let reptilianString = "          ";

console.log(reptilianString.trim());

// </code>

If we want to remove the whitespace only from the front but not from rear or vice-versa, we can also use the following methods.
<li><code>trimStart()</code></li><li><code>trimEnd()</code></li>

<h3>trimStart()</h3>
The <code>trimStart()</code> method is used to remove whitespace from the start of a string.
<li>Parameters: It does not accept any parameter.</li><li>Return type: It returns the string without whitespace at the start.</li>

Note: <code>trimLeft()</code> is an alias for <code>trimStart()</code>

<h3>trimEnd()</h3>
The <code>trimEnd()</code> method is used to remove the whitespace from the right end of the string.

Parameters: It does not accept any parameter. 
Return type: It returns the string without whitespace on the right end.

Note: <code>trimRight()</code> is an alias for <code>trimEnd()</code>

<h2>What is the preventDefault Event Method in JavaScript?</h2>

In this article you'll learn about the <code>event.preventDefault()</code> method. 
It's a reminder of how much control we have over the client (the browser) when programming in JavaScript.

If you've ever doubted how much power JavaScript gives you, try using <code>event.preventDefault()</code>! This method actually gives you the ability to <em>prevent a browser's default behavior for events</em>.

<h3>Examples</h3>
Let's explore how <code>preventDefault</code> works via interactive examples. 


<h3>Checkboxes</h3>
Normally, when you click on a checkbox it'll toggle the check. 
However if you use <code>preventDefault</code> it will actually stop the broswer from doing that.

index.html

<code>&lt;input type="checkbox" id="myCheckbox">  </code>

index.js

<code>document
 .getElementById('myCheckbox')
 .addEventListener('click', (event) => {
   event.preventDefault();  // 
 });</code>

<a href="https://glitch.com/embed/#!/embed/alligator-prevent-default-1?path=views/index.html&amp;previewSize=100&amp;attributionHidden=true">alligator-prevent-default-2 on Glitch</a>
Crazy! Just like that the browser is prevented from checking the box.

<h3>Links and input boxes</h3>
You can use <code>preventDefault</code> on all sorts of different HTML elements. 
Let's try using it on a link and an input box:

index.html

<code>&lt;a href="https://duckduckgo.com" id="myLink">DuckDuckGo&lt;/a>  

&lt;input type=text" id="myInput"/></code>

index.js

<code>document.getElementById('myLink')
 .addEventListener('click', (e) => e.preventDefault())

document.getElementById('myInput')
 .addEventListener('keypress', (e) => e.preventDefault())</code>

<a href="https://glitch.com/embed/#!/embed/alligator-prevent-default-2?path=views/index.html&amp;previewSize=100&amp;attributionHidden=true">alligator-prevent-default-2 on Glitch</a>

This is probably obvious but should be mentioned: you'll need to target the correct event. 
For example, targeting the <em>keyup</em> event on the <code>&lt;input></code> won't prevent you from entering text since that happens during the <em>keydown</em> event.

That's why we used <em>keypress</em> since it actually covers both <em>keydown/keyup</em>.

<h3>Non-Cancelable Events</h3>
There are some events that the browser can't prevent from happening. 
For example, events like <em>scroll</em> and <em>wheel</em> (for mouse wheel events!) will ignore <code>preventDefault</code>.

<code>document.addEventListener('scroll', (e) => {
 e.cancelable;         // false
 e.preventDefault();   // doh! the page still scrolls 
});</code>

To determine whether an event can be canceled, inspect the event using <code>e.cancelable</code> which will return a boolean value.

Reminder: <code>preventDefault()</code> should be distinguished from <code>stopPropagation()</code> as using preventDefault will still allow your events to bubble up the DOM if you don't also use stopPropagation.

<h3>preventDefault in Practice</h3>
In real life, you'll probably resort to using <code>preventDefault</code> most often to stop forms from automatically submitting when the submit button is clicked, giving you a chance to instead submit the form data asynchronously using JavaScript and something like the <a href="https://alligator.io/js/fetch-api/">Fetch API</a> to make an Ajax request.

<code>document
 .getElementById('myForm')
 .addEventListener('submit', (event) => {
   event.preventDefault();  // 

   // ...send the form data and get a response asynchronously
 });</code>

<h3>Wrapping Up</h3>
We've only used <code>preventDefault()</code> on some of the more popular event types (<em>click</em> and <em>keypress</em>) but it works with all <a href="https://developer.mozilla.org/en-US/docs/Web/Events">event types</a>. 
If you've ever doubted how much power JavaScript developers are entrusted with, look no further than <em>preventDefault</em> which can actually veto a browser's normal behavior!

To learn more about preventDefault visit the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" alt="mdn">Mozilla Developer Network</a> 


<h2>A Simple Way to Animate Scrolling Effects in JavaScript</h2>

Gone are the days of using JavaScript plugins to animate scrolling. 
In this article, you'll learn about a native way to accomplish this that you may not have heard of yet.

It's actually really easy to natively animate scrolling. 
Instead of using this syntax that you might familiar with:

<code>window.scroll(0, 1000);  // *jumps* the webpage down 1000px</code>

Use this alternate syntax:

<code>window.scroll({
 top: 1000,
 behavior: 'smooth'  //  
});</code>

That's it! That will animate the scrolling. 
It's a little odd that there's two wildly different syntaxes for the same method… But it works!

<h3>Why Animate Scrolling?</h3>
Animating scrolling is a nice touch for users. 
Without it, the webpage jumps abruptly to something else on the webpage:

<a href="https://glitch.com/embed/#!/embed/alligator-animated-scroll-1?path=views/index.html&amp;previewSize=100&amp;attributionHidden=true">alligator-animated-scroll-1 on Glitch</a>

It's easy to feel slightly disoriented, and wonder what just happened. 
Animating the scrolling effects provides a more pleasant experience:

<a href="https://glitch.com/embed/#!/embed/alligator-animated-scroll-2?path=views/index.html&amp;previewSize=100&amp;attributionHidden=true">alligator-animated-scroll-2 on Glitch</a>

<h3>Using Other Scrolling Methods</h3>
There's actually other scrolling methods besides <code>window.scroll()</code>. 
These other scroll methods can do things like incrementally scroll a specific distance, or even scroll to a DOM node.

Here's the various scroll methods that accept the “smooth” scrolling config object:

<code>// incrementally scroll up 100px
window.scrollBy({ top: -100, behavior: 'smooth' });

// scroll to the top
window.scroll({ top: 0, behavior: 'smooth' });

// scroll to a DOM node
document
 .getElementById('kristen-wiig')
 .scrollIntoView({ behavior: 'smooth' });</code>

Try clicking the buttons to play with the scrolling effects!

<a href="https://glitch.com/embed/#!/embed/alligator-animated-scroll-3?path=views/index.html&amp;previewSize=100&amp;attributionHidden=true">alligator-animated-scroll-3 on Glitch</a>
<h3>Conclusion</h3>
Try using animated scroll effects in your next project! It's a nice way to gently guide users to specific parts of your web page that they'll surely appreciate 

Browser compatibility is solid across the board with the exclusion of Safari, however there's a <a href="https://www.npmjs.com/package/smoothscroll-polyfill" alt="npm">popular polyfill</a> available that will give you blanket coverage on major browsers.


<h2>Using the Array.find Method in JavaScript</h2>

The JavaScript <code>Array.find</code> method is a convenient way to <code>find</code> and return the first occurence of an element in an array, under a defined testing function. 
When you want a <em>single</em> needle from the haystack, reach for <code>find()</code>!

<h3>When to Use Array.find</h3>
The function and syntax of <code>find()</code> is very much like the <a href="https://alligator.io/js/filter-array-method/">Array.filter</a> method, except it only returns a <em>single</em> element. 
Another difference is when nothing is found, this method returns a value of <code>undefined</code>.

So if you only need a single value, use <code>find()</code>! When you need to find/return multiple values, reach for <code>filter()</code> instead.

<h3>How to Use Array.find</h3>
Using <code>find()</code> is super easy! The only required parameter of this method is a testing function, and it can be as simple or complex as needed. 
In its most basic form:

<code>array.find(testingFunction); // that's it!</code>

<h3>Simple example:</h3>
Here's a simple example with an array of strings:

<code>const trees = [ 
 "birch", 
 "maple", 
 "oak", 
 "poplar" 
];

const result = trees.find(tree => tree.startsWith("m"));

// "maple"</code>

In non-shorthand, non-ES6 form:

<code>const result = trees.find(function(tree) {
 return tree.startsWith("m");
});

// "maple"</code>

<h3>Using with objects:</h3>
We can use <code>find()</code> to easily search arrays of objects, too!

<code>const trees = [
 { name: "birch", count: 4 },
 { name: "maple", count: 5 },
 { name: "oak", count: 2 }
];

const result = trees.find(tree => tree.name === "oak");

// { name: "oak", count, 2 }
</code>

Using the same example, notice if we use <code>find()</code> when a test has multiple results, we only get the first value found:

<code>const result = trees.find(tree => tree.count > 2);

// { name: "birch", count: 4 }</code>

This is an instance where you should probably use <code>filter()</code> instead. 
See the difference?

<h3>Tip: Separating the testing function</h3>
Sometimes you'll want to re-use the same <code>find()</code> test function in multiple places. 
In that case, it can be really helpful to create a separate testing function.

Let's demo this technique, expanding on our previous examples:

<code>const deciduous = [
 { name: "birch", count: 4 },
 { name: "maple", count: 5 },
 { name: "oak", count: 2 }
];

const evergreens = [
 { name: "cedar", count: 2 },
 { name: "fir", count: 6 },
 { name: "pine", count: 3 }
];

// our testing function
const hasFiveOrMore = el => el.count >= 5;

const decResult = deciduous.find(hasFiveOrMore);
// { name: "maple", count: 5 }

const evgResult = evergreens.find(hasFiveOrMore);
// { name: "fir", count: 6 }</code>

Simple, but powerful! 

<h3>Using the index parameter</h3>
Like <code>filter()</code>, there is an optional <code>index</code> parameter we can use. 
Here's one last example, using it as part of our testing function:

<code>const evergreens = [
 { name: "cedar", count: 2 },
 { name: "fir", count: 6 },
 { name: "pine", count: 3 }
];

// suppose we need to skip the first element
const result = evergreens.find((tree, i) => {
 if (tree.count > 1 &amp;&amp; i !== 0) return true;
});

// { name: "fir", count: 6 }</code>

The <code>index</code> is probably not something you'll need often — but it's great to have available at times.

<h3>Conclusion</h3>
<code>Array.find</code> is a simple but incredibly useful method for searching JavaScript arrays.

Just remember: only use <code>find</code> when you want a <em>single</em> element returned, and that it returns <code>undefined</code> if nothing is found! Otherwise, use the <a href="https://alligator.io/js/filter-array-method/"><code>filter</code></a> method when you need multiple elements returned.

<h2>What's the Difference Between var, let and const in JavaScript?</h2>

In this article, we'll cover the differences between <code>var</code>, <code>let</code>, and <code>const</code>. 
You'll also learn some prescriptive rules to know when to choose one over the other.

With ES2016, two new ways to define variables were introduced with <code>let</code> and <code>const</code>. 
Before that you could only use <code>var</code> to define variables. 
So… what's the big idea? Why are three different ways to define variables?

Before we can understand how <code>var</code> and <code>let/const</code> differ we need to understand a computer science-y concept called <a href="https://alligator.io/js/object-reference-context-scope-instantiation/#scopes-and-context">scope</a>.

<h3>Function-scope vs Block-scope</h3>
In JavaScript there's two kinds of scope: function-scope and block-scope.

<h3>Function-scope</h3>
<code>function myFn() {
 var foo = 'peekaboo!';
 
 console.log(foo); // 'peekaboo!'
}

console.log(foo); // ReferenceError: foo is not defined</code>

Using <code>var</code>, variables are function-scoped because their <em>visibility is limited to the function</em>. 
When you try to use it outside of the function, you'll get an error.

<h3>Block-scope</h3>
<code>if (true) {
 var foo = 'peekaboo!';
 let bar = 'i see u';
 const baz = 'baby blue!';

 console.log(foo); // 'peekaboo!';
 console.log(bar); // 'i see u';
 console.log(baz); // 'baby blue!';
}

console.log(foo); // 'peekaboo!';
console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined</code>

Notice the visibility of <code>foo</code> isn't limited by the if-statement block. 
However, both <code>bar</code> and <code>baz</code> are <em>limited in visibility to the block of code</em>.

This concept of scope is the most prominent distinction between the old-fashioned <code>var</code> and modern <code>let/const</code>.

A block of code is the code between curly braces in JavaScript.

<h3><code>var</code></h3>
There's other nuances between <code>var</code> and <code>let/const</code> so let's explore a few code snippets to understand them better.

<h3>var outside of a for-loop</h3>
<code>// for-loop
for (var i = 0; i &lt; 3; i++) {
 console.log(i);
}

console.log(i);</code>

What do you think the output of this code is?

<gator-collapse title="Click for Answer"> // 0<br> // 1<br> // 2<br> // 3
</gator-collapse>The variable <code>i</code> is accessible outside of the for-loop. 
This is expected since variables defined with <code>var</code> are only inaccessible outside of a function definition.

<h3>Redefining <code>var</code>
</h3>
Using <code>var</code> you can reassign it with a new value.

<code>function myFn() {
 var foo = 1;
 foo = 30;
 var foo = 101;

 console.log(foo);  
}

myFn();</code>

What's the output of <code>myFn()</code>?

<gator-collapse title="Click for Answer"> // 101
</gator-collapse><h3><code>let</code></h3>
In many ways <code>let</code> is like a cousin of <code>var</code>. 
It has a lot of similarities but differentiates in ways that makes ES2016 a more modern-feeling language.

<h3>
<code>let</code> outside of a for-loop</h3>
<code>// for-loop
for (let i = 0; i &lt; 3; i++) {
 console.log(i);
}

console.log(i);</code>

What do you think is the output?

<gator-collapse title="Click for Answer"> // 0<br> // 1<br> // 2<br> // ReferenceError: i is not defined
</gator-collapse><h3>Redefining <code>let</code>
</h3>
Using <code>let</code> you can reassign variables, but its syntax is more strict than <code>var</code>.

<code>function myFn() {
 let foo = 1;
 foo = 30;
 // let foo = 101;    // ♀ can't use "let" keyword again
 foo = 101;

 console.log(foo);  
}

myFn();

console.log(foo);  </code>

What's the output of <code>myFn()</code>?

<gator-collapse title="Click for Answer"> // 101<br> // ReferenceError: foo is not defined
</gator-collapse><h3><code>const</code></h3>
The keyword <code>const</code> is an abbreviation for <em>constant</em>. 
Similar to <code>let</code>, it's block-scoped, however, you can't reassigned it.

What do you think is the output of this code?

<code>const myBoolean = true;

if (myBoolean) {
 const turtles = [
   'leonardo',
   'donatello',
   'michaelangelo',
   'raphael'
 ];
 // turtles = turtles.concat('Shredder');  // ♀ this would throw an error

 console.log(turtles);
}

console.log(turtles); </code>

<gator-collapse title="Click for Answer"> // ['leonardo', 'donatello', 'michaelangelo', 'raphael']<br> // ReferenceError: turtles is not defined
</gator-collapse>Items can still be added to a <code>const</code> variable that points to an array or an object, because the <code>const</code> is not being reassigned in such case. 
You can learn more about that in this <a href="https://alligator.io/js/let-const-variables-es6/#const">short post about let and const</a>.

<h3>Review</h3>
See the table below for a breakdown.

<table style="width: 100%;">
<thead><tr>
<th>Keyword</th>
<th>Function vs Block-scope</th>
<th>Redefinable?</th>
</tr></thead>
<tbody>
<tr>
<td><code>var</code></td>
<td>function-scope</td>
<td></td>
</tr>
<tr>
<td><code>let</code></td>
<td>block-scope</td>
<td></td>
</tr>
<tr>
<td><code>const</code></td>
<td>block-scope</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
In summary, it's generally advisable to avoid using <code>var</code> because function-scope isn't as obvious as block-scope. 
It certainly seems that the intention of ES2016-2019 is to replace <code>var</code> with <code>let/const</code> since they encourage better coding practices.

Generally, if you need to create a variable, use <code>const</code>. 
However, if you know or think that you'll need to reassign it (for-loops, switch statements, algorithm swapping) use <code>let</code>.

<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>Drag and Drop Elements with interact.js</h2>

<style> section.example-code { font-family: sans-serif; } .item { background-color: #4AAE9B; width: 100px; margin: 10px 0; color: white; padding: 5px; } .dropzone { background-color: #EFBB35; height: 200px; width: 200px; padding: 20px; } .dropzone h3 { margin: 0; color: black; }</style>
Drag and drop functionality is a common feature seen in apps to make the UI feel more interactive for users. 
There are several JavaScript libraries for achieving this effect, as well as the <a href="https://alligator.io/js/drag-and-drop-vanilla-js/">native HTML Drag and Drop API</a>, but it can be difficult to pick what to use.

Here we'll look at one of those libraries: <a href="https://interactjs.io/">interact.js</a>, a customizable JavaScript library that can be used in HTML or front-end frameworks like React.

<h3>Setting Up Our HTML</h3>
Before we can make anything interactive, we need to set up our HTML elements. 
For the purpose of keeping things simple, let's create a few items that will be draggable and one non-draggable dropzone to put the items in.

<code>&lt;section>
 &lt;div class='item'>I'm an item&lt;/div>
 &lt;div class='item'>I'm an item&lt;/div>
 &lt;div class='item'>I'm an item&lt;/div>

 &lt;div class="dropzone">
   &lt;h3>Dropzone&lt;/h3>
 &lt;/div>
&lt;/section></code>

<section>I'm an item
I'm an item
I'm an item
<h3>Dropzone</h3></section>We've given each of our items a matching class (<code>.item</code>), which we'll need later to make our items “interactable”. 
Nothing can be interacted with yet, though, so let's move on the the JavaScript.

First, we'll need to import <code>interact.js</code>. 
At the top of the HTML file you're working in, add a <code>script</code> tag with the <code>interact.js</code> CDN link.

<code>&lt;script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js">&lt;/script></code>

If this were a React project, you could install via <code>npm</code> and import <code>interact.js</code> to your component. 
To do that, first run this in the command line:

<code>$ npm install --save interactjs</code>

Then import <code>interact.js</code> like so:

<code>import interact from 'interactjs'</code>

Now that we have our HTML elements and have imported <code>interactjs</code>, we can start actually using it! 

<hr>
<h3>Making Our Items “Interactable”</h3>
Since our items all have the class <code>.item</code> applied to them, we can select them all by using that class.

To make sure no other browser events related to the mouse happen while we're dragging, we'll first disable the browser panning and text selection on mouse drag.

<code>.item {
 touch-action: none;
 user-select: none;
}</code>

Now to move on to our JavaScript. 
We want to first make all our items <code>interact.js</code> items like so:

<code>interact('.item')</code>

Once our items are “interactable”, we can customize them as much as we want by chaining <code>interact.js</code> methods.

Note that just making our items "interactable" does not mean the items can be dragged yet. 
We need to explicitly declare dragging ourselves.

<h3>Dragging Items</h3>
Using the “interactable” item declared above, let's now add our dragging options. 
To set custom dragging options, we can access the <code>draggable</code> method and pass it an object with all our custom settings. 
We will need to set at least one property in the object we pass <code>draggable</code>: the <code>onmove</code> property. 
This will allow us to update the x- and y-coordinates of our item as we drag it.

In <code>onmove</code>, we will:
<li>Determine the initial x- and y-coordinates of our item with the <code>data-x</code> and <code>data-y</code> data attributes. 
These won't exist until we create them after the first run through so we'll use zero as a base value. 
We'll also have to convert them to numbers from strings with <code>parseFloat()</code>.</li><li>Get the delta (or difference) between the initial coordinates and where the mouse is now with the <code>dx</code> and <code>dy</code> values.</li><li>Add the initial values to the distance it has moved to get the new position for x and y.</li><li>Set those new positions with CSS's <code>transform</code> property.</li><li>Update the <code>data-x</code> and <code>data-y</code> data attributes to this new position.</li>

<code>interact('.item')
 .draggable({
   onmove: function(event) {
     const target = event.target;

     const dataX = target.getAttribute('data-x');
     const dataY = target.getAttribute('data-y');
     const initialX = parseFloat(dataX) || 0;
     const initialY = parseFloat(dataY) || 0;

     const deltaX = event.dx;
     const deltaY = event.dy;

     const newX = initialX + deltaX;
     const newY = initialY + deltaY;

     target
       .style
       .transform = `translate(${newX}px, ${newY}px)`;

     target.setAttribute('data-x', newX);
     target.setAttribute('data-y', newY);
   }
 })</code>

Since this function is getting pretty long, we can declare it outside the draggable property as a named function, and pass the named function instead. 
Once we start adding more properties, this we'll keep our “interactable” item more readable. 
Our function can also be refactored (a lot) but, for our purposes, let's keep it long so it's clearer what we're doing on each line.

<code>function onMove (event) {
 const event = target.event;

 const dataX = target.getAttribute('data-x');
 const dataY = target.getAttribute('data-y');
 const initialX = parseFloat(dataX) || 0;
 const initialY = parseFloat(dataY) || 0;

 const deltaX = event.dx;
 const deltaY = event.dy;

 const newX = initialX + deltaX;
 const newY = initialY + deltaY;

 target
   .style
   .transform = `translate(${newX}px, ${newY}px)`;

 target.setAttribute('data-x', x);
 target.setAttribute('data-y', y);
}

items
 .draggable({
   onmove: onMove(event)
 })</code>

Now that we've defined <code>onmove</code>, we officially have draggable items! They can be placed anywhere on the page, including the dropzone. 
The dropzone isn't exactly meaningful yet, but we'll get to that!

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/40e55e0834446ef02e9841173cd881a010e837bf/a0c30/images/js/drag-and-drop-interactjs/dragging.gif">
 Note that all our items automatically have a new cursor too so it's clear which elements are "interactable". 


<h3>Inertia Throwing</h3>
Inertia throwing is a quick little add-on for dragging elements that gives the them a more natural feel on move. 
When enabled, it factors in the velocity at which the items are moved. 
When dragging stops, the item will continue to move a bit relative to the velocity at which it was being dragged.

To enable inertia throwing, update your <code>draggable</code> property like so:

<code>items
 .draggable({
   onmove: onMove(event),
   inertia: true,
   restrict: {
     restriction: 'parent',
   },
 })</code>

The restrict property will make sure you can't “throw” your items off the screen. 


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bc81bf703c51f1fede6bb64d09785f3875862100/bb818/images/js/drag-and-drop-interactjs/inertiathrowing.gif">
<h3>Creating a Dropzone</h3>
To create a dropzone, we need to create a new “interactable” element. 
Like we did with the <code>.item</code> class, we can select our dropzone element with the <code>.dropzone</code> class we set in our HTML.

<code>interact('.dropzone')</code>

With our <code>.dropzone</code> element selected, we can set which elements can be accepted in the dropzone and how much overlap they need to have to count as “dropped”. 
(0.75 means 75% of the element must overlap in this case.) We can set these through the <code>dropzone</code> method.

<code>interact('.dropzone')
 .dropzone({
   accept: '.item',
   overlap: 0.75,
 })</code>

Now, let's decide on our goals. To make sure the dropzone is getting recognized, we can update the background color of our item in different states. 
<code>interact.js</code> thankfully has properties available for multiple states of dragging and dropping. 
We can update the color by adding classes to the item when each condition becomes true and remove those classes when they stop being true.

Let's look at the <code>interact.js</code> properties, what they do, and the class we'll use to represent each state:
<li>
<em>ondropactivate</em>: The item is getting dragged. 
Use the class <code>.dragging</code>
</li><li>
<em>ondropdeactivate</em>: The item is no longer being dragged. 
Remove the class <code>.dragging</code>
</li><li>
<em>ondragenter</em>: The item is considered to be in the dropzone. 
Add the class <code>.can-drop</code>
</li><li>
<em>ondragleave</em>: The item is getting moved out of the dropzone. 
Add the class <code>.cannot-drop</code>
</li>

<code>interact('.dropzone')
 .dropzone({
   accept: '.item',
   overlap: 0.75,
   ondropactivate: function (event) {
     const item = event.relatedTarget
     item.classList.add('dragging')
   },
   ondropdeactivate: function (event) {
     const item = event.relatedTarget
     item.classList.remove('dragging', 'cannot-drop')
   },
   ondragenter: function(event) {
     const item = event.relatedTarget
     item.classList.remove('cannot-drop')
     item.classList.add('can-drop')
   },
   ondragleave: function(event) {
     const item = event.relatedTarget
     item.classList.remove('can-drop')
     item.classList.add('cannot-drop')
   }
 })</code>

In each case, we select the item and apply or remove classes depending on what's being done.

event.relatedTarget selects the item being dragged. 
To update the dropzone, use event.target. 


After these properties are added to your <code>dropzone</code> element, make sure to add the CSS styles for <code>.item.dragging</code>, etc. 
Once that's done, you'll have items that can be dragged and get updated when they're in the dropzone. 
 Updating the background color is just one example of what you can do but the sky's the limit! 

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a0691e11eec46127031d202780ad17ba493242e0/6516f/images/js/drag-and-drop-interactjs/dropping.gif">
<h3>Customizing Your Elements Even More</h3>
<code>interact.js</code> is incredibly customizable. 
 Since you have access to the dropzone and item elements, you can update the styling of both, change the inner text, and add additional features like snapping into place. 
You can even use it for resizing your elements and add touchscreen dragging and dropping.

Check out the <a href="https://interactjs.io/docs/">docs</a> to learn even more options!

<h3>Browser Support</h3>
<code>interact.js</code> is supported by all modern browsers and even IE9+. 
 You can use it in your vanilla JS or whatever frontend framework you're using.


<h2>The Difference Between Promise.all and Promise.race in JavaScript</h2>

The <a href="https://alligator.io/js/promises-es6/">Promise object</a> in JavaScript offers a few useful built-in methods, with Promise.all and Promise.race being two such methods. 
Even though these two methods both take arrays of promises as argument, there's a big difference between <code>Promise.all</code> vs <code>Promise.race</code>.

Both of the <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects">Promise</a> methods receive an array of promises, however, you'll want to choose one over the other depending on what you need to accomplish.
<li>
<em>Promise.all</em> accepts an array of promises, and will attempt to fulfill all of them. 
Exits early if just 1 promise gets rejected.</li><li>
<em>Promise.race</em> also accepts an array of promises, but returns the first promise that is settled. 
A settled promise can either be resolved or rejected.</li>

<h3><code>Promise.all</code></h3>
The design purpose of <code>Promise.all</code> is to fulfill many promises. 
For example, when a user logs into a web app like Facebook, several network requests probably need to be made to populate the user's personalized content:

<code>const userContent = [
 new Promise(getFriendsList),
 new Promise(getGroups),
 new Promise(getLikedPages)
];

function initalizeUserContent() {
 Promise.all(userContent)  //  gotta get em all!
   .then(displayHomepage)
   .catch(redirectLoginForm);
};

initalizeUserContent();</code>

All those promises are vital to properly displaying the Facebook homepage to the user. 
If any of those promises are rejected it'll be required to exit <code>Promise.all</code> early, and redirect to the login page.

<h3><code>Promise.race</code></h3>
This one is somewhat different. 
You still give it an array of promises, but it exits with the first settled promise.

Imagine if you're developing software to purchase stocks on the NASDAQ exchange. 
You want to be able to submit purchases (called “buy orders”) to several stockbrokers, but you're only going to honor the first stockbroker that fulfills your order.

<code>const myStockBrokers = [
 eTrade,
 fidelity,
 interactiveBrokers,
 ameritrade,
 tradeStation,
 vanguard
];

function submitBuyOrder() {
 Promise.race(myStockBrokers)
   .then(updateMyPortfolio)
   .catch(cancelBuyOrder);
};

submitBuyOrder();</code>

The method name <code>Promise.race</code> is befitting because it causes all of the promises to “race” against each other with only a single winner. 


<h3>Quizzes</h3>
Here's 4 mini-quizzes to help reinforce what you learned! We're using <code>setTimeout</code> to simulate our promises.

<h3>Promise.all()</h3>
All 4 of the promises are “resolved” successfully! What's the return value?

<code>const foo = [
 new Promise((resolve, reject) => setTimeout(resolve, 222, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 333, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 111, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 444, ''))
];

Promise.all(foo)
 .then(console.log)
 .catch(console.log);</code>

<gator-collapse title="Click for Answer">[ '', '', '', '' ]
</gator-collapse>Notice the values in the array are ordered based on the same order in which the promises were passed-in to <code>promise.all</code>.

<hr>
Only 3 of the promises are “resolved” and 1 is “rejected.”

<code>const foo = [
 new Promise((resolve, reject) => setTimeout(resolve, 222, '')),
 new Promise((resolve, reject) => setTimeout(reject, 333, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 111, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 444, ''))
];

Promise.all(foo)
 .then(console.log)
 .catch(console.log);</code>

<gator-collapse title="Click for Answer"> '' // note: it's a "string" not an array
</gator-collapse>It only takes one bad apple to exit from <code>Promise.all</code>!

<h3>Promise.race()</h3>
If the first promise that's settled is “rejected” what's the result?

<code>const foo = [
 new Promise((resolve, reject) => setTimeout(resolve, 222, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 333, '')),
 new Promise((resolve, reject) => setTimeout(reject, 111, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 444, ''))
];

Promise.race(foo)
 .then(console.log)
 .catch(console.log);</code>

<gator-collapse title="Click for Answer"> ''
</gator-collapse><code>Promise.race</code> always returns the results of the 1<sup>st</sup> settled promise regardless of whether it's resolved or rejected.

<hr>
One promise will get “rejected.” What's the result?

<code>const foo = [
 new Promise((resolve, reject) => setTimeout(resolve, 222, '')),
 new Promise((resolve, reject) => setTimeout(reject, 333, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 111, '')),
 new Promise((resolve, reject) => setTimeout(resolve, 444, ''))
];

Promise.race(foo)
 .then(console.log)
 .catch(console.log);</code>

<gator-collapse title="Click for Answer"> ''
</gator-collapse><h3>Rule of Thumb </h3>
These 2 Promise methods serve different purposes even if they're both designed to work with arrays of promises. 
A helpful tip is to think about the returned value that you want. 
Do you want an array of promise results? Or, do you simply want the results of the first settled promise?


<h2>Drag &amp; Drop Elements with Vanilla JavaScript and HTML</h2>

There are lots of great JavaScript libraries for adding a drag and drop feature to your app. 
What you may not know is that HTML has a native API built-in for making elements in the DOM draggable and droppable. 
Here we'll look at creating a drag and drop feature using the HTML Drag and Drop API with a little vanilla JavaScript to set up the event handlers.

<h3>Overview</h3>
The HTML Drag and Drop API relies on the DOM's event model to get information on what is being dragged or dropped and to update that element on drag or drop. 
With just a few event handlers, you can turn any element into a draggable item or a dropzone.

The Drag and Drop API provides multiple options for customizing your actions beyond just the dragging and dropping. 
For example, you can update the CSS styling of your dragged items. 
Also, instead of just moving the item, you can choose to copy your draggable item so that it gets replicated on drop.

Here we'll focus on the basics of building your drag and drop JavaScript functions to update the DOM directly.

<h3>Making HTML Elements Draggable</h3>
Let's first start with what we want to drag. 
Let's say we have a container with two types of child elements: children that can be dropped and children that can have elements dropped in them. 
For example, if we had a to-do list, we could drag our to-do items to the “done” area. 
(We'll come back to this to-do list example at the end.)

To keep things simple, let's refer to the items being moved as the draggable elements and the target as the “dropzone”.

<style> .example-parent { border: 2px solid #DFA612; height: 4rem; display: flex; justify-content: space-between; color: black; margin-bottom: 10px; font-weight: bold; } .example-draggable { background-color: #4AAE9B; padding: 10px; } .example-dropzone { background-color: #6DB65B; padding: 10px; }</style>
<code>&lt;div class='parent'>
 &lt;span id='draggableSpan'>
   draggable
 &lt;/span>
 &lt;span> dropzone &lt;/span>
&lt;/div></code>

 draggable dropzone

Our first example here is the default and the children are <strong>not</strong> draggable.

So, let's start by explicitly making our draggable element actually draggable. 
To do that we need to use the <code>draggable</code> attribute like so:

<code>&lt;div class='parent'>
 &lt;span id='draggableSpan' draggable='true'>
   draggable
 &lt;/span>
 &lt;span> dropzone &lt;/span>
&lt;/div></code>

 draggable dropzone

Now if you try to move the draggable element with your mouse (sorry mobile visitors! ) you should see a lighter version of the element move with your cursor on drag.

Without setting this <code>draggable</code> attribute to <code>true</code>, the default value is <code>auto</code>. 
This means whether the element is draggable will be determined by your browser's default setting. 
Links (<code>&lt;a></code>), for example, are typically draggable by default. 
<code>span</code>s, however, are not.

<hr>
<h3>Creating Drag and Drop Event Handlers</h3>
Currently, if we release the mouse while dragging the draggable element, nothing happens. 
Not super helpful! To actually trigger an action on drag or drop, we'll need to utilize the Drag and Drop API for a minimum of three events:
<li>
<em><code>ondragstart</code></em>: Set the ID of the element being dragged and make any other changes we want to apply in the drag state.</li><li>
<em><code>ondragover</code></em>: Browsers by default don't trigger actions when a draggable element is dropped. 
We need to intervene here and let the drop actions happen!</li><li>
<em><code>ondrop</code></em>: Whatever is supposed to happen on drop will be triggered here. 
Often the element getting dragged will move to a new parent element in the DOM.</li>

The ondragstart, ondragover, ondrop event handlers are just the start. 
There are actually eight in total: ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, and ondrop. 


<h3>The DataTransfer Interface</h3>
The <em>DataTransfer</em> Interface will keep track of the information related to the current drag happening. 
To update our element on drag and on drop, we need to directly access the DataTransfer object. 
To do this, we can select the <code>dataTransfer</code> property from our DOM event.

The DataTransfer Interface (or object) can technically track information for multiple elements being dragged at the same time. 
For our example, we'll focus on dragging just one element. 


<h3>Updating Our Element on Drag</h3>
In this next step, we'll set up our function <code>ondragstart</code>.

In our <code>ondragstart</code> function we can make whatever changes we'd like to see once the dragging has started. 
You can update the CSS of the element being dragged, make the dragged version a temporary image, and anything else you can think of that can be accessed through the DOM event.

The <code>dataTransfer</code> object's property <code>setData</code> can be used to set the drag state information for your currently dragged element. 
It takes two parameters: a string that declares the format of the second parameter and the actual data being transferred.

Our goal is to move our draggable element to a new parent, so we need to be able to select our draggable element with a unique ID. 
We can set the ID of the dragged element with the <code>setData</code> property so it can be used later like so:

<code>function onDragStart(event) {
 event
   .dataTransfer
   .setData('text/plain', event.target.id);
}</code>

To update the dragged item's CSS styling, we can access its styles using the DOM event again and by setting whatever styles we want for the <code>currentTarget</code>:

<code>function onDragStart(event) {
 event
   .dataTransfer
   .setData('text/plain', event.target.id);

 event
   .currentTarget
   .style
   .backgroundColor = 'yellow';
}</code>

Note: Any styles you change will need to be manually updated again on drop if you want drag-only styles. 
So, if you change anything when it starts dragging, the dragged element will keep that new styling unless you change it back. 


Now that we have our JavaScript function for when dragging starts, we can pass it to our draggable item's <code>ondragstart</code> attribute:

<code>&lt;div class='parent'>
 &lt;span id='draggableSpan'
   draggable='true'
   ondragstart='onDragStart(event);'>
     draggable
 &lt;/span>

 &lt;span> dropzone &lt;/span>
&lt;/div></code>

Here's what dragging will look like in case you don't have a mouse to try it yourself.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6c8a12cc7be91b8682bbfa4c0bbbdfc3161cf7d6/e3d26/images/js/drag-and-drop-vanilla-js/dragnodrop.gif">
If you try to drag your item now, the styling declared in <code>ondragstart</code> will get applied but nothing will happen on drop. 
Let's move on to our dropzone event handlers.

<hr>
<h3>Allowing Droppable Elements</h3>
After <code>ondragstart</code>, our next function to set up is <code>ondragover</code>. 
As mentioned, drop actions get prevented by the browser by default so we need to prevent the browser from preventing our drop action. 
Two prevents equal an allow, right? 

<code>function onDragOver(event) {
 event.preventDefault();
}</code>

All we have to do here is stop the browser from interfering with our drop action. 
We can add this to our dropzone now so it can be a welcoming parent for any draggable elements.

<code>&lt;div class='parent'>
 &lt;span id='draggableSpan'
   draggable='true'
   ondragstart='onDragStart(event);'>
     draggable
 &lt;/span>

 &lt;span ondragover='onDragOver(event);'>
   dropzone
 &lt;/span>
&lt;/div></code>

Even though our dropzone can now accept draggable items, we still haven't said what should actually happen when the mouse is released.

<h3>What To Do On Drop</h3>
Now we can introduce our third and final function: <code>ondrop</code>.

Our steps for this function will be as follows:
<li>Remember the data we set with <code>setData</code>? Now we need to get that data with the <code>dataTransfer</code> object's <code>getData</code> property. 
The data we set was the ID, so that's what will be returned to us.</li><li>Select our draggable element with the ID we retrieved in step one.</li><li>Select our dropzone element.</li><li>Append our draggable element to the dropzone.</li><li>Reset our <code>dataTransfer</code> object.</li>

<code>function onDrop(event) {
 const id = event
   .dataTransfer
   .getData('text');

 const draggableElement = document.getElementById(id);
 const dropzone = event.target;
 
 dropzone.appendChild(draggableElement);

 event
   .dataTransfer
   .clearData();
}</code>

Since this is our third and final function to build, we just need to pass it to the dropzone's <code>ondrop</code> attribute. 
Once that's done, we have a completed drag and drop feature!

<code>&lt;div class='parent'>
 &lt;span id='draggableSpan'
   draggable='true'
   ondragstart='onDragStart(event);'>
     draggable
 &lt;/span>

 &lt;span
   ondragover='onDragOver(event);'
   ondrop='onDrop(event);'>
     dropzone
 &lt;/span>
&lt;/div></code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e01c977b1a23b6e01899af98d1176170582f034a/66910/images/js/drag-and-drop-vanilla-js/draganddrop.gif">
<hr>
Our example here is as basic as it gets to show how to make anything on your page draggable or droppable. 
You can have multiple draggable elements, multiple dropzones, and customize it a bunch with all the other Drag and Drop API event handlers.

Here's one more example of how you could use this API: a simple to-do list as mentioned at the start. 


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/88008a696406bcd7eb077271911baec22de4887e/5f7ff/images/js/drag-and-drop-vanilla-js/todolist.gif">
To replicate this, simply add more draggable elements exactly like we did above. 
Just make sure your IDs are always unique!

<h2>Reasons Why You Should Never Use eval() in JavaScript</h2>

The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval">eval()</a> function has been around for a long time in JavaScript! You likely don't see it often anymore because it's widely agreed that it's harmful to use. 
Let's take a brief look at it, and some of the dangers associated with using it.

The keyword <code>eval</code> is an abbreviation for “evaluate.” The function essentially takes a string with JavaScript code and will evaluate it for you.

<code>eval('2 + 3 + 1');
// 6</code>

You can evaluate a simple expression… Or a bunch of JavaScript code!

<code>var foo = 2;

eval('var bar = 3;\
var baz = 1;\
\
function addStuff() {\
 return foo + bar + baz;\
}\
\
addStuff();\
');
// 6</code>

<h3>Reasons to Avoid Using  <code>eval()</code>
</h3>
Unless you are doing really high-level JavaScript (see below) the risks usually outweigh the benefits of using <code>eval()</code>. 
Here's some of the reasons to avoid using it:
<li>
<em>Malicious code</em>: invoking <code>eval</code> can crash a computer. 
For example: if you use <code>eval</code> server-side and a mischievous user decides to use an <a href="https://stackoverflow.com/questions/24977456/how-do-i-create-an-infinite-loop-in-javascript">infinite loop</a> as their username.</li><li>
<em>Terribly slow</em>: the JavaScript language is designed to use the full gamut of JavaScript types (numbers, functions, objects, etc)… Not just strings! Using <code>eval</code> is orders of magnitude slower than normal JavaScript code.</li>

Considering that <code>eval()</code> is still part of the ECMAScript standard… Are there any appropriate uses for it?

<h3>Legitimate Uses for  <code>eval()</code>
</h3>
There's a small subset of JavaScript development that requires using <code>eval</code>. 
These include: developing template libraries, interpreters, command lines and module systems. 
Most of these types of software development are meta-programming and build tools… Not for the faint of heart! 

<hr>
If you're unsure whether to use <code>eval</code>, try doing a quick search on <a href="https://stackoverflow.com/">StackOverflow</a>. 
There's almost always a better approach! 

<h2>Understanding the JavaScript typeof Operator</h2>

The <code>typeof</code> operator returns a string that indicates the JavaScript type for a given value.

<h3>Usage</h3>
There are two ways to use <code>typeof</code>:

<code>typeof foo;
typeof(foo);</code>

<h3>Examples</h3>
Let's start with easy examples that aren't particularly surprising:

<code>typeof true;      // 'boolean'
typeof false;     // 'boolean'

typeof 3000;      // 'number'
typeof 3.14;      // 'number'
typeof NaN;       // 'number'
typeof Infinity;  // 'number'

typeof 'foobar';     // 'string'
typeof `foobar`;     // 'string'</code>

Simple enough! If you aren't familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures">types in JavaScript</a> it may be a good idea to get familiar with them.

<h3>Arrays and object literals</h3>
For arrays and object literals you simply get “object”:

<code>typeof [1, 2, 'foobar'];   // 'object'
typeof {a: 'foobar'};      // 'object'</code>

“object” is really just a generic label that's used loosely for more sophisticated values in JavaScript.

<h3>Empty values</h3>
Here's where you may scratch your head a bit…

<code>typeof null;       // 'object'
typeof undefined;  // 'undefined' </code>

In JavaScript <code>undefined</code> actually has its own type!

<h3>Constructors</h3>
Since constructors/classes in JavaScript are just functions:

<code>typeof String;           // 'function'
typeof Boolean;          // 'function' 
typeof Number;           // 'function'
typeof Object;           // 'function'
typeof Function;         // 'function'
typeof MyAwesomeClass;   // 'function'  </code>

<h3>Common Uses for  <code>typeof</code>
</h3>
Let's explore some of the ways you might find yourself using <code>typeof</code> in your programming adventures!

<h3>Type-checking for functions</h3>
The practice of type-checking in programming has a very long history and the primary way to do this in JavaScript is by using the <code>typeof</code> operator:

<code>function add(a, b) {

 // perform type-checks...
 if (typeof a !== 'number' || typeof b !== 'number') {
   throw 'Arguments must be a number'
 };

 return a + b;
}</code>

This allows you to ensure that the arguments to the <code>add</code> function are numbers and not something like a string (which would concatenate in JavaScript).

Type-checking in JavaScript produces more stable code because you are defining clear ground rules for interacting with your application.

<h3>Existence Testing</h3>
The other way you might use <code>typeof</code> is to determine the “existence” of a value.

<code>if (typeof window !== 'undefined') {
 // you're programming in JavaScript land!
};

if (typeof process !== 'undefined') {
 // Node.js!
}

if (typeof $ !== 'undefined') {
 // jQuery is available! 
}</code>

<h3>Notes</h3>
<li>The <code>typeof</code> result for primitive values (eg., <code>3000</code>, <code>true</code>, <code>'some string'</code>, <code>undefined</code>) are predictable and, as such, it's advisable that you get familiar with them.</li><li>Most other values you give to <code>typeof</code> will be <em>‘object'</em>. 
This goes for arrays, object literals, and constructors.</li><li>Remember that <code>undefined</code> is its own type of JavaScript. 
While <code>null</code> is of the <em>object</em> type</li>

<h3>Browser Compatibility</h3>
<code>typeof</code> is considered standard in JavaScript so it's very stable across desktop and mobile browsers and has been for a long time.

<h3>ECMA Specs</h3>
<table style="width: 100%;">
<thead><tr>
<th>Name</th>
<th>Specification</th>
<th>Status</th>
</tr></thead>
<tbody><tr>
<td><code>typeof</code></td>
<td><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator" alt="ecma">operator</a></td>
<td>Standard</td>
</tr></tbody>
</table>
<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>

<h2>The New globalThis JavaScript Property</h2>

A new property called <a href="https://github.com/tc39/proposal-global">globalThis</a> gives you cross-platform access to the global object in JavaScript.

Accessing the global property in JavaScript has always posed some difficulty. 
This is because different platforms have different ways to access it.
<li>
<em>Client-side JavaScript</em> uses <code>window</code> or <code>self</code>
</li><li>
<em>Node.js</em> uses <code>global</code>
</li><li>
<em>Web workers</em> use <code>self</code>
</li>

This isn't a huge problem if you're exclusively writing client-side JavaScript. 
You could simply write <code>window</code> to interact with the global object.

However, the problem arises when you need to write <em>portable JavaScript that works on more than a single platform</em> (eg.: a library like <a href="https://www.npmjs.com/package/lodash">lodash</a> which works in both Node.js and client-side).

<hr>
The popular solution is to use a shim that uses code like this to determine the available global object:

<code>var getGlobal = function () { 
 if (typeof window !== 'undefined') {
   return window;  // Client-side JavaScript 
 } 
 if (typeof self !== 'undefined') {
   return self;    // Client-side JavaScript / Web workers
 } 
 if (typeof global !== 'undefined') {
   return global;  // Node.js
 } 
}; 

var __global__ = getGlobal(); 

if (typeof __global__.alert === 'function') { 
 console.log('Client-side land!');
} else {
 console.log('Node.js land!');
};</code>

<h3>Using globalThis</h3>
Since <code>globalThis</code> is available in Node.js/client-side/Web workers, interacting with the global object becomes much simpler!

<code>if (typeof globalThis.alert === 'function') { 
 console.log('Client-side land!');
} else {
 console.log('Node.js land!');
}</code>

Say goodbye to inspecting which platform you're on! 

<h3>Conclusion</h3>
Currently <code>globalThis</code> is a Stage-3 ECMAScript Proposal. 
However, many browsers including Chrome, Firefox, and Safari (desktop/mobile) have already made this new API available!

For in-depth information about <code>globalThis</code> checkout <a href="https://2ality.com/2019/08/global-this.html" alt="2ality">Axel Rauschmayer's</a> blog post 


<h2>Using getBoundingClientRect to Get an Element's Size and Position</h2>

<code>getBoundingClientRect</code>, part of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction#DOM_and_JavaScript">JavaScript DOM</a> (Document Object Model), provides you with important pieces of data about an HTML element's size and positioning.

<h3>Using getBoundingClientRect</h3>
First, some simple markup:

<code>&lt;div id="foo">Hello World&lt;/div></code>

And now let's call <code>getBoundingClientRect</code> on our <em>#foo</em> element:

<code>document.getElementById('foo').getBoundingClientRect();
// =>  {
//       top: Number,
//       left: Number,
//       right: Number,
//       bottom: Number,
//       x: Number,
//       y: Number,
//       width: Number,
//       height: Number,
//     } </code>

<code>getBoundingClientRect</code> returns an object with several fields and gives you sufficient information to infer everything about an HTML Element's size and positioning within a webpage.

Here's an illustration describing what each of the fields mean:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/cc1a6aed4bd775dfc86fb59e2dd90e3d45681cda/087a8/images/js/getboundingclientrect/getboundingclientrect-1.png" width="500" alt="Illustrative example 1">

There's A LOT to chew on in this illustration. 
Take some time to let the info absorb!

Since the <code>x</code> and <code>y</code> values are redundant with <code>left</code> and <code>top</code> (respectively) and some browsers actually omit supplying them… You can sorta pretend like they don't exist . 
It's generally advisable to avoid using them for these reasons.

Another thing to notice is that <code>right</code>/<code>bottom</code> aren't quite what you may be accustomed to in CSS positioning (eg.: when positioning using <em>position: absolute</em>).

<h3>Learning Exercise</h3>
Let's try applying our knowledge! Given the illustration below what would be the output of <code>getBoundingClientRect()</code>?

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/93d16df90ccd69ddbcc25d5e9f898f1f6ae8a426/7d959/images/js/getboundingclientrect/getboundingclientrect-2.png" width="500" alt="Illustrative example 2">

<gator-collapse title="Click for Answer">

<code>{
 top: 450,
 left: 400,
 right: 825,
 bottom: 500,
 x: 400,  // "x" is always equal to "left"
 y: 450,  // "y" is always equal to "top"
 width: 425,
 height: 50
}</code>
</gator-collapse><h3>Notes</h3>
<code>getBoundingClientRect</code> provides a rich amount of data, however the downside is that it can be overwhelming if you haven't used it before.

Here's some tidbits to remember that'll help you!
<li>The <code>bottom</code> and <code>right</code> values in <code>getBoundingClientRect</code> are different than how it's used in CSS positioning.</li><li>Some browsers won't include <code>x</code> and <code>y</code> values so it's advisable to avoid using on them.</li><li>Since <code>getBoundingClientRect</code> is relative to the viewport, you can add <code>window.scrollY</code> and <code>window.scrollX</code> values to the <code>top</code> and <code>left</code> fields (respectively) to get the HTML element's position relative to the entire webpage.</li>

<h3>Browser Compatibility</h3>
<code>getBoundingClientRect</code> is reliably supported on all desktop and mobile browsers (with the exclusion of the <code>x</code> and <code>y</code> values which is unstable in IE/Edge and Safari)

<h3>Specification</h3>
Read the official W3C specs for detailed information about <code>getBoundingClientRect</code>.

<table style="width: 100%;">
<thead><tr>
<th>Name</th>
<th>Specification</th>
<th>Status</th>
</tr></thead>
<tbody><tr>
<td><code>getBoundingClientRect</code></td>
<td><a href="https://drafts.csswg.org/cssom-view/#dom-element-getboundingclientrect" alt="w3c">CSS Object Model (CSSOM) View Module</a></td>
<td>Working Draft</td>
</tr></tbody>
</table>
<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>Drawing Shapes with the JavaScript Canvas API</h2>

In this article we'll be looking at the HTML canvas element and the JavaScript canvas API to render complex shapes onto our web pages.

<h3>Setup</h3>
All we need to start is an HTML page with a canvas tag and a JavaScript file to manipulate it with.

index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
 &lt;head>
   &lt;meta charset="UTF-8"/>
   &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"/>
   &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"/>
   &lt;title>HTML Canvas&lt;/title>
 &lt;/head>
 &lt;body>
     
   &lt;canvas>&lt;/canvas>

 &lt;/body>
 &lt;script src="./canvas.js">&lt;/script>
&lt;/html></code>

With our canvas element in place, we now need to create a new variable with it and a canvas context, which adds a bunch of functionality onto our canvas. 
To keep things simple we'll stick with 2D shapes, but with the <code>webgl</code> context, 3D is also possible.

For our example we'll need our canvas to be fullscreen but setting the size using CSS creates a strange blurry effect, which we obviously don't want, so we'll have to set it here.

canvas.js

<code>// getting a reference to our HTML element
const canvas = document.querySelector('canvas')

// initiating 2D context on it
const c = canvas.getContext('2d')

addEventListener('resize', () => {
 canvas.width = innerWidth
 canvas.height = innerHeight
})</code>

<h3>Rectangles</h3>
To draw rectangles, on our context variable (<code>c</code>), we can start adding what we want, measured in pixels:
<li>
<code>rect(x-axis, y-axis, width, height)</code>: Sets the location and dimensions of our rectangle, and needs to be called before <code>stroke</code> or <code>fill</code>.</li><li>
<code>stroke</code>: Renders an outline of everything before it.</li><li>
<code>fill</code>: Renders the whole shape as a solid color.</li><li>
<code>strokeStyle</code> and <code>fillStyle</code>: Sets the outline and shape color. 
They are not functions like the others and need to be assigned a string.</li><li>
<code>strokeRect</code> and <code>fillRect</code>: Same as <code>stroke</code> and <code>fill</code> but only for that item, works the same as <code>rect</code>.</li><li>
<code>clearRect(x-axis, y-axis, width, height)</code>: Clears everything inside of a certain area. 
Very useful when we get into animations where we're constantly rendering new elements and don't want the old ones to stick around.</li>

canvas.js

<code>c.strokeStyle = 'white'
c.fillStyle = 'blue'
c.rect(100, 20, 150, 100)
c.stroke()
c.fill()

c.fillStyle = 'red'
c.fillRect(400, 500, 300, 250)

// Uncomment to remove the first two blocks
// c.clearRect(0, 0, canvas.width, canvas.height)
c.fillStyle = 'green'
c.fillRect(1500, 500, 300, 250)</code>

<h3>Lines</h3>
<li>
<code>beginPath</code>: Starts a new Line</li><li>
<code>stroke</code>: Renders the line</li><li>
<code>moveTo(x-axis, y-axis)</code>: Sets the starting point</li><li>
<code>lineTo(x-axis, y-axis)</code>: Renders a line from the previous endpoint</li><li>
<code>lineWidth</code>: Set the line's thickness</li>

And here are a few examples where we draw some lines:

<code>// Just a basic line
c.beginPath()
c.moveTo(40, 250)
c.lineTo(200, 500)
c.strokeStyle = 'red'
c.stroke()

// Draw the letter M
c.beginPath()
c.moveTo(1500, 700)
c.lineTo(1600, 450)
c.lineTo(1700, 700)
c.lineTo(1800, 450)
c.lineTo(1900, 700)
c.strokeStyle = 'blue'
c.stroke()

// Let's now draw a house
c.lineWidth = 10
c.strokeStyle = 'red'
c.fillStyle = 'red'

// Walls 
c.strokeRect(800, 500, 300, 200)

// Door
c.fillRect(925, 600, 50, 100)

// Roof 
c.beginPath()
c.moveTo(700, 500)
c.lineTo(1200, 500)
c.lineTo(950, 300)
c.lineTo(700, 500)
c.stroke()</code>

<h3>Circles</h3>
The only method we really need for drawing circles is <code>arc</code>. 
The angles are taken in radians and not degrees so for our end-angle we can just use <code>Math.PI * 2</code>, since that's equal to 360 degrees, and the starting angle can be left at 0. 
We're not going to need to specify a value for <code>counterclockwise</code>, so we can just leave it off since it defaults to false.
<li><code>arc(x, y, radius, starting-angle, end-angle, counterclockwise (boolean))</code></li>
canvas.js

<code>c.lineWidth = 5
c.beginPath()
c.arc(400, 400, 50, 0, Math.PI * 2)
c.stroke()</code>

<h3>Quadratic and Bezier Curves</h3>
If you've ever used graphic design tools like Photoshop or Affinity Designer, these will seem very similar to some of their line tools.

Essentially, quadratic and bezier curves are just free form lines with different methods of control. 
Quadratic curves are simpler in that they just have a start, endpoint, and what's known as the control point, which acts as a handle for curving the line. 
You can see a wonderful interactive example <a href="http://blogs.sitepointstatic.com/examples/tech/canvas-curves/quadratic-curve.html">here</a>. 
Bezier curves, on the other hand, have two control points, at each end of the curve for more complex shapes. 
Another great example <a href="http://blogs.sitepointstatic.com/examples/tech/canvas-curves/bezier-curve.html">here</a>.
<li><code>quadraticCurveTo(controlPoint-x, controlPoint-y, endpoint-x, endpoint-y)</code></li><li><code>bezierCurveTo(startControlPoint-x, startControlPoint-y, endControlPoint-x, endControlPoint-y, endpoint-x, endpoint-y)</code></li>

And some examples:

canvas.js

<code>c.lineWidth = 5
c.strokeStyle = 'white'

c.beginPath()
c.moveTo(400, 400)
c.lineTo(400, 300)
c.quadraticCurveTo(450, 250, 500, 300)
c.lineTo(500, 400)
c.stroke()

c.beginPath()
c.moveTo(800, 400);
c.bezierCurveTo(800, 150, 1200, 700, 1200, 400);
c.stroke()</code>

<h3>Text</h3>
Text works very similarly to rectangles with a few CSS-like options for styling:
<li><code>fillText(text, x, y)</code></li><li><code>strokeText(text, x, y)</code></li><li>
<code>font:</code> Takes a string with the size in pixels and font family; like ‘<code>60px Times-New-Roman</code>'.</li><li>
<code>textAlign</code>: Takes a string with the same options as its CSS counterpart; <code>start</code>, <code>end</code>, <code>left</code>, <code>right</code>, and <code>center</code>.</li>

canvas.js

<code>c.font = '60px Times-New-Roman'
c.fillText("Hello World", 600, 500)
c.strokeText('Hello World', 1200, 500)</code>

<h3>Conclusion</h3>
While there is still an enormous amount that can be done with HTML canvas like animations and interactivity, hopefully this was a good first introduction to some of its possibilities.


<h2>offsetWidth and offsetHeight in JavaScript</h2>

Using <code>offsetWidth</code> and <code>offsetHeight</code> in JavaScript, you're able to get the pixel dimensions of an HTML element. 
The dimensions are calculated using <em>the dimensions of content inside the HTML element</em> along with any <em>padding, borders, and scrollbars (if present).</em>

 The margins of an HTML Element are excluded when computing <code>offsetWidth</code> and <code>offsetHeight</code>

<h3>Using offsetWidth and offsetHeight</h3>
<code>&lt;div id="foo">
 Hello World
&lt;/div></code>

<code>const offsetWidth = document.querySelector('#foo').offsetWidth;
const offsetHeight = document.querySelector('#foo').offsetHeight;</code>

<h3>Learning Exercises</h3>
As an exercise, try calculating the value of <code>offsetWidth</code> and <code>offsetHeight</code> of the HTML element below:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f4f24989b6f745a01d5a6f4901780a2ed799a845/02474/images/js/offsetwidth-and-offsetheight/offsetwidth-offsetheight-1.svg" width="750" alt="offsetwidth offsetheight 1">

<gator-collapse title="Click for Answer">

<code>/**********************************************
**  If the HTML element is &lt;div/>  **
**********************************************/
const offsetWidth = document.querySelector('div#foo').offsetWidth;
const offsetHeight = document.querySelector('div#foo').offsetHeight;
console.log(offsetWidth, offsetHeight);
// --> 255, 140</code>
</gator-collapse><strong>How was it calculated?</strong> Simply add the border, padding, scrollbar, and the content inside the HTML element (ignore the margins!):

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7e2df884d78d67f15c410db9e024c163b84e6c70/8485f/images/js/offsetwidth-and-offsetheight/offsetwidth-offsetheight-2.svg" width="750" alt="offsetwidth offsetheight 2">

<hr>
Let's try another! Try calculating the <code>offsetWidth</code> and <code>offsetHeight</code> of this HTML element:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5535a445d0b268d645c06bdb727e8005e43942a5/cf743/images/js/offsetwidth-and-offsetheight/offsetwidth-offsetheight-3.svg" width="750" alt="offsetwidth offsetheight 3">

<gator-collapse title="Click for Answer">

<code>offsetWidth === 290
offsetHeight === 160</code>
</gator-collapse><h3>Notes</h3>
<li>
<em>Block-level</em>: <code>offsetWith</code> and <code>offsetHeight</code> does NOT work with inline HTML elements (like <code>span</code>, <code>em</code>, or <code>a</code>). 
It'll just return <code>0</code>!</li><li>
<em>Rounded Values</em>: Values are rounded to the nearest integer. 
If you need more precise values use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingoffsetRect">getBoundingoffsetRect()</a>
</li><li>
<em>Read-Only</em>: You can't assign a new value to change the dimensions of the HTML element. 
For example this doesn't do anything: <code>someElement.offsetWidth = 30</code>
</li>

<h3>Browser Compatibility</h3>
<code>offsetWidth</code> and <code>offsetHeight</code> are supported on all major desktop and mobile browsers.

<h3>Specification</h3>
Read the official W3C specs for detailed information about <code>offsetWidth</code> and <code>offsetHeight</code>.

<table style="width: 100%;">
<thead><tr>
<th>Name</th>
<th>Specification</th>
<th>Status</th>
</tr></thead>
<tbody>
<tr>
<td><code>offsetWidth</code></td>
<td><a href="https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetwidth" alt="w3c">CSS Object Model (CSSOM) View Module</a></td>
<td>Working Draft</td>
</tr>
<tr>
<td><code>offsetHeight</code></td>
<td><a href="https://drafts.csswg.org/cssom-view/#dom-htmlelement-offsetheight" alt="w3c">CSS Object Model (CSSOM) View Module</a></td>
<td>Working Draft</td>
</tr>
</tbody>
</table>
<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>clientWidth and clientHeight in JavaScript</h2>

Using <code>clientWidth</code> and <code>clientHeight</code> you're able to get the pixel dimensions of an HTML element. 
The dimensions are calculated using <em>the dimensions of content inside the HTML element, along with the padding.</em>

 Borders, margins, or scrollbars (if present) are excluded when computing <code>clientWidth</code> and <code>clientHeight</code>

<h3>Using clientWidth and clientHeight</h3>
<code>&lt;div id="foo">
 Hello World
&lt;/div></code>

<code>const clientWidth = document.querySelector('#foo').clientWidth;
const clientHeight = document.querySelector('#foo').clientHeight;</code>

<h3>Learning Exercises</h3>
As an exercise, try calculating the value of <code>clientWidth</code> and <code>clientHeight</code> of the HTML element below:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7a8150a16f8d2952645cb22281d29ccf4397a747/6cabd/images/js/clientwidth-and-clientheight/clientwidth-clientheight-1.svg" width="750" alt="clientwidth clientheight example 1">

<gator-collapse title="Click for Answer">

<code>/**********************************************
**  If the HTML element is &lt;div/>  **
**********************************************/
const clientWidth = document.querySelector('div#foo').clientWidth;
const clientHeight = document.querySelector('div#foo').clientHeight;
console.log(clientWidth, clientHeight);
// --> 200, 100</code>
</gator-collapse><strong>How was it calculated?</strong> Simply add the padding, with the content inside the HTML element (ignore the margins and borders):

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1f4fdf6920d1fdf98097d6abb3a2bc8284db19a2/50059/images/js/clientwidth-and-clientheight/clientwidth-clientheight-2.svg" width="750" alt="clientwidth clientheight example 2">

<code>(10 + 50) + 140   // clientWidth === 200
(30) + 70         // clientHeight === 100</code>

Let's try another! Try calculating the <code>clientWidth</code> and <code>clientHeight</code> of this HTML element:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6eedbeeea811607168006e3b413d35cad8c76e37/bab46/images/js/clientwidth-and-clientheight/clientwidth-clientheight-3.svg" width="750" alt="clientwidth clientheight example 3">

<gator-collapse title="Click for Answer">

<code>(10 + 10) + 230   // clientWidth === 250
(30 + 20) + 70    // clientHeight === 120</code>
</gator-collapse><h3>Notes</h3>
<li>
<em>Block-level</em>: <code>clientWidth</code> and <code>clientHeight</code> does NOT work with inline HTML elements (like <code>span</code>, <code>em</code>, or <code>a</code>). 
It'll just return <code>0</code>!</li><li>
<em>Rounded Values</em>: Values are rounded to the nearest integer. 
If you need more precise values use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect">getBoundingClientRect()</a>
</li><li>
<em>Read-Only</em>: You can't assign a new value to change the dimensions of the HTML element. 
For example this doesn't do anything: <code>someElement.clientWidth = 30</code>
</li>

<h3>Browser Compatibility</h3>
<code>clientWidth</code> and <code>clientHeight</code> are supported on all major desktop and mobile browsers.

<h3>Specification</h3>
Read the official W3C specs for detailed information about <code>clientWidth</code> and <code>clientHeight</code>.

<table style="width: 100%;">
<thead><tr>
<th>Name</th>
<th>Specification</th>
<th>Status</th>
</tr></thead>
<tbody>
<tr>
<td><code>clientWidth</code></td>
<td><a href="https://drafts.csswg.org/cssom-view/#dom-element-clientwidth" alt="w3c">CSS Object Model (CSSOM) View Module</a></td>
<td>Working Draft</td>
</tr>
<tr>
<td><code>clientHeight</code></td>
<td><a href="https://drafts.csswg.org/cssom-view/#dom-element-clientheight" alt="w3c">CSS Object Model (CSSOM) View Module</a></td>
<td>Working Draft</td>
</tr>
</tbody>
</table>
<style> table { width: 100%; } table.color-names tr th, table.color-names tr td { font-size: 1.2rem; } table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 0 auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.625rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.5rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>forEach vs for Loops in JavaScript: What's the Difference?</h2>

JavaScript works in funny ways. 
It's a language that provides you several ways of doing something. 
That's also one of its strengths though. 
One example of this is the difference between <code>forEach</code> and <code>for</code> loops.

We'll be taking a look at what each does and why you should choose one or the other!

<h3>The for loop</h3>
The <a href="https://alligator.io/js/for-loops/"><code>for</code> loop</a> is probably one of the first looping mechanisms you learned about when diving into JavaScript.

<code>for (let i = 0; i &lt; 5; i++) {
 console.log(i);
}

// Result:
// 0
// 1
// 2
// 3
// 4</code>

The <code>for</code> loop above takes 3 statements within it:

<ol><li>
<code>let i = 0</code>, which executes before the loop starts</li><li>
<code>i &lt; 5</code>, which is the condition for running the block of code within your loop</li><li>
<code>i++</code>, which runs after each iteration of your loop</li>
</ol>
The result of those three statements is that the <code>for</code> loop executes the code within it, which is <code>console.log(i)</code>. 
Our <code>i</code> starts at 0, and as long as <code>i</code> is smaller than 5, we'll run the code block. 
However, after each loop, we add 1 to our <code>i</code>, as shown by the third statement, <code>i++</code>.

Let's dive into something a little fancier for this <code>for</code> loop. 
Let's assume that we have an array with some objects in it:

<code>const foodArray = [
 { name: 'Burrito' },
 { name: 'Pizza' },
 { name: 'Burger' },
 { name: 'Pasta' }
];</code>

Let's say we wanted to use a <code>for</code> loop to iterate over each object within the <code>foodArray</code>. 
We would alter the condition and use <code>i</code> as the numeric index to access the values within <code>foodArray</code>.

<code>for (let i = 0; i &lt; foodArray.length; i++) {
 console.log(`i value: ${i} | Food Name:`, foodArray[i]);
}

// Result:
// i value: 0 | Food Name: { name: 'Burrito' }
// i value: 1 | Food Name: { name: 'Pizza' }
// i value: 2 | Food Name: { name: 'Burger' }
// i value: 3 | Food Name: { name: 'Pasta' }</code>

<h3>What About forEach?</h3>
Like the <code>for</code> loop, the <code>forEach</code> method can also achieve the same results:

<code>foodArray.forEach((food, index) => {
 console.log(`i value: ${index} | Food Name:`, food);
});

// Result:
// i value: 0 | Food Name: { name: 'Burrito' }
// i value: 1 | Food Name: { name: 'Pizza' }
// i value: 2 | Food Name: { name: 'Burger' }
// i value: 3 | Food Name: { name: 'Pasta' }</code>

<h3>How is that possible?</h3>
The <code>forEach</code> method exists within all arrays. 
In our case, <code>foodArray</code> is an array that inherits all of the various methods from <code>Array.prototype</code>. 
For the <code>forEach</code> method, we pass in a function that will be executed in each iteration.

<h3>Which Should You Use?</h3>
It really comes down to the preference of the developer. 
However, here are some things to consider when choosing between a <code>for</code> loop and the <code>forEach</code> method.

<h3>1. 
forEach keeps the variable's scope to the block</h3>
The good thing about <code>forEach</code> is that the callback function within it allows you to keep that variable within the <code>forEach</code>'s scope. 
If you've assigned a variable outside and re-use it within the <code>forEach</code>, the outside variable retains its value.

<code>const num = 4;
const arr = [0, 1, 2];

arr.forEach(num => {
 console.log(num);
});

// Result:
// 0
// 1
// 2
console.log(num);

// Result:
// 4</code>

Normally, you would try to avoid naming a variable twice like in the example above. 
It's just to make a point!

<h3>2. 
Lower chance of accidental errors with forEach</h3>
When using the <code>forEach</code> method, you're calling on the <code>Array.prototype</code> method in relation to the array directly. 
When you use a <code>for</code> loop, you have to set up a variable to increment (<code>i</code>), a condition to follow, and the actual increment itself.

Based on the example above, let's say that we wrote a <code>for</code> loop like this:

<code>for (let i = 0; i &lt;= foodArray.length; i++) {
 console.log(`i value: ${i} | Food Name:`, foodArray[i]);
}

// Result:
// i value: 0 | Food Name: { name: 'Burrito' }
// i value: 1 | Food Name: { name: 'Pizza' }
// i value: 2 | Food Name: { name: 'Burger' }
// i value: 3 | Food Name: { name: 'Pasta' }
// i value: 4 | Food Name: undefined</code>

I changed my condition from <code>&lt;</code> to a <code>&lt;=</code>. 
Instead of ending at 3, which is less than the length of my array, it goes all the way to 4. 
Since there's nothing in our array at index 4, it returns an undefined. 
This type of off-by-one-bug is a logic error when your iterative loop iterates one more or less than you anticipated.

Using a <code>forEach</code> loop, this can be avoided.

<h3>3. 
forEach is easier to read</h3>
Again, this is down to the discretion of the developer, but here's why I feel that the <code>forEach</code> method is a little cleaner than the <code>for</code> loop.

In a <code>forEach</code> method, we pass each food type within that iteration into the callback. 
A <code>for</code> loop needs you to access the array using a temporary <code>i</code> variable. 
While this might not seem very messy in the beginning, it can get more cluttered when you begin to add more code.

<code>for (let i = 0; i &lt; foodArray.length; i++) {
 let food = foodArray[i];
 console.log(food);
 for (let j = 0; j &lt; food.ingredients.length; j++) {
   let ingredient = food.ingredients[j];
   console.log(ingredient);
 }
}</code>

There's a bit going on in the code above. 
Having to use the temporary <code>i</code> and <code>j</code> variables can add a lot of confusion to your code. 
Here's what it would look like as a <code>forEach</code> instead:

<code>foodArray.forEach((food) => {
 console.log(food);
 food.ingredients.forEach((ingredient) => {
   console.log(ingredient);
 });
});</code>

We've gotten rid of the temporary counter variables and it requires fewer lines of code!

<h3>4. 
You can break out of a for loop earlier</h3>
One main reason why I would use the <code>for</code> loop is if I needed to break out of a loop early. 
If you wanted to only return a certain food in your array, you could use an <code>if</code> statement to check if your criteria matches, and then break out from the loop. 
The <code>forEach</code> method would iterate over each food, which could lead to performance issues.

Here's an example of what the <code>for</code> loop would look like if you broke out of it early:

<code>for (let i = 0; i &lt; foodArray.length; i++) {
 if (foodArray[i].name === 'Pizza') {
   console.log('I LOVE PIZZA');
   break;
 }
}</code>

When we use the <code>break</code> keyword, we can stop the loop from continuing once we've found the condition we were looking for.

<h3>forEach or for Loops, Use Whichever Suits You</h3>
At the end of the day, they're relatively similar performance-wise. 
The only difference is your personal preference and some small case-by-case situations. 
Don't get too hung up on how you reach your solution. 
As long as you can solve the problem at hand, it doesn't matter whether you use <code>forEach</code> or a <code>for</code> loop. 
Solve first, refactor later!

<h2>Best Practices for Debugging JavaScript Code in the Browser</h2>

All developers make mistakes and as a result bugs show up. 
We face bugs constantly and it's essential for programmers to have good debugging skills. 
I'll show you a few principles can make you more efficient in debugging.

<h3>A Few Good Principles of Debugging</h3>
<li>You have to first understand what your code should be doing, determine where issues are and start to debug to verify your assumptions.</li><li>Once you figured out the source of the failure, focus on fixing the cause of the issue.</li><li>When you test your assumptions you'll breakpoints and console logs. 
So don't forget to discard those after you finish debugging.</li><li>And obviously do not debug in production!</li>

<h3>Logging to the Console</h3>
<a href="https://alligator.io/js/console/">console.log</a> is the most common way to check the values of variables at various points in your app's execution. 
But there are a few more ways to display those values in more convenient ways.

Sometimes we have a complex object or array that we want to inspect. 
We can still use <em>console.log(array);</em> but the <em>console.table(array)</em> will display the object as a nice table:

<code>console.table([
 {animal: 'cayman', color: 'green' },
 {animal: 'crocodilian', color: 'yellow-green' }
]);</code>

Will output:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/06a2af85248ede8dbf4397cfb56f539bfad1a2ba/bafaf/images/js/debugging-js-best-practices/console-table.png" width="850" alt="Logging table to the console">

Also we can use <em>console.trace()</em> for logging the exact path to reach that point. 
It will output a stack trace.

<code>function meat(){
 function eggs(){
   console.trace();
 }
 eggs();
} </code>

We'll see in the console something like this:

<code>eggs
meat
&lt;anonymous></code>

You can read the <a href="https://developer.mozilla.org/en-US/docs/Web/API/console">console API documentation</a> for more methods.

<h3>Breakpoints</h3>
Breakpoints are a faster and more hassle-free way to debug your JavaScript code.

One common way to set a breakpoint in your code is to use the <code>debugger</code> statement:

<code>if (someCondition) {
 debugger;
}</code>

When the code hits the <code>debugger</code> statement execution stops, it will launch your browser's developer tools and jump to the line where the <code>debugger</code> statement was found.

It will allow you to pause execution and then step through your code line by line. 
We can observe our code and values stored in variables and see at what point things start to go wrong. 
We can inspect the current state of the code and see exactly where we are in the code.

We can see the <em>Call Stack</em> showing all of the functions that were called up to that point. 
The <em>Scope</em> tab shows all the variables scopes we've got available at the current point and see all of the variables and their values in each scope.

We can add or remove a breakpoints by clicking on the line number. 
When the code is paused we can move through code using arrows. 
By clicking the blue arrow you will move on the next breakpoint or just to the end of the code if there isn't a next breakpoint.

You can press the down arrow to skip into functions or right-facing arrow to step throw the code one line at the time.

And the debugger gives us the exact line of the code we need to go and fix.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/00019f11a20c6133513a9add1b798527ac9ead16/f547d/images/js/debugging-js-best-practices/debugger.jpg" width="850" alt="The debugger statement in action in Chrome DevTools">

<h3>Summary</h3>
I hope this was a helpful little intro to debugging your JavaScript code. 
Always remember that the best debugging tool is your mind and all those techniques won't be helpful if you don't understand what the problem is you're trying to solve.


<h2>Deep Cloning Objects In JavaScript (And How It Works)</h2>

If you plan on coding with JavaScript, you need to understand how objects work. 
They're one of the most important elements of JavaScript and a deep (pun intended ) understanding of objects will always be handy. 
Especially when cloning an object, it isn't as simple as it might seem.

You need to clone an object if you don't want to mutate your original object. 
For example, if you have a function that takes in an object and alters it, you probably don't want to mutate your original object.

Check out this other post on Alligator.io on <a href="https://alligator.io/js/objects-prototypes-classes/">JavaScript objects</a> if you're looking for a quick crash course.

<hr>
So let's create an object in JavaScript:

<code>let testObject = {
 a: 1,
 b: 2,
 c: 3
};</code>

In the above code snippet, we initialize a new object and assign it to the variable <code>testObject</code>. 
Now for most beginners, they'll try to create a copy of this object to manipulate in their code by assigning the <code>testObject</code> to a new variable. 
I've personally been guilty of this for longer than I care to admit.

Below is a code snippet that shows why that won't work.

<code>let testObject = {
 a: 1,
 b: 2,
 c: 3
};

// Creating a new variable that 'copies' our testObject
let testObjectCopy = testObject;

testObject.a = 9;
console.log(testObjectCopy.a);
// This returns a = 9</code>

As shown in the code snippet above, creating the new variable <code>testObjectCopy</code> doesn't actually create a copy of <code>testObject</code>. 
Instead, it's simply referencing the <code>testObject</code>. 
Any changes you make to the assumed copy will reflect in the original object as well.

Looping through the object and copying each property to a new object wouldn't work either.

<code>const copyObject = object => {
 // This is the object that will store the original object's properties
 let copiedObj = {};
 
 for (let key in object) {
   // This copies each property from the original object to the copy object
   copiedObj[key] = object[key];
 }

 return copiedObj;
};

const testObject = {
 a: 5,
 b: 6,
 c: {
   d: 4
 }
};

copyObject(testObject);</code>

There are several issues with the approach above:
<li>
<em>Point 1</em>. 
A loop that copies each property to a new object would only copy enumerable properties on the object. 
Enumerable properties are properties that will show up in <code>for</code> loops and <code>Object.keys</code>.</li><li>
<em>Point 2</em>. 
The copied object has a new <code>Object.prototype</code> method, which is not what you want when you copy an object.</li><li>
<em>Point 3</em>. 
If your object has a property that is an object, your copied object will actually refer to the original instead of creating an actual copy. 
This means that if you change that nested object in the copied object, the original gets changed as well.</li><li>
<em>Point 4</em>. 
Any property descriptors are not copied. 
If you set things like <code>configurable</code> or <code>writable</code> to <code>false</code>, the property descriptors in the copied object will default to <code>true</code>.</li>

<hr>
<h3>So How Can I Copy an Object the Right Way?</h3>
For simple objects that only stores primitive types like numbers and strings, shallow copying methods like the one above will work. 
However, if your object features references to other nested objects, the actual object won't be copied. 
You would only be copying the <em>reference</em>.

For a deep copy, the easiest option is to use reliable external libraries like <a href="https://lodash.com/"><strong>Lodash</strong></a>.

<h3>Using Lodash Clone And Clonedeep</h3>
Lodash comes with two different functions that allow you to do shallow copies and deep copies. 
These are <code>clone</code> and <code>clonedeep</code>. 
The great thing about Lodash is that you can import each function individually, without requiring the entire library into your project. 
This can <em>wildly</em> reduce the size of your dependencies.

<code>const clone = require('lodash/clone'); 
const cloneDeep = require('lodash/clonedeep');

// You could also do:
// const clone = require('lodash.clone');
// const cloneDeep = require('lodash.clonedeep');
// Depends on your style :)</code>

Now to use the <code>clone</code> and <code>clonedeep</code> function, here's some code to try out:

<code>const clone = require('lodash/clone'); 
const cloneDeep = require('lodash/clonedeep');

const externalObject = {
 animal: 'Gator'
};

const originalObject = {
 a: 1,
 b: 'string',
 c: false,
 d: externalObject
};

const shallowClonedObject = clone(originalObject);

externalObject.animal = 'Crocodile';

console.log(originalObject);
console.log(shallowClonedObject);
// The `animal` property in both the originalObject and shallowClonedObject 
// are both changed this way since it's a shallow copy.

const deepClonedObject = clonedeep(originalObject);

externalObject.animal = 'Lizard';

console.log(originalObject);
console.log(deepClonedObject);

// The 'animal' property in the originalObject changes, but for the
// deepClonedObject, it remains as 'Crocodile' since it copied
// the entire object separately instead of copying the reference.</code>

In the above code, we create our object called <code>originalObject</code>, which stores 7 properties with different values in each. 
The property <code>d</code> references our <code>externalObject</code> which has the property of <code>animal</code> and a value of <code>'Gator'</code>.

When we do the <code>clone</code> function from <strong>Lodash</strong>, it creates a shallow copy of the object, which we assign to <code>shallowClonedObject</code>. 
Assigning the <code>animal</code> property in our <code>externalObject</code> a new value will change both the <code>originalObject</code> and the <code>shallowClonedObject</code> because the shallow clone was only able to copy the reference to the <code>externalObject</code>. 
It didn't create a brand new object for itself.

This is where the <code>clonedeep</code> function comes in. 
If you do the same process above for the <code>deepClonedObject</code>, the <code>originalObject</code>'s <code>d</code> property is the only one to change.

 Try it out and see how this can help your code! 

<h2>Create Awesome Background Effects with Particles.js</h2>

By far, one of my favorite libraries for spicing up a landing page is particles.js. 
In a few minutes you can have a sleek and elegant sci-fi look that can completely change the overall feel of the page. 
You can find some amazing examples of what you can create on their <a href="https://vincentgarreau.com/particles.js/">official site</a>.

Since their <a href="https://github.com/VincentGarreau/particles.js/">documentation</a> takes more of a ‘play around and figure it out yourself' approach, this article aims to, hopefully, give more of a structured guide into its uses and capabilities.

So let's get started…

<h3>Installation</h3>
The obvious first step would be to install it through npm:

<code>$ npm install particles.js</code>

Or to just use the CDN in a script tag: <code>https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js</code>

If you use a local installation and get an error saying your file path 'was blocked due to MIME type ("text/html") mismatch (X-Content-Type-Options: nosniff)', then you may need to use the full path to the particles.js file. 
<br><br> Instead use <code>"./node_modules/particles.js/particles.js"</code>

<h3>File Setup</h3>
We only need three files to get started, the expected <code>index.html</code> and <code>app.js</code> with a <code>particles.json</code> file where we'll define how we want the particles configured.

index.html

All we need in our html file is a div with an <em>id</em> of <code>particles-js</code> for the library to hook the canvas onto:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">

&lt;head>
 &lt;meta charset="UTF-8" />
 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />
 &lt;meta http-equiv="X-UA-Compatible" content="ie=edge" />
 &lt;title>Particles&lt;/title>
&lt;/head>

&lt;body>
 &lt;div id="particles-js">&lt;/div>

 &lt;script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js">&lt;/script>
 &lt;!-- Or -->
 &lt;script src="particles.js">&lt;/script>
&lt;/body>
&lt;/html></code>

<h3>app.js</h3>
All we need here is the <code>particlesJS.load</code> function, which takes two arguments: the element you want it to be displayed onto (<code>#particles-js</code>), and the name of the configuration file (<code>particles.json</code>).

<code>particlesJS.load('particles-js', 'particles.json');</code>

<h3>Default Configuration</h3>
Now that the boilerplate's set up, we can start with the fun part. 
Since <code>particles.js</code> has it's own defaults you don't ‘need' to pass anything in besides some open curly brackets.

See the Pen <a href="https://codepen.io/alligatorio/pen/KjvoNz/"> Particles JS Example #1</a> by Alligator.io (<a href="https://codepen.io/alligatorio">@alligatorio</a>) on <a href="https://codepen.io">CodePen</a>.

<hr>
Not too exciting, right? Let's jazz it up a bit.

<h3>Configuration</h3>
The <code>particles.json</code> has two main objects, <code>particles</code> for controlling the look and feel of the particles, and <code>interactivity</code> for handling all of the effects. 
We'll start with manipulating the appearance.

<h3>particles</h3>
The best way to get comfortable with this is probably to just to work down the file and play around with everything.

Note that here I added some comments for extra information, but you'll want to remove those as JSON doesn't support comments.

particles.json

<code>"particles": {
 "number": {
   "value": 50,
   "density": {
     "enable": true,
     "value_area": 700 // Denser the smaller the number.
   }
 },
 "color": { // The color for every node, not the connecting lines.
   "value": "#01579b" // Or use an array of colors like ["#9b0000", "#001378", "#0b521f"]
 },
 "shape": {
     "type": "circle", // Can show circle, edge (a square), triangle, polygon, star, img, or an array of multiple.
     "stroke": { // The border
       "width": 1,
       "color": "#145ea8"
     },
     "polygon": { // if the shape is a polygon
       "nb_sides": 5
     },
     "image": { // If the shape is an image
       "src": "",
       "width": 100,
       "height": 100
     }
 },
 "opacity": {
   "value": 0.7,
   "random": true
 },
 "size": {
   "value": 10,
   "random": true
 },
 "line_linked": {
   "enable": true,
   "distance": 200, // The radius before a line is added, the lower the number the more lines.
   "color": "#007ecc",
   "opacity": 0.5,
   "width": 2
 },
 "move": {
   "enable": true,
   "speed": 2,
   "direction": "top", // Move them off the canvas, either "none", "top", "right", "bottom", "left", "top-right", "bottom-right" et cetera...
   "random": true,
   "straight": false, // Whether they'll shift left and right while moving.
   "out_mode": "out", // What it'll do when it reaches the end of the canvas, either "out" or "bounce".
   "bounce": false, 
   "attract": { // Make them start to clump together while moving.
     "enable": true,
     "rotateX": 600,
     "rotateY": 1200
   }
 }
}</code>

And here's what we get using that configuration:

See the Pen <a href="https://codepen.io/alligatorio/pen/xoLWdY/"> Particles JS Example #2</a> by Alligator.io (<a href="https://codepen.io/alligatorio">@alligatorio</a>) on <a href="https://codepen.io">CodePen</a>.

<h3>interactivity</h3>
The events, <code>onhover</code> and <code>onclick</code>, have 5 modes, or effects, they'll have on the particles. 
Each mode is activated in the <code>events</code> object and configured in the <code>modes</code> object.
<li>
<code>push</code> add more particles</li><li>
<code>remove</code> delete particles (only available on the onclick mode)</li><li>
<code>grab</code> connects lines from every node in a specific radius to your cursor (only available on the onhover mode)</li><li>
<code>bubble</code> node in a specific range will expand and/or change opacity</li><li>
<code>repulse</code> pushes all nodes away to a specific radius</li>

Things start to really get interesting when you pass multiple modes as an array.

particles.json

<code>"interactivity": {
 "detect_on": "canvas",
 // activate
 "events": {
     "onhover": {
       "enable": true,
       "mode": [
         "grab",
         "bubble"
       ]
     },
     "onclick": {
       "enable": true,
       "mode": "push"
     },
     "resize": true
 },
 // configure
 "modes": {
     "grab": {
       "distance": 400,
       "line_linked": {
         "opacity": 0.7
       }
     },
     "bubble": {
       "distance": 600,
       "size": 12,
       "duration": 1,
       "opacity": 0.8,
       "speed": 2
     },
     "repulse": {
       "distance": 400,
       "duration": 0.4
     },
     "push": {
       "particles_nb": 20 // How many you want added
     },
     "remove": {
       "particles_nb": 10
     }
 }
},
"retina_detect": true // No clue what this does, docs don't explain, too scared to remove. ˉ\_(ツ)_/ˉ
}</code>

Here's how it looks, I tried to go for a honeycomb-like look:

See the Pen <a href="https://codepen.io/alligatorio/pen/oreqwP/"> Particles JS Example #3</a> by Alligator.io (<a href="https://codepen.io/alligatorio">@alligatorio</a>) on <a href="https://codepen.io">CodePen</a>.

  While particles.js may not have a place in your daily arsenal of frameworks and libraries, it is undoubtedly a very simple tool for quickly jazzing up any landing page with jaw-dropping effects.


<h2>Master Time Manipulation in JavaScript Using Moment.js</h2>

When I was learning JavaScript, dealing with <a href="https://alligator.io/js/date-object/">time and dates</a> seemed like such an unnecessary hassle. 
Why deal with milliseconds from the first day of 1970? Why put up with a clunky return value like <code>2019-06-24T13:12:41.044Z</code>? Why is there no simple way of formatting or altering dates exactly as we would like? You would think that something as basic as time would have been optimized for ease of use long ago, but alas, that is not the case yet.

Here we are now, stranded, left to pick through the rubble that ECMA has left for us.

But not anymore…

Our savior has come, and it's called <a href="https://momentjs.com/docs/">Moment.js</a>. 
(yes, I'm being overdramatic)

<h3>Installation</h3>
First, we must install it through npm (or Yarn, I won't judge).

<code>$ npm install moment</code>

Or just use the handy CDN here, <code>https://cdn.jsdelivr.net/npm/moment@2.24.0/min/moment.min.js</code>

<h3>Basic Methods</h3>
<li>
<code>moment()</code> Store the desired date as a string or leave empty to save the current time/date</li><li>
<code>format()</code> Configure the date using the character strings below.</li>

<h3>Most Useful Formats</h3>
These are the strings that will be passed into <code>format()</code>. 
As you can tell the short versions tend to represent the shorthand dates and the long versions the longer, more formal versions.
<li>
<code>YY</code> and <code>YYYY</code> for single and four digit years like ‘19' and ‘2019'</li><li>
<code>M</code> and <code>MM</code> for single and double digit months like ‘6' and ‘06'</li><li>
<code>MMM</code> and <code>MMMM</code> for short and long month names like ‘Jan' and ‘January'</li><li>
<code>D</code> and <code>Do</code> for days of the month like ‘23' and ‘23rd'</li><li>
<code>ddd</code> and <code>dddd</code> for short and long forms of the week days like ‘Sun' and ‘Sunday'</li><li>
<code>h</code> for the hour of a 12 hour time system like ‘7'am/pm</li><li>
<code>m</code> for minutes into the current hour like ‘26'</li><li>
<code>s</code> for seconds into the current minute like ‘52'</li><li>
<code>a</code> and <code>A</code> for lower and uppercase AM/PM</li>

<h3>Examples</h3>
If you ever need to include text in the string, escape it with brackets <code>[]</code>. 
Commas, colons, dashes, and other punctuation will work by default and don't need to be escaped.

<code>const moment = require('moment');
const now = moment();

console.log(now.format('MMMM-Do-YYYY'));
// >> June-23rd-2019

console.log(now.format('dddd, MMMM Do YYYY [at] h:m A'));
// >> Sunday, June 23rd 2019 at 7:37 PM

const then = moment('1984-08-21');
console.log(then.format('Do [of] MMMM, YYYY'));
// >> 21st of August, 1984</code>

<h3>Date/Time Manipulations</h3>
We can do a lot more than just store and format dates, we can add or subtract units like years, days, or minutes as we please. 
It doesn't matter if the unit string is plural or not.
<li>
<code>add()</code> Takes the number amount and the unit as a string; <code>now.add(1, 'day')</code>
</li><li>
<code>subtract()</code> Takes the number amount and the unit as a string; <code>now.subtract(5, 'years')</code>
</li>

<h3>Examples</h3>
When you need to do multiple operations you can either chain the functions together like <code>now.add(1, 'year').add(4, 'days')</code> or pass in an object literal like <code>now.add({ years: 1, days: 4 })</code>. 
You can also chain different functions that are being passed in objects, for handling multiple different operations.

<code>const now = moment();

console.log(now.add(5, 'years').subtract(9, 'years').add(4, 'days').format('Do [of] MMMM, YYYY'));
// >> 3rd of July, 2015

console.log(now.add({ years: 6, days: 12 }).subtract({ years: 7 }).format('Do [of] MMMM, YYYY'));
// >> 11th of July, 2018</code>

<h3>Comparisons</h3>
Comparison functions are useful whenever you need to show a dynamic formatted message like ‘edited 1 hour ago' or set up some conditional logic.
<li>
<code>to()</code> and <code>from()</code> Return a formatted string for how distant in time something was or is. 
They essentially do the same thing but differ slightly in the message they return.</li><li>
<code>isBefore()</code>, <code>isAfter()</code>, <code>isBetween</code>, and <code>isSame()</code> return booleans.</li><li>
<code>isSameOrBefore()</code> and <code>isSameOrAfter()</code> return booleans.</li>

<code>const now = moment();
const then = moment('1984-08-21');

console.log(now.to(then));
// >> 35 years ago

console.log(then.to(now));
// >> in 35 years

if (then.isBefore(now)) console.log('this is the future');
// >> this is the future</code>

<h3>Example</h3>
Here's a basic example of what you can build with Moment.js. 
It's just an input that tells you what day of the week the given date falls on (I used a little Materialize css to snazz it up a bit).

See the Pen <a href="https://codepen.io/alligatorio/pen/VJWQBx/"> Day Calculator</a> by Alligator.io (<a href="https://codepen.io/alligatorio">@alligatorio</a>) on <a href="https://codepen.io">CodePen</a>.




<h2>In-Depth Look at How Events Propagate in JavaScript</h2>

A lesser-known fact about JavaScript events is that they actually “propagate” to nearby HTML elements. 
Like throwing a pebble into a pond creates ripples on the surface of the water…

Did you know? Events in JavaScript actually propagate to other HTML elements. 
Let's start with a small example where we apply two separate <em>click</em> listeners:

<code>&lt;div class="wood">
 wood
 &lt;div class="chuck">
   chuck
 &lt;/div> 
&lt;/div></code>

Applying the event listeners…

<code>document
 .querySelector('.wood')
 .addEventListener(
   'click',
   function () { alert('wood') }
 );

document
 .querySelector('.chuck')
 .addEventListener(
   'click',
   function () { alert('chuck') }
 );</code>

Simple enough! Let's click on the innermost element (<code>div.chuck</code>)…

<a href="https://glitch.com/embed/#!/embed/alligator-bubble-capture-1?path=public/index.html">bubble-capture</a>
Whoa! There's actually two browser alerts saying <em>chuck</em> and then <em>wood</em>!

<h3>Event Propagation</h3>
You might have guessed what went wrong. 
The click was actually handled by both event listeners.

<i>“But we only clicked on one of them!”</i>

This is essentially what the term <em>event propagation</em> refers to. 
The click event fires the first listener but it gets greedy, and just keeps climbing  up to the parent and fires every <em>click</em> handler until there aren't any left.

This phenomenon doesn't just occur when you have immediate parent-child HTML elements. 
It'll skip HTML elements that don't even have any event listeners!

<a href="https://glitch.com/embed/#!/embed/alligator-bubble-capture-2?path=public/index.html">bubble-capture</a>

<b> Did you know?</b> Event propagation is the default behavior for all major browser vendors (Chrome/Firefox/Safari/Edge)

<h3>The Fix</h3>
Because event propagation can cause unwanted results, JavaScript provides a method called “stopPropagation.” It's used like this:

<code>document
 .querySelector('.wood')
 .addEventListener(
   'click',
   function (e) {
     e.stopPropagation();
     alert('wood');
   }
 );

document
 .querySelector('.chuck')
 .addEventListener(
   'click',
   function (e) {
     e.stopPropagation();
     alert('chuck');
   }
 );</code>

This effectively contains the <em>click</em> event to one HTML element, and only one click handler fires:

<a href="https://glitch.com/embed/#!/embed/alligator-bubble-capture-3?path=public/index.html">bubble-capture-3</a>

 Voila! It's fixed!

Using <code>e.stopPropagation()</code> is usually considered good practice whenever you use <code>addEventListener</code>. 
It's rather the exception that you want unfettered event propagation.

<hr>
So far, we've only looked at <strong>bubbling</strong> events (the propagation goes up  the HTML tree) because it's the default way that events propagate in JavaScript.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/745497c13ec8c1448f7be4194ba142a9d543b608/a2a2e/images/js/event-propagation-in-javascript/bubbles.svg" width="250" alt="burblin">

<h3>Bubbling vs. 
Capturing</h3>
Events can actually propagate starting at the outermost HTML element, instead of the innermost HTML element that was clicked. 
That's called event capturing.

Let's look at these two diagrams to help illustrate how <strong>bubbling</strong> and <strong>capturing</strong> events differ:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1f98663641f21466c9a230498bdc05cdc0e35a0d/e08a5/images/js/event-propagation-in-javascript/event-bubbling.png" width="600" alt="JavaScript event bubbling">

Clicking on <code>div.chuck</code> triggers its own click handler, before it propagates  upward, hence the term bubbling. 
With capturing events, it actually goes  downward:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/157ca176c3932eff03d956ac0ba72c2221164b69/7a06b/images/js/event-propagation-in-javascript/event-capturing.png" width="600" alt="JavaScript event capturing">

The <em>click</em> event on <code>div.chuck</code> gets “captured” by the outermost HTML parent element (<code>div.wood</code>) because it has its own <em>click</em> handler. 
That fires, then it continues down  the HTML tree firing click handlers until it resolves back to <code>div.chuck</code>.

 Interesting…

<hr>
Luckily, since capturing events is reserved for specific scenarios in JavaScript, you have to explicitly enable it in your event listeners:

<code>document
 .querySelector('.wood')
 .addEventListener(
   'click',
   function (e) { alert('wood') },
   true //  boolean argument 
 );</code>

Try clicking on <code>div.chuck</code> below! You'll see the “wood” then “chuck” alert (I've disabled <code>stopPropagation</code> in this example):

<a href="https://glitch.com/embed/#!/embed/alligator-bubble-capture-4?path=public/index.html">bubble-capture-4</a>

<h3>Conclusion</h3>
Understanding how events naturally propagate in JavaScript is an important step to feeling comfortable using <code>addEventListener</code>. 
In general, it's good practice to use <code>e.stopPropagation()</code> so that you're able to contain propagation. 
You can always remove <code>e.stopPropagation()</code> in scenarios where you want your events to either bubble up or get captured down.

To learn more about JavaScript event propagation visit <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture" alt="mdn">Mozilla Developer Network</a> 


<h2>Data Types in JavaScript</h2>

Every programming language has its own way of representing data.<br> In javascript, there are 7 data types.

<h3>1. 
Number</h3>
Numbers in JavaScript are stored as 64-bit floats, and can be manipulated using the built-in operators.

There are a few noteworthy cases for numbers:
<li>
<em>Largest safe integer</em>: The largest possible integer that can be represented with 100% accuracy is given by <code>Number.MAX_SAFE_INTEGER</code>, and is equal to 2<sup>53</sup> - 1, or <code>9007199254740991</code>. 
Numbers are always signed, so <code>Number.MIN_SAFE_INTEGER</code> gives the minimum safe integer, which is <code>-1</code> times max safe integer.</li><li>
<em>Largest value</em>: The largest possible value than can be stored is given by <code>Number.MAX_VALUE</code>, and is equal to 2<sup>1024</sup> - 1. 
Again, the minimum value is <code>-1</code> times the maximum value.</li><li>
<em>Smallest value</em>: The smallest value greater than 0 is given by <code>Number.MIN_VALUE</code>, and is equal to 2<sup>-1074</sup>, or <code>5e-324</code>.</li><li>
<em>Epsilon</em>: The difference between 1 and the least number greater than 1 is given by <code>Number.EPSILON</code>, and is 2<sup>-52</sup>
</li><li>
<em>Infinity</em>: If a number goes outside the above limit, it will be either <code>Infinity</code> or <code>-Infinity</code>. 
We can check for this case using the function <code>Number.isFinite</code>. 
A few common cases involving Infinity are: <code>1 / 0 == Infinity</code>, and <code>1 / Infinity == 0</code>.</li><li>
<em>NaN</em>: <code>NaN</code> is anything that is “Not a Number”. 
If you attempt to convert an invalid non-number into a number, you will get <code>NaN</code>. 
Instead of throwing an error, any arithmetic operation with <code>NaN</code> will result in <code>NaN</code>. 
We can check if a number is NaN using <code>Number.isNaN</code>.</li>

We can create numbers in a few ways:

<code>const num1 = 123; // Literal declaration
const num2 = Number(123); // Using the Number constructor
const num3 = Number.parseInt("123.45"); // Conversion to integer
const num4 = Number.parseFloat("1.23e2"); // Conversion to float
const num5 = +"123"; // unary conversion to number</code>

We can also perform some basic built-in operations:

<code>const a = 12;
const b = 34;

// addition
a + b; // 46

// subtraction
a - b; // -22

// multiplication
a * b; // 408

// division
a / b; // 0.35294117647058826

// exponentiation
b ** a; // 2386420683693101000

// increment
a++; // 13

// decrement
b--; // 33

// modulus (remainder of the division)
b % a; // 10</code>

There are also some binary operations we can use, but be careful, these truncate both terms to signed integers:

<code>// bit shift left
34 &lt;&lt; 12; // 139264

// bit shift right
257 >> 4; // 16

// unsigned bit shift
-1 >>> 2; // 1073741823

// bitwise or
37 | 12; // 45

// bitwise and
124 &amp; 43; // 40

// bitwise xor
124 ^ 43; // 87

// bitwise not (signed)
~5; // -6</code>

More complicated operations are available through the built-in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math">Math library</a>:

<code>Math.sin((Math.PI * 11) / 3) / Math.sqrt(3); // -0.5</code>

<h3>2. 
String</h3>
Strings are always declared through quotations:

<code>const s1 = "this is a string"; // double quotes
const s2 = 'this is also a string'; // single quotes
const s3 = `this is, once more, a string`; // backticks</code>

Single and double quoted strings are identical in JavaScript. 
Backtick quotes are <a href="https://alligator.io/js/template-literals-es6/">template literals</a>, allowing for extended functionality seen below:

<code>const s4 = ` a
b
 c`; // multiline strings

const tmp = 1 + 2;
const s5 = ` 1 + ${1 + 1} = ${tmp} `; // embedded expressions and variables
s5 === " 1 + 2 = 3 "; // true</code>

Any legal expression can be embedded within the braces in backtick strings, including function calls, variables, and even other strings.

Strings can also be concatenated with the addition operator:

<code>const s6 = "string1" + " " + "string2"; // "string1 string2"</code>

<h3>3. 
Boolean</h3>
Booleans are the logical values, either <code>true</code> or <code>false</code>. 
They are the result of logical comparisons:

<code>const b1 = !false; // true
const b2 = true &amp;&amp; false; // false
const b3 = false || true; // true
const b4 = 123 === "456"; // false
const b5 = 1.23 === 123e-2; // true</code>

<h3>4. 
Symbol</h3>
Symbols are unique values created from string keys. 
Two Symbols created from the same key are not equal.

<code>Symbol("123") === Symbol("456"); // false
Symbol("1") === Symbol("1"); // false

const x = Symbol("abc");
x === x; // true</code>

There is also a Symbol registry which is shared throughout the entire JavaScript process. 
Symbols you create will not occur in the registry. 
Instead, you must retrieve them with <code>Symbol.for</code>. 
If you attempt to retrieve a Symbol that does not exist in the registry, one will be added and all subsequent requests for that key will return that Symbol.

<code>Symbol("123") === Symbol.for("123"); // false
Symbol.for("123") === Symbol.for("123"); // true
Symbol.for("123") === Symbol.for("456"); // false</code>

Lastly, you can check if a Symbol is from the registry with <code>Symbol.keyFor</code>, which will check the registry for a Symbol, and return its key if it exists, and <code>undefined</code> otherwise.

<code>const mySymbol = Symbol("myKey");
const theirSymbol = Symbol.for("myKey");

mySymbol === theirSymbol; // false
Symbol.keyFor(mySymbol); // undefined
Symbol.keyFor(theirSymbol); // "myKey"</code>

<h3>5. 
Object</h3>
Objects are collections of key/value pairs, where the keys are strings and the values can be any type, even other objects. 
Object literals are defined by the list of pairs <code>key: value</code>, comma-separated, enclosed by curly braces.

Values can be accessed from objects with the dot operator followed by the key name, or square brackets enclosing the key as a string.

<code>const myObject = { first: "123", second: 456, third: true };

myObject.first; // "123"

let second = "first";
// Dot accesses must be literal, not variables
myObject.second; // 456

// bracket accesses can be variables
myObject["first"] === myObject[second]; // true

// You can also write onto objects
myObject.first = 12;
myObject["first"]; // 12</code>

<h3>6. 
undefined</h3>
<code>undefined</code> is a global variable which represents the non-existence of data. 
When you attempt to access a key on an Object which does not exist, the result will be <code>undefined</code>.

<code>false === undefined; // false
({ a: "b" }["otherkey"] === undefined); // true</code>

The <code>void</code> keyword can be used to ignore the output of an expression. 
Writing <code>void x</code> or <code>void(x)</code> will evaluate <code>x</code>, and return undefined

<code>function f() {}
undefined === void f(); // true, and f gets called</code>

<h3>7. 
null</h3>
<code>null</code> is used to represent the absence of identity, and can only come from a literal expression.

<code>let x = null;</code>

<code>null</code> is often used to indicate that something may be expected, but is currently unavailable. 
For example, if a database is represented as an object, and keys are added whenever new data is received, the expected keys could be initialized to <code>null</code>. 
That way if a key is accessed, the user knows that there is nothing <em>yet</em>, but the key was correct.

Be careful when comparing <code>null</code> and <code>undefined</code>, as loose inequality will hold between them:

<code>null == undefined; // true
undefined == null; // true
undefined === null; // false</code>

<h2>Optimizing the switch Statement in JavaScript</h2>

The <a href="https://alligator.io/js/switch/">switch statement</a> is indispensable for certain programming tasks. 
In this article, you'll learn how to use <code>switch</code> and hopefully gain the intuition to know when you should use it.

A telltale sign to use <code>switch</code> is when you have a lot of consecutive <code>if/else</code> statements. 
Let's look at an example using <code>if/else</code>, and then we'll look at the <code>switch</code> equivalent for comparison:

<code>let dayIndex = new Date().getDay();
let day;

if (dayIndex === 0) {
 day = 'Sunday';
}
else if (dayIndex === 1) {
 day = 'Monday';
}
else if (dayIndex === 2) {
 day = 'Tuesday';
}
else if (dayIndex === 3) {
 day = 'Wednesday';
}
else if (dayIndex === 4) {
 day = 'Thursday';
}
else if (dayIndex === 5) {
 day = 'Friday';
}
else if (dayIndex === 6) {
 day = 'Saturday';
};

console.log(day); // "Friday"</code>

Did you know? JavaScript doesn't have a native method to get the day of the week!

Using <code>if/else</code> is really verbose, and contains a lot of unnecessary boilerplate that <code>switch</code> can handle with ease:

<code>let dayIndex = new Date().getDay();
let day;

switch (dayIndex) {
 case 0:
   day = "Sunday";
   break;
 case 1:
   day = "Monday";
   break;
 case 2:
   day = "Tuesday";
   break;
 case 3:
   day = "Wednesday";
   break;
 case 4:
   day = "Thursday";
   break;
 case 5:
   day = "Friday";
   break;
 case 6:
   day = "Saturday";
   break;
};

console.log(day); // "Friday"</code>

There's barely any code, and it's refreshingly minimal. 
This is because <code>switch</code> places <em>emphasis on the possible values</em> instead of the <em>conditions for the values</em>.

<h3>Using break</h3>
Since JavaScript will navigate through the entire <code>case</code> branch many times it's advisable to use <code>break</code> to prevent unexpected <code>case</code> matches or to save the engine from having to parse extra code.

<code>switch (dayIndex) {
 case 0:
   day = "Sunday";
   break;
 case 1:
   day = "Monday";
   break;
 case 2:
   day = "Tuesday";
   break;
 case 3:
   day = "Wednesday";
   break;
 case 4:
   day = "Thursday";
   break;
 case 5:
   day = "Friday";
   break;
 case 6:
   day = "Saturday";
   break;
}</code>

In this example, <code>break</code> doesn't actually provide any added safety since <code>case 2</code> can never be <code>case 5</code> (for example) so <code>break</code> is somewhat extraneous. 
This rigorous usage of <code>break</code> seems to be a preferential matter among developers like the usage of semicolons (;). 
Developers that take an explicit approach to programming will use <code>break</code> for every <code>case</code>, while some developers only use <code>break</code> strategically in <code>switch</code>. 
There's a slight performance gain from using it across the board however, because even if there's no chance for another case to be true, at least you won't even have the engine run through the rest of the switch statement.

<h3>The Strategic Use of “break”</h3>
Sometimes you'll actually want your cases to “fall through”. 
Using <code>break</code> for these instances is more of a strategy than a safety measure.

<code>let seasonIndex = new Date().getMonth();
let season;

switch (seasonIndex) {
 case 0:
 case 1:
 case 2:
   season = 'Winter'; // January, February, March
   break;
 case 3:
 case 4:
 case 5:
   season = 'Spring'; // April, May, June
   break;
 case 6:
 case 7:
 case 8:
   season = 'Summer'; // July, August, September
   break;
 case 9:
 case 10:
 case 11:
   season = 'Autumn'; // October, November, December
   break;
}</code>

In this example, the cases are “falling through” and <code>break</code> is used to explicitly exit <code>switch</code> early. 
This allows you to lump several cases together with a single value.

The <code>if/else</code> version would require using lots of <code>||</code> logical operators which doesn't seem as transparent:

<code> if (seasonIndex === 0 || seasonIndex === 1 || seasonIndex === 2) {
  season = 'Winter';
} else if (seasonIndex === 3 || seasonIndex === 4 || seasonIndex === 5) {
  season = 'Spring';
} else if (seasonIndex === 6 || seasonIndex === 7 || seasonIndex === 8) {
  season = 'Summer';
} else if (seasonIndex === 9 || seasonIndex === 10 || seasonIndex === 11) {
  season = 'Fall';
}</code>

<h3>Handling Default Cases</h3>
Another feature of <code>switch</code> is the ability to handle unexpected or generic cases. 
Returning to our first example, we can use <code>default</code> to implement error handling:

<code>let dayIndex = new Date().getDay();
let day;

switch (dayIndex) {
 default:
   day = new Error('Invalid argument: "dayIndex" must be an integer from 0 –> 6');
 case 0:
   day = 'Sunday';
   break;
 case 1:
   day = 'Monday';
   break;
 case 2:
   day = 'Tuesday';
   break;
 case 3:
   day = 'Wednesday';
   break;
 case 4:
   day = 'Thursday';
   break;
 case 5:
   day = 'Friday';
   break;
 case 6:
   day = 'Saturday';
   break;
}</code>

You might have noticed that the <code>default</code> case is placed at the top. 
Not to worry! It'll work as expected because JavaScript will look through all the <code>case</code> branches before it settling on <code>default</code>.

You can also use <code>default</code> for your generic cases:

<code>let beverage = 'Mr. 
Pibb';
let cost;

switch (beverage) {
 default:
   cost = 0.05;
 case 'Pepsi':
   cost = 1.00;
   break;
 case 'Coca-Cola':
   cost = 1.00;
   break;
 case 'Dr. 
Pepper':
   cost = 2.00;
   break;
 case 'Moutain Dew':
   cost = 5.00;
   break;
}

console.log(cost); // 0.05</code>

This ensures you'll get some sorta value from <code>switch</code> even if it doesn't match any of your defined <code>cases</code>.

<h3>Conclusion</h3>
Switch statements are an elegant alternative when you find yourself writing a lot of consecutive <code>if/else</code> statements. 
Even though you may not use <code>switch</code> as often as, say, a <code>for-loop</code> there's no substitute when you need it. 
Modern libraries libraries like <a href="https://github.com/lodash/lodash/search?q=switch&amp;unscoped_q=switch">Lodash</a> and <a href="https://redux.js.org/basics/usage-with-react#implementing-container-components">Redux</a> still use <code>switch</code> today, making it one of those old-school workhorse features of JavaScript you'll always need to keep under your belt.

To learn more about <code>switch</code> visit the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch" alt="mdn">Mozilla Developer</a> website.

<h2>What's new in ECMAScript 2019 (ES2019) / ES10</h2>

<strong>ECMAScript</strong> (ES for short) is a scripting language specification standardized by ECMA International in ECMA-262 and ISO/IEC 16262. 
It was created to standardize the JavaScript language, so as to foster multiple independent standard implementations from browser vendors. 
It evolves every year with new features.

The 2019 edition of the ECMAScript specification saw the addition of many new features, and here I'll cover some of these new features. 
I personally love how javaScript keeps evolving and improving on a regular basis.

<h3>Array.flat()</h3>
<code>Array.flat()</code> returns a new array with any sub-array(s) flattened. 
A call to <code>Array.flat()</code> without any arguments will only flatten one-level deep. 
An optional depth argument can be provided or it can just be called consecutively.

<h3>Examples:</h3>
<code>let arr = [1, 2, 3, [4, 5, 6, [7, 8, 9, [10, 11, 12]]]];

arr.flat(); // [1, 2, 3, 4, 5, 6, Array(4)];

arr.flat().flat(); // [1, 2, 3, 4, 5, 6, 7, 8, 9, Array(3)];

arr.flat(3); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]

// Or, if you're not sure about the depth of the array:
arr.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</code>

<h3>Array.flatMap()</h3>
The <code>flatMap()</code> method is identical to the ES6 map method, but also flattens at the same time. 
The <code>flatMap()</code> method first maps each element using a mapping function, then flattens the result into a new array. 
<code>flatMap()</code> is often quite useful, as merging both into one method is slightly more efficient.

<h3>Examples:</h3>
<code>let arr = [1, 2, 3, 4, 5];

arr.map(x => [x, x * 2]);
// [Array(2), Array(2), Array(2)]
// 0: (2)[1, 2]
// 1: (2)[2, 4]
// 2: (2)[3, 6]

arr.flatMap(v => [v, v * 2]);
// [1, 2, 2, 4, 3, 6, 4, 8, 5, 10]</code>

<h3>String.trimStart() &amp; String.trimEnd()</h3>
<code>String.trimStart()</code> can be used to trim white space from the start of a string.

<h3>Examples:</h3>
<code>let  greeting =  "    Hello everyone";

console.log(greeting.trimStart());
// "Hello everyone"</code>

<code>let greeting = "Hello world    ";

console.log(greeting.trimEnd());
// "Hello world"</code>

<h3>Optional Catch Binding</h3>
Optional catch binding allows developers to use try/catch without the error parameter inside the catch block.

<h3>Examples:</h3>
Before ES2019 we use:

<code>try {
 // some code
}
catch (err) {
 // error handling code
}</code>

Now we can use try/catch like this with ES2019:

<code>try  {
 // some code
}
catch {
 // error handling code
}</code>

<h3>Object.fromEntries()</h3>
It creates an object or transforms key-value pairs into an object. 
It only accepts <a href="https://alligator.io/js/iterables/">iterables</a> e.g: <code>Object.fromEntries(someIterable)</code>.

<h3>Examples:</h3>
<code>let entries = new Map([["name", "john"], ["age", 22]]);

console.log(Object.fromEntries(entries));
// { name: 'john', age: 22 }</code>

<h3>Symbol.description</h3>
The read-only description property is a string returning the optional description of Symbol objects.

<h3>Examples:</h3>
<code>let mySymbol = `My Symbol`;

let symObj = Symbol(mySymbol);

console.log(symObj) // Symbol(mySymbol);

console.log(String(symObj) === `Symbol(${mySymbol})`); // true

console.log(symObj.description); // "My Symbol"</code>


<h2>Introduction to Visual Testing for Web Apps</h2>
 Sponsored 

<a href="https://percy.io/visual-testing?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Visual testing</a> (sometimes called visual regression testing or UI testing) is the process of reviewing software for purely visual integrity. 
Unlike the tools you use to make sure your app is behaving as intended, visual testing is all about what your users actually see and interact with.

It works by comparing snapshots of your UI against baselines to see if pixels have changed. 
By looking at the pixels rather than the code underneath, visual testing makes it easy to see exactly what your UI looks like before deploying and to catch visual regressions.

Visual testing is more than snapshot testing—having a visual review workflow to get continuous visual coverage is crucial. 
With Percy, it's easy to integrate visual testing into your stack to in tandem with your CI/CD pipeline on every pull request.

<hr>
Now that you have an overview of how visual testing works, we're going to walk through a 5-minute tutorial.

This is what we'll cover:

<ol><li>Integrating Percy with an example web application (or your own)</li><li>Running your first visual tests</li><li>Making and reviewing visual changes</li><li>Adding visual reviews to your day-to-day workflow</li>
</ol>
Let's get started!

<hr>
<h3>Step 1: Integrate Percy</h3>
If you haven't already, <a href="https://percy.io/signup?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">sign up for a free Percy account</a>, name your organization, and create your first project.

<img class="lazy" data-src="https://user-images.githubusercontent.com/11337387/58920700-4b937380-86e8-11e9-90e8-074ceca9e732.png" width="850" alt="Setting up your Percy project">

Signing up for a Percy account is free and includes 5,000 snapshots each month with upgrades starting at $29 available.

Percy projects correspond with the apps, sites, or component libraries you want to test. 
With <a href="https://docs.percy.io/docs/sdks?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">our SDKs</a> you can add visual testing to virtually anything that renders in a browser.

These are some of our popular SDKs:
<li><a href="https://docs.percy.io/docs/cypress?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Cypress</a></li><li><a href="https://docs.percy.io/docs/puppeteer?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Puppeteer</a></li><li><a href="https://docs.percy.io/docs/ember?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Ember web apps</a></li><li><a href="https://docs.percy.io/docs/capybara?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Capybara for Ruby apps</a></li><li><a href="https://docs.percy.io/docs/storybook?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Storybook for React</a></li>

For this tutorial, we'll use <a href="https://docs.percy.io/docs/percyscript?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">PercyScript</a>—the easiest and fastest way to get started with visual testing for any web app. 
We're going to use this <a href="https://github.com/percy/example-todomvc" rel="sponsored">TodoMVC example app</a>, although you can easily adapt the PercyScript below to work for your own application.

First, let's setup the example app:

<code>$ git clone https://github.com/percy/example-todomvc.git
$ cd example-todomvc/
$ npm install
$ npm run start</code>

You can now visit <a href="http://localhost:8000">http://localhost:8000</a> and play around with the todos app yourself.

Next, we're going to install PercyScript and write our first visual tests for this application.

It's important to keep the server running and open a new terminal to run:

<code>$ npm install -D @percy/script</code>

This will add <code>@percy/script</code> to your <code>package.json</code> file.

Next, create a file named <code>snapshots.js</code> and add your first PercyScript:

<code>// snapshots.js
const PercyScript = require('@percy/script');

// A script to navigate our app and take snapshots with Percy.
PercyScript.run(async (page, percySnapshot) => {
 await page.goto('http://localhost:8000');
 await percySnapshot('TodoMVC home page');

 // Enter a new to-do.
 await page.type('.new-todo', 'A really important todo');
 await page.keyboard.press('Enter');
 await percySnapshot('TodoMVC with a new todo', { widths: [768, 992, 1200] });
});
</code>

That's it! The next step is to start running this PercyScript.

<h3>Step 2: Run Visual Tests</h3>
To run your PercyScript locally, copy the <code>PERCY_TOKEN</code> environment variable from the new project screen or your project settings, then run:

<code>$ export PERCY_TOKEN=aaabbbcccdddeee
$ npx percy exec -- node snapshots.js</code>

Replace the token with your project's `PERCY_TOKEN`.

You should see output like:

<code>$ npx percy exec -- node snapshots.js
[percy] created build #1: https://percy.io/test/example-todomvc/builds/1738842
[percy] percy has started.
[percy] snapshot taken: 'TodoMVC home page'
[percy] snapshot taken: 'TodoMVC with a new todo'
[percy] stopping percy...
[percy] waiting for 2 snapshots to complete...
[percy] done.
[percy] finalized build #1: https://percy.io/test/example-todomvc/builds/1738842</code>

What's happening behind the scenes? Percy works by capturing the DOM snapshot everywhere the Percy snapshot command is called. 
We then recreate the page or component in our <a href="https://docs.percy.io/docs/percy-platform-basics#section-snapshot-rendering-and-asset-discovery?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">custom rendering environment</a>. 
New snapshots are compared against <a href="https://docs.percy.io/docs/baseline-picking-logic?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">baseline snapshots</a> to determine which pixels have changed.

If you're following along, you'll see that since this is the first build, there isn't anything to compare it to. 
It has also been “auto-approved” because the commit was on master and we assume that master builds are production-ready.

<h3>Step 3: Review Visual Changes</h3>
Now that you're integrated and have pushed your first build establishing your baseline, let's make a new feature branch and introduce a visual change to review in Percy.

Use your text editor to edit <code>index.html</code> and make the h1 text on line 11 purple:

<code>&lt;h1 style=”color:#9e66bf;”></code>

Now run the snapshots again:

<code>$ npx percy exec -- node snapshots.js</code>

Head back to Percy or click the Percy build link to see the visual changes! On the right, you'll see the new snapshot, overlaid with red pixels highlighting the areas that have changed.

<img class="lazy" data-src="https://user-images.githubusercontent.com/11337387/58920703-4c2c0a00-86e8-11e9-9c23-a2490747dcdf.png" width="850" alt="Percy UI showing a snapshot comparison">

<em>Clicking that area (or pressing “d”) will toggle between the underlying snapshot and the overlaid diff so you can easily see what exactly has changed.</em>

<h3>Responsive diffs</h3>
You can also use Percy to get coverage across all the most important viewport sizes. 
By default, we render snapshots for mobile and desktop widths. 
Toggle between widths to see what has changed across each.

<h3>Cross-browser visual testing</h3>
Cross-browser snapshots help you detect subtle differences caused by browser rendering.

If you're happy with your changes, hit “Approve All” — knowing with 100% confidence what visual changes you'll be deploying. 
By default, Percy renders all snapshots across both Chrome and Firefox.

Since you wanted to make these changes, hit “Approve All.”

You've done your first visual review!

<h3>Step 4: CI and Source Code Integrations</h3>
To get the most value out of automated visual testing, we recommend integrating with your existing dev tools and processes.

Percy is designed to run alongside your CI builds as part of your code review process. 
For more in-depth instructions and to see all of our supported CI services, check out our <a href="https://docs.percy.io/docs/ci-setup?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">CI setup documentation</a>. 
Here are a few of our most popular supported services:
<li><a href="https://docs.percy.io/docs/circleci?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">CircleCI</a></li><li><a href="https://docs.percy.io/docs/buildkite?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Buildkite</a></li><li><a href="https://docs.percy.io/docs/codeship?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Codeship</a></li>

With a <a href="https://docs.percy.io/docs/source-code-integrations?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">source code integration</a> enabled, you will be notified right in your pull or merge request when visual changes are detected, and when those changes are approved and ready to merge.

<img class="lazy" data-src="https://user-images.githubusercontent.com/11337387/58920806-a2994880-86e8-11e9-8677-1c302f580c9d.png" width="850" alt="GitHub pull request with Percy status update showing visual changes detected">

Clicking “Details” will take you right to the Percy build where you can review visual changes.

After snapshots are approved, your commit status will change to green and the PR can be merged.

<img class="lazy" data-src="https://user-images.githubusercontent.com/11337387/58920822-b5138200-86e8-11e9-828d-f5982b85cc19.png" width="850" alt="GitHub pull request with Percy status update ready to merge">

That's it! You're ready to merge with confidence that every part of your app looks exactly like it should.

<hr>
We hope this tutorial has helped you get acquainted with Percy's visual review platform and workflow. 
To continue learning about how Percy works, feel free to check out these additional resources:
<li><a href="https://docs.percy.io/docs/getting-started?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Getting started with Percy</a></li><li><a href="https://docs.percy.io/docs/visual-testing-basics?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Visual testing basics</a></li><li><a href="https://docs.percy.io/docs/sdks?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">Percy SDKs</a></li>

And if you haven't already, <a href="https://percy.io/pricing?utm_source=alligatorio&amp;utm_medium=sponsored-post&amp;utm_campaign=190611all" rel="sponsored">sign up for a free Percy account</a>. 
You get 5,000 free monthly snapshots and access to our visual testing platform and integrations.

 Happy testing!


<h2>Working with Singletons in JavaScript</h2>

The Singleton is one of the most well known and hated design patterns amongst developers. 
It is very easy to implement a basic version of the singleton pattern (probably why it's abused so much). 
In this article, we'll take a look at what singletons are and how to best implement them in JavaScript.

There are times when you need to have only one instance of a class and no more. 
It could be some kind of resource manager, one that maintains I/O ports of your application or some global lookup for values. 
That's where singletons come in.

Singletons are used to create an instance of a class if it does not exist or else return the reference of the existing one. 
In other words, Singletons are created exactly once during the runtime of the application in the global scope.

You might ask, why use singletons in a language with global variables? They don't seem very different from global variables (or static ones), and most regard them as “glorified globals”. 
JavaScript in particular has that difference very very blurred, because the following code…

<code>var Alliagator = {
 color: "green", 
 getColor: function() { 
   console.log(color);
 };
}</code>

Is technically a singleton object, since it's an object literal - which means that the object with that name is unique throughout the application (since it can't be redeclared).

This seems to have a lot in common with global variables in JavaScript as well. 
So what's the difference?
<li>For starters, global variables are lexically scoped whereas singletons are not, meaning if there is another variable with the same name as the global variable inside a programming block, then that reference is given priority; In case of singletons, being sort of static in declaration, should not have that reference redeclared.</li><li>The value of a singleton is modified through methods.</li><li>The singleton is not freed until the termination of the program, which is likely not the case for a global variable.</li>

An interesting advantage of a singleton is that it's thread-safe. 
While that feature is not really applicable to Javascript, this comes in handy in languages like C++. 
This is just a case to prove the point that it's not really weird to go for singletons even in a language that supports global variables.

There are scenarios where singletons are handy. 
Some applications of singletons are logger objects or configuration settings classes.

A quick way to declare a singleton would be:

<code>// Declare them like this
var SingletonInstance = { 
method1: function () { ... 
}
method2: function () { ... 
} 
};

// and use them as such
console.log(SingletonInstance.method1());
console.log(SingletonInstance.method2());</code>

While this may be the easy way, it's not necessarily the best. 
Another way would be to use factory classes that allows us to create a singleton once.

<code>var SingletonFactory = (function(){
 function SingletonClass() {
   // ...
 }
 var instance;
 return {
   getInstance: function(){
     // check if instance is available
     if (!instance) {
       instance = new SingletonClass();
       delete instance.constructor; // or set it to null
     }
     return instance;
   }
 };
})();</code>

This is better than the last example because the class definition is private and the constructor is deleted after the first instance creation, which helps us prevent duplicate singletons in the program. 
But the above approach looks a lot like the factory pattern.

Perhaps the cleanest approach is to use a combination of ES6 <a href="https://alligator.io/js/objects-prototypes-classes/">classes</a>, <a href="https://alligator.io/js/const-vs-obj-freeze/"><code>const</code> and <code>Object.freeze()</code></a>:

<code>class Singleton {
 constructor(){
  ...
 }

 method1(){
   ...
 }

 method2(){
   ...
 }
}

const singletonInstance = new Singleton();
Object.freeze(singletonInstance);</code>

We can go a little further and write this singleton in a module and then export it with the <a href="https://alligator.io/js/modules-es6/#exporting">ES6 export</a> functionality.

<code>export default singletonInstance;</code>

Then use that singleton by importing it:

<code>import mySingleton from './path-to-my-singleton-definition.js'; 
mySingleton.method_1() // Now use your singletons</code>

So take your pick, find which approach works best for your application and puts readability first.

<h3>Conclusion</h3>
It's quite likely that you will run into overwhelming online literature on how singletons are bad for object oriented designs. 
The idea is to use singletons where it doesn't affect the state of the application, because if you fail to follow, then testing goes right out the window. 
This severely limits their usage in big applications. 
Most developers agree that global state is bad, but they love them too much to look at its bad sides while others go extreme lengths to avoid using global states. 
Whether singletons are good or bad, understanding this fundamental design pattern and adding it to your programming toolkit is always a wise idea.

<h2>const vs Object.freeze() in JavaScript</h2>

One of the most common uses of an object is to hold states - like configuration values or constants used by your application.

They are usually globals (which eliminates the need to pass them around as function parameters) but globals are not safe if they can be changed by functions that have access to them. 
Let's see why -

<code>var canAlligatorsFly = false;

function isItFlying() {
canAlligatorsFly = true;

if (canAlligatorsFly) {
 console.log("Yeah I'm flying");
} 

isItFlying(); // Yeah I'm flying</code>

The function <code>isItFlying()</code> has access to the global variable and has the ability to assign a new value to <code>canAlligatorsFly</code>, enabling them to fly which is a terrible idea. 
How to we prevent this “reassignment of value” to a variable?

The go-to variable type for these kinds of situations is the <code>const</code>. 
The <code>const</code> prevents reassignment of value to a variable after it has been declared once in the program.

<code>const alligatorColor = "green";

function getMyColor() {
alligatorColor = "yellow"; // This part throws an error

return alligatorColor;
}</code>

The error reads as “TypeError: Assignment to constant variable.” It appears that <code>const</code> has rendered the <code>alligatorColor</code> immutable.

Or has it? Let's find out.

<code>const reptiles = ['alligators', 'crocs'];

reptiles.push('snakes');

console.log(reptiles); // ['alligators', 'crocs', 'snakes']</code>

Looks like the value inside <code>reptiles</code> has been changed. 
So that means that <code>const</code> does not make the <i>value</i> of the variable immutable but instead makes the <i>binding</i> of the variable immutable. 
This means that reassignment of the variable is not allowed but the value referenced by the <code>const</code> variable can still be subject to change. 
That's why we were able to change the value of the array in the above example without suffering a <code>TypeError</code>.

How does <code>const</code> extend to objects now that we know that it's the binding that's immutable and not the value? Let's do that -

<code>const alligator = {
 canItFly : false
};

alligator.canItFly = true;
console.log(alligator.canItFly); // true</code>

Welp. 
Now that's not very good for us if we plan to use globals for state management in our program. 
We need to have the object be immune to the changes to its properties.

Here's where <a href="https://alligator.io/js/dealing-with-objects/#bonus-objectfreeze">Object.freeze()</a> comes into play. 
<code>Object.freeze()</code> prevents modification or extension to the existing value of an object.

<code>let alligator = {
 canItFly : false
};

Object.freeze(alligator);
alligator.canItFly = true;

console.log(alligator.canItFly); // false, the value is not modified</code>

A quick note though, Object.freeze does allow reassignment:

<code>let alligator = {
 canItFly : false
};

Object.freeze(alligator);
alligator = { pi: 3.14159 };

console.log(alligator) // {pi: 3.14159}</code>

So to sum it up:
<li>
<code>const</code> makes the variable binding immutable but it's value can still be modified.</li><li>
<code>Object.freeze()</code> ignores the value modification to an object but there is no restriction on the binding.</li>

What if we used the two in unison?

<code>const alligator = {
 canItFly : false
};

Object.freeze(alligator);
alligator.canItFly = true; // This is ignored
alligator = {pi: 3.14}; // This will throw an TypeError

console.log(alligator); // {canItFly: false}</code>

The above example shows the conjunction of <code>const</code> and <code>Object.freeze()</code> and is a very useful programming design in JavaScript. 
This will come in handy while we are learning about Singletons later.


<h2>How to use Axios with JavaScript</h2>

<a href="https://github.com/axios/axios">Axios</a> is an open source library that allows us to easily make HTTP requests. 
It's effectively just <code>fetch</code> with extra superpowers!

Let's see this in action by creating a new HTML5 project:

<code># Create directory with a name of your choosing
$ mkdir axios-js &amp;&amp; cd axios-js

# Create files
$ touch index.html app.js

# Initialise a new npm project
$ npm init -y

# Install Axios
$ npm i axios -S

$ npm i parcel-bundler -D

# Open this up in your editor
$ code .</code>

NOTE: Axios can also be added via a CDN like so: <code>&lt;script src="https://unpkg.com/axios/dist/axios.min.js">&lt;/script></code>

As you may be able to see from our <code>npm install</code> calls, we'll be using <a href="/tooling/parcel/">Parcel</a> to bundle and serve our code. 
We can add an <code>npm</code> script for this by heading over to <code>package.json</code>:

<code>{
 "scripts": {
   "dev": "parcel index.html",
   "build": "parcel build index.html"
 }
}</code>

As we'll be using <code>async</code> and <code>await</code> inside of our project, we'll install Babel and the <code>@babel/polyfill</code> package:

<code>$ npm i @babel/core @babel/polyfill</code>

Start your project by running <code>npm run dev</code> in your terminal and navigate to <code>http://localhost:1234/</code>. 
We can then update <code>index.html</code> with our <code>app.js</code> and some minor semantics:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
 &lt;meta charset="UTF-8">
 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
 &lt;meta http-equiv="X-UA-Compatible" content="ie=edge">
 &lt;title>Vanilla Axios&lt;/title>

 &lt;style>
   body {
     background-color: #673AB7;
     color: white;
   }
   ul {
     list-style: none;
   }
 &lt;/style>
&lt;/head>
&lt;body>

 &lt;div>
   &lt;h1>Todos&lt;/h1>
   &lt;ul>
     
   &lt;/ul>
 &lt;/div>
 &lt;script src="app.js">&lt;/script>

&lt;/body>
&lt;/html></code>

<h3>GET</h3>
Inside of <code>app.js</code>, let's make a function that allows us to <code>GET</code> Todos from an API. 
We'll be using the <a href="https://jsonplaceholder.typicode.com">JSON Placeholder API</a> for our example.

<code>import axios from 'axios';

const BASE_URL = 'https://jsonplaceholder.typicode.com';

const getTodos = async () => {
 try {
   const res = await axios.get(`${BASE_URL}/todos`);

   const todos = res.data;

   console.log(`GET: Here's the list of todos`, todos);

   return todos;
 } catch (e) {
   console.error(e);
 }
};</code>

Axios almost makes it almost <em>too simple</em> to get data from a server, which is great news for us. 
Simply pass <code>axios.get</code> the <code>BASE_URL</code> and you'll get a <code>response</code> object back.

This includes information about our response including things like <code>headers</code>, <code>status</code>, <code>config</code> and most importantly, <code>data</code>.

We can extend our application to now add this data to the DOM:

<code>const createLi = item => {
 const li = document.createElement('li');

 li.appendChild(document.createTextNode(item.title));

 return li;
};

const addTodosToDOM = todos => {
 const ul = document.querySelector('ul');

 if (Array.isArray(todos) &amp;&amp; todos.length > 0) {
   todos.map(todo => {
     ul.appendChild(createLi(todo));
   });
 } else if (todos) {
   ul.appendChild(createLi(todos));
 }
};

const main = async () => {
 addTodosToDOM(await getTodos());
};

main();</code>

<h3>POST</h3>
We can add Todos to our API by capturing some information about it inside of a <code>form</code> and <code>input</code>:

<code>&lt;div id="new-todos">
 &lt;h1>New Todo&lt;/h1>
 &lt;form>
   &lt;label>
     Name
     &lt;input type="text" id="new-todos__name" />
   &lt;/label>
   &lt;label>
     userId
     &lt;input type="text"  id="new-todos__userId" />
   &lt;/label>
   &lt;button type="submit">Add&lt;/button>
 &lt;/form>
&lt;/div></code>

We can then add the Todo by listening for the <code>submit</code> event:

<code>const form = document.querySelector('form');

const formEvent = form.addEventListener('submit', async event => {
 event.preventDefault();

 const title = document.querySelector('#new-todos__title').value;
 const userId = document.querySelector('#new-todos__userId').value;

 const todo = {
   title,
   userId
 };

 const addedTodo = await addTodo(todo);
 addTodosToDOM(addedTodo);
});</code>

We'll need to create the <code>addTodo</code> function inside of <code>app.js</code>. 
The major difference between this and the <code>get</code> example is that we're adding the <code>todo</code> payload.

<code>export const addTodo = async todo => {
 try {
   const res = await axios.post(`${BASE_URL}/todos`, todo);
   const addedTodo = res.data;

   console.log(`Added a new Todo!`, addedTodo);

   return addedTodo;
 } catch (e) {
   console.error(e);
 }
};</code>

<h3>DELETE</h3>
What good is a Todo list if we can't delete items? Let's add that functionality. 
We can create a <code>deleteTodo</code> function inside of <code>app.js</code>:

<code>export const deleteTodo = async id => {
 try {
   const res = await axios.delete(`${BASE_URL}/todos/${id}`);
   console.log(`Deleted Todo ID: `, id);

   return res.data;
 } catch (e) {
   console.error(e);
 }
};</code>

Within our <code>createLi</code> function we can attach an <code>onclick</code> event which handles the removal of our Todo when it's clicked. 
The <code>DELETE</code> method requires an <code>id</code> to be passed as a parameter, so we can also add an <code>id</code> to each element at this stage.

<code>const createLi = item => {
 const li = document.createElement('li');

 li.id = item.id;
 li.appendChild(document.createTextNode(item.title));

 // Remove LI on click
 li.onclick = async e => await removeTodo(e, li);

 return li;
};</code>

Inside of <code>removeLi</code> we can remove the Todo from the DOM and then call <code>deleteTodo</code> with the ID:

<code>const removeTodo = async (e, li) => {
 e.target.parentElement.removeChild(li);
 const id = li.id;

 await deleteTodo(id);
};</code>

<h3>Summary</h3>
This article looked at a few of the key ways to interact with an API using Axios using a <em>very simple</em> Todo application. 
If you'd like to learn more about Axios, check out the guides on <a href="/react/axios-react/">React + Axios</a> and <a href="/vuejs/rest-api-axios/">Vue + Axios</a>.


<h2>Understanding Closures in JavaScript</h2>

Closures have been hard to explain traditionally because, despite their usefulness, they work silently in the background to make things work, the stuff we take for granted. 
In this article, I'll try to cover the basics of what a closure is and why JavaScript benefits from closures.

A closure can be defined as a persistent scope that is held onto by a variable. 
Languages like JavaScript and Ruby support closures, which allows variables to have references to their parent scope even after their programming block has been executed and, as long as these variable have a reference somewhere, the closure exists.

Let's take a look at an example to illustrate:

<code>function outerFunction() {
// randomly gets an alligator object
let alligator = veryLongOperation(); 

let result = function() { someCallback(alligator); }
}</code>

Notice <code>result</code>, it's a function that is able to access the <code>alligator</code> object. 
This is described as the <i>closure of the function</i> <code>result</code> - the ability of the <code>result</code> function to access its parent scope elements. 
I consider closures as a kind of a sticky parent environment attached to a variable or a snapshot of the execution context when the variable is declared.

Now that we've seen what closures are, why are they useful?

JavaScript is async when it comes to execution, so waiting for an operation to get over doesn't really happen. 
Instead, if an operation is done then a callback is fired. 
This callback now has to run with the same execution context as it's caller/parent. 
This means that whatever variables or functions were available to the parent must now be made available to the callback as well. 
If these callbacks did not have closures, then we'd have to manually bind the needed scope members.

Closures make our lives a lot easier by doing this for us in the background. 
If there is function inside an function, the inner function has access to its scope members throughout its lifetime.

We use closures all the time without noticing them.

We've come across them during normal class definitions:

<code>let Alligator = function () {
let alligatorLength = Math.floor(Math.random()*10);
let getAlligatorLength = function() { 
 console.log(alligatorLength); 
};
}</code>

The scope chain of the <code>getAlligatorLength</code> is extended to include the members of the <code>Alligator</code> function.

Another instance where closures come into play is during currying (currying is process of returning multiple functions to reduce arity, it's employed in functional programming paradigm to reduce state changes)

<code>function addStuff(name1) {
 return function(name2) {
   return name1+ " and " + name2;
 }
}

console.log(addNames("alligator")("croc")); 
// alligator and croc</code>

Closures can be used along with currying to introduce private members for JavaScript classes.

<code>function Alligator() {
let hiddenPower = "I can fly";
return {
 showPower: () => { console.log(hiddenPower); }
};
}

let alligator = new Alligator();
console.log(alligator.hiddenPower); // undefined
alligator.showPower(); // I can fly</code>

<h3>Conclusion</h3>
Closures are a very subtle yet a powerful feature of JavaScript and understanding them is a very important step on the path to become a serious JavaScript developer. 
This is explained in more detail in <a href="https://twitter.com/getify">Kyle Simpson's</a> excellent write-up on <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch5.md">Closures</a>.


<h2>A Quick Introduction to Hyperapp</h2>

<a href="https://github.com/jorgebucaran/hyperapp">Hyperapp</a> is a <em>very small</em> micro-framework used to build declarative web applications. 
It's only 1kB in size and the API is similar to React's, perfect, right?! We'll build a small counter app to demonstrate how Hyperapp works.

<h3>New Hyper project</h3>
To get started, we can create a new Node application and install <code>hyperapp</code>. 
We'll then serve this application using <a href="/tooling/parcel/">parcel</a>:

<code># New directory, here we call it `hyper`
$ mkdir hyper &amp;&amp; cd hyper

# Initialise Node project
$ npm init -y

# Install Hyperapp
$ npm i hyperapp

# Create index.html and app.js
$ touch index.html
$ touch app.js

# Install `parcel` globally
$ npm i parcel -g

# Serve our application in the browser
$ parcel index.html</code>

We can then draft out a standard <code>index.html</code> page that includes <code>app.js</code> which will contain our <code>hyperapp</code> code.

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
 &lt;title> Hyperapp&lt;/title>
&lt;/head>
&lt;body>
 &lt;div id="app">&lt;/div>
 &lt;script src="app.js">&lt;/script>
&lt;/body>
&lt;/html></code>

<h3>Building a Counter</h3>
State-driven applications always start with a Counter example. 
This allows us to get used to how the data flows within our application. 
Let's start off by defining some <code>state</code>:

app.js

<code>const state = {
 count: 0
}</code>

We can then define a <code>view</code> based on that <code>state</code>. 
This can be displayed by using standard template syntax:

app.js

<code>// ...
const view = state => (
 &lt;div>
   &lt;h1>{state.count}&lt;/h1>
 &lt;/div>
);</code>

Finally, we can attach this to a particular element inside of the DOM. 
I've elected to add this to a <code>div</code> with the <code>id</code> of <code>app</code>:

app.js

<code>// ...
const el = document.getElementById('app');

const main = app(state, {}, view, el);</code>

Here's what our simple app looks like:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/962160d6982bbfa18c83ed0c9f39aa566e129feb/4a3fd/images/js/hyperapp/hyper-1.png" width="600" alt="Bare minimal Hyper project.">

<hr>
As <code>state</code> is immutable and should not be directly updated, we can now add <code>actions</code> to manipulate our <code>state</code> like so:

app.js

<code>// ...
const actions = {
 increment: () => state => ({ count: (state.count += 1) }),
 decrement: () => state => ({ count: (state.count -= 1) })
};</code>

This can be wired-up inside of our <code>main</code> and <code>view</code> to give it access to our <code>actions</code>:

app.js

<code>// ...
const view = (state, actions) => (
 &lt;div>
   &lt;h1>{state.count}&lt;/h1>
   &lt;button onclick={() => actions.increment()}>Increment&lt;/button>
   &lt;button onclick={() => actions.decrement()}>Decrement&lt;/button>
 &lt;/div>
);

const main = app(state, actions, view, el);</code>

Now if we select Increment or Decrement, we'll see the total count go up or down.

<hr>
What if we wanted to make this go up or down by a particular number? Let's add this functionality.

Firstly, we can add a new item to our <code>state</code> object. 
I've elected to call this <code>diff</code>, as this represents the difference between to added or subtracted:

<code>const state = {
 count: 1,
 diff: 1
};</code>

Then, we can update our <code>actions</code> to increment or decrement based on this:

<code>const actions = {
 updateCount: diff => state => ({ diff: diff }),
 increment: diff => state => ({ count: (state.count += Number(diff)) }),
 decrement: diff => state => ({ count: (state.count -= Number(diff)) })
};</code>

And finally, we can update our <code>view</code>:

<code>const view = (state, actions) => (
 &lt;div>
   &lt;input value={state.diff} oninput={e => actions.updateCount(e.target.value)} />

   &lt;h1>{state.count}&lt;/h1>
   &lt;button onclick={() => actions.increment(state.diff)}>Increment&lt;/button>
   &lt;button onclick={() => actions.decrement(state.diff)}>Decrement&lt;/button>
 &lt;/div>
);</code>

Now we have the ability to take advantage of input data to update our state.

<h3>Components</h3>
Let's now look at how we can make components out of our Hyperapp project. 
We'll make a <code>Counter</code> component and look at how we can embed this inside of a Page and route.

Create a new file at <code>components/Count.js</code> and add a counter that takes in a <code>count</code> from <code>props</code>:

Count.js

<code>import { h } from 'hyperapp';

const Count = ({ count }) => &lt;h1>{count}&lt;/h1>;

export default Count;</code>

We can then <code>import</code> this inside of <code>app.js</code>:

app.js

<code>import Count from './components/Count';

// ...</code>

Then we can pass the <code>count</code> in as props to our <code>Count</code> within the <code>view</code>:

app.js

<code>// ...
const view = () => (state, actions) => (
 &lt;div>
   &lt;Count count={state.count} />
   &lt;button onclick={actions.increment}>Increment&lt;/button>
   &lt;button onclick={actions.decrement}>Decrement&lt;/button>
 &lt;/div>
);</code>

I've also updated our <code>state</code> and <code>actions</code> to be a simple <code>increment</code> and <code>decrement</code> of <code>count</code>:

<code>const state = {
 count: 0
};

const actions = {
 increment: () => ({ count: (state.count += 1) }),
 decrement: () => ({ count: (state.count -= 1) })
};</code>

<h3>Routing</h3>
We can also take advantage of routing within Hyperapp. 
Let's install the router package (<code>@hyperapp/router</code>) like so:

<code>$ npm i @hyperapp/router</code>

We can then <code>import</code> the routing components inside of <code>app.js</code>:

app.js

<code>import { Link, Route, location } from '@hyperapp/router';</code>

Now we can create two different pages, <code>Home</code> and <code>Blog</code>:

app.js

<code>// ...
const Home = () => (state, actions) => (
 &lt;div>
   &lt;Count count={state.count} />
   &lt;button onclick={actions.increment}>Increment&lt;/button>
   &lt;button onclick={actions.decrement}>Decrement&lt;/button>
 &lt;/div>
);

const Blog = () => &lt;h1>Blog!&lt;/h1>;</code>

The <code>Home</code> page contains our counter example from before, and the <code>Blog</code> page is simply just some text. 
Let's assign these as a <code>Route</code> and <code>Link</code> and inside of the <code>view</code>:

app.js

<code>// ...
const view = state => (
 &lt;div>
   &lt;ul>
     &lt;li>
       &lt;Link to="/">Home&lt;/Link>
     &lt;/li>
     &lt;li>
       &lt;Link to="/blog">Blog&lt;/Link>
     &lt;/li>
   &lt;/ul>

   &lt;Route path="/" render={Home} />
   &lt;Route path="/blog" render={Blog} />
 &lt;/div>
);</code>

Next, we need to give the router access to the <code>location</code>, as it's based off the History API. 
Add the following to your <code>state</code> and <code>actions</code>:

app.js

<code>const state = {
 location: location.state,
 count: 0
};

const actions = {
 location: location.actions,
 increment: () => state => ({ count: (state.count += 1) }),
 decrement: diff => state => ({ count: (state.count -= 1) })
};</code>

Finally, we need to subscribe to the <code>location</code> itself:

app.js

<code>// ...
const unsubscribe = location.subscribe(main.location);</code>

Now we're able to select between different pages inside of our application!

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1efe2998f9bf42a57b69ed5bf171077aac96ce71/ab01a/images/js/hyperapp/hyper-routing-o.gif" width="600" alt="Routing with Hyperapp">

<hr>
Here's the full code for the routing example:

app.js

<code>import { h, app } from 'hyperapp';
import { Link, location } from '@hyperapp/router';

import Count from './components/Count';

const state = {
 location: location.state,
 count: 0
};

const actions = {
 location: location.actions,
 increment: () => state => ({ count: (state.count += 1) }),
 decrement: diff => state => ({ count: (state.count -= 1) })
};

const Home = () => (state, actions) => (
 &lt;div>
   &lt;Count count={state.count} />
   &lt;button onclick={actions.increment}>Increment&lt;/button>
   &lt;button onclick={actions.decrement}>Decrement&lt;/button>
 &lt;/div>
);

const Blog = () => &lt;h1>Blog!&lt;/h1>;

const view = state => (
 &lt;div>
   &lt;ul>
     &lt;li>
       &lt;Link to="/">Home&lt;/Link>
     &lt;/li>
     &lt;li>
       &lt;Link to="/blog">Blog&lt;/Link>
     &lt;/li>
   &lt;/ul>

   &lt;Route path="/" render={Home} />
   &lt;Route path="/blog" render={Blog} />
 &lt;/div>
);

const main = app(state, actions, view, document.body);

const unsubscribe = location.subscribe(main.location);</code>

<h3>Conclusion</h3>
With this, you should be off to the races!  And also, keep an eye out for <a href="https://github.com/jorgebucaran/hyperapp/pull/726">Hyperapp 2.0</a>, which should be out soon.


<h2>Built-in Web Modules: How to Use KV Storage</h2>

The release of <a href="https://wicg.github.io/kv-storage/">KV Storage</a> is a big deal for the web platform. 
It's part of the <a href="https://github.com/tc39/proposal-javascript-standard-library">Standard Library Proposal</a> which could see a more extensive standard library being introduced for JavaScript.

Before jumping in to <em>what</em> <code>kv-storage</code> is, let's first discuss how we can store data within the browser. 
If I wanted to store some local data right now, one of my main options would be the use of <a href="https://alligator.io/js/introduction-localstorage-sessionstorage/">localStorage</a>.

With that in mind, let's create a simple Todo application with JavaScript that takes advantage of <code>localStorage</code>. 
We'll need two files - <code>index.html</code> and <code>main.js</code>:

main.js

<code>const TODOS_KEY = 'todos';
const ul = document.getElementsByTagName('ul')[0];

const showExistingTodos = todos => {
 if (todos.length > 0) {
   todos.map(todo => {
     addLi(todo);
   });
 }
};

const addTodo = () => {
 const input = document.getElementById('todoInput').value;

 if (input.length > 0) {
   addLi(input);
   saveTodo(input);

   document.getElementById('todoInput').value = '';
 }
};

const addLi = text => {
 const li = document.createElement('li');

 li.appendChild(document.createTextNode(text));

 ul.appendChild(li);
};

const saveTodo = todo => {
 let loadedTodos = loadTodos();

 loadedTodos = [...loadedTodos, todo];

 localStorage.setItem(TODOS_KEY, JSON.stringify(loadedTodos));
};

const loadTodos = () => {
 const todos = JSON.parse(localStorage.getItem(TODOS_KEY));

 return todos != null ? todos : [];
};

const clearTodos = () => {
 localStorage.removeItem(TODOS_KEY);

 const todos = Array.from(document.getElementsByTagName('li'));

 todos.map(todo => ul.removeChild(todo));
};

const todos = loadTodos();

showExistingTodos(todos);</code>

index.html

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
&lt;head>
 &lt;meta charset="UTF-8">
 &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
 &lt;meta http-equiv="X-UA-Compatible" content="ie=edge">
 &lt;title>Document&lt;/title>
&lt;/head>
&lt;body>
 &lt;div>
   &lt;input id="todoInput" type="text" />  
   &lt;button onclick="addTodo()">Add Todo&lt;/button>
   &lt;button onclick="clearTodos()">Clear todos&lt;/button>
 &lt;/div>

 &lt;ul>

 &lt;/ul>
 
 &lt;script src="main.js">&lt;/script>
&lt;/body>
&lt;/html></code>

While this could definitely be improved, we now have an application that we can use as an example. 
If we try and add some Todo items and then refresh the page, we'll see that they appear instantly!

<blockquote>Hmm… I did some research and found out that <code>localStorage</code> is synchronous. 
What does that mean for our application?
</blockquote>
Essentially, this means that calls to <code>localStorage</code> will block rendering inside of the DOM. 
This may may represent a problem if we had lots of elements in <code>localStorage</code> and will significantly impact performance.

Let's take a look at an experimental built-in module named KV storage (for key/value storage). 
This is built on IndexedDB, an asynchronous storage API.

<blockquote>Why not use IndexedDB natively then?
</blockquote>
The use of KV storage gives us a more intuitive API that is similar to <code>localStorage</code>. 
We also don't need to turn to a third party IndexedDB library, we can now use this directly from within the browser!

<h3>KV Storage</h3>
For this example we'll need to enable Experimental Features within Chrome. 
Inside of your Chrome browser, navigate to the following address:

Select "Enabled" on Experimental Web Platform features: <a href="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features</a>.

It's also a good idea to use <a href="https://www.google.com/chrome/canary">Chrome Canary</a> for any and all experimental/new Web features. 
I'll be using it for our example.

We'll now need to perform the following updates:

Inside of <code>index.html</code>, import <code>main.js</code> as a module:

<code>&lt;script type="module" src="main.js">&lt;/script></code>

Next, we can update our <code>saveTodo</code> function to use <code>storage.set()</code> instead of <code>localStorage.setItem()</code>

<code>const saveTodo = async todo => {
 let loadedTodos = await loadTodos();

 loadedTodos = [...loadedTodos, todo];

 await storage.set(TODOS_KEY, loadedTodos);
};</code>

Our <code>loadTodos</code> function uses <code>storage.get()</code> instead of <code>localStorage.getItem()</code>:

<code>const loadTodos = async () => {
 const todos = await storage.get(TODOS_KEY);

 return todos != null ? todos : [];
};</code>

Notice here how we're dealing with the asynchronicity with ease using <a href="https://alligator.io/js/async-functions/">async/await functions</a>.

<hr>
Finally, we can improve our <code>clearTodos</code> function by using <code>storage.delete()</code> instead of <code>localStorage.removeItem()</code>:

<code>const clearTodos = () => {
 storage.delete(TODOS_KEY);

 const todos = Array.from(document.getElementsByTagName('li'));

 todos.map(todo => ul.removeChild(todo));
};</code>

We'll also need to expose these to the <code>window</code> object:

<code>window.addTodo = addTodo;
window.clearTodos = clearTodos;</code>

Our application now works once again, <em>but</em> instead of <code>localStorage</code> it uses the <code>std:kv-storage</code> built-in Web module. 
The best thing about this? It uses IndexedDB under the hood!

This means everything is asynchronous (as referenced by our <code>async</code> and <code>await</code> promise calls, too).

<h3>Client support</h3>
What if the browser doesn't support <code>kv-storage</code>? At the moment, this is extremely likely. 
Luckily, there's a polyfill available here: <a href="https://github.com/GoogleChromeLabs/kv-storage-polyfill">https://github.com/GoogleChromeLabs/kv-storage-polyfill</a>.

I'd recommend you add this to your application if you plan on using <code>kv-storage</code> in production at this stage.

<h2>Understanding Switch Cases in JavaScript</h2>

We recently looked at <a href="https://alligator.io/js/if-statements/">if statements</a>, but now it's time to <em>switch</em> things up! We'd look to use the <code>switch</code> statement whenever we have multiple test cases for a particular expression. 
If you find yourself writing multiple <code>if/else</code> statements, this may be worth condensing into a <code>switch</code> statement.

As a result, in many ways, the <code>switch</code> statement is similar to the <code>if</code> statement:

<ol><li>The switch statement firstly evaluates an expression.</li><li>Using <code>case</code> syntax, it compares the result of the expression with the particular case.</li><li>It then executes any code inside of the <code>case</code> until the <code>break</code> keyword is found. 
If the <code>break</code> keyword is not added to the case, it'll continue to execute further code within the block.</li><li>Alternatively, if there are no matching cases, an <em>optional</em><code>default</code> case can be added to execute a block of code regardless.</li>
</ol>
Let's look at a version of this in code:

<code>const sky = "blue";

switch (sky) {
 case "red":
   console.log("Uh oh.");
   break;
 case "blue":
   console.log("A good day for golf!");
   break;
 default:
   console.log("Try looking up for a hint.");
}</code>

As the value of <code>sky</code> is equal to <code>blue</code>, the case <code>blue</code> is executed. 
However, if we changed the value of <code>sky</code> to an empty string <code>""</code> we'd get the <code>default</code> case.

Here's the same example, with a little twist:

<code>const sky = "blue";

switch (sky) {
 case "red":
 case "purple":
 case "yellow":
 case "green":
   console.log("Uh oh.");
   break;
 case "blue":
   console.log("A good day for golf!");
   break;
 default:
   console.log("Try looking up for a hint.");
}</code>

As you can see in this second example, it's perfectly valid to have multiple case statements that share the same block of executed code.

<h3>Summary</h3>
You should now have the hang of <code>switch</code> statements within JavaScript. 
Use this new power wisely - don't turn every <code>if</code> statement into a <code>switch</code>, only those that are getting too long to read tersely. 
And don't forget to <code>break</code> out of the switch statement once you've found the right condition, otherwise the rest of the code will run and have an impact on your code's performance. 
<code>default</code> doesn't need a <code>break</code> statement, because if your code reaches that point, it has already gone through the whole code of the switch case anyway.


<h2>Introduction to Iterables and Iterators in JavaScript</h2>

JavaScript supports a protocol by which objects such as arrays can be used by control structures such as <a href="https://alligator.io/js/for-of-for-in-loops/">for…of</a> and the spread operator <code>...</code> to loop through data sequentially. 
This is referred to as the iterable and the data structures that support this functionality are called iterables. 
While JavaScript provides maps, arrays and sets with an iterable property from the get-go, plain objects do not have this by default.

Iterables are data structures which provide a mechanism to allow other data consumers to publicly access its elements in a sequential manner. 
Imagine a self-packaged data structure that unloads data one-by-one in order when put inside of a <code>for...of</code> loop.

The concept of the iterable protocol can be split into the <em>iterable</em> (the data structure itself) and the <em>iterator</em> (sort of a pointer that moves over the iterable). 
Let's consider an array for example, when the array is used in a <code>for...of</code> loop, the iterable property is called which returns an <code>iterator</code>. 
This iterable property is namespaced as <code>Symbol.iterator</code> and the object that it returns can be used on a common interface that is shared by all looping control structures.

In a way, the <code>Symbol.iterator</code> can be compared to a iterator factory that produces an iterator whenever the data structure is placed in a loop.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3ff4bc615c4088cb828c35715095d7ca8593613b/66c31/images/js/iterables/js-iterable-1.png" alt="JavaScript iterable">

As an iterator moves over the data structure and provides the elements sequentially, the object returned by the iterable contains a <code>value</code>and a <code>done</code> property.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/75441d6b509c487174f11182a727e588b12063fd/786a3/images/js/iterables/js-iterable-2.png" alt="JavaScript iterator">

The value indicates the current data value pointed by the iterator and <code>done</code> is a boolean that tells us if the iterator has reached the last element in the data structure.

This <code>{value, done}</code> is consumed by structures such as loops. 
So how does the iterator method call the next object? Using a <code>next()</code> method that's defined within the Symbol.iterator() method.

A better definition for the iterator property that I can come with at this point is that it's an property that <i> knows </i> how to access elements from a collection one by one and also provides a logical rule to stop doing so (eg. 
if there are no more elements in the array).

<h3>Objects and Iterables</h3>
JavaScript objects are cool and all, but why don't they have iterables? Well, some of the reasons could be:
<li>One of the key features of objects is that it's user defined. 
So slipping in a silent <code>[Symbol.iterator]()</code> into the object would make for a nasty surprise.</li><li>The above point also means that it can be added manually by the user, considering that all object compositions might not be similar. 
So having a common iterable property is pretty meaningless.</li><li>If you want to loop over the top level elements in the object, then use the other guy: a <code>for...in</code> loop.</li><li>The usage of the <a href="https://alligator.io/js/maps-introduction/">Maps</a> object type might be more appropriate.</li>

All the points above except the last one (I hate to admit that I'm too comfy with regular objects to move to maps) are good reasons not to have iterables in objects, but what if your boss wanted your JavaScript objects to have one?

A simple iterable implementation on objects would look like this:

<code>let Reptiles = {
 biomes: {
   water: ["Alligators", "Crocs"],
   land: ["Snakes", "Turtles"]
 },

 [Symbol.iterator]() {
   let reptilesByBiome = Object.values(this.biomes);
   let reptileIndex = 0;
   let biomeIndex = 0;
   return {
     next() {
       if (reptileIndex >= reptilesByBiome[biomeIndex].length) {
         biomeIndex++;
         reptileIndex = 0;
       }

       if (biomeIndex >= reptilesByBiome.length) {
         return { value: undefined, done: true };
       }

       return {
         value: reptilesByBiome[biomeIndex][reptileIndex++],
         done: false
       };
     }
   };
 }
};

// let's now iterate over our new `Reptiles` iterable:
for (let reptile of Reptiles) console.log(reptile);</code>

The output would be:

<code>Alligators
Crocs
Snakes
Turtles</code>

With this example, we see iterators can be implemented within the object. 
Iterables can be powerful properties for objects that provide ease of use while handling certain situations and help us avoid writing long path names.

<h3>Getting at the Iterator</h3>
Loops like <code>for...of</code> have a built-in mechanism to consume iterables until the <code>done</code> value evaluates to true. 
What if you want to consume the iterable on your own though, without a built-in loop? Simple, you get the iterator from the iterable and then call <em>next()</em> on it manually.

Given the same example as above, we could get an iterator from <code>Reptiles</code> by calling its <code>Symbol.iterator</code> like this:

<code>let reptileIterator = Reptiles[Symbol.iterator]();</code>

You can then use the iterator like this:

<code>console.log(reptileIterator.next());
// {value: "Alligators", done: false}
console.log(reptileIterator.next());
// {value: "Crocs", done: false}
console.log(reptileIterator.next());
// {value: "Snakes", done: false}
console.log(reptileIterator.next());
// {value: "Turtles", done: false}
console.log(reptileIterator.next());
// {value: undefined, done: true}

console.log(reptileIterator.next());
// TypeError: Cannot read property 'length' of undefined</code>

As you can see, the iterator has a <code>next()</code> method that returns the next value in the iterable. 
The value for <code>done</code> only evaluates to <code>true</code> after another <code>next()</code> call once the last value has been returned, so to go over the entire iterable there will always be one more call to <code>next()</code> than there is data in the iterable. 
Calling <code>next()</code> again after an iterator has reached the end of the itarable will result in a <code>TypeError</code> being thrown.

<h3>Wrapping Up</h3>
I hope that this introduction was eye opening in understanding a little more about JavaScript's internals for data structures such as objects. 
This only scratched the surface and, if you want to learn more, I invite you to read <a href="https://twitter.com/getify">Kyle Simpson's</a> excellent <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch4.md#iterables">chapter on Iterables</a>.


<h2>Conditional Basics: Using If Statements in JavaScript</h2>

Should we go out to eat tonight? The answer to this question is usually a yes or no answer (<em>depending on who you ask… :)</em>). 
Welcome to the world of conditionals! Let's explore how conditionals work in JavaScript.

If you're already an experienced developer or have played around with JavaScript for any length of time, this will probably already be second nature to you, but otherwise this is perfect if you're just getting started. 
Plus, sometimes we just draw a blank and need a refresher on the syntax. 
This article will be perfect for both scenarios!

<h3>If</h3>
Conditionals allow us to perform an action <em>if</em> something is <code>true</code> or <code>false</code>. 
Let's take the following example:

<code>const areWeGoingOutForFood = true

if (areWeGoingOutForFood) {
 console.log(`Yay! I want Chinese food.`)
}</code>

As our <code>areWeGoingOutForFood</code> variable is <code>true</code>, the message <code>Yay! I want Chinese food.</code> is logged to the console.

<h3>Else Block</h3>
What happens if we <em>don't</em> want to go out? Well. 
We haven't considered that yet. 
Let's do so:

<code>const areWeGoingOutForFood = false;

if (areWeGoingOutForFood) {
 console.log(`Yay! I want Chinese food.`);
} else {
 console.log(`I'd prefer to eat in tonight too.`);
}</code>

The addition of the <em>optional</em> <code>else</code> block means that if we aren't eating out tonight (i.e. 
the conditional is false), anything in this <code>else</code> block will be ran.

<h3>Multiple Conditional Statements with Else If</h3>
We can use multiple if/else statements in our code to switch between behavior states:

<code>// According to https://nationalzoo.si.edu/animals/american-alligator - alligators have from 74 - 80 teeth!
const teeth = 74;

const promptForGuess = () => {
 const guess = prompt('How many teeth do alligators have?');

 if (guess &lt;= 0) {
   alert(`It's definitely above zero!`);
   promptForGuess();
 } else if (guess >= 1 &amp;&amp; guess &lt;= 39) {
   alert(`Quite a bit higher than that!`);
   promptForGuess();
 } else if (guess >= 40 &amp;&amp; guess &lt;= 73) {
   alert(`Getting closer. 
It's a little higher!`);
   promptForGuess();
 } else if (guess >= teeth &amp;&amp; guess &lt;= 80) {
   alert(`Yup. 
That sounds about right.`);
 } else {
   alert(`Too many. 
Try lower than that.`);
   promptForGuess();
 }
};

promptForGuess();</code>

When we run our project, it'll prompt the user asking for an approximation on how many teeth an alligator has. 
As the user answers the question, feedback is given in the form of an <code>alert</code> which changes text based on how close the user was.

Our implementation is quite arbitrary, but this can be implemented in any way that you see fit. 
And when the number of conditions continues growing, you may want to consider using a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch">switch statement</a> instead.

<h3>Ternary Operator</h3>
The ternary operator can be thought of as a shortcut to the standard <code>if</code> statement. 
It takes a form similar to what we've already learned, but significantly more terse. 
Let's visualize it:

<code>const areWeGoingOutForFood = false;

areWeGoingOutForFood ?
 console.log(`Yay! I want Chinese food.`) :
 console.log(`I'd prefer to eat in tonight too.`)

// Result: console.log(`I'd prefer to eat in tonight too.`)</code>

What's happening here? Well, firstly, we're asking whether <code>areWeGoingOutForFood</code> is <code>true</code>. 
Then, it follows the “TRUE : FALSE” denomination. 
As <code>areWeGoingOutForFood</code> is equal to <code>false</code>, the second statement is executed. 
Note how we're using the colon <code>:</code> to separate the two statements.

Challenge: Based on the above example, what would happen if <code>areWeGoingOutForFood</code> was equal to <code>true</code>?

While it's also possible to nest ternary conditions, I wouldn't advise this as it tends to impair code readability and the logic gets hard to follow.

Alright, so now you know how to write conditional statements in JavaScript, which is one of the fundamental concepts to grasp! Go you! 


<h2>A Look at the JavaScript Pipeline Operator Proposal</h2>

The JavaScript <a href="https://github.com/tc39/proposal-pipeline-operator">pipeline operator proposal</a>, which is currently a <a href="https://tc39.github.io/process-document/">Stage 1</a> proposal, would add a new operator to JavaScript. 
This new operator would would act as syntax sugar to extend and make chained function more readable.

To demonstrate, let's start with a simple example without the use of the pipeline operator:

<code>// assume that `withHello`, `withWave` and `capitalize` are available
let greeting = withHello(withWave(capitalize('alligator')))

console.log(greeting) // Hello, Alligator </code>

Now the same example, but using the proposed pipeline operator:

<code>let greeting = 'alligator' |> capitalize |> withWave |> withHello

console.log(greeting) // Hello, Alligator </code>

Or formatted in a more readable way like so:

<code>let greeting = 'alligator' 
 |> capitalize 
 |> withWave 
 |> withHello

console.log(greeting) // Hello, Alligator </code>

As you can see, the pipeline operator can really help make the code more clear and readable, and ultimately more maintainable.

With multiple recursive function calls, the innermost function is called first, which means that the order in which the calls are written needs to be from the last function call to the first, which can be a bit of a backwards way to think about and write code. 
With the pipeline operator, the written order is reversed and the first function call is added first.

<h3>Using the Pipeline Operator Today</h3>
As this proposal is still very early stage, you won't find any support in current browsers. 
We can make use of <a href="https://babeljs.io/">Babel</a> to allow us to use it today, and have transpiled code that works in all browsers.

To get started make sure that you installed Node.js on your machine.

Let's create a new folder and initialize a new project:

<code>$ mkdir pipeline-operator
$ cd !$ 
$ yarn init -y
$ touch index.js</code>

In bash <code>!$</code> means the last argument of the last command.

<h3>Initialize Babel</h3>
Now let's install the Babel dev dependency for our project:

<code>$ yarn add -D @babel/cli @babel/core @babel/plugin-syntax-pipeline-operator</code>

Create a new file called <code>.babelrc</code> in the project directory:

<code>$ touch .babelrc</code>

Copy and paste the following settings into <code>.babelrc</code>:

<code>{
 "plugins":[
   [
     "@babel/plugin-proposal-pipeline-operator",
     {
       "proposal":"minimal"
     }
   ]
 ]
}</code>

Add a <code>start</code> script into the project's <a href="/nodejs/package-json/">package.json</a> file, which will run <code>babel</code>:

<code>"scripts": {
 "start": "babel index.js --out-file pipeline.js --watch"
}</code>

Start using Babel with the use of our new <code>start</code> script:

<code>$ yarn start</code>

Don't stop this script while you're working, it's in watch mode so it'll continue doing its job as you change the file. 
Instead just open another console tab to run the outputted JavaScript file (<code>pipeline.js</code>).

And that's it, we're now ready to use the pipeline operator in our code! 

<h3>Usage</h3>
Let's first create some helper functions to work with:

index.js

<code>function withPrefix(string, prefix = "Hello, ") {
 return prefix + string;
};

function withSuffix(string, suffix = "It's me!") {
 return string + suffix;
}

function capitalize(string) {
 return string[0].toUpperCase() + string.substr(1);
}

function lowerCase(string) {
 return string.toLowerCase();
}</code>

Let's see how we would use them without the pipeline operator:

index.js

<code>let greeting = withPrefix(withSuffix(lowerCase(capitalize('WORLD'))))

console.log(greeting) // Hello, world it's me!

// With arguments

let greeting = withPrefix(withSuffix(lowerCase(capitalize('WORLD')), '. 
We love you &lt;3'), 'Hi there, ')

console.log(greeting) // Hi there, world. 
we love you &lt;3</code>

The code looks a tad confusing, right? Let's now look at what it would look like with the pipeline operator:

index.js

<code>let greeting = 'WORLD' 
 |> capitalize
 |> lowerCase 
 |> withSuffix 
 |> withPrefix 

console.log(greeting) // Hello, world it's me!

// With arguments

let greeting = 'WORLD'
 |> capitalize
 |> lowerCase
 |> (str => withSuffix(str, '. 
We love you &lt;3'))
 |> (str => withPrefix(str, 'Hi there, '))

console.log(greeting) // Hi there, world. 
we love you &lt;3</code>

Run the code with:

<code>$ node pipeline.js</code>

As you can see, it's just as easy to use with function arguments.

<h3>Arguments</h3>
<code>// ...
|> (str => withPrefix(str, 'Hi there, '))</code>

It's just an arrow function. 
It's first argument is what we are trying to process, the string <code>'WORLD'</code> in our case.

You can even use built-in methods:

index.js

<code>let greetingArray = 'WORLD' 
 |> withPrefix
 |> (str => str.toLowerCase()) 
 |> capitalize
 |> (str => str.split(''))

console.log(greetingArray) // => ["H", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d"]</code>

<h3>Conclusion</h3>
I hope that this article was useful for you. 
Remember that <strong>it's just syntax sugar. 
It's up to you to use it or not.</strong> If you enjoy this article, subscribe to receive more cool articles.


<h2>D3.js: Understanding Selections and Comparing with Vanilla JavaScript</h2>

This article aims to show how selections work within D3. 
We'll start with a basic project that includes <code>d3.js</code> as a script with no build system:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
 &lt;head>
   &lt;title>D3: Selections&lt;/title>
 &lt;/head>
 &lt;body>
   &lt;div class="about-me">
     &lt;p>Hi! My name is Paul and here's some facts about me.&lt;/p>
     &lt;ul id="list">
       &lt;li>I'm a powerlifter&lt;/li>
       &lt;li>I'm studying MSc Data Science&lt;/li>
       &lt;li>I love D3.js!&lt;/li>
     &lt;/ul>
   &lt;/div>

   &lt;script src="https://d3js.org/d3.v5.min.js">&lt;/script>
   &lt;script src="main.js">&lt;/script>
 &lt;/body>
&lt;/html></code>

Consider how we may make selections and modify DOM elements without D3:

<code>const listItems = [...document.getElementsByTagName('li')];

listItems.map(item => item.style.setProperty('font-weight', 'bold'));</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/afec141f2512a47265a592fcd382b3084656d4dc/1d0b1/images/js/d3-selections/dom-selection.png" width="600" alt="vanilla JavaScript DOM selection">

While this isn't very complex right now, we can expect that things will get harder and more difficult to reason as we scale. 
Here's why we need to consider D3.

<h3>Selections in D3</h3>
Notice how when we wanted to manipulate <em>multiple</em> elements in the DOM we had to <em>map</em> over them. 
D3 selections allow us to query <em>one or more</em> elements on the page and allows us to manipulate the whole selection without the need for iteration on our part.

It uses standard CSS selector syntax, so you can expect to query an element by it's name, a class with <code>.about-me</code>, an id with <code>#list</code>, and so on.

We can select elements from the DOM with either:
<li>
<code>select()</code> takes <em>one</em> element from the DOM. 
If there are multiple matches, only the first one will be taken.</li><li>
<code>selectAll()</code> takes <em>all</em> elements from the DOM.</li>

<h3>Example</h3>
Let's take a look at this with a code example. 
Doing the same as our vanilla JavaScript example can be done in one line:

<code>const li = d3.selectAll('li').style('font-weight', 'bold');</code>

As you can see, it returns a collection of elements which we can chain into other methods such as <code>style</code>.

If we change this to be <code>select</code> instead of <code>selectAll</code>, you'll notice that <code>I'm a powerlifter</code> is the only <code>li</code> that gets bolded – this is expected as it's the first <code>li</code> in the DOM.

<h3>Appending a new list item</h3>
To further show the power of selections, consider how we may want to add a new <code>li</code> <a href="https://alligator.io/js/getting-elements/">to the DOM</a> with JavaScript:

<code>const ul = document.getElementsByTagName('ul')[0];

const newItem = document.createElement('li');

newItem.appendChild(document.createTextNode(`I'm learning about selections.`));

ul.appendChild(newItem);</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b4aae04d085dc0edb8724385629c430a9acfaafd/fd26b/images/js/d3-selections/dom-addition.png" width="600" alt="Screenshot: Appending an element">

Once again, this isn't exactly the best workflow when we're looking to create complex data visualizations. 
Let's look at the same example with D3:

<code>const ul = d3.select('ul');

ul.append('li').text(`I'm learning about selections`);</code>

Much easier! Each function returns the updated value of the previous change or query, allowing us to chain methods together in a powerful way.

<h3>Sub Selections</h3>
We're also able to select items <em>within</em> our selection. 
Let's take a look at this by selecting the first <code>li</code> from within our <code>ul</code> selection and making it red:

<code>const ul = d3.select('ul');

ul.select('li').style('color', 'red');

ul.append('li').text(`I'm learning about selections`);</code>

As you can see, we're not just limited to the initial selection. 
We can continue to make sub selections and get more specific about our implementation.

<h3>What do Selections Look Like?</h3>
Let's use <code>console.log</code> to inspect our <code>select</code> query to look at what gets returned:

<code>{
 _groups: [Array(1)]
 _parents: [html]
}</code>

If we expand <code>_groups</code>, you'll see that it returns our <code>ul</code> as per the selection. 
If we changed our selection to be <code>selectAll('li')</code>, the <code>_groups</code> returns an <code>Array</code> containing a collection of <code>li</code>s inside of a <code>NodeList(3)</code>.

<code>const li = d3.selectAll('li');

console.log(li);</code>

<code>_groups: Array(1)
 0: NodeList(3)
   0: li
   1: li
   2: li
_parents: [html]</code>

Naturally, the <code>_parents</code> object contains the parent for this selection, being the root <code>html</code> object.

And that's it for now! Stay tuned for more about using D3.js.


<h2>Getting Elements in JavaScript and the DOM</h2>

Oftentimes software libraries are created to help fill the shortcomings of a particular language. 
Libraries like jQuery introduced us to the idea of using CSS selectors to grab elements from the DOM, something that didn't really exist at the time. 
Eventually, JavaScript started to catch up by expanding beyond <code>getElementById()</code> to allow for selecting elements by way of things like class and tag names.

<h3>Get Element by ID</h3>
Tried and true. 
The O.G. 
of the element “getters”.

This <code>Document</code> method does exactly what it says it's going to do. 
Pass it the string of the ID you'd like to return and you're good to go:

<code>&lt;div>&lt;/div>
&lt;div id="alligator">&lt;/div>
&lt;div>&lt;/div></code>

<code>const element = document.getElementById('alligator');</code>

Easy, right?

A few things to mention though. 
First, take note that it's get “element”, singular and not “elements”. 
Remember that the <code>id</code> attribute is supposed to be unique across your entire HTML document, so this method will only ever return a single element.

Next, keep in mind that the method name is case sensitive. 
If you're like me, you probably type “<code>getElementByID</code>” (capital ID) thanks to muscle memory. 
If so, the method won't work and hopefully you have a linter in the mix that will bark about the problem before you waste a few hours trying to figure out what the heck you did wrong.

Lastly, the ID string supplied to the method <em>should not</em> include a pound sign. 
I couldn't tell you how many time's I've written <code>getElementById('#someId')</code> forgetting that I've switched gears and wasn't writing a CSS selector.

<h3>Get Elements by Tag Name</h3>
Next up is <code>getElementsByTagName()</code>. 
Give it a tag name and it will return all of the elements for that tag:

<code>&lt;ul>
 &lt;li>&lt;/li>
 &lt;li>&lt;/li>
 &lt;li>&lt;/li>
&lt;/ul></code>

<code>const ulElements = document.getElementsByTagName('ul');</code>

This method only lets you pull a single tag name at a time, but if you pass in <code>*</code> as the tag name, you will receive every element in the DOM tree:

<code>const allElements = document.getElementsByTagName('*');</code>

<h3>Get Elements by Name</h3>
Want to grab the elements that have a specific <code>name</code> attribute? You can use <code>getElementsByName()</code>, pass it a name value, and it will return all of the elements with that name attribute:

<code>&lt;input name="alligator" />
&lt;input name="crocodile" /></code>

<code>const namedElements = document.getElementsByName('alligator');</code>

<h3>Get Elements by Class Name</h3>
And finally, <code>getElementsByClassName()</code>. 
You can give it a class name and it will return all of the elements that have said class in it's class name list:

<code>&lt;div class="alligator">&lt;/div>
&lt;div class="crocodile">&lt;/div></code>

<code>const elements = document.getElementsByClassName('alligator');</code>

A bit more robust than some of the other “getter” methods, <code>getElementsByClassName()</code> also accepts multiple class names. 
The class names will need to be separated by spaces and then the method will return the elements that match <em>all</em> of the class names provided:

<code>&lt;div class="reptile alligator">&lt;/div>
&lt;div class="reptile crocodile">&lt;/div></code>

<code>const elements = document.getElementsByClassName('reptile alligator');</code>

Remember, the class names provided don't need to be prefixed with a period, as with CSS selectors. 
That's another one that's gotten me before ;)

<hr>
These methods are all well and good, but they are still lacking compared to using a raw CSS selector.

Chaining is possible, but it only really works when you chain to <code>getElementById()</code>. 
Even then, all you can do is get elements inside of the element that was selected by ID. 
Outside of looping through and interrogating each element, there's not a great way to get the power of multiple selectors.

Fortunately, modern JavaScript also includes some additional methods that allow you to select elements based on CSS selectors!

<h3>Query Selector</h3>
The first of two methods that use CSS selectors is <code>querySelector()</code>. 
Pass it a CSS selector (as crazy or as tame as you'd like) and you will receive the first matched element back:

<code>&lt;form id="form">
 &lt;input type="checkbox" name="gator">
 &lt;input type="checkbox" name="gator" class="reptile">
 &lt;input type="checkbox" name="gator">
&lt;/form></code>

<code>const elements = document.querySelector('#form input[name="gator"].reptile');</code>

<h3>Query Selector All</h3>
Looking for more than just the first element that matched? If so, you can use <code>querySelectorAll()</code> which also takes a CSS selector as an argument:

<code>&lt;form id="reptiles">
 &lt;input name="gator-01">
 &lt;input name="gator-02">
 &lt;input name="gator-03">
&lt;/form></code>

<code>const elements = document.querySelectorAll('form#reptiles input[name^="gator-"]');</code>

<hr>
<h3>Working with HTMLCollection</h3>
Most of the methods we've discussed (except <code>getElementById()</code> and <code>querySelector()</code>) return multiple elements as an <code>HTMLCollection</code>.

The <code>HTMLCollection</code> is similar to an array, but does deviate a bit as it lacks looping methods like <code>forEach()</code>.

Let's take a look at how to work with our elements now that we “got” them.

<h3>Length</h3>
Not much to grabbing the length, just append <code>.length</code> to the <code>HTMLCollection</code> and you'll be greeted with an integer value:

<code>const numberOfElements = elements.length;</code>

<h3>First Element</h3>
The first element of an <code>HTMLCollection</code> is the element that first matched the selection criteria when the method scanned the DOM. 
Grabbing the first element is quite simple:

<code>const firstElement = elements[0];</code>

<h3>Last Element</h3>
At the other end of the spectrum, or should I say <code>HTMLCollection</code>, is the last element that happened to have matched the selection criteria. 
It's a bit more work to get, but nothing too crazy:

<code>const lastElement = elements[elements.length - 1];</code>

<h3>Looping</h3>
Okay, so everything thus far has been exactly like working with an array. 
Looping on the other hand is a bit more complex.

As mentioned <code>HTMLCollection</code> doesn't have the array looping methods we know and love, like <code>.forEach()</code> or <code>.map()</code> but we can tap into the <code>Array.prototype</code> to access those looping methods anyway:

<code>Array.prototype.forEach.call(elements, (element) => {
 console.log(element);
});</code>


<h2>A Look at Scopes, Context, Object Reference and Instantiation in JavaScript</h2>

In this article, I would like to explain some tricky concepts in JavaScript that can get really confusing, depending on where you are in your development journey. 
Namely, I'll discuss object references, scopes, context and instantiation in JavaScript. 
It should help you understand some behaviors that can otherwise seem odd with JavaScript.

First, an example to illustrate the point:

<code>[] === []
// false</code>

Woah, what just happened an empty array is not equal to an empty array. 
JavaScript, how confusing can you be!

<h3>Object Reference</h3>
The concept of object reference can be very tricky, here for example let's do a check to see if <code>object1</code> and <code>object2</code> is the same:

<code>let object1 = { value:10 };
let object2 = object1;
let object3 = { value: 10};</code>

<code>object1 === object2
//true</code>

We get true because both <code>object1</code> and <code>object2</code> are both pointing to the same reference data that's in memory. 
If we check to see if <code>object1</code> and <code>object3</code> is the same:

<code>object1 === object3
// false</code>

Interesting! they both have the same value but why are they not the same. 
That's because <code>object3</code> creates another reference in the memory, which isn't the same as <code>object1</code> so JavaScript treats both objects as being different.

To explain further, imagine <code>object1</code> being created as an address in memory, then <code>object2</code> pointing to <code>object1</code> at the same address. 
While <code>object3</code> is another address in memory. 
<code>object1</code> address can never be the same as <code>object3</code> address.

<h3>Array Reference</h3>
Back to the initial example of:

<code>[] === []
// false</code>

In Javascript array's are really objects behind the scene so JavaScript treats the first <code>[]</code> as a new object and store the reference in memory, then stores the second <code>[]</code> as a different reference in memory, So when checking for equality, it turns out they can't be the same.

<h3>Scopes and Context</h3>
Context are always confused with scopes. 
A scope is always created when curly brackets are encountered. 
If we create a function, for example, a new scope is created:

<code>function sampleScope() {
 let a = 'a';
 console.log(a);
}</code>

If we were to reference the variable <code>a</code> from outside the <code>sampleScope</code> function it wouldn't be recognized because the variable is defined inside the <code>sampleScope</code> function scope.

<h3>Context</h3>
A context is different from scope, it tells you the current object we are currently referencing. 
Context is accessed using the <a href="https://alligator.io/js/this-keyword/">this keyword</a>. 
For example, if we log the current context we are in from the console in the browser with the following:

<code>console.log(this);
// Window {postMessage: , blur: , focus: , close: , parent: Window, …}</code>

It tells us we are currently in the <code>window</code> objects. 
The <code>this</code> is a special keyword of Javascript that point's to the current object or context:

<code>this.alert('hello');
window.alert('hello);</code>

The two lines above are essentially the same thing because the <code>this</code> keyword references the <code>window</code> object because that's the current context.

If we create a new object like so:

<code>const object4 = {
 a: function() {
   console.log(this);
 }
}

object4.a();

// {a: }</code>

We see that it logs out the current context which is the <code>object4</code> context.

<h3>Instantiation</h3>
Let's say we want to keep track of the students we had in a classroom by having their names and gender, so we model out a <a href="https://alligator.io/js/objects-prototypes-classes/">class</a> that looks like this:

<code>class Student {
 constructor(name, gender){
   console.log(this);
   this.name = name;
   this.gender = gender;
 }
 introduceStudent() {
   console.log(`${this.name}, ${this.gender}`);
 }
}</code>

We have a class that we created accepts a <code>name</code> and a <code>gender</code> and also has access to a function that logs the student's name.

Now let's say we want to create a class representative without having to copy the same code and adding extra information, we can extend the <code>Student</code> class while creating a new class for the class representative, like so:

<code>class Rep extends Student{
 constructor(name, gender){
   super(name, gender);
 }
 introduceClassRep() {
   console.log(`${this.name}, ${this.gender}, and I'm a class rep`);
 }
}</code>

The <code>extends</code> keyword tells JavaScript to add whatever property the class extends from to the current class. 
Whenever we extend a class, we also need to call it's constructor method, <code>super</code> gives us the power to do just that.

Now let's create instances of both class:

<code>const student1 = new Student('jane', 'female');
const student2 = new Rep('cole', 'male');</code>

After creating these new instances you'll see that the two console outputs are different. 
That's simply because they are instances of different classes.

<h3>Conclusion</h3>
With JavaScript the behavior of objects can seem quite complicated at first, but understanding the underlining concepts can give you a lot of power and reveal the underlining simplicity.

We've looked at how object references, context, scope and instances come to play in JavaScript, and we've shown how to use them. 
Hopefully you now have a better understanding of these more advanced concepts! 


<h2>Using JavaScript Mixins</h2>

When it comes to advanced class composition, JavaScript has quite a number of approaches - a true smorgasbord of options. 
A type of pattern that is rarely spotted in the wild is the mixin-based inheritance pattern. 
Mixins are usually skipped by new JavaScript programmers (I did it too). 
I don't want to complain but mixins can sometimes be quite dense to write and comprehend. 
But they come with a bunch of features that are worth looking into.

The mixin pattern - as the name suggests - is a pattern of mixing together an object with other objects to add properties we need. 
Think of it like add-ons that can give your object additional properties, but these individual properties are not really subclasses themselves.

On the surface, mixins behave like object mixing layers, where we pass-in the target (the mixin) and the source. 
The target is appended to the source and a new object is returned.

A more accurate description is that a mixin works as factory where new a subclass object is returned. 
Through this whole process there is no definition of the subclass anywhere.

A more C++ analogy would be to compare them to abstract classes with virtual functions, allowing them to be inherited by other subclasses.

So, now that we know mixins allow us to create a modified definition that can be applied to existing superclasses to create new subclasses, let's see how mixin would look like:

<code>//The swim property here is the mixin
let swim = {
 location() {
   console.log(`Heading ${this.direction} at ${this.speed}`);
 }
};

let Alligator = function(speed, direction) {
 this.speed = speed,
 this.direction = direction
};

//This is our source object
let alligator = new Alligator('20 mph','North');

alligator = Object.assign(alligator, swim);
console.log(alligator.location());</code>

In the above snippet, we want to create an alligator that can swim. 
So we create a new <code>alligator</code> and then give it the <code>swim</code> feature. 
The <code>swim</code> object is the mixin or an extension that we want the <code>alligator</code> object to have using the <a href="https://alligator.io/js/dealing-with-objects/#objectassign"><code>Object.assign</code> method</a>.

The <code>Object.assign</code> method allows us to add more than one mixin at a time. 
A multiple mixin case would look like this:

<code>alligator = Object.assign(alligator, swim, crawl);</code>

Now let's look how mixins can be used with <a href="https://alligator.io/js/objects-prototypes-classes/">ES6 classes</a>:

<code>let swim = {
setSwimProperties(speed, direction) {
  this.speed = speed;
  this.direction = direction;
},

getSwimProperties(){
  console.log(`swimming ${this.speed} towards ${this.direction}`);
}
}

class Reptile {
constructor(name) {
  this.name = name;
}
}

Object.assign(Reptile.prototype, swim);
let alligator = new Reptile("alligator");
alligator.setSwimProperties("5 m/s", "upstream");
alligator.getSwimProperties();</code>

The advantage of adding functionality via the mixin approach is flexibility. 
The mixin being a very primitive function, as in it does exactly one thing, allows us to use these structures repeatedly and in a variety of scenarios. 
It can used with a native function call, used in a class definition, etc.

Another good thing is that it tends to keep the class hierarchy horizontal - by allowing superclasses to use the mixins to create new objects of desired subclass properties rather than making the inheritance chain longer for creating new sublasses for these cases.

Some things to keep in mind when using mixins though:
<li>The <code>Object.assign</code> (both in object and class implementation) does only a shallow copy of the mixin properties.</li><li>There can be potential name clashes while using properties from different mixins (the diamond problem in multiple inheritance)</li><li>It can be quite difficult to figure out from which mixin the property came from, since the properties are copied onto the source object. 
The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code> operator</a> cannot help us here.</li>



<h2>Read JavaScript Source Code, Using an AST</h2>

Let's say you have a big JavaScript file, remaining from the old days. 
It's 70K lines long and you desperately need to split it up using webpack or consorts. 
Then you need know what function or constants it exposes to the global scope.

Let a computer read through your code and extract what you want from it.

It's a job for Abstract Syntax Trees (AST).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/00af6016a09598c0245deafdf166f04c7c38409d/46ffc/images/js/traversing-ast/ast-hero.png" width="230" alt="AST Hero">

The following example is small. 
Our mission, should you choose to accept it, will be to extract the names of <strong>all</strong> the functions exposed in the global scope.

<code>// test the code
function decrementAndAdd(a, b){
  function add(c, d){
     return c + d;
  }
  a--;
  b = b - 1;
  return add(a,b)
}

// test the code
function incrementAndMultiply(a, b){
   function multiply(c, d){
     return c * d;
   }
   a++;
   b = b + 1;
   return multiply(a, b)
}</code>

Result should be <code>["decrementAndAdd", "incrementAndMultiply"]</code>.

<h3>Parsing the Code</h3>
An AST is the result of parsing code. 
For JavaScript, an AST is a JavaScript object containing a tree representation of your source. 
Before we use it, we have to create it. 
Depending on the code we are parsing, we choose the appropriate parser.

Here since the code is ES5-compatible, we can choose the <strong>acorn</strong> parser.

Here are some of the most well known Open Source ECMAScript parsers:

<table>
<thead><tr>
<th>Parser</th>
<th>Supported Languages</th>
<th>Github</th>
</tr></thead>
<tbody>
<tr>
<td>acorn</td>
<td>esnext &amp; JSX (using acorn-jsx)</td>
<td><a href="https://github.com/acornjs/acorn">https://github.com/acornjs/acorn</a></td>
</tr>
<tr>
<td>esprima</td>
<td>esnext &amp; older</td>
<td><a href="https://github.com/jquery/esprima">https://github.com/jquery/esprima</a></td>
</tr>
<tr>
<td>cherow</td>
<td>esnext &amp; older</td>
<td><a href="https://github.com/cherow/cherow">https://github.com/cherow/cherow</a></td>
</tr>
<tr>
<td>espree</td>
<td>esnext &amp; older</td>
<td><a href="https://github.com/eslint/espree">https://github.com/eslint/espree</a></td>
</tr>
<tr>
<td>shift</td>
<td>esnext &amp; older</td>
<td><a href="https://github.com/shapesecurity/shift-parser-js">https://github.com/shapesecurity/shift-parser-js</a></td>
</tr>
<tr>
<td>babel</td>
<td>esnext, JSX &amp; typescript</td>
<td><a href="https://github.com/babel/babel">https://github.com/babel/babel</a></td>
</tr>
<tr>
<td>TypeScript</td>
<td>esnext &amp; typescript</td>
<td><a href="https://github.com/Microsoft/TypeScript">https://github.com/Microsoft/TypeScript</a></td>
</tr>
</tbody>
</table>
All parsers work the same. 
Give it some code, get an <code>AST</code>.

<code>const { Parser } = require("acorn")

const ast = Parser.parse(readFileSync(fileName).toString())</code>

The TypeScript parser syntax is a little different. 
But it is well <a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API">documented here</a>.

This is the tree obtained by parsing the code in black with <code>@babel/parser</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/010de1f875240e3fe452f37e91f706bb9c20cf98/8e1c4/images/js/traversing-ast/code2ast.png" width="800" alt="Tree graph from @babel/parser">

<h3>Traversing</h3>
In order to find what we are going to extract, it's often better not to treat the whole AST at once. 
It'll be a large object with thousands of nodes even for small code snippets. 
So, before we extract the information we need, we refine our search.

The best way to do that is to only filter the tokens one cares about.

Once again, many tools are available to do this <em>traversing</em> part. 
For our example we are going to use <a href="https://github.com/benjamn/recast">recast</a>. 
It's very fast and has the advantage of keeping a version of your code untouched. 
This way, it can return the part of your code you want with it's original formatting.

While traversing, we'll find all the <code>function</code> tokens. 
This is why we use the <code>visitFunctionDeclaration</code> method.

If we wanted to look at variable assignments we would use <code>visitAssignmentExpression</code>.

<code>const recast = require('recast');
const { Parser } = require("acorn");

const ast = Parser.parse(readFileSync(fileName).toString());

recast.visit(ast, visitFunctionDeclaration(path){
 // the navigation code here...

 // return false to stop at this depth
 return false;
})</code>

<h3>AST node types</h3>
Usually the names of the token types are not obvious. 
One can use <a href="https://astexplorer.net/">ast-explorer</a> to look up the types researched. 
Just paste your code in the left panel, select the parser you are using and “voilà!”. 
Browse the parsed code on the right and find what <em>Node Type</em> you're looking for.

<h3>Shallow or deep</h3>
We don't always want to look at every level of the tree. 
Sometimes we want to do a deep search while other times we just want to look at the top layer. 
Depending on the framework, the syntax differs. 
Fortunately, it's usually well documented.

With <a href="https://github.com/benjamn/recast">recast</a>, if we want to stop searching at the current depth, just <code>return false</code> when you are done. 
This is what we did before. 
If we want to traverse through (go deep), we can use <code>this.traverse(path)</code> like you'll see below.

With <code>@babel/traverse</code> no need to tell babel where to continue. 
One only needs to specify where to stop with a <code>return false</code> statement.

<code>recast.visit(ast, visitFunctionDeclaration(path){
 // deal with the path here...

 // run the visit on every child node
 this.traverse(path);
})</code>

We went from a very broad search to a smaller sample. 
We can now extract the data we need.

<h3>Navigating from Path, to Node, to Property</h3>
The <code>path</code> object passed to the <code>visitFunctionDeclaration</code> is a <code>NodePath</code>. 
This object represents the connection between a parent and child AST Nodes. 
This <code>path</code> on its own is of no use to us because it represents the link between the function declaration and the body of the function.

Using <a href="https://astexplorer.net/">ast-explorer</a>, we find the contents of he path we are looking for.

The classic thing to do: <code>path.node</code>. 
It gets the child Node in the parent-child relationship. 
If you chose to search functions, the node in <code>path.node</code> will be of type <code>Function</code>:

<code>const functionNames = [];
recast.visit(ast, visitFunctionDeclaration(path){
 console.log(path.node.type); // will print "FunctionDeclaration"
 functionNames.push(path.node.id.name); // will add the name of the function to the array

 // return false to avoid looking inside of the functions body
 // we stop our search at this level
 return false;
})</code>

Try wrapping traversing functions in each other to look at subtrees. 
The code below will return every function that's exactly on the second level down. 
It would not recognize a function in a function in a function:

<code>const functionNames = [];
recast.visit(ast, visitFunctionDeclaration(path){
 var newPath = path.get('body');

 // subtraversing
 recast.visit(newPath, visitFunctionDeclaration(path){
   functionNames.push(path.node.id.name);
   return false;
 })

 // return false to not look at other functions contained in this function
 // leave this role to the sub-traversing
 return false;
})</code>

Mission Accomplished!! 

We programmatically found all the function names. 
We could as easily find the names of the arguments, or the exposed variables.

<h3>Glossary</h3>
<strong>AST Node</strong> one object in a tree. 
Examples: function declaration, variable assignment, object expression

<strong>NodePath</strong> link between a parent Node and a child Node in a tree

<strong>NodeProperty</strong> parts of the definition of the node. 
Depending on the node, one can have just a name or more info

<style> table { border-collapse: collapse; border-spacing: 0; background: var(--bg); border: 1px solid var(--gs0); table-layout: auto; margin: 2rem auto } table thead { background: var(--bg3) } table thead tr th { padding: .5rem .625rem .625rem; font-size: 1.2rem; font-weight: 700; color: var(--text-color) } table tr td, table tr th { padding: .5625rem .625rem; font-size: 1.2rem; color: var(--text-color); text-align: center } table tr:nth-of-type(even) { background: var(--bg3) } table tbody tr td, table tbody tr th, table thead tr th, table tr td { display: table-cell; line-height: 2.8125rem }</style>


<h2>JavaScript Regular Expressions for Regular People</h2>

Regular expressions, also known as regex or regexp, is a difficult subject to tackle. 
Don't feel ashamed if you're not 100% comfortable with writing your own regular expressions yet, as it does take some getting used to. 
My hope is that by the end of this article, you'll be one step closer into rocking your own expressions in JavaScript without the need of relying so much on copypasta from Stack Overflow.

The first step to writing a regular expression is to understand how to invoke it. 
In JavaScript, regular expressions are a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">standard built-in object</a>. 
Because of this, we can create a new <code>RegExp</code> object in few ways:
<li>The literal way, <code>/expression/.match('string to test against')</code>
</li><li>The <code>new</code> keyword with string argument, <code>new RegExp('expression')</code>
</li><li>The <code>new</code> keyword with literal, <code>new RegExp(/expression/)</code>
</li>

I'll use a combination of the methods just to show that they essentially perform the same job.

<h3>The Goals of our Regular Expression</h3>
In my example I'm going to be working with a string that contains my first name, last name, and a domain name. 
In the real world, the example would need much more thought. 
There are scores of subtleties when it comes to <a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">dealing with names</a>, which I won't address here.

Let's say I'm building a dashboard and want to display the name of the logged-in user. 
I have no control over the data that's returned to me so I have to make do with what I have.

I need to convert <code>aaron.arney:alligator.io</code> into <code>Aaron Arney [Alligator]</code>.

Regular expressions fit a lot of logic into a single condensed object. 
This can and will cause confusion. 
A good practice is to break down your expression into a form of pseudo-code. 
This enables us to see what needs to happen and when.

<ol><li>Extract the first name</li><li>Extract the last name</li><li>Extract the domain name</li><li>Format the string into the desired templated format <code>First Last [Domain]</code>
</li>
</ol>
<h3>Matching the First Name</h3>
To match a string with a regular expression, all you have to do is pass the literal string. 
The <code>i</code> at the end of the expression is a flag. 
The <code>i</code> flag in particular stands for <code>case insensitive</code>. 
That means that our expression with ignore casing on the string.

<code>const unformattedName = 'aaron.arney:alligator.io';

const found = unformattedName.match(/aaron/i);

console.log(found);
// expected output: Array [ "aaron" ]</code>

That works well, yet in our case it isn't a good approach since the name of the user isn't always going to be “Aaron.” This is where we explore programmatically matching strings.

Let's focus on matching a first name for the time being. 
Break the word down into individual characters, what do you see?

The name “Aaron” consists of five alpha characters. 
Does <em>every</em> first name have <em>only</em> five characters? No, but it is reasonable to assume that first names can range between 1 and 15 characters. 
To denote a character in range of a-z, we use <code>[a-z]</code>.

Now, if we update our expression to use this character class…

<code>const unformattedName = 'aaron.arney:alligator.io';

const found = unformattedName.match(/[a-z]/i);

console.log(found);
// expected output: Array [ "a" ]</code>

Instead of extracting “aaron” from the string, it only returns “a.” This is good, as regular expressions try their hardest to match as little as possible. 
To repeat the character match a number up to our limit of 15, we use curly brackets. 
This tells the expression that we watch to match the preceding token, our “a-z”, to match between 1 and 15 times.

<code>const unformattedName = 'aaron.arney:alligator.io';
const unformattedNameTwo = 'montgomery.bickerdicke:alligator.io';
const unformattedNameThree = 'a.lila:alligator.io';

const exp = new RegExp(/[a-z]{1,15}/, 'i');

const found = unformattedName.match(exp);
const foundTwo = unformattedNameTwo.match(exp);
const foundThree = unformattedNameThree.match(exp);

console.log(found);
// expected output: Array [ "aaron" ]

console.log(foundTwo);
// expected output: Array [ "montgomery" ]

console.log(foundThree);
// expected output: Array [ "a" ]</code>

<h3>Matching the Last Name</h3>
Extracting the last name should be as easy as copying and pasting our first expression. 
You'll notice that the match still returns the same value instead of both the first and last names.

Break down the string <em>character by character</em>, there is a full stop separating the names. 
To account for this, we add the full stop to our expression.

We have to be careful here. 
The <code>.</code> can mean one of two things in an expression.
<li>
<code>.</code> - Match any character except newline</li><li>
<code>\.</code> - Match a .</li>

Using either version in this context will generate the same result, but that won't always be the case. 
Tools like <a href="https://eslint.org/">eslint</a> will sometimes mark the escape sequence <code>\</code> as unnecessary, but I say better safe than sorry!

<code>const unformattedName = 'aaron.arney:alligator.io';

const exp = new RegExp(/[a-z]{1,15}\.[a-z]{1,15}/, 'i');

const found = unformattedName.match(exp);

console.log(found);
// expected output: Array [ "aaron.arney" ]</code>

Since we prefer to split the string into two items as well as excluding the full stop from being returned by the expression, we can now use <code>capturing groups</code>. 
These are denoted by parenthesis <code>()</code> and wrap around parts of your expression in which you want to be returned. 
If we wrap them around the first and last name expressions, we'll get new results.

The syntax for using capture groups is simple: <code>(expression)</code>. 
Since I only want to return my first and last name and <em>not</em> the full stop, wrap our expressions in parenthesis.

<code>const unformattedName = 'aaron.arney:alligator.io';

const exp = new RegExp(/([a-z]{1,15})\.([a-z]{1,15})/, 'i');

const found = unformattedName.match(exp);

console.log(found);
// expected output: Array [ "aaron.arney", "aaron", "arney" ]</code>

<h3>Matching the Domain Name</h3>
To extract “alligator.io”, we will use the character classes we've already used thus far. 
With some slight modification, of course.

Validating domain names and TLD's is a difficult business. 
We're going to pretend the domains that we parse, are always <code>> 3 &amp;&amp; &lt; 25</code> characters. 
The TLD's are always <code>> 1 &amp;&amp; &lt; 10</code>. 
If we plug these in, we will get some new output:

<code>const unformattedName = 'aaron.arney:alligator.io';

const exp = new RegExp(/([a-z]{1,15})\.([a-z]{1,15}):([a-z]{3,25}\.[a-z]{2,10})/, 'i');

const found = unformattedName.match(exp);

console.log(found);
// expected output: Array [ "aaron.arney:alligator.io", "aaron", "arney", "alligator.io" ]</code>

<h3>A Shortcut</h3>
I showed you the “long way” of going about the expression. 
Now, I'll show you how you can have a less verbose expression that captures the same text. 
By using the <code>+</code> quantifier, we can tell our expression to repeat the preceding token as many times as it can. 
It will continue until it hits a dead end, in our case the full stop. 
This expression also introduces the <code>g</code> flag, which stands for <code>global</code>. 
It tells the expression that we want to repeat our search as many times as possible, instead of the least times.

<code>// With the global flag
'aaron.arney:alligator.io'.match(/[a-z]+/ig);
// expected output: Array(4) [ "aaron", "arney", "alligator", "io" ]

// Without the global flag
'aaron.arney:alligator.io'.match(/[a-z]+/i);
// expected output: Array(4) [ "aaron" ]</code>

<h3>Formatting Output</h3>
To format the string, we'll be using the <a href="https://alligator.io/js/string-replace/"><code>replace</code> method</a> on the <code>String</code> object. 
The <code>replace</code> method takes two arguments:
<li>
<code>RegExp | String</code> - A regular expression object or literal</li><li>
<code>RegExp | function</code> - A regular expression or function</li>

<code>const unformattedName = 'aaron.arney:alligator.io';

// The "long" way
const exp = new RegExp(/([a-z]{1,15})\.([a-z]{1,15}):([a-z]{3,25}\.[a-z]{2,10})/, 'i');

unformattedName.replace(exp, '$1 $2 [$3]');
// expected output:  "aaron arney [alligator.io]"

// A slightly shorter way
unformattedName.replace(/([a-z]+)\.([a-z]+):([a-z]+\.[a-z]{2,10})/ig, '$1 $2 [$3]');
// expected output: "aaron arney [alligator.io]"</code>

In the above snippet, the <code>$1</code>, <code>$2</code>, <code>$3</code> are special patterns that get interpreted by the <code>replace</code> method.
<li>
<code>$1</code> - <code>The first result from the match array</code> =><code>A reference to the first parenthesized group</code>
</li><li>
<code>$2</code> - <code>The second result from the match array</code>=> <code>A reference to the second parenthesized group</code>
</li><li>
<code>$n</code> - So on and so on</li>

To capitalize the words, we can use another regex. 
Instead of formatting the output like we did above, we will pass a function. 
The function capitalizes the argument supplied and returns it.

Here, I'm introducing a couple new parts, <code>anchors</code>, <code>alternation</code>, and a new character class <code>[^]</code>.
<li>
<code>[^abc]</code> - Not <code>a</code>, <code>b</code>, or <code>c</code>
</li><li>
<code>\b</code> - Word boundary</li><li>
<code>ab|cd</code> - Logical “OR”, matches <code>ab</code> or <code>cd</code>
</li>

<code>// Capitalize the words
"aaron arney [alligator.io]".replace(/(^\b[a-z])|([^\.]\b[a-z])/g, (char) => char.toUpperCase());
// expected output: "Aaron Arney [Alligator.io]"</code>

Breaking down this expression into two parts..
<li>
<code>(^\b[a-z])</code> - Capture the first character of the string. 
<code>^</code> says to match the beginning of the string.</li><li>
<code>|([^\.]\b[a-z])</code> - OR, match a new word that <em>does not</em> start with a full stop <code>.</code>, as this is the TLD.</li>

<h3>Continuing Your Exploration</h3>
This is but a small taste of the power of regular expressions. 
The example I worked through is improvable, but how?
<li>Is the expression too verbose? Is it too simplified?</li><li>Does it cover edge cases?</li><li>Could you replace it with some clever string manipulation using native methods?</li>

This is where you take the knowledge you learned and try to answer those questions. 
Explore the following resources to help you in your journey and experiment!
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp">RegExp on MDN</a></li><li><a href="https://regexr.com/">RegExr (Regular Expression Playground)</a></li>



<h2>The JavaScript Prototypal Inheritance Pattern</h2>

JavaScript does not contain classes and but it's an still strongly object oriented language. 
The object-to-object relation in JavaScript is implemented with the <code>prototype</code> and the resulting prototypal pattern is very unique to JavaScript.

Before the <a href="https://alligator.io/js/objects-prototypes-classes/">ES6 <code>class</code> syntax</a>, the topic of inheritance has been mostly confusing for developers who came from other languages. 
This is because JS, in my humble opinion, is a truly object-driven language.

This makes it quite difficult to grasp the idea of inheritance in JavaScript objects, like: <strong>how do you create new objects with same properties without classes?</strong>. 
This article is an attempt to explain it and how this property applies to a specific object oriented pattern in JavaScript.

As we've previously seen, objects in JavaScript have the ability to inherit directly from other objects through a shared property called <code>prototype</code> and how the <code>prototype</code> is used for implementing inheritance in JavaScript objects.

Now, this inheritance is not the traditional inheritance that we're used to in class-based languages but instead it's something comparable to <em>object delegation</em>. 
Roughly meaning, if a particular property is not found in an object, then I'd check its prototype for the definition of the property in question.

Here is a quick snippet to show what I'm talking about:

<code>let Alligator = function(color) {
 this.color = color;
}

Alligator.prototype.introduce = function() {
console.log('I am ' + this.color);
}

let Croc = function(color) {
 Alligator.call(this, color);
}

Croc.prototype = Object.create(Alligator.prototype)

let alligatorObj = new Alligator('green');
let crocObj = new Croc('yellow');

alligatorObj.introduce(); // I am green
crocObj.introduce(); // I am yellow</code>

So what happened above is this - the instance of <code>croc</code> has a copy of a <code>prototype</code> that links to the <code>prototype</code> of <code>Croc</code> which in turn links to the <code>prototype</code> of <code>Alligator</code>. 
The <code>Alligator</code> <code>prototype</code> is able to provide us with the definition for <code>introduce()</code>.

This is what I mean by <em>delegation</em>, searching for the target behavior inside objects (i.e the <code>prototype</code>). 
Also, JavaScript prototypes can link to multiple prototypes, so in that way we can have multiple inheritance as well, but that's often a bad idea in practice.

The snippet is an example of how object-to-object code looks like. 
It's very primitive but facilitates direct transfer of properties and methods between objects. 
This is built into the design of JavaScript; the class syntactic sugar or the constructor are simply wrappers on top this to make it feel like classical OOP.

Most of the time, prototypal pattern is very simple and easy to implement. 
Why? Because of our classical understanding of objects and classes, we expect a constructor function to create an instance for us. 
In JavaScript any function can be a constructor, like this :

<code>function Alligator(color) {
This.color = color;
}

Let alligator = new Alligator('purple');</code>

All we have to do is prefix the <code>new</code> keyword to the function invocation and we have an object. 
All that the <code>new</code> keyword does is that it invokes the <code>Alligator()</code> function as a constructor by binding <code>this</code> (which is the new context) to the function call. 
It feels like we are simply going out of our way to make classical object pattern work in JavaScript. 
Compared to this, the prototypal pattern feels intuitive. 
Note also that by convention functions that are meant to be used as a constructor for new objects should start with a capital letter, otherwise it could get quite confusing to know where the <code>new</code> keyword should be used.


<h2>JavaScript Object Oriented Patterns: Factory Pattern</h2>

Organizing code is going to save us from a lot of pain. 
Using the features of <a href="https://alligator.io/js/objects-prototypes-classes/">Object Oriented programming</a>, we can employ certain design patterns to achieve better readability, reduce redundancy and create abstractions, if needed. 
One such pattern is the factory pattern.

The factory pattern is a type of Object Oriented pattern which follows the DRY methodology. 
As the name suggests, object instances are created by using a factory to make the required object for us.

Let's have a look at a very simple example of using the factory pattern to assemble an <code>alligator</code> object. 
To do that we first need to make factories that create the <code>alligator</code> parts for us:

<code>class TailFactory {
 constructor(props) {
   this.tailLength = props.tailLength;
 }
};

class TorsoFactory {
 constructor(props) {
   this.color = props.color;
 }
};

class HeadFactory {
 constructor(props) {
   this.snoutLenth = props.snoutLenth;
 }
};</code>

Now, we create a class that acts as an intermediary between the actual factories classes and the user. 
Let's call this the <code>ReptilePartFactory</code>:

<code>class ReptilePartFactory {
 constructor(type, props) {
   if(type === "tail")
     return new TailFactory(props);
   if(type === "torso")
     return new TorsoFactory(props);
   if(type === "head")
     return new HeadFactory(props);
 }
};</code>

Let's go ahead and assemble the actual alligator now and use the <code>ReptilePartFactory</code> to get the required parts for us:

<code>let alligator = {};
let alligatorProps = {
 tailLength : 2.5, 
 color: "green",
 snoutLenth: 1
};

//gets a tail from the tail factory
alligator.tail  = new ReptilePartFactory("tail", alligatorProps); 

//gets a torso from the torso factory
alligator.torso = new ReptilePartFactory("torso", alligatorProps);

//gets a head from the head factory
alligator.head  = new ReptilePartFactory("head", alligatorProps);</code>

Take at the look the pattern above, it seems like we could use the same <code>ReptilePartFactory</code> to create parts for alligator-like objects. 
The factories in the background would never have to know about the nature of the final object.

Thus, using the factory pattern gives us certain advantages:
<li>
<em>Dynamic object creation</em>: It can be used in cases where the type of the object is decided at runtime.</li><li>
<em>Abstraction</em>: The user never really has to access the actual object's constructor.</li><li>
<em>Reusability/Maintenance</em>: Same factories can be used for similar objects and it allows us to add/remove new object classes easily without changing a lot of code.</li>

Now that we have some understanding of the factory pattern, let's explore a little bit on writing better factory pattern code.

The example above uses an if-ladder to find out which factory to call based on user input. 
This is a simple implementation, intuitive and not very open to changes. 
If we have new parts to add later, then we'd have to disturb the <code>ReptilePartFactory</code>. 
This is a violation of SOLID principles, which states “Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification”.

How about we store the factory classes in an object and call the required part factory by using the part we want as the key? First we'd have to register the factories, it'd be as simple as:

<code>let registeredPartFactories = {};
registeredPartFactories['tail'] = class TailFactory{
 ...
};

registeredPartFactories['torso'] = class TorsoFactory {
 ...
};

registeredPartFactories['head'] = class HeadFactory {
 ...
};</code>

And now, the abstract layer can call the factories like this:

<code>class ReptilePartFactory {
 constructor(type, props) {
   return new registeredPartFactories[type](props);
 }
};</code>

This approach is much cleaner and allows to expand our factories without affecting code in the <code>ReptilePartFactory</code>.

<h3>In conclusion</h3>
There are several other object oriented patterns which also increase readability and quality. 
So before using the factory pattern, check if there is a real requirement for it. 
If you're going to create similar types of objects repeatedly and also need a layer to create new instances using these objects while providing some level of abstraction to the creation logic, then yes - the factory pattern is a good option.


<h2>Objects, Prototypes and Classes in JavaScript</h2>

Considering the fact that almost everything in JavaScript is an object, object oriented JavaScript code is very different from other object-capable languages. 
The JS object system is more of a prototype-based object system instead.

Coming from a C++ background, I was aware of the Object Oriented programming paradigm and had a very rigid idea of how Objects and Classes <strong>should</strong> work. 
Exposure to other languages like Java only seemed to further establish this idea. 
While these languages have their own semantics on how objects and classes work; Javascript, for the new user, is quite a revelation.

First off the bat, JavaScript objects are very different in the way they are created. 
There is no requirement for a class. 
Object instances can be created using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new">new operator</a>:

<code>let Reptile = new Object() {
// ...
}</code>

or with a function constructor

<code>function Reptile() {
// ...
}</code>

Second, JavaScript objects are <strong>very</strong> flexible. 
While classic object oriented languages allow only property modification or property slots, JavaScript allows objects to modify their properties and methods; i.e. 
JavaScript objects have both property and method slots.

My first thought at the discovery was “yeah freedom!” but this came with a cost - a need to understand the prototype property in JavaScript. 
The knowledge of the prototype is essential to a developer who wishes to implement any semblance of an object oriented system in JavaScript.

All JavaScript objects are created from the <code>Object</code> constructor:

<code>var Reptile = function(name, canItSwim) {
 this.name = name;
 this.canItSwim = canItSwim;
}</code>

And the <code>prototype</code> allows us to add new methods to objects constructors, this means that the following method now exists in all instances of <code>Reptile</code>.

<code>Reptile.prototype.doesItDrown = function() {
 if (this.canItSwim) {
   console.log(`${this.name} can swim`);
 } else {
   console.log(`${this.name} has drowned`);
 }
};</code>

Object instances of <code>Reptile</code> can be now created:

<code>// for this example consider alligators can swim and crocs cannot
let alligator = new Reptile("alligator", true);
alligator.doesItDrown(); // alligator can swim

let croc = new Reptile("croc", false); 
croc.doesItDrown(); // croc has drowned</code>

The <code>prototype</code> of the <code>Reptile</code> object is now the basis for inheritance, the <code>doesItDrown</code> method is accessible to both <code>alligator</code> and <code>croc</code> because the <code>prototype</code> of <code>Reptile</code> has this method. 
The <code>prototype</code> property is shared amongst all its instances and is accessible via the <code>__proto__</code> property of a particular instance.

Now, because of the existence of method slots and a common <code>prototype</code> instance property being shared across all instances, some very neat tricks are possible which are very weird to C++ folks:

<code>croc.__proto__.doesItDrown = function() {
 console.log(`the croc never drowns`);
};

croc.doesItDrown(); // the croc never drowns
alligator.doesItDrown(); // the croc never drowns</code>

Change one instance's <code>prototype</code> property or method, all instances of the object are affected. 
This means we could be deleting stuff as well. 
A croc tired of drowning could potentially do this:

<code>delete croc.__proto__.doesItDrown
alligator.doesItDrown();

//TypeError: alligator.doesItDrown
// is not a function</code>

Now no one gets to swim.

This is just a silly example to show how fundamental the <code>prototype</code> is to the Object system in JavaScript and how it can be quite jarring to people from other object oriented languages.

With the ES6 syntax, JavaScript has been provided the feature to create classes.

However, the concept of true classes does not exist in JavaScript but it is emulated through <code>prototype</code> and the class syntax is just syntactic sugar around it. 
Therefore, understanding this behavior is important to realize the convenience and limitations of ES6 classes.

With the new <code>class</code> syntax, <code>Reptile</code> would be defined as:

<code>class Reptile {
 constructor (name, canItSwim) {
   this.name = name;
   this.canItSwim = canItSwim;
 }

 doesItDrown () {
  if(this.canItSwim) 
   console.log(`${this.name} can swim`);
  else
   console.log(`${this.name} has drowned`);
 }
}

let alligator = new Reptile("alligator", true);
alligator.doesItDrown(); //alligator can swim</code>

This does not mean it brings nothing new to the offer for <code>prototype</code> users, some pitfalls can be avoided by using ES6 classes, like making the <code>new</code> keyword mandatory for creating instances.

<code>let croc = Reptile("croc", false);
//TypeError: Class constructor Reptile cannot be invoked without 'new'</code>

This is actually a good thing, since it prevents accessing the wrong context when using the object properties and methods, which is usually the global scope or the window object.

<h3>In Conclusion</h3>
Though JavaScript right now does certainly lack features like truly private members. 
It has made creating objects via class syntax, instead of prototypes closely resemble classes from other OO languages like C++/Java.

<hr>
PS. 
There has been a proposal to TC39 for creating truly private members in JavaScript classes, you can follow it <a href="https://tc39.github.io/proposal-class-fields">here</a> and contribute your opinion. 
If it were to be included in the next revision, then we'd have something like:

<code>class Foo {
 #a; #b; // # indicates private members here
 #sum = function() { return #a + #b; };
}

// personally this format reminds me of $variable in PHP.
// I'm not sure if that's a good thing </code>


<h2>Tricks with JavaScript Destructuring</h2>

In order to understand the <a href="https://alligator.io/js/object-array-destructuring-es2015/">newer destructuring syntax</a> introduced in ES6, let's cover the “old” way. 
I'll mention this a couple times throughout, but these are optional syntaxes that MAY help. 
There are still some use cases that are cleaner with the original methods, such as property accessors, and that is perfectly valid.

<code>// some object
const apple = {
 numberOfLeaves: 2,
 colors: {
   actual: ['green', 'yellow'],
   possible: ['red', 'green', 'yellow'],
 },
 kind: 'Golden Delicious',
 sku: 'A-GD-01',
};</code>

Here is how we might get values from this object before ES6:

<code>// property accessors using the dot syntax
const kind = apple.kind;
const sku = apple.sku;</code>

And now that we have destructuring, we can do something like this to extract both of these properties from the object and assign them to new <code>const</code> variables:

<code>const { kind, sku } = apple;</code>

It comes in handy for accessing nested values. 
You can also choose your own name for the variable - it doesn't have to match the property name!

<code>// instead of:
//   const colors = apple.colors.actual;
//   const possibleColors = apple.colors.possible;

const { actual: colors, possible: possibleColors } = apple.colors;

console.log(colors); // outputs ["green", "yellow"]
console.log(possibleColors); // outputs ["red", "green", "yellow"]</code>

<h3>Array Destructuring</h3>
Array destructuring is very similar, and allows us to grab only some of the values from an array, like so:

<code>const names = ['Jack', 'Janet', 'John', 'Jessie', 'Jaqueline', 'Jerry', 'Justin', 'Julie', 'Jake'];

const [first, second, third, ...theRest] = names;

console.log(first); // outputs "Jack"

console.log(theRest); // outputs ["Jessie", "Jaqueline", "Jerry", "Justin", "Julie", "Jake"]</code>

As you can see, we are extracting the first 3 items into their own variables, and using the <a href="https://alligator.io/js/rest-parameters-es6/">rest syntax</a> <code>...</code> to assign the remaining values into another new variable.

We do not have to assign the remaining values to a variable. 
Let's say we only want the first array value - we can just enclose the variable in brackets.

Now, we're going to combine the array destructuring with object destructuring to pull out the one value we want, reducing the extraction into one statement.

<code>const winners = [
 { name: 'Mario',   time: 110 },
 { name: 'Waluigi', time: 115 },
 { name: 'Toad',    time: 116 },
 { name: 'Yoshi',   time: 124 },
 { name: 'Bowser',  time: 129 },
];

function getBestTimeOf(racers) {
 // extract only the first item and from that, we only assign 
 // the property of time to the new variable of bestTime
 const [{ time: bestTime }] = racers;
 return bestTime;
}

console.log( getBestTimeOf(winners) ); // outputs 110</code>

Some may not think that this extraction is cleaner than <code>const bestTime = winners[0].time;</code> and I agree that we may lose some ability to quickly read the code. 
That is why every strategy requires foresight and common sense before implementing it. 
In your real-life examples, you will likely be pulling more than just ONE property from ONE array value. 
Destructuring will greatly help at that point.

<h3>Two more quick tips for arrays</h3>
<ol><li>You can swap values, assuming that they are not defined with <code>const</code>.</li></ol>
<code>let a = 2;
let b = 5;

[a, b] = [b, a];
console.log(a); // 5
console.log(b); // 2</code>

<ol><li>You may skip values by leaving the slot with a comma. 
In this example, I'll pull only the second value. 
Don't worry about the regular expression usage - I have altered the code slightly from a project of mine in order to show a possible usage.</li></ol>
<code>const [,, three] = [1, 2, 3, 4, 5, 6, 7];
console.log(`I selected ${three}.`); // outputs "I selected 3."</code>

<h3> Hot Tips for Functions </h3>
<h3>Multiple Return Values</h3>
You can use array destructuring to cleanly return multiple values from a function! React devs using the <a href="https://reactjs.org/docs/hooks-intro.html">new hooks functionality</a> may be familiar with how this is used:

<code>const [count, setCount] = useState(0);</code>

All you need to do to have the same functionality of returning multiple values is to return those values. 
Literally.

<code>function getCoordinates(address) {
 // use an API to get the lon/lat of an address
 const coordinates = maps.address(address).coordinates;
 return [coordinates.lon, coordinates.lat];
}

// later I can get this with
const [longitude, latitude] = getCoordinates(someAddress);</code>

<hr>
<h3>Expressive Parameter / Argument Syntax</h3>
This is by far my favorite usage of destructuring. 
We are going to use objects as both our function parameters AND arguments! This can greatly simplify the structure of functions. 
Just as a reminder, you do not need to use this in every case, such as for those that are already straightforward.

To clarify — A parameter is a variable in a function declaration. 
An argument is the data you pass into the function parameters when it is called.

Below is a snippet to clarify these definitions. 
Don't pay too much attention to what the code is doing - look to see what the notes are pointing out.

<code>// level and data are the parameters
function logData(level, data) {
 console.log(`New log of level: ${level}`);
 console.log(data);
}

const someLevel = 'error';
const calculatedData = {
 id: 1,
 name: 'Jack',
};

// the VALUES of someLevel and calculatedData are the arguments 
// we are passing to logData() - the variable names are irrelevant
logData(someLevel, calculatedData);</code>

<hr>
Here is some code which could controls part of a telecommunications switch. 
This function sets a variable on a call channel. 
Again, disregard the actual code purpose and focus on the notes and strategy.

<code>// ...inside a class
async set({
 variable = '',
 value = '',
 callId = '',
} = {})
{
 console.log(`Setting ${variable} equal to ${value} on call ID: ${callId}`);
 return await this.api('call_setvar', `${callId} ${variable} ${value}`);
}</code>

I call this function like:

<code>// callId and url are defined above

await this.set({ callId, variable: 'custom_transfer_url', value: url });</code>

This method of passing-in an object and having it be implicitly destructured on the other end lends us some valuable benefits:

<ol><li>named parameters (self-documenting)</li><li>default values (via the <code>=</code> sign) **</li><li>order is inconsequential</li><li>object <a href="https://alligator.io/js/object-property-shorthand-es6/">property-value shorthand</a> (use the same name for property and variable that holds the value, such as for how uuid is passed in) <code>uuid: uuid,</code> was shortened to <code>uuid,</code>
</li>
</ol>
You do not have to put each variable on a different line as you see in my function declaration. 
I do this so that I can cleanly provide defaults and notes if I choose to.

** Note that default values will only be used if the value is undefined, meaning that it was not passed-in or it was explicitly set to undefined. 
Null values will not trigger the default and will remain null.

I hope that these uses of array and object destructuring have given you some new ways to simplify and structure your code! If you think any of your fellow developers could use these tips, please share this with them. 
You can also tweet or share this and link to <a href="https://twitter.com/alligatorio">@alligatorio</a>!


<h2>Custom-Styled JavaScript Console Logging</h2>

Are you in the mood for a lightweight and fun project? We are going to build a custom-styled console logging class that you can use in place of <code>console.log()</code>! We're going to add some color and variation to our consoles. 
It will be similar in functionality to <a href="https://www.npmjs.com/package/debug">the debug npm package</a>.

This should take no more than <em>10 minutes</em>. 
To make things simpler, we can use <a href="https://codesandbox.io/">CodeSandbox</a>. 
It's especially good for quick projects like this. 
We'll be using the <em>Vanilla</em> template, which utilizes <a href="https://parceljs.org/">Parcel</a> to give us features like bundling, importing, ES6 classes, etc. 
Check out <a href="/tooling/parcel/">this post</a> for an introduction to Parcel if you're curious to know more.

I like to outline what my code should look like before I get started. 
Something like:

index.js

<code>import CustomLogging from './CustomLogging';

const custom = new CustomLogging;
const error = new CustomLogging('error');
error.setBodyStyle({ color: 'red', size: '2rem' });

// the output
console.log('Regular log.');
custom.log('Hello there!');
error.log('Something bad happened!');</code>

In the console tab (at the bottom of CodeSandbox), this outputs:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e66a4c9a9cc15735078c953f3e59dfa2dfdec29a/297c2/images/js/custom-styled-console-logging/custom-logging-end-result.png" alt="Final result of custom logging" width="600">

<h3>Our Strategy</h3>
We're going to use an ES6 class to deliver this functionality. 
Because of Parcel, we can <a href="https://alligator.io/js/modules-es6/">import/export</a> this class to be used as a “package” of sorts. 
At it's core this project will utilize the <em>%c</em> feature in the regular <code>console.log()</code> method. 
See our article on the <a href="https://alligator.io/js/console/">JavaScript console API</a> for more details.

If you're feeling adventurous, try to see what you can come up with on your own! Tweet your results to <a href="https://twitter.com/alligatorio">@alligatorio</a> to show it off.

<h3>Let's Get Coding</h3>
First, clear the initial code in <code>index.js</code> so we're starting fresh. 
Be sure to save as you go.

Create a new <code>CustomLogging.js</code> file in the <code>src</code> directory. 
Here's a basic outline:

CustomLogging.js

<code>class CustomLogging {
 log() {
   console.log("Hey, good lookin`!");
 }
}

export default CustomLogging;</code>

You'll notice that this isn't dynamic - we're simply trying to make sure it works. 
To get this to be logged to the console, head over to the <code>index.js</code> file where you'll import the class, instantiate it, and then call the <code>log()</code> method.

index.js

<code>import CustomLogging from './CustomLogging';

const custom = new CustomLogging;

custom.log();</code>

<h3>Add Message and Styling</h3>
Now let's pass in any message we want and begin some styling:

CustomLogging.js

<code>class CustomLogging {
 log(
   body = "" // defaults to empty string
 ) {
   console.log(
     `%c${body}`, // everything after the %c is styled
     `color: green; font-weight: bold; font-size: 2rem;`
   );
 }
}

export default CustomLogging;</code>

…which is fired by:

index.js

<code>// ...

custom.log('May the Force be with you.');</code>

<h3>Dynamic Styling</h3>
Let's create a constructor to set defaults. 
We'll then add a method to modify the styling on the fly:

CustomLogging.js

<code>class CustomLogging {
 constructor() {
   // choose whatever defaults you'd like!
   this.body = {
     color: "#008f68",
     size: "1rem"
   };
 }

 setBodyStyle({ color, size }) {
   // this will only set a value that is passed-in
   if (color !== undefined) this.body.color = color;
   if (size !== undefined) this.body.size = size;
 }

 log(body = "") {
   // adds dynamic styling via the template literals
   console.log(
     `%c${body}`,
     `color: ${this.body.color}; font-weight: bold; font-size: ${
       this.body.size
     }; text-shadow: 0 0 5px rgba(0,0,0,0.2);`
   );
 }
}

export default CustomLogging;</code>

And again, we'll use it:

index.js

<code>// ...

custom.setBodyStyle({ color: 'red' });
custom.log('Anger, fear, aggression; the dark side of the Force are they.');</code>

<h3>What's the Title?</h3>
Lastly, we'll add a title into the constructor so that different instances can display their label:

CustomLogging.js

<code>class CustomLogging {
 constructor(title) {
   this.title = {
     body: title || "---",
     color: "darkgrey",
     size: "1rem"
   };

   this.body = {
     color: "#008f68",
     size: "1rem"
   };
 }

 setTitleStyle({ color, size }) {
   if (color !== undefined) this.title.color = color;
   if (size !== undefined) this.title.size = size;
 }

 setBodyStyle({ color, size }) {
   if (color !== undefined) this.body.color = color;
   if (size !== undefined) this.body.size = size;
 }

 log(body = "") {
   // the second line is now the body because the first references the content after the first %c for the title
   console.log(
     `%c${this.title.body} | %c${body}`,
     `color: ${this.title.color}; font-weight: bold; font-size: ${
       this.title.size
     };`,
     `color: ${this.body.color}; font-weight: bold; font-size: ${
       this.body.size
     }; text-shadow: 0 0 5px rgba(0,0,0,0.2);`
   );
 }
}

export default CustomLogging;</code>

Invoke it with:

index.js

<code>import CustomLogging from './CustomLogging';

const custom = new CustomLogging;
const error = new CustomLogging('error');
error.setBodyStyle({ color: 'red', size: '2rem' });

console.log('Regular log..');
custom.log('Hello there!');
error.log('Something bad happened!');</code>

<h3> Whoo! </h3>
We did it! Your console should now match the example at the top of the post. 
Pat yourself on the back, show a friend, or do whatever floats your boat.

<h3>Extra-Cool Functionality</h3>
What functionality can you add to this? Here are some ideas:
<li>More styling options</li><li>Detect if body of <code>log()</code> method is an array or object and print them out in a styled way</li><li>Track time between each log and tag that onto the end</li><li>Review the ‘debug' npm package for more ideas.</li>



<h2>Don't Be Afraid of the JavaScript Stack Trace</h2>

You start working on a new project right after you finish reading this post. 
It's not outlandish - something not too far off from a previous project you've done.

After 20-or-so minutes of getting the project base ready (so that you can begin the real project), you get hit with an error. 
It doesn't look too bad, but after an hour of searching on Google and making 10 changes to try to remedy the problem, you get snapped back to reality. 
You just spent a good chunk of time on code that won't affect your bottom line. 
Even if you're not getting paid for the project, you feel defeated.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/cef891d3da5693274c5f7ba253828b73b07a9ca5/3aa37/images/js/stack-trace/stack-trace-game.png" alt="Basic example of stack trace" width="600">

Before diving into other avenues of fixing the issue, take a step back, clear your mind, get a drink of water, and then consider these points:
<li>It's not a waste of time to LEARN - it's a waste to mindlessly attack a problem.</li><li>Is it worth starting over?</li><li>Maybe you could try a different setup, like a framework, to mitigate the chances of setup errors (because that's where the faux-reality issue is emerging). 
This may also make it more likely that your issues are common across other users of the framework.</li><li>Ask for another person's insight. 
An honest question is not a sign of weakness - in fact, it can increase team harmony.</li>

Now let's assume that you have gone through the options above. 
You feel that it's best to move forward and fix this issue - what strategy can you take? We're going to focus on one particular strategy - looking into the stack trace to determine the cause. 
Finding root causes are most of the battle. 
[Keep in mind that this short list is based on my own experience and is not comprehensive. 
That being said, try to have an open mind to try new tactics. 
]

<ol><li>When you run into an issue, <a href="/workflow/git-commit-and-collab/">commit your code</a> (at least into your local git). 
Even though this code may not be in a completely functional state, it is better than the mess you may eventually get to. 
Doing small commits along the way will help you keep track of what you've tried.</li><li>Set a timer (<a href="https://en.wikipedia.org/wiki/Pomodoro_Technique">Pomodoro-style</a> or just a regular timer). 
I suggest no more than 30 minutes. 
This doesn't mean that you need a solution in that time frame, but you can use a small break to re-evaluate.</li><li>Have a good idea of where to look (depending on your platform).</li><li>Know how to pick out key words and details.</li><li>Understand how to look it up.</li>
</ol>
We will go into greater detail on the last three points from above.

<h3>Where to Look</h3>
Here are a few different situations and where the stack trace can show up.
<li>Node (backend) –> <em>terminal console</em>
</li><li>React / Vue / vanilla JS (frontend) –> <em>browser console</em>
</li>

<h3>There's no stack trace. 
What do I do?</h3>
In some cases, no trace shows. 
Why is that? This is usually because there is a logical error (it doesn't work the way you thought it would) and the code itself is sound. 
To try to find the source of the problem, you could log information to the console before and after where you think the issue is.

<h3>What to Look For</h3>
Think of a stack trace like a stack of dishes. 
When they are piling up and they start to fall over, you know that last couple plates are the culprit. 
In the same way, the most recent actions (which is likely where the problem resides) are at the top of the stack trace.

It's also important to note that the lines you see in this trace are not all made up of errors. 
It is a history of where the program/script has gone up until that point, making it a great tool for pinpointing the real problem.

<h3>Error/Exception Messages</h3>
If the issue involves a package, the author may have put a good message or hint to help out. 
Even the language-level exceptions usually have hints. 
This would be the perfect place to start.

<h3>File Names</h3>
Typically the problem lies in your own source code and not other packages (at least that's the general rule), so look for files that have your base directory. 
If a file is one you've recently made changes to, that's a good indication to check there.

<h3>Line Numbers</h3>
You're in luck. 
Not only do you get to see the file name, but the trace includes the line number and sometimes the column number. 
The column tends to not be as useful, but hey - thanks to whoever decided to put those in there!

<h3>Exception Type(s)</h3>
Sometimes the name of an exception thrown can give you a solid clue. 
Likely you won't know exactly what it means though. 
Use some insight gleaned from the next section to search based on these.

If you run into this issue often, consider memorizing some of the more common exceptions for your language or framework.

<h3>How deep do I go?</h3>
Some traces are <em>very</em> long. 
You'll likely get heavy eyelids if you have to read the whole thing as if it were a novel. 
So where does it shift from helpful to a waste of time?

My experience has been that you can find the clues you need in the first 5 items of the trace. 
If you've combed through it carefully and you still haven't found anything, then, by all means, continue.

Let's create a fake error to see some of these clues in effect. 
You can run this client-side or server-side:

demo.js

<code>firstFunction = () => {
 secondFunction();
}

secondFunction = () => {
 thirdFunction();
}

thirdFunction = () => {
 notDefined();
}

firstFunction();</code>

This produces:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/fde71307fc0b5804862950159b06d36d6901929a/5b8cd/images/js/stack-trace/stack-trace-example.png" alt="Comprehensive example of stack trace" width="600">

<h3>What to Look Up</h3>
If a message is provided in the error, this may be the best thing to search on.

<h3>Tips for Google Search</h3>
<li>Use quotes to search for the exact phrase.</li><li>Place an asterisk within those quotes to specify an unknown word or phrase.</li><li>Use the minus sign to show that you want to eliminate results containing the word(s).</li><li>State the phrase “how to” at the beginning if you're looking for a tutorial (Google can be smart like that).</li>

<h3>Tips for Stack Overflow Search</h3>
<li>Add tags to your query by surrounding them with square brackets: <code>[vue] trigger an event</code>.</li><li>Typically you want to look for the results that have the solid green ‘answers' box. 
This means that one has been accepted as the correct answer.</li><li>Take a look at other answers besides the one marked as correct. 
They may be more modern or clean, or just your style.</li>

Right click all of the search results that look promising to open them up in a new tab. 
For faster flow, use your platform's shortcut key (Ctrl on Windows, Cmd on Mac) while you click the link.

Be sure to understand what the code is actually doing before you accept it into your final product.

<h3>Problem Solved - Or Is It?</h3>
How many times do we run into an issue, do a search, find a Stack Overflow post with the answer and then see that we've already upvoted it?  To avoid this, we should document the issue with the solution and more importantly do at least one of two things:

<ol><li>Create a new test.</li><li>Write some error-handling. 
You could even catch the error and spit out your own error with a custom message.</li>
</ol>
<code>if (valueIsNotCorrect) throw new Error(`D'oh, you did it again! Fix me by ...`);</code>

These are both essentially documentation, so double win!

<hr>
To end, here's a good laugh taken from <a href="https://twitter.com/divineomega/status/695744177557106688?lang=en">Jordan Hall on Twitter</a>:

<code>window.onerror = error => {
 // redirect to SO with error as query
 window.location.href = `https://stackoverflow.com/search?q=[js]${error.message}`;
}</code>


<h2>Flatten Arrays in Vanilla JavaScript with flat() and flatMap()</h2>

Libraries like <a href="https://lodash.com/">Lodash</a> and <a href="https://underscorejs.org/">Underscore.js</a> have provided us with utilities to help with flattening arrays for a while now. 
Thanks to the continuous evolvement of the ECMAScript standard, we'll now be getting methods to do that directly in vanilla JavaScript, without the need for external utility functions.

As you may have seen if you've been following the interwebs lately, these new methods to flatten arrays have triggered quite a bit of a stir. 
Now known at the <a href="https://developers.google.com/web/updates/2018/03/smooshgate">#Smooshgate</a>, the gist of it is that Array.prototype.flatten() is being monkey-patched by MooTools, which is still used by some websites, so at some point a suggestion popped-up to name the method <em>smoosh</em> instead of <em>flatten</em> as a joke, to avoid breaking some websites still relying on MooTools. 
A lot of people took the smoosh suggestion seriously, and quite a bit of keystrokes were lost over this.

Now that the dust has settled from this mini-controversy, the final decision has been to go with <em>flat</em> and <em>flatMap</em> as the two method names to help with flattening arrays in JavaScript.

Let's go over them now.

<h3>Array.prototype.flat()</h3>
As its name suggests, the <em>flat()</em> method available on the Array prototype returns a new array that's a flattened version of the array it was called on. 
Without arguments passed-in, a depth of 1 is assumed. 
Otherwise, if a number is passed-in as the first argument, it's used as the maximum depth to flatten the array.

Here's a simple example:

<code>const animals = [['', ''], ['', '']];

const flatAnimals = animals.flat();
// same as: const flatAnimals = animals.flat(1);

console.log(flatAnimals);

// ['', '', '', '']</code>

And notice what happens when the total depth of the array is larger than the maximum depth for the flat method:

<code>const animals = [['', ''], ['', '', ['',[''], '']]];

const flatAnimals = animals.flat(2);

console.log(flatAnimals);
// ['', '', '', '', '',[''], '']</code>

You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity">Infinity</a> if you want to flatten an array of arbitrary depth:

<code>const animals = [['', ''], ['', '', ['',[''], '']]];

const flatAnimals = animals.flat(Infinity);

console.log(flatAnimals);
// ['', '', '', '', '', '', '']</code>

<h3>Array.prototype.flatMap()</h3>
The <em>flatMap()</em> method available on the Array prototype has the same effect as using the <em>map()</em> method followed by the <em>flat()</em> method with the default depth of 1. 
In other words, <strong>flatMap()</strong> maps each value to a new value and then the resulting array is flatten up to a maximum depth of 1.

Here's an example:

<code>const animals = ['', '', '', ''];
const noises = ['woof', 'meow', 'baa', 'mooo'];

const mappedOnly = animals.map((animal, index) => [animal, noises[index]]);
const mappedAndFlatten = animals.flatMap((animal, index) => [animal, noises[index]]);

console.log(mappedOnly);
// [['', 'woof'], ['', 'meow'], ['', 'baa'], ['', 'mooo']

console.log(mappedAndFlatten);
// ['', 'woof', '', 'meow', '', 'baa', '', 'mooo']</code>

The callback function passed-into <strong>flatMap()</strong> expects the same arguments as the ones that can be passed-in to the traditional <a href="https://alligator.io/js/map-array-method/"><em>map()</em></a> method, the first being the current value, the second being the index of the current value in the array and the third being the full array being mapped over.

<h3>Browser Support</h3>
Support is already pretty good, with the latest version of most recent browsers supporting both methods. 
For example, the methods are supported in Chrome 69+, Firefox 62+ and Safari 12+. 
There currently is no support for any version of Internet Explorer or Edge, at the time of this writing.

If you want to start using it now and support all browsers, you can always use the official polyfill/shim for <a href="https://github.com/es-shims/Array.prototype.flat">flat</a> and <a href="https://github.com/es-shims/Array.prototype.flatMap">flatMap</a>.


<h2>A Look at the Channel Messaging API</h2>

<a href="https://alligator.io/js/service-workers/">Service Workers</a> are isolated from the main JavaScript thread. 
Being a special kind of Web Worker, they share the same limitations. 
How do you communicate back to the main thread? Browsers offer us the <strong>Channel Messaging API</strong>. 
This API allows two scripts to communicate by passing simple messages on a shared channel.

It's also useful to communicate with iframes, but we'll focus on the worker use case in this post.

<h3>Instantiate the Channel</h3>
You can instantiate a channel using the following syntax:

<code>const channel = new MessageChannel()</code>

On the <code>channel</code> object, which is of type <code>MessageChannel</code>, you have access to the two ports, <code>port1</code> and <code>port2</code>.

The gist is that at each end of the channel listen on one port, and you send messages to the other port.

When you create a channel, you send your messages to <code>port2</code>.

<h3>Sending Messages Through the Channel</h3>
You send a message through the channel using the <code>postMessage()</code> method, which is made available on the <code>window</code> object if the script is running in the browser:

<code>const data = { color: 'green' }
const channel = new MessageChannel()
window.postMessage(data, [channel.port2])</code>

<h3>Listen for Incoming Messages on the Receiving End</h3>
On the receiving end, in a Service Worker for example, you add a listener on <code>self</code>, a global that workers have to access themselves:

<code>self.addEventListener('message', event => {
 console.log('Incoming message')
})</code>

The <code>event</code> object passed as parameter contains the data attached to this event in the <code>data</code> property:

<code>self.addEventListener('message', event => {
 console.log('Incoming message')
 console.log(event.data)
})</code>

<h3>Send a Message Back</h3>
To send a message back, in the event listener we have access to the other port by referencing <code>event.ports[0]</code>.

On this object we can call <code>postMessage()</code> and post back additional data:

<code>self.addEventListener('message', event => {
 console.log('Incoming message')
 console.log(event.data)

 const data = { shape: 'rectangle' }
 event.ports[0].postMessage(data)
})</code>

<h3>Receiving a Message as the Sender</h3>
The sender has access to the channel object it created, so it can attach an <code>onmessage</code> handler to the <code>message.port1</code> object:

<code>channel.port1.onmessage = event => {
 console.log(event.data)
}</code>

<h3>What Kind of Messages Can You Send?</h3>
In <code>postMessage()</code> you can send any basic JavaScript data type. 
This means booleans, strings, numbers, and objects. 
You can use arrays to pass multiple objects.


<h2>First Steps with the Cache API</h2>

The Cache API was created to allow <a href="https://alligator.io/js/service-workers/">Service Workers</a> to have a deeper and fine-grained control over the caching of resources.

Through the Cache API a Service Worker can decide to cache resources for offline consumption and retrieve them later.

With resources, we mean complete responses from URL, like HTML pages, CSS, JavaScript files, images, JSON, and any other resource that can be consumed by your web pages or web apps.

<h3>Browser Support</h3>
You can't talk about recent web technology without detailing which are the browsers supported.

In the case of the Cache API, we are talking about:
<li>Firefox 39 and higher</li><li>Chrome 40 and higher</li><li>Opera 29 and higher</li><li>Safari 11.1 and higher</li><li>iOS Safari 11.4 and higher</li><li>Edge 17 and higher</li><li>UC Browser 11.8 and higher</li><li>Chrome for Android 67 and higher</li>

There is no support for Internet Explorer.

Other than Firefox and Chrome, support in other browsers has been introduced really recently, so you should keep this in mind.

Your sites and applications, if you plan to support more than just people that run the browsers above mentioned, should have any Cache API code inside this check:

<code>if ('caches' in window) {
 // The Cache API is supported

 // You can add your code here
}</code>

<h3>Working with caches</h3>
<code>if ('caches' in window) {
 // The Cache API is supported
 const cacheName = 'my-website-cache'
 caches.open(cacheName).then(cache => {
   // you can start using the cache
 })
}</code>

A cache is linked to the current origin (domain), and for security and privacy reasons you cannot access caches set up for others.

You can set up several different caches. 
To see all the caches set up for the current origin, you can iterate over <code>caches.keys()</code>:

<code>caches.keys().then(keys => {
 keys.map(key => {
   console.log(key)
 })
})</code>

You can delete one cache by calling the <code>delete()</code> method:

<code>const cacheName = 'my-website-cache'
caches.delete(cacheName).then(() => {
 console.log('Cache deleted')
})</code>

<h3>Adding to a cache</h3>
We have 3 methods:
<li><code>cache.put()</code></li><li><code>cache.add()</code></li><li><code>cache.addAll()</code></li>

You call <code>cache.put()</code> in the successful promise callback of a <code>fetch()</code> call:

<code>const cacheName = 'my-website-cache'
const url = '/resource'
fetch(url).then(res => {
 return caches.open(cacheName).then(cache => {
   return cache.put(url, res)
 })
})</code>

With <code>cache.add()</code> you don't manually have to fetch the resource prior to adding it to the cache: the Cache API makes this automatically for you.

<code>const cacheName = 'my-website-cache'
const url = '/resource'
caches.open(cacheName).then(cache => {
 cache.add(url).then(() => {
   //done!
 }
})</code>

In this case, following the <code>cache.add()</code> call, a <a href="https://alligator.io/js/fetch-api/">Fetch request</a> is sent to the server, and the response is cached.

<code>cache.addAll()</code> is used to perform requests to multiple URLs. 
The callback function is only called when all the resources have been fetched and cached:

<code>const cacheName = 'my-website-cache'
const url1 = '/resource1'
const url2 = '/resource2'
caches.open(cacheName).then(cache => {
 cache.addAll([url1, url2]).then(() => {
   //all requests were cached
 })
})</code>

<h3>Retrieving from a cache</h3>
Using <code>cache.match()</code> you can get the Response object that was stored corresponding to the URL that matches your query:

<code>const cacheName = 'my-website-cache'
const url = '/resource'
caches.open(cacheName).then(cache => {
 cache.match(url).then(item => {
   console.log(item)
 }
})</code>

<code>item</code> is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Request">Request object</a> which you can inspect, for example, you can get the URL using <code>item.url</code>.

<h3>Iterate Over All Items in the Cache</h3>
Using <code>cache.keys()</code> you can get all the items that are present in a cache, and iterate over them:

<code>const cacheName = 'my-website-cache'
const url = '/resource'
caches.open(cacheName).then(cache => {
 cache.keys().then(items => {
   items.map(item => {
     console.log(item)
   })
 }
})</code>

Each item is a <strong>Request</strong> object.

<h3>Removing an item from the cache</h3>
Once a resource is added to the cache, it takes up some amount of space in the browser's storage. 
You can manually clear anything you stored by its original URL, passing it to the <code>cache.delete()</code> method:

<code>const cacheName = 'my-website-cache'
const url = '/resource'
caches.open(cacheName).then(cache => {
 cache.delete(url).then(() => {
   //deleted successfully!
 }
})</code>


<h2>Getting Started with Service Workers</h2>

A Service Worker is a relatively new API that's been introduced in <a href="https://caniuse.com/#feat=serviceworkers">modern web browsers</a> in the last few years. 
It's a really important technology. 
It's a special kind of <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">web worker</a> that can be installed in your browser to provide special features that were previously unavailable to ordinary web pages like allowing for offline access of website content.

<blockquote>Service Workers are at the core of <a href="https://alligator.io/js/intro-progressive-web-apps/">Progressive Web Apps</a> because they allow caching of resources and push notifications, two of the main distinguishing features that up to now set native apps apart.
</blockquote>
The features that go under the <em>Progressive Web App</em> umbrella are mostly oriented towards having the <strong>ability to build a fully featured mobile app using web technologies</strong> that is not a sub-par experience compared to a native stack.

A Service Worker runs on a separate thread. 
This means you can't access many objects available in the main JavaScript thread, including access to the DOM and several APIs like XHR, or Cookies. 
On the plus side, any Service Worker operation can't ever block the UI thread, because it's completely separate.

Keep in mind that service workers need to be served over HTTPS, otherwise, the browser won't register them.

<h3>The Main Features of Service Workers</h3>
The end goal of Progressive Web Apps (PWAs) is to be excellent on mobile, and one thing that the web always failed at on mobile is handling the offline state.

Service workers can <strong>intercept network requests</strong>, add them to the browser cache, using the <a href="https://alligator.io/js/cache-api/">Cache API</a>, and they can serve cached resources if they detect that the browser is offline and the network is unavailable.

Another big feature is enabling <strong>push notifications</strong>, through the use of the <strong>Push API</strong> and the <strong>Notifications API</strong>, two separate web platform APIs that developers can use in service workers.

<h3>How to Install a Service Worker</h3>
Service workers need to be installed in the browser before they can be used.

First, you need to check if the browser implements service workers.

The best way is to check for the existence of <code>serviceWorker</code> on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator">navigator object</a>:

<code>if (!('serviceWorker' in navigator)) {
 // service workers not supported 
 return
}</code>

If service workers are available, you can register your service worker by specifying the file where it can be found. 
You always have a separate file, accessible by the browser. 
For example, you can have it in a <code>worker.js</code> file placed in the root directory.

You wait until the page is loaded, then you register the service worker with the <code>navigator.serviceWorker.register()</code> method:

<code>window.addEventListener('load', () => {
 if (!('serviceWorker' in navigator)) {
   // service workers not supported 
   return
 }

 navigator.serviceWorker.register('/worker.js').then(
   () => {
     // registered! 
   },
   err => {
     console.error('SW registration failed! ', err)
   }
 )
})</code>

<h3>Service Worker Lifecycle</h3>
I mentioned that a service worker needs to be installed in the browser before it can be used.

When a user first comes to your website, the only thing a service worker can do is be installed.

Anything that's inside the service worker, any of the functionalities it comes with, are not enabled until the user visits a second page on your site, or refreshes the current page. 
This is by design.

<h3>What's in a Service Worker</h3>
We just saw how to install a service worker that lives in a <code>worker.js</code> file, but we didn't look into that file yet.

In a service worker you can listen for several events emitted by the browser:
<li>
<code>fetch</code> is sent whenever a page of your site requires a network resource. 
It can be a new page, a JSON API, an image, a CSS file, whatever.</li><li>
<code>install</code> is sent when the service worker is being installed.</li><li>
<code>activate</code> is sent when the service worker has been registered and installed. 
This place is where you can clean up anything related to the older version of the service worker if it's been updated.</li><li>
<code>sync</code> is sent if the browser previously detected that the connection was unavailable, and now signals the service worker that the internet connection is working.</li><li>
<code>push</code> is invoked by the Push API when a new push event is received.</li>

<h3>Serving Cached Resources</h3>
When the service worker is installed we can tell the browser to cache specific resources that we would need to serve the page while offline later on:

<code>self.addEventListener('install', event => {
 event.waitUntil(
   caches
     .open('my-site-name')
     .then(cache =>
       cache.addAll([
         'favicon.ico',
         'style.css',
         'script.js',
         'https://fonts.googleapis.com/css?family=Inconsolata:400,700'
       ])
     )
 )
})</code>

This piece of code uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a> to make the browser cache all those resources in the cache named <code>my-site-name</code>.

Let's see how to listen for a <code>fetch</code> event to provide the user a cached resource the next time a page from our site is accessed:

<code>self.addEventListener('fetch', event => {
 event.respondWith(
   caches.match(event.request).then(response => {
     if (response) {
       //we found an entry in the cache!
       return response
     }
     return fetch(event.request)
   })
 )
})</code>

We check if the cache contains the resource identified by the <code>request</code> property, and if not we launch a <a href="https://alligator.io/js/fetch-api/">fetch request</a> to get it.

<hr>
Notice also the use of <code>self</code> in the above examples. 
Workers get a global <code>self</code> read-only property to allow access to themselves.

<h3>Updating a Service Worker</h3>
Once a service worker is installed, it will continue to run until it's either removed by the user, or you update it.

To update a service worker, you just need to push a new version of it in the server (even changing one byte will suffice) and the browser will detect it's a new version, it will download and install it.

Just like when first installed, the new service worker will not be available until the next page load.


<h2>Using JavaScript's sort Method for Sorting Arrays of Strings</h2>

The <code>sort</code> method available on the <strong>Array prototype</strong> allows you to sort the elements of an array. 
It accepts an optional callback function that you could use to tailor the sorting mechanism to your specific needs.

For arrays of numbers, refer to our previous post on <a href="https://alligator.io/js/array-sort-numbers/">sorting array of numbers</a>.

Sorting strings can get quite opinionated because of how the <code>sort</code> method works.

First of, the <strong>ECMAScript</strong> standard does not specify a particular sorting algorithm, it all depends on each browser vendor.

Second, casing plays a vital role when sorting. 
For sorting to work, there must be a sequential arrangement of things and this is obtainable with numbers - numbers are naturally sequential ( 1, 2 , 3, 4…). 
When strings are being compared, they are converted to their equivalent <strong>Unicode value</strong> - which unsurprisingly are numbers, then sorted sequentially, in ascending order by default.

<h3>Unicode Values for Characters</h3>
To grab the Unicode value of each character - lower or uppercase, we use the <code>charCodeAt</code> string method to access the <em>character code</em> of a specified character index.

Stay with me.

We'll start by creating utility functions that helps get the <strong>unicode values</strong> of characters as well as the characters. 
We will refer to them as we go.

<code>// get Unicode values of character items in an array
function getCharactersUnicodeValue(characters) {
 const unicodeChart = new Map();
 characters.forEach(character => {
   unicodeChart.set(
     character,
     character.charCodeAt(character.indexOf(character))
   );
 });
 console.table(unicodeChart);
}

// get unicode values of a single character
function getCharacterUnicodeValue(character) {
 const value = character.charCodeAt(character.indexOf(character));
 console.log(value);
}</code>

Notice the use of <a href="https://alligator.io/js/maps-introduction/">Maps</a> here.

<hr>
We'll call the utility functions like:

<code>getCharactersUnicodeValue("ABCDEFabcdef".split("")); // array of characters: [ 'A', 'B', 'C', 'D', 'E', 'F', 'a', 'b', 'c', 'd', 'e', 'f' ]
// Result: {character → Unicode Value}
// { A → 65, B → 66, C → 67, D → 68, E → 69, F → 70, a → 97, b → 98, c → 99, d → 100, e → 101, f → 102 }

getCharacterUnicodeValue("A");
// Result: {character → Unicode Value}
// { A → 65 }</code>

And here's yet another example:

<code>const crocodilian = "crOCoDiliaN".split(""); // array of characters i.e [ 'c', 'r', 'O', 'C', 'o', 'D', 'i', 'l', 'i', 'a', 'N' ]

getCharactersUnicodeValue(crocodilian);

// Result: {character → Unicode Value}
// { c → 99, r → 114, O → 79, C → 67, o → 111, D → 68, i → 105, l → 108, a → 97, N → 78 }</code>

Notice that the <em>UPPERCASE</em> characters appear before the <em>lowercase</em> characters. 
And they'll come sequentially. 
That is sorted like: <code>['Eggs', 'Tail', 'eggs']</code>. 
Notice how <code>Tail</code> comes before <code>eggs</code>? That's expected because:

<code>getCharactersUnicodeValue(["Eggs", "Tail", "eggs"]);

// Result: {character → Unicode Value}
// { Eggs → 69, Tail → 84, eggs → 101 }
// 84 (T) of Tail comes numerically before 101 (e) of eggs</code>

<hr>
<strong>TL;DR</strong>: Sorting when a string is formed only with the same case (all upper or all lower) is easy. 
The challenge only comes with mixed cases.

<h3>Sorting Mixed Case Strings</h3>
Most of the time we'll want our <strong>array of mixed case strings</strong> to be sorted regardless of the <strong>casing</strong>.

<code>const things = [ 'nest', 'Eggs', 'bite', 'gator', 'caYman', 'Grip', 'grips', 'Jaw', 'crocodilian', 'Bayou' ];</code>

Should eventually be sorted as:

<code>[ 'Bayou', 'bite', 'caYman', 'crocodilian', 'Eggs', 'gator', 'Grip', 'grips', 'Jaw', 'nest' ]</code>

And not:

<code>[ 'Bayou', 'Eggs', 'Grip', 'Jaw', 'bite', 'caYman', 'crocodilian', 'gator', 'grips', 'nest' ]</code>

<h3>Attempt One: Without a Comparison Function</h3>
Calling the sort method without a comparison function wouldn't work:

<code>things.sort();

// ['Bayou', 'Eggs', 'Grip', 'Jaw', 'bite', 'caYman', 'crocodilian', 'gator', 'grips', 'nest']</code>

<h3>Attempt Two: With a Comparison Function</h3>
<code>function sortThings(a, b) {
 if (a > b) {
   return 1;
 } else if (a &lt; b) {
   return -1;
 } else if (a === b) {
   return 0;
 }
}</code>

Then sort with the <code>comparison function</code>:

<code>things.sort(sortThings);

// [ 'Bayou', 'Eggs', 'Grip', 'Jaw', 'bite', 'caYman', 'crocodilian', 'gator', 'grips', 'nest' ]</code>

Still, it doesn't work. 
In fact, we might as well not have written a <em>comparison function</em>.

<h3>Attempt Three: With a Comparison Function and a Common Case</h3>
The problem is that the sorting still uses the default mixed cases of the things array elements what we need to do is convert the cases to a common case - either <em>lowercase</em> or <em>UPPERCASE</em> will do.

<code>function sortThings(a, b) {
 a = a.toLowerCase();
 b = b.toLowerCase();

 if (a > b) {
   return 1;
 } else if (a &lt; b) {
   return -1;
 } else if (a === b) {
   return 0;
 }
}</code>

Or, using ternary operators:

<code>function sortThings(a, b) {
 a = a.toLowerCase();
 b = b.toLowerCase();

 return a > b ? -1 : b > a ? 1 : 0;
}</code>

Then sort again with the <code>comparison function</code>:

<code>things.sort(sortThings);

// ['Bayou', 'bite', 'caYman', 'crocodilian', 'Eggs', 'gator', 'Grip', 'grips', 'Jaw', 'nest' 'eggz']</code>

And yippee it works now!

<h3>But Wait, There's More</h3>
Although browser vendors have their specific sorting algorithm, there are some techniques that we should be familiar with. 
Sorting is done on a <code>charCodeAt(index)</code> basis. 
In a scenario where two comparison items are almost similar, their <code>charCodeAt(index)</code> is being compared continuously. 
Where index starts from 0 until there's a difference.

Take <code>eggs</code> and <code>Eggz</code> for example:

<ol><li>Without converting to a lowercase, <code>Eggz</code> will come before <code>eggs</code> because the Unicode value of <code>E → 69</code> comes before that of <code>e → 101</code>.
</li><li>When there's a conversion to a similar case - lowercase for example - we are essentially comparing <code>eggs</code> and <code>eggz</code>. 
<code>e → 101</code> and <code>e → 101</code> are equal.
</li>
</ol>
Running:

<code>['Eggz', 'eggs'].sort(sortThings);

// ['eggs', 'Eggz']</code>

Sorts correctly with the last characters <code>s → 115 and z → 122</code> being the deterministic characters.

The check goes as follows:
<li>[e → 101 ]ggs and [e → 101]ggz / 101 === 101, we move to the next characters</li><li>e[g → 103]gs and e[g → 103]gz / 103 === 103, we move to the next characters</li><li>eg[g → 103]s and eg[g → 103]z / 103 === 103, we move to the next characters</li><li>egg[s → 115] and egg[z → 122] / obviously, 115 comes before 122.</li>

Et voilà, that decides the duel!

<h3>Descending Order</h3>
If you need to sort in descending order, just swap the return 1 in the comparison function with return -1 like so:

<code>function sortThings(a, b) {
 a = a.toLowerCase();
 b = b.toLowerCase();
 if (a > b) {
   return -1;
 } else if (b > a) {
   return 1;
 } else {
   return 0;
 }
}</code>

Or:

<code>function sortThings(a, b) {
 a = a.toLowerCase();
 b = b.toLowerCase();
 return a > b ? -1 : b > a ? 1 : 0;
}</code>

Or just <code>reverse</code> the sorted array with the <code>reverse</code> array method, which obviously reverses the array to the opposite sequence:

<code>things.sort(sortThings).reverse();</code>

<h3>Alternative: Using localeCompare</h3>
Although the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">localeCompare</a> string method can compare characters without regard for the case used, it's a string method so it can't be used directly on an array. 
To sort our <code>things</code> array with the <code>localeCompare</code> string method, we pass the <code>localeCompare</code> as the comparison function like so:

<code>things.sort((a, b) => a.localeCompare(b));
    
// [ 'Bayou', 'bite', 'caYman', 'crocodilian', 'Eggs', 'gator', 'Grip', 'grips', 'Jaw', 'nest' ]</code>

<h3>The code at a glance</h3>
<code>const things = [
 "nest",
 "Eggs",
 "bite",
 "gator",
 "caYman",
 "Grip",
 "grips",
 "Jaw",
 "crocodilian",
 "Bayou"
];
console.log(`unsorted: ${things.join(", ")}`);

function sortThings(a, b) {
 a = a.toLowerCase();
 b = b.toLowerCase();
 return a > b ? 1 : b > a ? -1 : 0;
}

console.log(`sorted:  ${things.sort(sortThings).join(", ")}`);</code>

<hr>
Remember, keep-on sorting, the world needs it.


<h2>Error Handling in JavaScript Using try...catch</h2>

Good code is code that preemptively prevents errors in a program from crashing the program and instead handles those errors gracefully by doing something like recovering from the error, informing the user about it or logging the error somewhere. 
This is called error handling and the primary mechanism for error handling in JavaScript is the try…catch construct.

Let's briefly go over how to use try…catch, and then also look at try…catch…<em>finally</em> and the <em>throw</em> statement to throw our own custom errors.

<h3>try…catch</h3>
Here's the basic syntax for try…catch:

<code>try {
 // some code that my error-out
} catch (e) {
 // this will run only if the code in the try block errors-out
}</code>

Notice how the catch block gets access to the error object (<code>e</code> in the above example). 
The error object will have a <em>name</em> and a <em>message</em> property. 
In most environments the error object will also have a <em>stack</em> property with the stack trace leading to the error.

If you log the error object to the console, it's name and message properties will <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/toString">conveniently be concatenated together</a>.

Here's an example where we misspell a variable name:

<code>let myVariable = 2;
try {
 console.log(myVriable + 77);
} catch (e) {
 console.log('Oopsies -', e);
}</code>

In this case, the <strong>catch</strong> block will be executed and the following message is printed to the console:

<code>Oopsies - ReferenceError: myVriable is not defined</code>

try...catch only handles errors encountered at runtime, and invalid JavaScript will error-out at parse-time so your program won't run at all. 
Instead, use a linter like <a href="https://eslint.org/">ESLint</a> to catch those errors directly when authoring your code.

<h3>Throwing Custom Errors</h3>
Oftentimes instead of catching pure JavaScript errors we instead will want to catch conditions encountered in our program that should be considered errors. 
For this, we can make use of the throw statement to throw our own errors in a try block so that the error can be caught and dealt with:

<code>let myVariable = prompt('Give me a number');

try {
 if (isNaN(+myVariable)) {
   // throws if the value provided can't be coerced to a number
   throw new Error('Not a number!');
 }
 console.log('Good choice', myVariable);
} catch (e) {
 console.log(e);
}</code>

With the above example, if we don't enter a value that can be coerced to a number we throw a custom error that's then caught by our <strong>catch</strong> clause.

You can also see that we make use of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">Error constructor</a> to create an error object with a custom message passed-in as the first argument. 
In this case, our error object will have a name of <em>Error</em>, but we can also produce a specific error type:

<code>try {
 if (isNaN(+myVariable)) {
   throw new TypeError('Not a number!');
 }
 console.log('Good choice', myVariable);
} catch (e) {
 console.log(e);
}</code>

<h3>Rethrowing an error</h3>
A good coding practice is to catch and deal only errors that we expect and then to rethrow other errors to be handled by a potential parent try…catch construct:

<code>let myVariable = prompt('Give me a number');

try {
 if (isNaN(+myVariable)) {
   throw new TypeError('Not a number!');
 }
 console.log('Good choice', myVariable);
} catch (e) {
 if (e.name === 'TypeError') {
   console.log(e);
 } else {
   throw e;
 }
}</code>

With the above example, if an error different than our <em>TypeError</em> is encountered in the <strong>try</strong> clause, our <strong>catch</strong> clause rethrows the error to be dealt with using a parent try…catch construct that we would put in place.

<h3>try…catch…finally</h3>
You can also tack-on a <em>finally</em> block to ensure that some code runs no matter if the code in the <strong>try</strong> blocks errors-out or not:

<code>let myVariable = 2;
try {
 console.log(myVriable + 77);
} catch (e) {
 console.log('Oopsies -', e);
} finally {
 console.log('Runs no matter what');
}</code>

The <strong>finally</strong> block can be useful to clean-up your code.

<h3>try…finally</h3>
Like <strong>finally</strong>, the <strong>catch</strong> clause is optional and, if you want you can use try…finally to ensures that some code runs upon encountering an error.

Here for example we try to set the background color on an element that doesn't exist. 
First, using a try…catch…finally:

<code>try {
 document.querySelector('.not-there').style.backgroundColor = 'pink';
} catch (e) {
 console.log('Oh no -', e);
} finally {
 console.log('Finally runs');
}
console.log('After try block');

// Oh no - TypeError: Cannot read property 'style' of null
// Finally runs
// After try block</code>

And now using only try…finally:

<code>try {
 document.querySelector('.here2').style.backgroundColor = 'pink';
} finally {
 console.log('Finally runs');
}
console.log('After try block');

// Finally runs
// Uncaught TypeError: Cannot read property 'style' of null</code>

Notice how, when the <strong>catch</strong> clause is missing, the error is uncaught and the program crashes, but only after running the code in our <strong>finally</strong> clause.


<h2>Using JavaScript's sort Method for Sorting Arrays of Numbers</h2>

The <code>sort</code> method available on the Array prototype allows you to sort the elements of an array and control how the sorting should be done. 
The aim of this post is to explain to you why, why not and how the <code>sort</code> method works when sorting an <strong>array of numbers</strong>.

<strong>TL;DR —</strong> Sort an array of numbers in ascending order using:<br><code>myArray.sort((a, b) => a - b);</code>

<em>Arrays</em> in JavaScript are data structures consisting of a collection of data items. 
Because Javascript is not a typed language, Javascript arrays can contain different types of elements - <em>strings</em>, <em>numbers</em>, <em>undefined</em>, etc. 
It's most often a good idea to have all items in an array be of the same type however.

One of the many operations that can be performed on an array is <strong>sorting</strong>. 
Whether you need to know the best students from a collection of grades, the big winners of Wall Street, how much data you've been consuming lately, it all involves organizing a collection through sorting.

In the code examples below. 
We'll get a collection of eggs in our nest, then sort them both in ascending and descending order. 
Ready? Let's do it!

<h3>Filling an Array</h3>
We declare and initialize a <code>nest</code> array and prefill it with <code>null</code> values - for the moment:

<code>let eggsInNest = new Array(10).fill(null);</code>

We use the static <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">fill</a> method available on the <code>Array</code> constructor method. 
Next, let's fill the 10 elements each with random values ranging from 1 - 200:

<code>eggsInNest = eggsInNest.map(() => (Math.floor(Math.random() * 200) + 1));</code>

<h3>Sorting</h3>
We can then sort simply by calling the <code>sort</code> method on our array without arguments:

<code>eggsInNest.sort();

// e.g.: [109, 136, 156, 188, 19, 190, 2, 34, 55, 90]</code>

As you can see, there's a slight problem and sorting didn't quite work out as you might have expected. 
Read on to learn why and how to fix it.

By default the <code>sort()</code> method sorts the array:

<ol><li>In ascending order</li><li>With the items casted to strings</li>
</ol>
To do this, the <code>sort</code> method calls the <code>String()</code> casting method on every array element and then compares the equivalent strings to determine the correct order.

It would have been that easy, except for the fact that items are compared as strings, which has items sorted as if they were strings of characters instead of numbers. 
In short, most times, using the <code>sort</code> method without a callback method doesn't quite work, because <code>sort</code> doesn't sort the way we expect. 
Instead, it needs to be explicitly told how to do so - with a <strong>callback function</strong>.

The <strong>callback function</strong> or, technically, <strong>comparison function</strong> receives two arguments (called <code>a</code> and <code>b</code> by convention) and should return <strong>1</strong> if the first argument should preceed the second, <strong>-1</strong> if the second argument should preceed the first and <strong>0</strong> if they are equal. 
Whew! 

<hr>
Let's create a <code>sortEggsInNest</code> comparison function:

<code>function sortEggsInNest(a, b) {
 if (a > b) {
   return 1;
 } else if (b > a) {
   return -1;
 } else {
   return 0;
 }
}</code>

If you want to be a hotshot , you could reduce the <code>sortEggsInNest</code> comparison function with a ternary operator like so:

<code>function sortEggsInNest(a, b) {
 return a > b ? 1 : b > a ? -1 : 0;
}</code>

Then we can call the <code>sort</code> method again but this time passing in the <code>sortEggsInNest</code> comparison function:

<code>eggsInNest.sort(sortEggsInNest);</code>

And yes, it works... 
in ascending order.

<h3>Descending order</h3>
Need to sort in descending order? Just swap the <strong>return 1</strong> in the comparison function with <strong>return -1</strong> like so:

<code>function sortEggsInNest(a, b) {
 if (a > b) {
   return -1;;
 } else if (b > a) {
   return 1;;
 } else {
   return 0;
 }
}</code>

Or, the short version using ternary operators:

<code>function sortEggsInNest(a, b) {
 return a > b ? -1 : b > a ? 1 : 0;
}</code>

<h3>A Shorter Way with Numbers</h3>
Finally, there's even a shorter way to write the comparison function. 
Here:

<code>eggsInNest.sort((a, b) => a - b);</code>

This is only Ok because the comparison function only returns <strong>1, -1 or 0</strong>. 
and subtracting the two intermediate values yields exactly that. 
However keep in mind - this can only be used with numeric types or objects whose <code>valueOf()</code> method returns numeric values (such as the Date object).

Keep on sorting! The world needs it. 



<h2>Scheduling Tasks in JavaScript Using setTimeout &amp; setInterval</h2>

In browser environments, as well as with Node.js, we get two methods on the global object that make it easy to schedule tasks to be performed at a later time: <em>setTimeout</em> and <em>setInterval</em>.
<li>
<em>setTimeout</em>: Calls a function once after a specified delay.</li><li>
<em>setInterval</em>: Calls a function continuously at a specified delay between each call.</li>

<h3>setTimeout</h3>
The <code>setTimeout</code> method expects 2 arguments: a reference to a callback function and a delay in milliseconds. 
The following will print a message to the console after 1 second:

<code>setTimeout(() => {
 console.log('Alligator!!!!');
}, 1000);</code>

The above example uses an inline function expression, but we could just as well reference a function by its name:

<code>function gator() {
 console.log('Alligator!!!!');
}

setTimeout(gator, 1000);</code>

Note that the function shouldn't be invoked, but instead a reference to the function should be used.

<h3>Additional arguments</h3>
setTimeout can take additional arguments after the delay and the extra values will be passed-in to the callback function:

<code>function animal(animalName, extras = '!!!') {
 const name = animalName.charAt(0).toUpperCase() + animalName.slice(1);
 console.log(`${name}${extras}`);
}

setTimeout(animal, 2500, 'wolf', ' $#@%');

// Wolf $#@% (after 2.5 seconds)</code>

<h3>Cancelling a timer</h3>
The <code>setTimeout</code> method returns a timer id that can then be passed to the global <code>clearTimeout</code> method to cancel the timeout. 
Take the following example:

<code>function animal(animalName, extras = '!!!') {
 const name = animalName.charAt(0).toUpperCase() + animalName.slice(1);
 console.log(`${name}${extras}`);
}

const animalTimer = setTimeout(animal, 800, 'wolf', ' $#@%');

setTimeout(() => {
 clearTimeout(animalTimer);
}, 250);</code>

With this, nothing will be printed to the console, because a second timer cancels the first one before the first one has a chance to run.

<h3>Execution with 0ms delay</h3>
A popular technique to improve the performance of JavaScript code is to set timers with setTimeout calls that have a delay of 0ms. 
This adds a timer to the message queue for code to run ASAP, as soon as the current synchronous code and previous messages in the queue have finished executing, making the code executed with the <code>setTimeout</code> asynchronous:

<code>setTimeout(() => {
 console.log('Panda ');
}, 0);

console.log('Koala ');

// Koala 
// Panda </code>

Used this way, <code>setTimeout</code> can become useful to defer tasks that could otherwise be blocking.

Something to keep in mind here is that this also means that the delay specified with <code>setTimeout</code> is not a guarantee, and only specifies the minimum amount of time that has to pass. 
If the JS engine is busy, the code could be executed much later.

Note also that when using a value of 0 as the delay, the second argument to <em>setTimeout</em> can be omitted and 0 will be implied.

<h3>setInterval</h3>
The API for <code>setInterval</code> is pretty much the same as with <code>setTimeout</code>. 
Just like with <code>setTimeout</code>:
<li>It expects 2 arguments: a callback function and a delay in milliseconds.</li><li>It returns a timer ID, and <code>clearInterval</code> can be called with the timer ID to cancel the timer.</li><li>Additional arguments can be passed-in, and they will then be passed-in as arguments to the callback function.</li>

The difference is that <code>setInterval</code> calls the callback function repeatedly with the specified delay in-between the calls. 
In the following example, we increment a value and print it to the console every second:

<code>let i = 0;

function increment() {
 i++;
 console.log(i);
}

setInterval(increment, 1000);

// 1
// 2
// 3
// ...</code>

<h3>Recursive setTimeout Calls</h3>
Sometimes it can make more sense to use a recursive <code>setTimeout</code> timer instead of a <code>setInterval</code> timer. 
For one, if the tasks performed as part of the timer take a long time, using <code>setInterval</code> can mean that the tasks end up having no delay in-between because the delay is calculated from the start of the task. 
If using a recurring <code>setTimeout</code> timer instead, we have full control on when the delay starts. 
Here's an example of a recursive <code>setTimeout</code> call:

<code>let i = 0;

function increment() {
 i++;
 console.log(i);
}

let timer = setTimeout(function myTimer() {
 increment();
 timer = setTimeout(myTimer, 1000);
}, 1000);

// let's cancel after 7 seconds
setTimeout(() => {
 console.log('Cancelling');
 clearTimeout(timer);
}, 7000);</code>

Note how we're re-assigning the value of <code>timer</code> each time, so that we can still probably cancel the timer when needed.

<h2>A Look at the JavaScript Console API</h2>

The JavaScript console is an invaluable tool to help develop and debug our apps. 
With the console object and its logging methods, long are the days of of calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/alert">alert()</a> to debug and get a variable's value. 
On top of that, thanks to a <a href="https://console.spec.whatwg.org/">work in progress standard</a>, modern browsers are finally supporting the same set of methods. 
In this post we'll explore some of the main methods made available by the console API.

<h3>Logging</h3>
<code>console.log</code> is the usual method we use to log values out to the console:

<code>const name = 'Alligator';
console.log('Hello', name); // Hello Alligator</code>

But we also have access to more logging methods like <em>warn</em>, <em>info</em> and <em>error</em>:

<code>console.info('Just FYI');
console.warn('Lookout!');
console.error('Boom ');</code>

As you can see from the resulting console output, using the <em>warn</em> or <em>error</em> methods also gives us a stack trace:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b76a633c50d5a125455958dbe25f5df58d0e4f8f/a4551/images/js/console-api/logging-methods.png" width="600" alt="Logging outputs">

You can also trigger a stack trace with <code>console.trace</code>:

<code>function hello(name = 'Alligator') {
 console.trace('name:', name);
 return `Hello ${name}!`;
}

hello();</code>

…Oh, and there's also <code>console.debug</code>, but it's currently just an alias for <code>console.log</code>.

<h3>console.dir &amp; console.dirxml</h3>
<code>console.dir</code> prints out objects in a nice formatted way:

<code>const fancyThings = {
 car: ' Ferrari',
 watch: ' Cartier',
 clothing: {
   shoes: ' Christian Louboutin',
   dress: ' Versace'
 },
 boat: ' Sunseeker'
}

console.dir(fancyThings);</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/609fa7ac900f338ac7fda2064a8de343d0293ae7/db068/images/js/console-api/dir.png" width="600" alt="Output of console.dir">

<hr>
As for <code>console.dirxml</code>, it prints out a DOM element's markup. 
For example:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">

&lt;head>
 &lt;!-- ... 
-->
&lt;/head>

&lt;body>
 &lt;h1>hello&lt;/h1>

 &lt;script>
   console.dirxml(document.body);
 &lt;/script>
&lt;/body>

&lt;/html></code>

This will output the following:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6f275510d911b057df9378c4652769a4f837a36a/276a3/images/js/console-api/dirxml.png" width="600" alt="Output of console.dirxml">

If you feel so inclined, you can even display data in the console more neatly in a table format using <a href="https://alligator.io/js/console-table/">console.table</a>.

<h3>Asserting</h3>
The <code>console.assert</code> method is an easy way to run simple assertion tests. 
The assertion fails if the 1st argument evaluates to false, and the subsequent arguments get printed to the console if the assertion fails:

<code>// this will pass, nothing will be logged
console.assert(2 == '2', '2 not == to "2"');

// this fails, '3 not === to "3"' will be logged
console.assert(3 === '3', '3 not === to "3"');</code>

<h3>Clearing</h3>
You can clear the console with <code>console.clear</code>:

<code>console.clear();</code>

<h3>Counting</h3>
The <code>console.count</code> method is used to count the number of times it has been invoked with the same provided label. 
For example, here we have two counters, one for even values and one for odd values:

<code>[1, 2, 3, 4, 5].forEach(nb => {
 if (nb % 2 === 0) {
   console.count('even');
 } else {
   console.count('odd');
 }
});

// odd: 1
// even: 1
// odd: 2
// even: 2
// odd: 3</code>

<h3>Timing</h3>
As we've showed in <a href="https://alligator.io/js/console-time-timeend/">this short post</a>, you can start a timer with <code>console.time</code> and then end it with <code>console.endTime</code>. 
Optionally the time can have a label:

<code>console.time('fetching data');
fetch('https://jsonplaceholder.typicode.com/users')
 .then(d => d.json())
 .then(console.log);
console.timeEnd('fetching data');

// fetching data: 0.2939453125ms
// (10)[{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]</code>

Note that if you use a label with <code>console.time</code> you must pass-in that same label when calling <code>console.timeEnd</code>.

<h3>Grouping</h3>
Use <code>console.group</code> and <code>console.groupEnd</code> to group console messages together with an optional label. 
Notice also how a group can be nested into another one:

<code>console.group(' colors');
console.log('red');
console.log('orange');
console.group('HEX');
console.log('#FF4C89');
console.log('#7186FE');
console.groupEnd();
console.log('blue');
console.groupEnd();</code>

Here's the resulting console output:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bea346f7d063d124effb267f79a25014bb74bc27/0eae2/images/js/console-api/group.png" width="600" alt="Output of console.group">

<h3>Bonus: Giving it Some Style</h3>
Console logging can be styled using a special <em>%c</em> delimiter:

<code>console.log(
'Hello %cAlligator%c!',
'color: #008f68; font-weight: bold; font-size: 2rem; text-shadow: 0 0 5px rgba(0,0,0,0.2);',
'color: hotpink; font-weight: bold; font-size: 2rem; text-shadow: 0 0 5px rgba(0,0,0,0.2);'
);</code>

Everything that comes after the first <em>%c</em> will be styled by the string provided by the second argument, then everything after the next <em>%c</em> is styled by the following string argument, and so on. 
Here's how the above example looks like at the console:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f22aa2c1bf7275bb744993836643f897cc01f033/50528/images/js/console-api/styling.png" width="600" alt="Result of styling console output">

<h2>Accessing the Clipboard in JavaScript Using the Async Clipboard API</h2>

There's a new JavaScript API for asynchronous clipboard access with <a href="https://www.w3.org/TR/clipboard-apis/#async-clipboard-api">a spec</a> that's currently in the works. 
The de facto way to copy text to the clipboard on the web has been to use <a href="https://alligator.io/js/copying-to-clipboard/">document.execCommand</a>, but a major caveat is that the operations are synchronous and blocking. 
Async clipboard is a <a href="https://alligator.io/js/promises-es6/">promise</a>-based API that aims to fix that and also give us a simpler and unified API. 
On top of that, the API is designed to support data types other than just <em>text/plain</em>.

At this time, the new API is only available in Chrome 66+ and only copying/pasting of plain text is supported.

Note that the API only works when served over secured domains (https) or localhost and when the page is the browser's currently active tab.

<h3>Writing to the Clipboard</h3>
Writing to the clipboard is as simple as calling <code>writeText</code> with the text to write to the clipboard:

<code>navigator.clipboard.writeText('Hello Alligator!')
 .then(() => {
   // Success!
 })
 .catch(err => {
   console.log('Something went wrong', err);
 });</code>

<h3>Reading from the Clipboard</h3>
To read from the clipboard, we use the <code>readText</code> method. 
To mitigate security risks, on top of needing to be in the active tab, an additional permission needs to be granted by the user. 
The browser will automatically ask for permission the first time <strong>readText</strong> is called.

<code>navigator.clipboard.readText()
 .then(text => {
   // `text` contains the text read from the clipboard
 })
 .catch(err => {
   // maybe user didn't grant access to read from clipboard
   console.log('Something went wrong', err);
 });</code>

<h3>Simple Demo</h3>
Below is a really simplistic demonstration for writing to and reading from the clipboard. 
This demo will only work in supported browsers, but as an exercise to the reader, you could expand and add a fallback for non-supporting browsers.

 <input type="text" placeholder="Type something..." aria-label="Type something"><button>Copy to clipboard</button>

<h3></h3>
<button>Paste from clipboard</button>

<hr>
Let's break it down with, first, the markup:

<code>&lt;div>
 &lt;input type="text" class="to-copy" placeholder="Type something..." aria-label="Type something">
 &lt;button class="write-btn">Copy to clipboard&lt;/button>
&lt;/div>

&lt;div>
 &lt;h3 class="clipboard-results">&lt;/h3>
 &lt;button class="read-btn">Paste from clipboard&lt;/button>
&lt;/div></code>

And then finally, here's the JavaScript code to make it all work:

<code>const readBtn = document.querySelector('.read-btn');
const writeBtn = document.querySelector('.write-btn');

const resultsEl = document.querySelector('.clipboard-results');
const inputEl = document.querySelector('.to-copy');

readBtn.addEventListener('click', () => {
 navigator.clipboard.readText()
   .then(text => {
     resultsEl.innerText = text;
   })
   .catch(err => {
     console.log('Something went wrong', err);
   })
});

writeBtn.addEventListener('click', () => {
 const inputValue = inputEl.value.trim();
 if (inputValue) {
   navigator.clipboard.writeText(inputValue)
     .then(() => {
       inputEl.value = '';
       if (writeBtn.innerText !== 'Copied!') {
         const originalText = writeBtn.innerText;
         writeBtn.innerText = 'Copied!';
         setTimeout(() => {
           writeBtn.innerText = originalText;
         }, 1500);
       }
     })
     .catch(err => {
       console.log('Something went wrong', err);
     })
 }
});</code>

The code is really straightforward. 
The only place where we add a bit more logic is with the copy button, where we first make sure that there's something to copy, and then also change the button's text for a moment as well as reset the input's value when the copy operation is successful.

<h3>The Future</h3>
The API also defines more generic <em>write</em> and a <em>read</em> methods for a way to copy or paste content other than just plain text, like with images. 
For example:

<code>navigator.clipboard.read().then(({ items }) => {
 items.forEach(item => {
   console.log(item.type);
   // do something with the data item
 });
});</code>

This is not supported in any browser at the time of this writing

<h3>Detecting Support</h3>
In order to degrade gracefully or to revert to using <em>execCommand</em> for non-supporting browsers, you can simply check for the presence of the <em>clipboard</em> object in the global <em>navigator</em> object:

<code>if (navigator.clipboard) {
 // yep, turn the feature on.
} else {
 // nope . 
Use execCommand or leave the feature off
}</code>

<h2>A Look at the Resize Observer JavaScript API</h2>

<a href="https://wicg.github.io/ResizeObserver/">Resize Observer</a> is a new JavaScript API that's very similar to other observer APIs like the <a href="https://alligator.io/js/intersection-observer/">Intersection Observer API</a>. 
It allows for elements to be notified when their size changes.

The most frequent reason for an element's size to change is when the viewport is resized or the device's direction changes between portrait and landscape. 
Up until this point, we've had to rely on the global <code>window.resize</code> event to listen for resize events and check if certain elements have changed size. 
This can easily lead to performance problems due to the large amount of triggered event. 
In other words, using <code>window.resize</code> is often wasteful because it informs us of every viewport size change, not just when an element's size actually changes.

There's also another use case for the <strong>Resize Observer API</strong> that the window's resize event can't help us with: when elements are added or removed from the DOM dynamically, influencing the size of the parent element. 
This is more and more frequent with modern single-page apps.

<h3>Basic Usage</h3>
Using Resize Observer is as simple as instantiating a new <em>ResizeObserver</em> object and passing-in a callback function that receives the entries that are observed:

<code>const myObserver = new ResizeObserver(entries => {
 // iterate over the entries, do something.
});</code>

Then, we can call <em>observe</em> on our instance and pass-in an element to observe:

<code>const someEl = document.querySelector('.some-element');
const someOtherEl = document.querySelector('.some-other-element');

myObserver.observe(someEl);
myObserver.observe(someOtherEl);</code>

With each entry, we get an object with a <em>contentRect</em> and a <em>target</em> property. 
The <strong>target</strong> is the DOM element itself, and <strong>contentRect</strong> is an object with the following properties: <em>width</em>, <em>height</em>, <em>x</em>, <em>y</em>, <em>top</em>, <em>right</em>, <em>bottom</em> and <em>left</em>.

Unlike with an element's getBoundingClientRect, contentRect's values for width and height don't include padding values. 
<code>contentRect.top</code> is the element's top padding and <code>contentRect.left</code> is the element's left padding.

<hr>
If, for example, we want log an observed element's width and height when the element's size changes, we could do something like this:

<code>const myObserver = new ResizeObserver(entries => {
 entries.forEach(entry => {
   console.log('width', entry.contentRect.width);
   console.log('height', entry.contentRect.height);
 });
});

const someEl = document.querySelector('.some-element');
myObserver.observe(someEl);</code>

<h3>Simple Demo</h3>
Below is a simple demonstration to see the Resize Observer API in action. 
Try it out by resizing your browser window and notice how the gradient angle and text content only change when the element's size is actually affected:

<h3></h3>
<h3></h3>
<hr>
Let's break down this simple demo. 
First, we start with some simple markup:

<code>&lt;div class="box">
 &lt;h3 class="info">&lt;/h3>
&lt;/div>
&lt;div class="box small">
 &lt;h3 class="info">&lt;/h3>
&lt;/div></code>

And a touch of styles:

<code>.box {
 text-align: center;
 height: 20vh;
 border-radius: 8px;
 box-shadow: 0 0 4px var(--subtle);

 display: flex;
 justify-content: center;
 align-items: center;
}

.box h3 {
 color: #fff;
 margin: 0;
 font-size: 5vmin;
 text-shadow: 0 0 10px rgba(0,0,0,0.4);
}

.box.small {
 max-width: 550px;
 margin: 1rem auto;
}</code>

Notice how we don't need to apply our gradient background to the <em>.box</em> element. 
The resize observer will be called once when the page first loads and our gradient will be applied then.

Now, the magic happens when we add the following JavaScript code:

<code>const boxes = document.querySelectorAll('.box');

const myObserver = new ResizeObserver(entries => {
 for (let entry of entries) {
   const infoEl = entry.target.querySelector('.info');
   const width = Math.floor(entry.contentRect.width);
   const height = Math.floor(entry.contentRect.height);

   const angle = Math.floor(width / 360 * 100);
   const gradient = `linear-gradient(${ angle }deg, rgba(0,143,104,1) 50%, rgba(250,224,66,1) 50%)`;

   entry.target.style.background = gradient;

   infoEl.innerText = `I'm ${ width }px and ${ height }px tall`;
 }
});

boxes.forEach(box => {
 myObserver.observe(box);
});</code>

Here we're iterating over the entries in the observer's callback using a <a href="https://alligator.io/js/for-of-for-in-loops/">for…of</a> loop, but calling <code>forEach</code> on the <em>entries</em> would work just the same.

Notice how we also have to iterate over the elements that we can to observe and call <code>observe</code> on each element.

<h3>Browser Support</h3>
Browser support right now is pretty bad, with only Chrome 64+ supporting Resize Observer out of the box. 
Thankfully, <a href="https://github.com/que-etc/resize-observer-polyfill">there's a polyfill</a> we can use in the mean time. 
The polyfill is based on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver API</a>.

<h2>Accessing Rails APIs in JavaScript Clients Using Rails Ranger</h2>

<a href="https://github.com/victor-am/rails-ranger">Rails Ranger</a> is a library I wrote that's focused on leveraging on the defaults of Ruby on Rails APIs to make your life easier when writing javascript clients for them. 
It's essentially a thin layer wrapping the powerful <a href="https://github.com/axios/axios">Axios</a> library, while still exposing its full power for you.

<h3>Installation</h3>
<code>$ yarn add rails-ranger

# or
$ npm install —-save rails-ranger</code>

<h3>Basic Setup</h3>
The most basic setup would be something like that:

api-client.js

<code>import RailsRanger from 'rails-ranger'

const config = {
 axios: { baseURL: 'http://api.myapp.com' }
}

export default new RailsRanger(config)</code>

One important note here is that anything you send inside the <strong>axios</strong> option will be handed down to Axios as it is, so you can configure it as you want.

<h3>Usage</h3>
Then how do we start making requests? Like this:

some-front-end-component.js

<code>import api from 'api-client'

api.list('users').then((response) => {
 // your code
})</code>

So let's break down what's happening here:

<ol><li>We import the client we've set up in the previous file seen in the configuration section.</li><li>We call the <code>list</code> function from it, which is just an alias for <code>index</code>. 
This will trigger a request to the <code>http://api.myapp.com/users</code> URL.</li><li>The JSON we receive inside <code>response.data</code> will have all its keys converted to snake case automatically for you!</li>
</ol>
Also, you can make use of nested resources with something like this:

<code>api.resource(users, 1)
  .list('blogPosts', { hideDrafts: true })
  .then((response) => {
 // your code
})</code>

And this would make a request to:

<code>http://api.myapp.com/users/1/blog_posts&amp;hide_drafts=true</code>

Notice that Rails Ranger converted your resource and parameters from camel case to snake case, so each part of your app (client and API) can talk in its preferred standards.

Everybody's happy! 

<h3>More Features</h3>
Other things you can do with Rails Ranger include using namespaced routes, interpolating into the URL and making raw HTTP requests.

You can see the full list of actions and methods of Rails Ranger at our comprehensive <a href="https://victor-am.github.io/rails-ranger/">documentation</a>. 


<h3>Bonus: Using Rails Ranger as a Path Builder</h3>
You can also use Rails Ranger as just a path builder and handle the requests yourself with your favorite client:

<code>import { RouteBuilder } from RailsRanger
const routes = new RouteBuilder

route = routes.create('users', { name: 'John' })
// => { path: '/users', params: { name: 'John' }, method: 'post' }</code>

<hr>
Making AJAX requests to a Ruby on Rails API can be fun if we leverage the well-stablished standards of the framework.

This way we can free ourselves from handling repetitive tasks like converting between camel case and snake case and focus on accessing endpoints in a semantic way. 



<h2>Class Composition in JavaScript</h2>

It seems like “composition over inheritance” is the new motto. 
Everyone's talking about it, and that's not strange since composition gives you more flexibility by composing functionality to create a new object, while inheritance forces you to extend entities in an inheritance tree.

<h3>Inheritance with Classes</h3>
ES2015 introduced the class syntax to JavaScript. 
The syntax gives us a nice way to use Object Oriented Programming (OOP) compared to managing prototypes. 
For example, inheritance in ES5 with prototypes:

<code>var Animal = function(name) {
 this.name = name;
}

var Alligator = function(name) {
 Animal.apply(this, arguments); // Call parent constructor
}

// Extend the prototype
Alligator.prototype = Object.create(Animal.prototype);
Alligator.prototype.constructor = Alligator;

var jack = new Alligator("jack");</code>

Becomes this using ES 2015 classes:

<code>class Animal {
 constructor(name) {
   this.name = name;
 }
}

class Alligator extends Animal {}

const jack = new Alligator("jack");</code>

With ES2015 classes, you can omit the constructor, then the parent one will be called. 
If you wish to make it explicit, it'd be equivalent to:

<code>class Alligator extends Animal {
 constructor(...args) {
   super(...args);
 }
}</code>

The new class syntax is just syntactical sugar over the prototype-based model and behind the scenes prototypes are still being used.

The bottom line is that <strong>classes are functions, and functions are objects</strong> in JavaScript, extendable using its <a href="https://developer.mozilla.org/es/docs/Learn/JavaScript/Objects/Inheritance">prototypal inheritance</a> nature. 
That sounds confusing, but it gives the language a lot of flexibility (and pains perhaps).

<h3>Object Composition</h3>
A common composition pattern in JavaScript is using object composition. 
It combines the power of objects and functional programming. 
For the example above, imagine an animal has the ability to <code>eat</code> and <code>fly</code>. 
In hierarchy, that could mean to have an <code>Animal</code> and <code>FlyingAnimal</code>. 
And if we add more and more animals, that hierarchy could become a bit messy, since abilities are shared between animals.

With composition, you could have <em>factories</em> that create an object:

<code>const alligator = name => {
 const self = {
   name
 };

 return self;
}

const jack =  alligator("jack");</code>

We're using an internal variable <code>self</code> that would represent the <code>prototype</code> using classes or prototypes. 
This would behave exactly as the example above.

Then, you can define <em>behaviors</em> as functions receiving the <code>self</code>. 
That makes them easily composable since they're just functions. 
Then we'll use any object merging utility, such as <a href="https://alligator.io/js/dealing-with-objects#objectassign"><code>Object.assign</code></a> or the spread operator (<code>{...a, ...b}</code>) in the factory function in order to create the final object:

<code>// We have some behaviors
const canSayHi = self => ({
 sayHi: () => console.log(`Hi! I'm ${self.name}`)
});
const canEat = () => ({
 eat: food => console.log(`Eating ${food}...`)
});
const canPoop = () => ({
 poop: () => console.log('Going to ...')
});

// Combined previous behaviours
const socialBehaviors = self => Object.assign({}, canSayHi(self), canEat(), canPoop());

const alligator = name => {
 const self = {
   name
 };

 const alligatorBehaviors = self => ({
   bite: () => console.log("Yum yum!")
 });

 return Object.assign(self, socialBehaviors(self), alligatorBehaviors(self));
};

const jack = alligator("jack");
jack.sayHi(); // Hi! I'm jack
jack.eat("Banana"); // Eating Banana...
jack.bite(); // Yum yum!</code>

As you can see, we define different behaviors prefixed with <code>can</code> (the <code>with</code> prefix is usually used as well). 
We are even combining some of them into <code>socialBehaviors</code> by creating a new composed object.

In this way, it'd be quite easy to create another animal:

<code>const dog = name => {
 const self = {
   name
 };

 const dogBehaviors = self => ({
   bark: () => console.log("Woff woff!"),
   haveLunch: food => {
     self.eat(food);
     self.poop();
   }
 });

 return Object.assign(self, dogBehaviors(self), canEat(), canPoop());
}</code>

Keep in mind that we're appending all functionality into the same reference of <code>self</code>, that's why you can call <code>self.eat</code> within <code>haveLunch</code>. 
That allow us to create behaviors on top of other behaviors.

This kind of composition has the benefits of easy refactoring and a simple mental model for structuring since you don't have the restrictions of a hierarchy.

<h3>Composition with JavaScript Classes</h3>
All of this is so cool, but lots of people are used to the OOP way and prefer to work with ES2015 classes. 
But remember that classes are functions and functions are objects, so we can compose them as well.

We can use a mixin technique in order to define pieces of behaviors, consisting of a factory function that takes a superclass as a parameter and returns a subclass:

<code>// Create a mixin
const FoodMixin = superclass => class extends superclass {
 eat(food) {
   console.log(`Eating ${food}`);
 }

 poop() {
   console.log("Going to ");
 }
};</code>

Then we can use it to reproduce the Dog example by enhancing an Animal class with the FoodMixin:

<code>class Animal {
 constructor(name) {
   this.name = name
 }
}

class Dog extends FoodMixin(Animal) {
 constructor(...args) {
   super(...args)
 }

 bark() {
   console.log("Woff woff!")
 }

 haveLunch(food) {
   this.eat(food);
   this.poop();
 }
}

const jack = new Dog("jack");
jack.haveLunch("little mouse");</code>

Using classes for composing gives us both the advantages of the class inheritance and composition world: you can compose behaviors by using a familiar OOP syntax and structure, where <code>super</code> and <code>this</code> are preserved because of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">JavaScript's prototype chain</a>.

<h3>Combining Mixins</h3>
Since mixins are just factory functions, we can use several of them:

<code>const MixinA = superclass => class extends superclass {};
const MixinB = superclass => class extends superclass {};

class Base {}
class Child extends MixinB(MixinA(Base)) {}</code>

We can also create mixins that extend other mixins, although that creates dependencies so try to not overuse it:

<code>const MixinA = superclass => class extends superclass {};
const MixinB = superclass => class extends MixinA(superclass) {};

class Base {}
class Child extends MixinB(Base) {}</code>

The problem using several mixins is that we easily end up in a deep nested syntax:

<code>const MixinA = superclass => class extends superclass {};
const MixinB = superclass => class extends superclass {};
const MixinC = superclass => class extends superclass {};
const MixinD = superclass => class extends superclass {};

class Base {}
class Child extends MixinD(MixinC(MixinB(MixinA(Base)))) {}</code>

The cool thing is that since they're just unary pure functions (they take only one argument), we can use a <code>compose</code> functional utility to avoid that, such as lodash's one:

<code>import compose from "lodash/fp/compose"

const MixinA = superclass => class extends superclass {};
const MixinB = superclass => class extends superclass {};
const MixinC = superclass => class extends superclass {};

class Base {}

const Behaviors = compose(MixinA, MixinB, MixinC)(Base)

class Child extends Behaviors {}</code>

As a final example, let's create a more “real-world” super powered Dog example. 
We could move all behaviors to a <em>behaviors.js</em> file:

behaviors.js

<code>export const EatMixin = superclass => class extends superclass {
 eat(food) {
   console.log(`Eating ${food}`);
 }
};

export const PoopMixin = superclass => class extends superclass {
 poop() {
   console.log("Going to ");
 }
};

export const FlyMixin = superclass => class extends superclass {
 fly() {
   console.log("Flying for real!");
 }
};</code>

And in a <em>dog-example.js</em> file use them:

<code>import compose from "lodash/fp/compose"
import { EatMixin, PoopMixin, FlyMixin } from "./behaviors.js"

class Animal {
 constructor(name) {
   this.name = name
 }
}

const SuperPoweredDog = compose(EatMixin, PoopMixin, FlyMixin)(Animal);

class Dog extends SuperPoweredDog {
 bark() {
   console.log("Woff woff!")
 }

 haveLunch(food) {
   this.eat(food);
   this.poop();
 }
}

const jack = new Dog("jack");
jack.bark(); // Woff woff!
jack.haveLunch("little mouse"); // Eating little mouse. 
Going to </code>

Note that we don't need to specify a constructor in the Dog class if we're just calling a parent constructor with all arguments. 
That happens implicitly.

<h3>Wrapping Up</h3>
We've compared different ways to reuse code and seen some examples of them. 
Class composition is a not a very well known pattern, but it provides easy composition with a nice syntax, having the benefits of composition with a kind of OOP syntax.

Stay cool 

<h2>A Quick Reference for the This Keyword in JavaScript</h2>

It's easy to forget the rules around what JavaScript's <code>this</code> keyword points to in different scenarios. 
This post aims to provide a quick refresher and reference to quickly grasp the different possibilities.

You'll almost always use <code>this</code> in the context of a function, but just remember that if <code>this</code> is used in the global context, then it points to the global object (e.g.: <code>window</code> in the browser and <code>global</code> in Node.js).

<h3>Four Rules</h3>
The value of <code>this</code> differs depending on how a function is invoked (the call site), so we can't know the value of <code>this</code> just by looking at the function itself, but we need to know the context in which the function is invoked.

There are 4 rules to keep in mind. 
Let's quickly review these rules.

<h3>Simple Function Call</h3>
<strong>tl;dr</strong>: <code>this</code> is the global object in non-strict mode, and <code>undefined</code> in strict mode.

<hr>
In the case of a simple function call, in <em>non-strict mode</em> <code>this</code> will default to the global object:

<code>function ghost() {
 console.log(this.boo);
}

ghost(); // undefined

var boo = '';

ghost(); // </code>

In the same scenario, but in <em>strict mode</em>, <code>this</code> will be <code>undefined</code>. 
Our example errors-out because we can't access <em>boo</em> on <code>undefined</code>:

<code>'use strict';

function ghost() {
 console.log(this.boo);
}

ghost(); // TypeError: this is undefined

// the rest is not executed
var boo = '';

ghost();</code>

<hr>
As a side note, variables declared with <em>let</em> or <em>const</em> at the global level are not stored in the global object, but instead in an inaccessible declarative environment record, so our previous example gives us a different result when using <em>let</em>:

<code>function ghost() {
 console.log(this.boo);
}

ghost(); // undefined

let boo = '';

ghost(); // undefined

window.boo = '';

ghost(); // </code>

<h3>Implicit Binding</h3>
<strong>tl;dr</strong>: <code>this</code> points to the object on which the function is called (what's to the left of the period when the function is called).

<hr>
This rule will apply for the majority of cases in your day-to-day code and applies when calling a method on an object:

<code>let myGhost = {
 name: 'Casper',
 boo: ' Boo!!',
 ghost: function () {
   console.log(this.boo);
 }
}

myGhost.ghost(); //  Boo!!</code>

Note also that we get the same result if our object only contains a reference to the function:

<code>function ghost() {
 console.log(this.boo);
}

let myGhost = {
 name: 'Casper',
 boo: ' Boo!!',
 ghost: ghost
}

myGhost.ghost(); //  Boo!!</code>

<h3>Explicit Binding</h3>
<strong>tl;dr</strong>: We can explicitly tell the JavaScript engine to set <code>this</code> to point to a certain value using <em>call</em>, <em>apply</em> or <em>bind</em>.

<hr>
<em>call</em> and <em>apply</em> can be used to invoke a function with a specific value for <code>this</code>:

<code>function ghost() {
 console.log(this.boo);
}

let myGhost = {
 name: 'Casper',
 boo: ' Boo!!',
}

ghost.call(myGhost); //  Boo!!</code>

Both <em>call</em> and <em>apply</em> accomplish the same task, and the first argument to both should be what <code>this</code> points to. 
The difference is only apparent if additional arguments need to be passed to the invoked function. 
With <em>call</em>, the additional arguments are passed as a normal comma-separated list of arguments, and with <em>apply</em> an array of arguments can be passed-in.

<hr>
<em>bind</em> is used to create a new function that's permanently bound to a <code>this</code> value. 
In the following example, we create a new function that has its <code>this</code> permanently bound to <em>myGhost</em> and re-assign ghost to that new permanently bound function:

<code>function ghost() {
 console.log(this.boo);
}

let myGhost = {
 name: 'Casper',
 boo: ' Boo!!',
}

ghost = ghost.bind(myGhost)

ghost(); //  Boo!!</code>

<h3>new Binding</h3>
<strong>tl;dr</strong>: Using the <code>new</code> keyword constructs a new object, and <code>this</code> points it.

<hr>
When a function is invoked as a constructor function using the <em>new</em> keyword, <code>this</code> points to the new object that's created:

<code>function Ghost(name) {
 this.name = name;
}

let myGhost = new Ghost('Casper the friendly ghost');

console.log(myGhost.name); // Casper the friendly ghost</code>

<h3>Bonus Rule: Arrow Functions</h3>
With <a href="https://alligator.io/js/arrow-functions/">arrow functions</a>, <code>this</code> keeps the same value as its parent scope.

For example, here <code>this</code> in the arrow function keeps the same value as <code>this</code> in its enclosing <em>Ghost</em> function:

<code>function Ghost(boo) {
 this.boo = boo;
 this.booUpperCase = () => {
   return this.boo.toUpperCase();
 }
}

const myGhost = new Ghost('boo!!');

console.log(myGhost.boo); // boo!!

console.log(myGhost.booUpperCase()); // BOO!!</code>

<h2>Your First Steps with the Web Audio API</h2>

The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a> is an abstraction layer which aims to simplify audio programming for the web.

In this short introduction, you'll learn about the Web Audio API's <code>AudioContext</code>, and the ability of <code>AudioContext</code> instances to create simple oscillators which can be used to transform your browser into a retro synthesizer! This tutorial's code snippets have been tested in Chrome, but you can probably follow along using the <code>console</code> of your favorite browser's developer tools.

<h3>Prep work</h3>
As mentioned, support for the Web Audio API is not universal, so it's best to verify that the API is available in the user's browser:

<code>let audioContext;

try {
 audioContext =
   new (window.AudioContext || window.webkitAudioContext)();
} catch (error) {
 window.alert(
   `Sorry, but your browser doesn't support the Web Audio API!`
 );
}

if (audioContext !== undefined) {
 /* Our code goes here */
}</code>

After this simple check, we're safe to use the Web Audio API's functionality.

<h3>About AudioContext</h3>
It might be helpful to imagine <code>audioContext</code>–our instance of the <code>AudioContext</code>–as a sort of DJ: it coordinates a collection of audio sources and ensures that the sources play through the user's speakers at the right time and with the right “sound.” And like a DJ, we can think of <code>audioContext</code> as a mediator between sources of sound and a “sound system,” the host machine's audio hardware. 
Here are some more things to keep in mind when working with the <code>AudioContext</code>:
<li>The <code>AudioContext</code> is a master “time-keeper.” All signals should be scheduled relative to <code>audioContext.currentTime</code>.</li><li>Instances of the <code>AudioContext</code> can create audio sources from scratch.</li>

<h3>A simple oscillator</h3>
To see what sorts of sounds it can generate on its own, let's use <code>audioContext</code> to create an <code>OscillatorNode</code>:

<code>const oscillator = audioContext.createOscillator();</code>

This is all we need to make sound with the browser–an <code>AudioContext</code> and an <code>OscillatorNode</code>. 
But first, we need to “wire” the <code>oscillator</code> to our <code>audioContext</code>:

<code>oscillator.connect(audioContext.destination);</code>

The Web Audio API attempts to mimic an analog signal chain. 
We pipe our input signal (the <code>oscillator</code>) into a digital power amp (the <code>audioContext</code>), which then passes the signal to the speakers (the <code>destination</code>).

Let's make some noise:

<code>oscillator.start();</code>

You should hear a sound comparable to a dial tone. 
Congratulations, you're making music with the Web Audio API! Of course, no one wants to hear the same pitch forever and ever. 
You can stop our <code>oscillator</code> this way:

<code>oscillator.stop();</code>

Once an AudioNode has been stopped, it cannot be started again! A new AudioNode will need to be created to resume playback.

The <code>start</code> and <code>stop</code> methods both accept a single parameter of type <code>number</code>. 
The parameter value is used to schedule the start/stop events:

<code>/* Emit a signal 10 seconds from now */
oscillator.start(audioContext.currentTime + 10);

/* Cancel the signal 10 seconds after that */
oscillator.stop(audioContext.currentTime + 20);</code>

Let's conclude by manipulating our <code>oscillator</code> to make different sounds.

<h3>Manipulating sound with AudioParams</h3>
Logging the <code>oscillator</code> object, we get something like this (specific property values are omitted as they may be different depending on the device/browser):

<code>console.log(oscillator);
/*
 {
   channelCount: number,
   context: AudioContext,
   detune: AudioParam,
   type: 'sine' | 'sawtooth' | 'triangle' | 'square'
   frequency: AudioParam,
   numberOfInputs: number,
   numberOfOutputs: number,
   onended: function
   ...
 }
*/</code>

The property that matters most for our purposes is <code>oscillator.frequency</code>:

<code>console.log(oscillator.frequency);
/*
 {
   defaultValue: number,
   maxValue: number,
   minValue: number,
   value: number // Probably 440 (A4)
 }
*/</code>

The <code>frequency</code> value of our <code>oscillator</code> implements the <code>AudioParam</code> <a href="https://developer.mozilla.org/en-US/docs/Web/API/AudioParam">interface</a>. 
The sound of an <code>AudioNode</code> such as <code>oscillator</code> can be manipulated via its <code>AudioParam</code> properties. 
However, direct reassignment to the <code>AudioParam</code> <code>value</code> property has been deprecated in favor of helper methods.

<code>/* Don't do this */
oscillator.frequency.value = 500;</code>

If we want our <code>oscillator</code> to emit a “Bb” instead of an “A”, we should do something like this:

<code>/* The frequency (in Hz) of Bb4 is 466.16 */
oscillator
 .frequency
 .setValueAtTime(466.16, audioContext.currentTime);</code>

or

<code>/* Slowly transition to Bb4 over the span of 10 seconds */
oscillator
 .frequency
 .exponentialRampToValueAtTime(
     466.16,
     audioContext.currentTime + 10
 );</code>

<h3>Bonus: adjusting the periodic waveform</h3>
Our <code>oscillator</code> uses a periodic waveform to emit its tone. 
The waveform is represented by the <code>type</code> property of the <code>OscillatorNode</code> interface. 
By default, the <code>type</code> is <code>'sine'</code>. 
Most browsers support at least three other options: <code>'sawtooth'</code>, <code>'triangle'</code>, and <code>'square'</code>. 
So, changing the “tone” of our <code>oscillator</code> is as simple as:

<code>oscillator.type = 'triangle';</code>

<h3>Conclusion</h3>
Generating and manipulating audio in the browser is easier than ever thanks to the Web Audio API. 
With its help, web developers can recreate retro synth tones with 3-5 lines of code.

 CHALLENGE: Use the Web Audio API to program the riff from <em>Funkytown</em>!

<h2>Exploring the JavaScript Date Object</h2>

There are some great libraries out there to deal with dates in JavaScript, with <a href="https://momentjs.com/">Moment.js</a> and <a href="https://date-fns.org/">date-fns</a> being perhaps the two most popular. 
It's very common however to have just some basic needs for playing with dates and using a library instead of the native JavaScript date object would be overkill. 
Let's therefore explore what we can do natively using the date object.

<h3>Creating Date Objects</h3>
Creating a new date instance is as easy as newing up a date object.

Without arguments, we get the current date and time in the local timezone:

<code>const now = new Date();

console.log(now); // Wed Dec 06 2017 18:30:55 GMT-0800 (PST)</code>

<h3>Milliseconds Since Unix Epoch</h3>
You can also pass-in an integer for a date object that's X amount of milliseconds after January 1st 1970 UTC:

<code>const latter = new Date(4000000000);

console.log(latter); // Sun Feb 15 1970 23:06:40 GMT-0800 (PST)</code>

<h3>Date String</h3>
You can also alternatively create a date object by passing a string:

<code>const summerOf95 = new Date("1995-06-28");

// or, with a full date string that also includes the time and the time zone. 
Note here that `Z` is for UTC timezone:
const december31st = new Date("1999-12-31T02:56:03.392Z");</code>

<h3>Date Components</h3>
Finally, you can create a date object in your local timezone using separate component argument:

<code>const someDate = new Date(2000, 5, 20, 16, 34, 12, 24);

console.log(someDate); // Tue Jun 20 2000 16:34:12 GMT-0700 (PDT)</code>

Notice how the months are zero-based, and <code>5</code> therefore represents June. 
Components for time can be omitted and <code>0</code> will be assumed:

<code>const someDate = new Date(2000, 5, 20, 16, null, 12, 24);

console.log(someDate); // Tue Jun 20 2000 16:00:12 GMT-0700 (PDT)</code>

If you're confused by the date returned when console logging a date object, remember that most browsers output the time in your local timezone.

<h3>Timestamps</h3>
Get a timestamp (number of milliseconds since Jan 1st 1970 UTC) using a date instance's <em>getTime</em> method:

<code>const nowTimestamp = new Date().getTime();

console.log(nowTimestamp); // 1512616153783</code>

<h3>Timestamp for now</h3>
In the above example, we're getting the timestamp for <code>now</code>. 
This is so common that JavaScript now has a method to get just that more easily:

<code>const nowTimestamp = Date.now();

console.log(nowTimestamp); // 1512616153783</code>

<hr>
Timestamps are useful to easily calculate the difference in milliseconds between two dates. 
For example, here we get the difference in milliseconds between Feb 3rd 1996 and Jan 1 1970:

<code>const diff = new Date("1995-02-03").getTime() - new Date(0).getTime();</code>

In the above case, you can ommit the call to <em>getTime</em> and the dates will automatically be coerced to timestamps:

<code>const diff = new Date("1995-02-03") - new Date(0);</code>

<h3>Human Readable Strings</h3>
Date object instances also give us a few useful methods to get human-friendly string representations. 
The <em>toDateString</em>, <em>toTimeString</em>, <em>toLocaleDateString</em>, <em>toLocaleString</em>, <em>toLocaleTimeString</em> and <em>toUTCString</em> methods are the most useful ones, and demonstrated in the following example:

<code>const now = new Date();

console.log(now.toDateString()); // Wed Dec 06 2017
console.log(now.toTimeString()); // 19:23:42 GMT-0800 (PST)
console.log(now.toLocaleDateString()); // 12/6/2017
console.log(now.toLocaleString()); // 12/6/2017, 7:20:28 PM
console.log(now.toLocaleTimeString()); // 7:20:51 PM
console.log(now.toUTCString()); // Thu, 07 Dec 2017 03:21:14 GMT</code>

<h3>Getting Date or Time Components</h3>
You can get specific date/time components from a date instance using the following methods:
<li>
<em>getFullYear()</em>: The year, using 4 digits.</li><li>
<em>getDate()</em>: The day of the month (e.g: 31).</li><li>
<em>getMonth()</em>: A zero-based integer for the month (e.g: 0 for January).</li><li>
<em>getDay()</em>: The index for the day of the week from 0 for Sunday up to 6 for Saturday.</li><li>
<em>getHours()</em>: The hour of the day.</li><li>
<em>getMinutes()</em>: The minutes.</li><li>
<em>getSeconds()</em>: The seconds.</li><li>
<em>getMilliseconds()</em>: The milliseconds.</li>

Here's a simple example:

<code>const now = new Date();

console.log(`It's ${now.getHours()}:${now.getMinutes()} o'clock`);
// It's 19:34 O'Clock</code>

Note that all the above methods return date/time components in the local timezone. 
Each method has an equivalent so that UTC date/time is returned instead (e.g: <em>getUTCMinutes()</em>).

<h3>Setting Date or Time Components</h3>
Similar to how we can get date/time components, we can also set them using analogous methods:

<code>const now = new Date();

now.setFullYear(2049);

console.log(now.toLocaleString()); // 12/6/2049, 7:40:04 PM</code>

Note that there's a shortcut where most of the set methods can take multiple arguments to set the other components. 
These two snippets produce the same result:

The tedious way

<code>const now = new Date();

now.setHours(0);
now.setMinutes(22);
now.setSeconds(3);</code>

The shortcut

<code>const now = new Date();

now.setHours(0, 22, 3);</code>

<h3>Adding/Subtracting Time</h3>
Using a combination of the get and set methods, you can add to or subtract from the date/time components of a date instance. 
Here for example, we add 15 minutes to the current time:

<code>const now = new Date();

console.log(now.toLocaleTimeString()); // 7:47:53 PM

now.setMinutes(now.getMinutes() + 15);

console.log(now.toLocaleTimeString()); // 8:02:53 PM</code>

<h2>substring vs substr in JavaScript</h2>

Similar to how the difference between the <a href="https://alligator.io/js/slice-vs-splice/">slice vs splice</a> array methods can be hard to remember, it can also be hard to remember the difference between the substring and substr JavaScript string methods. 
Here's a quick reference to help out with that.

<strong>TL;DR:</strong> <em>substring</em> takes a starting index and an end index while <em>substr</em> takes a starting index and a length of characters.

<h3>String.prototype.substring</h3>
The <em>substring()</em> method, all spelled out, returns a new string with a subset of the string. 
With one argument passed-in, we get the string starting from the specified index <strong>(inclusive)</strong> until the end of the string:

<code>const myStr = 'Alligator';

const myNewStr = myStr.substring(2);

console.log(myNewStr); // ligator</code>

With two arguments passed-in, we get a subset of the string from the starting index to the end index <strong>(exclusive)</strong>:

<code>const myStr = 'Alligator';

const myNewStr = myStr.substring(0, 3);

console.log(myNewStr); // All</code>

<h3>String.prototype.substr</h3>
The <em>substr()</em> method is very similar, but the second argument is not for the end index, it's for the amount of characters.

Here we want a 3-character string from a starting index of 2:

<code>const myStr = 'Alligator';

const myNewStr = myStr.substr(2, 3);

console.log(myNewStr); // lig</code>

<h3>Negative start index</h3>
Additionally, the first argument to <em>substr</em> can be a negative integer, in which case the start of the returned string is counted from the end of the string that the method is used on:

<code>const myStr = 'Alligator';

const myNewStr = myStr.substr(-2);

console.log(myNewStr); // or</code>

<h3>Same Result When Only One Argument</h3>
When only the first argument is used and is a positive integer, both <em>substring</em> and <em>substr</em> return the same value:

<code>const myStr = 'Alligator';

const myNewStrViaSubstring = myStr.substring(3);

const myNewStrViaSubstr = myStr.substr(3);

console.log(myNewStrViaSubstring); // igator

console.log(myNewStrViaSubstr); // igator</code>

<h2>Using the Geolocation API</h2>

The Geolocation API is a very simple API that allows to get a device's current location coordinates. 
It has only two methods: <em>getCurrentPosition</em> and <em>watchPosition</em> and the data returned is very straightforward, but when coupled with a mapping API, complex location-aware web apps can be created.

<h3>Setup</h3>
Before doing anything, you'll want to check if the API is available in the user's browsers:

<code>if (navigator.geolocation) {
 //  yep, we can proceed!
} else {
 // no can do
}</code>

Note that your website or app has to be served over <strong>https</strong> for the API to work. 
For local development, you'll want to run a local server instead of opening an html file directly. 
If you have <strong>npm 5.2</strong> or above available on your machine, you can use <a href="/workflow/npx/">npx</a> to quickly run an http server:

<code>$ npx http-server</code>

<h3>getCurrentPosition</h3>
Use the <em>getCurrentPosition</em> method to get the user's coordinates once. 
The first and only required argument should be a success callback function that will be called with a position object if the position request is successful.

Here's a simple example that prints out the device's longitude and latitude to the console:

<code>if (navigator.geolocation) {
 navigator.geolocation.getCurrentPosition(displayLocationInfo);
}

function displayLocationInfo(position) {
 const lng = position.coords.longitude;
 const lat = position.coords.latitude;

 console.log(`longitude: ${ lng } | latitude: ${ lat }`);
}</code>

Here's the shape and example data of the position object that's passed to the success callback:

<code>coords:
 accuracy: 52
 altitude: null
 altitudeAccuracy: null
 heading: null
 latitude: 27.380583
 longitude: 33.631839
 speed: null
timestamp: 1509152059444</code>

As you can see from the above example, some of the properties for <em>coords</em> may have a value of <strong>null</strong>. 
The availability of the data will depend on the capabilities of the device that's under use. 
The heading value, if any, will be in degrees relating to true North and going clockwise and the speed value, if any, will be in meters per second.

<h3>Permission</h3>
Because position information is potentially sensitive, the first time a domain makes a call to get a user's position, the browser will ask the user for permission by showing a widget that looks a little bit like this:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1adcb91c03717f0bcef3b6eec63dff61810e4b1b/d1487/images/js/geolocation/permission.png" width="419" height="215" alt="Geolocation permission widget">

If the user refuses access, the error callback, if any, will be called with an error code of 1 (<em>PERMISSION_DENIED</em>).

<h3>watchPosition</h3>
There's also a <em>watchPosition</em> method that will return new position data each time the device changes position significantly.

In the following example, we initiate a position watcher and then stop it after 15 seconds:

<code>const watcher = navigator.geolocation.watchPosition(displayLocationInfo);

setTimeout(() => {
 navigator.geolocation.clearWatch(watcher);
}, 15000);

function displayLocationInfo(position) {
 // ...do something with the data each time
}</code>

We use <em>clearWatch</em> with a watcher id to stop watching for position data.

<h3>Error Handling</h3>
You can provide an error handler callback as the second argument to either <em>getCurrentPosition</em> or <em>watchPosition</em>. 
If the error callback is called, an error object will be passed-in and will contain a <strong>code</strong> property that will have a value of 3 (<em>TIMEOUT</em>), 2 (<em>POSITION_UNAVAILABLE</em>) or 1 (<em>PERMISSION_DENIED</em>), depending on the nature of the error.

Here's a simple example where we trigger an automatic error by setting a timeout value of 0ms:

<code>navigator.geolocation.getCurrentPosition(displayLocationInfo, handleLocationError, { timeout: 0 });

function displayLocationInfo(position) {
 // ...do stuff
}

function handleLocationError(error) {
 switch (error.code) {
   case 3:
     // ...deal with timeout
     break;
   case 2:
     // ...device can't get data
     break;
   case 1:
     // ...user said no 
 }
}</code>

<h3>Options</h3>
Finally, you can pass-in a third argument with options for the following:
<li>
<em>enableHighAccuracy</em>: Takes a boolean value and defaults to false. 
Indicates if the position information should be as accurate as possible (more accuracy may be more costly in terms of CPU and battery usage).</li><li>
<em>maximumAge</em>: Number of milliseconds to keep position data cached for. 
It defaults to a value of 0.</li><li>
<em>timeout</em>: Number of milliseconds after which the error callback will be called if no data has been acquired.</li>

Here's an example with options passed-in for <strong>maximumAge</strong> and <strong>timeout</strong>:

<code>navigator.geolocation.getCurrentPosition(
 displayLocationInfo,
 handleLocationError,
 { maximumAge: 1500000, timeout: 0 }
);

function displayLocationInfo(position) {
 const lng = position.coords.longitude;
 const lat = position.coords.latitude;

 console.log(`longitude: ${lng} | latitude: ${lat}`);
}

function handleLocationError(error) {
 switch (error.code) {
   case 3:
     // timeout was hit, meaning nothing's in the cache
     // let's provide a default location:
     displayLocationInfo({ coords: { longitude: 33.631839, latitude: 27.380583 } });

     // now let's make a non-cached request to get the actual position
     navigator.geolocation.getCurrentPosition(displayLocationInfo, handleLocationError);
     break;
   case 2:
     // ...
     break;
   case 1:
   // ...
 }
}</code>

If there's cached position data that's available and that's a maximum of 25 minutes old (1500000ms) we return that. 
If not, we error-out immediately (using a <em>timeout</em> of <strong>0ms</strong>). 
In the error handler case for a timeout, we provide a default location value and then make another call to get fresh location data. 
This way, the app can avoid showing a blank state while fresh position data is being gathered.


<h2>Exploring Async/Await Functions in JavaScript</h2>

<a href="https://alligator.io/js/promises-es6/">Promises</a> give us an easier way to deal with asynchrony in our code in a sequential manner. 
Considering that our brains are not designed to deal with asynchronicity efficiently, this is a much welcome addition. 
<strong>Async/await functions</strong>, a new addition with ES2017 (<em>ES8</em>), help us even more in allowing us to write completely synchronous-looking code while performing asynchronous tasks behind the scenes.

The functionality achieved using async functions can be recreated by combining promises with <a href="https://alligator.io/js/generator-functions-es6/">generators</a>, but async functions give us what we need without any extra boilerplate code.

<h3>Simple Example</h3>
In the following example, we first declare a function that returns a promise that resolves to a value of <em></em> after 2 seconds. 
We then declare an <em>async</em> function and <em>await</em> for the promise to resolve before logging the message to the console:

<code>function scaryClown() {
 return new Promise(resolve => {
   setTimeout(() => {
     resolve('');
   }, 2000);
 });
}

async function msg() {
 const msg = await scaryClown();
 console.log('Message:', msg);
}

msg(); // Message:  &lt;-- after 2 seconds</code>

<code>await</code> is a new operator used to wait for a promise to resolve or reject. 
It can only be used inside an async function.

The power of async functions becomes more evident when there are multiple steps involved:

<code>function who() {
 return new Promise(resolve => {
   setTimeout(() => {
     resolve('');
   }, 200);
 });
}

function what() {
 return new Promise(resolve => {
   setTimeout(() => {
     resolve('lurks');
   }, 300);
 });
}

function where() {
 return new Promise(resolve => {
   setTimeout(() => {
     resolve('in the shadows');
   }, 500);
 });
}

async function msg() {
 const a = await who();
 const b = await what();
 const c = await where();

 console.log(`${ a } ${ b } ${ c }`);
}

msg(); //  lurks in the shadows &lt;-- after 1 second</code>

A word of caution however, in the above example each step is done sequentially, with each additional step waiting for the step before to resolve or reject before continuing. 
If you instead want the steps to happen in parallel, you can simply use <em>Promise.all</em> to wait for all the promises to have fulfilled:

<code>// ...

async function msg() {
 const [a, b, c] = await Promise.all([who(), what(), where()]);

 console.log(`${ a } ${ b } ${ c }`);
}

msg(); //  lurks in the shadows &lt;-- after 500ms</code>

<em>Promise.all</em> returns an array with the resolved values once all the passed-in promises have resolved.

In the above we also make use of some nice <a href="https://alligator.io/js/object-array-destructuring-es2015/">array destructuring</a> to make our code succinct.

<h3>Promise-Returning</h3>
Async functions always return a promise, so the following may not produce the result you're after:

<code>async function hello() {
 return 'Hello Alligator!';
}

const b = hello();

console.log(b); // [object Promise] { ... 
}</code>

Since what's returned is a promise, you could do something like this instead:

<code>async function hello() {
 return 'Hello Alligator!';
}

const b = hello();

b.then(x => console.log(x)); // Hello Alligator!</code>

…or just this:

<code>async function hello() {
 return 'Hello Alligator!';
}

hello().then(x => console.log(x)); // Hello Alligator!</code>

<h3>Different Forms</h3>
So far with our examples we saw the async function as a function declaration, but you we can also define async function expressions and async arrow functions:

<h3>Async Function Expression</h3>
Here's the async function from our first example, but defined as a function expression:

<code>const msg = async function() {
 const msg = await scaryClown();
 console.log('Message:', msg);
}</code>

<h3>Async Arrow Function</h3>
Here's that same example once again, but this time defined as an arrow function:

<code>const msg = async () => {
 const msg = await scaryClown();
 console.log('Message:', msg);
}</code>

<h3>Error Handling</h3>
Something else that's very nice about async functions is that error handling is also done completely synchronously, using good old <strong>try…catch</strong> statements. 
Let's demonstrate by using a promise that will reject half the time:

<code>function yayOrNay() {
 return new Promise((resolve, reject) => {
   const val = Math.round(Math.random() * 1); // 0 or 1, at random

   val ? resolve('Lucky!!') : reject('Nope ');
 });
}

async function msg() {
 try {
   const msg = await yayOrNay();
   console.log(msg);
 } catch(err) {
   console.log(err);
 }
}

msg(); // Lucky!!
msg(); // Lucky!!
msg(); // Lucky!!
msg(); // Nope 
msg(); // Lucky!!
msg(); // Nope 
msg(); // Nope 
msg(); // Nope 
msg(); // Nope 
msg(); // Lucky!!</code>

Given that async functions always return a promise, you can also deal with unhandled errors as you would normally using a catch statement:

<code>async function msg() {
 const msg = await yayOrNay();
 console.log(msg);
}

msg().catch(x => console.log(x));</code>

<hr>
This synchronous error handling doesn't just work when a promise is rejected, but also when there's an actual runtime or syntax error happening. 
In the following example, the second time with call our <em>msg</em> function we pass in a <em>number</em> value that doesn't have a <em>toUpperCase</em> method in its prototype chain. 
Our <strong>try…catch</strong> block catches that error just as well:

<code>function caserUpper(val) {
 return new Promise((resolve, reject) => {
   resolve(val.toUpperCase());
 });
}

async function msg(x) {
 try {
   const msg = await caserUpper(x);
   console.log(msg);
 } catch(err) {
   console.log('Ohh no:', err.message);
 }
}

msg('Hello'); // HELLO
msg(34); // Ohh no: val.toUpperCase is not a function</code>

<h3>Async Functions With Promise-Based APIS</h3>
As we showed in our primer to the <a href="https://alligator.io/js/fetch-api#fetch--asyncawait">Fetch API</a>, web APIs that are promise-based are a perfect candidate for async functions:

<code>async function fetchUsers(endpoint) {
 const res = await fetch(endpoint);
 let data = await res.json();

 data = data.map(user => user.username);

 console.log(data);
}

fetchUsers('https://jsonplaceholder.typicode.com/users');
// ["Bret", "Antonette", "Samantha", "Karianne", "Kamren", "Leopoldo_Corkery", "Elwyn.Skiles", "Maxime_Nienow", "Delphine", "Moriah.Stanton"]</code>


<h2>A Fetch API Primer</h2>

Fetch is a new-ish, promise-based API that lets us do Ajax requests without all the fuss associated with <strong>XMLHttpRequest</strong>. 
As you'll see in this post, Fetch is very easy to use and work with and greatly simplifies fetching resources from an API. 
Plus, it's now supported in all modern browsers, so using Fetch is really a no-brainer.

<h3>Get Requests</h3>
Let's demonstrate a simple GET request by going and <em>GET</em> ourselves some dummy data from the <a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> API:

<code>fetch('https://jsonplaceholder.typicode.com/users')
 .then(res => res.json())
 .then(res => res.map(user => user.username))
 .then(userNames => console.log(userNames));</code>

And the output will be an array of user names like this:

<code>["Bret", "Antonette", "Samantha", "Karianne", "Kamren", "Leopoldo_Corkery", "Elwyn.Skiles", "Maxime_Nienow", "Delphine", "Moriah.Stanton"]</code>

<hr>
Given that we expect a JSON response, we first need to call the <em>json()</em> method to transform the <em>Response</em> object into an object that we can interact with. 
The <code>text()</code> could be used if we expected an XML response instead.

<h3>Post, Put and Delete Requests</h3>
To make requests other than <strong>GET</strong>, pass-in an object as a second argument to a fetch call with the method to use as well as any needed headers and the body of the request:

<code>const myPost = {
 title: 'A post about true facts',
 body: '42',
 userId: 2
}

const options = {
 method: 'POST',
 body: JSON.stringify(myPost),
 headers: {
   'Content-Type': 'application/json'
 }
};

fetch('https://jsonplaceholder.typicode.com/posts', options)
 .then(res => res.json())
 .then(res => console.log(res));</code>

<strong>JSONPlaceholder</strong> sends us the POSTed data back with an ID attached:

<code>Object {
 body: 42,
 id: 101,
 title: "A post about true facts",
 userId: 2
}</code>

You'll note that the request body needs to be <a href="https://alligator.io/js/json-parse-stringify/">stringified</a>. 
Other methods that you can use for fetch calls are <em>DELETE</em>, <em>PUT</em>, <em>HEAD</em> and <em>OPTIONS</em>

<h3>Error Handling</h3>
There's a catch (pun intended ) when it comes to error handling with the Fetch API: if the request properly hits the endpoint and comes back, no error will be thrown. 
This means that error handling is not as simple as chaining a <em>catch</em> call at then end of your fetch promise chain.

Luckily though, the response object from a fetch call has an <em>ok</em> property that will be either true of false depending on the success of the request. 
You can then use <em>Promise.reject()</em> if <em>ok</em> is false:

<code>fetch('https://jsonplaceholder.typicode.com/postsZZZ', options)
 .then(res => {
   if (res.ok) {
     return res.json();
   } else {
     return Promise.reject({ status: res.status, statusText: res.statusText });
   }
 })
 .then(res => console.log(res))
 .catch(err => console.log('Error, with message:', err.statusText));</code>

With the above example our promise will reject because we're calling an endpoint that doesn't exist. 
The chained catch call will be hit and the following will be outputted:

<code>"Error, with message: Not Found"</code>

<h3>Fetch + Async/Await</h3>
Since Fetch is a promise-based API, using <em>async</em> functions is a great option to make your code even easier to reason about and synchronous-looking. 
Here for example is an <strong>async/await</strong> function that performs a simple <strong>GET</strong> request and extracts the usernames from the returned JSON response to then log the result at the console:

<code>async function fetchUsers(endpoint) {
 const res = await fetch(endpoint);
 let data = await res.json();

 data = data.map(user => user.username);

 console.log(data);
}

fetchUsers('https://jsonplaceholder.typicode.com/users');</code>

Or, you could just return a promise from your async/await function and then you'd have the ability to keep-on chaining <em>then</em> calls after calling the function:

<code>async function fetchUsers(endpoint) {
 const res = await fetch(endpoint);
 const data = await res.json();

 return data;
}

fetchUsers('https://jsonplaceholder.typicode.com/users')
 .then(data => {
   console.log(data.map(user => user.username));
 });</code>

Calling <em>json()</em> returns a promise so in the above example, when we <code>return data</code> in the async function, we're returning a promise.

And then again you could also throw an error if the response's <em>ok</em> is false and catch the error as usual in your promise chain:

<code>async function fetchUsers(endpoint) {
 const res = await fetch(endpoint);

 if (!res.ok) {
   throw new Error(res.status); // 404
 }

 const data = await res.json();
 return data;
}

fetchUsers('https://jsonplaceholder.typicode.com/usersZZZ')
 .then(data => {
   console.log(data.map(user => user.website));
 })
 .catch(err => console.log('Ooops, error', err.message));</code>

<code>Ooops, error 404</code>

<h3>Polyfills</h3>
<li>If you need to support older browsers, like Internet Explorer 11, you'll need to use a Fetch polyfill <a href="https://github.com/github/fetch">like this one from Github</a>.</li><li>If you need to use Fetch in Node.js, two of the most popular options are <a href="https://github.com/matthew-andrews/isomorphic-fetch">isomorphic-fetch</a> and <a href="https://github.com/bitinn/node-fetch">node-fetch</a>.</li>


<h2>Dealing With Objects in JavaScript With Object.assign, Object.keys and hasOwnProperty</h2>

This post is a sort of grab bag to help you explore a few very useful methods to help you manage your objects in JavaScript. 
We'll explore <em>Object.keys</em>, <em>Object.prototype.hasOwnProperty</em> and the newer <em>Object.assign</em>.

<h3>hasOwnProperty</h3>
<em>hasOwnProperty</em> is a method available on object instances that allows to check if an object has a property directly on its instance. 
Here's a simple example that should illustrate this very clearly:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

console.log('clown' in myObj); // true
console.log('valueOf' in myObj); // true

console.log(myObj.hasOwnProperty('clown')); // true
console.log(myObj.hasOwnProperty('valueOf')); // false</code>

<h3>Object.keys</h3>
The <em>Object.keys</em> static method returns an array with the property keys on an object:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

console.log(Object.keys(myObj));

// ["clown", "police", "santa", "farmer"]</code>

<em>Object.keys</em> can be really useful in allowing to use a <a href="https://alligator.io/js/for-of-for-in-loops/">for…of</a> loop over an object:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

for (let k of Object.keys(myObj)) {
 console.log(`Hey ${ myObj[k] }!`);
}

// "Hey !"
// "Hey !"
// "Hey !"
// "Hey !"</code>

Note that in the array returned from Object.keys, the keys won't necessarily be in order.

<h3>Object.assign</h3>
ES2015 (ES6) brings us a new static method on the <strong>Object</strong> constructor: <em>Object.assign</em>. 
This new method allows to easily copy values from one object to another. 
Notice in the following example how we use an empty object literal and copy over the properties from <em>myObj</em> to create a new object (<em>myObj3</em>) that's a copy of <strong>myObj</strong>:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

const myObj2 = myObj;

const myObj3 = Object.assign({}, myObj);

console.log(Object.is(myObj, myObj2)); // true

console.log(Object.is(myObj, myObj3)); // false

console.log(myObj3);

// Object {
//   clown: "",
//   farmer: "",
//   police: "",
//   santa: ""
// }</code>

In case you're wondering, <em>Object.is</em> is a method used to check if two objects are the same.

Note that only an object's enumerable properties will be copied over with Object.assign.

The first argument is the source object, and the subsequent arguments are source objects. 
You can pass-in multiple source objects, and duplicate properties in sources passed last will win:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

const myObj2 = Object.assign({}, myObj, {
 santa: '',
 teacher: ''
});

console.log(myObj2);

// Object {
//   clown: "",
//   farmer: "",
//   police: "",
//   santa: "",
//   teacher: ""
// }</code>

Today with the likes of Redux for state management, Object.assign becomes really useful to create completely new objects from existing ones, allowing you to copy and expand objects in an immutable manner.

<h3>Bonus: Object.freeze</h3>
Use <em>Object.freeze</em> to shallowly freeze an object to prevent its properties from being changed. 
Note in this following example how, after using Object.free on an object, we can't change a property, add a new one or delete one:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

myObj.clown = 'scary';
myObj.astronaut = '';

Object.freeze(myObj);

myObj.clown = 'really scary';
myObj.student = '';
delete myObj.santa;

console.log(myObj);

// Object {
//   clown: "scary",
//   farmer: "",
//   police: "",
//   santa: "",
//   astronaut: ""
// }</code>

There's also another useful method, <em>Object.isFrozen</em>, to know if an object has been frozen:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: ''
}

console.log(Object.isFrozen(myObj)); // false

Object.freeze(myObj);

console.log(Object.isFrozen(myObj)); // true</code>

<hr>
Note that nested objects won't automatically be frozen by <em>Object.freeze</em>. 
In the following example, the nested <em>animals</em> object can still have its properties changed or deleted even after the containing object has been frozen:

<code>const myObj = {
 clown: '',
 police: '',
 santa: '',
 farmer: '',
 animals: {
   cow: '',
   rabbit: ''
 }
}

Object.freeze(myObj);

delete myObj.animals.rabbit;
myObj.animals.cow = 'moo!';

console.log(myObj);

// Object {
//   clown: "",
//   farmer: "",
//   police: "",
//   santa: "",
//   animals: {
//     cow: 'moo!'
//   }
// }</code>

In order to deep-freeze an object, we would have to instead recursively freeze any object property that happens to also be an object. 
Here's <a href="https://github.com/substack/deep-freeze">a good utility</a> to make deep freeze a breeze.

 P.S.: You may also be interested in learning about the new <a href="https://alligator.io/js/object-entries-values/">Object.values &amp; Object.entries</a> methods.

<h2>The Web Share API</h2>

Another day, another Web API! The Web Share API is meant to help developers implement sharing functionality into their apps or websites, but using the device's native sharing capabilities instead of having to resort to scripts from the individual social platforms and DIY implementations.

The API surface is a simple as it gets. 
You can even read the <a href="https://wicg.github.io/web-share/">entire current spec</a> in just a few minutes. 
In keeping with that spirit, this post will be a short and sweet one.

<h3>Usage</h3>
A few notes to help you get started:
<li>Your site or web app has to be served over HTTPS in order for the API to work. 
When developing, running over localhost also works.</li><li>The <code>navigator.share</code> method has to be called following a user gesture like a button click. 
It can't simply be called on page load for example. 
That's in place to help prevent abuse.</li>

First, you'll want to detect if the browser supports the Web Share API. 
You can simply check to see if <code>navigator.share</code> is defined:

<code>if (navigator.share) {
 // we can use web share!
} else {
 // provide a fallback here
}</code>

The API is promise-based and is as simple to use as passing-in an object to the navigator's <em>share</em> method. 
The object should have at least a <strong>text</strong> or <strong>url</strong> key, and the <strong>title</strong> can also be passed-in.

Here's a simple example. 
Notice that our logic is inside of a click event handler, to satisfy the requirement that the share be initiated from a user gesture:

<code>const shareBtn = document.querySelector('.share-btn');

shareBtn.addEventListener('click', () => {
 if (navigator.share) {
   navigator.share({
      title: 'My awesome post!',
     text: 'This post may or may not contain the answer to the universe',
     url: window.location.href
   }).then(() => {
     console.log('Thanks for sharing!');
   })
   .catch(err => {
     console.log(`Couldn't share because of`, err.message);
   });
 } else {
   console.log('web share not supported');
 }
});</code>

<hr>
You may want to grab the page's title and use the canonical URL if the page has one. 
Here's a more complete example that includes just that:

<code>const shareBtn = document.querySelector('.share-btn');
const ogBtnContent = shareBtn.textContent;
const title = document.querySelector('h1').textContent;
const url = document.querySelector('link[rel=canonical]') &amp;&amp;
           document.querySelector('link[rel=canonical]').href ||
           window.location.href;

shareBtn.addEventListener('click', () => {
 if (navigator.share) {
   navigator.share({
     title,
     url
   }).then(() => {
     showMessage(shareBtn, 'Thanks! ');
   })
   .catch(err => {
     showMessage(shareBtn, `Couldn't share `);
   });
 } else {
   showMessage(shareBtn, 'Not supported ');
 }
});

function showMessage(element, msg) {
 element.textContent = msg;
 setTimeout(() => {
   element.textContent = ogBtnContent;
 }, 2000);
}</code>

In that example, our share button's text changes for 2 seconds to indicate if the share was successful, if there was an error sharing or if the Web Share API is not supported at all.

If your using a browser that has support, you can try it out by clicking the button below:

<button type="button">Share me!</button>

<hr>
<h3>A touch of JavaScript trivia for you</h3>
The statement used in the example to grab the url may be confusing at first glance:

<code>const url = document.querySelector('link[rel=canonical]') &amp;&amp;
           document.querySelector('link[rel=canonical]').href ||
           window.location.href;</code>

Here's some food for thought that will help you understand:

<code>55 &amp;&amp; 777; // 777
55 &amp;&amp; 777 || 999; // 777
55 &amp;&amp; 0 || 999; // 999</code>

In other words, the logical operators <em>&amp;&amp;</em> and <em>||</em> work in a way that may be surprising. 
They don't return a boolean but rather return either of the lefthand side expression or the righthand side expression depending on the truthiness of the expressions. 
Refer to this <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators">MDR article</a> for more details.

We check if the <em>&lt;link rel=”canonical”></em> exists, and if so, we grab the value of its <em>href</em> property. 
Otherwise, we just grab the href from <em>window.location</em>.

You may have also noticed that we use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015">shorthand in our object literal</a>, which is possible because the variables passed-in have the same names as the object keys.

<h3>Web Share API Browser Support</h3>
As you can see if you click the <em>Browser Support</em> button below, support for the Web Share API is pretty dismal at this time.

It's currently only available in Chrome and used to only be available as an origin trial, but as of Chrome 61 it can be used right out of the box.

 Here's to hoping that support gets better soon!

<h2>Detect Network Status With navigator.onLine</h2>

With <em>navigator.onLine</em>, we have a simple API to detect the user's current network status. 
It's pretty much available across the board, even down to IE9.

You can directly query <em>navigator.onLine</em>, which returns true or false depending on whether the user is online or not:

<code>navigator.onLine; // true

// now if you go offline:
navigator.onLine; // false</code>

Note that a value of <strong>true</strong> doesn't guarantee that the network is accessible.

You can also hook into the <em>online</em> and <em>offline</em> events of the <strong>window</strong> object to listen for when the network status changes to either online or offline:

<code>window.addEventListener('online', () => {
 //  we're back online!
});

window.addEventListener('offline', () => {
 //  oh no!
});</code>

<h3>Concrete Example</h3>
Here's a complete example with an info box that takes a different message and changes class names depending on the current network status:

<code>function showStatus(online) {
 const statusEl = document.querySelector('.network-status');

 if (online) {
   statusEl.classList.remove('warning');
   statusEl.classList.add('success');
   statusEl.innerText = `You're online! `;
 } else {
   statusEl.classList.remove('success');
   statusEl.classList.add('warning');
   statusEl.innerText = `You're offline! `;
 }
}

window.addEventListener('load', () => {
 // 1st, we set the correct status when the page loads
 navigator.onLine ? showStatus(true) : showStatus(false);

 // now we listen for network status changes
 window.addEventListener('online', () => {
   showStatus(true);
 });

 window.addEventListener('offline', () => {
   showStatus(false);
 });
});</code>

<h3>Try it out by turning your wifi off &amp; back on:</h3>



<h2>Using the Intersection Observer API to Trigger Animations and Transitions</h2>

With rapidly increasing browser support, there's been a lot of excitement around the <a href="https://github.com/w3c/IntersectionObserver/blob/gh-pages/explainer.md">Intersection Observer API</a>, which provides an easy way to watch and register callbacks to trigger when elements on a page come into view. 
Probably the most obvious use case is for lazy loading image when they come into view. 
Using Intersection Observer makes it less resource intensive and a lot easier to implement compared to listening for scroll events and checking if an element is about to enter the viewport. 
Behind the scenes, the Intersection Observer API makes use of <em>requestIdleCallback</em> to help with performance even more.

We've recently touched on using Intersection Observer to lazy load images when we covered writing <a href="/vuejs/vue-abstract-components/">abstract components in Vue.js</a>. 
Another fun use case is to make it easy to trigger CSS animations and transitions when an element comes into view. 
This is exactly what we'll be doing here, and give you a general overview of how to use the API in general at the same time.

<h3>Setup</h3>
Using the Intersection Observer API is as simple as creating an <em>IntersectionObserver</em> instance and calling <em>observe</em> on the instance with an element to observe:

<code>const myImg = document.querySelector('.animate-me');

observer = new IntersectionObserver((entry, observer) => {
 console.log('entry:', entry);
 console.log('observer:', observer);
});

observer.observe(myImg);</code>

With this, an <strong>InterSectionObserverEntry</strong> and the <strong>observer</strong> objects will be logged to the console each time the observed element either intersects in or out of the viewport. 
The entry itself contains properties with data about the <em>target</em>, the <em>boundingClientRect</em> and the <em>intersectionRatio</em>, among others.

Most of the time, you'll instead want to observe multiple elements at once. 
This can be done with the same intersection observer:

<code>const myImgs = document.querySelectorAll('.animate-me');

observer = new IntersectionObserver(entries => {
 console.log(entries);
});

myImgs.forEach(image => {
 observer.observe(image);
});</code>

<hr>
We're not yet detecting if the observed elements are either in or out of view, just that the intersection has been triggered. 
Here's how you could act on the observed elements either entering the view or leaving the view:

<code>const myImgs = document.querySelectorAll('.animate-me');

observer = new IntersectionObserver(entries => {
 entries.forEach(entry => {
   if (entry.intersectionRatio > 0) {
     console.log('in the view');
   } else {
     console.log('out of view');
   }
 });
});

myImgs.forEach(image => {
 observer.observe(image);
});</code>

We simply check if the entry's <em>intersectionRatio</em> is greater than 0 to know if it has entered the viewport.

<h3>Unobserving</h3>
Say you want to observe an element entering the view once and then stop observing that element. 
This is the case with lazy loading, where after image has entered the view and has been loaded, you don't need to observe it anymore. 
This can easily be done with <code>observer.unobserve</code>.

Here for example, when the element enters the view, the <em>in the view</em> message logs and then we stop observing that element so the message won't log again:

<code>const myImgs = document.querySelectorAll('.animate-me');

observer = new IntersectionObserver(entries => {
 entries.forEach(entry => {
   if (entry.intersectionRatio > 0) {
     console.log('in the view');
     observer.unobserve(entry.target);
   } else {
     console.log('out of view');
   }
 });
});

myImgs.forEach(image => {
 observer.observe(image);
});</code>

Once all the observed elements have been unobserved, the observer won't be triggered and nothing will log to the console anymore.

You can also call <code>observer.disconnect()</code> at any time to completely stop observing all the observed elements.

<h3>Configuration</h3>
You can pass-in a configuration object as a second argument when instantiating an <em>IntersectionObserver</em> and the following keys can be configured:
<li>
<em>root</em>: The element to use for intersection checking. 
It defaults to the document, but you may want to change the default for something like an iframe for example.</li><li>
<em>rootMargin</em>: A string with values in the same format as for a CSS margin or padding value. 
For example: <code>'3rem 2rem'</code>. 
This creates a margin of the specified size around the root element, to effectively create an inset or an outset for the intersection point. 
It defaults to <code>'0px'</code>.</li><li>
<em>threshold</em>: An array of number values between 0 and 1. 
The values correspond to the ratio of visibility of the element, with 0 being completely out of view and 1 being fully in the view. 
If you provide multiple values, the intersection callback will be called when each specified threshold value is reached. 
It defaults to <code>[0]</code>.</li>

Here's how you can pass-in some configuration:

<code>const config = {
 rootMargin: '50px 20px 75px 30px',
 threshold: [0, 0.25, 0.75, 1]
};

observer = new IntersectionObserver(entry => {
 // ...
}, config);</code>

<h3>Simple Example</h3>
Below you'll see an example where we have two images elements being observed. 
A <em>facy</em> class gets added or removed depending on if the image is in or out of the viewport.

Here's the code to implement that example:

<code>const images = document.querySelectorAll('.animate-me');

observer = new IntersectionObserver((entries) => {
 entries.forEach(entry => {
   if (entry.intersectionRatio > 0) {
     entry.target.classList.add('fancy');
   } else {
     entry.target.classList.remove('fancy');
   }
 });
});

images.forEach(image => {
 observer.observe(image);
});</code>

And the rest of the magic is done with some simple CSS:

<code>.cowboy.fancy {
 animation: anim1 .7s ease-out;
}
.chef.fancy {
 animation: anim2 .7s ease-out;
}

@keyframes anim1 {
 0% {
   opacity: 0;
   transform: translateX(-30rem) rotate(-45deg);
 }
 100% {
   opacity: 1;
   transform: scale(1) rotate(0deg);
 }
}

@keyframes anim2 {
 0% {
   opacity: 0;
   transform: translateX(30rem) rotate(45deg);
 }
 100% {
   opacity: 1;
   transform: scale(1) rotate(0deg);
 }
}</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/87e1bf9b49ec8a0ae7b343fce4f95fba32eb2cf8/0a3e5/images/cowboy.svg" width="275" height="275" alt="">

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/185c274053d2803726663cad3aac7245f90aa3fe/7df55/images/chef.svg" width="275" height="275" alt="">

 And it's as simple as that! Much simpler than performing manual checks on scroll events. 
Since it's not supported everywhere just yet, you'll probably want to use the <a href="https://github.com/w3c/IntersectionObserver/tree/master/polyfill">polyfill</a> as well for now.


<h2>Copying to Clipboard Using Vanilla JavaScript</h2>

We covered a great little library, <a href="https://alligator.io/js/clipboardjs/">Clipboard.js</a>, that makes it easy to copy text to the clipboard without the need for Flash. 
We also covered <a href="/vuejs/vue-clipboard-copy/">vue-clipboard2</a> to use Clipboard.js with Vue. 
The thing is though, you can now pretty easily implement the feature without the need for a library at all, thanks to the the document's <code>execCommand</code> method. 
Support for it is also really good now.

To make it work, behind the scenes we select the content to be copied, then run the <code>copy</code> command on that text and then finally remove the selection.

<h3>A Working Example</h3>
I recently implemented this for the <a href="/style-guide/#colors">style guide</a>, to allow to easily copy color codes. 
Try it by clicking on the color values to copy to clipboard:

#FAE042<br>rgba(250,224,66,1)

#EFBB35<br>rgba(239,187,53,1)

#DFA612<br>rgba(223,166,18,1)

Can't copy, hit Ctrl+C!

Here's the markup:

<code>&lt;div class="colors">
 &lt;div class="color">
   &lt;div style="background: #FAE042;">&lt;/div>
   &lt;span>#FAE042&lt;/span>&lt;br>
   &lt;span>rgba(250,224,66,1)&lt;/span>
 &lt;/div>

 &lt;div class="color">
   &lt;div style="background: #EFBB35;">&lt;/div>
   &lt;span>#EFBB35&lt;/span>&lt;br>
   &lt;span>rgba(239,187,53,1)&lt;/span>
 &lt;/div>

 &lt;div class="color">
   &lt;div style="background: #DFA612;">&lt;/div>
   &lt;span>#DFA612&lt;/span>&lt;br>
   &lt;span>rgba(223,166,18,1)&lt;/span>
 &lt;/div>
&lt;/div>

&lt;p class="error-msg">
 Can't copy, hit Ctrl+C!
&lt;/p></code>

And here's the simple script to make the copy to clipboard feature possible:

<code>const aioColors = document.querySelectorAll('.color span');

aioColors.forEach(color => {
 color.addEventListener('click', () => {
   const selection = window.getSelection();
   const range = document.createRange();
   range.selectNodeContents(color);
   selection.removeAllRanges();
   selection.addRange(range);

   try {
     document.execCommand('copy');
     selection.removeAllRanges();

     const original = color.textContent;
     color.textContent = 'Copied!';
     color.classList.add('success');

     setTimeout(() => {
       color.textContent = original;
       color.classList.remove('success');
     }, 1200);
   } catch(e) {
     const errorMsg = document.querySelector('.error-msg');
     errorMsg.classList.add('show');

     setTimeout(() => {
       errorMsg.classList.remove('show');
     }, 1200);
   }
 });
});</code>

Note that you'd probably want to transpile this JavaScript code using <a href="https://babeljs.io">Babel</a> because it uses a lot of new features like the <a href="https://alligator.io/js/let-const-variables-es6/">const</a> keyword and <a href="https://alligator.io/js/arrow-functions/">arrow functions</a>.

Oh, and by the way, the layout is made super easy thanks to <a href="/css/css-grid-layout-intro/">CSS grid</a>:

<code>.colors {
 display: grid;
 grid-template-columns: 1fr 1fr 1fr;
 grid-gap: 1rem;
 text-align: center;
 margin-bottom: 2rem;
}

@media (max-width: 600px) {
 .colors {
   grid-template-columns: 1fr 1fr;
 }
}</code>

<h3>Breaking It Down</h3>
We first get all the <em>span</em> elements that contain the color values:

<code>const aioColors = document.querySelectorAll('.color span');</code>

<em>querySelectorAll</em> return a nodeList, which is an array-like object. 
We then iterate over each node and add a <em>click</em> event listener:

<code>aioColors.forEach(color => {
 color.addEventListener('click', () => {
   // ...
 });
});</code>

Iterating over a nodeList using <em>forEach</em> is not yet supported across the board. 
For wider support, you can convert the nodeList to a real array with something like <em>[].forEach.call(aioColors)</em> and then call <strong>forEach</strong>.

<hr>
The magic happens next with the following code:

<code>const selection = window.getSelection();
const range = document.createRange();
range.selectNodeContents(color);
selection.removeAllRanges();
selection.addRange(range);</code>

This gets a selection object, then creates a range where we select the contents our our <em>span</em> element. 
We then make sure that the global selection doesn't contain any range yet, and add our new range to the selection.

<hr>
Next we're ready to try and copy the selection to the clipboard using <code>document.execCommand('copy')</code>:

<code>try {
 document.execCommand('copy');
 selection.removeAllRanges();

 const original = color.textContent;
 color.textContent = 'Copied!';
 color.classList.add('success');

 setTimeout(() => {
   color.textContent = original;
   color.classList.remove('success');
 }, 1200);
} catch(e) {
 // ...
}</code>

We then remove the selection range on our selection object to deselect the text, and setup a success message that disappears after 1.2 seconds.

In case of failure, we keep the selection active, and display a message to tell the user to hit <em>Ctrl + C</em>:

<code>try {
 // ...
} catch(e) {
 const errorMsg = document.querySelector('.error-msg');
 errorMsg.classList.add('show');

 setTimeout(() => {
   errorMsg.classList.remove('show');
 }, 1200);
}</code>

<h3>More Fun With execCommand</h3>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand">execCommand</a> can execute a <strong>cut</strong>, <strong>copy</strong> or a <strong>paste</strong> command, but it can also do a lot more. 
If you have have an element that has its <em>contenteditable</em> attribute set to true, or if your whole document has <em>designMode</em> turned on (<code>document.designMode = 'on'</code>), you can run commands to change the selected text.

Try it out by selecting some text in the paragraph below and the buttons:

Hello Alligator.io!

<button type="button">Bold</button> <button type="button">Delete</button> <button type="button">Color</button> <button type="button">Size</button>


<code>&lt;p contenteditable="true">
 Hello Alligator.io!
&lt;/p></code>

And the code for executing the commands looks like this:

<code>// select our button elements
const boldBtn = document.querySelector('.bold-btn');
const deleteBtn = document.querySelector('.delete-btn');
const colorBtn = document.querySelector('.color-btn');
const sizeBtn = document.querySelector('.size-btn');

// add our event listeners
boldBtn.addEventListener('click', () => {
 document.execCommand('bold');
});

deleteBtn.addEventListener('click', () => {
 document.execCommand('delete');
});

colorBtn.addEventListener('click', () => {
 document.execCommand('styleWithCSS', false, true);
 document.execCommand('foreColor', false, 'hotpink');
});

sizeBtn.addEventListener('click', () => {
 document.execCommand('styleWithCSS', false, true);
 document.execCommand('fontSize', false, '28px');
});</code>

The first argument to <em>execCommand</em> is the name of the command, the second is a boolean to specify if the default user interface should be shown or not, and the third argument is the value for the command.

<h3>Testing For Command Support</h3>
If the browser supports <code>execCommand</code>, you can test for support of specific commands using <code>document.queryCommandSupported</code>:

<code>document.queryCommandSupported('copy'); // true

document.queryCommandSupported('something'); // false</code>

<h2>Array slice vs splice in JavaScript</h2>

Are you finding yourself always looking up the difference between <em>slice()</em> and <em>splice()</em>? Well, here's a quick rundown of the difference.

<strong>TL;DR:</strong> <em>slice</em> is immutable and <em>splice</em> mutates the array.

<h3>Array.prototype.slice</h3>
The <em>slice</em> method returns a new array with a copied slice from the original array. 
The first <strong>optional</strong> argument is the beginning index and the second <strong>optional</strong> argument is the ending index (<strong>non-inclusive</strong>).

Without arguments, you get a copy of the full array:

<code>const myArr = ['', '', '', ''];

const myArrCopy = myArr.slice();

console.log(myArrCopy); // ["", "", "", ""]</code>

<hr>
With one argument, you get a copy from the specified index (zero-based) to the end of the array:

<code>const myArr = ['', '', '', ''];

const myArrCopy = myArr.slice(2);

console.log(myArrCopy); // ["", ""]</code>

The specified beginning index can also be negative, in which case the starting index is calculated from the end:

<code>const myArr = ['', '', '', ''];

const myArrCopy = myArr.slice(-3);

console.log(myArrCopy); // ["", "", ""]</code>

<hr>
And then here's an example with two argument provided:

<code>const myArr = ['', '', '', ''];

const myArrCopy = myArr.slice(-3, 2);

console.log(myArrCopy); // [""]</code>

<h3>Array.prototype.splice</h3>
The <em>splice</em> method changes the content of the array in place and can be used to add or remove items from the array.

When only one argument is provided, all the items after the provided starting index are removed from the array:

<code>let myArr = ['', '', '', ''];

myArr.splice(2);

console.log(myArr); // ["", ""]</code>

The second <strong>optional</strong> argument is for the number of items to remove:

<code>let myArr = ['', '', '', ''];

myArr.splice(2, 1);

console.log(myArr); // ["", "", ""]</code>

An arbitrary amount of additional arguments can be passed-in and will be added to the array:

<code>let myArr = ['', '', '', ''];

myArr.splice(2, 1, '', '');

console.log(myArr); // ["", "", "", "", ""]</code>

<hr>
You can specify <em>0</em> as the number of items to remove to simply add new items at the specified location in the array:

<code>let myArr = ['', '', '', ''];

myArr.splice(2, 0, '', '');

console.log(myArr); // ["", "", "", "", "", ""]</code>

<h2>JavaScript String Replace</h2>

Replacing text in a string is a very common operation, and thank's to the <em>replace</em> method available on the String prototype, it's very easy to do.

The simplest use-case is to provide a string that will act as a substring to match and a string replacement as the second argument:

<code>let myStr = 'My little Alligator ';

console.log(myStr.replace('Alligator', 'gator')); // My little gator </code>

Replace operations can also be chained:

<code>let myStr = 'My little Alligator ';

myStr = myStr
 .replace('Alligator', 'gator')
 .replace('My', 'Your')
 .replace('gator ', 'unicorn ');

console.log(myStr); // Your little unicorn </code>

Given that strings are immutable in JavaScript, <em>replace</em> returns a new string.

<hr>
You can use <em>$&amp;</em> in the replacement string to include the match:

<code>let myStr = 'My little Alligator ';

console.log(myStr.replace('gator', '-$&amp;-$&amp;'));
// My little Alli-gator-gator </code>
<li>Use <em>$`</em> to insert the part of the string that's before the match.</li><li>Use <em>$'</em> to insert the part of the string that's after the match.</li><li>Use <em>$n</em>, to insert the nth match.</li>

<h3>RegExp Match</h3>
Matching an exact substring is good, but often we find ourselves needing to match a pattern instead. 
It can easily be done by using a regular expression as the first argument:

<code>let myStr = 'Does my text make sense?';

myStr = myStr.replace(/e/g, 'a');

console.log(myStr); // Doas my taxt maka sansa?</code>

In the above example, we used the global (<em>g</em>) flag on the regular expression literal to match all occurrences. 
The <em>i</em> flag is also often useful for a case-insensitive match.

<hr>
Here's an example where we iterate over an array of strings and replace fractions followed by a unit (<em>tsp</em> or <em>tbsp</em>):

<code>let ingredients = ['1/4 tsp honey', '1/2 tbsp coconut oil', '1/8 tsp cocoa'];

ingredients = ingredients.map(ingredient => {
 return ingredient.replace(/(\d\/\d) (tsp|tbsp)/, 'Lots of');
});

console.log(ingredients);
// ["Lots of honey", "Lots of coconut oil", "Lots of cocoa"]</code>

<h3>Function as 2nd Argument</h3>
The second argument can also be a function, known as the replacer function. 
The return value of the function will be the value used for replacement. 
Here's a simple example:

<code>let myStr = '49.5 Red Balloons';

myStr = myStr.replace(/\d+\.\d+/, (match) => {
 return +match * 2; // 49.5 * 2
});

console.log(myStr); // 99 Red Balloons</code>

The first argument to the replacer function is the full match itself. 
You can also use additional arguments (often called <em>p1</em>, <em>p2</em>,…) to get the nth captured group from the match. 
This final example is a little silly, but it illustrates the functionality:

<code>let myStr = 'My friendly Alligator';

myStr = myStr.replace(/(\w+) (\w+) (\w+)/, function (match, p1, p2, p3) {
 return `${p1}/${p2}/${p3} `;
});

console.log(myStr); // My/friendly/Alligator </code>

<h2>Object.values and Object.entries in JavaScript</h2>

With ES2017 (ES8), the Object constructor gets two new useful methods: <em>Object.values</em> and <em>Object.entries</em>. 
Let's go over their use really quickly.

<h3>Object.values</h3>
<em>Object.values</em> takes an object and returns an array with the values, in the same order that a <a href="https://alligator.io/js/for-of-for-in-loops/">for…in</a> loop would give us. 
For example:

<code>const myObj = {
 piggy: '',
 birdy: '',
 bunny: ''
};

const myValues = Object.values(myObj); // ["", "", ""]</code>

<strong>Object.values</strong> doesn't follow the prototype chain and only iterates over the value that are directly on the provided object. 
It won't return any non-enumerable values either, as can be seen in this example:

<code>const myObj = {
 piggy: '',
 birdy: '',
 bunny: ''
};

Object.defineProperty(myObj, 'koala', {
 value: '',
 writable: true,
 configurable: true,
 enumerable: true
});

let myValues = Object.values(myObj);  // ["", "", "", ""]

Object.defineProperty(myObj, 'koala', {
 value: '',
 writable: true,
 configurable: true,
 enumerable: false
});

myValues = Object.values(myObj); // ["", "", ""]</code>

<h3>Object.entries</h3>
Very similar to the previous method, <em>Object.entries</em> returns an array with arrays of key-value pairs:

<code>const moreAnimals = {
 camel: '',
 boar: '',
 turkey: ''
};

const entries = Object.entries(moreAnimals);
// [['camel',''],['boar',''],['turkey','']]</code>

Since the new <em>map</em> object type <a href="https://alligator.io/js/maps-introduction/#initializing-maps-from-arrays">can be initialized</a> using an array of the shape that <strong>Object.entries</strong> gives us, it's now very easy to create a map from an object:

<code>const moreAnimals = {
 camel: '',
 boar: '',
 turkey: ''
};

const animalsMap = new Map(Object.entries(moreAnimals));

console.log(animalsMap.size); // 3
console.log(animalsMap.has('turkey')); // true
console.log(animalsMap.get('camel')); // ''</code>

<h2>Adding, Removing &amp; Toggling Classes With classList in JavaScript</h2>

It's much easier than it used to be to modify classes on an element, thanks in large part to the <em>classList</em> object.

Say we have an element like this:

<code>&lt;div class="cool new shades">
 
&lt;/div></code>

Let's play around with the classes on that element. 
First, let's grab a reference to the element in a <code>shadesEl</code> variable:

<code>let shadesEl = document.querySelector('.cool');

console.log(shadesEl.classList);
// ["cool", "new", "shades", value: "cool new shades"]

console.log(shadesEl.classList[1]); // new</code>

This works, but we should instead call one of the following methods on the <em>classList</em> object:

<h3>add</h3>
Add one or more classes to the element:

<code>shadesEl.classList.add('make', 'me', 'look', 'rad');</code>

Our element now:

<code>&lt;div class="cool new shades make me look rad">
 
&lt;/div></code>

<h3>contains</h3>
<em>Contains</em> returns a boolean indicating if the class is present:

<code>console.log(shadesEl.classList.contains('look')); // true</code>

<h3>item</h3>
Get the class that's at the provided index:

<code>console.log(shadesEl.classList.item(3));  // make</code>

<h3>remove</h3>
Remove one of more classes:

<code>shadesEl.classList.remove('cool', 'make', 'me');</code>

<code>&lt;div class="new shades look rad">
 
&lt;/div></code>

JavaScript won't complain if you try to remove a class that doesn't exist.

<h3>toggle</h3>
Instead of doing a whole dance like this if you want to toggle a class on or off:

<code>// Tedious toggle
if (shadesEl.classList.contains('rad')) {
 shadesEl.classList.remove('rad');
} else {
 shadesEl.classList.add('rad');
}</code>

…you can simply use <code>classList.toggle</code> instead. 
Say something like this on a button click:

<code>coolButton.addEventListener('click', () => {
 shadesEl.classList.toggle('cool');
});</code>

<code>classList.toggle</code> will return <em>true</em> if the class was added and <em>false</em> if it was removed:

<code>let a = shadesEl.classList.toggle('cool');

console.log(a); // true --> class was added</code>

<code>classList.toggle</code> optionally takes a second argument that should evaluate to a boolean. 
This will force toggle to either add the class or remove it depending on the how the second argument evaluates:

<code>let someCondition;

let b = shadesEl.classList.toggle('cool', !!someCondition);
console.log(b);
// false, `someCondition` is undefined and evaluates to false, class is removed

someCondition = 'I wear my sunglasses at night';

let c = shadesEl.classList.toggle('cool', !!someCondition);
console.log(c);
// true, `someCondition` evaluates to true, class is added.</code>

Using <em>!!</em> in front of an expression coerces the value to a boolean.

 And that's it! It doesn't get any easier than this.

<h2>Introduction to Maps in JavaScript</h2>

We introduced <a href="https://alligator.io/js/sets-introduction/">sets</a> in JavaScript, so it's only logical that we follow with a discussion on maps, which was also introduced with ES2015. 
Maps are a new object type that allow to store collections of key-value pairs.

Unlike with objects, map keys can be of any type, even objects or functions. 
It's also easy to get the size of a map, while it's not as straightforward for objects. 
On top of that, with maps we can iterate in the order in which the values were added, contrary to objects where there's no guarantee about the order.

Here's a simple example of a map demonstrating a few of the available methods and properties such as <em>set</em>, <em>get</em>, <em>size</em>, <em>has</em>, <em>delete</em> and <em>clear</em>:

<code>let things = new Map();

const myFunc = () => '';

things.set('', 'Car');
things.set('', 'House');
things.set('', 'Airplane');
things.set(myFunc, ' Key is a function!');

things.size; // 4

things.has(''); // true

things.has(myFunc) // true
things.has(() => ''); // false, not the same reference
things.get(myFunc); // ' Key is a function!'

things.delete('');
things.has(''); // false

things.clear();
things.size; // 0

// setting key-value pairs is chainable
things.set('', 'Wrench')
     .set('', 'Guitar')
     .set('', 'Joystick');

const myMap = new Map();

// Even another map can be a key
things.set(myMap, 'Oh gosh!');
things.size; // 4
things.get(myMap); // 'Oh gosh!'</code>

<h3>Initializing Maps from Arrays</h3>
You can initialize a map from an array that contains arrays of two values:

<code>const funArray = [
 ['', 'Champagne'],
 ['', 'Lollipop'],
 ['', 'Confetti'],
];

let funMap = new Map(funArray);
funMap.get(''); // Champagne</code>

<h3>Iterating Over Maps</h3>
It's easy to iterate over maps using <a href="https://alligator.io/js/for-of-for-in-loops/">for…of</a> and <a href="https://alligator.io/js/object-array-destructuring-es2015/">array destructuring</a>:

<code>let activities = new Map();

activities.set(1, '');
activities.set(2, '');
activities.set(3, '');
activities.set(4, '');

for (let [nb, activity] of activities) {
 console.log(`Activity ${nb} is ${activity}`);
}

// Activity 1 is 
// Activity 2 is 
// Activity 3 is 
// Activity 4 is </code>

…And you can also use <em>forEach</em> to iterate over a map in the same manner. 
Note however how the first argument to the forEach callback function is the <strong>value</strong> and the second is the <strong>key</strong>. 
The following will have the same result as the <strong>for…of</strong> example:

<code>activities.forEach((value, key) => {
 console.log(`Activity ${key} is ${value}`);
});</code>

<h2>for...of vs for...in Loops in JavaScript</h2>

Traditional <em>for</em> loops are so last year! <em>for..of</em> and <em>for…in</em> loops give us a very clean and concise syntax to iterate over all kinds of iterables and enumerables like strings, arrays and object literals. 
If you're anything like me though, you always forget which one to use. 
It is <strong>for…in</strong> or <strong>for…of</strong>? Darn!

We'll here's a quick reminder that you can reference:

<h3>for…of</h3>
Use <em>for…of</em> to iterate over the values in an <strong>iterable</strong>, like an array for example:

<code>let animals = ['', '', '', ''];
let names = ['Gertrude', 'Henry', 'Melvin', 'Billy Bob'];

for (let animal of animals) {
 // Random name for our animal
 let nameIdx = Math.floor(Math.random() * names.length);

 console.log(`${names[nameIdx]} the ${animal}`);
}

// Henry the 
// Melvin the 
// Henry the 
// Billy Bob the </code>

Strings are also an iterable type, so you can use <strong>for…of</strong> on strings:

<code>let str = 'abcde';

for (let char of str) {
 console.log(char.toUpperCase().repeat(3));
}

// AAA
// BBB
// ...</code>

You can also iterate over <em>maps</em>, <em>sets</em>, <em>generators</em>, <em>DOM node collections</em> and the <em>arguments object</em> available inside a functions.

<h3>for…in</h3>
Use <em>for…in</em> to iterate over the properties of an object (the object keys):

<code>let oldCar = {
 make: 'Toyota',
 model: 'Tercel',
 year: '1996'
};

for (let key in oldCar) {
 console.log(`${key} --> ${oldCar[key]}`);
}

// make --> Toyota
// model --> Tercel</code>

You can also use <strong>for…in</strong> to iterate over the index values of an iterable like an array or a string:

<code>let str = 'Turn the page';

for (let index in str) {
 console.log(`Index of ${str[index]}: ${index}`);
}

// Index of T: 0
// Index of u: 1</code>

<h2>Speed Up Scroll Events with Passive Event Listeners</h2>

Okay, let me get this out of the way real quick. 
I <strong>hate</strong> websites that attach <code>wheel</code> (or <code>touchstart</code> and <code>touchmove</code>) events to a page. 
Utterly hate them. 
The main reason is the horrid resulting performance, especially on mobile. 
You see, the browser has to wait to redraw the page until the event listener finishes execution, as the event is able to be canceled. 
If your event runs on every single scroll, then scrolling the page gets incredibly janky, especially if you don't debounce the events. 
Thankfully, there is now a solution: <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Improving_scrolling_performance_with_passive_listeners">Passive Event Listeners</a>.

<em>Passive Event Listeners</em> allow you to attach un-cancelable handlers to events, letting browsers optimize around your event listeners. 
The browser can then, for example, keep scrolling at native speed without waiting for your event handlers to finish executing.

While they are a relatively new addition to the spec, they're already supported by <a href="https://caniuse.com/#feat=passive-event-listener">most of the big players</a>. 
(Everybody except IE, Edge, and Opera Mini, basically.)

Additionally, their usage is such that they don't really break existing behavior. 
If you need to support the other browsers, you can use this <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/EventListenerOptions.polyfill.js">polyfill</a>.

<h3>Usage</h3>
Using passive events, unfortunately, is pretty complicated.

Say your original code is something like this:

<code>// Really, if you're using wheel, you should instead be using the 'scroll' event, as it's passive by default.
document.addEventListener('wheel', (evt) => {
 // ... 
do stuff with evt
}, true)</code>

You'll need to replace it with this:

<code>document.addEventListener('wheel', (evt) => {
 // ... 
do stuff with evt
}, {
 capture: true,
 passive: true
})</code>

Yeah. 
I know. 
Almost impossible to wrap your head around. 


Let me try to explain.

So, often when registering scroll events, you add the last parameter, <code>true</code>, to indicate that your event should run in the capturing phase. 
(ie. 
top-down instead of bottom-up)

One of the new features enabling passive events is the <em>EventListenerOptions</em> spec. 
Sounds scary, but it really just optionally replaces that capture boolean with an object with a few properties. 
In this case, we can set <code>capture</code> to <code>true</code> to get the same result as the first example, and then set <code>passive</code> to <code>true</code> to make the event passive.

To improve performance further, make sure you're throttling or debouncing your events. 
:)

<h3>Uses</h3>
The events with the greatest perceived performance penalty (say that five times fast) on mobile are <em>scroll</em>, <em>wheel</em>, <em>touchstart</em>, and <em>touchmove</em>. 
Scroll already is passive by default, so that takes one event out of the equation. 
As of Chrome 55, <em>touchstart</em> and <em>touchend</em> are passive as well.

So, if you're handling any of those four events on mobile, it couldn't hurt to throw in that tiny polyfill and add <code>{ passive: true }</code> to those events. 
99% of the time you won't need to cancel those events anyway, and using <code>{ passive: true }</code> can add a massive performance boost. 
So why not?

<h2>Default Parameters in JavaScript with ES6 / ES2015</h2>

You can now define default values for your function parameters in JavaScript. 
The default value will be used when an argument is missing or it evaluates to undefined.

It's very easy to understand with a simple example. 
Notice how the value <em>3</em> is used when <em>y</em> is not provided or when <em>undefined</em> is provided:

<code>function add(x, y = 3) {
 console.log(x + y);
}

add(3, 9); // 12
add(3) // 6
add(12, undefined) // 15
add(undefined, 8); // NaN, x doesn't have a default value</code>

<hr>
Default parameters can be really useful to ensure you have at least an empty array or object literal available when performing operations. 
Here's an example with a default parameter:

<code>function addToGuestList(guests, list = []) {
 console.log([...guests, ...list]);
}

addToGuestList(['Bob', 'Andy']); // ['Bob', 'Andy']
addToGuestList(['Bob', 'Andy'], ['Roger']); // ['Bob', 'Andy', Roger]</code>

And the same example without:

<code>function addToGuestList(guests, list) {
 console.log([...guests, ...list]);
}

addToGuestList(['Bob', 'Andy']); // ['Bob', 'Andy', undefined]
addToGuestList(['Bob', 'Andy'], ['Roger']); // ['Bob', 'Andy', Roger]</code>

<h2>padStart and padEnd String Methods in JavaScript</h2>

<em>padStart</em> and <em>padEnd</em> are two new methods available on JavaScript strings. 
As their name implies, they allow for formatting a string by adding padding characters at the start or the end. 
Keep in mind that these two methods are new and browser support is still very limited.

Both methods work in the same way, with the only difference being that with <em>padStart</em> the padding is added at the start of the string and with <em>padEnd</em> the padding added at then end.

They take a <em>targetLength</em> argument for the desired length or the string an optional <em>padString</em> argument that defaults to a space when not provided. 
The <strong>padString</strong> will be repeated if needed to fill the desired <strong>targetLength</strong>.

Here are a few examples:

<code>"Dog!".padStart(10); // "      Dog!"
"Dog!".padEnd(14, ' Woof'); // "Dog! Woof Woof"

"A longer string here".padEnd(10); // "A longer string here"</code>

<strong>padStart</strong> and <strong>padEnd</strong> come-in handy for formatting numbers and formatting for console outputting:

<code>let values = ['17.99', '200', '3400.57', '7.97', '567'];

let formattedValues = values.map(value => {
 let nbr = parseFloat(value).toFixed(2);

 return ('$' + nbr.toString()).padStart(9);  
});

console.log(formattedValues.join('\n'));

//    $17.99
//   $200.00
//  $3400.57
//     $7.97
//   $567.00</code>


<h2>Tagged Template Literals in JavaScript (ES6 / ES2015)</h2>

We briefly covered <a href="https://alligator.io/js/template-literals-es6/">template literals</a>, but they have an extra feature that we didn't discuss: tags. 
You can tag your template literals with a function that will be called and can act as a kind of preprocessor on the content of the template literal.

Here's a typical example of a template literal:

<code>let name = 'Benedict';
let occupation = 'being awesome';

let sentence = `Hi! I'm ${ name } and I'm busy at ${ occupation }.`;

console.log(sentence);
// Hi! I'm Benedict and I'm busy at being awesome.</code>

Now let's tag the literal with a <em>useless</em> function:

<code>function useless(strings, ...values) {
 return 'I render everything useless.';
}

let name = 'Benedict';
let occupation = 'being awesome';

let sentence = useless`Hi! I'm ${ name } and I'm busy at ${ occupation }.`;

console.log(sentence);
// I render everything useless.</code>

Obviously the above doesn't have any use, but where it starts to have more power is when we make use of the <em>strings</em> and <em>values</em> to construct the template literal with some processing.

With our current example:
<li>
<em>strings</em> is an array with 3 values: <em>Hi! I'm </em>, <em> and I'm busy at </em> and <em>.</em>
</li><li>
<em>values</em> is an array with the 2 interpolated values for the <code>name</code> and <code>occupation</code> variables. 
These values are passed as extra parameters to the tagged function, but here we make use of <a href="https://alligator.io/js/rest-parameters-es6/">rest parameters</a> to gather all the extra parameters into a <strong>values</strong> array.</li>

There always is one more <strong>strings</strong> value then there are interpolated values. 
With our example, if there was not period at the end of then sentence, an empty string would be the last value for the <strong>strings</strong> array, to satisfy the fact that there needs to be one more string value.

Armed with that knowledge, we can therefore create a tag function for the string literal that actually does something:

<code>function uppercase(strings, ...values) {
 let newStr = '';

 for (let i = 0; i &lt; strings.length; i++) {
   if (i > 0) {
     newStr += values[i-1].toUpperCase();
   }
   newStr += strings[i];
 }

 return newStr;
}

let name = 'Benedict';
let occupation = 'being awesome';

let sentence = uppercase`Hi! I'm ${ name } and I'm busy at ${ occupation }.`;

console.log(sentence);
// Hi! I'm BENEDICT and I'm busy at BEING AWESOME.</code>

<h2>Introduction to localStorage and sessionStorage</h2>

<em>localStorage</em> and <em>sessionStorage</em>, part of the web storage API, are two great tools to save key/value pairs locally. 
If you click the save button at the top of this post, localStorage is what's used to store your saved posts.

Both localStorage and sessionStorage offer advantages compared to using cookies:
<li>The data is saved locally only and can't be read by the server, which eliminates the security issue that cookies present.</li><li>It allows for much more data to be saved (<strong>10Mb</strong> for most browsers).</li><li>It's simpler to use and the syntax is very straightforward.</li>

It's also supported in all modern browsers, so you can use it today without an issue. 
Obviously, since the data can't be read on the server, cookies still have a use, especially when it comes to authentication.

<h3>localStorage vs sessionStorage</h3>
localStorage and sessionStorage accomplish the exact same thing and have the same API, but with sessionStorage the data is persisted only until the window or tab is closed, while with localStorage the data is persisted until the user manually clears the browser cache or until your web app clears the data. 
The examples in this post are for localStorage, but the same syntax works for sessionStorage.

<h3>Creating Entries</h3>
Create key/value pair entries with <em>localStorage.setItem</em>, providing a key and a value:

<code>let key = 'Item 1';
localStorage.setItem(key, 'Value');</code>

<h3>Reading Entries</h3>
Read entries with <em>localStorage.getItem</em>:

<code>let myItem = localStorage.getItem(key);</code>

<h3>Updating Entries</h3>
Update an entry just as you would create a new one with <em>setItem</em>, but with a key that already exists:

<code>localStorage.setItem(key, 'New Value');</code>

<h3>Deleting Entries</h3>
Delete an entry with the <em>removeItem</em> method:

<code>localStorage.removeItem(key);</code>

<h3>Clearing Everything</h3>
Here's how to clear everything that's stored in localStorage:

<code>localStorage.clear();</code>

<h3>Storing Json Objects</h3>
Only strings can be stored with localStorage or sessionStorage, but you can use <em>JSON.stringify</em> to store more complex objects and <em>JSON.parse</em> to read them:

<code>// Create item:
let myObj = { name: 'Skip', breed: 'Labrador' };
localStorage.setItem(key, JSON.stringify(myObj));

// Read item:
let item = JSON.parse(localStorage.getItem(key));</code>

<h3>Checking for Items</h3>
Here's how you can test for the presence of items in the loclaStorage:

<code>if (localStorage.length > 0) {
 // We have items
} else {
 // No items
}</code>

<h3>Checking for Support</h3>
Test for localStorage support by checking if it's available on the <em>window</em> object:

<code>if (window.localStorage) {
 // localStorage supported
}</code>

<h3>Iterating Over Items</h3>
localStorage or sessionStorage don't have a <em>forEach</em> method, but you can iterate over the items with a good old <em>for</em> loop:

<code>for (let i = 0; i &lt; localStorage.length; i++){
 let key = localStorage.key(i);
 let value = localStorage.getItem(key);
 console.log(key, value);
}</code>


<h2>Lazy Loading Scripts</h2>

The scripts needed for the search functionality of this website are only loaded when the search bar is focused. 
This way, they're only ever loaded for people who decide to use the search function, and bandwidth as well as page weight can be drastically reduced. 
Only a small fraction of visitors will use the search after all, so why incur the cost each time?

To accomplish this simple lazy load technique, let's first define a function that we'll call <code>loadScript</code>:

<code>function loadScript(url) {
 let isLoaded = document.querySelectorAll('.search-script');
 if(isLoaded.length > 0) {
   return;
 }

 let myScript = document.createElement("script");
 myScript.src = url;
 myScript.className = 'search-script';
 document.body.appendChild(myScript);
}</code>

The function first checks if the script has already been loaded, in which case it'll just return instead of trying to load it multiple times. 
We then create a script element with <code>document.createElement</code>, give it the passed-in url as the value to it's <em>src</em> attribute, give it the class name for our check to work, and then append this new <em>script</em> element to the body element.

<hr>
The last step is to simply setup an event listener on the search input and call our <code>loadScript</code> function with the url to our script:

<code>var searchInput = document.querySelector('.algolia__input');
searchInput.addEventListener('focus', function(e) {
 loadScript('/path/to/search-script.js');
});</code>

Obviously this mean that in theory there's a short delay between focusing in the search box and the script being available to use. 
In most cases it shouldn't be a problem, and in this case the real time search picks up as soon as the script is fully loaded.

<h2>Service Workers: Using SW-Toolbox to Serve an Offline Page</h2>

If you're using a browser with Service Worker support, you can turn off your internet connection and try to visit a new page from this site. 
Instead of the default browser offline page, you'll get a friendlier custom page.

Thanks to <a href="https://jeffy.info/">Jeff Posnick</a> and his solution to this <a href="https://github.com/GoogleChrome/sw-toolbox/issues/80">Github issue</a>. 
Here's how to make it work with an example of how your Service Worker file could be setup:

Service Worker: sw.js

<code>self.importScripts('assets/sw-toolbox/sw-toolbox.js');

self.toolbox.precache([
 '/offline',
 '/images/you-are-offline.svg',
 // ...
]);

self.toolbox.router.get('/(.*)', function(req, vals, opts) {
 return toolbox.networkFirst(req, vals, opts)
   .catch(function(error) {
     if (req.method === 'GET' &amp;&amp; req.headers.get('accept').includes('text/html')) {
       return toolbox.cacheOnly(new Request('/offline'), vals, opts);
     }
     throw error;
   });
});</code>

We first import SW-Toolbox, then add files and assets that should be precached. 
In there we make sure to precache our offline page and any assets that would be needed by that page.

We then call SW-Toolbox's <em>toolbox.router.get</em> with a callback to <em>toolbox.networkFirst</em>, but with a twist. 
If both the network and the cache fail to provide a response, the promise will fail. 
We can then use <em>catch</em> on the promise to request our offline page.

You could also have some of your most popular pages precached and link to them from your custom offline page. 
This way your visitors can still get some value while they're offline. 
That's a strategy that <a href="https://www.smashingmagazine.com/offline/">Smashing Magazine</a> has been using for example.

<h3>Boom, a nice offline page </h3>
<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a330bfe632f6ebcec44e9f94fab44f0179c0b233/a07be/images/js/pwa/offline-screen.jpg" width="425" height="504" alt="The Alligator.io offline page">


<h2>A Page Progress Bar with JavaScript and CSS Variables</h2>

Here's how to accomplish the scroll progress bar that you can see as you scroll though pages of this site. 
It's a nice way to convey a progress indicator for readers to know how far along they are in a post.

It uses the power of <a href="/css/css-variables/">CSS Variables</a>, and the solution is adapted from part of this <a href="https://www.youtube.com/watch?v=2an6-WVPuJU">excellent talk</a> by Lea Verou.

First, add the following markup right after the opening body tag:

<code>&lt;div>&lt;/div></code>

Then style this <em>.progress</em> element with something like this:

<code>.progress {
 background: linear-gradient(to right, #F9EC31 var(--scroll), transparent 0);
 background-repeat: no-repeat;
 position: fixed;
 width: 100%;
 height: 4px;
 z-index: 1;
}</code>

Notice how in the <a href="/css/linear-gradients/">linear gradient</a> we're referring to a CSS variable named <code>--scroll</code>, which will be given a value on scroll.

That means that all that's left to do is listen for the document's <em>scroll</em> event and set the value of the <code>--scroll</code> custom property with the scroll percentage. 
We use <em>element.style.setProperty</em> for that. 
The <em>.progress</em> element will get an inline value for <code>--scroll</code> once it gets set.

Thanks to <a href="http://stackoverflow.com/users/487719/phil-ricketts">Phil Ricketts</a> and his solution to this <a href="http://stackoverflow.com/questions/2387136/cross-browser-method-to-determine-vertical-scroll-percentage-in-javascript">StackOverflow question</a> for an accurate way to calculate the document scroll percentage:

<code>var h = document.documentElement,
 b = document.body,
 st = 'scrollTop',
 sh = 'scrollHeight',
 progress = document.querySelector('.progress'),
 scroll;

document.addEventListener('scroll', function() {
 scroll = (h[st]||b[st]) / ((h[sh]||b[sh]) - h.clientHeight) * 100;
 progress.style.setProperty('--scroll', scroll + '%');
});</code>

 Note that IE or Edge don't support CSS custom properties at the moment. 
Support is coming however, and it the mean time the feature gracefully degrades.

<h2>Object and Array Destructuring in JavaScript with ES6</h2>

With ES6 / ES2015, you can now extract data from arrays and objects with more ease and less syntactic clutter. 
See how it's done with the following snippet examples:

<h3>Array Destructuring</h3>
Automatically create variables who's values correspond to items in an array:

<code>const names = ['Bob', 'Fred', 'Benedict'];

const [cat, dog, alligator] = names;

console.log(cat); // Bob
console.log(dog); // Fred
console.log(alligator); // Benedict</code>

You can also skip items by using comas without any names for the variable names:

<code>const names = ['Bob', 'Fred', 'Benedict'];

const [cat, , alligator] = names;

console.log(cat); // Bob
console.log(alligator); // Benedict</code>

And you can destructure part of the array, then put the rest in a new array:

<code>const names = ['Bob', 'Fred', 'Benedict'];

const [cat, ...rest] = names;

console.log(cat); // Bob
console.log(rest); // ["Fred", "Benedict"]</code>

<h3>Object Destructuring</h3>
Object destructuring is a bit different because keys are not necessarily in a specific order, so the new variables need to have matching names with the object's keys:

<code>const names = {cat: 'Bob', dog: 'Fred', alligator: 'Benedict'};

const {cat, dog, alligator} = names;

console.log(cat); // Bob
console.log(dog); // Fred
console.log(alligator); // Benedict</code>

There's a way around matching names however, here's how to give new names to the variables:

<code>const names = {cat: 'Bob', dog: 'Fred', alligator: 'Benedict'};

const {cat: newCat, dog: newDog, alligator: newAlligator} = names;

console.log(newCat); // Bob
console.log(newDog); // Fred
console.log(newAlligator); // Benedict</code>

<h2>ES6 Modules and How to Use Import and Export in JavaScript</h2>

With ES2015 (ES6), with get built-in support for modules in JavaScript. 
Like with CommonJS, each file is its own module. 
To make objects, functions, classes or variables available to the outside world it's as simple as exporting them and then importing them where needed in other files. 
Angular 2 makes heavy use of ES6 modules, so the syntax will be very familiar to those who've worked in Angular. 
The syntax is pretty straightforward:

<h3>Exporting</h3>
You can export members one by one. 
What's not exported won't be available directly outside the module:

<code>export const myNumbers = [1, 2, 3, 4];
const animals = ['Panda', 'Bear', 'Eagle']; // Not available directly outside the module

export function myLogger() {
 console.log(myNumbers, animals);
}

export class Alligator {
  constructor() {
    // ...
  }
}</code>

Or you can export desired members in a single statement at the end of the module:

<code>export { myNumbers, myLogger, Alligator };</code>

<h3>Exporting with alias</h3>
You can also give an aliases to exported members with the <em>as</em> keyword:

<code>export { myNumbers, myLogger as Logger, Alligator }</code>

<h3>Default export</h3>
You can define a default export with the <em>default</em> keyword:

<code>export const myNumbers = [1, 2, 3, 4];
const animals = ['Panda', 'Bear', 'Eagle'];

export default function myLogger() {
 console.log(myNumbers, pets);
}

export class Alligator {
 constructor() {
   // ...
 }
}</code>

<h3>Importing</h3>
Importing is also very straightforward, with the <em>import</em> keyword, members to be imported in curly brackets and then the location of the module relative to the current file:

<code>import { myLogger, Alligator } from 'app.js';</code>

<h3>Importing with alias</h3>
You can also alias members at import time:

<code>import myLogger as Logger from 'app.js';</code>

<h3>Importing all exported members</h3>
You can import everything that's imported by a module like this:

<code>import * as Utils from 'app.js';</code>

This allows you access to members with the dot notation:

<code>Utils.myLogger();</code>

<h3>Importing a module with a default member</h3>
You import the default member by giving it a name of your choice. 
In the following example <em>Logger</em> is the name given to the imported default member:

<code>import Logger from 'app.js';</code>

And here's how you would import non-default members on top of the default one:

<code>import Logger, { Alligator, myNumbers } from 'app.js';</code>

<h2>A Simple Page Fade-In With JavaScript</h2>

Page transition effects can get rather complicated to pull-off, but the following gives us a nice little fade-in effect with minimal complexity. 
The body element gets a <em>fade</em> class upon rendering, and that class is then removed right away when the DOM content is loaded. 
CSS takes care of the rest.

It adds a little visual magic , and it can also detract the eye from something like a FOUT (flash of unstyled text). 
It's even resilient to JavaScript issues and if the scripts don't load the <em>fade</em> class never gets applied and the effect is just never shown. 
Here's how to implement it.

Add the <em>fade</em> class to the body element right right after the opening body tag with this one liner:

<code>&lt;script>
 document.body.className = 'fade';
&lt;/script></code>

Or, if your body tag already has other classes that you can to keep, you can add the class with <em>classList.add()</em>:

<code>&lt;script>
 document.body.classList.add('fade');
&lt;/script></code>

<hr>
Then, near the closing <em>body</em> tag, but before any large script files, remove the class with this:

<code>&lt;script>
 document.addEventListener("DOMContentLoaded", function(e) {
   document.body.className = '';
 });
&lt;/script></code>

And again, if your body tag has other classes that should be kept, use <em>classList.remove()</em>:

<code>&lt;script>
 document.addEventListener("DOMContentLoaded", function(e) {
   document.body.classList.remove('fade');
 });
&lt;/script></code>

<hr>
And in your CSS, include something like the following to create a .7 second fade-in:

<code>body {
 opacity: 1;
 transition: 0.7s opacity;
}

body.fade {
   opacity: 0;
   transition: none;
}</code>

<h2>Accessing Elements in JavaScript with querySelector and querySelectorAll</h2>

It used to be not so trivial to access elements in pure JavaScript using the DOM. 
This to two new methods, <em>querySelector</em> &amp; <em>querySelectorAll</em>, that are now supported in all modern browsers, this task is now much easier.

<h3>querySelector</h3>
<em>querySelector</em> returns the first element that match the provided CSS query. 
Use it on the full document:

<code>let myElem = document.querySelector('#myElem');</code>

Or use it on an element to get an element within the element:

<code>let elem = document.querySelector('p');
let myElem = elem.querySelector('#myElem');</code>

<h3>querySelectorAll</h3>
<em>querySelector</em> returns all the elements that match the provided selector:

<code>let elems = document.querySelectorAll('p');</code>

And here you can do the same and narrow your selection. 
Let's select <em>span</em> elements that are in the first <em>p</em> element:

<code>let firstP = document.querySelector('p');
let spanElems = firstP.querySelectorAll('span');</code>


<h2>Pop, Push, Shift and Unshift Array Methods in JavaScript</h2>

JavaScript gives us four methods to add or remove items from the beginning or end of arrays:

<h3>
<strong>pop()</strong>: Remove an item from the end of an array</h3>
<code>let cats = ['Bob', 'Willy', 'Mini'];

cats.pop(); // ['Bob', 'Willy']</code>

<em>pop()</em> returns the removed item.

<h3>
<strong>push()</strong>: Add items to the end of an array</h3>
<code>let cats = ['Bob'];

cats.push('Willy'); // ['Bob', 'Willy']

cats.push('Puff', 'George'); // ['Bob', 'Willy', 'Puff', 'George']</code>

<em>push()</em> returns the new array length.

<h3>
<strong>shift()</strong>: Remove an item from the beginning of an array</h3>
<code>let cats = ['Bob', 'Willy', 'Mini'];

cats.shift(); // ['Willy', 'Mini']</code>

<em>shift()</em> returns the removed item.

<h3>
<strong>unshift()</strong>: Add items to the beginning of an array</h3>
<code>let cats = ['Bob'];

cats.unshift('Willy'); // ['Willy', 'Bob']

cats.unshift('Puff', 'George'); // ['Puff', 'George', 'Willy', 'Bob']</code>

<em>unshift()</em> returns the new array length.

<h2>A Quick Introduction to the Yarn Package Manager</h2>

<a href="https://yarnpkg.com/">Yarn</a> is new and Open Source JavaScript package manager developed by Facebook. 
Yarn is fully compatible with the <em>npm</em> registry and can work alongside npm, but it's aim it to be a safer, more secure and more reliable alternative.

You can replace your whole npm workflow with Yarn for new or current projects with very minimal effort. 
Dependencies in Yarn are kept in a <em>yarn.lock</em> file that should be checked-in your source control, but the file itself is for Yarn only and shouldn't be edited. 
Here just enough to get your started with Yarn.

<h3>1. 
Installing</h3>
There are a few ways to install Yarn. 
You can, ironically enough, install it through <em>npm</em>:

<code>$ npm install -g yarn</code>

If you don't have npm installed, you can also install with a simple bash script:

<code>$ curl -o- -L https://yarnpkg.com/install.sh | bash</code>

On Windows, you can get an <a href="https://yarnpkg.com/en/docs/install#windows-tab">installer file here</a>.

<h3>2. 
Testing your install</h3>
Run this to see if Yarn was properly installed or to see if you have the latest version:

<code>$ yarn --version</code>

<h3>3. 
Init a project</h3>
To initialize a new project, run <em>yarn init</em>:

<code>$ yarn init</code>

<h3>4. 
Installing all dependencies</h3>
Here's how to install all the dependencies from your package.json file (the equivalent of <em>npm install</em>):

<code>$ yarn</code>

<h3>5. 
Dependency management</h3>
Let's use <em>lodash</em> for most of our examples:

<h3>Adding a project dependency</h3>
Use the <em>add</em> command to add a dependency to your project:

<code>$ yarn add lodash</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f8b971c0d9acfb10a4562c90a370de7815f0fe3a/97d4c/images/js/yarn.jpg" width="600" height="352" alt="The Yarn package manager">

Use the <code>--dev</code> (or its alias <code>-D</code>) flag to add a package as a dev dependency:

<code>$ yarn add babel-cli -D</code>

<h3>Updating a dependency</h3>
<code>$ yarn upgrade lodash</code>

or upgrade all the dependencies:

<code>$ yarn upgrade</code>

<h3>Removing a dependency</h3>
<code>$ yarn remove lodash</code>

<h3>Adding a global dependency</h3>
<code>$ yarn global add lodash</code>

<h3>A few more useful commands</h3>
<li>Get some information about a package: <em>yarn info lodash</em>
</li><li>Verify that the installed version of a package is a match between the package.json and the Yarn lock files: <em>yarn check</em>
</li><li>Publish a package: <em>yarn publish</em>
</li><li>Check for outdated packages: <em>yarn outdated</em>
</li><li>Find why a package is needed: <em>yarn why lodash</em>
</li><li>Run one of the scripts defined in package.json: <em>yarn run test</em>
</li>

Have fun with Yarn! 


<h2>Let and Const in JavaScript with ES6 / ES2015</h2>

Two new keywords are available in ES6 / ES2015 to declare variables in JavaScript: <em>let</em> and <em>const</em>. 
Contrary to var, let and const are block-scoped.

<em>Var</em> has an issue where it's not block-scoped, which can lead to surprises:

<code>var dog = 'Ralf';

if (true) {
 var dog = 'Skip';
}

console.log(dog); // Skip</code>

Compare this to using <em>let</em>:

<code>let dog = 'Ralf';

if (true) {
 let dog = 'Skip';
}

console.log(dog); // Ralf</code>

<em>Var</em> is properly function-scoped, meaning that the issue doesn't happen in functions, but in blocks like <em>if</em> or <em>for</em> all bets are off and variables declared with <em>var</em> get hoisted to the parent scope.

<h3>Const</h3>
With <em>const</em> you can define immutable variables (constants). 
Trying to re-assign a constant will raise an error:

<code>const PI = 3.1415;

PI = 5; // "TypeError: Assignment to constant variable.</code>

Be careful however, new items can still be pushed into an array constant or added to an object. 
The following 2 snippets work without complaining because we are not trying to reassign to the variables:

<code>const someArr = [3, 4, 5];

someArr.push(6);</code>

<code>const someObj = {
 dog: 'Skip',
 cat: 'Caramel',
 bird: 'Jack'
};

someObj.camel = 'Bob';</code>

<h3>Let vs Var</h3>
Many developers now agree that there's not a very strong case for using <em>var</em> at all anymore and that using <em>let</em> should be the way to go forward.

In short, <strong>use let</strong>!

<h2>Introduction to Progressive Web Apps (PWAs): Service Worker &amp; Manifest</h2>

Thanks to technologies like <em>Service Workers</em>, websites and web apps can now behave more and more like native apps on browsers that support it. 
That's what we then call a progressive web app (PWA).

Progressive web apps allow you to do things like install to home screen and make your app accessible when offline. 
Try it out, if you are on Chrome or Firefox, turn off your Wi-Fi and reload this page. 
You'll see that the page loads fine because it's been cached and the cached version is served from the Service Worker.

In order for a web app to be considered a progressive web app, a few things need to be in place:

<h3>Progressive Web App Checklist</h3>
The following 3 are the most important to have a basic progressive web app working:
<li>The website has to be served over <em>https</em>
</li><li>Your app should have a <em>Web App Manifest</em> file</li><li>Your app should have a working <em>Service Worker</em>
</li>

Having these three things covered you'll have a basic Progressive Web App that can be available offline and loads static assets from the cache. 
You can use the <a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk?hl=en">Lighthouse</a> Chrome extension to run an audit and see where your app is standing in the spectrum:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6c77c7550cf7ad14bec671a64a5ac484fe5d1e69/03527/images/js/pwa/lighthouse2.jpg" width="650" height="452" alt="The Lighthouse plugin in action">

<h3>Web App Manifest</h3>
A web app manifest is a Json file with metadata about your app. 
The content from the manifest is especially important to allow browsers like Chrome on Android phones to present an option to repeat visitors to install the web app on their home screen.

This <a href="https://app-manifest.firebaseapp.com/">Web App Manifest Generator</a> makes it easy to generate a manifest.json file. 
It'll even generate all the different icon sizes from just one 512x512 icon.

Once you have your manifest.json file, include it in the head section of your app with something like this:

<code>&lt;link rel="manifest" href="/path/to/manifest.json"></code>

Here's for example the content of the Web App Manifest for this website:

<code>{
 "name": "Alligator.io",
 "short_name": "Alligator",
 "theme_color": "#138e69",
 "background_color": "#f8ea48",
 "display": "browser",
 "Scope": "/",
 "start_url": "/",
 "icons": [
   {
     "src": "images/icons/icon-72x72.png",
     "sizes": "72x72",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-96x96.png",
     "sizes": "96x96",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-128x128.png",
     "sizes": "128x128",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-144x144.png",
     "sizes": "144x144",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-152x152.png",
     "sizes": "152x152",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-192x192.png",
     "sizes": "192x192",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-384x384.png",
     "sizes": "384x384",
     "type": "image/png"
   },
   {
     "src": "images/icons/icon-512x512.png",
     "sizes": "512x512",
     "type": "image/png"
   }
 ],
 "splash_pages": null
}</code>

<h3>Service Worker</h3>
Service Workers is a new technology available in <a href="http://caniuse.com/#feat=serviceworkers">some modern browsers</a> that allow control over network requests. 
Service Workers make it possible to cache assets and control what happens when there's no access to the network or when the access is very slow. 
In the case of web apps, assets for the shell of the app can be cached and then always available when offline or in low connectivity.

<h3>Registering a Service Worker</h3>
The first step in getting a service worker in place is to register it.

Here's a sample script that you can use to register a Service Worker. 
Notice how it first checks if Service Workers are supported:

<code>if ('serviceWorker' in navigator) {
 navigator.serviceWorker.register('/service-worker.js').then(function(registration) {
   console.log('ServiceWorker registration successful!');
 }).catch(function(err) {
   console.log('ServiceWorker registration failed: ', err);
 });
}</code>

Notice how the Service Worker is in the root folder. 
This means that it'll be scroped to the whole web app. 
If it had been in a subfolder, it would be scoped to just that subfolder by default.

<h3>The Service Worker</h3>
Now for the service worker itself, it can get quite complex, and a tool like <a href="https://github.com/GoogleChrome/sw-toolbox">SW-Toolbox</a> can really help cut the boiler plate code needed to setup a Service Worker. 
Manually coding a Service Worker involves setting up event listeners for the <em>install</em>, <em>activate</em> and <em>fetch</em> events, but SW-Toolbox takes care of that behind the scenes.

You can install SW-Toolbox from npm like this:

<code>$ npm install --save sw-toolbox</code>

Then, in the Service Worker that you registered (e.g.: <em>service-worker.js</em>), use <em>self.importScripts()</em> to import SW-Toolbox:

<code>self.importScripts('node_modules/sw-toolbox/sw-toolbox.js');</code>

For this website, all that was needed other than importing SW-Toolbox is the following:

<code>self.toolbox.precache(['/images/logo-small.svg', '/images/web-icons/webicon-twitter.svg', '/images/web-icons/webicon-facebook.svg']);
self.toolbox.router.get('/*', toolbox.networkFirst);</code>

This precaches a few assets and then caches everything, but tries to get fresh data from the network first before defaulting to the cached version if the network is not available.

This works well for a static website like this one, but caching everything wouldn't work with an actual web app that has dynamic data. 
You can dig peeper into what you can do with SW-Toolbox with this <a href="https://googlechrome.github.io/sw-toolbox/usage.html">usage guide</a> and this <a href="https://duske.me/improve-user-experience-with-service-worker-toolbox/">blog post</a>.

If you want to dig peeper into Service Workers, Mozilla put together a <a href="https://serviceworke.rs/">Service Worker Cookbook</a> with sample code for various things service workers can do.

<h3>Testing</h3>
Once you have everything in place, you can inspect the Web App Manifest and Service Worker from the Application tab of the Chrome DevTools:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ca9e28cc400b644ebc8e425b312141906d5ee7a4/8f23a/images/js/pwa/inspect.jpg" width="650" height="282" alt="Inspecting Service Worker">

You can play around with the <em>Offline</em> checkbox to test how your app would react when offline. 
When playing around with different Service Worker configurations, it's also useful to be able to unregister the current service worker so that the new version of the service worker gets registered instead.

<h3>Learning More</h3>
As this was just a brief introduction, you may want to dive deeper into progressive web apps. 
Here are a few good resources:
<li>A more in-depth <a href="https://developers.google.com/web/progressive-web-apps/checklist">Progressive Web App checklist</a> from Google.</li><li>Google's <a href="https://developers.google.com/web/progressive-web-apps/">Progressive Web App portal</a>.</li><li>This recording of the 2016 <a href="https://www.youtube.com/watch?v=oujlrIZkyYY">Progressive Web App Summit</a>.</li>



<h2>Object Property Value Shorthand in JavaScript with ES6</h2>

New in JavaScript with ES6/ES2015, if you want to define an object who's keys have the same name as the variables passed-in as properties, you can use the shorthand and simply pass the key name.

Here's how you can declare an object with the new ES6 / ES2015 syntax:

<code>let cat = 'Miaow';
let dog = 'Woof';
let bird = 'Peet peet';

let someObject = {
 cat,
 dog,
 bird
}

console.log(someObject);

//{
//  cat: "Miaow",
//  dog: "Woof",
//  bird: "Peet peet"
//}</code>

And here's how to do the same thing with the older ES5 syntax:

<code>var cat = 'Miaow';
var dog = 'Woof';
var bird = 'Peet peet';

var someObject = {
 cat: cat,
 dog: dog,
 bird: bird
}</code>

<h2>Generator Functions in JavaScript with ES6 / ES2015</h2>

With generator functions in ES2015 (ES6), we're now able to define functions that can return multiple values with the help of the <em>yield</em> keyword. 
Here's an example of a simple generator function:

<code>function* someGenerator(){
 yield 'Cats';
 yield 'Dogs';
 yield 'Birds';
}</code>

Notice the use of the <em>*</em> character next to the <em>function</em> keyword, to indicate that it's a generator function.

Now let's create an instance of the generator and extract the values from it by calling <em>next()</em> on the generator and getting value:

<code>const gen = someGenerator();

console.log(gen.next().value); // Cats
console.log(gen.next().value); // Dogs
console.log(gen.next().value); // Birds
console.log(gen.next().value); // Undefined</code>

<em>next()</em> returns an object with the <em>value</em> and a boolean called <em>done</em> that returns true if the generator is out of values:

<code>const gen2 = someGenerator();

console.log(gen2.next().done); // false
console.log(gen2.next().done); // false
console.log(gen2.next().done); // false
console.log(gen2.next().done); // true</code>

<h3>ID Generator</h3>
You can use an infinite while in a generator function to create a function that will generate a new ID every time <em>next()</em> is called on it. 
In this case the infinite loop is not dangerous because it will only execute once with calls to <em>next()</em>:

<code>function* idGen(){
 let i = 0;
 while (true) {
   yield ++i;
 }
}

const myIdGen = idGen();

console.log(myIdGen.next().value); // 1
console.log(myIdGen.next().value); // 2
console.log(myIdGen.next().value); // 3
console.log(myIdGen.next().value); // 4</code>

<h2>Rest Parameters in JavaScript with ES6 / ES2015</h2>

Rest parameters are a new way in ES6 / ES2015 to work with functions that have an arbitrary amount of arguments passed in:

<code>function myFunc(...someArgs) {
 for (let i = 0; i &lt; rest.length; i++) {
   console.log(`Argument ${ i + 1 }: ${ rest[i] }`);
 }
}</code>

Now let's call the function:

<code>myFunc('Paul', 'John', 'Ringo');</code>

And this is what we'll get at the console:

Argument 1: Paul
Argument 2: John
Argument 3: Ringo

Prior to ES6, the <em>arguments</em> array-like object could be used, but more boilerplate code was needed to be able to treat <em>arguments</em> like a real array.

<h3>Destructuring</h3>
You can define an array as the rest parameter, and the passed-in arguments will be broken down into the array:

<code>function myFunc(...[name1, name2, name3]) {
 console.log(name1, name2, name3);
}

let names = ['Paul', 'John', 'Ringo'];
myFunc(names);

// Paul,John,Ringo</code>

<h2>Promises in JavaScript with ES6 / ES2015</h2>

Promises are a new feature in the ES6 (ES2015) JavaScript spec that allow you to very easily deal with asynchronous code without resolving to multiple levels of callback functions. 
Goodbye callback hell!

Here's how we declare a basic promise. 
Below you would normally call something asynchronous like an external API for example. 
Here we're simulating with a setTimeout function:

<code>let myPromise = new Promise((resolve, reject) => {
 let data;
 setTimeout(() => {
   data = "Some payload";

   if (data) {
     resolve(data);
   } else {
     reject();
   }
 }, 2000);
});</code>

Notice how a new promise is initiated with two functions as arguments, a function for its success and a function for its failure. 
And here's how you would call the promise to get the payload data from it:

<code>myPromise.then(data => {
 console.log('Received: ' + data);
}).catch(() => {
 console.log("There was an error");
});</code>

The above will log the following at the console:

Received: Some payload

If no data was received, the following would be logged instead:

There was an error

<h3>Chaining Promises</h3>
Promises can also be chained together with multiple <em>then</em> functions. 
The return value of a <em>then</em> becomes the value available to the next <em>then</em> in the chain:

<code>myPromise.then(data => {
 console.log('Received: ' + data);
 let moreData = "Another payload";
 return moreData;
}).then(data => {
 console.log(data);
}).catch(() => {
 console.log("There was an error");
});</code>

The above will log the following at the console:

Received: Some payload
Another payload

<h2>Using DOMParser to Parse HTML Strings</h2>

I was playing with the <a href="https://wordpress.org/plugins/rest-api/">WP Rest API plugin</a> to access content from a WordPress blog into an Ionic 2 app. 
The WP Rest API returns an HTML string for the content of posts, which can make it hard to deal with. 
Fortunately though, the <em>DOMParser</em> Web API makes it easy to parse html strings into a fully formed DOM.

First you instantiate a new DOMParser instance and pass it your HTML string using <em>parseFromString()</em>. 
For this example, let's say that we stored the HTML string in a variable called htmlContent:

<code>let parser = new DOMParser();
let parsedHtml = parser.parseFromString(htmlContent, 'text/html');</code>

And now <em>parsedHtml</em> is a DOM object that can be interacted with. 
Let's extract a few things from it:

<code>// The src of the first image:
let firstImg = parsedHtml.images[0].src;

// The li elements of the second ul element:
let liElements = parsedHtml.getElementsByTagName("ul")[1].children;

// The the inner HTML of elements with class name 'active':
let active = parsedHtml.getElementsByClassName("active").innerHTML;</code>

Taking the second example with <em>li</em> elements, let's go a bit further and populate an array with the inner HTML of each element:

<code>let rawLiElements = parsedHtml.getElementsByTagName("ul")[1].children;
let liElements = [];

for (let i = 0; i &lt; rawLiElements.length; i++) {
 liElements.push(rawLiElements[i].innerHTML);
}</code>

 DOMParser is still experimental, so its implementation is subject to change and support can be limited.

<h2>Template Literals in JavaScript (ES6 / ES2015)</h2>

The ECMAScript 2015 specification (<em>ES6</em>) brings us <em>template literals</em> for string interpolation and multiline strings. 
You may also have heard of them as <em>template strings</em>. 
The character used to define template literals is the backtick (<em>`</em>), which is located to the right of the 1 on most keyboard layouts.

Here's an example of string interpolation with template literals:

<code>function greeting(firstName, lastName) {
 let message = `Hello ${firstName} ${lastName}`;
 return message;
}</code>

And here's an example of a multiline string:

<code>console.log(`Right now
 is the perfect time to
 learn JavaScript`);</code>

And here's yet another example of the power of string interpolation and multiline strings with template literals:

<code>var user = { name: "Joe", email: "joe@example.com" };
var item = { quantity: 3, price: 4.99 };

var message = `Name: ${user.name}
Email: ${user.email}
-----
Total price: ${item.quantity * item.price}`;

console.log(message);</code>

Here's the message that will be logged to the console from the above example:

<code>Name: Joe
Email: joe@example.com
-----
Total price: 14.97</code>

<h2>console.time() &amp; console.timeEnd() in JavaScript</h2>

The console object has <em>time()</em> and <em>timeEnd()</em> methods that help with analyzing performance of pieces of your code. 
You first call <em>console.time()</em> by providing a string argument, then the code that you want to test, then call <em>console.timeEnd()</em> with the same string argument. 
You'll then see the time it took to run the code in your browser console. 
Here's an example:

<code>console.time("Time this");

for (var i = 0; i &lt; 10000; i++) {
 // Your stuff here
}

console.timeEnd("Time this");</code>

Most of the time code will execute too fast to be able to draw conclusions, so you'd most likely want to run your code in a for loop that goes through thousands of iterations.

 Use this only in development mode and remove these calls in code that's going into production.

&lt;script> console.time("Time this"); for (var i = 0; i &lt; 10000; i++) { // Your stuff here } console.timeEnd("Time this"); &lt;/script>

<h2>console.table() in JavaScript</h2>

The <em>console.table()</em> allows to display data in the console in a nice tabular format. 
It comes in very handy when having to visualize complex arrays or objects. 
It can display tabular data for arrays or objects:

<code>var someArray = [
"Blowin' in the Wind",
"Like a Rolling Stone",
"Knockin' On Heaven's Door"
];

console.table(someArray);

// Array of arrays:
var anotherArray = [
["One", "Two"],
["Three", "Four"],
["Five", "Six"]
];

console.table(anotherArray);</code>

&lt;script> var someArray = [ "Blowin' in the Wind", "Like a Rolling Stone", "Knockin' On Heaven's Door" ]; console.table(someArray); // Array of arrays: var anotherArray = [ ["One", "Two"], ["Three", "Four"], ["Five", "Six"] ]; console.table(anotherArray); &lt;/script>

And here's an example with an object:

<code>function HitSingle(title, artist,
 year, album) {
 this.title = title;
 this.artist = artist;
 this.year = year;
 this.album = album;
}

var favHit = new HitSingle(
   "Like a Prayer",
   "Madonna",
   "1989",
   "Like a Prayer"
   );

console.table(favHit);</code>

&lt;script> function HitSingle(title, artist, year, album) { this.title = title; this.artist = artist; this.year = year; this.album = album; } var favHit = new HitSingle( "Like a Prayer", "Madonna", "1989", "Like a Prayer" ); console.table(favHit); &lt;/script>
There's an optional second argument to <em>console.table()</em>: an array with the names for the columns.

 Try it! Open your console to see the result. 
Keep in mind though that console.table() is not supported in IE.

<h2>Arrow Functions in JavaScript</h2>

New with JavaScript since ES6 / ES2015, <em>arrow functions</em>, also known as fat arrow functions, are a concise way to write function expressions.

Here are some examples:

<code>// No parameters
var myFunc = () => {
 // Do stuff
};

// With parameters
var myFunc = (a, b) => {
 return a * b;
};

// Only 1 param, no need for parens
var myFunc = a => {
 return a * a;
};

// No brackets and implicit return
// with single-line arrow function
var myFunc = a => a * a;

// Wrap body in parens to return
// object literal
var myFunc = (first, last) =>
({ firstName: first, lastName: last });</code>

<h3>A Few Facts About Arrow Functions in JavaScript</h3>
<li>You don't need to use curly brackets if there's only one statement in the function. 
In the cases where you omit the curly brackets, you can also omit the <em>return</em> keyword, as the return is implicit.</li><li>
<em>this</em> is bound lexically, meaning that fat arrow functions don't have their own <em>this</em> and that <em>this</em> refers to the parent scope.</li><li>They can't be used as constructors or generators.</li><li>There's no <em>arguments</em> variable available with arrow functions.</li><li>You'll probably want to use a transpiler like <a href="https://babeljs.io/">Babel</a> to use arrow functions today, for browsers that don't support them yet.</li>


<h2>charCodeAt() String Method in JavaScript</h2>

<em>charCodeAt()</em> returns the unicode value of the character at the specified index of a string:

<code>var someString = "Whale";

console.log(someString.charCodeAt(3));

// 108</code>

<h3>Syntax</h3>
<code>myString.charCodeAt(index);</code>

<h3>See Also</h3><li><a href="https://alligator.io/js/charat-string-method">charAt() String Method</a></li>

<h2>charAt() String Method in JavaScript</h2>

<em>charAt()</em> returns the character at the specified index of a string:

<code>var someString = "Whale";

console.log(someString.charAt(3));

// "l"</code>

<h3>Syntax</h3>
<code>myString.charAt(index);</code>

<h3>See Also</h3><li><a href="https://alligator.io/js/charcodeat-string-method">charCodeAt() String Method</a></li>

<h2>toLowerCase() and toUpperCase String Methods in JavaScript</h2>

<em>toLowerCase()</em> &amp; <em>toUpperCase()</em> on a string return that same string, with the cases converted to either lower or upper cases:

<code>var inconsistent = “Up AnD dOwn”;

console.log(inconsistent.toLowerCase());

// “up and down”</code>

<h3>Syntax</h3>
<code>// toLowerCase()
myString.toLowerCase();

// toUpperCase
myString.toUpperCase();</code>

<h3>Notes on Usage</h3>
This is most useful when comparing strings because you can ignore case inconsistencies and focus on the actual words. 
While there are times you need to check for cases, this has you covered for the times that you don't:

<code>var typeface = "Sans-serif";

console.log(typeface.toLowerCase() == "sans-serif");

// true</code>

<h2>includes() String Method in JavaScript</h2>

Use the <em>includes()</em> method to search for a substring inside a string:

<code>var word = "bravery";

console.log(word.includes(“rave”));

// true</code>

<h3>Syntax</h3>
This quick and easy way to check if one string contains another is very simple to implement. 
Just call the method with the <strong>substring</strong> you're looking for as the argument:

<code>myString.includes(subString);</code>

<h3>Case-Sensitive</h3>
Remember that the comparison takes cases into consideration:

<code>var burnIntro = “Yo momma ~”;

console.log(burnIntro.includes(“yo”));

// false</code>

<h2>Ternary Operator in JavaScript</h2>

If-else statements are pretty straightforward, but there's a shorter way to write them:

<code>var isEven = true;

isEven ? console.log(2) : console.log(1);

// 2</code>

<h3>Syntax</h3>
<code>condition ? firstExpression : secondExpression;</code>

Ternary operators are easy to understand. 
It first evaluates if the <em>condition</em> is met. 
<em>firstExpression</em> is executed if the result is true and <em>secondExpression</em> if false.

<h3>Conditional Assignments</h3>
One common use case for ternary operators is <em>conditional assignments</em>. 
You can assign values depending on a specific condition:

<code>var pokemon = 151;

var title = pokemon &lt; 152 ? "noob" : "master";

// "noob"</code>

<h2>reduce() Array Method in JavaScript</h2>

If <em>reduce()</em> was a person, it would be a census enumerator:

<code>var pokemon = ["squirtle", "charmander", "bulbasaur"];

var pokeLength =
 pokemon.reduce(function(previous, current) {
 	return previous + current.length;
 }, 0);

// 27</code>

<h3>Syntax</h3>
<em>reduce()</em> goes over each array entry updating a reference to a key value that it ultimately returns:

<code>array.reduce(function(previousValue, currentValue, currentIndex, array), {
	// do stuff here
	return newPreviousValue;
}, initialValue);</code>

<h3>Tips</h3>
If you supply an <em>initialValue</em>, the key value starts off with that. 
Otherwise it starts with the array's first element. 
In both cases, you can reference it using the <em>previousValue</em> argument in your callback function.

Remember that you must explicitly return something that will be the previousValue for the next entry in the array.

<h3>Reference</h3>
For a turn-by-turn explanation of the reduce method, head on over to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#How_reduce_works">Mozilla Developer Network</a>

<h2>JavaScript Reserved Keywords</h2>

Here are keywords that you can't use in JavaScript for variable names and identifiers:

<code>await</code>, <code>break</code>, <code>case</code>, <code>catch</code>, <code>class</code>, <code>const</code>, <code>continue</code>, <code>debugger</code>, <code>default</code>, <code>delete</code>, <code>do</code>, <code>else</code>, <code>enum</code>, <code>export</code>, <code>extends</code>, <code>false</code>, <code>finally</code>, <code>for</code>, <code>function</code>, <code>if</code>, <code>implements</code>, <code>import</code>, <code>in</code>, <code>instanceof</code>, <code>interface</code>, <code>new</code>, <code>null</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>return</code>, <code>super</code>, <code>switch</code>, <code>this</code>, <code>throw</code>, <code>true</code>, <code>try</code>, <code>typeof</code>, <code>var</code>, <code>void</code>, <code>while</code>, <code>with</code>, <code>yield</code>

You should also avoid these HTML event handlers as identifiers:

<code>onblur</code>, <code>onclick</code>, <code>onerror</code>, <code>onfocus</code>, <code>onkeydown</code>, <code>onkeypress</code>, <code>onkeyup</code>, <code>onmouseover</code>, <code>onload</code>, <code>onmouseup</code>, <code>onmousedown</code>, <code>onsubmit</code>

<h2>Holmes: Fast Page Searching</h2>

<a href="https://haroen.me/holmes/" target="_blank" rel="noopener">Holmes</a> is a tool that lets you search for content on a page easily. 
If you have a page with tons of content, Holmes can be a really useful tool to allow a visitor to type-in an input field and automatically be left with only the content that matches the search query.


<a aria-label="Star Haroenv/holmes on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/Haroenv/holmes#stargazers_count" data-count-href="/Haroenv/holmes/stargazers" data-icon="octicon-star" href="https://github.com/Haroenv/holmes">Star</a> <a aria-label="Fork Haroenv/holmes on GitHub" data-count-aria-label="# forks on GitHub" data-count-api="/repos/Haroenv/holmes#forks_count" data-count-href="/Haroenv/holmes/network" data-icon="octicon-repo-forked" href="https://github.com/Haroenv/holmes/fork">Fork</a> <a aria-label="Download Haroenv/holmes on GitHub" data-icon="octicon-cloud-download" href="https://github.com/Haroenv/holmes/archive/master.zip">Download</a>

<h3>Installation</h3>
npm installation:

<code>npm install holmes.js --save</code>

Bower installation:

<code>bower install holmes.js --save</code>

Then you can use a tool like <a href="http://browserify.org/">Browserify</a> to include Holmes in your project.

Also make sure that you have a CSS class named hidden defined that sets display: none. 
This class will be used by Holmes to hide elements that don't match the search query.

<h3>Usage</h3>
It's very simple to use. 
You instantiate Holmes and define a selector for the input and one for the individual possible results. 
It doesn't get any easier than that!

<code>$( document ).ready(function() {
 holmes({
   input: 'input.narrow-down',
   find: 'div.single-card'
 })
});</code>

There also are a few extra options that you can play with: placeholder, class, dynamic, contenteditable &amp; instant.


<h2>split() String Method in JavaScript</h2>

Sometimes you just need to take strings apart:

<code>var sentence = "Oh a cookie!"

sentence.split(" ");

// [ "Oh", "a", "cookie!" ]</code>

<h3>Syntax</h3>
The trick is using the correct separator:

<code>myArray.split(separator);</code>

<h3>Common use case</h3>
If you leave the separator blank, it will dissect each character.

<code>var pieces = sentence.split("");

// [ "O", "h", " ", "a", " ", "c", "o", "o", "k", "i", "e", "!" ]</code>

Notice that the spaces stay in the resulting array because they were not used as the separator.

<h2>concat() Array Method in JavaScript</h2>

What do you do when you have two arrays but only need one? You concat them:

<code>var words = [“cockapoo”, “beefalo”]

var moreWords = [“pegacorn”, “schnoodle”]

var allWeirdWords = words.concat(moreWords)

// [ “cockapoo”, “beefalo”, “pegacorn”, “schnoodle” ]</code>

<h3>Syntax</h3>
<code>firstArray.concat(secondArray);</code>

Remember! The array before the concat() method will be placed before the array inside the parenthesis once they are combined.

<h2>Share Button: Simple &amp; Stylish Share Button</h2>

<a href="https://github.com/carrot/share-button" target="_blank" rel="noopener">Share Button</a> is a really simple and elegant share button for your website. 
No iframes, no JavaScript from the social platforms, and a beautiful compact layout. 
You can see an <a href="https://sharebutton.co/" target="_blank" rel="noopener">example here</a>.


<a aria-label="Star carrot/share-button on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/carrot/share-button#stargazers_count" data-count-href="/carrot/share-button/stargazers" data-icon="octicon-star" href="https://github.com/carrot/share-button">Star</a> <a aria-label="Fork carrot/share-button on GitHub" data-count-aria-label="# forks on GitHub" data-count-api="/repos/carrot/share-button#forks_count" data-count-href="/carrot/share-button/network" data-icon="octicon-repo-forked" href="https://github.com/carrot/share-button/fork">Fork</a> <a aria-label="Download carrot/share-button on GitHub" data-icon="octicon-cloud-download" href="https://github.com/carrot/share-button/archive/master.zip">Download</a>

<h3>Installation</h3>
Download share-button.min.css and share-button.min.js from <a href="https://github.com/carrot/share-button/releases">here</a>. 
Then include the CSS file in the header of your website:

<code>&lt;link rel='stylesheet' href='path/to/share-button.min.css'
   type='text/css' media='all'/></code>

And include the JavaScript file before the closing &lt;/body> tag:

<code>&lt;script src="https://alligator.io/js/path/to/share-button.min.js">&lt;/script></code>

On your pages, include the &lt;share-button>&lt;/share-button> element where you want the share button to be rendered.

Finally, you'll want to instantiate it:

<code>$( document ).ready(function() {
 new ShareButton();
});</code>

<h3>Options</h3>
In most cases, you'll want to pass a few options when instantiating the share button. 
See here for a <a href="https://github.com/carrot/share-button/blob/master/docs/configuration-options.md">list of options</a>. 
And here's a quick example showing some options:

<code>new ShareButton({
networks: {
   whatsapp: {
     enabled: false
   },
   googlePlus: {
    enabled: false
   }
 },
ui: {
   flyout: 'middle right'
   }
});</code>

 There's currently a bug in Chrome for the share button where the SVG icons don't show up properly. 
See this <a href="https://github.com/carrot/share-button/issues/305">issue thread</a> for a fix.


<h2>clipboard.js: Copy Text to the Clipboard</h2>

<a href="https://clipboardjs.com/" target="_blank" rel="noopener">clipboard.js</a> lets you easily copy text to the clipboard. 
At 3kb gzipped and no need for Flash, it's a great lightweight way to allow your visitors to copy bits of text and code on your site.


<a href="https://github.com/zenorocha/clipboard.js" data-icon="octicon-star" data-count-href="/zenorocha/clipboard.js/stargazers" data-count-api="/repos/zenorocha/clipboard.js#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star zenorocha/clipboard.js on GitHub">Star</a> <a href="https://github.com/zenorocha/clipboard.js/fork" data-icon="octicon-repo-forked" data-count-href="/zenorocha/clipboard.js/network" data-count-api="/repos/zenorocha/clipboard.js#forks_count" data-count-aria-label="# forks on GitHub" aria-label="Fork zenorocha/clipboard.js on GitHub">Fork</a> <a href="https://github.com/zenorocha/clipboard.js/archive/master.zip" data-icon="octicon-cloud-download" aria-label="Download zenorocha/clipboard.js on GitHub">Download</a>

<h3>Installation</h3>
npm installation:

<code>npm install clipboard --save</code>

Bower installation:

<code>bower install clipboard --save</code>

Or get the package from Github and place the clipboard.min.js file manually in your project folder.

Then include the JavaScript file before the closing &lt;/body> tag:

<code>&lt;script src="https://alligator.io/js/path/to/clipboard.min.js">&lt;/script></code>

Finally, you'll want to instantiate it. 
It this example we're instantiating all elements with a class of clipboard:

<code>$( document ).ready(function() {
 var clipboard = new Clipboard('.clipboard');
});</code>

<h3>Usage</h3>
To use it, either use the data-clipboard-text data attribute:

<code>&lt;button
  data-clipboard-text="This will be copied">
 Copy this
&lt;/button></code>

Or use the data-clipboard-target data attribute:

<code>&lt;span>This text will be copied&lt;/span>

&lt;button data-clipboard-target="#copy">
 Copy this
&lt;/button></code>

<h3>Handling errors</h3>
Handle success and error states easily with the success and error custom events:

<code>$( document ).ready(function() {
 clipboard.on('success', function(e) {
   $(e.trigger).text("Copied!");
   e.clearSelection();
   setTimeout(function() {
     $(e.trigger).text("Copy");
   }, 2500);
 });

 clipboard.on('error', function(e) {
   $(e.trigger).text("Can't in Safari");
   setTimeout(function() {
     $(e.trigger).text("Copy");
   }, 2500);
 });
});</code>

 Some browsers don't support the execCommand API needed for clipboard.js to work properly. 
The text will still get selected, so a good workaround is to show a message telling the user to hit <em>ctrl + c</em> when an error event is triggered.


<h2>Comments in JavaScript</h2>

Here's how you use comments in JavaScript. 
First, an example of a single line comment:

<code>// Boo! I'm a comment.</code>

And here's an example for a multi-line comment:

<code>/* And I'm
a comment on
multiple lines */</code>

<h2>For Loops in JavaScript</h2>

Iterate over things in JavaScript with for loops using the following syntax:

<code>for (var i = 0; i &lt; 10; i++) {
 console.log("Iteration " + i);
}</code>

<h3>var i = 0</h3>
<strong>The initial statement</strong>, which is executed before the loop starts. 
Usually you'll use this to declare a counter. 
You'll see a lot of code with just i = 0, but it's a good practice to use the var keyword to ensure that the variable is declared locally.

<h3>i &lt; 0</h3>
<strong>The condition statement</strong>. 
The loop will run until the condition becomes false. 
Often the condition will look similar to something like this to run through all the items of an array:

<code>i &lt; myArray.length</code>

<h3>i++</h3>
<strong>The iteration statement</strong>. 
Iterate on something that will eventually make the condition false.

<h2>push() Array Method in JavaScript</h2>

When you want to add something to an array, just push() it in:

<code>var lyrics = ['push', 'it', 'real'];

lyrics.push('good');

// [ 'push', 'it', 'real', 'good' ]</code>

<h3>The syntax is real simple:</h3>
<code>myArray.push(toAdd);</code>

<h3>You can also push multiple items at once:</h3>
<code>myArray.push(item1, item2, item3);</code>

<h2>filter() Array Method in JavaScript</h2>

filter() creates a new array with elements that fall under a given criteria from an existing array:

<code>var numbers = [1, 3, 6, 8, 11];

var lucky = numbers.filter(function(number) {
 return number > 7;
});

// [ 8, 11 ]</code>

<h3>The syntax</h3>
<code>var newArray = array.filter(function(item) {
 return condition;
});</code>

The <em>item</em> argument is a reference to the current element in the array as filter() checks it against the <em>condition</em>. 
This is useful for accessing properties, in the case of objects.

If the current <em>item</em> passes the condition, it gets sent to the new array.

<h3>Filtering an array of objects</h3>
A common use case of .filter() is with an array of objects through their properties:

<code>var heroes = [
	{name: “Batman”, franchise: “DC”},
	{name: “Ironman”, franchise: “Marvel”},
	{name: “Thor”, franchise: “Marvel”},
	{name: “Superman”, franchise: “DC”}
];

var marvelHeroes =  heroes.filter(function(hero) {
	return hero.franchise == “Marvel”;
});

// [ {name: “Ironman”, franchise: “Marvel”}, {name: “Thor”, franchise: “Marvel”} ]</code>

<h2>map() Array Method in JavaScript</h2>

Way cooler than using for loops on arrays, map() iterates over an array and creates a new array that has had each item passed through a function:

<code>var drinks = [“coffee soda”, “tea”, “whiskey”];

var coldDrinks = drinks.map(function(drink) {
	return ‘iced ' + drink;
});

// [‘iced coffee soda', ‘iced coffee', ‘iced whiskey']</code>

The syntax is very simple:

<code>var newArray = myArray.map(function);</code>

<h2>Immediately-invoked function expressions</h2>

Protect your global environment from being polluted by your code with immediately-invoked function expressions (IIFE). 
Code within an IIFE is within its own lexical scope:

<code>(function() {
 // your stuff here
})();</code>

<h3>Passing-In Variables</h3>
You can pass variables in the IIFE's scope with something like this:

<code>(function($) {
 // $ == jQuery;
})(jQuery);</code>


<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>

</body>
</html>
