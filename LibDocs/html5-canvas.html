<base target="_blank"><html><head><title>HTML5 canvas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
  var showTopicNumber = true;
  var bookid = "HTML5 canvas"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>HTML5 canvas</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>
<h2>A Note Regarding Supplemental Files</h2>
Supplemental files and examples for this book can be found at <a href="http://examples.oreilly.com/0636920013327/">http://examples.oreilly.com/0636920013327/</a>. 
Please use a standard desktop web browser to access these files, as they may not be accessible from all ereader devices.
All code files or examples referenced in the book will be available online. 

For physical books that ship with an accompanying disc, whenever possible, we’ve posted all CD/DVD content. 
Note that while we provide as much of the media content as we are able via free download, we are sometimes limited by licensing restrictions. 
Please direct any questions or concerns to <a href="mailto:booktech@oreilly.com">booktech@oreilly.com</a>.
<h2>Preface</h2>
HTML5 Canvas offers developers the chance to create animated graphics in ordinary web browsers using common tools: HTML and JavaScript. 
Canvas is one of the most visible parts of HTML5, fueling demo after demo, game after game. 
It offers interactivity with great visuals, and provides tremendous freedom to do whatever you want in the browser window. 
However, it differs enough from typical JavaScript development (as well as Flash and Silverlight development) that it needs careful exploration!
<h2>Running the Examples in the Book</h2>
The best part about programming HTML5 Canvas is that the entry barrier is very low—all you need is a modern web browser and a text editor.

Every example in this book was tested with Google Chrome, Safari, and Opera. 
Late in the development of the example code, Firefox started causing issues. 
While we made every attempt to ensure these examples worked across as many browsers as possible, we recommend you use Google Chrome or Safari for the best results until Canvas support improves.
Please note that if you are using the .pdf version of this book to cut and paste the code, there may be instances where minus (“-”) signs are represented by another character, such as a hyphen. 

You may need to replace the other character with a minus sign (“-”) to get the code to work properly.
We suggest that if you have purchased the electronic version of this book, you should use the printed code samples as a guide only, and instead download the code from the book distribution. 
With that code, you will also get all the images, libraries, and assets necessary to make all the examples work in a web browser.
<h2>What You Need to Know</h2>
Ideally, you know your way around programming in some kind of modern language, such as C, C++, C#, ActionScript 2, ActionScript 3, Java, or JavaScript. 
However, if you’re new to this space, we will introduce Canvas in a way that should familiarize you with web programming at the same time.
Web developers with a foundation in HTML and JavaScript should easily be able to pick up this book and run with it.
If you are a Flash developer, JavaScript and ActionScript 1 are essentially the same language. 

While Adobe took some liberties with ActionScript 2, you should be very comfortable with JavaScript. 
If you only have experience with ActionScript 3, JavaScript might feel like a step backward.
If you are a Silverlight or C# developer, take a deep breath and think about a time before ASP.NET/C# when you might have had to develop web apps in VBScript. 
You are about to enter a similar space.

<h2>How This Book Is Organized</h2>
This book is organized into 11 chapters. 
The first four chapters walk you through the HTML Canvas API by example. 
The topics covered include text, images, and drawing. 

These chapters contain a few finished apps, but mainly consist of demos designed to show you the facets of the Canvas API. 
The following six chapters build upon the Canvas API by expanding the scope of the examples to application length. 
In these chapters, we discuss math and physics applications, video, audio, games, and mobile. 
The final chapter introduces a couple experimental areas: 3D and multiplayer.

What you won’t get in this book is a simple rundown and retelling of the published W3C Canvas API. 
While we cover portions of the API in detail, some of it is not applicable to games. 
Furthermore, you can just read the documentation here:
<table><tr><td><a href="http://dev.w3.org/html5/2dcontext">http://dev.w3.org/html5/2dcontext</a></td></tr></table>

Our goal is to feature the ways Canvas can be used to create animation, games, and entertainment applications for the Web.
<h2>Conventions Used in This Book</h2>
The following typographical conventions are used in this book:

Plain text
Indicates menu titles, menu options, menu buttons, and keyboard accelerators (such as Alt and Ctrl).

<em>Italic</em>
Indicates new terms, URLs, email addresses, filenames, file extensions, pathnames, directories, and Unix utilities.

<code>Constant width</code>
Indicates commands, options, switches, variables, attributes, keys, functions, types, classes, namespaces, methods, modules, properties, parameters, values, objects, events, event handlers, XML tags, HTML tags, macros, the contents of files, or the output from commands.

<strong><code>Constant width bold</code></strong>
Shows commands or other text that should be typed literally by the user.

<em><code>Constant width italic</code></em>
Shows text that should be replaced with user-supplied values.

<h3>Note</h3>
This icon signifies a tip, suggestion, or general note.
<h3>Warning</h3>

This icon indicates a warning or caution.
<h2>Using Code Examples</h2>
This book is here to help you get your job done. 
In general, you may use the code in this book in your programs and documentation. 

You do not need to contact us for permission unless you’re reproducing a significant portion of the code. 
For example, writing a program that uses several chunks of code from this book does not require permission. 
Selling or distributing a CD-ROM of examples from O’Reilly books does require permission. 
Answering a question by citing this book and quoting example code does not require permission. 

Incorporating a significant amount of example code from this book into your product’s documentation does require permission.
We appreciate, but do not require, attribution. 
An attribution usually includes the title, author, publisher, and ISBN. 
For example: “<em>HTML5 Canvas</em> by Steve Fulton and Jeff Fulton (O’Reilly). 

Copyright 2011 8bitrocket Studios, 978-1-4493-9390-8.”
If you feel your use of code examples falls outside fair use or the permission given above, feel free to contact us at <a href="mailto:permissions@oreilly.com">permissions@oreilly.com</a>.
<h2>We’d Like to Hear from You</h2>
Please address comments and questions concerning this book to the publisher:

<table>
<tr><td>O’Reilly Media, Inc.</td></tr>
<tr><td>1005 Gravenstein Highway North</td></tr>
<tr><td>Sebastopol, CA 95472</td></tr>

<tr><td>(800) 998-9938 (in the United States or Canada)</td></tr>
<tr><td>(707) 829-0515 (international or local)</td></tr>
<tr><td>(707) 829-0104 (fax)</td></tr>
</table>

We have a web page for this book, where we list errata, examples, and any additional information. 
You can access this page at:
<table><tr><td><a href="http://www.oreilly.com/catalog/9781449393908">http://www.oreilly.com/catalog/9781449393908</a></td></tr></table>
To comment or ask technical questions about this book, send email to:

<table><tr><td><a href="mailto:bookquestions@oreilly.com">bookquestions@oreilly.com</a></td></tr></table>
For more information about our books, courses, conferences, and news, see our website at <a href="http://www.oreilly.com">http://www.oreilly.com</a>.
Find us on Facebook: <a href="http://facebook.com/oreilly">http://facebook.com/oreilly</a>
Follow us on Twitter: <a href="http://twitter.com/oreillymedia">http://twitter.com/oreillymedia</a>

Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia">http://www.youtube.com/oreillymedia</a> Books Online">
<h2>Safari Books Online</h2>
<h3>Note</h3>

Safari Books Online is an on-demand digital library that lets you easily search over 7,500 technology and creative reference books and videos to find the answers you need quickly.
With a subscription, you can read any page and watch any video from our library online. 
Read books on your cell phone and mobile devices. 
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors. 

Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of other time-saving features.
O’Reilly Media has uploaded this book to the Safari Books Online service. 
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at <a href="http://my.safaribooksonline.com">http://my.safaribooksonline.com</a>.
<h2>Acknowledgments</h2>
First, Steve would like to thank his beautiful wife, Dawn, for the amazing patience, guidance, and support she lovingly provided before, during, and after this book was written. 
Steve would also like to thank his girls—Rachel, Daphnie, and Katie—for all their enthusiastic support and for not getting too frustrated every time they asked him to play and Daddy said, “Sure, yeah, in just a couple minutes” because his head was buried in these pages. 
He’d also like to thank his mom and dad, plus his sisters, Mari and Carol for everything they taught us; and his uncle Richard and cousin John for all their love and support. 
Also thanks to Sue, Morgan, and Lauren Miller; Jen, Eric, Sarah, and Paige Garnica; Dietrich; Chantal Martin; and Ryan and Justin Fulton.

Jeff would like to thank his amazing wife, Jeanne, and his two wonderful boys, Ryan and Justin, for putting up with him writing this second book in two years. 
The writing process is a time- and energy-consuming endeavor that demands patience and understanding from those in close proximity to the temperamental author. 
Jeff would also like to thank his mom and dad, as well as sisters Mari and Carol, for the morale and babysitting support that was needed during the crucial writing times. 
Also, special thanks to the Perry and Backlar clans for all of their love and support.

The authors would also like to acknowledge all the fine people at O’Reilly, especially Mike Loukides, who took the chance on us for this book; and Simon St.Laurent, who led us out of the wilderness; our copyeditor, Marlowe Shaeffer, who made the text sparkle in her own special way; and our production editor, Kristen Borg, for finishing the job.
We’d also like to thank our technical reviewers, Raffaele Cecco, Shelley Powers, and Andres Pagella.
Thanks to everyone at Electrotank, especially Jobe Makar, Matthew Weisner, and Teresa Carrigan; as well as our friends at Jett Morgan, Creative Bottle, Producto Studios, Mattel, Mochi, Adobe, Microsoft, Zynga, The SPIL Group, Giles Thomas from <a href="http://learningwebgl.com">Learningwebgl.com</a>, Ari Feldman, and Terry Paton, plus Ace The Super Villain, Bas Alicante, egdcltd, Tony Fernando, SeuJogo, Hayes, Jose Garay, Richard Davey (@PhotonStorm), Squize and nGfx (@GamingYourWay), and all our other friends at <a href="http://8bitrocket.com">8bitrocket.com</a>. 
We would also like to give a huge shout out to the simply outstanding team at 444 Deharo, especially the entire FV team and the Foo Fighters pod!

Finally, we’d like to thank all of our friends who helped along the way, including Ian Legler, Brandon Crist, Eric Barth, Wesley Crews, Kenny Brown, Mike Foti, Evan Pershing, Scott Johnson, Scott Lunceford, Kurt Legler, Ryan Legler, John Little, Matt Hyatt, Varun Tandon, Mark Hall, Jason Neifeld, Mike Peters and The Alarm.
…and, last but not least, thanks to the W3C for coming up with such a kickass spec for HTML5 Canvas.
 1. Introduction to HTML5 Canvas" epub:type="chapter">

<h2><span class="orange">Chapter 1. Introduction to HTML5 Canvas</span></h2>
<em>HTML5</em> is the current iteration of HTML, the
 <em>HyperText Markup Language</em>. 

HTML was first standardized in 1993, and it was the fuel that ignited the World Wide Web. 
HTML is a way to define the contents of a web page using tags that appear within pointy brackets, &lt; &gt;.
<em>HTML5 Canvas</em> is an <em>immediate mode</em> bitmapped area of the screen that can be manipulated with JavaScript. 

Immediate mode refers to the way the canvas renders pixels on the screen. 
HTML5 Canvas completely redraws the bitmapped screen on every frame using Canvas API calls from JavaScript. 

As a programmer, your job is to set up the screen display before each frame is rendered so that the correct pixels will be shown.
This makes HTML5 Canvas very different from Flash, Silverlight, or SVG, which operate in <em>retained mode</em>. 
In this mode, a display list of objects is kept by the graphics renderer, and objects are displayed on the screen according to attributes set in code (i.e., the <em>x</em> position, <em>y</em> position, and alpha transparency of an object). 
This keeps the programmer away from low-level operations, but gives her less control over the final rendering of the bitmapped screen.
The basic HTML5 Canvas API includes a 2D context that allows a programmer to draw various shapes, render text, and display images directly onto a defined area of the browser window. 

You can apply colors; rotations;
 alpha transparencies; pixel manipulations; and various types of lines, curves, boxes, and fills to augment the shapes, text, and images you place onto the canvas.

In itself, the HTML5 Canvas 2D context is a display API used to render graphics on a bitmapped area, but there is very little in that context to create applications using the technology. 
By adding cross-browser-compatible JavaScript functionality for keyboard and mouse inputs, timer intervals, events, objects, classes, sound, math functions, etc., you can learn to take HTML5 Canvas and create stunning animations, applications, and games.
Here’s where this book comes in. 

We are going to break down the Canvas API into digestible parts and then put it back together, demonstrating how to use it to create applications. 
Many of the techniques you will learn in this book have been tried and used successfully on other platforms, and now we are applying them to this exciting new technology.
Browser Support for HTML5 Canvas
With the exception of Internet Explorer 8, HTML5 Canvas is supported in some way by most modern web browsers, with specific feature support growing on an almost daily basis. 

The best support seems to be from Google Chrome, followed closely by Safari, Firefox, and Opera. 
We will utilize a JavaScript library named <em>modernizr.js</em> that will help us figure out which browsers support which Canvas features. 
At the same time, if you are worried about Internet Explorer, version 9 promises to have support for Canvas. 
In the meantime, you can check out Google Chrome Frame (<a href="http://code.google.com/chrome/chromeframe/">http://code.google.com/chrome/chromeframe/</a>), which delivers Canvas support for IE.

<h2>The Basic HTML Page</h2>
Before we get to Canvas, we need to talk a bit about the HTML5 standards we will be using to create our web pages.
HTML is the standard language used to construct pages on the World Wide Web. 
We will not spend much time on HTML, but it does form the basis of <code>&lt;canvas&gt;</code>, so we cannot skip it entirely.

A basic HTML page is divided into sections, commonly <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code>. 
The new HTML5 specification adds a few new sections, such as <code>&lt;nav&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;header&gt;</code>, and <code>&lt;footer&gt;</code>.
The <code>&lt;head&gt;</code> tag usually contains information that will be used by the HTML <code>&lt;body&gt;</code> tags to create the HTML page. 
It is a standard convention to put JavaScript functions in the <code>&lt;head&gt;</code>, as you will see later when we discuss the <code>&lt;canvas&gt;</code> tag. 

There may be reasons to put some JavaScript in the <code>&lt;body&gt;</code>, but we will make every attempt to keep things simple by having all JavaScript in the <code>&lt;head&gt;</code>.
Basic HTML for a page might look like Example 1-1</a>.
Example 1-1. 
A basic HTML page

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH1EX1: Basic Hello World HTML Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
Hello World!

&lt;/body&gt;
&lt;/html&gt;
<h3>&lt;!doctype html&gt;</h3>
This tag informs the web browser to render the page in standards mode. 

According to the HTML5 spec from W3C, this is required for HTML5 documents. 
This tag simplifies a long history of oddities when it came to rendering HTML in different browsers. 
This should always be the first line of HTML in a document.
<h3>&lt;html lang="en"&gt;</h3>

This is the <code>&lt;html&gt;</code> tag with the language referenced: for example, <code>“en”</code> = English. 
Some of the more common language values are:
<table>
<tr><td>Chinese – <code>lang = “zh”</code>

</td></tr>
<tr><td>French – <code>lang = “fr”</code>
</td></tr>
<tr><td>German – <code>lang = “de”</code>

</td></tr>
<tr><td>Italian – <code>lang = “it”</code>
</td></tr>
<tr><td>Japanese – <code>lang = “ja”</code>

</td></tr>
<tr><td>Korean – <code>lang = “ko”</code>
</td></tr>
<tr><td>Polish – <code>lang = “pl”</code>

</td></tr>
<tr><td>Russian – <code>lang = “ru”</code>
</td></tr>
<tr><td>Spanish (Castilian) – <code>lang = “es”</code>

</td></tr>
</table>
<h3>&lt;meta charset="UTF-8"&gt;</h3>
This tag tells the web browser which character-encoding method to use for the page. 

Unless you know what you’re doing, there is no need to change it. 
This is a required element for HTML5 pages.
<h3>&lt;title&gt;…&lt;/title&gt;</h3>
This is the title that will be displayed in the browser window for the HTML page. 

This is a very important tag, as it is one of the main pieces of information a search engine uses to catalog the content on the HTML page.
<h3>A Simple HTML5 Page</h3>
Now let’s look at this page in a web browser (this would be a great time to get your tools together to start developing code). 
Open your chosen text editor, and get ready to use your preferred web browser: Safari, Firefox, Opera, Chrome, or IE.

In your text editor, type in the code from Example 1-1</a>.
Save the code as <em>CH1EX1.html</em> in a directory of your choosing.
Under the File menu in Chrome, Safari, or Firefox, you should find the option Open File. 
Click that selection. 

You should then see a box to open a file. 
(On Windows using Chrome, you might need to press Ctrl+O to open a file.)
Locate the <em>CH1EX1.html</em> that you just created.
Click Open.

</li>
</ol>
You should see something similar to Figure 1-1.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893581.png" alt="HTML Hello World!" width="108" height="34">

Figure 1-1. 
HTML Hello World!
<h3>Warning</h3>
This is one of only two examples in this entire book that will work with Internet Explorer 8 or earlier.

<h2>Basic HTML We Will Use in This Book</h2>
Many HTML tags can be used to create an HTML page. 
In past versions of HTML, tags that specifically instructed the web browser on how to render the HTML page (e.g., <code>&lt;font&gt;</code> and <code>&lt;center&gt;</code>) were very popular. 
However, as browser standards have become more restrictive in the past decade, those types of tags have been pushed aside, and the use of CSS (Cascading Style Sheets) has been adopted as the primary way to style HTML content. 

Because this book is not about creating HTML pages (i.e., pages that don’t have Canvas in them), we are not going to discuss the inner workings of CSS.
We will focus on only two of the most basic HTML tags: <code>&lt;div&gt;</code> and <code>&lt;canvas&gt;</code>.
<h3>&lt;div&gt;</h3>
This is the main HTML tag that we will use in this book. 

We will use it to position <code>&lt;canvas&gt;</code> on the HTML page.
Example 1-2</a> uses a <code>&lt;div&gt;</code> tag to position the words “Hello World!” on the screen, as shown in Figure 1-2.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893583.png" alt="HTML5 Hello World! with a &lt;div&gt;" width="188" height="102">
Figure 1-2. 

HTML5 Hello World! with a &lt;div&gt;
Example 1-2. 
HTML5 Hello World!
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH1EX2: Hello World HTML Page With A DIV &lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
Hello World!

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
The <code>style="position: absolute; top: 50px; left: 50px;"</code> code is an example of inline CSS in an HTML page. 

It tells the browser to render the content at the <code>absolute</code> position of <code>50</code> pixels from the top of the page, and <code>50</code> pixels from the left of the page.
<h3>&lt;canvas&gt;</h3>
Our work with <code>&lt;canvas&gt;</code> will benefit from using the absolute positioning method with <code>&lt;div&gt;</code>. 
We will place our <code>&lt;canvas&gt;</code> inside the <code>&lt;div&gt;</code> tag, and it will help us retrieve information, such as the relative position of the mouse pointer when it appears over a canvas.

<h2>The Document Object Model (DOM) and Canvas</h2>
The Document Object Model represents all the objects on an HTML page. 
It is language- and platform-neutral, allowing the content and style of the page to be updated after it is rendered in the web browser. 
The DOM is accessible through JavaScript, and has been a staple of JavaScript, DHTML, and CSS development since the late 1990s.

The <code>canvas</code> element itself is accessible through the DOM in a web browser via the Canvas 2D context, but the individual graphical elements created on Canvas are not accessible to the DOM. 
As we stated earlier, this is because Canvas works in immediate mode and does not have its own objects, only instructions on what to draw on any single frame.
Our first example will use the DOM to locate the <code>&lt;canvas&gt;</code> tag on the HTML5 page so that we can manipulate it with JavaScript. 
There are two specific DOM objects we will need to understand when we start using <code>&lt;canvas&gt;</code>: <code>window</code> and <code>document</code>.

The <code>window</code> object is the top level of the DOM. 
We will need to test this object to make sure all the assets and code have loaded before we can start our Canvas applications.
The <code>document</code> object contains all the HTML tags that are on the HTML page. 
We will need to look at this object to find the instance of <code>&lt;canvas&gt;</code> that manipulates with JavaScript.

<h2>JavaScript and Canvas</h2>
JavaScript, the programming language we will use to create Canvas applications, can be run inside nearly any web browser in existence. 
If you need a refresher on the topic, read Douglas Crockford’s <a href="http://oreilly.com/catalog/9780596517748/"><em>JavaScript: The Good Parts</em></a> (O’Reilly), which is a very popular and well-written reference on the subject.
<h3>JavaScript Frameworks and Libraries</h3>

There are many popular JavaScript frameworks that developers use to help get their JavaScript off the ground, including libraries such as jQuery, Processing.js, and others. 
We expect these frameworks to add robust support for Canvas in the next 6–12 months. 
In the meantime, we will focus on straight JavaScript to control the canvas. 
However, where appropriate, we will introduce you to frameworks and JavaScript libraries that will help augment Canvas development (e.g., Modernizr, JSColor, and WebGL).

<h3>Where Does JavaScript Go and Why?</h3>
Because we will create the programming logic for the Canvas in JavaScript, a question arises: where does that JavaScript go in the pages we have already created?
It’s a good idea to place your JavaScript in the <code>&lt;head&gt;</code> of your HTML page because it makes it easy to find. 
However, placing JavaScript there means that the entire HTML page needs to load before your JavaScript can work with the HTML. 

This also means that the JavaScript code will start to execute before the entire page loads. 
As a result, you will need to test to see whether the HTML page has loaded before you run your JavaScript program.
There has been a recent move to put JavaScript right before the <code>&lt;/body&gt;</code> at the end of an HTML document to make sure the whole page loads before the JavaScript runs. 
However, because we are going to test to see whether the page has loaded in JavaScript before we run our <code>&lt;canvas&gt;</code> program, we will put our JavaScript in the traditional <code>&lt;head&gt;</code> location. 

If you are not comfortable with this, you can adapt the style of the code to your liking.
No matter where you put the code, you can place it inline in the HTML page or load an <em>external .js</em> file. 
The code for loading an external JavaScript file might look like this:
&lt;script type="text/javascript" src="canvasapp.js"&gt;&lt;/script&gt;

To make things simple, we will code our JavaScript inline in the HTML page. 
However, if you know what you are doing, saving an external file and loading it will work just as well.
<h3>Note</h3>
In HTML5 you no longer have to specify the script type.

<h2>HTML5 Canvas “Hello World!”</h2>
As we just mentioned, one of the first things we need to do when putting Canvas on an HTML5 page is test to see whether the entire page has loaded and all HTML elements are present before we start performing any operations. 
This will become essential when we start working with images and sounds in Canvas.
To do this, you need to work with <em>events</em> in JavaScript. 

Events are dispatched by objects when a defined event occurs. 
Other objects listen for events so they can do something based on the event. 
Some common events that an object in JavaScript might listen for are key presses, mouse movements, and when something has finished loading.
The first event we need to listen for is a <code>window</code> object’s <code>load</code> event, which occurs when the HTML page has finished loading.

To add a <em>listener</em> for an event, use the <code>addEventListener()</code> method that belongs to objects that are part of the DOM. 
Because <code>window</code> represents the HTML page, it is the top level of the DOM.
The <code>addEventListener()</code> function accepts three arguments:

Event: <code>load</code>
This is the named event for which we are adding a listener. 
Events for existing objects like <code>window</code> are already defined.

Event handler function: <code>eventWindowLoaded()</code>
Call this function when the event occurs. 

In our code, we will then call the <code>canvasApp()</code> function, which will start our main application execution.
<code>useCapture</code>: <code>true</code> or <code>false</code>

This sets the function to capture this type of event before it propagates lower in the DOM tree of objects. 
We will always set this to <code>false</code>.

Below is the final code we will use to test to see whether the <code>window</code> has loaded:
window.addEventListener("load", eventWindowLoaded, false);
function eventWindowLoaded () {
 canvasApp();

}
Alternatively, you can set up an event listener for the <code>load</code> event in a number of other ways:
window.onload = function()
 { canvasApp(); }
or:
window.onload = canvasApp();
We will use the first method throughout this book.

<h3>Encapsulating Your JavaScript Code for Canvas</h3>
Now that we have created a way to test to see whether the HTML page has loaded, we can start creating our JavaScript application. 
Because JavaScript runs in an HTML page, it could be running with other JavaScript applications and code simultaneously. 
Usually, this does not cause any problems. 

However, there is a chance that your code might have variables or functions that conflict with other JavaScript code on the HTML page.
Canvas applications are a bit different from other apps that run in the web browser. 
Because Canvas executes its display in a defined region of the screen, its functionality is most likely self-contained, so it should not interfere with the rest of the page, and vice versa. 
You might also want to put multiple Canvas apps on the same page, so there must be some kind of separation of JavaScript when defining the code.

To avoid this issue, you can encapsulate your variables and functions by placing them inside another function. 
Functions in JavaScript are objects themselves, and objects in JavaScript can have both properties and methods. 
By placing a function inside another function, you are making the second function local in scope to the first function.
In our example, we are going to have the <code>canvasApp()</code> function that is called from the <code>window load</code> event contain our entire Canvas application. 

This “Hello World!” example will have one function named <code>drawScreen()</code>. 
As soon as <code>canvasApp()</code> is called, we will call <code>drawScreen()</code> immediately to draw our “Hello World!” text.
The <code>drawScreen()</code> function is now local to <code>canvasApp()</code>. 
Any variables or functions we create in <code>canvasApp()</code> will be local to <code>drawScreen()</code>, but not to the rest of the HTML page or other JavaScript applications that might be running.

Here is the sample code for how we will encapsulate functions and code for our Canvas applications:
function canvasApp() {
 drawScreen();
 ... function drawScreen() {
 ...
 }
}

<h3>Adding Canvas to the HTML Page</h3>
In the <code>&lt;body&gt;</code> section of the HTML page, add a <code>&lt;canvas&gt;</code> tag using code such as the following:
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
Now, let’s break this down to understand what we are doing. 
The <code>&lt;canvas&gt;</code> tag has three main <em>attributes</em>. 
In HTML, attributes are set within pointy brackets of an HTML tag. 

The three attributes we need to set are:
<code>id</code>

The <code>id</code> is the name we will use to reference this <code>&lt;canvas&gt;</code> tag in our JavaScript code. 
<code>canvasOne</code> is the name we will use.
<code>width</code>

The width, in pixels, of the canvas. 
The <code>width</code> will be <code>500</code> pixels.

<code>height</code>
The height, in pixels, of the canvas. 
The <code>height</code> will be <code>300</code> pixels.

<h3>Note</h3>
HTML5 elements, including <code>canvas</code>, have many more attributes: <code>tabindex</code>, <code>title</code>, <code>class</code>, <code>accesskey</code>, <code>dir</code>, <code>draggable</code>, <code>hidden</code>, etc.

Between the opening <code>&lt;canvas&gt;</code> and closing <code>&lt;/canvas&gt;</code> tags, you can put text that will be displayed if the browser executing the HTML page does not support Canvas. 
For our Canvas applications, we will use the text “Your browser does not support HTML5 Canvas.” However, you can adjust this text to say anything.
<h4>Using document to reference the canvas element in JavaScript</h4>
We will now make use of the DOM to reference the <code>&lt;canvas&gt;</code> we defined in HTML. 

Recall that the <code>document</code> object represents every element of an HTML page after it has loaded.
We need a reference to the <code>Canvas</code> object so that we will know where to display the Canvas API calls we will make from JavaScript.
First, we will define a new variable named <code>theCanvas</code> that will hold the reference to the <code>Canvas</code> object.
Next, we retrieve a reference to <code>canvasOne</code> by calling the <code>getElementById()</code> function of <code>document</code>, and passing the name <code>canvasOne</code>, which we defined as the id of the <code>&lt;canvas&gt;</code> tag we created in the HTML page:

var theCanvas = document.getElementById("canvasOne");
<h3>Testing to See Whether the Browser Supports Canvas</h3>
Now that we have a reference to the <code>canvas</code> element on the HTML page, we need to test to see whether it contains a <em>context</em>. 
The Canvas context refers to the drawing surface defined by a web browser to support Canvas. 

Simply put, if the context does not exist, neither does the canvas. 
There are several ways to test this. 
This first test looks to see whether the <code>getContext</code> method exists before we call it using Canvas, as we have already defined it in the HTML page:
if (!theCanvas || !theCanvas.getContext) { return;
}
Actually, this tests two things. 
First, it tests to see whether <code>theCanvas</code> does not contain <code>false</code> (the value returned by <code>document.getElementById()</code> if the named <code>id</code> does not exist). 

Then, it tests whether the <code>getContext()</code> function exists.
The <code>return</code> statement breaks out and stops execution if the test fails.
Another method—popularized by Mark Pilgrim on his HTML5 website, <a href="http://diveintohtml5.org">http://diveintohtml5.org</a>—uses a function with a test of a dummy canvas created for the sole purpose of seeing whether browser support exists:
function canvasSupport () { return !!document.createElement('testcanvas').getContext;

}
function canvasApp() {
 if (!canvasSupport) { return;
 }

}
Our favorite method is to use the <em>modernizr.js</em> library, which you can find here: <a href="http://www.modernizr.com/">http://www.modernizr.com/</a>. 
Modernizr—an easy-to-use, lightweight library for testing support for various web-based technologies—creates a set of static Booleans that you can test against to see whether Canvas is supported.
To include <em>modernizr.js</em> in your HTML page, download the code from <a href="http://www.modernizr.com/">http://www.modernizr.com/</a> and then include the <em>external .js</em> file in your HTML page:

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
To test for Canvas, change the <code>canvasSupport()</code> function to look like this:
function canvasSupport () {
 return Modernizr.canvas;

}
We are going to use the <em>modernizr.js</em> method because we think it offers the best approach for testing whether Canvas is supported in web browsers.
<h3>Retrieving the 2D Context</h3>
Finally, we need to get a reference to the 2D context so we can manipulate it. 

HTML5 Canvas is designed to work with multiple contexts, including a proposed 3D context. 
However, for the purposes of this book, we only need to get the 2D context:
var context = theCanvas.getContext("2d");
<h3>The drawScreen() Function</h3>

It’s time to create actual Canvas API code. 
Every operation we perform on Canvas will be through the <code>context</code> object, as it references the object on the HTML page.
We will delve into writing text, graphics, and images to HTML5 Canvas in later chapters, so for now, we will only spend a very short time on the code of the <code>drawScreen()</code> function.
The “screen” here is really the defined drawing area of the canvas, not the whole browser window. 

We refer to it as such because within the context of the games and applications you will write, it is effectively the “window” or “screen” into the canvas display that you will be manipulating.
The first thing we want to do is clear the drawing area. 
The following two lines of code draw a yellow box on the screen that is the same size as the canvas. 
<code>fillStyle()</code> sets the color, and <code>fillRect()</code> creates a rectangle and puts it on the screen:

context.fillStyle = "#ffffaa";
context.fillRect(0, 0, 500, 300);
<h3>Note</h3>
Notice that we are calling functions of the <code>context</code>. 

There are no screen objects, color objects, or anything else. 
This is an example of the immediate mode we described earlier.
Again, we will discuss the text functions of Canvas in the next chapter, but here is a short preview of the code we will use to put the text “Hello World!” on the screen.
First, we set the color of the text in the same way we set the color of the rectangle:

context.fillStyle = "#000000";
Then we set the font size and weight:
context.font = "20px _sans";
Next, we set the vertical alignment of the font:

context.textBaseline = "top";
Finally, we print our test on the screen by calling the <code>fillText()</code> method of the <code>context</code> object. 
The three parameters of this method are text string, <code>x</code> position, and <code>y</code> position:
context.fillText ("Hello World!", 195, 80);

Let’s add some graphics to our “Hello World!” text. 
First, let’s load in an image and display it. 
We will dive into images and image manipulation in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, but for now, let’s just get an image on the screen. 

To display an image on the canvas, you need to create an instance of the <code>Image()</code> object, and set the <code>Image.src</code> property to the name of the image to load.
<h3>Note</h3>
You can also use another canvas or a video as the image to display. 
We will discuss these topics in Chapters <a href="ch04.html" title="Chapter 4. 

Images on the Canvas">4</a> and <a href="ch06.html" title="Chapter 6. 
Mixing HTML5 Video and Canvas">6</a>.
Before you display it, you need to wait for the image to load. 
Create a <code>callback()</code> function for the <code>Image load</code> event by setting the <code>onload</code> function of the <code>Image</code> object. 

<code>callback()</code> will be executed when the <code>onload</code> event occurs. 
When the image has loaded, you then call <code>context.drawImage()</code>, passing three parameters to put it on the canvas: <code>Image</code> object, <code>x</code> position, and <code>y</code> position:
var helloWorldImage = new Image();
helloWorldImage.src = "helloworld.gif";

helloWorldImage.onload = function () {
 context.drawImage(helloWorldImage, 160, 130);
}
Finally, let’s draw a box around the text and the image. 

To draw a box with no fill, use the <code>context.StrokeStyle()</code> method to set a color for the stroke (the border of the box), and then call the <code>context.strokeRect()</code> method to draw the rectangle border. 
The four parameters for the <code>strokeRect()</code> method are the upper left <code>x</code> and <code>y</code> coordinates, and the lower right <code>x</code> and <code>y</code> coordinates:
context.strokeStyle = "#000000";
context.strokeRect(5, 5, 490, 290);

The full code for the HTML5 Hello World! application is shown in Example 1-3</a>, and its results are illustrated in <a href="ch01.html#html5_canvas_hello_world_exclamatio" title="Figure 1-3. 
HTML5 Canvas Hello World!">Figure 1-3</a>.
Example 1-3. 
HTML5 Canvas Hello World!

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH1EX3: Your First Canvas Application &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);

var Debugger = function () { };
Debugger.log = function (message) {
 try { console.log(message);
 } catch (exception) { return; }
}
function eventWindowLoaded () {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp () { if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 Debugger.log("Drawing Canvas");
 function drawScreen() { //background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, 500, 300); //text context.fillStyle = "#000000"; context.font = "20px _sans"; context.textBaseline = "top"; context.fillText ("Hello World!", 195, 80 );
 //image var helloWorldImage = new Image(); helloWorldImage.src = "helloworld.gif"; helloWorldImage.onload = function () { context.drawImage(helloWorldImage, 160, 130); }
 //box context.strokeStyle = "#000000"; context.strokeRect(5, 5, 490, 290);
 } drawScreen();
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893585.png" alt="HTML5 Canvas Hello World!" width="500" height="300">
Figure 1-3. 
HTML5 Canvas Hello World!
<h2>Debugging with Console.log</h2>
There is one more thing to discuss before we explore bigger and better things beyond “Hello World!” In this book, we have implemented a very simple debugging methodology using the <code>console.log</code> functionality of modern web browsers. 
This function lets you log text messages to the JavaScript console to help find problems (or opportunities!) with your code. 
Any browser that has a JavaScript console (Chrome, Opera, Safari, Firefox with Firebug installed) can make use of <code>console.log</code>. 
However, browsers without <code>console.log</code> support throw a nasty error.

To handle this error, we use a wrapper around <code>console.log</code> that only makes the call if the function is supported. 
The wrapper creates a class named <code>Debugger</code>, and then creates a static function named <code>Debugger.log</code> that can be called from anywhere in your code, like this:
Debugger.log("Drawing Canvas");
Here is the code for the <code>console.log()</code> functionality:

var Debugger = function () { };
Debugger.log = function (message) {
 try { console.log(message);
 } catch (exception) { return; }
}
<h2>The 2D Context and the Current State</h2>
The HTML5 2D context (the <code>CanvasRenderingContext2D</code> object), retrieved by a call to the <code>getContext()</code> method of the <code>Canvas</code> object, is where all the action takes place. 

The <code>CanvasRenderingContext2D</code> contains all the methods and properties we need to draw onto the canvas. 
The <code>CanvasRenderingContext2D</code> (or context, as we will call it hereafter) uses a Cartesian coordinate system with 0,0 at the upper left and corner of the canvas, and coordinates increasing in value to the left and down.
However, all of these properties and methods are used in conjunction with <em>current state</em>, a concept that must be grasped before you can really understand how to work with HTML5 Canvas. 
The current state is actually a stack of drawing states that apply globally to the entire canvas. 

You will manipulate these states when drawing on the canvas. 
These states include:
Transformation matrix

Methods for scale, rotate, transform, and translate
Clipping region

Created with the <code>clip()</code> method
Properties of the context

Properties include <code>strokeStyle</code>, <code>fillStyle</code>, <code>globalAlpha</code>, <code>lineWidth</code>, <code>lineCap</code>, <code>lineJoin</code>, <code>miterLimit</code>, <code>shadowOffsetX</code>, <code>shadowOffsetY</code>, <code>shadowBlur</code>, <code>shadowColor</code>, <code>globalCompositeOperation</code>, <code>font</code>, <code>textAlign</code>, and <code>textBaseline</code>.

Don’t worry; these should not look familiar to you just yet. 
We will discuss these properties in depth in the next three chapters.
Remember earlier in this chapter when we discussed immediate mode versus retained mode? The canvas is an immediate mode drawing surface, which means everything needs to be redrawn every time something changes. 
There are some advantages to this; for example, global properties make it very easy to apply effects to the entire screen. 

Once you get your head around it, the act of redrawing the screen every time there is an update makes the process of drawing to the canvas straightforward and simple.
On the other hand, retained mode is when a set of objects is stored by a drawing surface and manipulated with a display list. 
Flash and Silverlight work in this mode. 
Retained mode can be very useful for creating applications that rely on multiple objects with their own independent states. 

Many of the same applications that could make full use of the canvas (games, activities, animations) are often easier to code with a retained mode drawing surface, especially for beginners.
Our challenge is to take advantage of the immediate mode drawing surface, while adding functionality to our code to help it act more like it works in retained mode. 
Throughout this book we will discuss strategies that will help take this immediate mode operation and make it easier to manipulate through code.
<h2>The HTML5 Canvas Object</h2>
Recall that the <code>Canvas</code> object is created by placing the <code>&lt;canvas&gt;</code> tag in the <code>&lt;body&gt;</code> portion of an HTML page. 
You can also create an instance of a canvas in code like this:
var theCanvas = document.createElement("canvas");
The <code>Canvas</code> object has two associated properties and methods that can be accessed through JavaScript: <code>width</code> and <code>height</code>. 

These tell you the current width and height of the canvas rendered on the HTML page. 
It is important to note that they are <em>not</em> read-only; i.e., they can be updated in code and changed on an HTML page. 
What does this mean? It means you can dynamically resize the canvas on the HTML page without reloading.
<h3>Note</h3>

You can also use CSS styles to change the scale of the canvas. 
Unlike resizing, scaling takes the current canvas bitmapped area and resamples it to fit into the size specified by the <code>width</code> and <code>height</code> attributes of the CSS style. 
For example, to scale the canvas to a 400×400 area, you might use this CSS style:
style="width: 400px; height:400px"

We include an example of scaling the Canvas with a transformation matrix in <a href="ch03.html" title="Chapter 3. 
The HTML5 Canvas Text API">Chapter 3</a>.
There are also two public methods for the <code>Canvas</code> object. 
The first is <code>getContext()</code>, which we used earlier in this chapter. 

We will continue to use it throughout this book to retrieve a reference to the Canvas 2D context so we can draw onto the canvas. 
The second property is <code>toDataURL()</code>. 
This method will return a string of data that represents the bitmapped image of the <code>Canvas</code> object as it is currently rendered. 
It’s like a snapshot of the screen. 

By supplying different MIME types as a parameter, you can retrieve the data in different formats. 
The basic format is an <em>image/png</em>, but <em>image/jpeg</em> and other formats can be retrieved. 
We will use the <code>toDataURL()</code> in the next application to export an image of the canvas into another browser window.
<h2>Another Example: Guess The Letter</h2>
Now we will take a quick look at a more involved example of a “Hello World!”-type application, the game “Guess The Letter.” We’ve included this example to illustrate how much more Canvas programming is done in JavaScript than in the Canvas API.
In this game, shown in <a href="ch01.html#html5_canvas_guess_the_letter_game" title="Figure 1-4. 
HTML5 Canvas “Guess The Letter” game">Figure 1-4</a>, the player’s job is to guess the letter of the alphabet the computer has chosen randomly. 
The game keeps track of how many guesses the player has made, lists the letters he has already guessed, and tells the player whether he needs to guess higher (toward Z) or lower (toward A).

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893587.png" alt="HTML5 Canvas “Guess The Letter” game" width="500" height="326">
Figure 1-4. 
HTML5 Canvas “Guess The Letter” game
<h3>How the Game Works</h3>

This game is set up with the same basic structure as “Hello World!” <code>canvasApp()</code> is the main function, and all other functions are defined as local to <code>canvasApp()</code>. 
We use a <code>drawScreen()</code> function to render text on the canvas. 
However, there are some other functions included as well, which are described next.
<h3>The “Guess The Letter” Game Variables</h3>

Here is a rundown of the variables we will use in the game. 
They are all defined and initialized in <code>canvasApp()</code>, so they have scope to the encapsulated functions that we define locally.
<code>guesses</code>

This variable holds the number of times the player has pressed a letter. 
The lower the number, the better he has done in the game.

<code>message</code>
The content of this variable is displayed to give the user instructions on how to play.

<code>letters</code>
This array holds one of each letter of the alphabet. 
We will use this array to both randomly choose a secret letter for the game, and to figure out the relative position of the letter in the alphabet.

<code>today</code>
This variable holds the current date. 

It is displayed on the screen but has no other purpose.
<code>letterToGuess</code>

This variable holds the current game’s secret letter that needs to be guessed.
<code>higherOrLower</code>

This variable holds the text “Higher” or “Lower” depending on where the last guessed letter is in relation to the secret letter. 
If the secret letter is closer to “a,” we give the “Lower” instruction. 
If the letter is closer to “z,” we give the “Higher” instruction.

<code>lettersGuessed</code>
This array holds the current set of letters the player has guessed already. 
We will print this list on the screen to help the player remember what letters he has already chosen.

<code>gameOver</code>
This variable is set to <code>false</code> until the player wins. 

We will use this to know when to put the “You Win” message on the screen, and to keep the player from guessing after he has won.
Here is the code: var guesses = 0;
 var message = "Guess The Letter From a (lower) to z (higher)";
 var letters = [ "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o", "p","q","r","s","t","u","v","w","x","y","z" ];
 var today = new Date(); var letterToGuess = "";
 var higherOrLower = "";
 var lettersGuessed;
 var gameOver = false;

<h3>The initGame() Function</h3>
The <code>initGame()</code> function sets up the game for the player. 
The two most important blocks of code are as follows. 
This code finds a random letter from the letters array and stores it in the <code>letterToGuess</code> variable:

var letterIndex = Math.floor(Math.random() * letters.length);
letterToGuess = letters[letterIndex];
This code adds an event listener to the <code>window</code> object of the DOM to listen for the keyboard <code>keyup</code> event. 
When a key is pressed, the <code>eventKeyPressed</code> event handler is called to test the letter pressed:

window.addEventListener("keyup",eventKeyPressed,true);
Here is the full code for the function:
function initGame() {
 var letterIndex = Math.floor(Math.random() * letters.length); letterToGuess = letters[letterIndex];
 guesses = 0;
 lettersGuessed = [];
 gameOver = false; window.addEventListener("keyup",eventKeyPressed,true);
 drawScreen();
}
<h3>The eventKeyPressed() Function</h3>

This function, called when the player presses a key, contains most of the action in this game. 
Every event handler function in JavaScript is passed an <code>event</code> object that has information about the event that has taken place. 
We use the <code>e</code> argument to hold that object.
The first test we make is to see whether the <code>gameOver</code> variable is <code>false</code>. 

If so, we continue to test the key that was pressed by the player; the next two lines of code are used for that purpose. 
The first line of code gets the key-press value from the event, and converts it to an alphabetic letter that we can test with the letter stored in <code>letterToGuess</code>:
var letterPressed = String.fromCharCode(e.keyCode);
The next line of code converts the letter to lowercase so that we can test uppercase letters if the player unintentionally has Caps Lock on:

letterPressed = letterPressed.toLowerCase();
Next, we increase the <code>guesses</code> count to display, and use the <code>Array.push()</code> method to add the letter to the <code>lettersGuessed</code> array:
guesses++;
lettersGuessed.push(letterPressed);

Now it is time to test the current game state to give feedback to the player. 
First, we test to see whether <code>letterPressed</code> is equal to <code>letterToGuess</code>. 
If so, the player has won the game:
if (letterPressed == letterToGuess) { gameOver = true;
If the player has not won, we need to get the index of <code>letterToGuess</code> and the index of <code>letterPressed</code> in the <code>letters</code> array. 
We are going to use these values to figure out whether we should display “Higher,” “Lower,” or “That is not a letter.” To do this, we use the <code>indexOf()</code> array method to get the relative index of each letter. 
Because we alphabetized the letters in the array, it is very easy to test which message to display:

} else {
 letterIndex = letters.indexOf(letterToGuess);
 guessIndex = letters.indexOf(letterPressed);
Now we make the test. 

First, if <code>guessIndex</code> is less than zero, it means that the call to <code>indexOf()</code> returned <code>-1</code>, and the key press was not a letter. 
We then display an error message:
if (guessIndex &lt; 0) {
 higherOrLower = "That is not a letter";

The rest of the tests are simple. 
If <code>guessIndex</code> is greater than <code>letterIndex</code>, we set the <code>higherOrLower</code> text to “Lower.” Conversely, if <code>guessIndex</code> is less than <code>letterIndex</code>, we set the <code>higherOrLower</code> test to “Higher”:
 } else if (guessIndex &gt; letterIndex) { higherOrLower = "Lower";
 } else { higherOrLower = "Higher"; }
}
Finally, we call <code>drawScreen()</code> to paint the screen:
drawScreen();

Here is the full code for the function:
function eventKeyPressed(e) { if (!gameOver) { var letterPressed = String.fromCharCode(e.keyCode); letterPressed = letterPressed.toLowerCase(); guesses++; lettersGuessed.push(letterPressed);
 if (letterPressed == letterToGuess) { gameOver = true; } else {
 letterIndex = letters.indexOf(letterToGuess); guessIndex = letters.indexOf(letterPressed); Debugger.log(guessIndex); if (guessIndex &lt; 0) { higherOrLower = "That is not a letter"; } else if (guessIndex &gt; letterIndex) { higherOrLower = "Lower"; } else { higherOrLower = "Higher"; } } drawScreen(); }
 }
<h3>The drawScreen() Function</h3>
Now we get to <code>drawScreen()</code>. 

The good news is that we have seen almost all of this before—there are only a few differences from “Hello World!” For example, we paint multiple variables on the screen using the Canvas Text API. 
We only set <code>context.textBaseline = 'top';</code> once for all the text we are going to display. 
Also, we change the color using <code>context.fillStyle</code>, and the font with <code>context.font</code>.
The most interesting thing we display here is the content of the <code>lettersGuessed</code> array. 

On the canvas, the array is printed as a set of comma-separated values, like this:
<table><tr><td><code>Letters Guessed: p,h,a,d</code></td></tr></table>
To print this value, all we do is use the <code>toString()</code> method of the <code>lettersGuessed</code> array, which prints out the values of an array as—you guessed it—comma-separated values:
context.fillText ("Letters Guessed: " + lettersGuessed.toString(), 10, 260);

We also test the <code>gameOver</code> variable. 
If it is <code>true</code>, we put <em>You Got It!</em> on the screen in giant <code>40px</code> text so the user knows he has won.
Here is the full code for the function:
function drawScreen() { //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, 500, 300); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, 490, 290); context.textBaseline = "top"; //Date context.fillStyle = "#000000"; context.font = "10px _sans"; context.fillText (today, 150 ,10); //Message context.fillStyle = "#FF0000"; context.font = "14px _sans"; context.fillText (message, 125, 30); //Guesses context.fillStyle = "#109910"; context.font = "16px _sans"; context.fillText ('Guesses: ' + guesses, 215, 50); //Higher Or Lower context.fillStyle = "#000000"; context.font = "16px _sans"; context.fillText ("Higher Or Lower: " + higherOrLower, 150,125); //Letters Guessed context.fillStyle = "#FF0000"; context.font = "16px _sans"; context.fillText ("Letters Guessed: " + lettersGuessed.toString(), 10, 260); if (gameOver) { context.fillStyle = "#FF0000"; context.font = "40px _sans"; context.fillText ("You Got It!", 150, 180); }
 }
<h3>Exporting Canvas to an Image</h3>
Earlier, we briefly discussed the <code>toDataUrL()</code> property of the <code>Canvas</code> object. 

We are going to use that property to let the user create an image of the game screen at any time. 
This acts almost like a screen-capture utility for games made on Canvas.
We need to create a button in the HTML page that the user can press to get the screen capture. 
We will add this button to <code>&lt;form&gt;</code> and give it the id <code>createImageData</code>:

&lt;form&gt;
&lt;input type="button" value="Export Canvas Image"&gt;
&lt;/form&gt;
In the <code>init()</code> function, we retrieve a reference to that form element by using the <code>getElementById()</code> method of the <code>document</code> object. 

We then set an event handler for the button “click” event as the function <code>createImageDataPressed()</code>:
var formElement = document.getElementById("createImageData");
formElement.addEventListener('click', createImageDataPressed, false);
In <code>canvasApp()</code>, we define the <code>createImageDataPressed()</code> function as an event handler. 

This function calls <code>window.open()</code>, passing the return value of the <code>Canvas.toDataUrl()</code> method as the source for the window. 
Since this data forms a valid <em>PNG</em>, the image is displayed in the new window:
function createImageDataPressed(e) {
 window.open(theCanvas.toDataURL(),"canvasImage","left=0,top=0,width=" +  theCanvas.width + ",height=" + theCanvas.height +",toolbar=0,resizable=0");
 }
<h3>Note</h3>
We will discuss this process in depth in <a href="ch03.html" title="Chapter 3. 

The HTML5 Canvas Text API">Chapter 3</a>.
<h3>The Final Game Code</h3>
Example 1-4</a> shows the full code for the Guess The Letter game.
Example 1-4. 

Guess The Letter game
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH1EX4: Guesss The Letter Game&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
var Debugger = function () { };
Debugger.log = function (message) {
 try { console.log(message); } catch (exception) { return;
 }
}
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function eventWindowLoaded() {
 canvasApp();
}
function canvasApp() { var guesses = 0;
 var message = "Guess The Letter From a (lower) to z (higher)";
 var letters = [ "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o", "p","q","r","s","t","u","v","w","x","y","z" ];
 var today = new Date(); var letterToGuess = "";
 var higherOrLower = "";
 var lettersGuessed;
 var gameOver = false; if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 initGame(); function initGame() { var letterIndex = Math.floor(Math.random() * letters.length); letterToGuess = letters[letterIndex]; guesses = 0; lettersGuessed = []; gameOver = false; window.addEventListener("keyup",eventKeyPressed,true); var formElement = document.getElementById("createImageData"); formElement.addEventListener('click', createImageDataPressed, false); drawScreen();
 }
 function eventKeyPressed(e) { if (!gameOver) { var letterPressed = String.fromCharCode(e.keyCode); letterPressed = letterPressed.toLowerCase(); guesses++; lettersGuessed.push(letterPressed);
 if (letterPressed == letterToGuess) { gameOver = true; } else { letterIndex = letters.indexOf(letterToGuess); guessIndex = letters.indexOf(letterPressed); Debugger.log(guessIndex); if (guessIndex &lt; 0) { higherOrLower = "That is not a letter"; } else if (guessIndex &gt; letterIndex) { higherOrLower = "Lower"; } else { higherOrLower = "Higher"; }
 } drawScreen(); }
 }
 function drawScreen() { //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, 500, 300); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, 490, 290); context.textBaseline = "top"; //Date context.fillStyle = "#000000"; context.font = "10px _sans"; context.fillText (today, 150 ,10); //Message context.fillStyle = "#FF0000"; context.font = "14px _sans"; context.fillText (message, 125, 30); //Guesses context.fillStyle = "#109910"; context.font = "16px _sans"; context.fillText ('Guesses: ' + guesses, 215, 50); //Higher Or Lower context.fillStyle = "#000000"; context.font = "16px _sans"; context.fillText ("Higher Or Lower: " + higherOrLower, 150,125); //Letters Guessed context.fillStyle = "#FF0000"; context.font = "16px _sans"; context.fillText ("Letters Guessed: " + lettersGuessed.toString(), 10, 260); if (gameOver) { context.fillStyle = "#FF0000"; context.font = "40px _sans"; context.fillText ("You Got It!", 150, 180); } }
 function createImageDataPressed(e) {
 window.open(theCanvas.toDataURL(),"canvasImage","left=0,top=0,width=" + theCanvas.width + ",height=" + theCanvas.height +",toolbar=0,resizable=0"); 
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;form&gt;
&lt;input type="button" value="Export Canvas Image"&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h2>What’s Next</h2>
So now you should have a basic understanding of the HTML and JavaScript we will use to render and control HTML5 Canvas on an HTML page. 

In the next chapter, we will take this information and expand on it to create an interactive application that uses the canvas to render information on the screen.
 2. 
Drawing on the Canvas" epub:type="chapter">
<h2><span class="orange">Chapter 2. Drawing on the Canvas</span></h2>
Using HTML5 Canvas effectively requires a strong foundation in drawing, coloring, and transforming basic two-dimensional shapes. 
While the selection of built-in shapes is relatively limited, we can draw any shape we desire using a series of line segments called <em>paths</em>, which we will discuss in the upcoming section Using Paths to Create Lines</a>.
<h3>Note</h3>

The HTML5 Canvas API is well covered in many online forms. 
The W3C site has an exhaustive and constantly updated reference that details the features of the Canvas 2D Drawing API. 
It can be viewed at <a href="http://dev.w3.org/2006/canvas-api/canvas-2d-api.html">http://dev.w3.org/2006/canvas-api/canvas-2d-api.html</a>.
However, this online reference lacks concrete examples on using the API. 

Rather than simply reprinting this entire specification, we will spend our time creating examples to explain and explore as many features as we have space to cover.
<h2>The Basic File Setup for This Chapter</h2>
As we proceed through the Drawing API, all the examples in this chapter will use the same basic file setup, shown below. 
Use this code as the basis for all of the examples we create. 

You will only have to change the contents of the <code>drawScreen()</code> function:
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;Ch2BaseFile - Template For Chapter 2 Examples&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasSupport () { return Modernizr.canvas;
}
function canvasApp(){
if (!canvasSupport()) { return; }else{ var theCanvas = document.getElementById("canvas"); var context = theCanvas.getContext("2d"); }
 drawScreen();
 function drawScreen() { <strong>//make changes here.</strong> context.fillStyle = '#aaaaaa'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#000000'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Canvas!", 0, 0);
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h2>The Basic Rectangle Shape</h2>
Let’s get our feet wet by looking at the single primitive, built-in geometric shape on Canvas—the rectangle. 
On Canvas, basic rectangle shapes can be drawn in three different ways: filling, stroking, or clearing. 
We can also build rectangles (or any other shape) by using paths, which we will cover in the next section.
First, let’s look at the API functions used for these three operations:

<code>fillRect(x,y,width,height)</code>
Draws a filled rectangle at position <code>x</code>,<code>y</code> for width and height.

<code>strokeRect(x,y,width,height)</code>
Draws a rectangular outline at position <code>x</code>,<code>y</code> for width and height. 

This makes use of the current <code>strokeStyle</code></a>, <code>lineWidth</code></a>, <code>lineJoin</code></a>, and <code>miterLimit</code></a> settings.
<code>clearRect(x,y,width,height)</code>

Clears the specified area and makes it fully transparent (using transparent black as the color) starting at position <code>x</code>,<code>y</code> for width and height.
Before we can use any of these functions, we will need to set up the fill or stroke style that will be used when drawing to the canvas.

The very basic way to set these styles is to use a color value represented by a 24-bit hex string. 
Here is an example from our first demonstration:
context.fillStyle = '#000000';
context.strokeStyle = '#ff00ff';

In Example 2-1</a>, the fill style is simply set to be the RGB color black, while the stroke style is a classic purple color. 
The results are shown in <a href="ch02.html#basic_rectangles-id1" title="Figure 2-1. 
Basic rectangles">Figure 2-1</a>:
Example 2-1. 

Basic rectangles
function drawScreen() { context.fillStyle = '#000000'; context.strokeStyle = '#ff00ff'; context.lineWidth = 2; context.fillRect(10,10,40,40); context.strokeRect(0, 0,60,60); context.clearRect(20,20,20,20);
}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893589.png" alt="Basic rectangles" width="61" height="61">

Figure 2-1. 
Basic rectangles
<h2>The Canvas State</h2>
When we draw on the Canvas context, we can make use of a stack of so-called drawing <em>states</em>. 

Each of these states stores data about the Canvas context at any one time. 
Here is a list of the data stored in the stack for each state:

Transformation matrix information such as rotations or translations using the <code>context.rotate()</code> and <code>context.setTransform()</code> methods
The current clipping region

The current values for canvas attributes, such as (but not limited to):

<code>globalAlpha</code>
<code>globalCompositeOperation</code>
<code>strokeStyle</code>
<code>textAlign</code>, <code>textBaseline</code>

<code>lineCap</code>, <code>lineJoin</code>, <code>lineWidth</code>, <code>miterLimit</code>
<code>fillStyle</code>
<code>font</code>
<code>shadowBlur</code>, <code>shadowColor</code>, <code>shadowOffsetX</code>, and <code>shadowOffsetY</code>

We will cover these states later in this chapter.

<h3>What’s Not Part of the State?</h3>
The current path (which we will explore later in this chapter) and current bitmap (see <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>) being manipulated on the Canvas context are <em>not</em> part of the saved state. 
This very important feature will allow us to draw and animate individual objects on the canvas. 

The section Simple Canvas Transformations</a> utilizes the Canvas state to apply transformations to only the current shape being constructed and drawn, leaving the rest of the canvas not transformed.
<h3>How Do We Save and Restore the Canvas State?</h3>
To save (push) the current state to the stack, call:
context.save()

To restore the canvas by “popping” the last state saved to the stack, use:
context.restore()
<h2>Using Paths to Create Lines</h2>
Paths are a method we can use to draw any shape on the canvas. 

A path is simply a list of points, and lines to be drawn between those points. 
A Canvas context can only have a single “current” path, which is not stored as part of the current drawing state when the <code>context.save()</code> method is called.
Context for paths is a critical concept to understand, because it will enable you to transform only the current path on the canvas.
<h3>Starting and Ending a Path</h3>

The <code>beginPath()</code> function call starts a path, and the <code>closePath()</code> function call ends the path. 
When you connect two points inside a path, it is referred to as a <em>subpath</em>. 
A subpath is considered “closed” if the final point connects to the first point.
<h3>Note</h3>

The current transformation matrix will affect everything drawn in this path. 
As we will see when we explore the upcoming section on transformations, we will always want to set the transformation matrix to the identity (or reset) if we do not want any transformation applied to a path.
<h3>The Actual Drawing</h3>
The most basic path is controlled by a series of <code>moveTo()</code> and <code>lineTo()</code> commands, as shown in Example 2-2</a>.

Example 2-2. 
A simple line path
function drawScreen() {
 context.strokeStyle = "black"; //need list of available colors context.lineWidth = 10;
 context.lineCap = 'square';
 context.beginPath();
 context.moveTo(20, 0); context.lineTo(100, 0);
 context.stroke();
 context.closePath();
}

<a href="ch02.html#a_simple_line_path-id1" title="Figure 2-2. 
A simple line path">Figure 2-2</a> shows an example of this output.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893591.png" alt="A simple line path" width="90" height="5">
Figure 2-2. 

A simple line path
Example 2-2</a> simply draws a 10-pixel-wide horizontal line (or stroke) from position 20,0 to position 100,0.
We have also added the <code>lineCap</code> and <code>strokeStyle</code> attributes. 
Let’s take a brief look at the various attributes we can apply to a line before we move on to some more advanced drawing.

<h4>lineCap attributes</h4>
<h5>context.lineCap</h5>
The <code>lineCap</code> is the end of a line drawn on the context. 
It can be one of three values:

<code>butt</code>
The default; a flat edge that is perpendicular to the edge of the line.

<code>round</code>
A semicircle that will have a diameter that is the length of the line.

<code>square</code>
A rectangle with the length of the line width and the width of half the line width placed flat perpendicular to the edge of the line.

<h4>lineJoin attributes</h4>
<h5>context.lineJoin</h5>

The <code>lineJoin</code> is the “corner” that is created when two lines meet. 
This is called a <em>join</em>. 
A filled triangle is created at the join, and we can set its basic properties with the <code>lineJoin</code> Canvas attribute.

<code>miter</code>
The default; an edge is drawn at the join. 
The <code>miterLimit</code> is the maximum allowed ratio of miter length to line width (the default is 10).

<code>bevel</code>
A diagonal edge is drawn at the join.

<code>round</code>
A round edge is drawn at the join.

<h4>lineWidth</h4>
The <code>lineWidth</code> (default = 1.0) depicts the thickness of the line.

<h4>strokeStyle</h4>
The <code>strokeStyle</code> defines the color or style that will be used for lines and around shapes (as we saw with the simple rectangles in Example 2-2</a>).
<h3>Examples of More Advanced Line Drawing</h3>
Example 2-3</a> shows these attributes in action; the results are depicted in <a href="ch02.html#line_cap_and_join-id1" title="Figure 2-3. 

Line cap and join">Figure 2-3</a>. 
There are a few oddities when drawing lines on the canvas, which we will point out along the way.
Example 2-3. 
Line cap and join

function drawScreen() {
 <strong>// Sample 1: round end, bevel join, at top left of canvas</strong> context.strokeStyle = "black"; //need list of available colors context.lineWidth = 10; context.lineJoin = 'bevel'; context.lineCap = 'round'; context.beginPath(); context.moveTo(0, 0); context.lineTo(25, 0); context.lineTo(25,25); context.stroke(); context.closePath();
 <strong>// Sample 2: round end, bevel join, not at top or left of canvas</strong> context.beginPath(); context.moveTo(10, 50); context.lineTo(35, 50); context.lineTo(35,75); context.stroke(); context.closePath();
 <strong>// Sample 3: flat end, round join, not at top or left of canvas</strong> context.lineJoin = 'round'; context.lineCap = 'butt'; context.beginPath(); context.moveTo(10, 100); context.lineTo(35, 100); context.lineTo(35,125); context.stroke(); context.closePath(); }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893593.png" alt="Line cap and join" width="40" height="125">
Figure 2-3. 
Line cap and join

These three line and join samples should help illustrate some of the combinations of attributes we can use to draw paths on the canvas.
The first sample attempts to draw starting at the top left of the canvas, resulting in a strange image. 
Canvas paths are drawn outward in both the <em>x</em> and <em>y</em> directions from the center of the pixel it begins on. 
For this reason, the top line in Sample 1 seems to be thinner than the 10 pixels we specified. 

In addition, the “round” end of the top-left horizontal line segment cannot be seen because both of these were drawn off the screen in the “negative” value areas of the screen coordinates. 
Furthermore, the diagonal “bevel” at the <code>lineJoin</code> is not drawn.
Sample 2 rectifies the problems in Sample 1 by offsetting the beginning of the drawing away from the top left. 
This allows the entire horizontal line to be drawn, as well as the “round” <code>lineCap</code> and the “bevel” <code>lineJoin</code>.

Sample 3 shows us eliminating the extra <code>lineCap</code> in favor of the default “butt,” and changing the <code>lineJoin</code> to “round.”
<h2>Advanced Path Methods</h2>
Let’s take a deeper look at some of the other methods we can use to draw paths on the canvas, including arcs and curves that can be combined to create complex images.
<h3>Arcs</h3>

There are four functions we can use to draw arcs and curves onto the canvas. 
An arc can be a complete circle or any part of a circle
<h4>context.arc</a>()</h4>
context.arc(x, y, radius, startAngle, endAngle, anticlockwise)

The <code>x</code> and <code>y</code> values define the center of our circle, and the <code>radius</code> will be the radius of the circle upon which our arc will be drawn. 
<code>startAngle</code> and <code>endAngle</code> are in radians, not degrees. 
<code>anticlockwise</code> is a <code>true</code> or <code>false</code> value that defines the direction of the arc.
For example, if we want to draw a circle with a center point at position 100,100 and with a radius of 20, as shown in <a href="ch02.html#a_basic_circle_arc" title="Figure 2-4. 

A basic circle arc">Figure 2-4</a>, we could use the code below for the contents of <code>drawScreen()</code>:
context.arc(100, 100, 20, (Math.PI/180)*0, (Math.PI/180)*360, false);
Example 2-4</a> illustrates the code necessary to create a simple circle.
Example 2-4. 

A circle arc
function drawScreen() {
 context.beginPath(); context.strokeStyle = "black"; context.lineWidth = 5; context.arc(100, 100, 20, (Math.PI/180)*0, (Math.PI/180)*360, false);
 //full circle context.stroke(); context.closePath();

}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893595.png" alt="A basic circle arc" width="46" height="46">
Figure 2-4. 
A basic circle arc

Notice that we have to convert our start angle (<code>0</code>) and our end angle (<code>360</code>) into radians by multiplying them by (<code>Math.PI/180</code>). 
By using <code>0</code> as the start angle and <code>360</code> as the end, we create a full circle.
We can also draw a segment of a circle by not specifying the entire 0 to 360 start and stop angles. 
This code for <code>drawScreen()</code> will create one-quarter of a circle drawn clockwise, as shown in <a href="ch02.html#a_one-quarter_circle_arc" title="Figure 2-5. 

A one-quarter circle arc">Figure 2-5</a>:
context.arc(100, 200, 20, (Math.PI/180)*0, (Math.PI/180)*90, false);
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893597.png" alt="A one-quarter circle arc" width="23" height="23">
Figure 2-5. 

A one-quarter circle arc
If we want to draw everything <em>but</em> the 0–90 angle, as shown in <a href="ch02.html#a_three-fourths_circle_arc" title="Figure 2-6. 
A three-fourths circle arc">Figure 2-6</a>, we can employ the <code>anticlockwise</code> argument and set it to <code>true</code>:
context.arc(100, 200, 20, (Math.PI/180)*0, (Math.PI/180)*90, true);

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893599.png" alt="A three-fourths circle arc" width="46" height="46">
Figure 2-6. 
A three-fourths circle arc
<h4>context.arcTo</a>()</h4>

context.arcTo(x1, y1, x2, y2, radius)
The <code>arcTo</code> method has only been implemented in the latest browsers—perhaps because its capabilities can be replicated by the <code>arc()</code> function. 
It takes in a point (<code>x1</code>,<code>y1</code>) and draws a straight line from the current path position to this new position. 
Then it draws an arc from that point to the <code>y1</code>,<code>y2</code> point using the given radius.

The <code>context.arcTo</code> method will work only if the current path has at least one subpath. 
So, let’s start with a line from position 0,0 to position 100,200. 
Then we will build our small arc. 
It will look a little like a bent wire coat hanger (for lack of a better description), as shown in <a href="ch02.html#an_arcto_open_parenthesis_close_parenthe" title="Figure 2-7. 

An arcTo() example">Figure 2-7</a>:
context.moveTo(0,0);
context.lineTo(100, 200);
context.arcTo(350,350,100,100,20);

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893601.png" alt="An arcTo() example" width="244" height="272">
Figure 2-7. 
An arcTo() example
<h3>Bezier Curves</h3>

Bezier curves, which are far more flexible than arcs, come in both the cubic and quadratic types:

<code>context.</code><code>bezierCurveTo</code></a><code>(</code><em><code>cp1x, cp1y, cp2x, cp2y, x, y</code></em><code>)</code>

<code>context.</code><code>quadraticCurveTo</code></a><code>(</code><em><code>cpx, cpy, x, y</code></em><code>)</code>

The Bezier curve is defined in 2D space by a “start point,” an “end point,” and one or two “control” points, which determine how the curve will be constructed on the canvas. 

A normal cubic Bezier curve uses two points, while a quadric version uses a single point.
The quadratic version, shown in <a href="ch02.html#a_simple_quadratic_bezier_curve" title="Figure 2-8. 
A simple quadratic Bezier curve">Figure 2-8</a>, is the simplest, only needing the end point (last) and a single point in space to use as a control point (first):
context.moveTo(0,0);

context.quadraticCurveTo(100,25,0,50);
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893603.png" alt="A simple quadratic Bezier curve" width="53" height="53">
Figure 2-8. 
A simple quadratic Bezier curve

This curve starts at <code>0,0</code> and ends at <code>0,50</code>. 
The point in space we use to create our arc is <code>100,25</code>. 
This point is roughly the center of the arc vertically. 
The <code>100</code> value for the single control point pulls the arc out to make an elongated curve.

The cubic Bezier curve offers more options because we have two control points to work with. 
The result is that curves—such as the classic “S” curve shown in <a href="ch02.html#a_bezier_curve_with_two_control_points" title="Figure 2-9. 
A Bezier curve with two control points">Figure 2-9</a>—are easier to make:
context.moveTo(150,0);

context.bezierCurveTo(0,125,300,175,150,300);
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893605.png" alt="A Bezier curve with two control points" width="92" height="302">
Figure 2-9. 
A Bezier curve with two control points

<h3>The Canvas Clipping Region</h3>
Combining the <code>save()</code> and <code>restore()</code> functions with the Canvas clip region limits the drawing area for a path and its subpaths. 
We do this by first setting <code>rect()</code> to a rectangle that encompasses the region we would like to draw in, and then calling the <code>clip()</code> function. 
This will set the clip region to be the rectangle we defined with the <code>rect()</code> method call. 

Now, no matter what we draw onto the current context, it will only display the portion that is in this region. 
Think of this as a sort of mask that you can use for your drawing operations. 
Example 2-5</a> shows how this works, producing the clipped result shown in <a href="ch02.html#the_canvas_clipping_region-id2" title="Figure 2-10. 
The Canvas clipping region">Figure 2-10</a>.

Example 2-5. 
The Canvas clipping region
function drawScreen() {
 //draw a big box on the screen context.fillStyle = "black"; context.fillRect(10, 10, 200, 200); context.save(); context.beginPath(); //clip the canvas to a 50×50 square starting at 0,0 context.rect(0, 0, 50, 50); context.clip();
 //red circle context.beginPath(); context.strokeStyle = "red"; //need list of available colors context.lineWidth = 5; context.arc(100, 100, 100, (Math.PI/180)*0, (Math.PI/180)*360, false); //full circle context.stroke(); context.closePath();
 context.restore();
 //reclip to the entire canvas context.beginPath(); context.rect(0, 0, 500, 500); context.clip(); //draw a blue line that is not clipped context.beginPath(); context.strokeStyle = "blue"; //need list of available colors context.lineWidth = 5; context.arc(100, 100, 50, (Math.PI/180)*0, (Math.PI/180)*360, false); //full circle context.stroke(); context.closePath();
}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893607.png.jpg" alt="The Canvas clipping region" width="217" height="217">
Figure 2-10. 

The Canvas clipping region
Example 2-5</a> first draws a large 200×200 black rectangle onto the canvas. 
Next, we set our Canvas clipping region to <code>rect(0,0,50,50)</code>. 
The <code>clip()</code> call then clips the canvas to those specifications. 

When we draw our full red circle arc, we only see the portion inside this rectangle. 
Finally, we set the clipping region back to <code>rect(0,0,500,500)</code> and draw a new blue circle. 
This time, we can see the entire circle on the canvas.
<h3>Note</h3>

Other Canvas methods can be used with the clipping region. 
The most obvious is the <code>arc()</code> function:
arc(<em><code>float</code></em> x, <em><code>float</code></em> y, <em><code>float</code></em> radius, <em><code>float</code></em> startAngle,
<em><code>float</code></em> endAngle, <em><code>boolean</code></em> anticlockwise)

This can be used to create a circular clipping region instead of a rectangular one.
<h2>Compositing on the Canvas</h2>
Compositing refers to how finely we can control the transparency and layering effects of objects as we draw them to the canvas. 
There are two attributes we can use to control Canvas compositing operations: <code>globalAlpha</code> and <code>globalCompositeOperation</code>.

<code>globalAlpha</code>
The <code>globalAlpha</code> Canvas property defaults to <code>1.0</code> (completely opaque) and can be set from <code>0.0</code> (completely transparent) through <code>1.0</code>. 

This Canvas property must be set before a shape is drawn to the canvas.
<code>globalCompositeOperation</code>

The <code>globalCompositeOperation</code> value controls how shapes are drawn into the current Canvas bitmap after both <code>globalAlpha</code> and any transformations have been applied (see the next section, Simple Canvas Transformations</a>, for more information).
In the following list, the “source” is the shape we are about to draw to the canvas, and the “destination” refers to the current bitmap displayed on the canvas.
<code>copy</code>

Where they overlap, displays the source and not the destination.
<code>destination-atop</code>

Destination atop the source. 
Where the source and destination overlap and both are opaque, displays the destination image. 
Displays the source image wherever the source image is opaque but the destination image is transparent. 

Displays transparency elsewhere.
<code>destination-in</code>

Destination in the source. 
Displays the destination image wherever both the destination image and source image are opaque. 
Displays transparency elsewhere.

<code>destination-out</code>
Destination out source. 
Displays the destination image wherever the destination image is opaque and the source image is transparent. 

Displays transparency elsewhere.
<code>destination-over</code>

Destination over the source. 
Displays the destination image wherever the destination image is opaque. 
Displays the source image elsewhere.

<code>lighter</code>
Source plus destination. 
Displays the sum of the source image and destination image, with color values approaching <code>1.0</code> as a limit.

<code>source-atop</code>
Source atop the destination. 

Displays the source image wherever both images are opaque. 
Displays the destination image wherever the destination image is opaque but the source image is transparent. 
Displays transparency elsewhere.

<code>source-in</code>
Source in the destination. 
Displays the source image wherever both the source image and destination image are opaque. 

Displays transparency elsewhere.
<code>source-out</code>

Source out destination. 
Displays the source image wherever the source image is opaque and the destination image is transparent. 
Displays transparency elsewhere.

<code>source-over</code>
(Default.) Source over destination. 
Displays the source image wherever the source image is opaque. 

Displays the destination image elsewhere.
<code>xor</code>

Source <code>xor</code> destination. 
Exclusive OR of the source image and destination image.

Example 2-6</a> shows how some of these values can affect how shapes are drawn to the canvas, producing <a href="ch02.html#canvas_compositing_example-id1" title="Figure 2-11. 
Canvas compositing example">Figure 2-11</a>.

Example 2-6. 
Canvas compositing example
function drawScreen() {
 //draw a big box on the screen context.fillStyle = "black"; // context.fillRect(10, 10, 200, 200); //leave globalCompositeOperation as is //now draw a red square context.fillStyle = "red"; context.fillRect(1, 1, 50, 50);
 //now set it to source-over context.globalCompositeOperation = "source-over"; //draw a red square next to the other one context.fillRect(60, 1, 50, 50);
 //now set to destination-atop context.globalCompositeOperation = "destination-atop"; context.fillRect(1, 60, 50, 50);
 //now set globalAlpha context.globalAlpha = .5; //now set to source-atop context.globalCompositeOperation = "source-atop"; context.fillRect(60, 60, 50, 50);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893609.png" alt="Canvas compositing example" width="209" height="209">
Figure 2-11. 

Canvas compositing example
As you can see in this example, we have toyed a little with both the <code>globalComposite</code><code>Operation</code> and the <code>globalAlpha</code> Canvas properties. 
When we assign the string <code>source-over</code>, we are essentially resetting the <code>globalCompositeOperation</code> back to the default. 
We then create some red squares to demonstrate a few of the various compositing options and combinations. 

Notice that <code>destination-atop</code> switches the newly drawn shapes under the current Canvas bitmap, and that the <code>globalAlpha</code> property only affects shapes that are drawn after it is set. 
This means we don’t have to <code>save()</code> and <code>restore()</code> the Canvas state to set the next drawn shape to a new transparency value.
In the next section, we will look at some transformations that affect the entire canvas. 
As a result, if we want to transform only the newly drawn shape, we will have to use the <code>save()</code> and <code>restore()</code> functions.

<h2>Simple Canvas Transformations</h2>
Transformations on the canvas refer to the mathematical adjustment of physical properties of drawn shapes. 
The two most commonly used shape transformations are scale and rotate, which we will focus on in this section.
Under the hood, a mathematical matrix operation applies to all transformations. 

Luckily, you do not need to understand this to use simple Canvas transformations. 
We will discuss how to apply rotation, translation, and scale transformations by changing simple Canvas properties.
<h3>Rotation and Translation Transformations</h3>
An object on the canvas is said to be at the 0 angle rotation when it is facing to the left (this is important if an object has a facing; otherwise, we will use this as a guide). 

Consequently, if we draw an equilateral box (all four sides are the same length), it doesn’t have an initial facing other than one of the flat sides facing to the left. 
Let’s draw that box for reference:
//now draw a red square
context.fillStyle = "red";

context.fillRect(100,100,50,50);
Now, if we want to rotate the entire canvas 45 degrees, we need to do a couple simple steps. 
First, we always set the current Canvas transformation to the “identity” (or “reset”) matrix:
context.setTransform(1,0,0,1,0,0);

Because Canvas uses radians, not degrees, to specify its transformations, we need to convert our 45-degree angle into radians:
var angleInRadians = 45 * Math.PI / 180;
context.rotate(angleInRadians);
<h4>Lesson 1: Transformations are applied to shapes and paths drawn after the setTransform() or other transformation function is called</h4>

If you use this code verbatim, you will see a funny result…<em>nothing</em>! This is because the <code>setTransform()</code> function call only affects shapes drawn to the canvas <em>after</em> it is applied. 
We drew our square first, then set the transformation properties. 
This resulted in no change (or transform) to the drawn square. 
Example 2-7</a> gives the code in the correct order to produce the expected result, as illustrated in <a href="ch02.html#simple_rotation_transformation-id1" title="Figure 2-12. 

Simple rotation transformation">Figure 2-12</a>.
Example 2-7. 
Simple rotation transformation
function drawScreen() { //now draw a red square context.setTransform(1,0,0,1,0,0); var angleInRadians = 45 * Math.PI / 180; context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(100,100,50,50);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893611.png" alt="Simple rotation transformation" width="36" height="71">
Figure 2-12. 

Simple rotation transformation
We get a result this time, but it will probably differ from what you expect. 
The red box is rotated, but it looks like the canvas was rotated with it. 
The entire canvas did not rotate, only the portion drawn after the <code>context.rotate()</code> function was called. 

So, why did our square both rotate and move off to the left of the screen? The origin of the rotation was set at the “nontranslated” <code>0,0</code> position, resulting in the square rotating from the top left of the entire canvas.
Example 2-8</a> offers a slightly different scenario: draw a black box first, then set the rotation transform, and finally draw the red box again. 
See the results in <a href="ch02.html#rotation_and_canvas_state" title="Figure 2-13. 
Rotation and the Canvas state">Figure 2-13</a>.

Example 2-8. 
Rotation and the Canvas state
function drawScreen() {
 //draw black square context.fillStyle = "black"; context.fillRect(20,20,25,25); //now draw a red square context.setTransform(1,0,0,1,0,0); var angleInRadians = 45 * Math.PI / 180; context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(100,100,50,50);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893613.png" alt="Rotation and the Canvas state" width="45" height="192">
Figure 2-13. 

Rotation and the Canvas state
The small black square was unaffected by the rotation, so you can see that only the shapes drawn after the <code>context.rotate()</code> function was called were affected.
Again, the red box was moved far off to the left. 
To reiterate, this occurred because the canvas did not know what origin to use for the rotation. 

In the absence of an actual translated origin, the <code>0,0</code> position setting is applied, resulting in the <code>context.rotate()</code> function rotating “around” the <code>0,0</code> point, which brings us to our next lesson.
<h4>Lesson 2: We must “translate” the point of origin to the center of our shape to rotate it around its own center</h4>
Let’s change Example 2-8</a> to rotate the red square 45 degrees while keeping it in its current location.
First, we take the numbers we applied to the <code>fillRect()</code> function call to create a few variables to hold the red square’s attributes. 

This is not necessary, but it will make the code much easier to read and change later:
var x = 100;
var y = 100;
var width = 50;

var height = 50;
Next, using the <code>context.translate()</code> function call, we must change the origin of the canvas to be the center of the red square we want to rotate and draw. 
This function moves the origin of the canvas to the accepted <code>x</code> and <code>y</code> locations. 
The center of our red square will now be the desired top-left corner <code>x</code> location for our object (<code>100</code>), plus half the width of our object. 

Using the variables we created to hold attributes of the red square, this would look like:
x+0.5*width
Next, we must find the <code>y</code> location for the origin translation. 
This time, we use the <code>y</code> value of the top-left corner of our shape and the height of the shape:

y+.05*height
The <code>translate()</code> function call looks like this:
context.translate(x+.05*width, y+.05*height)
Now that we have translated the canvas to the correct point, we can do our rotation. 

The code has not changed:
context.rotate(angleInRadians);
Finally, we need to draw our shape. 
We cannot simply reuse the same values from Example 2-8</a> because the canvas origin point has moved to the center of the location where we want to draw our object. 

You can now consider 125,125 as the starting point for all draw operations. 
We get <code>125</code> for <code>x</code> by taking the upper-left corner of the square (<code>100</code>) and adding half its width (<code>25</code>). 
We do the same for the <code>y</code> origin position. 
The <code>translate()</code> method call accomplishes this.

We will need to draw the object starting with the correct upper-left coordinates for <code>x</code> and <code>y</code>. 
We do this by subtracting half the width of our object from the origin <code>x</code>, and half the height of our object from the origin <code>y</code>:
context.fillRect(-0.5*width,-0.5*height, width, height);
Why do we do this? <a href="ch02.html#the_newly_translated_point" title="Figure 2-14. 

The newly translated point">Figure 2-14</a> illustrates the situation.
Consider that we want to draw our square starting at the top-left corner. 
If our origin point is at 125,125, the top left is actually 100,100. 
However, we have translated our origin so the canvas now considers 125,125 to be 0,0. 

To start our box drawing at the nontranslated canvas, we have to start at –25,–25 on the “translated” canvas.
This forces us to draw our box as though the origin is at 0,0, not 125,125. 
Therefore, when we do the actual drawing of the box, we must use these coordinates, as shown in <a href="ch02.html#drawing_with_a_translated_point" title="Figure 2-15. 
Drawing with a translated point">Figure 2-15</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893615.png" alt="The newly translated point" width="415" height="229">
Figure 2-14. 
The newly translated point
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893617.png" alt="Drawing with a translated point" width="415" height="229">

Figure 2-15. 
Drawing with a translated point
In summary, we needed to change the point of origin to the center of our square so it would rotate around that point. 
But when we draw the square, we need our code to act as though the (125,125) point is actually (0,0). 

If we had not translated the origin, we could have used the (125,125) point as the center of our square (as in <a href="ch02.html#the_newly_translated_point" title="Figure 2-14. 
The newly translated point">Figure 2-14</a>). 
Example 2-9</a> demonstrates how this works, creating the result shown in <a href="ch02.html#rotation_around_the_center" title="Figure 2-16. 
Rotation around the center point">Figure 2-16</a>.

Example 2-9. 
Rotation around the center point
function drawScreen() {
 //draw black square context.fillStyle = "black"; context.fillRect(20,20 ,25,25); //now draw a red square context.setTransform(1,0,0,1,0,0); var angleInRadians = 45 * Math.PI / 180; var x = 100; var y = 100; var width = 50; var height = 50; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893619.png" alt="Rotation around the center point" width="141" height="141">
Figure 2-16. 

Rotation around the center point
Let’s look at one final rotation example. 
Example 2-10</a> takes Example 2-9</a> and simply adds four separate 40×40 squares to the canvas, rotating each one slightly. 
The result is shown in <a href="ch02.html#multiple_rotated_squares-id1" title="Figure 2-17. 

Multiple rotated squares">Figure 2-17</a>.
Example 2-10. 
Multiple rotated squares
function drawScreen() { //now draw a red square context.setTransform(1,0,0,1,0,0); var angleInRadians = 45 * Math.PI / 180; var x = 50; var y = 100; var width = 40; var height = 40; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
 context.setTransform(1,0,0,1,0,0); var angleInRadians = 75 * Math.PI / 180; var x = 100; var y = 100; var width = 40; var height = 40; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
 context.setTransform(1,0,0,1,0,0); var angleInRadians = 90 * Math.PI / 180; var x = 150; var y = 100; var width = 40; var height = 40; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height); context.setTransform(1,0,0,1,0,0); var angleInRadians = 120 * Math.PI / 180; var x = 200; var y = 100; var width = 40; var height = 40; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
}

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893621.png.jpg" alt="Multiple rotated squares" width="226" height="81">
Figure 2-17. 
Multiple rotated squares
Next, we will examine scale transformations.

<h3>Scale Transformations</h3>
The <code>context.scale()</code> function takes in two parameters: the first is the scale attribute for the x-axis, and the second is the scale attribute for the y-axis. 
The value <code>1</code> is the normal scale for an object. 
Therefore, if we want to double an object’s size, we can set both values to <code>2</code>. 

Using the code below in <code>drawScreen()</code> produces the red square shown in <a href="ch02.html#a_simple_scaled_square" title="Figure 2-18. 
A simple scaled square">Figure 2-18</a>:
context.setTransform(1,0,0,1,0,0);
context.scale(2,2);

context.fillStyle = "red";
context.fillRect(100,100 ,50,50);
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893623.png" alt="A simple scaled square" width="100" height="100">
Figure 2-18. 

A simple scaled square
If you test this code, you will find that scale works in a similar manner as rotation. 
We did not translate the origin of the scale point to double the size of the square; rather, we used the top-left corner of the canvas as the origin point. 
The result is that the red square appears to move farther down and to the left. 

What we would like is for the red square to remain in place and to scale from its center. 
We do this by translating to the center of the square before we scale, and by drawing the square around this center point (just as we did in Example 2-9</a>). 
Example 2-11</a> produces the result shown in <a href="ch02.html#scale_from_the_center_point-id1" title="Figure 2-19. 
Scale from the center point">Figure 2-19</a>.

Example 2-11. 
Scale from the center point
function drawScreen() {
 //now draw a red square context.setTransform(1,0,0,1,0,0); var x = 100; var y = 100; var width = 50; var height = 50; context.translate(x+.5*width, y+.5*height); context.scale(2,2); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height); }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893625.png" alt="Scale from the center point" width="100" height="100">
Figure 2-19. 
Scale from the center point

<h3>Combining Scale and Rotation Transformations</h3>
If we want to both scale and rotate an object, Canvas transformations can easily be combined to achieve the desired results (as shown in <a href="ch02.html#scale_and_rotation_combined-id1" title="Figure 2-20. 
Scale and rotation combined">Figure 2-20</a>). 
Let’s look in Example 2-12</a> at how we might combine them by using <code>scale(2,2)</code> and <code>rotate(angleInRadians)</code> from our previous examples.

Example 2-12. 
Scale and rotation combined
function drawScreen() { context.setTransform(1,0,0,1,0,0); var angleInRadians = 45 * Math.PI / 180; var x = 100; var y = 100; var width = 50; var height = 50; context.translate(x+.5*width, y+.5*height); context.scale(2,2); context.rotate(angleInRadians); context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893627.png" alt="Scale and rotation combined" width="142" height="142">
Figure 2-20. 
Scale and rotation combined
Example 2-13</a> also combines rotation and scale, this time using a rectangle. 

<a href="ch02.html#scale_and_rotate_a_non-square_objec" title="Figure 2-21. 
Scale and rotate a nonsquare object">Figure 2-21</a> reveals what it creates.
Example 2-13. 
Scale and rotate a nonsquare object

function drawScreen() {
 //now draw a red rectangle context.setTransform(1,0,0,1,0,0); var angleInRadians = 90 * Math.PI / 180; var x = 100; var y = 100; var width = 100; var height = 50; context.translate(x+.5*width, y+.5*height); context.rotate(angleInRadians); context.scale(2,2);
 context.fillStyle = "red"; context.fillRect(-.5*width,-.5*height , width, height);
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893629.png" alt="Scale and rotate a nonsquare object" width="100" height="200">
Figure 2-21. 
Scale and rotate a nonsquare object
Finding the Center of Any Shape

The rotation and scale of a rectangle or any other shape we draw on the canvas acts much like that of a square. 
In fact, as long as we are sure to translate to the center of our shape before we scale, rotate, or scale and rotate, we will see the results we expect from our simple transformations. 
Keep in mind that the “center” of any shape will be the <code>x</code> value that is half its width, and the <code>y</code> value that is half its height. 
We need to use the <em>bounding box theory</em> when we attempt to find this center point.

<a href="ch02.html#the_bounding_box_of_a_complex_shape" title="Figure 2-22. 
The bounding box of a complex shape">Figure 2-22</a> demonstrates this theory. 
Even though the shape is not a simple square, we have been able to find a bounding box that encompasses each point of the object. 
<a href="ch02.html#the_bounding_box_of_a_complex_shape" title="Figure 2-22. 

The bounding box of a complex shape">Figure 2-22</a> is roughly square, but the same theory holds for rectangle-shaped bounding boxes.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893631.png" alt="The bounding box of a complex shape" width="326" height="220">
Figure 2-22. 
The bounding box of a complex shape

<h2>Filling Objects with Colors and Gradients</h2>
In this chapter, we have quickly looked at color and fill styles as we proceeded through the discussions of basic and complex shape construction. 
In this section, we will take a deeper look at coloring and filling shapes we draw on the canvas. 
In addition to these simple colors and fills, there are a number of different gradient styles that we can employ. 

Furthermore, Canvas also has a method to fill shapes with bitmap images (see <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>).
<h3>Setting Basic Fill Colors</h3>
The Canvas <code>fillStyle</code> property is used to set a basic color for filling shapes on the canvas. 

We saw this earlier in the chapter when we used simple color names for our <code>fillStyle</code>. 
An example is:
context.fillStyle = "red";
Below is a list of the usable color string values from the HTML4 specification. 

As of this writing, the HTML5 color specification has not been set. 
In the absence of any additional HTML5-specific colors, the HTML4 colors will work properly in HTML5:
<table>
<tr><td>Black = <code>#000000</code>

</td></tr>
<tr><td>Green = <code>#008000</code>
</td></tr>
<tr><td>Silver = <code>#C0C0C0</code>

</td></tr>
<tr><td>Lime = <code>#00FF00</code>
</td></tr>
<tr><td>Gray = <code>#808080</code>

</td></tr>
<tr><td>Olive = <code>#808000</code>
</td></tr>
<tr><td>White = <code>#FFFFFF</code>

</td></tr>
<tr><td>Yellow = <code>#FFFF00</code>
</td></tr>
<tr><td>Maroon = <code>#800000</code>

</td></tr>
<tr><td>Navy = <code>#000080</code>
</td></tr>
<tr><td>Red = <code>#FF0000</code>

</td></tr>
<tr><td>Blue = <code>#0000FF</code>
</td></tr>
<tr><td>Purple = <code>#800080</code>

</td></tr>
<tr><td>Teal = <code>#008080</code>
</td></tr>
<tr><td>Fuchsia = <code>#FF00FF</code>

</td></tr>
<tr><td>Aqua = <code>#00FFFF</code>
</td></tr>
</table>

<h3>Note</h3>
All these color values will work with the <code>strokeStyle</code> as well as the <code>fillStyle</code>.
Of course, using a string for the color name is not the only available method of specifying a solid color fill. 
The list below includes a few other methods:

Setting the fill color with the <code>rgb()</code> method
The <code>rgb()</code> method lets us use the 24-bit RGB value when specifying our fill colors:

context.fillStyle = rgb(255,0,0);
This will result in the same <code>red</code> color as the string value above.
Setting the fill color with a hex number string

We can also set the <code>fillStyle</code> color with a hex number in a string:
context.fillStyle = "#ff0000";

Setting the fill color with the <code>rgba()</code> method
The <code>rgba()</code> method allows us to specify a 32-bit color value with the final 8 bits representing the alpha value of the fill color:
context.fillStyle = rgba(255,0,0,1);

The alpha value can be from <code>1</code> (opaque) to <code>0</code> (transparent).
<h3>Filling Shapes with Gradients</h3>

There are two basic options for creating gradient fills on the canvas: linear and radial. 
A <em>linear</em> gradient creates a horizontal, vertical, or diagonal fill pattern; the <em>radial</em> variety creates a fill that “radiates” from a central point in a circular fashion. 
Let’s look at some examples of each.
<h4>Linear gradients</h4>

Linear gradients come in three basic styles: horizontal, vertical, and diagonal. 
We control where colors change in our gradient by setting <em>color stops</em> at points along the length of the object we wish to fill.
<h5>Linear horizontal gradients</h5>
Example 2-14</a> creates a simple horizontal gradient, as shown in <a href="ch02.html#a_linear_horizontal_gradient-id1" title="Figure 2-23. 

A linear horizontal gradient">Figure 2-23</a>.
Example 2-14. 
A linear horizontal gradient
function drawScreen() { // horizontal gradient values must remain 0 var gr = context.createLinearGradient(0, 0, 100, 0);
 // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 

context.fillStyle = gr; context.fillRect(0, 0,100,100);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893633.png" alt="A linear horizontal gradient" width="100" height="100">
Figure 2-23. 

A linear horizontal gradient
To create the horizontal gradient, we must first create a variable (<code>gr</code>) to reference the new gradient. 
Here’s how we set it:
var gr = context.createLinearGradient(0,0,100,0);

The four parameter values in the <code>createLinearGradient</code> method call are the top-left <em>x</em> and <em>y</em> coordinates to start the gradient, as well as the two bottom-right points to end the gradient. 
Our example starts at <code>0,0</code> and goes to <code>100,0</code>. 
Notice that the <em>y</em> values are both 0 when we create a horizontal gradient; the opposite will be true when we create a vertical gradient.
Once we have defined the size of our gradient, we then add in color stops that take two parameter values. 

The first is a relative position origin point along the gradient to start with color, and the second is the color to use. 
The relative position must be a value from 0.0 to 1.0:
gr.addColorStop(0,'rgb(255,0,0)');
gr.addColorStop(.5,'rgb(0,255,0)');

gr.addColorStop(1,'rgb(255,0,0)');
Therefore, in Example 2-14</a>, we have set a red color at <code>0</code>, a green color at <code>.5</code> (the center), and another red color at <code>1</code>. 
This will fill our shape with a relatively even red to green to red gradient.
Next, we need to get the <code>context.fillStyle</code> to be the gradient we just created:

context.fillStyle = gr;
Finally, we create a rectangle on the canvas:
context.fillRect(0, 0, 100, 100);
Notice that we created a rectangle that was the exact size of our gradient. 

We can change the size of the output rectangle like this:
context.fillRect(0, 100, 50, 100);
context.fillRect(0, 200, 200, 100);
Example 2-15</a> adds these two new filled rectangles to Example 2-14</a> to create <a href="ch02.html#linear_horizontal_gradient_on_multiple_o" title="Figure 2-24. 

Linear horizontal gradient on multiple objects">Figure 2-24</a>. 
Notice that the gradient fills up the available space, with the final color filling out the area larger than the defined gradient size.
Example 2-15. 
Multiple gradient-filled objects

function drawScreen() {
 var gr = context.createLinearGradient(0, 0, 100, 0);
 // Add the color stops.
 gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)');
 gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle.
 context.fillStyle = gr; context.fillRect(0, 0, 100, 100);
 context.fillRect(0, 100, 50, 100);
 context.fillRect(0, 200, 200, 100);
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893635.png" alt="Linear horizontal gradient on multiple objects" width="200" height="300">
Figure 2-24. 
Linear horizontal gradient on multiple objects
<h5>Applying a horizontal gradient to a stroke</h5>

Gradients can be applied to any shape—even the stroke around a shape. 
Example 2-16</a> takes the filled rectangles from Example 2-15</a> and creates a <code>strokeRect</code> shape instead of a filled rectangle. 
<a href="ch02.html#horizontal_stroke_gradients" title="Figure 2-25. 
Horizontal stroke gradients">Figure 2-25</a> shows the very different result.

Example 2-16. 
A horizontal stroke gradient
function drawScreen() {
 var gr = context.createLinearGradient(0, 0, 100, 0); // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.strokeStyle = gr; context.strokeRect(0, 0, 100, 100); context.strokeRect(0, 100, 50, 100); context.strokeRect(0, 200, 200, 100); }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893637.png" alt="Horizontal stroke gradients" width="201" height="301">
Figure 2-25. 
Horizontal stroke gradients

<h5>Applying a horizontal gradient to a complex shape</h5>
We can also apply a linear gradient to a “closed” shape made up of points, as shown in Example 2-17</a>. 
A shape is considered closed when the final point is the same as the starting point.
Example 2-17. 

Horizontal gradient on a complex shape
function drawScreen() {
 var gr = context.createLinearGradient(0, 0, 100, 0);
 // Add the color stops. 

gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.fillStyle = gr; context.beginPath(); context.moveTo(0,0); context.lineTo(50,0); context.lineTo(100,50); context.lineTo(50,100); context.lineTo(0,100); context.lineTo(0,0); context.stroke(); context.fill(); context.closePath();
 }

In this example, we use the <code>context.fill()</code> command to fill in our shape with the current <code>fillStyle</code>, creating the output shown in <a href="ch02.html#a_horizontal_gradient_on_a_complex_shape" title="Figure 2-26. 
A horizontal gradient on a complex shape">Figure 2-26</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893639.png" alt="A horizontal gradient on a complex shape" width="100" height="100">
Figure 2-26. 

A horizontal gradient on a complex shape
<a href="ch02.html#a_horizontal_gradient_on_a_complex_shape" title="Figure 2-26. 
A horizontal gradient on a complex shape">Figure 2-26</a> shows the new shape we have created with points. 
As long as the points are closed, the fill will work as we expect.

<h5>Vertical gradients</h5>
Vertical gradients are created in a very similar manner as the horizontal variety. 
The difference is that we must specify a <code>y</code> value that is not <code>0</code>, and the <code>x</code> values must both be <code>0</code>. 
Example 2-18</a> shows the shape from Example 2-17</a> created with a vertical rather than a horizontal gradient to produce the output in <a href="ch02.html#a_vertical_gradient_example" title="Figure 2-27. 

A vertical gradient example">Figure 2-27</a>.
Example 2-18. 
Vertical gradients
function drawScreen() { var gr = context.createLinearGradient(0, 0, 0, 100);
 // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 

context.fillStyle = gr; context.beginPath(); context.moveTo(0,0); context.lineTo(50,0); context.lineTo(100,50); context.lineTo(50,100); context.lineTo(0,100); context.lineTo(0,0); //context.stroke(); context.fill(); context.closePath();
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893641.png" alt="A vertical gradient example" width="100" height="100">
Figure 2-27. 

A vertical gradient example
The only difference between Example 2-18</a> and Example 2-17</a> is the line creating the linear gradient.
The horizontal version (Example 2-17</a>):
var gr = context.createLinearGradient(0, 0, 100, 0);

The new vertical version (Example 2-18</a>):
var gr = context.createLinearGradient(0, 0, 0, 100);
All of the same rules for strokes on horizontal gradients apply to vertical ones. 
Example 2-19</a> takes the shape from Example 2-18</a>, stroking it with the gradient instead of filling it, producing the outline shown in <a href="ch02.html#a_vertical_gradient_stroke-id1" title="Figure 2-28. 

A vertical gradient stroke">Figure 2-28</a>.
Example 2-19. 
A vertical gradient stroke
function drawScreen() { var gr = context.createLinearGradient(0, 0, 0, 100);
 // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 

context.strokeStyle = gr; context.beginPath(); context.moveTo(0,0); context.lineTo(50,0); context.lineTo(100,50); context.lineTo(50,100); context.lineTo(0,100); context.lineTo(0,0); context.stroke(); context.closePath();
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893643.png" alt="A vertical gradient stroke" width="101" height="101">
Figure 2-28. 

A vertical gradient stroke
<h5>Diagonal gradients</h5>
You can easily create a diagonal gradient by varying both the second <code>x</code> and second <code>y</code> parameters of the <code>createLinearGradient()</code> function:
var gr= context.createLinearGradient(0, 0, 100, 100);

To create a perfect diagonal gradient, as shown in <a href="ch02.html#a_diagonal_gradient_example" title="Figure 2-29. 
A diagonal gradient example">Figure 2-29</a>, fill a square that is the same size as the diagonal gradient. 
The code is provided in Example 2-20</a>.
Example 2-20. 

A diagonal gradient
function drawScreen() {
 var gr = context.createLinearGradient(0, 0, 100, 100);
 // Add the color stops. 

gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.fillStyle = gr; context.beginPath(); context.moveTo(0,0); context.fillRect(0,0,100,100) context.closePath();
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893645.png" alt="A diagonal gradient example" width="100" height="100">
Figure 2-29. 
A diagonal gradient example
<h4>Radial gradients</h4>

The definition process for radial and linear gradients is very similar. 
Although a radial gradient takes six parameters to initialize rather than the four needed for a linear gradient, it uses the same color stop idea to create the color changes.
The six parameters are used to define the center point and the radii of two circles. 
The first circle is the “start” circle, and the second circle is the “end” circle. 

Let’s look at an example:
var gr = context.createRadialGradient(50,50,25,50,50,100);
The first circle has a center point of <code>50,50</code> and a radius of <code>25</code>; the second has a center point of <code>50,50</code> and a radius of <code>100</code>. 
This will effectively create two concentric circles.

We set color stops the same way we did with the linear gradients:
gr.addColorStop(0,'rgb(255,0,0)');
gr.addColorStop(.5,'rgb(0,255,0)');
gr.addColorStop(1,'rgb(255,0,0)');

Example 2-21</a> puts this together to create the result shown in <a href="ch02.html#a_simple_radial_gradient-id1" title="Figure 2-30. 
A simple radial gradient">Figure 2-30</a>.
Example 2-21. 
A simple radial gradient

function drawScreen() {
 var gr = context.createRadialGradient(50,50,25,50,50,100);
 // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)'); // Use the gradient for the fillStyle. 
context.fillStyle = gr; context.fillRect(0, 0, 200, 200);
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893647.png.jpg" alt="A simple radial gradient" width="200" height="200">

Figure 2-30. 
A simple radial gradient
Example 2-22</a> offsets the second circle from the first to create the effects shown in <a href="ch02.html#a_complex_radial_gradient-id1" title="Figure 2-31. 
A complex radial gradient">Figure 2-31</a>.

Example 2-22. 
A complex radial gradient
function drawScreen() {
 var gr = context.createRadialGradient(50,50,25,100,100,100); // Add the color stops. 
gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.fillStyle = gr; context.fillRect(0, 0, 200, 200);

}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893649.png.jpg" alt="A complex radial gradient" width="200" height="200">
Figure 2-31. 
A complex radial gradient

As with the linear gradients, we can also apply the radial gradients to complex shapes. 
Example 2-23</a> takes an arc example from earlier in this chapter, but applies a radial gradient to create <a href="ch02.html#a_radial_gradient_applied_to_a_circle" title="Figure 2-32. 
A radial gradient applied to a circle">Figure 2-32</a>.
Example 2-23. 

A radial gradient applied to a circle
function drawScreen() {
 var gr = context.createRadialGradient(50,50,25,100,100,100);
 // Add the color stops. 

gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.fillStyle = gr; context.arc(100, 100, 100, (Math.PI/180)*0, (Math.PI/180)*360, false); context.fill();
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893651.png" alt="A radial gradient applied to a circle" width="200" height="200">
Figure 2-32. 
A radial gradient applied to a circle
Example 2-23</a> takes the radial gradient from Example 2-22</a> and applies it to a circle shape rather than a rectangle shape. 

This removes the red square from the background of the shape.
We can also apply our radial gradient to the stroke of our arc rather than the fill, as shown in Example 2-24</a> and <a href="ch02.html#an_arc_stroke_gradient_example" title="Figure 2-33. 
An arc stroke gradient">Figure 2-33</a>.
Example 2-24. 

An arc stroke gradient
function drawScreen() {
 var gr = context.createRadialGradient(50,50,25,100,100,100);
 // Add the color stops. 

gr.addColorStop(0,'rgb(255,0,0)'); gr.addColorStop(.5,'rgb(0,255,0)'); gr.addColorStop(1,'rgb(255,0,0)');
 // Use the gradient for the fillStyle. 
context.strokeStyle = gr; context.arc(100, 100, 50, (Math.PI/180)*0, (Math.PI/180)*360, false) context.stroke();
 }

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893653.png" alt="An arc stroke gradient" width="102" height="102">
Figure 2-33. 
An arc stroke gradient
Example 2-24</a> created a circle that is smaller than the version in Example 2-23</a>, so the radial gradient would show up on the stroke of the arc. 

If we left it the same size as Example 2-23</a>, we would have a solid red fill because the radial gradient is solid red at the diameter edge of the circle.
<h2>Filling Shapes with Patterns</h2>
We will cover using bitmap images on the canvas in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, but for now, let’s take a quick look at how images can be used as fill patterns for shapes we draw.

Fill patterns are initialized with the <code>createPattern()</code> function, which takes two parameters. 
The first is an <code>Image</code> object instance, and the second is a <code>String</code> representing how to display the <code>repeat</code> pattern inside the shape. 
We can use a loaded image file or an entire other canvas as a fill pattern for a drawn shape.
There are currently four types of image fills:

<code>repeat</code>
<code>repeat-x</code>

<code>repeat-y</code>
<code>no-repeat</code>

Modern browsers have implemented these four types to various degrees, but standard <code>repeat</code> seems to be the most common. 
Let’s look at it now and then we will take a brief look at the other three.
<a href="ch02.html#the_fill_underscore_20x20.gif_image_for" title="Figure 2-34. 
The fill_20x20.gif image for our fill">Figure 2-34</a> shows a simple bitmap fill pattern that we can use to test this functionality. 

It is a 20×20 green circle on a transparent background, saved as a <em>.gif</em> file named <em>fill_20x20.gif</em>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893655.png" alt="The fill_20x20.gif image for our fill" width="20" height="20">
Figure 2-34. 
The fill_20x20.gif image for our fill

Example 2-25</a> tests this first with the <code>repeat</code> string to create a box full of little green circles, as shown in <a href="ch02.html#repeat_fill_example" title="Figure 2-35. 
repeat fill example">Figure 2-35</a>.
Example 2-25. 
Filling with an image file using repeat

function drawScreen() {
 var fillImg = new Image(); fillImg.src = 'fill_20x20.gif'; fillImg.onload = function(){
 var fillPattern = context.createPattern(fillImg,'repeat'); context.fillStyle = fillPattern; context.fillRect(0,0,200,200);
 } }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893657.png" alt="repeat fill example" width="200" height="200">
Figure 2-35. 
repeat fill example

It is best not to use <code>Image</code> instances until they have loaded completely. 
We will cover this in detail in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, but for now, we simply create an inline <code>onload</code> event handler function that will be called when <code>Image</code> is ready to be used. 
The <code>repeat</code> pattern string does a good job of completely filling the 200×200 square. 

Let’s see the code for how the other repeat strings perform (in Example 2-26</a>), and view the results in Figures <a href="ch02.html#no-repeat_comma_repeat-x_comma_and" title="Figure 2-36. 
no-repeat, repeat-x, and repeat-y in Safari">2-36</a> through <a href="ch02.html#no-repeat_comma_repeat-x_comma_and-id2" title="Figure 2-38. 
no-repeat, repeat-x, and repeat-y in Chrome">2-38</a>.
Example 2-26. 

Using the no-repeat, repeat-x, and repeat-y strings
function drawScreen() {
 var fillImg = new Image(); fillImg.src = 'fill_20x20.gif';
 fillImg.onload = function(){ var fillPattern1 = context.createPattern(fillImg,'no-repeat'); var fillPattern2 = context.createPattern(fillImg,'repeat-x'); var fillPattern3 = context.createPattern(fillImg,'repeat-y');
 context.fillStyle = fillPattern1; context.fillRect(0,0,100,100);
 context.fillStyle = fillPattern2; context.fillRect(0,110,100,100);
 context.fillStyle = fillPattern3; context.fillRect(0,220,100,100); }
 }
<h3>Note</h3>
Each browser will show these patterns in a different manner.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893659.png" alt="no-repeat, repeat-x, and repeat-y in Safari" width="20" height="320">
Figure 2-36. 
no-repeat, repeat-x, and repeat-y in Safari
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893661.png" alt="no-repeat, repeat-x, and repeat-y in Firefox" width="20" height="320">

Figure 2-37. 
no-repeat, repeat-x, and repeat-y in Firefox
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893663.png" alt="no-repeat, repeat-x, and repeat-y in Chrome" width="100" height="320">
Figure 2-38. 

no-repeat, repeat-x, and repeat-y in Chrome
Only Firefox seems to show anything of significance when the <code>repeat-x</code> and <code>repeat-y</code> strings are used in the <code>repeat</code> parameter. 
We will cover more examples of filling, as well as many other uses for bitmap images, in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>.

<h2>Creating Shadows on Canvas Shapes</h2>
We can add shadows to shapes we draw on the canvas using four parameters. 
As with the tiled fill patterns in the previous section, this feature has not been fully implemented on all HTML5-compliant browsers.
We add a shadow by setting four Canvas properties:

<code>shadowOffsetX</code>
<code>shadowOffsetY</code>

<code>shadowBlur</code>
<code>shadowColor</code>

The <code>shadowOffsetX</code> and <code>shadowOffsetY</code> values can be positive or negative. 
Negative values will create shadows to the left and top rather than to the bottom and right. 
The <code>shadowBlur</code> property sets the size of the blurring effect on the shadow. 
None of these three parameters is affected by the current Canvas transformation matrix. 

The <code>shadowColor</code> can be any color set via HTML4 color constant string—<code>rgb()</code> or <code>rgba()</code>—or with a string containing a hex value.
Example 2-27</a> and <a href="ch02.html#adding_shadows_to_drawn_objects-id1" title="Figure 2-39. 
Adding shadows to drawn objects">Figure 2-39</a> show a few different boxes drawn with various shadow settings.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893665.png" alt="Adding shadows to drawn objects" width="304" height="410">

Figure 2-39. 
Adding shadows to drawn objects
Example 2-27. 
Adding shadows to drawn objects

function drawScreen() {
 context.fillStyle = 'red';
 context.shadowOffsetX = 4; context.shadowOffsetY = 4; context.shadowColor = 'black'; context.shadowBlur = 4; context.fillRect(10,10,100,100);
 context.shadowOffsetX = -4; context.shadowOffsetY = -4; context.shadowColor = 'black'; context.shadowBlur = 4; context.fillRect(150,10,100,100); context.shadowOffsetX = 10; context.shadowOffsetY = 10; context.shadowColor = 'rgb(100,100,100)'; context.shadowBlur = 8; context.arc(200, 300, 100, (Math.PI/180)*0, (Math.PI/180)*360, false) context.fill();
}
As you can see, if we adjust the <code>shadowOffset</code> values along with the <code>shadowBlur</code> value, we create various shadows. 
We can also create shadows for complex shapes drawn with paths and arcs.

<h2>What’s Next</h2>
We covered a lot of ground in this chapter, introducing the ways to construct primitive and complex shapes, and how we can draw and transform them on the canvas. 
We also discussed how to composite, rotate, scale, translate, fill, and create shadows on these shapes. 
But we’ve only just begun exploring HTML5 Canvas. 

In the next chapter, we will look at how to create and manipulate text objects on the canvas.
 3. 
The HTML5 Canvas Text API" epub:type="chapter">
<h2><span class="orange">Chapter 3. The HTML5 Canvas Text API</span></h2>
The HTML5 Canvas Text API allows developers to render text on an HTML page in ways that were either tricky or next to impossible before its invention.

We are providing an in-depth analysis of the HTML5 Canvas Text API because it is one of the most basic ways to interact with the canvas.
 However, that does not mean it was the first Canvas API feature developed.
 In fact, for many browsers, it was one of the last parts implemented.

There was a time in the recent past when HTML5 Canvas Text API support in browsers was spotty at best. 
Back then, using
 <em>modernizr.js</em> to test for text support would have been a good idea. 
However, at this historic moment, all modern browser versions
 (besides IE) support the HTML5 Canvas Text API in some way.
This chapter will create an application named “Text Arranger” to demonstrate the features and interdependencies of the HTML5 Canvas Text API.
 This application will display a single line of text in an almost infinite number of ways. 
This is also a useful tool to see whether support for text is common among web browsers. 
Later in this chapter you will see that some text features are incompatible when drawn on the canvas at the same time.

<h2>Displaying Basic Text</h2>
Displaying text on HTML5 Canvas is simple. 
In fact, we covered the very basics in <a href="ch01.html" title="Chapter 1. 
Introduction to HTML5 Canvas">Chapter 1</a>. 

First, we will review these basics, and then we will show you how to make them work with the Text Arranger application.
<h3>Basic Text Display</h3>
The simplest way to define text to be displayed on the canvas is to set the <code>context.font</code> style using standard values for CSS font style attributes: <code>font-style</code>, <code>font-weight</code>, <code>font-size</code>, and <code>font-face</code>.
We will discuss each of these attributes in detail in the upcoming section Setting the Text Font</a>. 

All you need to know now is that a font designation of some type is required. 
Here is a simple example of setting a 50-point serif font:
context.font = "50px serif";
You also need to set the color of the text. 

For filled text, you would use the <code>context.fillStyle</code> attribute and set it using a standard CSS color, or with a <code>Canvas</code><code>Gradient</code> or <code>CanvasPattern</code> object. 
We will discuss the latter two options later in the chapter.
Finally, you call the <code>context.fillText()</code> method, passing the text to be displayed and the <code>x</code> and <code>y</code> positions of the text on the canvas.
Below is an example of all three basic lines of code required to display filled text on HTML5 Canvas:

context.font = "50px serif"
context.fillStyle = "#FF0000";
context.fillText ("Hello World", 100, 80);
If you do not specify a font, the default 10px sans-serif will be used automatically.

<h3>Handling Basic Text in Text Arranger</h3>
For Text Arranger, we are going to allow the user to set the text displayed by the call to <code>context.fillText()</code>. 
To do this, we will create a variable named <code>message</code> where we will store the user-supplied text. 
We will later use that variable in our call to <code>context.fillText()</code>, inside the standard <code>drawScreen()</code> method that we introduced in <a href="ch01.html" title="Chapter 1. 

Introduction to HTML5 Canvas">Chapter 1</a> and will continue to use throughout this book:
var message = "<em><code>your text</code></em>";
...
function drawScreen() { ...
 context.fillStyle = "#FF0000";
 context.fillText (message, 100, 80);
}

To change the text displayed on the canvas to the text entered by the user, we need to create an event handler for the text box <code>keyup</code> event. 
This means that whenever someone changes text in the box, the event handler function will be called.
To make this work, we are going to name our text box in our HTML <code>&lt;form&gt;</code> using an <code>&lt;input&gt;</code> form element. 
Notice that the id is set to the value <code>textBox</code>. 

Also notice that we have set the <code>placeholder=""</code> attribute. 
This attribute is new to HTML5, so it might not work in every browser. 
You can also substitute it with the <code>value=""</code> attribute, which will not affect the execution of this application:
&lt;form&gt; Text: &lt;input placeholder="<em><code>your text</code></em>"/&gt;
 &lt;br&gt;
&lt;/form&gt;
<h3>Communicating Between HTML Forms and the Canvas</h3>

Back in our JavaScript code, we need to create an event handler for the <code>keyup</code> event of <code>textBox</code>. 
We do this by finding the form element using the <code>document.getElementById()</code> function of the DOM <code>document</code> object, and storing it in the <code>formElement</code> variable. 
Then we call the <code>addEventListener()</code> method of <code>formElement</code>, setting the event to <code>keyup</code> and the event handler to the function <code>textBoxChanged</code>, which we have yet to define:
var formElement = document.getElementById("textBox");

formElement.addEventListener('keyup', textBoxChanged, false);
The final piece of the puzzle is to define the <code>textBoxChanged()</code> event handler. 
This function works like the event handlers we created in <a href="ch01.html" title="Chapter 1. 
Introduction to HTML5 Canvas">Chapter 1</a>. 

It is passed one parameter when it is called, an <code>event</code> object that we universally name <code>e</code> because it’s easy to remember.
The <code>event</code> object contains a property named <code>target</code> that holds a reference to the HTML form element that created the <code>change</code> event. 
In turn, the <code>target</code> contains a property named <code>value</code> that holds the newly changed value of the form element that caused the event to occur (i.e., <code>textBox</code>). 
We retrieve this value, and store it in the <code>message</code> variable we created in JavaScript. 

It is the very same <code>message</code> variable we use inside the <code>drawScreen()</code> method to paint the canvas. 
Now, all we have to do is call <code>draw</code><code>Screen()</code>, and the new value of <code>message</code> will appear “automagically” on the canvas:
function textBoxChanged(e) { var target = e.target; message = target.value; drawScreen();
 }

We just spent a lot of time describing how we will handle changes in HTML form controls with event handlers in JavaScript, and then display the results on an HTML5 Canvas. 
We will repeat this type of code several more times while creating Text Arranger. 
However, we will refrain from explaining it in depth again, instead focusing on different ways to render and capture form data and use it with Canvas.
<h3>Using measureText</h3>

The HTML5 Canvas context object includes a useful method, <code>measureText()</code>. 
When supplied with a text string, it will return some properties about that text based on the current context settings (font face, size, etc.) in the form of a <code>TextMetrics</code> object. 
Right now the <code>TextMetrics</code> object has only a single property: <code>width</code>. 
The <code>width</code> property of a <code>TextMetrics</code> object gives you the exact width in pixels of the text when rendered on the canvas. 

This can be very useful when attempting to center text.
<h4>Centering text using width</h4>
For the Text Arranger application, we will use the <code>TextMetrics</code> object to center the text the user has entered in the <code>textBox</code> form control on the canvas. 
First, we retrieve an instance of <code>TextMetrics</code> by passing the <code>message</code> variable (which holds the text we are going to display) to the <code>measureText()</code> method of the 2D context, and storing it in a variable named <code>metrics</code>:

var metrics = context.measureText(message);
Then, from the <code>width</code> property of <code>metrics</code>, we get the <code>width</code> of the text in pixels and store it in a variable named <code>textWidth</code>:
var textWidth = metrics.width;
Next, we calculate the center of the screen by taking the <code>width</code> of the canvas and dividing it in half (<code>theCanvas.width/2</code>). 

From that, we subtract half the <code>width</code> of the text (<code>textWidth/2</code>). 
We do this because text on the canvas is vertically aligned to the left when it is displayed without any alignment designation (more on this a bit later). 
So, to center the text, we need to move it half its own width to the left, and place the center of the text in the absolute center of the canvas. 
We will update this in the next section when we allow the user to select the text’s vertical alignment:

var xPosition = (theCanvas.width/2) - (textWidth/2);
<h4>What about the height of the text?</h4>
So, what about finding the height of the text so you can break text that is longer than the width of the canvas into multiple lines, or center it on the screen? Well, this poses a problem. 
The <code>TextMetrics</code> object does not contain a height property. 

The text font size does not give the full picture either, as it does not take into account font glyphs that drop below the baseline of the font. 
While the font size will help you estimate how to center a font vertically on the screen, it does not offer much if you need to break text onto two or more lines. 
This is because the spacing would also need to be taken into account, which could be very tricky.
For our demonstration, instead of trying to use the font size to vertically center the text on the canvas, we will create the <code>yPosition</code> variable for the text by simply placing it at one-half the height of the canvas. 

The default <code>baseline</code> for a font is <code>middle</code>, so this works great for centering on the screen. 
We will talk more about <code>baseline</code> in the next section:
var yPosition = (theCanvas.height/2);
<h3>Note</h3>

In the chat example in <a href="ch11.html" title="Chapter 11. 
Further Explorations">Chapter 11</a>, we will show you an example of breaking up text onto multiple lines.
<h3>fillText and strokeText</h3>
The <code>context.fillText()</code> function (as shown in <a href="ch03.html#filltext_in_action" title="Figure 3-1. 

fillText in action">Figure 3-1</a>) will render solid colored text to the canvas. 
The color used is set in the <code>context.fillColor</code> property. 
The font used is set in the <code>context.font</code> property. 
The function call looks like this:

fillText([text],[x],[y],[maxWidth]);
where:
<code>text</code>

The text to render on the canvas.
<code>x</code>

The <code>x</code> position of the text on the canvas.
<code>y</code>

The <code>y</code> position of the text on the canvas.
<code>maxWidth</code>

The maximum width of the text as rendered on the canvas. 
At the time of this writing, support for this property was just being added to browsers.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893667.png" alt="fillText in action" width="501" height="349">
Figure 3-1. 
fillText in action

The <code>context.strokeText()</code> function (as shown in <a href="ch03.html#stroketext_setting_outline_properties" title="Figure 3-2. 
strokeText setting outline properties">Figure 3-2</a>) is similar, but it specifies the outline of text strokes to the canvas. 
The color used to render the stroke is set in the <code>context.strokeColor</code> property; the font used is set in the <code>context.font</code> property. 
The function call looks like:

strokeText([text],[x],[y],[maxWidth])
where:
<code>text</code>

The text to render on the canvas.
<code>x</code>

The <code>x</code> position of the text on the canvas.
<code>y</code>

The <code>y</code> position of the text on the canvas.
<code>maxWidth</code>

The maximum width of the text as rendered on the canvas. 
At the time of this writing, this property does not appear to be implemented in any browsers.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893669.png" alt="strokeText setting outline properties" width="501" height="350">
Figure 3-2. 
strokeText setting outline properties

The next iteration of Text Arranger adds the ability for the user to select <code>fillText</code>, <code>strokeText</code>, or <code>both</code>. 
Selecting <code>both</code> will give the <code>fillText</code> text a black border (the <code>strokeText</code>). 
In the HTML <code>&lt;form&gt;</code>, we will add a <code>&lt;select&gt;</code> box with the id <code>fillOrStroke</code>, which will allow the user to make the selections:
Fill Or Stroke:

&lt;select id = "fillOrStroke"&gt;
 &lt;option value = "fill"&gt;fill&lt;/option&gt;
 &lt;option value = "stroke"&gt;stroke&lt;/option&gt;
 &lt;option value = "both"&gt;both&lt;/option&gt;

&lt;/select&gt;
In the <code>canvasApp()</code> function, we will define a variable named <code>fillOrStroke</code> that we will use to hold the value selected by the user on the HTML <code>&lt;form&gt;</code>. 
The default value will be <code>fill</code>, which means Text Arranger will always show <code>fillText</code> first:
var fillOrStroke = "fill";

We will also create the event listener for a change in the <code>fillOrStroke</code> form element…
formElement = document.getElementById("fillOrStroke");
formElement.addEventListener('change', fillOrStrokeChanged, false);
…and create the function <code>fillOrStrokeChanged()</code> to handle the event:

function fillOrStrokeChanged(e) { var target = e.target; fillOrStroke = target.value; drawScreen();
 }
eval()
While we created a separate function for each event handler for the applications in this chapter, in reality many of them work in an identical way. 

However, some developers might be inclined to use an <code>eval()</code> function, such as the following, as their event handler for changes made to the HTML element that controls Text Arranger:
var formElement = document.getElementById("textBox"); formElement.addEventListener('keyup', function(e) { applyChange('message', e) }, false);
formElement = document.getElementById("fillOrStroke");
formElement.addEventListener('change', function(e) { applyChange('fillOrStroke', e) }, false);

function applyChange (variable, e) { eval(variable + ' = e.target.value'); drawScreen();
}
The code above uses <code>eval()</code> to create and execute JavaScript code on the fly. 
It dynamically creates the name of the HTML element so that the multiple event handler functions do not need to be created individually. 

However, many developers are wary of using <code>eval()</code> because it opens up security holes, and makes debugging code more difficult. 
Use at your own risk.
In the <code>drawScreen()</code> function, we test the <code>fillOrStroke</code> variable to see whether it contains the value <code>fill</code>. 
Since we have three states (<code>fill</code>, <code>stroke</code>, or <code>both</code>), we use a <code>switch</code> statement to handle the choices. 

If the choice is <code>both</code>, we set the <code>strokeStyle</code> to black (<code>#000000</code>) as the highlight for the colored <code>fillText</code>.
If we use the <code>xPosition</code> and <code>yPosition</code> calculated using the width and height of the canvas, the <code>message</code> variable that contains the default or user-input text, and the <code>fill</code><code>OrStroke</code> variable to determine how to render the text, we can display the text as configured by the user in <code>drawScreen()</code>:
var metrics = context.measureText(message);
var textWidth = metrics.width;

var xPosition = (theCanvas.width/2) - (textWidth/2);
var yPosition = (theCanvas.height/2);
switch(fillOrStroke) {
 case "fill": context.fillStyle = "#FF0000"; context.fillText (message, xPosition,yPosition); break; case "stroke": context.strokeStyle = "#FF0000"; context.strokeText (message, xPosition,yPosition); break;
 case "both": context.fillStyle = "#FF0000"; context.fillText (message, xPosition,yPosition); context.strokeStyle = "#000000"; context.strokeText (message, xPosition,yPosition); break; }
Example 3-1</a> shows the full code for Text Arranger. 
Test it out to see how the user controls in HTML affect the canvas. 

There are not many ways to change the text here, but you can see the difference between <code>fillText</code> and <code>strokeText</code>. 
In the next section, we will update this application to configure and render the text in multiple ways.
Example 3-1. 
Text Arranger 1.0

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH3EX1: Text Arranger Version 1.0&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function eventWindowLoaded() {
 canvasApp();
}

function canvasApp() {
 var message = "your text";
 var fillOrStroke ="fill";
 if (!canvasSupport()) { return; } var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 var formElement = document.getElementById("textBox");
 formElement.addEventListener("keyup", textBoxChanged, false); formElement = document.getElementById("fillOrStroke");
 formElement.addEventListener("change", fillOrStrokeChanged, false);
 drawScreen();
 function drawScreen() { //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //Text context.font = "50px serif"
 var metrics = context.measureText(message); var textWidth = metrics.width; var xPosition = (theCanvas.width/2) - (textWidth/2); var yPosition = (theCanvas.height/2);
 switch(fillOrStroke) { case "fill": context.fillStyle = "#FF0000"; context.fillText (message, xPosition,yPosition); break; case "stroke": context.strokeStyle = "#FF0000"; context.strokeText (message, xPosition,yPosition); break; case "both": context.fillStyle = "#FF0000"; context.fillText (message, xPosition ,yPosition); context.strokeStyle = "#000000"; context.strokeText (message, xPosition,yPosition); break; }
 } function textBoxChanged(e) { var target = e.target; message = target.value; drawScreen();
 }
 function fillOrStrokeChanged(e) { var target = e.target; fillOrStroke = target.value; drawScreen();
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;form&gt;
 Text: &lt;input placeholder="your text" /&gt;
 &lt;br&gt;
 Fill Or Stroke : &lt;select&gt;
 &lt;option value="fill"&gt;fill&lt;/option&gt;
 &lt;option value="stroke"&gt;stroke&lt;/option&gt;
 &lt;option value="both"&gt;both&lt;/option&gt; &lt;/select&gt;
 &lt;br&gt;
&lt;/form&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h2>Setting the Text Font</h2>
Now that we have placed text on the canvas, it’s time to explore some of the basics of setting the <code>context.font</code> property. 

As you will see, specifying the font for displaying basic text on Canvas is really no different from doing the same thing in HTML and CSS.
<h3>Font Size, Face Weight, and Style Basics</h3>
It is very easy to style text that will be rendered on the canvas. 
It requires you to set the size, weight, style, and font face in a CSS-compliant text string that is applied to the <code>context.font</code> property. 

The basic format looks like this:
<table><tr><td>[<em><code>font style</code></em>] [<em><code>font weight</code></em>] [<em><code>font size</code></em>] [<em><code>font face</code></em>]</td></tr></table>
An example might be:
context.font = "italic bold 24px serif";

or:
context.font = "normal lighter 50px cursive";
Once the <code>context.font</code> property is set, it will apply to <em>all</em> text that is rendered afterward—until the <code>context.font</code> is set to another CSS-compliant string.
<h3>Handling Font Size and Face in Text Arranger</h3>

In Text Arranger, we have implemented only a subset of the available font options for displaying text. 
We have chosen these to make the application work in as many browsers as possible. 
Here is a short rundown of the options we will implement.
<h4>Available font styles</h4>

CSS defines the valid font styles as:
<table><tr><td>
<code>normal</code> | <code>italic</code> | <code>oblique</code> | <code>inherit</code>
</td></tr></table>

In Text Arranger, we have implemented all but <code>inherit</code>.
Here is the markup we used to create the font style <code>&lt;select&gt;</code> box in HTML. 
We made the id of the form control equal to <code>fontStyle</code>. 
We will use this id when we listen for a <code>change</code> event, which is dispatched when the user updates the value of this control. 

We will do this for all the controls in this version of Text Arranger:
&lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt;
 &lt;option value="italic"&gt;italic&lt;/option&gt; &lt;option value="oblique"&gt;oblique&lt;/option&gt;
&lt;/select&gt;
<h4>Available font weights</h4>
CSS defines the valid font weights as:

<table><tr><td>
<code>normal</code> | <code>bold</code> | <code>bolder</code> | <code>lighter</code> | <code>100</code> | <code>200</code> | <code>300</code> | <code>400</code> | <code>500</code> | <code>600</code> | <code>700</code> | <code>800</code> | <code>900</code> | <code>inherit</code> | <code>auto</code>
</td></tr></table>
We have used only <code>normal</code>, <code>bold</code>, <code>bolder</code>, and <code>lighter</code> in Text Arranger. 

You can add the other values as you see fit.
Here is the markup we used to create the font weight <code>&lt;select&gt;</code> box in HTML:
&lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt; &lt;option value="bold"&gt;bold&lt;/option&gt;
 &lt;option value="bolder"&gt;bolder&lt;/option&gt;
 &lt;option value="lighter"&gt;lighter&lt;/option&gt;
&lt;/select&gt;

<h4>Generic font faces</h4>
Because we cannot be sure which font will be available in the browser at any time, we have limited the font face choices in Text Arranger to those that are defined as “generic” in the CSS specification: <code>serif</code>, <code>sans-serif</code>, <code>cursive</code>, <code>fantasy</code>, and <code>monospace</code>.
Here is the markup we used to create the font face <code>&lt;select&gt;</code> box in HTML:
&lt;select&gt; &lt;option value="serif"&gt;serif&lt;/option&gt;
 &lt;option value="sans-serif"&gt;sans-serif&lt;/option&gt;
 &lt;option value="cursive"&gt;cursive&lt;/option&gt;
 &lt;option value="fantasy"&gt;fantasy&lt;/option&gt; &lt;option value="monospace"&gt;monospace&lt;/option&gt;
&lt;/select&gt;
<h4>Font size and HTML5 range control</h4>
To specify the size of the font, we have implemented the new HTML5 <code>range</code> form control. 

<code>range</code> is an <code>&lt;input&gt;</code> type that creates a slider on the HTML page to limit the numerical input to that specified in the range. 
A <code>range</code> is created by specifying <code>range</code> as the <code>type</code> of a form input control. 
<code>range</code> has four properties that can be set:

<code>min</code>
The minimum value in the range

<code>max</code>
The maximum value in the range

<code>step</code>
The number of units to step when the range slider is moved

<code>value</code>
The default value of the range

Here is the markup we used to specify the range in the Text Arranger HTML:
&lt;input type="range"
 min="0" max="200"
 step="1"
 value="50"/&gt;
If the browser does not support this <code>range</code> control, it will be rendered as a text box.

<h3>Note</h3>
At the time of this writing, <code>range</code> did not render in Firefox.
<h4>Creating the necessary variables in the canvasApp() function</h4>
In the <code>canvasApp()</code> container function, we need to create four variables—<code>fontSize</code>, <code>fontFace</code>, <code>fontWeight</code>, and <code>fontStyle</code>—that will hold the values set by the HTML form controls for Text Arranger. 

We create a default value for each so that the canvas can render text the first time the <code>drawScreen()</code> function is called. 
After that, <code>drawScreen()</code> will be called only when a <code>change</code> event is handled by one of the event handler functions we will create for each form control:
var fontSize = "50";
var fontFace = "serif";

var fontWeight = "normal";
var fontStyle = "normal";
<h4>Setting event handlers in canvasApp()</h4>
Just like we did in version 1.0 of Text Arranger, we need to create event listeners and the associated event handler functions so changes on the HTML page form controls can interact with HTML5 Canvas. 

All of the event listeners below listen for a <code>change</code> event on the form control:
formElement = document.getElementById("textSize");
formElement.addEventListener('change', textSizeChanged, false);
formElement = document.getElementById("textFont");

formElement.addEventListener('change', textFontChanged, false);
formElement = document.getElementById("fontWeight");
formElement.addEventListener('change', fontWeightChanged, false);
formElement = document.getElementById("fontStyle");

formElement.addEventListener('change', fontStyleChanged, false);
<h4>Defining event handler functions in canvasApp()</h4>
Below are the event handlers we need to create for each form control. 
Notice that each handler updates the variable associated with part of the valid CSS font string, and then calls <code>drawScreen()</code> so the new text can be painted onto the canvas:

function textSizeChanged(e) {
 var target = e.target;
 fontSize = target.value;
 drawScreen();

}
function textFontChanged(e) {
 var target = e.target;
 fontFace = target.value; drawScreen();
}
function fontWeightChanged(e) {
 var target = e.target; fontWeight = target.value;
 drawScreen();
}
function fontStyleChanged(e) { var target = e.target;
 fontStyle = target.value;
 drawScreen();
}

<h4>Setting the font in the drawScreen() function</h4>
Finally, in the <code>drawScreen()</code> function, we put all of this together to create a valid CSS font string that we apply to the <code>context.font</code> property:
context.font = fontWeight + " " + fontStyle + " " + fontSize + "px " + fontFace;
Figures <a href="ch03.html#setting_the_font_size_and_face" title="Figure 3-3. 

Setting the font size and face">3-3</a> and <a href="ch03.html#setting_font_as_bold_and_italic" title="Figure 3-4. 
Setting the font as bold and italic">3-4</a> show the results.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893671.png" alt="Setting the font size and face" width="501" height="503">
Figure 3-3. 

Setting the font size and face
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893673.png" alt="Setting the font as bold and italic" width="501" height="503">
Figure 3-4. 
Setting the font as bold and italic

<h3>Font Color</h3>
Setting the font color for text rendered on HTML5 Canvas is as simple as setting the <code>context.fillStyle</code> or <code>context.strokeStyle</code> property to a valid CSS RGB color. 
Use the format “#RRGGBB”, where RR is the red component hexadecimal value, GG is the green component hexadecimal value, and BB is the blue component hexadecimal value. 
Here are some examples:

<code>context.fillStyle = "#FF0000";</code>
Sets the text fill to red.

<code>context.strokeStyle = "#FF00FF";</code>
Sets the text stroke to purple.

<code>context.fillStyle = "#FFFF00";</code>
Sets the text fill to yellow.

<h4>Handling font color with JSColor</h4>
For Text Arranger, we will allow the user to select the text color. 

We could have made this a drop-down or a text box, but instead, we want to use the new HTML5 <code>&lt;input&gt;</code> type of <code>color</code>. 
This handy new form control works directly in the web browser, allowing users to visually choose a color from a beautifully designed color picker. 
At the time of this writing, only Opera has implemented the <code>color &lt;input&gt;</code> object of the HTML5 specification.
However, since we could really use a nice color picker for Text Arranger, we will implement a third-party color picker, JSColor (<a href="http://jscolor.com/">http://jscolor.com/</a>). 

The <code>jsColor</code> control creates a nice color picker in JavaScript (see <a href="ch03.html#setting_the_font_color" title="Figure 3-5. 
Setting the font color">Figure 3-5</a>), similar to the one that will someday grace browsers supporting HTML5.
To implement <code>jsColor</code> and the color picker for Text Arranger, first download the <em>jscolor.js</em> library and put it in the same folder as Text Arranger. 
Then, add this line of code in the <code>&lt;head&gt;</code> to include <code>jsColor</code> in the HTML page:

&lt;script type="text/javascript" src="jscolor/jscolor.js"&gt;&lt;/script&gt;
Then add a new <code>&lt;input&gt;</code> element to the ever-growing HTML <code>&lt;form&gt;</code> on the Text Arranger HTML page, and give it the CSS class designation <code>color</code>:
&lt;input value="FF0000"/&gt;
When you pick a color with <code>jsColor</code>, it creates a text value that looks like “FF0000”, representing the color value chosen. 

However, we already know that we need to append the pound (#) sign to the front of that value to work with HTML5 Canvas. 
The <code>textFillColorChanged</code> event handler does this by appending “#” to the value of the <code>textFillColor</code> form control:
function textFillColorChanged(e) { var target = e.target; textFillColor = "#" + target.value; drawScreen();
 }

Oh yes, and let’s not forget the event listener we must create so that we can direct and “change” events from the <code>textFillColor &lt;input&gt;</code> element to the <code>textFillColor</code><code>Changed()</code> event handler:
formElement = document.getElementById("textFillColor");
formElement.addEventListener('change', textFillColorChanged, false);
Finally, in the <code>canvasApp()</code> function, we need to create the <code>textFillColor</code> variable:

var textFillColor = "#ff0000";
We do this so that the variable can be updated by the aforementioned event handler, and then implemented when that event handler calls the <code>drawScreen()</code> function:
switch(fillOrStroke) {
 case "fill": context.fillStyle = textFillColor; context.fillText (message, xPosition,yPosition); break; case "stroke": context.strokeStyle = textFillColor; context.strokeText (message, xPosition,yPosition); break;
 case "both": context.fillStyle = textFillColor; context.fillText (message, xPosition ,yPosition); context.strokeStyle = "#000000"; context.strokeText (message, xPosition,yPosition); break;
 }
Notice that we needed to update the <code>switch()</code> statement created for Text Arranger version 1.0 so that it used <code>textFillColor</code> instead of hardcoded values. 

However, when both a stroke and a fill are chosen, we still render the stroke as black (“#000000”). 
We could have added an additional color picker for the <code>strokeColor</code>, but that is something you can do if you want to start expanding the application. 
<a href="ch03.html#setting_the_font_color" title="Figure 3-5. 
Setting the font color">Figure 3-5</a> illustrates what it looks like now.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893675.png" alt="Setting the font color" width="501" height="538">
Figure 3-5. 
Setting the font color
<h3>Font Baseline and Alignment</h3>

You have options to align text on HTML5 Canvas both vertically and horizontally. 
These alignments affect the text in relation to Canvas itself, but only to the invisible bounding box that would surround the text’s topmost, bottommost, rightmost, and leftmost sides. 
This is an important distinction because it means these alignments affect the text in ways that might be unfamiliar to you.
<h4>Vertical alignment</h4>

The font baseline is the vertical alignment of the font glyphs based on predefined horizontal locations in a font’s <code>em square</code> (the grid used to design font outlines) in relation to font descenders. 
Basically, font glyphs, like lowercase <em>p</em> and <em>y</em> that traditionally extend “below the line,” have <em>descenders</em>. 
The baseline tells the canvas where to render the font based on how those descenders relate to other glyphs in the font face.
The HTML5 Canvas API online has a neat graphic that attempts to explain baseline. 

We could copy it here, but in reality, we think it’s easier to understand by <em>doing</em>, which is one of the main reasons we wrote the Text Arranger application.
The options for the <code>context.textBaseline</code> property are:
<code>top</code>

The top of the text <code>em square</code> and the top of the highest glyph in the font face. 
Selecting this baseline will push the text the farthest down (highest <code>y</code> position) the canvas of all the baselines.

<code>hanging</code>
This is a bit lower than the <code>top</code> baseline. 
It is the horizontal line from which many glyphs appear to “hang” from near the top of their face.

<code>middle</code>
The dead vertical center baseline. 

We will use <code>middle</code> to help us vertically center the text in Text Arranger.
<code>alphabetic</code>

The bottom of vertical writing script glyphs such as Arabic, Latin, and Hebrew.
<code>ideographic</code>

The bottom of horizontal writing script glyphs such as Han Ideographs, Katakana, Hiragana, and Hangul.
<code>bottom</code>

The bottom of the <code>em square</code> of the font glyphs. 
Choosing this baseline will push the font the farthest up (lowest <code>y</code> position) the canvas.

So, for example, if you want to place your text with a <code>top</code> baseline, you would use the following code:
context.textBaseline = "top";
All text displayed on the canvas afterward would have this baseline. 
To change the baseline, you would change the property:

context.textBaseline = "middle";
In reality, you will probably choose a single baseline for your app and stick with it, unless you are creating a word-processing or design application that requires more precise text handling.
<h4>Horizontal alignment</h4>
The <code>context.textAlign</code> property represents the horizontal alignment of the text based on its <code>x</code> position. 

These are the available <code>textAlign</code> values:
<code>center</code>

The dead horizontal center of the text. 
We can use this alignment to help center our text in Text Arranger.
<code>start</code>

Text is displayed directly after the text <code>y</code> position.
<code>end</code>

All text is displayed before the text <code>y</code> position.
<code>left</code>

Text is displayed starting with the <code>y</code> position of the text in the leftmost position (just like <code>start</code>).
<code>right</code>

Text is displayed with the <code>y</code> position in the rightmost position of the text (just like <code>end</code>).

For example, to set the text alignment to <code>center</code>, you would use the code:
context.textAlign = "center";
After this property is set, all text would be displayed with the <code>y</code> value of the text as the center point. 
However, this does not mean the text will be “centered” on the canvas. 

To do that, you need to find the center of the canvas, and use that location as the <code>y</code> value for the text position. 
We will do this in Text Arranger.
These values can also be modified by the <code>dir</code> attribute of the <code>Canvas</code> object (inherited from the DOM <code>document</code> object). 
<code>dir</code> changes the direction of how text is displayed; the valid values for <code>dir</code> are <code>rtl</code> (“right to left”) and <code>ltr</code> (“left to right”).

<h4>Handling text baseline and alignment</h4>
We are going to handle the text baseline and alignment much like we handled the other text properties in Text Arranger. 
First, we will add some variables to the <code>canvasApp()</code> function in which Text Arranger operates that will hold the alignment values. 
Notice that we have set the <code>textAlign</code> variable to <code>center</code>, helping us simplify centering the text on the canvas:

var textBaseline = "middle";
var textAlign = "center";
Next, we add the <code>&lt;select&gt;</code> form elements for each new attribute to the HTML portion of the page:
Text Baseline &lt;select&gt; &lt;option value="middle"&gt;middle&lt;/option&gt;
 &lt;option value="top"&gt;top&lt;/option&gt;
 &lt;option value="hanging"&gt;hanging&lt;/option&gt;
 &lt;option value="alphabetic"&gt;alphabetic&lt;/option&gt; &lt;option value="ideographic"&gt;ideographic&lt;/option&gt;
 &lt;option value="bottom"&gt;bottom&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt; Text Align &lt;select&gt;
 &lt;option value="center"&gt;center&lt;/option&gt;
 &lt;option value="start"&gt;start&lt;/option&gt;
 &lt;option value="end"&gt;end&lt;/option&gt; &lt;option value="left"&gt;left&lt;/option&gt;
 &lt;option value="right"&gt;right&lt;/option&gt;
 &lt;/select&gt;
We then add event listeners and event handler functions so we can connect the user interaction with the HTML form elements to the canvas display. 

We register the event listeners in the <code>canvasApp()</code> function:
formElement = document.getElementById("textBaseline");
formElement.addEventListener('change', textBaselineChanged, false);
formElement = document.getElementById("textAlign");

formElement.addEventListener('change', textAlignChanged, false);
Next, we need to create the event handler functions inside <code>canvasApp()</code>:
function textBaselineChanged(e) {
 var target = e.target; textBaseline = target.value;
 drawScreen();
}
function textAlignChanged(e) { var target = e.target;
 textAlign = target.value;
 drawScreen();
}

We then apply the new values in the <code>drawScreen()</code> function:
context.textBaseline = textBaseline;
context.textAlign = textAlign;
Finally, we change the code that centers the text horizontally on the screen. 

Because we used the <code>center</code> alignment for <code>context.textAlign</code>, we no longer need to subtract half the width of the text that we retrieved through <code>context.measureText()</code> like we did previously in Text Arranger 1.0:
var metrics = context.measureText(message);
var textWidth = metrics.width;
var xPosition = (theCanvas.width/2) - (textWidth/2);

Instead, we can simply use the center point of the canvas:
var xPosition = (theCanvas.width/2);
Remember, <code>center</code> is only the default alignment for the text. 
Because you can change this with Text Arranger, the text can still be aligned in different ways while you are using the application.

<a href="ch03.html#font_with_start_alignment_and_middle_bas" title="Figure 3-6. 
Font with start alignment and middle baseline">Figure 3-6</a> shows how a font set to <code>start</code> alignment with a <code>middle</code> baseline might appear on the canvas.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893677.png" alt="Font with start alignment and middle baseline" width="501" height="504">
Figure 3-6. 

Font with start alignment and middle baseline
<h3>Text Arranger Version 2.0</h3>
Now, try the new version of Text Arranger, shown in Example 3-2</a>. 
You can see that we have added a ton of new options that did not exist in version 1.0. 

One of the most striking things is how fluidly the text grows and shrinks as the font size is updated. 
Now, imagine scripting the font size to create animations. 
How would you do that? Could you create an application to record the manipulations the user makes with Text Arranger, and then play them back in real time?
Also, notice how all the alignment options affect one another. 

Experiment with how changing the text direction affects the vertical alignment. 
Choose different font faces and see how they affect the baseline. 
Do you see how an application like Text Arranger can help you understand the complex relationships of all the text properties on HTML5 Canvas in an interactive and—dare we say—fun way?
Example 3-2. 

Text Arranger 2.0
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH3EX2: Text Arranger Version 2.0&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jscolor/jscolor.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function eventWindowLoaded() { canvasApp();
}
function canvasApp() {
 var message = "your text"; var fillOrStroke = "fill";
 var fontSize = "50";
 var fontFace = "serif";
 var textFillColor = "#ff0000"; var textBaseline = "middle";
 var textAlign = "center";
 var fontWeight = "normal";
 var fontStyle = "normal"; if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 var formElement = document.getElementById("textBox"); formElement.addEventListener('keyup', textBoxChanged, false);
 formElement = document.getElementById("fillOrStroke");
 formElement.addEventListener('change', fillOrStrokeChanged, false);
 formElement = document.getElementById("textSize"); formElement.addEventListener('change', textSizeChanged, false);
 formElement = document.getElementById("textFillColor");
 formElement.addEventListener('change', textFillColorChanged, false);
 formElement = document.getElementById("textFont"); formElement.addEventListener('change', textFontChanged, false);
 formElement = document.getElementById("textBaseline");
 formElement.addEventListener('change', textBaselineChanged, false);
 formElement = document.getElementById("textAlign"); formElement.addEventListener('change', textAlignChanged, false);
 formElement = document.getElementById("fontWeight");
 formElement.addEventListener('change', fontWeightChanged, false);
 formElement = document.getElementById("fontStyle"); formElement.addEventListener('change', fontStyleChanged, false);
 drawScreen();
 function drawScreen() { //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
 //Text context.textBaseline = textBaseline; context.textAlign = textAlign; context.font = fontWeight + " " + fontStyle + " " + fontSize + "px " + fontFace; var xPosition = (theCanvas.width/2); var yPosition = (theCanvas.height/2);
 switch(fillOrStroke) { case "fill": context.fillStyle = textFillColor; context.fillText (message, xPosition,yPosition); break; case "stroke": context.strokeStyle = textFillColor; context.strokeText (message, xPosition,yPosition); break; case "both": context.fillStyle = textFillColor; context.fillText (message, xPosition ,yPosition); context.strokeStyle = "#000000"; context.strokeText (message, xPosition,yPosition); break; }
 }
 function textBoxChanged(e) { var target = e.target; message = target.value; drawScreen(); }
 function fillOrStrokeChanged(e) { var target = e.target; fillOrStroke = target.value; drawScreen();
 }
 function textSizeChanged(e) { var target = e.target; fontSize = target.value; drawScreen(); }
 function textFillColorChanged(e) { var target = e.target; textFillColor = "#" + target.value; drawScreen();
 }
 function textFontChanged(e) { var target = e.target; fontFace = target.value; drawScreen(); }
 function textBaselineChanged(e) { var target = e.target; textBaseline = target.value; drawScreen();
 }
 function textAlignChanged(e) { var target = e.target; textAlign = target.value; drawScreen(); }
 function fontWeightChanged(e) { var target = e.target; fontWeight = target.value; drawScreen();
 }
 function fontStyleChanged(e) { var target = e.target; fontStyle = target.value; drawScreen(); }
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;form&gt;
 Text: &lt;input placeholder="your text" /&gt;
 &lt;br&gt; Fill Or Stroke :
 &lt;select&gt;
 &lt;option value="fill"&gt;fill&lt;/option&gt;
 &lt;option value="stroke"&gt;stroke&lt;/option&gt; &lt;option value="both"&gt;both&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Text Font: &lt;select&gt; &lt;option value="serif"&gt;serif&lt;/option&gt;
 &lt;option value="sans-serif"&gt;sans-serif&lt;/option&gt;
 &lt;option value="cursive"&gt;cursive&lt;/option&gt;
 &lt;option value="fantasy"&gt;fantasy&lt;/option&gt; &lt;option value="monospace"&gt;monospace&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Text Size: &lt;input type="range" min="0" max="200" step="1" value="50"/&gt; &lt;br&gt;
 Text Color: &lt;input value="FF0000"/&gt;
 &lt;br&gt;
 Font Weight: &lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt;
 &lt;option value="bold"&gt;bold&lt;/option&gt;
 &lt;option value="bolder"&gt;bolder&lt;/option&gt; &lt;option value="lighter"&gt;lighter&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Font Style: &lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt;
 &lt;option value="italic"&gt;italic&lt;/option&gt;
 &lt;option value="oblique"&gt;oblique&lt;/option&gt; &lt;/select&gt;
 &lt;br&gt;
 Text Baseline &lt;select&gt;
 &lt;option value="middle"&gt;middle&lt;/option&gt; &lt;option value="top"&gt;top&lt;/option&gt;
 &lt;option value="hanging"&gt;hanging&lt;/option&gt;
 &lt;option value="alphabetic"&gt;alphabetic&lt;/option&gt;
 &lt;option value="ideographic"&gt;ideographic&lt;/option&gt; &lt;option value="bottom"&gt;bottom&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Text Align &lt;select&gt; &lt;option value="center"&gt;center&lt;/option&gt;
 &lt;option value="start"&gt;start&lt;/option&gt;
 &lt;option value="end"&gt;end&lt;/option&gt;
 &lt;option value="left"&gt;left&lt;/option&gt; &lt;option value="right"&gt;right&lt;/option&gt;
 &lt;/select&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h2>Text and the Canvas Context</h2>
We’ve already discussed a couple Canvas context properties that affect the canvas in a global fashion: <code>fillStyle</code> and <code>strokeStyle</code>. 
However, there are two areas that visually demonstrate how changes to the properties of the context can affect the entire HTML5 Canvas: alpha transparencies and shadows.

<h3>Global Alpha and Text</h3>
Using alpha is a cool way to make objects seem to be partially or fully transparent on HTML5 Canvas. 
The <code>globalAlpha</code> property of the Canvas context is used for this purpose. 
After <code>globalAlpha</code> is applied, it affects all drawing on the canvas, so you need to be careful when setting it.

The valid values for <code>context.globalAlpha</code> are numbers between 0.0 (transparent) and 1.0 (opaque), and they act as a percentage for the alpha value. 
For example, a 50% alpha value would be coded like this:
context.globalAlpha = 0.5;
A 100% alpha (no transparency) would be coded like this:

context.globalAlpha = 1.0;
<h4>Handling globalAlpha transparencies</h4>
Besides the now-familiar elements that we included for most of the other configurable options in Text Arranger, the <code>globalAlpha</code> property requires us to think a bit more about when we use it and how it will affect the rest of the canvas.
First, we create a variable named <code>textAlpha</code> in the <code>canvasApp()</code> function and initialize it with <code>1</code>, which means the text will have no transparency when it is first displayed:

var textAlpha = 1;
Next, in the <code>drawImage()</code> function, we need to set the <code>globalAlpha</code> property twice: once before we draw the background and the bounding box frame…
function drawScreen() { //Background context.globalAlpha = 1;

…and then again to the value stored in <code>textAlpha</code>, just before rendering the text to the canvas:
 context.globalAlpha = textAlpha;
This will reset <code>globalAlpha</code> so we can draw the background, but it will still allow us to use a configurable alpha value for the displayed text.
We will use another HTML5 <code>range</code> control in our form, but this time we set the value range with a min of 0.0 and a max of 1.0, stepping 0.01 every time the range is moved:

Alpha: &lt;input type="range" min="0.0" max="1.0" step="0.01" value="1.0"/&gt;
The <code>textAlphaChanged()</code> function works just like the other event handler functions we created in this chapter:
function textAlphaChanged(e) { var target = e.target; textAlpha = (target.value); drawScreen();
 }

Also, don’t forget the event listener for the <code>textAlpha range</code> control:
formElement = document.getElementById("textAlpha");
formElement.addEventListener('change', textAlphaChanged, false);
The results will look like <a href="ch03.html#text_with_globalalpha_applied" title="Figure 3-7. 

Text with globalAlpha applied">Figure 3-7</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893679.png" alt="Text with globalAlpha applied" width="501" height="653">
Figure 3-7. 
Text with globalAlpha applied

<h3>Global Shadows and Text</h3>
HTML5 Canvas includes a unique set of properties for creating a shadow for drawings. 
The <code>context.shadow</code> functions are not unique to text, but they can make some very good text effects with very little effort.
To create a <code>shadowEffect</code>, there are four properties of the Canvas context that need to be manipulated:

<code>context.shadowColor</code>
The color of the shadow. 

This uses the same “#RRGGBB” format of the <code>fillStyle</code> and <code>strokeStyle</code> properties.
<code>context.shadowOffsetX</code>

The <code>x</code> offset of shadow. 
This can be a positive or negative number.
<code>context.shadowOffsetY</code>

The <code>y</code> offset of shadow. 
This can be a positive or negative number.

<code>context.shadowBlur</code>
The blur filter diffusion of the shadow. 
The higher the number, the more diffusion.

For example, if you want to create a red shadow that is 5 pixels to the right and 5 pixels down from your text, with a blur of 2 pixels, you would set the properties like this:
context.shadowColor = "#FF0000";

context.shadowOffsetX = 5;
context.shadowOffsetY = 5;
context.shadowBlur = 2;
<h4>Handling global shadows</h4>

Just like we saw with <code>globalAlpha</code>, we must reset the shadow properties before we draw the background for <code>textArranger</code>; otherwise, the shadow will apply to the entire image. 
First, in the <code>canvasApp()</code> function, we create a set of variables to hold the shadow values:
var textAlpha = 1;
var shadowX = 1;

var shadowY = 1;
var shadowBlur = 1;
var shadowColor = "#707070";
We then make sure to turn off the shadow before we render the background for <code>textArranger</code> in the <code>drawScreen()</code>. 

We don’t have to reset the <code>shadowColor</code>, but we think it is good practice to update all the relative properties relating to any global change to the Canvas context:
context.shadowColor = "#707070";
context.shadowOffsetX = 0;
context.shadowOffsetY = 0;

context.shadowBlur = 0;
Later in <code>drawScreen()</code>, we render the shadow based on the settings in the four variables we created:
context.shadowColor = shadowColor;
context.shadowOffsetX = shadowX;

context.shadowOffsetY = shadowY;
context.shadowBlur = shadowBlur;
We also need to create the HTML to allow the user to update the shadow settings. 
We do this with three <code>range</code> controls, as well as another color picker using <code>jsColor</code>:

Shadow X:&lt;input type="range" min=",100" max="100" step="1" value="1"/&gt;
&lt;br&gt;
Shadow Y:&lt;input type="range" min=",100" max="100" step="1" value="1"/&gt;
&lt;br&gt;

Shadow Blur: &lt;input type="range" min="1" max="100" step="1" value="1" /&gt;
&lt;br&gt;
Shadow Color: &lt;input value="707070"/&gt;
Finally, we need to add the event listeners and event handler functions so the HTML form elements can communicate with the canvas. 

See the results in <a href="ch03.html#text_with_global_shadow_applied" title="Figure 3-8. 
Text with global shadow applied">Figure 3-8</a>:
formElement = document.getElementById("shadowX");
formElement.addEventListener('change', shadowXChanged, false);

formElement = document.getElementById("shadowY");
formElement.addEventListener('change', shadowYChanged, false);
formElement = document.getElementById("shadowBlur");
formElement.addEventListener('change', shadowBlurChanged, false);

formElement = document.getElementById("shadowColor");
formElement.addEventListener('change', shadowColorChanged, false);
function shadowXChanged(e) { var target = e.target; shadowX = target.value; drawScreen();
 } function shadowYChanged(e) { var target = e.target; shadowY = target.value; drawScreen();
 }
 function shadowBlurChanged(e) { var target = e.target; shadowBlur = target.value; drawScreen();
 } function shadowColorChanged(e) { var target = e.target; shadowColor = target.value; drawScreen();
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893681.png" alt="Text with global shadow applied" width="501" height="653">
Figure 3-8. 

Text with global shadow applied
<h2>Text with Gradients and Patterns</h2>
We’ve already explored the <code>fillColor</code> and <code>strokeColor</code> properties of the Canvas context by setting those value to CSS-compliant colors. 
However, those very same properties can be set to refer to a few other objects defined in the Canvas API to create some stunning text effects. 

The objects are:
Linear gradient

A linear color gradient with two or more colors
Radial gradient

A circular color gradient with two or more colors
Image pattern

An <code>Image</code> object used as a fill pattern
<h3>Linear Gradients and Text</h3>

To create a linear gradient, make a call to the context’s <code>createLinearGradient()</code> method to create a <code>Gradient</code> object. 
The <code>createLinearGradient()</code> method accepts four parameters that all define the line of the linear gradient. 
The <em><code>x0</code></em> and <em><code>y0</code></em> parameters are the starting point of the line, and <em><code>x1</code></em> and<em> <code>y1</code></em> represent the ending point of the line:
var gradient = context.createLinearGradient( <em><code>[x0]</code></em>,<em><code>[y0]</code></em>,<em><code>[x1]</code></em>,<em><code>[y1]</code></em>);

For example, if you want to create a linear gradient that starts at the beginning of the text (located at 100,100), and has an endpoint that is the width of your text as displayed on the canvas, you might write the following code:
var metrics = context.measureText(message);
var textWidth = metrics.width;
var gradient = context.createLinearGradient(100, 100, textWidth, 100);

After you have created the line that represents the gradient, you need to add colors that will form the gradations of the gradient fill. 
This is done with the <code>addColorStop()</code> method, which requires two arguments: <code>offset</code> and <code>color</code>:
gradient.addColorStop([offset],[color]);

<code>offset</code>
This is the offset on the gradient line to start the color gradation. 
The entire gradient is represented by the numbers between 0.0 and 1.0. 

The offset will be a decimal that represents a percentage.
<code>color</code>

A valid CSS color in the format “#RRGGBB”.
So, if you want black to be the first color in the gradient, and then red to be the second color that starts halfway down the gradient line, you would create two calls to <code>add</code><code>ColorStop()</code>:

gradient.addColorStop(0, "#000000");
gradient.addColorStop(.5, "#FF0000");
<h3>Note</h3>
If you fail to add colors with <code>addColorStop()</code>, the text will be rendered invisible.

The results are shown in <a href="ch03.html#text_with_linear_gradient_applied" title="Figure 3-9. 
Text with linear gradient applied">Figure 3-9</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893683.png" alt="Text with linear gradient applied" width="501" height="653">
Figure 3-9. 

Text with linear gradient applied
<h3>Radial Gradients and Text</h3>
A radial gradient is created much like a linear gradient, except that it represents a cone—not a line. 
The cone is created by defining the center points and the radii of two different circles when calling the <code>createRadialGradient()</code> function of the Canvas context:

var gradient = context.createRadialGradient(<em><code>[x0]</code></em>,<em><code>[y0]</code></em>,<em><code>[radius0]</code></em>,<em><code>[x1]</code></em>,<em><code>[y1]</code></em>,<em><code>[radius1]</code></em>);
Let’s say you want to create a radial gradient based on a cone. 
It starts with a circle that has its center point at 100,100 and a radius of 20, and ends at a circle with its center point at 200,100 and a radius of 5. 
The code would look like this:

var gradient = context.createRadialGradient(100,100,20,200,100,5);
Adding color stops to a radial gradient works the same as with a linear gradient, except the color moves along the cone instead of the line:
gradient.addColorStop(0, "#000000 ");
gradient.addColorStop(.5, "#FF0000");

<h3>Image Patterns and Text</h3>
Another option for filling text on HTML5 Canvas is to use an <code>Image</code> object. 
We will devote all of <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a> to using the Image API, so here we will only discuss the basics of how to use one as a pattern for a text fill.

To create an image pattern, call the <code>createPattern()</code> method of the Canvas context, passing a reference to an <code>Image</code> object, and an option for <code>repetition</code>:
var pattern = context.createPattern(<em><code>[image]</code></em>, <em><code>[repetition]</code></em>);
<code>image</code>

A valid <code>Image</code> object that has been loaded with an image by setting the <code>pattern</code><code>.src</code> property and waiting for the image to load by setting an event listener for the <code>Image onload</code> event. 
The Canvas specification also allows for a <code>video</code> element or another <code>&lt;canvas&gt;</code> to be used here as well.

<code>repetition</code>
The “tiling” of the image. 
This can have one of four values:

<code>repeat</code>
The image is tiled on both the x and y axes.

<code>repeat-x</code>
The image is tiled only on the x-axis (horizontally).

<code>repeat-y</code>
The image is tiled only on the y-axis (vertically).

<code>no-repeat</code>
The image is not tiled.


To use the image pattern, apply it to the <code>fillColor</code> and <code>strokeColor</code> properties of the context, just as you would apply a color:
context.fillStyle = pattern;
or:
context.strokeStyle = pattern;

For example, to load an image named <em>texture.jpg</em> and apply it to the <code>fillStyle</code> so that it tiles on both the x and y axes, you would write code like this:
var pattern = new Image();
pattern.src = "texture.jpg"
pattern.onload = function() { var pattern = context.createPattern("texture.jpg", "repeat");
 context.fillStyle = pattern;
...
}

Patterns with Video: The Bad News
The HTML5 Canvas API specifies that an HTML5 <code>video</code> element can be used as the source for <code>createPattern()</code> instead of an image. 
However, all of our attempts to do so emitted the following JavaScript error:
Uncaught Error: TYPE_MISMATCH_ERR: DOM Exception 17

According to the DOM reference at <a href="http://www.gnu.org">www.gnu.org</a>, DOM Exception 17, TYPE_MISMATCH_ERR occurs “if the type of an object is incompatible with the expected type of the parameter associated to the object.”
So it appears that most browsers have not included support for using video as the pattern for <code>createPattern()</code>. 
However, you can still load and play video on Canvas, which we will discuss in depth in <a href="ch06.html" title="Chapter 6. 
Mixing HTML5 Video and Canvas">Chapter 6</a>.

<h3>Handling Gradients and Patterns in Text Arranger</h3>
Text Arranger 3.0 includes many changes that were implemented to support using gradients and image patterns with text on HTML5 Canvas. 
To see these changes in action, we first need to make sure that we have preloaded the <em>texture.jpg</em> image, which we will use for the <code>context.createPattern()</code> functionality. 
To do this, we will create a new function named <code>eventAssetsLoaded()</code> that we will set as the event handler for the <code>onload</code> event of the <code>Image</code> object that will hold the pattern. 

When that image has loaded, we will call <code>canvasApp()</code> in the same way we called it from <code>eventWindowLoaded()</code>:
function eventWindowLoaded() {
 var pattern = new Image();
 pattern.src = "texture.jpg"; pattern.onload = eventAssetsLoaded;
}
function eventAssetsLoaded() {
 canvasApp();

}
<h3>Note</h3>
We are not going to use the pattern variable we created in this function, as it does not have scope in the <code>canvasApp()</code> function. 
We are merely using it to make sure that the image is available before we use it.

In the <code>canvasApp()</code> function, we will create three variables to support this new functionality. 
<code>fillType</code> describes how the text will be filled (a regular color fill, a linear gradient, a radial gradient, or a pattern). 
The <code>textColorFill2</code> variable is the second color we will use for the gradient color stop. 
Finally, the <code>pattern</code> variable holds the <code>Image</code> object we preloaded, which we now need to create an instance of in <code>canvasApp()</code>:

var fillType = "colorFill";
var textFillColor2 = "#000000";
var pattern = new Image();
...

pattern.src = "texture.jpg";
Now, let’s jump to the HTML of our <code>&lt;form&gt;</code>. 
Since we have created different ways to fill the text we are displaying, we need to build a selection that allows for this choice. 
We will create a <code>&lt;select&gt;</code> box with the id of <code>fillType</code> for this purpose:

Fill Type: &lt;select&gt;
 &lt;option value="colorFill"&gt;Color Fill&lt;/option&gt;
 &lt;option value="linearGradient"&gt;Linear Gradient&lt;/option&gt;
 &lt;option value="radialGradient"&gt;Radial Gradient&lt;/option&gt; &lt;option value="pattern"&gt;pattern&lt;/option&gt;
 &lt;/select&gt;
We need to add a second color selection that we can use for the gradient fills. 
We will use the <code>jsColor</code> picker and the id <code>textColorFill2</code>:

Text Color 2: &lt;input value ="000000"/&gt;
 &lt;br&gt;
Back in <code>canvasApp()</code>, we need to create the event listeners for our two new form elements:
 formElement = document.getElementById("textFillColor2"); formElement.addEventListener('change', textFillColor2Changed, false);
 formElement = document.getElementById("fillType");
 formElement.addEventListener('change', fillTypeChanged, false);
We also need to create the associated event handler functions for the new form elements:

function textFillColor2Changed(e) { var target = e.target; textFillColor2 = "#" + target.value; drawScreen();
 }
 function fillTypeChanged(e) { var target = e.target; fillType = target.value; drawScreen();
 }

We need to add support to <code>drawScreen()</code> for this new functionality. 
First, we use the <code>measureText()</code> method of the context to get the width of the text, which we will use to create the gradients:
var metrics = context.measureText(message);
var textWidth = metrics.width;

Then, we need to decide how to format our “color” for the <code>fillStyle</code> or <code>strokeStyle</code> of the context. 
In this instance, it can be a CSS color, a gradient, or an image pattern; the list below provides more information.
Color fill

If we are doing a simple color fill, we operate just like in previous versions of Text Arranger. 
All we need to do is make <code>tempColor</code> equal to the value of <code>y</code>.

Linear gradient
For the linear gradient, we need to decide what line we are going to create for the gradient. 
Our line will start at the beginning of the text (<code>xPosition</code><code>-</code><code>textWidth/2</code> because the text uses the <code>center</code> alignment), and runs horizontally to the end of the text (<code>textWidth</code>). 

We also add two color stops (at 0 and 60%)—the colors are <code>textFillColor1</code> and <code>textFillColor2</code>.
Radial gradient

For the radial gradient, we are going to create a cone that starts at the center of the text (<code>xPosition</code>,<code>yPosition</code>) with a radius the size of the font (<code>fontSize</code>). 
The cone will extend horizontally the width of the text (<code>textWidth</code>) with a radius of 1.
Pattern

For this option, we create a pattern using the pattern <code>image</code> variable we previously created. 
We designate it to <code>repeat</code> so it will tile horizontally and vertically.

Here’s the code:
var tempColor;
if (fillType == "colorFill") { tempColor = textFillColor;
} else if (fillType == "linearGradient") {
 var gradient = context.createLinearGradient(xPosition- textWidth/2, yPosition, textWidth, yPosition);
 gradient.addColorStop(0,textFillColor); gradient.addColorStop(.6,textFillColor2);
 tempColor = gradient;
} else if (fillType == "radialGradient") {
 var gradient = context.createRadialGradient(xPosition, yPosition, fontSize, xPosition+textWidth, yPosition, 1); gradient.addColorStop(0,textFillColor);
 gradient.addColorStop(.6,textFillColor2);
 tempColor = gradient;
} else if (fillType == "pattern") { var tempColor = context.createPattern(pattern,"repeat");
} else {
 tempColor = textFillColor;
}

Now, when we set our <code>fillStyle</code> or <code>strokeStyle</code>, we use <code>tempColor</code> instead of <code>textFillColor</code>. 
This will set the proper text fill choice that will be displayed on the canvas, as shown in <a href="ch03.html#text_with_image_pattern_applied" title="Figure 3-10. 
Text with image pattern applied">Figure 3-10</a>:
context.fillStyle = tempColor;

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893685.png" alt="Text with image pattern applied" width="501" height="653">
Figure 3-10. 
Text with image pattern applied
<h2>Width, Height, Scale, and toDataURL() Revisited</h2>
In <a href="ch01.html" title="Chapter 1. 
Introduction to HTML5 Canvas">Chapter 1</a>, we briefly discussed that you can set the width and height of the canvas, as well as the scale (style <code>width</code> and <code>height</code>) of the canvas display area, dynamically in code. 
We also showed you an example of using the <code>Canvas</code> object’s <code>toDataURL()</code> method to export a “screenshot” of the Canvas application. 
In this section, we will revisit those functions as they relate to Text Arranger 3.0.

<h3>Dynamically Resizing the Canvas</h3>
In the code we developed in this chapter, we created a reference to the <code>Canvas</code> object on the HTML page—with the id <code>canvasOne</code>—and used it to retrieve the 2D context of the <code>Canvas</code> object:
var theCanvas = document.getElementById("canvasOne");
var context = theCanvas.getContext("2d");

While the 2D context is very important because we used it to draw directly onto the canvas, we did not spend any time discussing the <code>Canvas</code> object itself. 
In this chapter, we use the <code>width</code> property of the <code>Canvas</code> object to center text on the canvas. 
However, the <code>Canvas</code> object also includes another property named <code>height</code>, and both of these properties can be used to dynamically resize the <code>Canvas</code> object on demand. 
Why would you want to do this? There could be many uses, such as:

Updating the canvas to the exact size of a loaded <code>video</code> object
Dynamically animating the canvas after the page is loaded

Other, more creative uses like the one we will experiment with next
Resizing the canvas on the fly is quite easy. 

To do it, simply set the <code>width</code> and <code>height</code> properties of the <code>Canvas</code> object, and then redraw the canvas contents:
Canvas.width = 600;
Canvas.height = 500;
drawScreen();

The Canvas 2D API describes this function as a way to “scale” the canvas, but in practice, this does not appear to be true. 
Instead, the contents of the canvas are simply redrawn at the same size and same location on a larger canvas. 
Furthermore, if you don’t redraw the canvas content, it appears to be invalidated, blanking the canvas back to white. 
To properly scale the canvas, you need to use the CSS <code>width</code> and <code>height</code> attributes, as described in the next section. 

We discuss using a matrix transformation to scale the Canvas in both Chapters <a href="ch02.html" title="Chapter 2. 
Drawing on the Canvas">2</a> and <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">4</a>.
<h4>Dynamically resizing in Text Arranger</h4>

We will add the ability for the canvas to be resized at will, giving you a good example of how resizing works and what it does to your drawn content.
First, we will add a couple new <code>range</code> controls to the HTML <code>&lt;form&gt;</code>. 
As you might have already guessed, we really like this new HTML5 <code>range</code> control, so we’ve tried to find as many uses as possible for it—even though it’s only tangentially related to HTML5 Canvas.
We will give the controls the ids <code>canvasWidth</code> and <code>canvasHeight</code>:

Canvas Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt;
 &lt;br&gt;
 Canvas Height:
 &lt;input type="range" min="0" max="1000" step="1" value="300"/&gt; &lt;br&gt;
Next, we add event listeners for the new form elements in the <code>canvasApp()</code> function:
formElement = document.getElementById("canvasWidth");
formElement.addEventListener('change', canvasWidthChanged, false);

formElement = document.getElementById("canvasHeight");
formElement.addEventListener('change', canvasHeightChanged, false);
Finally, we add the event handlers. 
Notice that we set the <code>width</code> and <code>height</code> of <code>the</code><code>Canvas</code> (the variable we created that represents the <code>Canvas</code> object on screen) right inside these functions. 

We also need to make sure that we call <code>drawScreen()</code> in each function so that the canvas is redrawn on the newly resized area. 
If we did not do this, the canvas on the page would blank back to white:
function canvasWidthChanged(e) { var target = e.target; theCanvas.width = target.value; drawScreen();
 }

function canvasHeightChanged(e) { var target = e.target; theCanvas.height = target.value; drawScreen();
 }
We also need to change the way we draw the background for the application in the <code>drawScreen()</code> function so it supports a resized canvas. 
We do this by using the <code>width</code> and <code>height</code> attributes of <code>theCanvas</code> to create our background and bounding box:

context.fillStyle = '#ffffaa';
context.fillRect(0, 0, theCanvas.width, theCanvas.height);
//Box
context.strokeStyle = '#000000';

context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
<h3>Dynamically Scaling the Canvas</h3>
Besides resizing the canvas using <code>theCanvas.width</code> and <code>theCanvas.height</code> attributes, you can also use CSS styles to change its scale. 
Unlike resizing, scaling takes the current canvas bitmapped area and resamples it to fit into the size specified by the <code>width</code> and <code>height</code> attributes of the CSS style. 

For example, to scale the canvas to a 400×400 area, you might use this CSS style:
style = "width: 400px; height:400px"
To update the <code>style.width</code> and <code>style.height</code> properties of the canvas in Text Arranger, we first create two more <code>range</code> controls in the HTML page:
Canvas Style Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt; &lt;br&gt;
 Canvas Style Height:
 &lt;input type="range" min="0" max="1000" step="1" value="300"/&gt;
 &lt;br&gt;

Next, we set the event handler for each <code>range</code> control. 
However, this time we are using the same handler —<code>canvasStyleSizeChanged()</code>—for both:
formElement = document.getElementById("canvasStyleWidth");
formElement.addEventListener("change", canvasStyleSizeChanged, false);

formElement = document.getElementById("canvasStyleHeight");
formElement.addEventListener("change", canvasStyleSizeChanged, false);
In the event handler, we use the <code>document.getElementById()</code> method to get the values from both <code>range</code> controls. 
We then create a string that represents the style we want to set for the canvas:

"width:" + styleWidth.value + "px; height:" + styleHeight.value +"px;";
Finally, we use the <code>setAttribute()</code> method to set the “style”:
function canvasStyleSizeChanged(e) {
 var styleWidth = document.getElementById("canvasStyleWidth"); var styleHeight = document.getElementById("canvasStyleHeight"); var styleValue = "width:" + styleWidth.value + "px; height:" + styleHeight.value +"px;"; theCanvas.setAttribute("style", styleValue ); drawScreen(); }

<h3>Note</h3>
While trying to change <code>theCanvas.width</code> and <code>theCanvas.height</code> attributes, you might notice some oddities if you try to change the scale with CSS at the same time. 
It appears that once you change the scale with CSS, the <code>width</code> and <code>height</code> attributes update the canvas in relation to that scale, which might not be the effect you are expecting. 
Experiment with Text Arranger 3.0 to see how these different styles and attributes interact.

<h3>The toDataURL() Method of the Canvas Object</h3>
As we briefly explained in <a href="ch01.html" title="Chapter 1. 
Introduction to HTML5 Canvas">Chapter 1</a>, the <code>Canvas</code> object also contains a method named <code>toDataURL()</code>, which returns a string representing the canvas’ image data. 
A call with no arguments will return a string of image data of MIME type <em>image/png</em>. 

If you supply the <em>image/jpg</em> as an argument, you can also supply a second argument between the numbers 0.0 and 1.0 that represents the quality/compression level of the image.
We are going to use <code>toDataURL()</code> to output the image data of the canvas into a <code>&lt;textarea&gt;</code> on our form, and then open a window to display the actual image. 
This is just a simple way to show that the function is working.
The first thing we do is create our last two form controls in HTML for Text Arranger. 

We start by creating a button with the id of <code>createImageData</code> that, when pressed, will create the image data with a call to an event handler named <code>createImageDataPressed()</code>.
We also create a <code>&lt;textarea&gt;</code> named <code>imageDataDisplay</code> that will hold the text data of the image after the <code>createImageData</code> button is pressed:
&lt;input type="button" value="Create Image Data"&gt;
&lt;br&gt;

&lt;br&gt;
&lt;textarea rows=10 cols=30&gt;&lt;/textarea&gt;
Next, we set up the event listener for the <code>createImageData</code> button:
formElement = document.getElementById("createImageData");

formElement.addEventListener('click', createImageDataPressed, false);
Then, in the <code>createImageDataPressed()</code> event handler, we call the <code>toDataURL()</code> method of the <code>Canvas</code> object (<code>theCanvas</code>), and set the value of the i<code>mageDataDisplay</code> <code>&lt;textarea&gt;</code> to the data returned from <code>toDataURL()</code>. 
Finally, using the image data as the URL for the window, we call <code>window.open()</code>. 
When we do this, a window will pop open, displaying the actual image created from the canvas (see <a href="ch03.html#canvas_exported_image_with_todataurl_ope" title="Figure 3-11. 

Canvas exported image with toDataURL()">Figure 3-11</a>). 
You can right-click and save this image, just like any other image displayed in an HTML page. 
Pretty cool, eh?
function createImageDataPressed(e) { var imageDataDisplay = document.getElementById('imageDataDisplay'); imageDataDisplay.value = theCanvas.toDataURL(); window.open(imageDataDisplay.value,"canvasImage","left=0,top=0,width=" + theCanvas.width + ",height=" + theCanvas.height + ",toolbar=0,resizable=0");
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893687.png" alt="Canvas exported image with toDataURL()" width="779" height="728">
Figure 3-11. 

Canvas exported image with toDataURL()
SECURITY_ERR: DOM Exception 18
In some web browsers, such as Google Chrome, you might experience an error (SECURITY_ERR: DOM Exception 18) when trying to export the canvas while an image is displayed (like the pattern fill type in Example 3-3</a>). 
This usually occurs because the web browser is executing a web page locally (loaded from the filesystem). 

These errors can usually be removed by loading the HTML page from a web server—either remotely or on your local machine.
<h2>Final Version of Text Arranger</h2>
The final version of Text Arranger (3.0) brings together all the HTML5 Text API features we have discussed in this chapter (see Example 3-3</a>). 
Play with the final app, and see how the different options interact with one another. 

Here are a couple things you might find interesting:
Shadows don’t work with patterns or gradients.

Increasing the text size with a pattern that is the size of the canvas changes the pattern on the text (it acts like a mask or window into the pattern itself).
Canvas width and height are affected by the style width and height (scaling).

Example 3-3. 
Text Arranger 3.0
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH3EX3: Text Arranger 3.0&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="jscolor/jscolor.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function eventWindowLoaded() {
 var pattern = new Image();
 pattern.src = "texture.jpg";
 pattern.onload = eventAssetsLoaded;

}
function eventAssetsLoaded() {
 canvasApp();
}

function canvasApp() {
 var message = "your text";
 var fontSize = "50";
 var fontFace = "serif"; var textFillColor = "#ff0000";
 var textAlpha = 1;
 var shadowX = 1;
 var shadowY = 1; var shadowBlur = 1;
 var shadowColor = "#707070";
 var textBaseline = "middle";
 var textAlign = "center"; var fillOrStroke ="fill";
 var fontWeight = "normal";
 var fontStyle = "normal";
 var fillType = "colorFill"; var textFillColor2 = "#000000";
 var pattern = new Image();
 if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 var formElement = document.getElementById("textBox");
 formElement.addEventListener("keyup", textBoxChanged, false);
 formElement = document.getElementById("fillOrStroke"); formElement.addEventListener("change", fillOrStrokeChanged, false);
 formElement = document.getElementById("textSize");
 formElement.addEventListener("change", textSizeChanged, false);
 formElement = document.getElementById("textFillColor"); formElement.addEventListener("change", textFillColorChanged, false);
 formElement = document.getElementById("textFont");
 formElement.addEventListener("change", textFontChanged, false);
 formElement = document.getElementById("textBaseline"); formElement.addEventListener("change", textBaselineChanged, false);
 formElement = document.getElementById("textAlign");
 formElement.addEventListener("change", textAlignChanged, false);
 formElement = document.getElementById("fontWeight"); formElement.addEventListener("change", fontWeightChanged, false);
 formElement = document.getElementById("fontStyle");
 formElement.addEventListener("change", fontStyleChanged, false);
 formElement = document.getElementById("shadowX"); formElement.addEventListener("change", shadowXChanged, false);
 formElement = document.getElementById("shadowY");
 formElement.addEventListener("change", shadowYChanged, false);
 formElement = document.getElementById("shadowBlur"); formElement.addEventListener("change", shadowBlurChanged, false);
 formElement = document.getElementById("shadowColor");
 formElement.addEventListener("change", shadowColorChanged, false);
 formElement = document.getElementById("textAlpha"); formElement.addEventListener("change", textAlphaChanged, false);
 formElement = document.getElementById("textFillColor2");
 formElement.addEventListener("change", textFillColor2Changed, false);
 formElement = document.getElementById("fillType"); formElement.addEventListener("change", fillTypeChanged, false);
 formElement = document.getElementById("canvasWidth");
 formElement.addEventListener("change", canvasWidthChanged, false);
 formElement = document.getElementById("canvasHeight"); formElement.addEventListener("change", canvasHeightChanged, false);
 formElement = document.getElementById("canvasStyleWidth");
 formElement.addEventListener("change", canvasStyleSizeChanged, false);
 formElement = document.getElementById("canvasStyleHeight"); formElement.addEventListener("change", canvasStyleSizeChanged, false);
 formElement = document.getElementById("createImageData");
 formElement.addEventListener("click", createImageDataPressed, false);
 pattern.src = "texture.jpg"; drawScreen();
 function drawScreen() { //Background context.globalAlpha = 1; context.shadowColor = "#707070"; context.shadowOffsetX = 0; context.shadowOffsetY = 0; context.shadowBlur = 0; context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); 
 //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width-10, theCanvas.height-10);
 //Text context.textBaseline = textBaseline; context.textAlign = textAlign; context.font = fontWeight + " " + fontStyle + " " + fontSize + "px " + fontFace; context.shadowColor = shadowColor; context.shadowOffsetX = shadowX; context.shadowOffsetY = shadowY; context.shadowBlur = shadowBlur; context.globalAlpha = textAlpha; var xPosition = (theCanvas.width/2); var yPosition = (theCanvas.height/2);
 var metrics = context.measureText(message); var textWidth = metrics.width;
 var tempColor; if (fillType == "colorFill") { tempColor = textFillColor; } else if (fillType == "linearGradient") {
 var gradient = context.createLinearGradient(xPosition- textWidth/2, yPosition, textWidth, yPosition); gradient.addColorStop(0,textFillColor); gradient.addColorStop(.6,textFillColor2); tempColor = gradient; } else if (fillType == "radialGradient") { var gradient = context.createRadialGradient(xPosition, yPosition, fontSize, xPosition+textWidth, yPosition, 1); gradient.addColorStop(0,textFillColor); gradient.addColorStop(.6,textFillColor2); tempColor = gradient; } else if (fillType == "pattern") { var tempColor = context.createPattern(pattern,"repeat") } else { tempColor = textFillColor; } switch(fillOrStroke) { case "fill": context.fillStyle = tempColor; context.fillText (message, xPosition,yPosition); break; case "stroke": context.strokeStyle = tempColor; context.strokeText (message, xPosition,yPosition); break; case "both": context.fillStyle = tempColor; context.fillText (message, xPosition,yPosition); context.strokeStyle = "#000000"; context.strokeText (message, xPosition,yPosition); break; }
 }
 function textBoxChanged(e) { var target = e.target; message = target.value; drawScreen();
 } function textBaselineChanged(e) { var target = e.target; textBaseline = target.value; drawScreen();
 }
 function textAlignChanged(e) { var target = e.target; textAlign = target.value; drawScreen();
 } function fillOrStrokeChanged(e) { var target = e.target; fillOrStroke = target.value; drawScreen();
 }
 function textSizeChanged(e) { var target = e.target; fontSize = target.value; drawScreen();
 } function textFillColorChanged(e) { var target = e.target; textFillColor = "#" + target.value; drawScreen();
 }
 function textFontChanged(e) { var target = e.target; fontFace = target.value; drawScreen();
 } function fontWeightChanged(e) { var target = e.target; fontWeight = target.value; drawScreen();
 }
 function fontStyleChanged(e) { var target = e.target; fontStyle = target.value; drawScreen();
 } function shadowXChanged(e) { var target = e.target; shadowX = target.value; drawScreen();
 }
 function shadowYChanged(e) { var target = e.target; shadowY = target.value; drawScreen();
 } function shadowBlurChanged(e) { var target = e.target; shadowBlur = target.value; drawScreen();
 }
 function shadowColorChanged(e) { var target = e.target; shadowColor = target.value; drawScreen();
 } function textAlphaChanged(e) { var target = e.target; textAlpha = (target.value); drawScreen();
 }
 function textFillColor2Changed(e) { var target = e.target; textFillColor2 = "#" + target.value; drawScreen();
 } function fillTypeChanged(e) { var target = e.target; fillType = target.value; drawScreen();
 }
 function canvasWidthChanged(e) { var target = e.target; theCanvas.width = target.value; drawScreen();
 } function canvasHeightChanged(e) { var target = e.target; theCanvas.height = target.value; drawScreen();
 }
 function canvasStyleSizeChanged(e) {
 var styleWidth = document.getElementById("canvasStyleWidth"); var styleHeight = document.getElementById("canvasStyleHeight"); var styleValue = "width:" + styleWidth.value + "px; height:" + styleHeight.value +"px;"; theCanvas.setAttribute("style", styleValue ); drawScreen(); }
 function createImageDataPressed(e) {
 var imageDataDisplay = document.getElementById("imageDataDisplay"); imageDataDisplay.value = theCanvas.toDataURL(); window.open(imageDataDisplay.value,"canvasImage","left=0,top=0,width=" + theCanvas.width + ",height=" + theCanvas.height + ",toolbar=0,resizable=0");
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt; &lt;video autoplay="true" loop="true"&gt; &lt;source src="spaceeggs.ogg" type="video/ogg"/&gt; &lt;/video&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;canvas width="500" height="300"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;form&gt;
 Text: &lt;input placeholder="your text" /&gt; &lt;br&gt;
 Text Font: &lt;select&gt;
 &lt;option value="serif"&gt;serif&lt;/option&gt;
 &lt;option value="sans-serif"&gt;sans-serif&lt;/option&gt; &lt;option value="cursive"&gt;cursive&lt;/option&gt;
 &lt;option value="fantasy"&gt;fantasy&lt;/option&gt;
 &lt;option value="monospace"&gt;monospace&lt;/option&gt;
 &lt;/select&gt; &lt;br&gt; Font Weight:
 &lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt;
 &lt;option value="bold"&gt;bold&lt;/option&gt; &lt;option value="bolder"&gt;bolder&lt;/option&gt;
 &lt;option value="lighter"&gt;lighter&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt; Font Style:
 &lt;select&gt;
 &lt;option value="normal"&gt;normal&lt;/option&gt;
 &lt;option value="italic"&gt;italic&lt;/option&gt; &lt;option value="oblique"&gt;oblique&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Text Size: &lt;input type="range" min="0" max="200" step="1" value="50"/&gt; &lt;br&gt;
 Fill Type: &lt;select&gt;
 &lt;option value="colorFill"&gt;Color Fill&lt;/option&gt;
 &lt;option value="linearGradient"&gt;Linear Gradient&lt;/option&gt; &lt;option value="radialGradient"&gt;Radial Gradient&lt;/option&gt;
 &lt;option value="pattern"&gt;pattern&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt; Text Color: &lt;input value="FF0000"/&gt;
 &lt;br&gt;
 Text Color 2: &lt;input value ="000000"/&gt;
 &lt;br&gt; Fill Or Stroke: &lt;select&gt;
 &lt;option value="fill"&gt;fill&lt;/option&gt;
 &lt;option value="stroke"&gt;stroke&lt;/option&gt;
 &lt;option value="both"&gt;both&lt;/option&gt; &lt;/select&gt;
 &lt;br&gt;
 Text Baseline &lt;select&gt;
 &lt;option value="middle"&gt;middle&lt;/option&gt; &lt;option value="top"&gt;top&lt;/option&gt;
 &lt;option value="hanging"&gt;hanging&lt;/option&gt;
 &lt;option value="alphabetic"&gt;alphabetic&lt;/option&gt;
 &lt;option value="ideographic"&gt;ideographic&lt;/option&gt; &lt;option value="bottom"&gt;bottom&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Text Align &lt;select&gt; &lt;option value="center"&gt;center&lt;/option&gt;
 &lt;option value="start"&gt;start&lt;/option&gt;
 &lt;option value="end"&gt;end&lt;/option&gt;
 &lt;option value="left"&gt;left&lt;/option&gt; &lt;option value="right"&gt;right&lt;/option&gt;
 &lt;/select&gt;
 &lt;br&gt;
 Alpha: &lt;input type="range" min="0.0" max="1.0" step="0.01" value="1.0"/&gt; &lt;br&gt;
 Shadow X:&lt;input type="range" min=",100" max="100" step="1" value="1"/&gt;
 &lt;br&gt;
 Shadow Y:&lt;input type="range" min=",100" max="100" step="1" value="1"/&gt; &lt;br&gt;
 Shadow Blur: &lt;input type="range" min="1" max="100" step="1" value="1" /&gt;
 &lt;br&gt;
 Shadow Color: &lt;input value="707070"/&gt; &lt;br&gt;
 Canvas Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt;
 &lt;br&gt;
 Canvas Height: &lt;input type="range" min="0" max="1000" step="1" value="300"/&gt;
 &lt;br&gt;
 Canvas Style Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt;
 &lt;br&gt; Canvas Style Height:
 &lt;input type="range" min="0" max="1000" step="1" value="300"/&gt;
 &lt;br&gt;
 &lt;input type="button" value="Create Image Data"&gt; &lt;br&gt;
 &lt;br&gt;
 &lt;textarea rows=10 cols=30&gt;&lt;/textarea&gt;
 &lt;/form&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h2>What’s Next</h2>
In this chapter, we introduced you to the fundamentals of the HTML5 Canvas Text API, offered some general concepts relating to drawing on the canvas, and explained how to communicate with HTML form controls. 
As you can now see, the basic concept of writing text to HTML5 Canvas can be taken to very complex (and some might argue ludicrous) levels. 
The final application, Text Arranger 3.0, allows you to modify a single line of text in an almost infinite number of ways. 
In the next chapter, we move on to displaying and manipulating images on the canvas. 4. 
Images on the Canvas" epub:type="chapter">
<h2><span class="orange">Chapter 4. Images on the Canvas</span></h2>
Like the Canvas Drawing API, the Canvas Image API is very robust. 
With it, we can load in image data and apply it directly to the canvas. 
This image data can also be cut and spliced to display any desired portion.
 Furthermore, Canvas gives us the ability to store arrays of pixel data that we can manipulate and then draw back to the canvas.
There are two primary Canvas functions we can perform with images. 

We can display images, and we can modify them pixel by pixel and paint them back to the canvas. 
There are only a few Image API functions, but they open up a world of pixel-level manipulation that gives the developer the power to create optimized applications directly in the web browser without needing any plug-ins.
<h2>The Basic File Setup for This Chapter</h2>
All the examples in this chapter will use the same basic file setup for displaying our demonstrations as we proceed through the Drawing API. 
Use the following as the basis for all the examples we create—you will only need to change the contents of the <code>drawScreen()</code> function:
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;Ch4BaseFile - Template For Chapter 4 Examples&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp(){ if (!canvasSupport()) { return; }else{ var theCanvas = document.getElementById("canvas"); var context = theCanvas.getContext("2d");
 }
drawScreen();
 function drawScreen() { <strong>//make changes here</strong> context.fillStyle = '#aaaaaa'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#000000'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Canvas!", 0, 0); }
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h2>Image Basics</h2>
The Canvas API allows access to the DOM-defined <code>Image</code> object type through the use of the <code>drawImage()</code> method. 
The image can be defined in HTML, such as:
&lt;img src="ship1.png"&gt;

Or it can be defined in JavaScript. 
We create a new JavaScript <code>Image</code> instance like this:
var spaceShip = new Image();
We can then set the file source of the image by assigning a URL to the <code>src</code> attribute of our newly created <code>Image</code> object:

spaceShip.src = "ship1.png";
<h3>Preloading Images</h3>
Before an image can be called in code, we must ensure that it has properly loaded and is ready to be used. 
We do this by creating an event listener to fire off when the <code>load</code> event on the image occurs:

spaceShip.addEventListener('load', eventShipLoaded , false);
When the image is fully loaded, the <code>eventShipLoaded()</code> function will fire off. 
Inside this function we will then call <code>drawScreen()</code>, as we have in the previous chapters:
function eventShipLoaded() { drawScreen();
}
<h3>Note</h3>
In practice, we would not create a separate event listener function for each loaded image. 

This code example works fine if your application contains only a single image. 
In <a href="ch09.html" title="Chapter 9. 
Combining Bitmaps and Sound">Chapter 9</a>, we will build a game with multiple image files (and sounds) and use a single listener function for all loaded resources.
<h3>Displaying an Image on the Canvas with drawImage()</h3>

Once we have an image loaded in, we can display it on the screen in a number of ways. 
The <code>drawImage()</code> Canvas method is used for displaying image data directly onto the canvas. 
<code>drawImage()</code> is <em>overloaded</em> and takes three separate sets of parameters, each allowing varied manipulation of both the image’s source pixels and the destination location for those pixels on the canvas. 
Let’s first look at the most basic:

drawImage(<em>Image</em>, <em>dx</em>, <em>dy</em>)
This function takes in three parameters: an <code>Image</code> object, and <code>x</code> and <code>y</code> values representing the top-left corner location to start painting the image on the canvas.
Here is the code we would use to place our spaceship image at the 0,0 location (the top-left corner) of the canvas:
context.drawImage(spaceShip, 0, 0);

If we want to place another copy at 50,50, we would simply make the same call but change the location:
context.drawImage(spaceShip, 50, 50);
Example 4-1</a> shows the full code for what we have done so far.
Example 4-1. 

Load and display an image file
var spaceShip = new Image();
spaceShip.addEventListener('load', eventShipLoaded , false);
spaceShip.src = "ship1.png";

function eventShipLoaded() {
 drawScreen();
}
function drawScreen() { context.drawImage(spaceShip, 0, 0);
 context.drawImage(spaceShip, 50, 50);
}
<a href="ch04.html#load_and_display_an_image_file-id1" title="Figure 4-1. 

Load and display an image file">Figure 4-1</a> shows the 32×32 <em>ship1.png</em> file.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893689.png" alt="Load and display an image file" width="405" height="222">
Figure 4-1. 
Load and display an image file

In practice, we would probably not put all of our drawing code directly into a function such as <code>drawScreen()</code>. 
It almost always makes more sense to create a separate function, such as <code>placeShip()</code>, shown here:
function drawScreen() {
 placeShip(context, spaceShip, 0, 0); placeShip(context, spaceShip, 50, 50);
}
function placeShip(ctx, obj, posX, posY, width, height) {
 if (width &amp;&amp; height) { context.drawImage(obj, posX, posY, width, height); } else { context.drawImage(obj, posX, posY);
 }
}
The <code>placeShip()</code> function accepts the context, the image object, the <code>x</code> and <code>y</code> positions, and a height and width. 

If a height and width are passed in, the first version of the <code>drawScreen()</code> function is called. 
If not, the second version is called. 
We will look at resizing images as they are drawn in the next section.
The <em>ship1.png</em> file we are using is a 32×32 pixel <em>.png</em> bitmap, which we have modified from Ari Feldman’s excellent SpriteLib. 

SpriteLib is a free library of pixel-based game sprites that Ari has made available for use in games and books. 
You can find the entire SpriteLib here: <a href="http://www.flyingyogi.com/fun/spritelib.html">http://www.flyingyogi.com/fun/spritelib.html</a>.
<h3>Note</h3>
The website for this book contains only the files necessary to complete the examples. 

We have modified Ari’s files to fit the needs of this book.
<a href="ch04.html#draw_multiple_objects_with_a_single_sour" title="Figure 4-2. 
Draw multiple objects with a single source">Figure 4-2</a> shows two copies of the image painted to the canvas. 
One of the copies has the top-left starting location of 0,0, and the other starts at 50,50.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893691.png" alt="Draw multiple objects with a single source" width="300" height="308">
Figure 4-2. 
Draw multiple objects with a single source
<h3>Resizing an Image Painted to the Canvas</h3>

To paint and scale drawn images, we can also pass parameters into the <code>drawImage()</code> function. 
For example, this second version of <code>drawImage()</code> takes in an extra two parameters:
drawImage(<em><code>Image, dx, dy, dw, dh</code></em>)
<em><code>dw</code></em> and <em><code>dh</code></em> represent the width and height of the rectangle portion of the canvas where our source image will be painted. 

If we only want to scale the image to 64×64 or 16×16, we would use the following code:
context.drawImage(spaceShip, 0, 0,64,64);
context.drawImage(spaceShip, 0, 0,16,16);
Example 4-2</a> draws various sizes to the canvas.

Example 4-2. 
Resizing an image as it is drawn
function eventShipLoaded() {
 drawScreen();

}
function drawScreen() {
 context.drawImage(spaceShip, 0, 0);
 context.drawImage(spaceShip, 0, 34,32,32); context.drawImage(spaceShip, 0, 68,64,64);
 context.drawImage(spaceShip, 0, 140,16,16);
}
See <a href="ch04.html#resizing_an_image_as_it_is_drawn-id1" title="Figure 4-3. 

Resizing an image as it is drawn">Figure 4-3</a> for the output to this example.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893693.png" alt="Resizing an image as it is drawn" width="257" height="637">
Figure 4-3. 
Resizing an image as it is drawn

In Example 4-2</a>, we have added a gray box so we can better see the placement of the images on the canvas. 
The image we placed on the screen can scale in size as it is painted, saving us the calculation and steps necessary to use a matrix transformation on the object. 
The only caveat is that the scale origin point of reference is the top-left corner of the object. 
If we used a matrix operation, we could translate the origin point to the center of the object before applying the scale.

We have placed two 32×32 objects on the canvas to show that these two function calls are identical:
context.drawImage(spaceShip, 0, 0);
context.drawImage(spaceShip, 0, 34,32,32);
Aside from the fact that the second is placed 34 pixels below the first, the extra 32,32 at the end of the second call is unnecessary because it is the original size of the object. 

This demonstrates that the scale operation does not translate (or move) the object on any axis. 
The top-left corner of each is 0,0.
<h3>Copying Part of an Image to the Canvas</h3>
The third set of parameters that can be passed into <code>drawImage()</code> allows us to copy an arbitrary rectangle of data from a source image and place it onto the canvas. 

This image data can be resized as it is placed.
We are going to use a second source image for this set of operations: spaceships that have been laid out on what is called a <em>tile sheet</em> (also known as a <em>sprite sheet</em>, a <em>texture sheet</em>, or by many other names). 
This type of file layout refers to an image file that is broken up physically into rectangles of data. 
Usually these rectangles have an equal width and height. 

The “tiles” or “sprites” we will be using are 32 pixels wide by 32 pixels high, commonly referred to as 32×32 tiles.
<a href="ch04.html#the_tile_sheet_inside_a_drawing_program" title="Figure 4-4. 
The tile sheet inside a drawing program">Figure 4-4</a> shows a tile sheet with the grid lines turned on in the drawing application. 
These grid lines separate each of the tiles on the sheet.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893695.png" alt="The tile sheet inside a drawing program" width="1000" height="127">
Figure 4-4. 
The tile sheet inside a drawing program
<a href="ch04.html#the_tile_sheet_exported_for_use_in_an_ap" title="Figure 4-5. 

The tile sheet exported for use in an application">Figure 4-5</a> is the actual tile sheet—without grid lines—that we will use for our further examples.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893697.png" alt="The tile sheet exported for use in an application" width="1000" height="123">
Figure 4-5. 
The tile sheet exported for use in an application

The structure of the parameters for this third version of the <code>drawImage()</code> function looks like this:
drawImage(<em><code>Image, sx, sy, sw, sh, dx, dy, dw, dh</code></em>)
<em><code>sx</code></em> and <em><code>sy</code></em> represent the “source positions” to start copying the source image to the canvas. 
<em><code>sw</code></em> and <em><code>sh</code></em> represent the width and height of the rectangle starting at <em><code>sx</code></em> and <em><code>sy</code></em>. 

That rectangle will be copied to the canvas at “destination” positions <em><code>dx</code></em> and <em><code>dy</code></em>. 
As with the previous <code>drawImage()</code> function, <em><code>dw</code></em> and <em><code>dh</code></em> represent the newly scaled width and height for the image.
Example 4-3</a> copies the second version of our spaceship (tile number 2) to the canvas and positions it at 50,50. 
It also scales the image to 64×64, producing the result shown in <a href="ch04.html#using_all_of_the_drawimage_open_pare" title="Figure 4-6. 

Using all of the drawImage() parameters">Figure 4-6</a>.
Example 4-3. 
Using all of the drawImage() parameters
var tileSheet = new Image();

tileSheet.addEventListener('load', eventShipLoaded , false);
tileSheet.src = "ships.png";
function eventShipLoaded() {
 drawScreen();

}
function drawScreen() {
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa"; context.fillRect(0,0,500,500);
 context.drawImage(tileSheet, 32, 0,32,32,50,50,64,64);
}
As you can see, we have changed the name of our <code>Image</code> instance to <code>tileSheet</code> because it represents more than just the source for the single ship image.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893699.png" alt="Using all of the drawImage() parameters" width="685" height="520">
Figure 4-6. 
Using all of the drawImage() parameters
Now, let’s use this same concept to simulate animation using the tiles on our tile sheet.

<h2>Simple Cell-Based Sprite Animation</h2>
With a tile sheet of images, it is relatively simple to create what seems like cell-based or flip-book animation. 
This technique involves rapidly swapping images over time to simulate animation. 
The term <em>flip-book</em> comes from the age-old technique of drawing individual cells of animation in the top-left corner pages of a book. 

When the pages are rapidly flipped through, the changes are viewed over time, appearing to create a cartoon. 
<em>Cell-based animation</em> refers to a similar professional technique. 
Individual same-sized cells (or pages) of images are drawn to simulate animation. 
When played back rapidly with special devices in front of a camera, animated cartoons are recorded.

We can use the <code>drawImage()</code> function and the first two tiles on our tile sheet to do the same thing.
<h3>Creating an Animation Frame Counter</h3>
We can simulate the ship’s exhaust firing by rapidly flipping between the first two tiles (or cells) on our tile sheet. 
To do this, we set up a counter variable, which is how we track the tile we want to paint to the canvas. 

We will use <code>0</code> for the first cell and <code>1</code> for the second cell.
We will create a simple integer to count which frame we are displaying on our tile sheet:
var counter = 0;
Inside <code>drawScreen()</code>, we will increment this value by <code>1</code> on each frame. 

Since we only have two frames, we will need to set it back to <code>0</code> when it is greater than <code>1</code>:
counter++;
if (counter &gt;1) { counter = 0;
}

Or use the nice shortcut:
counter ^= 1;
<h3>Creating a Timer Loop</h3>
As it currently stands, our code will only be called a single time. 

Let’s create a simple timer loop that will call the <code>drawScreen()</code> function 10 times a second, or once every 100 milliseconds. 
A timer loop that is set to run at a certain frame rate is sometimes referred to as a <em>frame tick</em> or <em>timer tick</em>. 
Each tick is simply a single iteration of the timer running all the code we put into our <code>drawScreen()</code> function. 
We will also need a function that starts the timer loop and initiates the tick once the image has preloaded properly. 

We’ll name this function <code>startUp()</code>:
function eventShipLoaded() {
 startUp();
}

function startUp(){
 setInterval(drawScreen, 100 );
}
<h3>Changing the Tile to Display</h3>

To change the tile to display, we can multiply the counter variable by <code>32</code> (the tile width). 
Since we only have a single row of tiles, we don’t have to change the <code>y</code> value:
context.drawImage(tileSheet, 32*counter, 0,32,32,50,50,64,64);
<h3>Note</h3>

We will examine how to use a tile sheet consisting of multiple rows and columns in the next section, Advanced Cell-Based Animation</a>.
Example 4-3</a> used this same line of code to draw our image. 
In Example 4-4</a>, it will be placed on the canvas at 50,50 and scaled to 64×64 pixels. 
Let’s look at the entire set of code.

Example 4-4. 
A simple sprite animation var counter = 0;
 var tileSheet = new Image(); tileSheet.addEventListener('load', eventShipLoaded , false);
 tileSheet.src = "ships.png";
 function eventShipLoaded() { startUp();
 } function drawScreen() {
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa"; context.fillRect(0,0,500,500); context.drawImage(tileSheet, 32*counter, 0,32,32,50,50,64,64); counter++; if (counter &gt;1) { counter = 0; }
 }
 function startUp(){ setInterval(drawScreen, 100 ); }
When you run this code, you will see the exhaust on the ship turn off and on every 100 milliseconds, creating a simple cell-based animation.
<h2>Advanced Cell-Based Animation</h2>
In the previous example, we simply flipped back and forth between two tiles on our tile sheet. 

Next, we are going to create a method that uses a tile sheet to play through a series of images. 
First, let’s look at the new tile sheet, created by using tiles from SpriteLib. 
<a href="ch04.html#example_tile_sheet" title="Figure 4-7. 
Example tile sheet">Figure 4-7</a> shows the example sprite sheet, <em>tanks_sheet.png</em>; we will refer back to this figure throughout the chapter.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893701.png" alt="Example tile sheet" width="256" height="128">
Figure 4-7. 
Example tile sheet
As you can see, it contains a number of 32×32 tiles that can be used in a game. 

We will not create an entire game in this chapter, but we will examine how to use these tiles to create a game screen. 
In <a href="ch09.html" title="Chapter 9. 
Combining Bitmaps and Sound">Chapter 9</a>, we will create a simple maze-chase game using some of these tiles.
<h3>Examining the Tile Sheet</h3>

The tile sheet is formatted into a series of tiles starting at the top left. 
As with a two-dimensional array, the numbering starts at 0—we call this <em>0 relative</em>. 
Moving from left to right and down, each tile will be referenced by a single number index (as opposed to a multidimensional index). 
The gray square in the top left is tile 0, while the tank at the end of the first row (the rightmost tank) is tile 7. 

Moving down to the next row, the first tank on the far left of the second row is tile 8, and so on until the final tile on row 3 (the fourth row down when we start numbering at 0) is tile 31. 
We have four rows with eight columns each, making 32 tiles with indexes numbered 0 to 31.
<h3>Creating an Animation Array</h3>
Next, we are going to create an array to hold the tiles for the animation. 

There are two tanks on the tile sheet: one is green and one is blue. 
Tiles 18 are a series that—when played in succession—will make it appear as though the green tank’s tracks are moving.
<h3>Note</h3>
Remember, the tile sheet starts at tile 0, but we want start with the first tank image at tile number 1.

We will store the tile ids we want to play for the tank in an array:
var animationFrames = [1,2,3,4,5,6,7,8];
We will use a counter to keep track of the current index of this array:
var frameIndex = 0;

<h3>Choosing the Tile to Display</h3>
We will use the <code>frameIndex</code> of the <code>animationFrames</code> array to calculate the 32×32 source rectangle from our tile sheet that we will copy to the canvas. 
First, we need to find the x and y locations of the top-left corner for the tile we want to copy. 
To do this, we will create local variables in our <code>drawScreen()</code> function on each iteration (frame) to calculate the position on the tile sheet. 

The <code>sourceX</code> variable will contain the top-left corner <code>x</code> position, and the <code>sourceY</code> variable will contain the top-left corner <code>y</code> position.
Here is pseudocode for the <code>sourceX</code> calculation:
sourceX = integer(current_frame_index modulo the_number_columns_in_the_tilesheet) * tile_width
The modulo (%) operator gives us the remainder of the division calculation. 

The actual code we will use for this calculation looks like this:
var sourceX = Math.floor(animationFrames[frameIndex] % 8) *32;
The calculation for the <code>sourceY</code> value is similar, except we divide rather than use the modulo operation:
sourceY = integer(current_frame_index divided by the_number_columns_in_the_tilesheet) *tile_height

Here is the actual code we will use for this calculation:
var sourceY = Math.floor(animationFrames[frameIndex] / 8) *32;
<h3>Looping Through the Tiles</h3>
We will update the <code>frameIndex</code> value on each frame tick. 

When <code>frameIndex</code> becomes greater than <code>7</code>, we will set it back to <code>0</code>:
frameIndex++; if (frameIndex == animationFrames.length) { frameIndex = 0; }
The <code>animationFrames.length</code> value is <code>8</code>. 
When the <code>frameIndex</code> is equal to <code>8</code>, we must set it back to <code>0</code> to start reading the array values over again, which creates an infinite animation loop.

<h3>Drawing the Tile</h3>
We will use <code>drawImage()</code> to place the new tile on the screen on each iteration:
context.drawImage(tileSheet, sourceX, sourceY,32,32,50,50,32,32);
Here, we are passing the calculated <code>sourceX</code> and <code>sourceY</code> values into the <code>drawImage()</code> function. 

We then pass in the width (<code>32</code>), the height (<code>32</code>), and the location (<code>50,50</code>) to draw the image on the canvas. 
Example 4-5</a> shows the full code.
Example 4-5. 
Advanced sprite animation

var tileSheet = new Image();
tileSheet.addEventListener('load', eventShipLoaded , false);
tileSheet.src = "tanks_sheet.png";
var animationFrames = [1,2,3,4,5,6,7,8];

var frameIndex = 0;
function eventShipLoaded() {
 startUp();
}

function drawScreen() {
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa";
 context.fillRect(0,0,500,500); var sourceX = Math.floor(animationFrames[frameIndex] % 8) *32;
 var sourceY = Math.floor(animationFrames[frameIndex] / 8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,50,50,32,32);
 frameIndex++; if (frameIndex ==animationFrames.length) { frameIndex=0;
 }
}
function startUp(){ setInterval(drawScreen, 100 );
}
When we run the example, we will see the eight tile cell frames for the tank run in order and then repeat—the only problem is that the tank isn’t going anywhere. 
Let’s solve that little dilemma next and drive the tank up the screen.

<h3>Moving the Image Across the Canvas</h3>
Now that we have the tank tracks animating, let’s “move” the tank. 
By animating the tank tracks and applying a simple movement vector to the tank’s position, we can achieve the simulation of animated movement.
To do this, we first need to create variables to hold the current <code>x</code> and <code>y</code> positions of the tank. 

These represent the top-left corner where the tile from our sheet will be drawn to the canvas. 
In the previous examples, this number was set at <code>50</code> for each, so let’s use that value here as well:
var x = 50;
var y = 50;

We also need a movement vector value for each axis. 
These are commonly known as <code>deltaX</code> (<code>dx</code>) and <code>deltaY</code> (<code>dy</code>). 
They represent the “delta” or “change” in the <code>x</code> or <code>y</code> axis position on each iteration. 
Our tank is currently facing in the “up” position, so we will use <code>-1</code> for the <code>dy</code> and <code>0</code> for the <code>dx</code>:

var dx = 0;
var dy = -1;
The result is that on each frame tick, our tank will move <em>one</em> pixel up on the y-axis and <em>zero</em> pixels on the x-axis.
Inside <code>drawScreen()</code> (which is called on each frame tick), we will add the <code>dx</code> and <code>dy</code> values to the <code>x</code> and <code>y</code> values, and then apply them to the <code>drawImage()</code> function:

y = y+dy;
x = x+dx;
context.drawImage(tileSheet, sourceX, sourceY,32,32,x,y,32,32);
Rather than use the hardcoded <code>50,50</code> for the location of the <code>drawImage()</code> call on the canvas, we have replaced it with the current <code>x,y</code> position. 

Let’s examine the entire code in Example 4-6</a>.
Example 4-6. 
Sprite animation and movement
var tileSheet = new Image();

tileSheet.addEventListener('load', eventShipLoaded , false);
tileSheet.src = "tanks_sheet.png";
var animationFrames = [1,2,3,4,5,6,7,8];
var frameIndex = 0;

var dx = 0;
var dy = -1;
var x = 50;
var y = 50;

function eventShipLoaded() {
 startUp();
}
function drawScreen() { y = y+dy;
 x = x+dx;
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa"; context.fillRect(0,0,500,500);
 var sourceX = Math.floor(animationFrames[frameIndex] % 8) *32;
 var sourceY = Math.floor(animationFrames[frameIndex] / 8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,x,y,32,32); frameIndex++;
 if (frameIndex==animationFrames.length) { frameIndex=0;
 }
}

function startUp(){
 setInterval(drawScreen, 100 );
}
By running this example, we see the tank move slowly up the canvas while its tracks play through the eight separate tiles of animation.

Our tile sheet only has images of the tank facing in the up position. 
If we want to have the tank move in other directions, we can do one of two things. 
The first option is to create more tiles on the tile sheet to represent the left, right, and down positions. 
However, this method requires much more work and creates a larger source image for the tile sheet. 

We are going to solve this problem in another way, which we will examine next.
<h2>Applying Rotation Transformations to an Image</h2>
In the previous section, we created an animation using tiles from a tile sheet. 
In this section, we will take it one step further and use the Canvas transformation matrix to rotate our image before drawing it to the canvas. 

This will allow us to use only a single set of animated tiles for all four (or more) rotated directions in which we would like to display our images. 
Before we write the code, let’s examine what it will take to rotate our tank animation from the previous section.
<h3>Note</h3>
In <a href="ch02.html" title="Chapter 2. 

Drawing on the Canvas">Chapter 2</a>, we dove into applying basic transformations when drawing with paths. 
The same concepts apply to transforming images on the canvas. 
If you have not read the section Simple Canvas Transformations</a> in <a href="ch02.html" title="Chapter 2. 
Drawing on the Canvas">Chapter 2</a>, you might want to review it before reading on.

<h3>Canvas Transformation Basics</h3>
Although we covered basic Canvas transformations in detail in <a href="ch02.html" title="Chapter 2. 
Drawing on the Canvas">Chapter 2</a>, let’s review what’s necessary to transform an individual object on the canvas. 
Remember, the canvas is a single immediate-mode drawing surface, so any transformations we make are applied to the entire canvas. 

In our example, we are drawing two objects. 
First, we draw a gray background rectangle, and then we copy the current tile from our tile sheet to the desired location. 
These are two discrete objects, but once they are on the canvas, they are both simply collections of pixels painted on the surface. 
Unlike Flash or other platforms that allow many separate sprites or “movie clips” to occupy the physical space, there is only one such object on Canvas: the <em>context</em>.

To compensate for this, we create logical display objects. 
Both the background and the tank are considered separate logical display objects. 
If we want to draw the tank but rotate it with a transformation matrix, we must separate the logical drawing operations by using the <code>save()</code> and <code>restore()</code> Canvas context functions.
Let’s look at an example where we rotate the tank 90 degrees so it is facing to the right rather than up.

<h4>Step 1: Save the current context to the stack</h4>
The <code>save()</code> context function will take the current contents of the canvas (in our case the gray background rectangle) and store it away for “safekeeping”:
 context.save();
Once we have transformed the tank, we will replace it with the <code>restore()</code> function call.

<h4>Step 2: Reset the transformation matrix to identity</h4>
The next step in transforming an object is to clear the transformation matrix by passing it values that reset it to the identity values:
context.setTransform(1,0,0,1,0,0)
<h4>Step 3: Code the transform algorithm</h4>

Each transformation will be slightly different, but usually if you are rotating an object, you will want to translate the matrix to the center point of that object. 
Our tank will be positioned at 50,50 on the canvas, so we will translate it to 66,66. 
Since our tank is a 32×32 square tile, we simply add half of 32, or 16, to both the <code>x</code> and <code>y</code> location points:
context.translate(x+16, y+16);

Next, we need to find the angle in radians for the direction we want the tank to be rotated. 
For this example, we will choose 90 degrees:
var rotation = 90;
var angleInRadians = rotation * Math.PI / 180;

context.rotate(angleInRadians);
<h4>Step 4: Draw the image</h4>
When we draw the image, we must remember that the drawing’s point of origin is no longer the 50,50 point from previous examples. 
Once the transformation matrix has been applied to translate to a new point, that point is now considered the 0,0 origin point for drawing.

This can be confusing at first, but it becomes clear with practice. 
To draw our image with 50,50 as the top-left coordinate, we must subtract 16 from the current position in both the <code>x</code> and <code>y</code> directions:
context.drawImage(tileSheet, sourceX, sourceY,32,32,-16,-16,32,32);
Example 4-7</a> adds in this rotation code to Example 4-4</a>. 

When you run the example now, you will see the tank facing to the right.
<h3>Note</h3>
Notice in Example 4-7</a> that we remove the original call to <code>draw</code><code>Screen()</code> from the previous examples, and replace it with a new event listener function that is called after the <code>tileSheet</code> has been loaded. 
The new function is called <code>eventShipLoaded()</code>.

Example 4-7. 
Rotation transformation
var tileSheet = new Image();
tileSheet.addEventListener('load', eventShipLoaded , false);

tileSheet.src = "tanks_sheet.png";
var animationFrames = [1,2,3,4,5,6,7,8];
var frameIndex = 0;
var rotation = 90;

var x = 50;
var y = 50;
function eventShipLoaded() {
 drawScreen();

}
function drawScreen() {
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa"; context.fillRect(0,0,500,500);
 context.save();
 context.setTransform(1,0,0,1,0,0)
 context.translate(x+16, y+16); var angleInRadians = rotation * Math.PI / 180;
 context.rotate(angleInRadians);
 var sourceX = Math.floor(animationFrames[frameIndex] % 8) *32;
 var sourceY = Math.floor(animationFrames[frameIndex] / 8) *32; context.drawImage(tileSheet, sourceX, sourceY,32,32,-16,-16,32,32);
 context.restore();
}
function eventShipLoaded() { drawScreen();

}
<a href="ch04.html#applying_a_rotation_transformation" title="Figure 4-8. 
Applying a rotation transformation">Figure 4-8</a> shows the output for this example.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893703.png" alt="Applying a rotation transformation" width="500" height="500">

Figure 4-8. 
Applying a rotation transformation
Let’s take this one step further by applying the animation technique from Example 4-5</a> and looping through the eight tiles while facing the tank at the 90-degree angle.
<h3>Animating a Transformed Image</h3>

To apply a series of image tiles to the rotated context, we simply have to add back in the frame tick loop code and increment the <code>frameIndex</code> variable on each frame tick. 
Example 4-8</a> has added this into the code for Example 4-7</a>.
Example 4-8. 
Animation and rotation

var tileSheet = new Image();
tileSheet.addEventListener('load', eventShipLoaded , false);
tileSheet.src = "tanks_sheet.png";
var animationFrames = [1,2,3,4,5,6,7,8];

var frameIndex = 0;
var rotation = 90;
var x = 50;
var y = 50;

function eventShipLoaded() {
 startUp();
}
function drawScreen() { //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa";
 context.fillRect(0,0,500,500);
 context.save(); context.setTransform(1,0,0,1,0,0)
 var angleInRadians = rotation * Math.PI / 180;
 context.translate(x+16, y+16)
 context.rotate(angleInRadians); var sourceX = Math.floor(animationFrames[frameIndex] % 8) *32;
 var sourceY = Math.floor(animationFrames[frameIndex] / 8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,-16,-16,32,32);
 context.restore(); frameIndex++;
 if (frameIndex==animationFrames.length) { frameIndex=0;
 }
}

function startUp(){
 setInterval(drawScreen, 100 );
}
When you test Example 4-8</a>, you should see that the tank has rotated 90 degrees, and the tank tracks loop through their animation frames.

As we did in Example 4-6</a>, let’s move the tank in the direction it is facing. 
This time, it will move to the right until it goes off the screen. 
Example 4-9</a> has added back in the <code>dx</code> and <code>dy</code> movement vectors; notice that <code>dx</code> is now <code>1</code>, and <code>dy</code> is now <code>0</code>.
Example 4-9. 

Rotation, animation, and movement
var tileSheet = new Image();
tileSheet.addEventListener('load', eventShipLoaded , false);
tileSheet.src = "tanks_sheet.png";

var animationFrames = [1,2,3,4,5,6,7,8];
var frameIndex = 0;
var rotation = 90;
var x = 50;

var y = 50;
var dx = 1;
var dy = 0;
function eventShipLoaded() { startUp();
}
function drawScreen() {
 x = x+dx; y = y+dy;
 //draw a background so we can see the Canvas edges context.fillStyle = "#aaaaaa";
 context.fillRect(0,0,500,500); context.save();
 context.setTransform(1,0,0,1,0,0)
 var angleInRadians = rotation * Math.PI / 180;
 context.translate(x+16, y+16) context.rotate(angleInRadians);
 var sourceX=Math.floor(animationFrames[frameIndex] % 8) *32;
 var sourceY=Math.floor(animationFrames[frameIndex] / 8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,,16,,16,32,32); context.restore();
 frameIndex++;
 if (frameIndex ==animationFrames.length) { frameIndex=0;
 }

}
function startUp(){
 setInterval(drawScreen, 100 );
}

When Example 4-9</a> is running, you will see the tank move slowly across the screen to the right. 
Its tracks animate through the series of tiles from the tile sheet on a plain gray background.
So far, we have only used tiles to simulate sprite-based animated movement. 
In the next section, we will examine how to use an image tile sheet to create a much more elaborate background using a series of tiles.

<h2>Creating a Grid of Tiles</h2>
Many games use what is called a <em>tile-based environment</em> for backgrounds and level graphics. 
We are now going to apply the knowledge we have learned from animating an image on the canvas to create the background maze for our hypothetical game: <em>No Tanks!</em> We will use the same tile sheet from the previous tank examples, but instead of showing the tank sprite tiles, we will create a maze for the tank to move through. 
We will not actually cover the game-play portion of the code in this chapter because we want to focus on using images to render the screen. 

In <a href="ch09.html" title="Chapter 9. 
Combining Bitmaps and Sound">Chapter 9</a> we will create a simple game using the type of examples shown here.
<h3>Defining a Tile Map</h3>
We will use the term <em>tile map</em> to refer to a game level or background built from a tile sheet. 

Take a look back at <a href="ch04.html#example_tile_sheet" title="Figure 4-7. 
Example tile sheet">Figure 4-7</a>—the four row by eight column tile sheet from earlier in this chapter. 
If we were to create a maze-chase game similar to <em>Pac-Man</em>, we could define the maze using tiles from a tile sheet. 
The sequence of tiles for our game maze would be considered a tile map.

The first tile is a gray square, which we can use for the “road” tiles between the wall tiles. 
Any tile that a game sprite can move on is referred to as <em>walkable</em>. 
Even though our tanks are not literally walking but driving, the concept is the same. 
In <a href="ch09.html" title="Chapter 9. 

Combining Bitmaps and Sound">Chapter 9</a> we will create a small game using these concepts, but for now, let’s concentrate on defining a tile map and displaying it on the canvas.
Our tile map will be a two-dimensional array of tile id numbers. 
If you recall, the tile id numbers for our tile sheet are in a single dimension, numbering from 0 to 31. 
Let’s say we are going to create a very small game screen consisting of 10 tiles in length and 10 tiles in height. 

This means we need to define a tile map of 100 individual tiles (10×10). 
If our tiles are 32 pixels by 32 pixels, we will define a 320×320 game screen.
There are many ways to define a tile map. 
One simple way is to use a tile map editor program to lay out a grid of tiles, and then export the data to re-create the tile map in JavaScript. 

This is precisely how we are going to create our tile map.
<h3>Creating a Tile Map with Tiled</h3>
The program we are going to use, Tiled, is a great tile map editor that is available for Mac OS, Windows, and Linux. 
Of course, tile maps can be designed by hand, but map creation is much easier if we utilize a program such as Tiled to do some of the legwork for us. 

Tiled is available for free under the GNU free software license from <a href="http://www.mapeditor.org/">http://www.mapeditor.org/</a>.
<h3>Note</h3>
As stated before, you do not need to use this software. 
Tile maps can be created with other good (and free) software such as Mappy (<a href="http://tilemap.co.uk/mappy.php">http://tilemap.co.uk/mappy.php</a>) and Tile Studio (<a href="http://tilestudio.sourceforge.net/">http://tilestudio.sourceforge.net/</a>), and even by hand using MS Paint.

The goal of creating a tile map is to visually lay out a grid of tiles that represents the game screen, and then export the tile ids that represent those tiles. 
We will use the exported data as a two-dimensional array in our code to build the tile map on the canvas.
Here are the basic steps for creating a simple tile map in Tiled for use in the following section:
Create a new tile map from the File menu. 

When it asks for Orientation, select Orthogonal with a Map Size of 10×10 and a Tile Size of 32×32.
From the Map menu, import the <em>tanks_sheet.png</em> to be used as the tile set. 
Select “New tileset” from this menu, and give it any name you want. 
Browse to find the <em>tanks_sheet.png</em> that you downloaded from this book’s website. 

Make sure that Tile Width and Tile Height are both 32; keep the Margin and Spacing both at 0.
Select a tile from the tile set on the bottom-right side of the screen. 
Once selected, you can click and “paint” the tile by selecting a location on the tile map on the top- left side of the screen. 
<a href="ch04.html#the_tile_map_example_in_tiled" title="Figure 4-9. 

The tile map example in Tiled">Figure 4-9</a> shows the tile map created for this example.
Save the tile map. 
Tiled uses a plain text file format called <em>.tmx</em>. 
Normally, tile data in Tiled is saved out in a base-64-binary file format; however, we can change this by editing the preferences for Tiled. 

On a Mac, under the Tiled menu, there should be a Preferences section. 
(If you are using the software on Windows or Linux, you will find this in the File menu.) When setting the preferences, select CSV in the “Store tile layer data as” drop-down menu. 
Once you have done this, you can save the file from the File menu.
</li>

</ol>
Here is a look at what the saved <em>.tmx</em> file will look like in a text editor:
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;map version="1.0" orientation="orthogonal" width="10" height="10" tilewidth="32" tileheight="32"&gt; &lt;tileset firstgid="1" name="tanks" tilewidth="32" tileheight="32"&gt;
 &lt;image source="tanks_sheet.png"/&gt;
 &lt;/tileset&gt;
 &lt;layer name="Tile Layer 1" width="10" height="10"&gt; &lt;data encoding="csv"&gt;
32,31,31,31,1,31,31,31,31,32,
1,1,1,1,1,1,1,1,1,1,
32,1,26,1,26,1,26,1,1,32,

32,26,1,1,26,1,1,26,1,32,
32,1,1,1,26,26,1,26,1,32,
32,1,1,26,1,1,1,26,1,32,
32,1,1,1,1,1,1,26,1,32,

1,1,26,1,26,1,26,1,1,1,
32,1,1,1,1,1,1,1,1,32,
32,31,31,31,1,31,31,31,31,32
&lt;/data&gt;

&lt;/layer&gt;
&lt;/map&gt;
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893705.png" alt="The tile map example in Tiled" width="608" height="514">
Figure 4-9. 

The tile map example in Tiled
The data is an XML data set used to load and save tile maps. 
Because of the open nature of this format and the simple sets of row data for the tile map, we can use this data easily in JavaScript. 
For now, we are only concerned with the 10 rows of comma-delimited numbers inside the <code>&lt;data&gt;</code> node of the XML—we can take those rows of data and create a very simple two-dimensional array to use in our code.

<h3>Displaying the Map on the Canvas</h3>
The first thing to note about the data from Tiled is that it is <em>1 relative</em>, not 0 relative. 
This means that the tiles are numbered from 1–32 instead of 0–31. 
We can compensate for this by subtracting one from each value as we transcribe it to our array, or programmatically during our tile sheet drawing operation. 

We will do it programmatically by creating an offset variable to be used during the draw operation:
var mapIndexOffset = -1;
<h3>Note</h3>
Rather than using the <code>mapIndexOffset</code> variable, we could loop through the array of data and subtract 1 from each value. 

This would be done before the game begins, saving the extra processor overload from performing this math operation on each tile when it is displayed.
<h4>Map height and width</h4>
We also are going to create two variables to give flexibility to our tile map display code. 
These might seem simple and unnecessary now, but if you get in the habit of using variables for the height and width of the tile map, it will be much easier to change its size in the future.

We will keep track of the width and height based on the number of rows in the map and the number of columns in each row:
var mapRows = 10;
var mapCols = 10;
<h4>Storing the map data</h4>

The data that was output from Tiled was a series of rows of numbers starting in the top left and moving left to right, then down when the rightmost column in a row was completed. 
We can use this data almost exactly as output by placing it in a two-dimensional array:
var tileMap = [ [32,31,31,31,1,31,31,31,31,32]
 , [1,1,1,1,1,1,1,1,1,1] , [32,1,26,1,26,1,26,1,1,32]
 , [32,26,1,1,26,1,1,26,1,32]
 , [32,1,1,1,26,26,1,26,1,32]
 , [32,1,1,26,1,1,1,26,1,32] , [32,1,1,1,1,1,1,26,1,32]
 , [1,1,26,1,26,1,26,1,1,1]
 , [32,1,1,1,1,1,1,1,1,32]
 , [32,31,31,31,1,31,31,31,31,32] ];
<h4>Displaying the map on the canvas</h4>
When we display the tile map, we simply loop through the rows in the <code>tileMap</code> array, and then loop through the columns in each row. 
The <code>tileID</code> number at <code>[row]</code><code>[column]</code> will be the tile to copy from the tile sheet to the canvas. 

<code>row *32</code> will be the <code>y</code> location to place the tile on the canvas; <code>col*32</code> will be the <code>x</code> location to place the tile:
<h3>Note</h3>
The row, column referencing might seem slightly confusing because row is the <em>y</em> direction and column is the <em>x</em> direction. 
We do this because our tiles are organized into a two-dimensional array. 

The row is always the first subscript when accessing a 2D array.
for (var rowCtr=0;rowCtr&lt;mapRows;rowCtr++) {
 for (var colCtr=0;colCtr&lt;mapCols;colCtr++){
 var tileId = tileMap[rowCtr][colCtr]+mapIndexOffset; var sourceX = Math.floor(tileId % 8) *32; var sourceY = Math.floor(tileId / 8) *32; context.drawImage(tileSheet, sourceX, sourceY,32,32,colCtr*32,rowCtr*32,32,32);
 }
}
We use the <code>mapRows</code> and the <code>mapCols</code> variables to loop through the data and to paint it to the canvas. 

This makes it relatively simple to modify the height and width of the tile map without having to find the hardcoded values in the code. 
We could have also done this with other values such as the tile width and height, as well as the number of tiles per row in the tile sheet (8).
The <code>sourceX</code> and <code>sourceY</code> values for the tile to copy are found in the same way as in the previous examples. 
This time, though, we find the <code>tileId</code> using the <code>[rowCtr][colCtr]</code> two-dimensional lookup, and then adding the <code>mapIndexOffset</code>. 

The offset is a negative number (<code>-1</code>), so this effectively subtracts 1 from each tile map value, resulting in 0-relative map values that are easier to work with. 
Example 4-10</a> shows this concept in action, and <a href="ch04.html#the_tile_map_painted_on_the_canvas" title="Figure 4-10. 
The tile map painted on the canvas">Figure 4-10</a> illustrates the results.
Example 4-10. 

Rotation, animation, and movement
var tileSheet = new Image();
tileSheet.addEventListener('load', eventSheetLoaded , false);
tileSheet.src = "tanks_sheet.png";

var mapIndexOffset = -1;
var mapRows = 10;
var mapCols = 10;
var tileMap = [ [32,31,31,31,1,31,31,31,31,32] , [1,1,1,1,1,1,1,1,1,1]
 , [32,1,26,1,26,1,26,1,1,32]
 , [32,26,1,1,26,1,1,26,1,32]
 , [32,1,1,1,26,26,1,26,1,32] , [32,1,1,26,1,1,1,26,1,32]
 , [32,1,1,1,1,1,1,26,1,32]
 , [1,1,26,1,26,1,26,1,1,1]
 , [32,1,1,1,1,1,1,1,1,32] , [32,31,31,31,1,31,31,31,31,32]
 ];
function eventSheetLoaded() {
 drawScreen()

}
function drawScreen() {
 for (var rowCtr=0;rowCtr&lt;mapRows;rowCtr++) { for (var colCtr=0;colCtr&lt;mapCols;colCtr++){
 var tileId = tileMap[rowCtr][colCtr]+mapIndexOffset; var sourceX = Math.floor(tileId % 8) *32; var sourceY = Math.floor(tileId / 8) *32; context.drawImage(tileSheet, sourceX, sourceY,32,32,colCtr*32,rowCtr*32,32,32); }
 }
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893707.png" alt="The tile map painted on the canvas" width="320" height="320">

Figure 4-10. 
The tile map painted on the canvas
Next, we are going to leave the world of tile-based Canvas development (see <a href="ch09.html" title="Chapter 9. 
Combining Bitmaps and Sound">Chapter 9</a> for an example of a small game developed with these principles). 

The final section of this chapter discusses building our own simple tile map editor. 
But before we get there, let’s look at panning around and zooming in and out of an image.
<h2>Zooming and Panning an Image</h2>
In this section, we will examine some methods to zoom and pan an image on the canvas. 

The image we are going to use is from a recent vacation to Central California. 
It is a large <em>.jpg</em> file, measuring 3648×2736. 
Obviously, this is far too large to view in a single canvas, so we will build a simple application allowing us to zoom and pan the image on our 500×500 canvas.
<a href="ch04.html#a_scaled-down_version_of_the_image_we_wi" title="Figure 4-11. 

A scaled-down version of the image we will zoom and pan">Figure 4-11</a> is a scaled-down version of this image.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893709.png.jpg" alt="A scaled-down version of the image we will zoom and pan" width="1000" height="750">
Figure 4-11. 
A scaled-down version of the image we will zoom and pan

<h3>Creating a Window for the Image</h3>
The first thing we are going to do is create a logical window, the size of the canvas, where our image will reside. 
We will use the following two variables to control the dimensions of this window:
var windowWidth = 500;

var windowHeight = 500;
We will also create two variables to define the current top-left corner for the window. 
When we move on to the panning examples, we will modify these values to redraw the image based on this location:
var windowX = 0;

var windowY = 0;
<h3>Drawing the Image Window</h3>
To draw the image window, we will simply modify the standard <code>context.drawImage()</code> function call using the values in the four variables we just defined:
context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0, 0, windowWidth,windowHeight);

Let’s take a closer look at this for a refresher on how the <code>drawImage()</code> function operates. 
The values are passed in order:
<code>photo</code>

The image instance we are going to use as our source for painting onto the canvas
<code>windowX</code>

The top-left <code>x</code> location to start copying from the source image
<code>windowY</code>

The top-left <code>y</code> location to start copying from the source image
<code>windowWidth</code>

The width of the rectangle to start copying from the source image
<code>windowHeight</code>

The height of the rectangle to start copying from the source image
<code>0</code>

The top-left <code>x</code> destination location for the image on the canvas
<code>0</code>

The top-left <code>y</code> destination location for the image on the canvas
<code>windowWidth</code>

The width in pixels for the destination copy (this can be modified to scale the image)
<code>windowHeight</code>

The height in pixels for the destination copy (this can be modified to scale the image)

When we draw from the image to the canvas, we will be modifying the <code>windowX</code> and <code>windowY</code> values to create a panning effect. 
Example 4-11</a> demonstrates how to get the image onto the canvas with the window location set to <code>0</code>,<code>0</code>. 
<a href="ch04.html#an_image_in_a_small_logical_window" title="Figure 4-12. 
An image in a small logical window">Figure 4-12</a> shows an example of the output for Example 4-11</a>.

Example 4-11. 
Placing an image on the canvas in a logical window
var photo = new Image();
photo.addEventListener('load', eventPhotoLoaded , false);

photo.src = "butterfly.jpg";
var windowWidth = 500;
var windowHeight = 500;
var windowX = 0;

var windowY = 0;
function eventPhotoLoaded() {
 drawScreen()
}

function drawScreen(){
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0, 0, windowWidth,windowHeight);
}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893711.png.jpg" alt="An image in a small logical window" width="500" height="500">

Figure 4-12. 
An image in a small logical window
<h3>Panning the Image</h3>
To pan the window across the image, we simply need to modify the <code>windowX</code> and <code>windowY</code> coordinates. 

In Example 4-12</a>, we will modify the <code>windowX</code> coordinate inside a frame tick interval. 
During each loop iteration, we will increase the value of <code>windowX</code> by <code>10</code>. 
We need to be careful not to go off the far right side of the image, so we will subtract the <code>windowWidth</code> from the <code>image.width</code>, and use the result as the maximum <code>windowX</code> position:
windowX+ = 10;

if (windowX&gt;photo.width - windowWidth){
 windowX = photo.width - windowWidth;
}
Example 4-12</a> contains the changes necessary to perform this panning operation.

Example 4-12. 
Simple image panning
var photo = new Image();
photo.addEventListener('load', eventPhotoLoaded , false);

photo.src = "butterfly.jpg";
var windowWidth = 500;
var windowHeight = 500;
var windowX = 0;

var windowY = 0;
function eventPhotoLoaded() {
 startUp();
}

function drawScreen(){
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0,0,windowWidth,windowHeight);
 windowX += 10;
 if (windowX&gt;photo.width - windowWidth){ windowX = photo.width - windowWidth; }
}
function startUp(){
 setInterval(drawScreen, 100 );

}
When you test Example 4-12</a>, you will see the window pan across the image and stop at the rightmost edge. 
Next, we will start to implement zooming into this simple example.
<h3>Zoom and Pan the Image</h3>

To zoom in or out of an image, we need to change the final <code>width</code> and <code>height</code> values of the <code>drawImage()</code> function. 
Let’s examine how we would zoom out to 50% of the original size of the image while panning at the same time. 
The <code>drawImage()</code> function will look like this:
context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0, 0, windowWidth*.5,windowHeight*.5);
Example 4-13</a> modifies Example 4-12</a> and adds in the 50% zoom.
Example 4-13. 
Pan an image with a preset zoom out

var photo = new Image();
photo.addEventListener('load', eventPhotoLoaded , false);
photo.src = "butterfly.jpg";
var windowWidth = 500;

var windowHeight = 500;
var windowX = 0;
var windowY = 0;
function eventPhotoLoaded() { startUp();
}
function drawScreen(){
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0,0,windowWidth*.5,windowHeight*.5); windowX += 10;
 if (windowX&gt;photo.width - windowWidth){ windowX = photo.width - windowWidth;
 }
}

function startUp(){
 setInterval(drawScreen, 100 );
}
When we test this example, we will see that when zoomed out, the image on the canvas is 50% of its original size. 

To zoom in, we simply change the scale factor from <code>.5</code> to a number greater than <code>1</code>:
context.drawImage(photo, windowX, windowY, windowWidth,windowHeight, 0,0,windowWidth*2,windowHeight*2);
Example 4-14</a> changes this single line from Example 4-13</a> to zoom in rather than zoom out.

Example 4-14. 
Pan an image with a preset zoom amount
var photo = new Image();
photo.addEventListener('load', eventPhotoLoaded , false);

photo.src = "butterfly.jpg";
var windowWidth = 500;
var windowHeight = 500;
var windowX = 0;

var windowY = 0;
function eventPhotoLoaded() {
 startUp();
}

function drawScreen(){
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0,0,windowWidth*2,windowHeight*2);
 windowX += 10;
 if (windowX&gt;photo.width - windowWidth){ windowX = photo.width - windowWidth; }
}
function startUp(){
 setInterval(drawScreen, 100 );

}
<h3>Application: Controlled Pan and Zoom</h3>
Our final example for this section will be a simple application allowing the user to zoom and pan a photo.
<h4>The zoom scale</h4>

We are going to create a set of variables to handle the current zoom scale, the factor by which the zoom scale is increased or decreased, as well as the maximum and minimum zoom values:
var currentScale = .5;
var minScale = .2
var maxScale = 3;

var scaleIncrement = .1;
We will apply these values to the <code>drawImage()</code> function:
context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0,0,windowWidth*currentScale,windowHeight*currentScale);
<h4>Keyboard input</h4>

Now we need to create a keyboard listener function. 
The following function seems to work best in all browsers tested—it’s certainly not the only keyboard event listener, but it is tried and true throughout this book:
document.onkeydown = function(e){
 e = e?e:window.event;

}
<h3>Note</h3>
This function utilizes the <em>ternary operator</em>. 
If the statement before the <code>?</code> is <code>true</code>, the statement following the <code>?</code> is executed. 

If it is <code>false</code>, the statement after the <code>:</code> is executed. 
This is a shorthand version of the classic <code>if</code>/<code>else</code> construct.
We will add a <code>switch</code>/<code>case</code> statement, combining all the functions we have put into the previous zoom and pan examples, along with a new set of code for the <em>y</em> direction panning that we have not implemented before. 
It is very similar to the <em>x</em> direction panning: the left arrow key will pan the image to the left; the right arrow key will pan the image to the right:

case 38: //up windowY-=10; if (windowY&lt;0){ windowY = 0; } break;
case 40: //down windowY+=10; if (windowY&gt;photo.height - windowHeight){ windowY = photo.height - windowHeight; } break;
case 37: //left windowX-=10; if (windowX&lt;0){ windowX = 0; } break;
case 39: //right windowX+=10; if (windowX&gt;photo.width - windowWidth){ windowX = photo.width - windowWidth; } break;

We also need to add in two cases for the + and - keys to perform zoom in and zoom out actions:
case 109: //- currentScale-=scaleIncrement; if (currentScale&lt;minScale){ currentScale = minScale; } break;
case 107: //+ currentScale+=scaleIncrement; if (currentScale&gt;maxScale){ currentScale = maxScale; }
When the user presses the + or - key, the <code>currentScale</code> variable is either incremented or decremented by the <code>scaleIncrement</code> value. 

If the new value of <code>currentScale</code> is greater than <code>maxScale</code> or lower than <code>minScale</code>, we set it to <code>maxScale</code> or <code>minScale</code>, respectively.
Example 4-15</a> puts this entire application together. 
It doesn’t take many lines of code to create the simple interactions.
Example 4-15. 

Image pan and zoom application
var photo = new Image();
photo.addEventListener('load', eventPhotoLoaded , false);
photo.src = "butterfly.jpg";

var windowWidth = 500;
var windowHeight = 500;
var windowX = 0;
var windowY = 0;

var currentScale = .5;
var minScale = .2
var maxScale = 3;
var scaleIncrement = .1;

function eventPhotoLoaded() {
 startUp();
}
function drawScreen(){ //draw a background so we can see the Canvas edges context.fillStyle = "#ffffff";
 context.fillRect(0,0,500,500);
 context.drawImage(photo, windowX, windowY, windowWidth, windowHeight, 0,0,windowWidth*currentScale,windowHeight*currentScale);

}
function startUp(){
 setInterval(drawScreen, 100 );
}

document.onkeydown = function(e){
 e = e?e:window.event;
 console.log(e.keyCode + "down");
 switch (e.keyCode){ case 38: //up windowY-=10; if (windowY&lt;0){ windowY = 0; } break; case 40: //down windowY+=10; if (windowY&gt;photo.height - windowHeight){ windowY = photo.height - windowHeight; } break; case 37: //left windowX-=10; if (windowX&lt;0){ windowX = 0; } break; case 39: //right windowX+=10; if (windowX&gt;photo.width - windowWidth){ windowX = photo.width - windowWidth; } break; case 109: //- currentScale-=scaleIncrement; if (currentScale&lt;minScale){ currentScale = minScale; } break; case 107: //+ currentScale+=scaleIncrement; if (currentScale&gt;maxScale){ currentScale = maxScale; } }
}
When testing Example 4-15</a>, use the arrow keys to pan across the photo, and the + and - keys to zoom in and out.
<h2>Pixel Manipulation</h2>
In this section, we will first examine the Canvas Pixel Manipulation API, and then build a simple application demonstrating how to manipulate pixels on the canvas in real time.
<h3>The Canvas Pixel Manipulation API</h3>
The Canvas Pixel Manipulation API gives us the ability to “get,” “put,” and “change” individual pixels utilizing what is known as the <code>CanvasPixelArray</code> interface. 
<code>ImageData</code> is the base object type for this manipulation, and an instance of this object is created with the <code>createImageData()</code> function call. 

Let’s start there.
The <code>createImageData()</code> function sets aside a portion of memory to store individual pixels’ worth of data based on the following three constructors:
<em><code>imagedata = context.</code></em><code>createImageData</code><em><code>(sw, sh)</code></em>

The <em><code>sw</code></em> and <em><code>sh</code></em> parameters represent the <code>width</code> and <code>height</code> values for the <code>ImageData</code> object. 
For example, <code>imagedata=createImageData(100,100)</code> would create a 100×100 area of memory in which to store pixel data.

<em><code>imagedata = context.</code></em><code>createImageData</code><em><code>(imagedata)</code></em>
The <em><code>imagedata</code></em> parameter represents a separate instance of <code>ImageData</code>. 
This constructor creates a new <code>ImageData</code> object with the same width and height as the parameter <code>ImageData</code>.

<em><code>imagedata = context.</code></em><code>createImageData</code><em><code>()</code></em>
This constructor returns a blank <code>ImageData</code> instance.

<h4>ImageData attributes</h4>
An <code>ImageData</code> object contains three attributes:

<code>ImageData.height</code>
This returns the height in pixels of the <code>ImageData</code> instance.

<code>ImageData.width</code>
This returns the width in pixels of the <code>ImageData</code> instance.

<code>ImageData.data</code>
This returns a single dimensional array of pixels representing the image data. 

Image data is stored with 32-bit color information for each pixel, meaning that every fourth number in this data array starts a new pixel. 
The four elements in the array represent the red, green, blue, and alpha transparency values of a single pixel.

<h4>Getting image data</h4>
To retrieve a set of pixel data from the canvas and put it into an <code>ImageData</code> instance, we use the <code>getImageData()</code> function call:
<em><code>imagedata</code></em> = <em><code>context</code></em>.getImageData(<em><code>sx</code></em>, <em><code>sy</code></em>, <em><code>sw</code></em>, <em><code>sh</code></em>)
<em><code>sx</code></em>, <em><code>sy</code></em>, <em><code>sw</code></em>, and <em><code>sh</code></em> define the location and size of the source rectangle to copy from the canvas to the <code>ImageData</code> instance.

<h3>Note</h3>
A security error will be thrown if the origin domain of an image file is not the same as the origin domain of the web page. 
This affects local files (when running on your hard drive rather than on a web server running locally or on a remote server), as most browsers will treat local image files as though they are from a different domain than the web page. 
When running on a web server, this error will not be thrown with local files. 

The current version of Safari (5.02) does not throw this error for local files.
<h4>Putting image data</h4>
To copy the pixels from an <code>ImageData</code> instance to the canvas, we use the <code>putImageData()</code> function call. 
There are two different constructors for this call:

<em><code>context</code></em>.putImageData (<em><code>imagedata</code></em>, <em><code>dx</code></em>, <em><code>dy)</code></em>
<em><code>context</code></em>.putImageData (<em><code>imagedata</code></em>, <em><code>dx</code></em>, <em><code>dy</code></em> [, <em><code>dirtyX</code></em>, <em><code>dirtyY</code></em>, <em><code>dirtyWidth</code></em>, <em><code>dirtyHeight</code></em> ])
The first constructor simply paints the entire <code>ImageData</code> instance to the <code>destinationX</code> (<code>dx</code>) and <code>destinationY</code> (<code>dy</code>) locations. 
The second constructor does the same, but allows the passage of a “dirty rectangle,” which represents the area of the <code>ImageData</code> to paint to the canvas.

<h3>Application Tile Stamper</h3>
We are going to create a simple application that will allow the user to highlight a box around some pixels on an image, copy them, and then use them as a stamp to paint back to the canvas. 
It will not be a full-blown editing application by any means—it’s just a demonstration of one use of the <code>ImageData</code> object.
<h3>Note</h3>

This application will need to be run from a local or remote web server, as most browsers will throw an exception if an application attempts to call <code>getImageData()</code> on a file—even in the same folder on a local machine. 
The current version of Safari (5.02) does not throw this error.
To create this simple application, we will use the tile sheet from earlier in this chapter. 
The user will click on a spot on the tile sheet, highlighting a 32×32 square tile. 

That tile can then be painted onto the bottom section of the canvas. 
To demonstrate pixel manipulation, we will set the color of the pixels to a new alpha value before they are painted to the screen. 
This will be the humble beginning to making our own tile map editor.
Once again, we will use the <em>tanks_sheet.png</em> file from <a href="ch04.html#example_tile_sheet" title="Figure 4-7. 

Example tile sheet">Figure 4-7</a>.
<h4>How ImageData.data is organized</h4>
The <code>ImageData.data</code> attribute is a single-dimensional array containing four bytes for every pixel in the <code>ImageData</code> object. 
We will be using 32×32 tiles in our example application. 

A 32×32 tile contains 1,024 pixels (or 1K of data). 
The <code>ImageData.data</code> attribute for an <code>ImageData</code> instance that holds a 32×32 image would be 4,096 bytes (or 4K). 
This is because a separate byte is used to store each of the red, green, blue, and alpha values for each pixel. 
In our application, we will loop through each pixel and set its alpha value to <code>128</code>. 

Here is the code we will use:
for (j=3; j&lt; imageData.data.length; j+=4){
 imageData.data[j] = 128;
}

We start our loop at <code>3</code>, which is the fourth attribute in the array. 
The single-dimensional array contains a continuous set of values for each pixel, so index <code>3</code> represents the alpha value for the first pixel (because the array is 0 relative). 
Our loop then skips to every fourth value in the array and sets it to <code>128</code>. 
Once the loop is complete, all pixels will have an alpha value of <code>128</code>.

<h3>Note</h3>
As opposed to other Canvas alpha manipulations where the alpha value is between 0 and 1, the alpha value is between 0 and 255 when manipulating it via the pixel color values.
<h4>A visual look at our basic application</h4>
<a href="ch04.html#the_tile_stamper_application" title="Figure 4-13. 

The Tile Stamper application">Figure 4-13</a> is a screenshot of the simple Tile Stamper application we will create.
<h3>Note</h3>
<a href="ch04.html#the_tile_stamper_application" title="Figure 4-13. 
The Tile Stamper application">Figure 4-13</a> is running in Safari 5.1 locally. 

As of this writing, this is the only browser that does not throw an exception when trying to manipulate the pixel data of a locally loaded file when not run on a web server.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893713.png" alt="The Tile Stamper application" width="256" height="256">
Figure 4-13. 
The Tile Stamper application

The screen is broken up into two sections vertically. 
The top section is the 256×128 tile sheet; the bottom is a tile map of the same size. 
The user will select a tile in the top section, and it will be highlighted by a red square. 
The user can then stamp the selected tile to the tile map drawing area in the lower portion. 

When a tile is drawn in this lower portion, we will set its alpha value to <code>128</code>.
<h4>Adding mouse events to the canvas</h4>
We need to code our application to respond to mouse clicks and to keep track of the current <code>x</code> and <code>y</code> positions of the mouse pointer. 
We will set up two global application scope variables to store the mouse pointer’s current position:

var mouseX;
var mouseY;
We will also set up two event listener functions and attach them to the <code>theCanvas</code> object:
theCanvas.addEventListener("mousemove", onMouseMove, false);

theCanvas.addEventListener("click", onMouseClick, false);
In the HTML, we will set up a single <code>Canvas</code> object:
&lt;canvas width="256" height="256" style="position: absolute; top: 50px; left: 50px;"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
In the JavaScript portion of our code, we will define the canvas:
theCanvas = document.getElementById("canvas");
Notice that we set the <code>&lt;canvas&gt;</code> position to <code>top: 50px</code> and <code>left: 50px</code>. 

This will keep the application from being shoved up into the top-left corner of the browser, but it also gives us a chance to demonstrate how to find correct mouse <code>x</code> and <code>y</code> values when the <code>&lt;canvas&gt;</code> tag is not in the top-left corner of the page. 
The <code>onMouseMove</code> function will make use of this information to offset the <code>mouseX</code> and <code>mouseY</code> values based on the position of the <code>&lt;canvas&gt;</code> tag:
function onMouseMove(e) {
 mouseX = e.clientX-theCanvas.offsetLeft; mouseY = e.clientY-theCanvas.offsetTop;
}
The <code>onMouseClick</code> function will actually do quite a lot in our application. 
When the mouse button is clicked, this function will determine whether the user clicked on the tile sheet or on the tile map drawing area below it. 

If the user clicked on the tile sheet, the function will determine which exact tile was clicked. 
It will then call the <code>highlightTile()</code> function and pass in the id (0–31) of the tile clicked, along with the <code>x</code> and <code>y</code> locations for the top-left corner of the tile.
If the user clicked in the lower portion of the tile map drawing area, this function will again determine which tile the user clicked on, and stamp the current selected tile in that location on the tile map. 
Here is the function:

function onMouseClick(e) {
 if (mouseY &lt; 128){ //find tile to highlight var col = Math.floor(mouseX / 32); var row = Math.floor(mouseY / 32); var tileId = (row*7)+(col+row); highlightTile(tileId,col*32,row*32)
 }else{ var col = Math.floor(mouseX / 32); var row = Math.floor(mouseY / 32); context.putImageData(imageData,col*32,row*32); }
 }

Let’s take a closer look at the tile sheet click (<code>mouseY &lt; 128</code>).
To determine the <code>tileId</code> of the tile clicked on the tile sheet, we first need to convert the <code>x</code> location of the mouse click to a number from 07, and the <code>y</code> location to a number from 03. 
We do this by calling the <code>Math.floor</code> function on the result of the current <code>mouseX</code> or <code>mouseY</code> location, divided by the tile width or height (they are both <code>32</code>). 
This will find the <code>row</code> and <code>col</code> of the clicked tile:

var col = Math.floor(mouseX / 32);
var row = Math.floor(mouseY / 32)
To find the <code>tileId</code> (the 031 tile number of the tile sheet) of this row and column combination, we need to use the following calculation:
TileId = (row*totalRows-1) + (col+row);

The actual calculation, with values for our application, looks like this:
var tileId = (row*7)+(col+row);
For example, if the user clicks on the point where <code>mouseX = 50</code> and <code>mouseY = 15</code>, the calculation would work like this:
col = Math.floor(50/32); // col = 1

row = Math.floor(15/32); // row = 0
tileId = (0*7)+(1+0); // tileId = 1
This position is the second tile on the tile sheet. 
The <code>onMouseClick()</code> function then passes the <code>tileId</code> and <code>col</code> value multiplied by <code>32</code>, and the <code>row</code> value multiplied by <code>32</code>, into the <code>highlightTile()</code> function. 

This tells the <code>highlightTile()</code> function the exact <code>tileId</code>, <code>row</code>, and <code>col</code> the user clicked.
If the user clicked the tile map drawing area in the lower portion of the screen, the code does the same row and column calculation. 
However, it then calls the <code>putImageData()</code> function and passes in the <code>ImageData</code> instance that holds the tile to stamp and the top-left location to place the tile:
var col = Math.floor(mouseX / 32);

var row = Math.floor(mouseY / 32);
context.putImageData(imageData,col*32,row*32);
<h4>The highlightTile() function</h4>
The <code>highlightTile()</code> function accepts three parameters:

The 0–31 <code>tileId</code> of the tile on the tile sheet
The top-left <code>x</code> coordinate of the tile represented by the <code>tileId</code>

The top-left <code>y</code> coordinate of the tile represented by the <code>tileId</code>
<h3>Note</h3>

The <code>x</code> and <code>y</code> coordinates can be found by passing in the <code>tileId</code> value, but they are needed in the <code>onMouseDown</code> function, so we pass them in from there when calling <code>highlightTile()</code>. 
This way, we do not need to perform the calculation twice.
The first task <code>highlightTile()</code> tackles is redrawing the tile sheet at the top of the screen:
context.fillStyle = "#aaaaaa";

context.fillRect(0,0,256,128);
drawTileSheet();
It does this to delete the red box around the current tile, while preparing to draw a new red box around the tile represented by the <code>tileId</code> passed in.
The <code>drawTileSheet()</code> function then paints the <em>tanks_sheet.png</em> file to the canvas starting at <code>0</code>,<code>0</code>:

function drawTileSheet(){
 context.drawImage(tileSheet, 0, 0);
}
Next, the <code>highlightTile()</code> function copies the new pixel data (with no red line around it yet) from the canvas and places it in the <code>ImageData</code> instance:

ImageData = context.getImageData(x,y,32,32);
The <code>ImageData</code> variable now contains a copy of the pixel data for the tile from the canvas. 
We then loop through the pixels in <code>ImageData.data</code> (as described previously in How ImageData.data is organized</a>), and set the alpha value of each to <code>128</code>.
Finally, now that the <code>ImageData</code> variable contains the correct pixels with the altered alpha values, we can draw the red line around the tile that’s been selected to stamp on the tile map:

var startX = Math.floor(tileId % 8) *32;
var startY = Math.floor(tileId / 8) *32;
context.strokeStyle = "red";
context.strokeRect(startX,startY,32,32)

Example 4-16</a> is the entire set of code for this application.
Example 4-16. 
The Tile Stamper application
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH4EX16: Tile Stamper Application&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () {
 return Modernizr.canvas;

}
function canvasApp(){
 if (!canvasSupport()) { return;
 }else{ var theCanvas = document.getElementById("canvas"); var context = theCanvas.getContext("2d"); }
 var mouseX;
 var mouseY;
 var tileSheet = new Image(); tileSheet.addEventListener('load', eventSheetLoaded , false);
 tileSheet.src = "tanks_sheet.png";
 var imageData = context.createImageData(32,32);
 function eventSheetLoaded() { startUp(); }
 function startUp(){ context.fillStyle = "#aaaaaa"; context.fillRect(0,0,256,256); drawTileSheet();
 }
 function drawTileSheet(){ context.drawImage(tileSheet, 0, 0); }
 function highlightTile(tileId,x,y){ context.fillStyle = "#aaaaaa"; context.fillRect(0,0,256,128); drawTileSheet();
 imageData = context.getImageData(x,y,32,32); //loop through imageData.data. 
Set every 4th value to a new value for (j=3; j&lt; imageData.data.length; j+=4){ imageData.data[j]=128; } var startX = Math.floor(tileId % 8) *32; var startY = Math.floor(tileId / 8) *32; context.strokeStyle = "red"; context.strokeRect(startX,startY,32,32)
 }
 function onMouseMove(e) { mouseX = e.clientX-theCanvas.offsetLeft; mouseY = e.clientY-theCanvas.offsetTop;
 } function onMouseClick(e) { console.log("click: " + mouseX + "," + mouseY); if (mouseY &lt; 128){ //find tile to highlight var col = Math.floor(mouseX / 32); var row = Math.floor(mouseY / 32) var tileId = (row*7)+(col+row); highlightTile(tileId,col*32,row*32) }else{ var col = Math.floor(mouseX / 32); var row = Math.floor(mouseY / 32);
 context.putImageData(imageData,col*32,row*32);
 }
 } theCanvas.addEventListener("mousemove", onMouseMove, false);
 theCanvas.addEventListener("click", onMouseClick, false);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="256" height="256" style="position: absolute; top: 50px; left: 50px;"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Note</h3>
As of this writing, you must run this application from a web server in order to manipulate the local <em>tanks_sheet.png</em> file on the canvas. 
If you are using the Safari browser (version 5.1 as of this writing), you can test the application on a local drive and it will function properly.

<h2>Copying from One Canvas to Another</h2>
The canvas allows us to use another canvas as the source of a bitmap drawing operation. 
Let’s take a quick look at how we might utilize this functionality.
We will need to modify the base file for this chapter and create an extra <code>&lt;canvas&gt;</code> tag in our HTML. 

We will name this extra <code>&lt;canvas&gt;</code> element <code>canvas2</code> (it can be given any id as long as it is not the same id as the first <code>&lt;canvas&gt;</code>). 
Here is what our HTML <code>&lt;body&gt;</code> will look like now:
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="256" height="256" style="position: absolute; top: 50px; left: 50px;"&gt;Your browser does not support HTML5 Canvas.&lt;/canvas&gt;
&lt;canvas width="32" height="32" style="position: absolute; top: 256px; left: 50px;"&gt;Your browser does not support HTML5 Canvas.&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

We will place the second <code>&lt;canvas&gt;</code> below the original, and give it a <code>width</code> and <code>height</code> of <code>32</code>. 
We will also need to create a new context and internal reference variable for <code>canvas2</code>. 
Here is the code that will be used to provide a reference to both <code>&lt;canvas&gt;</code> elements:
if (!canvasSupport()) { return; }else{
 var theCanvas = document.getElementById("canvas");
 var context = theCanvas.getContext("2d");
 var theCanvas2 = document.getElementById("canvas2"); var context2 = theCanvas2.getContext("2d");
}
Example 4-17</a> will use the tile sheet image from earlier examples and draw it to the first canvas. 
It will then copy a 32×32 square from this canvas and place it on the second canvas.

Example 4-17. 
Copying from one canvas to another
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH4EX17: Canvas Copy&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () {
 return Modernizr.canvas;
}

function canvasApp(){
 if (!canvasSupport()) { return;
 }else{ var theCanvas = document.getElementById("canvas"); var context = theCanvas.getContext("2d"); var theCanvas2 = document.getElementById("canvas2"); var context2 = theCanvas2.getContext("2d");
 } var tileSheet = new Image();
 tileSheet.addEventListener('load', eventSheetLoaded , false);
 tileSheet.src="tanks_sheet.png";
 function eventSheetLoaded() { startUp();
 }
 function startUp(){ context.drawImage(tileSheet, 0, 0); context2.drawImage(theCanvas, 32, 0,32,32,0,0,32,32);
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="256" height="256" style="position: absolute; top: 50px; left: 50px;"&gt; Your browser does not support HTML5 Canvas.&lt;/canvas&gt;
&lt;canvas width="32" height="32" style="position: absolute; top: 256px; left: 50px;"&gt;Your browser does not support HTML5 Canvas.&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<a href="ch04.html#an_example_canvas_copy_operation" title="Figure 4-14. 
An example canvas copy operation">Figure 4-14</a> shows the canvas copy functions in operation.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893715.png" alt="An example canvas copy operation" width="277" height="284">
Figure 4-14. 
An example canvas copy operation
Canvas copy operations can be very useful when creating applications that need to share and copy image data across multiple <code>&lt;div&gt;</code> instances on (and the <code>Canvas</code> object within) a web page. 

For example, multiple <code>Canvas</code> elements can be spread across a web page, and as the user makes changes to one, the others can be updated. 
This can be used for fun applications, such as a “minimap” in a game, or even in serious applications, such as stock portfolio charting and personalization features.
<h2>What’s Next</h2>
We covered quite a lot in this chapter, evolving from simply loading images to animating and rotating them. 

We looked at using tile sheets and tile maps, and then we built some useful applications with Canvas image functions and capabilities. 
In the first four chapters, we covered most of what Canvas offers as a drawing surface. 
In the next six chapters, we will cover some more advanced topics, such as applying 2D physics to <code>Canvas</code> objects, integrating the HTML5 <code>&lt;video&gt;</code> and <code>&lt;audio&gt;</code> tags with the <code>&lt;canvas&gt;</code> tag, creating games, and looking at some libraries and features that we can use to extend the functionality of HTML5 Canvas, even creating applications for mobile devices.
 5. 

Math, Physics, and Animation" epub:type="chapter">
<h2><span class="orange">Chapter 5. Math, Physics, and Animation</span></h2>
Impressing users with animation involves more than knowing how to move objects—you also need to know how to move them in ways that users expect.
 That requires understanding some common algorithms for math-based movement and physics interactions. 
Simple movement based on points and vectors provides a foundation, and then it’s time to create objects that bounce off walls and one another with a bit of friction added to the mix. 
After that, we will step back and talk about movement that goes beyond straight lines: circles, spirals, and complex Bezier curves. 
We will then cover how adding gravity can affect movement. 
Finally, we will finish this chapter by discussing easing and how it can have a positive effect on math-based animations.
<h2>Moving in a Straight Line</h2>
For the simplest kinds of animations—moving objects in a straight line up and down the canvas—this can take the form of adding a constant value to the <code>x</code> or <code>y</code> position of an object every time it is drawn.

So, to animate graphics, we will need to create an interval and then call a function that will display our updated graphics on every frame. 
Each example in this chapter will be built in a similar way. 
The first step is to set up the necessary variables in our <code>canvasApp()</code> function. 
For this first, basic example of movement, we will create a variable named <code>speed</code>. 

We will apply this value to the <code>y</code> position of our object on every call to <code>drawScreen()</code>. 
The <code>x</code> and <code>y</code> variables set up the initial position of the object (a filled circle) we will move down the canvas:
var speed = 5;
var y = 10;

var x = 250;
After we create the variables, we set up an interval to call the <code>drawScreen()</code> function every 33 milliseconds. 
This is the loop we need to update our objects and move them around the canvas:
setInterval(drawScreen, 33);

In the <code>drawScreen()</code> function, we update the value of <code>y</code> by adding to it the value of the <code>speed</code> variable:
y += speed;
Finally, we draw our circle on the canvas. 
We position it using the current value of <code>x</code> and <code>y</code>. 

Since <code>y</code> is updated every time the function is called, the circle effectively moves down the canvas:
context.fillStyle = "#000000";
context.beginPath();
context.arc(x,y,15,0,Math.PI*2,true);

context.closePath();
context.fill();
To move the circle up the screen, we would make <code>speed</code> a negative number. 
To move it left or right, we would update the <code>x</code> instead of the <code>y</code> variable. 

To move the circle diagonally, we would update both <code>x</code> and <code>y</code> at the same time.
Example 5-1</a> shows the complete code needed to create basic movement in a straight line.
Example 5-1. 
Moving in a straight line

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH5EX1: Moving In A Straight Line&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () { context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 // Create ball y += speed;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(x,y,15,0,Math.PI*2,true); context.closePath(); context.fill(); }
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 var speed = 5; var y = 10;
 var x = 250;
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Note</h3>
The basic structure of the HTML for all of the examples in this chapter will follow these rules. 

In the interest of saving space, we will refrain from discussing this code further, but it will appear in the examples provided.
<h3>Moving Between Two Points: The Distance of a Line</h3>
Movement based on constant changes to the <code>x</code> or <code>y</code> position of an object works well for some applications, but other times you will need to be more precise. 
One such instance is when you need to move an object from point A to point B at a constant rate of speed.

In mathematics, a common way to find the length of an unknown line is to use the Pythagorean theorem:
<table><tr><td>A<sup>2</sup> + B<sup>2</sup> = C<sup>2</sup>
</td></tr></table>
In this equation, C is the unknown side of a triangle when A and B are already known. 

However, we need to translate this equation into something we can use with the points and pixels we have available on the canvas.
This is a good example of using a mathematical equation in your application. 
In this case, we want to find the distance of a line, given two points. 
In English, this equation reads like this:

<blockquote>
The distance equals the square root of the square of the difference between the <em>x</em> value of the second point minus the <em>x</em> value of the first point, plus the square of the difference between the <em>y</em> value of the second point minus the <em>y</em> value of the first point.
</blockquote>
You can see this in <a href="ch05.html#distance_equation" title="Equation 5-1. 

Distance equation">Equation 5-1</a>. 
It’s much easier to understand in this format.
Equation 5-1. 
Distance equation

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893717.png" alt="Distance equation" width="240" height="52">
In the second example, we need to create some new variables in the <code>canvasApp()</code> function. 
We will still use a <code>speed</code> variable, just like in the first example, but this time we set it to <code>5</code>, which means it will move <code>5</code> pixels on every call to <code>drawScreen()</code>:
var speed = 5;

We then create a couple dynamic objects—each with an <code>x</code> and a <code>y</code> property—that will represent the two points we want to move between. 
For this example, we will move our circle from <code>20</code>,<code>250</code> to <code>480</code>,<code>250</code>:
var p1 = {x:20,y:250};
var p2 = {x:480,y:250};

Now it is time to re-create the distance equation in <a href="ch05.html#distance_equation" title="Equation 5-1. 
Distance equation">Equation 5-1</a>. 
The first step is to calculate the differences between the second and first <code>x</code> and <code>y</code> points:
var dx = p2.x - p1.x;

var dy = p2.y - p1.y;
To determine the <code>distance</code>, we square both the values we just created, add them, and then use the <code>Math.sqrt()</code> function to get the square root of the number:
var distance = Math.sqrt(dx*dx + dy*dy);
Next, we need to use that calculated <code>distance</code> in a way that will allow us to move an object a uniform number of pixels from <code>p1</code> to <code>p2</code>. 

The first thing we do is calculate how many <code>moves</code> (calls to <code>drawScreen()</code>) it will take the object to move at the given value of <code>speed</code>. 
We get this by dividing the <code>distance</code> by the <code>speed</code>:
var moves = distance/speed;
Then we find the distance to move both <code>x</code> and <code>y</code> on each call to <code>drawScreen()</code>. 

We name these variables <code>xunits</code> and <code>yunits</code>:
var xunits = (p2.x - p1.x)/moves;
var yunits = (p2.y - p1.y)/moves;
Finally, we create a dynamic object named <code>ball</code> that holds the <code>x</code> and <code>y</code> value of <code>p1</code>…

var ball = {x:p1.x, y:p1.y};
…and create the interval to call <code>drawScreen()</code> every 33 milliseconds:
setInterval(drawScreen, 33);
<h4>Drawing the ball</h4>

Let’s draw the ball on the screen. 
In the <code>drawScreen()</code> function, we first check to see whether the <code>moves</code> variable is greater than zero. 
If so, we are still supposed to move the ball across the screen because we have not yet reached <code>p2</code>. 
We decrement moves (<code>moves--</code>) and then update the <code>x</code> and <code>y</code> properties of the ball object by adding the <code>xunits</code> to <code>x</code> and <code>yunits</code> to <code>y</code>:

if (moves &gt; 0 ) {
 moves--;
 ball.x += xunits;
 ball.y += yunits;

}
Now that our <code>values</code> have been updated, we simply draw the ball at the <code>x</code> and <code>y</code> coordinates specified by the <code>x</code> and <code>y</code> properties, and we are done…that is, until <code>drawScreen()</code> is called 33 milliseconds later:
context.fillStyle = "#000000";
context.beginPath();

context.arc(ball.x,ball.y,15,0,Math.PI*2,true);
context.closePath();
context.fill();
Let’s try the example by executing it in a web browser. 

You can find it in the code distribution as <em>CH5EX2.html</em>, or you can type in Example 5-2</a>. 
Watch the ball move from one point to another. 
If you update the <em>x</em> and <em>y</em> values of each point, or change the speed, watch the results. 
You can do a lot with this very simple example.

<h4>Tracing movement: A path of points</h4>
For many of the examples in this chapter, we will create a way to trace an object’s movement on the canvas by drawing points to show its path. 
We have done this to help illustrate how objects move. 
However, in the real world, you would need to remove this functionality so that your application would perform to its potential. 

This is the only place we will discuss this code, so if you see it listed in any of the later examples in this chapter, refer back to this section to refresh your memory on its functionality.
First, we create an array in <code>canvasApp()</code> to hold the set of points we will draw on the canvas:
var points = new Array();
Next, we load a black 4×4 pixel image, <em>point.png</em>, that we will use to display the points on the canvas:

var pointImage = new Image();
pointImage.src = "point.png";
Whenever we calculate a point for an object we will move, we push that point into the <code>points</code> array:
points.push({x:ball.x,y:ball.y});

On each call to <code>drawScreen()</code>, we draw the set of points we have put into the <code>points</code> array. 
Remember, we have to redraw every point each time because the canvas is an immediate-mode display surface that does not retain any information about the images drawn onto it:
for (var i = 0; i&lt; points.length; i++) {
 context.drawImage(pointImage, points[i].x, points[i].y,1,1);

}
In <a href="ch05.html#a_ball_moving_from_one_point_to_another" title="Figure 5-1. 
A ball moving from one point to another along the line, with the points drawn for illustration">Figure 5-1</a>, you can see what the ball looks like when moving on a line from one point to another, and also what the <code>points</code> path looks like when it is drawn.
<h3>Note</h3>

This is the only time in this chapter where we will discuss the <code>points</code> path in depth. 
If you see the points being drawn, you will know how and why we have added that functionality. 
You should also have enough information to remove the code when necessary.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893719.png" alt="A ball moving from one point to another along the line, with the points drawn for illustration" width="500" height="500">

Figure 5-1. 
A ball moving from one point to another along the line, with the points drawn for illustration
Example 5-2</a> is the full code listing for <em>CH5EX2.html</em>.
Example 5-2. 

Moving on a simple line
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX2: Moving On A Simple Line&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() {
 if (!canvasSupport()) { return; } var pointImage = new Image();
 pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); // Create ball if (moves &gt; 0 ) { moves--; ball.x += xunits; ball.y += yunits; }
 //Draw points to illustrate path points.push({x:ball.x,y:ball.y}); for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1);
 }
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,15,0,Math.PI*2,true); context.closePath(); context.fill();
 } var speed = 5;
 var p1 = {x:20,y:250};
 var p2 = {x:480,y:250};
 var dx = p2.x - p1.x; var dy = p2.y - p1.y;
 var distance = Math.sqrt(dx*dx + dy*dy);
 var moves = distance/speed;
 var xunits = (p2.x - p1.x)/moves; var yunits = (p2.y - p1.y)/moves;
 var ball = {x:p1.x, y:p1.y};
 var points = new Array();
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Moving on a Vector</h3>
Moving between two points is handy, but sometimes you don’t have a point to move to, only a point to start from. 
In cases like this, it can be very useful to create a <code>vector</code> as a means to move your object.

A <em>vector</em> is a quantity in physics that has both magnitude and direction. 
For our purposes, the magnitude will be the <code>speed</code> of the moving object, and the direction will be an <code>angle</code> that the object will move upon.
The good news is that moving on a vector is very similar to moving between two points. 
In <code>canvasApp()</code>, we first set our <code>speed</code> (magnitude). 

This is the number of pixels the object will move on every call to <code>drawScreen()</code>. 
We will set this to <code>5</code>. 
We will also set the starting point (<code>p1</code>) for the object to <code>20</code>,<code>20</code>:
var speed = 5;

var p1 = {x:20,y:20};
Now, we will set the <code>angle</code> (direction) of movement for our object to <code>45</code> degrees. 
In mathematics, a flat, straight line usually represents the 0 angle, which means a vector with an angle of 45 degrees would be down and to the right on the canvas.
With our angle set, we now need to convert it to radians. 

Radians are a standard unit of angle measurement, and most mathematical calculations require you to convert an angle into radians before you can use it.
So why not just use radians and forget degrees altogether? Because it is much easier to understand movement in degrees when working with vectors and moving objects on a 2D surface. 
While a circle has 360 degrees, it has just about 6 radians, which are calculated counterclockwise. 
This might make perfect sense to mathematicians, but to move objects on a computer screen, angles are much easier. 

So, we will work with angles, but we still need to convert our 45-degree angle into radians. 
We do that with a standard formula: <code>radians = angle * Math.PI/ 180</code>. 
And in the code:
var angle = 45;

var radians = angle * Math.PI/ 180;
Before we can discuss how we calculate the movement of our object along our vector, we need to review a couple trigonometric concepts. 
These are <code>cosine</code> and <code>sine</code>, and both relate to the arc created by our <code>angle</code> (now converted to <code>radians</code>), if it was drawn outward from the center of the circle.

<code>cosine</code>
The angle measured counterclockwise from the x-axis (<code>x</code>)

<code>sine</code>
The vertical coordinate of the arc endpoint (<code>y</code>)

You can see how these values relate to a 45-degree angle in <a href="ch05.html#angles_on_the_canvas" title="Figure 5-2. 
Angles on the canvas">Figure 5-2</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893721.png" alt="Angles on the canvas" width="345" height="320">

Figure 5-2. 
Angles on the canvas
This might seem complicated, but there is a very simple way to think about it: cosine usually deals with the <code>x</code> value, and sine usually deals with the <code>y</code> value. 
We can use sine and cosine to help us calculate movement along our vector.

To calculate the number of pixels to move our object on each call to <code>drawScreen()</code> (<code>xunits</code> and <code>yunits</code>), we use the <code>radians</code> (direction) we calculated and <code>speed</code> (magnitude), along with the <code>Math.cos()</code> (cosine) and <code>Math.sin()</code> (sine) functions of the JavaScript <code>Math</code> object:
var xunits = Math.cos(radians) * speed;
var yunits = Math.sin(radians) * speed;
In <code>drawScreen()</code>, we simply add <code>xunits</code> and <code>yunits</code> to <code>ball.x</code> and <code>ball.y</code>. 

We don’t check to see whether <code>moves</code> has been exhausted because we are not moving to a particular point—we are simply moving along the vector, seemingly forever. 
In the next section, we will explore what we can do if we want the moving object to change direction when it hits something such as a wall:
ball.x += xunits;
ball.y += yunits;

<a href="ch05.html#moving_an_object_on_a_vector" title="Figure 5-3. 
Moving an object on a vector">Figure 5-3</a> shows what Example 5-3</a> looks like when it is executed in a web browser. 
Recall that the points are drawn for illustration only.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893723.png" alt="Moving an object on a vector" width="500" height="500">

Figure 5-3. 
Moving an object on a vector
Example 5-3</a> gives the full code listing.
Example 5-3. 

Moving on a vector
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX3: Moving On A Vector&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() {
 if (!canvasSupport()) { return; } var pointImage = new Image();
 pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); ball.x += xunits; ball.y += yunits;
 //Draw points to illustrate path points.push({x:ball.x,y:ball.y});
 for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1); } context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,15,0,Math.PI*2,true); context.closePath(); context.fill();
 }
 var speed = 5;
 var p1 = {x:20,y:20}; var angle = 45;
 var radians = angle * Math.PI/ 180;
 var xunits = Math.cos(radians) * speed;
 var yunits = Math.sin(radians) * speed; var ball = {x:p1.x, y:p1.y};
 var points = new Array();
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d"); setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h2>Bouncing Off Walls</h2>
While it’s neat that we can create a vector with magnitude and direction and then move an object along it infinitely, it’s probably not something you will need to do all that often. 
Most of the time, you will want to see that object react to the world around it by bouncing off horizontal and vertical walls, for example.
To help you understand how to do this, there is a simple rule in physics. 

Although this rule is usually applied to rays of light, it can be very useful when animating 2D objects—especially when they are bouncing off horizontal and vertical walls. 
This rule is known as <em>the angle of reflection</em>:
<blockquote>
The angle of incidence is equal to the angle of reflection.

</blockquote>
The <em>angle of incidence</em> is the angle an object is traveling when it hits the walls, and the <em>angle of reflection</em> is the angle it travels after it bounces off the wall.
<a href="ch05.html#angle_of_incidence_is_equal_to_the_angle" title="Figure 5-4. 
Angle of incidence is equal to the angle of reflection">Figure 5-4</a> illustrates that when an object hits a wall on a line that forms a 45-degree angle with a perpendicular line drawn to the point of impact, it will bounce off (reflect) at a similar 45-degree angle.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893725.png" alt="Angle of incidence is equal to the angle of reflection" width="291" height="304">
Figure 5-4. 
Angle of incidence is equal to the angle of reflection
In the next section, we will create a series of examples using this rule to animate objects. 

The first, Example 5-4</a>, will simply allow a single ball to bounce off the edges of the canvas.
<h3>Bouncing a Single Ball</h3>
In this first example, we will create a ball traveling on a vector. 
We will set the <code>speed</code> (magnitude) to <code>5</code> and the <code>angle</code> (direction) to <code>35</code> degrees. 

The rest of the variables are identical to those in Example 5-3</a>. 
We are still moving on a vector, but now we will test to see whether the ball hits a “wall” (the edges of the canvas), in which case it will bounce off, using the rule of the angle of reflection. 
One big change from the previous vector example is the location in which we initialize the values for <code>radians</code>, <code>xunits</code>, and <code>yunits</code>. 
Instead of setting them up when we initialize the application in <code>canvasApp()</code>, we save that for a call to a new function named <code>updateBall()</code>:

var speed = 5;
var p1 = {x:20,y:20};
var angle = 35;
var radians = 0;

var xunits = 0;
var yunits = 0;
var ball = {x:p1.x, y:p1.y};
updateBall();

The <code>updateBall()</code> function is called every time we set a new <code>angle</code> for the ball, because we need to recalculate the <code>radians</code> and find new values for <code>xunits</code> and <code>yunits</code>. 
A new <code>angle</code> is generated when the app starts, as well as every time the ball bounces off a wall:
function updateBall() {
 radians = angle * Math.PI/ 180; xunits = Math.cos(radians) * speed;
 yunits = Math.sin(radians) * speed;
}
In <code>drawScreen()</code>, we update the position of the ball, and then draw it on the canvas:

ball.x += xunits;
ball.y += yunits;
context.fillStyle = "#000000";
context.beginPath();

context.arc(ball.x,ball.y,15,0,Math.PI*2,true);
context.closePath();
context.fill();
Next, we test to see whether the ball has hit a wall before we draw it to the canvas. 

If the ball hits the right side (<code>ball.x &gt; the Canvas.width</code>) or the left side of the canvas (<code>ball.x &lt; 0</code>), we set the angle to 180 degrees minus the angle of the vector on which the ball is traveling. 
This gives us the angle of reflection. 
Alternatively, if the ball hits the top (<code>ball.y &lt; 0</code>) or bottom (<code>ball.y &gt; theCanvas.height</code>) of the canvas, we calculate the angle of reflection with 360 degrees minus the angle of the vector on which the ball is traveling:
if (ball.x &gt; theCanvas.width || ball.x &lt; 0 ) { angle = 180 - angle; updateBall(); } else if (ball.y &gt; theCanvas.height || ball.y &lt; 0) { angle = 360 - angle; updateBall(); }

That’s it. 
Example 5-4</a> demonstrates a ball that bounces off walls using the rules of physics. 
<a href="ch05.html#a_single_ball_bouncing_off_a_wall" title="Figure 5-5. 
A single ball bouncing off a wall">Figure 5-5</a> illustrates the code.

Example 5-4. 
Ball bounce
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX4: Ball Bounce&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() { if (!canvasSupport()) { return; }
 function drawScreen () { context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); ball.x += xunits; ball.y += yunits; context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,15,0,Math.PI*2,true); context.closePath(); context.fill();
 if (ball.x &gt; theCanvas.width || ball.x &lt; 0 ) { angle = 180 - angle; updateBall(); } else if (ball.y &gt; theCanvas.height || ball.y &lt; 0) { angle = 360 - angle; updateBall(); }
 } function updateBall() { radians = angle * Math.PI/ 180; xunits = Math.cos(radians) * speed; yunits = Math.sin(radians) * speed;
 }
 var speed = 5;
 var p1 = {x:20,y:20}; var angle = 35;
 var radians = 0;
 var xunits = 0;
 var yunits = 0; var ball = {x:p1.x, y:p1.y};
 updateBall();
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d"); setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893727.png" alt="A single ball bouncing off a wall" width="500" height="500">
Figure 5-5. 
A single ball bouncing off a wall
<h3>Note</h3>

The points on the line are not drawn when executed in the web browser because they slowed down the ball far too much. 
We left them in <a href="ch05.html#a_single_ball_bouncing_off_a_wall" title="Figure 5-5. 
A single ball bouncing off a wall">Figure 5-5</a> to illustrate the angles of incidence and reflection.
<h3>Multiple Balls Bouncing Off Walls</h3>

One ball is cool, but what about 100? Is the code 100 times more complicated? No, not at all. 
In fact, the code is only slightly more complicated, but it is also more refined. 
Most programming tasks that require only a single object of a type tend to allow you to be a bit lazy. 
However, when you need to build an application that must support <em><code>n</code></em> number of objects, you need to make sure the code will work in many different cases.

In the case of 100 balls bouncing on the canvas, we will need to create a ball object with a few more properties. 
Recall that the ball object we created previously had only <code>x</code> and <code>y</code> properties, and looked like this:
var ball = {x:p1.x, y:p1.y};
All the other variables that represented the ball (<code>speed</code>, <code>angle</code>, <code>xunits</code>, <code>yunits</code>) were global in scope to the <code>canvasApp()</code>. 

We used global variables because we could get away with it. 
However, because we need to make sure everything works the same way in this app, we make all those values properties of each ball object.
For the multiple-ball-bounce application, we will create an object that holds all the pertinent information about each bouncing ball: <code>x</code>, <code>y</code>, <code>speed</code>, <code>angle</code>, <code>xunits</code>, and <code>yunits</code>. 
Because we are going to create 100 balls of various sizes, we also add a property named <code>radius</code>, which represents the size of the ball (well, half the size since it <em>is</em> a radius):

tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits}
Inside <code>canvasApp()</code>, we define some new variables to help manage the multiple balls that will bounce around the canvas:
<code>numBalls</code>

The number of balls to randomly create
<code>maxSize</code>

The maximum radius length for any given ball
<code>minSize</code>

The minimum radius length for any given ball
<code>maxSpeed</code>

The maximum speed any ball can travel
<code>balls</code>

An array to hold all of the ball objects we will create

The following code shows the newly defined variables:
var numBalls = 100 ;
var maxSize = 8;
var minSize = 5;

var maxSpeed = maxSize+5;
var balls = new Array();
We also create a set of temporary variables to hold the values for each ball before we push it into the <code>balls</code> array:
var tempBall;

var tempX;
var tempY;
var tempSpeed;
var tempAngle;

var tempRadius;
var tempRadians;
var tempXunits;
var tempYunits;

Next, in <code>canvasApp()</code>, we iterate through a loop to create all the ball objects. 
Notice how <code>tempX</code> and <code>tempY</code> are created below. 
These values represent the ball’s starting location on the canvas. 
We create a random value for each, but we offset it by the size of the ball (<code>tempRadius*2</code>). 

If we did not do that, some of the balls would get “stuck” in a wall when the app starts because their <code>x</code> or <code>y</code> location would be “through” the wall, but their <code>speed</code> would not be enough so that a “bounce” would get them back on the playfield. 
They would be stuck in bouncing limbo forever (which is kind of sad when you think about it).
<h3>Note</h3>
When you try this app, you will see that occasionally a ball still gets stuck in a wall. 

There is a further optimization we need to make to prevent this, but it is a bigger subject than this little iteration. 
We will talk about it in the section Multiple Balls Bouncing and Colliding</a>.
The <code>tempSpeed</code> variable is created by subtracting the value of <code>tempRadius</code> from the value of <code>maxSpeed</code>, which we created earlier. 
The <code>speed</code> is not random, but it is inversely proportional to the size (radius) of the ball. 

A larger ball has larger radius, so the value you subtract from <code>tempSpeed</code> will be larger, thus making the ball move slower:
<h3>Note</h3>
When you run <em>CH5EX4.html</em> in your web browser, you will notice that this little trick makes the ball appear more “real” because your brain expects larger objects to move slower.
for (var i = 0; i &lt; numBalls; i++) { tempRadius = Math.floor(Math.random()*maxSize)+minSize; tempX = tempRadius*2 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*2); tempY = tempRadius*2 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*2); tempSpeed = maxSpeed-tempRadius; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempXunits = Math.cos(tempRadians) * tempSpeed; tempYunits = Math.sin(tempRadians) * tempSpeed; tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits} balls.push(tempBall);
}
Now we need to draw the balls onto the canvas. 
Inside <code>drawScreen()</code>, the code to draw the balls should look very familiar because it is essentially the same code we used for one ball in Example 5-4</a>. 

We just need to loop through the <code>balls</code> array to render each ball object:
for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.x += ball.xunits; ball.y += ball.yunits;
 context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill();
 if (ball.x &gt; theCanvas.width || ball.x &lt; 0 ) { ball.angle = 180 - ball.angle; updateBall(ball); } else if (ball.y &gt; theCanvas.height || ball.y &lt; 0) { ball.angle = 360 - ball.angle; updateBall(ball); } }

When you load Example 5-5</a> in your web browser, you will see a bunch of balls all moving around the screen independently, as shown in <a href="ch05.html#multiple_balls_of_different_sizes_bounci" title="Figure 5-6. 
Multiple balls of different sizes bouncing off walls">Figure 5-6</a>. 
For the fun of it, why not change the <code>numBalls</code> variable to 500 or 1,000? What does the canvas look like then?
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893729.png" alt="Multiple balls of different sizes bouncing off walls" width="500" height="500">

Figure 5-6. 
Multiple balls of different sizes bouncing off walls
Example 5-5. 
Multiple ball bounce

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH5EX5: Multiple Ball Bounce&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () { context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 //Place balls context.fillStyle = "#000000"; var ball;
 for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.x += ball.xunits; ball.y += ball.yunits;
 context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill(); if (ball.x &gt; theCanvas.width || ball.x &lt; 0 ) { ball.angle = 180 - ball.angle; updateBall(ball); } else if (ball.y &gt; theCanvas.height || ball.y &lt; 0) { ball.angle = 360 - ball.angle; updateBall(ball); } }
 }
 function updateBall(ball) {
 ball.radians = ball.angle * Math.PI/ 180; ball.xunits = Math.cos(ball.radians) * ball.speed; ball.yunits = Math.sin(ball.radians) * ball.speed; }
 var numBalls = 100 ;
 var maxSize = 8;
 var minSize = 5; var maxSpeed = maxSize+5;
 var balls = new Array();
 var tempBall;
 var tempX; var tempY;
 var tempSpeed;
 var tempAngle;
 var tempRadius; var tempRadians;
 var tempXunits;
 var tempYunits;
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 for (var i = 0; i &lt; numBalls; i++) { tempRadius = Math.floor(Math.random()*maxSize)+minSize; tempX = tempRadius*2 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*2); tempY = tempRadius*2 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*2); tempSpeed = maxSpeed-tempRadius; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempXunits = Math.cos(tempRadians) * tempSpeed; tempYunits = Math.sin(tempRadians) * tempSpeed;
 tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits} balls.push(tempBall);
 } setInterval(drawScreen, 33);
 }
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h3>Multiple Balls Bouncing with a Dynamically Resized Canvas</h3>
Before we move on to some more complex interaction among balls, let’s try one more thing. 
Back in <a href="ch03.html" title="Chapter 3. 
The HTML5 Canvas Text API">Chapter 3</a>, we resized the canvas with some HTML5 form controls to display text in the center of the canvas. 

Well, let’s do the same thing now with the ball example. 
This will give you a better idea of how we can make objects interact with a dynamically resizing canvas.
First, in the HTML, we create two HTML5 <code>range</code> controls, one for <code>width</code> and one for <code>height</code>, and set their maximum values to <code>1000</code>. 
We will use these controls to set the width and height of the canvas at runtime:

&lt;form&gt;
 Canvas Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt;
 &lt;br&gt;
 Canvas Height: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt; &lt;br&gt;
&lt;/form&gt;
In <code>canvasApp()</code>, we create the event listeners for the HTML5 form controls. 
We listen for the <code>change</code> event, which means any time the <code>range</code> control is moved, the event handlers will be called:

formElement = document.getElementById("canvasWidth")
formElement.addEventListener('change', canvasWidthChanged, false);
formElement = document.getElementById("canvasHeight")
formElement.addEventListener('change', canvasHeightChanged, false);

The event handler functions capture the changes to the range, set <code>theCanvas.width</code> or <code>theCanvas.height</code>, and then call <code>drawScreen()</code> to render the new size. 
Without a call to <code>drawScreen()</code> here, the canvas will blink when the new size is applied in <code>drawScreen()</code> on the next interval:
function canvasWidthChanged(e) { var target = e.target; theCanvas.width = target.value; drawScreen();
 }

function canvasHeightChanged(e) { var target = e.target; theCanvas.height = target.value; drawScreen();
}
<h3>Note</h3>
All of this is explained in gory detail in <a href="ch03.html" title="Chapter 3. 

The HTML5 Canvas Text API">Chapter 3</a>.
One last thing—let’s increase the number of balls set in <code>canvasApp()</code> to <code>500</code>:
var numBalls = 500 ;
Now, check out Example 5-6</a> (<em>CH5EX6.html</em> from the code distribution). 

When you run the code in a web browser, you should see 500 balls bounce around the canvas, as shown in <a href="ch05.html#multiple_balls_bouncing_while_the_canvas" title="Figure 5-7. 
Multiple balls bouncing while the canvas is resized on the fly">Figure 5-7</a>. 
When you increase the width or height using the <code>range</code> controls, they continue moving until they hit the new edge of the canvas. 
If you make the canvas smaller, the balls will be contained within the smaller space. 

If you adjust the size too rapidly, some balls will be lost off the canvas, but they will reappear when the canvas is resized. 
Neat, huh?
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893731.png" alt="Multiple balls bouncing while the canvas is resized on the fly" width="799" height="546">
Figure 5-7. 

Multiple balls bouncing while the canvas is resized on the fly
Example 5-6. 
Multiple ball bounce with dynamically resized canvas
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX6: Multiple Ball Bounce With Resize&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 formElement = document.getElementById("canvasWidth")
 formElement.addEventListener('change', canvasWidthChanged, false); formElement = document.getElementById("canvasHeight")
 formElement.addEventListener('change', canvasHeightChanged, false);
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); //Place balls context.fillStyle = "#000000"; var ball;
 for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.x += ball.xunits; ball.y += ball.yunits;
 context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill();
 if (ball.x &gt; theCanvas.width || ball.x &lt; 0 ) { ball.angle = 180 - ball.angle; updateBall(ball); } else if (ball.y &gt; theCanvas.height || ball.y &lt; 0) { ball.angle = 360 - ball.angle; updateBall(ball); } } }
 function updateBall(ball) {
 ball.radians = ball.angle * Math.PI/ 180; ball.xunits = Math.cos(ball.radians) * ball.speed; ball.yunits = Math.sin(ball.radians) * ball.speed;
 } var numBalls = 500 ;
 var maxSize = 8;
 var minSize = 5;
 var maxSpeed = maxSize+5; var balls = new Array();
 var tempBall;
 var tempX;
 var tempY; var tempSpeed;
 var tempAngle;
 var tempRadius;
 var tempRadians; var tempXunits;
 var tempYunits;
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d"); for (var i = 0; i &lt; numBalls; i++) { tempRadius = Math.floor(Math.random()*maxSize)+minSize; tempX = tempRadius*2 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*2); tempY = tempRadius*2 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*2); tempSpeed = maxSpeed-tempRadius; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempXunits = Math.cos(tempRadians) * tempSpeed; tempYunits = Math.sin(tempRadians) * tempSpeed;
 tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits} balls.push(tempBall);
 }
 setInterval(drawScreen, 33); function canvasWidthChanged(e) { var target = e.target; theCanvas.width = target.value; drawScreen();
 }
 function canvasHeightChanged(e) { var target = e.target; theCanvas.height = target.value; drawScreen();
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;form&gt;
 Canvas Width: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt;
 &lt;br&gt;
 Canvas Height: &lt;input type="range" min="0" max="1000" step="1" value="500"/&gt; &lt;br&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Multiple Balls Bouncing and Colliding</h3>
Now it’s time to step it up again. 
Testing balls bouncing off walls is one thing, but what about balls bouncing off one another? We will need to add some pretty intricate code to handle this type of interaction.

<h4>Ball interactions in physics</h4>
For this example, we are going to create an <em>elastic collision</em>, which means that the total kinetic energy of the objects is the same before and after the collision. 
This is known as the <em>law of conservation of momentum</em> (Newton’s third law). 
To do this, we will take the <em>x</em> and <em>y</em> velocities of two colliding balls, and draw a “line of action” between their centers. 

This is illustrated in <a href="ch05.html#two_balls_colliding_at_different_angles" title="Figure 5-8. 
Two balls colliding at different angles with a line of action drawn between them">Figure 5-8</a>, which has been adapted from Jobe Makar and Ben Winiarczyk’s <em>Macromedia’s Flash MX 2004 Game Design Demystified</em> (Macromedia Press). 
Then we will create new x and y velocities for each ball based on this angle and the law of conservation of momentum.
To properly calculate conservation of momentum when balls collide on the canvas, we need to add a new property: <code>mass</code>. 

Mass is the measurement of how much a ball (or any object) resists any change in its velocity. 
Because collisions tend to change the velocity of objects, this is an important addition to the ball objects we will use on the canvas.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893733.png" alt="Two balls colliding at different angles with a line of action drawn between them" width="340" height="372">
Figure 5-8. 

Two balls colliding at different angles with a line of action drawn between them
<h4>Making sure the balls don’t start on top of each other</h4>
We will work from the code we created for Example 5-6</a> (<em>CH5EX6.html</em>). 
The first big change to that code is to make sure the balls don’t randomly start on top of one another. 

If we let them start in the same location, they would be forever intertwined and would spin off into oblivion. 
To be honest, it looks pretty cool when that happens, but that’s not the result we are looking to achieve.
In <code>canvasApp()</code>, we set a variable named <code>tempRadius</code> to <code>5</code>. 
We will use this value as the radius for each ball we create. 

Next, we create another new variable named <code>placeOK</code> and set it to <code>false</code>. 
When this is equal to <code>true</code>, we know we have found a place to put a ball that is not on top of another ball.
Next, we enter a <code>while()</code> loop that will continue to iterate as long as <code>placeOK</code> is <code>false</code>. 
Then, we set all the values for our new ball object:

tempRadius = 5;
var placeOK = false;
while (!placeOK) {
tempX = tempRadius*3 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*3);

tempY = tempRadius*3 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*3);
tempSpeed = 4;
tempAngle = Math.floor(Math.random()*360);
tempRadians = tempAngle * Math.PI/ 180;

tempvelocityx = Math.cos(tempRadians) * tempSpeed;
tempvelocityy = Math.sin(tempRadians) * tempSpeed;
Now, we need to make a dynamic object out of the values we just created and place that object into the <code>tempBall</code> variable. 
This is where we create a <code>mass</code> property for each ball. 

Again, we do this so that we can calculate the effect when the balls hit one another. 
For all the balls in this example, the <code>mass</code> will be the same—the value of <code>tempRadius</code>. 
We do this because, in our 2D environment, the relative size of each ball is a very simple way to create a value for <code>mass</code>. 
Since the <code>mass</code> and <code>speed</code> of each ball will be the same, they will affect each other in a similar way. 

Later, we will show you what happens when we create ball objects with different <code>mass</code> values.
Finally, we create <code>nextX</code> and <code>nextY</code> properties that are equal to <code>x</code> and <code>y</code>. 
We will use these values as “look ahead” properties to help alleviate collisions that occur “between” our iterations, which lead to overlapping balls and other oddities:
tempBall = {x:tempX,y:tempY, nextX: tempX, nextY: tempY, radius:tempRadius, speed:tempSpeed, angle:tempAngle, velocityx:tempvelocityx, velocityy:tempvelocityy, mass:tempRadius};

Now that we have our new dynamic ball object represented by the <code>tempBall</code> variable, we will test to see whether it can be placed at the <code>tempX</code> and <code>tempY</code> we randomly created for it. 
We will do this with a call to a new function named <code>canStartHere()</code>. 
If <code>can</code><code>StartHere()</code> returns <code>true</code>, we drop out of the <code>while()</code> loop; if not, we start all over again:
 placeOK = canStartHere(tempBall); }

The <code>canStartHere()</code> function is very simple. 
It looks through the <code>ball</code> array, testing the new <code>tempBall</code> against all existing balls to see whether they overlap. 
If they do, the function returns <code>false</code>; if not, it returns <code>true</code>. 
To test the overlap, we have created another new function: <code>hitTestCircle()</code>:

function canStartHere(ball) { var retval = true; for (var i = 0; i &lt;balls.length; i++) { if (hitTestCircle(ball, balls[i])) { retval = false; } } return retval;
 }
<h4>Circle collision detection</h4>
The <code>hitTestCircle()</code> function performs a circle/circle collision-detection test to see whether the two circles (each representing a ball) passed as parameters to the function are touching. 

Because we have been tracking the balls by the center <code>x</code> and <code>y</code> of their location, this is quite easy to calculate. 
First, the function finds the distance of the line that connects the center of each circle. 
We do this using our old friend the Pythagorean theorem (A<sup>2</sup>+B<sup>2</sup> = C<sup>2</sup>). 
We use the <code>nextx</code> and <code>nexty</code> properties of the ball because we want to test the collision before it occurs. 

(Again, if we test after by using the current <code>x</code> and <code>y</code> locations, there is a good chance the balls will get stuck together and spin out of control.) We then compare that <code>distance</code> value to the sum of the radius of each ball. 
If the distance is less than or equal to the sum of the radii, we have a collision. 
This is a very simple and efficient way to test collisions, and it works especially well with collisions among balls in 2D:
function hitTestCircle(ball1,ball2) { var retval = false;
 var dx = ball1.nextx - ball2.nextx;
 var dy = ball1.nexty - ball2.nexty;
 var distance = (dx * dx + dy * dy); if (distance &lt;= (ball1.radius + ball2.radius) * (ball1.radius + ball2.radius) ) { retval = true; }
 return retval;
}
<a href="ch05.html#balls_colliding" title="Figure 5-9. 

Balls colliding">Figure 5-9</a> illustrates this code.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893735.png" alt="Balls colliding" width="346" height="329">
Figure 5-9. 
Balls colliding

<h4>Separating the code in drawScreen()</h4>
The next thing we want to do is simplify <code>drawScreen()</code> by separating the code into controllable functions. 
The idea here is that to test collisions correctly, we need to make sure some of our calculations are done in a particular order. 
We like to call this an <em>update-collide-render cycle</em>.

<code>update()</code>
Sets the <code>nextx</code> and <code>nexty</code> properties of all the balls in the <code>balls</code> array.

<code>testWalls()</code>
Tests to see whether the balls have hit one of the walls.

<code>collide()</code>
Tests collisions among balls. 

If the balls collide, updates <code>nextx</code> and <code>nexty</code>.
<code>render()</code>

Makes the <code>x</code> and <code>y</code> properties for each ball equal to <code>nextx</code> and <code>nexty</code> respectively, and then draws them to the canvas.
And here is the code:

function drawScreen () {
 update();
 testWalls();
 collide(); render();
 }
<h4>Updating positions of objects</h4>
The <code>update()</code> function loops through all the balls in the <code>balls</code> array, and updates the <code>nextx</code> and <code>nexty</code> properties with the <code>x</code> and <code>y</code> velocity for each ball. 

We don’t directly update <code>x</code> and <code>y</code> here, because we want to test collisions against walls and other balls before they occur. 
We will use the <code>nextx</code> and <code>nexty</code> properties for this purpose:
function update() { for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.nextx = (ball.x += ball.velocityx); ball.nexty = (ball.y += ball.velocityy); }
}

<h4>Better interaction with the walls</h4>
We discussed the interactions between balls and walls in the last example, but there is still one issue. 
Since we move the balls by the <code>x</code> and <code>y</code> location of their center, the balls would move halfway off the canvas before a bounce occurred. 
To fix this, we add or subtract the <code>radius</code> of the <code>ball</code> object, depending on which walls we are testing. 

For the right side and bottom of the canvas, we add the radius of the ball when we test the walls. 
In this way, the ball will appear to bounce exactly when its edge hits a wall. 
Similarly, we subtract the radius when we test the left side and the top of the canvas, so that the ball does not move off the side before we make it bounce off a wall:
function testWalls() { var ball; var testBall; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i];
 if (ball.nextx+ball.radius &gt; theCanvas.width) { ball.velocityx = ball.velocityx*,1; ball.nextx = theCanvas.width - ball.radius;
 } else if (ball.nextx-ball.radius &lt; 0 ) { ball.velocityx = ball.velocityx*,1; ball.nextx = ball.radius;
 } else if (ball.nexty+ball.radius &gt; theCanvas.height ) { ball.velocityy = ball.velocityy*,1; ball.nexty = theCanvas.height - ball.radius; } else if(ball.nexty-ball.radius &lt; 0) { ball.velocityy = ball.velocityy*,1; ball.nexty = ball.radius; }
 }
 }
<h4>Collisions with balls</h4>

The <code>collide()</code> function tests to see whether any balls have hit one another. 
This function uses two nested loops, both iterating through the <code>balls</code> array to ensure we test each ball against every other ball. 
We take the ball from the first loop of the <code>balls</code> array, and place it into the <code>ball</code> variable. 
Then we loop through <code>balls</code> again, placing each ball in the <code>testBall</code> variable, one at a time. 

When we have both <code>ball</code> and <code>testBall</code>, we make sure they are not equal to one another. 
We do this because a ball will always have a false positive collision if we test it against itself. 
When we are sure they are not the same ball, we call <code>hitTestCircle()</code> to test for a collision. 
If we find one, we call <code>collideBalls()</code>, and then all hell breaks loose. 

(OK, not really, but the balls do collide, and some really interesting code gets executed.) See that code here: 
function collide() { var ball; var testBall; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; for (var j = i+1; j &lt; balls.length; j++) { testBall = balls[j]; if (hitTestCircle(ball,testBall)) { collideBalls(ball,testBall); } } } }
<h4>Ball collisions in depth</h4>
So now we get to the most interesting code of this example. 

We are going to update the properties of each ball so they appear to bounce off one another. 
Recall that we use the <code>nextx</code> and <code>nexty</code> properties because we want to make sure to test where the balls will be after they are drawn—not where they are right now. 
This helps keep the balls from overlapping in a way that will make them stick together.
<h3>Note</h3>

Sometimes the balls will still stick together. 
This is a common problem when creating collisions among balls. 
This happens when balls overlap one another before the collision test, and the reaction bounce is not enough to split them apart completely. 
We have made every attempt to optimize this function for the canvas, but we are sure further optimizations are possible.

The <code>collideBalls()</code> function takes two parameters: <code>ball1</code> and <code>ball2</code>. 
Both parameters are the <code>ball</code> objects that we want to make collide:
function collideBalls(ball1,ball2) {
First, we need to calculate the difference between the center points of each ball. 

We store this as <code>dx</code> and <code>dy</code> (difference x and difference y). 
This should look familiar because we did something similar when we tested for a collision between the balls. 
The difference is that now we know they have collided, and we want to know how that collision occurred:
var dx = ball1.nextx - ball2.nextx;

var dy = ball1.nexty - ball2.nexty;
To do this, we need to find the angle of the collision using the <code>Math.atan2()</code> function. 
This function gives us the angle in radians of the collisions between the two balls. 
This is the line of action or angle of collision. 

We need this value so that we can determine how the balls will react when they collide:
var collisionAngle = Math.atan2(dy, dx);
Next, we calculate the velocity vector for each ball given the <code>x</code> and <code>y</code> velocities that existed before the collision occurred:
var speed1 = Math.sqrt(ball1.velocityx * ball1.velocityx + ball1.velocityy * ball1.velocityy);

var speed2 = Math.sqrt(ball2.velocityx * ball2.velocityx + ball2.velocityy * ball2.velocityy);
Then, we calculate angles (in radians) for each ball given its current velocities:
var direction1 = Math.atan2(ball1.velocityy, ball1.velocityx);
var direction2 = Math.atan2(ball2.velocityy, ball2.velocityx);

Next, we need to rotate the vectors counterclockwise so that we can plug those values into the equation for conservation of momentum. 
Basically, we are taking the angle of collision and making it flat so we can bounce the balls, similar to how we bounced balls off the sides of the canvas:
var velocityx_1 = speed1 * Math.cos(direction1 - collisionAngle);
var velocityy_1 = speed1 * Math.sin(direction1 - collisionAngle);

var velocityx_2 = speed2 * Math.cos(direction2 - collisionAngle);
var velocityy_2 = speed2 * Math.sin(direction2 - collisionAngle);
We take the <code>mass</code> values of each ball and update their <code>x</code> and <code>y</code> velocities based on the law of conservation of momentum. 
To find the final velocity for both balls, we use the following formulas:

velocity1 = ((mass1 - mass2) * velocity1 + 2*mass2 * velocity2) / mass1 + mass2
velocity2 = ((mass2 - mass1) * velocity2 + 2*mass1 * velocity1)/ mass1+ mass2
Actually, only the <code>x</code> velocity needs to be updated; the <code>y</code> velocity remains constant:
var final_velocityx_1 = ((ball1.mass - ball2.mass) * velocityx_1 + (ball2.mass + ball2.mass) * velocityx_2)/(ball1.mass + ball2.mass);

var final_velocityx_2 = ((ball1.mass + ball1.mass) * velocityx_1 + (ball2.mass - ball1.mass) * velocityx_2)/(ball1.mass + ball2.mass);
var final_velocityy_1 = velocityy_1;
var final_velocityy_2 = velocityy_2
After we have our final velocities, we rotate our angles back again so that the collision angle is preserved:

ball1.velocityx = Math.cos(collisionAngle) * final_velocityx_1 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_1;
ball1.velocityy = Math.sin(collisionAngle) * final_velocityx_1 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_1;
ball2.velocityx = Math.cos(collisionAngle) * final_velocityx_2 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_2;
ball2.velocityy = Math.sin(collisionAngle) * final_velocityx_2 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_2;

Now, we update <code>nextx</code> and <code>nexty</code> for both balls so can use those values in the <code>render()</code> function—or, for another collision:
 ball1.nextx = (ball1.nextx += ball1.velocityx);
 ball1.nexty = (ball1.nexty += ball1.velocityy);
 ball2.nextx = (ball2.nextx += ball2.velocityx); ball2.nexty = (ball2.nexty += ball2.velocityy);
}
<h3>Note</h3>
If this is confusing to you, you are not alone. 

It took some serious effort for us to translate this code from other sources into a working example on HTML5 Canvas. 
The code here is based on “<em>Flash Lite Effort - Embedded Systems and Pervasive Computing Lab</em>” by Felipe Sampaio, available here: <a href="http://wiki.forum.nokia.com/index.php/Collision_for_Balls">http://wiki.forum.nokia.com/index.php/Collision_for_Balls</a>. 
It is also partly based on Jobe Makar and Ben Winiarczyk’s work in <em>Macromedia Flash MX 2004 Game Design Demystified</em>, and Keith Peters’ books on ActionScript animation.
Here is the full code listing for Example 5-7</a>.

Example 5-7. 
Balls with simple interactions
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX7: Balls With Simple Interactions&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() { if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 update(); testWalls(); collide(); render(); }
 function update() { for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.nextx = (ball.x += ball.velocityx); ball.nexty = (ball.y += ball.velocityy); }
 }
 function testWalls() { var ball; var testBall; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i];
 if (ball.nextx+ball.radius &gt; theCanvas.width) { ball.velocityx = ball.velocityx*,1; ball.nextx = theCanvas.width - ball.radius;
 } else if (ball.nextx-ball.radius &lt; 0 ) { ball.velocityx = ball.velocityx*,1; ball.nextx =ball.radius;
 } else if (ball.nexty+ball.radius &gt; theCanvas.height ) { ball.velocityy = ball.velocityy*,1; ball.nexty = theCanvas.height , ball.radius; } else if(ball.nexty-ball.radius &lt; 0) { ball.velocityy = ball.velocityy*,1; ball.nexty = ball.radius; }
 }
 }
 function render() { var ball; context.fillStyle = "#000000"; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.x = ball.nextx; ball.y = ball.nexty; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill(); }
 }
 function collide() { var ball; var testBall; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; for (var j = i+1; j &lt; balls.length; j++) { testBall = balls[j]; if (hitTestCircle(ball,testBall)) { collideBalls(ball,testBall); } } } }
 function hitTestCircle(ball1,ball2) { var retval = false; var dx = ball1.nextx - ball2.nextx; var dy = ball1.nexty - ball2.nexty; var distance = (dx * dx + dy * dy); if (distance &lt;= (ball1.radius + ball2.radius) * (ball1.radius + ball2.radius) ) { retval = true; } return retval; } function collideBalls(ball1,ball2) {
 var dx = ball1.nextx - ball2.nextx; var dy = ball1.nexty - ball2.nexty;
 var collisionAngle = Math.atan2(dy, dx);
 var speed1 = Math.sqrt(ball1.velocityx * ball1.velocityx + ball1.velocityy * ball1.velocityy); var speed2 = Math.sqrt(ball2.velocityx * ball2.velocityx + ball2.velocityy * ball2.velocityy); var direction1 = Math.atan2(ball1.velocityy, ball1.velocityx); var direction2 = Math.atan2(ball2.velocityy, ball2.velocityx);
 var velocityx_1 = speed1 * Math.cos(direction1 - collisionAngle); var velocityy_1 = speed1 * Math.sin(direction1 - collisionAngle); var velocityx_2 = speed2 * Math.cos(direction2 - collisionAngle); var velocityy_2 = speed2 * Math.sin(direction2 - collisionAngle);
 var final_velocityx_1 = ((ball1.mass - ball2.mass) * velocityx_1 + (ball2.mass + ball2.mass) * velocityx_2)/(ball1.mass + ball2.mass); var final_velocityx_2 = ((ball1.mass + ball1.mass) * velocityx_1 + (ball2.mass - ball1.mass) * velocityx_2)/(ball1.mass + ball2.mass);
 var final_velocityy_1 = velocityy_1; var final_velocityy_2 = velocityy_2; ball1.velocityx = Math.cos(collisionAngle) * final_velocityx_1 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_1; ball1.velocityy = Math.sin(collisionAngle) * final_velocityx_1 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_1; ball2.velocityx = Math.cos(collisionAngle) * final_velocityx_2 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_2; ball2.velocityy = Math.sin(collisionAngle) * final_velocityx_2 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_2;
 ball1.nextx = (ball1.nextx += ball1.velocityx); ball1.nexty = (ball1.nexty += ball1.velocityy); ball2.nextx = (ball2.nextx += ball2.velocityx); ball2.nexty = (ball2.nexty += ball2.velocityy);
 }
 var numBalls = 200 ; var maxSize = 15;
 var minSize = 5;
 var maxSpeed = maxSize+5;
 var balls = new Array(); var tempBall;
 var tempX;
 var tempY;
 var tempSpeed; var tempAngle;
 var tempRadius;
 var tempRadians;
 var tempvelocityx; var tempvelocityy;
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 for (var i = 0; i &lt; numBalls; i++) { tempRadius = 5; var placeOK = false; while (!placeOK) { tempX = tempRadius*3 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*3); tempY = tempRadius*3 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*3); tempSpeed = 4; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempvelocityx = Math.cos(tempRadians) * tempSpeed; tempvelocityy = Math.sin(tempRadians) * tempSpeed; tempBall = {x:tempX,y:tempY, nextX: tempX, nextY: tempY, radius:tempRadius, speed:tempSpeed, angle:tempAngle, velocityx:tempvelocityx, velocityy:tempvelocityy, mass:tempRadius}; placeOK = canStartHere(tempBall); } balls.push(tempBall);
 }
 function canStartHere(ball) { var retval = true; for (var i = 0; i &lt;balls.length; i++) { if (hitTestCircle(ball, balls[i])) { retval = false; } } return retval;
 } setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

Now, when you execute Example 5-7</a> (<em>CH5EX7.html</em>), you will see a bunch of balls of the same size and mass bumping off of each other and the walls of the canvas, as shown in <a href="ch05.html#balls_of_the_same_size_bouncing_off_one" title="Figure 5-10. 
Balls of the same size bouncing off one another">Figure 5-10</a>. 
When you look at this demo, imagine all the ways you could modify it to do different things. 
You could create balls with different masses and different speeds, or even create balls that don’t move but simply alter the direction of other balls that hit them. 

In Example 5-8</a>, we will take a slightly different look at this same code and add some new properties to make it more interesting.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893737.png" alt="Balls of the same size bouncing off one another" width="500" height="500">
Figure 5-10. 
Balls of the same size bouncing off one another

<h3>Multiple Balls Bouncing with Friction</h3>
If we want the balls to slow down and eventually stop, we need to add friction to Example 5-7</a>. 
For our purposes, simple friction is a value we use to modify the velocity of our objects every time they are drawn to the canvas.
In <code>canvasApp()</code>, we now want to create balls of various sizes. 

In the previous example, the balls were all the same size. 
It worked, but having balls of different sizes with different masses will create more interesting effects. 
To do this, we set <code>minSize</code> to <code>3</code> and <code>maxSize</code> to <code>12</code>, meaning the radii for our balls will range from <code>3</code> to <code>12</code> pixels. 
We also add a new property named <code>friction</code>. 

This is a global property, so it will not be applied to each individual ball. 
We set it to <code>.01</code>, which means our balls will degrade their <code>x</code> and <code>y</code> velocities by <code>.01</code> pixels per frame (every time <code>drawScreen()</code> is called):
var numBalls = 50 ;
var maxSize = 12;

var minSize = 3;
var maxSpeed = maxSize+5;
var friction = .01;
We will now allow for various ball sizes. 

The mass of each ball will be different, and balls will have different effects on one another depending on their sizes. 
Recall that in Example 5-7</a> we needed a <code>mass</code> property so we could calculate conservation of momentum when the balls collided. 
We are doing the same thing here, but now the masses are different depending on the size:
for (var i = 0; i &lt; numBalls; i++) { tempRadius = Math.floor(Math.random()*maxSize)+minSize;
In <code>update()</code>, we apply the <code>friction</code> value by calculating the product of the current velocity multiplied by friction, and then subtracting that value from the current velocity. 
We do this for both the <code>x</code> and <code>y</code> velocities. 
Why must we do this instead of simply subtracting the friction value from the <code>x</code> and <code>y</code> velocities? Because the <code>x</code> and <code>y</code> velocities are not always proportional to each other. 

If we simply subtract the friction, we may alter the velocity unintentionally. 
Instead, we need to subtract a value for the friction that is proportional to the velocity itself, and that value is the product of the velocity multiplied by the <code>friction</code> value. 
This method will give you a smooth degradation of the velocity when the <code>friction</code> value is applied:
function update() { for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; //Friction ball.velocityx = ball.velocityx - ( ball.velocityx*friction); ball.velocityy = ball.velocityy - ( ball.velocityy*friction); ball.nextx = (ball.x += ball.velocityx); ball.nexty = (ball.y += ball.velocityy); }
 }
You can see the full version of this code by executing <em>CH5EX8.html</em> from the code distribution, or by typing in Example 5-8</a>. 
You should notice that the smaller balls have less of an effect on the larger balls when they collide, and vice versa. 

Also, the balls slow down as they move due to the applied friction.
Example 5-8. 
Balls with friction
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX8: Balls With Friction&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); update(); testWalls(); collide(); render();
 }
 function update() { for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; //Friction ball.velocityx = ball.velocityx - ( ball.velocityx*friction); ball.velocityy = ball.velocityy - ( ball.velocityy*friction);
 ball.nextx = (ball.x += ball.velocityx); ball.nexty = (ball.y += ball.velocityy); } }
 function testWalls() { var ball; var testBall;
 for (var i = 0; i &lt;balls.length; i++) { ball = balls[i];
 if (ball.nextx+ball.radius &gt; theCanvas.width) { ball.velocityx = ball.velocityx*,1; ball.nextx = theCanvas.width - ball.radius; } else if (ball.nextx-ball.radius &lt; 0 ) { ball.velocityx = ball.velocityx*,1; ball.nextx = ball.radius;
 } else if (ball.nexty+ball.radius &gt; theCanvas.height ) { ball.velocityy = ball.velocityy*,1; ball.nexty = theCanvas.height , ball.radius;
 } else if(ball.nexty-ball.radius &lt; 0) { ball.velocityy = ball.velocityy*,1; ball.nexty = ball.radius; }
 } }
 function render() { var ball;
 context.fillStyle = "#000000"; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; ball.x = ball.nextx; ball.y = ball.nexty;
 context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill(); } }
 function collide() { var ball; var testBall; for (var i = 0; i &lt;balls.length; i++) { ball = balls[i]; for (var j = i+1; j &lt; balls.length; j++) { testBall = balls[j]; if (hitTestCircle(ball,testBall)) { collideBalls(ball,testBall); } } } }
 function hitTestCircle(ball1,ball2) { var retval = false; var dx = ball1.nextx - ball2.nextx; var dy = ball1.nexty - ball2.nexty; var distance = (dx * dx + dy * dy); if (distance &lt;= (ball1.radius + ball2.radius) * (ball1.radius + ball2.radius) ) { retval = true; } return retval; }
 function collideBalls(ball1,ball2) { var dx = ball1.nextx - ball2.nextx; var dy = ball1.nexty - ball2.nexty;
 var collisionAngle = Math.atan2(dy, dx);
 var speed1 = Math.sqrt(ball1.velocityx * ball1.velocityx + ball1.velocityy * ball1.velocityy); var speed2 = Math.sqrt(ball2.velocityx * ball2.velocityx + ball2.velocityy * ball2.velocityy);
 var direction1 = Math.atan2(ball1.velocityy, ball1.velocityx); var direction2 = Math.atan2(ball2.velocityy, ball2.velocityx); var velocityx_1 = speed1 * Math.cos(direction1 - collisionAngle); var velocityy_1 = speed1 * Math.sin(direction1 - collisionAngle); var velocityx_2 = speed2 * Math.cos(direction2 - collisionAngle); var velocityy_2 = speed2 * Math.sin(direction2 - collisionAngle);
 var final_velocityx_1 = ((ball1.mass - ball2.mass) * velocityx_1 + (ball2.mass + ball2.mass) * velocityx_2)/(ball1.mass + ball2.mass); var final_velocityx_2 = ((ball1.mass + ball1.mass) * velocityx_1 + (ball2.mass - ball1.mass) * velocityx_2)/(ball1.mass + ball2.mass);
 var final_velocityy_1 = velocityy_1; var final_velocityy_2 = velocityy_2;
 ball1.velocityx = Math.cos(collisionAngle) * final_velocityx_1 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_1; ball1.velocityy = Math.sin(collisionAngle) * final_velocityx_1 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_1; ball2.velocityx = Math.cos(collisionAngle) * final_velocityx_2 + Math.cos(collisionAngle + Math.PI/2) * final_velocityy_2; ball2.velocityy = Math.sin(collisionAngle) * final_velocityx_2 + Math.sin(collisionAngle + Math.PI/2) * final_velocityy_2; ball1.nextx = (ball1.nextx += ball1.velocityx); ball1.nexty = (ball1.nexty += ball1.velocityy); ball2.nextx = (ball2.nextx += ball2.velocityx); ball2.nexty = (ball2.nexty += ball2.velocityy);
 }
 var numBalls = 50 ;
 var maxSize = 12; var minSize = 3;
 var maxSpeed = maxSize+5;
 var balls = new Array();
 var tempBall; var tempX;
 var tempY;
 var tempSpeed;
 var tempAngle; var tempRadius;
 var tempRadians;
 var tempvelocityx;
 var tempvelocityy; var friction = .01;
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 for (var i = 0; i &lt; numBalls; i++) { tempRadius = Math.floor(Math.random()*maxSize)+minSize; var placeOK = false; while (!placeOK) { tempX = tempRadius*3 + (Math.floor(Math.random()*theCanvas.width)-tempRadius*3); tempY = tempRadius*3 + (Math.floor(Math.random()*theCanvas.height)-tempRadius*3); tempSpeed = maxSpeed-tempRadius; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempvelocityx = Math.cos(tempRadians) * tempSpeed; tempvelocityy = Math.sin(tempRadians) * tempSpeed; tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, velocityx:tempvelocityx, velocityy:tempvelocityy, mass:tempRadius*8, nextx: tempX, nexty:tempY}; placeOK = canStartHere(tempBall); } balls.push(tempBall);
 }
 function canStartHere(ball) { var retval = true; for (var i = 0; i &lt;balls.length; i++) { if (hitTestCircle(ball, balls[i])) { retval = false; } } return retval;
 } setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<a href="ch05.html#multiple_balls_of_different_sizes_bo" title="Figure 5-11. 
Multiple balls of different sizes bouncing off one another with friction applied">Figure 5-11</a> illustrates how this code will look in the browser.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893739.png" alt="Multiple balls of different sizes bouncing off one another with friction applied" width="500" height="500">
Figure 5-11. 

Multiple balls of different sizes bouncing off one another with friction applied
<h2>Curve and Circular Movement</h2>
Whew! Moving and colliding balls on vectors can create some cool effects. 
However, moving in straight lines is not the only way you might want to move objects. 

In this section, we will show you some ways to animate objects using circles, spirals, and curves.
<h3>Uniform Circular Motion</h3>
Uniform circular motion occurs when we move an object along the distinct radius of a defined circle. 
Once we know the radius, we can use our old friends <code>cosine</code> and <code>sine</code> to find the <code>x</code> and <code>y</code> locations of the moving object. 

The equations to find the locations of an object moving uniformly on a defined circle are:
x = radius * cosine(angle)
y = radius * sine(angle)
We will create an example of uniform circular movement with a circle that has a radius of <code>125</code>, with its center position at <code>250</code>,<code>250</code> on the canvas. 

We will move a ball along that circle, starting at an <code>angle</code> of <code>0</code>.
In <code>canvasApp()</code>, we will define this circle path as a dynamic object stored in the <code>circle</code> variable. 
While this object defines the properties of a circle, we will not actually draw this circle on the canvas; rather, it defines only the path on which we will move our <code>ball</code> object:
var circle = {centerX:250, centerY:250, radius:125, angle:0}

var ball = {x:0, y:0,speed:.1};
In <code>drawScreen()</code>, we will incorporate the equations for uniform circular movement. 
To do this, we will set the <code>x</code> and <code>y</code> properties of the <code>ball</code> object to the products of the equations, added to the center location of the circle path on the canvas (<code>circle</code><code>.centerX</code>, <code>circle.centerY</code>):
ball.x = circle.centerX + Math.cos(circle.angle) * circle.radius;

ball.y = circle.centerY + Math.sin(circle.angle) * circle.radius;
We then add the speed of the ball to the angle of the circle path. 
This effectively sets the ball to move to a new location the next time <code>drawScreen()</code> is called:
circle.angle += ball.speed;

Finally, we draw the ball onto the canvas:
context.fillStyle = "#000000";
context.beginPath();
context.arc(ball.x,ball.y,15,0,Math.PI*2,true);

context.closePath();
context.fill();
You can see what the circle path looks like in <a href="ch05.html#moving_an_object_in_a_circle" title="Figure 5-12. 
Moving an object in a circle">Figure 5-12</a>. 

We have drawn the points on the canvas to illustrate the circle path.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893741.png" alt="Moving an object in a circle" width="500" height="500">
Figure 5-12. 
Moving an object in a circle

You can easily alter the location and size of the circle path by altering the <code>radius</code>, <code>centerX</code>, and <code>centerY</code> properties of the circle path object.
Example 5-9</a> shows the code for <em>CH5EX9.html</em>.
Example 5-9. 
Moving in a circle

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH5EX9: Moving In A Circle&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () { context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 ball.x = circle.centerX + Math.cos(circle.angle) * circle.radius; ball.y = circle.centerY + Math.sin(circle.angle) * circle.radius;
 circle.angle += ball.speed;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,15,0,Math.PI*2,true); context.closePath(); context.fill(); }
 var radius = 100;
 var circle = {centerX:250, centerY:250, radius:125, angle:0}
 var ball = {x:0, y:0,speed:.1}; theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Moving in a Simple Spiral</h3>
There are many complicated ways to move an object on a spiral path. 

One such way would be to use the Fibonacci sequence, which describes a pattern seen in nature that appears to create perfect spirals. 
The Fibonacci sequence starts with the number 0, and continues with each subsequent number calculated as the sum of the two previous numbers in the sequence. 
Each subsequent rotation of the spiral is the sum of the two previous numbers (1, 2, 3, 5, 8, 13, 21, 34, 55, 89...). 
However, as you might imagine, the math used to create this sequence is quite involved, and it is also difficult to translate to object movement.

For our purposes, we can create a simple spiral by increasing the radius of the circle path on each call to <code>drawScreen()</code>. 
If we take the code from Example 5-9</a>, we would add a <code>radiusInc</code> variable, which we will use as the value to add the radius movement path of the circle. 
We create this new variable in <code>canvasApp()</code>:
var radiusInc = 2;

Then, in <code>drawScreen()</code>, we add the following code to increase the radius of the circle every time we move the object:
circle.radius += radiusInc;
In <a href="ch05.html#moving_an_object_in_a_simple_spiral_patt" title="Figure 5-13. 
Moving an object in a simple spiral pattern">Figure 5-13</a>, you can see what the resulting spiral looks like (to illustrate the path, this example includes the points).

If you want a tighter spiral, decrease the value of <code>radiusInc</code>. 
Conversely, if you want a wider spiral, increase the value of <code>radiusInc</code>.
Example 5-10</a> shows the code for <em>CH5EX10.html</em> from the code distribution.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893743.png" alt="Moving an object in a simple spiral pattern" width="500" height="500">

Figure 5-13. 
Moving an object in a simple spiral pattern
Example 5-10. 
Moving in a simple geometric spiral

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH5EX10: Moving In A Simple Geometric Spiral &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 var pointImage = new Image(); pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 ball.x = circle.centerX + Math.cos(circle.angle) * circle.radius; ball.y = circle.centerY + Math.sin(circle.angle) * circle.radius; circle.angle += ball.speed; circle.radius += radiusInc; //Draw points to illustrate path points.push({x:ball.x,y:ball.y});
 for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1); }
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,15,0,Math.PI*2,true); context.closePath(); context.fill(); }
 var radiusInc = 2;
 var circle = {centerX:250, centerY:250, radius:2, angle:0, radiusInc:2}
 var ball = {x:0, y:0,speed:.1}; var points = new Array();
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h3>Cubic Bezier Curve Movement</h3>

Cubic Bezier curves can be used to define a movement path for an object. 
Pierre Bezier first popularized these curves in the 1960s. 
They are widely used in 2D vector graphics to define smooth curves for drawing, but they can also be used in animation to define a path for motion.
A cubic Bezier curve is created using four distinct points—<code>p0</code>, <code>p1</code>, <code>p2</code>, and <code>p3</code>:

<code>p0</code>
The starting point of the curve. 

We will refer to these <code>x</code> and <code>y</code> values as <code>x0</code> and <code>y0</code>.
<code>p3</code>

The ending point of the curve. 
We will refer to these <code>x</code> and <code>y</code> values as <code>x3</code> and <code>y3</code>.
<code>p1</code> and <code>p2</code>

The control points for the curve. 
The curve <em>does not pass through</em> these points; instead, the equation uses these points to determine the arc of the curve. 
We will refer to these <code>x</code> and <code>y</code> values as <code>x0</code>, <code>x1</code>, <code>x2</code>, <code>x3</code>, <code>y0</code>, <code>y1</code>, <code>y2</code>, and <code>y3</code>.

<h3>Note</h3>
The usage of the <code>p1</code> and <code>p2</code> points is the biggest stumbling block for understanding Bezier curves. 

The easiest way to understand the relationship between these points and the curve is to draw them on a bitmapped canvas, which we will do several times in this chapter.
After you have the four points, you need to calculate six coefficient values that you will use to find the <code>x</code> and <code>y</code> locations as you move an object on the curve. 
These coefficients are known as <code>ax</code>, <code>bx</code>, <code>cx</code>, <code>ay</code>, <code>by</code>, and <code>cy</code>. 
They are calculated as follows:

cx = 3 (x1 - x0)
bx = 3 (x2 - x1) - cx
ax = x3 - x0 - cx - bx
cy = 3 (y1 - y0)

by = 3 (y2 - y1) - cy
ay = y3 - y0 - cy - by
After you’ve calculated the six coefficients, you can find the <code>x</code> and <code>y</code> locations based on the changing <code>t</code> value using the following equations. 
The <code>t</code> value represents movement over time:

x(t) = axt3 + bxt2 + cxt + x0
y(t) = ayt3 + byt2 + cyt + y0
For our purposes, the <code>t</code> value will be increased by the <code>speed</code> at which we want the object to move. 
You will notice, though, that this value does not easily equate to the <code>speed</code> values we used elsewhere in this chapter. 

The reason is that the <code>t</code> value was not created with movement over time for animation in mind. 
The speed we specify must be smaller than <code>1</code> so the movement on the curve will be incremental enough for us to see it as part of the animation. 
For our example, we will increase <code>t</code> by a speed of <code>.01</code>, so that we will see <code>100</code> points on the movement curve (1/100 = .01). 
This is advantageous because we will know our object has finished moving when the <code>t</code> value is equal to <code>1</code>.

For Example 5-11</a> (<em>CH5EX11.html</em>), we will start by creating the four points of the Bezier curve in the <code>canvasApp()</code> function:
var p0 = {x:60, y:10};
var p1 = {x:70, y:200};
var p2 = {x:125, y:295};

var p3 = {x:350, y:350};
We then create a new <code>ball</code> object with a couple differing properties from those in the other examples in this chapter. 
The <code>speed</code> is <code>.01</code>, which means the object will move 100 points along the curve before it is finished. 
We start the <code>t</code> value at <code>0</code>, which means the <code>ball</code> will begin at <code>p0</code>:

var ball = {x:0, y:0, speed:.01, t:0};
Next, in the <code>drawScreen()</code> function, we calculate the Bezier curve coefficient values (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>ay</code>, <code>by</code>, <code>cy</code>) based on the four points (<code>p0</code>, <code>p1</code>, <code>p2</code>, <code>p3</code>):
var cx = 3 * (p1.x - p0.x)
var bx = 3 * (p2.x - p1.x) - cx;

var ax = p3.x - p0.x - cx - bx;
var cy = 3 * (p1.y - p0.y);
var by = 3 * (p2.y - p1.y) - cy;
var ay = p3.y - p0.y - cy - by;

Then, we take our <code>t</code> value and use it with the coefficients to calculate the <code>x</code> and <code>y</code> values for the moving object. 
First, we get the <code>t</code> value from the <code>ball</code> object, and store it locally so we can use it in our calculations:
var t = ball.t;
Next, we add the <code>speed</code> to the <code>t</code> value so that we can calculate the next point on the Bezier path:

ball.t += ball.speed;
Then, we use the <code>t</code> value to calculate the <code>x</code> and <code>y</code> values (<code>xt</code>, <code>yt</code>) using the Bezier curve equations:
var xt = ax*(t*t*t) + bx*(t*t) + cx*t + p0.x;
var yt = ay*(t*t*t) + by*(t*t) + cy*t + p0.y;

We add the <code>speed</code> to the <code>t</code> value of <code>ball</code>, then check to see whether <code>t</code> is greater than <code>1</code>. 
If so, we don’t increase it any further because we have finished moving on the curve:
ball.t += ball.speed;
if (ball.t &gt; 1) { ball.t = 1;
}
Finally, when we draw the <code>ball</code> object on the canvas, we use the <code>xt</code> and <code>yt</code> values:
context.arc(xt,yt,5,0,Math.PI*2,true);

<a href="ch05.html#moving_a_circle_on_a_bezier_curve" title="Figure 5-14. 
Moving a circle on a Bezier curve">Figure 5-14</a> shows what Example 5-11</a> (<em>CH5EX11.html</em>) looks like when it is executed in a web browser. 
In addition to drawing the points of the path using the <code>points</code> array, we also draw the four points of the Bezier curve. 
These illustrate the relationship of the points to the curve itself. 

Notice that the curve does not pass through <code>p1</code> or <code>p2</code>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893745.png" alt="Moving a circle on a Bezier curve" width="605" height="605">
Figure 5-14. 
Moving a circle on a Bezier curve

Example 5-11</a> gives the full code listing for <em>CH5EX11.html</em>, including the code to draw the Bezier curve points on the canvas. 
You can find that code in the <code>drawScreen()</code> function following the <code>//draw the points</code> comment.
Example 5-11. 
Moving on a cubic Bezier curve

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH5EX11: Moving On A Cubic Bezier Curve &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 var pointImage = new Image(); pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 var t = ball.t; var cx = 3 * (p1.x - p0.x) var bx = 3 * (p2.x - p1.x) - cx; var ax = p3.x - p0.x - cx - bx;
 var cy = 3 * (p1.y - p0.y); var by = 3 * (p2.y - p1.y) - cy; var ay = p3.y - p0.y - cy - by;
 var xt = ax*(t*t*t) + bx*(t*t) + cx*t + p0.x; var yt = ay*(t*t*t) + by*(t*t) + cy*t + p0.y;
 ball.t += ball.speed; if (ball.t &gt; 1) { ball.t = 1; }
 //draw the points context.font ="10px sans"; context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p0.x,p0.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("0",p0.x-2,p0.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p1.x,p1.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("1",p1.x-2,p1.y+2); context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p2.x,p2.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("2",p2.x-2, p2.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p3.x,p3.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("3",p3.x-2, p3.y+2);
 //Draw points to illustrate path points.push({x:xt,y:yt}); for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1); }
 context.closePath();
 //Draw circle moving context.fillStyle = "#000000"; context.beginPath(); context.arc(xt,yt,5,0,Math.PI*2,true); context.closePath(); context.fill(); }
 var p0 = {x:60, y:10};
 var p1 = {x:70, y:200};
 var p2 = {x:125, y:295}; var p3 = {x:350, y:350};
 var ball = {x:0, y:0, speed:.01, t:0};
 var points = new Array();
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Moving an Image</h3>
Moving an image on a cubic Bezier curve path is just as easy as moving a circular drawing object, as we’ll demonstrate in the next two examples. 
Suppose you are making a game where bullseyes move across the canvas and the player must shoot at them. 

You could use cubic Bezier curve paths to create new and interesting patterns for the bullseyes to move along.
For this example, we first create a global variable named <code>bullseye</code>, which we will use to hold the <em>bullseye.png</em> image that we will load to display on the canvas:
var bullseye;
function eventWindowLoaded() { bullseye = new Image();
 bullseye.src = "bullseye.png"
 bullseye.onload = eventAssetsLoaded;
}

In <code>canvasApp()</code>, we will create a different path for the curve from the one in the first example by setting new values for <code>p0</code>, <code>p1</code>, <code>p2</code>, and <code>p3</code>. 
Using these values, the <code>bullseye</code> will move on a parabola-like path (<a href="ch05.html#moving_an_image_on_a_cubic_bezier_curve" title="Figure 5-15. 
Moving an image on a cubic Bezier curve path">Figure 5-15</a> shows the path of the curve):
var p0 = {x:60, y:10};

var p1 = {x:150, y:350};
var p2 = {x:300, y:375};
var p3 = {x:400, y:20};
We also need to create a <code>player</code> object that represents the bullseye on the canvas:

var player = {x:0, y:0, speed:.01, t:0};
In <code>drawImage()</code>, after we calculate <code>t</code>, <code>xt</code>, and <code>yt</code>, we draw the image on the canvas:
player.x = xt-bullseye.width/2; player.y = yt-bullseye.height/2;
 context.drawImage(bullseye,player.x,player.y);

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893747.png" alt="Moving an image on a cubic Bezier curve path" width="605" height="605">
Figure 5-15. 
Moving an image on a cubic Bezier curve path
The rest of Example 5-12</a> works just like Example 5-11</a>.

Example 5-12. 
Moving an image
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX12: Moving An Image &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var bullseye;
function eventWindowLoaded() { bullseye = new Image();
 bullseye.src = "bullseye.png"
 bullseye.onload = eventAssetsLoaded;
}

function eventAssetsLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 var pointImage = new Image(); pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 var t = player.t; var cx = 3 * (p1.x - p0.x) var bx = 3 * (p2.x - p1.x) - cx; var ax = p3.x - p0.x - cx - bx;
 var cy = 3 * (p1.y - p0.y); var by = 3 * (p2.y - p1.y) - cy; var ay = p3.y - p0.y - cy - by;
 var xt = ax*(t*t*t) + bx*(t*t) + cx*t + p0.x;
 var yt = ay*(t*t*t) + by*(t*t) + cy*t + p0.y; player.t += player.speed;
 if (player.t &gt; 1) { player.t = 1; } //draw the points context.font = "10px sans";
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p0.x,p0.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("0",p0.x-2,p0.y+2); context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p1.x,p1.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("1",p1.x-2,p1.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p2.x,p2.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("2",p2.x-2, p2.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p3.x,p3.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("3",p3.x-2, p3.y+2);
 //Draw points to illustrate path points.push({x:xt,y:yt});
 for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1); }
 context.closePath();
 player.x = xt-bullseye.width/2; player.y = yt-bullseye.height/2; context.drawImage(bullseye,player.x,player.y);
 }
 var p0 = {x:60, y:10};
 var p1 = {x:150, y:350}; var p2 = {x:300, y:375};
 var p3 = {x:400, y:20};
 var player = {x:0, y:0, speed:.01, t:0};
 var points = new Array(); theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Creating a Cubic Bezier Curve Loop</h3>
You can create some very interesting paths using the four points in a cubic Bezier curve. 

One such effect is a loop. 
To create a loop, you need to make sure the points form an X, with <code>p0</code> diagonal from <code>p1</code>, and <code>p2</code> and <code>p3</code> on an opposite diagonal from the other two points. 
<code>p0</code> and <code>p3</code> must be closer to the center of the canvas than <code>p1</code> or <code>p2</code>. 
Below are the points we will use to create this effect in Example 5-13</a>:

var p0 = {x:150, y:440;
var p1 = {x:450, y:10};
var p2 = {x:50, y:10};
var p3 = {x:325, y:450};

Since it is much easier to show than tell when it comes to cubic Bezier curves, look at <a href="ch05.html#moving_an_object_in_a_loop_using_a_cubic" title="Figure 5-16. 
Moving an object in a loop using a cubic Bezier curve">Figure 5-16</a>. 
It shows what the looping curve looks like when Example 5-13</a> is executed in a web browser.
<h3>Note</h3>

This effect can only be created with the four points of a cubic Bezier curve. 
There is also a three-point Bezier curve known as a quadratic Bezier curve. 
You cannot create loops or S curves with quadratic Bezier curves because the three points are not as precise as the four points of a cubic Bezier curve.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893749.png" alt="Moving an object in a loop using a cubic Bezier curve" width="605" height="605">

Figure 5-16. 
Moving an object in a loop using a cubic Bezier curve
Since the code for this example is essentially the same as in Example 5-12</a> (besides the four points), we have highlighted in bold the changed code in Example 5-13</a>. 
We have done this to show you that—with relatively simple changes—you can create dramatic animation effects using cubic Bezier curves.

Example 5-13. 
Bezier curve loop
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX13: Bezier Curve Loop &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var bullseye;
function eventWindowLoaded() { bullseye = new Image();
 bullseye.src = "bullseye.png"
 bullseye.onload = eventAssetsLoaded;
}

function eventAssetsLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 var pointImage = new Image(); pointImage.src = "point.png";
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 var t = player.t; var cx = 3 * (p1.x - p0.x) var bx = 3 * (p2.x - p1.x) - cx; var ax = p3.x - p0.x - cx - bx;
 var cy = 3 * (p1.y - p0.y); var by = 3 * (p2.y - p1.y) - cy; var ay = p3.y - p0.y - cy - by;
 var xt = ax*(t*t*t) + bx*(t*t) + cx*t + p0.x;
 var yt = ay*(t*t*t) + by*(t*t) + cy*t + p0.y; player.t += player.speed;
 if (player.t &gt; 1) { player.t = 1; } //draw the points context.font = "10px sans";
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p0.x,p0.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("0",p0.x-2,p0.y+2); context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p1.x,p1.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("1",p1.x-2,p1.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p2.x,p2.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("2",p2.x-2, p2.y+2);
 context.fillStyle = "#FF0000"; context.beginPath(); context.arc(p3.x,p3.y,8,0,Math.PI*2,true); context.closePath(); context.fill(); context.fillStyle = "#FFFFFF"; context.fillText("3",p3.x-2, p3.y+2);
 points.push({x:xt,y:yt}); for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x, points[i].y,1,1); }
 context.closePath();
 player.x = xt-bullseye.width/2; player.y = yt-bullseye.height/2;
 context.drawImage(bullseye,player.x,player.y); }
 <strong>var p0 = {x:150, y:440};</strong>
 <strong>var p1 = {x:450, y:10};</strong>
 <strong>var p2 = {x:50, y:10};</strong> <strong>var p3 = {x:325, y:450};</strong>
 var player = {x:0, y:0, speed:.01, t:0};
 var points = new Array();
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h2>Simple Gravity, Elasticity, and Friction</h2>
Adding simulated gravity, elasticity, and friction to your objects adds a sense of realism that otherwise would not exist in 2D. 
These properties are major forces in nature that people feel and understand at nearly every moment of their lives. 

This means that people who play games expect objects to act in a particular way when these properties are applied. 
Our job is to simulate those effects as closely as possible, while minimizing the processing power necessary to create them. 
While there are some very complicated physics equations we could use to create these effects, we will use simplified versions that work well with the limited resources available to HTML5 Canvas in a web browser.
<h3>Simple Gravity</h3>

A very simple, yet seemingly realistic gravitational effect can be achieved by applying a constant gravity value to the <code>y</code> velocity of an object moving on a vector. 
To do this, select a value for gravity, such as <code>.1</code>, and then add that value to the <code>y</code> velocity of your object on every call to <code>drawScreen()</code>.
For this example, let’s simulate a ball with a <code>radius</code> of <code>15</code> pixels being shot from a cannon that rests near the bottom of the canvas. 
The ball will move at a <code>speed</code> of <code>4</code> pixels per frame, with an <code>angle</code> of <code>305</code> degrees. 

This means it will move up and to the right on the canvas. 
If we did not apply any gravity, the ball would simply keep moving on that vector until it left the canvas (actually, it would keep moving, we just would not see it any longer).
You have seen the code to create an effect like this already. 
In the <code>canvasApp()</code> function, we would create the starting variables like this:

var speed = 4;
var angle = 305;
var radians = angle * Math.PI/ 180;
var radius = 15;

var vx = Math.cos(radians) * speed;
var vy = Math.sin(radians) * speed;
Next, we create the starting point for the ball as <code>p1</code>, and then create a dynamic object that holds all the values we created for the <code>ball</code> object:
var p1 = {x:20,y:theCanvas.width-radius};

var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius};
If we want to add gravity to the application, we would first create a new variable named <code>gravity</code> and set it to a constant value of <code>.1</code>:
var gravity = .1;
Next, in the <code>drawScreen()</code> function, we apply this gravity value to the <code>ball</code> object when it is drawn to the canvas (<code>ball.velocityy += gravity</code>). 

We want the ball to stop moving when it hits the “ground” (the bottom of the canvas), so we test to see whether the <code>y</code> position of the <code>ball</code> plus the <code>radius</code> of the ball (the outer edge) has passed the bottom of the canvas (<code>ball.y + ball.radius &lt;= theCanvas.height</code>). 
If so, we stop the ball’s movement:
if (ball.y + ball.radius &lt;= theCanvas.height) {
 ball.velocityy += gravity;

} else {
 ball.velocityx = 0;
 ball.velocityy = 0;
 ball.y = theCanvas.height - ball.radius;

}
Next, we apply the constant <code>x</code> velocity and the new <code>y</code> velocity to <code>ball</code>, and draw it to the canvas:
ball.y += ball.velocityy;
ball.x += ball.velocityx;

context.fillStyle = "#000000";
context.beginPath();
context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true);
context.closePath();

context.fill();
<a href="ch05.html#simple_gravity_with_an_object_moving_on" title="Figure 5-17. 
Simple gravity with an object moving on a vector">Figure 5-17</a> shows what the path looks like when simple gravity is applied to a ball moving on a vector. 
We have added the points to illustrate the path.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893751.png" alt="Simple gravity with an object moving on a vector" width="500" height="500">
Figure 5-17. 
Simple gravity with an object moving on a vector
You can test out Example 5-14</a> with the file <em>CH5EX14.html</em> in the code distribution, or type in the full code listing below.

Example 5-14. 
Simple gravity
a&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX14: Simple Gravity&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() { if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 if (ball.y + ball.radius &lt;= theCanvas.height) { ball.velocityy += gravity; } else { ball.velocityx = 0; ball.velocityy = 0; ball.y = theCanvas.height - ball.radius; }
 ball.y += ball.velocityy; ball.x += ball.velocityx;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill();
 } var speed = 4;
 var gravity = .1;
 var angle = 305;
 var radians = angle * Math.PI/ 180; var radius = 15;
 var vx = Math.cos(radians) * speed;
 var vy = Math.sin(radians) * speed;
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 var p1 = {x:20,y:theCanvas.width-radius};
 var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius};
 setInterval(drawScreen, 33);

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h3>Simple Gravity with a Bounce</h3>

The last example showed what a cannonball might look like if it was shot out, landed on a surface, and stuck there with no reaction. 
However, even a heavy cannonball will bounce when it hits the ground.
To create a bouncing effect we do not have to change the code very much at all. 
In <code>drawScreen()</code>, we first apply <code>gravity</code> on every frame; then, instead of stopping the ball if it hits the bottom of the canvas, we simply need to reverse the <code>y</code> velocity of <code>ball</code> when it hits the ground.

In <em>CH5EX14.html</em> you would replace this code…
if (ball.y + ball.radius &lt;= theCanvas.height) {
 ball.velocityy += gravity;
} else { ball.velocityx = 0;
 ball.velocityy = 0;
 ball.y = theCanvas.height - ball.radius;
}

…with this:
ball.velocityy += gravity;
if ((ball.y + ball.radius) &gt; theCanvas.height) {
 ball.velocityy = -(ball.velocityy)

}
This code will send the ball bouncing back “up” the canvas. 
Since it is still traveling on the vector, and gravity is applied every time <code>drawScreen()</code> is called, the ball will eventually come down again as the applied <code>gravity</code> overtakes the reversed <code>y</code> velocity.
<a href="ch05.html#a_ball_moving_on_a_vector_with_gravity_a" title="Figure 5-18. 

A ball moving on a vector with gravity and a bounce applied">Figure 5-18</a> shows what the cannonball looks like when the bounce is applied.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893753.png" alt="A ball moving on a vector with gravity and a bounce applied" width="500" height="500">
Figure 5-18. 
A ball moving on a vector with gravity and a bounce applied

<h3>Note</h3>
To achieve a nice-looking bounce for this example, we also changed the <code>angle</code> of the vector in <code>canvasApp()</code> to <code>295</code>:
var angle = 295;
Example 5-15</a> offers the full code.

Example 5-15. 
Simple gravity with a bounce
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX15: Gravity With A Bounce&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp() { if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 ball.velocityy += gravity; if ((ball.y + ball.radius) &gt; theCanvas.height) { ball.velocityy = -(ball.velocityy) } ball.y += ball.velocityy; ball.x += ball.velocityx;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill();
 }
 var speed = 5; var gravity = .1;
 var angle = 295;
 var radians = angle * Math.PI/ 180;
 var radius = 15; var vx = Math.cos(radians) * speed;
 var vy = Math.sin(radians) * speed;
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d"); var p1 = {x:20,y:theCanvas.width-radius};
 var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius};
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Gravity with Bounce and Applied Simple Elasticity</h3>
In physics, the <em>elasticity</em> of a bouncing ball refers to how much energy is conserved when a ball bounces off a surface. 

We already covered a bit about conservation of energy when we discussed balls colliding, but when we are simulating objects falling, we need to take a slightly different path with our code. 
In Example 5-15</a>, we applied 100% elasticity and the ball bounced forever (actually, this was only implied since we did not consider elasticity at all). 
However, in real life, balls usually lose some of their energy every time they bounce off a surface. 
The amount of energy conserved depends on the material the ball is made from, as well as the surface it is bouncing on. 

For example, a rubber Super Ball is much more elastic than a cannonball and will bounce higher on the first bounce off a surface. 
Both will bounce higher off a concrete surface than a surface made of thick mud. 
Eventually, both will come to rest on the surface as all the energy is transferred away from the ball.
We can simulate simple elasticity by applying a constant value to the ball when it bounces off the ground. 

For this example, we will set the <code>speed</code> of the ball to <code>6</code> pixels per frame, and the <code>angle</code> to <code>285</code>. 
We will keep our <code>gravity</code> at <code>.1</code>, but set a new variable named <code>elasticity</code> to <code>.5</code>. 
To make this more straightforward, we will also assume that the surface the ball is bouncing on does not add or subtract from the elasticity of the ball.
In <code>canvasApp()</code> we would set the new properties like this:

var speed = 6;
var gravity = .1;
var elasticity = .5;
var angle = 285;

We then add the new <code>elasticity</code> property to the <code>ball</code> object because, unlike <code>gravity</code>, elasticity describes a property of an object, not the entire world it resides within. 
This means that having multiple balls with different values for elasticity would be very easy to implement:
var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius, elasticity: elasticity};
In the <code>drawScreen()</code> function, we still add the <code>gravity</code> value to the <code>y</code> velocity (<code>velocityy</code>). 

However, instead of simply reversing the <code>y</code> velocity when the <code>ball</code> hits the bottom of the canvas, we also multiply the <code>y</code> velocity by the <code>elasticity</code> value stored in the <code>ball.elasticity</code> property. 
This applies the elasticity to the bounce, preserving the <code>y</code> velocity by the percentage value of <code>elasticity</code> for the object:
ball.velocityy += gravity;
if ((ball.y + ball.radius) &gt; theCanvas.height) { ball.velocityy = -(ball.velocityy)*ball.elasticity;
}
ball.y += ball.velocityy;
ball.x += ball.velocityx;

In <a href="ch05.html#ball_bouncing_with_elasticity_and_gravit" title="Figure 5-19. 
Ball bouncing with elasticity and gravity applied">Figure 5-19</a> you can see what this application looks like when executed in a web browser.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893755.png" alt="Ball bouncing with elasticity and gravity applied" width="500" height="500">
Figure 5-19. 

Ball bouncing with elasticity and gravity applied
<h3>Note</h3>
With <code>gravity</code> applied, the bounce is not exactly as you might expect. 
Gravity is always pulling down on our object, so the effect of a loss of <code>y</code> velocity due to an elastic bounce is pronounced.

The full code is shown in Example 5-16</a>.
Example 5-16. 
Simple gravity with bounce and elasticity
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX16: Gravity With A Vector With Bounce And Elasticity&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); ball.velocityy += gravity;
 if ((ball.y + ball.radius) &gt; theCanvas.height) { ball.velocityy = -(ball.velocityy)*ball.elasticity; } ball.y += ball.velocityy; ball.x += ball.velocityx;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill();
 } var speed = 6;
 var gravity = .1;
 var elasticity = .5;
 var angle = 285; var radians = angle * Math.PI/ 180;
 var radius = 15;
 var vx = Math.cos(radians) * speed;
 var vy = Math.sin(radians) * speed; theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 var p1 = {x:20,y:theCanvas.width-radius};
 var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius, elasticity: elasticity}; setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h3>Simple Gravity, Simple Elasticity, and Simple Friction</h3>
Now that we have a ball traveling on a vector that is affected by both gravity and elasticity, we have one more element to add to make the animation more realistic. 
In the previous example, the <code>y</code> velocity was affected by gravity and elasticity, but the ball still traveled on the x-axis without any degradation in velocity. 
We will fix this issue now by adding friction into the equation.

In physics, <em>friction</em> is a force that resists the motion of an object. 
We have already discussed friction as it applies to colliding balls, and this implementation is similar except that it affects only the <code>x</code> velocity. 
For our purposes, we will achieve simple friction by degrading the <code>x</code> velocity as gravity degrades the <code>y</code> velocity.
Taking the code from Example 5-16</a>, in <code>canvasApp()</code> we create a new variable named <code>friction</code>. 

This is the amount of pixels to degrade the <code>x</code> velocity on every frame:
var friction = .008;
Notice that the amount is quite small. 
Friction does not have to be a large value to look realistic—it just needs to be applied uniformly each time <code>drawScreen()</code> is called. 

In <code>drawScreen()</code>, we apply <code>friction</code> to the <code>x</code> velocity like this:
ball.velocityx = ball.velocityx - ( ball.velocityx*friction);
This is the same type of proportional application of friction we used with the colliding balls, but again, this time we applied it only to the <code>x</code> velocity.
<a href="ch05.html#ball_bouncing_with_gravity_comma_elastic" title="Figure 5-20. 

Ball bouncing with gravity, elasticity, and friction applied">Figure 5-20</a> shows what this final version of our application looks like when executed in a web browser.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893757.png" alt="Ball bouncing with gravity, elasticity, and friction applied" width="500" height="500">
Figure 5-20. 
Ball bouncing with gravity, elasticity, and friction applied

Example 5-17</a> gives the full code for <em>CH5EX17.html</em>, the final code of our simple gravity, simple elasticity, and simple friction example.
Example 5-17. 
Gravity with a vector with bounce friction
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX17: Gravity With A Vector With Bounce Friction&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () { return Modernizr.canvas;
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#EEEEEE'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); ball.velocityx = ball.velocityx - ( ball.velocityx*friction);
 ball.velocityy += gravity;
 if ((ball.y + ball.radius) &gt; theCanvas.height) { ball.velocityy = -(ball.velocityy)*ball.elasticity; } ball.y += ball.velocityy; ball.x += ball.velocityx;
 context.fillStyle = "#000000"; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill(); }
 var speed = 6;
 var gravity = .1;
 var friction = .008; var elasticity = .5;
 var angle = 285;
 var radians = angle * Math.PI/ 180;
 var radius = 15; var vx = Math.cos(radians) * speed;
 var vy = Math.sin(radians) * speed;
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d"); var p1 = {x:20,y:theCanvas.width-radius};
 var ball = {x:p1.x, y:p1.y, velocityx: vx, velocityy:vy, radius:radius, elasticity: elasticity};
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h2>Easing</h2>
<em>Easing</em> is a technique used in animation to make an object smoothly enter or leave a location. 

The idea of easing is that instead of uniformly applying movement to every frame of animation, you instead increase (<em>easing in</em>) or decrease (<em>easing out</em>) the number of pixels you move on each frame. 
The result is that movement appears to be more realistic and smooth. 
There are many different ways to create easing animations. 
We will concentrate on two simple examples that will help pave the way for you to further explore the subject on your own.

<h3>Easing Out (Landing the Ship)</h3>
The process of easing out refers to easing at the end of an animation: an object moving from one point to another, starting out fast, and slowing down as it reaches the second point. 
To illustrate the concept, we will use the example of a spaceship landing. 
A spaceship starts out very fast, applies negative thrust to slow down, and, by the time it reaches the ground, is moving slowly enough to land without incident. 

If you’ve ever played the video game <em>Lunar Lander</em>, you will understand exactly the type of movement we are trying to accomplish.
To create this easing-out effect, we need to find two distinct points and then move an object between them, slowing down the object in linear fashion as it nears the second point. 
To achieve this effect, we first calculate the distance between the points. 
Next, we select a percentage value (<code>easeValue</code>) that we will use to move the object across that distance on each frame. 

As the distance gets shorter, the amount we move gets shorter as well. 
This gives the object the appearance of traveling slower and slower as it moves from the starting point to the ending point, as illustrated in <a href="ch05.html#spaceship_landing_illustrating_easing_ou" title="Figure 5-21. 
Spaceship landing (easing out)">Figure 5-21</a>. 
We have drawn the points to show the easing values as the ship nears the bottom of the screen. 

Notice that the points get closer and closer until there is almost no distance between them.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893759.png" alt="Spaceship landing (easing out)" width="500" height="500">
Figure 5-21. 
Spaceship landing (easing out)

<a href="ch05.html#spaceship_landing_illustrating_easing_ou" title="Figure 5-21. 
Spaceship landing (easing out)">Figure 5-21</a> displays the results of <em>CH5EX18.html</em>. 
Now, let’s look at how this example works in detail. 
First, we will load in the <em>ship.png</em> image the same way we have loaded images previously in this chapter:

var shipImage;
function eventWindowLoaded() {
 shipImage = new Image();
 shipImage.src = "ship.png" shipImage.onload = eventAssetsLoaded;
}
function eventAssetsLoaded() {
 canvasApp();

}
Then in <code>canvasApp()</code>, we create a variable named <code>easeValue</code>, which represents the percentage to move the ship across the remaining distance between the two points. 
In our example, it is 5% (<code>.05</code>):
var easeValue = .05;

Next, we create our two points. 
The first point, <code>p1</code>, is close to the middle of the canvas on the y-axis, and just above the top (<code>-20</code>) on the x-axis. 
The final point, <code>p2</code>, is in the same place on the x-axis, but near the bottom of the canvas (<code>470</code>) on the y-axis:
var p1 = {x:240,y:-20};

var p2 = {x:240,y:470};
Finally, we create a dynamic object for the <code>ship</code> that holds these values:
var ship = {x:p1.x, y:p1.y, endx: p2.x, endy:p2.y, velocityx:0, velocityy:0};
In <code>drawScreen()</code>, on every frame, we first find out the distance between the ship and the endpoint by subtracting the current <code>x</code> and <code>y</code> values for the <code>ship</code> from the endpoint <code>x</code> and <code>y</code> values. 

The distance will get shorter on each call to <code>drawScreen()</code> as the ship moves farther away from <code>p1</code> and gets closer to <code>p2</code>. 
We do this for both <code>x</code> and <code>y</code> even though, in our example, only the <code>y</code> value will change as the spaceship gets closer to <code>p2</code>:
var dx = ship.endx - ship.x;
var dy = ship.endy - ship.y;

Once we have the distances, we multiply those values by <code>easeValue</code> to get the <code>x</code> and <code>y</code> velocities for the <code>ship</code> on this call to <code>drawScreen()</code>:
ship.velocityx = dx * easeValue;
ship.velocityy = dy * easeValue;
Finally, we apply those values and draw the spaceship to the canvas:

ship.x += ship.velocityx;
ship.y += ship.velocityy;
context.drawImage(shipImage,ship.x,ship.y);
You can test this example by executing <em>CH5EX18.html</em> from the code distribution in your web browser, or by typing in the full code listing shown in Example 5-18</a>.

Example 5-18. 
Easing out (landing the ship)
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX18: Easing Out (Landing The Ship)&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var shipImage;
function eventWindowLoaded() { shipImage = new Image();
 shipImage.src = "ship.png"
 shipImage.onload = eventAssetsLoaded;
}

function eventAssetsLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return;
} var pointImage = new Image();
 pointImage.src = "pointwhite.png";
 function drawScreen () {
 context.fillStyle = '#000000'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#ffffff'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); var dx = ship.endx - ship.x; var dy = ship.endy - ship.y; ship.velocityx = dx * easeValue; ship.velocityy = dy * easeValue;
 ship.x += ship.velocityx; ship.y += ship.velocityy;
 //Draw points to illustrate path points.push({x:ship.x,y:ship.y}); for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x+shipImage.width/2, points[i].y,1,1); }
 context.drawImage(shipImage,ship.x,ship.y);
 } var easeValue = .05;
 var p1 = {x:240,y:-20}; var p2 = {x:240,y:470};
 var ship = {x:p1.x, y:p1.y, endx: p2.x, endy:p2.y, velocityx:0, velocityy:0};
 var points = new Array();
 theCanvas = document.getElementById("canvasOne"); context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Note</h3>
We are showing the points in this example but because the background is black, we load in a white bitmap point image named <em>pointwhite.png</em> instead of the all-black image, <em>point.png</em>.
<h3>Easing In (Taking Off)</h3>

Easing in is the opposite of easing out. 
When an animation <em>eases in</em>, it starts slowly and then gets faster and faster. 
If you have ever seen a video of a space shuttle taking off, you will understand this much better. 
The thrust builds up as the craft moves slowly, and then gets faster and faster as it moves through the sky. 

We are going to use this “taking off” example as a way to develop code for an easing-in animation on HTML5 Canvas.
In <code>canvasApp()</code>, we start our code much the same way as in the last example—by creating a variable named <code>easeValue</code>:
var easeValue = .05;
However, for easing in, instead of this being a percentage of the remaining distance between two points, it is simply a constant value added to the velocity of the ship on each frame. 

<a href="ch05.html#ship_taking_off_open_parenthesis_easing" title="Figure 5-22. 
Ship taking off (easing in)">Figure 5-22</a> shows what this would look like. 
We have added the points again to illustrate how the animation speeds up as the ship takes off.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893761.png" alt="Ship taking off (easing in)" width="500" height="500">

Figure 5-22. 
Ship taking off (easing in)
First, we set the beginning position of the <code>ship</code> (<code>p1</code>) to the bottom center of the canvas. 
Then, we set the beginning <code>speed</code> of the ship very low (<code>.5</code> pixels per frame), and set the <code>angle</code> to <code>270</code> (straight up the canvas). 

We then calculate the <code>x</code> and <code>y</code> velocity values for the <code>ship</code>:
var p1 = {x:240,y:470};
var tempSpeed = .5;
var tempAngle = 270 ;

var tempRadians = tempAngle * Math.PI/ 180;
var tempvelocityx = Math.cos(tempRadians) * tempSpeed;
var tempvelocityy = Math.sin(tempRadians) * tempSpeed;
var ship = {x:p1.x, y:p1.y, velocityx:tempvelocityx, velocityy:tempvelocityy};

In <code>drawScreen()</code>, instead of finding the distance between two points, we add the <code>easeValue</code> to the <code>x</code> and <code>y</code> velocities on each frame, and then apply it to the <code>ship x</code> and <code>y</code> values before drawing it to the canvas. 
This creates a linear increase in speed, resulting in the easing-in effect we want to see:
ship.velocityx = ship.velocityx + ( ship.velocityx*easeValue);
ship.velocityy = ship.velocityy + ( ship.velocityy*easeValue);

ship.x += ship.velocityx;
ship.y += ship.velocityy;
context.drawImage(shipImage,ship.x,ship.y);
You can see this example by executing <em>CH5EX19.html</em> from the code distribution, or by typing in the code listing shown in Example 5-19</a>.

Example 5-19. 
Easing in (taking off)
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH5EX19: Taking Off (Fake Ease In)&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var shipImage;
function eventWindowLoaded() { shipImage = new Image();
 shipImage.src = "ship.png"
 shipImage.onload = eventAssetsLoaded;
}

function eventAssetsLoaded() {
 canvasApp();
}
function canvasSupport () { return Modernizr.canvas;

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 var pointImage = new Image(); pointImage.src = "pointwhite.png";
 function drawScreen () {
 context.fillStyle = '#000000'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#ffffff'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2);
 ship.velocityx = ship.velocityx + ( ship.velocityx*easeValue); ship.velocityy = ship.velocityy + ( ship.velocityy*easeValue); ship.x += ship.velocityx; ship.y += ship.velocityy;
 //Draw points to illustrate path points.push({x:ship.x,y:ship.y});
 for (var i = 0; i&lt; points.length; i++) { context.drawImage(pointImage, points[i].x+shipImage.width/2, points[i].y,1,1); } context.drawImage(shipImage,ship.x,ship.y);
 }
 var easeValue = .05;
 var p1 = {x:240,y:470}; var tempX;
 var tempY;
 var tempSpeed = .5;
 var tempAngle = 270 ; var tempRadians = tempAngle * Math.PI/ 180;
 var tempvelocityx = Math.cos(tempRadians) * tempSpeed;
 var tempvelocityy = Math.sin(tempRadians) * tempSpeed;
 var ship = {x:p1.x, y:p1.y, velocityx:tempvelocityx, velocityy:tempvelocityy}; var points = new Array();
 theCanvas = document.getElementById("canvasOne");
 context = theCanvas.getContext("2d");
 setInterval(drawScreen, 33);

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h3>Note</h3>

For more information on easing, check out Robert Penner’s easing equations: <a href="http://www.robertpenner.com/easing/">http://www.robertpenner.com/easing/</a>. 
These equations have been implemented in jQuery for JavaScript at <a href="http://plugins.jquery.com/files/jquery.animation.easing.js.txt">http://plugins.jquery.com/files/jquery.animation.easing.js.txt</a>.
<h2>What’s Next?</h2>
We have shown you a plethora of examples for how you can use HTML5 Canvas to animate objects using some basic principles of math and physics. 

However, we have really only begun to scratch the surface of the multitude of ways you can use math and physics in your applications. 
In the next couple chapters we will switch gears, discussing audio and video, before we start applying many of the concepts we have learned in this book to a couple of in-depth game projects.
 6. 
Mixing HTML5 Video and Canvas" epub:type="chapter">

<h2><span class="orange">Chapter 6. Mixing HTML5 Video and Canvas</span></h2>
Using the new <code>&lt;video&gt;</code> tag, HTML5 lets sites show video directly in HTML without needing any plug-in technologies. 
However, the simple <code>&lt;video&gt;</code> tag opens up a whole slew of complexities and opportunities for developers. 
While we can’t cover everything related to video in this chapter, we will introduce you to the HTML5 <code>&lt;video&gt;</code> tag, and then show you ways in which video can be incorporated and manipulated by HTML5 Canvas.

<h2>HTML5 Video Support</h2>
HTML5 specifies a new tag, <code>&lt;video&gt;</code>, that allows developers to place video directly in an HTML page. 
With a few simple options, you can autoplay, loop, and add playback controls to the embedded video.
First, let’s talk about video format support, which is a very complicated issue. 

Some video formats are free, and others are licensed. 
Some formats look better than others, some make smaller file sizes, and some are supported in one browser while others are supported in a different browser. 
In this chapter we will concentrate on three formats that either have broad support now or promise to have broad support in the future:<em> .ogg</em>, <em>.mp4</em>, and <em>.webm</em>.
We will discuss these video formats in terms of <em>video codecs</em>. 

Each format uses one or more <em>codecs</em> to compress and decompress video. 
Codecs are usually the secret sauce of a video format because compression is the key to making video that, in the wild, can convert very large files into file sizes that can be easily transported on the Internet.
<h3>Theora + Vorbis = .ogg</h3>
Theora (<a href="http://www.theora.org/">http://www.theora.org/</a>) is an open source, free video codec developed by Xiph.org. 

Vorbis (<a href="http://www.vorbis.com">http://www.vorbis.com</a>) is a free, open source audio codec that is used in conjunction with Theora. 
Both Theora and Vorbis are stored in an <em>.ogg</em> file. 
<em>.ogg</em> files have the broadest support among traditional web browsers, but, unfortunately, not on handheld devices. 
Many commercial companies (e.g., Apple) have balked at using Theora/Vorbis because they are unsure whether somewhere, someplace, someone might own a patent that covers part of the technology, and thus they might get sued for using it.

<h3>Note</h3>
Sometimes technology companies get hit with what is known as a <em>submarine patent</em>. 
This was a patent tactic—available up until 1995 in the U.S.—that allowed a filer to delay the publication of a patent. 
Because patents were only enforceable for 17 years, if someone filed one but delayed the publications, he could wait years (even decades) until someone else came up with the same idea, then hit that person with a lawsuit.

<h3>H.264 + $$$ = .mp4</h3>
H.264 is a high-quality video standard that has received the backing of some very big players, such as Apple, Adobe, and Microsoft. 
However, despite offering high-quality video, it only defines a standard—not a video codec. 
An organization named MPEG LA owns the intellectual property, and they license it out to software and hardware vendors. 

Many companies that have implemented H.264 have done so with their own proprietary codecs. 
As a result, the varying codecs are incompatible with one another, making this a tricky format to use across multiple platforms. 
H.264 videos have the <em>.mp4</em> extension. 
Most for-profit corporations have implemented support for this format on their platforms, but the developers of open source browsers like Firefox and Opera have not. 

In late 2010, Google dropped H.264 support in Chrome in favor of WebM.
<h3>VP8 + Vorbis = .webm</h3>
WebM is a new open source video standard supported by Google, Adobe, Mozilla, and Opera. 
It is based on the VP8 codec and includes Vorbis (just like Theora) as an audio codec. 

When <a href="http://youtube.com">YouTube.com</a> announced they had converted many of their videos to be HTML5-compatible, one of the formats they used was WebM. 
Currently, only Google Chrome and Opera support WebM, but broader support should be coming in the future.
To summarize, here is a chart of the video formats supported by various browsers.
<table>

<colgroup>
<col>
<col>
<col>

<col>
</colgroup>
<thead><tr>
<td>

Platform
</td>
<td>
.ogg

</td>
<td>
.mp4
</td>

<td>
.webm
</td>
</tr></thead>

<tbody>
<tr>
<td>
Android

</td>
<td>
X
</td>

<td> </td>
<td> </td>
</tr>
<tr>

<td>
Firefox
</td>
<td>

X
</td>
<td> </td>
<td> </td>

</tr>
<tr>
<td>
Chrome

</td>
<td>
X
</td>

<td> </td>
<td>
X
</td>

</tr>
<tr>
<td>
iPhone

</td>
<td> </td>
<td>
X

</td>
<td> </td>
</tr>
<tr>

<td>
Internet Explorer 9
</td>
<td> </td>

<td>
X
</td>
<td> </td>

</tr>
<tr>
<td>
Opera

</td>
<td>
X
</td>

<td> </td>
<td>
X
</td>

</tr>
<tr>
<td>
Safari

</td>
<td> </td>
<td>
X

</td>
<td> </td>
</tr>
</tbody>

</table>
As you can see, no one format is supported by all browsers or platforms. 
Because HTML5 Canvas only supports video in the format supported by the browser it is implemented within, we must apply a strategy that uses multiple formats to play video.
<h3>Combining All Three</h3>

The examples in this chapter will introduce a strategy that may seem crazy at first—using all three formats at once. 
While this might seem to be more work than necessary, right now it is the only way to ensure broad support across as many platforms as possible. 
The HTML5 <code>&lt;video&gt;</code> tag allows us to specify multiple formats for a single video, and this will help us achieve our goal of broad video support when working with HTML5 Canvas.
<h2>Converting Video Formats</h2>
Before we get into some video demonstrations, we should discuss video conversions. 
Since we are going to use <em>.ogg</em>, <em>.mp4</em>, and <em>.webm</em> videos in all our projects, we need to have a way to convert video to these formats. 
Converting video can be a daunting task for someone unfamiliar with all the existing and competing formats; luckily, there are some great free tools to help us do just that:

Miro Video Converter (<a href="http://www.mirovideoconverter.com/">http://www.mirovideoconverter.com/</a>)
This application will quickly convert most video types to <em>.ogg</em>, <em>.mp4</em>, and <em>.webm</em>. 
It is available for both Windows and Mac.

SUPER  (<a href="http://www.erightsoft.com/SUPER.html">http://www.erightsoft.com/SUPER.html</a>)
This is a free video-conversion tool for Windows only that creates <em>.mp4</em> and <em>.ogg</em> formats. 

If you can navigate through the maze of screens trying to sell you other products, it can be very useful for video conversions.
HandBrake (<a href="http://handbrake.fr/">http://handbrake.fr/</a>)

This video-converter application for the Macintosh platform creates <em>.mp4</em> and <em>.ogg</em> file types.
FFmpeg (<a href="http://ffmpeg.org/">http://ffmpeg.org/</a>)

This is the ultimate cross-platform, command-line tool for doing video conversions. 
It works in Windows/Mac/Linux and can do nearly any conversion you desire. 
However, there is no GUI interface, so it can be daunting for beginners. 
Some of the tools above use FFmpeg as their engine to do video conversions.

<h2>Basic HTML5 Video Implementation</h2>
In the <code>&lt;video&gt;</code> tag’s most minimal implementation, it only requires a valid <code>src</code> atrribute. 

For example, if we took a nifty little video of the waves crashing at Muir Beach, California (just north of San Francisco), and we encoded it as an H.264 <em>.mp4</em> file, the code might look like this:
&lt;video src="muirbeach.mp4" /&gt;
<h3>Note</h3>
To see an example of this basic code, look at the <em>CH6EX1.html</em> file in the code distribution.

There are many properties that can be set in an HTML5 video embed. 
These properties are actually part of the <code>HTMLMediaElement</code> interface, implemented by the <code>HTMLVideo</code><code>Element</code> object. 
Some of the more important properties include:

<code>src</code>
The URL to the video that you want to play.

<code>autoplay</code>
<code>true</code> or <code>false</code>. 
Forces the video to play automatically when loaded.

<code>loop</code>
<code>true</code> or <code>false</code>. 

Loops the video back to the beginning when it has finished playing (at the time of this writing, this did not work in Firefox).
<code>volume</code>

A number between 0 and 1. 
Sets the volume level of the playing video.
<code>poster</code>

A URL to an image that will be shown while the video is loading.

There are also some methods of <code>HTMLVideoElement</code> that are necessary when playing video in conjunction with JavaScript and Canvas:
<code>play()</code>

A method used to start playing a video.
<code>pause()</code>

A method used to pause a video that is playing.
Additionally, there are some properties you can use to check the status of a video, including:

<code>duration</code>
The length of the video in seconds.

<code>currentTime</code>
The current playing time of the video in seconds. 

This can be used in conjunction with <code>duration</code> for some interesting effects, which we will explore later.
<code>ended</code>

<code>true</code> or <code>false</code>, depending on whether the video has finished playing.
<code>muted</code>

<code>true</code> or <code>false</code>. 
Used to inquire whether the sound of the playing video has been muted.
<code>paused</code>

<code>true</code> or <code>false</code>. 
Used to inquire whether the video is currently paused.

<h3>Note</h3>
There are even more properties that exist for <code>HTMLVideoElement</code>. 
Check them out at <a href="http://www.w3.org/2010/05/video/mediaevents.html">http://www.w3.org/2010/05/video/mediaevents.html</a>.

<h3>Plain-Vanilla Video Embed</h3>
To demonstrate a plain-vanilla embed, we are going to work under our previously established rules for video formats. 
We will use three formats because no one format will work in every browser. 
We have created a version of the Muir Beach video as a <em>.webm</em>, an <em>.ogg</em>, and a <em>.mp4</em>. 

For the rest of this chapter, we will use all three formats in all of our video embeds.
To support all three formats at once, we must use an alternative method for setting the <code>src</code> attribute of the <code>&lt;video&gt;</code> tag. 
Why? Because we need to specify three different video formats instead of one in our HTML page. 
To do this, we add <code>&lt;source&gt;</code> tags within the <code>&lt;video&gt;</code> tag:

&lt;video width="320" height="240"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;

&lt;/video&gt;
<h3>Note</h3>
We put the <em>.mp4</em> file first in the <code>src</code> list because on certain iOS (iPhone, iPad) devices, the browser will not attempt to load any other <code>src</code> type than the first one listed. 
Since those devices support <em>.mp4</em> files, we list them first to get the broadest support for HTML5 video.

When a web browser reads this HTML, it will attempt to load each video in succession. 
If it does not support one format, it will try the next one. 
Using this style of embed allows the code in Example 6-1</a> to execute on all HTML5-compliant browsers.
Also notice that we have set the <code>width</code> and <code>height</code> properties of the video. 

While these are not necessarily needed (as we saw earlier), it is proper HTML form to include them, and we will need them a bit later when we start to manipulate the video size in code.
Example 6-1. 
Basic HTML video
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX1: Basic HTML5 Video&lt;/title&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;video width="320" height="240"&gt; &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;

&lt;/div&gt;
&lt;div&gt;
(Right-click To Control)
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<a href="ch06.html#html5_video_embed" title="Figure 6-1. 
HTML5 video embed">Figure 6-1</a> is an example of the plain-vanilla video embed in an HTML5 page. 

There are no controls displayed in the default settings, but if you right-click on the video, controls will appear that can be used in conjunction with the embedded video.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893763.png.jpg" alt="HTML5 video embed" width="320" height="262">
Figure 6-1. 
HTML5 video embed

<h3>Video with Controls, Loop, and Autoplay</h3>
While a video displayed without controls might suit your needs, most users expect to see some way to control a video. 
Also, as the developer, you might want a video to play automatically or loop back to the beginning when it finishes. 
All of these things (if supported in the browser) are very easy to accomplish in HTML5.

Adding controls, looping, and autoplay to an HTML5 video embed is simple. 
All you need to do is specify the options <code>controls</code>, <code>loop</code>, and/or <code>autoplay</code> in the <code>&lt;video&gt;</code> tag, like this:
&lt;video autoplay loop controls width="320" height="240"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt; &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;
<h3>Note</h3>

As of this writing, <code>loop</code> does not work in Firefox; however, support is expected in version 4.0.
The code to embed our Muir Beach video with controls, loop, and autoplay is in <em>CH6EX2.html</em> in the code distribution. 
<a href="ch06.html#html5_video_embed_with_controls" title="Figure 6-2. 
HTML5 video embed with controls">Figure 6-2</a> shows what a video with controls looks like in Google Chrome.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893765.png.jpg" alt="HTML5 video embed with controls" width="320" height="262">
Figure 6-2. 
HTML5 video embed with controls
You can see the full code in Example 6-2</a>.

Example 6-2. 
HTML video with controls, loop, and autoplay
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX2: Basic HTML5 Video With Controls&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;video autoplay loop controls width="320" height="240"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt; &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;
&lt;/div&gt;

&lt;div&gt;
(Autoplay, Loop, Controls)
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Altering the Width and Height of the Video</h3>
In our first example, we showed how you could embed a video without changing the default width or height. 
However, there are many good reasons why you might want to change the default width and height of a video in the HTML page, such as fitting it into a particular part of the page, or enlarging it so it is easier to see. 

Similar to embedding an image into HTML with the <code>&lt;img&gt;</code> tag, a video will scale to whatever <code>width</code> and <code>height</code> you provide in the <code>&lt;video&gt;</code> tag. 
Also, like with the <code>&lt;img&gt;</code> tag, this scale does not affect the size of the object downloaded. 
If the video is 5 megabytes at 640×480, it will still be 5 megabytes when displayed at 180×120—just scaled to fit that size.
In Example 6-3</a> (<em>CH6EX3.html</em>) we have scaled the same video to three different sizes and displayed them on the same page. 

<a href="ch06.html#controlling_video_width_and_height_in_th" title="Figure 6-3. 
Controlling video width and height in the embed">Figure 6-3</a> shows what this looks like in HTML (again, rendered in the Google Chrome browser).
Example 6-3. 
Basic HTML5 video in three sizes

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH6EX3: Basic HTML5 Video: 3 Sizes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;video autoplay loop controls width="640" height="480"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt; &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
&lt;/video&gt;
&lt;/div&gt;
&lt;div&gt;

(640×480)
&lt;div&gt;
&lt;video autoplay loop controls width="320" height="240"id="thevideo"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt; &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;
&lt;/div&gt;

&lt;div&gt;
(320×240)
&lt;/div&gt;
&lt;div&gt;

&lt;video autoplay loop controls width="180" height="120"id="thevideo"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;

&lt;/video&gt;
&lt;/div&gt;
&lt;div&gt;
(180×120)

&lt;/body&gt;
&lt;/html&gt;
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893767.png.jpg" alt="Controlling video width and height in the embed" width="1000" height="880">
Figure 6-3. 

Controlling video width and height in the embed
<h4>Dynamically scaling a video</h4>
Now it is time for a more elaborate (and we think more effective) example of scaling a video. 
By changing the <code>width</code> and <code>height</code> attributes of the <code>&lt;video&gt;</code> tag, we can scale the video on the fly. 

While there may be a few practical reasons you would do this in a real-world situation, it is also an effective way to demonstrate some of the power of the HTML5 <code>&lt;video&gt;</code> tag.
First, we need to add an HTML5 <code>range</code> control to the page:
&lt;form&gt;
 Video Size: &lt;input type="range" min="80" max="1280" step="1" value="320"/&gt;

&lt;/form&gt;
We discussed the details of the <code>range</code> control in <a href="ch03.html" title="Chapter 3. 
The HTML5 Canvas Text API">Chapter 3</a>, but just to refresh your memory, <code>range</code> is a new form control added to HTML5 that creates a slider of values. 
We are going to use this slider to set the video size.

<h3>Note</h3>
If the browser does not support the <code>range</code> element, a text box will appear that will allow the user to enter text directly.
To capture the change to the video size, we need to add some JavaScript. 
We create an event listener for the <code>load</code> event that calls the <code>eventWindowLoaded()</code> function when the page loads (this should look very familiar to you by now):

window.addEventListener('load', eventWindowLoaded, false);
We need to set up a couple things in the <code>eventWindowLoaded()</code> function. 
First, we need to add an event listener for a change to the <code>videoSize</code> form control we created in the HTML page. 
A “change” to the control (e.g., someone slides it right or left) will create an event handled by the <code>videoSizeChanged()</code> event handler:

var sizeElement = document.getElementById("videoSize")
sizeElement.addEventListener('change', videoSizeChanged, false);
Next, we need to create a value that can be used to set both the width and the height of the video at once. 
This is because we want to keep the proper <em>aspect ratio</em> of the video (the ratio of width to height) when the video is resized. 

To do this, we create the variable <code>widthtoHeightRatio</code>, which is simply the width of the video divided by the height:
var widthtoHeightRatio = videoElement.width/videoElement.height;
Finally, when the user changes the <code>videoSize range</code> control, the <code>videoSizeChanged()</code> event handler is called. 
This function sets the <code>width</code> property of the video to the value of the <code>range</code> control (<code>target.value</code>), then sets the <code>height</code> of the video to the same value, and divides by the <code>widthtoHeightRatio</code> value we just created. 

The effect is that the video resizes while playing. 
<a href="ch06.html#controlling_video_width_and_height_in_ja" title="Figure 6-4. 
Controlling video width and height in JavaScript">Figure 6-4</a> captures one moment of that:
function videoSizeChanged(e) { var target = e.target; var videoElement = document.getElementById("theVideo"); videoElement.width = target.value; videoElement.height = target.value/widthtoHeightRatio;
 }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893769.png.jpg" alt="Controlling video width and height in JavaScript" width="786" height="625">
Figure 6-4. 

Controlling video width and height in JavaScript
Example 6-4</a> offers the full code listing for this application.
Example 6-4. 
Basic HTML5 video with resize range control

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH6EX4: Basic HTML5 Video With Resize Range Control &lt;/title&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { var sizeElement = document.getElementById("videoSize")
 sizeElement.addEventListener('change', videoSizeChanged, false);
 var videoElement = document.getElementById("theVideo");
 var widthtoHeightRatio = videoElement.width/videoElement.height;

function videoSizeChanged(e) { var target = e.target; var videoElement = document.getElementById("theVideo"); videoElement.width = target.value; videoElement.height = target.value/widthtoHeightRatio;
 }
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;form&gt; Video Size: &lt;input type="range" min="80" max="1280" step="1" value="320"/&gt;
&lt;/form&gt;
 &lt;br&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;video autoplay loop controls width="320" height="240"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt; &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h2>Preloading Video in JavaScript</h2>
It is often necessary to preload a video before you do anything with it. 
This is especially true when using video with HTML5 Canvas because many times what you want to do goes beyond the simple act of playing the video.

We are going to leverage the DOM and JavaScript to create a preload architecture that can be reused and expanded upon. 
We are still not using Canvas, but this process will lead directly to it.
To do this, we must first embed the video in the HTML page in the same way we have done previously in this chapter. 
However, this time, we are going to add <code>&lt;div&gt;</code> with the id of <code>loadingStatus</code>.

<h3>Note</h3>
In practice, you probably would not display the loading status on the HTML page.
This <code>&lt;div&gt;</code> will report the percentage of the video that has loaded when we retrieve it through JavaScript:
&lt;div&gt;

&lt;video loop controls width="320" height="240" preload="auto"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;

&lt;/video&gt;
&lt;div&gt;
&lt;div&gt;
0%

&lt;/div&gt;
In JavaScript, we need to create the same type of <code>eventWindowLoaded()</code> function that we have created many times previously in this book. 
This function is called when the HTML page has finished loading. 
In <code>eventWindowLoaded()</code> we need to create two listeners for two more events that are dispatched from the <code>HTMLVideoElement</code> object:

<code>progress</code>
Dispatched when the <code>video</code> object has updated information about the loading progress of a video. 

We will use this event to update the percentage text in the <code>loadingStatus &lt;div&gt;</code>.
<code>canplaythrough</code>

Dispatched when the video has loaded enough that it can play in its entirety. 
This event will let us know when to start playing the video.

Below is the code that creates the listeners for those events:
function eventWindowLoaded() {
 var videoElement = document.getElementById("thevideo");
 videoElement.addEventListener('progress',updateLoadingStatus,false); videoElement.addEventListener('canplaythrough',playVideo,false);
}
The <code>updateLoadingStatus()</code> function is called when the <code>progress</code> event is dispatched from the <code>video</code> element. 
This function calculates the percent loaded by calculating the ratio of the already-loaded bytes (<code>videoElement.buffered.end(0)</code>) by the total bytes (<code>videoElement.duration</code>), and dividing that value by 100. 

That value is then displayed by setting the <code>innerHTML</code> property of the <code>loadingStatus &lt;div&gt;</code>, as shown in <a href="ch06.html#preloading_a_video_in_javascript" title="Figure 6-5. 
Preloading a video in JavaScript">Figure 6-5</a>. 
Remember, this is only for displaying the progress. 
We still need to do something once the video has loaded.

<h3>Note</h3>
At the time of this writing, Firefox did not support the <code>videobuffered</code> property, but this was planned for Firefox version 4.0.
function updateLoadingStatus() {
 var loadingStatus = document.getElementById("loadingStatus"); var videoElement = document.getElementById("thevideo");
 var percentLoaded = parseInt(((videoElement.buffered.end(0) / videoElement.duration) * 100)); document.getElementById("loadingStatus").innerHTML = percentLoaded + '%';
}
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893771.png.jpg" alt="Preloading a video in JavaScript" width="320" height="259">

Figure 6-5. 
Preloading a video in JavaScript
The <code>playVideo()</code> function is called when the <code>video</code> object dispatches a <code>canplaythrough</code> event. 
<code>playVideo()</code> calls the <code>play()</code> function of the <code>video</code> object, and the video starts to play:

function playVideo() {
 var videoElement = document.getElementById("thevideo");
 videoElement.play();
}

Example 6-5</a> gives the full code for preloading video.
Example 6-5. 
Basic HTML5 preloading video
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX5: Basic HTML5 Preloading Video&lt;/title&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 var videoElement = document.getElementById("thevideo"); videoElement.addEventListener('progress',updateLoadingStatus,false);
 videoElement.addEventListener('canplaythrough',playVideo,false);
}
function updateLoadingStatus() { var loadingStatus = document.getElementById("loadingStatus");
 var videoElement = document.getElementById("thevideo");
 var percentLoaded = parseInt(((videoElement.buffered.end(0) / videoElement.duration) * 100)); document.getElementById("loadingStatus").innerHTML = percentLoaded + '%';
}

function playVideo() {
 var videoElement = document.getElementById("thevideo");
 videoElement.play();
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;video loop controls width="320" height="240" preload="auto"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt;
 &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;

&lt;/video&gt;
&lt;div&gt;
&lt;div&gt;
0%

&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h3>A Problem with Events and Embedded Video in HTML5</h3>
Now that we have gone through this exercise, we have to give you some bad news. 
While the code we presented for <em>CH6EX5.html</em> works in most HTML5-compliant web browsers, the code stopped working in Google Chrome as we finished up the first draft of this book. 
This was upsetting because we used Chrome as our primary platform when developing and testing all the book’s examples.

With a bit of investigation, we discovered that Chrome was not firing the <code>canplaythrough</code> or <code>progress</code> events. 
At the same time, Firefox removed the <code>load</code> event. 
While these were anecdotal occurrences, they lead to one common truth: <em>the HTML5 specification is not finished</em>. 
This is an obvious but important fact to note. 

If you are developing for HTML5 or Canvas, you are developing with a moving target.
Specifically in <em>CH6EX5.html</em>, we found that the process of embedding the <code>&lt;video&gt;</code> tag in the HTML page was the reason why the events weren’t firing in Chrome. 
In order to make this example work in Chrome, you need to add a call to <code>playVideo()</code> in the <code>eventWindowLoaded()</code> function, like this:
function eventWindowLoaded() { var videoElement = document.getElementById("thevideo");
 videoElement.addEventListener('progress',updateLoadingStatus,false);
 videoElement.addEventListener('canplaythrough',playVideo,false);
 playVideo()

}
However, this code will not solve the core problem: we need a reliable way to know when a video has finished loading so we can use it on the canvas. 
In Example 6-6</a>, we will show you a way to make that happen.
<h2>Video and the Canvas</h2>
The HTML <code>video</code> object already has a <code>poster</code> property for displaying an image before the video starts to play, as well as functions to <code>autoplay</code> and <code>loop</code>. 
So why is it necessary to preload the video? Well, as we alluded to in the previous section, simply playing a video is one thing—manipulating it with HTML5 Canvas is quite another. 
If you want to start manipulating video while it is displayed on the canvas, you first need to make sure it is loaded.
In this section, we will load video and then manipulate it in various ways so you can see how powerful Canvas can be when it is mixed with other HTML5 elements.

<h3>Displaying a Video on HTML5 Canvas</h3>
First, we must learn the basics of displaying video on HTML5 Canvas. 
There are a few important things to note that are not immediately obvious when you start working with video and the canvas. 
We worked through them so you don’t have to do it yourself (you’re welcome).

<h4>Video must still be embedded in HTML</h4>
Even though the video is only displayed on HTML5 Canvas, you still need a <code>&lt;video&gt;</code> tag in HTML. 
The key is to put the video in a <code>&lt;div&gt;</code> (or a similar construct), and set the <code>display</code> CSS style property of that <code>&lt;div&gt;</code> to <code>none</code> in HTML. 
This will ensure that while the video is loaded in the page, it is not displayed. 

If we wrote the code in HTML, it might look like this:
&lt;div&gt;
&lt;video loop controls width="320" height="240" preload="auto"&gt;
 &lt;source src="muirbeach.mp4" type='video/mp4; codecs="avc1.42E01E, mp4a.40.2"' &gt; &lt;source src="muirbeach.webm"type='video/webm; codecs="vp8, vorbis"' &gt;
 &lt;source src="muirbeach.ogg" type='video/ogg; codecs="theora, vorbis"'&gt;
&lt;/video&gt;
However, we already know that we don’t want to use an HTML embed. 

As we stated at the end of the last section, <code>video</code> events do not appear to fire reliably when <code>video</code> elements are embedded in the HTML page. 
For this reason, we need a new strategy to load video dynamically—we’ll create the <code>&lt;div&gt;</code> and <code>&lt;video&gt;</code> elements in JavaScript.
The first thing we do in our JavaScript is add a couple variables to hold references to the dynamic HTML elements we will create. 
The <code>videoElement</code> variable will hold the dynamically created <code>&lt;video&gt;</code> tag, while <code>videoDiv</code> will hold the dynamically created <code>&lt;div&gt;</code>:

var videoElement;
var videoDiv;
<h3>Note</h3>
We use this method to create global variables throughout this chapter. 

There are many reasons not to use global variables, but for these simple applications, it’s the quickest way to get something on the canvas. 
If you want to learn a better way to handle loading assets, the last section of <a href="ch07.html" title="Chapter 7. 
Working with Audio">Chapter 7</a> employs a strategy to preload assets without the use of global variables.
Next, we create our dynamic form elements in the <code>eventWindowLoaded()</code> function. 

First, we use the <code>createElement()</code> method of the document DOM object to create a <code>&lt;video&gt;</code> element and a <code>&lt;div&gt;</code> element, placing references to them in the variables we just created:
function eventWindowLoaded() {
 videoElement = document.createElement("video");
 videoDiv = document.createElement('div'); document.body.appendChild(videoDiv);
Next, we add <code>videoElement</code> as a child of <code>videoDiv</code>, essentially putting it inside of that <code>&lt;div&gt;</code> on the HTML page. 
We then set the style attribute of <code>&lt;div&gt;</code> to <code>display:none;</code>, which will make it invisible on the HTML page. 
We do this because although we want the video to display on the canvas, we don’t want to show it on the HTML page: videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "display:none;");
We then create another new variable named <code>videoType</code> that holds the results of a new function we will create, <code>supportedVideoFormat()</code>. 
This function returns the file extension of the supported video format for the browser; otherwise, it returns <code>“”</code> (an empty string), which means we alert the user that there is no video support in the app for his browser: var videoType = supportedVideoFormat(videoElement);
 if (videoType == "") { alert("no video support"); return;
 }
Finally, we set the <code>src</code> property of the <code>video</code> element using the file extension we just received from <code>supportedVideoFormat()</code>, and create the event handler for the <code>canplaythrough</code> event: videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);
}
When the video has finished loading, the <code>videoLoaded</code> event handler is called, which in turn calls the <code>canvasApp()</code> function:

function videoLoaded(event) {
 canvasApp();
}
Before the code in the last section will work, we need to define the <code>supportedVideo</code><code>Format()</code> function. 

The reason for this function is simple: since we are adding <code>video</code> objects dynamically to the HTML page, we do not have a way to define multiple <code>&lt;source&gt;</code> tags. 
Instead, we are going to use the <code>canPlayType()</code> method of the <code>video</code> object to tell us which type of audio file to load.
The <code>canPlayType()</code> method takes a single parameter, a MIME type. 
It returns a text string of <code>maybe</code>, <code>probably</code>, or nothing (an empty string).

<code>“”</code> (nothing)
This is returned if the browser knows the type cannot be rendered.

<code>maybe</code>
This is returned if the browser does not confidently know that the type can be displayed.

<code>probably</code>
This is returned if the browser knows the type can be displayed using an <code>audio</code> or <code>video</code> element.

We are going to use these values to determine which media type to load and play. 
For the sake of this exercise, we will assume that both <code>maybe</code> and <code>probably</code> equate to <code>yes</code>. 

If we encounter either result with any of our three MIME types (<em>video/webm</em>, <em>video/mp4</em>, <em>video/ogg</em>), we will return the extension associated with that MIME type so the sound file can be loaded.
In the function below, <code>video</code> represents the instance of <code>HTMLVideoElement</code> that we are going to test. 
The <code>returnExtension</code> variable represents that valid extension for the first MIME type found that has the value of <code>maybe</code> or <code>probably</code> returned from the call to <code>canPlayType()</code>:
function supportedVideoFormat(video) { var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm";
 } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg"; }
 return returnExtension;
}
We do not check for a condition when no valid video format is found and the return value is “”. 

If that is the case, the code that has called this function might need to be written in a way to catch that condition and alter the program execution. 
We did that with the test of the <code>return</code> value and <code>alert()</code>, which we described previously.
<h4>Video is displayed like an image</h4>
When you write code to display a video on the canvas, you use the <code>context.drawImage()</code> function, as though you are displaying a static image. 

Don’t go looking for a <code>drawVideo()</code> function in the HTML5 Canvas spec because you won’t find it. 
The following code will display a video stored in a variable named <code>videoElement</code>, displayed at the <code>x</code>,<code>y</code> position of <code>85</code>,<code>30</code>:
context.drawImage(videoElement , 85, 30);
However, when you draw a video for the first time, you will notice that it will not move—it stays on the first frame. 

At first you might think you have done something wrong, but you have not. 
You just need to add one more thing to make it work.
<h4>Set an interval to update the display</h4>
Just like when we discussed animation in the previous chapters, a video placed on HTML5 Canvas using <code>drawImage()</code> will not update itself. 

You need to call <code>drawImage()</code> in some sort of loop to continually update the image with new data from the playing video in the HTML page (hidden or not). 
To do this, we call the video’s <code>play()</code> method, and then use <code>setInterval()</code> to call the <code>drawScreen()</code> function every 33 milliseconds. 
This will give you about 30 frames per second (FPS). 
We put this code in our <code>canvasApp()</code> function, which is called after we know the video has loaded:

videoElement.play();
setInterval(drawScreen, 33);
In <code>drawScreen()</code>, we will call <code>drawImage()</code> to display the video, but since it will be called every 33 milliseconds, the video will be updated and play on the canvas:
function drawScreen () { context.drawImage(videoElement , 85, 30);
 }
Example 6-6</a> gives the full code for displaying a video on the canvas and updating it using <code>setInterval()</code>. 
<a href="ch06.html#displaying_a_video_on_html5_canvas-id1" title="Figure 6-6. 

Displaying a video on HTML5 Canvas">Figure 6-6</a> shows this code in the browser.
Example 6-6. 
Basic HTML5 loading video onto the canvas
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX6: Basic HTML5 Load Video Onto The Canvas&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var videoElement;

var videoDiv;
function eventWindowLoaded() {
 videoElement = document.createElement("video");
 videoDiv = document.createElement('div'); document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement); if (videoType == "") { alert("no video support"); return;
 }
 videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);

}
function supportedVideoFormat(video) {
 var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm"; } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function videoLoaded(event) { canvasApp();
}
function canvasApp() {
 if (!canvasSupport()) { return; }

function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video context.drawImage(videoElement , 85, 30);
 }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 videoElement.play();
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893773.png.jpg" alt="Displaying a video on HTML5 Canvas" width="543" height="340">
Figure 6-6. 

Displaying a video on HTML5 Canvas
<h3>HTML5 Video Properties</h3>
We have already talked about some properties of <code>HTMLVideoElement</code> (inherited from <code>HTMLMediaElement</code>), but now that we have a video loaded onto the canvas, it would be interesting to see them in action.
In this example, we are going to display seven properties of a playing video, taken from the <code>HTMLVideoElement</code> object: <code>duration</code>, <code>currentTime</code>, <code>loop</code>, <code>autoplay</code>, <code>muted</code>, <code>controls</code>, and <code>volume</code>. 

Of these, <code>duration</code>, <code>loop</code>, and <code>autoplay</code> will not update because they are set when the video is embedded. 
Also, since we call the <code>play()</code> function of the video after it is preloaded in JavaScript, <code>autoplay</code> may be set to <code>false</code>, but the video will play anyway. 
The other properties will update as the video is played.
To display these values on the canvas, we will draw them as text in the <code>drawScreen()</code> function called by <code>setInterval()</code>. 

Below is the <code>drawScreen()</code> that we have created to display these values:
function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video context.drawImage(videoElement , 85, 30); // Text context.fillStyle = "#000000"; context.fillText ("Duration:" + videoElement.duration, 10 ,280); context.fillText ("Current time:" + videoElement.currentTime, 260 ,280); context.fillText ("Loop: " + videoElement.loop, 10 ,290); context.fillText ("Autoplay: " + videoElement.autoplay, 100 ,290); context.fillText ("Muted: " + videoElement.muted, 180 ,290); context.fillText ("Controls: " + videoElement.controls, 260 ,290); context.fillText ("Volume: " + videoElement.volume, 340 ,290);
 }

<a href="ch06.html#video_on_the_canvas_with_properties_disp" title="Figure 6-7. 
Video on the canvas with properties displayed and &lt;video&gt; embed">Figure 6-7</a> shows what the attributes look like when displayed on the canvas. 
Notice that we have placed the <code>&lt;video&gt;</code> embed next to the canvas, and we have <em>not</em> set the CSS display style to <code>none</code>. 
We did this to demonstrate the relationship between the video embedded in the HTML page and the one playing on the canvas. 

If you roll over the video in the HTML page, you can see the control panel. 
If you set the volume, you will notice that the <code>volume</code> attribute displayed on the canvas will change. 
If you pause the embedded video, the video on the canvas will stop playing, and the <code>currentTime</code> value will stop.
This demo should give you a very good idea of the relationship between the video on the canvas and the one embedded with the <code>&lt;video&gt;</code> tag. 

Even though they are displayed using completely different methods, they are in fact one and the same.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893775.png.jpg" alt="Video on the canvas with properties displayed and &lt;video&gt; embed" width="913" height="340">
Figure 6-7. 
Video on the canvas with properties displayed and &lt;video&gt; embed

You can see Example 6-7</a> in action by executing <em>CH6EX7.html</em> from the code distribution.
Example 6-7. 
Video properties
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX7: Video Properties&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var videoElement;

var videoDiv;
function eventWindowLoaded() {
 videoElement = document.createElement("video");
 var videoDiv = document.createElement('div'); document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "position: absolute; top: 50px; left: 600px; ");
 var videoType = supportedVideoFormat(videoElement); if (videoType == "") { alert("no video support"); return;
 }
 videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);

}
function supportedVideoFormat(video) {
 var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm"; } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function videoLoaded() { canvasApp();
}
function canvasApp() {
 if (!canvasSupport()) { return; } function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video context.drawImage(videoElement , 85, 30); // Text context.fillStyle = "#000000"; context.fillText ("Duration:" + videoElement.duration, 10 ,280); context.fillText ("Current time:" + videoElement.currentTime, 260 ,280); context.fillText ("Loop: " + videoElement.loop, 10 ,290); context.fillText ("Autoplay: " + videoElement.autoplay, 100 ,290); context.fillText ("Muted: " + videoElement.muted, 180 ,290); context.fillText ("Controls: " + videoElement.controls, 260 ,290); context.fillText ("Volume: " + videoElement.volume, 340 ,290);
 }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 videoElement.play();
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Note</h3>
You can see all the events and properties for the <code>HTMLVideoElement</code> at <a href="http://www.w3.org/2010/05/video/mediaevents.html">http://www.w3.org/2010/05/video/mediaevents.html</a>.

<h2>Video on the Canvas Examples</h2>
In the last section, we learned that the video playing on the canvas and the video embedded with the <code>&lt;video&gt;</code> tag are, in fact, the same video. 
It took a lot more code to play the video on the canvas than it did to embed and play the video in JavaScript. 
So, this begs the question: <em>why load video onto the canvas at all?</em>

Well, sometimes simply displaying a video and playing it is not enough. 
You might want events to occur as the video is playing, or perhaps you want to use transformations on it, use it in a game, create custom video controls, or animate it and move it on the canvas.
The following five examples will show you in very specific detail why the canvas can be an exciting way to display video.
<h3>Using the currentTime Property to Create Video Events</h3>

The first way we will use video in conjunction with Canvas is to use the <code>currentTime</code> property of a playing video to trigger events. 
Recall that the <code>currentTime</code> property is updated as the video plays, and it shows the video’s elapsed running time.
For our example, we are going to create a dynamic object in JavaScript containing the following properties:

<code>time</code>
The elapsed time to trigger the event

<code>message</code>
A text message to display on the canvas

<code>x</code>
The <code>x</code> position of the text message

<code>y</code>
The <code>y</code> position of the text message

First, we will create an array of these objects and place them into a variable named <code>messages</code>. 
We will then create four events (messages that will appear) that will take place at the elapsed <code>currentTime</code> of <code>0</code>, <code>1</code>, <code>4</code>, and <code>8</code> seconds:
var messages = new Array(); messages[0] = {time:0,message:"", x:0 ,y:0};
 messages[1] = {time:1,message:"This Is Muir Beach!", x:90 ,y:200};
 messages[2] = {time:4,message:"Look At Those Waves!", x:240 ,y:240};
 messages[3] = {time:8,message:"Look At Those Rocks!", x:100 ,y:100};

To display the messages, we will call a <code>for:next</code> loop inside our <code>drawScreen()</code> function. 
Inside the loop, we test each message in the <code>messages</code> array to see whether the <code>currentTime</code> property of the video is greater than the <code>time</code> property of the message. 
If so, we know that it is OK to display the message. 
We then display the message on the canvas using the <code>fillStyle</code> property and <code>fillText()</code> function of the Canvas context, producing the results shown in <a href="ch06.html#canvas_video_displaying_text_overlay_eve" title="Figure 6-8. 

Canvas video displaying text overlay events">Figure 6-8</a>:
for (var i = 0; i &lt; messages.length ; i++) { var tempMessage = messages[i]; if (videoElement.currentTime &gt; tempMessage.time) { context.font = "bold 14px sans"; context.fillStyle = "#FFFF00"; context.fillText (tempMessage.message, tempMessage.x ,tempMessage.y); } }
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893777.png.jpg" alt="Canvas video displaying text overlay events" width="543" height="340">
Figure 6-8. 

Canvas video displaying text overlay events
Of course, this is a very simple way to create events. 
The various text messages will not disappear after others are created, but that is just a small detail. 
The point of this exercise is that, with code like this, you could do almost anything with a running video. 

You could pause the video, show an animation, and then continue once the animation is done. 
Or you could pause to ask the user for input and then load a different video. 
Essentially, you can make the video completely interactive in any way you choose. 
The model for these events could be very similar to the one we just created.

Example 6-8</a> provides the full code listing for this application.
Example 6-8. 
Creating simple video events
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX8: Creating Simple Video Events&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var videoElement;

var videoDiv;
function eventWindowLoaded() {
 videoElement = document.createElement("video");
 videoDiv = document.createElement('div'); document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement); if (videoType == "") { alert("no video support"); return;
 }
 videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);

}
function supportedVideoFormat(video) {
 var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm"; } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function videoLoaded() { canvasApp();
}
function canvasApp() {
 if (!canvasSupport()) { return; } function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video context.drawImage(videoElement , 85, 30); // Text context.fillStyle = "#000000"; context.font = "10px sans"; context.fillText ("Duration:" + videoElement.duration, 10 ,280); context.fillText ("Current time:" + videoElement.currentTime, 260 ,280); context.fillText ("Loop: " + videoElement.loop, 10 ,290); context.fillText ("Autoplay: " + videoElement.autoplay, 80 ,290); context.fillText ("Muted: " + videoElement.muted, 160 ,290); context.fillText ("Controls: " + videoElement.controls, 240 ,290); context.fillText ("Volume: " + videoElement.volume, 320 ,290);
 //Display Message for (var i =0; i &lt; messages.length ; i++) { var tempMessage = messages[i]; if (videoElement.currentTime &gt; tempMessage.time) { context.font = "bold 14px sans"; context.fillStyle = "#FFFF00"; context.fillText (tempMessage.message, tempMessage.x ,tempMessage.y); } }
 } var messages = new Array();
 messages[0] = {time:0,message:"", x:0 ,y:0};
 messages[1] = {time:1,message:"This Is Muir Beach!", x:90 ,y:200};
 messages[2] = {time:4,message:"Look At Those Waves!", x:240 ,y:240}; messages[3] = {time:8,message:"Look At Those Rocks!", x:100 ,y:100};
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 videoElement.play(); setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h3>Canvas Video Transformations: Rotation</h3>
Showing a static video on the screen is one thing, but transforming it on the screen using alpha transparency and rotations is quite another. 
These types of transformations can be easily applied to video on the canvas in much the same way as you would apply them to an image or a drawing object.
In this example, we will create a video that rotates clockwise. 

To achieve this effect, we first create a variable, <code>rotation</code>, which we will use to hold the current values of the rotation property that we will apply to the video. 
We create this variable outside of the <code>drawScreen()</code> function, inside <code>canvasApp()</code>:
var rotation = 0;
The <code>drawScreen()</code> function is where all the real action takes place for this example. 

First, we need to save the current canvas context so we can restore it after we perform the transformation. 
We covered this in depth in <a href="ch02.html" title="Chapter 2. 
Drawing on the Canvas">Chapter 2</a>, but here’s a quick refresher. 
Transformations on the canvas are global in nature, which means they affect <em>everything</em>. 

Since the canvas works in immediate mode, there is no stack of objects to manipulate. 
Instead, we need to save the canvas context before the transformation, apply the transformation, and then restore the saved context afterward.
First, we save it:
context.save();

Next, we reset the context transformation to the identity, which clears anything that was set previously:
context.setTransform(1,0,0,1,0,0);
Then we need to set up some variables that will be used for the rotation calculation. 
The <code>x</code> and <code>y</code> variables set the upper-left location of the video on the canvas. 

The <code>videoWidth</code> and <code>videoHeight</code> variables will be used to help rotate the video from the center:
var x = 100;
var y = 100;
var videoWidth=320;

var videoHeight=240;
Now it is time to use the <code>rotation</code> variable, which represents the angle that we rotated the video on the canvas. 
It starts at <code>0</code>, and we will increase it every time <code>drawScreen()</code> is called. 
However, the <code>context.rotate()</code> method requires an angle to be converted to radians when passed as its lone parameter. 

The following line of code converts the value in the <code>rotation</code> variable to radians, and stores it in a variable named <code>angleInRadians</code>:
var angleInRadians = rotation * Math.PI / 180;
We need to find the video’s center on the canvas so we can start our rotation from that point. 
We find the <code>x</code> value by taking our <code>videoX</code> variable and adding half the width of the video. 

We find the <code>y</code> value by taking our <code>videoY</code> variable and adding half the height of the video. 
We supply both of those values as parameters to the <code>context.translate()</code> function so the rotation will begin at that point. 
We need to do this because we are not rotating the video object—we are rotating the entire canvas in relation to the displayed video:
context.translate(x+.5*videoWidth, y+.5*videoHeight);

The rest of the code is really straightforward. 
First, we call the <code>rotate()</code> function of the context, passing our angle (converted to radians) to perform the rotation:
context.rotate(angleInRadians);
Then we call <code>drawImage()</code>, passing the video object, and the <code>x</code>,<code>y</code> positions of where we want the video to be displayed. 

This is a bit tricky but should make sense. 
Since we used the <code>context.translate()</code> function to move to the center of the video, we now need to place it in the upper-left corner. 
To find that corner, we need to subtract half the width to find the <code>x</code> position, and half the height to find the <code>y</code> position:
context.drawImage(videoElement ,-.5*videoWidth, -.5*videoHeight);

Finally, we restore the canvas we saved before the transformation started, and we update the <code>rotation</code> variable so that we will have a new angle on the next call to <code>drawScreen()</code>:
context.restore();
rotation++;
Now the video should rotate at <code>1</code> degree clockwise per call to <code>drawScreen()</code> while fading onto the canvas. 

You can easily increase the speed of the rotation by changing the value that you input for the <code>rotation</code> variable in the last line in the <code>drawScreen()</code> function.
Here is the code for the final <code>drawScreen()</code> function for this example:
function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video //*** Start rotation calculation context.save(); context.setTransform(1,0,0,1,0,0);  var angleInRadians = rotation * Math.PI / 180; var x = 100; var y = 100; var videoWidth=320; var videoHeight=240; context.translate(x+.5*videoWidth, y+.5*videoHeight); context.rotate(angleInRadians); //**** context.drawImage(videoElement ,-.5*videoWidth, -.5*videoHeight); //*** restore screen context.restore(); rotation++; //***
}
<a href="ch06.html#canvas_video_rotation" title="Figure 6-9. 
Canvas video rotation">Figure 6-9</a> shows what the video will look like when rotating on the canvas. 

You can see the full code for this in Example 6-9</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893779.png.jpg" alt="Canvas video rotation" width="543" height="540">
Figure 6-9. 
Canvas video rotation

Example 6-9. 
Rotating a video
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX9: Video Rotation Transform&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var videoElement;
var videoDiv;

function eventWindowLoaded() {
 videoElement = document.createElement("video");
 videoDiv = document.createElement('div');
 document.body.appendChild(videoDiv); videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement);
 if (videoType == "") { alert("no video support"); return; }
 videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);
}

function supportedVideoFormat(video) {
 var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm";
 } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4"; } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 }
 return returnExtension;
}

function canvasSupport () { return Modernizr.canvas;
}
function videoLoaded() {
 canvasApp();

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 //*** set rotation value var rotation = 0;
 //***
 function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width-10, theCanvas.height-10); //video //*** Start rotation calculation context.save(); context.setTransform(1,0,0,1,0,0);  var angleInRadians = rotation * Math.PI / 180; var x = 100; var y = 100; var videoWidth=320; var videoHeight=240; context.translate(x+.5*videoWidth, y+.5*videoHeight); context.rotate(angleInRadians); //**** context.drawImage(videoElement ,-.5*videoWidth, -.5*videoHeight); //*** restore screen context.restore(); rotation++; //***
 }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d"); videoElement.setAttribute("loop", "true"); videoElement.play();
 setInterval(drawScreen, 33);
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Canvas Video Puzzle</h3>
Now we arrive at the most involved example of this section. 
We are going to create a puzzle game based on the video we have displayed on the canvas, illustrated in <a href="ch06.html#video_puzzle" title="Figure 6-10. 

Video puzzle">Figure 6-10</a>. 
Here are the steps showing how the game will operate:
We will load the video onto the canvas but not display it.
We will decide how many parts we want to be in our puzzle.

We will create a <code>board</code> array that holds all the puzzle pieces.
The pieces will be displayed in a 4×4 grid.
We will randomize the pieces on the board to mix up the puzzle.
We will add an event listener for the mouse button.

We will set an interval to call <code>drawScreen()</code>.
We will wait for the user to click a puzzle piece.
While we are waiting, the various parts of the video will play just as though they were one video.
When a user clicks a puzzle piece, it will highlight in yellow.

If the user has selected two pieces, we will swap their positions.
The user will attempt to put the puzzle back together so she can see the video as it was created.
</li>
</ol>

<h4>Setting up the game</h4>
To start, we are going to set up some variables that will define the game’s playfield. 
Here is a rundown of the variables and how they will be used:

<code>rows</code>
The numbers of rows in the grid of puzzle pieces

<code>cols</code>
The number of columns in the grid of puzzle pieces

<code>xPad</code>
The space, in pixels, between each column

<code>yPad</code>
The space, in pixels, between each row

<code>startXOffset</code>
The number of pixels from the left of the canvas to the location where we will start drawing the grid of puzzle pieces

<code>startYOffset</code>
The number of pieces from the top of the canvas to the location where we will start drawing the grid of puzzle pieces

<code>partWidth</code>
The width of each puzzle piece

<code>partHeight</code>
The height of each puzzle piece

<code>board</code>
A two-dimensional array that holds the puzzle pieces

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893781.png.jpg" alt="Video puzzle" width="413" height="340">
Figure 6-10. 
Video puzzle

The following code includes values for each variable:
var rows = 4;
var cols = 4;
var xPad = 10;

var yPad = 10;
var startXOffset = 10;
var startYOffset = 10;
var partWidth = videoElement.width/cols;

var partHeight = videoElement.height/rows;
var board = new Array();
Next we need to initialize the <code>board</code> array and fill it with some dynamic objects that represent each piece of the puzzle. 
We loop through the number of <code>cols</code> in the board and create <code>rows</code> amount of dynamic objects in each one. 

The dynamic objects we are creating have these properties:
<code>finalCol</code>

The final column-resting place of the piece when the puzzle is complete. 
We use this value to figure out what part of the video cut out to make this piece.
<code>finalRow</code>

The final row-resting place of the piece when the puzzle is complete. 
We use this value to figure out what part of the video cut out to make this piece.

<code>selected</code>
A Boolean that is initially set to <code>false</code>. 
We will use this to see whether we should highlight a piece or switch two pieces when the user clicks a piece.

Notice that we use two nested <code>for:next</code> loops to fill the <code>board</code> array with these objects. 
Familiarize yourself with this construct because we use it many times in this game. 

Two nested loops used like this are particularly useful for games and apps that require a 2D grid in order to be displayed and manipulated:
for (var i = 0; i &lt; cols; i++) { board[i] = new Array(); for (var j =0; j &lt; rows; j++) { board[i][j] = { finalCol:i,finalRow:j,selected:false }; }
}
Now that we have the <code>board</code> array initialized, we call <code>randomizeBoard()</code> (we will discuss this function shortly), which mixes up the puzzle by randomly placing the pieces on the screen. 

We finish the setup section of the game by adding an event listener for the <code>mouseup</code> event (when the user releases the mouse button), and by setting an interval to call <code>drawScreen()</code> every 33 milliseconds:
board = randomizeBoard(board);
theCanvas.addEventListener("mouseup",eventMouseUp, false);
setInterval(drawScreen, 33);

<h4>Randomizing the puzzle pieces</h4>
The <code>randomizeBoard()</code> function requires you to pass in the <code>board</code> variable so we can operate on it. 
We’ve set up the function this way so it will be portable to other applications.
To randomize the puzzle pieces, we first need to set up an array named <code>newBoard</code> that will hold the randomized puzzle pieces. 

<code>newBoard</code> will be what we call a <em>parallel array</em>. 
Its purpose is to become the original array—but randomized. 
We then create a local <code>cols</code> variable and initialize it to the length of the <code>board</code> array that was passed in to the function, and a local <code>rows</code> variable, initialized to the length of the first column—<code>board[0]</code>—in the array. 
This works because all of our rows and columns are the same length, so the number of rows in the first column is the same as all the others. 

We now have the building blocks required to randomize the pieces:
function randomizeBoard(board) { var newBoard = new Array(); var cols = board.length; var rows = board[0].length
Next, we loop through every column and row, randomly choosing a piece from the <code>board</code> array and moving it into <code>newBoard</code>:
 for (var i = 0; i &lt; cols; i++) {

<h3>Note</h3>
We use two nested <code>for:next</code> loops here once again.
Every time we come to an iteration of the outer nested loop, we create a new array that we will fill up in the second nested loop. 
Then we drop into that nested loop. 

The <code>found</code> variable will be set to <code>true</code> when we have found a random location to place the piece in the <code>newBoard</code> array. 
The <code>rndRow</code> and <code>rndCol</code> variables hold the random values we will create to try and find a random location for the puzzle pieces:
newBoard[i] = new Array(); for (var j =0; j &lt; rows; j++) { var found = false; var rndCol = 0; var rndRow = 0;
Now we need to find a location in <code>newBoard</code> in which to put the puzzle piece from the <code>board</code> array. 

We use a <code>while()</code> loop that continues to iterate as long as the <code>found</code> variable is <code>false</code>. 
To find a piece to move, we randomly choose a row and column, and then use them to see whether that space (<code>board[rndCol][rndRow]</code>) is set to <code>false</code>. 
If it is not <code>false</code>, we have found a piece to move to the <code>newBoard</code> array. 
We then set <code>found</code> equal to <code>true</code> so we can get out of the <code>while()</code> loop and move to the next space in <code>newBoard</code> that we need to fill: while (!found) { var rndCol = Math.floor(Math.random() * cols); var rndRow = Math.floor(Math.random() * rows); if (board[rndCol][rndRow] != false) { found = true; } }
Finally, we move the piece we found in <code>board</code> to the current location we are filling in <code>newBoard</code>. 
Then, we set the piece in the <code>board</code> array to <code>false</code> so that when we test for the next piece, we won’t try to use the same piece we just found. 
When we are done filling up <code>newBoard</code>, we return it as the newly randomized array of puzzle pieces: newBoard[i][j] = board[rndCol][rndRow]; board[rndCol][rndRow] = false; }
 }
 return newBoard;
 }

<h4>Drawing the screen</h4>
The <code>drawScreen()</code> function is the heart of this application. 
It is called on an interval, and then used to update the video frames and to draw the puzzle pieces on the screen. 
A good portion of <code>drawScreen()</code> looks like applications we have built many times already in this book. 

When it begins, we draw the background and a bounding box on the screen:
function drawScreen () {
 //Background context.fillStyle = '#303030'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#FFFFFF'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
However, the primary work of this function is—you guessed it—another set of two nested <code>for:next</code> loops that draw the puzzle pieces onto the canvas. 

This set needs to do three things:
Draw a grid of puzzle pieces on the canvas based on their placement in the <code>board</code> two-dimensional array.
Find the correct part of the video to render for each piece based on the <code>finalCol</code> and <code>finalRow</code> properties we set in the dynamic object for each piece.
Draw a yellow box around the piece that has its <code>selected</code> property set to <code>true</code>.

</li>
</ol>
We start our loop by finding the <code>x</code> and <code>y</code> (<code>imageX</code>, <code>imageY</code>) locations to “cut” the puzzle piece from the video object. 
We do this by taking the <code>finalRow</code> and <code>finalCol</code> properties of the dynamic piece objects we created, and multiplying them by the <code>partWidth</code> and <code>partHeight</code>, respectively. 

We then have the origin point (top-left <code>x</code> and <code>y</code> locations) for the piece of the video to display:
for (var c = 0; c &lt; cols; c++) {
 for (var r = 0; r &lt; rows; r++) {
 var tempPiece = board[c][r]; var imageX = tempPiece.finalCol*partWidth; var imageY = tempPiece.finalRow*partHeight;

Now that we know the origin point of the video we will display for a particular piece of the puzzle, we need to know where it will be placed on the canvas. 
While the code below might look confusing, it’s really just simple arithmetic. 
To find the <code>x</code> location (<code>placeX</code>) of a piece, multiply the <code>partWidth</code> times the current iterated column (<code>c</code>), then add the current iterated column multiplied by the <code>xPad</code> (the number of pixels between each piece), and add the <code>startXOffset</code>, which is the <code>x</code> location of the upper-left corner of the entire board of pieces. 
Finding <code>placeY</code> is very similar, but you use the current row (<code>r</code>), <code>yPad</code>, and <code>partHeight</code> in the calculation:

var placeX = c*partWidth+c*xPad+startXOffset;
var placeY = r*partHeight+r*yPad+startYOffset;
Now it’s time to draw the piece on the canvas. 
We need to “cut” out the part of the video that we will display for each piece of the puzzle (we won’t actually cut anything though). 

We will again use the <code>drawImage()</code> function, as we have many other times already. 
However, now we use the version of <code>drawImage()</code> that accepts nine parameters:
<code>videoElement</code>

The image that we are going to display; in this case, it is the video.
<code>imageX</code>

The <code>x</code> location of the upper-right order of the part of the image to display.
<code>imageY</code>

The <code>y</code> location of the upper-right order of the part of the image to display.
<code>partWidth</code>

The width from the <code>x</code> location of the rectangle to display.
<code>partHeight</code>

The height from the <code>y</code> location of the rectangle to display.
<code>placeX</code>

The <code>x</code> location to place the image on the canvas.
<code>placeY</code>

The <code>y</code> location to place the image on the canvas.
<code>partWidth</code>

The width of the image as displayed on the canvas.
<code>partHeight</code>

The height of the image as displayed on the canvas.

We’ve already discussed how we calculated most of these values, so it is just a matter of knowing the <code>drawImage()</code> API function and plugging in the variables:
context.drawImage(videoElement, imageX, imageY, partWidth, partHeight, placeX, placeY, partWidth, partHeight);
There is one last thing we are going to do in this function. 
If a puzzle piece is marked as “selected” (the <code>selected</code> Boolean property is <code>true</code>), we will draw a yellow box around the piece: if (tempPiece.selected) {
 context.strokeStyle = '#FFFF00'; context.strokeRect( placeX, placeY, partWidth, partHeight);
 } }
 }

}
<h4>Detecting mouse interactions and the canvas</h4>
Recall that back in the <code>canvasApp()</code> function, we set an event listener for the <code>mouseup</code> action with the event handler function set to <code>eventMouseUp</code>. 
We now need to create that function:

theCanvas.addEventListener("mouseup",eventMouseUp, false);
The first thing we do in the <code>eventMouseUp()</code> function is test to find the <code>x</code> and <code>y</code> locations of the mouse pointer when the button was pressed. 
We will use those coordinates to figure out whether the user clicked on any of the puzzle pieces.
Since some browsers support the <code>layerX</code>/<code>layerY</code> properties of the event object, and others support the <code>offsetX</code>/<code>offsetY</code> properties, we need to support both. 

No matter which one is set, we will use those properties to set our <code>mouseX</code> and <code>mouseY</code> variables to the <code>x</code> and <code>y</code> locations of the mouse pointer:
function eventMouseUp(event) {
 var mouseX; var mouseY; var pieceX; var pieceY; if ( event.layerX || event.layerX == 0) { //Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; }
<h4>Creating hit test point-style collision detection</h4>

Now that we know where the user clicked, we need to test whether that location “hits” any of the puzzle pieces. 
If so, we set the <code>selected</code> property of that piece to <code>true</code>. 
What we are going to perform is a simple <em>hit test point</em>-style hit detection. 
It will tell us whether the <code>x</code>,<code>y</code> position (<em>point</em>) of the mouse is inside (<em>hits</em>) any one of the puzzle pieces when the mouse button is clicked.

First, we create a local variable named <code>selectedList</code> that we will use when we need to swap the pieces in the <code>board</code> array. 
Next, we will use a set of two nested <code>for:next</code> loops to traverse through all the pieces in the <code>board</code> array. 
Inside the <code>for:next</code> loops, the first thing we do is find the top-left corner <code>x</code> and <code>y</code> points of the current piece pointed to by <code>board[c][r]</code>. 
We calculate those values and put them into the <code>placeX</code> and <code>placeY</code> variables: var selectedList= new Array(); for (var c = 0; c &lt; cols; c++) {
 for (var r =0; r &lt; rows; r++) { pieceX = c*partWidth+c*xPad+startXOffset; pieceY = r*partHeight+r*yPad+startYOffset;
Next, we use those calculated values to test for a hit test point collision. 
We do this with a semicomplicated <code>if:then</code> statement that tests the following four conditions simultaneously:

<code>mouseY &gt;= pieceY</code>
The mouse pointer lies lower than or equal to the top of the piece.

<code>mouseY &lt;= pieceY+partHeight</code>
The mouse pointer lies above or equal to the bottom of the piece.

<code>mouseX &gt;= pieceX</code>
The mouse pointer lies to the right or equal to the left side of the piece.

<code>mouseX &lt;= pieceX+partWidth</code>
The mouse pointer lies to the left or equal to the right side of the piece.

All of the above conditions must evaluate to <code>true</code> for a hit to be registered on any one piece on the board:
if ( (mouseY &gt;= pieceY) &amp;&amp; (mouseY &lt;= pieceY+partHeight) &amp;&amp; (mouseX &gt;= pieceX) &amp;&amp; (mouseX &lt;= pieceX+partWidth) ) {

If all these conditions are true, we set the selected property of the piece object to <code>true</code> if it was already <code>false</code>, or we set it to <code>false</code> if it was already <code>true</code>. 
This allows the user to “deselect” the selected piece if he has decided not to move it:
 if ( board[c][r].selected) { board[c][r].selected = false;
 } else { board[c][r].selected = true; }
}
At the end of the nested <code>for:next</code> loop, we make sure to test each piece to see whether its <code>selected</code> property is <code>true</code>. 
If so, we push it into the <code>selectedList</code> local array so we can perform the swap operation on the pieces: if (board[c][r].selected) { selectedList.push({col:c,row:r})
 }
 }
}

<h4>Swapping two elements in a two-dimensional array</h4>
Now we need to test to see whether two pieces have been marked as <code>selected</code>. 
If so, we swap the positions of those pieces. 
In this way, it appears that the player is clicking on puzzle pieces and changing their locations to try to solve the puzzle.

To achieve the swap, we use a classic <em>three-way swap</em> programming construct utilizing a temporary variable, <code>tempPiece1</code>, as a placeholder for the values we are going to swap. 
First, we need to create a couple variables to hold the selected pieces. 
We will use <code>selected1</code> and <code>selected2</code> for that purpose. 
Next, we move the reference to the piece represented by <code>selected1</code> into the <code>tempPiece1</code> variable:

if (selectedList.length == 2) { var selected1 = selectedList[0]; var selected2 = selectedList[1]; var tempPiece1 = board[selected1.col][selected1.row]; board[selected1.col][selected1.row] =
Next, we move the piece referenced by <code>selected2</code> to the location in the <code>board</code> array of the piece represented by <code>selected1</code> (the first swap). 
Then we apply the piece referenced in <code>selected1</code> to the position represented by <code>selected2</code> (the second swap). 
Finally, now that they are swapped, we make sure to set the <code>selected</code> properties of both pieces to <code>false</code>: board[selected2.col][selected2.row]; board[selected2.col][selected2.row] = tempPiece1; board[selected1.col][selected1.row].selected = false; board[selected2.col][selected2.row].selected = false; }
 }
<h3>Note</h3>
This part of the function works because we have limited the number of pieces that can be selected to <code>2</code>. 

For a game such as poker, which requires the player to select five cards, you would use a slightly different algorithm that tests for <code>5</code> cards instead of <code>2</code>, and then calculate the value of the hand.
<h4>Testing the game</h4>
Believe it or not, that is all the code we need to talk about—the rest you have seen many times before. 
Try running the game (<em>CH6EX10.html</em>). 

When it loads, you should see the video organized in a 16-piece grid. 
Each part of the video will be playing, just like one of those magic tricks where a woman appears to be separated into multiple boxes but her legs, arms, and head are still moving. 
In fact, this game is sort of like one of those magic tricks because, in reality, the video was never “cut” in any way. 
We simply display the parts of the video to make it appear to be cut into 16 independent, moving pieces that can be swapped to re-form the original video.

Example 6-10</a> shows the full code listing for the Video Puzzle application.
Example 6-10. 
Video puzzle
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX10: Video Puzzle&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var videoElement;

var videoDiv;
function eventWindowLoaded() {
 videoElement = document.createElement("video");
 videoDiv = document.createElement('div'); document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement);
 videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement); if (videoType == "") { alert("no video support"); return;
 }
 videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);

}
function supportedVideoFormat(video) {
 var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm"; } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function videoLoaded() { canvasApp();
}
function canvasApp() {
 if (!canvasSupport()) { return; } function drawScreen () {
 //Background context.fillStyle = '#303030'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#FFFFFF'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
 for (var c = 0; c &lt; cols; c++) { for (var r = 0; r &lt; rows; r++) {
 var tempPiece = board[c][r]; var imageX = tempPiece.finalCol*partWidth; var imageY = tempPiece.finalRow*partHeight; var placeX = c*partWidth+c*xPad+startXOffset; var placeY = r*partHeight+r*yPad+startYOffset; //context.drawImage(videoElement , imageX, imageY, partWidth, partHeight); context.drawImage(videoElement, imageX, imageY, partWidth, partHeight, placeX, placeY, partWidth, partHeight); if (tempPiece.selected) { context.strokeStyle = '#FFFF00'; context.strokeRect( placeX, placeY, partWidth, partHeight);
 } } }
 }
 function randomizeBoard(board) { var newBoard = new Array(); var cols = board.length; var rows = board[0].length for (var i = 0; i &lt; cols; i++) { newBoard[i] = new Array(); for (var j =0; j &lt; rows; j++) { var found = false; var rndCol = 0; var rndRow = 0; while (!found) { var rndCol = Math.floor(Math.random() * cols); var rndRow = Math.floor(Math.random() * rows); if (board[rndCol][rndRow] != false) { found = true; } } newBoard[i][j] = board[rndCol][rndRow]; board[rndCol][rndRow] = false; }
 }
 return newBoard;
 } function eventMouseUp(event) {
 var mouseX; var mouseY; var pieceX; var pieceY; if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; } var selectedList= new Array(); for (var c = 0; c &lt; cols; c++) {
 for (var r =0; r &lt; rows; r++) { pieceX = c*partWidth+c*xPad+startXOffset; pieceY = r*partHeight+r*yPad+startYOffset; if ( (mouseY &gt;= pieceY) &amp;&amp; (mouseY &lt;= pieceY+partHeight) &amp;&amp; (mouseX &gt;= pieceX) &amp;&amp; (mouseX &lt;= pieceX+partWidth) ) {
 if ( board[c][r].selected) { board[c][r].selected = false; } else { board[c][r].selected = true;
 } } if (board[c][r].selected) { selectedList.push({col:c,row:r}) }
 }
 } if (selectedList.length == 2) { var selected1 = selectedList[0]; var selected2 = selectedList[1]; var tempPiece1 = board[selected1.col][selected1.row]; board[selected1.col][selected1.row] = board[selected2.col][selected2.row]; board[selected2.col][selected2.row] = tempPiece1; board[selected1.col][selected1.row].selected = false; board[selected2.col][selected2.row].selected = false; } }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 videoElement.play(); //Puzzle Settings var rows = 4;
 var cols = 4;
 var xPad = 10; var yPad = 10;
 var startXOffset = 10;
 var startYOffset = 10;
 var partWidth = videoElement.width/cols; var partHeight = videoElement.height/rows;
 //320×240
 partWidth = 80;
 partHeight = 60; var board = new Array();
 //Initialize Board for (var i = 0; i &lt; cols; i++) { board[i] = new Array(); for (var j =0; j &lt; rows; j++) { board[i][j] = { finalCol:i,finalRow:j,selected:false }; }
 } board = randomizeBoard(board);
 theCanvas.addEventListener("mouseup",eventMouseUp, false);
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="370" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Creating Video Controls on the Canvas</h3>
One obvious use of the HTML5 Canvas video display functionality is to create custom video controls to play, pause, stop, etc. 

You may have already noticed that when a video is rendered on the canvas, it does not retain any of the HTML5 video controls. 
If you want to create controls on the canvas, you need to make them yourself. 
Thankfully, we have already learned most everything we need to do this—now we just have to put it all together.
<h4>Creating video buttons</h4>

We are going to use some video control buttons that were created specifically for this example. 
<a href="ch06.html#video_control_button_tile_sheet" title="Figure 6-11. 
Video control button tile sheet">Figure 6-11</a> shows a tile sheet that consists of <em>off</em> and <em>on</em> states for play, pause, and stop. 
The top row images are the on state; the bottom row images are the off state.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893783.png" alt="Video control button tile sheet" width="96" height="64">
Figure 6-11. 
Video control button tile sheet
<h3>Note</h3>

We don’t use the off state of the stop button in this application, but we included it in case you—the amazing reader and programmer that you are—want to use it later.
We will load this image dynamically onto the canvas, and then place each 32×32 button onto the canvas individually. 
We use the width and height to calculate which part of the image to display as a control.
<h4>Preloading the buttons</h4>

The first thing we need to do is preload the button tile sheet. 
Since we are already testing for the video to preload before we display the canvas, we need a slightly new strategy to preload multiple objects. 
For this example, we will use a counter variable named <code>loadCount</code> that we will increment each time we detect that an item has loaded. 
In conjunction with that variable, we will create another named <code>itemsToLoad</code>, which will hold the number of things we are preloading. 

For this app that number is two: the video and the tile sheet. 
These two variables are created outside of all functions at the top of our JavaScript:
var loadCount = 0;
var itemsToLoad = 2;

Along with <code>videoElement</code> and <code>videoDiv</code>, we also create another new variable, <code>buttonSheet</code>. 
This is a reference to the image we load that holds the graphical buttons we will use for the video player interface:
var videoElement;
var videoDiv;

var buttonSheet
We now must make some updates to our standard <code>eventWindowLoaded()</code> function that we have used for most of this chapter. 
First, we are going to change the <code>canplay</code> event handler for the video to a new function, <code>itemLoaded</code>:
videoElement.addEventListener("canplay",itemLoaded,false);

We used the <code>canplay</code> event instead of <code>canplaythrough</code> because, most of the time, a user wants to start watching a video as soon as enough data has been buffered to play, and not after the entire video has loaded.
Next, we need to load our tile sheet. 
We create a new <code>Image</code> object and set the <code>src</code> property to <em>videobuttons.png</em>, which is the file shown in <a href="ch06.html#video_control_button_tile_sheet" title="Figure 6-11. 
Video control button tile sheet">Figure 6-11</a>. 

We also set its <code>onload</code> event handler to <code>itemLoaded</code>, just like the video:
 buttonSheet = new Image();
 buttonSheet.src = "videobuttons.png";
 buttonSheet.onload = itemLoaded;

}
Finally, we create the <code>itemLoaded()</code> event handler function. 
When this function is called, we increment the <code>loadCount</code> variable and test it against the <code>itemsToLoad</code> variable.
<h3>Note</h3>

<code>loadCount</code> should never be greater than <code>itemsToLoad</code> if your application is running correctly. 
However, we find it safer to limit the use of the strict <code>==</code> test if possible. 
Why? Because if somehow, somewhere, something gets counted twice, the app will never load properly.
If it is equal to or greater than <code>itemsToLoad</code>, we call <code>canvasApp()</code> to start the application:

function itemLoaded() {
 loadCount++;
 if (loadCount &gt;= itemsToLoad) { canvasApp();
 }

}
<h4>Placing the buttons</h4>
We need to set some variables in <code>canvasApp()</code> that will represent the locations of the three buttons we will display: play, pause, and stop. 
We start by specifying the standard button width and height as the variables <code>bW</code> and <code>bH</code>. 

All the images in the <em>videobuttons.png</em> tile sheet are 32×32 pixels, so we will set <code>bW</code> and <code>bH</code> accordingly. 
Then, we proceed to create variables that represent the <code>x</code> and <code>y</code> locations of each button: <code>playX</code>, <code>playY</code>, <code>pauseX</code>, <code>pauseY</code>, <code>stopX</code>, and <code>stopY</code>. 
We could use literal values; however, these variables will make a couple of the more complicated calculations easier to swallow:
var bW = 32;

var bH = 32;
var playX = 190;
var playY = 300;
var pauseX = 230;

var pauseY = 300;
var stopX = 270
var stopY = 300;
In the <code>drawImage()</code> function, we need to test for the current state of the playing video and render the buttons accordingly. 

For this application, we will use the <code>paused</code> state of the video object’s attribute to render the buttons properly in their “up” or “down” states.
When a video first loads on the page and is not yet playing, its <code>paused</code> attribute is set to <code>true</code>. 
When a video is playing, its <code>paused</code> attribute is set to <code>false</code>. 
Knowing this, we can create the actions for these simple buttons.

First, if we know that the video is not in a <code>paused</code> state, it must be playing, so we display the “down” version of the play button. 
The “down” position is in the second row on the tile sheet in <a href="ch06.html#video_control_button_tile_sheet" title="Figure 6-11. 
Video control button tile sheet">Figure 6-11</a>. 
The third parameter of the call to the <code>drawImage()</code> function is <code>32</code> because that is where the <code>y</code> position of the image we want to display starts on the tile sheet. 

If <code>paused</code> is <code>true</code>, it means the video is not playing, so we display the “up” version of the play button. 
It starts at <code>y</code> position <code>0</code>:
if (!videoElement.paused) { context.drawImage(buttonSheet, 0,32,bW,bH,playX,playY,bW,bH); //Play Down
} else { context.drawImage(buttonSheet, 0,0,bW,bH,playX,playY,bW,bH); //Play up

}
Displaying the pause button is simply the opposite of play. 
If the video <code>paused</code> property is <code>true</code>, we display the “down” version of the pause button. 
If the video is playing, it means the <code>pause</code> property is <code>false</code>, so we display the “up” version. 

Notice that the second parameter is <code>32</code> because to display the pause buttons in the tile sheet, we need to skip over the play button and start at the <code>x</code> position of the pause button:
if (videoElement.paused) { context.drawImage(buttonSheet, 32,32,bW,bH,pauseX,pauseY,bW,bH); //down
} else { context.drawImage(buttonSheet, 32,0,bW,bH,pauseX,pauseY,bW,bH); // up
}

context.drawImage(buttonSheet, 64,0,bW,bH,stopX,stopY,bW,bH); // Stop up
<h4>Listening for the button presses</h4>
We also need to listen for the mouse button click. 
This process is very similar to how we accomplished much the same thing in the Video Puzzle application. 

First, back in the <code>canvasApp()</code> function, we set an event handler, <code>eventMouseUp()</code>, for the <code>mouseup</code> event:
theCanvas.addEventListener("mouseup",eventMouseUp, false);
The <code>eventMouseUp()</code> function works very similar to the same function we created earlier for Video Puzzle. 
First, we find the mouse pointer’s <code>x</code> and <code>y</code> positions based on the way the browser tracks those values, and we put those values into local <code>mouseX</code> and <code>mouseY</code> variables:

function eventMouseUp(event) {
 var mouseX; var mouseY;
 if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; } //Hit Play
Next, we test for a hit test point inside each button by checking the bounds (right, left, top, bottom) on the canvas to see whether the mouse pointer was over any of our buttons when it was clicked. 

If so, we detect a hit.
First, we test the play button. 
Notice that those variables we created to represent the upper-left <code>x</code> and <code>y</code> locations of the button (<code>playX</code> and <code>playY</code>) help us make this calculation. 
They also help us because the names of the buttons self-document what we are trying to accomplish in each test of this function.

If the play button has been clicked, and the video <code>paused</code> property is <code>true</code>, we call the <code>play()</code> function of the video to start playing:
//Hit Play if ( (mouseY &gt;= playY) &amp;&amp; (mouseY &lt;= playY+bH) &amp;&amp; (mouseX &gt;= playX) &amp;&amp; (mouseX &lt;= playX+bW) ) { if (videoElement.paused) { videoElement.play();
 }
If the stop button was clicked, we set the <code>paused</code> property of the video to <code>true</code>, and set the <code>currentTime</code> property to <code>0</code> so that the video will return to the first frame:

//Hit Stop if ( (mouseY &gt;= stopY) &amp;&amp; (mouseY &lt;= stopY+bH) &amp;&amp; (mouseX &gt;= stopX) &amp;&amp; (mouseX &lt;= stopX+bW) ) {
 videoElement.pause(); videoElement.currentTime = 0; }
If the pause button is clicked and the <code>paused</code> property of the video is <code>false</code>, we call the <code>pause()</code> function of the video to—you guessed it—pause the video on the current frame. 

If the <code>paused</code> property is <code>true</code>, we call the <code>play()</code> function of the video so it will resume playing:
//Hit Pause if ( (mouseY &gt;= pauseY) &amp;&amp; (mouseY &lt;= pauseY+bH) &amp;&amp; (mouseX &gt;= pauseX) &amp;&amp; (mouseX &lt;= pauseX+bW) ) {
 if (videoElement.paused == false) { videoElement.pause(); } else { videoElement.play(); }
 }

<a href="ch06.html#canvas_video_player_buttons" title="Figure 6-12. 
Canvas video player buttons">Figure 6-12</a> shows what the canvas looks like when the video is displayed with controls.
<h3>Note</h3>
You will notice an odd relationship between the play and pause buttons. 

When one is “on,” the other is “off.” This is because we have only one property to look at: <code>paused</code>. 
There is a property named <code>playing</code> that exists in the HTML5 specification, but it did not work in all browsers, so we only used <code>paused</code>. 
In reality, you could have only one button and swap out the play or paused graphic depending on the <code>paused</code> state. 
That would make these controls work more like the default HTML <code>video</code> controls.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893785.png.jpg" alt="Canvas video player buttons" width="543" height="390">
Figure 6-12. 
Canvas video player buttons
Example 6-11</a> shows the full source code for this application.

Example 6-11. 
Canvas video with controls
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX11: Canvas Video With Controls&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var loadCount= 0;
var itemsToLoad = 2;

var videoElement;
var videoDiv;
var buttonSheet
function eventWindowLoaded() { videoElement = document.createElement("video");
 videoDiv = document.createElement('div');
 document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement); videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement);
 if (videoType == "") { alert("no video support"); return;
 } videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplay",itemLoaded,false);
 buttonSheet = new Image();
 buttonSheet.onload = itemLoaded; buttonSheet.src = "videobuttons.png";
}
function supportedVideoFormat(video) {
 var returnExtension = ""; if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm";
 } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg";
 } return returnExtension;
}
function canvasSupport () { return Modernizr.canvas;
}

function itemLoaded() {
 loadCount++;
 if (loadCount &gt;= itemsToLoad) { canvasApp();
 }

}
function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () { //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); //video context.drawImage(videoElement , 85, 30); //Draw Buttons //Play if (!videoElement.paused) { context.drawImage(buttonSheet, 0,32,bW,bH,playX,playY,bW,bH); //Play Down
 } else { context.drawImage(buttonSheet, 0,0,bW,bH,playX,playY,bW,bH); //Play up
 } if (videoElement.paused) { context.drawImage(buttonSheet, 32,32,bW,bH,pauseX,pauseY,bW,bH); // Pause down } else { context.drawImage(buttonSheet, 32,0,bW,bH,pauseX,pauseY,bW,bH); // Pause up }
 context.drawImage(buttonSheet, 64,0,bW,bH,stopX,stopY,bW,bH); // Stop up
 }
 function eventMouseUp(event) { var mouseX; var mouseY;
 if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; }
 //Hit Play if ( (mouseY &gt;= playY) &amp;&amp; (mouseY &lt;= playY+bH) &amp;&amp; (mouseX &gt;= playX) &amp;&amp; (mouseX &lt;= playX+bW) ) { if (videoElement.paused) { videoElement.play();
 } }
 //Hit Stop if ( (mouseY &gt;= stopY) &amp;&amp; (mouseY &lt;= stopY+bH) &amp;&amp; (mouseX &gt;= stopX) &amp;&amp; (mouseX &lt;= stopX+bW) ) {
 videoElement.pause(); videoElement.currentTime = 0; } //Hit Pause if ( (mouseY &gt;= pauseY) &amp;&amp; (mouseY &lt;= pauseY+bH) &amp;&amp; (mouseX &gt;= pauseX) &amp;&amp; (mouseX &lt;= pauseX+bW) ) {
 if (videoElement.paused == false) { videoElement.pause(); } else { videoElement.play(); }
 }
 } var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 var bW = 32;
 var bH = 32; var playX = 190;
 var playY = 300;
 var pauseX = 230;
 var pauseY = 300; var stopX = 270
 var stopY = 300;
 theCanvas.addEventListener("mouseup",eventMouseUp, false);
 setInterval(drawScreen, 33);

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="350"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h2>Animation Revisited: Moving Videos</h2>
Now we are going to revisit the bouncing balls demo from Chapter 5 to show you how you can achieve the same effect with images and videos. 
Since we covered this in detail in Example 5-5</a> (<em>CH5EX5.html</em>), we don’t need to examine all the code—just the changes that make the videos move.
<h3>Note</h3>

Remember that videos are drawn in much the same way as images, so with very few changes this application would work just as well with a static image.
While there are a few other changes, the most important is in the <code>drawScreen()</code> function when we draw the videos onto the canvas. 
Recall that in Chapter 5 we created an array named <code>balls</code> and a dynamic object to hold the properties of each ball that looked like this:

tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits}
For videos, we will create a similar array, named <code>videos</code>, but we will alter the dynamic object:
tempvideo = {x:tempX,y:tempY,width:180, height:120, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits}
The big difference here is that we no longer need a <code>radius</code> that represents the size of the ball; instead, we need the <code>width</code> and <code>height</code> so we can render the video to our desired size in the <code>drawScreen()</code> function.

Back in Chapter 5</a> we used the canvas drawing command to draw balls on the screen like this:
context.beginPath();
context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true);

context.closePath();
context.fill();
To draw videos, we need to change the code:
context.drawImage(videoElement, video.x, video.y, video.width, video.height);

That is pretty much all you need to do! There are some others changes here (e.g., we start all the videos in the center of the screen before they start moving), but the items mentioned above are the main things you need to concentrate on to move video, not yellow balls, around the screen. 
Figure 6-13 shows what the example looks like with bouncing videos instead of balls. 
You can see the full code in Example 6-12</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893787.png.jpg" alt="Canvas video animation demo" width="543" height="540">
Figure 6-13. 
Canvas video animation demo
Example 6-12. 

Multiple video bounce
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH6EX12: Multiple Video Bounce&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
var videoElement;
var videoDiv;
function eventWindowLoaded() { videoElement = document.createElement("video");
 var videoDiv = document.createElement('div');
 document.body.appendChild(videoDiv);
 videoDiv.appendChild(videoElement); videoDiv.setAttribute("style", "display:none;");
 var videoType = supportedVideoFormat(videoElement);
 if (videoType == "") { alert("no video support"); return;
 } videoElement.setAttribute("src", "muirbeach." + videoType);
 videoElement.addEventListener("canplaythrough",videoLoaded,false);
}
function supportedVideoFormat(video) { var returnExtension = "";
 if (video.canPlayType("video/webm") =="probably" || video.canPlayType("video/webm") == "maybe") { returnExtension = "webm";
 } else if(video.canPlayType("video/mp4") == "probably" || video.canPlayType("video/mp4") == "maybe") { returnExtension = "mp4";
 } else if(video.canPlayType("video/ogg") =="probably" || video.canPlayType("video/ogg") == "maybe") { returnExtension = "ogg"; }
 return returnExtension;
}
function canvasSupport () { return Modernizr.canvas;

}
function videoLoaded() {
 canvasApp();
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 context.fillStyle = '#000000'; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = '#ffffff'; context.strokeRect(1, 1, theCanvas.width-2, theCanvas.height-2); //Place videos context.fillStyle = "#FFFF00"; var video;
 for (var i =0; i &lt;videos.length; i++) { video = videos[i]; video.x += video.xunits; video.y += video.yunits;
 context.drawImage(videoElement ,video.x, video.y, video.width, video.height);
 if (video.x &gt; theCanvas.width-video.width || video.x &lt; 0 ) { video.angle = 180 - video.angle; updatevideo(video); } else if (video.y &gt; theCanvas.height-video.height || video.y &lt; 0) { video.angle = 360 - video.angle; updatevideo(video); } } }
 function updatevideo(video) {
 video.radians = video.angle * Math.PI/ 180; video.xunits = Math.cos(video.radians) * video.speed; video.yunits = Math.sin(video.radians) * video.speed;
 } var numVideos = 12 ;
 var maxSpeed = 10;
 var videos = new Array();
 var tempvideo; var tempX;
 var tempY;
 var tempSpeed;
 var tempAngle; var tempRadians;
 var tempXunits;
 var tempYunits;
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 videoElement.play();
 for (var i = 0; i &lt; numVideos; i++) {
 tempX = 160 ; tempY = 190 ; tempSpeed = 5; tempAngle = Math.floor(Math.random()*360); tempRadians = tempAngle * Math.PI/ 180; tempXunits = Math.cos(tempRadians) * tempSpeed; tempYunits = Math.sin(tempRadians) * tempSpeed; tempvideo = {x:tempX,y:tempY,width:180, height:120, speed:tempSpeed, angle:tempAngle, xunits:tempXunits, yunits:tempYunits} videos.push(tempvideo);
 }
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Note</h3>
The HTML5 <code>video</code> element combined with the canvas is an exciting, emerging area that is being explored on the Web as you read this. 

One great example of this is the exploding 3D video at <a href="http://craftymind.com">CraftyMind.com</a>: <a href="http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/">http://www.craftymind.com/2010/04/20/blowing-up-html5-video-and-mapping-it-into-3d-space/</a>.
<h2>What’s Next?</h2>
In this chapter we introduced the HTML <code>&lt;video&gt;</code> tag and showed some basic ways that it could be used on an HTML page, including how to manipulate loaded video in numerous ways. 
While we showed you how to do some pretty cool stuff with the video and HTML5 Canvas, this is really just the tip of the iceberg. 

We believe that these two very powerful and flexible new features of HTML5 (video and the canvas) will prove to be a very potent combination for web applications of the future. 
In the next chapter, we will dive into HTML5 audio and how it can be used with applications created on the canvas.
 7. 
Working with Audio" epub:type="chapter">

<h2><span class="orange">Chapter 7. Working with Audio</span></h2>
You can’t physically manipulate audio with HTML5 Canvas as directly as you can video, but many canvas applications can use that extra dimension of sound. 
Audio is represented by the <code>HTMLAudioElement</code> object manipulated through JavaScript, and by the <code>&lt;audio&gt;</code> tag in HTML5. 

There is no Canvas API for audio nor, really, is one necessary.
 However, there are many ways that you might want to use audio with HTML5
 Canvas.
<h2>The Basic &lt;audio&gt; Tag</h2>
The basic usage of the <code>&lt;audio&gt;</code> tag in HTML5 is very similar to that of the <code>&lt;video&gt;</code> tag. 
The only required property is <code>src</code>, which needs to point to an existing audio file to play in the browser. 
Of course, it’s always nice to show some audio controls on the page, and this can be accomplished using the <code>controls</code> Boolean, just as we did with <code>&lt;video&gt;</code>.
The code in Example 7-1 will load and play <em>song1.ogg</em> in a web browser that supports <em>.ogg</em> file playback, as shown in Figure 7-1. 
(Reminder: not all browsers support all formats.)
Example 7-1. 
Basic HTML5 audio

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH7EX1: Basic HTML5 Audio&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;audio src="song1.ogg" controls&gt;
Your browser does not support the audio element.
&lt;/audio&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893789.png" alt="The very basic HTML5 &lt;audio&gt; tag" width="300" height="32">
Figure 7-1. 

The very basic HTML5 &lt;audio&gt; tag
<h2>Audio Formats</h2>
Similar to video formats, which we learned about in Chapter 6, not every web browser supports every audio format. 

In fact, audio support appears to be in worse shape than video. 
As you will soon discover in this chapter, audio is one place where HTML5 needs some serious work. 
However, we will show you some strategies and workarounds for making audio easier to use in your applications.
<h3>Supported Formats</h3>

Here is a quick chart to show you which audio formats are supported by which browsers. 
We are not going to use version numbers here because we assume the latest version of each product:
<table>
<colgroup>

<col>
<col>
<col>
<col>

</colgroup>
<thead><tr>
<td>
Platform

</td>
<td>
.ogg
</td>

<td>
.mp3
</td>
<td>

.wav
</td>
</tr></thead>
<tbody>

<tr>
<td>
Chrome
</td>

<td>
X
</td>
<td>

X
</td>
<td> </td>
</tr>

<tr>
<td>
Firefox
</td>

<td>
X
</td>
<td> </td>

<td>
X
</td>
</tr>

<tr>
<td>
Safari
</td>

<td> </td>
<td>
X
</td>

<td>
X
</td>
</tr>

<tr>
<td>
Opera
</td>

<td>
X
</td>
<td> </td>

<td>
X
</td>
</tr>

<tr>
<td>
Internet Explorer 9
</td>

<td> </td>
<td>
X
</td>

<td>
X
</td>
</tr>

</tbody>
</table>
The situation is much like that of the <code>&lt;video&gt;</code> tag. 
To support <code>&lt;audio&gt;</code> we will need to use multiple separate formats for each piece of audio we want to play. 

To be on the safe side, we will use three formats: <em>.mp3</em>, <em>.ogg</em>, and <em>.wav</em>.
<h3>Audacity</h3>
Fortunately, there is a great free audio tool available that will help you convert audio into any format. 
In our case, we need to convert to <em>.mp3</em>, <em>.ogg</em>, and <em>.wav</em>.

Audacity (<a href="http://audacity.sourceforge.net/">http://audacity.sourceforge.net/</a>) is an open source, cross-platform project designed to bring sophisticated audio editing to the desktop. 
The current version works on Mac, Windows, and Linux.
Figure 7-2 shows a sample screen from Audacity. 

When you load a sound into Audacity, it displays the waveform of the sound. 
You can manipulate the sound in many ways, including trimming, splitting, and duplicating, and then add effects such as fade, echo, reverse, etc. 
After editing a sound, you export it to the sound format you would like to create. 
In our case, that would be <em>.ogg</em>, <em>.wav</em>, and <em>.mp3</em>.

<h3>Note</h3>
We don’t have the space here to fully describe how to use an audio tool like Audacity, but we do need to give you one caveat: the distributed version of Audacity does not support the export of audio in the <em>.mp3</em> format. 
To export <em>.mp3</em> audio, you will need to download the LAME <em>.mp3</em> encoder from <a href="http://lame.sourceforge.net/">http://lame.sourceforge.net/</a>. 
LAME is also an open source project.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893791.png" alt="Editing an audio file in Audacity" width="881" height="644">
Figure 7-2. 
Editing an audio file in Audacity
<h3>Example: Using All Three Formats</h3>

In Example 7-2</a>, we are going to embed a 40-second song, <em>song1</em>, in an HTML5 page and play it. 
To make sure <em>song1</em> can play in as many browsers as possible, we are going to embed it with three different sources. 
For this example, we are also going to set the <code>autoplay</code>, <code>loop</code>, and <code>controls</code> properties so the song will start automatically, replay when it reaches the end, and display the default browser audio controls. 
Here is the code to embed <em>song1</em>:

&lt;audio controls autoplay loop&gt;
&lt;source src="song1.mp3" type="audio/mp3"&gt;
&lt;source src="song1.wav" type="audio/wav"&gt;
&lt;source src="song1.ogg" type="audio/ogg"&gt;

&lt;/audio&gt;
<h3>Note</h3>
Just as we did with video, we have placed the audio type with the broadest support for iOS devices first in the list. 
This is because handheld devices do not do well with multiple embedded sources.

We created <em>.ogg</em>, <em>.wav</em>, and <em>.mp3</em> versions of the song using Audacity. 
Example 7-2</a> gives the full code.
Example 7-2. 
Basic HTML5 audio revisited

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH7EX2: Basic HTML5 Audio Revisited&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;audio controls autoplay loop&gt;
&lt;source src="song1.mp3" type="audio/mp3"&gt;
&lt;source src="song1.ogg" type="audio/ogg"&gt;
&lt;source src="song1.wav" type="audio/wav"&gt;

Your browser does not support the audio element.
&lt;/audio&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Note</h3>
<em>song1</em> was created 10 years ago using Sonic Foundry’s Acid music-looping software. 
Acid is an amazing tool for creating soundtracks because it can help even the musically inept (read: us) create songs that sound perfect for games and applications. 

Acid is now sold by Sony for Windows only. 
Songs can be created on the Mac in a similar way using GarageBand.
<h2>Audio Tag Properties, Functions, and Events</h2>
Similar to the <code>&lt;video&gt;</code> tag, the <code>&lt;audio&gt;</code> tag in HTML5 is based on the <code>HTMLAudio</code><code>Element</code> DOM object, which is derived from <code>HTMLMediaElement</code>.

<h3>Audio Functions</h3>
<code>load()</code>

Starts loading the sound file specified by the <code>src</code> property of the <code>&lt;audio&gt;</code> tag.
<code>play()</code>

Starts playing the sound file specified by the <code>src</code> property of the <code>&lt;audio&gt;</code> tag. 
If the file is not ready, it will be loaded.
<code>pause()</code>

Pauses the playing audio file.
<code>canPlayType()</code>

Accepts a MIME type as a parameter, and returns the value <code>maybe</code> or <code>probably</code> if the browser can play that type of audio file. 
It returns <code>“”</code> (an empty string) if it cannot.

<h3>Important Audio Properties</h3>
There are many properties defined for the <code>audio</code> element in HTML5. 
We are going to focus on the following because they are the most useful for the applications we will build:

<code>duration</code>
The total length, in seconds, of the sound represented by the <code>audio</code> object.

<code>currentTime</code>
The current playing position, in seconds, of the playing audio file.

<code>loop</code>
<code>true</code> or <code>false</code>: whether the audio clip should start playing at the beginning when <code>currentTime</code> reaches the <code>duration</code>.

<code>autoplay</code>
<code>true</code> or <code>false</code>: whether the audio should start playing automatically when it has loaded.

<code>muted</code>
<code>true</code> or <code>false</code>. 

Setting this to <code>true</code> silences the <code>audio</code> object regardless of <code>volume</code> settings
<code>controls</code>

<code>true</code> or <code>false</code>. 
Displays controls for an <code>audio</code> object in an HTML page. 
Controls will not display on the canvas unless they are created in HTML (for example, with a <code>&lt;div&gt;</code> overlay).

<code>volume</code>
The volume level of the <code>audio</code> object; the value must be between <code>0</code> and <code>1</code>.

<code>paused</code>
<code>true</code> or <code>false</code>: whether the <code>audio</code> object is paused. 
Set with a call to the <code>pause()</code> function.

<code>ended</code>
<code>true</code> or <code>false</code>. 

Set when an <code>audio</code> object has played through its entire <code>duration</code>.
<code>currentSrc</code>

URL to the source file for the <code>audio</code> object.
<code>preload</code>

Specifies whether the media file should be loaded before the page is displayed. 
At the time of this writing, this property has not been implemented across all browsers.

<h3>Note</h3>
To see which properties and events of the <code>HTMLMediaObject</code> are supported in which browsers, visit <a href="http://www.w3.org/2010/05/video/mediaevents.html">http://www.w3.org/2010/05/video/mediaevents.html</a>.
<h3>Important Audio Events</h3>
Many events are defined for the HTML5 <code>audio</code> element. 

We are going to focus on the following events because they have proven to work when building audio applications:
<code>progress</code>

Raised when the browser is retrieving data while loading the file. 
(This still has spotty support in browsers, so be careful with it.)
<code>canplaythrough</code>

Raised when the browser calculates that the media element could be played from beginning to end if started immediately.
<code>playing</code>

Set to <code>true</code> when the audio is being played.
<code>volumechange</code>

Set when either the <code>volume</code> property or the <code>muted</code> property changes.
<code>ended</code>

Set when playback reaches the <code>duration</code> of the audio file and the file stops being played.

<h3>Loading and Playing the Audio</h3>
We are going to use the <code>canplaythrough</code> and <code>progress</code> events to load <code>&lt;audio&gt;</code> before we try to play it. 
Here is how we embed the audio for <em>song1</em>:
&lt;audio controls&gt;

&lt;source src="song1.mp3" type="audio/mp3"&gt;
&lt;source src="song1.wav" type="audio/wav"&gt;
&lt;source src="song1.ogg" type="audio/ogg"&gt;
Your browser does not support the audio element.

&lt;/audio&gt;
Similar to most of the applications we have built thus far in this book, we will create event handlers for <code>progress</code> and <code>canplaythrough</code> once the <code>window</code> DOM object has finished loading, and then call the <code>load()</code> method of <code>audioElement</code> to force the audio file to start loading:
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { var audioElement = document.getElementById("theAudio");
 audioElement.addEventListener('progress',updateLoadingStatus,false);
 audioElement.addEventListener('canplaythrough',audioLoaded,false);
 audioElement.load();

}
When the <code>canplaythrough</code> event is dispatched, <code>canvasApp()</code> is called. 
Then, we start playing the audio by retrieving a reference to the <code>audio</code> element in the HTML page through the DOM, with a call to <code>getElementById()</code>. 
(We will create a variable named <code>audioElement</code> that we will use throughout the canvas application to reference the <code>audio</code> element in the HTML page.) We then call the <code>play()</code> function of <code>audioElement</code>:

var audioElement = document.getElementById("theAudio");
audioElement.play();
You may be wondering why we didn’t use the <code>preload</code> attribute of <code>HTMLAudioElement</code> instead of forcing it to load by listening for the <code>canplaythrough</code> event. 
There are two reasons for this, and both apply to the <code>video</code> element as well. 

First, you want to preload so that you are sure the assets you need are available to your program at runtime. 
Second, preloading ensures that the user will see something useful or interesting while everything is loading. 
By using the standard <code>preload</code> attribute, you (in theory) force your audio assets to load before the page loads. 
Because canvas apps are interactive and may require many more assets than those loaded when the page loads, we avoid the <code>preload</code> attribute and load the assets within the application.

<h3>Displaying Attributes on the Canvas</h3>
Now we are going to display the attribute values of an <code>audio</code> element playing on an HTML page. 
In this example (<em>CH7EX3.html</em>), we are also going to display the <code>audio</code> element in the HTML page so you can see the relationship between what is shown on the canvas and the state of the <code>&lt;audio&gt;</code> tag in the page.
In the <code>drawScreen()</code> function we will add the following code to display the attributes of the <code>audioElement</code> variable:

context.fillStyle = "#000000";
context.fillText ("Duration:" + audioElement.duration, 20 ,20);
context.fillText ("Current time:" + audioElement.currentTime, 20 ,40);
context.fillText ("Loop: " + audioElement.loop, 20 ,60);

context.fillText ("Autoplay: " +audioElement.autoplay, 20 ,80);
context.fillText ("Muted: " + audioElement.muted, 20 ,100);
context.fillText ("Controls: " + audioElement.controls, 20 ,120);
context.fillText ("Volume: " + audioElement.volume, 20 ,140);

context.fillText ("Paused: " + audioElement.paused, 20 ,160);
context.fillText ("Ended: " + audioElement.ended, 20 ,180);
context.fillText ("Source: " + audioElement.currentSrc, 20 ,200);
context.fillText ("Can Play OGG: " + audioElement.canPlayType("audio/ogg"), 20 ,220);

context.fillText ("Can Play WAV: " + audioElement.canPlayType("audio/wav"), 20 ,240);
context.fillText ("Can Play MP3: " + audioElement.canPlayType("audio/mp3"), 20 ,260);
You should already be familiar with most of these attributes. 
When you launch Example 7-3</a> (<em>CH7EX3.html</em>), play with the audio controls in the browser. 

You will notice that the changes are reflected by the attribute values displayed on the canvas. 
This is just our first step toward integrating audio with the canvas, but it should give you a good idea of how we will start to use <code>audio</code> elements and manipulate them through JavaScript.
Figure 7-3 shows what this application looks like when it is executed in a web browser.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893793.png" alt="Showing audio properties on the canvas" width="893" height="340">
Figure 7-3. 
Showing audio properties on the canvas
There are also a few attributes displayed at the bottom of this list that we have not discussed. 

They all come from calls to the <code>canPlayType()</code> function of <code>HTMLAudio</code><code>Element</code>. 
We are only displaying these right now, but in Example 7-3</a> we will make use of this function to help us decide which sound to dynamically load in JavaScript.
Example 7-3. 
Audio properties and the canvas

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH7EX3: Audio Properties And The Canvas&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 var audioElement = document.getElementById("theAudio");
 audioElement.addEventListener("progress",updateLoadingStatus,false);
 audioElement.addEventListener("canplaythrough",audioLoaded,false); audioElement.load();
}
function canvasSupport () { return Modernizr.canvas;
}

function updateLoadingStatus() {
 var loadingStatus = document.getElementById("loadingStatus");
 var audioElement = document.getElementById("theAudio");
 var percentLoaded = parseInt(((audioElement.buffered.end(0) / audioElement.duration) * 100)); document.getElementById("loadingStatus").innerHTML = 'loaded ' + percentLoaded + '%';

}
function audioLoaded() {
 canvasApp();
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10); // Text context.fillStyle = "#000000"; context.fillText ("Duration:" + audioElement.duration, 20 ,20); context.fillText ("Current time:" + audioElement.currentTime, 20 ,40); context.fillText ("Loop: " + audioElement.loop, 20 ,60); context.fillText ("Autoplay: " +audioElement.autoplay, 20 ,80); context.fillText ("Muted: " + audioElement.muted, 20 ,100); context.fillText ("Controls: " + audioElement.controls, 20 ,120); context.fillText ("Volume: " + audioElement.volume, 20 ,140); context.fillText ("Paused: " + audioElement.paused, 20 ,160); context.fillText ("Ended: " + audioElement.ended, 20 ,180); context.fillText ("Source: " + audioElement.currentSrc, 20 ,200); context.fillText ("Can Play OGG: " + audioElement.canPlayType("audio/ogg"), 20 ,220); context.fillText ("Can Play WAV: " + audioElement.canPlayType("audio/wav"), 20 ,240); context.fillText ("Can Play MP3: " + audioElement.canPlayType("audio/mp3"), 20 ,260);
 }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d"); var audioElement = document.getElementById("theAudio");
 audioElement.play();
 setInterval(drawScreen, 33);
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;div&gt;
0%
&lt;/div&gt;
&lt;div&gt;

&lt;audio controls &gt;
&lt;source src="song1.mp3" type="audio/mp3"&gt;
&lt;source src="song1.ogg" type="audio/ogg"&gt;
&lt;source src="song1.wav" type="audio/wav"&gt;

Your browser does not support the audio element.
&lt;/audio&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>Note</h3>
This process is explained in detail in Chapter 6, where we warned that some browsers do not fire events for embedded <code>&lt;video&gt;</code> tags. 

That does not appear to be the case for <code>&lt;audio&gt;</code>, but it could happen in the future. 
We still believe the best bet for loading audio and video is the technique developed in the next section.
<h2>Playing a Sound with No Audio Tag</h2>
Now that we have a sound playing in an HTML5 page and we are tracking the properties of the <code>audio</code> element on the canvas, it is time to step up their integration. 

The next step is to do away with the <code>&lt;audio&gt;</code> tag embedded in the HTML page.
If you recall from Chapter 6, we created a <code>video</code> element dynamically in the HTML page and then used the <code>canPlayType()</code> method of the <code>HTMLVideoElement</code> object to figure out what video file type to load for a particular browser. 
We will do something very similar for audio.

<h3>Dynamically Creating an Audio Element in JavaScript</h3>
The first step to dynamically creating <code>audio</code> elements is to create a global variable named <code>audioElement</code>. 
This variable will hold an instance of <code>HTMLAudioElement</code> that we will use in our canvas application. 
Recall that <code>audio</code> elements in an HTML page are instances of the <code>HTMLAudioElement</code> DOM object. 

We refer to them as <code>audio</code> objects when embedded in an HTML page, and as instances of <code>HTMLAudioElement</code> when created dynamically in JavaScript. 
However, they are essentially the same.
<h3>Note</h3>
Don’t fret if you don’t like using global variables. 

By the end of this chapter, we will show you a way to make these variables local to your canvas application.
Next, we create our event handler for the window <code>load</code> event named <code>eventWindow</code><code>Loaded()</code>. 
Inside that function, we call the <code>createElement()</code> function of the DOM <code>document</code> object, passing the value <code>audio</code> as the type of element to create. 
This will dynamically create an <code>audio</code> object and put it into the DOM. 

By placing that object in the <code>audioElement</code> variable, we can then dynamically place it onto the HTML page with a call to the <code>appendChild()</code> method of the <code>document.body</code> DOM object:
window.addEventListener('load', eventWindowLoaded, false);
var audioElement;
function eventWindowLoaded() { audioElement = document.createElement("audio");
 document.body.appendChild(audioElement);
However, just having a dynamically created <code>audio</code> element is not enough. 
We also need to set the <code>src</code> attribute of the <code>HTMLAudioElement</code> object represented by <code>audioElement</code> to a valid audio file to load and play. 

But the problem is that we don’t yet know what type of audio file the current browser supports. 
We will get that information from a function we will create named <code>supportedAudioFormat()</code>. 
We will define this function so that it returns a string value representing the extension of the file type we want to load. 
When we have that extension, we concatenate it with the name of the sound we want to load, and set the <code>src</code> with a call to the <code>setAttribute()</code> method of the <code>HTMLAudioElement</code> object:

var audioType = supportedAudioFormat(audioElement);
If a valid extension from <code>supportedAudioFormat()</code> is not returned, something has gone wrong and we need to halt execution. 
To handle this condition in a simple way we create an <code>alert()</code> message and then <code>return</code> from the function, effectively halting execution. 
While this is not a very robust form of error handling, it will work for the sake of this example:

if (audioType == "") {
 alert("no audio support");
 return;
}

audioElement.setAttribute("src", "song1." + audioType);
Finally, like we did with video, we will listen for the <code>canplaythrough</code> event of <code>audio</code><code>Element</code> so that we know when the sound is ready to play:
audioElement.addEventListener("canplaythrough",audioLoaded,false);
<h3>Finding the Supported Audio Format</h3>

Before the code in the previous section will work, we need to define the <code>supported</code><code>AudioFormat()</code> function. 
Since we are adding <code>audio</code> objects dynamically to the HTML page, we do not have a way to define multiple <code>&lt;source&gt;</code> tags like we can in HTML. 
Instead, we are going to use the <code>canPlayType()</code> method of the <code>audio</code> object to tell us which type of audio file to load. 
We already introduced you to the <code>canPlayType()</code> method in Chapter 6, but to refresh your memory, <code>canPlayType()</code> takes a single parameter—a MIME type. 
It returns a text string of <code>maybe</code>, <code>probably</code>, or “” (nothing). 
We are going to use these values to figure out which media type to load and play. 
Just like in Chapter 6, and for the sake of this exercise, we are going to assume that both <code>maybe</code> and <code>probably</code> equate to <code>yes</code>. 
If we encounter either result with any of our three MIME types (<em>audio/ogg</em>, <em>audio/wav</em>, <em>audio/mp3</em>), we will return the extension associated with that MIME type so the sound file can be loaded.
<h3>Note</h3>
The next function is essentially the same as the one we created in Chapter 6 to handle video formats. 
The obvious changes here are with the MIME types for audio.
In the function below, <code>audio</code> represents the instance of <code>HTMLAudioElement</code> that we will test. 
The <code>returnExtension</code> variable represents that valid extension for the first MIME type found that has the value of <code>maybe</code> or <code>probably</code> returned:

function supportedAudioFormat(audio) {
 var returnExtension = "";
 if (audio.canPlayType("audio/ogg") =="probably" || audio.canPlayType("audio/ogg") == "maybe") { returnExtension = "ogg"; } else if(audio.canPlayType("audio/wav") =="probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "wav";
 } else if(audio.canPlayType("audio/mp3") == "probably" || audio.canPlayType("audio/mp3") == "maybe") { returnExtension = "mp3"; }
 return returnExtension;
}
Notice that we do not check for a condition when no valid audio format is found and the return value is <code>“”</code>. 

If that is the case, the code that has called this function might need to be written in a way to catch that condition and alter the program execution. 
We did that with the test of the <code>return</code> value and the <code>alert()</code> message, which we described in the previous section.
<h3>Note</h3>
If you want to test the error condition with no valid <code>return</code> value from this function, simply add an extra character to the MIME type (e.g., <em>audio</em>/<em>oggx</em>) to make sure an empty string is always returned.

Alternatively, you can use Modernizr to test for audio support. 
If you have included the Modernizr JavaScript library in your HTML page (as we have done in every application we have written thus far), you can access the static values of <em>Modernizr.audio.ogg</em>, <em>Modernizr.audio.wav</em>, and <em>Modernizr.audio.mp3</em> to test to see whether those types are valid. 
These are not Booleans—they evaluate to the same <code>probably</code>, <code>maybe</code>, and <code>“”</code> values that we get from a call to <code>canPlayType()</code>. 
If you are comfortable using Modernizr for all your tests, you can replace the test in the code with tests of these Modernizr static values.

<h3>Playing the Sound</h3>
Finally, we get to the point where we can play a sound inside our <code>canvasApp()</code> function. 
Since we preloaded the sound originally outside the context of this function into a variable with a global scope, we just need to call the <code>play()</code> function <code>audioElement</code> to start playing the sound:
audioElement.play();
Figure 7-4 shows what this canvas application will look like when executed in an HTML5-compliant web browser (notice that we have left the display of the audio properties in this application).
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893795.png" alt="Sound loaded and played “on” the canvas" width="500" height="300">
Figure 7-4. 

Sound loaded and played “on” the canvas
<h3>Look Ma, No Tag!</h3>
Now, check out the full application in Example 7-4</a>. 
Notice that there is no <code>&lt;audio&gt;</code> tag defined in the HTML, but the sound still plays. 

This is our first step toward integrating <code>HTMLAudioElement</code> objects with HTML5 Canvas.
Example 7-4. 
Playing a sound with no tag
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH7EX4: Playing A Sound With No Tag&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
var audioElement;

function eventWindowLoaded() {
 audioElement = document.createElement("audio");
 document.body.appendChild(audioElement);
 var audioType = supportedAudioFormat(audioElement); if (audioType == "") { alert("no audio support"); return;
 }
 audioElement.setAttribute("src", "song1." + audioType);
 audioElement.addEventListener("canplaythrough",audioLoaded,false);

}
function supportedAudioFormat(audio) {
 var returnExtension = "";
 if (audio.canPlayType("audio/ogg") =="probably" || audio.canPlayType("audio/ogg") == "maybe") { returnExtension = "ogg"; } else if(audio.canPlayType("audio/wav") =="probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "wav";
 } else if(audio.canPlayType("audio/mp3") == "probably" || audio.canPlayType("audio/mp3") == "maybe") { returnExtension = "mp3";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function audioLoaded(event) { canvasApp();
}
function canvasApp() {
 if (!canvasSupport()) { return; } function drawScreen () {
 //Background context.fillStyle = '#ffffaa'; context.fillRect(0, 0, theCanvas.width, theCanvas.height);
 //Box context.strokeStyle = '#000000'; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
 // Text context.fillStyle = "#000000"; context.fillText ("Duration:" + audioElement.duration, 20 ,20); context.fillText ("Current time:" + audioElement.currentTime, 20 ,40); context.fillText ("Loop: " + audioElement.loop, 20 ,60); context.fillText ("Autoplay: " +audioElement.autoplay, 20 ,80); context.fillText ("Muted: " + audioElement.muted, 20 ,100); context.fillText ("Controls: " + audioElement.controls, 20 ,120); context.fillText ("Volume: " + audioElement.volume, 20 ,140); context.fillText ("Paused: " + audioElement.paused, 20 ,160); context.fillText ("Ended: " + audioElement.ended, 20 ,180); context.fillText ("Source: " + audioElement.currentSrc, 20 ,200); context.fillText ("Can Play OGG: " + audioElement.canPlayType("audio/ogg"), 20 ,220); context.fillText ("Can Play WAV: " + audioElement.canPlayType("audio/wav"), 20 ,240); context.fillText ("Can Play MP3: " + audioElement.canPlayType("audio/mp3"), 20 ,260); }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 audioElement.play() setInterval(drawScreen, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h2>Creating a Canvas Audio Player</h2>
Now that we can play an audio file directly in an HTML page using the <code>&lt;audio&gt;</code> tag, or through JavaScript by creating a dynamic <code>HTMLAudioElement</code> object, it’s time to step up our game. 
We are going to create an audio player on the canvas that we can use to control dynamically loaded audio files. 
Why do we want to do this? Well, while the audio controls baked into HTML5-compliant browsers might look decent, it is often necessary for developers to implement a design that more closely matches a particular website. 

HTML5 Canvas provides a way to create a dynamic set of audio controls with nearly any look-and-feel you desire.
However, this flexibility comes at a cost. 
HTML5 Canvas does not natively support common GUI controls such as push buttons, toggle buttons, and sliders. 
So to create a decent audio player, we need to make these types of GUI user controls from scratch. 

We could create these controls in HTML and JavaScript, but we have already covered communication between HTML and Canvas via form controls several times in this book. 
You wanted to know how to make HTML5 Canvas apps when you started reading, so we won’t pull any punches in this chapter.
<h3>Creating Custom User Controls on the Canvas</h3>
For this application we are going to create four elements:

Play/pause push button
The audio file is either playing or is paused. 

Whichever state it is currently in, we show the other button (i.e., show pause when playing).
A sliding progress bar

This is a noninteractive slider. 
It displays how much of the audio track has played and how much is left to play. 
The movement of this bar needs to be dynamic and based on the <code>duration</code> and <code>currentTime</code> properties of the <code>HTMLAudioElement</code> object.

An interactive volume slider
We want to create a sliding volume control that the user can manipulate with a click-and-drag operation. 
This is the trickiest control we will build because Canvas has no native support for click-and-drag.

A loop toggle button
This is a bonus. 

Most of the default embedded HTML5 audio players do not have a loop/no-loop toggle button, but we are going to add one. 
Already, we are outstripping the functionality of standard HTML5!

Figure 7-5 shows the <em>audiocontrols.png</em> image that we created. 
It holds all the images we will use for the audio player. 
The top row consists of:

The play state of the play/pause button
The background of the play slider

The moving slider we will use for the play and volume sliders
The second row consists of:

The pause state of the play/pause button
The background of the volume slider

The “off” state of the loop button
The “on” state of the loop button

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893797.png" alt="audiocontrols.png" width="249" height="64">
Figure 7-5. 
audiocontrols.png
<h3>Loading the Button Assets</h3>

Since we are going to load in both an audio file and an image file for this application, we need to employ a strategy that will allow us to preload two assets instead of just one. 
This process is much like the one we employed in Chapter 6 when we created controls for a video. 
Previously in this chapter, we used a function named <code>audio</code><code>Loaded()</code> to make sure the audio was loaded before we started use it. 

However, that strategy will not work when we have two assets to load. 
We could create two separate event listeners, but then what if we need to load 3, 4, or 10 assets? What we need is a simple way to ensure that we can preload any number of assets before our application executes.
We will start this process by creating some variables that are global in scope to all the functions in the applications. 
First, outside of all the JavaScript functions, we will create three new variables—<code>loadCount</code>, <code>itemsToLoad</code>, and <code>buttonSheet</code>:

<code>loadCount</code>
This variable will be used as a counter. 

When an asset has preloaded we will increment this value.
<code>itemsToLoad</code>

This is a numeric value that represents the number of assets we need to load before we can execute the application in the HTML page.
<code>buttonSheet</code>

This variable will hold a reference to the <em>audiocontrols.png</em> image shown in Figure 7-5. 
We will use it to create our audio controls.

Here is the code with values included:
var loadCount = 0;
var itemsToLoad = 2;

var buttonSheet;
var audioElement;
<h3>Note</h3>
To make these variables scope only to the Canvas app and not globally to all of JavaScript, you can encapsulate this code in a <code>function()</code>. 

The final version of the code in Example 7-6</a> shows that process.
Inside the <code>eventWindowLoaded()</code> function we now need to set the event handlers for the assets to load. 
For the <code>audioElement</code>, we will change the handler from <code>audioLoaded</code> to <code>itemLoaded</code>:
audioElement.addEventListener("canplaythrough",itemLoaded,false);

To load and use the <em>audiocontrols.png</em> image, we first create a new <code>Image()</code> object and place a reference to it into the <code>buttonSheet</code> variable. 
Next, we set the <code>src</code> attribute of the new <code>Image</code> object to the image file we want to load—in this case, <em>audiocontrols.png</em>. 
We then set the <code>onload</code> event handler of the <code>Image</code> object to <code>itemLoaded</code>, which is the same event handler we used for the audio file:
buttonSheet = new Image();

buttonSheet.onload = itemLoaded;
buttonSheet.src = "audiocontrols.png";
Now we need to create the <code>itemLoaded()</code> event handler. 
This function is quite simple. 

Every time it is called, we increment the <code>loadCount</code> variable. 
We then test <code>loadCount</code> to see whether it is equal to or has surpassed the number of items we want to preload, which is represented by the <code>itemsToLoad</code> variable. 
If so, we call the <code>canvasApp()</code> function to start our application:
function itemLoaded(event) { loadCount++;
 if (loadCount &gt;= itemsToLoad) { canvasApp();
 }
}

<h3>Setting Up the Audio Player Values</h3>
Inside the <code>canvasApp()</code> function we need to create some values to help us place all the various buttons and sliders on the canvas.
First, <code>bH</code> represents the height of all the controls; <code>bW</code> represents the width of a standard button (play/pause, loop/not loop):
var bW = 32;

var bH = 32;
Next, we set the width of the playback area, <code>playBackW</code>, and the width of the volume background, <code>volBackW</code>. 
We also set the slider’s width (<code>sliderW</code>) and height (<code>sliderH</code>):
var playBackW = 206;

var volBackW = 50;
var sliderW = 10;
var sliderH = 32;
We also need a couple variables to represent the <code>x</code> and <code>y</code> locations on the canvas where we will start to build our audio controls. 

We will define those as <code>controlStartX</code> and <code>controlStartY</code>:
var controlStartX = 25;
var controlStartY = 200;
Finally, we need to specify the <code>x</code> and <code>y</code> locations for the play/pause button (<code>playX</code>, <code>playY</code>), the playing slider background <code>(playBackX</code>, <code>playBackY</code>), the volume slider background (<code>volBackX</code>, <code>volBackY</code>), and the location of the loop/no loop toggle button (<code>loopX</code>, <code>loopY</code>):

var playX = controlStartX;
var playY = controlStartY;
var playBackX = controlStartX+bW
var playBackY = controlStartY;

var volBackX = controlStartX+bW+playBackW;
var volBackY = controlStartY;
var loopX = controlStartX+bW+playBackW+volBackW
var loopY = controlStartY;

We are going to use all of these values to help design and add functionality to our audio controls. 
It may seem like overkill to create so many variables, but when trying to “roll your own” collision detection and drag-and-drop functionality into the canvas, having variable names to manipulate instead of literals makes the job much easier.
<h3>Mouse Events</h3>
Since we are going to create our own functions for interactivity between the mouse and our custom canvas audio controls, we need to add some event handlers for certain common mouse events.

First, we need to create a couple variables—<code>mouseX</code> and <code>mouseY</code>—that will hold the current <code>x</code> and <code>y</code> locations of the mouse pointer:
var mouseX;
var mouseY;
Next, we need to create the event handlers. 

First, we listen for the <code>mouseup</code> event. 
This event fires when a user stops pressing the mouse button. 
We will listen for this event when we are trying to determine whether we should stop dragging the volume slider:
theCanvas.addEventListener("mouseup",eventMouseUp, false);

We also need to listen for the <code>mousedown</code> event to determine whether the play/pause button was pressed, the loop on/off toggle button was pressed, and/or the volume slider was clicked so we can start dragging it:
theCanvas.addEventListener("mousedown",eventMouseDown, false);
Finally, we listen for <code>mousemove</code> so we can figure out the current <code>x</code> and <code>y</code> locations of the mouse pointer. 
We use this value to determine whether buttons have been pressed, as well as whether the volume slider has been clicked and/or dragged:

theCanvas.addEventListener("mousemove",eventMouseMove, false);
<h3>Sliding Play Indicator</h3>
The sliding play indicator is the simplest control we are going to draw onto the canvas. 
It is not interactive—it just gives the user a visual indication of how much of the audio clip is left to play.

First of all, in <code>canvasApp()</code> we need to make sure that we call the <code>drawScreen()</code> function on an interval, so our updated controls will be displayed:
setInterval(drawScreen, 33);
<h3>Note</h3>
Unlike when displaying video on the canvas, we do not have to call <code>drawScreen()</code> to update the playing audio. 

In JavaScript, audio plays completely separate from the canvas. 
Our need to call <code>drawScreen()</code> on an interval is necessary because the audio controls we are creating need to be updated as the audio plays.
In the <code>drawScreen()</code> function we need to draw the slider and background on the canvas. 
We are going to “cut” all the images we display from the single <code>buttonSheet</code> image we loaded from <em>audiocontrols.png</em>. 

To draw the background, we use the values we set up earlier. 
We use literals (i.e., <code>32,0</code>) to locate the starting point of the image because those values do not change on the <code>buttonSheet</code> image. 
However, we use the variables we created to find the width and height, and to locate the final position of the background on the canvas:
context.drawImage(buttonSheet, 32,0,playBackW,bH,playBackX,playBackY,playBackW,bH);

Drawing the play slider is only a bit more complicated. 
Before we draw it, we need to create a variable that represents the relationship between the length of playing audio and the width of slider area. 
This is so we will know how far on the x-axis to move the slider based on how much of the song has played. 
This may sound complicated, but it’s just a simple fraction. 

Divide the width of the play background (<code>playBackW</code>) by the duration of the playing audio (<code>audioElement.duration</code>). 
We will store that ratio in <code>sliderIncrement</code> and use it to place the play slider on the canvas:
var slideIncrement = playBackW/audioElement.duration;
Now we need to calculate the <code>x</code> position of the slider. 

The <code>x</code> position is the sum of the slider’s starting position (the place on the canvas where the controls start plus the width of the play/pause button: <code>controlStartX+bW</code>) plus the audio’s current play position. 
We calculate the play position by taking the ratio we just created, <code>sliderIncrement</code>, and multiplying it by the current play time of the audio clip (<code>audioElement.currentTime</code>). 
That’s it!
var sliderX = (playBackW,bH,controlStartX+bW) + (slideIncrement*audioElement.currentTime);

Now all we need to do is draw the image onto the canvas, and then test to see whether the audio clip has ended. 
If it has ended, we put the play position back to the beginning of the playback area and call <code>audioElement.pause()</code> to pause the audio clip. 
That is, unless the <code>loop</code> property is sent, in which case we start playing the audio clip from the beginning by setting the <code>currentTime</code> property to <code>0</code>:
context.drawImage(buttonSheet, 238,0,sliderW,bH,sliderX,controlStartY,sliderW,bH);

if (audioElement.ended &amp;&amp; !audioElement.loop) {
 audioElement.currentTime = 0;
 audioElement.pause();
}

This leads us right into our next topic, handling the play/pause button.
<h3>Play/Pause Push Button: Hit Test Point Revisited</h3>
The first thing we need to do when implementing the play/pause button is create the event handler for the <code>mousemove</code> event. 
The function really is just the standard cross-browser code we introduced earlier in the book for tracking the mouse position, depending on which properties the DOM in browsers supports: <code>layerX</code>/<code>layerY</code> or <code>offsetX</code>/<code>offsetY</code>. 

This function is called every time the mouse is moved on the canvas to update the <code>mouseX</code> and <code>mouseY</code> variables. 
Those variables are scoped to <code>canvasApp()</code> so all functions defined inside of it can access them:
function eventMouseMove(event) { if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; }
 }

Now we need to create the <code>eventMouseUp()</code> handler function. 
This function is called when the user releases the mouse button after clicking. 
Why <em>after</em> and not when the mouse is clicked? Well, one reason is because we generally use the <code>mousedown</code> event for the start of a “dragging” operation, which we will show you shortly.
The heart of this function is a hit test point-style collision detection check for the buttons. 

We discussed this in depth in Chapter 6 when we created the buttons for the video puzzle game (<em>CH6EX10.html</em>). 
Notice that here we are using the variables we create to represent the <code>x</code> and <code>y</code> locations of the button (<code>playX</code>, <code>playY</code>) and the width and height of a button (<code>bW</code>, <code>bH</code>) to form the bounds of the area we will test. 
If the mouse pointer is within those bounds, we know the button has been clicked:

function eventMouseUp(event) {
if ( (mouseY &gt;= playY) &amp;&amp; (mouseY &lt;= playY+bH) &amp;&amp; (mouseX &gt;= playX) &amp;&amp; (mouseX &lt;= playX+bW) ) {
<h3>Note</h3>
If you had images stacked on top of one another, you would need to store some kind of stacking value or z-index to know which item was on top and was clicked at any one time. 

Because the canvas works in immediate mode, you would have to “roll your own” just like the other functionality we have discussed.
After a hit is detected, we need to determine whether we are going to call the <code>play()</code> or <code>pause()</code> method of the <code>HTMLAudioElement</code> object represented by the <code>audioElement</code> variable. 
To figure out which method to call, we simply test to see whether the audio is paused by checking the <code>audioElement.paused</code> property. 
If so, we call the <code>play()</code> method; if not, we call <code>pause()</code>. 

Recall that the <code>HTMLAudioElement.paused</code> property is set to <code>true</code> if the audio is not playing, regardless of whether the <code>paused()</code> function was called. 
This means that when the application starts but we have not set <code>autoplay</code>, we can easily display the proper button (play or pause) just by testing this property:
 if (audioElement.paused) { audioElement.play();
 } else { audioElement.pause(); }
 }
}
Now, in <code>drawScreen()</code> we need to choose which button to display: the one representing play (green triangle) or pause (two horizontal boxes). 

The play button is displayed when the audio is paused, and the pause button is displayed when the audio is playing. 
This button is a “call to action,” so it displays what will happen when you click on it, not the status of the audio element that is playing. 
This <em>inverse relationship</em> exists because it is the standard way audio players work.
If the <code>audioElement</code> is paused, we display the graphic from the top row of the <em>audiocontrols.png</em> image represented by <code>buttonSheet</code> (see Figure 7-5). 
If it is not paused, we display the button on the second row right below it. 
Since that button starts at the <code>y</code> position of <code>32</code>, we use that literal value in the call to <code>drawImage()</code>:
if (audioElement.paused) { context.drawImage(buttonSheet, 0,0,bW,bH,playX,playY,bW,bH);//show play
} else {
 context.drawImage(buttonSheet, 0,32,bW,bH,playX,playY,bW,bH); //show pause
}

<h3>Note</h3>
Again, we could have represented the literal values of locations in the <code>buttonSheet</code> with variables, but we decided to use literals to show you the difference between how we specify <code>buttonSheet</code> pixel locations, and how we calculate widths and distances for placing those elements.
<h3>Loop/No Loop Toggle Button</h3>
Implementing the loop/no loop toggle button is nearly identical to implementing the play/pause button. 

In Figure 7-5, you can see that the last two buttons on the bottom row represent the “on” and “off” states of the loop/no loop button. 
Unlike the play/pause button, this button shows the “state” of looping: the lighter, 3D-looking “out” button is displayed when the audio is not set to loop. 
The inverse, darker button is displayed when the audio is set to loop (because it looks like the button has been pressed).

In the <code>eventMouseUp()</code> function, we need to add support for loop/no loop. 
First, we test for a hit test point on the button with the current location of the mouse pointer. 
This is identical to the test we did for the play/pause button, except that we use <code>loopX</code> and <code>loopY</code> to find the current location of the loop/no loop button.
Next, we check the value of <code>audioElement.loop</code>. 

We need to update the value to the opposite of the current setting. 
If <code>loop</code> is <code>true</code>, we set it to <code>false</code>; if it is <code>false</code>, we set it to <code>true</code>:
if ( (mouseY &gt;=loopY) &amp;&amp; (mouseY &lt;= loopY+bH) &amp;&amp; (mouseX &gt;= loopX) &amp;&amp; (mouseX &lt;= loopX+bW) ) {
 if (audioElement.loop) { audioElement.loop = false; } else { audioElement.loop = true;
 }
Finally, in <code>drawScreen()</code> we will display the proper part of the <code>buttonSheet</code> image for whichever state of loop/no loop is currently set. 
Unlike play/pause, we display the “off” state when <code>loop</code> is <code>false</code> and the “on” state when it is set to <code>true</code> because, again, there is not an inverse relationship to the states of the button:

if (audioElement.loop) { context.drawImage(buttonSheet, 114,32,bW,bH,loopX,loopY,bW,bH);//loop
 } else { context.drawImage(buttonSheet, 82,32,bW,bH,loopX,loopY,bW,bH); // no loop }
<h3>Click-and-Drag Volume Slider</h3>
So now we make it to the last, but certainly not least, piece of functionality for the audio player: the volume slider. 

The volume slider is an interactive control allowing the user to manipulate it by sliding it right or left to control the volume of the playing audio element. 
Before we create the volume slider, we need to define some boundaries for its usage:

The slider never moves on the y-axis; it will always keep a constant <code>y</code> value.
The farther the volume slider is to the right (the greater the <code>x</code> value), the higher the volume.
The slider moves on the x-axis but is bounded by the starting <code>x</code> value of the volume slider image—<code>volumeSliderStart</code> on the left and <code>volumeSliderEnd</code> on the right.
When the user clicks on the volume slider, we will assume that the user wants to set the volume, so we will start “dragging” the slider. 

This means that if the user moves the mouse on the x-axis, we will move the slider accordingly.
When the user takes his finger off the mouse button, we will assume that he no longer wishes to set the volume, and we still stop “dragging” the slider.
The volume will be set based on the slider’s position on the x-axis in relation to the <code>volumeSliderStart</code> plus a ratio (<code>volumeIncrement</code>) that we create describing how much volume to increase or decrease based on where the slider rests.
</li>

</ul>
<h4>Volume slider variables</h4>
OK, now that we have thoroughly confused you, let’s talk about the process in depth. 
First, we start with the <code>canvasApp()</code> function. 

In <code>canvasApp()</code> we need to set up some variables to set the rules we defined in the list above.
The starting <code>x</code> position for the volume slider is <code>volumeSliderStart</code>. 
When the application starts, it is equal to the <code>x</code> position of the volume background, or <code>volBackX</code>. 
This means it will start at the leftmost edge of the volume slider where the <code>volume</code> will be set to <code>0</code>. 

We will update this to the correct position based on the <code>volume</code> as soon as we calculate that value:
var volumeSliderStart = volBackX;
The final <code>x</code> position for the volume slider is <code>volumeSliderEnd</code>, which is the rightmost position. 
It is the position where the volume will be set to 100% (or <code>1</code>). 

This position lies at the <code>x</code> position of <code>volumeSliderStart</code> plus the width of the volume slider background (<code>volBackW</code>), less the width of the volume slider itself (<code>sliderW</code>):
var volumeSliderEnd = volumeSliderStart + volBackW - sliderW;
<code>volumeSliderX</code> and <code>volumeSliderY</code> are the slider’s <code>x</code> and <code>y</code> positions on the canvas. 
The <code>y</code> position is the same as the other elements in the audio player, <code>controlStartY</code>. 

However, the <code>x</code> position is calculated in quite a different way. 
First, we take the value of <code>volumeSliderStart</code> and add the difference between slider volume background width and the slider width (<code>volBackW – sliderW</code>), multiplied by the <code>volume</code> property of the <code>audioElement</code>, which is a number between <code>0</code> and <code>1</code>. 
This will give us the position relative to the starting point from which we want to draw the volume slider for any given volume setting:
var volumeSliderX = volumeSliderStart + (audioElement.volume* (volBackW - sliderW));

var volumeSliderY = controlStartY;
Next, we create the <code>volumeSliderDrag</code> variable, which we will use as a switch to tell us whether the volume slider is being dragged by the user at any given moment:
var volumeSliderDrag = false;
Finally, we create the <code>volumeIncrement</code> variable. 

This variable tells us how much volume to increase or decrease on the <code>audioElement.volume</code> property based on where the slider is positioned on the volume background. 
Since the maximum value of the volume is <code>1</code>, we simply find the total width that the volume slider can move on the x-axis (<code>volBackW - sliderW</code>) and divide <code>1</code> by that value. 
This will give us a product that we can multiply by the <code>x</code> position of the slider, relative to <code>volumeSliderStart</code>, to give us the volume we should set for the <code>audioElement</code>:
var volumeIncrement = 1/(volBackW - sliderW);

<h4>Volume slider functionality</h4>
Now that we have discussed the variables we need for the volume slider, we will talk about how we use them in the various functions of the audio player. 
The good news is that the implementation is simple now that you know how the variables work.
In the <code>eventMouseDown()</code> handler, we perform a hit test point-style test, just like we did with the play/pause and loop/no loop buttons to see whether the volume slider was clicked. 

If so, we set the <code>volumeSliderDrag</code> variable to <code>true</code>. 
This means that the volume slider will now to move to the <code>x</code> position of the mouse when we call <code>drawScreen()</code>:
function eventMouseDown(event) {
if ( (mouseY &gt;= volumeSliderY) &amp;&amp; (mouseY &lt;=volumeSliderY+sliderH) &amp;&amp; (mouseX &gt;= volumeSliderX) &amp;&amp; (mouseX &lt;= volumeSliderX+sliderW) ) { volumeSliderDrag = true; }
 }
In the <code>eventMouseUp()</code> handler, we test to see whether the <code>volumeSliderDrag</code> is set to <code>true</code>. 
If so, it means that the user has released the mouse button and no longer wants to drag the volume slider. 

We set <code>volumeSliderDrag</code> to <code>false</code> so the slider will not move with the mouse:
if (volumeSliderDrag) { volumeSliderDrag = false; }
In <code>drawScreen()</code> we actually put the pixels to the canvas, so to speak, with the volume slider. 
First, we draw the background image from <code>buttonSheet</code>:

//vol Background context.drawImage(buttonSheet, 32,32,volBackW,bH,volBackX,volBackY,volBackW,bH);
Next, we check to see whether <code>volumeSliderDrag</code> is <code>true</code>. 
If so, we make the <code>volume</code><code>SliderX</code> variable equal to the mouse’s <code>x</code> position. 
Then, we drop in a couple more tests to determine whether the <code>x</code> position of the volume slider falls outside the bounds of the volume background. 

These two tests make sure that the volume slider does not move past the rightmost or leftmost sides of the volume slider background, and in turn, the <code>volume</code> property of <code>audioElement</code> is not calculated to be more than <code>1</code> or less than <code>0</code>:
if (volumeSliderDrag) {
 volumeSliderX = mouseX;
 if (volumeSliderX &gt; volumeSliderEnd) { volumeSliderX = volumeSliderEnd; }
 if (volumeSliderX &lt; volumeSliderStart) { volumeSliderX = volumeSliderStart;
 }
If the <code>volumeSliderDrag</code> is <code>false</code>, we still need an <code>x</code> position at which to draw the slider graphic. 

We get this the same way we calculated the <code>volumeSliderX</code> when we initialized the variable in the <code>canvasApp()</code> function:
} else {
 volumeSliderX = volumeSliderStart + (audioElement.volume* (volBackW -sliderW));
}

Finally, we draw the slider onto the canvas:
context.drawImage(buttonSheet, 238,0,sliderW,bH,volumeSliderX, volumeSliderY, sliderW,bH);
audioElement.volume = (volumeSliderX-volumeSliderStart) * volumeIncrement;
Figure 7-6 displays the custom controls in the browser.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893799.png" alt="Canvas sound player with custom controls" width="500" height="300">
Figure 7-6. 
Canvas sound player with custom controls

So there you have it. 
You can test the audio player as <em>CH7EX5.html</em> in the source code. 
The full code listing for the HTML5 Canvas audio player is shown in Example 7-5</a>.
Example 7-5. 

A custom audio player on the canvas
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH7EX5: A Custom Sound Player On The Canvas&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
var loadCount = 0;
var itemsToLoad = 2;
var buttonSheet;

var audioElement;
function eventWindowLoaded() {
 audioElement = document.createElement("audio");
 document.body.appendChild(audioElement); var audioType = supportedAudioFormat(audioElement);
 if (audioType == "") { alert("no audio support"); return;
 }
 audioElement.setAttribute("src", "song1." + audioType); audioElement.addEventListener("canplaythrough",itemLoaded,false);
 buttonSheet = new Image();
 buttonSheet.onload = itemLoaded;
 buttonSheet.src = "audiocontrols.png";

}
function supportedAudioFormat(audio) {
 var returnExtension = "";
 if (audio.canPlayType("audio/ogg") =="probably" || audio.canPlayType("audio/ogg") == "maybe") { returnExtension = "ogg"; } else if(audio.canPlayType("audio/wav") =="probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "wav";
 } else if(audio.canPlayType("audio/mp3") == "probably" || audio.canPlayType("audio/mp3") == "maybe") { returnExtension = "mp3";
 }
 return returnExtension;

}
function canvasSupport () { return Modernizr.canvas;
}
function itemLoaded(event) { loadCount++;
 if (loadCount &gt;= itemsToLoad) { canvasApp();
 }
}

function canvasApp() {
 if (!canvasSupport()) { return; }
 function drawScreen () {
 //Background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, theCanvas.width, theCanvas.height);
 //Box context.strokeStyle = "#000000"; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
 // Text context.fillStyle = "#000000"; context.fillText ("Duration:" + audioElement.duration, 20 ,20); context.fillText ("Current time:" + audioElement.currentTime, 250 ,20); context.fillText ("Loop: " + audioElement.loop, 20 ,40); context.fillText ("Autoplay: " +audioElement.autoplay, 250 ,40); context.fillText ("Muted: " + audioElement.muted, 20 ,60); context.fillText ("Controls: " + audioElement.controls, 250 ,60); context.fillText ("Volume: " + audioElement.volume, 20 ,80); context.fillText ("Paused: " + audioElement.paused, 250 ,80); context.fillText ("Ended: " + audioElement.ended, 20 ,100); context.fillText ("Can Play OGG: " + audioElement.canPlayType("audio/ogg"), 250 ,100); context.fillText ("Can Play WAV: " + audioElement.canPlayType("audio/wav"), 20 ,120); context.fillText ("Can Play MP3: " + audioElement.canPlayType("audio/mp3"), 250 ,120); context.fillText ("Source: " + audioElement.currentSrc, 20 ,140); context.fillText ("volumeSliderDrag: " + volumeSliderDrag, 20 ,160);
 //Draw Controls //play or pause if (audioElement.paused) { context.drawImage(buttonSheet, 0,0,bW,bH,playX,playY,bW,bH);//show play
 } else { context.drawImage(buttonSheet, 0,32,bW,bH,playX,playY,bW,bH); //show pause
 } //loop if (audioElement.loop) { context.drawImage(buttonSheet, 114,32,bW,bH,loopX,loopY,bW,bH);//show loop } else { context.drawImage(buttonSheet, 82,32,bW,bH,loopX,loopY,bW,bH); //show no loop }
 //play background context.drawImage(buttonSheet, 32,0,playBackW,bH,playBackX,playBackY,playBackW,bH);
 //vol Background context.drawImage(buttonSheet, 32,32,volBackW,bH,volBackX,volBackY,volBackW,bH); //play slider var slideIncrement = playBackW/audioElement.duration; var sliderX = (playBackW,bH,controlStartX+bW) + (slideIncrement*audioElement.currentTime); context.drawImage(buttonSheet, 238,0,sliderW,bH,sliderX,controlStartY,sliderW,bH);
 //Go back to start if (audioElement.ended &amp;&amp; !audioElement.loop) { audioElement.currentTime = 0; audioElement.pause(); }
 //Volume slider //Test Volume Drag if (volumeSliderDrag) { volumeSliderX = mouseX; if (volumeSliderX &gt; volumeSliderEnd) { volumeSliderX = volumeSliderEnd; } if (volumeSliderX &lt; volumeSliderStart) { volumeSliderX = volumeSliderStart; } } else { volumeSliderX = volumeSliderStart + (audioElement.volume*(volBackW -sliderW)); } context.drawImage(buttonSheet, 238,0,sliderW,bH,volumeSliderX,volumeSliderY, sliderW,bH); audioElement.volume = (volumeSliderX-volumeSliderStart) * volumeIncrement;
 }
 function eventMouseDown(event) {
 //Hit Volume Slider if ( (mouseY &gt;= volumeSliderY) &amp;&amp; (mouseY &lt;=volumeSliderY+sliderH) &amp;&amp; (mouseX &gt;= volumeSliderX) &amp;&amp; (mouseX &lt;= volumeSliderX+sliderW) ) { volumeSliderDrag = true; }
 }
 function eventMouseMove(event) { if ( event.layerX || event.layerX == 0) { mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { mouseX = event.offsetX; mouseY = event.offsetY; }
 } function eventMouseUp(event) {
 //Hit Play if ( (mouseY &gt;= playY) &amp;&amp; (mouseY &lt;= playY+bH) &amp;&amp; (mouseX &gt;= playX) &amp;&amp; (mouseX &lt;= playX+bW) ) { if (audioElement.paused) { audioElement.play();
 } else { audioElement.pause();
 } }
 //Hit loop if ( (mouseY &gt;=loopY) &amp;&amp; (mouseY &lt;= loopY+bH) &amp;&amp; (mouseX &gt;= loopX) &amp;&amp; (mouseX &lt;= loopX+bW) ) { if (audioElement.loop) { audioElement.loop=false;
 } else { audioElement.loop = true;
 } }
 if (volumeSliderDrag) { volumeSliderDrag = false; }
 }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 var bW = 32;
 var bH = 32;
 var playBackW = 206; var volBackW = 50;
 var sliderW = 10;
 var sliderH = 32;
 var controlStartX = 25; var controlStartY =200;
 var playX = controlStartX;
 var playY = controlStartY;
 var playBackX = controlStartX+bW; var playBackY = controlStartY;
 var volBackX = controlStartX+bW+playBackW;
 var volBackY = controlStartY;
 var loopX = controlStartX+bW+playBackW+volBackW; var loopY = controlStartY;
 var mouseX;
 var mouseY;
 theCanvas.addEventListener("mouseup",eventMouseUp, false); theCanvas.addEventListener("mousedown",eventMouseDown, false);
 theCanvas.addEventListener("mousemove",eventMouseMove, false);
 audioElement.play();
 audioElement.loop = false; audioElement.volume = .5;
 var volumeSliderStart = volBackX;
 var volumeSliderEnd = volumeSliderStart + volBackW -sliderW;
 var volumeSliderX = volumeSliderStart + (audioElement.volume*(volBackW -sliderW)); var volumeSliderY = controlStartY;
 var volumeSliderDrag = false;
 var volumeIncrement = 1/(volBackW -sliderW);
 setInterval(drawScreen, 33);

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="300"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
<h2>Case Study in Audio: Space Raiders Game</h2>
If we were writing a book about standard HTML5, we might be able to stop here and continue on with another topic. 
However, there is a lot more to playing audio in an application than simply getting a song to play and tracking its progress. 
In the last part of this chapter, we will look at a case study: <em>Space Raiders</em>. 
We will iterate through several ideas and attempts to get audio working in an efficient way in conjunction with action on HTML5 Canvas.

<h3>Why Sounds in Apps Are Different: Event Sounds</h3>
Why make a game as an example for playing sounds in HTML5? Well, a game is a perfect example because it is difficult to predict how many sounds might be playing at any one time.
If you can imagine, games are some of the most demanding applications when it comes to sound. 
In most games, sounds are played based on user interactions, and those interactions are usually both asynchronous and unpredictable. 

Because of those factors, we need to create a strategy for playing sounds that is flexible and resource-efficient.
To demonstrate how tricky sounds can be when using JavaScript and HTML5 with a canvas game, we will iterate this game several times until we have a working model.
Here are some assumptions we will make regarding sound in <em>Space Raiders</em> based on what we know about the HTML5 <code>audio</code> object.
After loading a sound, you can make another object with the same source and “load” it without having to wait for it to load. 

(Flash sort of works this way.)
Playing sounds locally is the same as playing them on a remotely hosted web page.
</li>
</ol>

It turns out that both of these assumptions are <em>wrong</em>. 
As we continue through this case study, we will show you why, as well as how to accommodate them.
Since this is not a chapter about making games, <em>Space Raiders</em> is only going to be a fa ade. 
In Hollywood, a fa ade is a structure built for filming, containing only the parts the camera will see. 

For example, a building fa ade might have only the front wall and windows—with nothing behind them. 
<em>Space Raiders</em> is like this because we are only going to create the parts necessary to include the dynamic sounds we will be using. 
It will be most of a game, leading you into Chapters 8 and 9, which take a deep dive into making complete games with HTML5 Canvas.
<h3>Iterations</h3>
In this case study, we will create four iterations of <em>Space Raiders</em>. 
Each one will attempt to solve a dynamic audio problem in a different way. 

First, we will show you the basics of the <em>Space Raiders</em> game structure, and then we will discuss how to solve the audio problem.
<h3>Space Raiders Game Structure</h3>
<em>Space Raiders</em> is an iconic action game where a swarm of alien invaders attack from the top of the screen, and the player’s job is to defend the world. 
The raiders move in horizontal lines near the top of the screen. 

When each raider reaches the side of the playfield, it moves down the screen and then switches direction.
The player controls a spaceship by moving the mouse, and fires missiles using the left mouse button. 
We need to play a “shoot” sound every time the player fires a missile. 
When the missiles hit the enemy space raiders, we need to remove them from the screen, and then play an “explosion” sound. 

We are not limiting the number of shots the player can fire, which means that there could be any number of shoot and explode sounds playing simultaneously. 
Our goal is to manage all these dynamic sounds.
<h4>State machine</h4>
This game runs using a very simple state machine. 

A <em>state machine</em> is a construct that allows an application to exist in only one state at a time, which means it is only doing one thing. 
This kind of construct is great for single-player games because it removes the need to hold a bunch of Booleans describing what is going on at any one moment.
<em>Space Raiders</em> has four states plus a variable named <code>appState</code> that holds the value of the current state. 
Those states include:

<code>STATE_INIT</code>
A state to set up the loading of assets:

const STATE_INIT = 10;
<code>STATE_LOADING</code>

A wait state that has the application sleep until all assets have been loaded:
const STATE_LOADING = 20;
<code>STATE_RESET</code>

A state to set up the initial game values:
const STATE_RESET = 30;

<code>STATE_PLAYING</code>
A state that handles all game-play logic:
const STATE_PLAYING = 40;

<h3>Note</h3>
A final game of this type might have a few more states, such as <code>STATE_END_GAME</code> and <code>STATE_NEXT_LEVEL</code>, but our case study does not require them.

The heart of our state machine is the <code>run()</code> function, which is called on an interval every 33 milliseconds. 
The <code>appState</code> variable determines what function to call at any given time using a <code>switch()</code> statement. 
<code>appState</code> is updated to a different state any time the program is ready to move on and do something else. 
The process of calling a function such as <code>run()</code> on an interval and switching states is commonly known as a <em>game loop</em>:

function run() { switch(appState) { case STATE_INIT: initApp(); break; case STATE_LOADING: //wait for call backs break; case STATE_RESET: resetApp(); break; case STATE_PLAYING: drawScreen(); break;
 }
}
<h4>Initializing the game: no global variables</h4>

Now that we know a bit about the state machine construct we will use for this game, it’s time to set up the preload for our assets. 
As we mentioned previously, this game has two sounds, shoot and explode, but it also has three images: a player, an alien, and a missile.
Remember how we kept saying we’d do away with global variables in these applications? Well, here’s where it happens. 
With the state machine, we now have a mechanism to allow our application to wait for loading assets instead of leveraging only the DOM’s window <code>load</code> event.

In the <code>canvasApp()</code> function, we set up the following variables to use in the game.
The <code>appState</code> variable holds the current state constant:
var appState = STATE_INIT;
We use the <code>loadCount</code> and <code>itemsToLoad</code> variables in exactly the same way we used them in the audio player application—except here we will be loading more items:

var loadCount= 0;
var itemsToLoad = 0;
The variables <code>alienImage</code>, <code>missileImage</code>, and <code>playerImage</code> will hold the loaded images we use in the game:
var alienImage = new Image();

var missileImage = new Image();
var playerImage = new Image();
<code>explodeSound</code> and <code>shootSound</code> will hold the references to the <code>HTMLAudioElement</code> objects we will load:
var explodeSound ;

var shootSound;
The <code>audioType</code> variable will hold the extension of the valid audio file type for the browser displaying the application:
var audioType;
The <code>mouseX</code> and <code>mouseY</code> variables will hold the current <code>x</code> and <code>y</code> location of the mouse:

var mouseX;
var mouseY;
The <code>player</code> variable will hold a dynamic object with the <code>x</code> and <code>y</code> location of the player ship (controlled with the mouse):
var player = {x:250,y:475};

Both the <code>aliens</code> and <code>missiles</code> arrays will hold lists of dynamic objects for displaying aliens and missiles on the canvas:
var aliens = new Array();
var missiles = new Array();
The next five constants set the number of aliens (<code>ALIEN_ROWS</code>, <code>ALIEN_COLS</code>), their starting location (<code>ALIEN_START_X</code>, <code>ALIEN_START_Y</code>), and their spacing on screen (<code>ALIEN_SPACING</code>):

const ALIEN_START_X = 25;
const ALIEN_START_Y = 25;
const ALIEN_ROWS = 5;
const ALIEN_COLS = 8;

const ALIEN_SPACING = 40;
Also in the <code>canvasApp()</code> function, we need to set up event handlers for <code>mouseup</code> and <code>mousemove</code>. 
To create the game loop, we need to set up our interval to call the <code>run()</code> function:
theCanvas.addEventListener("mouseup",eventMouseUp, false);

theCanvas.addEventListener("mousemove",eventMouseMove, false);
setInterval(run, 33);
At this point, <code>run()</code> will be called and our game loop will start by calling the function associated with the value of <code>appState</code>.
<h4>Preloading all assets without global variables</h4>

We just showed that the <code>appState</code> variable was initialized to <code>STATE_INIT</code>, which means that when the <code>run()</code> function is called for the first time, the <code>initApp()</code> function will be called. 
The good news (at least for this discussion) is that <code>initApp()</code> does very little that we have not already seen—it just does it in the context of the Canvas application. 
The result? Now we don’t need any global variables.
In the code below, notice that we are using the same strategy. 

We have a single event handler for all loaded assets (<code>itemLoaded()</code>),we set <code>itemsToLoad</code> to <code>5</code> (three graphics and two sounds), and we set the <code>appState</code> to <code>STATE_LOADING</code> at the end of the function. 
The rest of the code is all simple review:
function initApp() {
 loadCount=0; itemsToLoad = 5;
 explodeSound = document.createElement("audio");
 document.body.appendChild(explodeSound);
 audioType = supportedAudioFormat(explodeSound); explodeSound.setAttribute("src", "explode1." + audioType);
 explodeSound.addEventListener("canplaythrough",itemLoaded,false);
 shootSound = document.createElement("audio");
 document.body.appendChild(shootSound); shootSound.setAttribute("src", "shoot1." + audioType);
 shootSound.addEventListener("canplaythrough",itemLoaded,false);
 alienImage = new Image();
 alienImage.onload = itemLoaded; alienImage.src = "alien.png";
 playerImage = new Image();
 playerImage.onload = itemLoaded;
 playerImage.src = "player.png"; missileImage = new Image();
 missileImage.onload = itemLoaded;
 missileImage.src = "missile.png"; appState = STATE_LOADING;
 }

If you recall, <code>STATE_LOADING</code> does nothing in our <code>run()</code> function; it just waits for all events to occur. 
The action here is handled by the <code>itemLoaded()</code> event handler, which works exactly like the <code>itemLoaded()</code> function we wrote for the audio player, except that it has two additional functions:
It must remove the event listeners from the two <code>sound</code> objects we created. 
This is because, in some browsers, calling the <code>play()</code> method of an <code>HTMLAudioElement</code> object—or changing the <code>src</code> attribute of an <code>HTMLAudioElement</code> object—initiates a <code>load</code> operation, which will then call the <code>itemLoaded</code> event handler a second time. 

This will cause unexpected results in your application. 
Furthermore, it is always a good idea to remove unneeded event handlers from your objects.
We set the <code>appState</code> to <code>STATE_RESET</code>, which will initialize the game the next time the <code>run()</code> function is called on the interval.
</li>

</ol>
Here is the code with the two additional functions:
function itemLoaded(event) {
 loadCount++; if (loadCount &gt;= itemsToLoad) {
 shootSound.removeEventListener("canplaythrough",itemLoaded, false); explodeSound.removeEventListener("canplaythrough",itemLoaded,false);
 appState = STATE_RESET;
 } }
<h4>Resetting the game</h4>
In the <code>run()</code> function, the <code>STATE_RESET</code> state calls the <code>resetApp()</code> function, which in turn calls <code>startLevel()</code>. 
It also sets the volume of our two sounds to 50% (<code>.5</code>) before setting the <code>appState</code> to <code>STATE_PLAYING</code>:

function resetApp() {
 startLevel();
 shootSound.volume = .5;
 explodeSound.valume = .5; appState = STATE_PLAYING;
 }
The <code>startLevel()</code> function traverses through two nested <code>for:next</code> loops, creating the rows of aliens by column. 
Each time we create an alien, we push a dynamic object into the <code>aliens</code> array with the following properties:

<code>speed</code>
The number of pixels the aliens will move left or right on each call to <code>drawScreen()</code>.

<code>x</code>
The starting <code>x</code> position of the alien on the screen. 

This value is set by the column (<code>c</code>) multiplied by <code>ALIEN_SPACING</code>, added to <code>ALIEN_START_X</code>.
<code>y</code>

The starting <code>y</code> position of the alien on the screen. 
This is set by the row (<code>r</code>) multiplied by <code>ALIEN_SPACING</code>, added to <code>ALIEN_START_X.</code>
<code>width</code>

The width of the alien image.
<code>height</code>

The height of the alien image.

Here is the code for the <code>startLevel()</code> function:
function startLevel() {
 for (var r = 0; r &lt; ALIEN_ROWS; r++) { for( var c= 0; c &lt; ALIEN_COLS; c++) { aliens.push({speed:2,x:ALIEN_START_X+c*ALIEN_SPACING, y:ALIEN_START_Y+r* ALIEN_SPACING,width:alienImage.width, height:alienImage.height}); } }
 }

<h4>Mouse control</h4>
Before we talk about the game play itself, let’s quickly discuss mouse event handlers, which will collect all user input for the game. 
When the player moves the mouse, the <code>eventMouseMove()</code> handler is called. 
This function operates just like the same function we created for the audio player, except for the last two lines. 

Those two lines set the <code>x</code> and <code>y</code> properties of the <code>player</code> object we created back in the variable definition section of <code>canvasApp()</code>. 
We will use these two properties to position the <code>playerImage</code> on the canvas in the <code>drawScreen()</code> function:
function eventMouseMove(event) { if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; } player.x = mouseX; player.y = mouseY;
 }

The <code>eventMouseUp()</code> handler is called when the player presses and releases the left mouse button. 
When this event occurs, a missile will fire. 
The <code>missile</code> object is almost identical to the <code>alien</code> object, as it includes <code>speed</code>, <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> properties. 
Since the player is firing the missile, we set the missile’s <code>x</code> and <code>y</code> positions to the center of the player’s ship on the x-axis (<code>player.x+.5*playerImage.width</code>), and to the <code>y</code> position of the player’s ship, minus the height of the missile (<code>player.y - missileImage.height</code>):

function eventMouseUp(event) {
 missiles.push({speed:5, x: player.x+.5*playerImage.width, y:player.y-missileImage.height,width:missileImage.width, height:missileImage.height});
Next is the first really critical line of code for the subject at hand: audio. 
For this first iteration of <em>Space Raiders</em>, we simply call the <code>play()</code> function of <code>shootSound</code>. 

This will play the shoot sound as often as the player presses the left mouse button (in theory):
 shootSound.play();
}
<h4>Bounding box collision detection</h4>

Before we get to the main part of the game logic, we should discuss bounding box collision detection. 
We need to detect collisions between the missiles the player fires and the aliens the player is firing upon. 
To do this, we will create a function that tests to see whether two objects are overlapping. 
For lack of a better name, we call this function <code>hitTest()</code>.

The type of hit test we are going to perform is called a bounding box collision test. 
This means that we are going to ignore the intricate details of the bitmapped graphics and simply test to see whether an invisible “box” drawn around the bounds of each object overlaps with a similar box drawn around the other objects.
Recall that both the <code>alien</code> and <code>missile</code> dynamic objects were created with similar properties: <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code>. 
This was so the <code>hitTest()</code> function could test them as generic objects, unspecific to the type of on-screen object that they represent. 

This means that we can add any other type of object to this game (boss alien, power-ups, enemy missiles, etc.), and if it is created with similar properties, we can use the same function to test collisions against it.
The function works by finding the top, left, bottom, and right values for each object, and then testing to see whether any of those values overlap. 
Bounding box collision detection will be discussed in detail in Chapter 8, but we just wanted to give you a preview of what it looks like for <em>Space Raiders</em>:

function hitTest(image1,image2) { r1left = image1.x; r1top = image1.y; r1right = image1.x + image1.width; r1bottom = image1.y + image1.height; r2left = image2.x; r2top = image2.y; r2right = image2.x + image2.width; r2bottom = image2.y + image2.height; retval = false;
 if ( (r1left &gt; r2right) || (r1right &lt; r2left) || (r1bottom &lt; r2top) || (r1top &gt; r2bottom) ) { retval = false; } else { retval = true; }
 return retval;
 }

<h4>Playing the game</h4>
Now the game is ready to play. 
<code>STATE_PLAYING</code> calls the <code>drawScreen()</code> function, which is the heart of <em>Space Raiders</em>. 
The first part of this function simply moves the missiles and aliens on the screen. 

Moving the missiles is quite easy. 
We loop through the array (backward), updating the <code>y</code> property of each with the <code>speed</code> property. 
If they move off the top of the screen, we remove them from the array. 
We move through the array backward so that we can <code>splice()</code> array elements out of the array and not affect loop length. 

If we did not do this, elements would be skipped after we <code>splice()</code> the array:
for (var i=missiles.length-1; i&gt;= 0;i,,) {
 missiles[i].y ,= missiles[i].speed;
 if (missiles[i].y &lt; (0-missiles[i].height)) { missiles.splice(i,1); }
}
Drawing the aliens is similar to drawing missiles—with a few exceptions. 
Aliens move left and right, and when they reach the side of the canvas, they move down <code>20</code> pixels and then reverse direction. 

To achieve the reversal in direction, multiply the <code>speed</code> property by <code>-1</code>. 
If the aliens are moving to the right (<code>speed = 2</code>), this will make the <code>speed = -2</code>, which will subtract from the <code>x</code> position and move the aliens to the left. 
If the aliens hit the left side of the canvas, the <code>speed</code> property will again be multiplied by <code>-1</code> (<code>-2 * -1</code>), which will equal <code>2</code>. 
The alien will then move to the right because <code>2</code> will be added to the <code>x</code> value for the alien each time <code>drawScreen()</code> is called:

//Move Aliens for (var i=aliens.length,1; i&gt;= 0;i,,) { aliens[i].x += aliens[i].speed; if (aliens[i].x &gt; (theCanvas.width-aliens[i].width) || aliens[i].x &lt; 0) { aliens[i].speed *= -1; aliens[i].y += 20; } if (aliens[i].y &gt; theCanvas.height) { aliens.splice(i,1); }
 }
The next step in <code>drawScreen()</code> is to detect collisions between the aliens and the missiles. 
This part of the code loops through the <code>missiles</code> array backward while nesting a loop through the <code>aliens</code> array. 

It will test every missile against every alien to determine whether there is a collision. 
Since we have already covered the <code>hitTest()</code> function, we only need to discuss what happens if a collision is detected. 
First, we call the <code>play()</code> function of the <code>explodeSound</code>. 
This is the second critical line of code in this iteration of <em>Space Raiders</em>, as it plays (or attempts to play) the explosion sound every time a collision is detected. 

After that, it splices the <code>alien</code> and <code>missile</code> objects out of their respective arrays, and then breaks out of the nested <code>for:next</code> loop. 
If there are no aliens left to shoot, we set the <code>appState</code> to <code>STATE_RESET</code>, which will add more aliens to the canvas so the player can continue shooting:
missile: for (var i=missiles.length,1; i&gt;= 0;i,,) { var tempMissile = missiles[i] for (var j=aliens.length-1; j&gt;= 0;j,,) { var tempAlien =aliens[j]; if (hitTest(tempMissile,tempAlien)) { explodeSound.play(); missiles.splice(i,1); aliens.splice(j,1); break missile; } }
 if (aliens.length &lt;=0) { appState = STATE_RESET; } }

The last few lines of code in <code>drawScreen()</code> loop through the <code>missiles</code> and <code>aliens</code> arrays, and draw them onto the canvas. 
This is done using the <code>drawImage()</code> method of the <code>context</code> object, and the <code>x</code> and <code>y</code> properties we calculated earlier. 
Finally, it draws the <code>playerImage</code> on the canvas, and the function is finished:
//Draw Missiles for (var i=missiles.length,1; i&gt;= 0;i,,) { context.drawImage(missileImage,missiles[i].x,missiles[i].y); }
//draw aliens for (var i=aliens.length,1; i&gt;= 0;i,,) { context.drawImage(alienImage,aliens[i].x,aliens[i].y);
 }
//Draw Player context.drawImage(playerImage,player.x,player.y);

Like we stated previously, <em>Space Raiders</em> is not a full game. 
We have only implemented enough to get the player to shoot missiles so we can play the shoot sound, and to detect collisions so we can play the explode sound.
<h3>Iteration #1: Playing Sounds Using a Single Object</h3>
We just described the first iteration of the dynamic audio code. 

It works by attempting to call the <code>play()</code> function of both <code>shootSound</code> and <code>explodeSound</code> as often as necessary. 
This appears to work at first, but if you listen carefully (and this is apparent on some browsers more than others), the sounds start to play “off,” or not play at all. 
This is because we are using a single object and attempting to play and replay the same sound over and over. 
A single <code>HTMLAudioElement</code> was not designed to operate this way. 

You can test this example in the code distribution by running <em>CH7EX6.html</em> in your HTML5-compliant web browser. 
Press the fire button as quickly as possible and listen to when and how the sounds play. 
After a bit, they start to play at the wrong time, don’t finish, or don’t play at all. 
Figure 7-7 shows what the first iteration of <em>Space Raiders</em> looks like in a web browser.
<h3>Iteration #2: Creating Unlimited Dynamic Sound Objects</h3>
So, we almost got what we wanted with the first iteration, but we ran into some oddities when calling the <code>play()</code> function on a single <code>HTMLAudioElement</code> multiple times before the sound had finished playing.
For our second iteration, we are going to try something different. 

Let’s see what happens when you simply create a new <code>HTMLAudioElement</code> object every time you want to play a sound. 
If this doesn’t sound like an efficient use of memory or resources in the web browser, you are a keen observer. 
It’s actually a horrible idea. 
However, let’s proceed just to see what happens.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893801.png" alt="Space Raiders playing sounds from two objects" width="500" height="500">
Figure 7-7. 
Space Raiders playing sounds from two objects
In <code>canvasApp()</code>, we will create a couple constants that represent the filenames of the sounds we want to play, but without the associated extension. 

We will still retrieve the extension with a call to <code>supportedAudioFormat()</code>, just as we did in the first iteration, and store that value in the <code>audioType</code> variable.
We will also create an array named <code>sounds</code> that we will use to hold all the <code>HTMLAudio</code><code>Element</code> objects we create. 
This array will tell us how many objects we have created so we can visually see when all hell breaks loose:
const SOUND_EXPLODE = "explode1";

const SOUND_SHOOT = "shoot1";
var sounds = new Array();
Instead of calling the <code>play()</code> function of each sound directly, we are going to create a function named <code>playSound()</code>. 
This function accepts two parameters:

<code>sound</code>
One of the constants we created above that contains the name of the sound file

<code>volume</code>
A number between <code>0</code> and <code>1</code> that represents the volume of the sound to play

The function here creates a new <code>sound</code> object every time it is called by calling the <code>createElement()</code> function of the <code>document</code> DOM object. 
It then sets the properties (<code>src</code>, <code>loop</code>, <code>volume</code>) and attempts to play the sound. 

Just for fun, let’s push the object into the <code>sounds</code> array:
function playSound(sound,volume) {
 var tempSound = document.createElement("audio");
 tempSound.setAttribute("src", sound + "." + audioType); tempSound.loop = false;
 tempSound.volume = volume;
 tempSound.play();
 sounds.push(tempSound);

}
To play the sounds, we call <code>playSound()</code>, passing the proper parameters.
The call in <code>eventMouseUp()</code> looks like this:
playSound(SOUND_SHOOT,.5);

And in <code>drawScreen()</code> it looks like this:
playSound(SOUND_EXPLODE,.5);
To display on the canvas how many sounds we have created, we add this code to the <code>drawScreen()</code> function:
context.fillStyle = "#FFFFFF";

context.fillText ("Active Sounds: " + sounds.length, 200 ,480);
Now, go ahead and try this example (<em>CH7EX7.html</em> in the code distribution). 
Figure 7-8 shows what <em>Space Raiders</em> iteration #2 looks like. 

Notice we have added some display text at the bottom of the screen to show how many sounds are in the sounds array. 
You will discover two issues with this iteration:
The sounds play with almost no pauses when loaded from a local drive. 
But when the page is loaded from a remote website, there is a defined pause before each sound is loaded and played.

The number of <code>sound</code> objects created is a huge problem. 
For some browsers, such as Chrome, the number of active sounds caps out at about 50. 
After that, no sounds play at all.
</li>

</ol>
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893803.png" alt="Space Raiders creating sounds on the fly" width="500" height="500">
Figure 7-8. 
Space Raiders creating sounds on the fly

<h3>Iteration #3: Creating a Sound Pool</h3>
So, now we know we don’t want to play an <code>HTMLAudioElement</code> repeatedly, or create unlimited <code>sound</code> objects on the fly. 
However, what if we cap the number of <code>audio</code> objects we create, and put those objects in a pool so we can use them over and over? This will save us memory, and after the sounds are loaded, we shouldn’t see any loading pause before they are played, right?
We will implement a solution that uses <code>HTMLAudioElement</code> objects as general-purpose <code>sound</code> objects. 

We will keep a pool of them, and change the <code>src</code> attribute to whatever sound we want to play. 
This appears to be an elegant solution that reuses as much as possible, in addition to giving us a lot of flexibility as to which sounds we want to play.
In <code>canvasApp()</code>, we will create a new constant named <code>MAX_SOUNDS</code>. 
This will represent the maximum number of <code>sound</code> objects we can create at any one time. 

We will also rename our <code>sounds</code> array to <code>soundPool</code> to better describe its purpose:
const MAX_SOUNDS = 8;
var soundPool = new Array();
The big change here is the <code>playSound()</code> function. 

It uses the same parameters as the one from iteration #2, but the functionality is very different:
function playSound(sound,volume) {
The first half of the function loops through the <code>soundPool</code> array to see whether any of the <code>HTMLAudioElement</code> objects in the pool are available to play a sound. 
We determine this by checking the <code>ended</code> property. 

Since only <code>HTMLAudioElement</code> objects that have previously been used to play a sound are put into the pool, the <code>ended</code> property will be set to <code>true</code> once the sound has finished playing. 
By replaying sounds that have finished, we remove the issue of trying to reuse an <code>HTMLAudioElement</code> object to play a sound while it is already in use:
var soundFound = false;
var soundIndex = 0;

var tempSound;
if (soundPool.length&gt; 0) {
 while (!soundFound &amp;&amp; soundIndex &lt; soundPool.length) {
 var tSound = soundPool[soundIndex]; if (tSound.ended) { soundFound = true; } else { soundIndex++; }
 }
}
if (soundFound) { tempSound = soundPool[soundIndex];
 tempSound.setAttribute("src", sound + "." + audioType);
 tempSound.loop = false;
 tempSound.volume = volume; tempSound.play();
If we don’t find a sound, and the size of the pool is less than <code>MAX_SOUNDS</code>, we go ahead and create a new <code>HTMLAudioElement</code>, call its <code>play()</code> function, and push it into the sound pool. 
This keeps the pool from getting too large, while making sure there are not too many <code>HTMLAudioElement</code> objects in the browser at any one time:
 } else if (soundPool.length &lt; MAX_SOUNDS){ tempSound = document.createElement("audio"); tempSound.setAttribute("src", sound + "." + audioType); tempSound.volume = volume; tempSound.play(); soundPool.push(tempSound); }
}
You can go ahead and try this iteration by loading <em>CH7EX8.html</em> in your HTML5-compliant web browser. 
In this case, it works! You hear every sound, and the browser doesn’t die like it would with iteration #2.

Unfortunately, there are some issues. 
On some browsers, there is still a pause before a sound plays, just like with iteration #2. 
Again, this happens more often when the page is loaded from an external website than when it is loaded locally in a web browser.
The worst manifestation of this comes in Google Chrome, where the sounds pause every time they are played. 

Also, in Firefox, the <code>src</code> doesn’t change for all the objects, making the shoot sound play when the explode sound should play, and vice versa.
Uh-oh, it looks like we need another iteration. 
Figure 7-9 shows <em>Space Raiders</em> playing with a pool size governed by <code>MAX_SOUNDS</code>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893805.png" alt="Space Raiders with a sound pool" width="500" height="500">
Figure 7-9. 
Space Raiders with a sound pool
<h3>Iteration #4: Reusing Preloaded Sounds</h3>

Even though the code in iteration #3 was pretty clean, it simply did not work for us. 
Instead, we need to compromise and implement a solution that is less elegant, but that works to play sounds nearly every time they are needed. 
This solution must also work both locally and when loaded from a website.
For this final iteration, we are going to use a sound pool just like in iteration #3, but it will operate in a different way. 

We will not reuse <code>sound</code> objects for different sound files. 
Instead, we will load all our sounds up front, and simply play a <code>sound</code> object that is currently not being used. 
In effect, we will “prime the pump,” creating three <code>sound</code> objects for each of our two sounds for a total of six <code>sound</code> objects when we start the application. 
While this may not seem like the perfect solution, it appears to work fairly well in all browsers and plays sounds in the most effective way.

In <code>canvasApp()</code>, we set our <code>MAX_SOUNDS</code> constant to <code>6</code>. 
We could make it higher, but for this example we will limit it to the number of sounds we will create and preload:
const MAX_SOUNDS = 6;
We then create six variables to hold our <code>HTMLAudioElement</code> objects: three for the explode sound…

var explodeSound ;
var explodeSound2 ;
var explodeSound3 ;
…and three for the shoot sound:

var shootSound;
var shootSound2;
var shootSound3;
In the <code>initApp()</code> function, we preload all of these <code>sound</code> objects. 

Yes, we load the same object multiple times:
explodeSound = document.createElement("audio");
document.body.appendChild(explodeSound);
audioType = supportedAudioFormat(explodeSound);

explodeSound.setAttribute("src", "explode1." + audioType);
explodeSound.addEventListener("canplaythrough",itemLoaded,false);
explodeSound2 = document.createElement("audio");
document.body.appendChild(explodeSound2);

explodeSound2.setAttribute("src", "explode1." + audioType);
explodeSound2.addEventListener("canplaythrough",itemLoaded,false);
explodeSound3 = document.createElement("audio");
document.body.appendChild(explodeSound3);

explodeSound3.setAttribute("src", "explode1." + audioType);
explodeSound3.addEventListener("canplaythrough",itemLoaded,false);
shootSound = document.createElement("audio");
document.body.appendChild(shootSound);

shootSound.setAttribute("src", "shoot1." + audioType);
shootSound.addEventListener("canplaythrough",itemLoaded,false);
shootSound2 = document.createElement("audio");
document.body.appendChild(shootSound2);

shootSound2.setAttribute("src", "shoot1." + audioType);
shootSound2.addEventListener("canplaythrough",itemLoaded,false);
shootSound3 = document.createElement("audio");
document.body.appendChild(shootSound3);

shootSound3.setAttribute("src", "shoot1." + audioType);
shootSound3.addEventListener("canplaythrough",itemLoaded,false);
In the <code>itemLoaded()</code> function, we remove the event listeners for all six loaded sounds:
shootSound.removeEventListener("canplaythrough",itemLoaded, false);

shootSound2.removeEventListener("canplaythrough",itemLoaded, false);
shootSound3.removeEventListener("canplaythrough",itemLoaded, false);
explodeSound.removeEventListener("canplaythrough",itemLoaded,false);
explodeSound2.removeEventListener("canplaythrough",itemLoaded,false);

explodeSound3.removeEventListener("canplaythrough",itemLoaded,false);
Then, we push each sound into our <code>soundPool</code> array. 
However, this time, we push them as dynamic objects so we can set the following properties, which don’t exist in the <code>HTMLAudioElement</code> object:

<code>name</code>
The name of the sound file to play (again, without the extension).

<code>element</code>
The reference to the <code>HTMLAudioElement</code> object.

<code>played</code>
A Boolean that tells us whether this sound has played once or not. 
We need this property because we are putting all of these <code>sound</code> objects into our array, but they have not been played yet. 

That means their <code>ended</code> property has not yet been set to <code>true</code>. 
The <code>played</code> property tells us whether the sound is ready to play—that is, it has not been played yet. 
We will set this to <code>true</code> after we play the sound once:

soundPool.push({name:"explode1", element:explodeSound, played:false});
soundPool.push({name:"explode1", element:explodeSound2, played:false});
soundPool.push({name:"explode1", element:explodeSound3, played:false});

soundPool.push({name:"shoot1", element:shootSound, played:false});
soundPool.push({name:"shoot1", element:shootSound2, played:false});
soundPool.push({name:"shoot1", element:shootSound3, played:false});
Now we need to make a change in our <code>resetApp()</code> function. 

This change is to support sounds playing in Chrome, which appears to be the only browser that has a slight issue with loading sounds in this manner. 
The first time you play a sound in Chrome, there is a pause before it starts. 
To alleviate this, we play each sound type once but set the volume to <code>0</code>. 
This will make sure a sound is loaded and ready to play the first time we call <code>playSound()</code> in Chrome:

function resetApp() {
 playSound(SOUND_EXPLODE,0);
 playSound(SOUND_SHOOT,0);
 startLevel(); appState = STATE_PLAYING;
 }
The <code>playSound()</code> function operates in a similar way to iteration #3. 
It loops through the <code>soundPool</code> array looking for a sound that it can play. 

However, in this version, we check to see whether the <code>HTMLAudioElement</code> has ended (<code>tSound.element.ended</code>) or if it has not been played (<code>!tSound.played</code>) yet. 
We also check whether the value in the <code>sound</code> parameter matches the <code>name</code> property of the <code>sound</code> object in <code>soundPool</code> (<code>tSound.name == sound</code>):
function playSound(sound,volume) {
 var soundFound = false; var soundIndex = 0; var tempSound; if (soundPool.length &gt; 0) { while (!soundFound &amp;&amp; soundIndex &lt; soundPool.length) {
 var tSound = soundPool[soundIndex]; if ((tSound.element.ended || !tSound.played) &amp;&amp; tSound.name == sound) { soundFound = true; tSound.played = true; } else { soundIndex++; }
 } }
Using this method, we play a sound only if it has not been played, it has ended, and it already has the sound file loaded that we need to play. 

There is no pause to load (most of the time), and sounds play at pretty much the time we need them to play. 
If we need more sounds, we can load more up front, or set <code>MAX_SOUNDS</code> to a number greater than the number of preloaded sounds. 
If we do that, we will create new <code>sound</code> objects on the fly (although this might still give you a pause when loading from a web server):
if (soundFound) { tempSound = soundPool[soundIndex].element; tempSound.volume = volume; tempSound.play(); } else if (soundPool.length &lt; MAX_SOUNDS){ tempSound = document.createElement("audio"); tempSound.setAttribute("src", sound + "." + audioType); tempSound.volume = volume; tempSound.play(); soundPool.push({name:sound, element:tempSound, type:audioType, played:true}); }
Go ahead and try this code. 
It is <em>CH7EX9.html</em> in the code distribution, or you can type in the program listing.
<h4>Other stuff you could do to improve the game</h4>

Since the next couple chapters introduce game concepts, we really shouldn’t go much further with <em>Space Raiders</em>. 
Still, if you were going to finish this game, these are the things you might consider doing:
Add a score.
Increase the aliens’ speed on each new level.

Collision-detect the aliens and the player.
Make an object pool for missiles and aliens.
Slow down firing with a <code>wait()</code> state or frame counter.
Add explosions.

Include a title sequence, level sequence, and end game sequence.
Add a looping soundtrack.
</li>
</ol>

<h4>The final code for Space Raiders</h4>
Example 7-6</a> shows the final code for the <em>Space Raiders</em> game (<em>CH7EX9.html</em>).
Example 7-6. 
Space Raiders with optimized dynamic network sound and state loader

&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;

&lt;title&gt;CH7EX9: Space Raiders With Optimized Dynamic Network Sound And State Loader&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
function supportedAudioFormat(audio) { var returnExtension = "";
 if (audio.canPlayType("audio/ogg") =="probably" || audio.canPlayType("audio/ogg") == "maybe") { returnExtension = "ogg"; } else if(audio.canPlayType("audio/wav") =="probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "wav";
 } else if(audio.canPlayType("audio/mp3") == "probably" || audio.canPlayType("audio/mp3") == "maybe") { returnExtension = "mp3";
 } return returnExtension;
}
function canvasSupport () { return Modernizr.canvas;
}

function canvasApp() {
 const STATE_INIT = 10;
 const STATE_LOADING = 20;
 const STATE_RESET = 30; const STATE_PLAYING = 40;
 var appState = STATE_INIT;
 var loadCount= 0;
 var itemsToLoad = 0; var alienImage = new Image();
 var missileImage = new Image();
 var playerImage = new Image();
 const SOUND_EXPLODE = "explode1"; const SOUND_SHOOT = "shoot1";
 const MAX_SOUNDS = 6;
 var soundPool = new Array();
 var explodeSound ; var explodeSound2 ;
 var explodeSound3 ;
 var shootSound;
 var shootSound2; var shootSound3;
 var audioType;
 var mouseX;
 var mouseY; var player = {x:250,y:475};
 var aliens = new Array();
 var missiles = new Array();
 const ALIEN_START_X = 25; const ALIEN_START_Y = 25;
 const ALIEN_ROWS = 5;
 const ALIEN_COLS = 8;
 const ALIEN_SPACING = 40; if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne");
 var context = theCanvas.getContext("2d");
 function itemLoaded(event) { loadCount++;
 if (loadCount &gt;= itemsToLoad) {
 shootSound.removeEventListener("canplaythrough",itemLoaded, false); shootSound2.removeEventListener("canplaythrough",itemLoaded, false); shootSound3.removeEventListener("canplaythrough",itemLoaded, false); explodeSound.removeEventListener("canplaythrough",itemLoaded,false); explodeSound2.removeEventListener("canplaythrough",itemLoaded,false); explodeSound3.removeEventListener("canplaythrough",itemLoaded,false); soundPool.push({name:"explode1", element:explodeSound, played:false}); soundPool.push({name:"explode1", element:explodeSound2, played:false}); soundPool.push({name:"explode1", element:explodeSound3, played:false}); soundPool.push({name:"shoot1", element:shootSound, played:false}); soundPool.push({name:"shoot1", element:shootSound2, played:false}); soundPool.push({name:"shoot1", element:shootSound3, played:false});
 appState = STATE_RESET; }
 }
 function initApp() {
 loadCount=0; itemsToLoad = 9;
 explodeSound = document.createElement("audio");
 document.body.appendChild(explodeSound);
 audioType = supportedAudioFormat(explodeSound); explodeSound.setAttribute("src", "explode1." + audioType);
 explodeSound.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound2 = document.createElement("audio");
 document.body.appendChild(explodeSound2); explodeSound2.setAttribute("src", "explode1." + audioType);
 explodeSound2.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound3 = document.createElement("audio");
 document.body.appendChild(explodeSound3); explodeSound3.setAttribute("src", "explode1." + audioType);
 explodeSound3.addEventListener("canplaythrough",itemLoaded,false);
 shootSound = document.createElement("audio");
 document.body.appendChild(shootSound); shootSound.setAttribute("src", "shoot1." + audioType);
 shootSound.addEventListener("canplaythrough",itemLoaded,false);
 shootSound2 = document.createElement("audio");
 document.body.appendChild(shootSound2); shootSound2.setAttribute("src", "shoot1." + audioType);
 shootSound2.addEventListener("canplaythrough",itemLoaded,false);
 shootSound3 = document.createElement("audio");
 document.body.appendChild(shootSound3); shootSound3.setAttribute("src", "shoot1." + audioType);
 shootSound3.addEventListener("canplaythrough",itemLoaded,false);
 alienImage = new Image();
 alienImage.onload = itemLoaded; alienImage.src = "alien.png";
 playerImage = new Image();
 playerImage.onload = itemLoaded;
 playerImage.src = "player.png"; missileImage = new Image();
 missileImage.onload = itemLoaded;
 missileImage.src = "missile.png";
 appState = STATE_LOADING; }
 function startLevel() {
 for (var r = 0; r &lt; ALIEN_ROWS; r++) { for( var c= 0; c &lt; ALIEN_COLS; c++) { aliens.push({speed:2,x:ALIEN_START_X+c*ALIEN_SPACING, y:ALIEN_START_Y+r* ALIEN_SPACING,width:alienImage.width, height:alienImage.height}); } }
 } function resetApp() {
 playSound(SOUND_EXPLODE,0);
 playSound(SOUND_SHOOT,0);
 startLevel(); appState = STATE_PLAYING;
 }
 function drawScreen () {
 //Move missiles for (var i=missiles.length,1; i&gt;= 0;i,,) { missiles[i].y ,= missiles[i].speed; if (missiles[i].y &lt; (0-missiles[i].height)) { missiles.splice(i,1); } }
 //Move Aliens for (var i=aliens.length,1; i&gt;= 0;i,,) { aliens[i].x += aliens[i].speed; if (aliens[i].x &gt; (theCanvas.width-aliens[i].width) || aliens[i].x &lt; 0) { aliens[i].speed *= -1; aliens[i].y += 20; } if (aliens[i].y &gt; theCanvas.height) { aliens.splice(i,1); }
 }
 //Detect Collisions missile: for (var i=missiles.length,1; i&gt;= 0;i,,) { var tempMissile = missiles[i] for (var j=aliens.length,1; j&gt;= 0;j,,) { var tempAlien =aliens[j]; if (hitTest(tempMissile,tempAlien)) { playSound(SOUND_EXPLODE,.5); missiles.splice(i,1); aliens.splice(j,1); break missile; } } if (aliens.length &lt;=0) { appState = STATE_RESET; } }
 //Background context.fillStyle = "#000000"; context.fillRect(0, 0, theCanvas.width, theCanvas.height); //Box context.strokeStyle = "#EEEEEE"; context.strokeRect(5, 5, theCanvas.width,10, theCanvas.height,10);
 //Draw Player context.drawImage(playerImage,player.x,player.y);
 //Draw Missiles for (var i=missiles.length,1; i&gt;= 0;i,,) { context.drawImage(missileImage,missiles[i].x,missiles[i].y); }
 //draw aliens for (var i=aliens.length,1; i&gt;= 0;i,,) { context.drawImage(alienImage,aliens[i].x,aliens[i].y);
 }
 //Draw Text context.fillStyle = "#FFFFFF"; context.fillText ("Active Sounds: " + soundPool.length, 200 ,480); }
 function hitTest(image1,image2) { r1left = image1.x; r1top = image1.y; r1right = image1.x + image1.width; r1bottom = image1.y + image1.height; r2left = image2.x; r2top = image2.y; r2right = image2.x + image2.width; r2bottom = image2.y + image2.height; retval = false;
 if ( (r1left &gt; r2right) || (r1right &lt; r2left) || (r1bottom &lt; r2top) || (r1top &gt; r2bottom) ) { retval = false; } else { retval = true; }
 return retval; }
 function eventMouseMove(event) { if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; }
 player.x = mouseX; player.y = mouseY;
 } function eventMouseUp(event) {
 missiles.push({speed:5, x: player.x+.5*playerImage.width, y:player.y-missileImage.height,width:missileImage.width, height:missileImage.height});
 playSound(SOUND_SHOOT,.5);
 } function playSound(sound,volume) {
 var soundFound = false; var soundIndex = 0; var tempSound;
 if (soundPool.length&gt; 0) { while (!soundFound &amp;&amp; soundIndex &lt; soundPool.length) {
 var tSound = soundPool[soundIndex]; if ((tSound.element.ended || !tSound.played) &amp;&amp; tSound.name == sound) { soundFound = true; tSound.played = true; } else { soundIndex++; } } } if (soundFound) { tempSound = soundPool[soundIndex].element; tempSound.volume = volume; tempSound.play();
 } else if (soundPool.length &lt; MAX_SOUNDS){ tempSound = document.createElement("audio"); tempSound.setAttribute("src", sound + "." + audioType); tempSound.volume = volume; tempSound.play(); soundPool.push({name:sound, element:tempSound, type:audioType, played:true}); }
 }
 function run() { switch(appState) { case STATE_INIT: initApp(); break; case STATE_LOADING: //wait for call backs break; case STATE_RESET: resetApp(); break; case STATE_PLAYING: drawScreen(); break; }
 }
 theCanvas.addEventListener("mouseup",eventMouseUp, false);
 theCanvas.addEventListener("mousemove",eventMouseMove, false); setInterval(run, 33);
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

<h2>What’s Next</h2>
Since this is not a book about the HTML5 <code>&lt;audio&gt;</code> tag, we did not cover every aspect of that new feature. 
Instead, we focused on the elements of <code>audio</code> that could be used with HTML5 Canvas. 
We created two in-depth applications that make use of sound with HTML5 Canvas in very different ways: an audio player that plays one song, and a game that plays many sounds dynamically. 

During that process we learned that audio in HTML, while being a wonderful new feature, is not without its pitfalls and gotchas.
In the next two chapters we will expand upon the last section we presented here, and discuss how to implement games on HTML5 Canvas.
 8. 
Canvas Game Essentials" epub:type="chapter">

<h2><span class="orange">Chapter 8. Canvas Game Essentials</span></h2>
Games are the reason why many of us initially became interested in computers, and they continue to be a major driving force that pushes computer technology to new heights. 
In this chapter, we will examine how to build a mini game framework that can be used to create games on the canvas.
 We will explore many of the core building blocks associated with game development and apply them to HTML5 Canvas with the JavaScript API.
We don’t have the space to cover every type of game you might want to create, but we will discuss many elementary and intermediate topics necessary for most games. 
At the end of this chapter, we will have a basic clone of Atari’s classic <em>Asteroids</em>
 game. 

We will step through the creation of this game by first applying some of the techniques for drawing and transformations specific to our game’s visual objects. 
This will help get our feet wet by taking some of the techniques we covered in previous chapters and applying them to an arcade game application. 
Next, we will create a basic game framework that can be applied to any game we want to make on the canvas. 

Following this, we will dive into some game techniques and algorithms, and finally, we will apply everything we have covered to create the finished product.
<h2>Why Games in HTML5?</h2>
Playing games in a browser has become one of the most popular activities for Internet users. 
HTML5 Canvas gives web developers an API to directly manage drawing to a specific area of the browser. 
This functionality makes game development in JavaScript much more powerful than ever before.
<h3>Canvas Compared to Flash</h3>

We’ve covered this topic in earlier chapters, but we expect that a large portion of readers might have previously developed games in Flash. 
If so, you will find that Canvas offers similar functionality in certain areas, but lacks some of the more refined features of Flash.
No Flash timeline

There is no frame-based timeline for animation intrinsic to Canvas. 
This means that we will need to code all of our animations using images and/or paths, and apply our own frame-based updates.

No display list
Flash AS3 offers the very powerful idea of an object display list; a developer can add hundreds of individual physical display objects to the game screen. 
HTML5 Canvas has only a single display object (the canvas itself).

<h3>What Does Canvas Offer?</h3>
Even though Canvas lacks some of the features that make the Flash platform very nice for game development, it also has some strengths.

A powerful single stage
HTML5 Canvas is closely akin to the Flash Stage. 

It is a rectangular piece of screen real estate that can be manipulated programmatically. 
Advanced Flash developers might recognize the canvas as a close cousin to both the <code>BitmapData</code> and <code>Shape</code> objects in ActionScript. 
We can draw directly to the canvas with paths and images, and transform them on the fly.

Logical display objects
Canvas gives us a single physical display object, but we can create any number of logical display objects. 
We will use JavaScript objects to hold all of the logical data and methods we need to draw and transform our logical game objects to the physical canvas.

<h2>Our Basic Game HTML5 File</h2>
Before we start to develop our arcade game, let’s look at Example 8-1</a>, the most basic HTML file we will use in this chapter (<em>CH8EX1.html</em>). 

We’ll start by using the basic HTML5 template we defined in Chapter 1. 
Our canvas will be a 200×200 square.
Example 8-1. 

The Basic HTML file for Chapter 8
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH8EX1: Filled Screen With Some Text&lt;/title&gt;
&lt;script type="text/javascript"&gt; window.addEventListener('load', eventWindowLoaded, false);
 function eventWindowLoaded() { canvasApp();
 }
 function canvasApp(){ var theCanvas = document.getElementById("canvas"); if (!theCanvas || !theCanvas.getContext) { return; } var context = theCanvas.getContext("2d"); if (!context) { return; } drawScreen(); function drawScreen() { context.fillStyle = '#ffaaaa'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#000000'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Canvas!", 0, 0); } }
&lt;/script&gt;
&lt;/head&gt;
 &lt;body&gt; &lt;div&gt; &lt;canvas width="200" height="200"&gt; Your browser does not support HTML5 Canvas. 

&lt;/canvas&gt; &lt;/div&gt;
 &lt;/body&gt;
&lt;/html&gt;
This example will do nothing more than place a 200×200 gray box on the canvas and write “Canvas!” starting at <code>0</code>,<code>0</code>. 

We will be replacing the <code>drawScreen()</code> function for most of the next few examples. 
Figure 8-1 illustrates Example 8-1</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893807.png" alt="The basic HTML file for" width="201" height="200">

Figure 8-1. 
The basic HTML file for Chapter 8
Next, we will begin to make our <em>Asteroids</em>-like game, which we’ve named <em>Geo Blaster Basic</em>. 

See Figure 8-7 for an example of the final game in action.
<h2>Our Game’s Design</h2>
We are not going to assume that everyone who reads this chapter knows of or understands Atari’s classic arcade game <em>Asteroids</em>. 

So, let’s start by taking a peek at <em>Asteroids</em>’ game-play elements.
<em>Asteroids</em>, designed by Ed Logg and Lyle Rains, was released by Atari in 1979. 
The game pitted a lone triangular two-dimensional vector spaceship (the player ship) against screen after screen of asteroid rocks that needed to be dodged and destroyed. 
Every so often a space saucer would enter the screen attempting to destroy the player ship.

All asteroids started the game as large rocks; once they were hit, they would split into two medium-sized rocks. 
When hit by a player missile, these medium-sized rocks would then split into two small rocks. 
The small rocks would simply be destroyed when hit (small was the final size for all asteroids).
When the player destroyed all the asteroids, a new screen of more and slightly faster asteroids would appear. 

This went on until the player exhausted his three ships. 
At each 10,000-point score mark, the player was awarded an extra ship.
All of the game objects moved (thrusting, rotating, and/or floating) freely across the entire screen, which represented a slice of space as a flat plane. 
When an object went off the side of the screen, it would reappear on the opposite side, in warp-like fashion.

<h2>Game Graphics: Drawing with Paths</h2>
Let’s jump into game development on Canvas by first taking a look at some of the graphics we will use in our game. 
This will help give us a visual feel for what type of code we will need to implement.
<h3>Needed Assets</h3>

For our <em>Asteroids</em>-like game, <em>Geo Blaster Basic</em>, we will need some very simple game graphics, including:
A solid black background.

A player ship that will rotate and thrust (move on a vector) across the game screen. 
There will be two frames of animation for this ship: a “static” frame and a “thrust” frame.
A saucer that flies across the screen and shoots at the player.
Some “rocks” for the player to shoot. 

We will use a simple square as our rock.
There are two different methods we can employ to draw the graphics for our game: bitmap images or paths. 

For the game in this chapter, we will focus on using paths. 
In Chapter 9, we will explore how to manipulate bitmap images for our game graphics.
<h3>Using Paths to Draw the Game’s Main Character</h3>

Paths offer us a very simple but powerful way to mimic the vector look of the classic <em>Asteroids</em> game. 
We could use bitmap images for this purpose, but in this chapter we are going to focus on creating our game in code with no external assets. 
Let’s take a look at the two frames of animation we will create for our player ship.
<h4>The static player ship (frame 1)</h4>

The main frame of the player ship will be drawn with paths on a 20×20 grid, as shown in Figure 8-2.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893809.png" alt="The player ship" width="158" height="159">
Figure 8-2. 

The player ship
Using the basic HTML file presented in Example 8-1</a>, we can simply swap the <code>drawScreen()</code> function with the code in Example 8-2</a> to draw the ship.
Example 8-2. 
Drawing the player ship

function drawScreen() {
 // draw background and text context.fillStyle = '#000000';
 context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff';
 context.font = '20px _sans';
 context.textBaseline = 'top';
 context.fillText ("Player Ship - Static", 0, 180); //drawShip context.strokeStyle = '#ffffff';
 context.beginPath();
 context.moveTo(10,0); context.lineTo(19,19);
 context.lineTo(10,9);
 context.moveTo(9,9);
 context.lineTo(0,19); context.lineTo(9,0);
 context.stroke();
 context.closePath();
}

Drawing with Paths
The list below is a refresher on drawing with paths:
Always start a new path with the <code>context.beginPath()</code> function call.
Set <code>context.strokeStyle()</code> before starting to draw the path.

Use a combination of the <code>context.moveTo()</code> and <code>context.drawTo()</code> stroke commands to paint the path lines.
End the drawing with the <code>context.stroke()</code> call, and close off the path with <code>context.closePath()</code>.
</li>
</ol>

We are drawing to the upper-left corner of the screen starting at <code>0</code>,<code>0</code>. 
Figure 8-3 shows what this will look like.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893811.png" alt="The player ship on the canvas" width="202" height="201">

Figure 8-3. 
The player ship on the canvas
<h4>The ship with thrust engaged (frame 2)</h4>
Now let’s take a look at the second frame of animation for the player ship, which is shown in Figure 8-4.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893813.png" alt="The player ship with thrust engaged" width="159" height="159">
Figure 8-4. 
The player ship with thrust engaged

The <code>drawScreen()</code> function code to add this extra “thrust” graphic is very simple; see Example 8-3</a>.
Example 8-3. 
Drawing the player ship with thrust
function drawScreen() { // draw background and text context.fillStyle = '#000000';
 context.fillRect(0, 0, 200, 200);
 context.fillStyle = '#ffffff'; context.font = '20px _sans';
 context.textBaseline = 'top';
 context.fillText ("Player Ship - Thrust", 0, 180);
 //drawShip context.strokeStyle = '#ffffff';
 context.beginPath();
 context.moveTo(10,0);
 context.lineTo(19,19); context.lineTo(10,9);
 context.moveTo(9,9);
 context.lineTo(0,19);
 context.lineTo(9,0); //draw thrust context.moveTo(8,13);
 context.lineTo(11,13);
 context.moveTo(9,14); context.lineTo(9,18);
 context.moveTo(10,14);
 context.lineTo(10,18);
 context.stroke(); context.closePath();
}
<h2>Animating on the Canvas</h2>
The player ship we just created has two frames (static and thrust), but we can only display a single frame at a time. 

Our game will need to switch out the frame of animation based on the state of the player ship, and it will need to run on a timer so this animation can occur. 
Let’s take a quick look at the code necessary to create our game timer.
<h3>Game Timer Loop</h3>
Games on HTML5 Canvas require the use of the repeated update/render loop to simulate animation. 

We do this by using the <code>setInterval()</code> JavaScript function, which will repeatedly call a function of our choosing at millisecond intervals. 
Each second of game/animation time is made up of 1,000 milliseconds. 
If we want our game to run at 30 update/render cycles per second, we call this a 30 frames per second (FPS) rate. 
To run our interval at 30 FPS, we first need to divide 1,000 by 30. 

The result is the number of milliseconds in each interval:
const FRAME_RATE = 30;
var intervalTime = 1000/FRAME_RATE;
setInterval(drawScreen, intervalTime );

By calling the <code>drawScreen()</code> function repeatedly on each interval, we can simulate animation.
<h3>Note</h3>
Sometimes we will refer to each of the frame intervals as a <em>frame tick</em>.
<h3>The Player Ship State Changes</h3>

We simply need to switch between the static and thrust states to simulate the animation. 
Let’s take a look at the full HTML file to do this. 
In Example 8-4</a>, we will start to place <code>canvasApp</code> class-level variables in a new section just above the <code>drawScreen()</code> function. 
This will be the location going forward for all variables needing a global scope inside the <code>canvasApp()</code> object.

Example 8-4. 
The player ship state changes for thrust animation
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH8EX4: Ship Animation Loop&lt;/title&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasApp(){
 var theCanvas = document.getElementById("canvas");
 if (!theCanvas || !theCanvas.getContext) { return;
 } var context = theCanvas.getContext("2d");
 if (!context) { return;
 }
 //canvasApp level variables var shipState = 0; //0 = static, 1 = thrust function drawScreen() { //update the shipState shipState++; if (shipState &gt;1) { shipState=0; }
 // draw background and text context.fillStyle = '#000000'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Player Ship - animate", 0, 180);
 //drawShip context.strokeStyle = '#ffffff'; context.beginPath(); context.moveTo(10,0); context.lineTo(19,19); context.lineTo(10,9); context.moveTo(9,9); context.lineTo(0,19); context.lineTo(9,0); if (shipState==1) { //draw thrust context.moveTo(8,13); context.lineTo(11,13); context.moveTo(9,14); context.lineTo(9,18); context.moveTo(10,14); context.lineTo(10,18); }
 context.stroke(); context.closePath();
 }
 const FRAME_RATE = 40; var intervalTime = 1000/FRAME_RATE;
 setInterval(drawScreen, intervalTime );
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="200" height="200"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
When we run Example 8-4</a> we will see the player ship in the upper-left corner of the canvas. 
The static and thrust states will alternate on each frame.
<h2>Applying Transformations to Game Graphics</h2>
Our game will probably have many individual logical display objects that need to be updated on a single frame tick. 
We can make use of the Canvas stack (<code>save()</code> and <code>restore()</code> functions), and use the transformation matrix to ensure the final output affects only the current object we are working on—not the entire canvas.
<h3>The Canvas Stack</h3>
The Canvas state can be saved to a stack and retrieved. 

This is important when we are transforming and animating game objects because we want our transformations to affect only the current game object and not the entire canvas. 
The basic workflow for using the Canvas stack in a game looks like this:
Save the current canvas to the stack.
Transform and draw the game object.

Retrieve the saved canvas from the stack.
</li>
</ol>
As an example, let’s set up a basic rotation for our player ship. 

We will rotate it by 1 degree on each frame. 
Since we are currently drawing the player ship in the top-left corner of the canvas, we are going to move it to a new location. 
We do this because the basic rotation will use the top-left corner of the ship as the <em>registration point</em>: the axis location used for rotation and scale operations. 
So, if we kept the ship at the <code>0</code>,<code>0</code> location and rotated it by its top-left corner, you would not see it half the time because its location would be off the top and left edges of the canvas. 

Instead, we will place the ship at <code>50</code>,<code>50</code>.
We will be using the same HTML code as in Example 8-4</a>, changing out only the <code>drawCanvas()</code> function. 
To simplify this example, we will remove the <code>shipState</code> variable and concentrate on the static state only. 
We will be adding in three new variables above the <code>drawCanvas()</code> function:

var rotation = 0; - holds the current rotation of the player ship
var x = 50; - holds the x location to start drawing the player ship
var y = 50; - holds the y location to start drawing the player ship
Example 8-5</a> gives the full code.

Example 8-5. 
Rotating an image
//canvasApp level variables var rotation = 0; var x = 50;
 var y = 50;
 function drawScreen() {
 // draw background and text context.fillStyle = '#000000'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Player Ship - rotate", 0, 180); //transformation var angleInRadians = rotation * Math.PI / 180; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(x,y); context.rotate(angleInRadians);
 //drawShip context.strokeStyle = '#ffffff'; context.beginPath(); context.moveTo(10,0); context.lineTo(19,19); context.lineTo(10,9); context.moveTo(9,9); context.lineTo(0,19); context.lineTo(9,0);
 context.stroke(); context.closePath(); //restore context context.restore(); //pop old state on to screen
 //add to rotation rotation++;
 }
As you can see, the player ship rotates clockwise one degree at a time. 

As we’ve mentioned many times already, we must convert from degrees to radians because the <code>context.rotate()</code> transformations use radians for calculations. 
In the next section, we’ll take a deeper look at some of the transformations we will use in our <em>Geo</em> <em>Blaster Basic</em> game.
<h2>Game Graphic Transformations</h2>
As we saw in the previous section, we can easily rotate a game graphic at the top-left corner by using the <code>context.rotate()</code> transformation. 

However, our game will need to rotate objects at the center rather than the top-left corner. 
To do this, we must change the transformation point to the center of our game graphic object.
<h3>Rotating the Player Ship from the Center</h3>
The code to rotate the player ship from its center point is almost exactly like the code used to rotate it at the top-left corner. 

What we need to modify is the point of the translation. 
In Example 8-5</a>, we placed the immediate-mode drawing context at the <code>x</code> and <code>y</code> coordinates of our game object (<code>50</code>,<code>50</code>). 
This had the effect of rotating the object from the top-left corner. 
Now we must move the translation to the center of our object:

context.translate(x+.5*width,y+.5*height);
<h3>Note</h3>
The <code>width</code> and <code>height</code> variables represent attributes of our drawn player ship. 
We will create these attributes in Example 8-6</a>.

This is not the only change we need to make; we also need to draw our ship as though it is the center point. 
To do this, we will subtract half the <code>width</code> from each <code>x</code> attribute in our path draw sequence, and half the <code>height</code> from each <code>y</code> attribute:
context.moveTo(10-.5*width,0-.5*height);
context.lineTo(19-.5*width,19-.5*height);

As you can see, it might get a little confusing trying to draw coordinates in this manner. 
It is also slightly more processor-intensive than using constants. 
In that case, we would simply hardcode in the needed values. 
Remember, the <code>width</code> and <code>height</code> attributes of our ship are both <code>20</code>. 

The hardcoded version would look something like this:
context.moveTo(0,,10); //10-10, 0-10
context.lineTo(9,9); //19-10, 19-10
The method where we use the calculated values (using the <code>width</code> and <code>height</code> variables) is much more flexible, while the hardcoded method is much less processor-intensive. 

Example 8-6</a> contains all the code to use either method. 
We have commented out the calculated version of the code.
Example 8-6. 
Rotating an image from its center point

//canvasApp level variables var rotation = 0;
 var x = 50;
 var y = 50; var width = 20; var height = 20;
 function drawScreen() { // draw background and text context.fillStyle = '#000000'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Player Ship - rotate", 0, 180);
 //transformation var angleInRadians = rotation * Math.PI / 180; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(x+.5*width,y+.5*height); context.rotate(angleInRadians); //drawShip context.strokeStyle = '#ffffff'; context.beginPath();
 //hardcoding in locations context.moveTo(0,-10); context.lineTo(9,9); context.lineTo(0,-1); context.moveTo(-1,-1); context.lineTo(-10,9); context.lineTo(-1,-10);
 /* //using the width and height to calculate context.moveTo(10-.5*width,0-.5*height); context.lineTo(19-.5*width,19-.5*height); context.lineTo(10-.5*width,9-.5*height); context.moveTo(9-.5*width,9-.5*height); context.lineTo(0-.5*width,19-.5*height); context.lineTo(9-.5*width,0-.5*height); */ context.stroke(); context.closePath();
 //restore context context.restore(); //pop old state on to screen
 //add to rotation rotation++;
 }

<h3>Alpha Fading the Player Ship</h3>
When a new player ship in <em>Geo</em> <em>Blaster Basic</em> enters the game screen, we will have it fade from transparent to opaque. 
Example 8-7</a> shows how we will create this transformation in our game.
<h4>Using the context.globalAlpha attribute</h4>

To use the <code>context.globalAlpha</code> attribute of the canvas, we simply set it to a number between <code>0</code> and <code>1</code> before we draw the game graphics. 
We will create a new variable in our code called <code>alpha</code>, which will hold the current alpha value for our player ship. 
We will increase it by <code>.01</code> until it reaches <code>1</code>. 
When we actually create our game we will stop it at <code>1</code> and then start the game level. 

However, for this demo, we will just repeat it over and over.
Example 8-7. 
Alpha fading to the player ship
//canvasApp level variables var x = 50;
 var y = 50;
 var width = 20;
 var height = 20; var alpha = 0;
 context.globalAlpha = 1;
 function drawScreen() {
 context.globalAlpha = 1; context.fillStyle = '#000000'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Player Ship - alpha", 0, 180); context.globalAlpha = alpha; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity //translate the canvas origin to the center of the player context.translate(x+.5*width,y+.5*height);
 //drawShip context.strokeStyle = '#ffffff'; context.beginPath();
 //hardcoding in locations context.moveTo(0,-10); context.lineTo(9,9); context.lineTo(0,-1); context.moveTo(-1,-1); context.lineTo(-10,9); context.lineTo(-1,-10);
 context.stroke(); context.closePath(); //restore context context.restore(); //pop old state on to screen
 //add to rotation alpha+=.01; if (alpha &gt; 1) { alpha=0; }
 }
<h2>Game Object Physics and Animation</h2>
All of our game objects will move on a two-dimensional plane. 
We will use basic directional movement vectors to calculate the change in the <code>x</code> and <code>y</code> coordinates for each game object. 
At its very basic level, we will be updating the delta x (<code>dx</code>) and delta y (<code>dy</code>) of each of our game objects on each frame to simulate movement. 
These <code>dx</code> and <code>dy</code> values will be based on the angle and direction in which we want the object to move. 

All of our logical display objects will add their respective <code>dx</code> and <code>dy</code> values to their <code>x</code> and <code>y</code> values on each frame of animation. 
The player ship will not use strict <code>dx</code> and <code>dy</code> because it needs to be able to float and turn independently. 
Let’s take a closer look at the player movement now.
<h3>How Our Player Ship Will Move</h3>

Our player ship will change its angle of center axis rotation when the game player presses the left and right arrow keys. 
When the game player presses the up arrow key, the player ship will accelerate (thrust) in the angle it is facing. 
Because there is no friction applied to the ship, it will continue to float in the current accelerated angle until a different angle of acceleration is applied. 
This happens when the game player rotates to a new angle and presses the up (thrust) key once again.

<h4>The difference between facing and moving</h4>
Our player ship can rotate to the direction it is facing while it is moving in a different direction. 
For this reason, we cannot simply use classic <code>dx</code> and <code>dy</code> values to represent the movement vector on the x and y axes. 
We must keep both sets of values for the ship at all times. 

When the player rotates the ship but does not thrust it, we need to draw the ship in the new rotated angle. 
All missile projectiles the ship fires must also move in the direction the ship is facing. 
On the x-axis, we will name this value <code>facingX</code>; on the y-axis, it’s <code>facingY</code>. 
<code>movingX</code> and <code>movingY</code> values will handle moving the ship in the direction it was pointed in when the thrust was applied. 

All four values are needed to thrust the ship in a new direction. 
Let’s take a look at this next.
<h4>Thrusting in the rotated direction</h4>
Once the ship is rotated to the desired direction, the player can thrust it forward by pressing the up arrow key. 

This thrust will accelerate the player ship only while the key is pressed. 
Since we know the rotation of the ship, we can easily calculate the angle of the rotation. 
We will then add new <code>movingX</code> and <code>movingY</code> values to the ship’s <code>x</code> and <code>y</code> attributes to move it forward.
First, we must change the rotation value from degrees to radians:

var angleInRadians = rotation * Math.PI / 180;
You have seen this before—it’s identical to how we calculated the rotation transformation before it was applied to the player ship.
Once we have the angle of the ship’s rotation, we must calculate the <code>facingX</code> and <code>facingY</code> values for this current direction. 
We only do this when we are going to thrust because it is an expensive calculation, processor-wise. 

We could calculate these each time the player changes the ship’s rotation, but doing so would add unnecessary processor overhead:
facingX = Math.cos(angleInRadians);
facingY = Math.sin(angleInRadians);
Once we have values on the x and y axes that represent the direction the player ship is currently facing, we can calculate the new <code>movingX</code> and <code>movingY</code> values for the player:

movingX = movingX+thrustAcceleration*facingX;
movingY = movingY+thrustAcceleration*facingY;
To apply these new values to the player ship’s current position, we need to add them to its current <code>x</code> and <code>y</code> positions. 
<em>This does not occur only when the player presses the up key</em>. 

If it did, the player ship would not float; it would only move when the key was pressed. 
We must modify the <code>x</code> and <code>y</code> values on each frame with the <code>movingX</code> and <code>movingY</code> values:
x = x+movingX;
y = y+movingY;

<h4>Redrawing the player ship to start at angle 0</h4>
As you may recall, when we first drew the image for our player ship, we had the point end (the top) of the ship pointing up. 
We did this for ease of drawing, but it’s not really the best direction in which to draw our ship when we intend to apply calculations for rotational thrust. 
The pointing-up direction is actually the <code>-90</code> (or <code>270</code>) degree angle. 

If we want to leave everything the way it currently is, we will need to modify the <code>angleInRadians</code> calculation to look like this:
var angleInRadians = (Math.PI * (player.rotation -90 ))/ 180;
This is some ugly code, but it works fine if we want our player ship to be pointing up before we apply rotation transformations. 
A better method is to keep the current <code>angleInRadians</code> calculation but draw the ship pointing in the actual angle <code>0</code> direction (to the right). 

Figure 8-5 shows how we would draw this.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893815.png" alt="The player ship drawn at the 0 degree rotation" width="160" height="160">
Figure 8-5. 

The player ship drawn at the 0 degree rotation
The drawing code for this direction would be modified to look like this:
//facing right
context.moveTo(,10,,10);

context.lineTo(10,0);
context.moveTo(10,1);
context.lineTo(,10,10);
context.lineTo(1,1);

context.moveTo(1,,1);
context.lineTo(,10,,10);
<h3>Controlling the Player Ship with the Keyboard</h3>
We will add in two keyboard events and an array object to hold the state of each key press. 

This will allow the player to hold down a key and have it repeat without a pause. 
Arcade games require this type of key-press response.
<h4>The array to hold our key presses</h4>
An array will hold the <code>true</code> or <code>false</code> value for each <code>keyCode</code> associated with key events. 

The <code>keyCode</code> will be the index of the array that will receive the <code>true</code> or <code>false</code> value:
var keyPressList = [];
<h4>The key events</h4>
We will use separate events for both key down and key up. 

The key <code>down</code> event will put a <code>true</code> value in the <code>keyPressList</code> array at the index associated with the event’s <code>keyCode</code>. 
Conversely, the key <code>up</code> event will place a <code>false</code> in that array index:
document.onkeydown = function(e){
 e=e?e:window.event; //ConsoleLog.log(e.keyCode + "down"); keyPressList[e.keyCode] = true; }
 document.onkeyup = function(e){
 //document.body.onkeyup=function(e){ e = e?e:window.event; //ConsoleLog.log(e.keyCode + "up"); keyPressList[e.keyCode] = false;
 };

<h4>Evaluating key presses</h4>
Our game will need to include code to look for <code>true</code> (or <code>false</code>) values in the <code>keyPressList</code> array, and use those values to apply game logic:
if (keyPressList[38]==true){
 //thrust var angleInRadians = player.rotation * Math.PI / 180;
 facingX = Math.cos(angleInRadians);
 facingY = Math.sin(angleInRadians);
 movingX = movingX+thurstAcceleration*facingX; movingY = movingY+thurstAcceleration*facingY;
}
if (keyPressList[37]==true) {
 //rotate counterclockwise rotation-=rotationalVelocity;
}
if (keyPressList[39]==true) {
 //rotate clockwise rotation+=rotationalVelocity;;
}
Let’s add this code to our current set of rotation examples and test it out. 
We have made some major changes, so Example 8-8</a> presents the entire HTML file once again.

Example 8-8. 
Controlling the player ship
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH8EX8: Ship Turn With Keys&lt;/title&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasApp(){
 var theCanvas = document.getElementById("canvas");
 if (!theCanvas || !theCanvas.getContext) { return;
 } var context = theCanvas.getContext("2d");
 if (!context) { return;
 }
 //canvasApp level variables var rotation = 0;
 var x = 50;
 var y = 50;
 var facingX = 0; var facingY = 0;
 var movingX = 0;
 var movingY = 0;
 var width = 20; var height = 20;
 var rotationalVelocity = 5; //how many degrees to turn the ship var thrustAcceleration = .03;
 var keyPressList = []; function drawScreen() {
 //check keys if (keyPressList[38]==true){ //thrust var angleInRadians = rotation * Math.PI / 180; facingX = Math.cos(angleInRadians); facingY = Math.sin(angleInRadians);
 movingX = movingX+thrustAcceleration*facingX; movingY = movingY+thrustAcceleration*facingY; }
 if (keyPressList[37]==true) { //rotate counterclockwise rotation ,= rotationalVelocity;
 }
 if (keyPressList[39]==true) { //rotate clockwise rotation += rotationalVelocity;; }
 x = x+movingX;
 y = y+movingY;
 // draw background and text context.fillStyle = '#000000';
 context.fillRect(0, 0, 200, 200);
 context.fillStyle = '#ffffff';
 context.font = '20px _sans'; context.textBaseline = 'top';
 context.fillText ("Player Ship - key turn", 0, 180);
 //transformation var angleInRadians = rotation * Math.PI / 180; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(x+.5*width,y+.5*height); context.rotate(angleInRadians);
 //drawShip context.strokeStyle = '#ffffff';
 context.beginPath(); //hardcoding in locations
 //facing right context.moveTo(-10,-10);
 context.lineTo(10,0); context.moveTo(10,1);
 context.lineTo(-10,10);
 context.lineTo(1,1);
 context.moveTo(1,-1); context.lineTo(-10,-10);
 context.stroke();
 context.closePath();
 //restore context context.restore(); //pop old state on to screen
 }
 const FRAME_RATE = 40;
 var intervalTime = 1000/FRAME_RATE; setInterval(drawScreen, intervalTime );
 document.onkeydown = function(e){ e = e?e:window.event; //ConsoleLog.log(e.keyCode + "down"); keyPressList[e.keyCode] = true;
 }
 document.onkeyup = function(e){ //document.body.onkeyup = function(e){ e = e?e:window.event; //ConsoleLog.log(e.keyCode + "up"); keyPressList[e.keyCode] = false; };
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="200" height="200"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;

Once this file is run in a browser, you should be able to press the left and right keys to rotate the ship on its center axis. 
If you press the up key, the ship will move in the direction it is facing.
<h3>Giving the Player Ship a Maximum Velocity</h3>
If you play with the code in Example 8-8</a>, you will notice two problems:

The ship can go off the sides of the screen and get lost.
The ship has no maximum speed.
</li>
</ol>

We’ll resolve the first issue when we start to code the complete game, but for now, let’s look at how to apply a maximum velocity to our current movement code. 
Suppose we give our player ship a maximum acceleration of <code>2</code> pixels per frame. 
It’s easy to calculate the current velocity if we are only moving in the four primary directions: up, down, right, left. 
When we are moving left or right, the <code>movingY</code> value will always be <code>0</code>. 

If we are moving up or down, the <code>movingX</code> value will always be <code>0</code>. 
The current velocity we are moving on one axis would be easy to compare to the maximum velocity.
But in our game, we are almost always moving in the <em>x</em> and <em>y</em> directions at the same time. 
To calculate the current velocity and compare it to a maximum velocity, we must use a bit more math.

First, let’s assume that we will add a maximum velocity variable to our game:
var maxVelocity = 2;
Next, we must make sure to calculate and compare the <code>maxVelocity</code> to the current velocity <em>before</em> we calculate the new <code>movingX</code> and <code>movingY</code> values. 
We will do this with local variables used to store the new values for <code>movingX</code> and <code>movingY</code> before they are applied:

var movingXNew = movingX+thrustAcceleration*facingX;
var movingYNew = movingY+thrustAcceleration*facingY;
The current velocity of our ship is the square root of <code>movingXNew^2 + movingYNew^2</code>:
var currentVelocity = Math.sqrt ((movingXNew*movingXNew) + (movingXNew*movingXNew));

If the <code>currentVelocity</code> is less than the <code>maxVelocity</code>, we set the <code>movingX</code> and <code>movingY</code> values:
if (currentVelocity &lt; maxVelocity) {
 movingX = movingXNew;
 movingY = movingYNew;

}
<h2>A Basic Game Framework</h2>
Now that we have gotten our feet wet (so to speak) by taking a peek at some of the graphics, transformations, and basic physics we will use in our game, let’s look at how we will structure a simple framework for all games we might want to create on HTML5 Canvas. 
We will begin by creating a simple state machine using constant variables. 

Next, we will introduce our game timer interval function to this structure, and finally, we will create a simple reusable object that will display the current frame rate our game is running in. 
Let’s get started.
<h3>The Game State Machine</h3>
A state machine is a programming construct that allows for our game to be in only a single application state at any one time. 

We will create a state machine for our game, called <em>application state</em>, which will include seven basic states (we will use constants to refer to these states):
<code>GAME_STATE_TITLE</code>

<code>GAME_STATE_NEW_GAME</code>
<code>GAME_STATE_NEW_LEVEL</code>
<code>GAME_STATE_PLAYER_START</code>
<code>GAME_STATE_PLAY_LEVEL</code>

<code>GAME_STATE_PLAYER_DIE</code>
<code>GAME_STATE_GAME_OVER</code>

We will create a <code>function</code> object for each state that will contain game logic necessary for the state to function and to change to a new state when appropriate. 
By doing this, we can use the same structure for each game we create by simply changing out the content of each <em>state function</em> (as we will refer to them).
Let’s take a look at a very basic version of this in action. 
We will use a function reference variable called <code>currentGameStateFunction</code>, as well as an integer variable called <code>currentGameState</code> that will hold the current application state constant value:

var currentGameState = 0;
var currentGameStateFunction = null;
We will create a function called <code>switchAppState()</code> that will be called only when we want to switch to a new state:
function switchGameState(newState) { currentGameState = newState;
 switch (currentState) {
 case GAME_STATE_TITLE: currentGameStateFunction = gameStateTitle; break;
 case GAME_STATE_PLAY_LEVEL: currentGameStateFunctionappStatePlayeLevel; break; case GAME_STATE_GAME_OVER: currentGameStateFunction = gameStateGameOver; break;
 }
}
We will call the <code>runGame()</code> function repeatedly in the <code>setInterval()</code> method. 

<code>runGame()</code> will call the <code>currentGameStateFunction</code> reference variable on each frame tick. 
This allows us to easily change the function called by <code>runGame()</code> based on changes in the application state:
setInterval(runGame, intervalTime );
function runGame(){ currentGameStateFunction();
}
Let’s look at the complete code. 
We will create some shell functions for the various application state functions. 

Before the application starts, we will call the <code>switchGame</code><code>State()</code> function, and pass in the constant value for the new function we want as the <code>currentGameStateFunction</code>:
//*** application start switchGameState(GAME_STATE_TITLE);
In Example 8-9</a>, we will use the <code>GAME_STATE_TITLE</code> state to draw a simple title screen that will be redrawn on each frame tick.

Example 8-9. 
The tile screen state
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);

function eventWindowLoaded() {
 canvasApp();
}
 function canvasApp(){ var theCanvas = document.getElementById("canvas");
 if (!theCanvas || !theCanvas.getContext) { return;
 }
 var context = theCanvas.getContext("2d"); if (!context) { return;
 }
 //application states const GAME_STATE_TITLE = 0; const GAME_STATE_NEW_LEVEL = 1;
 const GAME_STATE_GAME_OVER = 2;
 var currentGameState = 0;
 var currentGameStateFunction = null; function switchGameState(newState) { currentGameState = newState; switch (currentGameState) {
 case GAME_STATE_TITLE: currentGameStateFunction = gameStateTitle; break;
 case GAME_STATE_PLAY_LEVEL: currentGameStateFunctionappStatePlayeLevel; break;
 case GAME_STATE_GAME_OVER: currentGameStateFunction = gameStateGameOver; break; }
 }
 function gameStateTitle() { ConsoleLog.log("appStateTitle"); // draw background and text context.fillStyle = '#000000'; context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff'; context.font = '20px _sans'; context.textBaseline = 'top'; context.fillText ("Title Screen", 50, 90);
 } function gameStatePlayLevel() { ConsoleLog.log("appStateGamePlay");
 }
 function gameStateGameOver() { ConsoleLog.log("appStateGameOver");
 } function runGame(){ currentGameStateFunction();
 }
 //*** application start switchGameState(GAME_STATE_TITLE); //**** application loop const FRAME_RATE = 40;
 var intervalTime = 1000/FRAME_RATE;
 setInterval(runGame, intervalTime );

}
//***** object prototypes *****
//*** consoleLog util object
//create constructor

function ConsoleLog(){
}
//create function that will be added to the class
console_log = function(message) { if(typeof(console) !== 'undefined' &amp;&amp; console != null) { console.log(message);
 }
}
//add class/static function to class by assignment

ConsoleLog.log = console_log;
//*** end console log object
&lt;/script&gt;
<h3>Note</h3>

Example 8-9</a> added in the <code>ConsoleLog</code> object from the previous chapters. 
We will continue to use this utility to create helpful debug messages in the JavaScript log window of the browser.
We will continue to explore the application state machine, and then create one for our game logic states in the upcoming section, Putting It All Together</a>.
<h3>The Update/Render (Repeat) Cycle</h3>

In any of our application states, we might need to employ animation and screen updates. 
We will handle these updates by separating our code into distinct <code>update()</code> and <code>render()</code> operations. 
For example, as you might recall, the player ship can move around the game screen, and when the player presses the up arrow key, the ship’s thrust frame of animation will be displayed rather than its static frame. 
In the previous examples, we contained all the code that updates the properties of the ship, as well as the code that actually draws the ship, in a single function called <code>drawScreen()</code>. 

Starting with Example 8-10</a>, we will rid ourselves of this simple <code>drawScreen()</code> function and instead employ <code>update()</code> and <code>render()</code> functions separately. 
We will also separate out the code that checks for the game-specific key presses into a <code>checkKeys()</code> function.
Let’s reexamine the contents of the <code>drawScreen()</code> function from Example 8-8</a>, but this time break the function up into separate functions for each set of tasks, as shown in Example 8-10</a>.
Example 8-10. 

Splitting the update and render cycles
function gameStatePlayLevel() {
 checkKeys();
 update(); render();
}
function checkKeys() {
 //check keys if (keyPressList[38]==true){ //thrust var angleInRadians = rotation * Math.PI / 180; facingX = Math.cos(angleInRadians); facingY = Math.sin(angleInRadians);
 movingX = movingX+thrustAcceleration*facingX; movingY = movingY+thrustAcceleration*facingY;
 }
 if (keyPressList[37]==true) { //rotate counterclockwise rotation,=rotationalVelocity; }
 if (keyPressList[39]==true) { //rotate clockwise rotation+=rotationalVelocity;;
 }
}

function update() {
 x = x+movingX;
 y = y+movingY;
}

function render() {
 //draw background and text context.fillStyle = '#000000';
 context.fillRect(0, 0, 200, 200); context.fillStyle = '#ffffff';
 context.font = '20px _sans';
 context.textBaseline = 'top';
 context.fillText ("render/update", 0, 180); //transformation var angleInRadians = rotation * Math.PI / 180;
 context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity //translate the canvas origin to the center of the player context.translate(x+.5*width,y+.5*height);
 context.rotate(angleInRadians);
 //drawShip context.strokeStyle = '#ffffff';
 context.beginPath();
 //hardcoding in locations
 //facing right context.moveTo(,10,,10);
 context.lineTo(10,0);
 context.moveTo(10,1);
 context.lineTo(,10,10); context.lineTo(1,1);
 context.moveTo(1,,1);
 context.lineTo(,10,,10);
 context.stroke(); context.closePath();
 //restore context context.restore(); //pop old state on to screen
}

const FRAME_RATE = 40;
var intervalTime = 1000/FRAME_RATE;
setInterval(appStateGamePlay, intervalTime );
We left out the entire application state machine from Example 8-9</a> to save space. 

In Example 8-10</a>, we are simply showing what the <code>gameStatePlayLevel()</code> function might look like.
In the section Putting It All Together</a>, we will go into this in greater detail as we start to build out the entire application.
<h3>The FrameRateCounter Object Prototype</h3>
Arcade games such as <em>Asteroids</em> and <em>Geo Blaster Basic</em> rely on fast processing and screen updates to ensure all game-object rendering and game-play logic are delivered to the player at a reliable rate. 

One way to tell whether your game is performing up to par is to employ the use of a frame rate per second (FPS) counter. 
Below is a simple one that can be reused in any game you create on the canvas:
//*** FrameRateCounter object prototype
function FrameRateCounter() { this.lastFrameCount = 0;
 var dateTemp = new Date();
 this.frameLast = dateTemp.getTime();
 delete dateTemp; this.frameCtr = 0;
}
FrameRateCounter.prototype.countFrames=function() {
 var dateTemp = new Date(); this.frameCtr++;
 if (dateTemp.getTime() &gt;=this.frameLast+1000) { ConsoleLog.log("frame event"); this.lastFrameCount = this.frameCtr; this.frameLast = dateTemp.getTime(); this.frameCtr = 0;
 }
 delete dateTemp;

}
Our game will create an instance of this object and call the <code>countFrames()</code> function on each frame tick in our <code>update()</code> function. 
We will write out the current frame rate in our <code>render()</code> function.
Example 8-11</a> shows these functions by adding code to Example 8-10</a>. 

Make sure you add the definition of the <code>FrameRateCounter</code> prototype object to the code in Example 8-10</a> under the <code>canvasApp()</code> function but before the final <code>&lt;script&gt;</code> tag. 
Alternatively, you can place it in its own <code>&lt;script\&gt;</code> tags, or in a separate <em>.js</em> file and set the URL as the <code>src=</code> value of a <code>&lt;script&gt;</code> tag. 
For simplicity’s sake, we will keep all our code in a single file.
Example 8-11</a> contains the definition for our <code>FrameRateCounter</code> object prototype, as well as the code changes to Example 8-10</a> that are necessary to implement it.

Example 8-11. 
The FrameRateCounter is added
function update() {
 x = x+movingX; y = y+movingY;
 frameRateCounter.countFrames();
}
function render() { // draw background and text context.fillStyle = '#000000';
 context.fillRect(0, 0, 200, 200);
 context.fillStyle = '#ffffff'; context.font = '20px _sans';
 context.textBaseline = 'top';
 context.fillText ("FPS:" + frameRateCounter.lastFrameCount, 0, 180);
 //...Leave everything else from Example 8-10 intact here

}
frameRateCounter = new FrameRateCounter();
const FRAME_RATE = 40;
var intervalTime = 1000/FRAME_RATE;

setInterval(runGame, intervalTime );
<h2>Putting It All Together</h2>
We are now ready to start coding our game. 
First, we will look at the structure of the game and some of the ideas behind the various algorithms we will employ to create it. 

After that, we will present the full source code for <em>Geo Blaster Basic</em>.
<h3>Geo Blaster Game Structure</h3>
The structure of the game application is very similar to the structure we started to build earlier in this chapter. 
Let’s take a closer look at the state functions and how they will work together.

<h4>Game application states</h4>
Our game will have seven distinct game application states. 
We will store these in constants:
const GAME_STATE_TITLE = 0;

const GAME_STATE_NEW_GAME = 1;
const GAME_STATE_NEW_LEVEL = 2;
const GAME_STATE_PLAYER_START = 3;
const GAME_STATE_PLAY_LEVEL = 4;

const GAME_STATE_PLAYER_DIE = 5;
const GAME_STATE_GAME_OVER = 6;
<h4>Game application state functions</h4>
Each individual state will have an associated function that will be called on each frame tick. 

Let’s look at the functionality for each:
<code>gameStateTitle()</code>

Displays the title screen text and waits for the space bar to be pressed before the game starts.
<code>gameStateNewGame()</code>

Sets up all the defaults for a new game. 
All of the arrays for holding display objects are reinitialized—the game <code>level</code> is reset to <code>0</code>, and the game <code>score</code> is set to <code>0</code>.
<code>gameStateNewLevel()</code>

Increases the <code>level</code> value by one, and then sets the “game knob” values to control the level difficulty. 
See the upcoming section Level Knobs</a> for details.

<code>gameStatePlayerStart()</code>
Fades the player graphic onto the screen from <code>0</code> alpha to <code>1</code>. 
Once this is complete, level play will start.

<code>gameStatePlayLevel()</code>
Controls the play of the game level. 

It calls the <code>update()</code> and <code>render()</code> functions, as well as the functions for evaluating keyboard input for player ship control.
<code>gameStatePlayerDie()</code>

Starts up an explosion at the location where the player ship was when it was hit by a rock, saucer, or saucer missile. 
Once the explosion is complete (all particles in the explosion have exhausted their individual life values), it sets the move to the <code>GAME_STATE_PLAYER_START</code> state.
<code>gameStateGameOver()</code>

Displays the “Game Over” screen, and starts a new game when the space bar is pressed.

<h4>Game application functions</h4>
Aside from the game application state functions, there are a number of functions we need for the game to run. 
Each state function will call these functions as needed:

<code>resetPlayer()</code>
Resets the player to the center of the game screen and readies it for game play.

<code>checkForExtraShip()</code>
Checks to see whether the player should be awarded an extra ship. 
See the section Awarding the Player Extra Ships</a> for details on this algorithm.

<code>checkForEndOfLevel()</code>
Checks to see whether all the rocks have been destroyed on a given level and, if so, starts up a new level. 

See the section Level and Game End</a> for details on this algorithm.
<code>fillBackground()</code>

Fills the canvas with the background color on each frame tick.
<code>setTextStyle()</code>

Sets the base text style before text is written to the game screen.
<code>renderScoreBoard()</code>

Is called on each frame tick. 
It displays the updated score, number of ships remaining, and the current FPS for the game.
<code>checkKeys()</code>

Checks the <code>keyPressList</code> array, and then modifies the player ship attributes based on the values found to be <code>true</code>.
<code>update()</code>

Is called from <code>GAME_STATE_PLAY_LEVEL</code>. 
It in turn calls the <code>update()</code> function for each individual display object array.

Individual display object <code>update()</code> functions
The unique functions listed below update each different type of display object. 
These functions (with the exception of <code>updatePlayer()</code>) will loop through the respective array of objects associated with its type of display object, and update the <code>x</code> and <code>y</code> values with <code>dx</code> and <code>dy</code> values. 

The <code>updateSaucer()</code> function contains the logic necessary to check whether to create a new saucer, and whether any current saucers on the screen should fire a missile at the player.
<code>updatePlayer()</code>

<code>updatePlayerMissiles()</code>
<code>updateRocks()</code>
<code>updateSaucers()</code>
<code>updateSaucerMissiles()</code>

<code>updateParticles()</code>

<code>render()</code>

Is called from <code>GAME_STATE_PLAY_LEVEL</code>. 
It in turn calls the <code>render()</code> function for each individual display object array.
Individual display object <code>render()</code> functions

Like the <code>update()</code> functions, the unique functions listed below render each different type of display object. 
Again, with the exception of the <code>renderPlayer()</code> object (because there is only a single player ship), each of these functions will loop through the array of objects associated with its type and draw them to the game screen. 
As we saw when drawing the player ship earlier in this chapter, we will draw each object by moving and translating the canvas to the point at which we want to draw our logical object. 

We will then transform our object (if necessary) and paint the paths to the game screen.
<code>renderPlayer()</code>

<code>renderPlayerMissiles()</code>
<code>renderRocks()</code>
<code>renderSaucers()</code>
<code>renderSaucerMissiles()</code>

<code>renderParticles()</code>

<code>checkCollisions()</code>

Loops through the individual game display objects and checks them for collisions. 
See the section Applying Collision Detection</a> for a detailed discussion of this topic.
<code>firePlayerMissile()</code>

Creates a <code>playerMissile</code> object at the center of the player ship and fires it in the direction the player ship is facing.
<code>fireSaucerMissile()</code>

Creates a <code>saucerMissile</code> object at the center of the saucer and fires it in the direction of the player ship.
<code>playerDie()</code>

Creates an explosion for the player by calling <code>createExplode()</code>, as well as changing the game application state to <code>GAME_STATE_PLAYER_DIE</code>.
<code>createExplode()</code>

Accepts in the location for the explosion to start and the number of particles for the explosion.
<code>boundingBoxCollide()</code>

Determines whether the rectangular box that encompasses an object’s width and height is overlapping the bounding box of another object. 
It takes in two logical display objects as parameters, and returns <code>true</code> if they are overlapping and <code>false</code> if they are not. 
See the section Applying Collision Detection</a> for details on this function.

<code>splitRock()</code>
Accepts in the scale and <code>x</code> and <code>y</code> starting points for two new rocks that will be created if a large or medium rock is destroyed.

<code>addToScore()</code>
Accepts in a value to add to the player’s score.

<h3>Geo Blaster Global Game Variables</h3>
Now let’s look at the entire set of game application scope variables needed for our game.

Variables that control screen flow
These variables will be used when the title and “Game Over” screens first appear. 

They will be set to <code>true</code> once the screen is drawn. 
When these variables are <code>true</code>, the screens will look for the space bar to be pressed before moving on to the next application state:
var titleStarted = false;
var gameOverStarted = false;

Game environment variables
These variables set up the necessary defaults for a new game. 

We will discuss the <code>extraShipAtEach</code> and <code>extraShipsEarned</code> in the section, Awarding the Player Extra Ships</a>:
var score = 0;
var level = 0;
var extraShipAtEach = 10000;

var extraShipsEarned = 0;
var playerShips = 3;
Playfield variables

These variables set up the maximum and minimum <code>x</code> and <code>y</code> coordinates for the game stage:
var xMin = 0;
var xMax = 400;

var yMin = 0;
var yMax = 400;
Score value variables

These variables set the score value for each of the objects the player can destroy:
var bigRockScore = 50;
var medRockScore = 75;

var smlRockScore = 100;
var saucerScore = 300;
Rock size constants

These variables set up some human-readable values for the three rock sizes, allowing us to simply use the constant instead of a literal value. 
We can then change the literal value if needed:
const ROCK_SCALE_LARGE = 1;

const ROCK_SCALE_MEDIUM = 2;
const ROCK_SCALE_SMALL = 3;
Logical display objects

These variables set up the single player object and arrays to hold the various other logical display objects for our game. 
See the upcoming sections </a> and Arrays of Logical Display Objects</a> for further details on each:
var player = {};

var rocks = [];
var saucers = [];
var playerMissiles = [];
var particles = []

var saucerMissiles = [];
Level-specific variables

The level-specific variables handle the difficulty settings when the game level increases. 
See the section Level Knobs</a> for more details on how these are used:
var levelRockMaxSpeedAdjust = 1;
var levelSaucerMax = 1;

var levelSaucerOccurrenceRate = 25
var levelSaucerSpeed = 1;
var levelSaucerFireDelay = 300;
var levelSaucerFireRate = 30;

var levelSaucerMissileSpeed = 1;
<h2>The player Object</h2>
The <code>player</code> object contains many of the variables we encountered earlier in this chapter when we discussed animating, rotating, and moving the player ship about the game screen. 
We have also added in three new variables that you have not seen before:
player.maxVelocity = 5;
player.width = 20;

player.height = 20;
player.halfWidth = 10;
player.halfHeight = 10;
player.rotationalVelocity = 5

player.thrustAcceleration = .05;
player.missileFrameDelay = 5;
player.thrust = false;
The new variables are <code>halfWidth</code>, <code>halfHeight</code>, and <code>missileFrameDelay</code>. 

<code>halfWidth</code> and <code>halfHeight</code> simply store half the width and half the height values, so these need not be calculated on each frame tick in multiple locations inside the code. 
The <code>missileFrameDelay</code> variable contains the number of frame ticks the game will count between firing player missiles. 
This way, the player cannot simply fire a steady stream of ordnance and destroy everything with little difficulty.
The <code>player.thrust</code> variable will be set to <code>true</code> when the player presses the up key.

<h2>Geo Blaster Game Algorithms</h2>
The game source code covers a lot of ground that we did not touch on earlier in this chapter. 
Let’s discuss some of those topics now; the rest will be covered in detail in Chapter 9.

<h3>Arrays of Logical Display Objects</h3>
We have used arrays to hold all our logical display objects, and we have an array for each type of object (<code>rocks</code>, <code>saucers</code>, <code>playerMissiles</code>, <code>saucerMissiles</code>, and <code>particles</code>). 
Each logical display object is a simple object instance. 
We have created a separate function to draw and update each of our objects.

<h3>Note</h3>
The use of an object class prototype similar to <code>FrameRateCounter</code> can be implemented easily for the various display object types. 
To conserve space, we have not implemented them in this game. 
However, these objects would allow us to separate the update and draw code from the current common functions, and then place that code into the individual object prototypes. 

We have included a Rock prototype at the end of this chapter as an example (see Example 8-13</a>).
You will notice that saucers and rocks are drawn with points in the same manner as the player ship.
<h4>Rocks</h4>
The rocks will be simple squares that rotate clockwise or counterclockwise. 

The rock instances will be in the <code>rocks</code> array. 
When a new level starts, these will all be created in the upper-right corner of the game screen.
Here are the variable attributes of a <code>rock</code> object:
newRock.scale = 1;

newRock.width = 50;
newRock.height = 50;
newRock.halfWidth = 25;
newRock.halfHeight = 25;

newRock.x
newRock.y
newRock.dx
newRock.dy

newRock.scoreValue = bigRockScore;
newRock.rotation = 0;
The rock scale will be set to one of the three rock-scale constants discussed earlier. 
<code>halfWidth</code> and <code>halfHeight</code> will be set based on the scale, and they will be used in calculations in the same manner as the player object versions. 

The <code>dx</code> and <code>dy</code> values represent the values to apply to the x and y axes when updating the rock on each frame tick.
<h4>Saucers</h4>
Unlike Atari’s <em>Asteroids</em> game, which has both small and large saucers, we are only going to have one size in <em>Geo Blaster Basic</em>. 
It will be stored in the <code>saucers</code> array. 

On a 28×13 grid (using paths), it looks like Figure 8-6.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893817.png" alt="The saucer design" width="226" height="105">
Figure 8-6. 

The saucer design
The variable attributes of the <code>saucer</code> object are very similar to the attributes of a <code>rock</code> object, although without the rock <code>scale</code> attribute. 
Also, saucers don’t have a rotation; it is always set at <code>0</code>. 
The saucer also contains variables that are updated on each new level to make the game more challenging for the player. 

Here are those variables, which will be discussed in more detail in the upcoming section </a>:
newSaucer.fireRate = levelSaucerFireRate;
newSaucer.fireDelay = levelSaucerFireDelay;
newSaucer.fireDelayCount = 0;

newSaucer.missileSpeed = levelSaucerMissileSpeed;
<h4>Missiles</h4>
Both the player missiles and saucer missiles will be 2×2-pixel blocks. 
They will be stored in the <code>playerMissiles</code> and <code>saucerMissiles</code> arrays, respectively.

The objects are very simple. 
They contain enough attributes to move them across the game screen and to calculate life values:
newPlayerMissile.dx = 5*Math.cos(Math.PI*(player.rotation)/180);
newPlayerMissile.dy = 5*Math.sin(Math.PI*(player.rotation)/180);

newPlayerMissile.x = player.x+player.halfWidth;
newPlayerMissile.y = player.y+player.halfHeight;
newPlayerMissile.life = 60;
newPlayerMissile.lifeCtr = 0;

newPlayerMissile.width = 2;
newPlayerMissile.height = 2;
<h4>Explosions and particles</h4>
When a rock, saucer, or the player ship is destroyed, that object explodes into a series of particles. 

The <code>createExplode()</code> function creates this so-called particle explosion. 
Particles are simply individual logical display objects with their own <code>life</code>, <code>dx</code>, and <code>dy</code> values. 
Randomly generating these values makes each explosion appear to be unique. 
Particles will be stored in the <code>particles</code> array.

Like missiles, <code>particle</code> objects are rather simple. 
They also contain enough information to move them across the screen and to calculate their life span in frame ticks:
newParticle.dx = Math.random()*3;
newParticle.dy = Math.random()*3;

newParticle.life = Math.floor(Math.random()*30+30);
newParticle.lifeCtr = 0;
newParticle.x = x;
newParticle.y = y;

<h3>Level Knobs</h3>
Even though we never show the level number to the game player, we are adjusting the difficulty every time a screen of rocks is cleared. 
We do this by increasing the level variable by <code>1</code> and then recalculating these values before the level begins. 
We refer to the variance in level difficulty as <em>knobs</em>, which refers to dials or switches. 

Here are the variables we will use for these knobs:
<code>level+3</code>

Number of rocks
<code>levelRockMaxSpeedAdjust = level*.25;</code>

Rock max speed
<code>levelSaucerMax = 1+Math.floor(level/10);</code>

Number of simultaneous saucers
<code>levelSaucerOccurrenceRate = 10+3*level;</code>

Percent chance a saucer will appear
<code>levelSaucerSpeed = 1+.5*level;</code>

Saucer speed
<code>levelSaucerFireDelay = 120-10*level;</code>

Delay between saucer missiles
<code>levelSaucerFireRate = 20+3*level;</code>

Percent chance a saucer will fire at the player
<code>levelSaucerMissileSpeed = 1+.2*level;</code>

Speed of saucer missiles
<h3>Level and Game End</h3>

We need to check for game and level end so we can transition to either a new game or to the next level.
<h4>Level end</h4>
We will check for level end on each frame tick. 
The function to do so will look like this:

function checkForEndOfLevel(){
 if (rocks.length==0) { switchGameState(GAME_STATE_NEW_LEVEL);
 }
}

Once the <code>rocks</code> array length is <code>0</code>, we switch the state to <code>GAME_STATE_NEW_LEVEL</code>.
<h4>Game end</h4>
We do not need to check for the end of the game on each frame tick. 
We only need to check when the player loses a ship. 

We do this inside the <code>gameStatePlayerDie()</code> function:
function gameStatePlayerDie(){
 if (particles.length &gt;0 || playerMissiles.length&gt;0) { fillBackground(); renderScoreBoard(); updateRocks(); updateSaucers(); updateParticles(); updateSaucerMissiles(); updatePlayerMissiles(); renderRocks(); renderSaucers(); renderParticles(); renderSaucerMissiles(); renderPlayerMissiles(); frameRateCounter.countFrames();
 }else{ playerShips--; if (playerShips&lt;1) { switchGameState(GAME_STATE_GAME_OVER); }else{ resetPlayer(); switchGameState(GAME_STATE_PLAYER_START); } }
}
This is the state function that is called on each frame tick during the <code>GAME_STATE_PLAYER_DIE</code> state. 
First, it checks to see that there are no longer any particles on the screen. 

This ensures that the game will not end until the player ship has finished exploding. 
We also check to make sure that all the player’s missiles have finished their lives. 
We do this so we can check for collisions between the <code>playerMissiles</code>, and for <code>rocks</code> against <code>saucers</code>. 
This way the player might earn an extra ship before <code>playerShips--</code> is called.

Once the <code>particles</code> and <code>missiles</code> have all left the game screen, we subtract <code>1</code> from the <code>playerShips</code> variable and then switch to <code>GAME_STATE_GAME_OVER</code> if the <code>playerShips</code> number is less than <code>1</code>.
<h3>Awarding the Player Extra Ships</h3>
We want to award the player extra ships at regular intervals based on her score. 
We do this by setting an amount of points that the game player must achieve to earn a new ship—this also helps us keep a count of the number of ships earned:

function checkForExtraShip() {
 if (Math.floor(score/extraShipAtEach) &gt; extraShipsEarned) { playerShips++ extraShipsEarned++;
 }
}

We call this function on each frame tick. 
The player earns an extra ship if the <code>score/extraShipAtEach</code> variable (with the decimals stripped off) is greater than the number of ships earned. 
In our game, we have set the <code>extraShipAtEach</code> value to <code>10000</code>. 
When the game starts, <code>extraShipsEarned</code> is <code>0</code>. 

When the player’s score is <code>10000</code> or more, <code>score/extraShipAtEach</code> will equal <code>1</code>, which is greater than the <code>extraShipsEarned</code> value of <code>0</code>. 
An extra ship is given to the player, and the <code>extraShipsEarned</code> value is increased by <code>1</code>.
<h3>Applying Collision Detection</h3>
We will be checking the bounding box around each object when we do our collision detection. 

A bounding box is the smallest rectangle that will encompass all four corners of a game logic object. 
We have created a function for this purpose:
function boundingBoxCollide(object1, object2) {
 var left1 = object1.x; var left2 = object2.x;
 var right1 = object1.x + object1.width;
 var right2 = object2.x + object2.width;
 var top1 = object1.y; var top2 = object2.y;
 var bottom1 = object1.y + object1.height;
 var bottom2 = object2.y + object2.height;
 if (bottom1 &lt; top2) return(false); if (top1 &gt; bottom2) return(false);
 if (right1 &lt; left2) return(false);
 if (left1 &gt; right2) return(false);
 return(true);

};
We can pass any two of our game objects into this function as long as each contains <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> attributes. 
If the two objects are overlapping, the function will return <code>true</code>. 
If not, it will return <code>false</code>.

The <code>checkCollision()</code> function for <em>Geo Blaster Basic</em> is quite involved. 
The full code listing is given in Example 8-12</a>. 
Rather than reprint it here, let’s examine some of the basic concepts.
One thing you will notice is the use of “labels” next to the <code>for</code> loop constructs. 

Using labels such as in the following line can help streamline collision detection:
rocks: for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){
We will need to loop through each of the various object types that must be checked against one another. 
But we do not want to check an object that was previously destroyed against other objects. 

To ensure we do the fewest amount of collision checks necessary, we have implemented a routine that employs label and <code>break</code> statements.
Here is the logic behind the routine:
Create a <code>rocks:</code> label and then start to loop through the <code>rocks</code> array.
Create a <code>missiles:</code> label inside the <code>rocks</code> iteration, and loop through the <code>playerMissiles</code> array.

Do a bounding box collision detection between the last rock and the last missile. 
Notice that we loop starting at the end of each array so that we can remove elements (when collisions occur) in the array without affecting array members that have not been checked yet.
If a rock and a missile collide, remove them from their respective arrays, and then call <code>break rocks</code> and then <code>break missiles</code>. 
We must break back to the next element in an array for any object type that is removed.

Continue looping through the missiles until they have all been checked against the current rock (unless <code>break rocks</code> was fired off for a rock/missile collision).
Check each saucer, each saucer missile, and the player against each of the rocks. 
The player does not need a label because there is only a single instance of the player. 
The <code>saucers</code> and <code>saucerMissiles</code> will follow the same logic as <code>missiles</code>. 

If there is a collision between one and a rock, break back to their respective labels after removing the objects from their respective arrays.
Once we have checked the rocks against all the other game objects, check the <code>playerMissiles</code> against the saucers using the same basic logic of loop labels, looping backward through the arrays, and breaking back to the labels once objects are removed.
Check the <code>saucerMissiles</code> against the player in the same manner.
</li>

</ol>
Over the years, we have found this to be a powerful way to check multiple objects’ arrays against one another. 
It certainly is not the only way to do so. 
If you are not comfortable using loop labels, you can employ a method such as the following:

Add a Boolean <code>hit</code> attribute to each object and set it to <code>false</code> when an object is created.
Loop through the <code>rocks</code> and check them against the other game objects. 
This time the direction (forward or backward) through the loops does not matter.
Before calling the <code>boundingBoxCollide()</code> function, be sure that each object’s <code>hit</code> attribute is <code>false</code>. 

If not, skip the collision check.
If the two objects collide, set each object’s <code>hit</code> attribute to <code>true</code>. 
There is no need to remove objects from the arrays at this time.
Loop though <code>playerMissiles</code> and check against the <code>saucers</code>, and then loop through the <code>saucers</code> to check against the <code>player</code>.

When all the collision-detection routines are complete, reloop through each object array (backward this time) and remove all the objects with <code>true</code> as a <code>hit</code> attribute.
</li>
</ol>
We have used both methods—and variations—on each. 

While the second method is a little cleaner, this final loop through all of the objects might add more processor overhead when dealing with a large number of objects. 
We will leave the implementation of this second method to you as an exercise, in case you wish to test it.
<h2>The Geo Blaster Basic Full Source</h2>
Example 8-12</a> shows the entire set of code for our game. 

You can download this and the entire set of example files from the book’s website.
Example 8-12. 
The Geo Blaster Basic full source listing
&lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;Geo Blaster Basic Game&lt;/title&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}

function canvasApp(){
 var theCanvas = document.getElementById("canvas");
 if (!theCanvas || !theCanvas.getContext) { return;
 } var context = theCanvas.getContext("2d");
 if (!context) { return;
 }
 //application states const GAME_STATE_TITLE = 0;
 const GAME_STATE_NEW_GAME = 1;
 const GAME_STATE_NEW_LEVEL = 2;
 const GAME_STATE_PLAYER_START = 3; const GAME_STATE_PLAY_LEVEL = 4;
 const GAME_STATE_PLAYER_DIE = 5;
 const GAME_STATE_GAME_OVER = 6;
 var currentGameState = 0; var currentGameStateFunction = null;
 //title screen var titleStarted = false;
 //gameover screen var gameOverStarted = false;
 //objects for game play
 //game environment var score = 0; var level = 0;
 var extraShipAtEach = 10000;
 var extraShipsEarned = 0;
 var playerShips = 3; //playfield var xMin = 0;
 var xMax = 400;
 var yMin = 0; var yMax = 400;
 //score values var bigRockScore = 50;
 var medRockScore = 75; var smlRockScore = 100;
 var saucerScore = 300;
 //rock scale constants const ROCK_SCALE_LARGE = 1; const ROCK_SCALE_MEDIUM = 2;
 const ROCK_SCALE_SMALL = 3;
 //create game objects and arrays var player = {}; var rocks = [];
 var saucers = [];
 var playerMissiles = [];
 var particles = [] var saucerMissiles = [];
 //level specific var levelRockMaxSpeedAdjust = 1;
 var levelSaucerMax = 1; var levelSaucerOccurrenceRate = 25;
 var levelSaucerSpeed = 1;
 var levelSaucerFireDelay = 300;
 var levelSaucerFireRate = 30; var levelSaucerMissileSpeed = 1;
 //keyPresses var keyPressList = [];
 function runGame(){ currentGameStateFunction(); }
 function switchGameState(newState) { currentGameState = newState; switch (currentGameState) {
 case GAME_STATE_TITLE: currentGameStateFunction = gameStateTitle; break; case GAME_STATE_NEW_GAME: currentGameStateFunction = gameStateNewGame; break; case GAME_STATE_NEW_LEVEL: currentGameStateFunction = gameStateNewLevel; break; case GAME_STATE_PLAYER_START: currentGameStateFunction = gameStatePlayerStart; break; case GAME_STATE_PLAY_LEVEL: currentGameStateFunction = gameStatePlayLevel; break; case GAME_STATE_PLAYER_DIE: currentGameStateFunction = gameStatePlayerDie; break;
 case GAME_STATE_GAME_OVER: currentGameStateFunction = gameStateGameOver; break; }
 }
 function gameStateTitle() { if (titleStarted !=true){ fillBackground(); setTextStyle(); context.fillText ("Geo Blaster Basic", 130, 70); context.fillText ("Press Space To Play", 120, 140);
 titleStarted = true; }else{ //wait for space key click if (keyPressList[32]==true){ ConsoleLog.log("space pressed"); switchGameState(GAME_STATE_NEW_GAME); titleStarted = false; } }
 }
 function gameStateNewGame(){ ConsoleLog.log("gameStateNewGame") //set up new game level = 0; score = 0; playerShips = 3; player.maxVelocity = 5; player.width = 20; player.height = 20; player.halfWidth = 10; player.halfHeight = 10; player.rotationalVelocity = 5; //how many degrees to turn the ship player.thrustAcceleration = .05; player.missileFrameDelay = 5; player.thrust = false;
 fillBackground(); renderScoreBoard(); switchGameState(GAME_STATE_NEW_LEVEL) }
 function gameStateNewLevel(){ rocks = []; saucers = []; playerMissiles = []; particles = []; saucerMissiles = []; level++; levelRockMaxSpeedAdjust = level*.25; if (levelRockMaxSpeedAdjust &gt; 3){ levelRockMaxSpeed = 3; }
 levelSaucerMax = 1+Math.floor(level/10); if (levelSaucerMax &gt; 5){ levelSaucerMax = 5; } levelSaucerOccurrenceRate = 10+3*level; if (levelSaucerOccurrenceRate &gt; 35){ levelSaucerOccurrenceRate = 35; } levelSaucerSpeed = 1+.5*level; if (levelSaucerSpeed&gt;5){ levelSaucerSpeed = 5; } levelSaucerFireDelay = 120-10*level; if (levelSaucerFireDelay&lt;20) { levelSaucerFireDelay = 20; }
 levelSaucerFireRate = 20 + 3*level; if (levelSaucerFireRate&lt;50) { levelSaucerFireRate = 50; } levelSaucerMissileSpeed = 1+.2*level; if (levelSaucerMissileSpeed &gt; 4){ levelSaucerMissileSpeed = 4; } //create level rocks for (var newRockctr=0;newRockctr&lt;level+3;newRockctr++){ var newRock={};
 newRock.scale = 1; //scale //1 = large //2 = medium //3 = small //these will be used as the divisor for the new size //50/1 = 50 //50/2 = 25 //50/3 = 16 newRock.width = 50; newRock.height = 50; newRock.halfWidth = 25; newRock.halfHeight = 25;
 //start all new rocks in upper left for ship safety newRock.x = Math.floor(Math.random()*50);
 //ConsoleLog.log("newRock.x=" + newRock.x); newRock.y = Math.floor(Math.random()*50); //ConsoleLog.log("newRock.y=" + newRock.y); newRock.dx = (Math.random()*2)+levelRockMaxSpeedAdjust; if (Math.random()&lt;.5){ newRock.dx*=-1; }
 newRock.dy = (Math.random()*2)+levelRockMaxSpeedAdjust; if (Math.random()&lt;.5){ newRock.dy*=-1; }
 //rotation speed and direction newRock.rotationInc = (Math.random()*5)+1;
 if (Math.random()&lt;.5){ newRock.rotationInc*=-1; } newRock.scoreValue = bigRockScore; newRock.rotation = 0;
 rocks.push(newRock); //ConsoleLog.log("rock created rotationInc=" + newRock.rotationInc); } resetPlayer(); switchGameState(GAME_STATE_PLAYER_START);
 }
 function gameStatePlayerStart(){ fillBackground(); renderScoreBoard(); if (player.alpha &lt; 1){ player.alpha += .02; context.globalAlpha = player.alpha; }else{ switchGameState(GAME_STATE_PLAY_LEVEL); } renderPlayerShip(player.x, player.y,270,1); context.globalAlpha = 1; updateRocks(); renderRocks();
 }
 function gameStatePlayLevel(){ checkKeys(); update(); render(); checkCollisions(); checkForExtraShip(); checkForEndOfLevel(); frameRateCounter.countFrames();
 } function resetPlayer() { player.rotation = 270; player.x = .5*xMax; player.y = .5*yMax; player.facingX = 0; player.facingY = 0; player.movingX = 0; player.movingY = 0; player.alpha = 0; player.missileFrameCount = 0;
 }
 function checkForExtraShip() { if (Math.floor(score/extraShipAtEach) &gt; extraShipsEarned) { playerShips++ extraShipsEarned++; }
 } function checkForEndOfLevel(){ if (rocks.length==0) { switchGameState(GAME_STATE_NEW_LEVEL); }
 }
 function gameStatePlayerDie(){ if (particles.length &gt;0 || playerMissiles.length&gt;0) { fillBackground(); renderScoreBoard(); updateRocks(); updateSaucers(); updateParticles(); updateSaucerMissiles(); updatePlayerMissiles(); renderRocks(); renderSaucers(); renderParticles(); renderSaucerMissiles(); renderPlayerMissiles(); frameRateCounter.countFrames();
 }else{ playerShips--; if (playerShips&lt;1) { switchGameState(GAME_STATE_GAME_OVER); }else{ resetPlayer(); switchGameState(GAME_STATE_PLAYER_START); } } }
 function gameStateGameOver() { //ConsoleLog.log("Game Over State"); if (gameOverStarted !=true){ fillBackground(); renderScoreBoard(); setTextStyle(); context.fillText ("Game Over!", 150, 70); context.fillText ("Press Space To Play", 120, 140);
 gameOverStarted = true; }else{ //wait for space key click if (keyPressList[32]==true){ ConsoleLog.log("space pressed"); switchGameState(GAME_STATE_TITLE); gameOverStarted = false;
 } } }
 function fillBackground() { // draw background and text context.fillStyle = '#000000'; context.fillRect(xMin, yMin, xMax, yMax);
 }
 function setTextStyle() { context.fillStyle = '#ffffff'; context.font = '15px _sans'; context.textBaseline = 'top'; }
 function renderScoreBoard() {
 context.fillStyle = "#ffffff"; context.fillText('Score ' + score, 10, 20); renderPlayerShip(200,16,270,.75) context.fillText('X ' + playerShips, 220, 20);
 context.fillText('FPS: ' + frameRateCounter.lastFrameCount, 300,20) }
 function checkKeys() { //check keys if (keyPressList[38]==true){ //thrust var angleInRadians = player.rotation * Math.PI / 180; player.facingX = Math.cos(angleInRadians); player.facingY = Math.sin(angleInRadians);
 var movingXNew = player.movingX+player.thrustAcceleration*player.facingX; var movingYNew = player.movingY+player.thrustAcceleration*player.facingY; var currentVelocity = Math.sqrt ((movingXNew*movingXNew) + (movingXNew*movingXNew));
 if (currentVelocity &lt; player.maxVelocity) { player.movingX = movingXNew; player.movingY = movingYNew; } player.thrust = true;
 }else{ player.thrust = false; }
 if (keyPressList[37]==true) { //rotate counterclockwise player.rotation ,= player.rotationalVelocity; }
 if (keyPressList[39]==true) { //rotate clockwise player.rotation += player.rotationalVelocity;; }
 if (keyPressList[32]==true) { //ConsoleLog.log("player.missileFrameCount=" + player.missileFrameCount); //ConsoleLog.log("player.missileFrameDelay=" + player.missileFrameDelay); if (player.missileFrameCount&gt;player.missileFrameDelay){ firePlayerMissile(); player.missileFrameCount = 0;
 } } }
 function update() { updatePlayer(); updatePlayerMissiles(); updateRocks(); updateSaucers(); updateSaucerMissiles(); updateParticles();
 }
 function render() { fillBackground(); renderScoreBoard(); renderPlayerShip(player.x,player.y,player.rotation,1); renderPlayerMissiles(); renderRocks(); renderSaucers(); renderSaucerMissiles(); renderParticles(); }
 function updatePlayer() { player.missileFrameCount++;
 player.x += player.movingX; player.y += player.movingY;
 if (player.x &gt; xMax) { player.x =- player.width; }else if (player.x&lt;-player.width){ player.x = xMax; } if (player.y &gt; yMax) { player.y =- player.height; }else if (player.y&lt;-player.height){ player.y = yMax; }
 }
 function updatePlayerMissiles() { var tempPlayerMissile= {}; var playerMissileLength = playerMissiles.length-1; //ConsoleLog.log("update playerMissileLength=" + playerMissileLength);
 for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){ //ConsoleLog.log("update player missile" + playerMissileCtr) tempPlayerMissile = playerMissiles[playerMissileCtr]; tempPlayerMissile.x += tempPlayerMissile.dx; tempPlayerMissile.y += tempPlayerMissile.dy; if (tempPlayerMissile.x &gt; xMax) { tempPlayerMissile.x =- tempPlayerMissile.width; }else if (tempPlayerMissile.x&lt;-tempPlayerMissile.width){ tempPlayerMissile.x = xMax; }
 if (tempPlayerMissile.y &gt; yMax) { tempPlayerMissile.y =- tempPlayerMissile.height; }else if (tempPlayerMissile.y&lt;-tempPlayerMissile.height){ tempPlayerMissile.y = yMax; }
 tempPlayerMissile.lifeCtr++; if (tempPlayerMissile.lifeCtr &gt; tempPlayerMissile.life){ //ConsoleLog.log("removing player missile"); playerMissiles.splice(playerMissileCtr,1) tempPlayerMissile = null; } }
 } function updateRocks(){
 var tempRock = {}; var rocksLength = rocks.length,1; //ConsoleLog.log("update rocks length=" + rocksLength); for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){ tempRock = rocks[rockCtr] tempRock.x += tempRock.dx; tempRock.y += tempRock.dy; tempRock.rotation += tempRock.rotationInc; //ConsoleLog.log("rock rotationInc="+ tempRock.rotationInc) //ConsoleLog.log("rock rotation="+ tempRock.rotation) if (tempRock.x &gt; xMax) { tempRock.x = xMin-tempRock.width; }else if (tempRock.x&lt;xMin-tempRock.width){ tempRock.x = xMax; }
 if (tempRock.y &gt; yMax) { tempRock.y = yMin-tempRock.width; }else if (tempRock.y&lt;yMin-tempRock.width){ tempRock.y = yMax; }
 //ConsoleLog.log("update rock "+ rockCtr) } }
 function updateSaucers() { //first check to see if we want to add a saucer if (saucers.length&lt; levelSaucerMax){ if (Math.floor(Math.random()*100)&lt;=levelSaucerOccurrenceRate){ //ConsoleLog.log("create saucer") var newSaucer = {};
 newSaucer.width = 28; newSaucer.height = 13; newSaucer.halfHeight = 6.5; newSaucer.halfWidth = 14; newSaucer.scoreValue = saucerScore; newSaucer.fireRate = levelSaucerFireRate; newSaucer.fireDelay = levelSaucerFireDelay; newSaucer.fireDelayCount = 0; newSaucer.missileSpeed = levelSaucerMissileSpeed; newSaucer.dy = (Math.random()*2); if (Math.floor(Math.random)*2==1){ newSaucer.dy*=-1; } //choose betweeen left or right edge to start if (Math.floor(Math.random()*2)==1){ //start on right and go left newSaucer.x = 450; newSaucer.dx=-1*levelSaucerSpeed;
 }else{ //left to right newSaucer.x=-50; newSaucer.dx = levelSaucerSpeed; }
 newSaucer.missileSpeed = levelSaucerMissileSpeed; newSaucer.fireDelay = levelSaucerFireDelay; newSaucer.fireRate = levelSaucerFireRate; newSaucer.y = Math.floor(Math.random()*400);
 saucers.push(newSaucer); } }
 var tempSaucer = {}; var saucerLength = saucers.length-1; //ConsoleLog.log("update rocks length=" + rocksLength); for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr];
 //should saucer fire tempSaucer.fireDelayCount++;
 if (Math.floor(Math.random()*100) &lt;=tempSaucer.fireRate &amp;&amp; tempSaucer.fireDelayCount&gt;tempSaucer.fireDelay ){ fireSaucerMissile(tempSaucer) tempSaucer.fireDelayCount= 0; }
 var remove = false; tempSaucer.x += tempSaucer.dx; tempSaucer.y += tempSaucer.dy;
 //remove saucers on left and right edges if (tempSaucer.dx &gt; 0 &amp;&amp; tempSaucer.x &gt;xMax){ remove = true; }else if (tempSaucer.dx &lt;0 &amp;&amp;tempSaucer.x&lt;xMin-tempSaucer.width){ remove = true; }
 //bounce saucers off over vertical edges if (tempSaucer.y &gt; yMax || tempSaucer.y&lt;yMin-tempSaucer.width) { tempSaucer.dy*=-1 } if (remove==true) { //remove the saucer ConsoleLog.log("saucer removed") saucers.splice(saucerCtr,1); tempSaucer = null; }
 }
 }
 function updateSaucerMissiles() { var tempSaucerMissile = {}; var saucerMissileLength = saucerMissiles.length-1; for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){
 //ConsoleLog.log("update player missile" + playerMissileCtr) tempSaucerMissile = saucerMissiles[saucerMissileCtr]; tempSaucerMissile.x += tempSaucerMissile.dx; tempSaucerMissile.y += tempSaucerMissile.dy; if (tempSaucerMissile.x &gt; xMax) { tempSaucerMissile.x=-tempSaucerMissile.width; }else if (tempSaucerMissile.x&lt;-tempSaucerMissile.width){ tempSaucerMissile.x = xMax; }
 if (tempSaucerMissile.y &gt; yMax) { tempSaucerMissile.y=-tempSaucerMissile.height; }else if (tempSaucerMissile.y&lt;-tempSaucerMissile.height){ tempSaucerMissile.y = yMax; }
 tempSaucerMissile.lifeCtr++; if (tempSaucerMissile.lifeCtr &gt; tempSaucerMissile.life){ //remove saucerMissiles.splice(saucerMissileCtr,1) tempSaucerMissile = null; } } }
 function updateParticles() { var tempParticle = {}; var particleLength = particles.length-1; //ConsoleLog.log("particle=" + particleLength) for (var particleCtr=particleLength;particleCtr&gt;=0;particleCtr--){ var remove = false; tempParticle = particles[particleCtr]; tempParticle.x += tempParticle.dx; tempParticle.y += tempParticle.dy;
 tempParticle.lifeCtr++; //ConsoleLog.log("particle.lifeCtr=" + tempParticle.lifeCtr);
 //try{ if (tempParticle.lifeCtr &gt; tempParticle.life){ remove = true; } else if ((tempParticle.x &gt; xMax) || (tempParticle.x&lt;xMin) || (tempParticle.y &gt; yMax) || (tempParticle.y&lt;yMin)){
 remove = true;
 } //} //catch(err) { // ConsoleLog.log ("error in particle"); // ConsoleLog.log("particle:" + particleCtr);
 //} if (remove) { particles.splice(particleCtr,1) tempParticle = null; }
 }
 }
 function renderPlayerShip(x,y,rotation, scale) { //transformation var angleInRadians = rotation * Math.PI / 180; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity //translate the canvas origin to the center of the player context.translate(x+player.halfWidth,y+player.halfHeight); context.rotate(angleInRadians); context.scale(scale,scale);
 //drawShip context.strokeStyle = '#ffffff'; context.beginPath();
 //hardcoding in locations //facing right context.moveTo(-10,-10); context.lineTo(10,0); context.moveTo(10,1); context.lineTo(-10,10); context.lineTo(1,1); context.moveTo(1,-1); context.lineTo(-10,-10);
 if (player.thrust==true &amp;&amp; scale==1) { //check for scale==1 for ship indicator does not display with thrust context.moveTo(-4,-2); context.lineTo(-4,1); context.moveTo(-5,-1); context.lineTo(-10,-1); context.moveTo(-5,0); context.lineTo(-10,0); } context.stroke(); context.closePath(); //restore context context.restore(); //pop old state on to screen
 }
 function renderPlayerMissiles() { var tempPlayerMissile = {}; var playerMissileLength = playerMissiles.length-1; //ConsoleLog.log("render playerMissileLength=" + playerMissileLength);
 for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempPlayerMissile = playerMissiles[playerMissileCtr]; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(tempPlayerMissile.x+1,tempPlayerMissile.y+1); context.strokeStyle = '#ffffff';
 context.beginPath();
 //draw everything offset by 1/2. 

Zero Relative 1/2 is 15 context.moveTo(-1,-1); context.lineTo(1,-1); context.lineTo(1,1); context.lineTo(-1,1); context.lineTo(-1,-1); context.stroke(); context.closePath(); context.restore(); //pop old state on to screen }
 }
 function renderRocks() { var tempRock = {}; var rocksLength = rocks.length-1; for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){
 tempRock = rocks[rockCtr]; var angleInRadians = tempRock.rotation * Math.PI / 180; //ConsoleLog.log("render rock rotation"+(tempRock.rotation)); context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity //translate the canvas origin to the center of the player context.translate(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight);
 //ConsoleLog.log("render rock x"+(tempRock.x+tempRock.halfWidth)); //ConsoleLog.log("render rock y"+(tempRock.y+tempRock.halfHeight)); context.rotate(angleInRadians); context.strokeStyle = '#ffffff';
 context.beginPath();
 //draw everything offset by 1/2. 

//Zero Relative 1/2 is if .5*width -1. 
Same for height context.moveTo(-(tempRock.halfWidth-1),-(tempRock.halfHeight-1)); context.lineTo((tempRock.halfWidth-1),-(tempRock.halfHeight-1)); context.lineTo((tempRock.halfWidth-1),(tempRock.halfHeight-1)); context.lineTo(-(tempRock.halfWidth-1),(tempRock.halfHeight-1)); context.lineTo(-(tempRock.halfWidth-1),-(tempRock.halfHeight-1));
 context.stroke(); context.closePath(); context.restore(); //pop old state on to screen }
 }
 function renderSaucers() { var tempSaucer = {}; var saucerLength = saucers.length-1; for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ //ConsoleLog.log("saucer: " + saucerCtr); tempSaucer = saucers[saucerCtr];
 context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity //translate the canvas origin to the center of the player //context.translate(this.x+halfWidth,this.y+halfHeight); context.translate(tempSaucer.x,tempSaucer.y); context.strokeStyle = '#ffffff';
 context.beginPath();
 //did not move to middle because it is drawn in exact space context.moveTo(4,0); context.lineTo(9,0); context.lineTo(12,3); context.lineTo(13,3); context.moveTo(13,4); context.lineTo(10,7); context.lineTo(3,7); context.lineTo(1,5); context.lineTo(12,5); context.moveTo(0,4); context.lineTo(0,3); context.lineTo(13,3); context.moveTo(5,1); context.lineTo(5,2); context.moveTo(8,1); context.lineTo(8,2); context.moveTo(2,2); context.lineTo(4,0); context.stroke(); context.closePath(); context.restore(); //pop old state on to screen }
 }
 function renderSaucerMissiles() { var tempSaucerMissile = {}; var saucerMissileLength = saucerMissiles.length-1; //ConsoleLog.log("saucerMissiles= " + saucerMissiles.length)
 for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempSaucerMissile = saucerMissiles[saucerMissileCtr]; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(tempSaucerMissile.x+1,tempSaucerMissile.y+1); context.strokeStyle = '#ffffff';
 context.beginPath();
 //draw everything offset by 1/2. 

Zero Relative 1/2 is 15 context.moveTo(-1,-1); context.lineTo(1,-1); context.lineTo(1,1); context.lineTo(-1,1); context.lineTo(-1,-1); context.stroke(); context.closePath(); context.restore(); //pop old state on to screen
 }
 }
 function renderParticles() { var tempParticle = {}; var particleLength = particles.length-1; for (var particleCtr=particleLength;particleCtr&gt;=0;particleCtr--){ tempParticle = particles[particleCtr]; context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(tempParticle.x,tempParticle.y); context.strokeStyle = '#ffffff';
 context.beginPath();
 //draw everything offset by 1/2. 

Zero Relative 1/2 is 15 context.moveTo(0,0); context.lineTo(1,1); context.stroke(); context.closePath(); context.restore(); //pop old state on to screen
 }
 }
 function checkCollisions() { //loop through rocks then missiles. 
There will always be rocks and a ship, //but there will not always be missiles.
 var tempRock = {}; var rocksLength = rocks.length-1; var tempPlayerMissile = {}; var playerMissileLength = playerMissiles.length-1; var saucerLength = saucers.length-1; var tempSaucer = {}; var saucerMissileLength = saucerMissiles.length-1;
 rocks: for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){ tempRock = rocks[rockCtr]; missiles:for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){
 tempPlayerMissile = playerMissiles[playerMissileCtr];
 if (boundingBoxCollide(tempRock,tempPlayerMissile)){ //ConsoleLog.log("hit rock");
 createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); } addToScore(tempRock.scoreValue); playerMissiles.splice(playerMissileCtr,1); tempPlayerMissile = null;
 rocks.splice(rockCtr,1); tempRock = null;
 break rocks; break missiles; } }
 saucers:for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr]; if (boundingBoxCollide(tempRock,tempSaucer)){ //ConsoleLog.log("hit rock"); createExplode(tempSaucer.x+tempSaucer.halfWidth, tempSaucer.y+tempSaucer.halfHeight,10);
 createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10);
 if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); }
 saucers.splice(saucerCtr,1); tempSaucer = null; rocks.splice(rockCtr,1); tempRock = null;
 break rocks; break saucers; } } //saucer missiles against rocks //this is done here so we don't have to loop //through rocks again as it would probably //be the biggest array saucerMissiles:for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){
 tempSaucerMissile = saucerMissiles[saucerMissileCtr]; if (boundingBoxCollide(tempRock,tempSaucerMissile)){ //ConsoleLog.log("hit rock");
 createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); }
 saucerMissiles.splice(saucerCtr,1); tempSaucerMissile = null;
 rocks.splice(rockCtr,1); tempRock = null; break rocks; break saucerMissiles; } }
 //check player aginst rocks if (boundingBoxCollide(tempRock,player)){ //ConsoleLog.log("hit player"); createExplode(tempRock.x+tempRock.halfWidth,tempRock.halfHeight,10); addToScore(tempRock.scoreValue); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); } rocks.splice(rockCtr,1); tempRock = null;
 playerDie(); } } //now check player against saucers and then saucers against player missiles //and finally player against saucer missiles playerMissileLength = playerMissiles.length-1; saucerLength = saucers.length-1; saucers:for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr];
 missiles:for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){
 tempPlayerMissile = playerMissiles[playerMissileCtr]; if (boundingBoxCollide(tempSaucer,tempPlayerMissile)){ //ConsoleLog.log("hit rock");
 createExplode(tempSaucer.x+tempSaucer.halfWidth, tempSaucer.y+tempSaucer.halfHeight,10);
 addToScore(tempSaucer.scoreValue);
 playerMissiles.splice(playerMissileCtr,1); tempPlayerMissile = null; saucers.splice(saucerCtr,1); tempSaucer = null;
 break saucers; break missiles; } }
 //player against saucers if (boundingBoxCollide(tempSaucer,player)){ ConsoleLog.log("hit player"); createExplode(tempSaucer.x+16,tempSaucer.y+16,10); addToScore(tempSaucer.scoreValue);
 saucers.splice(rockCtr,1); tempSaucer = null; playerDie(); } }
 //saucerMissiles against player saucerMissileLength = saucerMissiles.length-1;
 saucerMissiles:for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){
 tempSaucerMissile = saucerMissiles[saucerMissileCtr]; if (boundingBoxCollide(player,tempSaucerMissile)){ ConsoleLog.log("saucer missile hit player");
 playerDie(); saucerMissiles.splice(saucerCtr,1); tempSaucerMissile = null;
 break saucerMissiles; } }
 } function firePlayerMissile(){ //ConsoleLog.log("fire playerMissile"); var newPlayerMissile = {}; newPlayerMissile.dx = 5*Math.cos(Math.PI*(player.rotation)/180); newPlayerMissile.dy = 5*Math.sin(Math.PI*(player.rotation)/180); newPlayerMissile.x = player.x+player.halfWidth; newPlayerMissile.y = player.y+player.halfHeight; newPlayerMissile.life = 60; newPlayerMissile.lifeCtr = 0; newPlayerMissile.width = 2; newPlayerMissile.height = 2; playerMissiles.push(newPlayerMissile);
 }
 function fireSaucerMissile(saucer) { var newSaucerMissile = {}; newSaucerMissile.x = saucer.x+.5*saucer.width; newSaucerMissile.y = saucer.y+.5*saucer.height;
 newSaucerMissile.width = 2; newSaucerMissile.height = 2; newSaucerMissile.speed = saucer.missileSpeed; //ConsoleLog.log("saucer fire"); //fire at player from small saucer var diffx = player.x-saucer.x; var diffy = player.y-saucer.y; var radians = Math.atan2(diffy, diffx); var degrees = 360 * radians / (2 * Math.PI); newSaucerMissile.dx = saucer.missileSpeed*Math.cos(Math.PI*(degrees)/180); newSaucerMissile.dy = saucer.missileSpeed*Math.sin(Math.PI*(degrees)/180); newSaucerMissile.life = 160; newSaucerMissile.lifeCtr = 0; saucerMissiles.push(newSaucerMissile);
 }
 function playerDie() { ConsoleLog.log("player die"); createExplode(player.x+player.halfWidth, player.y+player.halfWidth,50); switchGameState(GAME_STATE_PLAYER_DIE);
 } function createExplode(x,y,num) { //create 10 particles for (var partCtr=0;partCtr&lt;num;partCtr++){ var newParticle = new Object(); newParticle.dx = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dx*=-1; } newParticle.dy = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dy*=-1; }
 newParticle.life = Math.floor(Math.random()*30+30); newParticle.lifeCtr = 0; newParticle.x = x; newParticle.y = y; //ConsoleLog.log("newParticle.life=" + newParticle.life); particles.push(newParticle); }
 }
 function boundingBoxCollide(object1, object2) { var left1 = object1.x; var left2 = object2.x; var right1 = object1.x + object1.width; var right2 = object2.x + object2.width; var top1 = object1.y; var top2 = object2.y; var bottom1 = object1.y + object1.height; var bottom2 = object2.y + object2.height;
 if (bottom1 &lt; top2) return(false); if (top1 &gt; bottom2) return(false);
 if (right1 &lt; left2) return(false); if (left1 &gt; right2) return(false);
 return(true); };
 function splitRock(scale,x,y){ for (var newRockctr=0;newRockctr&lt;2;newRockctr++){ var newRock = {}; //ConsoleLog.log("split rock");
 if (scale==2){ newRock.scoreValue = medRockScore; newRock.width = 25; newRock.height = 25; newRock.halfWidth = 12.5; newRock.halfHeight = 12.5;
 }else { newRock.scoreValue = smlRockScore; newRock.width = 16; newRock.height = 16; newRock.halfWidth = 8; newRock.halfHeight = 8; } newRock.scale = scale; newRock.x = x; newRock.y = y; newRock.dx = Math.random()*3; if (Math.random()&lt;.5){ newRock.dx*=-1; } newRock.dy = Math.random()*3; if (Math.random()&lt;.5){ newRock.dy*=-1; } newRock.rotationInc = (Math.random()*5)+1; if (Math.random()&lt;.5){ newRock.rotationInc*=-1; } newRock.rotation = 0; ConsoleLog.log("new rock scale"+(newRock.scale)); rocks.push(newRock);
 }
 }
 function addToScore(value){ score+=value; }
 document.onkeydown = function(e){
 e = e?e:window.event; //ConsoleLog.log(e.keyCode + "down"); keyPressList[e.keyCode] = true;
 } document.onkeyup = function(e){
 //document.body.onkeyup = function(e){ e = e?e:window.event; //ConsoleLog.log(e.keyCode + "up"); keyPressList[e.keyCode] = false;
 };
 //*** application start switchGameState(GAME_STATE_TITLE);
 frameRateCounter = new FrameRateCounter();
 //**** application loop const FRAME_RATE = 40; var intervalTime = 1000/FRAME_RATE;
 setInterval(runGame, intervalTime );
}
//***** object prototypes *****

//*** consoleLog util object
//create constructor
function ConsoleLog(){
}

//create function that will be added to the class
console_log = function(message) {
 if(typeof(console) !== 'undefined' &amp;&amp; console != null) { console.log(message);
 }

}
//add class/static function to class by assignment
ConsoleLog.log = console_log;
//*** end console log object

//*** FrameRateCounter object prototype
function FrameRateCounter() {
 this.lastFrameCount = 0;
 var dateTemp = new Date(); this.frameLast = dateTemp.getTime();
 delete dateTemp;
 this.frameCtr = 0;
}

FrameRateCounter.prototype.countFrames = function() {
 var dateTemp = new Date();
 this.frameCtr++;
 if (dateTemp.getTime() &gt;=this.frameLast+1000) { ConsoleLog.log("frame event"); this.lastFrameCount = this.frameCtr; this.frameLast = dateTemp.getTime(); this.frameCtr = 0; }
 delete dateTemp;
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="400" height="400"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
Figure 8-7 shows a screenshot of the game in action.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893819.png" alt="Geo Blaster Basic in action" width="398" height="398">

Figure 8-7. 
Geo Blaster Basic in action
<h2>Rock Object Prototype</h2>
To conserve space, we did not create separate object prototypes for the various display objects in this game. 

However, Example 8-13</a> is a Rock prototype object that can be used in a game such as <em>Geo Blaster Basic</em>.
Example 8-13. 
The Rock.js prototype
//*** Rock Object Prototype

function Rock(scale, type) {
 //scale
 //1 = large
 //2 = medium //3 = small
 //these will be used as the divisor for the new size
 //50/1 = 50
 //50/2 = 25 //50/3 = 16
 this.scale = scale;
 if (this.scale &lt;1 || this.scale &gt;3){ this.scale=1;
 } this.type = type;
 this.dx = 0;
 this.dy = 0;
 this.x = 0; this.y = 0;
 this.rotation = 0;
 this.rotationInc = 0;
 this.scoreValue = 0; //ConsoleLog.log("create rock. 
Scale=" + this.scale);
 switch(this.scale){
 case 1: this.width = 50; this.height = 50; break; case 2: this.width = 25; this.height = 25; break; case 3: this.width = 16; this.height = 16; break; }
}
Rock.prototype.update = function(xmin,xmax,ymin,ymax) {
 this.x += this.dx; this.y += this.dy;
 this.rotation += this.rotationInc;
 if (this.x &gt; xmax) { this.x = xmin-this.width;
 }else if (this.x&lt;xmin-this.width){ this.x = xmax; }
 if (this.y &gt; ymax) { this.y = ymin-this.width;
 }else if (this.y&lt;ymin-this.width){ this.y = ymax;
 }

}
Rock.prototype.draw = function(context) {
 var angleInRadians = this.rotation * Math.PI / 180;
 var halfWidth = Math.floor(this.width*.5); //used to find center of object var halfHeight = Math.floor(this.height*.5)// used to find center of object context.save(); //save current state in stack context.setTransform(1,0,0,1,0,0); // reset to identity
 //translate the canvas origin to the center of the player context.translate(this.x+halfWidth,this.y+halfHeight);
 context.rotate(angleInRadians);
 context.strokeStyle = '#ffffff';
 context.beginPath(); //draw everything offset by 1/2. 
Zero Relative 1/2 is if .5*width -1. 
Same for height context.moveTo(-(halfWidth-1),-(halfHeight-1)); context.lineTo((halfWidth-1),-(halfHeight-1));
 context.lineTo((halfWidth-1),(halfHeight-1));
 context.lineTo(-(halfWidth-1),(halfHeight-1));
 context.lineTo(-(halfWidth-1),-(halfHeight-1)); context.stroke();
 context.closePath();
 context.restore(); //pop old state on to screen
}

//*** end Rock Class
<h2>What’s Next</h2>
We covered quite a bit in this chapter. 
HTML5 Canvas might lack some of the more refined features common to web game development platforms such as Flash, but it contains powerful tools for manipulating the screen in immediate mode. 

These features allow us to create a game application with many individual logical display objects—even though each canvas can support only a single physical display object (the canvas itself).
In Chapter 9 we will explore some more advanced game topics, such as replacing paths with bitmap images, creating object pools, and adding a sound manager. 
We’ll extend the game we built in this chapter and create a new turn-based strategy game. 9. 
Combining Bitmaps and Sound" epub:type="chapter">
<h2><span class="orange">Chapter 9. Combining Bitmaps and Sound</span></h2>
<em>Geo Blaster Basic</em> was constructed using pure paths for drawing. 
In its creation, we began to cover some game-application-related topics, such as basic collision detection and state machines. 
In this chapter, we will focus on using bitmaps and tile sheets for our game graphics, and we will also add sound using techniques introduced in Chapter 7.
Along the way, we will update the <code>FrameRateCounter</code> from Chapter 8 by adding in a “step timer.” We will also examine how we can eliminate the use of a tile sheet for rotations by precreating an array of <code>imageData</code>
 instances using the <code>getImageData()</code> and
 <code>putImageData()</code> Canvas functions.
In the second half of this chapter, we will create another small turn-based strategy game using bitmaps. 
This game will be roughly based on the classic computer game <em>Daleks</em>.
<h2>Geo Blaster Extended</h2>
We will create a new game, <em>Geo Blaster Extended</em>, by adding bitmaps and sound to the <em>Geo Blaster Basic</em> game from Chapter 8. 
Much of the game logic will be the same, but adding bitmaps to replace paths will enable us to optimize the game for rendering. 
Optimized rendering is very important when you are targeting limited-processor devices, such as mobile phones. 

We will also add sound to <em>Geo Blaster Extended</em>, and apply an object pool to the particles used for game explosions. 
Figure 9-1 shows an example screen of the finished game.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893821.png.jpg" alt="Geo Blaster Extended" width="400" height="400">

Figure 9-1. 
Geo Blaster Extended
First, let’s look at the tile sheets we will use for our new game.
<h3>Geo Blaster Tile Sheet</h3>

In Chapter 4, we examined applying bitmap graphics to the canvas, and we explored using tile sheet methods to render images. 
In Chapter 8, we drew all our game graphics as paths and transformed them on the fly. 

In this chapter, we will apply the concepts from Chapter 4 to optimizing the rendering of the <em>Geo Blaster Basic</em> game. 
We will do this by prerendering all of our game graphics and transformations as bitmaps. 
We will then use these bitmaps instead of paths and the immediate-mode transformations that were necessary in Chapter 8 to create <em>Geo Blaster Extended</em>.
Figure 9-2</a> shows one of the tile sheets we will use for this game (<em>ship_tiles.png</em>).
These tiles are the 36 rotations for our player ship. 

We are “canning” the rotations in a tile sheet to avoid spending processor cycles transforming them on each frame tick as we draw them to the canvas.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893823.png.jpg" alt="The ship_tiles.png tile sheet" width="320" height="128">
Figure 9-2. 
The ship_tiles.png tile sheet

Figure 9-3 shows a second set of tiles for the ship with the “thruster” firing (<em>ship_tiles2.png</em>). 
We will use this set to depict the ship when the user is pressing the up arrow key.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893825.png.jpg" alt="The ship_tiles2.png tile sheet" width="320" height="128">

Figure 9-3. 
The ship_tiles2.png tile sheet
The next three sets of tiles are for the rocks that the player will destroy. 
We have three sheets for these: <em>largerocks.png</em> (<a href="ch09.html#the_largerocks.png_tile_sheet" title="Figure 9-4. 

The largerocks.png tile sheet">Figure 9-4</a>), <em>mediumrocks.png</em> (<a href="ch09.html#the_mediumrocks.png_tile_sheet" title="Figure 9-5. 
The mediumrocks.png tile sheet">Figure 9-5</a>), and <em>smallrocks.png</em> (<a href="ch09.html#the_smallrocks.png_tile_sheet" title="Figure 9-6. 
The smallrocks.png tile sheet">Figure 9-6</a>).
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893827.png.jpg" alt="The largerocks.png tile sheet" width="320" height="64">

Figure 9-4. 
The largerocks.png tile sheet
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893829.png.jpg" alt="The mediumrocks.png tile sheet" width="160" height="32">
Figure 9-5. 

The mediumrocks.png tile sheet
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893831.png.jpg" alt="The smallrocks.png tile sheet" width="120" height="24">
Figure 9-6. 
The smallrocks.png tile sheet

These three tile sheets only need to be five tiles each. 
Since the rock is a square, we can simply repeat the five frames to simulate rotation in either the clockwise or counterclockwise direction.
The saucer that attempts to shoot the player is a single tile, <em>saucer.png</em>, shown in <a href="ch09.html#the_saucer.png_tile_sheet" title="Figure 9-7. 
The saucer.png tile">Figure 9-7</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893833.png" alt="The saucer.png tile" width="30" height="15">
Figure 9-7. 
The saucer.png tile
Finally, <em>parts.png</em> (<a href="ch09.html#the_parts.png_tile_sheet" title="Figure 9-8. 

The parts.png tile sheet">Figure 9-8</a>), is a tiny 8×2 tile sheet that contains four 2×2 “particle” tiles. 
These will be used for the explosions and missiles fired by the player and the saucer.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893835.png" alt="The parts.png tile sheet" width="8" height="2">
Figure 9-8. 

The parts.png tile sheet
You cannot see the colors in a black-and-white printed book, but you can view them by downloading the files from this book’s website. 
The first tile is green, and it will be used for the small rock and saucer explosions. 
The second tile is light blue, and it will depict the player’s missiles and the player explosion. 

The third tile is reddish pink (salmon, if you will), and it will illustrate the large rock explosions. 
The final, purple tile will be used for the medium rock explosions.
Now that we have our tiles in place, let’s look at the methods we will use to transform <em>Geo Blaster Basic</em>’s immediate-mode path, rendering it to <em>Geo Blaster Extended</em>’s tile-based bitmap.
<h4>Refresher: Calculating the tile source location</h4>

In <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, we examined the method to calculate a tile’s location on a tile sheet if we know the single-dimension id of that tile. 
Let’s briefly look back at this, as it will be reused to render all the tiles for the games in this chapter.
Given that we have a tile sheet such as <em>ship_tiles.png</em>, we can locate the tile we want to display with a simple math trick.

<em>ship_tiles.png</em> is a 36-tile animation with the player ship starting in the 0-degree angle, or “pointing right” direction. 
Each of the remaining 35 tiles displays the ship rotating in 10-degree increments.
If we would like to display tile 19 (the ship pointing to the left, or in the 190-degree angle), we first need to find the <code>x</code> and <code>y</code> coordinates for the top-left corner of the tile, by calculating <code>sourceX</code> and <code>sourceY</code>.
Here is pseudocode for the <code>sourceX</code> calculation:

sourceX = integer(current_frame_index modulo
the_number_columns_in_the_tilesheet) * tile_width
The modulo (%) operator will return the remainder of the division calculation. 
Below is the actual code (with variables replaced with literals) we will use for this calculation:

var sourceX = Math.floor(19 % 10) *32;
The result is <code>x = 9*32 = 288;</code>.
The calculation for the <code>sourceY</code> value is similar except we divide rather than use the modulo operator:
sourceY = integer(current_frame_index divided by

the_number_columns_in_the_tilesheet) *tile_height
Here’s the actual code we will use for this calculation:
var sourceY = Math.floor(19 / 10) *32;
This works out to <code>y = 1*32 = 32;</code>. 

So, the top-left location on the <em>ship_tiles.png</em> from which to start copying pixels is <code>288</code>,<code>32</code>.
To actually copy this to the canvas, we will use this statement:
context.drawImage(shipTiles, sourceX, sourceY,32,32,player.x,player.y,32,32);
In <a href="ch08.html" title="Chapter 8. 

Canvas Game Essentials">Chapter 8</a>, we needed quite a lot of code to draw and translate the player ship at the current rotation. 
When we use a tile sheet, this code is reduced considerably.
Here is the code we will use to render the player ship. 
It will replace the <code>renderPlayer()</code> function in Example 8-12</a> in <a href="ch08.html" title="Chapter 8. 

Canvas Game Essentials">Chapter 8</a>:
function renderPlayerShip(x,y,rotation, scale) { //transformation context.save(); //save current state in stack context.globalAlpha = parseFloat(player.alpha); var angleInRadians = rotation * Math.PI / 180; var sourceX = Math.floor((player.rotation/10) % 10) * 32; var sourceY = Math.floor((player.rotation/10) /10) *32; if (player.thrust){ context.drawImage(shipTiles2, sourceX, sourceY, 32, 32, player.x,player.y,32,32); }else{ context.drawImage(shipTiles, sourceX, sourceY, 32, 32, player.x,player.y,32,32); }
 //restore context context.restore(); //pop old state on to screen context.globalAlpha = 1; }
<h3>Note</h3>
You will find the entire source code for <em>Geo Blaster Extended</em> (Example 9-1</a>) later, in Geo Blaster Extended Full Source</a>.
The <code>renderPlayer()</code> function divides the <code>player.rotation</code> by <code>10</code> to determine which of the 36 tiles in the <code>shipTiles</code> image instance to display on the canvas. 

If the player is in “thrust” mode, the <code>shipTiles2</code> image is used instead of <code>shipTiles</code>.
This works because we have set the ship to rotate by <code>10</code> degrees with each press of the left or right arrow key. 
In <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a>’s version of the game, we set this to <code>5</code> degrees. 

If we had created a 72-frame tile sheet, with the player ship rotated in 5-degree increments, we could have kept the <code>player.rotationalVelocity</code> at 5. 
For <em>Geo Blaster Extended</em>, we only drew 36 tiles for the player ship, so we are using the value <code>10</code> for the rotational velocity. 
There certainly is no reason why we could not use 72 or even 360 frames for the player ship rotation tiles. 
This is only limited by creative imagination (and patience with a drawing tool).

Let’s look at the <code>rotationalVelocity</code> value assigned earlier in the <code>gameStateNewGame()</code> function:
function gameStateNewGame(){
 ConsoleLog.log("gameStateNewGame")
 //setup new game level = 0;
 score = 0;
 playerShips = 3;
 player.maxVelocity = 5; player.width = 32;
 player.height = 32;
 player.halfWidth = 16;
 player.halfHeight = 16; player.hitWidth = 24;
 player.hitHeight = 24;
 player.rotationalVelocity = 10; //how many degrees to turn the ship player.thrustAcceleration = .05; player.missileFrameDelay = 5;
 player.thrust = false;
 player.alpha = 1;
 player.rotation = 0; player.x = 0;
 player.y = 0;
 fillBackground();
 renderScoreBoard(); switchGameState(GAME_STATE_NEW_LEVEL)
}
<h4>Other new player attributes</h4>
Along with the change in the rotational velocity, we have also modified the player’s <code>width</code> and <code>height</code> attributes. 

These are both now <code>32</code>, which is the same as the tile width and height. 
If you look at the first frame of the <em>ship_tiles.png</em> tile sheet, you will see that the player ship does not fill the entire 32×32 tile. 
It is centered in the middle, taking up roughly 24×24 of the tile, which leaves enough space around the edges of the tile to eliminate clipping when the ship is rotated. 
We also used this concept when we created the rock rotations.

The extra pixels of padding added to eliminate clipping during frame rotation poses a small problem for collision detection. 
In the <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a> version of the game, we used the <code>width</code> and <code>height</code> values for bounding box collision detection. 
We will not use those values in this new version because we have created two new variables to use for collision detection: <code>hitWidth</code> and <code>hitHeight</code>. 

Instead of setting these values to <code>32</code>, they are <code>24</code>. 
This new smaller value makes our collision detection more accurate than if we used the entire tile width and height.
<h4>The new boundingBoxCollide() algorithm</h4>
All the other game objects will also have new <code>hitWidth</code> and <code>hitHeight</code> attributes. 

We will modify the <code>boundingBoxCollide()</code> function from <em>Geo Blaster Basic</em> to use these new values for all collision testing:
function boundingBoxCollide(object1, object2) {
 var left1 = object1.x;
 var left2 = object2.x; var right1 = object1.x + object1.hitWidth;
 var right2 = object2.x + object2.hitWidth;
 var top1 = object1.y;
 var top2 = object2.y; var bottom1 = object1.y + object1.hitHeight;
 var bottom2 = object2.y + object2.hitHeight;
 if (bottom1 &lt; top2) return(false);
 if (top1 &gt; bottom2) return(false); if (right1 &lt; left2) return(false);
 if (left1 &gt; right2) return(false);
 return(true);
 }

Next, we will take a quick look at how we will use these same ideas to render the rest of the game objects with the new tile sheets.
<h3>Rendering the Other Game Objects</h3>
The rocks, saucers, missiles, and particles will all be rendered in a manner similar to the method implemented for the player ship. 
Let’s first look at the code for the saucer’s render function.

<h4>Rendering the saucers</h4>
The saucers do not have a multiple-cell tile sheet, but to be consistent, we will render them as though they do. 
This will allow us to add more animation tiles for the saucers later:
function renderSaucers() { var tempSaucer = {};
 var saucerLength = saucers.length-1;
 for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ //ConsoleLog.log("saucer: " + saucerCtr); tempSaucer = saucers[saucerCtr];
 context.save(); //save current state in stack var sourceX = 0; var sourceY = 0; context.drawImage(saucerTiles, sourceX, sourceY, 30, 15, tempSaucer.x,tempSaucer.y,30,15); context.restore(); //pop old state on to screen }
}
There is no need to actually calculate the <code>sourceX</code> and <code>sourceY</code> values for the saucer because the saucer is only a single tile. 
In this instance, we can just set them to <code>0</code>. 

We have hardcoded the <code>saucer.width (30)</code> and <code>saucer.height (15)</code> as an example, but with all the rest of the game objects, we will use the object <code>width</code> and <code>height</code> attributes rather than literals.
Next, let’s look at the rock rendering, which varies slightly from both the player ship and the saucers.
<h4>Rendering the rocks</h4>
The rock tiles are contained inside three separate tile sheets based on their size (large, medium, and small), and we have used only five tiles for each rock. 

The rocks are square with a symmetrical pattern, so we only need to precreate a single quarter-turn rotation for each of the three sizes.
Here is the <code>renderRocks()</code> function. 
Notice that we must “switch” based on the scale of the rock (1=large, 2=medium, 3=small) to choose the right tile sheet to render:
function renderRocks() { var tempRock = {}; var rocksLength = rocks.length-1; for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){ context.save(); //save current state in stack tempRock = rocks[rockCtr]; var sourceX = Math.floor((tempRock.rotation) % 5) * tempRock.width; var sourceY = Math.floor((tempRock.rotation) /5) *tempRock.height; switch(tempRock.scale){ case 1: context.drawImage(largeRockTiles, sourceX, sourceY, tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break; case 2: context.drawImage(mediumRockTiles, sourceX, sourceY,tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break; case 3: context.drawImage(smallRockTiles, sourceX, sourceY,tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break;
 }
 context.restore(); //pop old state on to screen
 } }
In the <code>renderRocks()</code> function, we are no longer using the <code>rock.rotation</code> attribute as the angle of rotation as we did in <em>Geo Blaster Basic</em>. 
Instead, we have repurposed the <code>rotation</code> attribute to represent the tile id (0–4) of the current tile on the tile sheet to render.
In the <a href="ch08.html" title="Chapter 8. 

Canvas Game Essentials">Chapter 8</a> version, we were able to simulate faster or slower speeds for the rock rotations by simply giving each rock a random <code>rotationInc</code> value. 
This value, either negative for counterclockwise or positive for clockwise, was added to the <code>rotation</code> attribute on each frame. 
In this new tilesheet-based version, we only have five frames of animation, so we don’t want to skip frames because it will look choppy. 
Instead, we are going to add two new attributes to each rock: <code>animationCount</code> and <code>animationDelay</code>.

The <code>animationDelay</code> will represent the number of frames between each tile change for a given rock. 
The <code>animationCount</code> variable will restart at <code>0</code> after each tile frame change and will increase by <code>1</code> on each subsequent frame tick. 
When <code>animationCount</code> is greater than <code>animationDelay</code>, the <code>rock.rotation</code> value will be increased (clockwise) or decreased (counterclockwise). 
Here is the new code that we will have in our <code>updateRocks()</code> function:

tempRock.animationCount++;
 if (tempRock.animationCount &gt; tempRock.animationDelay){ tempRock.animationCount = 0; tempRock.rotation += tempRock.rotationInc;
 if (tempRock.rotation &gt; 4){ tempRock.rotation = 0; }else if (tempRock.rotation &lt;0){ tempRock.rotation = 4; }
 }

You will notice that we have hardcoded the values <code>4</code> and <code>0</code> into the tile id maximum and minimum checks. 
We could have just as easily used a constant or two variables for this purpose.
<h4>Rendering the missiles</h4>
Both the player missiles and saucer missiles are rendered in the same manner. 

For each, we simply need to know the tile id on the four-tile <code>particleTiles</code> image representing the tile we want to display. 
For the player missiles, this tile id is <code>1</code>; for the saucer missile, the tile id is <code>0</code>.
Let’s take a quick look at both of these functions:
 function renderPlayerMissiles() { var tempPlayerMissile = {}; var playerMissileLength = playerMissiles.length-1; //ConsoleLog.log("render playerMissileLength=" + playerMissileLength); for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0; playerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempPlayerMissile = playerMissiles[playerMissileCtr]; context.save(); //save current state in stack var sourceX = Math.floor(1 % 4) * tempPlayerMissile.width; var sourceY = Math.floor(1 / 4) * tempPlayerMissile.height;
 context.drawImage(particleTiles, sourceX, sourceY, tempPlayerMissile.width,tempPlayerMissile.height, tempPlayerMissile.x,tempPlayerMissile.y,tempPlayerMissile.width, tempPlayerMissile.height);
 context.restore(); //pop old state on to screen } }
function renderSaucerMissiles() { var tempSaucerMissile = {}; var saucerMissileLength = saucerMissiles.length-1; //ConsoleLog.log("saucerMissiles= " + saucerMissiles.length) for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr &gt;= 0;saucerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempSaucerMissile = saucerMissiles[saucerMissileCtr]; context.save(); //save current state in stack var sourceX = Math.floor(0 % 4) * tempSaucerMissile.width; var sourceY = Math.floor(0 / 4) * tempSaucerMissile.height; context.drawImage(particleTiles, sourceX, sourceY, tempSaucerMissile.width,tempSaucerMissile.height, tempSaucerMissile.x,tempSaucerMissile.y,tempSaucerMissile.width, tempSaucerMissile.height);
 context.restore(); //pop old state on to screen
 } }
The particle explosion will also be rendered using a bitmap tile sheet, and its code will be very similar to the code for the projectiles. 

Let’s examine the particles next.
<h4>Rendering the particles</h4>
The particles will use the same four-tile <em>parts.png</em> file (as shown in <a href="ch09.html#the_parts.png_tile_sheet" title="Figure 9-8. 
The parts.png tile sheet">Figure 9-8</a>) that rendered the projectiles. 

The <em>Geo Blaster Basic</em> game from <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a> used only a single white particle for all explosions. 
We replace the <code>createExplode()</code> function from this previous game with a new one that will be able to use a different-colored particle for each type of explosion. 
This way the rocks, saucers, and player ship can all have unique colored explosions.

The new <code>createExplode()</code> function will handle this by adding a final <code>type</code> parameter to its parameter list. 
Let’s look at the code:
function createExplode(x,y,num,type) {
 playSound(SOUND_EXPLODE,.5); for (var partCtr=0;partCtr&lt;num;partCtr++){ if (particlePool.length &gt; 0){ newParticle = particlePool.pop(); newParticle.dx = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dx *= -1; } newParticle.dy = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dy *= -1; }
 newParticle.life = Math.floor(Math.random()*30+30); newParticle.lifeCtr = 0; newParticle.x = x; newParticle.width = 2; newParticle.height = 2; newParticle.y = y; newParticle.type = type; //ConsoleLog.log("newParticle.life=" + newParticle.life); particles.push(newParticle); }
 }
}

As the <code>particle</code> objects are created in <code>createExplode()</code>, we added a new <code>type</code> attribute to them. 
When an explosion is triggered in the <code>checkCollisions()</code> function, the call to <code>createExplode()</code> will now include this <code>type</code> value based on the object that was destroyed. 
Each rock already has a <code>scale</code> parameter that varies from <code>1</code> to <code>3</code> based on its size. 
We will use those as our base <code>type</code> value to pass in for the rocks. 

Now we only need <code>type</code> values for the player and the saucer. 
For the saucer we will use <code>0</code>, and for the player we will use <code>4</code>. 
We pulled these id values out of the air. 
We very well could have used <code>99</code> for the saucer and <code>200</code> for the player. 

We just could not use <code>1</code>, <code>2</code>, or <code>3</code> because those values are used for the rocks. 
The <code>type</code> breakdown looks like this:

Saucer: <code>type</code>=<code>0</code>
Large rock: <code>type</code>=<code>1</code>
Medium rock: <code>type</code>=<code>2</code>
Small rock: <code>type</code>=<code>3</code>

Player: <code>type</code>=<code>4</code>
This <code>type</code> value will need to be used in a switch statement inside the <code>render</code><code>Particles()</code> function to determine which of the four tiles to render for a given particle. 

Let’s examine this function now:
function renderParticles() {
 var tempParticle = {};
 var particleLength = particles.length-1; for (var particleCtr=particleLength;particleCtr&gt;=0;particleCtr--){ tempParticle = particles[particleCtr]; context.save(); //save current state in stack var tile;
 console.log("part type=" + tempParticle.type) switch(tempParticle.type){ case 0: // saucer tile = 0; break; case 1: //large rock tile = 2 break; case 2: //medium rock tile = 3; break; case 3: //small rock tile = 0; break; case 4: //player tile = 1; break;
 } var sourceX = Math.floor(tile % 4) * tempParticle.width; var sourceY = Math.floor(tile / 4) * tempParticle.height;
 context.drawImage(particleTiles, sourceX, sourceY, tempParticle.width, tempParticle.height, tempParticle.x, tempParticle.y,tempParticle.width,tempParticle.height);
 context.restore(); //pop old state on to screen
 }

In <code>checkCollisions()</code>, we will need to pass the <code>type</code> parameter to the <code>createExplode()</code> function so the <code>type</code> can be assigned to the particles in the explosion. 
Here is an example of a <code>createExplode()</code> function call used for a rock instance:
createExplode(tempRock.x+tempRock.halfWidth,tempRock.y+tempRock.halfHeight, 10,tempRock.scale);

We pass the <code>tempRock.scale</code> as the final parameter because we are using the rock’s scale as the <code>type</code>.
For a saucer:
createExplode(tempSaucer.x+tempSaucer.halfWidth, tempSaucer.y+tempSaucer.halfHeight,10,0);

For the saucers and the player, we will pass a number literal into the <code>createExplode()</code> function. 
In the saucer’s case, we pass in a <code>1</code>. 
For the player ship, we pass in a <code>4</code>:
createExplode(player.x+player.halfWidth, player.y+player.halfWidth,50,4);

Note that the <code>createExplode()</code> function call for the player is in the <code>playerDie()</code> function, which is called from <code>checkCollisions()</code>.
<h3>Note</h3>
After we discuss adding sound and a particle pool to this game, we will present the entire set of code (Example 9-1</a>), replacing the <em>Geo Blaster Basic</em> code. 
There will be no need to make the changes to the individual functions.

<h3>Adding Sound</h3>
In <a href="ch07.html" title="Chapter 7. 
Working with Audio">Chapter 7</a>, we covered everything we need to know to add robust sound management to our canvas applications. 
If you are unfamiliar with the concepts presented in <a href="ch07.html" title="Chapter 7. 

Working with Audio">Chapter 7</a>, please review that chapter first. 
In this chapter, we will cover only the code necessary to include sound in our game.
Arcade games need to play many sounds simultaneously, and sometimes those sounds play very rapidly in succession. 
In <a href="ch07.html" title="Chapter 7. 

Working with Audio">Chapter 7</a>, we used the HTML5 <code>&lt;audio&gt;</code> tag to create a pool of sounds, solving the problems associated with playing the same sound instance multiple times.
<h3>Note</h3>
As of this writing, the Opera browser in Windows offers the best support for playing sounds. 
If you are having trouble with the sound in this game, any other sound example in the book, or in your own games, please test them out in the Opera browser.

<h4>The sounds for our game</h4>
We will be adding three sounds to our game:

A sound for when the player shoots a projectile (<em>shoot1.mp3</em>, <em>.ogg</em>, <em>.wav</em>)
A sound for explosions (<em>explode1.mp3</em>, <em>.ogg</em>, <em>.wav</em>)
A sound for when the saucer shoots a projectile (<em>saucershoot.mp3</em>, <em>.ogg</em>, <em>.wav</em>)
</li>

</ul>
In the file download for this chapter, we have provided each of the three sounds in three different formats: <em>.wav</em>, <em>.ogg</em>, and <em>.mp3</em>.
<h4>Adding sound instances and management variables to the game</h4>
In the variable definition section of our game code, we will create variables to work with the sound manager code from <a href="ch07.html" title="Chapter 7. 

Working with Audio">Chapter 7</a>. 
We will create three instances of each sound that goes into our pool:
var explodeSound;
var explodeSound2;

var explodeSound3;
var shootSound;
var shootSound2;
var shootSound3;

var saucershootSound;
var saucershootSound2;
var saucershootSound3;
We also need to create an array to hold our pool of sounds:

var soundPool = new Array();
To control which sound we want to play, we will assign a constant string to each, and to play the sound, we only ever need to use the constant. 
This way, we can change the sound names easily, which will help in refactoring code if we want to modify the sounds at a later time:
 const SOUND_EXPLODE = "explode1"; const SOUND_SHOOT = "shoot1"; const SOUND_SAUCER_SHOOT = "saucershoot"

Finally, we need a variable called <code>audioType</code>, which we will use to reference the current file type (<em>.ogg</em>, <em>.mp3</em>, or <em>.wav</em>) by the sound manager code.
<h4>Loading in sounds and tile sheet assets</h4>
In <a href="ch07.html" title="Chapter 7. 
Working with Audio">Chapter 7</a>, we used a function to load all of the game assets while our state machine waited in an idle state. 

We will add this code to our game in a function called <code>game</code><code>StateInit()</code>:
function gameStateInit() {
 loadCount = 0;
 itemsToLoad = 16; explodeSound = document.createElement("audio");
 document.body.appendChild(explodeSound);
 audioType = supportedAudioFormat(explodeSound);
 explodeSound.setAttribute("src", "explode1." + audioType); explodeSound.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound2 = document.createElement("audio");
 document.body.appendChild(explodeSound2);
 explodeSound2.setAttribute("src", "explode1." + audioType); explodeSound2.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound3 = document.createElement("audio");
 document.body.appendChild(explodeSound3);
 explodeSound3.setAttribute("src", "explode1." + audioType); explodeSound3.addEventListener("canplaythrough",itemLoaded,false);
 shootSound = document.createElement("audio");
 audioType = supportedAudioFormat(shootSound);
 document.body.appendChild(shootSound); shootSound.setAttribute("src", "shoot1." + audioType);
 shootSound.addEventListener("canplaythrough",itemLoaded,false);
 shootSound2 = document.createElement("audio");
 document.body.appendChild(shootSound2); shootSound2.setAttribute("src", "shoot1." + audioType);
 shootSound2.addEventListener("canplaythrough",itemLoaded,false);
 shootSound3 = document.createElement("audio");
 document.body.appendChild(shootSound3); shootSound3.setAttribute("src", "shoot1." + audioType);
 shootSound3.addEventListener("canplaythrough",itemLoaded,false);
 saucershootSound = document.createElement("audio");
 audioType = supportedAudioFormat(saucershootSound); document.body.appendChild(saucershootSound);
 saucershootSound.setAttribute("src", "saucershoot." + audioType);
 saucershootSound.addEventListener("canplaythrough",itemLoaded,false);
 saucershootSound2 = document.createElement("audio"); document.body.appendChild(saucershootSound2);
 saucershootSound2.setAttribute("src", "saucershoot." + audioType);
 saucershootSound2.addEventListener("canplaythrough",itemLoaded,false);
 saucershootSound3 = document.createElement("audio"); document.body.appendChild(saucershootSound3);
 saucershootSound3.setAttribute("src", "saucershoot." + audioType);
 saucershootSound3.addEventListener("canplaythrough",itemLoaded,false);
 shipTiles = new Image(); shipTiles.src = "ship_tiles.png";
 shipTiles.onload = itemLoaded;
 shipTiles2 = new Image();
 shipTiles2.src = "ship_tiles2.png"; shipTiles2.onload = itemLoaded;
 saucerTiles= new Image();
 saucerTiles.src = "saucer.png";
 saucerTiles.onload = itemLoaded; largeRockTiles = new Image();
 largeRockTiles.src = "largerocks.png";
 largeRockTiles.onload = itemLoaded;
 mediumRockTiles = new Image(); mediumRockTiles.src = "mediumrocks.png";
 mediumRockTiles.onload = itemLoaded;
 smallRockTiles = new Image();
 smallRockTiles.src = "smallrocks.png"; smallRockTiles.onload = itemLoaded;
 particleTiles = new Image();
 particleTiles.src = "parts.png";
 particleTiles.onload = itemLoaded; switchGameState(GAME_STATE_WAIT_FOR_LOAD);
}
Notice that we must create and preload three separate instances of each sound, even though they share the same sound file (or files). 
In this function, we also load in our tile sheets. 

The application scope <code>itemsToLoad</code> variable will be used to check against the application scope <code>loadCount</code> variable in the <code>load</code> event callback <code>itemLoaded()</code> function, which is shared by all assets to be loaded. 
This will make it easy for the application to change state so that it can start playing the game when all assets have loaded. 
Let’s briefly look at the <code>itemLoaded()</code> function now:
function itemLoaded(event) { loadCount++;
 //console.log("loading:" + loadCount)
 if (loadCount &gt;= itemsToLoad) {
 shootSound.removeEventListener("canplaythrough",itemLoaded, false); shootSound2.removeEventListener("canplaythrough",itemLoaded, false); shootSound3.removeEventListener("canplaythrough",itemLoaded, false); explodeSound.removeEventListener("canplaythrough",itemLoaded,false); explodeSound2.removeEventListener("canplaythrough",itemLoaded,false); explodeSound3.removeEventListener("canplaythrough",itemLoaded,false); saucershootSound.removeEventListener("canplaythrough",itemLoaded,false); saucershootSound2.removeEventListener("canplaythrough",itemLoaded,false); saucershootSound3.removeEventListener("canplaythrough",itemLoaded,false); soundPool.push({name:"explode1", element:explodeSound, played:false}); soundPool.push({name:"explode1", element:explodeSound2, played:false}); soundPool.push({name:"explode1", element:explodeSound3, played:false}); soundPool.push({name:"shoot1", element:shootSound, played:false}); soundPool.push({name:"shoot1", element:shootSound2, played:false}); soundPool.push({name:"shoot1", element:shootSound3, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound2, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound3, played:false});
 switchGameState(GAME_STATE_TITLE) }
}
In this function, we first remove the event listener from each loaded item, then add the sounds to our sound pool. 

Finally, we call the <code>switchGameState()</code> to send the game to the title screen.
<h4>Playing sounds</h4>
Sounds will be played using the <code>playSound()</code> function from <a href="ch07.html" title="Chapter 7. 
Working with Audio">Chapter 7</a>. 

We will not reprint that function here, but it will be in Example 9-1</a> where we give the entire set of code for the game. 
We will call the <code>playSound()</code> function at various instances in our code to play the needed sounds. 
For example, the <code>createExplode()</code> function presented earlier in this chapter included this line:
playSound(SOUND_EXPLODE,.5);

When we want to play a sound instance from the pool, we call the <code>playSound()</code> function and pass in the constants representing the sound and the volume for the sound. 
If an instance of the sound is available in the pool, it will be used and the sound will play.
Now, let’s move on to another type of application pool—the object pool.
<h3>Pooling Object Instances</h3>

We have looked at object pools as they relate to sounds, but we have not applied this concept to our game objects. 
Object pooling is a technique designed to save processing time, so it is very applicable to an arcade game application such as the one we are building. 
By pooling object instances, we avoid the sometimes processor-intensive task of creating object instances on the fly during game execution. 
This is especially applicable to our particle explosions, as we create multiple objects on the same frame tick. 

On a lower-powered platform, such as a handheld device, object pooling can help increase frame rate.
<h4>Object pooling in Geo Blaster Extended</h4>
In our game, we will apply the pooling concept to the explosion particles. 
Of course, we can extend this concept to rocks, projectiles, saucers, and any other type of object that requires multiple instances. 

For this example, though, let’s focus on the particles. 
As we will see, adding pooling in JavaScript is a relatively simple but powerful technique.
<h4>Adding pooling variables to our game</h4>
We will need to add four application scope variables to our game to make use of pooling for our game particle: var particlePool = []; var maxParticles = 200; var newParticle; var tempParticle;
The <code>particlePool</code> array will hold the list of <code>particle</code> object instances that are waiting to be used. 
When <code>createExplode()</code> needs to use a particle, it will first look to see whether any are available in this array. 
If one is available, it will be “popped” off the top of the <code>particlePool</code> stack and placed in the application scope <code>newParticle</code> variable—which is a reference to the pooled particle. 

The <code>createExplode()</code> function will set the properties of the <code>newParticle</code>, and then “push” it to the end of the existing <code>particles</code> array.
Once a particle’s life has been exhausted, the <code>updateParticles()</code> function will splice the particle from the <code>particles</code> array and push it back into the <code>particlePool</code> array. 
We have created the <code>tempParticle</code> reference to alleviate the <code>updateParticles()</code> function’s need to create this instance on each frame tick.
The <code>maxParticles</code> value will be used in a new function called <code>createObjectPools()</code>. 

We will call this function in the <code>gameStateInit()</code> state function before we create the sound and tile sheet loading events.
Let’s take a look at the <code>createObjectPools()</code> function now:
function createObjectPools(){
 for (var ctr=0;ctr&lt;maxParticles;ctr++){ var newParticle = {}; particlePool.push(newParticle) }
 console.log("particlePool=" + particlePool.length)
}
As you can see, we simply iterate from <code>0</code> to <code>1</code> less than the <code>maxParticles</code> value, and place a generic object instance at each element in the pool. 

When a particle is needed, the <code>createExplode()</code> function will look to see whether <code>particlePool.length</code> is greater than <code>0</code>. 
If a particle is available, it will be added to the <code>particles</code> array after its attributes are set. 
If no particle is available, none will be used.
<h3>Note</h3>

This functionality can be extended to add a particle as needed to the pool when none is available. 
We have not added that functionality to our example, but it is common in some pooling algorithms.
Here is the newly modified <code>createExplode()</code> function in its entirety:
function createExplode(x,y,num,type) { playSound(SOUND_EXPLODE,.5);
 for (var partCtr=0;partCtr&lt;num;partCtr++){ if (particlePool.length &gt; 0){
 newParticle = particlePool.pop(); newParticle.dx = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dx* = -1; } newParticle.dy = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dy* = -1; }
 newParticle.life = Math.floor(Math.random()*30+30); newParticle.lifeCtr = 0; newParticle.x = x; newParticle.width = 2; newParticle.height = 2; newParticle.y = y; newParticle.type = type; //ConsoleLog.log("newParticle.life=" + newParticle.life); particles.push(newParticle); } }
}
The <code>updateParticles()</code> function will loop through the <code>particles</code> instances, update the attributes of each, and then check to see whether the particle’s life has been exhausted. 
If it has, the function will place the particle back in the pool. 

Here is the code we will add to <code>updateParticles()</code> to replenish the pool:
if (remove) {
 particlePool.push(tempParticle)
 particles.splice(particleCtr,1)

}
<h3>Adding in a Step Timer</h3>
In <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a>, we created a simple <code>FrameRateCounter</code> object prototype that was used to display the current frame rate as the game was running. 

We are going to extend the functionality of this counter to add in a “step timer.” The step timer will use the time difference calculated between frames to create a “step factor.” This step factor will be used when updating the positions of the objects on the canvas. 
The result will be smoother rendering of the game objects when there are drops in frame rate, as well as keeping relatively consistent game play on browsers and systems that cannot maintain the frame rate needed to play the game effectively.
<h4>How the step timer works</h4>
We will update the constructor function for <code>FrameRateCounter</code> to accept in a new single parameter called <code>fps</code>. 

This value will represent the frames per second that we want our game to run:
function FrameRateCounter(fps) {
 if (fps == undefined){ this.fps = 40
 }else{ this.fps = fps }
If no <code>fps</code> value is passed in, the value <code>40</code> will be used.
We will also add in two new object-level scope variables to calculate the <code>step</code> in our step timer:
this.lastTime = dateTemp.getTime();

this.step = 1;
The <code>lastTime</code> variable will contain the time in which the previous frame completed its work.
We calculate the <code>step</code> by comparing the current time value with the <code>lastTime</code> value on each frame tick. 
This calculation will occur in the <code>FrameRateCounter</code> <code>countFrames()</code> function:

FrameRateCounter.prototype.countFrames=function() {
 var dateTemp = new Date();
 var timeDifference = dateTemp.getTime()-this.lastTime;
 this.step = (timeDifference/1000)*this.fps; this.lastTime = dateTemp.getTime();
The local <code>timeDifference</code> value is calculated by subtracting the <code>lastTime</code> value from the current time (represented by the <code>dateTemp.getTime()</code> return value).
To calculate the <code>step</code> value, divide the <code>timeDifference</code> by <code>1000</code> (the number of milliseconds in a single second), and multiply the result by the desired frame rate. 
If the game is running with no surplus or no deficit in time between frame ticks, the step value will be <code>1</code>. 

If the current frame tick took longer than a single frame to finish, the value will be greater than <code>1</code> (a deficit). 
If the current frame took less time than a single frame, the step value will be less than <code>1</code> (a surplus).
For example, if the last frame took too long to process, the current frame will compensate by moving each object a little bit more than the <code>step</code> value of <code>1</code>. 
Let’s illustrate this with a simple example.

Let’s say we want the saucer to move five pixels to the right on each frame tick. 
This would be a <code>dx</code> value of <code>5</code>.
For this example, we will also say that our desired frame rate is <code>40</code> FPS. 
This means that we want each frame tick to use up <code>25</code> milliseconds (<code>1000/40 = 25</code>).

Let’s also suppose that the <code>timeDifference</code> between the current frame and the last frame is <code>26</code> milliseconds. 
Our game is running at a deficit of <code>1</code> millisecond per frame—this means that the game processing is taking more time than we want it to.
To calculate the <code>step</code> value, divide the <code>timeDifference</code> by <code>1000</code>: <code>26/1000 = .026</code>.
We multiply this value by the desired <code>fps</code> for our game: <code>.026 * 40 = 1.04</code>

Our <code>step</code> value is <code>1.04</code> for the current frame. 
Because of the deficit in processing time, we want to move each game object slightly more than a frame so there is no surplus or deficit. 
In the case of no surplus or deficit, the step value would be <code>1</code>. 
If there is a surplus, the <code>step</code> value would be less than <code>1</code>.

This <code>step</code> value will be multiplied to the changes in movement vectors for each object in the update functions. 
This allows the game to keep a relatively smooth look even when there are fluctuations in the frame rate. 
In addition, the game will update the screen in a relatively consistent manner across the various browsers and systems, resulting in game play that is relatively consistent for each user.
Here are the new movement vector calculations for each object:

<code>player</code>
player.x += player.movingX*frameRateCounter.step;

player.y += player.movingY*frameRateCounter.step;
<code>playerMissiles</code>

tempPlayerMissile.x += tempPlayerMissile.dx*frameRateCounter.step;
tempPlayerMissile.y += tempPlayerMissile.dy*frameRateCounter.step;
<code>rocks</code>

tempRock.x += tempRock.dx*frameRateCounter.step;
tempRock.y += tempRock.dy*frameRateCounter.step;

<code>saucers</code>
tempSaucer.x += tempSaucer.dx*frameRateCounter.step;
tempSaucer.y += tempSaucer.dy*frameRateCounter.step;

<code>saucerMissiles</code>
tempSaucerMissile.x += tempSaucerMissile.dx*frameRateCounter.step;

tempSaucerMissile.y += tempSaucerMissile.dy*frameRateCounter.step;
<code>particles</code>

tempParticle.x += tempParticle.dx*frameRateCounter.step;
tempParticle.y += tempParticle.dy*frameRateCounter.step;

We have now covered all of the major changes to turn <em>Geo Blaster Basic</em> into <em>Geo Blaster Extended</em>. 
Let’s look at Example 9-1</a>, which has the entire code for the final game.
<h3>Geo Blaster Extended Full Source</h3>
Example 9-1. 

Geo Blaster Extended full source code listing
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH9EX1: Geo Blaster Extended&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();
}

function canvasSupport () {
 return Modernizr.canvas;
}
function supportedAudioFormat(audio) { var returnExtension = "";
 if (audio.canPlayType("audio/ogg") =="probably" || audio.canPlayType("audio/ogg") == "maybe") { returnExtension = "ogg";
 } else if(audio.canPlayType("audio/wav") =="probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "wav";
 } else if(audio.canPlayType("audio/wav") == "probably" || audio.canPlayType("audio/wav") == "maybe") { returnExtension = "mp3"; }
 return returnExtension;
}
function canvasApp(){ if (!canvasSupport()) { return; }else{ theCanvas = document.getElementById("canvas"); context = theCanvas.getContext("2d");
 }
 //sounds const SOUND_EXPLODE = "explode1"; const SOUND_SHOOT = "shoot1";
 const SOUND_SAUCER_SHOOT = "saucershoot"
 const MAX_SOUNDS = 9;
 var soundPool = new Array(); var explodeSound;
 var explodeSound2;
 var explodeSound3;
 var shootSound; var shootSound2;
 var shootSound3;
 var saucershootSound;
 var saucershootSound2; var saucershootSound3;
 var audioType;
 //application states const GAME_STATE_INIT = 0; const GAME_STATE_WAIT_FOR_LOAD = 5;
 const GAME_STATE_TITLE = 10;
 const GAME_STATE_NEW_GAME = 20;
 const GAME_STATE_NEW_LEVEL = 30; const GAME_STATE_PLAYER_START = 40;
 const GAME_STATE_PLAY_LEVEL = 50;
 const GAME_STATE_PLAYER_DIE = 60;
 const GAME_STATE_GAME_OVER = 70; var currentGameState = 0;
 var currentGameStateFunction = null;
 //title screen var titleStarted = false; //game over screen var gameOverStarted = false;
 //objects for game play
 //game environment var score = 0;
 var level = 0;
 var extraShipAtEach = 10000;
 var extraShipsEarned = 0; var playerShips = 3;
 //playfield var xMin = 0;
 var xMax = 400; var yMin = 0;
 var yMax = 400;
 //score values var bigRockScore = 50; var medRockScore = 75;
 var smlRockScore = 100;
 var saucerScore = 300;
 //rock scale constants const ROCK_SCALE_LARGE = 1;
 const ROCK_SCALE_MEDIUM = 2;
 const ROCK_SCALE_SMALL = 3;
 //create game objects and arrays var player = {};
 var rocks = [];
 var saucers = [];
 var playerMissiles = []; var particles = [];
 var saucerMissiles = [];
 var particlePool = [];
 var maxParticles = 200; var newParticle;
 var tempParticle;
 //level specific var levelRockMaxSpeedAdjust = 1; var levelSaucerMax = 1;
 var levelSaucerOccurrenceRate = 25;
 var levelSaucerSpeed = 1;
 var levelSaucerFireDelay = 300; var levelSaucerFireRate = 30;
 var levelSaucerMissileSpeed = 1;
 //keyPresses var keyPressList=[]; //tile sheets var shipTiles;
 var shipTiles2;
 var saucerTiles; var largeRockTiles;
 var mediumRockTiles;
 var smallRockTiles;
 var particleTiles; function itemLoaded(event) {
 loadCount++; //console.log("loading:" + loadCount) if (loadCount &gt;= itemsToLoad) {
 shootSound.removeEventListener("canplaythrough",itemLoaded, false); shootSound2.removeEventListener("canplaythrough",itemLoaded, false); shootSound3.removeEventListener("canplaythrough",itemLoaded, false); explodeSound.removeEventListener("canplaythrough",itemLoaded,false); explodeSound2.removeEventListener("canplaythrough",itemLoaded,false); explodeSound3.removeEventListener("canplaythrough",itemLoaded,false); saucershootSound.removeEventListener("canplaythrough",itemLoaded,false); saucershootSound2.removeEventListener("canplaythrough",itemLoaded, false); saucershootSound3.removeEventListener("canplaythrough",itemLoaded, false);
 soundPool.push({name:"explode1", element:explodeSound, played:false}); soundPool.push({name:"explode1", element:explodeSound2, played:false}); soundPool.push({name:"explode1", element:explodeSound3, played:false}); soundPool.push({name:"shoot1", element:shootSound, played:false}); soundPool.push({name:"shoot1", element:shootSound2, played:false}); soundPool.push({name:"shoot1", element:shootSound3, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound2, played:false}); soundPool.push({name:"saucershoot", element:saucershootSound3, played:false}); switchGameState(GAME_STATE_TITLE)
 }
 }
 function playSound(sound,volume) { ConsoleLog.log("play sound" + sound); var soundFound = false; var soundIndex = 0; var tempSound; if (soundPool.length&gt; 0) { while (!soundFound &amp;&amp; soundIndex &lt; soundPool.length) {
 var tSound = soundPool[soundIndex]; if ((tSound.element.ended || !tSound.played) &amp;&amp; tSound.name == sound) { soundFound = true; tSound.played = true; } else { soundIndex++; }
 } } if (soundFound) { ConsoleLog.log("sound found"); tempSound = soundPool[soundIndex].element; //tempSound.setAttribute("src", sound + "." + audioType); //tempSound.loop = false; //tempSound.volume = volume; tempSound.play();
 } else if (soundPool.length &lt; MAX_SOUNDS){ ConsoleLog.log("sound not found"); tempSound = document.createElement("audio"); tempSound.setAttribute("src", sound + "." + audioType); tempSound.volume = volume; tempSound.play(); soundPool.push({name:sound, element:tempSound, type:audioType, played:true}); } }
 function runGame(){ currentGameStateFunction();
 }
 function switchGameState(newState) { currentGameState = newState; switch (currentGameState) { case GAME_STATE_INIT: currentGameStateFunction = gameStateInit; break; case GAME_STATE_WAIT_FOR_LOAD: currentGameStateFunction = gameStateWaitForLoad; break; case GAME_STATE_TITLE: currentGameStateFunction = gameStateTitle; break; case GAME_STATE_NEW_GAME: currentGameStateFunction = gameStateNewGame; break; case GAME_STATE_NEW_LEVEL: currentGameStateFunction = gameStateNewLevel; break; case GAME_STATE_PLAYER_START: currentGameStateFunction = gameStatePlayerStart; break; case GAME_STATE_PLAY_LEVEL: currentGameStateFunction = gameStatePlayLevel; break; case GAME_STATE_PLAYER_DIE: currentGameStateFunction = gameStatePlayerDie; break; case GAME_STATE_GAME_OVER: currentGameStateFunction = gameStateGameOver; break;
 }
 }
 function gameStateWaitForLoad(){ //do nothing while loading events occur console.log("doing nothing...") }
 function createObjectPools(){ for (var ctr=0;ctr&lt;maxParticles;ctr++){ var newParticle = {}; particlePool.push(newParticle) } console.log("particlePool=" + particlePool.length)
 }
 function gameStateInit() { createObjectPools(); loadCount = 0; itemsToLoad = 16;
 explodeSound = document.createElement("audio"); document.body.appendChild(explodeSound); audioType = supportedAudioFormat(explodeSound); explodeSound.setAttribute("src", "explode1." + audioType); explodeSound.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound2 = document.createElement("audio"); document.body.appendChild(explodeSound2); explodeSound2.setAttribute("src", "explode1." + audioType); explodeSound2.addEventListener("canplaythrough",itemLoaded,false);
 explodeSound3 = document.createElement("audio"); document.body.appendChild(explodeSound3); explodeSound3.setAttribute("src", "explode1." + audioType); explodeSound3.addEventListener("canplaythrough",itemLoaded,false); shootSound = document.createElement("audio"); audioType = supportedAudioFormat(shootSound); document.body.appendChild(shootSound); shootSound.setAttribute("src", "shoot1." + audioType); shootSound.addEventListener("canplaythrough",itemLoaded,false);
 shootSound2 = document.createElement("audio"); document.body.appendChild(shootSound2); shootSound2.setAttribute("src", "shoot1." + audioType); shootSound2.addEventListener("canplaythrough",itemLoaded,false);
 shootSound3 = document.createElement("audio"); document.body.appendChild(shootSound3); shootSound3.setAttribute("src", "shoot1." + audioType); shootSound3.addEventListener("canplaythrough",itemLoaded,false);
 saucershootSound = document.createElement("audio"); audioType = supportedAudioFormat(saucershootSound); document.body.appendChild(saucershootSound); saucershootSound.setAttribute("src", "saucershoot." + audioType); saucershootSound.addEventListener("canplaythrough",itemLoaded,false); saucershootSound2 = document.createElement("audio"); document.body.appendChild(saucershootSound2); saucershootSound2.setAttribute("src", "saucershoot." + audioType); saucershootSound2.addEventListener("canplaythrough",itemLoaded,false);
 saucershootSound3 = document.createElement("audio"); document.body.appendChild(saucershootSound3); saucershootSound3.setAttribute("src", "saucershoot." + audioType); saucershootSound3.addEventListener("canplaythrough",itemLoaded,false);
 shipTiles = new Image(); shipTiles.src = "ship_tiles.png"; shipTiles.onload = itemLoaded;
 shipTiles2 = new Image(); shipTiles2.src = "ship_tiles2.png"; shipTiles2.onload = itemLoaded; saucerTiles= new Image(); saucerTiles.src = "saucer.png"; saucerTiles.onload = itemLoaded;
 largeRockTiles = new Image(); largeRockTiles.src = "largerocks.png"; largeRockTiles.onload = itemLoaded;
 mediumRockTiles = new Image(); mediumRockTiles.src = "mediumrocks.png"; mediumRockTiles.onload = itemLoaded;
 smallRockTiles = new Image(); smallRockTiles.src = "smallrocks.png"; smallRockTiles.onload = itemLoaded; particleTiles = new Image(); particleTiles.src = "parts.png"; particleTiles.onload = itemLoaded;
 switchGameState(GAME_STATE_WAIT_FOR_LOAD);
 }
 function gameStateTitle() { if (titleStarted !=true){ fillBackground(); setTextStyleTitle(); context.fillText ("Geo Blaster X-ten-d", 120, 70); setTextStyle(); context.fillText ("Press Space To Play", 130, 140);
 setTextStyleCredits(); context.fillText ("An HTML5 Example Game", 125, 200); context.fillText ("From our upcoming HTML5 Canvas", 100, 215); context.fillText ("book on O'Reilly Press", 130, 230);
 context.fillText ("Game Code - Jeff Fulton", 130, 260); context.fillText ("Sound Manager - Steve Fulton", 120, 275);
 titleStarted = true; }else{ //wait for space key click if (keyPressList[32]==true){ ConsoleLog.log("space pressed"); switchGameState(GAME_STATE_NEW_GAME); titleStarted = false; }
 }
 }
 function gameStateNewGame(){ ConsoleLog.log("gameStateNewGame") //set up new game level = 0; score = 0; playerShips = 3; player.maxVelocity = 5; player.width = 32; player.height = 32; player.halfWidth = 16; player.halfHeight = 16; player.hitWidth = 24; player.hitHeight = 24; player.rotationalVelocity = 10; //how many degrees to turn the ship player.thrustAcceleration = .05; player.missileFrameDelay = 5; player.thrust = false; player.alpha = 1; player.rotation = 0; player.x = 0; player.y = 0; fillBackground(); renderScoreBoard(); switchGameState(GAME_STATE_NEW_LEVEL)
 }
 function gameStateNewLevel(){ rocks = []; saucers = []; playerMissiles = []; particles = []; saucerMissiles = []; level++; levelRockMaxSpeedAdjust = level*.25; if (levelRockMaxSpeedAdjust &gt; 3){ levelRockMaxSpeed = 3; }
 levelSaucerMax = 1+Math.floor(level/10); if (levelSaucerMax &gt; 5){ levelSaucerMax = 5; } levelSaucerOccurrenceRate = 10+3*level; if (levelSaucerOccurrenceRate &gt; 35){ levelSaucerOccurrenceRate = 35; } levelSaucerSpeed = 1+.5*level; if (levelSaucerSpeed&gt;5){ levelSaucerSpeed = 5; } levelSaucerFireDelay = 120-10*level; if (levelSaucerFireDelay&lt;20) { levelSaucerFireDelay = 20; } levelSaucerFireRate = 20 + 3*level; if (levelSaucerFireRate&lt;50) { levelSaucerFireRate = 50; }
 levelSaucerMissileSpeed = 1+.2*level; if (levelSaucerMissileSpeed &gt; 4){ levelSaucerMissileSpeed = 4; } //create level rocks for (var newRockctr=0;newRockctr&lt;level+3;newRockctr++){ var newRock = {};
 newRock.scale = 1; //scale //1 = large //2 = medium //3 = small //these will be used as the divisor for the new size //50/1 = 50 //50/2 = 25 //50/3 = 16 newRock.width = 64; newRock.height = 64; newRock.halfWidth = 32; newRock.halfHeight = 32;
 newRock.hitWidth = 48; newRock.hitHeight = 48; //start all new rocks in upper left for ship safety newRock.x = Math.floor(Math.random()*50); //ConsoleLog.log("newRock.x=" + newRock.x); newRock.y = Math.floor(Math.random()*50); //ConsoleLog.log("newRock.y=" + newRock.y); newRock.dx = (Math.random()*2)+levelRockMaxSpeedAdjust; if (Math.random()&lt;.5){ newRock.dx *= -1; } newRock.dy=(Math.random()*2)+levelRockMaxSpeedAdjust; if (Math.random()&lt;.5){ newRock.dy *= -1; } //rotation speed and direction if (Math.random()&lt;.5){ newRock.rotationInc = -1; }else{ newRock.rotationInc = 1; }
 newRock.animationDelay = Math.floor(Math.random()*3+1); newRock.animationCount = 0;
 newRock.scoreValue = bigRockScore; newRock.rotation = 0; rocks.push(newRock); //ConsoleLog.log("rock created rotationInc=" + newRock.rotationInc); } resetPlayer(); switchGameState(GAME_STATE_PLAYER_START);
 }
 function gameStatePlayerStart(){
 fillBackground(); renderScoreBoard(); if (player.alpha &lt; 1){ player.alpha += .01; ConsoleLog.log("player.alpha=" + context.globalAlpha) }else{ switchGameState(GAME_STATE_PLAY_LEVEL); player.safe = false; // added chapter 9
 }
 //renderPlayerShip(player.x, player.y,270,1); context.globalAlpha = 1; //new in chapter 9 checkKeys(); update(); render(); //added chapter 9 checkCollisions(); checkForExtraShip(); checkForEndOfLevel(); frameRateCounter.countFrames();
 } function gameStatePlayLevel(){ checkKeys(); update(); render(); checkCollisions(); checkForExtraShip(); checkForEndOfLevel(); frameRateCounter.countFrames();
 }
 function resetPlayer() { player.rotation = 270; player.x = .5*xMax; player.y = .5*yMax; player.facingX = 0; player.facingY = 0; player.movingX = 0; player.movingY = 0; player.alpha = 0; player.missileFrameCount = 0; //added chapter 9 player.safe = true;
 } function checkForExtraShip() { if (Math.floor(score/extraShipAtEach) &gt; extraShipsEarned) { playerShips++ extraShipsEarned++; }
 }
 function checkForEndOfLevel(){ if (rocks.length==0) { switchGameState(GAME_STATE_NEW_LEVEL); }
 } function gameStatePlayerDie(){ if (particles.length &gt;0 || playerMissiles.length&gt;0) { fillBackground(); renderScoreBoard(); updateRocks(); updateSaucers(); updateParticles(); updateSaucerMissiles(); updatePlayerMissiles(); renderRocks(); renderSaucers(); renderParticles(); renderSaucerMissiles(); renderPlayerMissiles(); frameRateCounter.countFrames();
 }else{ playerShips--; if (playerShips&lt;1) { switchGameState(GAME_STATE_GAME_OVER); }else{ //resetPlayer(); switchGameState(GAME_STATE_PLAYER_START); } }
 }
 function gameStateGameOver() { //ConsoleLog.log("Game Over State"); if (gameOverStarted !=true){ fillBackground(); renderScoreBoard(); setTextStyle(); context.fillText ("Game Over!", 160, 70); context.fillText ("Press Space To Play", 130, 140); gameOverStarted = true; }else{ //wait for space key click if (keyPressList[32]==true){ ConsoleLog.log("space pressed"); switchGameState(GAME_STATE_TITLE); gameOverStarted = false;
 }
 }
 } function fillBackground() { // draw background and text context.fillStyle = '#000000'; context.fillRect(xMin, yMin, xMax, yMax);
 }
 function setTextStyle() { context.fillStyle = '#ffffff'; context.font = '15px _sans'; context.textBaseline = 'top';
 } function setTextStyleTitle() { context.fillStyle = '#54ebeb'; context.font = '20px _sans'; context.textBaseline = 'top';
 }
 function setTextStyleCredits() { context.fillStyle = '#ffffff'; context.font = '12px _sans'; context.textBaseline = 'top';
 } function renderScoreBoard() {
 context.fillStyle = "#ffffff"; context.fillText('Score ' + score, 10, 20); renderPlayerShip(200,16,270,.75) context.fillText('X ' + playerShips, 220, 20);
 context.fillText('FPS: ' + frameRateCounter.lastFrameCount, 300,20)
 } function checkKeys() { //check keys if (keyPressList[38]==true){ //thrust var angleInRadians = player.rotation * Math.PI / 180; player.facingX = Math.cos(angleInRadians); player.facingY = Math.sin(angleInRadians);
 var movingXNew = player.movingX+player.thrustAcceleration*player.facingX; var movingYNew = player.movingY+player.thrustAcceleration*player.facingY;
 var currentVelocity = Math.sqrt ((movingXNew*movingXNew) + (movingXNew*movingXNew)); if (currentVelocity &lt; player.maxVelocity) { player.movingX = movingXNew; player.movingY = movingYNew; } player.thrust = true;
 }else{ player.thrust = false; }
 if (keyPressList[37]==true) { //rotate counterclockwise player.rotation -= player.rotationalVelocity; if (player.rotation &lt;0) { player.rotation = 350 }
 } if (keyPressList[39]==true) { //rotate clockwise player.rotation += player.rotationalVelocity; if (player.rotation &gt;350) { player.rotation = 10 } }
 if (keyPressList[32]==true) { if (player.missileFrameCount&gt;player.missileFrameDelay){ playSound(SOUND_SHOOT,.5); firePlayerMissile(); player.missileFrameCount = 0;
 } }
 } function update() { updatePlayer(); updatePlayerMissiles(); updateRocks(); updateSaucers(); updateSaucerMissiles(); updateParticles();
 }
 function render() { fillBackground(); renderScoreBoard(); renderPlayerShip(player.x,player.y,player.rotation,1); renderPlayerMissiles(); renderRocks(); renderSaucers(); renderSaucerMissiles(); renderParticles();
 } function updatePlayer() { player.missileFrameCount++;
 player.x += player.movingX*frameRateCounter.step; player.y += player.movingY*frameRateCounter.step;
 if (player.x &gt; xMax) { player.x =- player.width; }else if (player.x&lt;-player.width){ player.x = xMax; }
 if (player.y &gt; yMax) { player.y =- player.height; }else if (player.y&lt;-player.height){ player.y = yMax; } }
 function updatePlayerMissiles() { var tempPlayerMissile = {}; var playerMissileLength=playerMissiles.length-1; //ConsoleLog.log("update playerMissileLength=" + playerMissileLength); for (var playerMissileCtr=playerMissileLength;playerMissileCtr&gt;=0; playerMissileCtr--){ //ConsoleLog.log("update player missile" + playerMissileCtr) tempPlayerMissile = playerMissiles[playerMissileCtr]; tempPlayerMissile.x += tempPlayerMissile.dx*frameRateCounter.step;; tempPlayerMissile.y += tempPlayerMissile.dy*frameRateCounter.step;; if (tempPlayerMissile.x &gt; xMax) { tempPlayerMissile.x =- tempPlayerMissile.width; }else if (tempPlayerMissile.x&lt;-tempPlayerMissile.width){ tempPlayerMissile.x = xMax; }
 if (tempPlayerMissile.y &gt; yMax) { tempPlayerMissile.y =- tempPlayerMissile.height; }else if (tempPlayerMissile.y&lt;-tempPlayerMissile.height){ tempPlayerMissile.y = yMax; }
 tempPlayerMissile.lifeCtr++; if (tempPlayerMissile.lifeCtr &gt; tempPlayerMissile.life){ //ConsoleLog.log("removing player missile"); playerMissiles.splice(playerMissileCtr,1) tempPlayerMissile = null; } } }
 function updateRocks(){
 var tempRock = {}; var rocksLength = rocks.length-1; //ConsoleLog.log("update rocks length=" + rocksLength); for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){ tempRock = rocks[rockCtr] tempRock.x += tempRock.dx*frameRateCounter.step; tempRock.y += tempRock.dy*frameRateCounter.step;
 tempRock.animationCount++; if (tempRock.animationCount &gt; tempRock.animationDelay){ tempRock.animationCount = 0; tempRock.rotation += tempRock.rotationInc; if (tempRock.rotation &gt; 4){ tempRock.rotation = 0; }else if (tempRock.rotation &lt;0){ tempRock.rotation = 4; } }
 if (tempRock.x &gt; xMax) { tempRock.x = xMin-tempRock.width; }else if (tempRock.x&lt;xMin-tempRock.width){ tempRock.x = xMax; }
 if (tempRock.y &gt; yMax) { tempRock.y = yMin-tempRock.width; }else if (tempRock.y&lt;yMin-tempRock.width){ tempRock.y = yMax; }
 //ConsoleLog.log("update rock "+ rockCtr) } }
 function updateSaucers() { //first check to see if we want to add a saucer if (saucers.length&lt; levelSaucerMax){ if (Math.floor(Math.random()*100)&lt;=levelSaucerOccurrenceRate){ //ConsoleLog.log("create saucer") var newSaucer = {};
 newSaucer.width = 30; newSaucer.height = 13; newSaucer.halfHeight = 6.5; newSaucer.halfWidth = 15; newSaucer.hitWidth = 30; newSaucer.hitHeight = 13; newSaucer.scoreValue = saucerScore; newSaucer.fireRate = levelSaucerFireRate; newSaucer.fireDelay = levelSaucerFireDelay; newSaucer.fireDelayCount = 0; newSaucer.missileSpeed = levelSaucerMissileSpeed; newSaucer.dy = (Math.random()*2); if (Math.floor(Math.random)*2==1){ newSaucer.dy *= -1; } //choose betweeen left or right edge to start if (Math.floor(Math.random()*2)==1){ //start on right and go left newSaucer.x = 450; newSaucer.dx = -1*levelSaucerSpeed;
 }else{ //left to right newSaucer.x = -50; newSaucer.dx = levelSaucerSpeed; }
 newSaucer.missileSpeed = levelSaucerMissileSpeed; newSaucer.fireDelay = levelSaucerFireDelay; newSaucer.fireRate = levelSaucerFireRate; newSaucer.y = Math.floor(Math.random()*400);
 saucers.push(newSaucer); } }
 var tempSaucer = {}; var saucerLength = saucers.length-1; //ConsoleLog.log("update rocks length=" + rocksLength); for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr];
 //should saucer fire tempSaucer.fireDelayCount++; if (Math.floor(Math.random()*100) &lt;=tempSaucer.fireRate &amp;&amp; tempSaucer.fireDelayCount&gt;tempSaucer.fireDelay ){ playSound(SOUND_SAUCER_SHOOT,.5); fireSaucerMissile(tempSaucer) tempSaucer.fireDelayCount=0; }
 var remove = false; tempSaucer.x += tempSaucer.dx*frameRateCounter.step; tempSaucer.y += tempSaucer.dy*frameRateCounter.step; //remove saucers on left and right edges if (tempSaucer.dx &gt; 0 &amp;&amp; tempSaucer.x &gt;xMax){ remove = true; }else if (tempSaucer.dx &lt;0 &amp;&amp;tempSaucer.x&lt;xMin-tempSaucer.width){ remove = true; }
 //bounce saucers off over vertical edges if (tempSaucer.y &gt; yMax || tempSaucer.y&lt;yMin-tempSaucer.width) { tempSaucer.dy *= -1 }
 if (remove==true) { //remove the saucer ConsoleLog.log("saucer removed") saucers.splice(saucerCtr,1); tempSaucer = null; }
 } }
 function updateSaucerMissiles() { var tempSaucerMissile = {}; var saucerMissileLength = saucerMissiles.length-1; for (var saucerMissileCtr = saucerMissileLength;saucerMissileCtr&gt;=0; saucerMissileCtr--){ //ConsoleLog.log("update player missile" + playerMissileCtr) tempSaucerMissile = saucerMissiles[saucerMissileCtr]; tempSaucerMissile.x += tempSaucerMissile.dx*frameRateCounter.step; tempSaucerMissile.y += tempSaucerMissile.dy*frameRateCounter.step; if (tempSaucerMissile.x &gt; xMax) { tempSaucerMissile.x =- tempSaucerMissile.width; }else if (tempSaucerMissile.x&lt;-tempSaucerMissile.width){ tempSaucerMissile.x = xMax; }
 if (tempSaucerMissile.y &gt; yMax) { tempSaucerMissile.y =- tempSaucerMissile.height; }else if (tempSaucerMissile.y&lt;-tempSaucerMissile.height){ tempSaucerMissile.y = yMax; }
 tempSaucerMissile.lifeCtr++; if (tempSaucerMissile.lifeCtr &gt; tempSaucerMissile.life){ //remove saucerMissiles.splice(saucerMissileCtr,1) tempSaucerMissile = null; } } }
 function updateParticles() {
 var particleLength=particles.length-1; ConsoleLog.log("particle=" + particleLength) ConsoleLog.log("particlePool=" + particlePool.length) for (var particleCtr=particleLength;particleCtr&gt;=0;particleCtr--){ var remove = false; tempParticle = particles[particleCtr]; tempParticle.x += tempParticle.dx*frameRateCounter.step; tempParticle.y += tempParticle.dy*frameRateCounter.step;
 tempParticle.lifeCtr++; if (tempParticle.lifeCtr &gt; tempParticle.life){ remove = true; } else if ((tempParticle.x &gt; xMax) || (tempParticle.x&lt;xMin) || (tempParticle.y &gt; yMax) || (tempParticle.y&lt;yMin)){ remove=true;
 }
 if (remove) { particlePool.push(tempParticle) particles.splice(particleCtr,1)
 } }
 }
 function renderPlayerShip(x,y,rotation, scale) { //transformation context.save(); //save current state in stack context.globalAlpha = parseFloat(player.alpha); var angleInRadians = rotation * Math.PI / 180; var sourceX = Math.floor((player.rotation/10) % 10) * 32; var sourceY = Math.floor((player.rotation/10) /10) *32; if (player.thrust){ context.drawImage(shipTiles2, sourceX, sourceY, 32,32, player.x,player.y,32,32); }else{ context.drawImage(shipTiles, sourceX, sourceY, 32,32, player.x,player.y,32,32); }
 //restore context context.restore(); //pop old state on to screen context.globalAlpha = 1;
 }
 function renderPlayerMissiles() { var tempPlayerMissile = {}; var playerMissileLength=playerMissiles.length-1; //ConsoleLog.log("render playerMissileLength=" + playerMissileLength); for (var playerMissileCtr=playerMissileLength;playerMissileCtr&gt;=0; playerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempPlayerMissile = playerMissiles[playerMissileCtr]; context.save(); //save current state in stack var sourceX=Math.floor(1 % 4) * tempPlayerMissile.width; var sourceY=Math.floor(1 / 4) * tempPlayerMissile.height;
 context.drawImage(particleTiles, sourceX, sourceY, tempPlayerMissile.width,tempPlayerMissile.height, tempPlayerMissile.x,tempPlayerMissile.y, tempPlayerMissile.width,tempPlayerMissile.height); context.restore(); //pop old state on to screen }
 }
 function renderRocks() { var tempRock = {}; var rocksLength = rocks.length-1; for (var rockCtr = rocksLength;rockCtr&gt;=0;rockCtr--){ context.save(); //save current state in stack tempRock = rocks[rockCtr]; var sourceX = Math.floor((tempRock.rotation) % 5) * tempRock.width; var sourceY = Math.floor((tempRock.rotation) /5) *tempRock.height;
 switch(tempRock.scale){ case 1: context.drawImage(largeRockTiles, sourceX, sourceY, tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break; case 2: context.drawImage(mediumRockTiles, sourceX, sourceY,tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break; case 3: context.drawImage(smallRockTiles, sourceX, sourceY,tempRock.width,tempRock.height,tempRock.x,tempRock.y, tempRock.width,tempRock.height); break; } context.restore(); //pop old state on to screen
 }
 }
 function renderSaucers() { var tempSaucer = {}; var saucerLength = saucers.length-1; for (var saucerCtr = saucerLength;saucerCtr&gt;=0;saucerCtr--){ //ConsoleLog.log("saucer: " + saucerCtr); tempSaucer = saucers[saucerCtr]; context.save(); //save current state in stack var sourceX = 0; var sourceY = 0; context.drawImage(saucerTiles, sourceX, sourceY, 30,15, tempSaucer.x,tempSaucer.y,30,15); context.restore(); //pop old state on to screen }
 }
 function renderSaucerMissiles() { var tempSaucerMissile = {}; var saucerMissileLength = saucerMissiles.length-1; //ConsoleLog.log("saucerMissiles= " + saucerMissiles.length) for (var saucerMissileCtr=saucerMissileLength;saucerMissileCtr&gt;=0; saucerMissileCtr--){ //ConsoleLog.log("draw player missile " + playerMissileCtr) tempSaucerMissile = saucerMissiles[saucerMissileCtr]; context.save(); //save current state in stack var sourceX = Math.floor(0 % 4) * tempSaucerMissile.width; var sourceY = Math.floor(0 / 4) * tempSaucerMissile.height;
 context.drawImage(particleTiles, sourceX, sourceY, tempSaucerMissile.width,tempSaucerMissile.height, tempSaucerMissile.x,tempSaucerMissile.y,tempSaucerMissile.width, tempSaucerMissile.height); context.restore(); //pop old state on to screen
 }
 }
 function renderParticles() { var tempParticle = {}; var particleLength = particles.length-1; for (var particleCtr=particleLength;particleCtr&gt;=0;particleCtr--){ tempParticle = particles[particleCtr]; context.save(); //save current state in stack var tile;
 //console.log("part type=" + tempParticle.type) switch(tempParticle.type){ case 0: // saucer tile = 0; break; case 1: //large rock tile = 2 break; case 2: //medium rock tile = 3; break; case 3: //small rock tile = 0; break; case 4: //player tile = 1; break;
 } var sourceX = Math.floor(tile % 4) * tempParticle.width; var sourceY = Math.floor(tile / 4) * tempParticle.height;
 context.drawImage(particleTiles, sourceX, sourceY, tempParticle.width,tempParticle.height,tempParticle.x, tempParticle.y,tempParticle.width,tempParticle.height);
 context.restore(); //pop old state on to screen
 } }
 function checkCollisions() {
 //loop through rocks then missiles. 
//There will always be rocks and a ship, //but there will not always be missiles. 

var tempRock = {}; var rocksLength = rocks.length-1; var tempPlayerMissile = {}; var playerMissileLength = playerMissiles.length-1; var saucerLength = saucers.length-1; var tempSaucer = {}; var saucerMissileLength = saucerMissiles.length-1;
 rocks: for (var rockCtr=rocksLength;rockCtr&gt;=0;rockCtr--){ tempRock = rocks[rockCtr];
 missiles:for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){ tempPlayerMissile = playerMissiles[playerMissileCtr];
 if (boundingBoxCollide(tempRock,tempPlayerMissile)){ //ConsoleLog.log("hit rock"); createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10,tempRock.scale); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); } addToScore(tempRock.scoreValue); playerMissiles.splice(playerMissileCtr,1); tempPlayerMissile = null; rocks.splice(rockCtr,1); tempRock = null;
 break rocks; break missiles; } }
 saucers:for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr];
 if (boundingBoxCollide(tempRock,tempSaucer)){ //ConsoleLog.log("hit rock"); createExplode(tempSaucer.x+tempSaucer.halfWidth, tempSaucer.y+tempSaucer.halfHeight,10,0); createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10,tempRock.scale); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); }
 saucers.splice(saucerCtr,1); tempSaucer = null;
 rocks.splice(rockCtr,1); tempRock = null;
 break rocks; break saucers; } } //saucer missiles against rocks //this is done here so we don't have to loop through //rocks again as it would probably //be the biggest array saucerMissiles:for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){ tempSaucerMissile = saucerMissiles[saucerMissileCtr]; if (boundingBoxCollide(tempRock,tempSaucerMissile)){ //ConsoleLog.log("hit rock");
 createExplode(tempRock.x+tempRock.halfWidth, tempRock.y+tempRock.halfHeight,10,tempRock.scale); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); }
 saucerMissiles.splice(saucerCtr,1); tempSaucerMissile = null;
 rocks.splice(rockCtr,1); tempRock = null; break rocks; break saucerMissiles; } }
 //check player against rocks if (boundingBoxCollide(tempRock,player) &amp;&amp; player.safe==false){ //ConsoleLog.log("hit player"); createExplode(tempRock.x+tempRock.halfWidth, tempRock.halfHeight,10,tempRock.scale); addToScore(tempRock.scoreValue); if (tempRock.scale&lt;3) { splitRock(tempRock.scale+1, tempRock.x, tempRock.y); } rocks.splice(rockCtr,1); tempRock=null;
 playerDie(); } }
 //now check player against saucers and then saucers against player missiles //and finally player against saucer missiles playerMissileLength = playerMissiles.length-1; saucerLength = saucers.length-1; saucers:for (var saucerCtr=saucerLength;saucerCtr&gt;=0;saucerCtr--){ tempSaucer = saucers[saucerCtr];
 missiles:for (var playerMissileCtr=playerMissileLength; playerMissileCtr&gt;=0;playerMissileCtr--){
 tempPlayerMissile = playerMissiles[playerMissileCtr]; if (boundingBoxCollide(tempSaucer,tempPlayerMissile)){ //ConsoleLog.log("hit rock"); createExplode(tempSaucer.x+tempSaucer.halfWidth, tempSaucer.y+tempSaucer.halfHeight,10,0); addToScore(tempSaucer.scoreValue);
 playerMissiles.splice(playerMissileCtr,1); tempPlayerMissile = null;
 saucers.splice(saucerCtr,1); tempSaucer = null;
 break saucers; break missiles; } } //player against saucers if (boundingBoxCollide(tempSaucer,player) &amp; player.safe==false){ ConsoleLog.log("hit player"); createExplode(tempSaucer.x+16,tempSaucer.y+16,10,tempRock.scale); addToScore(tempSaucer.scoreValue);
 saucers.splice(rockCtr,1); tempSaucer = null;
 playerDie(); } }
 //saucerMissiles against player saucerMissileLength = saucerMissiles.length-1; saucerMissiles:for (var saucerMissileCtr=saucerMissileLength; saucerMissileCtr&gt;=0;saucerMissileCtr--){
 tempSaucerMissile = saucerMissiles[saucerMissileCtr];
 if (boundingBoxCollide(player,tempSaucerMissile) &amp; player.safe==false){ ConsoleLog.log("saucer missile hit player");
 playerDie(); saucerMissiles.splice(saucerCtr,1); tempSaucerMissile = null; break saucerMissiles; } }
 }
 function firePlayerMissile(){
 //ConsoleLog.log("fire playerMissile"); var newPlayerMissile = {}; newPlayerMissile.dx = 5*Math.cos(Math.PI*(player.rotation)/180); newPlayerMissile.dy = 5*Math.sin(Math.PI*(player.rotation)/180); newPlayerMissile.x = player.x+player.halfWidth; newPlayerMissile.y = player.y+player.halfHeight; newPlayerMissile.life = 60; newPlayerMissile.lifeCtr = 0; newPlayerMissile.width = 2; newPlayerMissile.height = 2; newPlayerMissile.hitHeight = 2; newPlayerMissile.hitWidth = 2; playerMissiles.push(newPlayerMissile); }
 function fireSaucerMissile(saucer) { var newSaucerMissile = {}; newSaucerMissile.x = saucer.x+.5*saucer.width; newSaucerMissile.y = saucer.y+.5*saucer.height; newSaucerMissile.width = 2; newSaucerMissile.height = 2; newSaucerMissile.hitHeight = 2; newSaucerMissile.hitWidth = 2; newSaucerMissile.speed = saucer.missileSpeed;
 //ConsoleLog.log("saucer fire"); //fire at player from small saucer var diffx = player.x-saucer.x; var diffy = player.y-saucer.y; var radians = Math.atan2(diffy, diffx); var degrees = 360 * radians / (2 * Math.PI); newSaucerMissile.dx = saucer.missileSpeed*Math.cos(Math.PI*(degrees)/180); newSaucerMissile.dy = saucer.missileSpeed*Math.sin(Math.PI*(degrees)/180); newSaucerMissile.life = 160; newSaucerMissile.lifeCtr = 0; saucerMissiles.push(newSaucerMissile);
 } function playerDie() {
 ConsoleLog.log("player die"); createExplode(player.x+player.halfWidth, player.y+player.halfWidth,50,4); resetPlayer(); switchGameState(GAME_STATE_PLAYER_DIE);
 }
 function createExplode(x,y,num,type) { playSound(SOUND_EXPLODE,.5); for (var partCtr=0;partCtr&lt;num;partCtr++){ if (particlePool.length &gt; 0){
 newParticle = particlePool.pop(); newParticle.dx = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dx *= -1; } newParticle.dy = Math.random()*3; if (Math.random()&lt;.5){ newParticle.dy *= -1; }
 newParticle.life = Math.floor(Math.random()*30+30); newParticle.lifeCtr = 0; newParticle.x = x; newParticle.width = 2; newParticle.height = 2; newParticle.y = y; newParticle.type = type; //ConsoleLog.log("newParticle.life=" + newParticle.life); particles.push(newParticle); }
 } }
 function boundingBoxCollide(object1, object2) {
 var left1 = object1.x; var left2 = object2.x; var right1 = object1.x + object1.hitWidth; var right2 = object2.x + object2.hitWidth; var top1 = object1.y; var top2 = object2.y; var bottom1 = object1.y + object1.hitHeight; var bottom2 = object2.y + object2.hitHeight;
 if (bottom1 &lt; top2) return(false); if (top1 &gt; bottom2) return(false); if (right1 &lt; left2) return(false); if (left1 &gt; right2) return(false);
 return(true);
 };
 function splitRock(scale,x,y){ for (var newRockctr=0;newRockctr&lt;2;newRockctr++){ var newRock = {}; //ConsoleLog.log("split rock"); if (scale==2){ newRock.scoreValue = medRockScore; newRock.width = 32; newRock.height = 32; newRock.halfWidth = 16; newRock.halfHeight = 16; newRock.hitWidth = 24; newRock.hitHeight = 24;
 }else { newRock.scoreValue = smlRockScore; newRock.width = 24; newRock.height = 24; newRock.halfWidth = 12; newRock.halfHeight = 12; newRock.hitWidth = 16; newRock.hitHeight = 16; }
 newRock.scale = scale; newRock.x = x; newRock.y = y; newRock.dx = Math.random()*3; if (Math.random()&lt;.5){ newRock.dx *= -1; } newRock.dy = Math.random()*3; if (Math.random()&lt;.5){ newRock.dy *= -1; } if (Math.random()&lt;.5){ newRock.rotationInc = -1; }else{ newRock.rotationInc = 1; }
 newRock.animationDelay = Math.floor(Math.random()*3+1); newRock.animationCount = 0; newRock.rotation = 0; ConsoleLog.log("new rock scale"+(newRock.scale)); rocks.push(newRock);
 }
 }
 function addToScore(value){ score += value; }
 document.onkeydown = function(e){
 e = e?e:window.event; //ConsoleLog.log(e.keyCode + "down"); keyPressList[e.keyCode] = true;
 } document.onkeyup = function(e){
 //document.body.onkeyup = function(e){ e = e?e:window.event; //ConsoleLog.log(e.keyCode + "up"); keyPressList[e.keyCode] = false;
 };
 //*** application start switchGameState(GAME_STATE_INIT); const FRAME_RATE = 40; frameRateCounter = new FrameRateCounter(FRAME_RATE); //**** application loop var intervalTime = 1000/FRAME_RATE; setInterval(runGame, intervalTime );
}
//***** object prototypes *****
//*** consoleLog util object

//create constructor
function ConsoleLog(){
}
//create function that will be added to the class

console_log = function(message) {
 if(typeof(console) !== 'undefined' &amp;&amp; console != null) { console.log(message);
 }
}

//add class/static function to class by assignment
ConsoleLog.log = console_log;
//*** end console log object
//*** new FrameRateCounter object prototype

function FrameRateCounter(fps) {
 if (fps == undefined){
 this.fps = 40
 }else{ this.fps = fps }
 this.lastFrameCount = 0;
 var dateTemp = new Date();
 this.frameLast = dateTemp.getTime(); delete dateTemp;
 this.frameCtr = 0;
 this.lastTime = dateTemp.getTime();
 this.step = 1;

}
FrameRateCounter.prototype.countFrames = function() {
 var dateTemp = new Date();
 var timeDifference = dateTemp.getTime()-this.lastTime; this.step = (timeDifference/1000)*this.fps;
 this.lastTime = dateTemp.getTime();
 this.frameCtr++;
 if (dateTemp.getTime() &gt;=this.frameLast+1000) { ConsoleLog.log("frame event"); this.lastFrameCount = this.frameCtr; this.frameCtr = 0; this.frameLast = dateTemp.getTime(); }
 delete dateTemp;
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="400" height="400"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h2>Creating a Dynamic Tile Sheet at Runtime</h2>
In <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, we briefly examined two principles we can use to help eliminate the need to precreate rotations of objects in tile sheets. 

Creating these types of tile sheets can be cumbersome and use up valuable time that’s better spent elsewhere in the project.
The idea will be to take a single image of a game object (e.g., the first tile in the medium rock tile sheet), create a “dynamic tile sheet” at runtime, and store it in an array rather than using the prerendered image rotation tiles.
To accomplish this, we need to make use of a second canvas, as well as the <code>getImageData()</code> and <code>putImageData()</code> Canvas functions. 
If you recall from <a href="ch04.html" title="Chapter 4. 

Images on the Canvas">Chapter 4</a>, <code>getImageData()</code> will throw a security error if the HTML page using it is not on a web server.
Currently, only the Safari browser will not throw this error if the file is used on a local filesystem. 
For this reason, we have separated this functionality from the <em>Geo Blaster Extended</em> game and will simply demonstrate how it could be used instead of replacing all the tile sheets in the game with this type of prerendering.
We will start by creating two <code>&lt;canvas&gt;</code> elements on our HTML page:

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="256" height="256" style="position: absolute; top: 
50px; left: 50px;"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;canvas width="32" height="32" style="position: absolute; top: 
 256px; left: 50px;"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;
&lt;/body&gt;

The first <code>&lt;canvas&gt;</code>, named <code>canvas</code>, will represent our hypothetical game screen, which will be used to display the precached dynamic tile sheet animation.
The second <code>&lt;canvas&gt;</code>, named <code>canvas2</code>, will be used as a drawing surface to create the dynamic tile frames for our tile sheet.
We will need to separate context instances in the JavaScript, one for each <code>&lt;canvas&gt;</code>:
var theCanvas = document.getElementById("canvas");

var context = theCanvas.getContext("2d");
var theCanvas2 = document.getElementById("canvas2");
var context2= theCanvas2.getContext("2d");
We will use the <em>mediumrocks.png</em> file (<a href="ch09.html#the_mediumrocks.png_tile_sheet-id1" title="Figure 9-9. 

The mediumrocks.png tile sheet">Figure 9-9</a>) from the <em>Geo Blaster Extended</em> game as our source for the dynamic tile sheet. 
Don’t let this confuse you. 
We are not going to use all five tiles on this tile sheet—only the first tile.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893837.png.jpg" alt="The mediumrocks.png tile sheet" width="152" height="31">

Figure 9-9. 
The mediumrocks.png tile sheet
In <em>Geo Blaster Extended</em>, we used all five tiles to create a simulated rotation animation. 
Here, we will only use the first tile. 

We will draw this first tile and rotate it on <code>the</code><code>Canvas2</code> by <code>10</code> degrees, and then copy the current <code>imageData</code> pixels from this canvas to an array of <code>imageData</code> instances, called <code>rotationImageArray</code>.
We will then repeat this process by rotating <code>theCanvas2</code> by <code>10</code> more degrees and in a loop until we have 36 individual frames of <code>imageData</code> representing the rotation animation for our medium rock in an array:
var rotationImageArray = [];
var animationFrame = 0;

var tileSheet = new Image();
tileSheet.addEventListener('load', eventSheetLoaded , false);
tileSheet.src = "mediumrocks.png";
The <code>rotationImageArray</code> variable will hold the generated <code>imageData</code> instances, which we will create by using a rotation transformation on <code>theCanvas2</code>.

The <code>animationFrame</code> is used when redisplaying the rotation animation frames in <code>rotationImageArray</code> back to the first <code>theCanvas</code> to demo the animation.
When the <code>tileSheet</code> is loaded, the <code>eventSheetLoaded()</code> function is called, which in turn calls the <code>startup()</code> function. 
The <code>startup()</code> function will use a loop to create the 36 frames of animation:
function startUp(){ for (var ctr=0;ctr&lt;360;ctr+=10){ context2.fillStyle = "#ffffff"; context2.fillRect(0,0,32,32); context2.save(); context2.setTransform(1,0,0,1,0,0) var angleInRadians = ctr * Math.PI / 180; context2.translate(16, 16); context2.rotate(angleInRadians); context2.drawImage(tileSheet, 0, 0,32,32,-16,-16,32,32); context2.restore(); var imagedata = context2.getImageData(0, 0, 32, 32) rotationImageArray.push(imagedata);
 }
 setInterval(drawScreen, 100 );
}

This loop first clears <code>theCanvas2</code> with a white color, and then saves it to the stack. 
We then translate to the center of our object and rotate the canvas by the current <code>ctr</code> value (an increment of <code>10</code>). 
Next, we draw the first tile from <em>mediumrocks.png</em> and save the result into a new local <code>imageData</code> instance using the <code>getImageData()</code> function.
<h3>Note</h3>

This is the place where the security error will be thrown if the domain of the image and the domain of the HTML file are not the same. 
On a local machine (not running on a local web server, but from the filesystem), this error will be thrown on all browsers but Safari (currently).
Finally, the new <code>imageData</code> is pushed into the <code>rotationImageArray</code>. 
When the loop is complete, we set up an interval to run and call the <code>drawScreen()</code> function every 100 milliseconds.

To display the animation on the first canvas, we use this timer loop interval and call <code>putImageData()</code> to draw each frame in succession, creating the simulation of animation. 
As with the tile sheet, we didn’t have to use 36 frames of animation, we could use just five. 
Naturally, the animation is much smoother with more frames. 
But this process shows how easy it is to create simple transformation animations “on the fly” rather than precreating them in image files:

function drawScreen() {
 //context.fillStyle = "#ffffff"; //context.fillRect(50,50,32,32); context.putImageData(rotationImageArray[animationFrame],50,50); animationFrame++; if (animationFrame ==rotationImageArray.length){ animationFrame=0; }
}
Example 9-2</a> shows the entire code.

Example 9-2. 
A dynamic tile sheet example
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH9EX2: Canvas Copy&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp(){ if (!canvasSupport()) { return; }else{ var theCanvas = document.getElementById("canvas"); var context = theCanvas.getContext("2d");
 var theCanvas2 = document.getElementById("canvas2"); var context2= theCanvas2.getContext("2d");
 }
 var rotationImageArray = [] var tileSheet = new Image();
 var animationFrame = 0;
 tileSheet.addEventListener('load', eventSheetLoaded , false);
 tileSheet.src = "mediumrocks.png"; function eventSheetLoaded() { startUp();
 }
 function startUp(){ //context.drawImage(tileSheet, 0, 0); //context2.drawImage(theCanvas, 0, 0,32,32,0,0,32,32);
 for (var ctr=0;ctr&lt;360;ctr+=10){ context2.fillStyle="#ffffff"; context2.fillRect(0,0,32,32); context2.save(); context2.setTransform(1,0,0,1,0,0) var angleInRadians = ctr * Math.PI / 180; context2.translate(16, 16) context2.rotate(angleInRadians); context2.drawImage(tileSheet, 0, 0,32,32,-16,-16,32,32); context2.restore();
 var imagedata = context2.getImageData(0, 0, 32, 32);
 rotationImageArray.push(imagedata); } setInterval(drawScreen, 100 );
 } function drawScreen() { //context.fillStyle="#ffffff"; //context.fillRect(50,50,32,32); context.putImageData(rotationImageArray[animationFrame],50,50); animationFrame++; if (animationFrame ==rotationImageArray.length){ animationFrame = 0; }
 }
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="256" height="256" style="position: absolute; top:  50px; left: 50px;"&gt;
 Your browser does not support the HTML 5 Canvas.
&lt;/canvas&gt;
&lt;canvas width="32" height="32" style="position: absolute; top:  256px; left: 50px;"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
In the rest of the chapter, we will look at creating a simple tile-based game using some of the techniques first discussed in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>.

<h2>A Simple Tile-Based Game</h2>
Let’s move from <em>Asteroids</em> to another classic game genre, the tile-based maze-chase game. 
When you’re discussing early tile-based games, undoubtedly <em>Pac-Man</em> enters the conversation. 
<em>Pac-Man</em> was one of the first commercially successful tile-based games, although it certainly was not the first of its kind. 

The maze-chase genre was actually well covered by budding game developers before microcomputers were even thought possible. 
Many minicomputer and mainframe tile-based games, such as <em>Daleks</em>, were crafted in the ’60s and ’70s. 
In this section, we will create a simple turn-based maze-chase game. 
Our game, <em>Micro Tank Maze</em>, will be based loosely on <em>Daleks</em>, but we will use the tank sprites from <a href="ch04.html" title="Chapter 4. 

Images on the Canvas">Chapter 4</a>. 
<a href="ch09.html#micro_tank_maze_in_action" title="Figure 9-10. 
Micro Tank Maze in action">Figure 9-10</a> is a screenshot from the finished game.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893839.png" alt="Micro Tank Maze in action" width="480" height="480">

Figure 9-10. 
Micro Tank Maze in action
<h3>Micro Tank Maze Description</h3>
<em>Micro Tank Maze</em> is a simple turn-based strategy game played on a 15×15 tile-based grid. 

At the beginning of each game, the player (the green tank), 20 enemy tanks (the blue tanks), 25 wall tiles, and a single goal tile (the phoenix) are randomly placed on the grid. 
The rest of the grid is simply “road” tiles on which the tanks move. 
The player is tasked with getting to the goal object without running into any walls or any of the enemy tanks. 
On each turn, the player and all enemy tanks will move a single space (tile) on the grid. 

Neither the player nor the enemy tanks can move off the grid edges. 
If the player runs into a wall tile or an enemy tank, his game is over. 
If an enemy tank runs into a wall or another tank, it is destroyed and removed from the game board. 
If an enemy tank runs into the player tank, it and the player are destroyed. 

If the player hits the goal tile without an enemy tank also hitting the tile on the same turn, the player wins.
<h4>Game progression</h4>
Each time the player collects the goal object and wins the game, the next game will start with one more enemy tank (up to 50 enemy tanks). 
The ultimate goal of the game is to see how many times you (the player) can win before your tank is finally destroyed. 

The game will keep a session-based high score, and even if you lose, you always start from the last completed level.
This is a simple game, and much more can be added to it to enhance the gaming experience. 
In this chapter, though, we want to cover the basics of creating a tile-based game on HTML5 Canvas. 
By combining what we have learned throughout this book, you should have enough skill and knowledge to extend this simple contest into a much more robust game-play experience.

<h4>Game strategy</h4>
The player must try to reach the goal while avoiding the enemy tanks. 
The enemy will follow or chase the player to a fault. 
Most of the time (75%), each enemy tank will stupidly follow the player, even if that means moving into a wall and destroying itself. 

The player then has the advantage of intelligence to compensate for the large number of tanks the enemy employs. 
The other 25% of the time, an enemy tank will randomly choose a direction to move in.
Now, let’s get into the game by looking at the tile sheet we will be using.
<h3>The Tile Sheet for Our Game</h3>

Make sure you’ve read <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a> and the <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a> section A Basic Game Framework</a> before moving on. 
Even though <em>Micro Tank Maze</em> is a relatively simple game, it is still quite a few lines of code. 

We’ll hit the major points, but we don’t have space to discuss every detail.
The tile sheet (<em>tanks_sheet.png</em>) we are going to use will look very familiar if you’ve read <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>. 
<a href="ch09.html#the_micro_tank_maze_tile_sheet" title="Figure 9-11. 

The Micro Tank Maze tile sheet">Figure 9-11</a> shows <em>tanks_sheet.png</em>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893841.png" alt="The Micro Tank Maze tile sheet" width="256" height="128">
Figure 9-11. 
The Micro Tank Maze tile sheet

We will be using only a very small portion of these tiles for <em>Micro Tank Maze</em>.
Road tile

This is the tile on which the player and the enemy tanks can move. 
Tile 0, the road tile, is in the top-left corner.
Wall tile

The wall tile will cause any tank moving on it to be destroyed. 
Tile 30, the second to last tile on the sheet, will be the wall tile.

Goal tile
This is the tile the player must reach to win the game. 
It is the last tile in the second to last row (the phoenix).

Player tiles
The player will be made up of the first eight green tank tiles. 

Each tile will be used to simulate the tank treads moving from tile to tile.
Enemy tiles

The enemy will be made up of the second eight blue tank tiles. 
These tiles will be used to animate the tank treads as it moves from tile to tile.

Our game code will store the tile ids needed for each of these game objects in application scope variables:
var playerTiles = [1,2,3,4,5,6,7,8];
var enemyTiles = [9,10,11,12,13,14,15,16];
var roadTile = 0;

var wallTile = 30;
var goalTile = 23;
var explodeTiles = [17,18,19,18,17];
The tile sheet will be loaded into an application scope <code>Image</code> instance and given the name <code>tileSheet</code>:

var tileSheet;
In the application’s initialization state, we will load in and assign the <code>Image</code> instance:
tileSheet = new Image();
tileSheet.src = "tanks_sheet.png";

Next, we will examine the setup of the game playfield.
<h3>The Playfield</h3>
The game playfield will be a 15×15 grid of 32×32 tiles. 
This is a total of 225 tiles with a width and height of 480 pixels each. 

Every time we start a new game, all the objects will be placed randomly onto the grid. 
The <code>playField[]</code> array will hold <code>15</code> row arrays each with <code>15</code> columns. 
This gives us 225 tiles that can be easily accessed with the simple <code>playField[row][col]</code> syntax.
<h4>Creating the board</h4>

We will first place a road tile on each of the 225 <code>playField</code> array locations. 
We then randomly place all of the wall tiles (these will actually replace some of the road tiles at locations in the <code>playField</code> array).
Next, we randomly place all of the enemy tank tiles. 
Unlike the wall tiles, the tank tiles will <em>not</em> replace road tiles in the <code>playField</code> array. 

Instead, they will be placed into an array of their own called <code>enemy</code>. 
To ensure that neither the player nor the goal object occupies the same tile space as the enemy tanks, we will create another array called <code>items</code>.
The <code>items</code> array will also be a 15×15 two-dimensional array of rows and columns, which can be considered the “second” layer of playfield data. 
Unlike the <code>playField</code> array, it will only be used to make sure no two objects (player, enemy, or goal) occupy the same space while building the playfield. 

We must do this because the player and enemy objects are not added to the <code>playField</code> array.
Once we have placed the enemy, we will randomly place the player at a spot that is not currently occupied by an enemy or a wall. 
Finally, we will place the goal tile in a spot not taken by the player, a wall, or an enemy tank.
The code for this will be in the <code>createPlayField()</code> function. 

If you would like to review it now, go to the section Micro Tank Maze Complete Game Code</a> (Example 9-3</a>).
All the data about the <code>playField</code> will be stored in application scope variables:
//playfield
var playField = [];

var items = [];
var xMin = 0;
var xMax = 480;
var yMin = 0;

var yMax = 480;
To create the <code>playField</code>, the game code will need to know the maximum number of each type of tile. 
These will also be application scope variables:
var wallMax = 20;

var playerMax = 1;
var enemyMax = 20;
var goalMax = 1;
<h3>The Player</h3>

The player and all of its current attributes will be contained in the <code>player</code> object. 
Even a game as simple as <em>Micro Tank Maze</em> requires quite a few attributes. 
Here is a list and description of each:

<code>player.row</code>
The current row on the 15×15 <code>playField</code> grid where the player resides.

<code>player.col</code>
The current column on the 15×15 <code>playField</code> grid where the player resides.

<code>player.nextRow</code>
The row the player will move to next, after a successful key press in that direction.

<code>player.nextCol</code>
The column the player will move to next, after a successful key press in that direction.

<code>player.currentTile</code>
The id of the current tile used to display the player from the <code>playerTiles</code> array.

<code>player.rotation</code>
The player starts pointed up, so this will be the 0 rotation. 
When the player moves in one of the four basic directions, this rotation will change and will be used to move the player in the direction it is facing.

<code>player.speed</code>
The number of pixels the <code>player</code> object will move on each frame tick.

<code>player.destinationX</code>
The final <code>x</code> location for the 32×32 <code>player</code> object while it is moving to a new tile. 

It represents the top-left corner <code>x</code> location for this new location. 
During the player movement and animation phase of the game, this value determines when the player has arrived at its new x-axis location.
<code>player.destinationY</code>

The final <code>y</code> location for the 32×32 <code>player</code> object while it is moving to a new tile. 
It represents the top-left corner <code>y</code> location for this new location. 
During the player movement and animation phase of the game, this value determines when the player has arrived at its new y-axis location.

<code>player.x</code>
The current <code>x</code> location of the top-left corner of the 32×32 player object.

<code>player.y</code>
The current <code>y</code> location of the top-left corner of the 32×32 player object.

<code>player.dx</code>
The player’s change in <code>x</code> direction on each frame tick while it is animating. 

This will be <code>-1</code>, <code>0</code>, or <code>1</code>, depending on the direction in which the player is moving.
<code>player.dy</code>

The player’s change in <code>y</code> direction on each frame tick while it is animating. 
This will be <code>-1</code>, <code>0</code>, or <code>1</code>, depending on the direction in which the player is moving.
<code>player.hit</code>

Set to <code>true</code> when the player moves to a new square that is occupied by an enemy tank or a wall.
<code>player.dead</code>

When <code>player.hit</code> is <code>true</code>, it will be replaced on the <code>playField</code> by an explosion sprite. 
With <code>dead</code> set to <code>true</code>, it will not be rendered to the game screen.

<code>player.win</code>
Set to <code>true</code> if the player collects the goal object.

The enemy and the player share many of the same attributes, as they both use the same type of calculations to move about the grid. 
Now let’s examine how the enemy object is constructed.
<h3>The Enemy</h3>

Each <code>enemy</code> object will have its own set of attributes that are very similar to those of the player. 
Like the player, each enemy will be an object instance.
Here is the code from the <code>createPlayField()</code> function that sets up the attributes for a new <code>enemy</code> object:
EnemyLocationFound = true;

var tempEnemy = {};
tempEnemy.row = randRow;
tempEnemy.col = randCol;
tempEnemy.nextRow = 0;

tempEnemy.nextCol = 0;
tempEnemy.currentTile = 0;
tempEnemy.rotation = 0;
tempEnemy.x = tempEnemy.col*32;

tempEnemy.y = tempEnemy.row*32;
tempEnemy.speed = 2;
tempEnemy.destinationX = 0;
tempEnemy.destinationY = 0;

tempEnemy.dx = 0;
tempEnemy.dy = 0;
tempEnemy.hit = false;
tempEnemy.dead = false;

tempEnemy.moveComplete = false;
enemy.push(tempEnemy);
items[randRow][randCol] = 1;
There are a couple extra things worth pointing out in this code. 

The first is that each <code>enemy</code> object needs an attribute called <code>moveComplete</code>. 
This is used in the <code>animate</code><code>Enemy()</code> game state function. 
When the entire enemy battalion has moved to its new location, the game will transition to the next game state. 
This is discussed in detail in the next section </a>.

Also, notice that the new <code>enemy</code> objects are added to the <code>enemy</code> array, as well as to the <code>items</code> multidimensional array. 
This ensures that the player and the goal cannot be placed on to an enemy location. 
Once the enemy moves from its initial location, the <code>playField</code> array will still have a road tile to show in its place. 
We call the player and the enemy “moving object” tiles because they can move about the game board. 

When they move, they must “uncover” the road tile in the spot they were in before moving.
Now let’s take a quick look at the goal tile to solidify your understanding of the difference between the <code>playField</code> and the moving object tiles.
<h3>The Goal</h3>
The tile id of the goal tile will be stored in the <code>playField</code> array along with the road and wall tiles. 

It is not considered a separate item because, unlike the <code>player</code> and <code>enemy</code> objects, it does not need to move. 
As we have described previously, since the enemy and player tiles move on top of the playfield, they are considered moving items and not part of the playfield.
<h3>The Explosions</h3>
The explosion tiles are unique. 

They will be rendered on top of the playfield when an enemy tank or the player’s <code>hit</code> attribute has been set to <code>true</code>. 
The explosion tiles will animate through a list of five tiles and then be removed from the game screen. 
Again, tiles for the explosion are set in the <code>explodeTiles</code> array:
var explodeTiles = [17,18,19,18,17];

Next, we will examine the entire game flow and state machine to give you an overall look at how the game logic is designed.
<h3>Turn-Based Game Flow and the State Machine</h3>
Our game logic and flow is separated into 16 discrete states. 
The entire application runs on a <code>40</code> frames per second interval timer:

switchGameState(GAME_STATE_INIT);
const FRAME_RATE = 40;
var intervalTime = 1000/FRAME_RATE;
setInterval(runGame, intervalTime )

As with the other games, in <a href="ch08.html" title="Chapter 8. 
Canvas Game Essentials">Chapter 8</a> and earlier in this chapter, we will use a function reference state machine to run our current game state. 
The <code>switchGameState()</code> function will be used to transition to a new game state. 
Let’s begin by discussing this function briefly, and then moving through the rest of the game functions.

<h3>Note</h3>
We will not reprint each line of code or dissect it in detail here. 
Use this section as a guide for perusing the entire set of game code included at the end of this chapter (in Example 9-3</a>). 
By now, you have seen most of the code and ideas used to create this game logic. 

We will break out the new ideas and code in the sections that follow.
<h4>GAME_STATE_INIT</h4>
This state loads in the assets we need for our game. 
We are loading in only a single tile sheet and no sounds for <em>Micro Tank Maze</em>.

After the initial load, it sends the state machine to the <code>GAME_STATE_WAIT_FOR_LOAD</code> state until the load event has occurred.
<h4>GAME_STATE_WAIT_FOR_LOAD</h4>
This state simply makes sure that all the items in <code>GAME_STATE_INIT</code> have loaded properly. 
It then sends the state machine to the <code>GAME_STATE_TITLE</code> state.

<h4>GAME_STATE_TITLE</h4>
This state shows the title screen and then waits for the space bar to be pressed. 
When this happens, it sends the state machine to <code>GAME_STATE_NEW_GAME</code>.
<h4>GAME_STATE_NEW_GAME</h4>

This state resets all of the game arrays and objects and then calls the <code>createPlayField()</code> function. 
The <code>createPlayField()</code> function creates the <code>playField</code> and <code>enemy</code> arrays for the new game, as well as sets the <code>player</code> object’s starting location. 
Once it has finished, it calls the <code>renderPlayField()</code> function a single time to display the initial board on the game screen.
Once this completes, the state machine is now ready to start the real game loop. 

This is done by moving the game state machine to the <code>GAME_STATE_WAIT_FOR_PLAYER_MOVE</code> state.
<h4>GAME_STATE_WAIT_FOR_PLAYER_MOVE</h4>
This state waits for the player to press one of the four arrow buttons. 
Once the player has done so, the switch statement checks to see which arrow was pressed. 

Based on the direction pressed, the <code>checkBounds()</code> function is called.
<h3>Note</h3>
This state contains a bit of the new code for tile movement logic that we have not seen previously in this book. 
See the upcoming section Simple Tile Movement Logic Overview</a> for more details on these concepts.

The <code>checkBounds()</code> function accepts in three parameters:
The number to increment the row the player is currently in

The number to increment the column the player is currently in
The object being tested (either the player or one of the enemy tanks)

The sole purpose of this function is to determine whether the object being tested can move in the desired direction. 
In this game, the only illegal moves are off the side of the screen. 
In games such as <em>Pac-Man</em>, this would check to make sure that the tile was not a wall tile. 
Our game does not do this because we want the player and the enemy objects to be able to move mistakenly onto the wall tiles (and be destroyed).

If a valid move is found for the player in the direction pressed, the <code>setPlayerDestination()</code> function is called. 
This function simply sets the <code>player.destinationX</code> and <code>player.destinationY</code> attributes based on the new tile location.
<code>checkBounds()</code> sets the <code>player.nextRow</code> and <code>player.nextCol</code> attributes. 
The <code>setPlayerDestination()</code> function multiplies the <code>player.nextRow</code> and the <code>player.nextCol</code> by the tile size (<code>32</code>) to determine the <code>player.destinationX</code> and <code>player.destinationY</code> attributes. 

These will be used to move the player to its new location.
<code>GAME_STATE_ANIMATE_PLAYER</code> is then set as the current game state.
<h4>GAME_STATE_ANIMATE_PLAYER</h4>
This function moves the player to its <code>destinationX</code> and <code>destinationY</code> locations. 

Since this is a turn-based game, we don’t have to do any other processing while this movement is occurring.
On each iteration, the <code>player.currentTile</code> is incremented by <code>1</code>. 
This will change the tile that is rendered to be the next tile in the <code>playerTiles</code> array. 
When <code>destinationX</code> and <code>destinationY</code> are equal to the <code>x</code> and <code>y</code> values for the player, the movement and animation stop, and the game state is changed to the <code>GAME_STATE_EVALUATE_PLAYER_MOVE</code> state.

<h4>GAME_STATE_EVALUATE_PLAYER_MOVE</h4>
Now that the player has been moved to the next tile, the <code>player.row</code> and <code>player.col</code> attributes are set to <code>player.nextRow</code> and <code>player.nextCol</code>, respectively.
Next, if the player is on a goal tile, the <code>player.win</code> attribute will be set to <code>true</code>. 
If the player is on a wall tile, the <code>player.hit</code> will be set to <code>true</code>.

We then loop though all of the <code>enemy</code> objects and see whether any occupy the same tile as the player. 
If they do, both the player and the enemy <code>hit</code> attributes are set to <code>true</code>.
Next, we move the game to the <code>GAME_STATE_ENEMY_MOVE</code> state.
<h4>GAME_STATE_ENEMY_MOVE</h4>

This state uses the homegrown chase AI—discussed in Simple Homegrown AI Overview</a>—to choose a direction in which to move each enemy tank. 
It does this by looping through all the tanks and applying the logic to them individually.
This function first uses a little tile-based math to determine where the player is in relation to an enemy tank. 
It then creates an array of directions to test based on these calculations. 

It stores these as string values in a variable called <code>directionsToTest</code>.
Next, it uses the <code>chanceRandomMovement</code> value (<code>25%</code>) to determine whether it will use the list of directions it just compiled, or whether it will throw them out and simply choose a random direction to move in.
In either case, it must check all of the available directions (either in the list of <code>directionsToMove</code> or in all four directions for random movement) to see which is the first that will not move the tank off the side of the screen.
Once it has the direction to move in, it sets the <code>destinationX</code> and <code>destinationY</code> values of the enemy tank using the same <code>tile size * x</code> and <code>tile size * y</code> trick used for the player.

Finally, it sets the game state to <code>GAME_STATE_ANIMATE_ENEMY</code>.
<h4>GAME_STATE_ANIMATE_ENEMY</h4>
Like <code>GAME_STATE_ANIMATE_PLAYER</code>, this state moves and animates the tank to its new location represented by its <code>destinationX</code> and <code>destinationY</code> values. 
It must do this for each of the enemy tanks, so it uses the <code>enemyMoveCompleteCount</code> variable to keep count of how many of the enemy tanks have finished their moves.

When all the enemy tanks have completed their moves, the game state is changed to the <code>GAME_STATE_EVALUATE_ENEMY_MOVE</code> state.
<h4>GAME_STATE_EVALUATE_ENEMY_MOVE</h4>
Like <code>GAME_STATE_EVALUATE_PLAYER_MOVE</code>, this state looks at the location of each tank to determine which ones need to be destroyed.
If a tank occupies the same tile as the player, a wall, or another tank, the tank is “to be destroyed”. 

If the player and enemy tank occupy the same tile, the player is also “to be destroyed”. 
This “to be destroyed” state is set by placing <code>true</code> in the <code>hit</code> attribute of the enemy tank or the player.
The game is then moved to the <code>GAME_STATE_EVALUATE_OUTCOME</code> state.
<h4>GAME_STATE_EVALUATE_OUTCOME</h4>

This function looks at each of the enemy tanks and the player tank to determine which have a <code>hit</code> attribute set to <code>true</code>. 
If any do, that tank’s <code>dead</code> attribute is set to <code>true</code>, and an explosion is created by calling <code>createExplode()</code> and passing in the object instance (player or enemy tank). 
In the case of the enemy, a <code>dead</code> enemy is also removed from the enemy array.
The <code>GAME_STATE_ANIMATE_EXPLODE</code> state is called next.

<h4>GAME_STATE_ANIMATE_EXPLODE</h4>
If the <code>explosions</code> array length is greater than <code>0</code>, this function loops through each instance and animates them using the <code>explodeTiles</code> array. 
Each explosion instance is removed from the <code>explosions</code> array after it finishes its animation. 
When the explosions array length is <code>0</code>, the game moves to the <code>GAME_STATE_CHECK_FOR_GAME_OVER</code> state.

<h4>GAME_STATE_CHECK_FOR_GAME_OVER</h4>
This state will first check to see whether the player is dead, and then check to see whether he has won. 
That means that the player cannot win if an enemy tank makes it to the goal on the same try as the player.
If the player has lost, the state changes to <code>GAME_STATE_PLAYER_LOSE</code>; if the player has won, it moves to the <code>GAME_STATE_PLAYER_WIN</code> state. 

If neither of those has occurred, the game is set to <code>GAME_STATE_WAIT_FOR_PLAYER_MOVE</code>. 
This starts the game loop iteration over, and the player begins her next turn.
<h4>GAME_STATE_PLAYER_WIN</h4>
If the player wins, the <code>maxEnemy</code> is increased for the next game. 

The player’s <code>score</code> is also checked against the current session high score to determine whether a new high score has been achieved. 
This state waits for a space bar press and then moves to the <code>GAME_STATE_NEW_GAME</code> state.
<h4>GAME_STATE_PLAYER_LOSE</h4>
The player’s score is checked against the current session high score to determine whether a new high score has been achieved. 

This state waits for a space bar press and then moves to the <code>GAME_STATE_NEW_GAME</code> state.
<h3>Simple Tile Movement Logic Overview</h3>
<em>Micro Tank Maze</em> employs simple tile-to-tile movement using the “center of a tile” logic. 
This logic relies on making calculations once the game character has reached the center of a tile. 

The origin point of our game character tiles is the top-left corner. 
Because of this, we can easily calculate that a game character is in the center of a tile when its <code>x</code> and <code>y</code> coordinates are equal to the destination tile’s <code>x</code> and <code>y</code> coordinates.
When the user presses a movement key (up, down, right, or left arrow), we first must check whether the player is trying to move to a “legal” tile on the <code>playField</code>. 
In <em>Micro Tank Maze</em>, all tiles are legal. 

The only illegal moves are off the edges of the board. 
So, if the player wants to move up, down, left, or right, we must first check the tile in that direction based on the key pressed in the <code>gameStateWaitForPlayerMove()</code> function. 
Here is the switch statement used to determine whether the player pressed an arrow key:
if (keyPressList[38]==true){ //up if (checkBounds(-1,0, player)){ setPlayerDestination(); } }else if (keyPressList[37]==true) { //left if (checkBounds(0,-1, player)){ setPlayerDestination(); } }else if (keyPressList[39]==true) { //right if (checkBounds(0,1, player)){ setPlayerDestination(); } }else if (keyPressList[40]==true){ //down if (checkBounds(1,0, player)){ setPlayerDestination(); } }

Notice that the <code>checkBounds()</code> function takes a <code>row</code> increment and then a <code>column</code> increment to test. 
It is important to note that we don’t access tiles in the same manner that we would access pixels on the screen. 
Tiles in the <code>playField</code> array are accessed by addressing the vertical (row) and then the horizontal (column) (using <code>[row][column]</code>, not <code>[column][row]</code>). 
This is because a simple array is organized into a set of rows. 

Each row has a set of 15 columns. 
Therefore, we do not access a tile in the <code>playField</code> using the <code>[horizontal][vertical]</code> coordinates. 
Instead, we use the <code>[row][column]</code> syntax that simple arrays use to powerful and elegant effect.
In the <code>checkBounds()</code> function, enter the <code>row</code> increment, then the column increment, and then the object to be tested. 

If this is a legal move, the <code>checkBounds()</code> function sets the <code>nextRow</code> and <code>nextCol</code> to be <code>row+rowInc</code> and <code>col+colInc</code>, respectively:
function checkBounds(rowInc, colInc, object){
 object.nextRow = object.row+rowInc;
 object.nextCol = object.col+colInc; if (object.nextCol &gt;=0 &amp;&amp; object.nextCol&lt;15 &amp;&amp; object.nextRow&gt;=0 &amp;&amp; object.nextRow&lt;15){ object.dx = colInc; object.dy = rowInc;
 if (colInc==1){ object.rotation = 90; }else if (colInc==-1){ object.rotation = 270; }else if (rowInc==-1){ object.rotation = 0; }else if (rowInc==1){ object.rotation = 180; }
 return(true);
 }else{ object.nextRow = object.row; object.nextCol = object.col; return(false); }
}
If the move is legal, the <code>dx</code> (delta, or change in <code>x</code>) and <code>dy</code> (delta, or change in <code>y</code>) are set to the <code>colInc</code> and <code>rowInc</code>, respectively.
The <code>animatePlayer()</code> function is called next. 

Its job is to move the <code>player</code> object to its new location while running through its animation frames. 
Here is the code from the <code>animatePlayer()</code> function:
player.x += player.dx*player.speed;
player.currentTile++;if (player.currentTile==playerTiles.length){ player.currentTile = 0;
}
renderPlayField();
if (player.x==player.destinationX &amp;&amp; player.y==player.destinationY){ switchGameState(GAME_STATE_EVALUATE_PLAYER_MOVE);
}
First, the <code>player</code> object’s <code>x</code> and <code>y</code> locations are increased by the <code>player.speed * player.dx</code> (or <code>dy</code>). 
The tile size is <code>32</code>, so we must use a speed value that is evenly divided into <code>32</code>. 

The values 1, 2, 4, 8, 16, and 32 are all valid.
This function also runs though the <code>playerTiles</code> array on each game loop iteration. 
This will render the tank tracks moving, simulating a smooth ride from one tile to the next.
Next, let’s take a closer look at how we render the <code>playField</code>.

<h3>Rendering Logic Overview</h3>
Each time the game renders objects to the screen, it runs through the entire <code>render()</code> function. 
It does this to ensure that even the nonmoving objects are rendered back to the game screen. 
The <code>render()</code> function looks like this:

function renderPlayField() {
 fillBackground();
 drawPlayField();
 drawPlayer(); drawEnemy();
 drawExplosions();
}
First, we draw the plain black background, then we draw the <code>playField</code>, and after that we draw the game objects. 

<code>drawPlayField()</code> draws the map of tiles to the game screen. 
This function is similar to the functions in <a href="ch04.html" title="Chapter 4. 
Images on the Canvas">Chapter 4</a>, but with some additions for our game. 
Let’s review how it is organized:

function drawPlayField(){
 for (rowCtr=0;rowCtr&lt;15;rowCtr++){
 for (colCtr=0;colCtr&lt;15;colCtr++) { var sourceX = Math.floor((playField[rowCtr][colCtr]) % 8) * 32; var sourceY = Math.floor((playField[rowCtr][colCtr]) /8) *32;
 if (playField[rowCtr][colCtr] != roadTile){ context.drawImage(tileSheet, 0, 0,32,32,colCtr*32,rowCtr*32,32,32); } context.drawImage(tileSheet, sourceX, sourceY, 32,32, colCtr*32,rowCtr*32,32,32); } } }
The <code>drawPlayField()</code> function loops through the rows in the <code>playField</code> array, and then through each column inside each row. 
If the tile id number at <code>playField[rowCtr][colCtr]</code> is a road tile, it simply paints that tile at the correct location on the <code>playField</code>. 
If the tile id is a game object (not a road tile), it first paints a road tile in that spot and then paints the object tile in that spot.

<h3>Simple Homegrown AI Overview</h3>
The enemy tanks chase the <code>player</code> object based on a set of simple rules. 
We have coded those rules into the <code>gameStateEnemyMove()</code> function, which is one of the longest and most complicated functions in this book. 
Let’s first step through the logic used to create the function, and then you can examine it in Example 9-3</a>.

This function starts by looping through the <code>enemy</code> array. 
It must determine a new tile location on which to move each enemy. 
To do so, it follows some simple rules that determine the order in which the <code>testBounds()</code> function will test the movement directions:
First, it tests to see whether the player is closer to the enemy vertically or horizontally.

If vertically, and the player is above the enemy, it places <code>up</code> and then <code>down</code> into the <code>directionsToTest</code> array.
If vertically, and the player is below the enemy, it places <code>down</code> and then <code>up</code> into the <code>directionsToTest</code> array.
<h3>Note</h3>
The <code>up</code> and then <code>down</code>, or <code>down</code> and then <code>up</code>, directions are pushed into the <code>directionsTest</code> array to simplify the AI. 

The logic here is if the player is “up” from the enemy, but the enemy is blocked by an object, the enemy will try the opposite direction first. 
In our game, there will be no instance where an object blocks the direction the enemy tank wants to move in. 
This is because the only illegal direction is trying to move off the bounds of the screen. 
If we add tiles to our playfield that “block” the enemy, this entire set of AI code suddenly becomes very useful and necessary. 

We have included this entire “homegrown chase AI” in our game in case more of these tile types are added.
It then looks to see where to add the <code>left</code> and <code>right</code> directions. 
It does this based on which way will put it closer to the player.
If the horizontal direction and not the vertical direction is the shortest, it runs through the same type of logic, but this time using <code>left</code> and then <code>right</code>, then <code>up</code> and then <code>down</code>.

When this is complete, all four directions will be in the <code>directionsToTest</code> array.
</li>
</ol>
Next, the logic finds a number between <code>0</code> and <code>99</code>, and checks to see whether it is less than the <code>chanceRandomEnemyMovement</code> value. 

If it is, it will ignore the <code>directionsToTest</code> array and simply try to find a random direction to move in. 
In either case, all the directions (either in the <code>directionsToTest</code> array or in order up, down, left, and right) are tested until the <code>testBounds()</code> function returns <code>true</code>.
That’s all there is to this code. 
In Example 9-3</a>, you will find the entire set of code for this game.

<h3>Micro Tank Maze Complete Game Code</h3>
Example 9-3. 
Micro Tank Maze full source code listing
 &lt;!doctype html&gt;

&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH(EX3: Micro Tank Maze Game&lt;/title&gt;

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
window.addEventListener('load', eventWindowLoaded, false);
function eventWindowLoaded() { canvasApp();
}
function canvasSupport () {
return Modernizr.canvas;

}
function canvasApp(){
 if (!canvasSupport()) { return; }else{ theCanvas = document.getElementById("canvas"); context = theCanvas.getContext("2d");
 } //application states const GAME_STATE_INIT = 0;
 const GAME_STATE_WAIT_FOR_LOAD = 10;
 const GAME_STATE_TITLE = 20; const GAME_STATE_NEW_GAME = 30;
 const GAME_STATE_WAIT_FOR_PLAYER_MOVE = 40;
 const GAME_STATE_ANIMATE_PLAYER = 50;
 const GAME_STATE_EVALUATE_PLAYER_MOVE = 60; const GAME_STATE_ENEMY_MOVE = 70;
 const GAME_STATE_ANIMATE_ENEMY = 80;
 const GAME_STATE_EVALUATE_ENEMY_MOVE = 90;
 const GAME_STATE_EVALUATE_OUTCOME = 100; const GAME_STATE_ANIMATE_EXPLODE = 110;
 const GAME_STATE_CHECK_FOR_GAME_OVER = 120;
 const GAME_STATE_PLAYER_WIN = 130;
 const GAME_STATE_PLAYER_LOSE = 140; const GAME_STATE_GAME_OVER = 150;
 var currentGameState = 0;
 var currentGameStateFunction = null;
 //loading var loadCount = 0;
 var itemsToLoad = 1;
 //keyPresses var keyPressList = []; var tileSheet;
 var mapRows = 15;
 var mapCols = 15;
 //playfield var playField = [];
 var items = [];
 var xMin = 0;
 var xMax = 480; var yMin = 0;
 var yMax = 480;
 //tiles var playerTiles = [1,2,3,4,5,6,7,8]; var enemyTiles = [9,10,11,12,13,14,15,16];
 var roadTile = 0;
 var wallTile = 30;
 var goalTile = 23; var explodeTiles = [17,18,19,18,17];
 var wallMax = 20;
 var playerMax = 1;
 var enemyMax = 20; var goalMax = 1;
 var enemyMoveCompleteCount=0;
 //objects var player = {}; var enemy = [];
 var explosions = [];
 //screens var screenStarted = false; var score = 0;
 var enemyScore = 10;
 var goalScore = 50;
 var highScore = 0; var chanceRandomEnemyMovement = 25;
 function runGame(){ currentGameStateFunction();
 }
 function switchGameState(newState) { currentGameState = newState; switch (currentGameState) { case GAME_STATE_INIT: currentGameStateFunction = gameStateInit; break; case GAME_STATE_WAIT_FOR_LOAD: currentGameStateFunction = gameStateWaitForLoad; break; case GAME_STATE_TITLE: currentGameStateFunction = gameStateTitle; break; case GAME_STATE_NEW_GAME: currentGameStateFunction = gameStateNewGame; break; case GAME_STATE_WAIT_FOR_PLAYER_MOVE: currentGameStateFunction = gameStateWaitForPlayerMove; break; case GAME_STATE_ANIMATE_PLAYER: currentGameStateFunction = gameStateAnimatePlayer; break; case GAME_STATE_EVALUATE_PLAYER_MOVE: currentGameStateFunction = gameStateEvaluatePlayerMove; break; case GAME_STATE_ENEMY_MOVE: currentGameStateFunction = gameStateEnemyMove; break; case GAME_STATE_ANIMATE_ENEMY: currentGameStateFunction = gameStateAnimateEnemy; break; case GAME_STATE_EVALUATE_ENEMY_MOVE: currentGameStateFunction = gameStateEvaluateEnemyMove; break; case GAME_STATE_EVALUATE_OUTCOME: currentGameStateFunction = gameStateEvaluateOutcome; break; case GAME_STATE_ANIMATE_EXPLODE: currentGameStateFunction = gameStateAnimateExplode; break; case GAME_STATE_CHECK_FOR_GAME_OVER: currentGameStateFunction = gameStateCheckForGameOver; break; case GAME_STATE_PLAYER_WIN: currentGameStateFunction = gameStatePlayerWin; break; case GAME_STATE_PLAYER_LOSE: currentGameStateFunction = gameStatePlayerLose; break;
 }
 }
 function gameStateWaitForLoad(){ //do nothing while loading events occur //console.log("doing nothing...") }
 function gameStateInit() {
 tileSheet = new Image(); tileSheet.src = "tanks_sheet.png"; tileSheet.onload = itemLoaded;
 switchGameState(GAME_STATE_WAIT_FOR_LOAD); }
 function itemLoaded(event) {
 loadCount++; ////console.log("loading:" + loadCount) if (loadCount &gt;= itemsToLoad) {
 switchGameState(GAME_STATE_TITLE) }
 }
 function gameStateTitle() { if (screenStarted !=true){ fillBackground(); setTextStyleTitle(); context.fillText ("Micro Tank Maze", 160, 70); context.fillText ("Press Space To Play", 150, 140);
 screenStarted = true; }else{ //wait for space key click if (keyPressList[32]==true){ //console.log("space pressed"); switchGameState(GAME_STATE_NEW_GAME); screenStarted = false; }
 }
 }
 function gameStatePlayerWin(){ if (!screenStarted){
 score += goalScore; fillBackground(); setTextStyleTitle(); context.fillText ("YOU WON THE GAME!", 135, 70); context.fillText ("Final Score: " + score, 150, 100); context.fillText ("Number of enemy: " + enemyMax, 150,130);
 if (score &gt; highScore){ highScore = score; context.fillText ("NEW HIGH SCORE!", 150,160); }
 context.fillText ("High Score: " + score, 150, 190); screenStarted = true;
 enemyMax++; if (enemyMax &gt;50){ enemyMax = 50; } context.fillText ("Number of enemy for next game: " + enemyMax, 100,220);
 context.fillText ("Press Space To Play", 150, 300);
 }else{ //wait for space key click if (keyPressList[32]==true){ //console.log("space pressed"); switchGameState(GAME_STATE_NEW_GAME); screenStarted = false; }
 }
 }
 function gameStatePlayerLose(){ if (!screenStarted){ fillBackground(); setTextStyleTitle(); context.fillText ("SORRY, YOU LOST THE GAME!", 100, 70); context.fillText ("Final Score: " + score, 150, 100); context.fillText ("Number of enemy: " + enemyMax, 150,130); if (score &gt; highScore){ highScore = score; context.fillText ("NEW HIGH SCORE!", 150,160); }
 context.fillText ("High Score: " + score, 150, 190);
 screenStarted = true;
 context.fillText ("Number of enemy for next game: " + enemyMax, 100,220); context.fillText ("Press Space To Play", 150, 300); }else{ //wait for space key click if (keyPressList[32]==true){ //console.log("space pressed"); switchGameState(GAME_STATE_NEW_GAME); screenStarted = false; }
 }
 }
 function gameStateNewGame(){ score = 0; enemy = []; explosions = []; playField = []; items = []; resetPlayer(); createPlayField(); renderPlayField(); switchGameState(GAME_STATE_WAIT_FOR_PLAYER_MOVE);
 }
 function createPlayField(){ var wallCount = 0; var playerCount = 0; var enemyCount = 0; var goalCount = 0; var roadCount = 0;
 //fill with road for (var rowCtr=0;rowCtr&lt;15;rowCtr++){ var tempRow = []; for (colCtr=0;colCtr&lt;15;colCtr++) { tempRow.push(roadTile) } playField.push(tempRow);
 } //console.log("playField=" + playField);
 //create items array for (rowCtr=0;rowCtr&lt;15;rowCtr++){ var tempRow = []; for (colCtr=0;colCtr&lt;15;colCtr++) { tempRow.push(0); }
 items.push(tempRow); }
 var randRow; var randCol; //placewalls for (var wallCtr=0;wallCtr&lt;wallMax;wallCtr++){ var wallLocationFound = false; while(!wallLocationFound){ randRow = Math.floor(Math.random()*15); randCol = Math.floor(Math.random()*15); if (playField[randRow][randCol]==roadTile){ playField[randRow][randCol] = wallTile; wallLocationFound = true; } } }
 //place enemy for (var enemyCtr=0;enemyCtr&lt;enemyMax;enemyCtr++){ var enemyLocationFound = false; while(!enemyLocationFound){ randRow = Math.floor(Math.random()*15); randCol = Math.floor(Math.random()*15); if (playField[randRow][randCol]==roadTile){ enemyLocationFound = true; var tempEnemy = {}; tempEnemy.row = randRow; tempEnemy.col = randCol; tempEnemy.nextRow = 0; tempEnemy.nextCol = 0; tempEnemy.currentTile = 0; tempEnemy.rotation = 0; tempEnemy.x = tempEnemy.col*32; tempEnemy.y = tempEnemy.row*32; tempEnemy.speed = 2; tempEnemy.destinationX = 0; tempEnemy.destinationY = 0; tempEnemy.dx = 0; tempEnemy.dy = 0; tempEnemy.hit = false; tempEnemy.dead = false; tempEnemy.moveComplete = false; enemy.push(tempEnemy); items[randRow][randCol] = 1; } } }
 //place player var playerLocationFound = false; while(!playerLocationFound){ randRow = Math.floor(Math.random()*15); randCol = Math.floor(Math.random()*15); if (playField[randRow][randCol]==roadTile &amp;&amp; items[randRow][randCol]==0){ playerLocationFound = true; player.col = randCol; player.row = randRow; player.x = player.col*32; player.y = player.row*32; items[randRow][randCol] = 1; } } //place goal var goalLocationFound = false; while(!goalLocationFound){ randRow = Math.floor(Math.random()*15); randCol = Math.floor(Math.random()*15); if (playField[randRow][randCol]==roadTile &amp;&amp; items[randRow][randCol]==0){ playField[randRow][randCol] = goalTile; goalLocationFound = true; } }
 //console.log("playField=" + playField);
 }
 function resetPlayer(){ player.row = 0; player.col = 0; player.nextRow = 0; player.nextCol = 0; player.currentTile = 0; player.rotation = 0; player.speed = 2; player.destinationX = 0; player.destinationY = 0; player.x = 0; player.y = 0; player.dx = 0; player.dy = 0; player.hit = false; player.dead = false; player.win = false; }
 function gameStateWaitForPlayerMove() { if (keyPressList[38]==true){ //up if (checkBounds(-1,0, player)){ setPlayerDestination();
 } }else if (keyPressList[37]==true) { //left if (checkBounds(0,-1, player)){ setPlayerDestination(); } }else if (keyPressList[39]==true) { //right if (checkBounds(0,1, player)){ setPlayerDestination(); } }else if (keyPressList[40]==true){ //down if (checkBounds(1,0, player)){ setPlayerDestination(); } }
 } function setPlayerDestination(){ player.destinationX = player.nextCol*32; player.destinationY = player.nextRow*32; switchGameState(GAME_STATE_ANIMATE_PLAYER);
 }
 function checkBounds(rowInc, colInc, object){ object.nextRow = object.row+rowInc; object.nextCol = object.col+colInc;
 if (object.nextCol &gt;=0 &amp;&amp; object.nextCol&lt;15 &amp;&amp; object.nextRow&gt;=0 &amp;&amp; object.nextRow&lt;15){ object.dx = colInc; object.dy = rowInc; if (colInc==1){ object.rotation = 90; }else if (colInc==-1){ object.rotation = 270; }else if (rowInc==-1){ object.rotation = 0; }else if (rowInc==1){ object.rotation = 180; }
 return(true);
 }else{ object.nextRow = object.row; object.nextCol = object.col; return(false);
 } }
 function gameStateAnimatePlayer(){ player.x += player.dx*player.speed; player.y += player.dy*player.speed; player.currentTile++; if (player.currentTile==playerTiles.length){ player.currentTile = 0; } renderPlayField(); if (player.x==player.destinationX &amp;&amp; player.y==player.destinationY){ switchGameState(GAME_STATE_EVALUATE_PLAYER_MOVE); }
 }
 function gameStateEvaluatePlayerMove(){ player.row = player.nextRow; player.col = player.nextCol; if (playField[player.row][player.col]==wallTile){ player.hit = true; }else if (playField[player.row][player.col]==goalTile){ player.win = true; }
 for (var eCtr=enemy.length-1;eCtr&gt;=0;eCtr--){ if (player.row==enemy[eCtr].row &amp;&amp; player.col==enemy[eCtr].col){ enemy[eCtr].hit = true; player.hit = true; } }
 switchGameState(GAME_STATE_ENEMY_MOVE);
 } function gameStateEnemyMove(){ for (var eCtr=0;eCtr&lt;enemy.length;eCtr++){ var tempEnemy = enemy[eCtr]; if (!tempEnemy.hit){
 var directionsToTest=[]; var hDiff = tempEnemy.col - player.col; var vDiff = tempEnemy.row - player.row;
 if (Math.abs(vDiff) &lt; Math.abs(hDiff)){ if (vDiff &gt; 0){ directionsToTest.push("up"); directionsToTest.push("down"); }else if (vDiff &lt;0){ directionsToTest.push("down"); directionsToTest.push("up"); }
 if (hDiff &gt;0){ directionsToTest.push("left"); directionsToTest.push("right"); }else if (hDiff &lt;0){ directionsToTest.push("right"); directionsToTest.push("left"); } }else if (Math.abs(hDiff) &lt; Math.abs(vDiff)) { if (hDiff &gt;0){ directionsToTest.push("left"); directionsToTest.push("right"); }else if (hDiff&lt;0){ directionsToTest.push("right"); directionsToTest.push("left"); }else if (vDiff &gt; 0){ directionsToTest.push("up"); directionsToTest.push("down"); }else if (vDiff &lt;0){ directionsToTest.push("down"); directionsToTest.push("up"); } }else if (Math.abs(hDiff) == Math.abs(vDiff)) { //make an educated random guess if (Math.floor(Math.random()*2)==0){ //try vertical first if (vDiff &gt;0){ directionsToTest.push("up"); directionsToTest.push("down"); }else if (vDiff&lt;0){ directionsToTest.push("down"); directionsToTest.push("up"); } }else{ //try vertical first if (hDiff &gt;0){ directionsToTest.push("left"); directionsToTest.push("right"); }else if (hDiff&lt;0){ directionsToTest.push("right"); directionsToTest.push("left"); } } } var chooseRandom = false; var moveFound = false; var movePtr = 0; var move; if (Math.floor(Math.random()*100)&gt; chanceRandomEnemyMovement){
 //not random movement while(!moveFound){
 move = directionsToTest[movePtr]; switch(move){ case "up": if (checkBounds(-1,0,tempEnemy)){ moveFound = true;
 } break;
 case "down": if (checkBounds(1,0,tempEnemy)){ moveFound = true;
 } break; case "left": if (checkBounds(0,-1, tempEnemy)){ moveFound = true;
 } break; case "right": if (checkBounds(0,1,tempEnemy)){ moveFound = true;
 } break }
 movePtr++ if (movePtr==directionsToTest.length){ //do not move if no move found //this should be impossible chooseRandom = true; } }
 }else{ chooseRandom = true; } //pick random direction to test; if (chooseRandom) {
 while(!moveFound){ switch(Math.floor(Math.random()*4)){ case 0: if (checkBounds(-1,0,tempEnemy)){ moveFound = true;
 }else{ } break;
 case 1: if (checkBounds(1,0,tempEnemy)){ moveFound = true;
 }else{
 } break; case 2: if (checkBounds(0,-1, tempEnemy)){ moveFound = true;
 }else{
 } break; case 3: if (checkBounds(0,1,tempEnemy)){ moveFound = true;
 }else{ } break } }
 }
 tempEnemy.destinationX = tempEnemy.nextCol*32; tempEnemy.destinationY = tempEnemy.nextRow*32;
 }else{ tempEnemy.nextCol = tempEnemy.col; tempEnemy.nextRow = tempEnemy.row; tempEnemy.destinationX = tempEnemy.nextCol*32; tempEnemy.destinationY = tempEnemy.nextRow*32; } } switchGameState(GAME_STATE_ANIMATE_ENEMY);
 }
 function gameStateAnimateEnemy(){ for (var eCtr=enemy.length-1;eCtr&gt;=0;eCtr--){ var tempEnemy = enemy[eCtr];
 if (!tempEnemy.moveComplete){ tempEnemy.x += tempEnemy.dx*tempEnemy.speed; tempEnemy.y += tempEnemy.dy*tempEnemy.speed; tempEnemy.currentTile++; if (tempEnemy.currentTile==enemyTiles.length){ tempEnemy.currentTile = 0; } renderPlayField(); if (tempEnemy.x==tempEnemy.destinationX &amp;&amp; tempEnemy.y==tempEnemy.destinationY){ tempEnemy.moveComplete = true; enemyMoveCompleteCount++; } } }
 if (enemyMoveCompleteCount &gt;= enemy.length){ enemyMoveCompleteCount = 0; for (var eCtr=0;eCtr&lt;enemy.length;eCtr++){ var tempEnemy = enemy[eCtr]; tempEnemy.moveComplete = false; } switchGameState(GAME_STATE_EVALUATE_ENEMY_MOVE);
 }
 } function gameStateEvaluateEnemyMove(){ for (var eCtr=enemy.length-1;eCtr&gt;=0;eCtr--){ var tempEnemy = enemy[eCtr]; tempEnemy.row = tempEnemy.nextRow; tempEnemy.col = tempEnemy.nextCol;
 if (playField[tempEnemy.row][tempEnemy.col]==wallTile){ tempEnemy.hit = true; }
 if (player.row==tempEnemy.row &amp;&amp; player.col==tempEnemy.col){ tempEnemy.hit = true; player.hit = true;
 } //check against other enemy for (var eCtr2=enemy.length-1;eCtr2&gt;=0;eCtr2--){ var tempEnemy2 = enemy[eCtr2];
 if (tempEnemy.row==tempEnemy2.row &amp;&amp; tempEnemy.col==tempEnemy2.col &amp;&amp; eCtr != eCtr2){ tempEnemy.hit = true; tempEnemy2.hit = true; }
 }
 } switchGameState(GAME_STATE_EVALUATE_OUTCOME); }
 function gameStateEvaluateOutcome(){ if (player.hit){ player.dead = true; createExplode(player); }
 for (var eCtr=enemy.length-1;eCtr&gt;=0;eCtr--){ var tempEnemy = enemy[eCtr]; if (tempEnemy.hit){ score += enemyScore; tempEnemy.dead = true; createExplode(tempEnemy) enemy.splice(eCtr,1); tempEnemy = null; } }
 switchGameState(GAME_STATE_ANIMATE_EXPLODE); }
 function createExplode(object){ var newExplode = {}; newExplode.currentTile = 0; newExplode.row = object.row; newExplode.col = object.com; newExplode.x = object.x; newExplode.y = object.y; newExplode.rotation = 0; explosions.push(newExplode);
 }
 function gameStateAnimateExplode(){ for (var eCtr=explosions.length-1;eCtr&gt;=0;eCtr--){ var tempExplosion = explosions[eCtr]; renderPlayField(); tempExplosion.currentTile++; if (tempExplosion.currentTile == explodeTiles.length){ explosions.splice(eCtr,1); tempExplode = null; } } if (explosions.length==0){ switchGameState(GAME_STATE_CHECK_FOR_GAME_OVER); }
 }
 function gameStateCheckForGameOver() { if (player.dead){ switchGameState(GAME_STATE_PLAYER_LOSE); }else if (player.win){ switchGameState(GAME_STATE_PLAYER_WIN) }else{ switchGameState(GAME_STATE_WAIT_FOR_PLAYER_MOVE); }
 } function drawPlayField(){ for (rowCtr=0;rowCtr&lt;15;rowCtr++){
 for (colCtr=0;colCtr&lt;15;colCtr++) { var sourceX = Math.floor((playField[rowCtr][colCtr]) % 8) * 32; var sourceY = Math.floor((playField[rowCtr][colCtr]) /8) *32;
 if (playField[rowCtr][colCtr] != roadTile){ context.drawImage(tileSheet, 0, 0,32,32, colCtr*32, rowCtr*32,32,32); } context.drawImage(tileSheet, sourceX, sourceY,32,32, colCtr*32,rowCtr*32,32,32); } }
 } function drawPlayer(){ if (!player.dead){ context.save();
 context.setTransform(1,0,0,1,0,0); context.translate(player.x+16, player.y+16); var angleInRadians = player.rotation * Math.PI / 180; context.rotate(angleInRadians);
 var sourceX = Math.floor(playerTiles[player.currentTile] % 8) * 32; var sourceY = Math.floor(playerTiles[player.currentTile] /8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,-16,-16,32,32); context.restore(); }
 }
 function drawEnemy(){ for (var eCtr=enemy.length-1;eCtr&gt;=0;eCtr--){ tempEnemy = enemy[eCtr]; if (!tempEnemy.dead){ context.save();
 context.setTransform(1,0,0,1,0,0); context.translate(tempEnemy.x+16, tempEnemy.y+16); var angleInRadians = tempEnemy.rotation * Math.PI / 180; context.rotate(angleInRadians); var sourceX = Math.floor(enemyTiles[tempEnemy.currentTile] % 8) * 32; var sourceY = Math.floor(enemyTiles[tempEnemy.currentTile] /8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32,-16,-16,32,32);
 context.restore(); } }
 } function drawExplosions(){ for (var eCtr=explosions.length-1;eCtr&gt;=0;eCtr--){ tempExplosion = explosions[eCtr];
 context.save();
 var sourceX = Math.floor(explodeTiles[tempExplosion.currentTile] % 8) * 32; var sourceY = Math.floor(explodeTiles[tempExplosion.currentTile] /8) *32;
 context.drawImage(tileSheet, sourceX, sourceY,32,32, tempExplosion.x,tempExplosion.y,32,32); context.restore();
 }
 }
 function fillBackground() { // draw background and text context.fillStyle = '#000000'; context.fillRect(xMin, yMin, xMax, yMax); }
 function setTextStyleTitle() { context.fillStyle = '#54ebeb'; context.font = '20px _sans'; context.textBaseline = 'top';
 }
 function renderPlayField() { fillBackground(); drawPlayField(); drawPlayer(); drawEnemy(); drawExplosions(); }
 document.onkeydown = function(e){
 e = e?e:window.event; keyPressList[e.keyCode]=true;
 } document.onkeyup = function(e){
 //document.body.onkeyup = function(e){ e = e?e:window.event; keyPressList[e.keyCode] = false;
 };
//*** application start switchGameState(GAME_STATE_INIT);
 const FRAME_RATE = 40;
 frameRateCounter = new FrameRateCounter(FRAME_RATE);
 //**** application loop var intervalTime = 1000/FRAME_RATE;
 setInterval(runGame, intervalTime );
}
//*** new FrameRateCounter object prototype

function FrameRateCounter(fps) {
 if (fps == undefined){ this.fps = 40
 }else{ this.fps = fps
 } this.lastFrameCount = 0;
 var dateTemp = new Date();
 this.frameLast = dateTemp.getTime();
 delete dateTemp; this.frameCtr = 0;
 this.lastTime = dateTemp.getTime();
 this.step = 1;
}

FrameRateCounter.prototype.countFrames=function() {
 var dateTemp = new Date();
 var timeDifference = dateTemp.getTime()-this.lastTime;
 this.step = (timeDifference/1000)*this.fps; this.lastTime = dateTemp.getTime();
 //console.log("step=",this.step)
 this.frameCtr++;
 if (dateTemp.getTime() &gt;=this.frameLast+1000) { ConsoleLog.log("frame event"); this.lastFrameCount = this.frameCtr; this.frameCtr = 0; this.frameLast = dateTemp.getTime(); }
 delete dateTemp;
}
&lt;/script&gt;

&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;
&lt;canvas width="480" height="480"&gt; Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;

<h2>What’s Next</h2>
Throughout this entire book, we have used game- and entertainment-related subjects to demonstrate canvas application building concepts. 
Over these last two chapters, we’ve sped up the game discussion and covered many game concepts directly by creating two unique games and optimizing a third with bitmaps and object pooling. 
In doing so, we have applied many of the concepts from the earlier chapters in full-blown game applications. 

The techniques used to create a game on Canvas can be applied to almost any canvas application from image viewers to stock charting. 
The sky is really the limit, as the canvas allows the developer a full suite of powerful low-level capabilities that can be molded into any application.
In <a href="ch10.html" title="Chapter 10. 
Mobilizing Games with PhoneGap">Chapter 10</a>, we will look at porting a simple game from the canvas into a native iPhone application. 10. 
Mobilizing Games with PhoneGap" epub:type="chapter">
<h2><span class="orange">Chapter 10. Mobilizing Games with PhoneGap</span></h2>
<h2>Going Mobile!</h2>
Nowadays it seems that everyone is making, planning to make, or thinking of making applications for mobile devices. 
Mobile is the next great (or maybe actually the current) place to make money by selling applications. 
The Apple iPhone is currently one of the most popular personal communication devices, and the iTunes Store gives budding application developers a place to show and sell the fruits of their labor. 

Apple separates their application-development platforms into three categories: Desktop (OS X), Browser (Safari), and iPhone/iPad/iPod Touch (iOS).
Most iOS applications, especially games, are written in Objective-C and compiled directly to the platform using the Xcode IDE. 
This is a large barrier to entry to develop native applications, as Objective-C is not widely used on platforms other than Apple devices. 
Up until early 2010, Objective-C/Xcode was the only viable development system for targeting iOS development.

In this chapter, we will “port” our HTML5 Canvas application to the iPhone using a technology called PhoneGap. 
PhoneGap allows an HTML application to run natively on an iPhone by packaging the application as a Safari Mobile “app.” This app can be run from the iPhone interface, and it will look and act like an app compiled in Objective-C. 
Applications packaged with PhoneGap can even be sold in the iTunes Store.
<h3>Note</h3>

Other third-party tools can be used to create iOS applications and games. 
For example, Unity (<a href="http://unity3d.com/">http://unity3d.com/</a>) is a powerful game-development platform that can target iOS. 
In addition, there are tools such as Ansca’s Corona SDK (<a href="http://www.anscamobile.com/">http://www.anscamobile.com/</a>) that use scripting languages to harness the power of the platform.
<h3>Introducing PhoneGap</h3>

PhoneGap is an open source development tool created by Nitobi (<a href="http://www.nitobi.com">http://www.nitobi.com</a>) that acts as a software bridge between standards-based HTML development and several mobile platforms. 
Using PhoneGap, the HTML5 Canvas developer has access to the various hardware APIs for supported devices through an <em>abstraction layer</em>. 
This software interface allows the same code to be used to target features common among various devices—such as geolocation, touch screens, microphones, and other hardware capabilities—so that separate code does not need to be written for each device.
<h3>Warning</h3>

You will need an Intel-based Macintosh running Xcode to be able to compile a PhoneGap project. 
There currently is no development platform for Windows that will allow compiling Safari Mobile applications to the iOS platform with an Objective-C wrapper.
We won’t target too many specific iPhone features in this chapter. 
In the allotted space, we will cover the basics needed to take a simple application and get it up and running in the iPhone simulator, and then onto a physical device. 

We will then implement an accelerometer feature into our application.
<h3>Note</h3>
For further reading, Jonathan Stark’s <a href="http://oreilly.com/catalog/9780596805791/"><em>Building iPhone Apps with HTML, CSS, and JavaScript</em></a> (O’Reilly) covers PhoneGap and hardware feature API integration in detail. 
If you’d rather try this with Android, explore the similar <em><a href="http://oreilly.com/catalog/0636920010067/">Building Android Apps with HTML, CSS, and JavaScript</a></em> (O’Reilly), also by Jonathan Stark, which applies PhoneGap to create applications for Android.

<h3>The Application</h3>
The application we are going to create is a simple <em>BS Bingo</em> game. 
BS Bingo was designed on paper well before mobile devices were available. 
This cynical game concept is based on the feeling (by some) that the typical business workplace has been overtaken with <em>Dilbert-</em> or <em>Office Space</em>-esque annoying corporate jargon and doublespeak. 

This doublespeak seems to have deeply rooted itself in the workplace over the last 20 years, mostly to the annoyance of software developers (such as ourselves).
In the pen-and-paper version of the game, each player brings a “bingo card” to a meeting where he expects to hear a lot of this corporate doublespeak. 
The bingo card is a 5×5 grid, and each of the 25 squares is filled with one of the annoying words or jargon phrases. 
During the meeting, each player marks off squares as the words or phrases are said aloud by the unsuspecting (and not playing) members of the meeting. 

When a player has a full column of his card marked off, he is supposed to jump up from the meeting table and yell “BS!”
Whether this game was ever widely played (or even played at all) is a debatable urban legend, but the simple concept of clicking squares to highlight them makes for a useful piece of code that we can build easily and then port to the iPhone. 
We are not even going to build the entire game here; we will leave extending it into a full application (possibly adding multiplayer, which is discussed in <a href="ch11.html" title="Chapter 11. 
Further Explorations">Chapter 11</a>) for you, the reader.

<h3>The Code</h3>
Example 10-1</a> gives the code for our game. 
We’ll discuss the various functions in the next section before we move on to installing, modifying, and testing it in Xcode using PhoneGap. 
This version of the game will work fine on a Safari desktop browser. 

We will highlight the modifications necessary to port it to the iPhone in the next section.
Example 10-1. 
BSBingo.html full source listing
&lt;!doctype html&gt; &lt;html lang="en"&gt;
 &lt;head&gt; &lt;meta charset="UTF-8"&gt;
 &lt;title&gt;BS Bingo&lt;/title&gt;
 &lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt; &lt;script src="TextButton.js"&gt;&lt;/script&gt;
 &lt;script src="ConsoleLog.js"&gt;&lt;/script&gt;
 &lt;script type="text/javascript"&gt;
 window.addEventListener('load', eventWindowLoaded, false); function eventWindowLoaded() {
 canvasApp();
 }
 function canvasSupport () { return Modernizr.canvas; }
 function canvasApp(){
 if (!canvasSupport()) { return; }else{ theCanvas = document.getElementById("canvas"); context = theCanvas.getContext("2d"); }
 var bingoCard = []; var buttons = []; var standardJargonList = []; var tempButton = {}; var clickSound;
 function initLists(){
 standardJargonList=[ "Actionable", "Assessment" ,"Bandwidth", "Benchmark", "Best\nPractices", "Bottle neck" , "Change\nManagement", "Coach", "Competitive\nAdvantage", "Constraints", "Core\nCompetencies", "Core values", "Critical\nthinking", "Cutting\nedge", "Dashboard", "Deliverables", "Enterprise","Gatekeeper", "Individual\nContributor", "Leadership", "Matrix\norganisation", "Metrics", "Milestones", "Momentum", "Moving target", "Initiative","Partnership", "Process", "Process\nmanagement", "Re-engineer", "Requirements", "Rightsize", "Seat at\nthe table", "Tentpole", " Silo", "Standards", "State of the art", "Supply chain", "Synergy","Teamwork", "Thought\nleader", "Touchpoints", "Value\nadded", "Drink the\nKool Aid", "Baked In", "Champion", "Circle Back", "Dialogue", "Emerge", "Enhance", "Evolve", "Execute", "Facilitate" ,"Incentivise", "Leverage", "Partner", "Spearhead", "Strategize","Synergise", "Throw\na\nCurve", "Touch Base", "Outside\nthe\nBox", "Opportunity", "Open Door\nPolicy","Win-Win\n(Anything)", "Risk\n(Anything)","Proactive","Reactive","Buy-In", "Paradigm\nShift","Task-Oriented","Empower","Team\nPlayer", "Enterprise\nWide","Globalization","Localization", "Mission-critical", "Magic\nQuadrant","Agile\n(Anything)", "Waterfall","Outsourcing","Off-Shoring","Blue Sky", "20/20 \nindsight","Low\nHanging\nFruit","10,000\nFoot View", "Take\nOwnership","Ramp up", "Out of\nthe Box", "24x7", "Fast Track", "Out of\nthe Loop", "In the\nLoop","Touch Base", "Mindset", "Game Plan", "Bring to \nthe Table", "Drill Down", "Elevator\nSpeech", "Level the\nPlaying field", "Ping\n(Someone)","Pushback","Retool", "Take Away", "Life-Time\nValue", "Thought\nLeadership", "Up Sell" ];
 } function initButtons(){ buttons = [ [
 new TextButton(0,0,"Button 0,0",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(92,0,"Button 0,1",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(184,0,"Button 0,2",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(276,0,"Button 0,3",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(368,0,"Button 0,4",85,50,gr,"#000000","#ffff00","#000000")
 ], [ new TextButton(0,57,"Button 1,0",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(92,57,"Button 1,1",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(184,57,"Button 1,2",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(276,57,"Button 1,3",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(368,57,"Button 1,4",85,50,gr,"#000000","#ffff00","#000000")
 ], [
 new TextButton(0,114,"Button 2,0",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(92,114,"Button 2,1",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(184,114,"Button 2,2",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(276,114,"Button 2,3",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(368,114,"Button 2,4",85,50,gr,"#000000","#ffff00","#000000") ], [
 new TextButton(0,171,"Button 3,0",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(92,171,"Button 3,1",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(184,171,"Button 3,2",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(276,171,"Button 3,3",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(368,171,"Button 3,4",85,50,gr,"#000000","#ffff00","#000000")
 ], [
 new TextButton(0,228,"Button 4,0",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(92,228,"Button 4,1",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(184,228,"Button 4,2",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(276,228,"Button 4,3",85,50,gr,"#000000","#ffff00","#000000"), new TextButton(368,228,"Button 4,4",85,50,gr,"#000000","#ffff00","#000000")
 ] ]; }
 function initSounds(){ clickSound = document.getElementById('clicksound'); } function chooseButtonsForCard(){ //copy jargon into temp array var tempArray = []; for (var arrayctr=0;arrayctr&lt;standardJargonList.length;arrayctr++){ tempArray.push(standardJargonList[arrayctr]); }
 for (var ctr1=0;ctr1&lt;buttons.length;ctr1++){
 for (var ctr2=0; ctr2&lt;buttons[ctr1].length;ctr2++){ var randInt = Math.floor(Math.random()*tempArray.length) buttons[ctr1][ctr2].text = tempArray[randInt]; tempArray.splice(randInt,1) } }
 } function drawScreen() { //ConsoleLog.log("standardAcronymList="+standardAcronymList.length); //ConsoleLog.log("standardJargonList="+standardJargonList.length); for (var ctr1=0;ctr1&lt;buttons.length;ctr1++){ ConsoleLog.log("ctr1="+ctr1) for (var ctr2=0; ctr2&lt;buttons[ctr1].length;ctr2++){ ConsoleLog.log("ctr2="+ctr2) buttons[ctr1][ctr2].draw(context); } }
 }
 function onMouseClick(e) {
 //select case through states and then the locations of //buttons in those states mouseX = e.clientX-theCanvas.offsetLeft; mouseY = e.clientY-theCanvas.offsetTop; ConsoleLog.log("click " + mouseX + "," + mouseY); //find the button clicked var col = Math.floor(mouseX/92); var row = Math.floor(mouseY/57);
 console.log("row",row,"col", col); tempButton = buttons[row][col]; clickSound.play(); tempButton.pressDown(); tempButton.draw(context);
 }
 function onMouseMove(e) { mouseX = e.clientX-theCanvas.offsetLeft; mouseY = e.clientY-theCanvas.offsetTop; //ConsoleLog.log("move: " + mouseX + "," + mouseY); }
 //**** start application var gr = context.createLinearGradient(0, 0, 85, 50);
 // Add the color stops. 

gr.addColorStop(0,'#ffffff'); gr.addColorStop(.5,'#bbbbbb'); gr.addColorStop(1,'#777777');
 theCanvas.addEventListener("mousemove", onMouseMove, false); theCanvas.addEventListener("click", onMouseClick, false);
 initSounds(); initButtons(); initLists(); chooseButtonsForCard(); drawScreen();
 } &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
 &lt;div&gt; &lt;canvas width="570" height="418"&gt;
 Your browser does not support HTML5 Canvas.
 &lt;/canvas&gt;
 &lt;audio id ="clicksound" preload="auto"&gt; &lt;source src="click.mp3" type="audio/mpeg" /&gt; Your browser does not support the audio element.
 &lt;/audio&gt;
 &lt;/div&gt;
 &lt;/body&gt; &lt;/html&gt;
Name this file <em>BSBingo.html</em> and save it in a folder. 
If you are going to follow along and create the example project, you will also want to create a folder to hold the project files.
<h3>Examining the Code for BSBingo.html</h3>

<h3>Note</h3>
When designing an application for the iPhone using PhoneGap, we are actually targeting the Safari Mobile browser. 
This means we can make concessions rather than having to target all available HTML5-compatible devices. 
You will notice this especially when we discuss <code>&lt;audio&gt;</code> tag usage.

<h4>The TextButton.js file</h4>
Our BS Bingo game will be played on a grid of 25 squares. 
We created a class (an object prototype, actually) called <em>TextButton.js</em> to help us create buttons with the text, as well as a “press” state we can use to show that the button has been clicked. 
You will want to save this file in the project folder along with the <em>BSBingo.html</em> file. 

Here is the code for this file:
function TextButton(x,y,text, width, height, backColor, strokeColor, 
 overColor, textColor){ this.x = x; this.y = y; this.text = text; this.width = width; this.height = height; this.backColor = backColor; this.strokeColor = strokeColor; this.overColor = overColor; this.textColor = textColor; this.press = false;
}

TextButton.prototype.pressDown=function() { if (this.press==true){ this.press = false; }else{ this.press = true; }
}
TextButton.prototype.draw = function(context){
 context.save(); context.setTransform(1,0,0,1,0,0); // reset to identity context.translate(this.x, this.y); context.shadowOffsetX = 3; context.shadowOffsetY = 3; context.shadowBlur = 3; context.shadowColor = "#222222";
 context.lineWidth = 4; context.lineJoin = 'round'; context.strokeStyle = this.strokeColor;
 if (this.press==true){ context.fillStyle = this.overColor; }else{ context.fillStyle = this.backColor; }
 context.strokeRect(0, 0, this.width,this.height); context.fillRect(0, 0, this.width,this.height); //text context.shadowOffsetX = 1; context.shadowOffsetY = 1; context.shadowBlur = 1; context.shadowColor = "#ffffff"; context.font = "14px serif" context.fillStyle = this.textColor; context.textAlign = "center"; context.textBaseline = "middle"; var metrics = context.measureText(this.text) var textWidth = metrics.width; var xPosition = this.width/2; var yPosition = (this.height/2);
 var splitText = this.text.split('\n'); var verticalSpacing = 14; console.log("text=" + this.text) console.log("text split length=" + splitText.length)
 for (var ctr1=0; ctr1&lt;splitText.length;ctr1++) { context.fillText ( splitText[ctr1], xPosition, yPosition+ (ctr1*verticalSpacing)); }
 context.restore();

}
This object prototype contains functions for creating, drawing, and clicking a gray square button with black text on it. 
When clicked, the button will be drawn with a yellow background. 
We have covered all these drawing functions earlier in this book, so they will look familiar to you if you have read those chapters. 

If you have not, it’s especially a good idea to read <a href="ch02.html" title="Chapter 2. 
Drawing on the Canvas">Chapter 2</a>, which covers drawing and shading objects drawn with paths.
Let’s now take a quick look at the functions we have created in <em>BSBingo.html</em>.
<h4>The initLists() function</h4>

The first game-related function you will encounter is <code>initLists()</code>. 
For our simple game implementation, we have created a single list of words based on some common business jargon. 
The <code>standardJargonList</code> application scope variable will contain a single-dimension array of words that will be placed randomly on the player’s bingo card. 
We can add more types of lists if we would like to target other types of jargon-speak, such as pure IT process-speak, marketing-speak, or even sports- or geek-speak.

<h4>The initButtons() function</h4>
This function creates a grid of 25 <code>TextButton</code> instances, 85 pixels in width and 25 in height. 
These are stored in the application scope <code>buttons</code> two-dimensional array so they can be accessed via the <code>[row][column]</code> syntax.
<h4>The initSounds() function</h4>

The <code>initSounds()</code> function needs to initialize only a single sound referenced in an HTML5 <code>&lt;audio&gt;</code> tag. 
Since we are targeting the iOS platform, we need to provide only a single <em>.mp3</em>-formatted sound. 
We do not need <em>.ogg</em> or <em>.wav</em> because we are not targeting any other browsers. 
Here is the HTML5 <code>&lt;audio&gt;</code> tag:

&lt;audio preload="auto"&gt; &lt;source src="click.mp3" type="audio/mpeg" /&gt;
 Your browser does not support the audio element.
 &lt;/audio&gt;
<h4>The chooseButtonsForCard() function</h4>

This function creates a local array called <code>tempArray</code> and fills it with the contents of the <code>standardJargonList</code>. 
Next, it randomly chooses an element from the <code>tempArray</code> for each of the 25 row/column combinations on the bingo card. 
As it selects a word, it splices it from the <code>tempArray</code> so it cannot be selected again, leaving the card with no duplicates.
<h4>The drawScreen() function</h4>

This function loops through the <code>buttons</code> two-dimensional array and draws the initial 25 buttons with text onto the canvas.
<h4>The onMouseClick() function</h4>
When the user clicks the mouse on the game screen, this event listener function determines which of the 25 squares was clicked. 
It calls the appropriate <code>TextButton</code> instance’s <code>pressDown()</code> function and then its <code>draw()</code> function, passing in the context.

<h4>The onMouseMove() function</h4>
When the mouse is moved, this event listener function will set the <code>mouseX</code> and <code>mouseY</code> values to the current mouse position on the canvas.
<h3>The Application Code</h3>
Once all the functions and the <code>TextButton</code> object prototype are created, the actual application code is very simple. 

Because this is a completely event-based application, we don’t need a main loop. 
We also have not put in any other states or buttons, such as a title screen or a reset button. 
This makes the app less user-friendly, but it is fine for this simple example. 
It also makes the application code very simple: //**** start application var gr = context.createLinearGradient(0, 0, 100, 100);
 // Add the color stops. 
gr.addColorStop(0,'#ffffff'); gr.addColorStop(.5,'#bbbbbb'); gr.addColorStop(1,'#777777');
 theCanvas.addEventListener("mousemove", onMouseMove, false); theCanvas.addEventListener("click", onMouseClick, false); initSounds(); initButtons(); initLists(); chooseButtonsForCard(); drawScreen();

First, we create a shared linear gradient that can be used by all the <code>TextButton</code> instances. 
Next, we add the mouse event listeners for click and move. 
Finally, we run through our functions to set up the card, and then we simply wait for the user to click a button. 
That’s all there is to it. 

We haven’t even added a way to announce that the player has won. 
Extending this into a full-fledged application would be very simple, so we leave this task up to the reader if you have the desire to do so.
<a href="ch10.html#bs_bingo_in_safari_desktop_edition" title="Figure 10-1. 
BS Bingo in Safari Desktop Edition">Figure 10-1</a> shows the screen for the finished application.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893843.png.jpg" alt="BS Bingo in Safari Desktop Edition" width="460" height="284">
Figure 10-1. 
BS Bingo in Safari Desktop Edition
Next, we will look at how to use PhoneGap to turn this simple game into a native iOS application.

<h2>Creating the iOS Application with PhoneGap</h2>
You will need to install and set up two tools to get an iOS application up and running on your iOS device simulator: Xcode, a free application development IDE from Apple, and PhoneGap. 
Let’s start with Xcode.
<h3>Installing Xcode</h3>

Xcode actually comes packaged on the installable operating system DVD for Snow Leopard, but this version will not be as up-to-date as the version available on the Apple developer website.
First, you will want to visit the iOS Developer Center: <a href="http://developer.apple.com/devcenter/ios/index.action">http://developer.apple.com/devcenter/ios/index.action</a>. 
Once there, you can create a free user account, which you will need to download Xcode and the latest iOS developer SDK. 
You will also need to create a paid account if you would like to test or deploy on a physical device and/or sell your application in the iTunes Store. 

You do not need a paid account to build and test your application in the SDK and the included iOS device simulators.
Download and install the latest version of Xcode and the iOS SDK. 
This is a large download (3.5 GB at the time of this writing). 
See <a href="ch10.html#download_the_ios_sdk" title="Figure 10-2. 

Download the iOS SDK">Figure 10-2</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893845.png" alt="Download the iOS SDK" width="1000" height="628">
Figure 10-2. 
Download the iOS SDK

Once these are downloaded (most likely to your Downloads folder), start the Xcode installer. 
The file will be named similar to <em>xcode_3.2.3_and_ios_sdk_4.0.2.dmg</em>. 
Run the package installer to set up Xcode and the development kit on your computer.
<h3>Note</h3>

Once installed (using the default location), Xcode can be found in the Developer folder on your main storage drive.
<h3>Installing PhoneGap</h3>
Download PhoneGap from <a href="https://github.com/phonegap/phonegap">https://github.com/phonegap/phonegap</a>, choosing the ZIP file option, as shown in <a href="ch10.html#download_phonegap" title="Figure 10-3. 
Download PhoneGap">Figure 10-3</a>.

The file will most likely be saved into your Mac Downloads folder. 
Unpack this ZIP file in a safe location, such as the desktop.
Inside the ZIP, you will find a series of folders for various devices. 
We are interested in the iOS folder. 

<a href="ch10.html#phonegap_folder_structure" title="Figure 10-4. 
PhoneGap folder structure">Figure 10-4</a> illustrates this folder structure.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893847.png.jpg" alt="Download PhoneGap" width="1000" height="737">
Figure 10-3. 

Download PhoneGap
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893849.png" alt="PhoneGap folder structure" width="770" height="437">
Figure 10-4. 
PhoneGap folder structure

In the iOS folder there will be an installer with a name similar to <em>PhoneGapLibInstaller.pkg</em>. 
Open this to start the install process.
After the install, you will be given the latest install notes. 
It is important to read them carefully as they give great information, including the latest tips for getting started with PhoneGap. 

For example, after this installation, the notes read as follows:
<blockquote>
To get started creating PhoneGap projects, launch Xcode, then under the File menu, select “New Project…”.
Navigate to the section “User Templates”, select PhoneGap, then in the right pane, select “PhoneGap-based Application”.

Select the “Choose…” button, name your project and choose the location where you want the new project to be.
That’s it! Modify the contents of the “www” directory to add your HTML, CSS and JavaScript.
iPad:
Go to your project folder and launch the “[projectname]-iPad” Xcode project. 

You will need the 3.2 iPhone OS SDK.
<a href="http://www.phonegap.com">http://www.phonegap.com</a>
<a href="http://github.com/phonegap">http://github.com/phonegap</a>
</blockquote>

In the next section, we will follow these directions closely to get BS Bingo into a PhoneGap Xcode project.
<h3>Creating the BS Bingo PhoneGap Project in Xcode</h3>
To begin, launch Xcode and create a new PhoneGap project. 
See <a href="ch10.html#xcode_new_project_screen" title="Figure 10-5. 

Xcode New Project screen">Figure 10-5</a> for an example of the New Project screen.
Select the PhoneGap-based application and click the Choose button.
You will next be asked to save the project in a location and give it a name. 
We will use the name <em>chapter10_bs_bingo</em>.

You will be presented with a screen that resembles <a href="ch10.html#the_chapter10_underscore_bs_underscore_b" title="Figure 10-6. 
The chapter10_bs_bingo project">Figure 10-6</a>.
On the lefthand side, you will find a folder called “www”. 
This is the most important folder because it is where we will place all of the files for our game. 

Before we do that, we need to make sure that the SDK is set to the correct version. 
In the top left, you might see a drop-down with the words “Base SDK Missing” (as shown in <a href="ch10.html#the_chapter10_underscore_bs_underscore_b" title="Figure 10-6. 
The chapter10_bs_bingo project">Figure 10-6</a>). 
This means that we will not be able to build and compile our game until we choose an SDK.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893851.png" alt="Xcode New Project screen" width="721" height="624">
Figure 10-5. 
Xcode New Project screen
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893853.png" alt="The chapter10_bs_bingo project" width="787" height="434">

Figure 10-6. 
The chapter10_bs_bingo project
The Base SDK Missing message simply indicates that the default SDK is not the current version installed. 
In the [Project] drop-down menu, you will find a menu item called Edit Project Settings. 

Click this and you will see a screen similar to <a href="ch10.html#select_the_correct_base_sdk" title="Figure 10-7. 
Select the correct Base SDK">Figure 10-7</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893855.png" alt="Select the correct Base SDK" width="879" height="658">
Figure 10-7. 

Select the correct Base SDK
Make sure that you select an SDK that is present on your machine (4.2 is the latest as of this writing).
Close this window and click on the Base SDK Missing drop-down, and be sure to select the Simulator option rather than the Device option. 
See <a href="ch10.html#setting_up_an_app_to_run_in_the_simulato" title="Figure 10-8. 

Setting up an app to run in the simulator">Figure 10-8</a> for an example of this screen.
<h3>Testing the New Blank Application in the Simulator</h3>
We are now ready to build our first application and see it in the simulator. 
We have not added any of our own code yet (though we will in the next section), so we will be testing the contents of the <em>index.html</em> file in the project’s www folder. 

Simply click the “Build and Run” button at the top of the IDE. 
If everything is set up properly, the simulator will come up with a blank screen, as shown in <a href="ch10.html#a_basic_app_running_in_the_simulator" title="Figure 10-9. 
A basic app running in the simulator">Figure 10-9</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893857.png.jpg" alt="Setting up an app to run in the simulator" width="786" height="451">

Figure 10-8. 
Setting up an app to run in the simulator
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893859.png.jpg" alt="A basic app running in the simulator" width="367" height="715">
Figure 10-9. 

A basic app running in the simulator
For a single second you will see the PhoneGap banner show up on the screen. 
We will customize this banner for our own game shortly.
<h3>Integrating BS Bingo into the Project</h3>

We are now going to copy code from the <em>BSBingo.html</em> file we created earlier into the <em>index.html</em> file in our project.
First we will copy our JavaScript include files and add them under the <em>phonegap.js</em> script include. 
We will not need the <em>modernizer.js</em> file, as we will assume the iOS platform can use HTML5 Canvas:
&lt;script type="text/javascript" charset="utf-8" src="phonegap.js"&gt;&lt;/script&gt;

&lt;script src="TextButton.js"&gt;&lt;/script&gt;
&lt;script src="ConsoleLog.js"&gt;&lt;/script&gt;
The <em>phonegap.js</em> file should already be included in the www folder, along with <em>index.html</em>. 
It is part of the project template and is needed for all PhoneGap iOS applications.

Next, we will need to add the call to start our application into the <code>deviceReady()</code> function:
/*When this function is called, PhoneGap has been initialized and is ready to roll*/
 function onDeviceReady()
 { // do your thing! <strong>canvasApp();</strong> }
We can now replace the rest of the <code>script</code> code in the file with our code.
<h3>Warning</h3>
At this step, don’t replace from the <code>&lt;body&gt;</code> tag down to the end of the <code>&lt;html&gt;</code>. 

Just add the game code inside the <code>&lt;script&gt;</code> tags. 
You can use the existing <code>&lt;script&gt;&lt;/script&gt;</code> tags; if you do, be careful not to copy them from <em>BSBingo.html</em>.
Make sure that the first few lines look like this because we are removing the check for Canvas support:
function canvasApp(){ theCanvas = document.getElementById("canvas");
 context = theCanvas.getContext("2d");
 var bingoCard = [];
 var buttons = []; var standardJargonList = [];
 var tempButton = {};
 var clickSound;
Notice that we have removed this set of code:

if (!canvasSupport()) {
 return;
}else{
 theCanvas = document.getElementById("canvas"); context = theCanvas.getContext("2d");
}
We have replaced it with just the following since we no longer need to check whether the device can use the canvas (we must assume it can):
theCanvas = document.getElementById("canvas");

context = theCanvas.getContext("2d");
We have also deleted the <code>canvasSupport()</code> function, as it is not needed. 
We will next copy the rest of the code, including our HTML, and replace everything in the <em>index.html</em> file.
We need to make sure that the current opening <code>&lt;body&gt;</code> tag remains in <em>index.html</em>. 

It should look like this:
&lt;/head&gt;
&lt;body onload="onBodyLoad()"&gt;
The next step is to replace the rest of the file with HTML code from <em>BSBingo.html</em>:

&lt;div&gt;
&lt;canvas width="570" height="418"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;audio id ="clicksound" preload="auto"&gt;
&lt;source src="click.mp3" type="audio/mpeg" /&gt;
Your browser does not support the audio element.
&lt;/audio&gt;

&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
We now have enough code to do a preliminary test of our game in the simulator.

We will first need to move our files into the project folder. 
Take <em>TextButton.js</em>, <em>ConsoleLog.js</em>, and <em>click.mp3</em> and move them to the www folder on the disk. 
The project in Xcode will now reflect the new files, as seen in <a href="ch10.html#the_project_www_file_listing" title="Figure 10-10. 
The project www file listing">Figure 10-10</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893861.png" alt="The project www file listing" width="894" height="631">
Figure 10-10. 
The project www file listing
<h3>Note</h3>

You will see that we have added the <em>BSBingo.html</em> file to the www folder. 
This is not <em>necessary</em>, but it makes it easier to edit and copy code into the <em>index.html</em> file.
<h3>Setting the Orientation</h3>
It is important to note that Safari Mobile and iOS applications render the screen in different ways. 

A Safari Mobile application can be set to automatically scale to fit in the iOS device’s window, while a pure iOS application needs to be coded to fit the size of the target device. 
If an application targeted to the iOS platform is taller or wider than the device, the application will automatically be put into “scroll” mode.
We set the width of our application to be 570 and the height to be 418. 
The height will fit fine in either Landscape or Portrait orientation, but the width will only fit in Landscape (without scrolling). 

For this reason, we will want our application to run in Landscape mode only.
To set the application to default to Landscape and not allow Portrait, we must make some changes to a file called <em>chapter10_bs_bingo-info.plist</em>, which is in the root folder (the parent of the www folder) for our project.
Open this file and you will see settings called “Supported interface orientations” and “Supported interface orientations (iPad)”. 
You will want to be sure to have four entries in each that allow only the “Landscape (left home button)” value. 

See <a href="ch10.html#setting_landscape_orientation" title="Figure 10-11. 
Setting Landscape orientation">Figure 10-11</a> for an example.
<h3>Note</h3>
The iPad entries are only necessary if you are targeting that platform. 

There is a separate PhoneGap project created by the template for iPad-targeted projects.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893863.png" alt="Setting Landscape orientation" width="997" height="730">
Figure 10-11. 
Setting Landscape orientation

Next, we will customize the banner and icon for our application.
<h3>Changing the Banner and Icon</h3>
We have the option of changing the startup banner and “desktop” icon for our application to customized graphics.
In the root folder of our project, we will customize two image files. 

<em>default.png</em> is the banner image that shows up when the application starts. 
<em>icon.png</em> is the “desktop” icon that remains on the iOS device just like any other installed application.
Our icon is a 57×75 image called <em>bingo_icon.png</em> (see <a href="ch10.html#the_bs_bingo_icon.png_customization" title="Figure 10-12. 
The BS Bingo icon.png customization">Figure 10-12</a>).

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893865.png" alt="The BS Bingo icon.png customization" width="57" height="57">
Figure 10-12. 
The BS Bingo icon.png customization
The startup banner is a 320×460 image, which we will name <em>startup.png</em>. 

It will look like <a href="ch10.html#the_bs_bingo_default.png_customization" title="Figure 10-13. 
The BS Bingo default.png customization">Figure 10-13</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893867.png" alt="The BS Bingo default.png customization" width="320" height="460">
Figure 10-13. 

The BS Bingo default.png customization
Now we need to replace the existing <em>default.png</em> and <em>icon.png</em> files with these new images.
Once you change these files in the project, you should be able to explore the root project folder in Xcode and see the new images. 
<a href="ch10.html#the_bs_bingo_root_folder" title="Figure 10-14. 

The BS Bingo root folder">Figure 10-14</a> illustrates the root folder for our project.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893869.png" alt="The BS Bingo root folder" width="999" height="729">
Figure 10-14. 
The BS Bingo root folder

<h3>Note</h3>
Included in the source for this chapter is the full Xcode project with all of these changes ready to be made and compiled.
We are ready to test on the iPhone simulator. 
If you have any problems or questions up to this point, you can always examine the source files on this book’s download site.

<h3>Testing on the Simulator</h3>
Our project is set to target the iPhone (not iPad). 
Before we test, we must make sure that we target that platform in the simulator. 
To do this, choose the iPhone simulator from the SDK drop-down menu at the top left of the Xcode screen, as shown in <a href="ch10.html#setting_build_target_to_the_simulator" title="Figure 10-15. 

Setting the build target to the simulator">Figure 10-15</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893871.png" alt="Setting the build target to the simulator" width="992" height="729">
Figure 10-15. 
Setting the build target to the simulator

<h3>Note</h3>
The PhoneGap template has created a second project file, called <em>chapter10_bs_bingo-iPad.xcodeproj</em>, to target the iPad.
Once this is set, click on the “Build and Run” icon at the top center of this screen.
You should see the simulator fire up, show the custom banner image oriented to Landscape mode, and present the game, as shown in <a href="ch10.html#bs_bingo_running_in_the_simulator" title="Figure 10-16. 

BS Bingo running in the simulator">Figure 10-16</a>.
If you click on the buttons, the simulator will even play the <em>click.mp3</em> file we included. 
When the iPhone “control button” is clicked (the big black circle on the left), the game will exit to the iOS “desktop.” On the desktop, the custom <em>icon.png</em> will wait to be clicked once again, as shown in <a href="ch10.html#the_bs_bingo_ios_desktop_icon" title="Figure 10-17. 
The BS Bingo iOS desktop icon">Figure 10-17</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893873.png.jpg" alt="BS Bingo running in the simulator" width="708" height="356">
Figure 10-16. 
BS Bingo running in the simulator
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893875.png.jpg" alt="The BS Bingo iOS desktop icon" width="364" height="707">

Figure 10-17. 
The BS Bingo iOS desktop icon
<h3>Note</h3>
You will notice that the iPhone simulator has made our plain icon look much better by adding a bevel and highlighting. 

There is no need for you to create anything other than a plain image, as the phone takes care of the rest.
<h3>Adding in an iPhone “Gesture”</h3>
The PhoneGap API allows us to add in control over various iOS features, such as vibrate, geolocation, and accelerometer. 
We will target one of these features by adding code that will wipe our board clean and create a fresh new game when the phone is shaken.

To do this, we will look for changes to the device’s physical location in space (using JavaScript), and then simply call our existing <code>chooseButtonsForCard()</code> and <code>drawScreen()</code> functions to refresh the card.
First, we need to add a single line to the <code>chooseButtonsForCard()</code> function that will set all the <code>buttons</code> instances’ <code>press</code> attributes to <code>false</code>:
function chooseButtonsForCard(){ //copy jargon into temp array var tempArray = []; for (var arrayctr=0;arrayctr&lt;standardJargonList.length;arrayctr++){ tempArray.push(standardJargonList[arrayctr]); }
 for (var ctr1=0;ctr1&lt;buttons.length;ctr1++){ for (var ctr2=0; ctr2&lt;buttons[ctr1].length;ctr2++){ var randInt = Math.floor(Math.random()*tempArray.length) buttons[ctr1][ctr2].text = tempArray[randInt]; <strong>buttons[ctr1][ctr2].press = false;</strong> tempArray.splice(randInt,1); } }
 }
Next, we need to add a function that will listen for the iOS “shake” event, and then refresh the card.
Apple makes it pretty easy to test for changes in the <code>x</code>, <code>y</code>, and <code>z</code> coordinate spaces of an iOS device (and PhoneGap makes it even easier), but acting on this information is a little tricky and will require the use of an actual device for testing.

<h3>Note</h3>
At the time of this writing, a PhoneGap Adobe AIR iPhone simulator was available that goes beyond the limited shake gestures available in the SDK simulator. 
If you do not have a device to test with, we recommend trying this emulator. 
It can be found at <a href="http://blogs.nitobi.com/yohei/2009/04/01/phonegap-air-simulator-in-development/">http://blogs.nitobi.com/yohei/2009/04/01/phonegap-air-simulator-in-development/</a>.

<h3>Adding the Gesture Functions to index.html</h3>
Inside the <code>canvasApp()</code> function, we will need to add a series of functions and a variable to use in testing the iPhone’s accelerometer, which detects movement in our application.
Example 10-2</a> shows the code necessary to do this. 
Notice we are placing it under the current application start code (the new code is in bold).

Example 10-2. 
The gesture code added to BS Bingo theCanvas.addEventListener("mousemove", onMouseMove, false);
 theCanvas.addEventListener("click", onMouseClick, false); initSounds();
 initButtons();
 initLists();
 chooseButtonsForCard(); drawScreen();
 <strong>var accelerationWatchId = null;</strong>
 <strong>startAccelerationWatch();</strong>
 <strong>function startAccelerationWatch() {</strong> <strong>// Update acceleration every 3 seconds</strong> <strong>var options = { frequency: 100 };</strong>
 <strong>accelerationWatchId = navigator.accelerometer.watchAcceleration</strong> <strong>(onSuccess, onError, options);</strong> <strong>}</strong>
 <strong>function stopAccelerationWatch() {</strong> <strong>if (accelerationWatchId) {</strong> <strong>navigator.accelerometer.clearWatch(accelerationWatchId);</strong> <strong>accelerationWatchIdD = null;</strong> <strong>}</strong> <strong>}</strong>
 <strong>function onSuccess(acceleration) {</strong> <strong>if (Math.abs(acceleration.x) &gt; 2 || Math.abs(acceleration.y)&gt;2 </strong> <strong>|| Math.abs(acceleration.z)&gt;2) {</strong> <strong>alert('Acceleration X: ' + acceleration.x + '\n' +</strong> <strong>'Acceleration Y: ' + acceleration.y + '\n' +</strong> <strong>'Acceleration Z: ' + acceleration.z + '\n' +</strong> <strong>'Timestamp: ' + acceleration.timestamp + '\n');</strong> <strong>stopAccelerationWatch()</strong> <strong>chooseButtonsForCard();</strong> <strong>drawScreen();</strong> <strong>startAccelerationWatch();</strong> <strong>}</strong>
 <strong>}</strong>
 <strong>// onError: Failed to get the acceleration</strong> <strong>//</strong> <strong>function onError() {</strong> <strong>alert('onError!');</strong> <strong>}</strong>
The new code begins with the <code>var accelerationWatchId = null;</code> variable setting. 

We have created a <code>startAccelerationWatch()</code> function, which will call the <code>onSuccess()</code> function every <code>100</code> milliseconds.
The <code>onSuccess()</code> function receives the “acceleration” values from the API, which consist of delta changes to the <code>x</code>, <code>y</code>, and <code>z</code> of the device. 
These values are set to <code>0,0,0</code> when the application begins.
On each <code>100</code>-millisecond interval, these values are checked. 

If any is <code>2</code> units greater (in either the positive or negative direction) from the <code>0</code> beginning values, we fire off an <code>alert</code> and then call our functions to reset the card. 
First, we call the <code>stopAccelerationWatch()</code> function, which acts as a reset for the location of the device in physical space. 
Next, we call the <code>chooseButtonsForCard()</code> and <code>drawScreen()</code> functions. 
Finally, we set up the watch again with <code>startAccelerationWatch()</code>.

<h3>Note</h3>
For the most detailed and up-to-date information on integrating PhoneGap with iOS and other device features, visit the PhoneGap documentation website. 
Most of the information for this example is based off the explanation and examples found at <a href="http://docs.phonegap.com/phonegap_accelerometer_accelerometer.md.html">http://docs.phonegap.com/phonegap_accelerometer_accelerometer.md.html</a>.
<h3>Testing on a Device</h3>

Before we can test the application on an actual device, we need to “provision” the device. 
To do this, we will need the device, a paid iOS developer account, and a development Mac computer all synced up into a single provisioning profile. 
This necessary process is not for the faint of heart.
<h4>Step 1: Launch the Provisioning Assistant</h4>

Begin by visiting the Developer Provisioning Assistant (<a href="http://developer.apple.com/iphone">http://developer.apple.com/iphone</a>) and logging in with your paid iOS developer ID. 
Once logged in, click on the link for the “iOS Provisioning Portal” (currently in the upper-right side menu). 
There should be a button called “Launch the Provisioning Assistant.” Click on this button and follow all the on-screen instructions.
<h4>Step 2: Find the device’s Unique ID</h4>

You will be asked to find the Unique ID of your physical device. 
This is found by plugging the device into your computer, and then looking up the ID in Xcode. 
In the Window→Organizer Information window, you will see a list of the attached devices. 
The ID will be a long alphanumeric string next to the word Identifier.

<h4>Step 3: Generate a Certificate Signing Request</h4>
When asked by the Provisioning Assistant, input this ID value. 
You will next be asked to “Generate a Certificate Signing Request”, which involves the Apple Keychain. 
Follow all the on-screen dialogs carefully because this can be a confusing process. 

You will need to open the Keychain Access application in the Applications→Utilities folder on your machine, and then follow the on-screen instructions from the Provisioning Assistant.
<h4>Step 4: Locate saved Certificate Signing Request File</h4>
This will save a Certificate Signing Request File to your desktop. 
In the next step, the Provisioning Assistant will need to find this file, so it is important to remember where you save the request.

After you find the file, the assistant will ask you to name your profile. 
This will generate a file that you must download and install on your Mac.
<h4>Step 5: Drag provisioning file into Xcode Organizer window</h4>
With the location of the downloaded file handy, plug in your device (if it isn’t already plugged in), and open up the Xcode Window→Organizer once again. 

Simply drag the <em>.mobileProvision</em> file into the Organizer window, and it will set up the profile in Xcode automatically.
<h4>Step 6: Set up certificates with the Keychain</h4>
Next, you will be asked to download and install development certificates that match this profile. 
Save the <em>.cer</em> file and double-click it to add it to the Keychain Access list.

You should now see both Public and Private keys paired together with your developer account name inside the Keychain Access provisioning list.
<h4>Success</h4>
Whew! That certainly was not simple, but the Provisioning Assistant is very easy to use as long as you follow each step carefully. 
We are now ready to test the application on a physical device.

<h3>Using Xcode to Target a Test Device</h3>
We will need to change the build profile to target the attached device rather than the simulator. 
To do this, we simply change the drop-down in the upper left from Simulator to Device, as shown in <a href="ch10.html#setting_the_build_target_to_a_device" title="Figure 10-18. 
Setting the build target to a device">Figure 10-18</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893877.png" alt="Setting the build target to a device" width="995" height="729">
Figure 10-18. 
Setting the build target to a device
After all that, now it is time to click the “Build and Run” icon.

After a few seconds, the application will initialize and show up on the device like a normal iOS application.
When running the app on a device, you will be able to click the buttons, hear the sounds, and see the buttons change color. 
When you want to reset the card, give the device a good shake to see the alert box with the current location offsets for the accelerometer. 
Click the OK button, and the card will reset.

<h2>Beyond the Canvas</h2>
A nice set of tools and frameworks are available (with more emerging every day) that can help transform the look and feel of HTML or an HTML5 application (not necessarily just on Canvas) into an iPhone-like application. 
These can be used in conjunction with a canvas app to provide a seamless iPhone look and feel for the user.
If you would like to explore mobile functionality further, we recommend the following technologies, which can be combined with PhoneGap to create very powerful mobile applications:

jQTouch
jQTouch (<a href="http://www.jqtouch.com/">http://www.jqtouch.com/</a>) is a framework that makes use of jQuery to target mobile-device-specific features across platforms that use WebKit (iOS, Palm, Nexus, etc.).

jQuery Mobile Framework
The jQuery Mobile Framework (<a href="http://jquerymobile.com/">http://jquerymobile.com/</a>) is another jQuery-based mobile framework for building cross-platform applications. 

It can be used to create a unified user interface across mobile platforms.
<h2>What’s Next</h2>
As you can see, HTML5 Canvas is a powerful and easy way to target native apps across a variety of mobile devices. 
In this chapter, we built a small game to run in the Safari browser, and then installed PhoneGap and modified the application to run on the iPhone simulator using an Xcode project template. 
Once the simulation was successful, we added in a device-specific accelerometer feature, and then provisioned a physical device for testing. 
Finally, we were able to see our completed application running on an actual iOS device.

In <a href="ch11.html" title="Chapter 11. 
Further Explorations">Chapter 11</a>, we will look at applying multiplayer capabilities to a canvas application using ElectroServer, and we’ll even take a small tour of 3D in Canvas.
 11. 
Further Explorations" epub:type="chapter">

<h2><span class="orange">Chapter 11. Further Explorations</span></h2>
There are many emerging technologies and frameworks that can help take HTML5 Canvas into rarely explored areas. 

In this chapter, we will cover a couple of those areas: using Canvas for 3D with WebGL, and using Canvas for multiplayer applications. 
Both of these areas are still experimental, requiring you to either download beta/developer versions of browsers, or launch browsers using command-line switches so you can turn various technologies off and on.
This chapter is structured a bit differently. 

The discussions are focused on giving you some tools and information about these new and emerging areas for Canvas. 
While we will offer code, examples, and some explanation, it’s geared more toward getting you started on the path to learning than on teaching you how every detail works. 
We have structured these two topics in this way for one very simple reason: <em>they are incomplete</em>. 
With APIs, libraries, locations, browsers, names, etc., all subject to change, we are not comfortable presenting these topics as finished and ready to go. 

You need to approach this chapter knowing that things are bound to go wrong or change frequently.
Having said that, even though these topics are experimental, that does not mean you cannot use them right now, nor does it mean they are not useful or capable of doing very cool things. 
You just need to be aware of the pitfalls before treading forward.
<h2>3D with WebGL</h2>
The 2D capabilities of HTML5 Canvas are impressive, but what about 3D? There is no “production” 3D context available in the standard version of any web browser at this time. 
However, the best support for a 3D context will probably come in the form of WebGL.
<h3>What Is WebGL?</h3>
WebGL is a JavaScript API that gives programmers access to the 3D hardware on the user’s machine. 

Currently, it is only supported by the debug/development versions of Opera, Firefox, and Chrome. 
The API is managed by Kronos, the same organization that manages OpenGL. 
In fact, much of WebGL is similar to programming in OpenGL. 
This is both good and bad. 

It’s good because it’s a standard programming interface that is recognizable to many developers, but bad because it is not as easy to learn as the 2D Canvas context.
<h3>How Do I Test WebGL?</h3>
First, you need to find a web browser that supports WebGL. 
When trying to run a WebGL application, a browser that does not support WebGL might give a message like the one shown in <a href="ch11.html#trying_to_run_webgl_in_a_standard_web_br" title="Figure 11-1. 

Trying to run WebGL in a standard web browser">Figure 11-1</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893879.png" alt="Trying to run WebGL in a standard web browser" width="451" height="186">
Figure 11-1. 
Trying to run WebGL in a standard web browser

<h3>Note</h3>
Chromium, the open source version of Chrome, will display WebGL. 
You can download the latest development build of Chromium from <a href="http://build.chromium.org/f/chromium/continuous/">http://build.chromium.org/f/chromium/continuous/</a>.
Once you have a browser that can display WebGL, you need to write the code to make it happen. 

You start that process by accessing the WebGL context instead of the Canvas <code>2d</code> context. 
So, instead of this code, which we have used throughout this book:
context = theCanvas.getContext("2d");
We reference the <code>experimental-webgl</code> context, like this:

gl = theCanvas.getContext("experimental-webgl");
<h3>How Do I Learn More About WebGL?</h3>
The best place to learn about WebGL is at <a href="http://learningwebgl.com/">http://learningwebgl.com/</a>. 
This site has an FAQ, a blog, and some helpful low-level lessons on how to create apps using WebGL. 

You can also find a ton of great content about WebGL at <a href="http://developer.mozilla.org">http://developer.mozilla.org</a>.
One warning, though: programming WebGL is not for the uninitiated. 
Although WebGL is based on OpenGL, it is still a very low-level API, meaning you will need to create everything by hand. 
At the end of this section, we will guide you toward some higher-level libraries that should make this process a bit easier.

<h3>What Does a WebGL Application Look Like?</h3>
Now we are going to show you a WebGL application demo that rotates a 3D cube on Canvas (see <a href="ch11.html#d_rotating_cube_open_parenthesis_ch11ex1" title="Figure 11-2. 
3D rotating cube (CH11EX1.html)">Figure 11-2</a>). 
Since we are not experts in 3D graphics, we will forgo our practice of describing every line of code in the example; instead, we will highlight interesting sections of code to help you understand what is happening.

This demo is based on Lesson 4 from Giles Thomas’s Learning WebGL website (<a href="http://learningwebgl.com/blog/?p=370">http://learningwebgl.com/blog/?p=370</a>). 
While this is only one short demo, it should give you a very good idea of how to structure and build code for a WebGL application.
<h3>Note</h3>
Much of this code has been adapted from the work of Giles Thomas with his expressed, written permission.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893881.png" alt="3D rotating cube (CH11EX1.html)" width="500" height="500">
Figure 11-2. 
3D rotating cube (CH11EX1.html)
<h4>JavaScript libraries</h4>

First, we add some JavaScript libraries. 
Modernizr 1.6 includes a test for WebGL support in a web browser. 
This version was freshly released, but it could be updated with new features at any time (in fact, at the time of this writing, this had been updated to version 1.7). 
It is necessary to make sure you have the most recent versions of your libraries:

&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
We now need to include some JavaScript libraries to assist with our application. 
<em>sylvester.js</em> and <em>glUtils.as</em> are two libraries that you will find included for most apps that use WebGL. 
<em>sylvester.js</em> (<a href="http://sylvester.jcoglan.com/">http://sylvester.jcoglan.com/</a>) is a library that helps when performing vector and matrix math calculations in JavaScript. 

<em>glUtils.as</em> is an extension for <em>sylvester.js</em>, specifically for helping with math related to WebGL:
&lt;script type="text/javascript" src="sylvester.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="glUtils.js"&gt;&lt;/script&gt;
<h4>Shaders</h4>

<em>Shaders</em> are pieces of code that run directly on a graphics card. 
They describe how a <em>scene</em>—how you refer to a 3D canvas when working with WebGL—should be rendered. 
Many of these little programs perform mathematical transformations that would otherwise run very slowly in JavaScript. 
In fact, we are pointing these out because they are <em>not</em> JavaScript; they are written in a way that WebGL can understand. 

These sections of code will be read in like text files and passed to the graphics hardware. 
Full discussions of topics like shaders are far out of scope for this little section of the book, but we will tell you a bit about each one of them to help set the tone for what comes next.
The first shader below is a <em>fragment shader</em>, which tells the graphics card that we will be using floating-point numbers and blended colors. 
The second shader is the <em>vertex shader</em>. 

It works with the vertices (defined points in 3D space used to create 3D objects) and will be used for every vertex we draw onto the Canvas 3D context:
&lt;script type="x-shader/x-fragment"&gt;
 #ifdef GL_ES precision highp float; #endif varying vec4 vColor;
 void main(void) { gl_FragColor = vColor;
 }

&lt;/script&gt;
&lt;script type="x-shader/x-vertex"&gt;
 attribute vec3 aVertexPosition;
 attribute vec4 aVertexColor; uniform mat4 uMVMatrix;
 uniform mat4 uPMatrix;
 varying vec4 vColor;
 void main(void) { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vColor = aVertexColor; }
&lt;/script&gt;
<h4>Testing for WebGL support with Modernizr</h4>
The structure of the code in this example is much like the other applications we have written in this book. 

However, it has been modified to work with the specific needs of the 3D context. 
In the <code>canvasApp()</code> function, we need to test to see whether the browser has WebGL support. 
This is easily accomplished by using the <code>Modernizr.webgl</code> static constant in Modernizr 1.6:
if ( !webglSupport()) { alert("Unable to initialize WebGL");
 return;
}
function webglSupport() { return Modernizr.webgl;
}
<h4>Initialization in canvasApp()</h4>
In <code>canvasApp()</code> we still get a context, but this time it is the <code>experimental-webgl</code> context. 

Also, just like in our other apps, we still call <code>drawScreen()</code> on an interval to render the canvas:
var theCanvas = document.getElementById("canvasOne");
webGLContext = theCanvas.getContext("experimental-webgl");
setInterval(drawScreen, 33);

However, there is additional code in <code>canvasApp()</code> required to set up the application to rotate the cube. 
A couple of the most important initialization steps are the calls to <code>initShaders()</code> and <code>initBuffers()</code>:
initShaders();
initBuffers();

The <code>initShaders()</code> function itself calls a function named <code>getShader()</code> to load in the text of the <code>shader</code> programs we have already defined. 
You can see the code for these functions in the code listing a bit later in Example 11-1</a>.
<h3>Note</h3>
You can learn about the shaders used in this program in “Lesson 2—Adding colour” on the LearningWebGL website: <a href="http://learningwebgl.com/blog/?p=134">http://learningwebgl.com/blog/?p=134</a>.

Once we have loaded the <code>shader</code> programs, we need to create the buffers. 
<em>Buffers</em> refer to space in the video card’s memory that we set aside to hold the geometry describing our 3D objects. 
In our case, we need to create buffers to describe the cube we will rotate on the canvas. 
We do this in <code>initBuffers()</code>.

The <code>initBuffers()</code> function contains a lot of code, but we’ll discuss only a couple very interesting sections. 
The first is the Vertex Position buffer, which describes the vertices that make up the sides of the cube:
webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexPositionBuffer); vertices = [ // Front face -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, // Back face -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, // Top face -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, // Bottom face -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // Right face 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, // Left face -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, ];

The Vertex Color buffer holds information about the color that will appear on each side of the cube. 
These values are set as percentages of <code>RBGA</code> values (red, green, blue, alpha):
webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexColorBuffer); var colors = [ [1.0, 1.0, 1.0, 1.0], // Front face [0.9, 0.0, 0.0, 1.0], // Back face [0.6, 0.6, 0.6, 1.0], // Top face [0.6, 0.0, 0.0, 1.0], // Bottom face [0.3 ,0.0, 0.0, 1.0], // Right face [0.3, 0.3, 0.3, 1.0], // Left face ];
The Vertex Index buffer is kind of like a map that builds the object (our cube) based on the colors specified in Vertex Color (the order of these elements) and the vertices specified in the Vertex Position buffer. 

Each of these sets of three values represents a triangle that will be drawn onto the 3D context:
webGLContext.bindBuffer(webGLContext.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer); var cubeVertexIndices = [ 0, 1, 2, 0, 2, 3, // Front face 4, 5, 6, 4, 6, 7, // Back face 8, 9, 10, 8, 10, 11, // Top face 12, 13, 14, 12, 14, 15, // Bottom face 16, 17, 18, 16, 18, 19, // Right face 20, 21, 22, 20, 22, 23 // Left face ]
Again, there is more code in <code>initBuffers()</code> than we described here, but start with these three sections when you want to play with the code and make your own objects.
<h4>Animating the cube</h4>

Now that you know a bit about creating an object in WebGL, let’s learn about animating the cube on the canvas. 
Similar to what we did in the 2D context, we use the <code>drawScreen()</code> function to position, draw, and animate objects in the 3D context. 
The first thing we do here is set up the viewport, which defines the canvas’ view of the 3D scene. 
Next, we clear the canvas and then set up the perspective. 

The perspective has four parameters:
Field of view

The angle at which we will view the 3D scene (<code>25</code> degrees).
Width-to-height ratio

The radio of width to height of the current size of the canvas (<code>500×500</code>).
Minimum units

The smallest unit size away from our viewport we want to display (<code>0.1</code>).
Maximum units

The furthest unit size away from our viewport that we want to see (<code>100.0</code>).
function drawScreen() { webGLContext.viewport(0, 0, webGLContext.viewportWidth, webGLContext.viewportHeight);
 webGLContext.clear(webGLContext.COLOR_BUFFER_BIT | webGLContext.DEPTH_BUFFER_BIT);
 perspective(25, (webGLContext.viewportWidth / webGLContext.viewportHeight), 0.1, 100.0);
Next, we move to the center of the 3D scene, calling <code>loadIdentity()</code> so we can start drawing. 

We then call <code>mvTranslate()</code>, passing the locations on the x, y, and z axes to draw the cube. 
To rotate the cube, we call a function named <code>mvPushMatrix()</code>, and later <code>mvPopMatrix()</code>, which is similar to how we called <code>context.save()</code> and <code>context.restore()</code> when rotating objects on the 2D canvas. 
The call to <code>mvRotate()</code> then makes the cube rotate from the center, tilted up and to the right:
loadIdentity();

mvTranslate([0, 0.0, -10.0])
mvPushMatrix();
mvRotate(rotateCube, [0, .5, .5]);
Next, we draw the cube by binding the buffers that hold the vertices and color information that we set up earlier for the cube’s sides. 

We then draw each side, made up of two triangles each:
webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexPositionBuffer);
webGLContext.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, webGLContext.FLOAT, false, 0, 0);
webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexColorBuffer);

webGLContext.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, webGLContext.FLOAT, false, 0, 0);
webGLContext.bindBuffer(webGLContext.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
setMatrixUniforms();webGLContext.drawElements(webGLContext.TRIANGLES, cubeVertexIndexBuffer.numItems, webGLContext.UNSIGNED_SHORT, 0);
mvPopMatrix();

Finally, we increase the <code>rotateCube</code> variable so that the next time <code>drawScreen()</code> is called, the cube will be updated with a new angle. 
The code below adds <code>2</code> degrees to the rotation angle each time <code>drawScreen()</code> is called:
 rotateCube += 2;
 }

<h3>Full Code Listing</h3>
Example 11-1</a> gives the full code listing for <em>CH11EX1.html</em>. 
Notice that many of the code styles and constructs we have used over the past 10 chapters are still in place in this application. 
Besides the obvious inclusion of code related directly to WebGL, this application operates essentially the same way as the other apps we discussed in this book.

Example 11-1. 
WebGL test
&lt;!doctype html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH11EX1: WebGL Test &lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript" src="sylvester.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="glUtils.js"&gt;&lt;/script&gt;
&lt;script type="x-shader/x-fragment"&gt;
 #ifdef GL_ES precision highp float;
 #endif varying vec4 vColor;
 void main(void) { gl_FragColor = vColor; }
&lt;/script&gt;
&lt;script type="x-shader/x-vertex"&gt;
 attribute vec3 aVertexPosition; attribute vec4 aVertexColor;
 uniform mat4 uMVMatrix;
 uniform mat4 uPMatrix;
 varying vec4 vColor; void main(void) { gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0); vColor = aVertexColor;
 }
&lt;/script&gt;
&lt;script type="text/javascript"&gt;

window.addEventListener("load", eventWindowLoaded, false);
function eventWindowLoaded () {
 canvasApp();
}

function canvasSupport () {
 return Modernizr.canvas;
}
function webglSupport() { return Modernizr.webgl;
}
function canvasApp () {
function drawScreen() { webGLContext.viewport(0, 0, webGLContext.viewportWidth, webGLContext.viewportHeight); webGLContext.clear(webGLContext.COLOR_BUFFER_BIT | webGLContext.DEPTH_BUFFER_BIT);
 perspective(25, (webGLContext.viewportWidth / webGLContext.viewportHeight), 0.1, 100.0); loadIdentity();
 mvTranslate([0, 0.0, -10.0])
 mvPushMatrix(); mvRotate(rotateCube, [0, .5, .5]); webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexPositionBuffer); webGLContext.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, webGLContext.FLOAT, false, 0, 0);
 webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexColorBuffer); webGLContext.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, webGLContext.FLOAT, false, 0, 0);
 webGLContext.bindBuffer(webGLContext.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer); setMatrixUniforms(); webGLContext.drawElements(webGLContext.TRIANGLES, cubeVertexIndexBuffer.numItems, webGLContext.UNSIGNED_SHORT, 0);
 mvPopMatrix(); rotateCube += 2; }
 if (!canvasSupport() ) { alert("Unable to initialize Canvas"); return; }
 if ( !webglSupport()) { alert("Unable to initialize WebGL"); return; }
 var webGLContext; var rotateCube = 0; var theCanvas = document.getElementById("canvasOne"); webGLContext =theCanvas.getContext("experimental-webgl"); webGLContext.viewportWidth =theCanvas.width; webGLContext.viewportHeight = theCanvas.height;
 initShaders() initBuffers();
 webGLContext.clearColor(0.0, 0.0, 0.0, 1.0); webGLContext.clearDepth(1.0); webGLContext.enable(webGLContext.DEPTH_TEST); webGLContext.depthFunc(webGLContext.LEQUAL);
 setInterval(drawScreen, 33); function getShader(webglcontext, id) { var shaderScript = document.getElementById(id); if (!shaderScript) { return null; }
 var str = ""; var scriptChild = shaderScript.firstChild; while (scriptChild) { if (scriptChild.nodeType == 3) { str += scriptChild.textContent; } scriptChild = scriptChild.nextSibling; }
 var shader; if (shaderScript.type == "x-shader/x-fragment") { shader = webGLContext.createShader(webGLContext.FRAGMENT_SHADER); } else if (shaderScript.type == "x-shader/x-vertex") { shader = webGLContext.createShader(webGLContext.VERTEX_SHADER); } else { return null; }
 webGLContext.shaderSource(shader, str); webGLContext.compileShader(shader); if (!webGLContext.getShaderParameter(shader, webGLContext.COMPILE_STATUS)) { alert(webGLContext.getShaderInfoLog(shader)); return null; }
 return shader; }
 var shaderProgram;
 function initShaders() { var fragmentShader = getShader(webGLContext, "shader-fs"); var vertexShader = getShader(webGLContext, "shader-vs"); shaderProgram = webGLContext.createProgram(); webGLContext.attachShader(shaderProgram, vertexShader); webGLContext.attachShader(shaderProgram, fragmentShader); webGLContext.linkProgram(shaderProgram);
 if (!webGLContext.getProgramParameter(shaderProgram, webGLContext.LINK_STATUS)) { alert("Could not initialize shaders"); }
 webGLContext.useProgram(shaderProgram);
 shaderProgram.vertexPositionAttribute = webGLContext.getAttribLocation (shaderProgram, "aVertexPosition"); webGLContext.enableVertexAttribArray(shaderProgram.vertexPositionAttribute); shaderProgram.vertexColorAttribute = webGLContext.getAttribLocation (shaderProgram, "aVertexColor"); webGLContext.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
 shaderProgram.pMatrixUniform = webGLContext.getUniformLocation (shaderProgram, "uPMatrix"); shaderProgram.mvMatrixUniform = webGLContext.getUniformLocation (shaderProgram, "uMVMatrix"); }
 var mvMatrix; var mvMatrixStack = [];
 function mvPushMatrix(matrix) { if (matrix) { mvMatrixStack.push(matrix.dup()); mvMatrix = matrix.dup(); } else { mvMatrixStack.push(mvMatrix.dup()); } } function mvPopMatrix() { if (mvMatrixStack.length == 0) { throw "Invalid popMatrix!"; } mvMatrix = mvMatrixStack.pop(); return mvMatrix; }
 function loadIdentity() { mvMatrix = Matrix.I(4); }
 function multMatrix(matrix) { mvMatrix = mvMatrix.x(matrix); }
 function mvTranslate(vector) { var matrix = Matrix.Translation($V([vector[0], vector[1], vector[2]])).ensure4x4(); multMatrix(matrix); } function mvRotate(angle, vector) { var radians = angle * Math.PI / 180.0; var matrix = Matrix.Rotation(radians, $V([vector[0], vector[1], vector[2]])).ensure4x4(); multMatrix(matrix); }
 var pMatrix; function perspective(fovy, aspect, znear, zfar) { pMatrix = makePerspective(fovy, aspect, znear, zfar); }
 function setMatrixUniforms() { webGLContext.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten())); webGLContext.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten())); }
 var cubeVertexPositionBuffer; var cubeVertexColorBuffer; var cubeVertexIndexBuffer; function initBuffers() {
 cubeVertexPositionBuffer = webGLContext.createBuffer(); webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexPositionBuffer); vertices = [ // Front face -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, // Back face -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, // Top face -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, // Bottom face -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // Right face 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, // Left face -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, ]; webGLContext.bufferData(webGLContext.ARRAY_BUFFER, new Float32Array(vertices), webGLContext.STATIC_DRAW); cubeVertexPositionBuffer.itemSize = 3; cubeVertexPositionBuffer.numItems = 24;
 cubeVertexColorBuffer = webGLContext.createBuffer(); webGLContext.bindBuffer(webGLContext.ARRAY_BUFFER, cubeVertexColorBuffer); var colors = [ [1.0, 1.0, 1.0, 1.0], // Front face [0.9, 0.0, 0.0, 1.0], // Back face [0.6, 0.6, 0.6, 1.0], // Top face [0.6, 0.0, 0.0, 1.0], // Bottom face [0.3 ,0.0, 0.0, 1.0], // Right face [0.3, 0.3, 0.3, 1.0], // Left face ]; var unpackedColors = [] for (var i in colors) { var color = colors[i]; for (var j=0; j &lt; 4; j++) { unpackedColors = unpackedColors.concat(color); } } webGLContext.bufferData(webGLContext.ARRAY_BUFFER, new Float32Array(unpackedColors), webGLContext.STATIC_DRAW); cubeVertexColorBuffer.itemSize = 4; cubeVertexColorBuffer.numItems = 24;
 cubeVertexIndexBuffer = webGLContext.createBuffer(); webGLContext.bindBuffer(webGLContext.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer); var cubeVertexIndices = [ 0, 1, 2, 0, 2, 3, // Front face 4, 5, 6, 4, 6, 7, // Back face 8, 9, 10, 8, 10, 11, // Top face 12, 13, 14, 12, 14, 15, // Bottom face 16, 17, 18, 16, 18, 19, // Right face 20, 21, 22, 20, 22, 23 // Left face ] webGLContext.bufferData(webGLContext.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), webGLContext.STATIC_DRAW); cubeVertexIndexBuffer.itemSize = 1; cubeVertexIndexBuffer.numItems = 36;
 }
}

&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;

&lt;canvas width="500" height="500"&gt;
 Your browser does not support HTML5 Canvas or WebGLContext.
&lt;/canvas&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Further Explorations with WebGL</h3>
Obviously, we cannot teach you all about WebGL in this chapter. 

We opted to include this demo and short discussion to introduce you to WebGL and show you what it looks like. 
In reality, a full discussion of WebGL, even the basic concepts, could take up an entire volume.
If you are interested in WebGL, we strongly recommend you consult <a href="http://learningwebgl.com">http://learningwebgl.com</a> for more examples and the latest information about this exciting yet still experimental context for HTML5 Canvas.
<h3>WebGL JavaScript Libraries</h3>

At the start of this section, we promised to show you some libraries that can be used with WebGL to make it easier to develop applications. 
Here are some of the more interesting libraries and projects.
<h4>Google O3D</h4>
Google’s O3D library (<a href="http://code.google.com/p/o3d/">http://code.google.com/p/o3d/</a>) was once a browser plug-in but has now been released as a standalone JavaScript library for WebGL. 

The examples of using O3D with JavaScript—including a fairly spectacular 3D pool game—are very impressive. 
O3D allows you to load COLLADA 3D models created with Google SketchUp (as well as other 3D packages).
The required code looks about as complex as straight WebGL code, so while this is very powerful, you might want to look at some of the other libraries here first if you are just starting out.
<h4>GLGE</h4>

“WebGL for the lazy” is the tagline for this JavaScript library (<a href="http://www.glge.org/">http://www.glge.org/</a>). 
The author of the library, Paul Brunt, says this about GLGE:
<blockquote>
The aim of GLGE is to mask the involved nature of WebGL from the web developer, who can then spend his/her time creating richer content for the Web.

</blockquote>
This is a high-level API that is still in development. 
Just like O3D, it has the ability to load COLLADA models. 
Applications written with GLGE are created with a combination of XML and JavaScript. 

It looks very promising.
<h4>C3DL</h4>
The tagline for C3DL (<a href="http://www.c3dl.org/">http://www.c3dl.org/</a>) is “WebGL made easy!” C3DL, or “Canvas 3D JS Library,” is similar to GLGE, but it seems to have a head start thanks to a larger API and more support. 
This library also appears to be slanted toward games, as a real-time strategy (RTS) and an arcade game are featured as its more prominent demos. 

The library supports COLLADA models, and the code also appears very straightforward to implement.
<h4>SpiderGL</h4>
“3D Graphics for Next-Generation WWW” is how SpiderGL (<a href="http://spidergl.org/">http://spidergl.org/</a>) bills itself to the world. 
This library appears to be very similar to GLGE and C3DL, except that the demos focus more on lighting, color, and textures than on games and applications. 

It also supports COLLADA models.
<h4>SceneJS</h4>
SceneJS (<a href="http://scenejs.org/">http://scenejs.org/</a>) is geared toward rendering 3D scenes built as COLLADA JSON models in WebGL. 
You can also define and manipulate 3D scenes. 

Loading and rendering the models is a straightforward process, and the results are quite impressive.
<h4>CopperLicht</h4>
This commercial library (<a href="http://www.ambiera.com/copperlicht/">http://www.ambiera.com/copperlicht/</a>) advertises itself as the “fast WebGL JavaScript 3D Engine.” All the demos are game-oriented, and the library supports many commercial 3D formats. 
It has both collision detection and physics built in. 

The demos are fast and are fun to play. 
This library appears to be centered around loading and using external 3D assets, so if that is what you are looking for, this might be your best choice.
<h2>Multiplayer Applications with ElectroServer 5</h2>
The extended HTML5 specification includes an API for what is known as <em>Web</em><em>Sockets</em>. 

Socket communications allow a client application to remain constantly connected to a server-aide application. 
This type of communication can be especially useful for chat, multiplayer games, e-learning applications, and multiuser whiteboards, as well as many others. 
At this point, WebSockets is just a promise with very little support beyond test and development builds of web browsers. 
In fact, security concerns have halted some implementations and slowed others. 

However, this does not mean you cannot make use of socket-server applications with HTML5 Canvas.
Because Flash has built-in support for communication via sockets, its applications have had the ability to open socket communications with server-side applications for many years. 
HTML, on the other hand, has never had the ability to reliably communicate to a socket server without performing some sleight of hand, usually involving constant polling by the web browser for new information from the web server.
ElectroServer from Electrotank was one of the first reliable socket-server applications built to communicate with Flash clients. 

Over the past couple years, ElectroServer has been updated with APIs for iOS, C#, C++, and now JavaScript. 
This first iteration of the ElectroServer JavaScript API does not use WebSockets, but instead implements JavaScript polling. 
However, with the availability of ElectroServer’s simplified JavaScript API, you can still start to write multiplayer applications using HTML5 Canvas.
<h3>Note</h3>

While this portion of the chapter is specific to ElectroServer, many of the multiplayer/multiuser concepts are applicable to other technologies as well.
<h3>Installing ElectroServer</h3>
To get started with multiplayer development using HTML5 Canvas and the ElectroServer socket server, you first need to download the free, 25-user version of the software from Electrotank. 
You can download the appropriate version for your operating system (Windows, Mac, Linux) at <a href="http://www.electrotank.com/resources/downloads.html">http://www.electrotank.com/resources/downloads.html</a>.

<h3>Note</h3>
There are some installation prerequisites, such as having Java version 1.6. 
For detailed installation instructions for every OS, visit <a href="http://www.electrotank.com/docs/es5/manual/index.html?operating_system.htm">http://www.electrotank.com/docs/es5/manual/index.html?operating_system.htm</a>.
The install package includes the server software, client APIs, documentation, and sample applications. 

Once you have installed the server software, you should have a folder named something like “Electroserver_5_x_” on your computer. 
We used Mac OS X for this test, so this folder was created inside the Mac Applications folder. 
On Windows, it will be created in the location you specify upon installation.
<h4>Starting the server</h4>

Once you have the files installed, you need to start the ElectroServer socket server by finding the installation directory and executing the file <em>Start_ElectroServer_5_0_1</em>. 
(Note: the three numbers at the end of this file will change as the version is upgraded, but the concept will remain the same.)
When ElectroServer starts, you should see a screen similar to <a href="ch11.html#electroserver_started" title="Figure 11-3. 
ElectroServer started">Figure 11-3</a>.

<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893883.png" alt="ElectroServer started" width="505" height="365">
Figure 11-3. 
ElectroServer started
The server will run on your local machine for testing purposes. 

However, for any real-world application, you will need to install a production version of the software on a web server.
<h4>The ElectroServer admin tool</h4>
Because ElectroServer is a socket server, it listens on a specified port for communication from the JavaScript client using one of the supported protocols. 
ElectroServer supports multiple protocols, but we need to make sure we are using the <em>BinaryHTTP</em> protocol for the JavaScript API. 

The default port for BinaryHTTP in ElectroServer is 8989.
<h3>Note</h3>
When the ElectroServer JavaScript API is updated to support WebSockets, the port and protocol will likely be different.
There is a nifty admin tool for ElectroServer that allows you to view and modify all the supported protocols and ports, as well as many other cool features of the socket server. 

In the <em>/admin</em> directory of the install folder, you should find both an installer for an Adobe AIR admin tool (named something like <em>es5-airadmin-5.0.0.air</em>), and a <em>/webadmin</em> directory with an HTML file named <em>webadmin.html</em>. 
Either one will work for this exercise.
<h3>Note</h3>
In order for the admin console to display properly, the server needs to be started.

When you launch the admin tool, you will be asked to supply a username and password. 
The default is <code>administrator</code> and <code>password</code>, unless you changed them upon installation.
Once you log in, click the Server Management button on the top menu, and then the Gateways option from the side menu. 
You should see a screen that looks similar to <a href="ch11.html#electroserver_ports_and_protocols" title="Figure 11-4. 

ElectroServer ports and protocols">Figure 11-4</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893885.png" alt="ElectroServer ports and protocols" width="1000" height="754">
Figure 11-4. 
ElectroServer ports and protocols

This screen shows you the port settings for each protocol that ElectroServer supports. 
For the JavaScript API, we are most interested in the BinaryHTTP setting, which you can see is set to port 8989.
<h4>The JavaScript API</h4>
Besides starting ElectroServer, you will also need the JavaScript API so you can begin building Canvas apps that connect to the server. 

You should be able to find the JavaScript API in the <em>/apis/client/javascript</em> directory of the folder in which you installed ElectroServer (this name might change in the final version). 
The API should be named <em>ElectroServer-5-Client-JavaScript.js</em>.
<h3>The Basic Architecture of a Socket-Server Application</h3>
Now that you have ElectroServer ready to go, and you have the JavaScript API, it is time to learn a bit about how socket-server-based multiplayer/multiuser applications are designed. 

Using a socket server means you are creating an application that relies on a client for input from a user, as well as relying on a server to distribute that input to other users who are connected to the first user.
A good example of this is a chat application. 
Most chat applications require a user to enter a <em>room</em> (a logical space in which people are “chatting,” i.e., exchanging messages), where that user can see the messages of other people in the same virtual space. 
In that room, the client is “connected” to those other users. 

However, it is usually not a direct connection (e.g., peer-to-peer), but instead a connection through a port to a socket server.
The socket server acts as the traffic cop for the chat messages. 
It listens on a port (in our case, 8989) for messages coming in from the clients. 
Those messages need to be formatted in a way that the server can understand so it can process them. 

The JavaScript API we will use performs this formatting for our client applications.
When the socket server receives a message from the client, it routes the various text messages sent by each client back out to the other clients in the room. 
However, it can also do much more by using server-side processing, such as hold the list of current messages, so people entering the room while the chat is ongoing can see what has been said previously, scan chat messages for swear words, award points to users for their input, or anything else you can dream up.
When the server finally processes the message and sends it back, the client then processes that message. 

In the case of the chat, that processing usually involves displaying the message on the canvas.
<h3>The Basic Architecture of an ElectroServer Application</h3>
ElectroServer acts very much like the socket-server application we described in the previous section. 
It listens on specified ports for different protocols; when messages arrive, they are routed back to the connected clients.

However, ElectroServer has some specific features that we should discuss. 
Some of these exist on other socket-server platforms, while some don’t. 
However, much of this discussion will still be applicable to other socket servers once they make JavaScript APIs available.
<h4>Client</h4>

The client for an ElectroServer application is a program written in one of the API-supported language platforms, including Flash ActionScript 2, Flash ActionScript 3, Java, Objective-C, C#/.NET, and now JavaScript. 
The client is the application, which the user will manipulate to send messages through the API to ElectroServer. 
This is usually a game, a chat room, a virtual world, or some other kind of multiuser social or communication application.
All the communication with ElectroServer is <em>event</em>-based. 

The client application uses the JavaScript API to send events, and the client defines event handlers that listen for messages from ElectroServer. 
All of these messages and events are communicated through the API, which in turn is communicating through port 8989 using the BinaryHTTP protocol (at least for our examples).
<h4>Zones, rooms, and games</h4>
When a user first connects to ElectroServer, she needs to join or create a <em>zone</em>, which is simply a collection of rooms. 

If the user tries to create a zone that already exists, she will be added to that zone without creating a new one.
After entering a zone, the user needs to join a room in that zone. 
If a user attempts to create a new room that already exists, she will be added to that room instead.
<h3>Note</h3>

Beyond zones and rooms, ElectroServer also offers a GameManager API that allows you to further segment users into specific instances of a game that is being played. 
We do not get this granular for the examples in this chapter.
<h4>Extensions</h4>
Extensions are server-side code modules that can process data sent by clients before that data is sent back to other clients. 

Extensions can also process and create their own events. 
For many games, the extension contains much of the game logic, relying on the clients for displaying and gathering user input.
At the very minimum, an extension contains what is known as a <em>plug-in</em>. 
A plug-in is a code module written in ActionScript 1 (basically JavaScript) or Java that can be instantiated and scoped to a room. 

For example, if you were making a card game, you would want a card game plug-in on the server to handle things like shuffling the deck and making sure the correct player wins a hand. 
In this way, the server holds the true state of the game. 
Using an extension helps keep a game flowing and lessens the users’ ability to cheat. 
For the simple examples in this chapter, we will not be using any server-side extensions. 

However, if you delve further into ElectroServer or other socket-server applications, you should make sure to learn as much as possible about them.
<h3>Creating a Chat Application with ElectroServer</h3>
As an example, we are going to create a single chat application using the ElectroServer JavaScript API. 
Users will submit a chat message through an HTML form, and the displayed chat will be in HTML5 Canvas. 

We are also going to create and display some messages from ElectroServer so you can see the status of the connection to the server.
<h4>Establishing a connection to ElectroServer</h4>
First, a client application is written so that it includes the ElectroServer JavaScript API:
&lt;script src="ElectroServer-5-Client-JavaScript.js"&gt;&lt;/script&gt;

The client application makes a connection to ElectroServer running on a server at a specific URL, listening on a specific port, using a specific protocol. 
For our examples, this will be <code>localhost</code>, <code>8989</code>, and <code>BinaryHTTP</code>, respectively.
We need to use these values to make a connection from the client to the server. 
We do this by first creating an instance of the <code>ElectroServer</code> object, and then calling its methods. 

We start by creating an instance of an ElectroServer server connection named <code>server</code>. 
We then configure a new variable named <code>availableConnection</code> with the previous properties we described, then add it to the server variable with a call to the method <code>addAvailableConnection()</code>. 
We will create all of this code inside our <code>canvasApp()</code> function:
var server = new ElectroServer.Server("server1");

var availableConnection = new ElectroServer.AvailableConnection ("localhost", 8989, ElectroServer.TransportType.BinaryHTTP);
server.addAvailableConnection(availableConnection);
Now, we need to use the <code>server</code> variable we just configured to establish a connection to <code>ElectroServer</code>. 
We do this by setting a new variable, <code>es</code>, as an instance of the class <code>ElectroServer</code>. 

We then call its <code>initialize()</code> method and add the server we just configured to the <code>es</code> object by calling the <code>addServer()</code> method of the <code>ElectroServer</code> server engine property:
var es = new ElectroServer();
es.initialize();
es.engine.addServer(server);

We are almost ready to try to connect to ElectroServer. 
First though, we need to create some event handlers for <code>ElectroServer</code> events. 
Remember when we told you that all the communication with ElectroServer is done through creating and listening for events? This is where that process begins. 
We need to listen for the following events: <code>ConnectionResponse</code>, <code>LoginResponse</code>, <code>JoinRoomEvent</code>, <code>JoinZoneEvent</code>, <code>ConnectionAttemptResponse</code>, and <code>PublicMessageEvent</code>:

es.engine.addEventListener(MessageType.ConnectionResponse, onConnectionResponse);
es.engine.addEventListener(MessageType.LoginResponse, onLoginResponse);
es.engine.addEventListener(MessageType.JoinRoomEvent, onJoinRoomEvent);
es.engine.addEventListener(MessageType.JoinZoneEvent, onJoinZoneEvent);

es.engine.addEventListener(MessageType.ConnectionAttemptResponse, onConnectionAttemptResponse);
es.engine.addEventListener(MessageType.PublicMessageEvent, onPublicMessageEvent);
Finally, once we have everything ready, we call the <code>connect</code> method of the <code>ElectroServer</code> object, and wait for events to be handled by the event listener functions we have just established:
es.engine.connect();

When the <code>ElectroServer</code> API object tries to connect to an ElectroServer server, a <code>ConnectionAttemptResponse</code> event will be fired back to the client from the server. 
We handle that event with the <code>onConnectionAttemptResponse()</code> event handler. 
For our application, we don’t do anything with this event, except create a status message for it that we will display. 
The <code>statusMessages</code> variable is an array of messages that we keep around to display back as debug information for our chat application. 

We will discuss this briefly in the next section:
function onConnectionAttemptResponse(event) {
 statusMessages.push("connection attempt response!!");
}

At this point, the client waits for a <code>ConnectionResponse</code> event to be sent back from the ElectroServer server. 
When the client application receives a <code>ConnectionResponse</code> event, it handles it with the <code>onConnectionResponse()</code> event handler. 
Once the connection is established, the client then attempts to log on to the server. 
To make a logon attempt, we need a username. 

We will create a random username, but it could come from an account on a web server, a <code>form</code> field or cookie, Facebook Connect, or any other location or service you might have available.
After we have a username, we create a <code>LoginRequest()</code> object, set the <code>userName</code> property, and then call the <code>send()</code> method of the <code>es.engine</code> object. 
This is how we will send all messages to ElectroServer from this point forward:
function onConnectionResponse(event) { statusMessages.push("Connect Successful?: "+event.successful);
 var r = new LoginRequest();
 r.userName = "CanvasUser_" + Math.floor(Math.random() * 1000);
 es.engine.send(r); }
When ElectroServer responds from the <code>LoginRequest</code>, it is time to join a <code>zone</code> and a <code>room</code>. 
Recall that any user connected to ElectroServer needs to belong to a <code>room</code>, and every <code>room</code> belongs to a <code>zone</code>. 
Therefore, we need to make a user belong to one of each, which we accomplish with a <code>CreateRoomRequest()</code>. 

We set the <code>zoneName</code> property to <code>TestZoneChat</code>, and the <code>roomName</code> property to <code>TestRoomChat</code>. 
If either of these do not already exist, they will be created by the server. 
If they do exist, the user will be added to them. 
We then send the message to ElectroServer:

function onLoginResponse(event) {
 statusMessages.push("Login Successful?: "+event.successful);
 username = event.userName;
 var crr = new CreateRoomRequest(); crr.zoneName = "TestZoneChat";
 crr.roomName = "TestRoomChat";
 es.engine.send(crr);
}

We still need to wait for a couple responses from ElectroServer events that come back through the API via port 8989. 
We know we have to join a <code>zone</code>, and we handle the event with the function <code>onJoinZoneEvent()</code>, but we don’t need to do anything with it:
function onJoinZoneEvent(event) {
 statusMessages.push("joined a zone");

}
The most important event we are waiting to handle is <code>JoinRoomEvent</code>. 
When we receive this event, we know that we have joined both a <code>zone</code> and a <code>room</code>, and the application is ready to run. 
For the chat application, this means the user can start typing and sending messages. 

First, we set the <code>_room</code> variable equal to the <code>Room</code> object, which was returned by the event from <code>ElectroServer</code>. 
We will use this variable for our further communications with <code>ElectroServer</code>. 
The other thing we do in this function is set an HTML <code>&lt;div&gt;</code> with the id of <code>inputForm</code>, which is made visible by changing its style. 
The <code>inputForm &lt;div&gt;</code> is invisible when the page loads. 

We do this so the user won’t send chat messages before the connection to <code>ElectroServer</code> is established. 
Now that everything is ready to go, we display the <code>inputForm &lt;div&gt;</code> so chatting can start:
function onJoinRoomEvent(event) { statusMessages.push("joined a room"); _room = es.managerHelper.zoneManager.zoneById (event.zoneId).roomById(event.roomId); var formElement = document.getElementById("inputForm"); formElement.setAttribute("style", "display:true"); }
<h4>Creating the chat functionality</h4>

Now that we have established a connection to ElectroServer and joined a zone and a room, the chat application can start.
First, let’s talk a bit about a few more variables we have created in our <code>canvasApp()</code> function, which we must scope to the rest of the chat application. 
The <code>status</code><code>Messages</code> array will hold a set of messages that we want to keep about the connection to <code>ElectroServer</code>. 
We will display these in a box on the right side of the canvas. 

The <code>chatMessages</code> array holds all the messages users have sent into the chat room. 
The <code>username</code> variable holds the name of the user who is running the Canvas application, and <code>_room</code> is a reference to the <code>room</code> object that user has joined:
var statusMessages = new Array();
var chatMessages = new Array();

var username;
var _room;
The HTML page holds a <code>&lt;form&gt;</code> that we will use to collect the chat messages from the user. 
It contains a text box for the user to type into (the id of <code>textBox</code>), and a button with the id of <code>sendChat</code>. 

This is the same form that was invisible until we received the <code>JoinRoomEvent</code> event:
&lt;form&gt;
&lt;input placeholder="your text" /&gt;
&lt;input type="button" id ="sendChat" value="Send"/&gt;

&lt;/form&gt;
In <code>canvasApp()</code>, we set up an event listener for when the user clicks the <code>sendChat</code> button. 
When a click event occurs, the function <code>sendMessage</code> handles the event:
var formElement = document.getElementById("sendChat");

formElement.addEventListener('click', sendMessage, false);
The <code>sendMessage()</code> function is one of the most important functions in this application. 
This is where we create a couple very critical objects for communicating with ElectroServer. 
The first is a <code>PublicMessageRequest</code>, which is one of several types we can make to the ElectroServer socket server. 

Others include a <code>PrivateMessageRequest</code> and a <code>PluginMessageRequest</code>. 
A <code>PublicMessageRequest</code> is a message that will be sent to everyone in the room. 
We send that data using an <code>EsObject</code>, which is native to the ElectroServer API. 
It allows you to create and access ad hoc data elements for any type of information you want to send to other users in the same room.

<h3>Note</h3>
For a full discussion of <code>EsObject</code> and <code>ElectroServer</code> events, see the ElectroServer documentation. 
It is installed with the server on your local machine in <em><code>[your install folder]</code></em><em>//documentation/html/index.html *</em>.
For this simple chat example, we want to send the chat message the user typed and submitted. 

To do this, we will use the <code>setString()</code> method of <code>EsObject</code>. 
This method takes two parameters: the text you want to send, and an identifier you can use to access the text. 
We also set another element named <code>type</code>, which will tell us what kind of message we are sending. 
We do this because in a more complicated application, you may send all sorts of messages and need a way to identify what they are so you can process them.

Once we have configured our <code>PublicMessageEvent</code> with the <code>roomId</code>, the <code>zoneId</code>, and the <code>EsObject</code>, we call <code>es.engine.send(pmr)</code> to send it to the rest of the room:
function sendMessage(event) {
 var formElement = document.getElementById("textBox");
 var pmr = new PublicMessageRequest(); pmr.message = "";
 pmr.roomId = _room.id;
 pmr.zoneId = _room.zoneId;
 var esob = new ElectroServer.EsObject(); esob.setString("message", formElement.value);
 esob.setString("type","chatmessage");
 pmr.esObject = esob;
 es.engine.send(pmr); statusMessages.push("message sent")
}
Notice that we did not print the user’s chat message to the canvas when it was submitted. 
Instead, we will wait for the <code>PublicMessageEvent</code> to return from <code>ElectroServer</code>, and then handle it like all the other chats. 

This keeps the interface clean, while preserving a create event/handle event processing model across the entire application.
After the socket server processes the chat message, it is broadcast out to all the users in the room. 
All the users must create an event handler for a <code>PublicMessageEvent</code> so they can receive and process the message; we have created the <code>onPublicMessageEvent</code> handler for this purpose. 
This function is very simple. 

It checks the <code>type EsObject</code> variable we set to see whether it is a <code>chatmessage</code>. 
If so, it pushes a string that includes the user who submitted the message (<code>event.userName</code>) and the message itself (<code>esob.getString("message")</code>) into the <code>chatMessages</code> array. 
This is what will be displayed on the canvas:
function onPublicMessageEvent(event) { var esob = event.esObject;
 statusMessages.push("message received")
 if (esob.getString("type") == "chatmessage") {
 chatMessages.push(event.userName + ":" + esob.getString("message")); }
}
Now, all that remains is to display the messages that we have collected. 
We do this (where else?) in <code>drawScreen()</code>. 

For both the <code>statusMessages</code> and <code>chatMessages</code> arrays, we need to display the “current” <code>22</code> messages (if we have <code>22</code>), and start them at the <code>y</code> position of <code>15</code> pixels. 
We only display the last <code>22</code> messages so both the chat and the status messages will appear to scroll up the screen as more chatting and status messages are generated:
var starty = 15;
var maxMessages = 22;

If the array is larger than <code>maxMessages</code>, we display only the latest <code>22</code>. 
To find those messages, we set a new variable named <code>starti</code> to the length of the <code>statusMessages</code> array, subtracted by the value in <code>maxMessages</code>. 
This gives us the index into the array of the first message we want to display. 
We do the exact same thing for the <code>chatMessages</code> array:

//status box context.strokeStyle = '#000000'; context.strokeRect(345, 10, 145, 285); var starti = 0;
 if (statusMessages.length &gt; maxMessages) { starti = (statusMessages.length) - maxMessages;
 } for (var i = starti;i&lt; statusMessages.length;i++) { context.fillText (statusMessages[i], 350, starty ); starty+=12;

//chat box context.strokeStyle = '#000000'; context.strokeRect(10, 10, 335, 285);
 starti = 0; lastMessage = chatMessages.length-1; if (chatMessages.length &gt; maxMessages) { starti = (chatMessages.length) - maxMessages; } starty = 15; for (var i = starti;i&lt; chatMessages.length;i++) { context.fillText (chatMessages[i], 10, starty ); starty+=12; } }
That’s it! We’ve finished developing our multiuser chat application.
<h3>Testing the Application in Google Chrome</h3>

To test the current ElectroServer JavaScript API, you need to start Google Chrome with web security disabled. 
The method of doing this varies by OS, but on Mac OS X, you can open a Terminal session and execute the following command (which will open Chrome if you have it in your Applications folder):
/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security
On a Windows PC, input a command similar to this from a command prompt or from a <em>.bat</em> file:

"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe" --disable-web-security
<h3>Note</h3>
Obviously this is not a workable solution for a production application. 
As Electrotank (and other companies who make similar products) continue to improve the functionality of their APIs and add support for HTML5 WebSockets, this limitation should disappear.

The best way to test a multiplayer application on your own development machine is to open two web browsers, or two web browser windows, at the same time. 
When you look at <em>CH11EX2.html</em> in Google Chrome using this method, you should see something that looks like <a href="ch11.html#electroserver_chat_demo_on_the_canvas_wi" title="Figure 11-5. 
ElectroServer chat demo on the canvas with JavaScript API">Figure 11-5</a>.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893887.png" alt="ElectroServer chat demo on the canvas with JavaScript API" width="1000" height="508">

Figure 11-5. 
ElectroServer chat demo on the canvas with JavaScript API
The full source code is listed in Example 11-2</a>.
Example 11-2. 

ES5 chat demo
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH11EX2: ES5 Chat Demo&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script src="ElectroServer-5-Client-JavaScript.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);
 function eventWindowLoaded () { canvasApp();
} function canvasSupport () { return Modernizr.canvas;
}
 function canvasApp () {
 if (!canvasSupport()) { return; } var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 var formElement = document.getElementById("sendChat"); formElement.addEventListener('click', sendMessage, false);
 function drawScreen() { //background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, 500, 320);
 context.fillStyle = "#000000"; context.font = "10px _sans"; context.textBaseline = "top"; //box context.strokeStyle = '#000000'; context.strokeRect(5, 5, 490, 310);
 var starty = 15; var maxMessages = 22;
 //status box context.strokeStyle = '#000000'; context.strokeRect(345, 10, 145, 285); var starti = 0;
 if (statusMessages.length &gt; maxMessages) { starti = (statusMessages.length) - maxMessages; } for (var i = starti;i&lt; statusMessages.length;i++) { context.fillText (statusMessages[i], 350, starty ); starty+=12; }
 //chat box context.strokeStyle = '#000000'; context.strokeRect(10, 10, 335, 285);
 starti = 0; lastMessage = chatMessages.length-1; if (chatMessages.length &gt; maxMessages) { starti = (chatMessages.length) - maxMessages; } starty = 15; for (var i = starti;i&lt; chatMessages.length;i++) { context.fillText (chatMessages[i], 10, starty ); starty+=12; }
 context.fillText ("User Name:" + username, 10, 295 ); }
 var statusMessages = new Array(); var chatMessages = new Array();
 var server = new ElectroServer.Server("server1");
 statusMessages.push(server); var availableConnection = new ElectroServer.AvailableConnection ("localhost", 8989, ElectroServer.TransportType.BinaryHTTP);
 server.addAvailableConnection(availableConnection);
 var es = new ElectroServer(); es.initialize();
 var username; var _room; es.engine.addServer(server);
 es.engine.addEventListener(MessageType.ConnectionResponse, onConnectionResponse); es.engine.addEventListener(MessageType.LoginResponse, onLoginResponse); es.engine.addEventListener(MessageType.JoinRoomEvent, onJoinRoomEvent); es.engine.addEventListener(MessageType.JoinZoneEvent, onJoinZoneEvent); es.engine.addEventListener(MessageType.ConnectionAttemptResponse, onConnectionAttemptResponse); es.engine.addEventListener(MessageType.PublicMessageEvent, onPublicMessageEvent);
 es.engine.connect();
 statusMessages.push("Connecting..."); setInterval(drawScreen, 33);
 function onConnectionAttemptResponse(event) { statusMessages.push("connection attempt response!!"); }
 function onJoinRoomEvent(event) { statusMessages.push("joined a room"); _room = es.managerHelper.zoneManager.zoneById (event.zoneId).roomById(event.roomId); var formElement = document.getElementById("inputForm"); formElement.setAttribute("style", "display:true"); }
 function onJoinZoneEvent(event) { statusMessages.push("joined a zone"); }
 function onConnectionResponse(event) { statusMessages.push("Connect Successful?: "+event.successful); var r = new LoginRequest(); r.userName = "CanvasUser_" + Math.floor(Math.random() * 1000); es.engine.send(r); }
 function onLoginResponse(event) { statusMessages.push("Login Successful?: "+event.successful);
 username = event.userName; var crr = new CreateRoomRequest(); crr.zoneName = "TestZoneChat"; crr.roomName = "TestRoomChat";
 es.engine.send(crr); }
 function sendMessage(event) { var formElement = document.getElementById("textBox"); var pmr = new PublicMessageRequest(); pmr.message = ""; pmr.roomId = _room.id; pmr.zoneId = _room.zoneId; var esob = new ElectroServer.EsObject(); esob.setString("message", formElement.value); esob.setString("type","chatmessage"); pmr.esObject = esob; es.engine.send(pmr); statusMessages.push("message sent")
 } function onPublicMessageEvent(event) {
 var esob = event.esObject; statusMessages.push("message received") if (esob.getString("type") == "chatmessage") {
 chatMessages.push(event.userName + ":" + esob.getString("message"));
 } }
}
&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;div&gt;
&lt;canvas width="500" height="320"&gt;
 Your browser does not support HTML5 Canvas.

&lt;/canvas&gt;
&lt;div &gt;
&lt;form&gt;
&lt;input placeholder="your text" /&gt;

&lt;input type="button" id ="sendChat" value="Send"/&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
<h3>Further Explorations with ElectroServer</h3>
Displaying text on HTML5 Canvas is interesting, but as we have shown you in this book, you can do much more. 

Let’s add some graphics to the previous demo. 
We have added a second application for you to peruse, named <em>CH11EX3.html</em>. 
This application adds the bouncing ball demo app from Chapter 5</a> to the chat application we just created. 

It allows chatters to “send” bouncing balls to each other by clicking on the canvas.
The heart of the app is simply another use of the <code>EsObject</code> from the chat application, which is created when the user clicks on the canvas. 
This <code>EsObject</code> adds information about a <code>ball</code> that one user created for the others in the room:
function eventMouseUp(event) { var mouseX;
 var mouseY;
 if (event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY;
 } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; }
 ballcounter++;
 var maxSize = 8;
 var minSize = 5; var maxSpeed = maxSize+5;
 var tempRadius = Math.floor(Math.random()*maxSize)+minSize;
 var tempX = mouseX;
 var tempY = mouseY; var tempSpeed = maxSpeed-tempRadius;
 var tempAngle = Math.floor(Math.random()*360);
 var tempRadians = tempAngle * Math.PI/ 180;
 var tempvelocityx = Math.cos(tempRadians) * tempSpeed; var tempvelocityy = Math.sin(tempRadians) * tempSpeed;
 var pmr = new PublicMessageRequest();
 pmr.message = "";
 pmr.roomId = _room.id; pmr.zoneId = _room.zoneId;
 var esob = new ElectroServer.EsObject();
 esob.setFloat("tempX",tempX );
 esob.setFloat("tempY",tempY ); esob.setFloat("tempRadius",tempRadius );
 esob.setFloat("tempSpeed",tempSpeed );
 esob.setFloat("tempAngle",tempAngle );
 esob.setFloat("velocityx",tempvelocityx ); esob.setFloat("velocityy",tempvelocityy );
 esob.setString("usercolor",usercolor );
 esob.setString("ballname",username+ballcounter);
 esob.setString("type", "newball"); pmr.esObject = esob;
 es.engine.send(pmr);
 statusMessages.push("send ball");
 }

When a user connected in the same room receives this public message, we handle the <code>newball</code> event in a similar manner to how we handled the chat text, by using the <code>on</code><code>PublicMessageEvent()</code> function. 
When the function sees an event with the type <code>newball</code>, it calls <code>createNetBall()</code>. 
The <code>createNetBall()</code> function creates ball objects to bounce around the canvas, much like the ones we created in Chapter 5</a>:

function onPublicMessageEvent(event) {
 statusMessages.push("message received")
 var esob = event.esObject;
 if (esob.getString("type") == "chatmessage") { chatMessages.push(event.userName + ":" + esob.getString("message")); } else if (esob.getString("type") == "newball") { statusMessages.push("create ball") createNetBall(esob.getFloat("tempX"),esob.getFloat("tempY"), esob.getFloat("tempSpeed"),esob.getFloat("tempAngle"), esob.getFloat("tempRadius"),esob.getFloat("velocityx"), esob.getFloat("velocityy"),event.userName,esob.getString("usercolor"), esob.getString("ballname") );
 }
}
function createNetBall(tempX,tempY,tempSpeed,tempAngle,tempRadius,tempvelocityx, tempvelocityy, user, usercolor, ballname) { tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, velocityx:tempvelocityx, velocityy:tempvelocityy,nextx:tempX, nexty:tempY, mass:tempRadius, usercolor:usercolor, ballname:ballname} balls.push(tempBall); }

<a href="ch11.html#electroserver_chat_ball_demo" title="Figure 11-6. 
ElectroServer chat ball demo">Figure 11-6</a> shows what this demo looks like when users click the mouse button to send balls to other users. 
The colors of the balls are assigned randomly.
<img src="https://www.oreilly.com/library/view/html5-canvas/9781449308032/httpatomoreillycomsourceoreillyimages1893889.png" alt="ElectroServer chat ball demo" width="1000" height="509">

Figure 11-6. 
ElectroServer chat ball demo
Example 11-3</a> gives the full set of code for <em>CH11EX3.html</em>.
Example 11-3. 

ES5 ball demo
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;

&lt;meta charset="UTF-8"&gt;
&lt;title&gt;CH11EX3: ES5 Ball Demo&lt;/title&gt;
&lt;script src="modernizr-1.6.min.js"&gt;&lt;/script&gt;
&lt;script src="ElectroServer-5-Client-JavaScript.js"&gt;&lt;/script&gt;

&lt;script type="text/javascript"&gt;
window.addEventListener("load", eventWindowLoaded, false);
function eventWindowLoaded () {
 canvasApp();

}
function canvasSupport () { return Modernizr.canvas;
}
function canvasApp () { if (!canvasSupport()) { return; }
 var theCanvas = document.getElementById("canvasOne"); var context = theCanvas.getContext("2d");
 var formElement = document.getElementById("sendChat"); formElement.addEventListener('click', sendMessage, false);
 function drawScreen() { //background context.fillStyle = "#ffffaa"; context.fillRect(0, 0, 500, 320); context.fillStyle = "#000000"; context.font = "10px _sans"; context.textBaseline = "top";
 //box context.strokeStyle = '#000000'; context.strokeRect(5, 5, 490, 310);
 var starty = 15; var maxMessages = 22;
 //status box context.strokeStyle = '#000000'; context.strokeRect(345, 10, 145, 285); var starti = 0; if (statusMessages.length &gt; maxMessages) { starti = (statusMessages.length) - maxMessages;
 } for (var i = starti;i&lt; statusMessages.length;i++) { context.fillText (statusMessages[i], 350, starty ); starty+=12; }
 //chat box context.strokeStyle = '#000000'; context.strokeRect(10, 10, 335, 285);
 starti = 0; lastMessage = chatMessages.length-1; if (chatMessages.length &gt; maxMessages) { starti = (chatMessages.length) - maxMessages; } starty = 15; for (var i = starti;i&lt; chatMessages.length;i++) { context.fillText (chatMessages[i], 10, starty ); starty+=12; } context.fillText ("User Name:" + username, 10, 295 );
 update(); testWalls(); render();
 }
 function updateBall(ball) { ball.radians = ball.angle * Math.PI/ 180; ball.velocityx = Math.cos(ball.radians) * ball.speed; ball.velocityy = Math.sin(ball.radians) * ball.speed; }
 var statusMessages = new Array(); var chatMessages = new Array();
 var server = new ElectroServer.Server("server1");
 statusMessages.push(server); var availableConnection = new ElectroServer.AvailableConnection ("localhost", 8989, ElectroServer.TransportType.BinaryHTTP);
 server.addAvailableConnection(availableConnection);
 var es = new ElectroServer(); es.initialize();
 var username; var usercolor; var _room; var ballcounter = 0; es.engine.addServer(server);
 es.engine.addEventListener(MessageType.ConnectionResponse, onConnectionResponse); es.engine.addEventListener(MessageType.LoginResponse, onLoginResponse); es.engine.addEventListener(MessageType.JoinRoomEvent, onJoinRoomEvent); es.engine.addEventListener(MessageType.JoinZoneEvent, onJoinZoneEvent); es.engine.addEventListener(MessageType.ConnectionAttemptResponse, onConnectionAttemptResponse); es.engine.addEventListener(MessageType.PublicMessageEvent, onPublicMessageEvent);
 es.engine.connect();
 statusMessages.push("Connecting..."); var balls = new Array();
 theCanvas.addEventListener("mouseup",eventMouseUp, false);
 var friction = 0;
 setInterval(drawScreen, 33); function eventMouseUp(event) { var mouseX; var mouseY; if ( event.layerX || event.layerX == 0) { // Firefox mouseX = event.layerX ; mouseY = event.layerY; } else if (event.offsetX || event.offsetX == 0) { // Opera mouseX = event.offsetX; mouseY = event.offsetY; } ballcounter++; var maxSize = 8; var minSize = 5; var maxSpeed = maxSize+5; var tempRadius = Math.floor(Math.random()*maxSize)+minSize; var tempX = mouseX; var tempY = mouseY; var tempSpeed = maxSpeed-tempRadius; var tempAngle = Math.floor(Math.random()*360); var tempRadians = tempAngle * Math.PI/ 180; var tempvelocityx = Math.cos(tempRadians) * tempSpeed; var tempvelocityy = Math.sin(tempRadians) * tempSpeed; var pmr = new PublicMessageRequest(); pmr.message = ""; pmr.roomId = _room.id; pmr.zoneId = _room.zoneId; var esob = new ElectroServer.EsObject(); esob.setFloat("tempX",tempX ); esob.setFloat("tempY",tempY ); esob.setFloat("tempRadius",tempRadius ); esob.setFloat("tempSpeed",tempSpeed ); esob.setFloat("tempAngle",tempAngle ); esob.setFloat("velocityx",tempvelocityx ); esob.setFloat("velocityy",tempvelocityy ); esob.setString("usercolor",usercolor ); esob.setString("ballname",username+ballcounter); esob.setString("type", "newball"); pmr.esObject = esob; es.engine.send(pmr); statusMessages.push("send ball");
 }
 function createNetBall(tempX,tempY,tempSpeed,tempAngle,tempRadius,tempvelocityx, tempvelocityy, user, usercolor, ballname) {
 tempBall = {x:tempX,y:tempY,radius:tempRadius, speed:tempSpeed, angle:tempAngle, velocityx:tempvelocityx, velocityy:tempvelocityy, nextx:tempX, nexty:tempY, mass:tempRadius, usercolor:usercolor, ballname:ballname} balls.push(tempBall); } function onConnectionAttemptResponse(event) { statusMessages.push("connection attempt response!!"); }
 function onJoinRoomEvent(event) { statusMessages.push("joined a room"); _room = es.managerHelper.zoneManager.zoneById (event.zoneId).roomById(event.roomId); var formElement = document.getElementById("inputForm"); formElement.setAttribute("style", "display:true"); }
 function onJoinZoneEvent(event) { statusMessages.push("joined a zone");
 } function onConnectionResponse(event) { statusMessages.push("Connect Successful?: "+event.successful); var r = new LoginRequest(); r.userName = "CanvasUser_" + Math.floor(Math.random() * 1000); es.engine.send(r); }
 function onLoginResponse(event) { statusMessages.push("Login Successful?: "+event.successful);
 username = event.userName; usercolor = "#"+(Math.random()*0xFFFFFF&lt;&lt;0).toString(16);
 var crr = new CreateRoomRequest(); crr.zoneName = "TestZoneCuesors"; crr.roomName = "TestRoomCursors"; es.engine.send(crr);
 }
 function sendMessage(event) { var formElement = document.getElementById("textBox"); var pmr = new PublicMessageRequest(); pmr.message = ""; pmr.roomId = _room.id; pmr.zoneId = _room.zoneId; var esob = new ElectroServer.EsObject(); esob.setString("message", formElement.value); esob.setString("type","chatmessage"); pmr.esObject = esob; es.engine.send(pmr); statusMessages.push("message sent")
 } function onPublicMessageEvent(event) { statusMessages.push("message received") var esob = event.esObject;
 if (esob.getString("type") == "chatmessage") {
 chatMessages.push(event.userName + ":" + esob.getString("message"));
 } else if (esob.getString("type") == "newball") { statusMessages.push("create ball") createNetBall(esob.getFloat("tempX"),esob.getFloat("tempY"), esob.getFloat("tempSpeed"),esob.getFloat("tempAngle"), esob.getFloat("tempRadius"),esob.getFloat("velocityx"), esob.getFloat("velocityy"),event.userName,esob.getString("usercolor"), esob.getString("ballname") ); } }
 function update() { for (var i =0; i &lt;balls.length; i++) { ball = balls[i]; //Friction ball.velocityx = ball.velocityx - ( ball.velocityx*friction); ball.velocityy = ball.velocityy - ( ball.velocityy*friction);
 ball.nextx = (ball.x += ball.velocityx); ball.nexty = (ball.y += ball.velocityy); }
 } function testWalls() { var ball; var testBall;
 for (var i = 0; i &lt;balls.length; i++) { ball = balls[i];
 if (ball.nextx+ball.radius &gt; theCanvas.width) { ball.velocityx = ball.velocityx*-1; ball.nextx = theCanvas.width - ball.radius;
 } else if (ball.nextx-ball.radius &lt; 0 ) { ball.velocityx = ball.velocityx*-1; ball.nextx = ball.radius; } else if (ball.nexty+ball.radius &gt; theCanvas.height ) { ball.velocityy = ball.velocityy*-1; ball.nexty = theCanvas.height - ball.radius;
 } else if(ball.nexty-ball.radius &lt; 0) { ball.velocityy = ball.velocityy*,1; ball.nexty = ball.radius; }
 }
 } function render() { var ball;
 for (var i =0; i &lt;balls.length; i++) {
 ball = balls[i]; ball.x = ball.nextx; ball.y = ball.nexty; context.fillStyle = ball.usercolor; context.beginPath(); context.arc(ball.x,ball.y,ball.radius,0,Math.PI*2,true); context.closePath(); context.fill(); }
 }

}
&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div&gt;
&lt;canvas width="500" height="320"&gt;
 Your browser does not support HTML5 Canvas.
&lt;/canvas&gt;

&lt;div &gt;
&lt;form&gt;
&lt;input placeholder="your text" /&gt;
&lt;input type="button" id ="sendChat" value="Send"/&gt;

&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;
<h3>This Is Just the Tip of the Iceberg</h3>
There is much more you can do with ElectroServer than what we showed you in this chapter. 
Sending and receiving <code>PublicMessage</code> events can only get you so far when designing multiuser/multiplayer applications.

To start designing multiplayer applications seriously, you will need to delve into the extension and plug-in architecture of ElectroServer, as well as explore plug-in events, which are used to communicate to the server portion of an application. 
We suggest you check out <a href="http://www.electrotank.com/es5.html">http://www.electrotank.com/es5.html</a> for more information about the socket server. 
You can also read <em>ActionScript for Multiplayer Games and Virtual Worlds</em> by Jobe Makar (New Riders). 
Even though it centers on Flash and an earlier version of ElectroServer, the architectural information about designing apps for a socket server is well worth your time.

At the same time, ElectroServer can be used with technologies other than Canvas (Flash, iOS, etc.), so Canvas will be able to communicate with other socket servers via JavaScript and WebSockets. 
We chose to base this example on ElectroServer because it allowed us to create a full application for you to test and work through. 
Other libraries and tools are bound to appear very soon that can work with canvas; for example, the SmartFoxServer Ajax API. 
Still in beta, this API uses the Google Web Toolkit to connect to the SmartFox socket server through an Ajax connection in JavaScript. 

This library requires the SmartFoxServer BlueBox add-on module. 
In theory, this means SmartFoxServer could be used in conjunction with Canvas right now.
<h2>Conclusion</h2>
Over the past 11 chapters, you have been immersed in the world of HTML5 Canvas. 

We have given you dozens of examples and applications to work from and through so you can start building your own creations. 
From simple text displays to high-performance games, we have showed you many ways to bring some of the magic of previous RIA (Rich Internet Application) technologies into the plug-in-<em>less</em> browser experience.
We offered many strategies for integrating Canvas with other HTML5 technologies, as well as techniques for handling text, displaying graphics, scrolling bitmaps, creating animation, detecting multiple types of collisions, embedding and manipulating video, playing music, handling sound effects, creating user interfaces, optimizing code, and preparing apps for mobile platforms. 
We even introduced you to the future of 3D and multiuser applications directly in the web browser.

The true future, though, is up to you. 
HTML5 and Canvas are dynamic topics that are still in a rapid state of change and adoption. 
While this book is a good starting point, you will need to keep abreast of new changes to the technology. 
Visit our website, <a href="http://www.8bitrocket.com">http://www.8bitrocket.com</a>, for news and updates on HTML5 Canvas.

O’Reilly also has several books that you might find useful, including:
<a href="http://oreilly.com/catalog/9780596806033/"><em>HTML5: Up and Running</em></a> by Mark Pilgrim

<a href="http://oreilly.com/catalog/0636920013044/"><em>Supercharged JavaScript Graphics</em></a> by Raffaele Cecco
If you are interested in learning how some of the game-development techniques described in this book (as well as many others) can be applied to Flash, check out our other most recent book, <em>The Essential Guide to Flash Games</em> (friendsofED).

There is a real paradigm shift occurring right now on the Web. 
For most of the first decade of the 21st century, Java, Flash, Silverlight, and other plug-in RIA technologies dominated application development and design. 
At the time, there appeared to be no better solution for the development of rich applications in a web browser than to bolt on technology that was not native to the browser.
The emergence of the “connected apps” culture is changing this. 

Every platform—from phones to TVs, e-readers to tablets, wireless printers to desktop PCs—is targeted for web-enabled applications sold or distributed through an app store. 
In many ways, these apps are replacing RIA applications, or at the very least offering a compelling new platform for their development and distribution.
Where RIA technologies of the past—like Java, Flash, and Silverlight—could target nearly all web browsers and PCs, they are having trouble finding a true foothold in the area of connected apps (especially on platforms where they are restricted from running, like iOS). 
This is where HTML5 Canvas can really make a difference. 

With true cross-platform execution, applications run in the web browser (or compiled with technologies like PhoneGap) can be made available to the widest audience possible. 
Soon these applications will be enhanced with 3D graphics and have the ability to communicate with one another via technologies like the ElectroServer socket server. 
One can envision a day in the near future where technology platforms fade away, and the web-connected app world simply works, regardless of screen or location. 
This is the promise of HTML5—especially HTML5 Canvas. 
So, now that you have the tools to begin, what do you plan to build?
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
