<base target="_blank"><html><head><title>Full IndexedDB example</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Full IndexedDB example"
  var markerName = "h2, h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Full IndexedDB example</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>

<h2>Build a basic web app with IndexedDB</h2>
<h3>Making our database</h3>

let db;
let dbReq = indexedDB.open(&#x27;myDatabase&#x27;, 1);
dbReq.onupgradeneeded = function(event) {
  // Set the db variable to our database so we can use it!  
  db = event.target.result;

  // Create an object store named notes. Object stores in databases are where data are stored.

  let notes = db.createObjectStore(&#x27;notes&#x27;, {autoIncrement: true});
}
dbReq.onsuccess = function(event) {
  db = event.target.result;
}
dbReq.onerror = function(event) {
  alert(&#x27;error opening database &#x27; + event.target.errorCode);
}

To run the JavaScript, put this code in a file named <code>index.html</code> and open it in Chrome:

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;IndexedDB note store&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;&lt;h1&gt;Coming soon&lt;/h1&gt;&lt;/div&gt;
    &lt;script src=&quot;db.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

Now in Chrome, go to <strong>developer tools</strong>, click the <strong>application</strong> tab, and then click <strong>IndexedDB</strong> in the left bar, you can see that the database was created!

<img src="https://miro.medium.com/max/1546/1*HHaYVXJSH6J0HFaeesea8g.png">

Cool! We have a database named <code>myDatabase</code>, and there‚Äôs an <strong>object store</strong> (a collection of items, similar to a SQL table or a collection in MongoDB) named <code>notes</code>. 
But that seemed like a lot of code for just creating the database and store. 
So what‚Äôs going on there?
In the first couple lines

let db;
let dbReq = indexedDB.open(&#x27;myDatabase&#x27;, 1);

We open version 1 of a database named myDatabase, but <code>indexedDB.open</code> doesn‚Äôt return a database, it returns a <em>request</em> for a database because IndexedDB is an <em>asynchronous</em> API. 
IndexedDB code runs behind the scenes so if we do something like store thousands of items, the rest of your web app won‚Äôt stop running its JavaScript waiting for that to complete. 
So in the rest of the code we listen for when ourdatabase is ready for us with <em>event listeners</em>:

dbReq.onupgradeneeded = function(event) {
  db = event.target.result;
  let notes = db.createObjectStore(&#x27;notes&#x27;, {autoIncrement: true});
}

<code>myDatabase</code> didn‚Äôt previously exist, so it‚Äôs automatically created and then the <code>onupgradeneeded</code> event fires. 
In an onupgradeneeded callback, and only in that callback, we can create a database‚Äôs object stores. 
So first, with <code>db = event.target.result</code>, we set the variable <code>db</code> to hold our database. 
Then, we create one object store named <code>notes</code>.

dbReq.onsuccess = function(event) {
  db = event.target.result;
}

<code>onsuccess</code> fires after <code>onupgradeneeded</code> completes and it also fires if we refresh the page and open the database again. 
So there too, we run <code>db = event.target.result</code> to get our database so we can use it.

dbReq.onerror = function(event) {
  alert(&#x27;error opening database &#x27; + event.target.errorCode);
}

Finally, if something goes wrong on any IndexedDB request, its <code>onerror</code> event fires so you can handle the error however you see fit. 
We‚Äôre just going to do an <code>alert</code>.

<h3>Put some data into the database</h3>
Well we‚Äôve got our database, but we can‚Äôt do much with it without data. 
Let‚Äôs add a sticky note!

function addStickyNote(db, message) {
  // Start a database transaction and get the notes object store
  let tx = db.transaction([&#x27;notes&#x27;], &#x27;readwrite&#x27;);
  let store = tx.objectStore(&#x27;notes&#x27;);
  // Put the sticky note into the object store
  let note = {text: message, timestamp: Date.now()};
  store.add(note);
  // Wait for the database transaction to complete
  tx.oncomplete = function() { console.log(&#x27;stored note!&#x27;) }
  tx.onerror = function(event) {
    alert(&#x27;error storing note &#x27; + event.target.errorCode);
  }
}

To see this in action, let‚Äôs put some call to the function into our <code>dbReq.onsuccess</code>:

dbReq.onsuccess = function(event) {
  db = event.target.result;
  <strong>// Add some sticky notes</strong>
  <strong>addStickyNote(db, &#x27;Sloths are awesome!&#x27;);
  addStickyNote(db, &#x27;Order more hibiscus tea&#x27;);
  addStickyNote(db, &#x27;And Green Sheen shampoo, the best for sloth fur algae grooming!&#x27;);</strong>
}

Now refresh index.html in your browser, go to <strong>Application &gt; IndexedDB</strong> in developer tools again, click on the object store, and let‚Äôs see our data!

<img src="https://miro.medium.com/max/2442/1*6wDn9WnLobrpoWFfdxkDPg.png">

Now we have some data stored! And as you can see, our sticky notes in the notes object store are stored as JavaScript objects. 
So what was going on in that code?

let tx = db.transaction([&#x27;notes&#x27;], &#x27;readwrite&#x27;);
let store = tx.objectStore(&#x27;notes&#x27;);

First we start a <strong>transaction </strong>on our database to write data to our <code>notes</code> object store, and then we retrieve that object store from the transaction.

let note = {text: message, timestamp: Date.now()};
store.add(note);

We represent the sticky note as a JavaScript object and store it in the object store with <code>store.add</code>.

tx.oncomplete = function() { console.log(&#x27;stored note!&#x27;) }
tx.onerror = function(event) {
  alert(&#x27;error storing note &#x27; + event.target.errorCode);
}

Finally, just like our open database request, this transaction has event listeners; we listen for when storing the note finishes or where an errror happens with the transaction‚Äôs <code>oncomplete</code> and <code>onerror</code> listeners.

Something else worth noting about our sticky notes is that each one has a number for its <code>Key</code> that counts up. 
So if you stored another note after those three, its key would be 4. 
Where did those numbers come from? In IndexedDB, all objects in an object store have a <strong>key</strong> identifying them, and when we created the object store with the line

let notes = db.createObjectStore(&#x27;notes&#x27;, {autoIncrement: true});

the <code>autoIncrement</code> option says that we want every object in the store to have a key that counts up. 
You can also make object stores with string keys if it makes more sense to store and retrieve objects by a unique name (for example a UUID could be a string key for an object store, or if you had an object store of sloths, you could identify each sloth by a string encoding of the tone of their squeak as the key).

Now let‚Äôs add this <code>addStickyNote</code> function to our actual web app; we need a text box to submit notes to, so in the &lt;body&gt; tag add these tags:

&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;IndexedDB note store&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
      <strong>&lt;div id=&quot;textbox&quot;&gt;
        &lt;textarea id=&quot;newmessage&quot;&gt;&lt;/textarea&gt;
        &lt;button onclick=&quot;submitNote()&quot;&gt;Add note&lt;/button&gt;
      &lt;/div&gt;</strong>
    &lt;/div&gt;
    &lt;script src=&quot;db.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;

And add this function to <code>db.js</code> that runs every time a user submits a note:

function submitNote() {
  let message = document.getElementById(&#x27;newmessage&#x27;);
  addStickyNote(db, message<em>.</em>value);
  message<em>.</em>value = &#x27;&#x27;;
}

Now get rid of the call to <code>addStickyNote</code> in <code>dbReq.onsuccess</code> and then if we go to index.html, we‚Äôll see notes being stored in IndexedDB when we click submit!

Before we go on and I show you how to retrieve the data so we can display it, though, let‚Äôs take a detour to talk about a central concept to working with IndexedDB, transactions!

<h3>Transactions are king in IndexedDB</h3>
As you saw in our last example, to access our <code>notes</code> object store we had to run <code>db.transaction</code> to create a <strong>transaction</strong>, which is a set of one or more <strong>requests</strong> to the database. 
Everything in IndexedDB happens through transactions. 
So storing a sticky note, opening the database, and retrieving your notes are all requests that happen inside transactions.

You can have more than one request in the same transaction too, for example if you‚Äôre storing many items in the same object store, all of the <code>store.add</code> requests can be made in the same transaction, like:

function addManyNotes(db, messages) {
  let tx = db.transaction([&#x27;notes&#x27;], &#x27;readwrite&#x27;);
  let store = tx.objectStore(&#x27;notes&#x27;);
  for (let i = 0; i &lt; messages.length; i++) {
    // All of the requests made from store.add are part of
    // the same transaction
    store.add({text: messages[i], timestamp: Date.now()});
  }
  tx.oncomplete = function() {console.log(&#x27;transaction complete&#x27;)};
}

Just like requests have <code>onsuccess</code> and <code>onerror</code> event handlers, transactions have <code>oncomplete</code>, <code>onerror</code>, and <code>onabort</code> event handlers we can use for responding to a transaction completing, erroring, or being rolled back.

But what exactly are we getting out of putting every request in a transaction? Remember that IndexedDB is an asynchronous API, so it‚Äôs possible to have many requests going on at the same time. 
Say we had a sticky note in the note store that said ‚ÄúSloths are awesome‚Äù, and we made one request to make the note all-caps and another to add an exclamation point to the note. 
Without transactions, we could end up with a situation like this:

<img src="https://miro.medium.com/max/1600/1*thqid7g2J59WDs2yJeCGOA.png">

We start the <code>makeAllCaps</code> and <code>addExclamation</code> actions and both of them retrieve the unmodified ‚ÄúSloths are awesome‚Äù note. 
<code>addExclamation</code> saves the note with an exclamation point first. 
<code>makeAllCaps</code> takes longer and it saves the note ‚ÄúSLOTHS ARE AWESOME‚Äù, with no exclamation point. 
The <code>makeAllCaps</code> update completely wipes out the update from <code>addExclamation</code>!

With transactions, though, we get <strong>concurrency control</strong>. 
<em>Only one transaction can create, modify, or delete items in an object store at a time</em>, so what really happens looks more like this:

<img src="https://miro.medium.com/max/1600/1*sPotSeQtjNDAcvavbjZKBQ.png">

The <code>makeAllCaps</code> transaction starts first, but since <code>addExclamation</code> uses the same object store as <code>makeAllCaps</code>, it does not start until makeAllCaps finishes. 
So makeAllCaps finishes, addExclamation reads the note in all caps, and then both edits go through! üéâ

That also means if a road was an object store and a streetsweeper and a line painter were running without transactions, the line painter might paint before the streetsweeper moved a branch and you‚Äôd get this:

<img src="https://miro.medium.com/max/700/1*EnkYMjS67faterkYkmVqrg.jpeg">

But with transactions, the streetsweeper can sweep branches out of the road and the line painter can paint lines so sloths can safely go for a bike ride!

<img src="https://miro.medium.com/max/508/1*ZyLHpl-fwH-uvne2vAA-bg.jpeg"/>

Before we move on, one other thing to know is that transactions on the same object store only happen one-at-a-time <em>if they‚Äôre modifying data</em>; in other words they‚Äôre<code>readwrite</code> transactions, which are created like this:

let tx = db.transaction([&#x27;notes&#x27;, &#x27;someOtherStore&#x27;], &#x27;readwrite&#x27;);

Here we make a transaction that‚Äôs readwrite and say that it affects <code>notes</code> and <code>someOtherStore</code>. 
Since it‚Äôs readwrite, it can‚Äôt start until any other transaction touching either of those object stores is done.

While readwrite transactions are one at a time, there are also <code>readonly</code> transactions; you can <em>have as many of them as you want</em> talking to the same object store simultaneously since we don‚Äôt need to keep them from messing with each other‚Äôs data! You make them like this:

// These transactions can all do their thing at the same time!
let tx = db.transaction([&#x27;notes&#x27;, &#x27;someOtherStore&#x27;], &#x27;readonly&#x27;);
let tx2 = db.transaction([&#x27;notes&#x27;], &#x27;readonly&#x27;);
let tx3 = db.transaction([&#x27;someOtherStore&#x27;], &#x27;readonly&#x27;);

<h3>Retrieving data and displaying your sticky notes</h3>
Now that we know how transactions work and how readonly transactions work, let‚Äôs retrieve the sticky notes from the note store so we can display them. 
If we‚Äôre getting just one item from our database, we would use an object store‚Äôs <code>get</code> method, like this:

// Set up an object store and transaction
let tx = db.transaction([&#x27;notes&#x27;], &#x27;readonly&#x27;);
let store = tx.objectStore(&#x27;notes&#x27;);
// Set up a request to get the sticky note with the key 1
let req = store.get(1);
// We can use the note if the request succeeds, getting it in the
// onsuccess handler
req.onsuccess = function(event) {
  let note = event.target.result;
  if (note) {
    console.log(note);
  } else {
    console.log(&quot;note 1 not found&quot;)
  }
}
// If we get an error, like that the note wasn&#x27;t in the object
// store, we handle the error in the onerror handler
req.onerror = function(event) {
  alert(&#x27;error getting note 1 &#x27; + event.target.errorCode);
}

We make a transaction, request the note in the note store with the key 1 to get our request, and then we either use the retrieved note in the request‚Äôs <code>onsuccess</code> handler, or we handle an error in the <code>onerror</code> handler if we get an error. 
Note that if the sticky note does not exist, <code>onsuccess</code> still fires, but <code>event.target.result</code> will be <code>undefined</code>.

The pattern feels similar to the handler we had for opening the database; we start the request, then get the result in the onsuccess handler or handle an error in the onerror handler. 
But we want to display all the notes, so we need to get all of them, and for that we use a <strong>cursor</strong>.

Retrieve all the items in the object store with a cursor has this funky syntax:

function getAndDisplayNotes(db) {
  let tx = db.transaction([&#x27;notes&#x27;], &#x27;readonly&#x27;);
  let store = tx.objectStore(&#x27;notes&#x27;);
  // Create a cursor request to get all items in the store, which 
  // we collect in the allNotes array
  let req = store.openCursor();
  let allNotes = [];

  req.onsuccess = function(event) {
    // The result of req.onsuccess is an IDBCursor
    let cursor = event.target.result;
    if (cursor != null) {
      // If the cursor isn&#x27;t null, we got an IndexedDB item.
      // Add it to the note array and have the cursor continue!
      allNotes.push(cursor.value);
      cursor.continue();
    } else {
      // If we have a null cursor, it means we&#x27;ve gotten
      // all the items in the store, so display the notes we got
      displayNotes(allNotes);
    }
  }
  req.onerror = function(event) {
    alert(&#x27;error in cursor request &#x27; + event.target.errorCode);
  }
}

We create a readonly transaction on the <code>notes</code> object store, we get the store, and then with the <code>store.openCursor()</code> method, we get a request, which means once again we‚Äôre working with its results with its <code>onsuccess</code> and <code>onerror</code> handlers to handle the results.

Inside the onsuccess handler, the event‚Äôs result is an <code>IDBCursor</code> containing the <code>key</code> of the sticky note the cursor is holding, as well as the sticky note itself as the cursor‚Äôs <code>value</code>.

let cursor = event.target.result;
if (cursor != null) {
  allNotes.push(cursor.value);
  cursor.continue();
} else {

In the if statement, if the cursor isn‚Äôt null, that means we have another sticky note, so we add the cursor‚Äôs value to our array of notes and continue retrieving notes by calling <code>cursor.continue()</code>.

} else {
  displayNotes(allNotes);
}

But if the cursor is null, there are no more notes to retrieve, so we display the notes by passing them to a <code>displayNotes</code> function.

Hmm, this <code>cursor.continue()</code> thing feels kind of like a while loop, but there‚Äôs no looping or control flow going on. 
So how exactly are we looping? This line will give you a hint:

req.onsuccess = function(event) {

It turns out every time you call <code>cursor.continue()</code>, an event fires and sends the cursor with the next item to the <code>onsuccess</code> handler. 
So in each onsuccess, we collect another sticky note, until we get an onsuccess where the cursor is null. 
That‚Äôs how we iterate with cursors.

Now to display these notes, in <code>index.html</code>, after the textbox div, add a div below the text box to store our sticky notes:

&lt;div id=&quot;notes&quot;&gt;&lt;/div&gt;

And in <code>db.js</code> add this function to display the notes:

function displayNotes(notes) {
  let listHTML = &#x27;&lt;ul&gt;&#x27;;
  for (let i = 0; i &lt; notes.length; i++) {
    let note = notes[i];
    listHTML += &#x27;&lt;li&gt;&#x27; + note.text + &#x27; &#x27; + 
      new Date(note.timestamp).toString() + &#x27;&lt;/li&gt;&#x27;;
  }
  document.getElementById(&#x27;notes&#x27;).innerHTML = listHTML;
}

That function just converts each note to an <code>&lt;li&gt;</code> tag and displays them as a list with old-school JavaScript.

Now that we have a function to display all the sticky notes, let‚Äôs add it in a couple places. 
We‚Äôll want to be able to see all our sticky notes when we first open the app, so when the database first opens, we should have a call to <code>getAndDisplayNotes</code> in <code>dbReq.onsuccess:</code>

dbReq.onsuccess = function(event) {
  db = event.target.result;
  <strong>getAndDisplayNotes(db);</strong>
}

And when you add a sticky note, you should be able to see it right away, so in <code>addStickyNote</code>, let‚Äôs change the transaction <code>oncomplete</code> callback to call <code>getAndDisplayNotes</code>:

tx.oncomplete = function() { getAndDisplayNotes(db); }

Now reopen the page in Chrome and try adding some more notes. 
It should look something like this!

<img src="https://miro.medium.com/max/1782/1*FzIye7BYv6YBf4cSdDOK8A.png">

Now for one last thing, let‚Äôs make a mode to see the newest notes first and see why this is called IndexedDB!

<h3>Indices, putting the indexed in IndexedDB</h3>
We‚Äôve got this sticky note store and we‚Äôre storing notes with timestamps, so it should make sense that we should be able to retrieve all sticky notes for a time range (like 5‚Äì10 minutes ago, or all the notes from a given day) or be able to retrieve them with the newest ones first, right?

Well we can, but to be able to query by the timestamp field, we need to give that field in the notes object store an <strong>index</strong>. 
Once we have that index, we can query by it. 
But remember that any changes to the structure of a database need to happen inside a database request‚Äôs <code>onupgradeneeded</code> handler, so we need to up the version of our database to create the index, like this:

// We update the version of the database to 2 to trigger
// onupgradeneeded
let dbReq = indexedDB.open(&#x27;myDatabase&#x27;, 2);
dbReq.onupgradeneeded = function(event) {
  db = event.target.result;
  // Create the nores object store, or retrieve it if it
  // already exists.
  let notes;
  <strong>if (!db.objectStoreNames.contains(&#x27;notes&#x27;)) {
</strong>    notes = db.createObjectStore(&#x27;notes&#x27;, {autoIncrement: true});
  } <strong>else {
    notes = dbReq.transaction.objectStore(&#x27;notes&#x27;);
  }</strong>
  <strong>// If there isn&#x27;t already a timestamp index, make one so we
  // can query notes by their timestamps
  if (!notes.indexNames.contains(&#x27;timestamp&#x27;)) {
    notes.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);
  }</strong>
}

First, we update the version of our database to 2, which indicates that the structure of the database is changing, so we need an <code>onupgradeneeded</code> event:

let dbReq = indexedDB.open(&#x27;myDatabase&#x27;, 2);

Now we have a version upgrade where the notes object store already exists, so we check if there‚Äôs already a notes store with <code>db.objectStoreNames</code>:

if(!db.objectStoreNames.contains(&#x27;notes&#x27;))

and if there‚Äôs already one, we retrieve it with <code>dbReq.transaction.objectStore</code>:

notes = dbReq.transaction.objectStore(&#x27;notes&#x27;);

Finally, we add an index with <code>createIndex</code>:

if (!notes.indexNames.includes(&#x27;timestamp&#x27;)) {
  notes.createIndex(&#x27;timestamp&#x27;, &#x27;timestamp&#x27;);
}

The first parameter is the name of our index, and the second is the index‚Äôs <strong>keyPath</strong>. 
An index is actually itself an object store, so all items in an index have a key, so if you give an index the keyPath <code>timestamp</code>, then the timestamp of each object in the object store will be its key.

Additionally, there is an optional third options object parameter. 
Say our notes had titles and we wanted to require that a note could not be stored if it had the same title as another note. 
We could do that by creating a unique title index like this:

notes.createIndex(&#x27;title&#x27;, &#x27;title&#x27;, {unique: true})

To see our new index, once you update <code>onupgradeneeded</code>, refresh index.html in Chrome (you may need to X out of Chrome to see the change), go to Developer Tools &gt; Application &gt; IndexedDB again, and you should be able to see your notes object store:

<img src="https://miro.medium.com/max/2248/1*bReu7gCgbgNhaTZGWQt4Mg.png">

As you can see, the notes are now listed by their timestamps as their primary keys. 
And in fact, as an object store, an index has the same <code>get</code> and <code>openCursor</code> methods that a regular object store would. 
For example we could request the first note with a call to:

tx.objectStore(&#x27;notes&#x27;).index(&#x27;timestamp&#x27;).get(1533144673015)

Now that we‚Äôve got a cool new index, let‚Äôs add a mode to our web app to flip the order we display notes in. 
First, in <code>db.js</code>, add a global bool variable:

let reverseOrder = false;

Then in <code>getAndDisplayNotes</code>, we just need to update our request:

let tx = db.transaction([&#x27;notes&#x27;], &#x27;readonly&#x27;);
let store = tx.objectStore(&#x27;notes&#x27;);
// Retrieve the sticky notes index to run our cursor query on; 
// the results will be ordered by their timestamp<strong>
let index = store.index(&#x27;timestamp&#x27;);
</strong>
// Create our openCursor request; if we&#x27;re going in reverse, then
// specify the direction as prev, otherwise, we specify it as next
<strong>let req = index.openCursor(null, reverseOrder ? &#x27;prev&#x27; : &#x27;next&#x27;);</strong>

In <code>store.index()</code>, we retrieve the timestamp with the name we request, just like how we retrieve an object store from the transaction. 
Now we can define a cursor request to get back our notes ordered by the timestamp.

<code>index.openCursor</code> has two optional parameters. 
The first one, if it isn‚Äôt null, lets us specify the range of items we want to retrieve. 
For example, if we only wanted the sticky notes from the past hour, we could do:

let anHourAgoInMS = Date.now() - 60 * 60 * 1000;
// IDBKeyRange is a global variable for defining ranges to query
// indices on
let keyRange = IDBKeyRange.lowerBound(anHourAgoInMS)
let req = index.openCursor(keyRange, &#x27;next&#x27;)

The second parameter is the order we want to retrieve items in, which can be <code>&#x27;prev&#x27;</code> or <code>&#x27;next&#x27;</code>, so we specify our direction with:

reverseOrder ? &#x27;prev&#x27; : &#x27;next&#x27;

Finally, let‚Äôs see this in action; in index.html, add another button for flipping the order of the notes we display:

function flipNoteOrder(notes) {
  reverseOrder = !reverseOrder;
  getAndDisplayNotes(db);
}

And in <code>index.html</code>, add one more button for flipping the order of the notes

&lt;button onclick=&quot;flipNoteOrder()&quot;&gt;Flip note order&lt;/button&gt;

And if you refresh Chrome, your flip button should now work!

<img src="https://miro.medium.com/max/1776/1*hLvfo-iT59xs05dZAvnjag.png">

<figcaption>The final product!</figcaption>Cool! Now we can change the order we see notes in! Now you‚Äôve seen the basics of IndexedDB. 
There are other functionalities we didn‚Äôt see in action, like deleting objects, storing binary data in IndexedDB, and multi-field indices, but this should be a good starting point for building web apps with IndexedDB.

As you could see though, the basic IndexedDB API, though powerful, doesn‚Äôt really have an ergonomic feel to it. 
I don‚Äôt know about you, but to me, these <code>on</code> event listeners feel inconvenient to reason about, and those handlers also took some thinking my first time figuring out how to give IndexedDB code test coverage.

<h2>register-form</h2>
<label for="pub-title" class="required">Title:</label><input type="text" id="pub-title" name="pub-title" />

<label for="pub-biblioid" class="required">ISBN:</label><input type="text" id="pub-biblioid" name="pub-biblioid"/>

<label for="pub-year">Year:</label><input type="number" id="pub-year" name="pub-year" />

<label for="pub-file">File image:</label><input type="file" id="pub-file"/>

<label for="pub-file-url">Online-file image URL:<span class="note">(same origin URL)</span></label>
<input type="text" id="pub-file-url" name="pub-file-url"/>

<div class="button-pane">
<input type="button" id="add-button" value="Add Publication" />
<input type="reset" id="register-form-reset"/>
</div>


<form id="delete-form">
<label for="pub-biblioid-to-delete">Bibliographic ID:<span class="note">(ISBN, ISSN, etc.)</span></label><input type="text" id="pub-biblioid-to-delete" name="pub-biblioid-to-delete" />
<label for="key-to-delete">Key:<span class="note">(for example 1, 2, 3, etc.)</span></label><input type="text" id="key-to-delete" name="key-to-delete" />

<div class="button-pane">
<input type="button" id="delete-button" value="Delete Publication" />
<input type="button" id="clear-store-button" value="Clear the whole store" class="destructive" />
</div>
</form>


<form id="search-form">
<div class="button-pane">
<input type="button" id="search-list-button" value="List database content" />
</div>
</form>

<div id="pub-msg"></div>
<div id="pub-viewer"></div>
<ul id="pub-list"></ul>


<script>
(function () {
  var COMPAT_ENVS = [
    ['Firefox', ">= 16.0"],
    ['Google Chrome',
     ">= 24.0 (you may need to get Google Chrome Canary), NO Blob storage support"]
  ];
  var compat = $('#compat');
  compat.empty();
  compat.append('<ul id="compat-list"></ul>');
  COMPAT_ENVS.forEach(function(val, idx, array) {
    $('#compat-list').append('<li>' + val[0] + ': ' + val[1] + '</li>');
  });

  const DB_NAME = 'mdn-demo-indexeddb-epublications';
  const DB_VERSION = 1; // Use a long long for this value (don't use a float)
  const DB_STORE_NAME = 'publications';

  var db;

  // Used to keep track of which view is displayed to avoid uselessly reloading it
  var current_view_pub_key;

  function openDb() {
    console.log("openDb ...");
    var req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onsuccess = function (evt) {
      // Equal to: db = req.result;
      db = this.result;
      console.log("openDb DONE");
    };
    req.onerror = function (evt) {
      console.error("openDb:", evt.target.errorCode);
    };

    req.onupgradeneeded = function (evt) {
      console.log("openDb.onupgradeneeded");
      var store = evt.currentTarget.result.createObjectStore(
        DB_STORE_NAME, { keyPath: 'id', autoIncrement: true });

      store.createIndex('biblioid', 'biblioid', { unique: true });
      store.createIndex('title', 'title', { unique: false });
      store.createIndex('year', 'year', { unique: false });
    };
  }

  /**
   * @param {string} store_name
   * @param {string} mode either "readonly" or "readwrite"
   */
  function getObjectStore(store_name, mode) {
    var tx = db.transaction(store_name, mode);
    return tx.objectStore(store_name);
  }

  function clearObjectStore() {
    var store = getObjectStore(DB_STORE_NAME, 'readwrite');
    var req = store.clear();
    req.onsuccess = function(evt) {
      displayActionSuccess("Store cleared");
      displayPubList(store);
    };
    req.onerror = function (evt) {
      console.error("clearObjectStore:", evt.target.errorCode);
      displayActionFailure(this.error);
    };
  }

  function getBlob(key, store, success_callback) {
    var req = store.get(key);
    req.onsuccess = function(evt) {
      var value = evt.target.result;
      if (value)
        success_callback(value.blob);
    };
  }

  /**
   * @param {IDBObjectStore=} store
   */
  function displayPubList(store) {
    console.log("displayPubList");

    if (typeof store == 'undefined')
      store = getObjectStore(DB_STORE_NAME, 'readonly');

    var pub_msg = $('#pub-msg');
    pub_msg.empty();
    var pub_list = $('#pub-list');
    pub_list.empty();
    // Resetting the iframe so that it doesn't display previous content
    newViewerFrame();

    var req;
    req = store.count();
    // Requests are executed in the order in which they were made against the
    // transaction, and their results are returned in the same order.
    // Thus the count text below will be displayed before the actual pub list
    // (not that it is algorithmically important in this case).
    req.onsuccess = function(evt) {
      pub_msg.append('<p>There are <strong>' + evt.target.result +
                     '</strong> record(s) in the object store.</p>');
    };
    req.onerror = function(evt) {
      console.error("add error", this.error);
      displayActionFailure(this.error);
    };

    var i = 0;
    req = store.openCursor();
    req.onsuccess = function(evt) {
      var cursor = evt.target.result;

      // If the cursor is pointing at something, ask for the data
      if (cursor) {
        console.log("displayPubList cursor:", cursor);
        req = store.get(cursor.key);
        req.onsuccess = function (evt) {
          var value = evt.target.result;
          var list_item = $('<li>' +
                            '[' + cursor.key + '] ' +
                            '(biblioid: ' + value.biblioid + ') ' +
                            value.title +
                            '</li>');
          if (value.year != null)
            list_item.append(' - ' + value.year);

          if (value.hasOwnProperty('blob') &&
              typeof value.blob != 'undefined') {
            var link = $('<a href="' + cursor.key + '">File</a>');
            link.on('click', function() { return false; });
            link.on('mouseenter', function(evt) {
                      setInViewer(evt.target.getAttribute('href')); });
            list_item.append(' / ');
            list_item.append(link);
          } else {
            list_item.append(" / No attached file");
          }
          pub_list.append(list_item);
        };

        // Move on to the next object in store
        cursor.continue();

        // This counter serves only to create distinct ids
        i++;
      } else {
        console.log("No more entries");
      }
    };
  }

  function newViewerFrame() {
    var viewer = $('#pub-viewer');
    viewer.empty();
    var iframe = $('<iframe />');
    viewer.append(iframe);
    return iframe;
  }

  function setInViewer(key) {
    console.log("setInViewer:", arguments);
    key = Number(key);
    if (key == current_view_pub_key)
      return;

    current_view_pub_key = key;

    var store = getObjectStore(DB_STORE_NAME, 'readonly');
    getBlob(key, store, function(blob) {
      console.log("setInViewer blob:", blob);
      var iframe = newViewerFrame();

      // It is not possible to set a direct link to the
      // blob to provide a mean to directly download it.
      if (blob.type == 'text/html') {
        var reader = new FileReader();
        reader.onload = (function(evt) {
          var html = evt.target.result;
          iframe.load(function() {
            $(this).contents().find('html').html(html);
          });
        });
        reader.readAsText(blob);
      } else if (blob.type.indexOf('image/') == 0) {
        iframe.load(function() {
          var img_id = 'image-' + key;
          var img = $('<img id="' + img_id + '"/>');
          $(this).contents().find('body').html(img);
          var obj_url = window.URL.createObjectURL(blob);
          $(this).contents().find('#' + img_id).attr('src', obj_url);
          window.URL.revokeObjectURL(obj_url);
        });
      } else if (blob.type == 'application/pdf') {
        $('*').css('cursor', 'wait');
        var obj_url = window.URL.createObjectURL(blob);
        iframe.load(function() {
          $('*').css('cursor', 'auto');
        });
        iframe.attr('src', obj_url);
        window.URL.revokeObjectURL(obj_url);
      } else {
        iframe.load(function() {
          $(this).contents().find('body').html("No view available");
        });
      }

    });
  }

  /**
   * @param {string} biblioid
   * @param {string} title
   * @param {number} year
   * @param {string} url the URL of the image to download and store in the local
   *   IndexedDB database. The resource behind this URL is subjected to the
   *   "Same origin policy", thus for this method to work, the URL must come from
   *   the same origin as the web site/app this code is deployed on.
   */
  function addPublicationFromUrl(biblioid, title, year, url) {
    console.log("addPublicationFromUrl:", arguments);

    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    // Setting the wanted responseType to "blob"
    // http://www.w3.org/TR/XMLHttpRequest2/#the-response-attribute
    xhr.responseType = 'blob';
    xhr.onload = function (evt) {
      if (xhr.status == 200) {
        console.log("Blob retrieved");
        var blob = xhr.response;
        console.log("Blob:", blob);
        addPublication(biblioid, title, year, blob);
      } else {
        console.error("addPublicationFromUrl error:",
        xhr.responseText, xhr.status);
      }
    };
    xhr.send();

    // We can't use jQuery here because as of jQuery 1.8.3 the new "blob"
    // responseType is not handled.
    // http://bugs.jquery.com/ticket/11461
    // http://bugs.jquery.com/ticket/7248
    // $.ajax({
    //   url: url,
    //   type: 'GET',
    //   xhrFields: { responseType: 'blob' },
    //   success: function(data, textStatus, jqXHR) {
    //     console.log("Blob retrieved");
    //     console.log("Blob:", data);
    //     // addPublication(biblioid, title, year, data);
    //   },
    //   error: function(jqXHR, textStatus, errorThrown) {
    //     console.error(errorThrown);
    //     displayActionFailure("Error during blob retrieval");
    //   }
    // });
  }

  /**
   * @param {string} biblioid
   * @param {string} title
   * @param {number} year
   * @param {Blob=} blob
   */
  function addPublication(biblioid, title, year, blob) {
    console.log("addPublication arguments:", arguments);
    var obj = { biblioid: biblioid, title: title, year: year };
    if (typeof blob != 'undefined')
      obj.blob = blob;

    var store = getObjectStore(DB_STORE_NAME, 'readwrite');
    var req;
    try {
      req = store.add(obj);
    } catch (e) {
      if (e.name == 'DataCloneError')
        displayActionFailure("This engine doesn't know how to clone a Blob, " +
                             "use Firefox");
      throw e;
    }
    req.onsuccess = function (evt) {
      console.log("Insertion in DB successful");
      displayActionSuccess();
      displayPubList(store);
    };
    req.onerror = function() {
      console.error("addPublication error", this.error);
      displayActionFailure(this.error);
    };
  }

  /**
   * @param {string} biblioid
   */
  function deletePublicationFromBib(biblioid) {
    console.log("deletePublication:", arguments);
    var store = getObjectStore(DB_STORE_NAME, 'readwrite');
    var req = store.index('biblioid');
    req.get(biblioid).onsuccess = function(evt) {
      if (typeof evt.target.result == 'undefined') {
        displayActionFailure("No matching record found");
        return;
      }
      deletePublication(evt.target.result.id, store);
    };
    req.onerror = function (evt) {
      console.error("deletePublicationFromBib:", evt.target.errorCode);
    };
  }

  /**
   * @param {number} key
   * @param {IDBObjectStore=} store
   */
  function deletePublication(key, store) {
    console.log("deletePublication:", arguments);

    if (typeof store == 'undefined')
      store = getObjectStore(DB_STORE_NAME, 'readwrite');

    // As per spec http://www.w3.org/TR/IndexedDB/#object-store-deletion-operation
    // the result of the Object Store Deletion Operation algorithm is
    // undefined, so it's not possible to know if some records were actually
    // deleted by looking at the request result.
    var req = store.get(key);
    req.onsuccess = function(evt) {
      var record = evt.target.result;
      console.log("record:", record);
      if (typeof record == 'undefined') {
        displayActionFailure("No matching record found");
        return;
      }
      // Warning: The exact same key used for creation needs to be passed for
      // the deletion. If the key was a Number for creation, then it needs to
      // be a Number for deletion.
      req = store.delete(key);
      req.onsuccess = function(evt) {
        console.log("evt:", evt);
        console.log("evt.target:", evt.target);
        console.log("evt.target.result:", evt.target.result);
        console.log("delete successful");
        displayActionSuccess("Deletion successful");
        displayPubList(store);
      };
      req.onerror = function (evt) {
        console.error("deletePublication:", evt.target.errorCode);
      };
    };
    req.onerror = function (evt) {
      console.error("deletePublication:", evt.target.errorCode);
    };
  }

  function displayActionSuccess(msg) {
    msg = typeof msg != 'undefined' ? "Success: " + msg : "Success";
    $('#msg').html('<span class="action-success">' + msg + '</span>');
  }
  function displayActionFailure(msg) {
    msg = typeof msg != 'undefined' ? "Failure: " + msg : "Failure";
    $('#msg').html('<span class="action-failure">' + msg + '</span>');
  }
  function resetActionStatus() {
    console.log("resetActionStatus ...");
    $('#msg').empty();
    console.log("resetActionStatus DONE");
  }

  function addEventListeners() {
    console.log("addEventListeners");

    $('#register-form-reset').click(function(evt) {
      resetActionStatus();
    });

    $('#add-button').click(function(evt) {
      console.log("add ...");
      var title = $('#pub-title').val();
      var biblioid = $('#pub-biblioid').val();
      if (!title || !biblioid) {
        displayActionFailure("Required field(s) missing");
        return;
      }
      var year = $('#pub-year').val();
      if (year != '') {
        // Better use Number.isInteger if the engine has EcmaScript 6
        if (isNaN(year))  {
          displayActionFailure("Invalid year");
          return;
        }
        year = Number(year);
      } else {
        year = null;
      }

      var file_input = $('#pub-file');
      var selected_file = file_input.get(0).files[0];
      console.log("selected_file:", selected_file);
      // Keeping a reference on how to reset the file input in the UI once we
      // have its value, but instead of doing that we rather use a "reset" type
      // input in the HTML form.
      //file_input.val(null);
      var file_url = $('#pub-file-url').val();
      if (selected_file) {
        addPublication(biblioid, title, year, selected_file);
      } else if (file_url) {
        addPublicationFromUrl(biblioid, title, year, file_url);
      } else {
        addPublication(biblioid, title, year);
      }

    });

    $('#delete-button').click(function(evt) {
      console.log("delete ...");
      var biblioid = $('#pub-biblioid-to-delete').val();
      var key = $('#key-to-delete').val();

      if (biblioid != '') {
        deletePublicationFromBib(biblioid);
      } else if (key != '') {
        // Better use Number.isInteger if the engine has EcmaScript 6
        if (key == '' || isNaN(key))  {
          displayActionFailure("Invalid key");
          return;
        }
        key = Number(key);
        deletePublication(key);
      }
    });

    $('#clear-store-button').click(function(evt) {
      clearObjectStore();
    });

    var search_button = $('#search-list-button');
    search_button.click(function(evt) {
      displayPubList();
    });

  }

  openDb();
  addEventListeners();

})(); // Immediately-Invoked Function Expression (IIFE)

var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>

</body>
</html>
