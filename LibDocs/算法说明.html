<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<style>

a:hover,a:active{color:red}
table.w3-table-all{margin:20px 0}
.top {
 position:relative;
 background-color:black;
 height:68px;
 padding-top:20px;
 line-height:50px;
 overflow:hidden;
 z-index:2;
}
body {
 background-color: #000000;
 color: MediumSeaGreen;
 margin-left: 14%;
 margin-right: 14%;
 font-size: 24px;
}
a { text-decoration: none;
	color: #58D858;}
a:visited { color: #88C898;}
A:hover {	color: yellow;}
A:focus {	color: red;}
code { color: gray; background-color: #001010; font-size: 18px;}
pre { color: gray; background-color: #001010; font-size: 18px;}
h1, h2, h3, h4, h5, .goldword {
	color: gold;
}
table{
	width: 100%;
	font-size: 20px;
	border-collapse: collapse;
	border: 1px solid gray;
}
th{
	border: 1px solid gray;
	font-weight:bold;
	color: lightgreen;
}
td{
	padding:10px;
	border: 1px dotted dimgray;
}
tr>th:first-child{
	width:40%;
}
tr>td:first-child{
	color: lime;

}
img{
	margin-top:1%;
	margin-bottom:2%;
}
.topic{
    color: lime;
}
.goldsha {
    color: white;
    border: 1px solid gold;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px gold inset;
}
.redsha {
    color: gold;
    border: 1px solid red;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px red inset;
}
.whitesha {
    color: red;
    border: 1px solid white;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -3px -2px 3px white inset;
}
.orangesha {
    color: yellow;
    border: 1px solid orange;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px orange inset;
}
.yellowsha {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
	display: inline-block;
}
.greensha {
    color: lightblue;
    border: 1px solid green;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px green inset;
}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.yellowbord {
    color: lime;
    border: 1px solid yellow;
    padding: 2px;
    border-radius: 3px;
	box-shadow: 3px 3px 3px silver;
}
.bluebord {
    color: white;
    border: 1px solid lightblue;
    padding: 2px;
    border-radius: 3px;
	box-shadow: -2px -2px 3px silver inset;
}
.highlight { 
    color: white;
    background-color: #002030
  }
hr {width: 50%;}
li{
	list-style-type: decimal;
}
#toc, #tang, #san, #pill {
	margin-left: 15%;
	margin-right: 15%;
	color: gold;
	padding: 1%;
	text-align: left;
	box-shadow: 5px 5px 15px silver;
	border-radius: 5px;
	border: 1px solid DarkSlateGray;
    font-size: 90%;
}
.mywords{
    color: Crimson;
}
.orangeword{
    color: orange;
}
.remarks {
	font-size: 22px;
	color: MediumSeaGreen;
}
</STYLE>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .topic').click(function(){
    parent.history.back();
    return false;
    });
});
</script>

<link rel="stylesheet" href="submaincss.css">

</head>
<body>

<center><h2>算法说明</h2></center>
<div id="toc"><ul></ul></div>
<br>
<br>
<br>


像阅读宜家的安装说明书一样学习算法。<br>
不伦瑞克工业大学的三名研究者制作了这份“算法说明书”，简明传神地解释了一些基本算法，一起来看图说话。<br>
<h3>Quicksort算法</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/6b4b34d5d4dc4fb78b3ec9989f125975.jpeg" /><br>
快速排序（Quicksort）是基于“分治法”的高效排序算法。<br>
随机选择划分元素是避免最坏情况runtime好策略。<br>
<h3>Bogo排序</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/4ecda0eccade420a80ba271ef32bb02a.jpeg" /><br>
Bogo排序（Bogo sort）也称为愚蠢排序，是一种简单但效率非常低的排序算法。<br>
这个排序算法基于可能性，其原理等同将一堆卡片抛起，落在桌上后检查卡片是否已整齐排列好，若非就再抛一次，直到正确排好序的序列出现为止。<br>
<h3>公开密匙加密</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/7789202be183449fbcace15990c38b8e.jpeg" /><br>
公开密匙加密（Public-key cryptography）可以用于（至少）两个目的：一个人的公开密匙可以用来发送加密的消息给密钥的所有者。<br>
这个人可以使用他的私有密匙来创建数字签名，从而显示消息的真实性。<br>
<h3>二分搜素算法</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/a3778bde13e54176b1a85302c80d190e.jpeg" /><br>
二分搜素算法（Binary search）是一种用于在有序数组中查找某个值的位置的快速搜索算法。<br>
例如人们在“猜数字”时，可以通过反复询问“大于或小于x？”来找到。<br>
这种搜索算法每一次比较都使搜索范围缩小一半。<br>
<h3>归并排序</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/900f20b6510e4f398210a1a75866746e.jpeg" /><br>
归并排序（Merge sort）是基于“分治法”的递归排序算法。<br>
<h3>AVL tree</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/b4f6806c98e74774b60fbb28d00b24f9.jpeg" /><br>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/0f695bdf3a534cf6bcdfd961c1842fd7.jpeg" /><br>
AVL树（AVL tree）是一种保证项目快速查找，插入和删除的数据结构。<br>
它是二叉搜索树（Binary Search Tree）的一种自平衡变体。<br>
<h3>graph scan算法</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/b33e6f2e78e041dab6c282f9b844a52b.jpeg" /><br>
graph scan算法遍历图中所有可到达的节点。<br>
它的行为可以通过插入不同的数据结构来改变：使用无序集合导致随机搜索，使用堆栈产生深度优先搜索，使用队列产生广度优先搜索。<br>
<h3>Fleury算法</h3>
<img src="http://5b0988e595225.cdn.sohucs.com/images/20180318/7ab0a75567134e6789b59a479b8577eb.jpeg" /><br>
Fleury算法，这是一种在图中求解欧拉路径的优雅方法——一次只通过每条边一次的路径。<br>
注：IDEA是SándorP. Fekete，Sebastian Morr和Sebastian Stiller汇编的一些算法说明。<br>
它们最初是为不伦瑞克工业大学Sándor算法和数据结构讲座而创建，作者发布它们，希望它们能够用于各种背景的教学和学习。<br>
<br>
<br><br><br><br><br>
<script>
  $(function() {
    var toc = $('#toc>ul');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h3').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
