<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<style>

a:hover,a:active{color:red}
table.w3-table-all{margin:20px 0}
.top {
 position:relative;
 background-color:black;
 height:68px;
 padding-top:20px;
 line-height:50px;
 overflow:hidden;
 z-index:2;
}
body {
 background-color: #000000;
 color: MediumSeaGreen;
 margin-left: 14%;
 margin-right: 14%;
 font-size: 24px;
}
a { text-decoration: none;
	color: #58D858;}
a:visited { color: #88C898;}
A:hover {	color: yellow;}
A:focus {	color: red;}
code { color: gray; background-color: #001000}
pre { color: gray; background-color: #001008}
h1, h2, h3, h4, h5, .goldword {
	color: gold;
}
img {
	background-color: white;
}
table{
	width: 100%;
	font-size: 20px;
	border-collapse: collapse;
	border: 1px solid gray;
}
th{
	border: 1px solid gray;
	font-weight:bold;
	color: lightgreen;
}
td{
	padding:10px;
	border: 1px dotted dimgray;
}}
tr>th:first-child{
	width:40%;
}
tr>td:first-child{
	color: lime;

}
.topic{
    color: lime;
}
.left {
    position: absolute;
    left: 100px;
    color: GoldenRod;
    border: 1px solid GoldenRod;
    padding: 2px;
    font-size: 60%;
}
.bord {
    color: redpink;
    border: 1px solid GoldenRod;
    padding: 1px;
    font-size: 90%;
}
.highlight { 
    color: white;
    background-color: #002030
  }
hr {width: 50%;}
li{
	list-style-type: decimal;
}
#toc, #tang, #san, #pill {
	margin-left: 15%;
	margin-right: 15%;
	color: gold;
	padding: 1%;
	text-align: left;
	box-shadow: 5px 5px 15px silver;
	border-radius: 5px;
	border: 1px solid DarkSlateGray;
    font-size: 90%;
}
.mywords{
    color: Crimson;
}
.orangeword{
    color: orange;
}
.remarks {
	font-size: 22px;
	color: MediumSeaGreen;
}
</STYLE>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .topic').click(function(){
    parent.history.back();
    return false;
    });
});
</script>


</head><body>

<center><h1>CPP Language Tutorials</h1></center>
<div id="toc"><ul></ul></div>
<br>
<br>
<br>
<h2>Compilers</h2>
<section id="requirements">
The essential tools needed to follow these tutorials are a computer and a compiler toolchain able to compile C++ code and build the programs to run on it.<br>
<br>
C++ is a language that has evolved much over the years, and these tutorials explain many features added recently to the language. Therefore, in order to properly follow the tutorials, a recent compiler is needed. It shall support (even if only partially) the features introduced by the 2011 standard.<br>
<br>
Many compiler vendors support the new features at different degrees. See the bottom of this page for some compilers that are known to support the features needed. Some of them are free!<br>
<br>
If for some reason, you need to use some older compiler, you can access an older version of these tutorials <a href="/doc/oldtutorial/">here</a> (no longer updated).<br>
</section>
<br>
<section id="compiler">
<h3>What is a compiler?</h3>
Computers understand only one language and that language consists of sets of instructions made of ones and zeros. This computer language is appropriately called <i>machine language</i>.<br>
<br>
A single instruction to a computer could look like this:<br>
<br>
<table class="boxed"><tr><td>00000</td><td>10011110</td></tr></table>
 <br>
A particular computer's machine language program that allows a user to input two numbers, adds the two numbers together, and displays the total could include these machine code instructions:<br>
<br>
<table class="boxed">
<tr><td>00000</td><td>10011110</td></tr>
<tr><td>00001</td><td>11110100</td></tr>
<tr><td>00010</td><td>10011110</td></tr>
<tr><td>00011</td><td>11010100</td></tr>
<tr><td>00100</td><td>10111111</td></tr>
<tr><td>00101</td><td>00000000</td></tr>
</table>
 <br>
As you can imagine, programming a computer directly in machine language using only ones and zeros is very tedious and error prone. To make programming easier, high level languages have been developed. High level programs also make it easier for programmers to inspect and understand each other's programs easier.<br>
 <br>
This is a portion of code written in C++ that accomplishes the exact same purpose:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>int</var> a, b, sum;
     
cin &gt;&gt; a;
cin &gt;&gt; b;
             
sum = a + b;
cout &lt;&lt; sum &lt;&lt; endl;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Even if you cannot really understand the code above, you should be able to appreciate how much easier it will be to program in the C++ language as opposed to machine language.<br>
 <br>
Because a computer can only understand machine language and humans wish to write in high level languages high level languages have to be re-written (translated) into machine language at some point. This is done by special programs called compilers, interpreters, or assemblers that are built into the various programming applications.<br>
<br>
C++ is designed to be a compiled language, meaning that it is generally translated into machine language that can be understood directly by the system, making the generated program highly efficient. For that, a set of tools are needed, known as the development toolchain, whose core are a compiler and its linker.<br>
</section>
<br>
<section id="console">
<h3>Console programs</h3>
Console programs are programs that use text to communicate with the user and the environment, such as printing text to the screen or reading input from a keyboard.<br>
<br>
Console programs are easy to interact with, and generally have a predictable behavior that is identical across all platforms. They are also simple to implement and thus are very useful to learn the basics of a programming language: The examples in these tutorials are all console programs.<br>
<br>
The way to compile console programs depends on the particular tool you are using.<br>
<br>
The easiest way for beginners to compile C++ programs is by using an Integrated Development Environment (IDE). An IDE generally integrates several development tools, including a text editor and tools to compile programs directly from it.<br>
<br>
Here you have instructions on how to compile and run console programs using different free Integrated Development Interfaces (IDEs):<br>
<br>
<table class="boxed"><tr><th>IDE</th><th>Platform</th><th>Console programs</th></tr>
<tr><td><b>Code::blocks</b></td><td>Windows/Linux/MacOS</td><td><a href="codeblocks/">Compile console programs using Code::blocks</a></td></tr>
<tr><td><b>Visual Studio Express</b></td><td>Windows</td><td><a href="visualstudio/">Compile console programs using VS Express 2013</a></td></tr>
<tr><td><b>Dev-C++</b></td><td>Windows</td><td><a href="devcpp/">Compile console programs using Dev-C++</a></td></tr>
</table>
<br>
If you happen to have a Linux or Mac environment with development features, you should be able to compile any of the examples directly from a terminal just by including C++11 flags in the command for the compiler:<br>
<br>
<table class="boxed"><tr><th>Compiler</th><th>Platform</th><th>Command</th></tr>
<tr><td><b>GCC</b></td><td>Linux, among others...</td><td><code>g++ -std=c++0x example.cpp -o example_program</code></td></tr>
<tr><td><b>Clang</b></td><td>OS X, among others...</td><td><code>clang++ -std=c++11 -stdlib=libc++ example.cpp -o example_program</code></td></tr>
</table>
</section><table class="C_docPrevNext"><tr><td class="prev"></td><td class="index"><a href="/doc/tutorial/" rel="index">
<br>Index</a></td><td class="next"><a href="/doc/tutorial/program_structure/" rel="next">Next:<br><b>Structure of a program</b></a></td></tr></table><br><br>
<h2></h2>
<h2>Structure of a program</h2>
<section id="program_structure">
The best way to learn a programming language is by writing programs. Typically, the first program beginners write is a program called "Hello World", which simply prints "Hello World" to your computer screen. Although it is very simple, it contains all the fundamental components C++ programs have:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><cite>// my first program in C++</cite>
<dfn>#include &lt;iostream&gt;</dfn>

<var>int</var> main()
{
  std::cout &lt;&lt; <kbd>"Hello World!"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>Hello World!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The left panel above shows the C++ code for this program. The right panel shows the result when the program is executed by a computer. The grey numbers to the left of the panels are line numbers to make discussing programs and researching errors easier. They are not part of the program.<br>
<br>
Let's examine this program line by line:<br>
<br>
<dl>
<dt>Line 1: <code>// my first program in C++</code></dt>
<dd>
Two slash signs indicate that the rest of the line is a comment inserted by the programmer but which has no effect on the behavior of the program. Programmers use them to include short explanations or observations concerning the code or program. In this case, it is a brief introductory description of the program.<br>
</dd>
<br>
<dt>Line 2: <code>#include &lt;iostream&gt;</code></dt>
<dd>Lines beginning with a hash sign (<code>#</code>) are directives read and interpreted by what is known as the <i>preprocessor</i>. They are special lines interpreted before the compilation of the program itself begins. In this case, the directive <code>#include &lt;iostream&gt;</code>, instructs the preprocessor to include a section of standard C++ code, known as <i>header iostream</i>, that allows to perform standard input and output operations, such as writing the output of this program (<samp>Hello World</samp>) to the screen.<br>
</dd>
<br>
<dt>Line 3:  A blank line.</dt>
<dd>Blank lines have no effect on a program.  They simply improve readability of the code.</dd>
<br>
<dt>Line 4: <code>int main ()</code>
<dd>This line initiates the declaration of a function. Essentially, a function is a group of code statements which are given a name: in this case, this gives the name "main" to the group of code statements that follow. Functions will be discussed in detail in a later chapter, but essentially, their definition is introduced with a succession of a type (<code>int</code>), a name (<code>main</code>) and a pair of parentheses (<code>()</code>), optionally including parameters.<br>
<br>
The function named <code>main</code> is a special function in all C++ programs; it is the function called when the program is run. The execution of all C++ programs begins with the <code>main</code> function, regardless of where the function is actually located within the code.</dd>
<br>
<dt>Lines 5 and 7: <code>{</code> and <code>}</code></dt>
<dd>The open brace (<code>{</code>) at line 5 indicates the beginning of <code>main</code>'s function definition, and the closing brace (<code>}</code>) at line 7, indicates its end. Everything between these braces is the function's body that defines what happens when <code>main</code> is called. All functions use braces to indicate the beginning and end of their definitions.<br>
</dd>
<br>
<dt>Line 6: <code>std::cout &lt;&lt; "Hello World!";</code></dt>
<dd>
This line is a C++ statement. A statement is an expression that can actually produce some effect. It is the meat of a program, specifying its actual behavior. Statements are executed in the same order that they appear within a function's body.<br>
<br>
This statement has three parts: First, <code>std::cout</code>, which identifies the <b>st</b>andar<b>d</b> <b>c</b>haracter <b>out</b>put device (usually, this is the computer screen). Second, the insertion operator (<code>&lt;&lt;</code>), which indicates that what follows is inserted into <code>std::cout</code>. Finally, a sentence within quotes ("Hello world!"), is the content inserted into the standard output.<br>
<br>
Notice that the statement ends with a semicolon (<code>;</code>). This character marks the end of the statement, just as the period ends a sentence in English.  All C++ statements must end with a semicolon character. One of the most common syntax errors in C++ is forgetting to end a statement with a semicolon.<br>
</dd>
</dl>
<br>
You may have noticed that not all the lines of this program perform actions when the code is executed. There is a line containing a comment (beginning with <code>//</code>). There is a line with a directive for the preprocessor (beginning with <code>#</code>). There is a line that defines a function (in this case, the <code>main</code> function). And, finally, a line with a statements ending with a semicolon (the insertion into <code>cout</code>), which was within the block delimited by the braces ( <code>{ }</code> ) of the <code>main</code> function. <br>
<br>
The program has been structured in different lines and properly indented, in order to make it easier to understand for the humans reading it. But C++ does not have strict rules on indentation or on how to split instructions in different lines. For example, instead of <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>int</var> main ()
{
  std::cout &lt;&lt; <kbd>" Hello World!"</kbd>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
We could have written:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> main () { std::cout &lt;&lt; <kbd>"Hello World!"</kbd>; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
all in a single line, and this would have had exactly the same meaning as the preceding code.<br>
<br>
In C++, the separation between statements is specified with an ending semicolon (<code>;</code>), with the separation into different lines not mattering at all for this purpose. Many statements can be written in a single line, or each statement can be in its own line. The division of code in different lines serves only to make it more legible and schematic for the humans that may read it, but has no effect on the actual behavior of the program.<br>
<br>
Now, let's add an additional statement to our first program:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></code></pre></td>
<td class="source"><pre><code><cite>// my second program in C++</cite>
<dfn>#include &lt;iostream&gt;</dfn>

<var>int</var> main ()
{
  std::cout &lt;&lt; <kbd>"Hello World! "</kbd>;
  std::cout &lt;&lt; <kbd>"I'm a C++ program"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>Hello World! I'm a C++ program</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the program performed two insertions into <code>std::cout</code> in two different statements. Once again, the separation in different lines of code simply gives greater readability to the program, since <code>main</code> could have been perfectly valid defined in this way:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> main () { std::cout &lt;&lt; <kbd>" Hello World! "</kbd>; std::cout &lt;&lt; <kbd>" I'm a C++ program "</kbd>; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The source code could have also been divided into more code lines instead:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>int</var> main ()
{
  std::cout &lt;&lt;
    <kbd>"Hello World!"</kbd>;
  std::cout
    &lt;&lt; <kbd>"I'm a C++ program"</kbd>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
And the result would again have been exactly the same as in the previous examples.<br>
<br>
Preprocessor directives (those that begin by <code>#</code>) are out of this general rule since they are not statements. They are lines read and processed by the preprocessor before proper compilation begins. Preprocessor directives must be specified in their own line and, because they are not statements, do not have to end with a semicolon (<code>;</code>).<br>
</section>
<br>
<section id="comments">
<h3>Comments</h3>
As noted above, comments do not affect the operation of the program; however,  they provide an important tool to document directly within the source code what the program does and how it operates.<br>
<br>
C++ supports two ways of commenting code:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><cite>// line comment</cite>
<cite>/* block comment */</cite> </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first of them, known as <i>line comment</i>, discards everything from where the pair of slash signs (<code>//</code>) are found up to the end of that same line. The second one, known as <i>block comment</i>, discards everything between the <code>/*</code> characters and the first appearance of the <code>*/</code> characters, with the possibility of including multiple lines.<br>
<br>
Let's add comments to our second program: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br></code></pre></td>
<td class="source"><pre><code><cite>/* my second program in C++
   with more comments */</cite>

<dfn>#include &lt;iostream&gt;</dfn>

<var>int</var> main ()
{
  std::cout &lt;&lt; <kbd>"Hello World! "</kbd>;     <cite>// prints Hello World!</cite>
  std::cout &lt;&lt; <kbd>"I'm a C++ program"</kbd>; <cite>// prints I'm a C++ program</cite>
}</code></pre></td>
<td class="output"><pre><samp>Hello World! I'm a C++ program</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If comments are included within the source code of a program without using the comment characters combinations <code>//</code>, <code>/*</code> or <code>*/</code>, the compiler takes them as if they were C++ expressions, most likely causing the compilation to fail with one, or several, error messages.<br>
</section>
<br>
<section id="std">
<h3>Using namespace std</h3>
If you have seen C++ code before, you may have seen <code>cout</code> being used instead of <code>std::cout</code>. Both name the same object: the first one uses its <i>unqualified name</i> (<code>cout</code>), while the second qualifies it directly within the <i>namespace</i> <code>std</code> (as <code>std::cout</code>).<br>
<br>
<code>cout</code> is part of the standard library, and all the elements in the standard C++ library are declared within what is called a <i>namespace</i>: the namespace <code>std</code>.<br>
<br>
In order to refer to the elements in the <code>std</code> namespace a program shall either qualify each and every use of elements of the library (as we have done by prefixing <code>cout</code> with <code>std::</code>), or introduce visibility of its components. The most typical way to introduce visibility of these components is by means of <i>using declarations</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>using</var> <var>namespace</var> std;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The above declaration allows all elements in the <code>std</code> namespace to be accessed in an <i>unqualified</i> manner (without the <code>std::</code> prefix).<br>
<br>
With this in mind, the last example can be rewritten to make unqualified uses of <code>cout</code> as:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><cite>// my second program in C++</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  cout &lt;&lt; <kbd>"Hello World! "</kbd>;
  cout &lt;&lt; <kbd>"I'm a C++ program"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>Hello World! I'm a C++ program</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both ways of accessing the elements of the <code>std</code> namespace (explicit qualification and <i>using</i> declarations) are valid in C++ and produce the exact same behavior. For simplicity, and to improve readability, the examples in these tutorials will more often use this latter approach with <i>using</i> declarations, although note that <i>explicit qualification</i> is the only way to guarantee that name collisions never happen.<br>
<br>
Namespaces are explained in more detail in a later chapter.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/introduction/" rel="prev">Previous:<br><b>Compilers</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/variables/" rel="next">Next:<br><b>Variables and types</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Variables and types</h2>
<section id="variables">
The usefulness of the "Hello World" programs shown in the previous chapter is rather questionable. We had to write several lines of code, compile them, and then execute the resulting program, just to obtain the result of a simple sentence written on the screen. It certainly would have been much faster to type the output sentence ourselves.<br>
<br>
However, programming is not limited only to printing simple texts on the screen. In order to go a little further on and to become able to write programs that perform useful tasks that really save us work, we need to introduce the concept of <i>variables</i>.<br>
<br>
Let's imagine that I ask you to remember the number 5, and then I ask you to also memorize the number 2 at the same time. You have just stored two different values in your memory (5 and 2). Now, if I ask you to add 1 to the first number I said, you should be retaining the numbers 6 (that is 5+1) and 2 in your memory. Then we could, for example, subtract these values and obtain 4 as result.<br>
<br>
The whole process described above is a simile of what a computer can do with two variables. The same process can be expressed in C++ with the following set of statements:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>a = 5;
b = 2;
a = a + 1;
result = a - b;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Obviously, this is a very simple example, since we have only used two small integer values, but consider that your computer can store millions of numbers like these at the same time and conduct sophisticated mathematical operations with them.<br>
<br>
We can now define <dfn>variable</dfn> as a portion of memory to store a value.<br>
<br>
Each variable needs a name that identifies it and distinguishes it from the others. For example, in the previous code the variable names were <code>a</code>, <code>b</code>, and <code>result</code>, but we could have called the variables any names we could have come up with, as long as they were valid C++ identifiers.<br>
</section>
<br>
<section id="identifiers">
<h3>Identifiers</h3>
A <dfn>valid identifier</dfn> is a sequence of one or more letters, digits, or underscore characters (<code>_</code>). Spaces, punctuation marks, and symbols cannot be part of an identifier. In addition, identifiers shall always begin with a letter. They can also begin with an underline character (<code>_</code>), but such identifiers are -on most cases- considered reserved for compiler-specific keywords or external identifiers, as well as identifiers containing two successive underscore characters anywhere. In no case can they begin with a digit.<br>
<br>
C++ uses a number of keywords to identify operations and data descriptions; therefore, identifiers created by a programmer cannot match these keywords.  The standard reserved keywords that cannot be used for programmer created identifiers are:<br>
<br>
<code>
alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool, break, case, catch, char, char16_t, char32_t, class, compl, const, constexpr, const_cast, continue, decltype, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_assert, static_cast, struct, switch, template, this, thread_local, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while, xor, xor_eq<br>
</code>
<br>
Specific compilers may also have additional specific reserved keywords.<br>
<br>
<b>Very important:</b> The C++ language is a "case sensitive" language. That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters. Thus, for example, the <code>RESULT</code> variable is not the same as the <code>result</code> variable or the <code>Result</code> variable. These are three different identifiers identifiying three different variables.<br>
</section>
<br>
<section id="fundamental">
<h3>Fundamental data types</h3>
The values of variables are stored somewhere in an unspecified location in the computer memory as zeros and ones. Our program does not need to know the exact location where a variable is stored; it can simply refer to it by its name. What the program needs to be aware of is the kind of data stored in the variable. It's not the same to store a simple integer as it is to store a letter or a large floating-point number; even though they are all represented using zeros and ones, they are not interpreted in the same way, and in many cases, they don't occupy the same amount of memory.<br>
<br>
Fundamental data types are basic types implemented directly by the language that represent the basic storage units supported natively by most systems. They can mainly be classified into:<br>
<ul>
<li><b>Character types:</b> They can represent a single character, such as <code>'A'</code> or <code>'$'</code>. The most basic type is <code>char</code>, which is a one-byte character. Other types are also provided for wider characters.</li>
<li><b>Numerical integer types:</b> They can store a whole number value, such as <code>7</code> or <code>1024</code>. They exist in a variety of sizes, and can either be <i>signed</i> or <i>unsigned</i>, depending on whether they support negative values or not.</li>
<li><b>Floating-point types:</b> They can represent real values, such as <code>3.14</code> or <code>0.01</code>, with different levels of precision, depending on which of the three floating-point types is used.</li>
<li><b>Boolean type:</b> The boolean type, known in C++ as <code>bool</code>, can only represent one of two states, <code>true</code> or <code>false</code>.</li>
</ul>
<br>
Here is the complete list of fundamental types in C++:<br>
<table class="boxed">
<tr><th>Group</th><th>Type names*</th><th>Notes on size / precision</th></tr>
<tr><td rowspan="4">Character types</td><td><code><b>char</b></code></td><td>Exactly one byte in size. At least 8 bits.</td></tr>
<tr><td><code><b>char16_t</b></code></td><td>Not smaller than <code>char</code>. At least 16 bits.</td></tr>
<tr><td><code><b>char32_t</b></code></td><td>Not smaller than <code>char16_t</code>. At least 32 bits.</td></tr>
<tr><td><code><b>wchar_t</b></code></td><td>Can represent the largest supported character set.</td></tr>
<tr><td rowspan="5">Integer types (signed)</td><td><code><b>signed char</b></code></td><td>Same size as <code>char</code>. At least 8 bits.</td></tr>
<tr><td><code><i>signed</i> <b>short</b> <i>int</i></code></td><td>Not smaller than <code>char</code>. At least 16 bits.</td></tr>
<tr><td><code><i>signed</i> <b>int</b></code></td><td>Not smaller than <code>short</code>. At least 16 bits.</td></tr>
<tr><td><code><i>signed</i> <b>long</b> <i>int</i></code></td><td>Not smaller than <code>int</code>. At least 32 bits.</td></tr>
<tr><td><code><i>signed</i> <b>long long</b> <i>int</i></code></td><td>Not smaller than <code>long</code>. At least 64 bits.</td></tr>
<tr><td rowspan="5">Integer types (unsigned)</td><td><code><b>unsigned char</b></code></td><td rowspan="5">(same size as their signed counterparts)</td></tr>
<tr><td><code><b>unsigned short</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned long</b> <i>int</i></code></td></tr>
<tr><td><code><b>unsigned long long</b> <i>int</i></code></td></tr>
<tr><td rowspan="3">Floating-point types</td><td><code><b>float</b></code></td><td></td></tr>
<tr><td><code><b>double</b></code></td><td>Precision not less than <code>float</code></td></tr>
<tr><td><code><b>long double</b></code></td><td>Precision not less than <code>double</code></td></tr>
<tr><td>Boolean type</td><td><code><b>bool</b></code></td><td></td></tr>
<tr><td>Void type</td><td><code><b>void</b></code></td><td>no storage</td></tr>
<tr><td>Null pointer</td><td><code><b>decltype(nullptr)</b></code></td><td></td></tr>
</table>
<br>
* The names of certain integer types can be abbreviated without their <code>signed</code> and <code>int</code> components - only the part not in italics is required to identify the type, the part in italics is optional. I.e., <code><i>signed</i> short <i>int</i></code> can be abbreviated as <code>signed short</code>, <code>short int</code>, or simply <code>short</code>; they all identify the same fundamental type.<br>
<br>
Within each of the groups above, the difference between types is only their size (i.e., how much they occupy in memory): the first type in each group is the smallest, and the last is the largest, with each type being at least as large as the one preceding it in the same group. Other than that, the types in a group have the same properties.<br>
<br>
Note in the panel above that other than <code>char</code> (which has a size of exactly one byte), none of the fundamental types has a standard size specified (but a minimum size, at most). Therefore, the type is not required (and in many cases is not) exactly this minimum size. This does not mean that these types are of an undetermined size, but that there is no standard size across all compilers and machines; each compiler implementation may specify the sizes for these types that fit the best the architecture where the program is going to run. This rather generic size specification for types gives the C++ language a lot of flexibility to be adapted to work optimally in all kinds of platforms, both present and future. <br>
<br>
Type sizes above are expressed in bits; the more bits a type has, the more distinct values it can represent, but at the same time, also consumes more space in memory:<br>
<br>
<table class="boxed">
<tr><th>Size</th><th>Unique representable values</th><th>Notes</th></tr>
<tr><td>8-bit</td><td class="right"><code>256</code></td><td>= 2<sup>8</sup></td></tr>
<tr><td>16-bit</td><td class="right"><code>65 536</code></td><td>= 2<sup>16</sup></td></tr>
<tr><td>32-bit</td><td class="right"><code>4 294 967 296</code></td><td>= 2<sup>32</sup> (~4 billion)</td></tr>
<tr><td>64-bit</td><td class="right"><code>18 446 744 073 709 551 616</code></td><td>= 2<sup>64</sup> (~18 billion billion)</td></tr>
</table>
<br>
For integer types, having more representable values means that the range of values they can represent is greater; for example, a 16-bit unsigned integer would be able to represent 65536 distinct values in the range 0 to 65535, while its signed counterpart would be able to represent, on most cases, values between -32768 and 32767. Note that the range of positive values is approximately halved in signed types compared to unsigned types, due to the fact that one of the 16 bits is used for the sign; this is a relatively modest difference in range, and seldom justifies the use of unsigned types based purely on the range of positive values they can represent.<br>
<br>
For floating-point types, the size affects their precision, by having more or less bits for their significant and exponent.<br>
<br>
If the size or precision of the type is not a concern, then <code>char</code>, <code>int</code>, and <code>double</code> are typically selected to represent characters, integers, and floating-point values, respectively. The other types in their respective groups are only used in very particular cases.<br>
<br>
The properties of fundamental types in a particular system and compiler implementation can be obtained by using the <samp><a href="/numeric_limits">numeric_limits</a></samp> classes (see standard header <code><a href="/&lt;limits&gt;">&lt;limits&gt;</a></code>). If for some reason, types of specific sizes are needed, the library defines certain fixed-size type aliases in header <code><a href="/&lt;cstdint&gt;">&lt;cstdint&gt;</a></code>.<br>
<br>
The types described above (characters, integers, floating-point, and boolean) are collectively known as arithmetic types. But two additional fundamental types exist: <code>void</code>, which identifies the lack of type; and the type <code>nullptr</code>, which is a special type of pointer. Both types will be discussed further in a coming chapter about pointers.<br>
<br>
C++ supports a wide variety of types based on the fundamental types discussed above; these other types are known as <i>compound data types</i>, and are one of the main strengths of the C++ language. We will also see them in more detail in future chapters.<br>
</section>
<br>
<section id="declarations">
<h3>Declaration of variables</h3>
C++ is a strongly-typed language, and requires every variable to be declared with its type before its first use. This informs the compiler the size to reserve in memory for the variable and how to interpret its value. The syntax to declare a new variable in C++ is straightforward: we simply write the type followed by the variable name (i.e., its identifier). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> a;
<var>float</var> mynumber;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These are two valid declarations of variables. The first one declares a variable of type <code>int</code> with the identifier <code>a</code>. The second one declares a variable of type <code>float</code> with the identifier <code>mynumber</code>. Once declared, the variables <code>a</code> and <code>mynumber</code> can be used within the rest of their scope in the program.<br>
If declaring more than one variable of the same type, they can all be declared in a single statement by separating their identifiers with commas. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> a, b, c;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares three variables (<code>a</code>, <code>b</code> and <code>c</code>), all of them of type <code>int</code>, and has exactly the same meaning as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> a;
<var>int</var> b;
<var>int</var> c;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
To see what variable declarations look like in action within a program, let's have a look at the entire C++ code of the example about your mental memory proposed at the beginning of this chapter:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><cite>// operating with variables</cite>

<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <cite>// declaring variables:</cite>
  <var>int</var> a, b;
  <var>int</var> result;

  <cite>// process:</cite>
  a = 5;
  b = 2;
  a = a + 1;
  result = a - b;

  <cite>// print out the result:</cite>
  cout &lt;&lt; result;

  <cite>// terminate the program:</cite>
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>4</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Don't be worried if something else than the variable declarations themselves look a bit strange to you. Most of it will be explained in more detail in coming chapters.<br>
</section>
<br>
<section id="initialization">
<h3>Initialization of variables</h3>
When the variables in the example above are declared, they have an undetermined value until they are assigned a value for the first time. But it is possible for a variable to have a specific value from the moment it is declared. This is called the <i>initialization</i> of the variable.<br>
<br>
In C++, there are three ways to initialize variables. They are all equivalent and are reminiscent of the evolution of the language over the years:<br>
<br>
The first one, known as <i>c-like initialization</i> (because it is inherited from the C language), consists of appending an equal sign followed by the value to which the variable is initialized:<br>
<br>
<code>type identifier = initial_value;</code>
<br>
For example, to declare a variable of type <code>int</code> called <code>x</code> and initialize it to a value of zero from the same moment it is declared, we can write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> x = 0;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
A second method, known as <i>constructor initialization</i> (introduced by the C++ language), encloses the initial value between parentheses (<code>()</code>):<br>
<br>
<code>type identifier (initial_value);</code>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> x (0);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Finally, a third method, known as <i>uniform initialization</i>, similar to the above, but using curly braces (<code>{}</code>) instead of parentheses (this was introduced by the revision of the C++ standard, in 2011):<br>
<br>
<code>type identifier {initial_value};</code>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> x {0}; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
All three ways of initializing variables are valid and equivalent in C++.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// initialization of variables</cite>

<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> a=5;               <cite>// initial value: 5</cite>
  <var>int</var> b(3);              <cite>// initial value: 3</cite>
  <var>int</var> c{2};              <cite>// initial value: 2</cite>
  <var>int</var> result;            <cite>// initial value undetermined</cite>

  a = a + b;
  result = a - c;
  cout &lt;&lt; result;

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="type_deduction">
<h3>Type deduction: auto and decltype</h3>
When a new variable is initialized, the compiler can figure out what the type of the variable is automatically by the initializer. For this, it suffices to use <code>auto</code> as the type specifier for the variable:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> foo = 0;
<var>auto</var> bar = foo;  <cite>// the same as: int bar = foo; </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>bar</code> is declared as having an <code>auto</code> type; therefore, the type of <code>bar</code> is the type of the value used to initialize it: in this case it uses the type of <code>foo</code>, which is <code>int</code>.<br>
<br>
Variables that are not initialized can also make use of type deduction with the <code>decltype</code> specifier:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> foo = 0;
<var>decltype</var>(foo) bar;  <cite>// the same as: int bar; </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>bar</code> is declared as having the same type as <code>foo</code>.<br>
<br>
<code>auto</code> and <code>decltype</code> are powerful features recently added to the language. But the type deduction features they introduce are meant to be used either when the type cannot be obtained by other means or when using it improves code readability. The two examples above were likely neither of these use cases. In fact they probably decreased readability, since, when reading the code, one has to search for the type of <code>foo</code> to actually know the type of <code>bar</code>.<br>
</section>
<br>
<section id="strings">
<h3>Introduction to strings</h3>
Fundamental types represent the most basic types handled by the machines where the code may run. But one of the major strengths of the C++ language is its rich set of compound types, of which the fundamental types are mere building blocks.<br>
<br>
An example of compound type is the <code>string</code> class. Variables of this type are able to store sequences of characters, such as words or sentences. A very useful feature!<br>
<br>
A first difference with fundamental data types is that in order to declare and use objects (variables) of this type, the program needs to include the header where the type is defined within the standard library (header <code>&lt;string&gt;</code>): <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></code></pre></td>
<td class="source"><pre><code><cite>// my first string</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string mystring;
  mystring = <kbd>"This is a string"</kbd>;
  cout &lt;&lt; mystring;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>This is a string</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
As you can see in the previous example, strings can be initialized with any valid string literal, just like numerical type variables can be initialized to any valid numerical literal. As with fundamental types, all initialization formats are valid with strings:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>string mystring = <kbd>"This is a string"</kbd>;
string mystring (<kbd>"This is a string"</kbd>);
string mystring {<kbd>"This is a string"</kbd>};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Strings can also perform all the other basic operations that fundamental data types can, like being declared without an initial value and change its value during execution:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// my first string</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string mystring;
  mystring = <kbd>"This is the initial string content"</kbd>;
  cout &lt;&lt; mystring &lt;&lt; endl;
  mystring = <kbd>"This is a different string content"</kbd>;
  cout &lt;&lt; mystring &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>This is the initial string content
This is a different string content</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note: inserting the <code>endl</code> manipulator <b>end</b>s the <b>l</b>ine (printing a newline character and flushing the stream).<br>
<br>
The <samp><a href="/string">string</a></samp> class is a <i>compound type</i>. As you can see in the example above, <i>compound types</i> are used in the same way as <i>fundamental types</i>: the same syntax is used to declare variables and to initialize them.<br>
<br>
For more details on standard C++ strings, see the <samp><a href="/string">string</a></samp> class reference.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/program_structure/" rel="prev">Previous:<br><b>Structure of a program</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/constants/" rel="next">Next:<br><b>Constants</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Constants</h2>
<section id="constants">
<dfn>Constants</dfn> are expressions with a fixed value.<br>
</section>
<br>
<section id="literals">
<h3>Literals</h3>
Literals are the most obvious kind of constants. They are used to express particular values within the source code of a program. We have already used some in previous chapters to give specific values to variables or to express messages we wanted our programs to print out, for example, when we wrote:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>a = 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <code>5</code> in this piece of code was a <i>literal constant</i>.<br>
<br>
Literal constants can be classified into: integer, floating-point, characters, strings, Boolean, pointers, and user-defined literals.<br>
</section>
<br>
<section id="integer">
<h4>Integer Numerals</h4>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>1776
707
-273</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These are numerical constants that identify integer values. Notice that they are not enclosed in quotes or any other special character; they are a simple succession of digits representing a whole number in decimal base; for example, <code>1776</code> always represents the value <i>one thousand seven hundred seventy-six</i>.<br>
<br>
In addition to decimal numbers (those that most of us use every day), C++ allows the use of octal numbers (base 8) and hexadecimal numbers (base 16) as literal constants. For octal literals, the digits are preceded with a <code>0</code> (zero) character. And for hexadecimal, they are preceded by the characters <code>0x</code> (zero, x). For example, the following literal constants are all equivalent to each other: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>75         <cite>// decimal</cite>
0113       <cite>// octal</cite>
0x4b       <cite>// hexadecimal  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
All of these represent the same number: 75 (seventy-five) expressed as a base-10 numeral, octal numeral and hexadecimal numeral, respectively. <br>
<br>
These literal constants have a type, just like variables. By default, integer literals are of type <code>int</code>. However, certain suffixes may be appended to an integer literal to specify a different integer type:<br>
<br>
<table class="boxed">
<tr><th>Suffix</th><th>Type modifier</th></tr>
<tr><td><code>u</code> <i>or</i> <code>U</code></td><td><code>unsigned</code></td></tr>
<tr><td><code>l</code> <i>or</i> <code>L</code></td><td><code>long</code></td></tr>
<tr><td><code>ll</code> <i>or</i> <code>LL</code></td><td><code>long long</code></td></tr>
</table>
<br>
Unsigned may be combined with any of the other two in any order to form <code>unsigned long</code> or <code>unsigned long long</code>.<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code>75         <cite>// int</cite>
75u        <cite>// unsigned int</cite>
75l        <cite>// long</cite>
75ul       <cite>// unsigned long </cite>
75lu       <cite>// unsigned long </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In all the cases above, the suffix can be specified using either upper or lowercase letters.<br>
</section>
<br>
<section id="floating">
<h4>Floating Point Numerals</h4>
They express real values, with decimals and/or exponents. They can include either a decimal point, an <code>e</code> character (that expresses <i>"by ten at the Xth height"</i>, where <i>X</i> is an integer value that follows the <code>e</code> character), or both a decimal point and an <code>e</code> character:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>3.14159    <cite>// 3.14159</cite>
6.02e23    <cite>// 6.02 x 10^23</cite>
1.6e-19    <cite>// 1.6 x 10^-19</cite>
3.0        <cite>// 3.0  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These are four valid numbers with decimals expressed in C++. The first number is PI, the second one is the number of Avogadro, the third is the electric charge of an electron (an extremely small number) -all of them approximated-, and the last one is the number <i>three</i> expressed as a floating-point numeric literal.<br>
<br>
The default type for floating-point literals is <code>double</code>. Floating-point literals of type <code>float</code> or <code>long double</code> can be specified by adding one of the following suffixes:<br>
<br>
<table class="boxed">
<tr><th>Suffix</th><th>Type</th></tr>
<tr><td><code>f</code> <i>or</i> <code>F</code></td><td><code>float</code></td></tr>
<tr><td><code>l</code> <i>or</i> <code>L</code></td><td><code>long double</code></td></tr>
</table>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>3.14159L   <cite>// long double</cite>
6.02e23f   <cite>// float  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Any of the letters that can be part of a floating-point numerical constant (<code>e</code>, <code>f</code>, <code>l</code>) can be written using either lower or uppercase letters with no difference in meaning.<br>
</section>
<br>
<section id="strings">
<h4>Character and string literals</h4>
Character and string literals are enclosed in quotes:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><kbd>'z'</kbd>
<kbd>'p'</kbd>
<kbd>"Hello world"</kbd>
<kbd>"How do you do?"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first two expressions represent <i>single-character literals</i>, and the following two represent <i>string literals</i> composed of several characters. Notice that to represent a single character, we enclose it between single quotes (<code>'</code>), and to express a string (which generally consists of more than one character), we enclose the characters between double quotes (<code>"</code>).<br>
<br>
Both single-character and string literals require quotation marks surrounding them to distinguish them from possible variable identifiers or reserved keywords. Notice the difference between these two expressions:<br>
<br>
<code>
x<br>
'x'<br>
</code>
<br>
Here, <code>x</code> alone would refer to an identifier, such as the name of a variable or a compound type, whereas <code>'x'</code> (enclosed within single quotation marks) would refer to the character literal <code>'x'</code> (the character that represents a lowercase <i>x</i> letter).<br>
<br>
Character and string literals can also represent special characters that are difficult or impossible to express otherwise in the source code of a program, like newline (<code>\n</code>) or tab (<code>\t</code>). These special characters are all of them preceded by a backslash character (<code>\</code>).<br>
<br>
Here you have a list of the single character escape codes: <br>
<br>
<table class="boxed">
<tr><th>Escape code</th><th>Description</th></tr>
<tr><td><code>\n</code></td><td>newline</td></tr>
<tr><td><code>\r</code></td><td>carriage return</td></tr>
<tr><td><code>\t</code></td><td>tab</td></tr>
<tr><td><code>\v</code></td><td>vertical tab</td></tr>
<tr><td><code>\b</code></td><td>backspace</td></tr>
<tr><td><code>\f</code></td><td>form feed (page feed)</td></tr>
<tr><td><code>\a</code></td><td>alert (beep)</td></tr>
<tr><td><code>\'</code></td><td>single quote (<code>'</code>)</td></tr>
<tr><td><code>\"</code></td><td>double quote (<code>"</code>)</td></tr>
<tr><td><code>\?</code></td><td>question mark (<code>?</code>)</td></tr>
<tr><td><code>\\</code></td><td>backslash (<code>\</code>)</td></tr>
</table>
<br>
For example:<br>
<br>
<code>
'\n'<br>
'\t'<br>
"Left \t Right"<br>
"one\ntwo\nthree"<br>
</code>
<br>
Internally, computers represent characters as numerical codes: most typically, they use one extension of the <a href="/ascii">ASCII</a> character encoding system (see <a href="/ascii">ASCII code</a> for more info). Characters can also be represented in literals using its numerical code by writing a backslash character (<code>\</code>) followed by the code expressed as an octal (base-8) or hexadecimal (base-16) number. For an octal value, the backslash is followed directly by the digits; while for hexadecimal, an <code>x</code> character is inserted between the backslash and the hexadecimal digits themselves (for example: <code>\x20</code> or <code>\x4A</code>).<br>
<br>
Several string literals can be concatenated to form a single string literal simply by separating them by one or more blank spaces, including tabs, newlines, and other valid blank characters. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><kbd>"this forms"</kbd> <kbd>"a single"</kbd>     <kbd>" string "</kbd>
<kbd>"of characters"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The above is a string literal equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><kbd>"this formsa single string of characters"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note how spaces within the quotes are part of the literal, while those outside them are not.<br>
<br>
Some programmers also use a trick to include long string literals in multiple lines: In C++, a backslash (<code>\</code>) at the end of line is considered a <i>line-continuation</i> character that merges both that line and the next into a single line. Therefore the following code:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>x = <kbd>"string expressed in \
two lines"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
is equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = <kbd>"string expressed in two lines"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
All the character literals and string literals described above are made of characters of type <code>char</code>. A different character type can be specified by using one of the following prefixes:<br>
<br>
<table class="boxed">
<tr><th>Prefix</th><th>Character type</th></tr>
<tr><td><code>u</code></td><td><code>char16_t</code></td></tr>
<tr><td><code>U</code></td><td><code>char32_t</code></td></tr>
<tr><td><code>L</code></td><td><code>wchar_t</code></td></tr>
</table>
<br>
Note that, unlike type suffixes for integer literals, these prefixes are <i>case sensitive</i>: lowercase for <code>char16_t</code> and uppercase for <code>char32_t</code> and <code>wchar_t</code>.<br>
<br>
For string literals, apart from the above <code>u</code>, <code>U</code>, and <code>L</code>, two additional prefixes exist:<br>
<br>
<table class="boxed">
<tr><th>Prefix</th><th>Description</th></tr>
<tr><td><code>u8</code></td><td>The string literal is encoded in the executable using UTF-8</td></tr>
<tr><td><code>R</code></td><td>The string literal is a raw string</td></tr>
</table>
<br>
In raw strings, backslashes and single and double quotes are all valid characters; the content of the literal is delimited by an initial <code>R"<i>sequence</i>(</code> and a final <code>)<i>sequence</i>"</code>, where <code><i>sequence</i></code> is any sequence of characters (including an empty sequence). The content of the string is what lies inside the parenthesis, ignoring the delimiting sequence itself. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>R<kbd>"(string with \backslash)"</kbd>
R<kbd>"&amp;%$(string with \backslash)&amp;%$"</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both strings above are equivalent to <code>"string with \\backslash"</code>. The <code>R</code> prefix can be combined with any other prefixes, such as <code>u</code>, <code>L</code> or <code>u8</code>.<br>
</section>
<br>
<section id="other">
<h4>Other literals</h4>
Three keyword literals exist in C++: <code>true</code>, <code>false</code> and <code>nullptr</code>:<br>
<ul>
<li><code>true</code> and <code>false</code> are the two possible values for variables of type <code>bool</code>.</li>
<li><code>nullptr</code> is the <i>null pointer</i> value.</li>
</ul>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>bool</var> foo = <var>true</var>;
<var>bool</var> bar = <var>false</var>;
<var>int</var>* p = <var>nullptr</var>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="const">
<h3>Typed constant expressions</h3>
Sometimes, it is just convenient to give a name to a constant value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>const</var> <var>double</var> pi = 3.1415926;
<var>const</var> <var>char</var> tab = <kbd>'\t'</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
We can then use these names instead of the literals they were defined to:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>const</var> <var>double</var> pi = 3.14159;
<var>const</var> <var>char</var> newline = <kbd>'\n'</kbd>;

<var>int</var> main ()
{
  <var>double</var> r=5.0;               <cite>// radius</cite>
  <var>double</var> circle;

  circle = 2 * pi * r;
  cout &lt;&lt; circle;
  cout &lt;&lt; newline;
}</code></pre></td>
<td class="output"><pre><samp>31.4159</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="define">
<h3>Preprocessor definitions (#define)</h3>
Another mechanism to name constant values is the use of preprocessor definitions. They have the following form:<br>
<br>
<code>#define identifier replacement</code> <br>
<br>
After this directive, any occurrence of <code>identifier</code> in the code is interpreted as <code>replacement</code>, where replacement is any sequence of characters (until the end of the line). This replacement is performed by the preprocessor, and happens before the program is compiled, thus causing a sort of blind replacement: the validity of the types or syntax involved is not checked in any way.<br>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<dfn>#define PI 3.14159</dfn>
<dfn>#define NEWLINE '\n'</dfn>

<var>int</var> main ()
{
  <var>double</var> r=5.0;               <cite>// radius</cite>
  <var>double</var> circle;

  circle = 2 * PI * r;
  cout &lt;&lt; circle;
  cout &lt;&lt; NEWLINE;

}</code></pre></td>
<td class="output"><pre><samp>31.4159</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that the <code>#define</code> lines are preprocessor directives, and as such are single-line instructions that -unlike C++ statements- do not require semicolons (;) at the end; the directive extends automatically until the end of the line. If a semicolon is included in the line, it is part of the replacement sequence and is also included in all replaced occurrences.<br>
</section>
<table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/variables/" rel="prev">Previous:<br><b>Variables and types</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/operators/" rel="next">Next:<br><b>Operators</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Operators</h2>
<section id="operators">
Once introduced to variables and constants, we can begin to operate with them by using <i>operators</i>. What follows is a complete list of operators. At this point, it is likely not necessary to know all of them, but they are all listed here to also serve as reference.<br>
</section>
<br>
<section id="assignment">
<h3>Assignment operator (=)</h3>
The assignment operator assigns a value to a variable.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
 <br>
This statement assigns the integer value <code>5</code> to the variable <code>x</code>. The assignment operation always takes place from right to left, and never the other way around:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = y;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This statement assigns to variable <code>x</code> the value contained in variable <code>y</code>. The value of <code>x</code> at the moment this statement is executed is lost and replaced by the value of <code>y</code>.<br>
<br>
Consider also that we are only assigning the value of <code>y</code> to <code>x</code> at the moment of the assignment operation. Therefore, if <code>y</code> changes at a later moment, it will not affect the new value taken by <code>x</code>.<br>
<br>
For example, let's have a look at the following code - I have included the evolution of the content stored in the variables as comments:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// assignment operator</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> a, b;         <cite>// a:?,  b:?</cite>
  a = 10;           <cite>// a:10, b:?</cite>
  b = 4;            <cite>// a:10, b:4</cite>
  a = b;            <cite>// a:4,  b:4</cite>
  b = 7;            <cite>// a:4,  b:7</cite>

  cout &lt;&lt; <kbd>"a:"</kbd>;
  cout &lt;&lt; a;
  cout &lt;&lt; <kbd>" b:"</kbd>;
  cout &lt;&lt; b;
}</code></pre></td>
<td class="output"><pre><samp>a:4 b:7</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This program prints on screen the final values of <code>a</code> and <code>b</code> (4 and 7, respectively). Notice how <code>a</code> was not affected by the final modification of <code>b</code>, even though we declared <code>a = b</code> earlier.<br>
<br>
Assignment operations are expressions that can be evaluated. That means that the assignment itself has a value, and -for fundamental types- this value is the one assigned in the operation. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>y = 2 + (x = 5);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this expression, <code>y</code> is assigned the result of adding 2 and the value of another assignment expression (which has itself a value of 5). It is roughly equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>x = 5;
y = 2 + x;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With the final result of assigning 7 to <code>y</code>.<br>
<br>
The following expression is also valid in C++: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = y = z = 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It assigns 5 to the all three variables: <code>x</code>, <code>y</code> and <code>z</code>; always from right-to-left.<br>
</section>
<br>
<section id="arithmetic">
<h3>Arithmetic operators ( +, -, *, /, % )</h3>
The five arithmetical operations supported by C++ are: <br>
<br>
<table class="boxed">
<tr><th>operator</th><th>description</th></tr>
<tr><td><code>+</code></td><td>addition</td></tr>
<tr><td><code>-</code></td><td>subtraction</td></tr>
<tr><td><code>*</code></td><td>multiplication</td></tr>
<tr><td><code>/</code></td><td>division</td></tr>
<tr><td><code>%</code></td><td>modulo</td></tr>
</table>
<br>
Operations of addition, subtraction, multiplication and division correspond literally to their respective mathematical operators. The last one, <i>modulo operator</i>, represented by a percentage sign (<code>%</code>), gives the remainder of a division of two values. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = 11 % 3;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
results in variable <code>x</code> containing the value 2, since dividing 11 by 3 results in 3, with a remainder of 2.<br>
</section>
<br>
<section id="compound">
<h3>Compound assignment (+=, -=, *=, /=, %=, &gt;&gt;=, &lt;&lt;=, &=, ^=, |=)</h3>
Compound assignment operators modify the current value of a variable by performing an operation on it. They are equivalent to assigning the result of an operation to the first operand:<br>
<br>
<table class="boxed">
<tr><th>expression</th><th>equivalent to...</th></tr>
<tr><td><code>y += x;</code></td><td><code>y = y + x;</code></td></tr>
<tr><td><code>x -= 5;</code></td><td><code>x = x - 5;</code></td></tr>
<tr><td><code>x /= y;</code></td><td><code>x = x / y;</code></td></tr>
<tr><td><code>price *= units + 1;</code></td><td><code>price = price * (units+1);</code></td></tr>
</table>
<br>
and the same for all other compound assignment operators. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br></code></pre></td>
<td class="source"><pre><code><cite>// compound assignment operators</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> a, b=3;
  a = b;
  a+=2;             <cite>// equivalent to a=a+2</cite>
  cout &lt;&lt; a;
}</code></pre></td>
<td class="output"><pre><samp>5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="increment">
<h3>Increment and decrement (++, --)</h3>
Some expression can be shortened even more: the increase operator (<code>++</code>) and the decrease operator (<code>--</code>) increase or reduce by one the value stored in a variable. They are equivalent to <code>+=1</code> and to <code>-=1</code>, respectively. Thus:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>++x;
x+=1;
x=x+1;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
are all equivalent in its functionality; the three of them increase by one the value of <code>x</code>.<br>
<br>
In the early C compilers, the three previous expressions may have produced different executable code depending on which one was used. Nowadays, this type of code optimization is generally performed automatically by the compiler, thus the three expressions should produce exactly the same executable code.<br>
<br>
A peculiarity of this operator is that it can be used both as a prefix and as a suffix. That means that it can be written either before the variable name (<code>++x</code>) or after it (<code>x++</code>). Although in simple expressions like <code>x++</code> or <code>++x</code>, both have exactly the same meaning; in other expressions in which the result of the increment or decrement operation is evaluated, they may have an important difference in their meaning: In the case that the increase operator is used as a prefix (<code>++x</code>) of the value, the expression evaluates to the final value of <code>x</code>, once it is already increased. On the other hand, in case that it is used as a suffix (<code>x++</code>), the value is also increased, but the expression evaluates to the value that x had before being increased. Notice the difference:<br>
<br>
<table class="boxed">
<tr><th>Example 1</th><th>Example 2</th></tr>
<tr><td><code>
x = 3;<br>
y = ++x;<br>
// x contains 4, y contains 4<br>
</code></td>
<td><code>
x = 3;<br>
y = x++;<br>
// x contains 4, y contains 3<br>
</code></td></tr>
</table>
<br>
In <i>Example 1</i>, the value assigned to <code>y</code> is the value of <code>x</code> after being increased. While in <i>Example 2</i>, it is the value <code>x</code> had before being increased.<br>
</section>
<br>
<section id="relational">
<h3>Relational and comparison operators ( ==, !=, &gt;, &lt;, &gt;=, &lt;= )</h3>
Two expressions can be compared using relational and equality operators. For example, to know if two values are equal or if one is greater than the other.<br>
<br>
The result of such an operation is either true or false (i.e., a Boolean value).<br>
<br>
The relational operators in C++ are:<br>
<br>
<table class="boxed">
<tr><th>operator</th><th>description</th></tr>
<tr><td><code>==</code></td><td>Equal to</td></tr>
<tr><td><code>!=</code></td><td>Not equal to</td></tr>
<tr><td><code>&lt;</code></td><td>Less than</td></tr>
<tr><td><code>&gt;</code></td><td>Greater than</td></tr>
<tr><td><code>&lt;=</code></td><td>Less than or equal to</td></tr>
<tr><td><code>&gt;=</code></td><td>Greater than or equal to</td></tr>
</table>
<br>
Here there are some examples:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code>(7 == 5)     <cite>// evaluates to false</cite>
(5 &gt; 4)      <cite>// evaluates to true</cite>
(3 != 2)     <cite>// evaluates to true</cite>
(6 &gt;= 6)     <cite>// evaluates to true</cite>
(5 &lt; 5)      <cite>// evaluates to false </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Of course, it's not just numeric constants that can be compared, but just any value, including, of course, variables. Suppose that <code>a=2</code>, <code>b=3</code> and <code>c=6</code>, then:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>(a == 5)     <cite>// evaluates to false, since a is not equal to 5</cite>
(a*b &gt;= c)   <cite>// evaluates to true, since (2*3 &gt;= 6) is true</cite>
(b+4 &gt; a*c)  <cite>// evaluates to false, since (3+4 &gt; 2*6) is false</cite>
((b=2) == a) <cite>// evaluates to true </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Be careful! The assignment operator (operator <code>=</code>, with one equal sign) is not the same as the equality comparison operator (operator <code>==</code>, with two equal signs); the first one (<code>=</code>) assigns the value on the right-hand to the variable on its left, while the other (<code>==</code>) compares whether the values on both sides of the operator are equal. Therefore, in the last expression (<code>(b=2) == a</code>), we first assigned the value <code>2</code> to <code>b</code> and then we compared it to <code>a</code> (that also stores the value 2), yielding <code>true</code>.<br>
</section>
<br>
<section id="logical">
<h3>Logical operators ( !, &&, || )</h3>
The operator <code>!</code> is the C++ operator for the Boolean operation NOT. It has only one operand, to its right, and inverts it, producing <code>false</code> if its operand is <code>true</code>, and <code>true</code> if its operand is <code>false</code>. Basically, it returns the opposite Boolean value of evaluating its operand. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>!(5 == 5)   <cite>// evaluates to false because the expression at its right (5 == 5) is true</cite>
!(6 &lt;= 4)   <cite>// evaluates to true because (6 &lt;= 4) would be false</cite>
!<var>true</var>       <cite>// evaluates to false</cite>
!<var>false</var>      <cite>// evaluates to true </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The logical operators <code>&&</code> and <code>||</code> are used when evaluating two expressions to obtain a single relational result. The operator <code>&&</code> corresponds to the Boolean logical operation AND, which yields <code>true</code> if both its operands are <code>true</code>, and <code>false</code> otherwise. The following panel shows the result of operator <code>&&</Code> evaluating the expression <code>a&&b</code>:<br>
<br>
<table class="boxed">
<tr><th colspan="3">&& OPERATOR (and)</th></tr>
<tr><th><code>a</code></th><th><code>b</code></th><th><code>a && b</code></th></tr>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>false</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</table>
<br>
The operator <code>||</code> corresponds to the Boolean logical operation OR, which yields <code>true</code> if either of its operands is <code>true</code>, thus being false only when both operands are false. Here are the possible results of <code>a||b</code>:<br>
<br>
<table class="boxed">
<tr><th colspan="3">|| OPERATOR (or)</th></tr>
<tr><th><code>a</code></th><th><code>b</code></th><th><code>a || b</code></th></tr>
<tr><td><code>true</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>true</code></td><td><code>false</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>true</code></td><td><code>true</code></td></tr>
<tr><td><code>false</code></td><td><code>false</code></td><td><code>false</code></td></tr>
</table>
<br>
For example:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>( (5 == 5) &amp;&amp; (3 &gt; 6) )  <cite>// evaluates to false ( true &amp;&amp; false )</cite>
( (5 == 5) || (3 &gt; 6) )  <cite>// evaluates to true ( true || false ) </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
When using the logical operators, C++ only evaluates what is necessary from left to right to come up with the combined relational result, ignoring the rest. Therefore, in the last example (<code>(5==5)||(3&gt;6)</code>), C++ evaluates first whether <code>5==5</code> is <code>true</code>, and if so, it never checks whether <code>3&gt;6</code> is <code>true</code> or not. This is known as <i>short-circuit evaluation</i>, and works like this for these operators:<br>
<br>
<table class="boxed">
<tr><th>operator</th><th>short-circuit</th></tr>
<tr><td><code>&&</code></td><td>if the left-hand side expression is <code>false</code>, the combined result is <code>false</code> (the right-hand side expression is never evaluated).</td></tr>
<tr><td><code>||</code></td><td>if the left-hand side expression is <code>true</code>, the combined result is <code>true</code> (the right-hand side expression is never evaluated).</td></tr>
</table>
<br>
This is mostly important when the right-hand expression has side effects, such as altering values:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>if</var> ( (i&lt;10) &amp;&amp; (++i&lt;n) ) { <cite>/*...*/</cite> }   <cite>// note that the condition increments i </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, the combined conditional expression would increase <code>i</code> by one, but only if the condition on the left of <code>&&</code> is <code>true</code>, because otherwise, the condition on the right-hand side (<code>++i&lt;n</code>) is never evaluated.<br>
</section>
<br>
<section id="conditional">
<h3>Conditional ternary operator ( ? )</h3>
The conditional operator evaluates an expression, returning one value if that expression evaluates to <code>true</code>, and a different one if the expression evaluates as <code>false</code>. Its syntax is:<br>
<br>
<code>condition ? result1 : result2</code> <br>
<br>
If <code>condition</code> is <code>true</code>, the entire expression evaluates to <code>result1</code>, and otherwise to <code>result2</code>.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>7==5 ? 4 : 3     <cite>// evaluates to 3, since 7 is not equal to 5.</cite>
7==5+2 ? 4 : 3   <cite>// evaluates to 4, since 7 is equal to 5+2.</cite>
5&gt;3 ? a : b      <cite>// evaluates to the value of a, since 5 is greater than 3.</cite>
a&gt;b ? a : b      <cite>// evaluates to whichever is greater, a or b.  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// conditional operator</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> a,b,c;

  a=2;
  b=7;
  c = (a&gt;b) ? a : b;

  cout &lt;&lt; c &lt;&lt; <kbd>'\n'</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>7</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, <code>a</code> was 2, and <code>b</code> was 7, so the expression being evaluated (<code>a&gt;b</code>) was not <code>true</code>, thus the first value specified after the question mark was discarded in favor of the second value (the one after the colon) which was <code>b</code> (with a value of 7).<br>
</section>
<br>
<section id="comma">
<h3>Comma operator ( , )</h3>
The comma operator (<code>,</code>) is used to separate two or more expressions that are included where only one expression is expected. When the set of expressions has to be evaluated for a value, only the right-most expression is considered.<br>
<br>
For example, the following code:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>a = (b=3, b+2);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
would first assign the value 3 to <code>b</code>, and then assign <code>b+2</code> to variable <code>a</code>. So, at the end, variable <code>a</code> would contain the value 5 while variable <code>b</code> would contain value 3.<br>
</section>
<br>
<section id="bitwise">
<h3>Bitwise operators ( &, |, ^, ~, &lt;&lt;, &gt;&gt; )</h3>
Bitwise operators modify variables considering the bit patterns that represent the values they store.<br>
<br>
<table class="boxed">
<tr><th>operator</th><th>asm equivalent</th><th>description</th></tr>
<tr><td><code>&</code></td><td><code>AND</code></td><td>Bitwise AND</td></tr>
<tr><td><code>|</code></td><td><code>OR</code></td><td>Bitwise inclusive OR</td></tr>
<tr><td><code>^</code></td><td><code>XOR</code></td><td>Bitwise exclusive OR</td></tr>
<tr><td><code>~</code></td><td><code>NOT</code></td><td>Unary complement (bit inversion)</td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>SHL</code></td><td>Shift bits left</td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>SHR</code></td><td>Shift bits right</td></tr>
</table>
</section>
<br>
<section id="typecast">
<h3>Explicit type casting operator</h3>
Type casting operators allow to convert a value of a given type to another type. There are several ways to do this in C++. The simplest one, which has been inherited from the C language, is to precede the expression to be converted by the new type enclosed between parentheses (()):<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> i;
<var>float</var> f = 3.14;
i = (<var>int</var>) f;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The previous code converts the floating-point number <code>3.14</code> to an integer value (<code>3</code>); the remainder is lost. Here, the typecasting operator was <code>(int)</code>. Another way to do the same thing in C++ is to use the functional notation preceding the expression to be converted by the type and enclosing the expression between parentheses:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>i = <var>int</var> (f);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both ways of casting types are valid in C++.<br>
</section>
<br>
<section id="sizeof">
<h3>sizeof</h3>
This operator accepts one parameter, which can be either a type or a variable, and returns the size in bytes of that type or object:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = <var>sizeof</var> (<var>char</var>);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>x</code> is assigned the value <code>1</code>, because <code>char</code> is a type with a size of one byte.<br>
<br>
The value returned by <code>sizeof</code> is a compile-time constant, so it is always determined before program execution.<br>
</section>
<br>
<section id="other">
<h3>Other operators</h3>
Later in these tutorials, we will see a few more operators, like the ones referring to pointers or the specifics for object-oriented programming.<br>
</section>
<br>
<section id="precedence">
<h3>Precedence of operators</h3>
A single expression may have multiple operators. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = 5 + 7 % 2;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In C++, the above expression always assigns 6 to variable <code>x</code>, because the <code>%</code> operator has a higher precedence than the <code>+</code> operator, and is always evaluated before. Parts of the expressions can be enclosed in parenthesis to override this precedence order, or to make explicitly clear the intended effect. Notice the difference:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>x = 5 + (7 % 2);    <cite>// x = 6 (same as without parenthesis)</cite>
x = (5 + 7) % 2;    <cite>// x = 0 </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
From greatest to smallest priority, C++ operators are evaluated in the following order:<br>
<table class="boxed"><tr><th>Level</th><th>Precedence group</th><th>Operator</th><th>Description</th><th>Grouping</th></tr>
<tr><td>1</td><td>Scope</td><td><code>::</code></td><td>scope qualifier</td><td>Left-to-right</td></tr>
<tr><td rowspan="4">2</td><td rowspan="4">Postfix (unary)</td><td><code>++ --</code></td><td>postfix increment / decrement</td><td rowspan="4">Left-to-right</td></tr>
<tr><td><code>()</code></td><td>functional forms</td></tr>
<tr><td><code>[]</code></td><td>subscript</td></tr>
<tr><td><code>. -&gt;</code></td><td>member access</td></tr>
<tr><td rowspan="7">3</td><td rowspan="7">Prefix (unary)</td><td><code>++ --</code></td><td>prefix increment / decrement</td><td rowspan="7">Right-to-left</td></tr>
<tr><td><code>~ !</code></td><td>bitwise NOT / logical NOT</td></tr>
<tr><td><code>+ -</code></td><td>unary prefix</td></tr>
<tr><td><code>& *</code></td><td>reference / dereference</td></tr>
<tr><td><code>new delete</code></td><td>allocation / deallocation</td></tr>
<tr><td><code>sizeof</code></td><td>parameter pack</td></tr>
<tr><td><code>(<i>type</i>)</code></td><td>C-style type-casting</td></tr>
<tr><td>4</td><td>Pointer-to-member</td><td><code>.* -&gt;*</code></td><td>access pointer</td><td>Left-to-right</td></tr>
<tr><td>5</td><td>Arithmetic: scaling</td><td><code>* / %</code></td><td>multiply, divide, modulo</td><td>Left-to-right</td></tr>
<tr><td>6</td><td>Arithmetic: addition</td><td><code>+ -</code></td><td>addition, subtraction</td><td>Left-to-right</td></tr>
<tr><td>7</td><td>Bitwise shift</td><td><code>&lt;&lt; &gt;&gt;</code></td><td>shift left, shift right</td><td>Left-to-right</td></tr>
<tr><td>8</td><td>Relational</td><td><code>&lt; &gt; &lt;= &gt;=</code></td><td>comparison operators</td><td>Left-to-right</td></tr>
<tr><td>9</td><td>Equality</td><td><code>== !=</code></td><td>equality / inequality</td><td>Left-to-right</td></tr>
<tr><td>10</td><td>And</td><td><code>&</code></td><td>bitwise AND</td><td>Left-to-right</td></tr>
<tr><td>11</td><td>Exclusive or</td><td><code>^</code></td><td>bitwise XOR</td><td>Left-to-right</td></tr>
<tr><td>12</td><td>Inclusive or</td><td><code>|</code></td><td>bitwise OR</td><td>Left-to-right</td></tr>
<tr><td>13</td><td>Conjunction</td><td><code>&&</code></td><td>logical AND</td><td>Left-to-right</td></tr>
<tr><td>14</td><td>Disjunction</td><td><code>||</code></td><td>logical OR</td><td>Left-to-right</td></tr>
<tr><td rowspan="2">15</td><td rowspan="2">Assignment-level expressions</td><td><code>= *= /= %= += -=<br>
&gt;&gt;= &lt;&lt;= &= ^= |=</code></td><td>assignment / compound assignment</td><td rowspan="2">Right-to-left</td></tr>
<tr><td><code>?:</code></td><td>conditional operator</td></tr>
<tr><td>16</td><td>Sequencing</td><td><code>,</code></td><td>comma separator</td><td>Left-to-right</td></tr>
</table>
<br>
When an expression has two operators with the same precedence level, <i>grouping</i> determines which one is evaluated first: either left-to-right or right-to-left.<br>
<br>
Enclosing all sub-statements in parentheses (even those unnecessary because of their precedence) improves code readability.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/constants/" rel="prev">Previous:<br><b>Constants</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/basic_io/" rel="next">Next:<br><b>Basic Input/Output</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Basic Input/Output</h2>
<section id="intro">
The example programs of the previous sections provided little interaction with the user, if any at all. They simply printed simple values on screen, but the standard library provides many additional ways to interact with the user via its input/output features. This section will present a short introduction to some of the most useful. <br>
<br>
C++ uses a convenient abstraction called <i>streams</i> to perform input and output operations in sequential media such as the screen, the keyboard or a file. A <dfn>stream</dfn> is an entity where a program can either insert or extract characters to/from. There is no need to know details about the media associated to the stream or any of its internal specifications. All we need to know is that streams are a source/destination of characters, and  that these characters are provided/accepted sequentially (i.e., one after another).<br>
<br>
The standard library defines a handful of stream objects that can be used to access what are considered the standard sources and destinations of characters by the environment where the program runs:<br>
<br>
<table class="boxed">
<tr><th>stream</th><th>description</th></tr>
<tr><td><code>cin</code></td><td>standard input stream</td></tr>
<tr><td><code>cout</code></td><td>standard output stream</td></tr>
<tr><td><code>cerr</code></td><td>standard error (output) stream</td></tr>
<tr><td><code>clog</code></td><td>standard logging (output) stream</td></tr>
</table>
<br>
We are going to see in more detail only <code>cout</code> and <code>cin</code> (the standard output and input streams); <code>cerr</code> and <code>clog</code> are also output streams, so they essentially work like <code>cout</code>, with the only difference being that they identify streams for specific purposes: error messages and logging; which, in many cases, in most environment setups, they actually do the exact same thing: they print on screen, although they can also be individually redirected.<br>
</section>
<br>
<section id="cout">
<h3>Standard output (cout)</h3>
On most program environments, the standard output by default is the screen, and the C++ stream object defined to access it is <code>cout</code>.<br>
<br>
For formatted output operations, <code>cout</code> is used together with the <i>insertion operator</i>, which is written as <code>&lt;&lt;</code> (i.e., two "less than" signs).<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"Output sentence"</kbd>; <cite>// prints Output sentence on screen</cite>
cout &lt;&lt; 120;               <cite>// prints number 120 on screen</cite>
cout &lt;&lt; x;                 <cite>// prints the value of x on screen  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <code>&lt;&lt;</code> operator inserts the data that follows it into the stream that precedes it. In the examples above, it inserted the literal string <code>Output sentence</code>, the number <code>120</code>, and the value of variable <code>x</code> into the standard output stream <code>cout</code>. Notice that the sentence in the first statement is enclosed in double quotes (<code>"</code>) because it is a string literal, while in the last one, <code>x</code> is not. The double quoting is what makes the difference; when the text is enclosed between them, the text is printed literally; when they are not, the text is interpreted as the identifier of a variable, and its value is printed instead. For example, these two sentences have very different results:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"Hello"</kbd>;  <cite>// prints Hello</cite>
cout &lt;&lt; Hello;    <cite>// prints the content of variable Hello </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Multiple insertion operations (&lt;&lt;) may be chained in a single statement:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"This "</kbd> &lt;&lt; <kbd>" is a "</kbd> &lt;&lt; <kbd>"single C++ statement"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This last statement would print the text <code>This is a single C++ statement</code>. Chaining insertions is especially useful to mix literals and variables in a single statement:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"I am "</kbd> &lt;&lt; age &lt;&lt; <kbd>" years old and my zipcode is "</kbd> &lt;&lt; zipcode;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Assuming the <var>age</var> variable contains the value 24 and the <var>zipcode</var> variable contains 90064, the output of the previous statement would be: <br>
<br>
<code>I am 24 years old and my zipcode is 90064</code>
<br>
What cout does not do automatically is add line breaks at the end, unless instructed to do so. For example, take the following two statements inserting into <code>cout</code>:<br>
cout &lt;&lt; "This is a sentence.";<br>
cout &lt;&lt; "This is another sentence."; <br>
<br>
The output would be in a single line, without any line breaks in between. Something like:<br>
<br>
<code>This is a sentence.This is another sentence.</code>
<br>
To insert a line break, a new-line character shall be inserted at the exact position the line should be broken. In C++, a new-line character can be specified as <code>\n</code> (i.e., a backslash character followed by a lowercase <code>n</code>). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"First sentence.\n"</kbd>;
cout &lt;&lt; <kbd>"Second sentence.\nThird sentence."</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This produces the following output: <br>
<br>
<code>
First sentence.<br>
Second sentence.<br>
Third sentence.<br>
</code>
<br>
Alternatively, the <code>endl</code> manipulator can also be used to break lines. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"First sentence."</kbd> &lt;&lt; endl;
cout &lt;&lt; <kbd>"Second sentence."</kbd> &lt;&lt; endl;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would print:<br>
<br>
<code>
First sentence.<br>
Second sentence.<br>
</code>
<br>
The <code>endl</code> manipulator produces a newline character, exactly as the insertion of <code>'\n'</code> does; but it also has an additional behavior: the stream's buffer (if any) is flushed, which means that the output is requested to be physically written to the device, if it wasn't already. This affects mainly <i>fully buffered</i> streams, and <code>cout</code> is (generally) not a <i>fully buffered</i> stream. Still, it is generally a good idea to use <code>endl</code> only when flushing the stream would be a feature and <code>'\n'</code> when it would not. Bear in mind that a flushing operation incurs a certain overhead, and on some devices it may produce a delay.<br>
</section>
<br>
<section id="cin">
<h3>Standard input (cin)</h3>
In most program environments, the standard input by default is the keyboard, and the C++ stream object defined to access it is <code>cin</code>.<br>
<br>
For formatted input operations, <code>cin</code> is used together with the extraction operator, which is written as <code>&gt;&gt;</code> (i.e., two "greater than" signs). This operator is then followed by the variable where the extracted data is stored. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> age;
cin &gt;&gt; age;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first statement declares a variable of type <code>int</code> called <code>age</code>, and the second extracts from <code>cin</code> a value to be stored in it. This operation makes the program wait for input from <code>cin</code>; generally, this means that the program will wait for the user to enter some sequence with the keyboard. In this case, note that the characters introduced using the keyboard are only transmitted to the program when the <kbd>ENTER</kbd> (or <kbd>RETURN</kbd>) key is pressed. Once the statement with the extraction operation on <code>cin</code> is reached, the program will wait for as long as needed until some input is introduced.<br>
<br>
The extraction operation on <code>cin</code> uses the type of the variable after the <code>&gt;&gt;</code> operator to determine how it interprets the characters read from the input; if it is an integer, the format expected is a series of digits, if a string a sequence of characters, etc.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// i/o example</cite>

<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> i;
  cout &lt;&lt; <kbd>"Please enter an integer value: "</kbd>;
  cin &gt;&gt; i;
  cout &lt;&lt; <kbd>"The value you entered is "</kbd> &lt;&lt; i;
  cout &lt;&lt; <kbd>" and its double is "</kbd> &lt;&lt; i*2 &lt;&lt; <kbd>".\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Please enter an integer value: 702
The value you entered is 702 and its double is 1404.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
As you can see, extracting from <code>cin</code> seems to make the task of getting input from the standard input pretty simple and straightforward. But this method also has a big drawback. What happens in the example above if the user enters something else that cannot be interpreted as an integer? Well, in this case, the extraction operation fails. And this, by default, lets the program continue without setting a value for variable <code>i</code>, producing undetermined results if the value of <code>i</code> is used later.<br>
<br>
This is very poor program behavior. Most programs are expected to behave in an expected manner no matter what the user types, handling invalid values appropriately. Only very simple programs should rely on values extracted directly from <code>cin</code> without further checking. A little later we will see how <i>stringstreams</i> can be used to have better control over user input. <br>
Extractions on <code>cin</code> can also be chained to request more than one datum in a single statement:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cin &gt;&gt; a &gt;&gt; b;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>cin &gt;&gt; a;
cin &gt;&gt; b;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In both cases, the user is expected to introduce two values, one for variable <code>a</code>, and another for variable <code>b</code>. Any kind of space is used to separate two consecutive input operations; this may either be a space, a tab, or a new-line character.<br>
</section>
<br>
<section id="cin_and_strings">
<h3>cin and strings</h3>
The extraction operator can be used on <code>cin</code> to get strings of characters in the same way as with fundamental data types:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>string mystring;
cin &gt;&gt; mystring;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
However, <code>cin</code> extraction always considers spaces (whitespaces, tabs, new-line...) as terminating the value being extracted, and thus extracting a string means to always extract a single word, not a phrase or an entire sentence.<br>
<br>
To get an entire line from <code>cin</code>, there exists a function, called <code>getline</code>, that takes the stream (<code>cin</code>) as first argument, and the string variable as second. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// cin with strings</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string mystr;
  cout &lt;&lt; <kbd>"What's your name? "</kbd>;
  getline (cin, mystr);
  cout &lt;&lt; <kbd>"Hello "</kbd> &lt;&lt; mystr &lt;&lt; <kbd>".\n"</kbd>;
  cout &lt;&lt; <kbd>"What is your favorite team? "</kbd>;
  getline (cin, mystr);
  cout &lt;&lt; <kbd>"I like "</kbd> &lt;&lt; mystr &lt;&lt; <kbd>" too!\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>What's your name? Homer Simpson
Hello Homer Simpson.
What is your favorite team? The Isotopes
I like The Isotopes too!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how in both calls to <code>getline</code>, we used the same string identifier (<code>mystr</code>). What the program does in the second call is simply replace the previous content with the new one that is introduced.<br>
<br>
The standard behavior that most users expect from a console program is that each time the program queries the user for input, the user introduces the field, and then presses <kbd>ENTER</kbd> (or <kbd>RETURN</kbd>). That is to say, input is generally expected to happen in terms of lines on console programs, and this can be achieved by using <code>getline</code> to obtain input from the user. Therefore, unless you have a strong reason not to, you should always use <code>getline</code> to get input in your console programs instead of extracting from <code>cin</code>.<br>
</section>
<br>
<section id="stringstream">
<h3>stringstream</h3>
The standard header <code><a href="/&lt;sstream&gt;">&lt;sstream&gt;</a></code> defines a type called <code><a href="/stringstream">stringstream</a></code> that allows a string to be treated as a stream, and thus allowing extraction or insertion operations from/to strings in the same way as they are performed on <code>cin</code> and <code>cout</code>. This feature is most useful to convert strings to numerical values and vice versa. For example, in order to extract an integer from a string we can write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>string mystr (<kbd>"1204"</kbd>);
<var>int</var> myint;
stringstream(mystr) &gt;&gt; myint;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares a <code>string</code> with initialized to a value of <code>"1204"</code>, and a variable of type <code>int</code>. Then, the third line uses this variable to extract from a <code>stringstream</code> constructed from the string. This piece of code stores the numerical value <code>1204</code> in the variable called <code>myint</code>.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// stringstreams</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string mystr;
  <var>float</var> price=0;
  <var>int</var> quantity=0;

  cout &lt;&lt; <kbd>"Enter price: "</kbd>;
  getline (cin,mystr);
  stringstream(mystr) &gt;&gt; price;
  cout &lt;&lt; <kbd>"Enter quantity: "</kbd>;
  getline (cin,mystr);
  stringstream(mystr) &gt;&gt; quantity;
  cout &lt;&lt; <kbd>"Total price: "</kbd> &lt;&lt; price*quantity &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Enter price: 22.25
Enter quantity: 7
Total price: 155.75</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, we acquire numeric values from the <i>standard input</i> indirectly: Instead of extracting numeric values directly from <code>cin</code>, we get lines from it into a string object (<code>mystr</code>), and then we extract the values from this string into the variables <code>price</code> and <code>quantity</code>. Once these are numerical values, arithmetic operations can be performed on them, such as multiplying them to obtain a total price.<br>
<br>
With this approach of getting entire lines and extracting their contents, we separate the process of getting user input from its interpretation as data, allowing the input process to be what the user expects, and at the same time gaining more control over the transformation of its content into useful data by the program.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/operators/" rel="prev">Previous:<br><b>Operators</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/control/" rel="next">Next:<br><b>Statements and flow control</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Statements and flow control</h2>
<section id="statement">
A simple C++ statement is each of the individual instructions of a program, like the variable declarations and expressions seen in previous sections. They always end with a semicolon (<code>;</code>), and are executed in the same order in which they appear in a program.<br>
<br>
But programs are not limited to a linear sequence of statements. During its process, a program may repeat segments of code, or take decisions and bifurcate. For that purpose, C++ provides flow control statements that serve to specify what has to be done by our program, when, and under which circumstances.<br>
<br>
Many of the flow control statements explained in this section require a generic (sub)statement as part of its syntax. This statement may either be a simple C++ statement, -such as a single instruction, terminated with a semicolon (<code>;</code>) - or a compound statement. A compound statement is a group of statements (each of them terminated by its own semicolon), but all grouped together in a block, enclosed in curly braces: {}:<br>
<br>
<code>{ statement1; statement2; statement3; }</code> <br>
<br>
The entire block is considered a single statement (composed itself of multiple substatements). Whenever a generic statement is part of the syntax of a flow control statement, this can either be a simple statement or a compound statement.<br>
</section>
<br>
<section id="ifelse">
<h3>Selection statements: if and else</h3>
The <code>if</code> keyword is used to execute a statement or block, if, and only if, a condition is fulfilled. Its syntax is:<br>
<br>
<code>if (condition) statement</code> <br>
<br>
Here, <code>condition</code> is the expression that is being evaluated. If this <code>condition</code> is true, <code>statement</code> is executed. If it is false, <code>statement</code> is not executed (it is simply ignored), and the program continues right after the entire selection statement.<br>
For example, the following code fragment prints the message <code>(x is 100)</code>, only if the value stored in the <code>x</code> variable is indeed 100:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>if</var> (x == 100)
  cout &lt;&lt; <kbd>"x is 100"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If <code>x</code> is not exactly 100, this statement is ignored, and nothing is printed.<br>
<br>
If you want to include more than a single statement to be executed when the condition is fulfilled, these statements shall be enclosed in braces (<code>{}</code>), forming a block:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>if</var> (x == 100)
{
   cout &lt;&lt; <kbd>"x is "</kbd>;
   cout &lt;&lt; x;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
As usual, indentation and line breaks in the code have no effect, so the above code is equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>if</var> (x == 100) { cout &lt;&lt; <kbd>"x is "</kbd>; cout &lt;&lt; x; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Selection statements with <code>if</code> can also specify what happens when the condition is not fulfilled, by using the <code>else</code> keyword to introduce an alternative statement. Its syntax is:<br>
<br>
<code>
if (condition) statement1 else statement2<br>
</code>
<br>
where <code>statement1</code> is executed in case condition is true, and in case it is not, <code>statement2</code> is executed.<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>if</var> (x == 100)
  cout &lt;&lt; <kbd>"x is 100"</kbd>;
<var>else</var>
  cout &lt;&lt; <kbd>"x is not 100"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This prints <code>x is 100</code>, if indeed x has a value of 100, but if it does not, and only if it does not, it prints <code>x is not 100</code> instead.<br>
Several if + else structures can be concatenated with the intention of checking a range of values. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>if</var> (x &gt; 0)
  cout &lt;&lt; <kbd>"x is positive"</kbd>;
<var>else</var> <var>if</var> (x &lt; 0)
  cout &lt;&lt; <kbd>"x is negative"</kbd>;
<var>else</var>
  cout &lt;&lt; <kbd>"x is 0"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This prints whether x is positive, negative, or zero by concatenating two if-else structures. Again, it would have also been possible to execute more than a single statement per case by grouping them into blocks enclosed in braces: <code>{}</code>.<br>
</section>
<br>
<section id="loops">
<h3>Iteration statements (loops)</h3>
Loops repeat a statement a certain number of times, or while a condition is fulfilled. They are introduced by the keywords <code>while</code>, <code>do</code>, and <code>for</code>.<br>
<br>
<div id="while">
<h4>The while loop</h4>
The simplest kind of loop is the while-loop. Its syntax is:<br>
<br>
<code>
while (expression) statement<br>
</code>
<br>
The while-loop simply repeats <code>statement</code> while <code>expression</code> is true. If, after any execution of <code>statement</code>, <code>expression</code> is no longer true, the loop ends, and the program continues right after the loop. For example, let's have a look at a countdown using a while-loop:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><cite>// custom countdown using while</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> n = 10;

  <var>while</var> (n&gt;0) {
    cout &lt;&lt; n &lt;&lt; <kbd>", "</kbd>;
    --n;
  }

  cout &lt;&lt; <kbd>"liftoff!\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first statement in <code>main</code> sets <var>n</var> to a value of 10. This is the first number in the countdown. Then the while-loop begins: if this value fulfills the condition <code>n&gt;0</code> (that <var>n</var> is greater than zero), then the block that follows the condition is executed, and repeated for as long as the condition (<code>n&gt;0</code>) remains being true.<br>
<br>
The whole process of the previous program can be interpreted according to the following script (beginning in <code>main</code>):<br>
<br>
<ol>
<li><code>n</code> is assigned a value</li>
<li>The <code>while</code> condition is checked (<code>n&gt;0</code>). At this point there are two possibilities:<br>
<ul>
<li>condition is true: the statement is executed (to step 3)<br>
<li>condition is false: ignore statement and continue after it (to step 5)<br>
</ul>
</li>
<li>Execute statement:<br>
<code>
cout &lt;&lt; n &lt;&lt; ", ";<br>
--n;<br>
</code>
(prints the value of <code>n</code> and decreases <code>n</code> by 1)<br>
</li>
<li>End of block. Return automatically to step 2.</li>
<li>Continue the program right after the block:<br>
print <code>liftoff!</code> and end the program.</li>
</ol>
<br>
A thing to consider with while-loops is that the loop should end at some point, and thus the statement shall alter values checked in the condition in some way, so as to force it to become false at some point. Otherwise, the loop will continue looping forever. In this case, the loop includes <code>--n</code>, that decreases the value of the variable that is being evaluated in the condition (<code>n</code>) by one - this will eventually make the condition (<code>n&gt;0</code>) false after a certain number of loop iterations. To be more specific, after 10 iterations, <code>n</code> becomes 0, making the condition no longer true, and ending the while-loop.<br>
<br>
Note that the complexity of this loop is trivial for a computer, and so the whole countdown is performed instantly, without any practical delay between elements of the count (if interested, see <code><a href="/sleep_for">sleep_for</a></code> for a countdown example with delays).<br>
</div>
<br>
<div id="dowhile">
<h4>The do-while loop</h4>
A very similar loop is the do-while loop, whose syntax is:<br>
<br>
<code>
do statement while (condition);<br>
</code>
<br>
It behaves like a while-loop, except that <code>condition</code> is evaluated after the execution of <code>statement</code> instead of before, guaranteeing at least one execution of <code>statement</code>, even if <code>condition</code> is never fulfilled. For example, the following example program echoes any text the user introduces until the user enters goodbye:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// echo machine</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string str;
  <var>do</var> {
    cout &lt;&lt; <kbd>"Enter text: "</kbd>;
    getline (cin,str);
    cout &lt;&lt; <kbd>"You entered: "</kbd> &lt;&lt; str &lt;&lt; <kbd>'\n'</kbd>;
  } <var>while</var> (str != <kbd>"goodbye"</kbd>);
}</code></pre></td>
<td class="output"><pre><samp>Enter text: hello
You entered: hello
Enter text: who's there?
You entered: who's there?
Enter text: goodbye
You entered: goodbye</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The do-while loop is usually preferred over a while-loop when the <code>statement</code> needs to be executed at least once, such as when the condition that is checked to end of the loop is determined within the loop statement itself. In the previous example, the user input within the block is what will determine if the loop ends. And thus, even if the user wants to end the loop as soon as possible by entering <samp>goodbye</samp>, the block in the loop needs to be executed at least once to prompt for input, and the condition can, in fact, only be determined after it is executed.<br>
</div>
<br>
<div id="for">
<h4>The for loop</h4>
The <code>for</code> loop is designed to iterate a number of times. Its syntax is:<br>
<br>
<code>
for (initialization; condition; increase) statement;<br>
</code>
<br>
Like the while-loop, this loop repeats <code>statement</code> while <code>condition</code> is true. But, in addition, the for loop provides specific locations to contain an <code>initialization</code> and an <code>increase</code> expression, executed before the loop begins the first time, and after each iteration, respectively. Therefore, it is especially useful to use counter variables as <code>condition</code>.<br>
<br>
It works in the following way:<br>
<br>
<ol>
<li><code>initialization</code> is executed. Generally, this declares a counter variable, and sets it to some initial value. This is executed a single time, at the beginning of the loop.</li>
<li><code>condition</code> is checked. If it is true, the loop continues; otherwise, the loop ends, and <code>statement</code> is skipped, going directly to step 5.</li>
<li><code>statement</code> is executed. As usual, it can be either a single statement or a block enclosed in curly braces <code>{ }</code>.</li>
<li><code>increase</code> is executed, and the loop gets back to step 2.</li>
<li>the loop ends: execution continues by the next statement after it.</li>
</ol>
<br>
Here is the countdown example using a for loop:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br></code></pre></td>
<td class="source"><pre><code><cite>// countdown using a for loop</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>for</var> (<var>int</var> n=10; n&gt;0; n--) {
    cout &lt;&lt; n &lt;&lt; <kbd>", "</kbd>;
  }
  cout &lt;&lt; <kbd>"liftoff!\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The three fields in a for-loop are optional. They can be left empty, but in all cases the semicolon signs between them are required. For example, <code>for (;n&lt;10;)</code> is a loop without <i>initialization</i> or <i>increase</i> (equivalent to a while-loop); and <code>for (;n&lt;10;++n)</code> is a loop with <i>increase</i>, but no <i>initialization</i> (maybe because the variable was already initialized before the loop). A loop with no <i>condition</i> is equivalent to a loop with <code>true</code> as condition (i.e., an infinite loop).<br>
<br>
Because each of the fields is executed in a particular time in the life cycle of a loop, it may be useful to execute more than a single expression as any of <i>initialization</i>, <i>condition</i>, or <i>statement</i>. Unfortunately, these are not statements, but rather, simple expressions, and thus cannot be replaced by a block. As expressions, they can, however, make use of the comma operator (<code>,</code>): This operator is an expression separator, and can separate multiple expressions where only one is generally expected. For example, using it, it would be possible for a for loop to handle two counter variables, initializing and increasing both:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>for</var> ( n=0, i=100 ; n!=i ; ++n, --i )
{
   <cite>// whatever here...</cite>
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This loop will execute 50 times if neither <code>n</code> or <code>i</code> are modified within the loop:<br>
<br>

<img src="http://www.cplusplus.com/doc/tutorial/control/for_loop.png" alt=""> <br>
 <br>
<code>n</code> starts with a value of 0, and <code>i</code> with 100, the condition is <code>n!=i</code> (i.e., that <code>n</code> is not equal to <code>i</code>). Because <code>n</code> is increased by one, and <code>i</code> decreased by one on each iteration, the loop's condition will become false after the 50th iteration, when both <code>n</code> and <code>i</code> are equal to 50.<br>
</div>
<br>
<div id="rangefor">
<h4>Range-based for loop</h4>
The for-loop has another syntax, which is used exclusively with ranges:<br>
<br>
<code>
for ( declaration : range ) statement;<br>
</code>
<br>
This kind of for loop iterates over all the elements in <code>range</code>, where <code>declaration</code> declares some variable able to take the value of an element in this range. Ranges are sequences of elements, including arrays, containers, and any other type supporting the functions <samp>begin</samp> and <samp>end</samp>; Most of these types have not yet been introduced in this tutorial, but we are already acquainted with at least one kind of range: strings, which are sequences of characters.<br>
<br>
An example of range-based for loop using strings:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// range-based for loop</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  string str {<kbd>"Hello!"</kbd>};
  <var>for</var> (<var>char</var> c : str)
  {
    cout &lt;&lt; <kbd>"["</kbd> &lt;&lt; c &lt;&lt; <kbd>"]"</kbd>;
  }
  cout &lt;&lt; <kbd>'\n'</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>[H][e][l][l][o][!]</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note how what precedes the colon (<code>:</code>) in the for loop is the declaration of a <code>char</code> variable (the elements in a string are of type <code>char</code>). We then use this variable, <code>c</code>, in the statement block to represent the value of each of the elements in the range.<br>
<br>
This loop is automatic and does not require the explicit declaration of any counter variable.<br>
<br>
Range based loops usually also make use of type deduction for the type of the elements with <code>auto</code>. Typically, the range-based loop above can also be written as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>for</var> (<var>auto</var> c : str)
  cout &lt;&lt; <kbd>"["</kbd> &lt;&lt; c &lt;&lt; <kbd>"]"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, the type of <code>c</code> is automatically deduced as the type of the elements in <code>str</code>.<br>
</div>
</section>
<br>
<section id="jumps">
<h3>Jump statements</h3>
Jump statements allow altering the flow of a program by performing jumps to specific locations.<br>
<br>
<div id="break">
<h4>The break statement</h4>
<code>break</code> leaves a loop, even if the condition for its end is not fulfilled. It can be used to end an infinite loop, or to force it to end before its natural end. For example, let's stop the countdown before its natural end:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// break loop example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>for</var> (<var>int</var> n=10; n&gt;0; n--)
  {
    cout &lt;&lt; n &lt;&lt; <kbd>", "</kbd>;
    <var>if</var> (n==3)
    {
      cout &lt;&lt; <kbd>"countdown aborted!"</kbd>;
      <var>break</var>;
    }
  }
}</code></pre></td>
<td class="output"><pre><samp>10, 9, 8, 7, 6, 5, 4, 3, countdown aborted!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</div>
<br>
<div id="continue">
<h4>The continue statement</h4>
The <code>continue</code> statement causes the program to skip the rest of the loop in the current iteration, as if the end of the statement block had been reached, causing it to jump to the start of the following iteration. For example, let's skip number 5 in our countdown:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></code></pre></td>
<td class="source"><pre><code><cite>// continue loop example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>for</var> (<var>int</var> n=10; n&gt;0; n--) {
    <var>if</var> (n==5) <var>continue</var>;
    cout &lt;&lt; n &lt;&lt; <kbd>", "</kbd>;
  }
  cout &lt;&lt; <kbd>"liftoff!\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>10, 9, 8, 7, 6, 4, 3, 2, 1, liftoff!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</div>
<br>
<div id="goto">
<h4>The goto statement</h4>
<code>goto</code> allows to make an absolute jump to another point in the program. This unconditional jump ignores nesting levels, and does not cause any automatic stack unwinding. Therefore, it is a feature to use with care, and preferably within the same block of statements, especially in the presence of local variables.<br>
<br>
The destination point is identified by a <i>label</i>, which is then used as an argument for the <code>goto</code> statement. A <i>label</i> is made of a valid identifier followed by a colon (<code>:</code>).<br>
<br>
<code>goto</code> is generally deemed a low-level feature, with no particular use cases in modern higher-level programming paradigms generally used with C++. But, just as an example, here is a version of our countdown loop using goto:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><cite>// goto loop example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> n=10;
mylabel:
  cout &lt;&lt; n &lt;&lt; <kbd>", "</kbd>;
  n--;
  <var>if</var> (n&gt;0) <var>goto</var> mylabel;
  cout &lt;&lt; <kbd>"liftoff!\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>10, 9, 8, 7, 6, 5, 4, 3, 2, 1, liftoff!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</div>
</section>
<br>
<section id="switch">
<h3>Another selection statement: switch.</h3>
The syntax of the switch statement is a bit peculiar. Its purpose is to check for a value among a number of possible constant expressions. It is something similar to concatenating <code>if</code>-<code>else</code> statements, but limited to constant expressions. Its most typical syntax is:<br>
<br>
<pre ><code>switch (expression)
{
  case constant1:
     group-of-statements-1;
     break;
  case constant2:
     group-of-statements-2;
     break;
  .
  .
  .
  default:
     default-group-of-statements
}</code></pre>
<br>
It works in the following way: <code>switch</code> evaluates <code>expression</code> and checks if it is equivalent to <code>constant1</code>; if it is, it executes <code>group-of-statements-1</code> until it finds the <code>break</code> statement. When it finds this <code>break</code> statement, the program jumps to the end of the entire <code>switch</code> statement (the closing brace).<br>
<br>
If expression was not equal to <code>constant1</code>, it is then checked against <code>constant2</code>. If it is equal to this, it executes <code>group-of-statements-2</code> until a <code>break</code> is found, when it jumps to the end of the switch.<br>
<br>
Finally, if the value of expression did not match any of the previously specified constants (there may be any number of these), the program executes the statements included after the <code>default:</code> label, if it exists (since it is optional).<br>
<br>
Both of the following code fragments have the same behavior, demonstrating the if-else equivalent of a switch statement:<br>
<br>
<table class="boxed">
<tr><th>switch example</th><th>if-else equivalent</th></tr>
<tr><td>
<pre ><code>switch (x) {
  case 1:
    cout &lt;&lt; "x is 1";
    break;
  case 2:
    cout &lt;&lt; "x is 2";
    break;
  default:
    cout &lt;&lt; "value of x unknown";
  }</code></pre>
</td><td>
<pre ><code>if (x == 1) {
  cout &lt;&lt; "x is 1";
}
else if (x == 2) {
  cout &lt;&lt; "x is 2";
}
else {
  cout &lt;&lt; "value of x unknown";
}
</code></pre></td></tr>
</table>
<br>
The <code>switch</code> statement has a somewhat peculiar syntax inherited from the early times of the first C compilers, because it uses labels instead of blocks. In the most typical use (shown above), this means that <code>break</code> statements are needed after each group of statements for a particular label. If <code>break</code> is not included, all statements following the case (including those under any other labels) are also executed, until the end of the switch block or a jump statement (such as <code>break</code>) is reached.<br>
<br>
If the example above lacked the break statement after the first group for case one, the program would not jump automatically to the end of the switch block after printing <code>x is 1</code>, and would instead continue executing the statements in case two (thus printing also <code>x is 2</code>). It would then continue doing so until a <code>break</code> statement is encountered, or the end of the <code>switch</code> block. This makes unnecessary to enclose the statements for each case in braces <code>{}</code>, and can also be useful to execute the same group of statements for different possible values. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><var>switch</var> (x) {
  <var>case</var> 1:
  <var>case</var> 2:
  <var>case</var> 3:
    cout &lt;&lt; <kbd>"x is 1, 2 or 3"</kbd>;
    <var>break</var>;
  <var>default</var>:
    cout &lt;&lt; <kbd>"x is not 1, 2 nor 3"</kbd>;
  }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that <code>switch</code> is limited to compare its evaluated expression against labels that are constant expressions. It is not possible to use variables as labels or ranges, because they are not valid C++ constant expressions.<br>
<br>
To check for ranges or values that are not constant, it is better to use concatenations of <code>if</code> and <code>else if</code> statements.<br>
</section>
<table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/basic_io/" rel="prev">Previous:<br><b>Basic Input/Output</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/functions/" rel="next">Next:<br><b>Functions</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Functions</h2>
<section id="functions">
Functions allow to structure programs in segments of code to perform individual tasks.<br>
<br>
In C++, a function is a group of statements that is given a name, and which can be called from some point of the program. The most common syntax to define a function is:<br>
<br>
<code>
type name ( parameter1, parameter2, ...) { statements }<br>
</code>
<br>
Where:<br>
- <code>type</code> is the type of the value returned by the function.<br>
- <code>name</code> is the identifier by which the function can be called.<br>
- <code>parameters</code> (as many as needed): Each parameter consists of a type followed by an identifier, with each parameter being separated from the next by a comma. Each parameter looks very much like a regular variable declaration (for example: <code>int x</code>), and in fact acts within the function as a regular variable which is local to the function. The purpose of parameters is to allow passing arguments to the function from the location where it is called from.<br>
- <code>statements</code> is the function's body. It is a block of statements surrounded by braces { } that specify what the function actually does.<br>
<br>
Let's have a look at an example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> addition (<var>int</var> a, <var>int</var> b)
{
  <var>int</var> r;
  r=a+b;
  <var>return</var> r;
}

<var>int</var> main ()
{
  <var>int</var> z;
  z = addition (5,3);
  cout &lt;&lt; <kbd>"The result is "</kbd> &lt;&lt; z;
}</code></pre></td>
<td class="output"><pre><samp>The result is 8</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This program is divided in two functions: <code>addition</code> and <code>main</code>. Remember that no matter the order in which they are defined, a C++ program always starts by calling <code>main</code>. In fact, <code>main</code> is the only function called automatically, and the code in any other function is only executed if its function is called from <code>main</code> (directly or indirectly).<br>
<br>
In the example above, <code>main</code> begins by declaring the variable <code>z</code> of type <code>int</code>, and right after that, it performs the first function call: it calls <code>addition</code>. The call to a function follows a structure very similar to its declaration. In the example above, the call to <code>addition</code> can be compared to its definition just a few lines earlier:<br>
<br>

<img src="http://www.cplusplus.com/doc/tutorial/functions/function_arguments.png" alt="">
 <br>
The parameters in the function declaration have a clear correspondence to the arguments passed in the function call. The call passes two values, <code>5</code> and <code>3</code>, to the function; these correspond to the parameters <code>a</code> and <code>b</Code>, declared for function <code>addition</code>.<br>
<br>
At the point at which the function is called from within main, the control is passed to function <code>addition</code>: here, execution of <code>main</code> is stopped, and will only resume once the <code>addition</code> function ends. At the moment of the function call, the value of both arguments (<code>5</code> and <code>3</code>) are copied to the local variables <code>int a</code> and <code>int b</code> within the function.<br>
<br>
Then, inside <code>addition</code>, another local variable is declared (<code>int r</code>), and by means of the expression <code>r=a+b</code>, the result of <code>a</code> plus <code>b</code> is assigned to <code>r</code>; which, for this case, where <code>a</code> is 5 and <code>b</code> is 3, means that 8 is assigned to <code>r</code>.<br>
<br>
The final statement within the function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>return</var> r;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Ends function <code>addition</code>, and returns the control back to the point where the function was called; in this case: to function <code>main</code>. At this precise moment, the program resumes its course on <code>main</code> returning exactly at the same point at which it was interrupted by the call to <code>addition</code>. But additionally, because <code>addition</code> has a return type, the call is evaluated as having a value, and this value is the value specified in the return statement that ended <code>addition</code>: in this particular case, the value of the local variable <code>r</code>, which at the moment of the <code>return</code> statement had a value of 8.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/functions/function_return_value.png" alt="">
<br>
Therefore, the call to <code>addition</code> is an expression with the value returned by the function, and in this case, that value, 8, is assigned to <code>z</code>. It is as if the entire function call (<code>addition(5,3)</code>) was replaced by the value it returns (i.e., 8).<br>
<br>
Then main simply prints this value by calling: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
A function can actually be called multiple times within a program, and its argument is naturally not limited just to literals:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> subtraction (<var>int</var> a, <var>int</var> b)
{
  <var>int</var> r;
  r=a-b;
  <var>return</var> r;
}

<var>int</var> main ()
{
  <var>int</var> x=5, y=3, z;
  z = subtraction (7,2);
  cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; subtraction (7,2) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"The third result is "</kbd> &lt;&lt; subtraction (x,y) &lt;&lt; <kbd>'\n'</kbd>;
  z= 4 + subtraction (x,y);
  cout &lt;&lt; <kbd>"The fourth result is "</kbd> &lt;&lt; z &lt;&lt; <kbd>'\n'</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>The first result is 5
The second result is 5
The third result is 2
The fourth result is 6</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Similar to the <code>addition</code> function in the previous example, this example defines a <code>subtract</code> function, that simply returns the difference between its two parameters. This time, <code>main</code> calls this function several times, demonstrating more possible ways in which a function can be called.<br>
<br>
Let's examine each of these calls, bearing in mind that each function call is itself an expression that is evaluated as the value it returns. Again, you can think of it as if the function call was itself replaced by the returned value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = subtraction (7,2);
cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If we replace the function call by the value it returns (i.e., 5), we would have:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = 5;
cout &lt;&lt; <kbd>"The first result is "</kbd> &lt;&lt; z;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With the same procedure, we could interpret:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; subtraction (7,2);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
as:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The second result is "</kbd> &lt;&lt; 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
since 5 is the value returned by <code>subtraction (7,2)</code>.<br>
<br>
In the case of:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"The third result is "</kbd> &lt;&lt; subtraction (x,y);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
 <br>
The arguments passed to subtraction are variables instead of literals. That is also valid, and works fine. The function is called with the values <code>x</code> and <code>y</code> have at the moment of the call: 5 and 3 respectively, returning 2 as result. <br>
<br>
The fourth call is again similar:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>z = 4 + subtraction (x,y);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The only addition being that now the function call is also an operand of an addition operation. Again, the result is the same as if the function call was replaced by its result: 6. Note, that thanks to the commutative property of additions, the above can also be written as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>z = subtraction (x,y) + 4;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With exactly the same result. Note also that the semicolon does not necessarily go after the function call, but, as always, at the end of the whole statement. Again, the logic behind may be easily seen again by replacing the function calls by their returned value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>z = 4 + 2;    <cite>// same as z = 4 + subtraction (x,y);</cite>
z = 2 + 4;    <cite>// same as z = subtraction (x,y) + 4; </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="void">
<h3>Functions with no type. The use of void</h3>
The syntax shown above for functions:<br>
<br>
<code>
type name ( argument1, argument2 ...) { statements }<br>
</code>
<br>
Requires the declaration to begin with a type. This is the type of the value returned by the function. But what if the function does not need to return a value? In this case, the type to be used is <code>void</code>, which is a special type to represent the absence of value. For example, a function that simply prints a message may not need to return any value:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><cite>// void function example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> printmessage ()
{
  cout &lt;&lt; <kbd>"I'm a function!"</kbd>;
}

<var>int</var> main ()
{
  printmessage ();
}</code></pre></td>
<td class="output"><pre><samp>I'm a function!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>void</code> can also be used in the function's parameter list to explicitly specify that the function takes no actual parameters when called. For example, <code>printmessage</code> could have been declared as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>void</var> printmessage (<var>void</var>)
{
  cout &lt;&lt; <kbd>"I'm a function!"</kbd>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In C++, an empty parameter list can be used instead of <code>void</code> with same meaning, but the use of <code>void</code> in the argument list was popularized by the C language, where this is a requirement.<br>
<br>
Something that in no case is optional are the parentheses that follow the function name, neither in its declaration nor when calling it. And even when the function takes no parameters, at least an empty pair of parentheses shall always be appended to the function name. See how <code>printmessage</code> was called in an earlier example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>printmessage ();</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The parentheses are what differentiate functions from other kinds of declarations or statements. The following would not call the function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>printmessage;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="mainreturns">
<h3>The return value of main</h3>
You may have noticed that the return type of <code>main</code> is <code>int</code>, but most examples in this and earlier chapters did not actually return any value from <code>main</code>.<br>
<br>
Well, there is a catch: If the execution of <code>main</code> ends normally without encountering a <code>return</code> statement the compiler assumes the function ends with an implicit return statement:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>return</var> 0;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that this only applies to function <code>main</code> for historical reasons. All other functions with a return type shall end with a proper <code>return</code> statement that includes a return value, even if this is never used.<br>
<br>
When <code>main</code> returns zero (either implicitly or explicitly), it is interpreted by the environment as that the program ended successfully. Other values may be returned by <code>main</code>, and some environments give access to that value to the caller in some way, although this behavior is not required nor necessarily portable between platforms. The values for <code>main</code> that are guaranteed to be interpreted in the same way on all platforms are:<br>
<br>
<table class="boxed">
<tr><th>value</th><th>description</th></tr>
<tr><td><code>0</code></td><td>The program was successful</td></tr>
<tr><td><code><a href="/EXIT_SUCCESS">EXIT_SUCCESS</a></code></td><td>The program was successful (same as above).<br>
This value is defined in header <code><a href="/&lt;cstdlib&gt;">&lt;cstdlib&gt;</a></code>.</td></tr>
<tr><td><code><a href="/EXIT_FAILURE">EXIT_FAILURE</a></code></td><td>The program failed.<br>
This value is defined in header <code><a href="/&lt;cstdlib&gt;">&lt;cstdlib&gt;</a></code>.</td></tr>
</table>
<br>
Because the implicit <code>return 0;</code> statement for <code>main</code> is a tricky exception, some authors consider it good practice to explicitly write the statement.<br>
</section>
<br>
<section id="reference">
<h3>Arguments passed by value and by reference</h3>
In the functions seen earlier, arguments have always been passed <i>by value</i>. This means that, when calling a function, what is passed to the function are the values of these arguments on the moment of the call, which are copied into the variables represented by the function parameters. For example, take:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> x=5, y=3, z;
z = addition ( x, y );</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, function addition is passed 5 and 3, which are copies of the values of <code>x</code> and <code>y</code>, respectively. These values (5 and 3) are used to initialize the variables set as parameters in the function's definition, but any modification of these variables within the function has no effect on the values of the variables x and y outside it, because x and y were themselves not passed to the function on the call, but only copies of their values at that moment.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/functions/function_arguments.png" alt="">
<br>
In certain cases, though, it may be useful to access an external variable from within a function. To do that, arguments can be passed <i>by reference</i>, instead of <i>by value</i>. For example, the function <code>duplicate</code> in this code duplicates the value of its three arguments, causing the variables used as arguments to actually be modified by the call:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// passing parameters by reference</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> duplicate (<var>int</var>&amp; a, <var>int</var>&amp; b, <var>int</var>&amp; c)
{
  a*=2;
  b*=2;
  c*=2;
}

<var>int</var> main ()
{
  <var>int</var> x=1, y=3, z=7;
  duplicate (x, y, z);
  cout &lt;&lt; <kbd>"x="</kbd> &lt;&lt; x &lt;&lt; <kbd>", y="</kbd> &lt;&lt; y &lt;&lt; <kbd>", z="</kbd> &lt;&lt; z;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>x=2, y=6, z=14</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
To gain access to its arguments, the function declares its parameters as <i>references</i>. In C++, references are indicated with an ampersand (<code>&</code>) following the parameter type, as in the parameters taken by <code>duplicate</code> in the example above.<br>
<br>
When a variable is passed <i>by reference</i>, what is passed is no longer a copy, but the variable itself, the variable identified by the function parameter, becomes somehow associated with the argument passed to the function, and any modification on their corresponding local variables within the function are reflected in the variables passed as arguments in the call.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/functions/function_by_reference.png" alt=""> <br>
<br>
In fact, <code>a</code>, <code>b</code>, and <code>c</code> become aliases of the arguments passed on the function call (<code>x</code>, <code>y</code>, and <code>z</code>) and any change on <code>a</code> within the function is actually modifying variable <code>x</code> outside the function. Any change on <code>b</code> modifies <code>y</code>, and any change on <code>c</code> modifies <code>z</code>. That is why when, in the example, function <code>duplicate</code> modifies the values of variables <code>a</code>, <code>b</code>, and <code>c</code>, the values of <code>x</code>, <code>y</code>, and <code>z</code> are affected.<br>
<br>
If instead of defining duplicate as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> duplicate (<var>int</var>&amp; a, <var>int</var>&amp; b, <var>int</var>&amp; c) </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Was it to be defined without the ampersand signs as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> duplicate (<var>int</var> a, <var>int</var> b, <var>int</var> c)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The variables would not be passed <i>by reference</i>, but <i>by value</i>, creating instead copies of their values. In this case, the output of the program would have been the values of <code>x</code>, <code>y</code>, and <code>z</code> without being modified (i.e., 1, 3, and 7).<br>
</section>
<br>
<section id="constref">
<h3>Efficiency considerations and const references</h3>
Calling a function with parameters taken by value causes copies of the values to be made. This is a relatively inexpensive operation for fundamental types such as <code>int</code>, but if the parameter is of a large compound type, it may result on certain overhead. For example, consider the following function:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (string a, string b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This function takes two strings as parameters (by value), and returns the result of concatenating them. By passing the arguments by value, the function forces <code>a</code> and <code>b</code> to be copies of the arguments passed to the function when it is called. And if these are long strings, it may mean copying large quantities of data just for the function call.<br>
<br>
But this copy can be avoided altogether if both parameters are made <i>references</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (string&amp; a, string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Arguments by reference do not require a copy. The function operates directly on (aliases of) the strings passed as arguments, and, at most, it might mean the transfer of certain pointers to the function. In this regard, the version of <code>concatenate</code> taking references is more efficient than the version taking values, since it does not need to copy expensive-to-copy strings.<br>
<br>
On the flip side, functions with reference parameters are generally perceived as functions that modify the arguments passed, because that is why reference parameters are actually for.<br>
<br>
The solution is for the function to guarantee that its reference parameters are not going to be modified by this function. This can be done by qualifying the parameters as constant:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>string concatenate (<var>const</var> string&amp; a, <var>const</var> string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
By qualifying them as <code>const</code>, the function is forbidden to modify the values of neither <code>a</code> nor <code>b</code>, but can actually access their values as references (aliases of the arguments), without having to make actual copies of the strings.<br>
<br>
Therefore, <code>const</code> references provide functionality similar to passing arguments by value, but with an increased efficiency for parameters of large types. That is why they are extremely popular in C++ for arguments of compound types. Note though, that for most fundamental types, there is no noticeable difference in efficiency, and in some cases, const references may even be less efficient!<br>
</section>
<br>
<section id="inline">
<h3>Inline functions</h3>
Calling a function generally causes a certain overhead (stacking arguments, jumps, etc...), and thus for very short functions, it may be more efficient to simply insert the code of the function where it is called, instead of performing the process of formally calling a function.<br>
<br>
Preceding a function declaration with the <code>inline</code> specifier informs the compiler that inline expansion is preferred over the usual function call mechanism for a specific function. This does not change at all the behavior of a function, but is merely used to suggest the compiler that the code generated by the function body shall be inserted at each point the function is called, instead of being invoked with a regular function call.<br>
<br>
For example, the concatenate function above may be declared inline as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>inline</var> string concatenate (<var>const</var> string&amp; a, <var>const</var> string&amp; b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This informs the compiler that when <code>concatenate</code> is called, the program prefers the function to be expanded inline, instead of performing a regular call. <code>inline</code> is only specified in the function declaration, not when it is called.<br>
<br>
Note that most compilers already optimize code to generate inline functions when they see an opportunity to improve efficiency, even if not explicitly marked with the <code>inline</code> specifier. Therefore, this specifier merely indicates the compiler that inline is preferred for this function, although the compiler is free to not inline it, and optimize otherwise. In C++, optimization is a task delegated to the compiler, which is free to generate any code for as long as the resulting behavior is the one specified by the code.<br>
</section>
<br>
<section id="defaultvalues">
<h3>Default values in parameters</h3>
In C++, functions can also have optional parameters, for which no arguments are required in the call, in such a way that, for example, a function with three parameters may be called with only two. For this, the function shall include a default value for its last parameter, which is used by the function when called with fewer arguments. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// default values in functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> divide (<var>int</var> a, <var>int</var> b=2)
{
  <var>int</var> r;
  r=a/b;
  <var>return</var> (r);
}

<var>int</var> main ()
{
  cout &lt;&lt; divide (12) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; divide (20,4) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, there are two calls to function <code>divide</code>. In the first one:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>divide (12)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The call only passes one argument to the function, even though the function has two parameters. In this case, the function assumes the second parameter to be 2 (notice the function definition, which declares its second parameter as <code>int b=2</code>). Therefore, the result is 6.<br>
<br>
In the second call:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>divide (20,4)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The call passes two arguments to the function. Therefore, the default value for <code>b</code> (<code>int b=2</code>) is ignored, and <code>b</code> takes the value passed as argument, that is 4, yielding a result of 5.<br>
</section>
<br>
<section id="declarations">
<h3>Declaring functions</h3>
In C++, identifiers can only be used in expressions once they have been declared. For example, some variable <code>x</code> cannot be used before being declared with a statement, such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> x;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The same applies to functions. Functions cannot be called before they are declared. That is why, in all the previous examples of functions, the functions were always defined before the <code>main</code> function, which is the function from where the other functions were called. If <code>main</code> were defined before the other functions, this would break the rule that functions shall be declared before being used, and thus would not compile.<br>
<br>
The prototype of a function can be declared without actually defining the function completely, giving just enough details to allow the types involved in a function call to be known. Naturally, the function shall be defined somewhere else, like later in the code. But at least, once declared like this, it can already be called.<br>
<br>
The declaration shall include all types involved (the return type and the type of its arguments), using the same syntax as used in the definition of the function, but replacing the body of the function (the block of statements) with an ending semicolon.<br>
<br>
The parameter list does not need to include the parameter names, but only their types. Parameter names can nevertheless be specified, but they are optional, and do not need to necessarily match those in the function definition. For example, a function called <code>protofunction</code> with two int parameters can be declared with either of these statements:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> protofunction (<var>int</var> first, <var>int</var> second);
<var>int</var> protofunction (<var>int</var>, <var>int</var>);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Anyway, including a name for each parameter always improves legibility of the declaration.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><cite>// declaring functions prototypes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> odd (<var>int</var> x);
<var>void</var> even (<var>int</var> x);

<var>int</var> main()
{
  <var>int</var> i;
  <var>do</var> {
    cout &lt;&lt; <kbd>"Please, enter number (0 to exit): "</kbd>;
    cin &gt;&gt; i;
    odd (i);
  } <var>while</var> (i!=0);
  <var>return</var> 0;
}

<var>void</var> odd (<var>int</var> x)
{
  <var>if</var> ((x%2)!=0) cout &lt;&lt; <kbd>"It is odd.\n"</kbd>;
  <var>else</var> even (x);
}

<var>void</var> even (<var>int</var> x)
{
  <var>if</var> ((x%2)==0) cout &lt;&lt; <kbd>"It is even.\n"</kbd>;
  <var>else</var> odd (x);
}</code></pre></td>
<td class="output"><pre><samp>Please, enter number (0 to exit): 9
It is odd.
Please, enter number (0 to exit): 6
It is even.
Please, enter number (0 to exit): 1030
It is even.
Please, enter number (0 to exit): 0
It is even.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This example is indeed not an example of efficiency. You can probably write yourself a version of this program with half the lines of code. Anyway, this example illustrates how functions can be declared before its definition:<br>
<br>
The following lines:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>void</var> odd (<var>int</var> a);
<var>void</var> even (<var>int</var> a); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Declare the prototype of the functions. They already contain all what is necessary to call them, their name, the types of their argument, and their return type (<code>void</code> in this case). With these prototype declarations in place, they can be called before they are entirely defined, allowing for example, to place the function from where they are called (<code>main</code>)  before the actual definition of these functions.<br>
<br>
But declaring functions before being defined is not only useful to reorganize the order of functions within the code. In some cases, such as in this particular case, at least one of the declarations is required, because <code>odd</code> and <code>even</code> are mutually called; there is a call to <code>even</code> in <code>odd</code> and a call to <code>odd</code> in <code>even</code>. And, therefore, there is no way to structure the code so that <code>odd</code> is defined before <code>even</code>, and <code>even</code> before <code>odd</code>.<br>
</section>
<br>
<section id="recursivity">
<h3>Recursivity</h3>
Recursivity is the property that functions have to be called by themselves. It is useful for some tasks, such as sorting elements, or calculating the factorial of numbers. For example, in order to obtain the factorial of a number (<code>n!</code>) the mathematical formula would be:<br>
<br>
<code>n! = n * (n-1) * (n-2) * (n-3) ... * 1</code>
<br>
More concretely, <code>5!</code> (factorial of 5) would be:<br>
<br>
<code>5! = 5 * 4 * 3 * 2 * 1 = 120</code>
<br>
And a recursive function to calculate this in C++ could be:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// factorial calculator</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>long</var> factorial (<var>long</var> a)
{
  <var>if</var> (a &gt; 1)
   <var>return</var> (a * factorial (a-1));
  <var>else</var>
   <var>return</var> 1;
}

<var>int</var> main ()
{
  <var>long</var> number = 9;
  cout &lt;&lt; number &lt;&lt; <kbd>"! = "</kbd> &lt;&lt; factorial (number);
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>9! = 362880</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how in function factorial we included a call to itself, but only if the argument passed was greater than 1, since, otherwise, the function would perform an infinite recursive loop, in which once it arrived to 0, it would continue multiplying by all the negative numbers (probably provoking a stack overflow at some point during runtime).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/control/" rel="prev">Previous:<br><b>Statements and flow control</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/functions2/" rel="next">Next:<br><b>Overloads and templates</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Overloads and templates</h2>
<section id="overload">
<h3>Overloaded functions</h3>
In C++, two different functions can have the same name if their parameters are different; either because they have a different number of parameters, or because any of their parameters are of a different type. For example: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// overloading functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> operate (<var>int</var> a, <var>int</var> b)
{
  <var>return</var> (a*b);
}

<var>double</var> operate (<var>double</var> a, <var>double</var> b)
{
  <var>return</var> (a/b);
}

<var>int</var> main ()
{
  <var>int</var> x=5,y=2;
  <var>double</var> n=5.0,m=2.0;
  cout &lt;&lt; operate (x,y) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; operate (n,m) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>10
2.5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, there are two functions called <code>operate</code>, but one of them has two parameters of type <code>int</code>, while the other has them of type <code>double</code>. The compiler knows which one to call in each case by examining the types passed as arguments when the function is called. If it is called with two <code>int</code> arguments, it calls to the function that has two <code>int</code> parameters, and if it is called with two <code>double</code>s, it calls the one with two <code>double</code>s.<br>
<br>
In this example, both functions have quite different behaviors, the <code>int</code> version multiplies its arguments, while the <code>double</code> version divides them. This is generally not a good idea. Two functions with the same name are generally expected to have -at least- a similar behavior, but this example demonstrates that is entirely possible for them not to. Two overloaded functions (i.e., two functions with the same name) have entirely different definitions; they are, for all purposes, different functions, that only happen to have the same name.<br>
<br>
Note that a function cannot be overloaded only by its return type. At least one of its parameters must have a different type.<br>
</section>
<br>
<section id="templates">
<h3>Function templates</h3>
Overloaded functions may have the same definition. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// overloaded functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> sum (<var>int</var> a, <var>int</var> b)
{
  <var>return</var> a+b;
}

<var>double</var> sum (<var>double</var> a, <var>double</var> b)
{
  <var>return</var> a+b;
}

<var>int</var> main ()
{
  cout &lt;&lt; sum (10,20) &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; sum (1.0,1.5) &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>30
2.5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>sum</code> is overloaded with different parameter types, but with the exact same body.<br>
<br>
The function <code>sum</code> could be overloaded for a lot of types, and it could make sense for all of them to have the same body. For cases such as this, C++ has the ability to define functions with generic types, known as <i>function templates</i>. Defining a function template follows the same syntax as a regular function, except that it is preceded by the <code>template</code> keyword and a series of template parameters enclosed in angle-brackets &lt;&gt;:<br>
<br>
<code>template &lt;template-parameters&gt; function-declaration</code>
<br>
The template parameters are a series of parameters separated by commas. These parameters can be generic template types by specifying either the <code>class</code> or <code>typename</code> keyword followed by an identifier. This identifier can then be used in the function declaration as if it was a regular type. For example, a generic <code>sum</code> function could be defined as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> SomeType&gt;
SomeType sum (SomeType a, SomeType b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It makes no difference whether the generic type is specified with keyword <code>class</code> or keyword <code>typename</code> in the template argument list (they are 100% synonyms in template declarations).<br>
<br>
In the code above, declaring <code>SomeType</code> (a generic type within the template parameters enclosed in angle-brackets) allows <code>SomeType</code> to be used anywhere in the function definition, just as any other type; it can be used as the type for parameters, as return type, or to declare new variables of this type. In all cases, it represents a generic type that will be determined on the moment the template is instantiated.<br>
<br>
Instantiating  a template is applying the template to create a function using particular types or values for its template parameters. This is done by calling the <i>function template</i>, with the same syntax as calling a regular function, but specifying the template arguments enclosed in angle brackets:<br>
<br>
<code>name &lt;template-arguments&gt; (function-arguments)</code>
<br>
For example, the <code>sum</code> function template defined above can be called with:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = sum&lt;<var>int</var>&gt;(10,20);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The function <code>sum&lt;int&gt;</code> is just one of the possible instantiations of function template <code>sum</code>. In this case, by using <code>int</code> as template argument in the call, the compiler automatically instantiates a version of <code>sum</code> where each occurrence of <code>SomeType</code> is replaced by <code>int</code>, as if it was defined as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>int</var> sum (<var>int</var> a, <var>int</var> b)
{
  <var>return</var> a+b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Let's see an actual example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// function template</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
T sum (T a, T b)
{
  T result;
  result = a + b;
  <var>return</var> result;
}

<var>int</var> main () {
  <var>int</var> i=5, j=6, k;
  <var>double</var> f=2.0, g=0.5, h;
  k=sum&lt;<var>int</var>&gt;(i,j);
  h=sum&lt;<var>double</var>&gt;(f,g);
  cout &lt;&lt; k &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; h &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>11
2.5</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, we have used <code>T</code> as the template parameter name, instead of <code>SomeType</code>. It makes no difference, and <code>T</code> is actually a quite common template parameter name for generic types. <br>
<br>
In the example above, we used the function template <code>sum</code> twice. The first time with arguments of type <code>int</code>, and the second one with arguments of type <code>double</code>. The compiler has instantiated and then called each time the appropriate version of the function.<br>
<br>
Note also how <code>T</code> is also used to declare a local variable of that (generic) type within <code>sum</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>T result;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Therefore, result will be a variable of the same type as the parameters <code>a</code> and <code>b</code>, and as the type returned by the function.<br>
In this specific case where the generic type <code>T</code> is used as a parameter for <code>sum</code>, the compiler is even able to deduce the data type automatically without having to explicitly specify it within angle brackets. Therefore, instead of explicitly specifying the template arguments with:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>k = sum&lt;<var>int</var>&gt; (i,j);
h = sum&lt;<var>double</var>&gt; (f,g);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It is possible to instead simply write:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>k = sum (i,j);
h = sum (f,g);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
without the type enclosed in angle brackets. Naturally, for that, the type shall be unambiguous. If <code>sum</code> is called with arguments of different types, the compiler may not be able to deduce the type of <code>T</code> automatically.<br>
<br>
Templates are a powerful and versatile feature. They can have multiple template parameters, and the function can still use regular non-templated types. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></code></pre></td>
<td class="source"><pre><code><cite>// function templates</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T, <var>class</var> U&gt;
<var>bool</var> are_equal (T a, U b)
{
  <var>return</var> (a==b);
}

<var>int</var> main ()
{
  <var>if</var> (are_equal(10,10.0))
    cout &lt;&lt; <kbd>"x and y are equal\n"</kbd>;
  <var>else</var>
    cout &lt;&lt; <kbd>"x and y are not equal\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>x and y are equal</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that this example uses automatic template parameter deduction in the call to <code>are_equal</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>are_equal(10,10.0)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Is equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>are_equal&lt;<var>int</var>,<var>double</var>&gt;(10,10.0)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
There is no ambiguity possible because numerical literals are always of a specific type: Unless otherwise specified with a suffix, integer literals always produce values of type <code>int</code>, and floating-point literals always produce values of type <code>double</code>. Therefore <code>10</code> has always type <code>int</code> and <code>10.0</code> has always type <code>double</code>.<br>
</section>
<br>
<section id="nontype">
<h3>Non-type template arguments</h3>
The template parameters can not only include types introduced by <code>class</code> or <code>typename</code>, but can also include expressions of a particular type:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// template arguments</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T, <var>int</var> N&gt;
T fixed_multiply (T val)
{
  <var>return</var> val * N;
}

<var>int</var> main() {
  std::cout &lt;&lt; fixed_multiply&lt;<var>int</var>,2&gt;(10) &lt;&lt; <kbd>'\n'</kbd>;
  std::cout &lt;&lt; fixed_multiply&lt;<var>int</var>,3&gt;(10) &lt;&lt; <kbd>'\n'</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>20
30</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The second argument of the <code>fixed_multiply</code> function template is of type <code>int</code>. It just looks like a regular function parameter, and can actually be used just like one.<br>
<br>
But there exists a major difference: the value of template parameters is determined on compile-time to generate a different instantiation of the function <code>fixed_multiply</code>, and thus the value of that argument is never passed during runtime: The two calls to <code>fixed_multiply</code> in <code>main</code> essentially call two versions of the function: one that always multiplies by two, and one that always multiplies by three. For that same reason, the second template argument needs to be a constant expression (it cannot be passed a variable).<br>
</section>
<table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/functions/" rel="prev">Previous:<br><b>Functions</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/namespaces/" rel="next">Next:<br><b>Name visibility</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Name visibility</h2>
<section id="scopes">
<h3>Scopes</h3>
Named entities, such as variables, functions, and compound types need to be declared before being used in C++. The point in the program where this declaration happens influences its visibility:<br>
<br>
An entity declared outside any block has <i>global scope</i>, meaning that its name is valid anywhere in the code. While an entity declared within a block, such as a function or a selective statement, has <i>block scope</i>, and is only visible within the specific block in which it is declared, but not outside it.<br>
<br>
Variables with block scope are known as <i>local variables</i>.<br>
<br>
For example, a variable declared in the body of a function is a <i>local variable</i> that extends until the end of the the function (i.e., until the brace <code>}</code> that closes the function definition), but not outside it:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><var>int</var> foo;        <cite>// global variable</cite>

<var>int</var> some_function ()
{
  <var>int</var> bar;      <cite>// local variable</cite>
  bar = 0;
}

<var>int</var> other_function ()
{
  foo = 1;  <cite>// ok: foo is a global variable</cite>
  bar = 2;  <cite>// wrong: bar is not visible from this function</cite>
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In each scope, a name can only represent one entity. For example, there cannot be two variables with the same name in the same scope:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>int</var> some_function ()
{
  <var>int</var> x;
  x = 0;
  <var>double</var> x;   <cite>// wrong: name already used in this scope</cite>
  x = 0.0;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The visibility of an entity with <i>block scope</i> extends until the end of the block, including inner blocks. Nevertheless, an inner block, because it is a different block, can re-utilize a name existing in an outer scope to refer to a different entity; in this case, the name will refer to a different entity only within the inner block, hiding the entity it names outside. While outside it, it will still refer to the original entity. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// inner block scopes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>int</var> x = 10;
  <var>int</var> y = 20;
  {
    <var>int</var> x;   <cite>// ok, inner scope.</cite>
    x = 50;  <cite>// sets value to inner x</cite>
    y = 50;  <cite>// sets value to (outer) y</cite>
    cout &lt;&lt; <kbd>"inner block:\n"</kbd>;
    cout &lt;&lt; <kbd>"x: "</kbd> &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"y: "</kbd> &lt;&lt; y &lt;&lt; <kbd>'\n'</kbd>;
  }
  cout &lt;&lt; <kbd>"outer block:\n"</kbd>;
  cout &lt;&lt; <kbd>"x: "</kbd> &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"y: "</kbd> &lt;&lt; y &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>inner block:
x: 50
y: 50
outer block:
x: 10
y: 50</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that <code>y</code> is not hidden in the inner block, and thus accessing <code>y</code> still accesses the outer variable.<br>
<br>
Variables declared in declarations that introduce a block, such as function parameters and variables declared in loops and conditions (such as those declared on a for or an if) are local to the block they introduce.<br>
</section>
<br>
<section id="namespace">
<h3>Namespaces</h3>
Only one entity can exist with a particular name in a particular scope. This is seldom a problem for local names, since blocks tend to be relatively short, and names have particular purposes within them, such as naming a counter variable, an argument, etc...<br>
<br>
But non-local names bring more possibilities for name collision, especially considering that libraries may declare many functions, types, and variables, neither of them local in nature, and some of them very generic.<br>
<br>
Namespaces allow us to group named entities that otherwise would have <i>global scope</i> into narrower scopes, giving them <i>namespace scope</i>. This allows organizing the elements of programs into different logical scopes referred to by names.<br>
<br>
The syntax to declare a namespaces is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
namespace identifier
{
  named_entities
}
</samp></pre></td></tr></table></div>
<br>
Where <code>identifier</code> is any valid identifier and <code>named_entities</code> is the set of variables, types and functions that are included within the namespace. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>namespace</var> myNamespace
{
  <var>int</var> a, b;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the variables <code>a</code> and <code>b</code> are normal variables declared within a namespace called <code>myNamespace</code>.<br>
<br>
These variables can be accessed from within their namespace normally, with their identifier (either <code>a</code> or <code>b</code>), but if accessed from outside the <code>myNamespace</code> namespace they have to be properly qualified with the scope operator <code>::</Code>. For example, to access the previous variables from outside <code>myNamespace</code> they should be qualified like:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>myNamespace::a
myNamespace::b </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Namespaces are particularly useful to avoid name collisions. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// namespaces</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>namespace</var> foo
{
  <var>int</var> value() { <var>return</var> 5; }
}

<var>namespace</var> bar
{
  <var>const</var> <var>double</var> pi = 3.1416;
  <var>double</var> value() { <var>return</var> 2*pi; }
}

<var>int</var> main () {
  cout &lt;&lt; foo::value() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; bar::value() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; bar::pi &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>5
6.2832
3.1416</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, there are two functions with the same name: <code>value</code>. One is defined within the namespace <code>foo</code>, and the other one in <code>bar</code>. No redefinition errors happen thanks to namespaces. Notice also how <code>pi</code> is accessed in an unqualified manner from within namespace <code>bar</code> (just as <code>pi</code>), while it is again accessed in <code>main</code>, but here it needs to be qualified as <code>bar::pi</code>.<br>
<br>
Namespaces can be split: Two segments of a code can be declared in the same namespace:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>namespace</var> foo { <var>int</var> a; }
<var>namespace</var> bar { <var>int</var> b; }
<var>namespace</var> foo { <var>int</var> c; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares three variables: <code>a</code> and <code>c</code> are in namespace <code>foo</code>, while <code>b</code> is in namespace <code>bar</code>. Namespaces can even extend across different translation units (i.e., across different files of source code).<br>
</section>
<br>
<section id="using">
<h3>using</h3>
The keyword <code>using</code> introduces a name into the current declarative region (such as a block), thus avoiding the need to qualify the name. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code><cite>// using</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>namespace</var> first
{
  <var>int</var> x = 5;
  <var>int</var> y = 10;
}

<var>namespace</var> second
{
  <var>double</var> x = 3.1416;
  <var>double</var> y = 2.7183;
}

<var>int</var> main () {
  <var>using</var> first::x;
  <var>using</var> second::y;
  cout &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; y &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; first::y &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; second::x &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>5
2.7183
10
3.1416</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how in <code>main</code>, the variable <code>x</code> (without any name qualifier) refers to <code>first::x</code>, whereas <code>y</code> refers to <code>second::y</code>, just as specified by the <code>using</code> declarations. The variables <code>first::y</code> and <code>second::x</code> can still be accessed, but require fully qualified names.<br>
<br>
The keyword <code>using</code> can also be used as a directive to introduce an entire namespace:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// using</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>namespace</var> first
{
  <var>int</var> x = 5;
  <var>int</var> y = 10;
}

<var>namespace</var> second
{
  <var>double</var> x = 3.1416;
  <var>double</var> y = 2.7183;
}

<var>int</var> main () {
  <var>using</var> <var>namespace</var> first;
  cout &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; y &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; second::x &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; second::y &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>5
10
3.1416
2.7183</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, by declaring that we were using namespace <code>first</code>, all direct uses of <code>x</code> and <code>y</code> without name qualifiers were also looked up in namespace <code>first</code>.<br>
<br>
<code>using</code> and <code>using namespace</code> have validity only in the same block in which they are stated or in the entire source code file if they are used directly in the global scope. For example, it would be possible to first use the objects of one namespace and then those of another one by splitting the code in different blocks:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code><cite>// using namespace example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>namespace</var> first
{
  <var>int</var> x = 5;
}

<var>namespace</var> second
{
  <var>double</var> x = 3.1416;
}

<var>int</var> main () {
  {
    <var>using</var> <var>namespace</var> first;
    cout &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  }
  {
    <var>using</var> <var>namespace</var> second;
    cout &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>5
3.1416</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="alias">
<h3>Namespace aliasing</h3>
Existing namespaces can be aliased with new names, with the following syntax:<br>
<br>
<code>namespace new_name = current_name;</code>
</section>
<br>
<section id="std">
<h3>The std namespace</h3>
All the entities (variables, types, constants, and functions) of the standard C++ library are declared within the <code>std</code> namespace. Most examples in these tutorials, in fact, include the following line:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>using</var> <var>namespace</var> std;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This introduces direct visibility of all the names of the <code>std</code> namespace into the code. This is done in these tutorials to facilitate comprehension and shorten the length of the examples, but many programmers prefer to qualify each of the elements of the standard library used in their programs. For example, instead of:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"Hello world!"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It is common to instead see:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>std::cout &lt;&lt; <kbd>"Hello world!"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Whether the elements in the <code>std</code> namespace are introduced with <code>using</code> declarations or are fully qualified on every use does not change the behavior or efficiency of the resulting program in any way. It is mostly a matter of style preference, although for projects mixing libraries, explicit qualification tends to be preferred.<br>
</section>
<br>
<section id="storageclasses">
<h3>Storage classes</h3>
The storage for variables with <i>global</i> or <i>namespace scope</i> is allocated for the entire duration of the program. This is known as <i>static storage</i>, and it contrasts with the storage for <i>local variables</i> (those declared within a block). These use what is known as automatic storage. The storage for local variables is only available during the block in which they are declared; after that, that same storage may be used for a local variable of some other function, or used otherwise.<br>
<br>
But there is another substantial difference between variables with <i>static storage</i> and variables with <i>automatic storage</i>:<br>
- Variables with <i>static storage</i> (such as global variables) that are not explicitly initialized are automatically initialized to zeroes.<br>
- Variables with <i>automatic storage</i> (such as local variables) that are not explicitly initialized are left uninitialized, and thus have an undetermined value.<br>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><cite>// static vs automatic storage</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> x;

<var>int</var> main ()
{
  <var>int</var> y;
  cout &lt;&lt; x &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; y &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>0
4285838</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The actual output may vary, but only the value of <code>x</code> is guaranteed to be zero. <code>y</code> can actually contain just about any value (including zero).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/functions2/" rel="prev">Previous:<br><b>Overloads and templates</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/arrays/" rel="next">Next:<br><b>Arrays</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Arrays</h2>
<section id="arrays">
An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.<br>
<br>
That means that, for example, five values of type <code>int</code> can be declared as an array without having to declare 5 different variables (each with its own identifier). Instead, using an array, the five <code>int</code> values are stored in contiguous memory locations, and all five can be accessed using the same identifier, with the proper index.<br>
<br>
For example, an array containing 5 integer values of type <code>int</code> called <code>foo</code> could be represented as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/arrays1.png" alt="">
  <br>
where each blank panel represents an element of the array. In this case, these are values of type <code>int</code>. These elements are numbered from 0 to 4, being 0 the first and 4 the last; In C++, the first element in an array is always numbered with a zero (not a one), no matter its length.<br>
<br>
Like a regular variable, an array must be declared before it is used. A typical declaration for an array in C++ is:<br>
<br>
<code>
type name [elements];<br>
</code>
<br>
where <code>type</code> is a valid type (such as <code>int</code>, <code>float</code>...), <code>name</code> is a valid identifier and the <code>elements</code> field (which is always enclosed in square brackets <code>[]</code>), specifies the length of the array in terms of the number of elements.<br>
<br>
Therefore, the <code>foo</code> array, with five elements of type <code>int</code>, can be declared as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> foo [5];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
NOTE: The <code>elements</code> field within square brackets <code>[]</code>, representing the number of elements in the array, must be a <i>constant expression</i>, since arrays are blocks of static memory whose size must be determined at compile time, before the program runs.<br>
</section>
<br>
<section id="initialization">
<h3>Initializing arrays</h3>
By default, regular arrays of <i>local scope</i> (for example, those declared within a function) are left uninitialized. This means that none of its elements are set to any particular value; their contents are undetermined at the point the array is declared.<br>
<br>
But the elements in an array can be explicitly initialized to specific values when it is declared, by enclosing those initial values in braces {}. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> foo [5] = { 16, 2, 77, 40, 12071 }; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This statement declares an array that can be represented like this:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/arrays2.png" alt="">
<br>
The number of values between braces <code>{}</code> shall not be greater than the number of elements in the array. For example, in the example above, <code>foo</code> was declared having 5 elements (as specified by the number enclosed in square brackets, <code>[]</code>), and the braces <code>{}</code> contained exactly 5 values, one for each element. If declared with less, the remaining elements are set to their default values (which for fundamental types, means they are filled with zeroes). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> bar [5] = { 10, 20, 30 }; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Will create an array like this:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/arrays3.png" alt="">
<br>
The initializer can even have no values, just the braces:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> baz [5] = { }; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This creates an array of five <code>int</code> values, each initialized with a value of zero:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/arrays4.png" alt="">
<br>
When an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets empty <code>[]</code>. In this case, the compiler will assume automatically a size for the array that matches the number of values included between the braces <code>{}</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> foo [] = { 16, 2, 77, 40, 12071 };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
After this declaration, array <code>foo</code> would be 5 <code>int</code> long, since we have provided 5 initialization values.<br>
<br>
Finally, the evolution of C++ has led to the adoption of <i>universal initialization</i> also for arrays. Therefore, there is no longer need for the equal sign between the declaration and the initializer. Both these statements are equivalent:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> foo[] = { 10, 20, 30 };
<var>int</var> foo[] { 10, 20, 30 }; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Static arrays, and those declared directly in a namespace (outside any function), are always initialized. If no explicit initializer is specified, all the elements are default-initialized (with zeroes, for fundamental types).<br>
</section>
<br>
<section id="access">
<h3>Accessing the values of an array</h3>
The values of any of the elements in an array can be accessed just like the value of a regular variable of the same type. The syntax is:<br>
<br>
<code>name[index]</code>
<br>
Following the previous examples in which <code>foo</code> had 5 elements and each of those elements was of type <code>int</code>, the name which can be used to refer to each element is the following:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/arrays5.png" alt="">
<br>
For example, the following statement stores the value 75 in the third element of <code>foo</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>foo [2] = 75;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
and, for example, the following copies the value of the third element of <code>foo</code> to a variable called <code>x</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>x = foo[2];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Therefore, the expression <code>foo[2]</code> is itself a variable of type <code>int</code>.<br>
<br>
Notice that the third element of <code>foo</code> is specified <code>foo[2]</code>, since the first one is <code>foo[0]</code>, the second one is <code>foo[1]</code>, and therefore, the third one is <code>foo[2]</code>. By this same reason, its last element is <code>foo[4]</code>. Therefore, if we write <code>foo[5]</Code>, we would be accessing the sixth element of <code>foo</code>, and therefore actually exceeding the size of the array.<br>
<br>
In C++, it is syntactically correct to exceed the valid range of indices for an array. This can create problems, since accessing out-of-range elements do not cause errors on compilation, but can cause errors on runtime. The reason for this being allowed will be seen in a later chapter when pointers are introduced.<br>
<br>
At this point, it is important to be able to clearly distinguish between the two uses that brackets <code>[]</code> have related to arrays. They perform two different tasks: one is to specify the size of arrays when they are declared; and the second one is to specify indices for concrete array elements when they are accessed. Do not confuse these two possible uses of brackets <code>[]</code> with arrays.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> foo[5];         <cite>// declaration of a new array</cite>
foo[2] = 75;        <cite>// access to an element of the array.  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The main difference is that the declaration is preceded by the type of the elements, while the access is not.<br>
<br>
Some other valid operations with arrays:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>foo[0] = a;
foo[a] = 75;
b = foo [a+2];
foo[foo[a]] = foo[2] + 5;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// arrays example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> foo [] = {16, 2, 77, 40, 12071};
<var>int</var> n, result=0;

<var>int</var> main ()
{
  <var>for</var> ( n=0 ; n&lt;5 ; ++n )
  {
    result += foo[n];
  }
  cout &lt;&lt; result;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>12206</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="multidimensional">
<h3>Multidimensional arrays</h3>
Multidimensional arrays can be described as "arrays of arrays". For example, a bidimensional array can be imagined as a two-dimensional table made of elements, all of them of a same uniform data type.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/bidimensional_arrays1.png" alt="">
  <br>
<code>jimmy</code> represents a bidimensional array of 3 per 5 elements of type <code>int</code>. The C++ syntax for this is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> jimmy [3][5];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
and, for example, the way to reference the second element vertically and fourth horizontally in an expression would be: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>jimmy[1][3]</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/bidimensional_arrays2.png" alt="">
  <br>
(remember that array indices always begin with zero).<br>
<br>
Multidimensional arrays are not limited to two indices (i.e., two dimensions). They can contain as many indices as needed. Although be careful: the amount of memory needed for an array increases exponentially with each dimension. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>char</var> century [100][365][24][60][60];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
declares an array with an element of type <code>char</code> for each second in a century. This amounts to more than 3 billion <code>char</code>! So this declaration would consume more than 3 gigabytes of memory!<br>
<br>
At the end, multidimensional arrays are just an abstraction for programmers, since the same results can be achieved with a simple array, by multiplying its indices:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> jimmy [3][5];   <cite>// is equivalent to</cite>
<var>int</var> jimmy [15];     <cite>// (3 * 5 = 15)  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
With the only difference that with multidimensional arrays, the compiler automatically remembers the depth of each imaginary dimension. The following two pieces of code produce the exact same result, but one uses a bidimensional array while the other uses a simple array: <br>
<br>
<table class="boxed">
<tr><th>multidimensional array</th><th>pseudo-multidimensional array</th></tr>
<tr><td><code><pre >#define WIDTH 5
#define HEIGHT 3

int jimmy [HEIGHT][WIDTH];
int n,m;

int main ()
{
  for (n=0; n&lt;HEIGHT; n++)
    for (m=0; m&lt;WIDTH; m++)
    {
      jimmy[n][m]=(n+1)*(m+1);
    }
}</pre></code></td>
<td><code><pre >#define WIDTH 5
#define HEIGHT 3

int jimmy [HEIGHT * WIDTH];
int n,m;

int main ()
{
  for (n=0; n&lt;HEIGHT; n++)
    for (m=0; m&lt;WIDTH; m++)
    {
      jimmy[n*WIDTH+m]=(n+1)*(m+1);
    }
}</pre></code></td></tr>
</table>
<br>
None of the two code snippets above produce any output on the screen, but both assign values to the memory block called jimmy in the following way: <br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/arrays/bidimensional_arrays3.png" alt="">
 <br>
Note that the code uses defined constants for the width and height, instead of using directly their numerical values. This gives the code a better readability, and allows changes in the code to be made easily in one place.<br>
</section>
<br>
<section id="arrayparameters">
<h3>Arrays as parameters</h3>
At some point, we may need to pass an array to a function as a parameter. In C++, it is not possible to pass the entire block of memory represented by an array to a function directly as an argument. But what can be passed instead is its address. In practice, this has almost the same effect, and it is a much faster and more efficient operation.<br>
<br>
To accept an array as parameter for a function, the parameters can be declared as the array type, but with empty brackets, omitting the actual size of the array. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> procedure (<var>int</var> arg[])</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This function accepts a parameter of type "array of <code>int</code>" called <code>arg</code>. In order to pass to this function an array declared as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> myarray [40];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
it would be enough to write a call like this:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>procedure (myarray);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here you have a complete example: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// arrays as parameters</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> printarray (<var>int</var> arg[], <var>int</var> length) {
  <var>for</var> (<var>int</var> n=0; n&lt;length; ++n)
    cout &lt;&lt; arg[n] &lt;&lt; <kbd>' '</kbd>;
  cout &lt;&lt; <kbd>'\n'</kbd>;
}

<var>int</var> main ()
{
  <var>int</var> firstarray[] = {5, 10, 15};
  <var>int</var> secondarray[] = {2, 4, 6, 8, 10};
  printarray (firstarray,3);
  printarray (secondarray,5);
}</code></pre></td>
<td class="output"><pre><samp>5 10 15
2 4 6 8 10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the code above, the first parameter (<code>int arg[]</code>) accepts any array whose elements are of type <code>int</code>, whatever its length. For that reason, we have included a second parameter that tells the function the length of each array that we pass to it as its first parameter. This allows the for loop that prints out the array to know the range to iterate in the array passed, without going out of range.<br>
<br>
In a function declaration, it is also possible to include multidimensional arrays. The format for a tridimensional array parameter is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>base_type[][depth][depth]</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
For example, a function with a multidimensional array as argument could be: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> procedure (<var>int</var> myarray[][3][4])</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that the first brackets <code>[]</code> are left empty, while the following ones specify sizes for their respective dimensions. This is necessary in order for the compiler to be able to determine the depth of each additional dimension.<br>
<br>
In a way, passing an array as argument always loses a dimension. The reason behind is that, for historical reasons, arrays cannot be directly copied, and thus what is really passed is a pointer. This is a common source of errors for novice programmers. Although a clear understanding of pointers, explained in a coming chapter, helps a lot.<br>
</section>
<br>
<section id="libraryarrays">
<h3>Library arrays</h3>
The arrays explained above are directly implemented as a language feature, inherited from the C language. They are a great feature, but by restricting its copy and easily decay into pointers, they probably suffer from an excess of optimization.<br>
<br>
To overcome some of these issues with language built-in arrays, C++ provides an alternative array type as a standard container. It is a type template (a class template, in fact) defined in header <code><a href="/&lt;array&gt;">&lt;array&gt;</a></code>.<br>
<br>
Containers are a library feature that falls out of the scope of this tutorial, and thus the class will not be explained in detail here. Suffice it to say that they operate in a similar way to built-in arrays, except that they allow being copied (an actually expensive operation that copies the entire block of memory, and thus to use with care) and decay into pointers only when explicitly told to do so (by means of its member <code>data</code>).<br>
<br>
Just as an example, these are two versions of the same example using the language built-in array described in this chapter, and the container in the library:<br>
<br>
<table class="boxed"><tr><th>language built-in array</th><th>container library array</th></tr>
<tr><td><code><pre >#include &lt;iostream&gt;

using namespace std;

int main()
{
  int myarray[3] = {10,20,30};

  for (int i=0; i&lt;3; ++i)
    ++myarray[i];

  for (int elem : myarray)
    cout &lt;&lt; elem &lt;&lt; '\n';
}</pre></code></td>
<td><code><pre >#include &lt;iostream&gt;
#include &lt;array&gt;
using namespace std;

int main()
{
  array&lt;int,3&gt; myarray {10,20,30};

  for (int i=0; i&lt;myarray.size(); ++i)
    ++myarray[i];

  for (int elem : myarray)
    cout &lt;&lt; elem &lt;&lt; '\n';
}
</pre></code></td></tr>
</table>
<br>
As you can see, both kinds of arrays use the same syntax to access its elements: <code>myarray[i]</code>. Other than that, the main differences lay on the declaration of the array, and the inclusion of an additional header for the <i>library array</i>. Notice also how it is easy to access the size of the <i>library array</i>.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/namespaces/" rel="prev">Previous:<br><b>Name visibility</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/ntcs/" rel="next">Next:<br><b>Character sequences</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Character sequences</h2>
<section id="intro">
The <code>string</code> class has been briefly introduced in an earlier chapter. It is a very powerful class to handle and manipulate strings of characters. However, because strings are, in fact, sequences of characters, we can represent them also as plain arrays of elements of a character type.<br>
<br>
For example, the following array:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>char</var> foo [20];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
is an array that can store up to 20 elements of type <code>char</code>. It can be represented as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/ntcs/c_strings1.png" alt="">
  <br>
Therefore, this array has a capacity to store sequences of up to 20 characters. But this capacity does not need to be fully exhausted: the array can also accommodate shorter sequences. For example, at some point in a program, either the sequence <code>"Hello"</code> or the sequence <code>"Merry Christmas"</code> can be stored in <code>foo</code>, since both would fit in a sequence with a capacity for 20 characters.<br>
<br>
By convention, the end of strings represented in character sequences is signaled by a special character: the <i>null character</i>, whose literal value can be written as <code>'\0'</code> (backslash, zero).<br>
<br>
In this case, the array of 20 elements of type <code>char</code> called <code>foo</Code> can be represented storing the character sequences <code>"Hello"</code> and <code>"Merry Christmas"</code> as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/ntcs/c_strings2.png" alt="">
<br>
Notice how after the content of the string itself, a null character (<code>'\0'</code>) has been added in order to indicate the end of the sequence. The panels in gray color represent <code>char</code> elements with undetermined values.<br>
</section>
<br>
<section id="initialization">
<h3>Initialization of null-terminated character sequences</h3>
Because arrays of characters are ordinary arrays, they follow the same rules as these. For example, to initialize an array of characters with some predetermined sequence of characters, we can do it just like any other array: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>char</var> myword[] = { <kbd>'H'</kbd>, <kbd>'e'</kbd>, <kbd>'l'</kbd>, <kbd>'l'</kbd>, <kbd>'o'</kbd>, <kbd>'\0'</kbd> }; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The above declares an array of 6 elements of type <code>char</code> initialized with the characters that form the word <code>"Hello"</code> plus a <i>null character</i> <code>'\0'</code> at the end.<br>
<br>
But arrays of character elements have another way to be initialized: using <i>string literals</i> directly.<br>
<br>
In the expressions used in some examples in previous chapters, string literals have already shown up several times. These are specified by enclosing the text between double quotes (<code>"</code>). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><kbd>"the result is: "</kbd></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is a <i>string literal</i>, probably used in some earlier example.<br>
<br>
Sequences of characters enclosed in double-quotes (<code>"</code>) are <i>literal constants</i>. And their type is, in fact, a null-terminated array of characters. This means that string literals always have a null character (<code>'\0'</code>) automatically appended at the end.<br>
<br>
Therefore, the array of char elements called <code>myword</code> can be initialized with a null-terminated sequence of characters by either one of these two statements:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>char</var> myword[] = { <kbd>'H'</kbd>, <kbd>'e'</kbd>, <kbd>'l'</kbd>, <kbd>'l'</kbd>, <kbd>'o'</kbd>, <kbd>'\0'</kbd> };
<var>char</var> myword[] = <kbd>"Hello"</kbd>; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In both cases, the array of characters <code>myword</code> is declared with a size of 6 elements of type <code>char</code>: the 5 characters that compose the word <code>"Hello"</code>, plus a final null character (<code>'\0'</code>), which specifies the end of the sequence and that, in the second case, when using double quotes (<code>"</code>) it is appended automatically.<br>
<br>
Please notice that here we are talking about initializing an array of characters at the moment it is being declared, and not about assigning values to them later (once they have already been declared). In fact, because string literals are regular arrays, they have the same restrictions as these, and cannot be assigned values.<br>
<br>
Expressions (once myword has already been declared as above), such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>myword = <kbd>"Bye"</kbd>;
myword[] = <kbd>"Bye"</kbd>; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
would <strong>not</strong> be valid, like neither would be:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>myword = { <kbd>'B'</kbd>, <kbd>'y'</kbd>, <kbd>'e'</kbd>, <kbd>'\0'</kbd> };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is because arrays cannot be assigned values. Note, though, that each of its elements can be assigned a value individually. For example, this would be correct:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>myword[0] = <kbd>'B'</kbd>;
myword[1] = <kbd>'y'</kbd>;
myword[2] = <kbd>'e'</kbd>;
myword[3] = <kbd>'\0'</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="converting">
<h3>Strings and null-terminated character sequences</h3>
Plain arrays with null-terminated sequences of characters are the typical types used in the C language to represent strings (that is why they are also known as <i>C-strings</i>). In C++, even though the standard library defines a specific type for strings (class <code><a href="/string">string</a></code>), still, plain arrays with null-terminated sequences of characters (C-strings) are a natural way of representing strings in the language; in fact, string literals still always produce null-terminated character sequences, and not <code>string</code> objects.<br>
<br>
In the standard library, both representations for strings (C-strings and library strings) coexist, and most functions requiring strings are overloaded to support both.<br>
<br>
For example, <code>cin</code> and <code>cout</code> support null-terminated sequences directly, allowing them to be directly extracted from <code>cin</code> or inserted into <code>cout</code>, just like strings. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br></code></pre></td>
<td class="source"><pre><code><cite>// strings and NTCS:</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>char</var> question1[] = <kbd>"What is your name? "</kbd>;
  string question2 = <kbd>"Where do you live? "</kbd>;
  <var>char</var> answer1 [80];
  string answer2;
  cout &lt;&lt; question1;
  cin &gt;&gt; answer1;
  cout &lt;&lt; question2;
  cin &gt;&gt; answer2;
  cout &lt;&lt; <kbd>"Hello, "</kbd> &lt;&lt; answer1;
  cout &lt;&lt; <kbd>" from "</kbd> &lt;&lt; answer2 &lt;&lt; <kbd>"!\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>What is your name? Homer
Where do you live? Greece
Hello, Homer from Greece!</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, both arrays of characters using null-terminated sequences and strings are used. They are quite interchangeable in their use together with <code>cin</code> and <code>cout</code>, but there is a notable difference in their declarations: arrays have a fixed size that needs to be specified either implicit or explicitly when declared; <code>question1</code> has a size of exactly 20 characters (including the terminating null-characters) and <code>answer1</code> has a size of 80 characters; while strings are simply strings, no size is specified. This is due to the fact that strings have a dynamic size determined during runtime, while the size of arrays is determined on compilation, before the program runs.<br>
<br>
In any case, null-terminated character sequences and strings are easily transformed from one another:<br>
<br>
Null-terminated character sequences can be transformed into strings implicitly, and strings can be transformed into null-terminated character sequences by using either of <code>string</Code>'s member functions <code>c_str</code> or <code>data</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>char</var> myntcs[] = <kbd>"some text"</kbd>;
string mystring = myntcs;  <cite>// convert c-string to string</cite>
cout &lt;&lt; mystring;          <cite>// printed as a library string</cite>
cout &lt;&lt; mystring.c_str();  <cite>// printed as a c-string </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
(note: both <code>c_str</code> and <code>data</code> members of <code>string</code> are equivalent)<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/arrays/" rel="prev">Previous:<br><b>Arrays</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/pointers/" rel="next">Next:<br><b>Pointers</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Pointers</h2>
<section id="description">
In earlier chapters, variables have been explained as locations in the computer's memory which can be accessed by their identifier (their name). This way, the program does not need to care about the physical address of the data in memory; it simply uses the identifier whenever it needs to refer to the variable.<br>
<br>
For a C++ program, the memory of a computer is like a succession of memory cells, each one byte in size, and each with a unique address. These single-byte memory cells are ordered in a way that allows data representations larger than one byte to occupy memory cells that have consecutive addresses.<br>
<br>
This way, each cell can be easily located in the memory by means of its unique address. For example, the memory cell with the address <code>1776</code> always follows immediately after the cell with address <code>1775</code> and precedes the one with <code>1777</code>, and is exactly one thousand cells after <code>776</code> and exactly one thousand cells before <code>2776</code>.<br>
<br>
When a variable is declared, the memory needed to store its value is assigned a specific location in memory (its memory address). Generally, C++ programs do not actively decide the exact memory addresses where its variables are stored. Fortunately, that task is left to the environment where the program is run - generally, an operating system that decides the particular memory locations on runtime. However, it may be useful for a program to be able to obtain the address of a variable during runtime in order to access data cells that are at a certain position relative to it.<br>
</section>
<br>
<section id="reference">
<h3>Address-of operator (&)</h3>
The address of a variable can be obtained by preceding the name of a variable with an ampersand sign (<code>&</code>), known as <i>address-of operator</i>. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>foo = &amp;myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would assign the address of variable <code>myvar</code> to <code>foo</code>; by preceding the name of the variable <code>myvar</code> with the <i>address-of operator</i> (<code>&</code>), we are no longer assigning the content of the variable itself to <code>foo</code>, but its address.<br>
<br>
The actual address of a variable in memory cannot be known before runtime, but let's assume, in order to help clarify some concepts, that <code>myvar</code> is placed during runtime in the memory address <code>1776</code>.<br>
 <br>
In this case, consider the following code fragment:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>myvar = 25;
foo = &amp;myvar;
bar = myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The values contained in each variable after the execution of this are shown in the following diagram: <br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/pointers/reference_operator.png" alt=""> <br>
<br>
First, we have assigned the value <code>25</code> to <code>myvar</code> (a variable whose address in memory we assumed to be <code>1776</code>).<br>
<br>
The second statement assigns <code>foo</code> the address of <code>myvar</code>, which we have assumed to be <code>1776</code>.<br>
<br>
Finally, the third statement, assigns the value contained in <code>myvar</code> to <code>bar</code>. This is a standard assignment operation, as already done many times in earlier chapters.<br>
<br>
The main difference between the second and third statements is the appearance of the <i>address-of operator</i> (<code>&</code>).<br>
<br>
The variable that stores the address of another variable (like <code>foo</code> in the previous example) is what in C++ is called a <i>pointer</i>. Pointers are a very powerful feature of the language that has many uses in lower level programming. A bit later, we will see how to declare and use pointers.<br>
</section>
<br>
<section id="dereference">
<h3>Dereference operator (*)</h3>
As just seen, a variable which stores the address of another variable is called a <i>pointer</i>. Pointers are said to "point to" the variable whose address they store.<br>
<br>
An interesting property of pointers is that they can be used to access the variable they point to directly. This is done by preceding the pointer name with the <i>dereference operator</i> (<code>*</code>). The operator itself can be read as "value pointed to by".<br>
<br>
Therefore, following with the values of the previous example, the following statement: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>baz = *foo;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This could be read as: "<code>baz</code> equal to value pointed to by <code>foo</code>", and the statement would actually assign the value <code>25</code> to <code>baz</code>, since <code>foo</code> is <code>1776</code>, and the value pointed to by <code>1776</code> (following the example above) would be <code>25</code>.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/pointers/dereference_operator.png" alt="">
<br>
It is important to clearly differentiate that <code>foo</code> refers to the value <code>1776</code>, while <code>*foo</code> (with an asterisk <code>*</code> preceding the identifier) refers to the value stored at address <code>1776</code>, which in this case is <code>25</code>. Notice the difference of including or not including the <i>dereference operator</i> (I have added an explanatory comment of how each of these two expressions could be read): <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>baz = foo;   <cite>// baz equal to foo (1776)</cite>
baz = *foo;  <cite>// baz equal to value pointed to by foo (25)  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The reference and dereference operators are thus complementary:<br>
<ul>
<li><code>&</code> is the <i>address-of operator</i>, and can be read simply as "address of"</li>
<li><code>*</code> is the <i>dereference operator</i>, and can be read as "value pointed to by"</li>
</ul>
<br>
Thus, they have sort of opposite meanings: An address obtained with <code>&</code> can be dereferenced with <code>*</code>.<br>
<br>
Earlier, we performed the following two assignment operations:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>myvar = 25;
foo = &amp;myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Right after these two statements, all of the following expressions would give true as result:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>myvar == 25
&amp;myvar == 1776
foo == 1776
*foo == 25</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first expression is quite clear, considering that the assignment operation performed on <code>myvar</code> was <code>myvar=25</code>. The second one uses the address-of operator (<code>&</code>), which returns the address of <code>myvar</code>, which we assumed it to have a value of <code>1776</code>. The third one is somewhat obvious, since the second expression was true and the assignment operation performed on <code>foo</code> was <code>foo=&myvar</code>. The fourth expression uses the <i>dereference operator</i> (<code>*</code>) that can be read as "value pointed to by", and the value pointed to by <code>foo</code> is indeed <code>25</code>.<br>
<br>
So, after all that, you may also infer that for as long as the address pointed to by <code>foo</code> remains unchanged, the following expression will also be true: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>*foo == myvar</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="declaration">
<h3>Declaring pointers</h3>
Due to the ability of a pointer to directly refer to the value that it points to, a pointer has different properties when it points to a <code>char</code> than when it points to an <code>int</code> or a <code>float</code>. Once dereferenced, the type needs to be known. And for that, the declaration of a pointer needs to include the data type the pointer is going to point to.<br>
<br>
The declaration of pointers follows this syntax:<br>
<br>
<code>type * name;</code> <br>
<br>
where <code>type</code> is the data type pointed to by the pointer. This type is not the type of the pointer itself, but the type of the data the pointer points to. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> * number;
<var>char</var> * character;
<var>double</var> * decimals;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These are three declarations of pointers. Each one is intended to point to a different data type, but, in fact, all of them are pointers and all of them are likely going to occupy the same amount of space in memory (the size in memory of a pointer depends on the platform where the program runs). Nevertheless, the data to which they point to do not occupy the same amount of space nor are of the same type: the first one points to an <code>int</code>, the second one to a <code>char</code>, and the last one to a <code>double</code>. Therefore, although these three example variables are all of them pointers, they actually have different types: <code>int*</code>, <code>char*</code>, and <code>double*</code> respectively, depending on the type they point to.<br>
<br>
Note that the asterisk (<code>*</code>) used when declaring a pointer only means that it is a pointer (it is part of its type compound specifier), and should not be confused with the <i>dereference operator</i> seen a bit earlier, but which is also written with an asterisk (<code>*</code>). They are simply two different things represented with the same sign.<br>
<br>
Let's see an example on pointers:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// my first pointer</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> firstvalue, secondvalue;
  <var>int</var> * mypointer;

  mypointer = &amp;firstvalue;
  *mypointer = 10;
  mypointer = &amp;secondvalue;
  *mypointer = 20;
  cout &lt;&lt; <kbd>"firstvalue is "</kbd> &lt;&lt; firstvalue &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"secondvalue is "</kbd> &lt;&lt; secondvalue &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>firstvalue is 10
secondvalue is 20</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that even though neither <code>firstvalue</code> nor <code>secondvalue</code> are directly set any value in the program, both end up with a value set indirectly through the use of <code>mypointer</code>. This is how it happens:<br>
<br>
First, <code>mypointer</code> is assigned the address of firstvalue using the address-of operator (<code>&</code>). Then, the value pointed to by <code>mypointer</code> is assigned a value of <code>10</code>. Because, at this moment, <code>mypointer</code> is pointing to the memory location of <code>firstvalue</code>, this in fact modifies the value of <code>firstvalue</code>.<br>
<br>
In order to demonstrate that a pointer may point to different variables during its lifetime in a program, the example repeats the process with <code>secondvalue</code> and that same pointer, <code>mypointer</code>.<br>
<br>
Here is an example a little bit more elaborated:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// more pointers</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> firstvalue = 5, secondvalue = 15;
  <var>int</var> * p1, * p2;

  p1 = &amp;firstvalue;  <cite>// p1 = address of firstvalue</cite>
  p2 = &amp;secondvalue; <cite>// p2 = address of secondvalue</cite>
  *p1 = 10;          <cite>// value pointed to by p1 = 10</cite>
  *p2 = *p1;         <cite>// value pointed to by p2 = value pointed to by p1</cite>
  p1 = p2;           <cite>// p1 = p2 (value of pointer is copied)</cite>
  *p1 = 20;          <cite>// value pointed to by p1 = 20</cite>
  
  cout &lt;&lt; <kbd>"firstvalue is "</kbd> &lt;&lt; firstvalue &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"secondvalue is "</kbd> &lt;&lt; secondvalue &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>firstvalue is 10
secondvalue is 20</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Each assignment operation includes a comment on how each line could be read: i.e., replacing ampersands (<code>&</code>) by "address of", and asterisks (<code>*</code>) by "value pointed to by".<br>
<br>
Notice that there are expressions with pointers <code>p1</code> and <code>p2</code>, both with and without the <i>dereference operator</i> (<code>*</code>). The meaning of an expression using the <i>dereference operator</i> (*) is very different from one that does not. When this operator precedes the pointer name, the expression refers to the value being pointed, while when a pointer name appears without this operator, it refers to the value of the pointer itself (i.e., the address of what the pointer is pointing to).<br>
<br>
Another thing that may call your attention is the line: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> * p1, * p2;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares the two pointers used in the previous example. But notice that there is an asterisk (<code>*</code>) for each pointer, in order for both to have type <code>int*</code> (pointer to <code>int</code>). This is required due to the precedence rules. Note that if, instead, the code was:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> * p1, p2;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>p1</code> would indeed be of type <code>int*</code>, but <code>p2</code> would be of type <code>int</code>. Spaces do not matter at all for this purpose. But anyway, simply remembering to put one asterisk per pointer is enough for most pointer users interested in declaring multiple pointers per statement. Or even better: use a different statement for each variable.<br>
</section>
<br>
<section id="arrays">
<h3>Pointers and arrays</h3>
The concept of arrays is related to that of pointers. In fact, arrays work very much like pointers to their first elements, and, actually, an array can always be implicitly converted to the pointer of the proper type. For example, consider these two declarations:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myarray [20];
<var>int</var> * mypointer;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The following assignment operation would be valid: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mypointer = myarray;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
After that, <code>mypointer</code> and <code>myarray</code> would be equivalent and would have very similar properties. The main difference being that <code>mypointer</code> can be assigned a different address, whereas <code>myarray</code> can never be assigned anything, and will always represent the same block of 20 elements of type <code>int</code>. Therefore, the following assignment would not be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>myarray = mypointer;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Let's see an example that mixes arrays and pointers:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// more pointers</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> numbers[5];
  <var>int</var> * p;
  p = numbers;  *p = 10;
  p++;  *p = 20;
  p = &amp;numbers[2];  *p = 30;
  p = numbers + 3;  *p = 40;
  p = numbers;  *(p+4) = 50;
  <var>for</var> (<var>int</var> n=0; n&lt;5; n++)
    cout &lt;&lt; numbers[n] &lt;&lt; <kbd>", "</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>10, 20, 30, 40, 50, </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Pointers and arrays support the same set of operations, with the same meaning for both. The main difference being that pointers can be assigned new addresses, while arrays cannot.<br>
<br>
In the chapter about arrays, brackets (<code>[]</code>) were explained as specifying the index of an element of the array. Well, in fact these brackets are a dereferencing operator known as <i>offset operator</i>. They dereference the variable they follow just as <code>*</code> does, but they also add the number between brackets to the address being dereferenced. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>a[5] = 0;       <cite>// a [offset of 5] = 0</cite>
*(a+5) = 0;     <cite>// pointed to by (a+5) = 0  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These two expressions are equivalent and valid, not only if <code>a</code> is a pointer, but also if <code>a</code> is an array. Remember that if an array, its name can be used just like a pointer to its first element.<br>
</section>
<br>
<section id="initialization">
<h3>Pointer initialization</h3>
Pointers can be initialized to point to specific locations at the very moment they are defined:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myvar;
<var>int</var> * myptr = &amp;myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The resulting state of variables after this code is the same as after:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myvar;
<var>int</var> * myptr;
myptr = &amp;myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
When pointers are initialized, what is initialized is the address they point to (i.e., <code>myptr</code>), never the value being pointed (i.e., <code>*myptr</code>). Therefore, the code above shall not be confused with: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myvar;
<var>int</var> * myptr;
*myptr = &amp;myvar;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Which anyway would not make much sense (and is not valid code).<br>
<br>
The asterisk (<code>*</code>) in the pointer declaration (line 2) only indicates that it is a pointer, it is not the dereference operator (as in line 3). Both things just happen to use the same sign: <code>*</code>. As always, spaces are not relevant, and never change the meaning of an expression.<br>
<br>
Pointers can be initialized either to the address of a variable (such as in the case above), or to the value of another pointer (or array):<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myvar;
<var>int</var> *foo = &amp;myvar;
<var>int</var> *bar = foo;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="arithmetics">
<h3>Pointer arithmetics</h3>
To conduct arithmetical operations on pointers is a little different than to conduct them on regular integer types. To begin with, only addition and subtraction operations are allowed; the others make no sense in the world of pointers. But both addition and subtraction have a slightly different behavior with pointers, according to the size of the data type to which they point.<br>
<br>
When fundamental data types were introduced, we saw that types have different sizes. For example: <code>char</code> always has a size of 1 byte, <code>short</code> is generally larger than that, and <code>int</code> and <code>long</code> are even larger; the exact size of these being dependent on the system. For example, let's imagine that in a given system, <code>char</code> takes 1 byte, <code>short</code> takes 2 bytes, and <code>long</code> takes 4.<br>
<br>
Suppose now that we define three pointers in this compiler: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>char</var> *mychar;
<var>short</var> *myshort;
<var>long</var> *mylong;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
and that we know that they point to the memory locations <code>1000</code>, <code>2000</code>, and <code>3000</code>, respectively. <br>
<br>
Therefore, if we write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>++mychar;
++myshort;
++mylong;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>mychar</code>, as one would expect, would contain the value 1001. But not so obviously, <code>myshort</code> would contain the value 2002, and <code>mylong</code> would contain 3004, even though they have each been incremented only once. The reason is that, when adding one to a pointer, the pointer is made to point to the following element of the same type, and, therefore, the size in bytes of the type it points to is added to the pointer.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/pointers/pointer_arithmetics.png" alt="">
<br>
This is applicable both when adding and subtracting any number to a pointer. It would happen exactly the same if we wrote: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>mychar = mychar + 1;
myshort = myshort + 1;
mylong = mylong + 1;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Regarding the increment (<code>++</code>) and decrement (<code>--</code>) operators, they both can be used as either prefix or suffix of an expression, with a slight difference in behavior: as a prefix, the increment happens before the expression is evaluated, and as a suffix, the increment happens after the expression is evaluated. This also applies to expressions incrementing and decrementing pointers, which can become part of more complicated expressions that also include dereference operators (<code>*</code>). Remembering operator precedence rules, we can recall that postfix operators, such as increment and decrement, have higher precedence than prefix operators, such as the dereference operator (<code>*</code>). Therefore, the following expression:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>*p++</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
is equivalent to <code>*(p++)</code>. And what it does is to increase the value of <code>p</code> (so it now points to the next element), but because <code>++</code> is used as postfix, the whole expression is evaluated as the value pointed originally by the pointer (the address it pointed to before being incremented).<br>
<br>
Essentially, these are the four possible combinations of the dereference operator with both the prefix and suffix versions of the increment operator (the same being applicable also to the decrement operator):<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>*p++   <cite>// same as *(p++): increment pointer, and dereference unincremented address</cite>
*++p   <cite>// same as *(++p): increment pointer, and dereference incremented address</cite>
++*p   <cite>// same as ++(*p): dereference pointer, and increment the value it points to</cite>
(*p)++ <cite>// dereference pointer, and post-increment the value it points to </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
A typical -but not so simple- statement involving these operators is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>*p++ = *q++;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Because <code>++</code> has a higher precedence than <code>*</code>, both <code>p</code> and <code>q</code> are incremented, but because both increment operators (<code>++</code>) are used as postfix and not prefix, the value assigned to <code>*p</code> is <code>*q</code> before both <code>p</code> and <code>q</code> are incremented. And then both are incremented. It would be roughly equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>*p = *q;
++p;
++q;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Like always, parentheses reduce confusion by adding legibility to expressions.<br>
</section>
<br>
<section id="const">
<h3>Pointers and const</h3>
Pointers can be used to access a variable by its address, and this access may include modifying the value pointed. But it is also possible to declare pointers that can access the pointed value to read it, but not to modify it. For this, it is enough with qualifying the type pointed to by the pointer as <code>const</code>. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>int</var> x;
<var>int</var> y = 10;
<var>const</var> <var>int</var> * p = &amp;y;
x = *p;          <cite>// ok: reading p</cite>
*p = x;          <cite>// error: modifying p, which is const-qualified </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here <code>p</code> points to a variable, but points to it in a <code>const</code>-qualified manner, meaning that it can read the value pointed, but it cannot modify it. Note also, that the expression <code>&y</code> is of type <code>int*</code>, but this is assigned to a pointer of type <code>const int*</code>. This is allowed: a pointer to non-const can be implicitly converted to a pointer to const. But not the other way around! As a safety feature, pointers to <code>const</code> are not implicitly convertible to pointers to non-<code>const</code>.<br>
<br>
One of the use cases of pointers to <code>const</code> elements is as function parameters: a function that takes a pointer to non-<code>const</code> as parameter can modify the value passed as argument, while a function that takes a pointer to <code>const</code> as parameter cannot.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><cite>// pointers as arguments:</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> increment_all (<var>int</var>* start, <var>int</var>* stop)
{
  <var>int</var> * current = start;
  <var>while</var> (current != stop) {
    ++(*current);  <cite>// increment value pointed</cite>
    ++current;     <cite>// increment pointer</cite>
  }
}

<var>void</var> print_all (<var>const</var> <var>int</var>* start, <var>const</var> <var>int</var>* stop)
{
  <var>const</var> <var>int</var> * current = start;
  <var>while</var> (current != stop) {
    cout &lt;&lt; *current &lt;&lt; <kbd>'\n'</kbd>;
    ++current;     <cite>// increment pointer</cite>
  }
}

<var>int</var> main ()
{
  <var>int</var> numbers[] = {10,20,30};
  increment_all (numbers,numbers+3);
  print_all (numbers,numbers+3);
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>11
21
31</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that <code>print_all</code> uses pointers that point to constant elements. These pointers point to constant content they cannot modify, but they are not constant themselves: i.e., the pointers can still be incremented or assigned different addresses, although they cannot modify the content they point to.<br>
<br>
And this is where a second dimension to constness is added to pointers: Pointers can also be themselves const. And this is specified by appending const to the pointed type (after the asterisk):<br>
 <br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>int</var> x;
      <var>int</var> *       p1 = &amp;x;  <cite>// non-const pointer to non-const int</cite>
<var>const</var> <var>int</var> *       p2 = &amp;x;  <cite>// non-const pointer to const int</cite>
      <var>int</var> * <var>const</var> p3 = &amp;x;  <cite>// const pointer to non-const int</cite>
<var>const</var> <var>int</var> * <var>const</var> p4 = &amp;x;  <cite>// const pointer to const int </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The syntax with <code>const</code> and pointers is definitely tricky, and recognizing the cases that best suit each use tends to require some experience. In any case, it is important to get constness with pointers (and references) right sooner rather than later, but you should not worry too much about grasping everything if this is the first time you are exposed to the mix of <code>const</code> and pointers. More use cases will show up in coming chapters.<br>
<br>
To add a little bit more confusion to the syntax of <code>const</code> with pointers, the <code>const</code> qualifier can either precede or follow the pointed type, with the exact same meaning:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>const</var> <var>int</var> * p2a = &amp;x;  <cite>//      non-const pointer to const int</cite>
<var>int</var> <var>const</var> * p2b = &amp;x;  <cite>// also non-const pointer to const int </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
As with the spaces surrounding the asterisk, the order of const in this case is simply a matter of style. This chapter uses a prefix <code>const</code>, as for historical reasons this seems to be more extended, but both are exactly equivalent. The merits of each style are still intensely debated on the internet.<br>
</section>
<br>
<section id="stringliterals">
<h3>Pointers and string literals</h3>
As pointed earlier, <i>string literals</i> are arrays containing null-terminated character sequences. In earlier sections, string literals have been used to be directly inserted into <code>cout</code>, to initialize strings and to initialize arrays of characters.<br>
<br>
But they can also be accessed directly. String literals are arrays of the proper array type to contain all its characters plus the terminating null-character, with each of the elements being of type <code>const char</code> (as literals, they can never be modified). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>const</var> <var>char</var> * foo = <kbd>"hello"</kbd>; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares an array with the literal representation for <code>"hello"</code>, and then a pointer to its first element is assigned to <code>foo</code>. If we imagine that <code>"hello"</code> is stored at the memory locations that start at address 1702, we can represent the previous declaration as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/pointers/pointer_assignment.png" alt="">
  <br>
Note that here <code>foo</code> is a pointer and contains the value 1702, and not <code>'h'</code>, nor <code>"hello"</code>, although 1702 indeed is the address of both of these.<br>
<br>
The pointer <code>foo</code> points to a sequence of characters. And because pointers and arrays behave essentially in the same way in expressions, <code>foo</code> can be used to access the characters in the same way arrays of null-terminated character sequences are. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>*(foo+4)
foo[4]</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both expressions have a value of <code>'o'</code> (the fifth element of the array).<br>
</section>
<br>
<section id="pointerstopointers">
<h3>Pointers to pointers</h3>
C++ allows the use of pointers that point to pointers, that these, in its turn, point to data (or even to other pointers). The syntax simply requires an asterisk (<code>*</code>) for each level of indirection in the declaration of the pointer:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>char</var> a;
<var>char</var> * b;
<var>char</var> ** c;
a = <kbd>'z'</kbd>;
b = &amp;a;
c = &amp;b;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This, assuming the randomly chosen memory locations for each variable of <code>7230</code>, <code>8092</code>, and <code>10502</code>, could be represented as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/pointers/pointer_to_pointer.png" alt="">
  <br>
With the value of each variable represented inside its corresponding cell, and their respective addresses in memory represented by the value under them.<br>
 <br>
The new thing in this example is variable <code>c</code>, which is a pointer to a pointer, and can be used in three different levels of indirection, each one of them would correspond to a different value:<br>
<br>
<ul>
<li><code>c</code> is of type <code>char**</code> and a value of <code>8092</code></li>
<li><code>*c</code> is of type <code>char*</code> and a value of <code>7230</code></li>
<li><code>**c</code> is of type <code>char</code> and a value of <code>'z'</code></li>
</ul>
</section>
<br>
<section id="void">
<h3>void pointers</h3>
The <code>void</code> type of pointer is a special type of pointer. In C++, <code>void</code> represents the absence of type. Therefore, <code>void</code> pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereferencing properties).<br>
<br>
This gives <code>void</code> pointers a great flexibility, by being able to point to any data type, from an integer value or a float to a string of characters. In exchange, they have a great limitation: the data pointed to by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason, any address in a <code>void</code> pointer needs to be transformed into some other pointer type that points to a concrete data type before being dereferenced.<br>
<br>
One of its possible uses may be to pass generic parameters to a function. For example: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// increaser</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> increase (<var>void</var>* data, <var>int</var> psize)
{
  <var>if</var> ( psize == <var>sizeof</var>(<var>char</var>) )
  { <var>char</var>* pchar; pchar=(<var>char</var>*)data; ++(*pchar); }
  <var>else</var> <var>if</var> (psize == <var>sizeof</var>(<var>int</var>) )
  { <var>int</var>* pint; pint=(<var>int</var>*)data; ++(*pint); }
}

<var>int</var> main ()
{
  <var>char</var> a = <kbd>'x'</kbd>;
  <var>int</var> b = 1602;
  increase (&amp;a,<var>sizeof</var>(a));
  increase (&amp;b,<var>sizeof</var>(b));
  cout &lt;&lt; a &lt;&lt; <kbd>", "</kbd> &lt;&lt; b &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>y, 1603</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>sizeof</code> is an operator integrated in the C++ language that returns the size in bytes of its argument. For non-dynamic data types, this value is a constant. Therefore, for example, <code>sizeof(char)</code> is 1, because <code>char</code> has always a size of one byte. <br>
</section>
<br>
<section id="null">
<h3>Invalid pointers and null pointers</h3>
In principle, pointers are meant to point to valid addresses, such as the address of a variable or the address of an element in an array. But pointers can actually point to any address, including addresses that do not refer to any valid element. Typical examples of this are <i>uninitialized pointers</i> and pointers to nonexistent elements of an array:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>int</var> * p;               <cite>// uninitialized pointer (local variable)</cite>

<var>int</var> myarray[10];
<var>int</var> * q = myarray+20;  <cite>// element out of bounds </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Neither <code>p</code> nor <code>q</Code> point to addresses known to contain a value, but none of the above statements causes an error. In C++, pointers are allowed to take any address value, no matter whether there actually is something at that address or not. What can cause an error is to dereference such a pointer (i.e., actually accessing the value they point to). Accessing such a pointer causes undefined behavior, ranging from an error during runtime to accessing some random value.<br>
<br>
But, sometimes, a pointer really needs to explicitly point to nowhere, and not just an invalid address. For such cases, there exists a special value that any pointer type can take: the <i>null pointer value</i>. This value can be expressed in C++ in two ways: either with an integer value of zero, or with the <code>nullptr</code> keyword:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> * p = 0;
<var>int</var> * q = <var>nullptr</var>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, both <code>p</code> and <code>q</code> are <i>null pointers</i>, meaning that they explicitly point to nowhere, and they both actually compare equal: all <i>null pointers</i> compare equal to other <i>null pointers</i>. It is also quite usual to see the defined constant <code>NULL</code> be used in older code to refer to the <i>null pointer</i> value:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> * r = NULL;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>NULL</code> is defined in several headers of the standard library, and is defined as an alias of some <i>null pointer</i> constant value (such as <code>0</code> or <code>nullptr</code>).<br>
<br>
Do not confuse <i>null pointers</i> with <code>void</code> pointers! A <i>null pointer</i> is a value that any pointer can take to represent that it is pointing to "nowhere", while a <code>void</code> pointer is a type of pointer that can point to somewhere without a specific type. One refers to the value stored in the pointer, and the other to the type of data it points to.<br>
</section>
<br>
<section id="pointerstofunctions">
<h3>Pointers to functions</h3>
C++ allows operations with pointers to functions. The typical use of this is for passing a function as an argument to another function. Pointers to functions are declared with the same syntax as a regular function declaration, except that the name of the function is enclosed between parentheses () and an asterisk (<code>*</code>) is inserted before the name:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// pointer to functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> addition (<var>int</var> a, <var>int</var> b)
{ <var>return</var> (a+b); }

<var>int</var> subtraction (<var>int</var> a, <var>int</var> b)
{ <var>return</var> (a-b); }

<var>int</var> operation (<var>int</var> x, <var>int</var> y, <var>int</var> (*functocall)(<var>int</var>,<var>int</var>))
{
  <var>int</var> g;
  g = (*functocall)(x,y);
  <var>return</var> (g);
}

<var>int</var> main ()
{
  <var>int</var> m,n;
  <var>int</var> (*minus)(<var>int</var>,<var>int</var>) = subtraction;

  m = operation (7, 5, addition);
  n = operation (20, m, minus);
  cout &lt;&lt;n;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>8</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the example above, <code>minus</code> is a pointer to a function that has two parameters of type <code>int</code>. It is directly initialized to point to the function <code>subtraction</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> (* minus)(<var>int</var>,<var>int</var>) = subtraction;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/ntcs/" rel="prev">Previous:<br><b>Character sequences</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/dynamic/" rel="next">Next:<br><b>Dynamic memory</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Dynamic memory</h2>
<section id="intro">
In the programs seen in previous chapters, all memory needs were determined before program execution by defining the variables needed. But there may be cases where the memory needs of a program can only be determined during runtime. For example, when the memory needed depends on user input. On these cases, programs need to dynamically allocate memory, for which the C++ language integrates the operators <code>new</code> and <code>delete</code>.<br>
</section>
<br>
<section id="new">
<h3>Operators new and new[]</h3>
Dynamic memory is allocated using operator <code>new</code>. <code>new</code> is followed by a data type specifier and, if a sequence of more than one element is required, the number of these within brackets <code>[]</code>. It returns a pointer to the beginning of the new block of memory allocated. Its syntax is: <br>
<br>
<code>
pointer = new type<br>
pointer = new type [number_of_elements]<br>
</code>
<br>
The first expression is used to allocate memory to contain one single element of type <code>type</code>. The second one is used to allocate a block (an array) of elements of type <code>type</code>, where <code>number_of_elements</code> is an integer value representing the amount of these. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> * foo;
foo = <var>new</var> <var>int</var> [5];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the system dynamically allocates space for five elements of type <code>int</code> and returns a pointer to the first element of the sequence, which is assigned to <code>foo</code> (a pointer). Therefore, <code>foo</code> now points to a valid block of memory with space for five elements of type <code>int</code>.<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/dynamic/dynamic.png" alt="">  <br>
<br>
Here, <code>foo</code> is a pointer, and thus, the first element pointed to by <code>foo</code> can be accessed either with the expression <code>foo[0]</code> or the expression <code>*foo</code> (both are equivalent). The second element can be accessed either with <code>foo[1]</code> or <code>*(foo+1)</code>, and so on...<br>
<br>
There is a substantial difference between declaring a normal array and allocating dynamic memory for a block of memory using <code>new</code>. The most important difference is that the size of a regular array needs to be a <i>constant expression</i>, and thus its size has to be determined at the moment of designing the program, before it is run, whereas the dynamic memory allocation performed by <code>new</code> allows to assign memory during runtime using any variable value as size.<br>
<br>
The dynamic memory requested by our program is allocated by the system from the memory heap. However, computer memory is a limited resource, and it can be exhausted. Therefore, there are no guarantees that all requests to allocate memory using operator <code>new</code> are going to be granted by the system. <br>
<br>
C++ provides two standard mechanisms to check if the allocation was successful:<br>
<br>
One is by handling exceptions. Using this method, an exception of type <code>bad_alloc</code> is thrown when the allocation fails. Exceptions are a powerful C++ feature explained later in these tutorials. But for now, you should know that if this exception is thrown and it is not handled by a specific handler, the program execution is terminated.<br>
<br>
This exception method is the method used by default by <code>new</code>, and is the one used in a declaration like:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>foo = <var>new</var> <var>int</var> [5];  <cite>// if allocation fails, an exception is thrown  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The other method is known as <code>nothrow</code>, and what happens when it is used is that when a memory allocation fails, instead of throwing a <code>bad_alloc</code> exception or terminating the program, the pointer returned by <code>new</code> is a <i>null pointer</i>, and the program continues its execution normally.<br>
<br>
This method can be specified by using a special object called <code>nothrow</code>, declared in header <code><a href="/&lt;new&gt;">&lt;new&gt;</a></code>, as argument for <code>new</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>foo = <var>new</var> (nothrow) <var>int</var> [5]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, if the allocation of this block of memory fails, the failure can be detected by checking if <code>foo</code> is a null pointer:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>int</var> * foo;
foo = <var>new</var> (nothrow) <var>int</var> [5];
<var>if</var> (foo == <var>nullptr</var>) {
  <cite>// error assigning memory. Take measures.</cite>
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This <code>nothrow</code> method is likely to produce less efficient code than exceptions, since it implies explicitly checking the pointer value returned after each and every allocation. Therefore, the exception mechanism is generally preferred, at least for critical allocations. Still, most of the coming examples will use the <code>nothrow</code> mechanism due to its simplicity.<br>
</section>
<br>
<section id="delete">
<h3>Operators delete and delete[]</h3>
In most cases, memory allocated dynamically is only needed during specific periods of time within a program; once it is no longer needed, it can be freed so that the memory becomes available again for other requests of dynamic memory. This is the purpose of operator <code>delete</code>, whose syntax is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>delete</var> pointer;
<var>delete</var>[] pointer;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first statement releases the memory of a single element allocated using <code>new</code>, and the second one releases the memory allocated for arrays of elements using new and a size in brackets (<code>[]</code>).<br>
<br>
The value passed as argument to <code>delete</code> shall be either a pointer to a memory block previously allocated with <code>new</code>, or a <i>null pointer</i> (in the case of a <i>null pointer</i>, <code>delete</code> produces no effect).<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br></code></pre></td>
<td class="source"><pre><code><cite>// rememb-o-matic</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;new&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main ()
{
  <var>int</var> i,n;
  <var>int</var> * p;
  cout &lt;&lt; <kbd>"How many numbers would you like to type? "</kbd>;
  cin &gt;&gt; i;
  p= <var>new</var> (nothrow) <var>int</var>[i];
  <var>if</var> (p == <var>nullptr</var>)
    cout &lt;&lt; <kbd>"Error: memory could not be allocated"</kbd>;
  <var>else</var>
  {
    <var>for</var> (n=0; n&lt;i; n++)
    {
      cout &lt;&lt; <kbd>"Enter number: "</kbd>;
      cin &gt;&gt; p[n];
    }
    cout &lt;&lt; <kbd>"You have entered: "</kbd>;
    <var>for</var> (n=0; n&lt;i; n++)
      cout &lt;&lt; p[n] &lt;&lt; <kbd>", "</kbd>;
    <var>delete</var>[] p;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>How many numbers would you like to type? 5
Enter number : 75
Enter number : 436
Enter number : 1067
Enter number : 8
Enter number : 32
You have entered: 75, 436, 1067, 8, 32,</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how the value within brackets in the new statement is a variable value entered by the user (<code>i</code>), not a constant expression:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>p= <var>new</var> (nothrow) <var>int</var>[i];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
There always exists the possibility that the user introduces a value for <code>i</code> so big that the system cannot allocate enough memory for it. For example, when I tried to give a value of 1 billion to the "How many numbers" question, my system could not allocate that much memory for the program, and I got the text message we prepared for this case (<code>Error: memory could not be allocated</code>).<br>
 <br>
It is considered good practice for programs to always be able to handle failures to allocate memory, either by checking the pointer value (if <code>nothrow</code>) or by catching the proper exception.<br>
</section>
<br>
<section id="malloc">
<h3>Dynamic memory in C</h3>
C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory. But these were not available in the C language; instead, it used a library solution, with the functions <code><a href="/malloc">malloc</a></code>, <code><a href="/calloc">calloc</a></code>, <code><a href="/realloc">realloc</a></code> and <code><a href="/free">free</a></code>, defined in the header <code><a href="/&lt;cstdlib&gt;">&lt;cstdlib&gt;</a></code> (known as <code>&lt;stdlib.h&gt;</code> in C). The functions are also available in C++ and can also be used to allocate and deallocate dynamic memory.<br>
<br>
Note, though, that the memory blocks allocated by these functions are not necessarily compatible with those returned by <code>new</code>, so they should not be mixed; each one should be handled with its own set of functions or operators.<br>
</section> <br>
<table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/pointers/" rel="prev">Previous:<br><b>Pointers</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/structures/" rel="next">Next:<br><b>Data structures</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Data structures</h2>
<section id="data_structures">
<h3>Data structures</h3>
A <dfn>data structure</dfn> is a group of data elements grouped together under one name. These data elements, known as <i>members</i>, can have different types and different lengths. Data structures can be declared in C++ using the following syntax:<br>
<br>
<code>
struct type_name {<br>
member_type1 member_name1;<br>
member_type2 member_name2;<br>
member_type3 member_name3;<br>
.<br>
.<br>
} object_names;<br>
</code>
<br>
Where <code>type_name</code> is a name for the structure type, <code>object_name</code> can be a set of valid identifiers for objects that have the type of this structure. Within braces <code>{}</code>, there is a list with the data members, each one is specified with a type and a valid identifier as its name.<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>struct</var> product {
  <var>int</var> weight;
  <var>double</var> price;
} ;

product apple;
product banana, melon;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares a structure type, called <code>product</code>, and defines it having two members: <code>weight</code> and <code>price</code>, each of a different fundamental type. This declaration creates a new type (<code>product</code>), which is then used to declare three objects (variables) of this type: <code>apple</code>, <code>banana</code>, and <code>melon</code>. Note how once <code>product</code> is declared, it is used just like any other type.<br>
<br>
Right at the end of the <code>struct</code> definition, and before the ending semicolon (<code>;</code>), the optional field <code>object_names</code> can be used to directly declare objects of the structure type. For example, the structure objects <code>apple</code>, <code>banana</code>, and <code>melon</code> can be declared at the moment the data structure type is defined: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>struct</var> product {
  <var>int</var> weight;
  <var>double</var> price;
} apple, banana, melon;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, where <code>object_names</code> are specified, the type name (<code>product</code>) becomes optional: <code>struct</code> requires either a <code>type_name</Code> or at least one name in <code>object_names</code>, but not necessarily both.<br>
<br>
It is important to clearly differentiate between what is the structure type name (<code>product</code>), and what is an object of this type (<code>apple</code>, <code>banana</code>, and <code>melon</code>). Many objects (such as <code>apple</code>, <code>banana</code>, and <code>melon</code>) can be declared from a single structure type (<code>product</code>).<br>
<br>
Once the three objects of a determined structure type are declared (<code>apple</code>, <code>banana</code>, and <code>melon</code>) its members can be accessed directly. The syntax for that is simply to insert a dot (<code>.</code>) between the object name and the member name. For example, we could operate with any of these elements as if they were standard variables of their respective types: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>apple.weight
apple.price
banana.weight
banana.price
melon.weight
melon.price</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Each one of these has the data type corresponding to the member they refer to: <code>apple.weight</code>, <code>banana.weight</code>, and <code>melon.weight</code> are of type <code>int</code>, while <code>apple.price</code>, <code>banana.price</code>, and <code>melon.price</code> are of type <code>double</code>.<br>
<br>
Here is a real example with structure types in action:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br></code></pre></td>
<td class="source"><pre><code><cite>// example about structures</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>struct</var> movies_t {
  string title;
  <var>int</var> year;
} mine, yours;

<var>void</var> printmovie (movies_t movie);

<var>int</var> main ()
{
  string mystr;

  mine.title = <kbd>"2001 A Space Odyssey"</kbd>;
  mine.year = 1968;

  cout &lt;&lt; <kbd>"Enter title: "</kbd>;
  getline (cin,yours.title);
  cout &lt;&lt; <kbd>"Enter year: "</kbd>;
  getline (cin,mystr);
  stringstream(mystr) &gt;&gt; yours.year;

  cout &lt;&lt; <kbd>"My favorite movie is:\n "</kbd>;
  printmovie (mine);
  cout &lt;&lt; <kbd>"And yours is:\n "</kbd>;
  printmovie (yours);
  <var>return</var> 0;
}

<var>void</var> printmovie (movies_t movie)
{
  cout &lt;&lt; movie.title;
  cout &lt;&lt; <kbd>" ("</kbd> &lt;&lt; movie.year &lt;&lt; <kbd>")\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>Enter title: Alien
Enter year: 1979

My favorite movie is:
 2001 A Space Odyssey (1968)
And yours is:
 Alien (1979)</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The example shows how the members of an object act just as regular variables. For example, the member <code>yours.year</code> is a valid variable of type <code>int</code>, and <code>mine.title</code> is a valid variable of type <code>string</code>.<br>
<br>
But the objects <code>mine</code> and <code>yours</code> are also variables with a type (of type <code>movies_t</code>). For example, both have been passed to function <code>printmovie</code> just as if they were simple variables. Therefore, one of the features of data structures is the ability to refer to both their members individually or to the entire structure as a whole. In both cases using the same identifier: the name of the structure.<br>
<br>
Because structures are types, they can also be used as the type of arrays to construct tables or databases of them:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br></code></pre></td>
<td class="source"><pre><code><cite>// array of structures</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>struct</var> movies_t {
  string title;
  <var>int</var> year;
} films [3];

<var>void</var> printmovie (movies_t movie);

<var>int</var> main ()
{
  string mystr;
  <var>int</var> n;

  <var>for</var> (n=0; n&lt;3; n++)
  {
    cout &lt;&lt; <kbd>"Enter title: "</kbd>;
    getline (cin,films[n].title);
    cout &lt;&lt; <kbd>"Enter year: "</kbd>;
    getline (cin,mystr);
    stringstream(mystr) &gt;&gt; films[n].year;
  }

  cout &lt;&lt; <kbd>"\nYou have entered these movies:\n"</kbd>;
  <var>for</var> (n=0; n&lt;3; n++)
    printmovie (films[n]);
  <var>return</var> 0;
}

<var>void</var> printmovie (movies_t movie)
{
  cout &lt;&lt; movie.title;
  cout &lt;&lt; <kbd>" ("</kbd> &lt;&lt; movie.year &lt;&lt; <kbd>")\n"</kbd>;
}</code></pre></td>
<td class="output"><pre><samp>Enter title: Blade Runner
Enter year: 1982
Enter title: The Matrix
Enter year: 1999
Enter title: Taxi Driver
Enter year: 1976
 
You have entered these movies:
Blade Runner (1982)
The Matrix (1999)
Taxi Driver (1976)</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="pointers_to_structures">
<h3>Pointers to structures</h3>
Like any other type, structures can be pointed to by its own type of pointers:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><var>struct</var> movies_t {
  string title;
  <var>int</var> year;
};

movies_t amovie;
movies_t * pmovie;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here <code>amovie</code> is an object of structure type <code>movies_t</code>, and <code>pmovie</code> is a pointer to point to objects of structure type <code>movies_t</code>. Therefore, the following code would also be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>pmovie = &amp;amovie;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The value of the pointer <code>pmovie</code> would be assigned the address of object <code>amovie</code>.<br>
<br>
Now, let's see another example that mixes pointers and structures, and will serve to introduce a new operator: the arrow operator (<code>-&gt;</code>):<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br></code></pre></td>
<td class="source"><pre><code><cite>// pointers to structures</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<dfn>#include &lt;sstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>struct</var> movies_t {
  string title;
  <var>int</var> year;
};

<var>int</var> main ()
{
  string mystr;

  movies_t amovie;
  movies_t * pmovie;
  pmovie = &amp;amovie;

  cout &lt;&lt; <kbd>"Enter title: "</kbd>;
  getline (cin, pmovie-&gt;title);
  cout &lt;&lt; <kbd>"Enter year: "</kbd>;
  getline (cin, mystr);
  (stringstream) mystr &gt;&gt; pmovie-&gt;year;

  cout &lt;&lt; <kbd>"\nYou have entered:\n"</kbd>;
  cout &lt;&lt; pmovie-&gt;title;
  cout &lt;&lt; <kbd>" ("</kbd> &lt;&lt; pmovie-&gt;year &lt;&lt; <kbd>")\n"</kbd>;

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Enter title: Invasion of the body snatchers
Enter year: 1978
 
You have entered:
Invasion of the body snatchers (1978)</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The arrow operator (<code>-&gt;</code>) is a dereference operator that is used exclusively with pointers to objects that have members. This operator serves to access the member of an object directly from its address. For example, in the example above:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>pmovie-&gt;title</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
is, for all purposes, equivalent to: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>(*pmovie).title</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both expressions, <code>pmovie-&gt;title</code> and <code>(*pmovie).title</code> are valid, and both access the member <code>title</code> of the data structure pointed by a pointer called <code>pmovie</code>. It is definitely something different than:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>*pmovie.title</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
which is rather equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>*(pmovie.title)</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would access the value pointed by a hypothetical pointer member called <code>title</code> of the structure object <code>pmovie</code> (which is not the case, since <code>title</code> is not a pointer type). The following panel summarizes possible combinations of the operators for pointers and for structure members:<br>
<br>
<table class="boxed">
<tr><th>Expression</th><th>What is evaluated</th><th>Equivalent</th></tr>
<tr><td><code>a.b</code></td><td>Member <code>b</code> of object <code>a</code></td><td></td></tr>
<tr><td><code>a-&gt;b</code></td><td>Member <code>b</code> of object pointed to by <code>a</code></td><td><code>(*a).b</code></td></tr>
<tr><td><code>*a.b</code></td><td>Value pointed to by member <code>b</code> of object <code>a</code></td><td><code>*(a.b)</code></td></tr>
</table>
</section>
<br>
<section id="nesting_structures">
<h3>Nesting structures</h3>
Structures can also be nested in such a way that an element of a structure is itself another structure:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></code></pre></td>
<td class="source"><pre><code><var>struct</var> movies_t {
  string title;
  <var>int</var> year;
};

<var>struct</var> friends_t {
  string name;
  string email;
  movies_t favorite_movie;
} charlie, maria;

friends_t * pfriends = &amp;charlie;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
After the previous declarations, all of the following expressions would be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>charlie.name
maria.favorite_movie.title
charlie.favorite_movie.year
pfriends-&gt;favorite_movie.year</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
(where, by the way, the last two expressions refer to the same member). <br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/dynamic/" rel="prev">Previous:<br><b>Dynamic memory</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/other_data_types/" rel="next">Next:<br><b>Other data types</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Other data types</h2>
<section id="type_aliases">
<h3>Type aliases (typedef / using)</h3>
A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier.<br>
<br>
In C++, there are two syntaxes for creating such type aliases: The first, inherited from the C language, uses the <code>typedef</code> keyword:<br>
<br>
<code>
typedef existing_type new_type_name ;<br>
</code>
<br>
where <code>existing_type</code> is any type, either fundamental or compound, and <code>new_type_name</code> is an identifier with the new name given to the type.<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>typedef</var> <var>char</var> C;
<var>typedef</var> <var>unsigned</var> <var>int</var> WORD;
<var>typedef</var> <var>char</var> * pChar;
<var>typedef</var> <var>char</var> field [50]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This defines four type aliases: <code>C</code>, <code>WORD</code>, <code>pChar</code>, and <code>field</code> as <code>char</code>, <code>unsigned int</code>, <code>char*</code> and <code>char[50]</code>, respectively. Once these aliases are defined, they can be used in any declaration just like any other valid type:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>C mychar, anotherchar, *ptc1;
WORD myword;
pChar ptc2;
field name; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
More recently, a second syntax to define type aliases was introduced in the C++ language:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>using</var> new_type_name = existing_type ;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
For example, the same type aliases as above could be defined as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>using</var> C = <var>char</var>;
<var>using</var> WORD = <var>unsigned</var> <var>int</var>;
<var>using</var> pChar = <var>char</var> *;
<var>using</var> field = <var>char</var> [50]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both aliases defined with <code>typedef</code> and aliases defined with <code>using</code> are semantically equivalent. The only difference being that <code>typedef</code> has certain limitations in the realm of templates that <code>using</code> has not. Therefore, <code>using</code> is more generic, although <code>typedef</code> has a longer history and is probably more common in existing code.<br>
<br>
Note that neither <code>typedef</code> nor <code>using</code> create new distinct data types. They only create synonyms of existing types. That means that the type of <code>myword</code> above, declared with type <code>WORD</code>, can as well be considered of type <code>unsigned int</code>; it does not really matter, since both are actually referring to the same type.<br>
<br>
Type aliases can be used to reduce the length of long or confusing type names, but they are most useful as tools to abstract programs from the underlying types they use. For example, by using an alias of <code>int</code> to refer to a particular kind of parameter instead of using <code>int</code> directly, it allows for the type to be easily replaced by <code>long</code> (or some other type) in a later version, without having to change every instance where it is used.<br>
</section>
<br>
<section id="unions">
<h3>Unions</h3>
Unions allow one portion of memory to be accessed as different data types. Its declaration and use is similar to the one of structures, but its functionality is totally different:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
union type_name {
  member_type1 member_name1;
  member_type2 member_name2;
  member_type3 member_name3;
  .
  .
} object_names;
</samp></pre></td></tr></table></div>
<br>
This creates a new union type, identified by <code>type_name</code>, in which all its member elements occupy the same physical space in memory. The size of this type is the one of the largest member element. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>union</var> mytypes_t {
  <var>char</var> c;
  <var>int</var> i;
  <var>float</var> f;
} mytypes;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
declares an object (<code>mytypes</code>) with three members:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>mytypes.c
mytypes.i
mytypes.f</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Each of these members is of a different data type. But since all of them are referring to the same location in memory, the modification of one of the members will affect the value of all of them. It is not possible to store different values in them in a way that each is independent of the others.<br>
<br>
One of the uses of a union is to be able to access a value either in its entirety or as an array or structure of smaller elements. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></code></pre></td>
<td class="source"><pre><code><var>union</var> mix_t {
  <var>int</var> l;
  <var>struct</var> {
    <var>short</var> hi;
    <var>short</var> lo;
    } s;
  <var>char</var> c[4];
} mix;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If we assume that the system where this program runs has an <code>int</Code> type with a size of 4 bytes, and a <code>short</code> type of 2 bytes, the union defined above allows the access to the same group of 4 bytes: <code>mix.l</code>, <code>mix.s</code> and <code>mix.c</code>, and which we can use according to how we want to access these bytes: as if they were a single value of type <code>int</code>, or as if they were two values of type <code>short</code>, or as an array of <code>char</code> elements, respectively. The example mixes types, arrays, and structures in the union to demonstrate different ways to access the data. For a little-endian system, this union could be represented as:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/other_data_types/union.png" alt="">
<br>
The exact alignment and order of the members of a union in memory depends on the system, with the possibility of creating portability issues.<br>
</section>
<br>
<section id="anonymous_unions">
<h3>Anonymous unions</h3>
When unions are members of a class (or structure), they can be declared with no name. In this case, they become <i>anonymous unions</i>, and its members are directly accessible from objects by their member names. For example, see the differences between these two structure declarations: <br>
<br>
<table class="boxed"><tr><th>structure with regular union</th><th>structure with anonymous union</th></tr>
<tr><td><code><pre >struct book1_t {
  char title[50];
  char author[50];
  union {
    float dollars;
    int yen;
  } price;
} book1;</pre></code></td>
<td><code><pre >struct book2_t {
  char title[50];
  char author[50];
  union {
    float dollars;
    int yen;
  };
} book2;</pre></code></td></tr>
</table>
<br>
The only difference between the two types is that in the first one, the member union has a name (<code>price</code>), while in the second it has not. This affects the way to access members <code>dollars</code> and <code>yen</code> of an object of this type. For an object of the first type (with a regular union), it would be:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>book1.price.dollars
book1.price.yen</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
whereas for an object of the second type (which has an anonymous union), it would be: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>book2.dollars
book2.yen</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Again, remember that because it is a member union (not a member structure), the members <code>dollars</code> and <code>yen</code> actually share the same memory location, so they cannot be used to store two different values simultaneously. The <code>price</code> can be set in <code>dollars</code> or in <code>yen</code>, but not in both simultaneously.<br>
</section>
<br>
<section id="enumerated_types">
<h3>Enumerated types (enum)</h3>
<dfn>Enumerated types</dfn> are types that are defined with a set of custom identifiers, known as <i>enumerators</i>, as possible values. Objects of these <i>enumerated types</i> can take any of these enumerators as value.<br>
<br>
Their syntax is:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
enum type_name {
  value1,
  value2,
  value3,
  .
  .
} object_names;
</samp></pre></td></tr></table></div>
<br>
This creates the type <code>type_name</code>, which can take any of <code>value1</code>, <code>value2</code>, <code>value3</code>, ... as value. Objects (variables) of this type can directly be instantiated as <code>object_names</code>.<br>
<br>
For example, a new type of variable called <code>colors_t</code> could be defined to store colors with the following declaration: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>enum</var> colors_t {black, blue, green, cyan, red, purple, yellow, white};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that this declaration includes no other type, neither fundamental nor compound, in its definition. To say it another way, somehow, this creates a whole new data type from scratch without basing it on any other existing type. The possible values that variables of this new type <code>color_t</code> may take are the enumerators listed within braces. For example, once the <code>colors_t</code> enumerated type is declared, the following expressions will be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>colors_t mycolor;
 
mycolor = blue;
<var>if</var> (mycolor == green) mycolor = red; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Values of <i>enumerated types</i> declared with <code>enum</code> are implicitly convertible to an integer type, and vice versa. In fact, the elements of such an <code>enum</code> are always assigned an integer numerical equivalent internally, to which they can be implicitly converted to or from. If it is not specified otherwise, the integer value equivalent to the first possible value is <code>0</code>, the equivalent to the second is <code>1</code>, to the third is <code>2</code>, and so on... Therefore, in the data type <code>colors_t</code> defined above, <code>black</code> would be equivalent to <code>0</code>, <code>blue</code> would be equivalent to <code>1</code>, <code>green</code> to <code>2</code>, and so on...<br>
<br>
A specific integer value can be specified for any of the possible values in the enumerated type. And if the constant value that follows it is itself not given its own value, it is automatically assumed to be the same value plus one. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>enum</var> months_t { january=1, february, march, april,
                may, june, july, august,
                september, october, november, december} y2k;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the variable <code>y2k</code> of the enumerated type <code>months_t</Code> can contain any of the 12 possible values that go from <code>january</code> to <code>december</code> and that are equivalent to the values between <code>1</code> and <code>12</code> (not between <code>0</code> and <code>11</code>, since <code>january</code> has been made equal to <code>1</code>).<br>
<br>
The implicit conversion works both ways: a value of type <code>months_t</code> can be assigned a value of <code>1</code> (which would be equivalent to <code>january</code>), or an integer variable can be assigned a value of <code>january</code> (equivalent to <code>1</code>).<br>
</section>
<br>
<section id="enum_class">
<h3>Enumerated types with enum class</h3>
But, in C++, it is possible to create real <code>enum</code> types that are neither implicitly convertible to <code>int</code> and that neither have enumerator values of type <code>int</code>, but of the <code>enum</code> type itself, thus preserving type safety. They are declared with <code>enum class</code> (or <code>enum struct</code>) instead of just <code>enum</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>enum</var> <var>class</var> Colors {black, blue, green, cyan, red, purple, yellow, white};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Each of the enumerator values of an <code>enum class</code> type needs to be scoped into its type (this is actually also possible with <code>enum</code> types, but it is only optional). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>Colors mycolor;
 
mycolor = Colors::blue;
<var>if</var> (mycolor == Colors::green) mycolor = Colors::red; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Enumerated types declared with <code>enum class</code> also have more control over their underlying type; it may be any integral data type, such as <code>char</code>, <code>short</code> or <code>unsigned int</code>, which essentially serves to determine the size of the type. This is specified by a colon and the underlying type following the enumerated type. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>enum</var> <var>class</var> EyeColor : <var>char</var> {blue, green, brown}; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>Eyecolor</code> is a distinct type with the same size of a <code>char</code> (1 byte).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/structures/" rel="prev">Previous:<br><b>Data structures</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/classes/" rel="next">Next:<br><b>Classes (I)</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Classes (I)</h2>
<section id="definition">
<dfn>Classes</dfn> are an expanded concept of <i>data structures</i>: like data structures, they can contain data members, but they can also contain functions as members.<br>
<br>
An <dfn>object</dfn> is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the variable.<br>
<br>
Classes are defined using either keyword <code>class</code> or keyword <code>struct</code>, with the following syntax:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>class class_name {
  access_specifier_1:
    member1;
  access_specifier_2:
    member2;
  ...
} object_names;
</samp></pre></td></tr></table></div>
<br>
Where <code>class_name</code> is a valid identifier for the class, <code>object_names</code> is an optional list of names for objects of this class. The body of the declaration can contain <i>members</i>, which can either be data or function declarations, and optionally <i>access specifiers</i>.<br>
<br>
Classes have the same format as plain <i>data structures</i>, except that they can also include functions and have these new things called <i>access specifiers</i>. An <i>access specifier</i> is one of the following three keywords: <code>private</code>, <code>public</code> or <code>protected</code>. These specifiers modify the access rights for the members that follow them:<br>
<br>
<ul>
<li><code>private</code> members of a class are accessible only from within other members of the same class (or from their <i>"friends"</i>).</li>
<li><code>protected</code> members are accessible from other members of the same class (or from their <i>"friends"</i>), but also from members of their derived classes.</li>
<li>Finally, <code>public</code> members are accessible from anywhere where the object is visible.</li>
</ul>
<br>
By default, all members of a class declared with the <code>class</code> keyword have private access for all its members. Therefore, any member that is declared before any other <i>access specifier</i> has private access automatically. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var>,<var>int</var>);
    <var>int</var> area (<var>void</var>);
} rect;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Declares a class (i.e., a type) called <code>Rectangle</code> and an object (i.e., a variable) of this class, called <code>rect</code>. This class contains four members: two data members of type <code>int</code> (member <code>width</code> and member <code>height</code>) with <i>private access</i> (because private is the default access level) and two member functions with <i>public access</i>: the functions <code>set_values</code> and <code>area</code>, of which for now we have only included their declaration, but not their definition.<br>
<br>
Notice the difference between the <i>class name</i> and the <i>object name</i>: In the previous example, <code>Rectangle</code> was the <i>class name</i> (i.e., the type), whereas <code>rect</code> was an object of type <code>Rectangle</code>. It is the same relationship <code>int</code> and <code>a</code> have in the following declaration:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> a;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
where <code>int</code> is the type name (the class) and <code>a</code> is the variable name (the object). <br>
<br>
After the declarations of <code>Rectangle</code> and <code>rect</code>, any of the public members of object <code>rect</code> can be accessed as if they were normal functions or normal variables, by simply inserting a dot (<code>.</code>) between <i>object name</i> and <i>member name</i>. This follows the same syntax as accessing the members of plain data structures. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>rect.set_values (3,4);
myarea = rect.area(); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The only members of <code>rect</code> that cannot be accessed from outside the class are <code>width</code> and <code>height</code>, since they have private access and they can only be referred to from within other members of that same class.<br>
<br>
Here is the complete example of class Rectangle:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// classes example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var>,<var>int</var>);
    <var>int</var> area() {<var>return</var> width*height;}
};

<var>void</var> Rectangle::set_values (<var>int</var> x, <var>int</var> y) {
  width = x;
  height = y;
}

<var>int</var> main () {
  Rectangle rect;
  rect.set_values (3,4);
  cout &lt;&lt; <kbd>"area: "</kbd> &lt;&lt; rect.area();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>area: 12</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This example reintroduces the <i>scope operator</i> (<code>::</code>, two colons), seen in earlier chapters in relation to namespaces. Here it is used in the definition of function <code>set_values</code> to define a member of a class outside the class itself.<br>
<br>
Notice that the definition of the member function <code>area</code> has been included directly within the definition of class <code>Rectangle</code> given its extreme simplicity. Conversely, <code>set_values</code> it is merely declared with its prototype within the class, but its definition is outside it. In this outside definition, the operator of scope (<code>::</code>) is used to specify that the function being defined is a member of the class <code>Rectangle</code> and not a regular non-member function.<br>
<br>
The scope operator (<code>::</code>) specifies the class to which the member being defined belongs, granting exactly the same scope properties as if this function definition was directly included within the class definition. For example, the function <code>set_values</code> in the previous example has access to the variables <code>width</code> and <code>height</code>, which are private members of class <code>Rectangle</code>, and thus only accessible from other members of the class, such as this.<br>
<br>
The only difference between defining a member function completely within the class definition or to just include its declaration in the function and define it later outside the class, is that in the first case the function is automatically considered an <i>inline</i> member function by the compiler, while in the second it is a normal (not-inline) class member function. This causes no differences in behavior, but only on possible compiler optimizations.<br>
<br>
Members <code>width</code> and <code>height</code> have private access (remember that if nothing else is specified, all members of a class defined with keyword <code>class</code> have private access). By declaring them private, access from outside the class is not allowed. This makes sense, since we have already defined a member function to set values for those members within the object: the member function <code>set_values</code>. Therefore, the rest of the program does not need to have direct access to them. Perhaps in a so simple example as this, it is difficult to see how restricting access to these variables may be useful, but in greater projects it may be very important that values cannot be modified in an unexpected way (unexpected from the point of view of the object).<br>
<br>
The most important property of a class is that it is a type, and as such, we can declare multiple objects of it. For example, following with the previous example of class <code>Rectangle</code>, we could have declared the object <code>rectb</code> in addition to object <code>rect</code>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// example: one class, two objects</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var>,<var>int</var>);
    <var>int</var> area () {<var>return</var> width*height;}
};

<var>void</var> Rectangle::set_values (<var>int</var> x, <var>int</var> y) {
  width = x;
  height = y;
}

<var>int</var> main () {
  Rectangle rect, rectb;
  rect.set_values (3,4);
  rectb.set_values (5,6);
  cout &lt;&lt; <kbd>"rect area: "</kbd> &lt;&lt; rect.area() &lt;&lt; endl;
  cout &lt;&lt; <kbd>"rectb area: "</kbd> &lt;&lt; rectb.area() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>rect area: 12
rectb area: 30  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this particular case, the class (type of the objects) is <code>Rectangle</code>, of which there are two instances (i.e., objects): <code>rect</code> and <code>rectb</code>. Each one of them has its own member variables and member functions.<br>
<br>
Notice that the call to <code>rect.area()</code> does not give the same result as the call to <code>rectb.area()</code>. This is because each object of class <code>Rectangle</code> has its own variables <code>width</code> and <code>height</code>, as they -in some way- have also their own function members <code>set_value</code> and <code>area</code> that operate on the object's own member variables.<br>
<br>
Classes allow programming using object-oriented paradigms: Data and functions are both members of the object, reducing the need to pass and carry handlers or other state variables as arguments to functions, because they are part of the object whose member is called. Notice that no arguments were passed on the calls to <code>rect.area</code> or <code>rectb.area</code>. Those member functions directly used the data members of their respective objects <code>rect</code> and <code>rectb</code>.<br>
</section>
<br>
<section id="constructors">
<h3>Constructors</h3>
What would happen in the previous example if we called the member function <code>area</code> before having called <code>set_values</code>? An undetermined result, since the members <code>width</code> and <code>height</code> had never been assigned a value.<br>
<br>
In order to avoid that, a class can include a special function called its <i>constructor</i>, which is automatically called whenever a new object of this class is created, allowing the class to initialize member variables or allocate storage.<br>
<br>
This constructor function is declared just like a regular member function, but with a name that matches the class name and without any return type; not even <code>void</code>.<br>
<br>
The <code>Rectangle</code> class above can easily be improved by implementing a constructor:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><cite>// example: class constructor</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    Rectangle (<var>int</var>,<var>int</var>);
    <var>int</var> area () {<var>return</var> (width*height);}
};

Rectangle::Rectangle (<var>int</var> a, <var>int</var> b) {
  width = a;
  height = b;
}

<var>int</var> main () {
  Rectangle rect (3,4);
  Rectangle rectb (5,6);
  cout &lt;&lt; <kbd>"rect area: "</kbd> &lt;&lt; rect.area() &lt;&lt; endl;
  cout &lt;&lt; <kbd>"rectb area: "</kbd> &lt;&lt; rectb.area() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>rect area: 12
rectb area: 30  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The results of this example are identical to those of the previous example. But now, class <code>Rectangle</code> has no member function <code>set_values</code>, and has instead a constructor that performs a similar action: it initializes the values of <code>width</code> and <code>height</code> with the arguments passed to it.<br>
<br>
Notice how these arguments are passed to the constructor at the moment at which the objects of this class are created:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Rectangle rect (3,4);
Rectangle rectb (5,6);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Constructors cannot be called explicitly as if they were regular member functions. They are only executed once, when a new object of that class is created.<br>
<br>
Notice how neither the constructor prototype declaration (within the class) nor the latter constructor definition, have return values; not even <code>void</code>: Constructors never return values, they simply initialize the object.<br>
</section>
<br>
<section id="overloading_constructors">
<h3>Overloading constructors</h3>
Like any other function, a constructor can also be overloaded with different versions taking different parameters: with a different number of parameters and/or parameters of different types. The compiler will automatically call the one whose parameters match the arguments:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br></code></pre></td>
<td class="source"><pre><code><cite>// overloading class constructors</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    Rectangle ();
    Rectangle (<var>int</var>,<var>int</var>);
    <var>int</var> area (<var>void</var>) {<var>return</var> (width*height);}
};

Rectangle::Rectangle () {
  width = 5;
  height = 5;
}

Rectangle::Rectangle (<var>int</var> a, <var>int</var> b) {
  width = a;
  height = b;
}

<var>int</var> main () {
  Rectangle rect (3,4);
  Rectangle rectb;
  cout &lt;&lt; <kbd>"rect area: "</kbd> &lt;&lt; rect.area() &lt;&lt; endl;
  cout &lt;&lt; <kbd>"rectb area: "</kbd> &lt;&lt; rectb.area() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>rect area: 12
rectb area: 25  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the above example, two objects of class <code>Rectangle</code> are constructed: <code>rect</code> and <code>rectb</code>. <code>rect</code> is constructed with two arguments, like in the example before.<br>
<br>
But this example also introduces a special kind constructor: the <i>default constructor</i>. The <i>default constructor</i> is the constructor that takes no parameters, and it is special because it is called when an object is declared but is not initialized with any arguments. In the example above, the <i>default constructor</i> is called for <code>rectb</code>. Note how <code>rectb</code> is not even constructed with an empty set of parentheses - in fact, empty parentheses cannot be used to call the default constructor:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Rectangle rectb;   <cite>// ok, default constructor called</cite>
Rectangle rectc(); <cite>// oops, default constructor NOT called </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is because the empty set of parentheses would make of <code>rectc</code> a function declaration instead of an object declaration: It would be a function that takes no arguments and returns a value of type <code>Rectangle</code>.<br>
</section>
<br>
<section id="uniform_initialization">
<h3>Uniform initialization</h3>
The way of calling constructors by enclosing their arguments in parentheses, as shown above, is known as <i>functional form</i>. But constructors can also be called with other syntaxes:<br>
<br>
First, constructors with a single parameter can be called using the variable initialization syntax (an equal sign followed by the argument):<br>
<br>
<code>class_name  object_name = initialization_value;</code> <br>
<br>
More recently, C++ introduced the possibility of constructors to be called using <i>uniform initialization</i>, which essentially is the same as the functional form, but using braces (<code>{}</code>) instead of parentheses (<code>()</code>):<br>
<br>
<code>class_name object_name { value, value, value, ... }</code> <br>
<br>
Optionally, this last syntax can include an equal sign before the braces.<br>
<br>
Here is an example with four ways to construct objects of a class whose constructor takes a single parameter:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// classes and uniform initialization</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Circle {
    <var>double</var> radius;
  <var>public</var>:
    Circle(<var>double</var> r) { radius = r; }
    <var>double</var> circum() {<var>return</var> 2*radius*3.14159265;}
};

<var>int</var> main () {
  Circle foo (10.0);   <cite>// functional form</cite>
  Circle bar = 20.0;   <cite>// assignment init.</cite>
  Circle baz {30.0};   <cite>// uniform init.</cite>
  Circle qux = {40.0}; <cite>// POD-like</cite>

  cout &lt;&lt; <kbd>"foo's circumference: "</kbd> &lt;&lt; foo.circum() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>foo's circumference: 62.8319</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
An advantage of uniform initialization over functional form is that, unlike parentheses, braces cannot be confused with function declarations, and thus can be used to explicitly call default constructors:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>Rectangle rectb;   <cite>// default constructor called</cite>
Rectangle rectc(); <cite>// function declaration (default constructor NOT called)</cite>
Rectangle rectd{}; <cite>// default constructor called </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The choice of syntax to call constructors is largely a matter of style. Most existing code currently uses functional form, and some newer style guides suggest to choose uniform initialization over the others, even though it also has its potential pitfalls for its preference of <code><a href="/initializer_list">initializer_list</a></code> as its type.<br>
</section>
<br>
<section id="member_initialization">
<h3>Member initialization in constructors</h3>
When a constructor is used to initialize other members, these other members can be initialized directly, without resorting to statements in its body. This is done by inserting, before the constructor's body, a colon (<code>:</code>) and a list of initializations for class members. For example, consider a class with the following declaration:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Rectangle {
    <var>int</var> width,height;
  <var>public</var>:
    Rectangle(<var>int</var>,<var>int</var>);
    <var>int</var> area() {<var>return</var> width*height;}
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The constructor for this class could be defined, as usual, as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>int</var> x, <var>int</var> y) { width=x; height=y; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But it could also be defined using <i>member initialization</i> as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>int</var> x, <var>int</var> y) : width(x) { height=y; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Or even:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>int</var> x, <var>int</var> y) : width(x), height(y) { }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note how in this last case, the constructor does nothing else than initialize its members, hence it has an empty function body.<br>
<br>
For members of fundamental types, it makes no difference which of the ways above the constructor is defined, because they are not initialized by default, but for member objects (those whose type is a class), if they are not initialized after the colon, they are default-constructed.<br>
<br>
Default-constructing all members of a class may or may always not be convenient: in some cases, this is a waste (when the member is then reinitialized otherwise in the constructor), but in some other cases, default-construction is not even possible (when the class does not have a default constructor). In these cases, members shall be initialized in the member initialization list. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code><cite>// member initialization</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Circle {
    <var>double</var> radius;
  <var>public</var>:
    Circle(<var>double</var> r) : radius(r) { }
    <var>double</var> area() {<var>return</var> radius*radius*3.14159265;}
};

<var>class</var> Cylinder {
    Circle base;
    <var>double</var> height;
  <var>public</var>:
    Cylinder(<var>double</var> r, <var>double</var> h) : base (r), height(h) {}
    <var>double</var> volume() {<var>return</var> base.area() * height;}
};

<var>int</var> main () {
  Cylinder foo (10,20);

  cout &lt;&lt; <kbd>"foo's volume: "</kbd> &lt;&lt; foo.volume() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>foo's volume: 6283.19</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, class <code>Cylinder</code> has a member object whose type is another class (<code>base</code>'s type is <code>Circle</code>). Because objects of class <code>Circle</code> can only be constructed with a parameter, <code>Cylinder</code>'s constructor needs to call <code>base</code>'s constructor, and the only way to do this is in the <i>member initializer list</i>.<br>
<br>
These initializations can also use uniform initializer syntax, using braces <code>{}</code> instead of parentheses <code>()</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Cylinder::Cylinder (<var>double</var> r, <var>double</var> h) : base{r}, height{h} { }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="pointers_to_classes">
<h3>Pointers to classes</h3>
Objects can also be pointed to by pointers: Once declared, a class becomes a valid type, so it can be used as the type pointed to by a pointer. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle * prect;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
is a pointer to an object of class <code>Rectangle</code>.<br>
<br>
Similarly as with plain data structures, the members of an object can be accessed directly from a pointer by using the arrow operator (<code>-&gt;</code>). Here is an example with some possible combinations:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// pointer to classes example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
  <var>int</var> width, height;
<var>public</var>:
  Rectangle(<var>int</var> x, <var>int</var> y) : width(x), height(y) {}
  <var>int</var> area(<var>void</var>) { <var>return</var> width * height; }
};


<var>int</var> main() {
  Rectangle obj (3, 4);
  Rectangle * foo, * bar, * baz;
  foo = &amp;obj;
  bar = <var>new</var> Rectangle (5, 6);
  baz = <var>new</var> Rectangle[2] { {2,5}, {3,6} };
  cout &lt;&lt; <kbd>"obj's area: "</kbd> &lt;&lt; obj.area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"*foo's area: "</kbd> &lt;&lt; foo-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"*bar's area: "</kbd> &lt;&lt; bar-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"baz[0]'s area:"</kbd> &lt;&lt; baz[0].area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; <kbd>"baz[1]'s area:"</kbd> &lt;&lt; baz[1].area() &lt;&lt; <kbd>'\n'</kbd>;       
  <var>delete</var> bar;
  <var>delete</var>[] baz;
  <var>return</var> 0;
}	</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This example makes use of several operators to operate on objects and pointers (operators <code>*</code>, <code>&</code>, <code>.</code>, <code>-&gt;</code>, <code>[]</code>). They can be interpreted as:<br>
<br>
<table class="boxed">
<tr><th>expression</th><th>can be read as</th></tr>
<tr><td><code>*x</code></td><td>pointed to by <code>x</code></td></tr>
<tr><td><code>&x</code></td><td>address of <code>x</code></td></tr>
<tr><td><code>x.y</code></td><td>member <code>y</code> of object <code>x</code></td></tr>
<tr><td><code>x-&gt;y</code></td><td>member <code>y</code> of object pointed to by <code>x</code></td></tr>
<tr><td><code>(*x).y</code></td><td>member <code>y</code> of object pointed to by <code>x</code> (equivalent to the previous one)</td></tr>
<tr><td><code>x[0]</code></td><td>first object pointed to by <code>x</code></td></tr>
<tr><td><code>x[1]</code></td><td>second object pointed to by <code>x</code></td></tr>
<tr><td><code>x[n]</code></td><td>(<code>n+1</code>)th object pointed to by <code>x</code></td></tr>
</table>
<br>
Most of these expressions have been introduced in earlier chapters. Most notably, the chapter about arrays introduced the offset operator (<code>[]</code>) and the chapter about plain data structures introduced the arrow operator (<code>-&gt;</code>).<br>
</section>
<br>
<section id="struct_and_union">
<h3>Classes defined with struct and union</h3>
Classes can be defined not only with keyword <code>class</code>, but also with keywords <code>struct</code> and <code>union</code>.<br>
<br>
The keyword <code>struct</code>, generally used to declare plain data structures, can also be used to declare classes that have member functions, with the same syntax as with keyword <code>class</code>. The only difference between both is that members of classes declared with the keyword <code>struct</code> have <code>public</code> access by default, while members of classes declared with the keyword <code>class</code> have <code>private</code> access by default. For all other purposes both keywords are equivalent in this context.<br>
<br>
Conversely, the concept of <i>unions</i> is different from that of classes declared with <code>struct</code> and <code>class</Code>, since unions only store one data member at a time, but nevertheless they are also classes and can thus also hold member functions. The default access in union classes is <code>public</code>.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/other_data_types/" rel="prev">Previous:<br><b>Other data types</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/templates/" rel="next">Next:<br><b>Classes (II)</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Classes (II)</h2>
<section id="overloading_operators">
<h3>Overloading operators</h3>
Classes, essentially, define new types to be used in C++ code. And types in C++ not only interact with code by means of constructions and assignments. They also interact by means of operators. For example, take the following operation on fundamental types:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> a, b, c;
a = b + c;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, different variables of a fundamental type (<code>int</code>) are applied the addition operator, and then the assignment operator. For a fundamental arithmetic type, the meaning of such operations is generally obvious and unambiguous, but it may not be so for certain class types. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>struct</var> myclass {
  string product;
  <var>float</var> price;
} a, b, c;
a = b + c;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, it is not obvious what the result of the addition operation on <code>b</code> and <code>c</code> does. In fact, this code alone would cause a compilation error, since the type <code>myclass</code> has no defined behavior for additions. However, C++ allows most operators to be overloaded so that their behavior can be defined for just about any type, including classes. Here is a list of all the operators that can be overloaded:<br>
<br>
<table class="boxed">
<tr><th>Overloadable operators</th></tr>
<tr><td><code><pre >+    -    *    /    =    &lt;    &gt;    +=   -=   *=   /=   &lt;&lt;   &gt;&gt;
&lt;&lt;=  &gt;&gt;=  ==   !=   &lt;=   &gt;=   ++   --   %    &    ^    !    |
~    &=   ^=   |=   &&   ||   %=   []   ()   ,    -&gt;*  -&gt;   new 
delete    new[]     delete[]</pre></code></td></tr>
</table>
<br>
Operators are overloaded by means of <code>operator</Code> functions, which are regular functions with special names: their name begins by the <code>operator</code> keyword followed by the <i>operator sign</i> that is overloaded. The syntax is:<br>
<br>
<code>type operator sign (parameters) { /*... body ...*/ }</code>
<br>
For example, <i>cartesian vectors</i> are sets of two coordinates: <code>x</code> and <code>y</code>. The addition operation of two <i>cartesian vectors</i> is defined as the addition both <code>x</code> coordinates together, and both <code>y</code> coordinates together. For example, adding the <i>cartesian vectors</i> <code>(3,1)</code> and <code>(1,2)</code> together would result in <code>(3+1,1+2) = (4,3)</code>. This could be implemented in C++ with the following code:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// overloading operators example</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> CVector {
  <var>public</var>:
    <var>int</var> x,y;
    CVector () {};
    CVector (<var>int</var> a,<var>int</var> b) : x(a), y(b) {}
    CVector <var>operator</var> + (<var>const</var> CVector&amp;);
};

CVector CVector::<var>operator</var>+ (<var>const</var> CVector&amp; param) {
  CVector temp;
  temp.x = x + param.x;
  temp.y = y + param.y;
  <var>return</var> temp;
}

<var>int</var> main () {
  CVector foo (3,1);
  CVector bar (1,2);
  CVector result;
  result = foo + bar;
  cout &lt;&lt; result.x &lt;&lt; <kbd>','</kbd> &lt;&lt; result.y &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>4,3</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If confused about so many appearances of <code>CVector</code>, consider that some of them refer to the class name (i.e., the type) <code>CVector</code> and some others are functions with that name (i.e., constructors, which must have the same name as the class). For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>CVector (<var>int</var>, <var>int</var>) : x(a), y(b) {}  <cite>// function name CVector (constructor)</cite>
CVector <var>operator</var>+ (<var>const</var> CVector&amp;); <cite>// function that returns a CVector  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The function <code>operator+</code> of class <code>CVector</code> overloads the addition operator (<code>+</code>) for that type. Once declared, this function can be called either implicitly using the operator, or explicitly using its functional name:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>c = a + b;
c = a.<var>operator</var>+ (b);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both expressions are equivalent.<br>
<br>
The operator overloads are just regular functions which can have any behavior; there is actually no requirement that the operation performed by that overload bears a relation to the mathematical or usual meaning of the operator, although it is strongly recommended. For example, a class that overloads <code>operator+</code> to actually subtract or that overloads <code>operator==</code> to fill the object with zeros, is perfectly valid, although using such a class could be challenging.<br>
<br>
The parameter expected for a member function overload for operations such as <code>operator+</code> is naturally the operand to the right hand side of the operator. This is common to all binary operators (those with an operand to its left and one operand to its right). But operators can come in diverse forms. Here you have a table with a summary of the parameters needed for each of the different operators than can be overloaded (please, replace <code>@</code> by the operator in each case):<br>
<br>
<table class="boxed">
<tr><th>Expression</th><th>Operator</th><th>Member function</th><th>Non-member function</th></tr>
<tr><td><code>@a</code></td><td><code>+ - * & ! ~ ++ --</code></td><td><code>A::operator@()</code></td><td><code>operator@(A)</code></td></tr>
<tr><td><code>a@</code></td><td><code>++ --</code></td><td><code>A::operator@(int)</code></td><td><code>operator@(A,int)</code></td></tr>
<tr><td><code>a@b</code></td><td><code>+ - * / % ^ & | &lt; &gt; == != &lt;= &gt;= &lt;&lt; &gt;&gt; && || ,</code></td><td><code>A::operator@(B)</code></td><td><code>operator@(A,B)</code></td></tr>
<tr><td><code>a@b</code></td><td><code>= += -= *= /= %= ^= &= |= &lt;&lt;= &gt;&gt;= []</code></td><td><code>A::operator@(B)</code></td><td>-</td></tr>
<tr><td><code>a(b,c...)</code></td><td><code>()</code></td><td><code>A::operator()(B,C...)</code></td><td>-</td></tr>
<tr><td><code>a-&gt;b</code></td><td><code>-&gt;</code></td><td><code>A::operator-&gt;()</code></td><td>-</td></tr>
<tr><td><code>(TYPE) a</code></td><td><code>TYPE</code></td><td><code>A::operator TYPE()</code></td><td>-</td></tr>
</table>
Where <code>a</code> is an object of class <code>A</code>, <code>b</code> is an object of class <code>B</code> and <code>c</code> is an object of class <code>C</code>. <code>TYPE</code> is just any type (that operators overloads the conversion to type <code>TYPE</code>).<br>
<br>
Notice that some operators may be overloaded in two forms: either as a member function or as a non-member function: The first case has been used in the example above for <code>operator+</code>. But some operators can also be overloaded as non-member functions; In this case, the operator function takes an object of the proper class as first argument.<br>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// non-member operator overloads</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> CVector {
  <var>public</var>:
    <var>int</var> x,y;
    CVector () {}
    CVector (<var>int</var> a, <var>int</var> b) : x(a), y(b) {}
};


CVector <var>operator</var>+ (<var>const</var> CVector&amp; lhs, <var>const</var> CVector&amp; rhs) {
  CVector temp;
  temp.x = lhs.x + rhs.x;
  temp.y = lhs.y + rhs.y;
  <var>return</var> temp;
}

<var>int</var> main () {
  CVector foo (3,1);
  CVector bar (1,2);
  CVector result;
  result = foo + bar;
  cout &lt;&lt; result.x &lt;&lt; <kbd>','</kbd> &lt;&lt; result.y &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>4,3</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="this">
<h3>The keyword this</h3>
The keyword <code>this</Code> represents a pointer to the object whose member function is being executed. It is used within a class's member function to refer to the object itself.<br>
<br>
One of its uses can be to check if a parameter passed to a member function is the object itself. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// example on this</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Dummy {
  <var>public</var>:
    <var>bool</var> isitme (Dummy&amp; param);
};

<var>bool</var> Dummy::isitme (Dummy&amp; param)
{
  <var>if</var> (&amp;param == <var>this</var>) <var>return</var> <var>true</var>;
  <var>else</var> <var>return</var> <var>false</var>;
}

<var>int</var> main () {
  Dummy a;
  Dummy* b = &amp;a;
  <var>if</var> ( b-&gt;isitme(a) )
    cout &lt;&lt; <kbd>"yes, &amp;a is b\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>yes, &amp;a is b</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It is also frequently used in <code>operator=</code> member functions that return objects by reference. Following with the examples on <i>cartesian vector</i> seen before, its <code>operator=</code> function could have been defined as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>CVector&amp; CVector::<var>operator</var>= (<var>const</var> CVector&amp; param)
{
  x=param.x;
  y=param.y;
  <var>return</var> *<var>this</var>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In fact, this function is very similar to the code that the compiler generates implicitly for this class for <code>operator=</code>.<br>
</section>
<br>
<section id="static_members">
<h3>Static members</h3>
A class can contain static members, either data or functions.<br>
<br>
A static data member of a class is also known as a "class variable", because there is only one common variable for all the objects of that same class, sharing the same value: i.e., its value is not different from one object of this class to another.<br>
<br>
For example, it may be used for a variable within a class that can contain a counter with the number of objects of that class that are currently allocated, as in the following example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// static members in classes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Dummy {
  <var>public</var>:
    <var>static</var> <var>int</var> n;
    Dummy () { n++; };
};

<var>int</var> Dummy::n=0;

<var>int</var> main () {
  Dummy a;
  Dummy b[5];
  cout &lt;&lt; a.n &lt;&lt; <kbd>'\n'</kbd>;
  Dummy * c = <var>new</var> Dummy;
  cout &lt;&lt; Dummy::n &lt;&lt; <kbd>'\n'</kbd>;
  <var>delete</var> c;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>6
7</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In fact, static members have the same properties as non-member variables but they enjoy class scope. For that reason, and to avoid them to be declared several times, they cannot be initialized directly in the class, but need to be initialized somewhere outside it. As in the previous example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> Dummy::n=0;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Because it is a common variable value for all the objects of the same class, it can be referred to as a member of any object of that class or even directly by the class name (of course this is only valid for static members):<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; a.n;
cout &lt;&lt; Dummy::n;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
These two calls above are referring to the same variable: the static variable <code>n</Code> within class <code>Dummy</code> shared by all objects of this class.<br>
<br>
Again, it is just like a non-member variable, but with a name that requires to be accessed like a member of a class (or an object).<br>
<br>
Classes can also have static member functions. These represent the same: members of a class that are common to all object of that class, acting exactly as non-member functions but being accessed like members of the class. Because they are like non-member functions, they cannot access non-static members of the class (neither member variables nor member functions). They neither can use the keyword <code>this</code>.<br>
</section>
<br>
<section id="const_member_functions">
<h3>Const member functions</h3>
When an object of a class is qualified as a <code>const</code> object:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>const</var> MyClass myobject;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The access to its data members from outside the class is restricted to read-only, as if all its data members were <code>const</code> for those accessing them from outside the class. Note though, that the constructor is still called and is allowed to initialize and modify these data members:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br></code></pre></td>
<td class="source"><pre><code><cite>// constructor on const object</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> MyClass {
  <var>public</var>:
    <var>int</var> x;
    MyClass(<var>int</var> val) : x(val) {}
    <var>int</var> get() {<var>return</var> x;}
};

<var>int</var> main() {
  <var>const</var> MyClass foo(10);
<cite>// foo.x = 20;            // not valid: x cannot be modified</cite>
  cout &lt;&lt; foo.x &lt;&lt; <kbd>'\n'</kbd>;  <cite>// ok: data member x can be read</cite>
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The member functions of a <code>const</code> object can only be called if they are themselves specified as <code>const</code> members; in the example above, member <code>get</code> (which is not specified as <code>const</code>) cannot be called from <code>foo</code>. To specify that a member is a <code>const</code> member, the <code>const</code> keyword shall follow the function prototype, after the closing parenthesis for its parameters:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>int</var> get() <var>const</var> {<var>return</var> x;}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that <code>const</code> can be used to qualify the type returned by a member function. This <code>const</code> is not the same as the one which specifies a member as <code>const</code>. Both are independent and are located at different places in the function prototype:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>int</var> get() <var>const</var> {<var>return</var> x;}        <cite>// const member function</cite>
<var>const</var> <var>int</var>&amp; get() {<var>return</var> x;}       <cite>// member function returning a const&amp;</cite>
<var>const</var> <var>int</var>&amp; get() <var>const</var> {<var>return</var> x;} <cite>// const member function returning a const&amp; </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Member functions specified to be <code>const</code> cannot modify non-static data members nor call other non-<code>const</code> member functions. In essence, <code>const</code> members shall not modify the state of an object.<br>
<br>
<code>const</code> objects are limited to access only member functions marked as <code>const</code>, but non-<code>const</code> objects are not restricted and thus can access both <code>const</code> and non-<code>const</code> member functions alike.<br>
<br>
You may think that anyway you are seldom going to declare <code>const</code> objects, and thus marking all members that don't modify the object as const is not worth the effort, but const objects are actually very common. Most functions taking classes as parameters actually take them by <code>const</code> reference, and thus, these functions can only access their <code>const</code> members:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br></code></pre></td>
<td class="source"><pre><code><cite>// const objects</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> MyClass {
    <var>int</var> x;
  <var>public</var>:
    MyClass(<var>int</var> val) : x(val) {}
    <var>const</var> <var>int</var>&amp; get() <var>const</var> {<var>return</var> x;}
};

<var>void</var> print (<var>const</var> MyClass&amp; arg) {
  cout &lt;&lt; arg.get() &lt;&lt; <kbd>'\n'</kbd>;
}

<var>int</var> main() {
  MyClass foo (10);
  print(foo);

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If in this example, <code>get</code> was not specified as a <code>const</code> member, the call to <code>arg.get()</code> in the <code>print</code> function would not be possible, because <code>const</code> objects only have access to <code>const</code> member functions.<br>
<br>
Member functions can be overloaded on their constness: i.e., a class may have two member functions with identical signatures except that one is <code>const</code> and the other is not: in this case, the <code>const</code> version is called only when the object is itself const, and the non-<code>const</code> version is called when the object is itself non-<code>const</code>.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// overloading members on constness</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> MyClass {
    <var>int</var> x;
  <var>public</var>:
    MyClass(<var>int</var> val) : x(val) {}
    <var>const</var> <var>int</var>&amp; get() <var>const</var> {<var>return</var> x;}
    <var>int</var>&amp; get() {<var>return</var> x;}
};

<var>int</var> main() {
  MyClass foo (10);
  <var>const</var> MyClass bar (20);
  foo.get() = 15;         <cite>// ok: get() returns int&amp;</cite>
<cite>// bar.get() = 25;        // not valid: get() returns const int&amp;</cite>
  cout &lt;&lt; foo.get() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; bar.get() &lt;&lt; <kbd>'\n'</kbd>;

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>15
20</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="class_templates">
<h3>Class templates</h3>
Just like we can create function templates, we can also create class templates, allowing classes to have members that use template parameters as types. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T values [2];
  <var>public</var>:
    mypair (T first, T second)
    {
      values[0]=first; values[1]=second;
    }
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The class that we have just defined serves to store two elements of any valid type. For example, if we wanted to declare an object of this class to store two integer values of type <code>int</code> with the values 115 and 36 we would write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mypair&lt;<var>int</var>&gt; myobject (115, 36);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This same class could also be used to create an object to store any other type, such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>mypair&lt;<var>double</var>&gt; myfloats (3.0, 2.18); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The constructor is the only member function in the previous class template and it has been defined inline within the class definition itself. In case that a member function is defined outside the defintion of the class template, it shall be preceded with the <code>template &lt;...&gt;</code> prefix:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br></code></pre></td>
<td class="source"><pre><code><cite>// class templates</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mypair {
    T a, b;
  <var>public</var>:
    mypair (T first, T second)
      {a=first; b=second;}
    T getmax ();
};

<var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax ()
{
  T retval;
  retval = a&gt;b? a : b;
  <var>return</var> retval;
}

<var>int</var> main () {
  mypair &lt;<var>int</var>&gt; myobject (100, 75);
  cout &lt;&lt; myobject.getmax();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>100</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice the syntax of the definition of member function <code>getmax</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt;
T mypair&lt;T&gt;::getmax () </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Confused by so many <code>T</code>'s? There are three <code>T</code>'s in this declaration: The first one is the template parameter. The second <code>T</code> refers to the type returned by the function. And the third <code>T</code> (the one between angle brackets) is also a requirement: It specifies that this function's template parameter is also the class template parameter.<br>
</section>
<br>
<section id="template_specialization">
<h3>Template specialization</h3>
It is possible to define a different implementation for a template when a specific type is passed as template argument. This is called a <i>template specialization</i>.<br>
<br>
For example, let's suppose that we have a very simple class called <code>mycontainer</code> that can store one element of any type and that has just one member function called <code>increase</code>, which increases its value. But we find that when it stores an element of type <code>char</code> it would be more convenient to have a completely different implementation with a function member <code>uppercase</code>, so we decide to declare a class template specialization for that type:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br></code></pre></td>
<td class="source"><pre><code><cite>// template specialization</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<cite>// class template:</cite>
<var>template</var> &lt;<var>class</var> T&gt;
<var>class</var> mycontainer {
    T element;
  <var>public</var>:
    mycontainer (T arg) {element=arg;}
    T increase () {<var>return</var> ++element;}
};

<cite>// class template specialization:</cite>
<var>template</var> &lt;&gt;
<var>class</var> mycontainer &lt;<var>char</var>&gt; {
    <var>char</var> element;
  <var>public</var>:
    mycontainer (<var>char</var> arg) {element=arg;}
    <var>char</var> uppercase ()
    {
      <var>if</var> ((element&gt;=<kbd>'a'</kbd>)&amp;&amp;(element&lt;=<kbd>'z'</kbd>))
      element+=<kbd>'A'</kbd>-<kbd>'a'</kbd>;
      <var>return</var> element;
    }
};

<var>int</var> main () {
  mycontainer&lt;<var>int</var>&gt; myint (7);
  mycontainer&lt;<var>char</var>&gt; mychar (<kbd>'j'</kbd>);
  cout &lt;&lt; myint.increase() &lt;&lt; endl;
  cout &lt;&lt; mychar.uppercase() &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>8
J</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is the syntax used for the class template specialization:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
First of all, notice that we precede the class name with <code>template&lt;&gt;</code> , including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.<br>
<br>
But more important than this prefix, is the <code>&lt;char&gt;</code> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (<code>char</code>). Notice the differences between the generic class template and the specialization:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>template</var> &lt;<var>class</var> T&gt; <var>class</var> mycontainer { ... };
<var>template</var> &lt;&gt; <var>class</var> mycontainer &lt;<var>char</var>&gt; { ... };</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The first line is the generic template, and the second one is the specialization.<br>
<br>
When we declare specializations for a template class, we must also define all its members, even those identical to the generic template class, because there is no "inheritance" of members from the generic template to the specialization.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/classes/" rel="prev">Previous:<br><b>Classes (I)</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/classes2/" rel="next">Next:<br><b>Special members</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Special members</h2>
<section id="special_member_functions">
[NOTE: This chapter requires proper understanding of <i><a href="/doc/tutorial/dynamic/">dynamically allocated memory</a></i>]<br>
<br>
<dfn>Special member functions</dfn> are member functions that are implicitly defined as member of classes under certain circumstances. There are six:<br>
<br>
<table class="boxed"><tr><th>Member function</th><th>typical form for class <code>C</code>:</th></tr>
<tr><td><a href="#default_constructor">Default constructor</a></td><td><code>C::C();</code></td></tr>
<tr><td><a href="#destructor">Destructor</a></td><td><code>C::~C();</code></td></tr>
<tr><td><a href="#copy_constructor">Copy constructor</a></td><td><code>C::C (const C&);</code></td></tr>
<tr><td><a href="#copy_assignment">Copy assignment</a></td><td><code>C& operator= (const C&);</code></td></tr>
<tr><td><a href="#move">Move constructor</a></td><td><code>C::C (C&&);</code></td></tr>
<tr><td><a href="#move">Move assignment</a></td><td><code>C& operator= (C&&);</code></td></tr>
</table>
<br>
Let's examine each of these:<br>
</section>
<br>
<section id="default_constructor">
<h3>Default constructor</h3>
The <dfn>default constructor</dfn> is the constructor called when objects of a class are declared, but are not initialized with any arguments.<br>
<br>
If a class definition has no constructors, the compiler assumes the class to have an implicitly defined <i>default constructor</i>. Therefore, after declaring a class like this:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Example {
  <var>public</var>:
    <var>int</var> total;
    <var>void</var> accumulate (<var>int</var> x) { total += x; }
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The compiler assumes that <code>Example</code> has a <i>default constructor</i>. Therefore, objects of this class can be constructed by simply declaring them without any arguments:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example ex;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But as soon as a class has some constructor taking any number of parameters explicitly declared, the compiler no longer provides an implicit default constructor, and no longer allows the declaration of new objects of that class without arguments. For example, the following class:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Example2 {
  <var>public</var>:
    <var>int</var> total;
    Example2 (<var>int</var> initial_value) : total(initial_value) { };
    <var>void</var> accumulate (<var>int</var> x) { total += x; };
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, we have declared a constructor with a parameter of type <code>int</code>. Therefore the following object declaration would be correct:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example2 ex (100);   <cite>// ok: calls constructor </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But the following:<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example2 ex;         <cite>// not valid: no default constructor </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Would not be valid, since the class has been declared with an explicit constructor taking one argument and that replaces the implicit <i>default constructor</i> taking none.<br>
<br>
Therefore, if objects of this class need to be constructed without arguments, the proper <i>default constructor</i> shall also be declared in the class. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// classes and default constructors</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example3 {
    string data;
  <var>public</var>:
    Example3 (<var>const</var> string&amp; str) : data(str) {}
    Example3() {}
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> data;}
};

<var>int</var> main () {
  Example3 foo;
  Example3 bar (<kbd>"Example"</kbd>);

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>Example3</code> has a <i>default constructor</i> (i.e., a constructor without parameters) defined as an empty block:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example3() {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This allows objects of class <code>Example3</code> to be constructed without arguments (like <code>foo</code> was declared in this example). Normally, a default constructor like this is implicitly defined for all classes that have no other constructors and thus no explicit definition is required. But in this case, <code>Example3</code> has another constructor:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Example3 (<var>const</var> string&amp; str);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
And when any constructor is explicitly declared in a class, no implicit <i>default constructors</i> is automatically provided.<br>
</section>
<br>
<section id="destructor">
<h3>Destructor</h3>
Destructors fulfill the opposite functionality of <i>constructors</i>: They are responsible for the necessary cleanup needed by a class when its lifetime ends. The classes we have defined in previous chapters did not allocate any resource and thus did not really require any clean up.<br>
<br>
But now, let's imagine that the class in the last example allocates dynamic memory to store the string it had as data member; in this case, it would be very useful to have a function called automatically at the end of the object's life in charge of releasing this memory. To do this, we use a <i>destructor</i>. A destructor is a member function very similar to a <i>default constructor</i>: it takes no arguments and returns nothing, not even <code>void</code>. It also uses the class name as its own name, but preceded with a tilde sign (<code>~</code>):<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// destructors</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example4 {
    string* ptr;
  <var>public</var>:
    <cite>// constructors:</cite>
    Example4() : ptr(<var>new</var> string) {}
    Example4 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    <cite>// destructor:</cite>
    ~Example4 () {<var>delete</var> ptr;}
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
};

<var>int</var> main () {
  Example4 foo;
  Example4 bar (<kbd>"Example"</kbd>);

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
On construction, <code>Example4</code> allocates storage for a <code>string</code>. Storage that is later released by the destructor.<br>
<br>
The destructor for an object is called at the end of its lifetime; in the case of <code>foo</code> and <code>bar</code> this happens at the end of function <code>main</code>.<br>
</section>
<br>
<section id="copy_constructor">
<h3>Copy constructor</h3>
When an object is passed a named object of its own type as argument, its <i>copy constructor</i> is invoked in order to construct a copy.<br>
<br>
A <i>copy constructor</i> is a constructor whose first parameter is of type <i>reference to the class</i> itself (possibly <code>const</code> qualified) and which can be invoked with a single argument of this type. For example, for a class <code>MyClass</code>, the <i>copy constructor</i> may have the following signature:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass::MyClass (<var>const</var> MyClass&amp;);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
If a class has no custom <i>copy</i> nor <i>move</i> constructors (or assignments) defined, an implicit <i>copy constructor</i> is provided. This copy constructor simply performs a copy of its own members. For example, for a class such as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>class</var> MyClass {
  <var>public</var>:
    <var>int</var> a, b; string c;
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
An implicit <i>copy constructor</i> is automatically defined. The definition assumed for this function performs a <i>shallow copy</i>, roughly equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass::MyClass(<var>const</var> MyClass&amp; x) : a(x.a), b(x.b), c(x.c) {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This default <i>copy constructor</i> may suit the needs of many classes. But <i>shallow copies</i> only copy the members of the class themselves, and this is probably not what we expect for classes like class <code>Example4</code> we defined above, because it contains pointers of which it handles its storage. For that class, performing a <i>shallow copy</i> means that the pointer value is copied, but not the content itself; This means that both objects (the copy and the original) would be sharing a single <code>string</code> object (they would both be pointing to the same object), and at some point (on destruction) both objects would try to delete the same block of memory, probably causing the program to crash on runtime. This can be solved by defining the following custom <i>copy constructor</i> that performs a <i>deep copy</i>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><cite>// copy constructor: deep copy</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example5 {
    string* ptr;
  <var>public</var>:
    Example5 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    ~Example5 () {<var>delete</var> ptr;}
    <cite>// copy constructor:</cite>
    Example5 (<var>const</var> Example5&amp; x) : ptr(<var>new</var> string(x.content())) {}
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
};

<var>int</var> main () {
  Example5 foo (<kbd>"Example"</kbd>);
  Example5 bar = foo;

  cout &lt;&lt; <kbd>"bar's content: "</kbd> &lt;&lt; bar.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <i>deep copy</i> performed by this <i>copy constructor</i> allocates storage for a new string, which is initialized to contain a copy of the original object. In this way, both objects (copy and original) have distinct copies of the content stored in different locations.<br>
</section>
<br>
<section id="copy_assignment">
<h3>Copy assignment</h3>
Objects are not only copied on construction, when they are initialized: They can also be copied on any assignment operation. See the difference:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>MyClass foo;
MyClass bar (foo);       <cite>// object initialization: copy constructor called</cite>
MyClass baz = foo;       <cite>// object initialization: copy constructor called</cite>
foo = bar;               <cite>// object already initialized: copy assignment called </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that <code>baz</code> is initialized on construction using an <i>equal sign</i>, but this is not an assignment operation! (although it may look like one): The declaration of an object is not an assignment operation, it is just another of the syntaxes to call single-argument constructors.<br>
<br>
The assignment on <code>foo</code> is an assignment operation. No object is being declared here, but an operation is being performed on an existing object; <code>foo</code>.<br>
<br>
The <i>copy assignment operator</i> is an overload of <code>operator=</code> which takes a <i>value</i> or <i>reference</i> of the class itself as parameter. The return value is generally a reference to <code>*this</code> (although this is not required). For example, for a class <code>MyClass</code>, the <i>copy assignment</i> may have the following signature:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>MyClass&amp; <var>operator</var>= (<var>const</var> MyClass&amp;);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <i>copy assignment operator</i> is also a <i>special function</i> and is also defined implicitly if a class has no custom <i>copy</i> nor <i>move</i> assignments (nor move constructor) defined.<br>
<br>
But again, the <i>implicit</i> version performs a <i>shallow copy</i> which is suitable for many classes, but not for classes with pointers to objects they handle its storage, as is the case in <code>Example5</code>. In this case, not only the class incurs the risk of deleting the pointed object twice, but the assignment creates memory leaks by not deleting the object pointed by the object before the assignment. These issues could be solved with a <i>copy assignment</i> that deletes the previous object and performs a <i>deep copy</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>Example5&amp; <var>operator</var>= (<var>const</var> Example5&amp; x) {
  <var>delete</var> ptr;                      <cite>// delete currently pointed string</cite>
  ptr = <var>new</var> string (x.content());  <cite>// allocate space for new string, and copy</cite>
  <var>return</var> *<var>this</var>;
}
</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Or even better, since its <code>string</code> member is not constant, it could re-utilize the same <code>string</code> object:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code>Example5&amp; <var>operator</var>= (<var>const</var> Example5&amp; x) {
  *ptr = x.content();
  <var>return</var> *<var>this</var>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
</section>
<br>
<section id="move">
<h3>Move constructor and assignment</h3>
Similar to copying, moving also uses the value of an object to set the value to another object. But, unlike copying, the content is actually transferred from one object (the source) to the other (the destination): the source loses that content, which is taken over by the destination. This moving only happens when the source of the value is an <i>unnamed object</i>. <br>
<br>
<i>Unnamed objects</i> are objects that are temporary in nature, and thus haven't even been given a name. Typical examples of <i>unnamed objects</i> are return values of functions or type-casts.<br>
<br>
Using the value of a temporary object such as these to initialize another object or to assign its value, does not really require a copy: the object is never going to be used for anything else, and thus, its value can be <i>moved into</i> the destination object. These cases trigger the <i>move constructor</i> and <i>move assignments</i>:<br>
<br>
The <i>move constructor</i> is called when an object is initialized on construction using an unnamed temporary. Likewise, the <i>move assignment</i> is called when an object is assigned the value of an unnamed temporary:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code>MyClass fn();            <cite>// function returning a MyClass object</cite>
MyClass foo;             <cite>// default constructor</cite>
MyClass bar = foo;       <cite>// copy constructor</cite>
MyClass baz = fn();      <cite>// move constructor</cite>
foo = bar;               <cite>// copy assignment</cite>
baz = MyClass();         <cite>// move assignment </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Both the value returned by <code>fn</code> and the value constructed with <code>MyClass</code> are unnamed temporaries. In these cases, there is no need to make a copy, because the unnamed object is very short-lived and can be acquired by the other object when this is a more efficient operation.<br>
<br>
The move constructor and move assignment are members that take a parameter of type <i>rvalue reference to the class</i> itself:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>MyClass (MyClass&amp;&amp;);             <cite>// move-constructor</cite>
MyClass&amp; <var>operator</var>= (MyClass&amp;&amp;);  <cite>// move-assignment </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
An <i>rvalue reference</i> is specified by following the type with two ampersands (<code>&&</code>). As a parameter, an <i>rvalue reference</i> matches arguments of temporaries of this type.<br>
<br>
The concept of moving is most useful for objects that manage the storage they use, such as objects that allocate storage with new and delete. In such objects, copying and moving are really different operations:<br>
- Copying from A to B means that new memory is allocated to B and then the entire content of A is copied to this new memory allocated for B.<br>
- Moving from A to B means that the memory already allocated to A is transferred to B without allocating any new storage. It involves simply copying the pointer.<br>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br></code></pre></td>
<td class="source"><pre><code><cite>// move constructor/assignment</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Example6 {
    string* ptr;
  <var>public</var>:
    Example6 (<var>const</var> string&amp; str) : ptr(<var>new</var> string(str)) {}
    ~Example6 () {<var>delete</var> ptr;}
    <cite>// move constructor</cite>
    Example6 (Example6&amp;&amp; x) : ptr(x.ptr) {x.ptr=<var>nullptr</var>;}
    <cite>// move assignment</cite>
    Example6&amp; <var>operator</var>= (Example6&amp;&amp; x) {
      <var>delete</var> ptr; 
      ptr = x.ptr;
      x.ptr=<var>nullptr</var>;
      <var>return</var> *<var>this</var>;
    }
    <cite>// access content:</cite>
    <var>const</var> string&amp; content() <var>const</var> {<var>return</var> *ptr;}
    <cite>// addition:</cite>
    Example6 <var>operator</var>+(<var>const</var> Example6&amp; rhs) {
      <var>return</var> Example6(content()+rhs.content());
    }
};


<var>int</var> main () {
  Example6 foo (<kbd>"Exam"</kbd>);
  Example6 bar = Example6(<kbd>"ple"</kbd>);   <cite>// move-construction</cite>
  
  foo = foo + bar;                  <cite>// move-assignment</cite>

  cout &lt;&lt; <kbd>"foo's content: "</kbd> &lt;&lt; foo.content() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>foo's content: Example</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Compilers already optimize many cases that formally require a move-construction call in what is known as <i>Return Value Optimization</i>. Most notably, when the value returned by a function is used to initialize an object. In these cases, the <i>move constructor</i> may actually never get called.<br>
<br>
Note that even though <i>rvalue references</i> can be used for the type of any function parameter, it is seldom useful for uses other than the <i>move constructor</i>. Rvalue references are tricky, and unnecessary uses may be the source of errors quite difficult to track.<br>
</section>
<br>
<section id="implicit">
<h3>Implicit members</h3>
The six <i>special members functions</i> described above are members implicitly declared on classes under certain circumstances:<br>
<br>
<table class="boxed"><tr><th>Member function</th><th>implicitly defined:</th><th>default definition:</th></tr>
<tr><td><a href="#default_constructor">Default constructor</a></td><td>if no other constructors</td><td>does nothing</td></tr>
<tr><td><a href="#destructor">Destructor</a></td><td>if no destructor</td><td>does nothing</td></tr>
<tr><td><a href="#copy_constructor">Copy constructor</a></td><td>if no move constructor and no move assignment</td><td>copies all members</td></tr>
<tr><td><a href="#copy_assignment">Copy assignment</a></td><td>if no move constructor and no move assignment</td><td>copies all members</td></tr>
<tr><td><a href="#move">Move constructor</a></td><td>if no destructor, no copy constructor and no copy nor move assignment</td><td>moves all members</td></tr>
<tr><td><a href="#move">Move assignment</a></td><td>if no destructor, no copy constructor and no copy nor move assignment</td><td>moves all members</td></tr>
</table>
<br>
Notice how not all <i>special member functions</i> are implicitly defined in the same cases. This is mostly due to backwards compatibility with C structures and earlier C++ versions, and in fact some include deprecated cases. Fortunately, each class can select explicitly which of these members exist with their default definition or which are deleted by using the keywords <code>default</code> and <code>delete</code>, respectively. The syntax is either one of:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="output"><pre><samp>
function_declaration = default;
function_declaration = delete;
</samp></pre></td></tr></table></div>
<br>
For example:<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// default and delete implicit members</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    Rectangle (<var>int</var> x, <var>int</var> y) : width(x), height(y) {}
    Rectangle() = <var>default</var>;
    Rectangle (<var>const</var> Rectangle&amp; other) = <var>delete</var>;
    <var>int</var> area() {<var>return</var> width*height;}
};

<var>int</var> main () {
  Rectangle foo;
  Rectangle bar (10,20);

  cout &lt;&lt; <kbd>"bar's area: "</kbd> &lt;&lt; bar.area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>bar's area: 200</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, <code>Rectangle</code> can be constructed either with two <code>int</code> arguments or be <i>default-constructed</i> (with no arguments). It cannot however be <i>copy-constructed</i> from another <code>Rectangle</code> object, because this function has been deleted. Therefore, assuming the objects of the last example, the following statement would not be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle baz (foo);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
It could, however, be made explicitly valid by defining its copy constructor as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>const</var> Rectangle&amp; other) = <var>default</var>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Which would be essentially equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Rectangle::Rectangle (<var>const</var> Rectangle&amp; other) : width(other.width), height(other.height) {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Note that, the keyword <code>default</code> does not define a member function equal to the <i>default constructor</i> (i.e., where <i>default constructor</i> means constructor with no parameters), but equal to the constructor that would be implicitly defined if not deleted.<br>
<br>
In general, and for future compatibility, classes that explicitly define one copy/move constructor or one copy/move assignment but not both, are encouraged to specify either <code>delete</code> or <code>default</code> on the other special member functions they don't explicitly define.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/templates/" rel="prev">Previous:<br><b>Classes (II)</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/inheritance/" rel="next">Next:<br><b>Friendship and inheritance</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Friendship and inheritance</h2>
<section id="friend_functions">
<h3>Friend functions</h3>
In principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared. However, this rule does not apply to <i>"friends"</i>.<br>
<br>
<dfn>Friends</dfn> are functions or classes declared with the <code>friend</code> keyword.<br>
<br>
A non-member function can access the private and protected members of a class if it is declared a <i>friend</i> of that class. That is done by including a declaration of this external function within the class, and preceding it with the keyword <code>friend</code>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br></code></pre></td>
<td class="source"><pre><code><cite>// friend functions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    Rectangle() {}
    Rectangle (<var>int</var> x, <var>int</var> y) : width(x), height(y) {}
    <var>int</var> area() {<var>return</var> width * height;}
    <var>friend</var> Rectangle duplicate (<var>const</var> Rectangle&amp;);
};

Rectangle duplicate (<var>const</var> Rectangle&amp; param)
{
  Rectangle res;
  res.width = param.width*2;
  res.height = param.height*2;
  <var>return</var> res;
}

<var>int</var> main () {
  Rectangle foo;
  Rectangle bar (2,3);
  foo = duplicate (bar);
  cout &lt;&lt; foo.area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>24</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The <code>duplicate</code> function is a <i>friend</i> of class <code>Rectangle</code>. Therefore, function <code>duplicate</code> is able to access the members <code>width</code> and <code>height</code> (which are private) of different objects of type <code>Rectangle</code>. Notice though that neither in the declaration of <code>duplicate</code> nor in its later use in <code>main</code>, function <code>duplicate</code> is considered a member of class <code>Rectangle</code>. It isn't! It simply has access to its private and protected members without being a member.<br>
<br>
Typical use cases of friend functions are operations that are conducted between two different classes accessing private or protected members of both. <br>
</section>
<br>
<section id="friend_classes">
<h3>Friend classes</h3>
Similar to friend functions, a friend class is a class whose members have access to the private or protected members of another class:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br></code></pre></td>
<td class="source"><pre><code><cite>// friend class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Square;

<var>class</var> Rectangle {
    <var>int</var> width, height;
  <var>public</var>:
    <var>int</var> area ()
      {<var>return</var> (width * height);}
    <var>void</var> convert (Square a);
};

<var>class</var> Square {
  <var>friend</var> <var>class</var> Rectangle;
  <var>private</var>:
    <var>int</var> side;
  <var>public</var>:
    Square (<var>int</var> a) : side(a) {}
};

<var>void</var> Rectangle::convert (Square a) {
  width = a.side;
  height = a.side;
}
  
<var>int</var> main () {
  Rectangle rect;
  Square sqr (4);
  rect.convert(sqr);
  cout &lt;&lt; rect.area();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>16</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, class <code>Rectangle</code> is a friend of class <code>Square</code> allowing <code>Rectangle</code>'s member functions to access private and protected members of <code>Square</code>. More concretely, <code>Rectangle</code> accesses the member variable <code>Square::side</code>, which describes the side of the square.<br>
<br>
There is something else new in this example: at the beginning of the program, there is an empty declaration of class <code>Square</code>. This is necessary because class <code>Rectangle</code> uses <code>Square</code> (as a parameter in member <code>convert</code>), and <code>Square</code> uses <code>Rectangle</code> (declaring it a friend). <br>
<br>
Friendships are never corresponded unless specified: In our example, <code>Rectangle</code> is considered a friend class by <code>Square</code>, but Square is not considered a friend by <code>Rectangle</code>. Therefore, the member functions of <code>Rectangle</code> can access the protected and private members of <code>Square</code> but not the other way around. Of course, <code>Square</code> could also be declared friend of <code>Rectangle</code>, if needed, granting such an access.<br>
<br>
Another property of friendships is that they are not transitive: The friend of a friend is not considered a friend unless explicitly specified.<br>
</section>
<br>
<section id="inheritance">
<h3>Inheritance between classes</h3>
Classes in C++ can be extended, creating new classes which retain characteristics of the base class. This process, known as inheritance, involves a <i>base class</i> and a <i>derived class</i>: The <i>derived class</i> inherits the members of the <i>base class</i>, on top of which it can add its own members.<br>
<br>
For example, let's imagine a series of classes to describe two kinds of polygons: rectangles and triangles. These two polygons have certain common properties, such as the values needed to calculate their areas: they both can be described simply with a height and a width (or base).<br>
<br>
This could be represented in the world of classes with a class <code>Polygon</code> from which we would derive the two other ones: <code>Rectangle</code> and <code>Triangle</code>:<br>
<br>
<img src="http://www.cplusplus.com/doc/tutorial/inheritance/inheritance.png" alt="">
<br>
The <code>Polygon</code> class would contain members that are common for both types of polygon. In our case: <code>width</code> and <code>height</code>. And <code>Rectangle</code> and <code>Triangle</code> would be its derived classes, with specific features that are different from one type of polygon to the other.<br>
<br>
Classes that are derived from others inherit all the accessible members of the base class. That means that if a base class includes a member <code>A</code> and we derive a class from it with another member called <code>B</code>, the derived class will contain both member <code>A</code> and member <code>B</code>.<br>
<br>
The inheritance relationship of two classes is declared in the derived class. Derived classes definitions use the following syntax:<br>
<br>
<code>
class derived_class_name: public base_class_name<br>
{ /*...*/ };<br>
</code>
<br>
Where <code>derived_class_name</code> is the name of the derived class and <code>base_class_name</code> is the name of the class on which it is based. The <code>public</code> access specifier may be replaced by any one of the other access specifiers (<code>protected</code> or <code>private</code>). This access specifier limits the most accessible level for the members inherited from the base class: The members with a more accessible level are inherited with this level instead, while the members with an equal or more restrictive access level keep their restrictive level in the derived class.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br></code></pre></td>
<td class="source"><pre><code><cite>// derived classes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b;}
 };

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area ()
      { <var>return</var> width * height; }
 };

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area ()
      { <var>return</var> width * height / 2; }
  };
  
<var>int</var> main () {
  Rectangle rect;
  Triangle trgl;
  rect.set_values (4,5);
  trgl.set_values (4,5);
  cout &lt;&lt; rect.area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; trgl.area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The objects of the classes <code>Rectangle</code> and <code>Triangle</code> each contain members inherited from <code>Polygon</code>. These are: <code>width</code>, <code>height</code> and <code>set_values</code>.<br>
<br>
The <code>protected</code> access specifier used in class <code>Polygon</code> is similar to <code>private</code>. Its only difference occurs in fact with inheritance: When a class inherits another one, the members of the derived class can access the protected members inherited from the base class, but not its private members.<br>
<br>
By declaring <code>width</code> and <code>height</code> as <code>protected</code> instead of <code>private</code>, these members are also accessible from the derived classes <code>Rectangle</code> and <code>Triangle</code>, instead of just from members of <code>Polygon</code>. If they were public, they could be accessed just from anywhere.<br>
 <br>
We can summarize the different access types according to which functions can access them in the following way: <br>
<br>
<table class="boxed">
<tr><th>Access</th><th><code>public</code></th><th><code>protected</code></th><th><code>private</code></th></tr>
<tr><td>members of the same class</td><td class="yes">yes</td><td class="yes">yes</td><td class="yes">yes</td></tr>
<tr><td>members of derived class</td><td class="yes">yes</td><td class="yes">yes</td><td class="no">no</td></tr>
<tr><td>not members</td><td class="yes">yes</td><td class="no">no</td><td class="no">no</td></tr>
</table>
<br>
Where "not members" represents any access from outside the class, such as from <code>main</code>, from another class or from a function.<br>
<br>
In the example above, the members inherited by <code>Rectangle</code> and <code>Triangle</code> have the same access permissions as they had in their base class <code>Polygon</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code>Polygon::width           <cite>// protected access</cite>
Rectangle::width         <cite>// protected access</cite>

Polygon::set_values()    <cite>// public access</cite>
Rectangle::set_values()  <cite>// public access  </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This is because the inheritance relation has been declared using the <code>public</Code> keyword on each of the derived classes:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>class</var> Rectangle: <var>public</var> Polygon { <cite>/* ... */</cite> }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This <code>public</code> keyword after the colon (<code>:</code>) denotes the most accessible level the members inherited from the class that follows it (in this case <code>Polygon</code>) will have from the derived class (in this case <code>Rectangle</code>). Since <code>public</code> is the most accessible level, by specifying this keyword the derived class will inherit all the members with the same levels they had in the base class.<br>
<br>
With <code>protected</code>, all public members of the base class are inherited as <code>protected</code> in the derived class. Conversely, if the most restricting access level is specified (<code>private</code>), all the base class members are inherited as <code>private</code>.<br>
<br>
For example, if daughter were a class derived from mother that we defined as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>class</var> Daughter: <var>protected</var> Mother;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would set <code>protected</code> as the less restrictive access level for the members of <code>Daughter</code> that it inherited from mother. That is, all members that were <code>public</code> in <code>Mother</code> would become <code>protected</code> in <code>Daughter</code>. Of course, this would not restrict <code>Daughter</code> from declaring its own public members. That <i>less restrictive access level</i> is only set for the members inherited from <code>Mother</code>.<br>
<br>
If no access level is specified for the inheritance, the compiler assumes private for classes declared with keyword <code>class</code> and public for those declared with <code>struct</code>.<br>
<br>
Actually, most use cases of inheritance in C++ should use public inheritance. When other access levels are needed for base classes, they can usually be better represented as member variables instead.<br>
</section>
<br>
<section id="what_is_inherited">
<h3>What is inherited from the base class?</h3>
In principle, a publicly derived class inherits access to every member of a base class except:<br>
<br>
<ul>
<li>its constructors and its destructor</li>
<li>its assignment operator members (operator=)</li>
<li>its friends</li>
<li>its private members</li>
</ul>
<br>
Even though access to the constructors and destructor of the base class is not inherited as such, they are automatically called by the constructors and destructor of the derived class.<br>
<br>
Unless otherwise specified, the constructors of a derived class calls the default constructor of its base classes (i.e., the constructor taking no arguments). Calling a different constructor of a base class is possible, using the same syntax used to initialize member variables in the initialization list:<br>
<br>
<code>
derived_constructor_name (parameters) : base_constructor_name (parameters) {...}<br>
</code>
<br>
For example: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br></code></pre></td>
<td class="source"><pre><code><cite>// constructors and derived classes</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Mother {
  <var>public</var>:
    Mother ()
      { cout &lt;&lt; <kbd>"Mother: no parameters\n"</kbd>; }
    Mother (<var>int</var> a)
      { cout &lt;&lt; <kbd>"Mother: int parameter\n"</kbd>; }
};

<var>class</var> Daughter : <var>public</var> Mother {
  <var>public</var>:
    Daughter (<var>int</var> a)
      { cout &lt;&lt; <kbd>"Daughter: int parameter\n\n"</kbd>; }
};

<var>class</var> Son : <var>public</var> Mother {
  <var>public</var>:
    Son (<var>int</var> a) : Mother (a)
      { cout &lt;&lt; <kbd>"Son: int parameter\n\n"</kbd>; }
};

<var>int</var> main () {
  Daughter kelly(0);
  Son bud(0);
  
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Mother: no parameters
Daughter: int parameter

Mother: int parameter
Son: int parameter</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice the difference between which <code>Mother</code>'s constructor is called when a new <code>Daughter</code> object is created and which when it is a <code>Son</code> object. The difference is due to the different constructor declarations of <code>Daughter</code> and <code>Son</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Daughter (<var>int</var> a)          <cite>// nothing specified: call default constructor</cite>
Son (<var>int</var> a) : Mother (a)  <cite>// constructor specified: call this specific constructor </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="multiple_inheritance">
<h3>Multiple inheritance</h3>
A class may inherit from more than one class by simply specifying more base classes, separated by commas, in the list of a class's base classes (i.e., after the colon). For example, if the program had a specific class to print on screen called <code>Output</code>, and we wanted our classes <code>Rectangle</code> and <code>Triangle</code> to also inherit its members in addition to those of <code>Polygon</code> we could write:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Rectangle: <var>public</var> Polygon, <var>public</var> Output;
<var>class</var> Triangle: <var>public</var> Polygon, <var>public</var> Output; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here is the complete example: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br></code></pre></td>
<td class="source"><pre><code><cite>// multiple inheritance</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    Polygon (<var>int</var> a, <var>int</var> b) : width(a), height(b) {}
};

<var>class</var> Output {
  <var>public</var>:
    <var>static</var> <var>void</var> print (<var>int</var> i);
};

<var>void</var> Output::print (<var>int</var> i) {
  cout &lt;&lt; i &lt;&lt; <kbd>'\n'</kbd>;
}

<var>class</var> Rectangle: <var>public</var> Polygon, <var>public</var> Output {
  <var>public</var>:
    Rectangle (<var>int</var> a, <var>int</var> b) : Polygon(a,b) {}
    <var>int</var> area ()
      { <var>return</var> width*height; }
};

<var>class</var> Triangle: <var>public</var> Polygon, <var>public</var> Output {
  <var>public</var>:
    Triangle (<var>int</var> a, <var>int</var> b) : Polygon(a,b) {}
    <var>int</var> area ()
      { <var>return</var> width*height/2; }
};
  
<var>int</var> main () {
  Rectangle rect (4,5);
  Triangle trgl (4,5);
  rect.print (rect.area());
  Triangle::print (trgl.area());
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/classes2/" rel="prev">Previous:<br><b>Special members</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/polymorphism/" rel="next">Next:<br><b>Polymorphism</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Polymorphism</h2>
<section id="requirements">
Before getting any deeper into this chapter, you should have a proper understanding of pointers and class inheritance. If you are not really sure of the meaning of any of the following expressions, you should review the indicated sections:<br>
<br>
<table class="boxed">
<tr><th>Statement:</th><th>Explained in:</th></tr>
<tr><td><code>int A::b(int c) { }</code></td><td><a href="/doc/tutorial/classes/">Classes</a></td></tr>
<tr><td><code>a-&gt;b</code></td><td><a href="/doc/tutorial/structures/">Data structures</a></td></tr>
<tr><td><code>class A: public B {};</code></td><td><a href="/doc/tutorial/inheritance/">Friendship and inheritance</a></td></tr>
</table>
</section>
<br>
<section id="pointers_to_base_class">
<h3>Pointers to base class</h3>
One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. <i>Polymorphism</i> is the art of taking advantage of this simple but powerful and versatile feature.<br>
<br>
The example about the rectangle and triangle classes can be rewritten using pointers taking this feature into account:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br></code></pre></td>
<td class="source"><pre><code><cite>// pointers to base class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b; }
};

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area()
      { <var>return</var> width*height; }
};

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area()
      { <var>return</var> width*height/2; }
};

<var>int</var> main () {
  Rectangle rect;
  Triangle trgl;
  Polygon * ppoly1 = &amp;rect;
  Polygon * ppoly2 = &amp;trgl;
  ppoly1-&gt;set_values (4,5);
  ppoly2-&gt;set_values (4,5);
  cout &lt;&lt; rect.area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; trgl.area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Function <code>main</code> declares two pointers to <code>Polygon</code> (named <code>ppoly1</code> and <code>ppoly2</code>). These are assigned the addresses of <code>rect</code> and <code>trgl</code>, respectively, which are objects of type <code>Rectangle</code> and <code>Triangle</code>. Such assignments are valid, since both <code>Rectangle</code> and <code>Triangle</code> are classes derived from <code>Polygon</code>.<br>
<br>
Dereferencing <code>ppoly1</code> and <code>ppoly2</code> (with <code>*ppoly1</code> and <code>*ppoly2</code>) is valid and allows us to access the members of their pointed objects. For example, the following two statements would be equivalent in the previous example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>ppoly1-&gt;set_values (4,5);
rect.set_values (4,5);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But because the type of <code>ppoly1</code> and <code>ppoly2</code> is pointer to <code>Polygon</code> (and not pointer to <code>Rectangle</code> nor pointer to <code>Triangle</code>), only the members inherited from <code>Polygon</code> can be accessed, and not those of the derived classes <code>Rectangle</code> and <code>Triangle</code>. That is why the program above accesses the <code>area</code> members of both objects using <code>rect</code> and <code>trgl</code> directly, instead of the pointers; the pointers to the base class cannot access the <code>area</code> members.<br>
<br>
Member <code>area</code> could have been accessed with the pointers to <code>Polygon</code> if <code>area</code> were a member of <code>Polygon</code> instead of a member of its derived classes, but the problem is that <code>Rectangle</code> and <code>Triangle</code> implement different versions of <code>area</code>, therefore there is not a single common version that could be implemented in the base class. <br>
</section>
<br>
<section id="virtual_members">
<h3>Virtual members</h3>
A virtual member is a member function that can be redefined in a derived class, while preserving its calling properties through references. The syntax for a function to become virtual is to precede its declaration with the <code>virtual</code> keyword:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br></code></pre></td>
<td class="source"><pre><code><cite>// virtual members</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b; }
    <var>virtual</var> <var>int</var> area ()
      { <var>return</var> 0; }
};

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area ()
      { <var>return</var> width * height; }
};

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area ()
      { <var>return</var> (width * height / 2); }
};

<var>int</var> main () {
  Rectangle rect;
  Triangle trgl;
  Polygon poly;
  Polygon * ppoly1 = &amp;rect;
  Polygon * ppoly2 = &amp;trgl;
  Polygon * ppoly3 = &amp;poly;
  ppoly1-&gt;set_values (4,5);
  ppoly2-&gt;set_values (4,5);
  ppoly3-&gt;set_values (4,5);
  cout &lt;&lt; ppoly1-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; ppoly2-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; ppoly3-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10
0</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, all three classes (<code>Polygon</code>, <code>Rectangle</code> and <code>Triangle</code>) have the same members: <code>width</code>, <code>height</code>, and functions <code>set_values</code> and <code>area</code>.<br>
<br>
The member function <code>area</code> has been declared as <code>virtual</code> in the base class because it is later redefined in each of the derived classes. Non-virtual members can also be redefined in derived classes, but non-virtual members of derived classes cannot be accessed through a reference of the base class: i.e., if <code>virtual</code> is removed from the declaration of <code>area</code> in the example above, all three calls to <code>area</code> would return zero, because in all cases, the version of the base class would have been called instead.<br>
<br>
Therefore, essentially, what the <code>virtual</code> keyword does is to allow a member of a derived class with the same name as one in the base class to be appropriately called from a pointer, and more precisely when the type of the pointer is a pointer to the base class that is pointing to an object of the derived class, as in the above example.<br>
<br>
A class that declares or inherits a virtual function is called a <i>polymorphic class</i>.<br>
<br>
Note that despite of the virtuality of one of its members, <code>Polygon</code> was a regular class, of which even an object was instantiated (<code>poly</code>), with its own definition of member <code>area</code> that always returns 0.<br>
</section>
<br>
<section id="abstract_base_classes">
<h3>Abstract base classes</h3>
Abstract base classes are something very similar to the <code>Polygon</code> class in the previous example. They are classes that can only be used as base classes, and thus are allowed to have virtual member functions without definition (known as pure virtual functions). The syntax is to replace their definition by <code>=0</code> (an equal sign and a zero):<br>
<br>
An abstract base <code>Polygon</code> class could look like this:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></code></pre></td>
<td class="source"><pre><code><cite>// abstract class CPolygon</cite>
<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b; }
    <var>virtual</var> <var>int</var> area () =0;
};</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that <code>area</code> has no definition; this has been replaced by <code>=0</code>, which makes it a <i>pure virtual function</i>. Classes that contain at least one <i>pure virtual function</i> are  known as <i>abstract base classes</i>.<br>
<br>
Abstract base classes cannot be used to instantiate objects. Therefore, this last abstract base class version of <code>Polygon</code> could not be used to declare objects like:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>Polygon mypolygon;   <cite>// not working if Polygon is abstract base class </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
But an <i>abstract base class</i> is not totally useless. It can be used to create pointers to it, and take advantage of all its polymorphic abilities. For example, the following pointer declarations would be valid:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Polygon * ppoly1;
Polygon * ppoly2;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
And can actually be dereferenced when pointing to objects of derived (non-abstract) classes. Here is the entire example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br></code></pre></td>
<td class="source"><pre><code><cite>// abstract base class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b; }
    <var>virtual</var> <var>int</var> area (<var>void</var>) =0;
};

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area (<var>void</var>)
      { <var>return</var> (width * height); }
};

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area (<var>void</var>)
      { <var>return</var> (width * height / 2); }
};

<var>int</var> main () {
  Rectangle rect;
  Triangle trgl;
  Polygon * ppoly1 = &amp;rect;
  Polygon * ppoly2 = &amp;trgl;
  ppoly1-&gt;set_values (4,5);
  ppoly2-&gt;set_values (4,5);
  cout &lt;&lt; ppoly1-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  cout &lt;&lt; ppoly2-&gt;area() &lt;&lt; <kbd>'\n'</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, objects of different but related types are referred to using a unique type of pointer (<code>Polygon*</code>) and the proper member function is called every time, just because they are virtual. This can be really useful in some circumstances. For example, it is even possible for a member of the abstract base class <code>Polygon</code> to use the special pointer <code>this</code> to access the proper virtual members, even though <code>Polygon</code> itself has no implementation for this function:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br></code></pre></td>
<td class="source"><pre><code><cite>// pure virtual members can be called</cite>
<cite>// from the abstract base class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    <var>void</var> set_values (<var>int</var> a, <var>int</var> b)
      { width=a; height=b; }
    <var>virtual</var> <var>int</var> area() =0;
    <var>void</var> printarea()
      { cout &lt;&lt; <var>this</var>-&gt;area() &lt;&lt; <kbd>'\n'</kbd>; }
};

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area (<var>void</var>)
      { <var>return</var> (width * height); }
};

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    <var>int</var> area (<var>void</var>)
      { <var>return</var> (width * height / 2); }
};

<var>int</var> main () {
  Rectangle rect;
  Triangle trgl;
  Polygon * ppoly1 = &amp;rect;
  Polygon * ppoly2 = &amp;trgl;
  ppoly1-&gt;set_values (4,5);
  ppoly2-&gt;set_values (4,5);
  ppoly1-&gt;printarea();
  ppoly2-&gt;printarea();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Virtual members and abstract classes grant C++ polymorphic characteristics, most useful for object-oriented projects. Of course, the examples above are very simple use cases, but these features can be applied to arrays of objects or dynamically allocated objects.<br>
<br>
Here is an example that combines some of the features in the latest chapters, such as dynamic memory, constructor initializers and polymorphism:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br></code></pre></td>
<td class="source"><pre><code><cite>// dynamic allocation and polymorphism</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Polygon {
  <var>protected</var>:
    <var>int</var> width, height;
  <var>public</var>:
    Polygon (<var>int</var> a, <var>int</var> b) : width(a), height(b) {}
    <var>virtual</var> <var>int</var> area (<var>void</var>) =0;
    <var>void</var> printarea()
      { cout &lt;&lt; <var>this</var>-&gt;area() &lt;&lt; <kbd>'\n'</kbd>; }
};

<var>class</var> Rectangle: <var>public</var> Polygon {
  <var>public</var>:
    Rectangle(<var>int</var> a,<var>int</var> b) : Polygon(a,b) {}
    <var>int</var> area()
      { <var>return</var> width*height; }
};

<var>class</var> Triangle: <var>public</var> Polygon {
  <var>public</var>:
    Triangle(<var>int</var> a,<var>int</var> b) : Polygon(a,b) {}
    <var>int</var> area()
      { <var>return</var> width*height/2; }
};

<var>int</var> main () {
  Polygon * ppoly1 = <var>new</var> Rectangle (4,5);
  Polygon * ppoly2 = <var>new</var> Triangle (4,5);
  ppoly1-&gt;printarea();
  ppoly2-&gt;printarea();
  <var>delete</var> ppoly1;
  <var>delete</var> ppoly2;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>20
10</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice that the <code>ppoly</code> pointers:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Polygon * ppoly1 = <var>new</var> Rectangle (4,5);
Polygon * ppoly2 = <var>new</var> Triangle (4,5);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
are declared being of type "pointer to <code>Polygon</code>", but the objects allocated have been declared having the derived class type directly (<code>Rectangle</code> and <code>Triangle</code>).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/inheritance/" rel="prev">Previous:<br><b>Friendship and inheritance</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/typecasting/" rel="next">Next:<br><b>Type conversions</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Type conversions</h2>
<section id="implicit_conversion">
<h3>Implicit conversion</h3>
Implicit conversions are automatically performed when a value is copied to a compatible type. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><var>short</var> a=2000;
<var>int</var> b;
b=a;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Here, the value of <code>a</code> is promoted from <code>short</code> to <code>int</code> without the need of any explicit operator. This is known as a <i>standard conversion</i>. Standard conversions affect fundamental data types, and allow the conversions between numerical types (<code>short</code> to <code>int</code>, <code>int</code> to <code>float</code>, <code>double</code> to <code>int</code>...), to or from <code>bool</code>, and some pointer conversions.<br>
<br>
Converting to <code>int</code> from some smaller integer type, or to <code>double</code> from <code>float</code> is known as <i>promotion</i>, and is guaranteed to produce the exact same value in the destination type. Other conversions between arithmetic types may not always be able to represent the same value exactly:<br>
<ul>
<li>If a negative integer value is converted to an unsigned type, the resulting value corresponds to its 2's complement bitwise representation (i.e., <code>-1</code> becomes the largest value representable by the type, <code>-2</code> the second largest, ...).</li>
<li>The conversions from/to <code>bool</code> consider <code>false</code> equivalent to <i>zero</i> (for numeric types) and to <i>null pointer</i> (for pointer types); <code>true</code> is equivalent to all other values and is converted to the equivalent of <code>1</code>.</li>
<li>If the conversion is from a floating-point type to an integer type, the value is truncated (the decimal part is removed). If the result lies outside the range of representable values by the type, the conversion causes <i>undefined behavior</i>.</li>
<li>Otherwise, if the conversion is between numeric types of the same kind (integer-to-integer or floating-to-floating), the conversion is valid, but the value is <i>implementation-specific</i> (and may not be portable).</li>
</ul>
<br>
Some of these conversions may imply a loss of precision, which the compiler can signal with a warning. This warning can be avoided with an explicit conversion.<br>
<br>
For non-fundamental types, arrays and functions implicitly convert to pointers, and pointers in general allow the following conversions:<br>
<ul>
<li><i>Null pointers</i> can be converted to pointers of any type</li>
<li>Pointers to any type can be converted to <code>void</code> pointers.</li>
<li>Pointer <i>upcast</i>: pointers to a derived class can be converted to a pointer of an <i>accessible</i> and <i>unambiguous</i> base class, without modifying its <code>const</code> or <code>volatile</code> qualification.<br>
</ul>
</section>
<br>
<section id="implicit_in_classes">
<h3>Implicit conversions with classes</h3>
In the world of classes, implicit conversions can be controlled by means of three member functions:<br>
<ul>
<li><b>Single-argument constructors:</b> allow implicit conversion from a particular type to initialize an object.</li>
<li><b>Assignment operator:</b> allow implicit conversion from a particular type on assignments.</li>
<li><b>Type-cast operator:</b> allow implicit conversion to a particular type.</li>
</ul>
<br>
For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// implicit conversion of classes:</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> A {};

<var>class</var> B {
<var>public</var>:
  <cite>// conversion from A (constructor):</cite>
  B (<var>const</var> A&amp; x) {}
  <cite>// conversion from A (assignment):</cite>
  B&amp; <var>operator</var>= (<var>const</var> A&amp; x) {<var>return</var> *<var>this</var>;}
  <cite>// conversion to A (type-cast operator)</cite>
  <var>operator</var> A() {<var>return</var> A();}
};

<var>int</var> main ()
{
  A foo;
  B bar = foo;    <cite>// calls constructor</cite>
  bar = foo;      <cite>// calls assignment</cite>
  foo = bar;      <cite>// calls type-cast operator</cite>
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp> </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The type-cast operator uses a particular syntax: it uses the <code>operator</code> keyword followed by the destination type and an empty set of parentheses. Notice that the return type is the destination type and thus is not specified before the <code>operator</code> keyword.<br>
</section>
<br>
<section id="explicit">
<h3>Keyword explicit</h3>
On a function call, C++ allows one implicit conversion to happen for each argument. This may be somewhat problematic for classes, because it is not always what is intended. For example, if we add the following function to the last example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>void</var> fn (B arg) {}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This function takes an argument of type <code>B</code>, but it could as well be called with an object of type <code>A</code> as argument:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>fn (foo);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This may or may not be what was intended. But, in any case, it can be prevented by marking the affected constructor with the <code>explicit</code> keyword:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br></code></pre></td>
<td class="source"><pre><code><cite>// explicit:</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> A {};

<var>class</var> B {
<var>public</var>:
  <var>explicit</var> B (<var>const</var> A&amp; x) {}
  B&amp; <var>operator</var>= (<var>const</var> A&amp; x) {<var>return</var> *<var>this</var>;}
  <var>operator</var> A() {<var>return</var> A();}
};

<var>void</var> fn (B x) {}

<var>int</var> main ()
{
  A foo;
  B bar (foo);
  bar = foo;
  foo = bar;
  
<cite>//  fn (foo);  // not allowed for explicit ctor.</cite>
  fn (bar);  

  <var>return</var> 0;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Additionally, constructors marked with <code>explicit</code> cannot be called with the assignment-like syntax; In the above example, <code>bar</code> could not have been constructed with:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>B bar = foo;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Type-cast member functions (those described in the previous section) can also be specified as <code>explicit</code>. This prevents implicit conversions in the same way as <code>explicit</code>-specified constructors do for the destination type.<br>
</section>
<br>
<section id="type_casting">
<h3>Type casting</h3>
C++ is a strong-typed language. Many conversions, specially those that imply a different interpretation of the value, require an explicit conversion, known in C++ as <i>type-casting</i>. There exist two main syntaxes for generic type-casting: <i>functional</i> and <i>c-like</i>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>double</var> x = 10.3;
<var>int</var> y;
y = <var>int</var> (x);    <cite>// functional notation</cite>
y = (<var>int</var>) x;    <cite>// c-like cast notation </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The functionality of these generic forms of type-casting is enough for most needs with fundamental data types. However, these operators can be applied indiscriminately on classes and pointers to classes, which can lead to code that -while being syntactically correct- can cause runtime errors. For example, the following code compiles without errors: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// class type-casting</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Dummy {
    <var>double</var> i,j;
};

<var>class</var> Addition {
    <var>int</var> x,y;
  <var>public</var>:
    Addition (<var>int</var> a, <var>int</var> b) { x=a; y=b; }
    <var>int</var> result() { <var>return</var> x+y;}
};

<var>int</var> main () {
  Dummy d;
  Addition * padd;
  padd = (Addition*) &amp;d;
  cout &lt;&lt; padd-&gt;result();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp> </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The program declares a pointer to <code>Addition</code>, but then it assigns to it a reference to an object of another unrelated type using explicit type-casting:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>padd = (Addition*) &amp;d;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Unrestricted explicit type-casting allows to convert any pointer into any other pointer type, independently of the types they point to. The subsequent call to member <code>result</code> will produce either a run-time error or some other unexpected results.<br>
<br>
In order to control these types of conversions between classes, we have four specific casting operators: <code>dynamic_cast</code>, <code>reinterpret_cast</code>, <code>static_cast</code> and <code>const_cast</code>. Their format is to follow the new type enclosed between angle-brackets (<code>&lt;&gt;</code>) and immediately after, the expression to be converted between parentheses.<br>
<br>
<code>
dynamic_cast &lt;new_type&gt; (expression)<br>
reinterpret_cast &lt;new_type&gt; (expression)<br>
static_cast &lt;new_type&gt; (expression)<br>
const_cast &lt;new_type&gt; (expression)<br>
</code>
<br>
The traditional type-casting equivalents to these expressions would be:<br>
 <br>
<code>
(new_type) expression<br>
new_type (expression)<br>
</code>
<br>
but each one with its own special characteristics:<br>
</section>
<br>
<section id="dynamic_cast">
<h3>dynamic_cast</h3>
<code>dynamic_cast</code> can only be used with pointers and references to classes (or with <code>void*</code>). Its purpose is to ensure that the result of the type conversion points to a valid complete object of the destination pointer type.<br>
<br>
This naturally includes <i>pointer upcast</i> (converting from pointer-to-derived to pointer-to-base), in the same way as allowed as an <i>implicit conversion</i>.<br>
<br>
But <code>dynamic_cast</code> can also <i>downcast</i> (convert from pointer-to-base to pointer-to-derived) polymorphic classes (those with virtual members) if -and only if- the pointed object is a valid complete object of the target type. For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br></code></pre></td>
<td class="source"><pre><code><cite>// dynamic_cast</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Base { <var>virtual</var> <var>void</var> dummy() {} };
<var>class</var> Derived: <var>public</var> Base { <var>int</var> a; };

<var>int</var> main () {
  <var>try</var> {
    Base * pba = <var>new</var> Derived;
    Base * pbb = <var>new</var> Base;
    Derived * pd;

    pd = <var>dynamic_cast</var>&lt;Derived*&gt;(pba);
    <var>if</var> (pd==0) cout &lt;&lt; <kbd>"Null pointer on first type-cast.\n"</kbd>;

    pd = <var>dynamic_cast</var>&lt;Derived*&gt;(pbb);
    <var>if</var> (pd==0) cout &lt;&lt; <kbd>"Null pointer on second type-cast.\n"</kbd>;

  } <var>catch</var> (exception&amp; e) {cout &lt;&lt; <kbd>"Exception: "</kbd> &lt;&lt; e.what();}
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>Null pointer on second type-cast.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<table class="boxed"><tr><td>
<b>Compatibility note:</b> This type of <code>dynamic_cast</code> requires <i>Run-Time Type Information (RTTI)</i> to keep track of dynamic types. Some compilers support this feature as an option which is disabled by default. This needs to be enabled for runtime type checking using <code>dynamic_cast</code> to work properly with these types.<br>
</td></tr></table>
<br>
The code above tries to perform two dynamic casts from pointer objects of type <code>Base*</code> (<code>pba</code> and <code>pbb</code>) to a pointer object of type <code>Derived*</code>, but only the first one is successful. Notice their respective initializations:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>Base * pba = <var>new</var> Derived;
Base * pbb = <var>new</var> Base;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Even though both are pointers of type <code>Base*</code>, <code>pba</code> actually points to an object of type <code>Derived</code>, while <code>pbb</code> points to an object of type <code>Base</code>. Therefore, when their respective type-casts are performed using <code>dynamic_cast</code>, <code>pba</code> is pointing to a full object of class <code>Derived</code>, whereas <code>pbb</code> is pointing to an object of class <code>Base</code>, which is an incomplete object of class <code>Derived</code>.<br>
 <br>
When <code>dynamic_cast</code> cannot cast a pointer because it is not a complete object of the required class -as in the second conversion in the previous example- it returns a <i>null pointer</i> to indicate the failure. If <code>dynamic_cast</code> is used to convert to a reference type and the conversion is not possible, an exception of type <code>bad_cast</code> is thrown instead.<br>
<br>
<code>dynamic_cast</code> can also perform the other implicit casts allowed on pointers: casting null pointers between pointers types (even between unrelated classes), and casting any pointer of any type to a <code>void*</code> pointer.<br>
</section>
<br>
<section id="static_cast">
<h3>static_cast</h3>
<code>static_cast</code> can perform conversions between pointers to related classes, not only <i>upcasts</i> (from pointer-to-derived to pointer-to-base), but also <i>downcasts</i> (from pointer-to-base to pointer-to-derived). No checks are performed during runtime to guarantee that the object being converted is in fact a full object of the destination type. Therefore, it is up to the programmer to ensure that the conversion is safe. On the other side, it does not incur the overhead of the type-safety checks of <code>dynamic_cast</code>.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>class</var> Base {};
<var>class</var> Derived: <var>public</var> Base {};
Base * a = <var>new</var> Base;
Derived * b = <var>static_cast</var>&lt;Derived*&gt;(a);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would be valid code, although <code>b</code> would point to an incomplete object of the class and could lead to runtime errors if dereferenced.<br>
<br>
Therefore, <code>static_cast</code> is able to perform with pointers to classes not only the conversions allowed implicitly, but also their opposite conversions.<br>
<br>
<code>static_cast</code> is also able to perform all conversions allowed implicitly (not only those with pointers to classes), and is also able to perform the opposite of these. It can:<br>
<ul>
<li>Convert from <code>void*</code> to any pointer type. In this case, it guarantees that if the <code>void*</code> value was obtained by converting from that same pointer type, the resulting pointer value is the same.</li>
<li>Convert integers, floating-point values and enum types to enum types.</li>
</ul>
<br>
Additionally, <code>static_cast</code> can also perform the following:<br>
<ul>
<li>Explicitly call a single-argument constructor or a conversion operator.</li>
<li>Convert to <i>rvalue references</i>.</li>
<li>Convert <code>enum class</code> values into integers or floating-point values.</li>
<li>Convert any type to <code>void</code>, evaluating and discarding the value.</li>
</ul>
</section>
<br>
<section id="reinterpret_cast">
<h3>reinterpret_cast</h3>
<code>reinterpret_cast</code> converts any pointer type to any other pointer type, even of unrelated classes. The operation result is a simple binary copy of the value from one pointer to the other. All pointer conversions are allowed: neither the content pointed nor the pointer type itself is checked.<br>
<br>
It can also cast pointers to or from integer types. The format in which this integer value represents a pointer is platform-specific. The only guarantee is that a pointer cast to an integer type large enough to fully contain it (such as <code><a href="/intptr_t">intptr_t</a></code>), is guaranteed to be able to be cast back to a valid pointer.<br>
<br>
The conversions that can be performed by <code>reinterpret_cast</code> but not by <code>static_cast</code> are low-level operations based on reinterpreting the binary representations of the types, which on most cases results in code which is system-specific, and thus non-portable. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><var>class</var> A { <cite>/* ... */</cite> };
<var>class</var> B { <cite>/* ... */</cite> };
A * a = <var>new</var> A;
B * b = <var>reinterpret_cast</var>&lt;B*&gt;(a);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This code compiles, although it does not make much sense, since now <code>b</code> points to an object of a totally unrelated and likely incompatible class. Dereferencing <code>b</code> is unsafe.<br>
</section>
<br>
<section id="const_cast">
<h3>const_cast</h3>
This type of casting manipulates the constness of the object pointed by a pointer, either to be set or to be removed. For example, in order to pass a const pointer to a function that expects a non-const argument:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// const_cast</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>void</var> print (<var>char</var> * str)
{
  cout &lt;&lt; str &lt;&lt; <kbd>'\n'</kbd>;
}

<var>int</var> main () {
  <var>const</var> <var>char</var> * c = <kbd>"sample text"</kbd>;
  print ( <var>const_cast</var>&lt;<var>char</var> *&gt; (c) );
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>sample text</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The example above is guaranteed to work because function <code>print</code> does not write to the pointed object. Note though, that removing the constness of a pointed object to actually write to it causes <i>undefined behavior</i>.<br>
</section>
<br>
<section id="typeid">
<h3>typeid</h3>
<code>typeid</code> allows to check the type of an expression: <br>
<br>
<code>
typeid (expression)<br>
</code>
<br>
This operator returns a reference to a constant object of type <code><a href="/type_info">type_info</a></code> that is defined in the standard header <code><a href="/&lt;typeinfo&gt;">&lt;typeinfo&gt;</a></code>. A value returned by <code>typeid</code> can be compared with another value returned by <code>typeid</code> using operators <code>==</code> and <code>!=</code> or can serve to obtain a null-terminated character sequence representing the data type or class name by using its <code>name()</code> member.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// typeid</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;typeinfo&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>int</var> * a,b;
  a=0; b=0;
  <var>if</var> (<var>typeid</var>(a) != <var>typeid</var>(b))
  {
    cout &lt;&lt; <kbd>"a and b are of different types:\n"</kbd>;
    cout &lt;&lt; <kbd>"a is: "</kbd> &lt;&lt; <var>typeid</var>(a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"b is: "</kbd> &lt;&lt; <var>typeid</var>(b).name() &lt;&lt; <kbd>'\n'</kbd>;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>a and b are of different types:
a is: int *
b is: int  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
When <code>typeid</code> is applied to classes, <code>typeid</code> uses the RTTI to keep track of the type of dynamic objects. When <code>typeid</code> is applied to an expression whose type is a polymorphic class, the result is the type of the most derived complete object:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br></code></pre></td>
<td class="source"><pre><code><cite>// typeid, polymorphic class</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;typeinfo&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> Base { <var>virtual</var> <var>void</var> f(){} };
<var>class</var> Derived : <var>public</var> Base {};

<var>int</var> main () {
  <var>try</var> {
    Base* a = <var>new</var> Base;
    Base* b = <var>new</var> Derived;
    cout &lt;&lt; <kbd>"a is: "</kbd> &lt;&lt; <var>typeid</var>(a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"b is: "</kbd> &lt;&lt; <var>typeid</var>(b).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"*a is: "</kbd> &lt;&lt; <var>typeid</var>(*a).name() &lt;&lt; <kbd>'\n'</kbd>;
    cout &lt;&lt; <kbd>"*b is: "</kbd> &lt;&lt; <var>typeid</var>(*b).name() &lt;&lt; <kbd>'\n'</kbd>;
  } <var>catch</var> (exception&amp; e) { cout &lt;&lt; <kbd>"Exception: "</kbd> &lt;&lt; e.what() &lt;&lt; <kbd>'\n'</kbd>; }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>a is: class Base *
b is: class Base *
*a is: class Base
*b is: class Derived</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<i>Note: The string returned by member <code>name</code> of <code><a href="/type_info">type_info</a></code> depends on the specific implementation of your compiler and library. It is not necessarily a simple string with its typical type name, like in the compiler used to produce this output.</i> <br>
<br>
Notice how the type that <code>typeid</code> considers for pointers is the pointer type itself (both <code>a</code> and <code>b</code> are of type <code>class Base *</code>). However, when <code>typeid</code> is applied to objects (like <code>*a</code> and <code>*b</code>) <code>typeid</code> yields their dynamic type (i.e. the type of their most derived complete object).<br>
<br>
If the type <code>typeid</code> evaluates is a pointer preceded by the dereference operator (<code>*</code>), and this pointer has a null value, <code>typeid</code> throws a <code><a href="/bad_typeid">bad_typeid</a></code> exception.<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/polymorphism/" rel="prev">Previous:<br><b>Polymorphism</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/exceptions/" rel="next">Next:<br><b>Exceptions</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Exceptions</h2>
<section id="exceptions">
Exceptions provide a way to react to exceptional circumstances (like runtime errors) in programs by transferring control to special functions called <i>handlers</i>.<br>
<br>
To catch exceptions, a portion of code is placed under exception inspection. This is done by enclosing that portion of code in a <i>try-block</i>. When an exceptional circumstance arises within that block, an exception is thrown that transfers the control to the exception handler. If no exception is thrown, the code continues normally and all handlers are ignored.<br>
<br>
An exception is thrown by using the <code>throw</code> keyword from inside the <code>try</code> block. Exception handlers are declared with the keyword <code>catch</code>, which must be placed immediately after the <code>try</code> block:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><cite>// exceptions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>try</var>
  {
    <var>throw</var> 20;
  }
  <var>catch</var> (<var>int</var> e)
  {
    cout &lt;&lt; <kbd>"An exception occurred. Exception Nr. "</kbd> &lt;&lt; e &lt;&lt; <kbd>'\n'</kbd>;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>An exception occurred. Exception Nr. 20</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The code under exception handling is enclosed in a <code>try</code> block. In this example this code simply throws an exception:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>throw</var> 20;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
A <code>throw</code> expression accepts one parameter (in this case the integer value <code>20</code>), which is passed as an argument to the exception handler.<br>
<br>
The exception handler is declared with the <code>catch</code> keyword immediately after the closing brace of the <code>try</code> block. The syntax for <code>catch</code> is similar to a regular function with one parameter. The type of this parameter is very important, since the type of the argument passed by the <code>throw</code> expression is checked against it, and only in the case they match, the exception is caught by that handler.<br>
<br>
Multiple handlers (i.e., <code>catch</code> expressions) can be chained; each one with a different parameter type. Only the handler whose argument type matches the type of the exception specified in the <code>throw</code> statement is executed.<br>
<br>
If an ellipsis (<code>...</code>) is used as the parameter of <code>catch</code>, that handler will catch any exception no matter what the type of the exception thrown. This can be used as a default handler that catches all exceptions not caught by other handlers:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br></code></pre></td>
<td class="source"><pre><code><var>try</var> {
  <cite>// code here</cite>
}
<var>catch</var> (<var>int</var> param) { cout &lt;&lt; <kbd>"int exception"</kbd>; }
<var>catch</var> (<var>char</var> param) { cout &lt;&lt; <kbd>"char exception"</kbd>; }
<var>catch</var> (...) { cout &lt;&lt; <kbd>"default exception"</kbd>; }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the last handler would catch any exception thrown of a type that is neither <code>int</code> nor <code>char</code>.<br>
<br>
After an exception has been handled the program, execution resumes after the <i>try-catch</i> block, not after the <code>throw</code> statement!.<br>
<br>
It is also possible to nest <code>try-catch</code> blocks within more external <code>try</code> blocks. In these cases, we have the possibility that an internal <code>catch</code> block forwards the exception to its external level. This is done with the expression <code>throw;</code> with no arguments. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br></code></pre></td>
<td class="source"><pre><code><var>try</var> {
  <var>try</var> {
      <cite>// code here</cite>
  }
  <var>catch</var> (<var>int</var> n) {
      <var>throw</var>;
  }
}
<var>catch</var> (...) {
  cout &lt;&lt; <kbd>"Exception occurred"</kbd>;
}</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="exception_specification">
<h3>Exception specification</h3>
Older code may contain <i>dynamic exception specifications</i>. They are now deprecated in C++, but still supported. A <i>dynamic exception specification</i> follows the declaration of a function, appending a <code>throw</code> specifier to it. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>double</var> myfunction (<var>char</var> param) <var>throw</var> (<var>int</var>);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This declares a function called <code>myfunction</code>, which takes one argument of type <code>char</code> and returns a value of type <code>double</code>. If this function throws an exception of some type other than <code>int</code>, the function calls <samp><a href="/unexpected">std::unexpected</a></samp> instead of looking for a handler or calling <samp><a href="/terminate">std::terminate</a></samp>.<br>
<br>
If this <code>throw</code> specifier is left empty with no type, this means that <samp><a href="/unexpected">std::unexpected</a></samp> is called for any exception. Functions with no <code>throw</code> specifier (regular functions) never call <samp><a href="/unexpected">std::unexpected</a></samp>, but follow the normal path of looking for their exception handler.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> myfunction (<var>int</var> param) <var>throw</var>(); <cite>// all exceptions call unexpected</cite>
<var>int</var> myfunction (<var>int</var> param);         <cite>// normal exception handling </cite></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="standard_exceptions">
<h3>Standard exceptions</h3>
The C++ Standard library provides a base class specifically designed to declare objects to be thrown as exceptions. It is called <code><a href="/exception">std::exception</a></code> and is defined in the <code><a href="/&lt;exception&gt;">&lt;exception&gt;</a></code> header. This class has a virtual member function called <code>what</code> that returns a null-terminated character sequence (of type <code>char *</code>) and that can be overwritten in derived classes to contain some sort of description of the exception.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br></code></pre></td>
<td class="source"><pre><code><cite>// using standard exceptions</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>class</var> myexception: <var>public</var> exception
{
  <var>virtual</var> <var>const</var> <var>char</var>* what() <var>const</var> <var>throw</var>()
  {
    <var>return</var> <kbd>"My exception happened"</kbd>;
  }
} myex;

<var>int</var> main () {
  <var>try</var>
  {
    <var>throw</var> myex;
  }
  <var>catch</var> (exception&amp; e)
  {
    cout &lt;&lt; e.what() &lt;&lt; <kbd>'\n'</kbd>;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>My exception happened.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
We have placed a handler that catches exception objects by reference (notice the ampersand <code>&</code> after the type), therefore this catches also classes derived from <code>exception</code>, like our <code>myex</code> object of type <code>myexception</code>.<br>
<br>
All exceptions thrown by components of the C++ Standard library throw exceptions derived from this <code>exception</code> class. These are:<br>
<br>
<table class="boxed">
<tr><th>exception</th><th>description</th></tr>
<tr><td><code><a href="/bad_alloc">bad_alloc</a></code></td><td>thrown by <code>new</code> on allocation failure</td></tr>
<tr><td><code><a href="/bad_cast">bad_cast</a></code></td><td>thrown by <code>dynamic_cast</code> when it fails in a dynamic cast</td></tr>
<tr><td><code><a href="/bad_exception">bad_exception</a></code></td><td>thrown by certain dynamic exception specifiers</td></tr>
<tr><td><code><a href="/bad_typeid">bad_typeid</a></code></td><td>thrown by <code>typeid</code></td></tr>
<tr><td><code><a href="/bad_function_call">bad_function_call</a></code></td><td>thrown by empty <code><a href="/function">function</a></code> objects</td></tr>
<tr><td><code><a href="/bad_weak_ptr">bad_weak_ptr</a></code></td><td>thrown by <code><a href="/shared_ptr">shared_ptr</a></code> when passed a bad <code><a href="/weak_ptr">weak_ptr</a></code></td></tr>
</table>
<br>
Also deriving from <code>exception</code>, header <code><a href="/&lt;exception&gt;">&lt;exception&gt;</a></code> defines two generic exception types that can be inherited by custom exceptions to report errors:<br>
<br>
<table class="boxed">
<tr><th>exception</th><th>description</th></tr>
<tr><td><code><a href="/logic_error">logic_error</a></code></td><td>error related to the internal logic of the program</td></tr>
<tr><td><code><a href="/runtime_error">runtime_error</a></code></td><td>error detected during runtime</td></tr>
</table>
<br>
A typical example where standard exceptions need to be checked for is on memory allocation:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// bad_alloc standard exception</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;exception&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  <var>try</var>
  {
    <var>int</var>* myarray= <var>new</var> <var>int</var>[1000];
  }
  <var>catch</var> (exception&amp; e)
  {
    cout &lt;&lt; <kbd>"Standard exception: "</kbd> &lt;&lt; e.what() &lt;&lt; endl;
  }
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp> </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The exception that may be caught by the exception handler in this example is a <code>bad_alloc</code>. Because <code>bad_alloc</code> is derived from the standard base class <code>exception</code>, it can be caught (capturing by reference, captures all related classes).<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/typecasting/" rel="prev">Previous:<br><b>Type conversions</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/preprocessor/" rel="next">Next:<br><b>Preprocessor directives</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Preprocessor directives</h2>
<section id="description">
Preprocessor directives are lines included in the code of programs preceded by a hash sign (<code>#</code>). These lines are not program statements but directives for the <i>preprocessor</i>. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.<br>
<br>
These <i>preprocessor directives</i> extend only across a single line of code. As soon as a newline character is found, the preprocessor directive is ends. No semicolon (<code>;</code>) is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash (<code>\</code>).<br>
</section>
<br>
<section id="define_undef">
<h3>macro definitions (#define, #undef)</h3>
To define preprocessor macros we can use <code>#define</code>. Its syntax is:<br>
<br>
<code>
#define identifier replacement<br>
</code>
<br>
When the preprocessor encounters this directive, it replaces any occurrence of <code>identifier</code> in the rest of the code by <code>replacement</code>. This <code>replacement</code> can be an expression, a statement, a block or simply anything. The preprocessor does not understand C++ proper, it simply replaces any occurrence of <code>identifier</code> by <code>replacement</code>.<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><dfn>#define TABLE_SIZE 100</dfn>
<var>int</var> table1[TABLE_SIZE];
<var>int</var> table2[TABLE_SIZE]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
After the preprocessor has replaced <code>TABLE_SIZE</code>, the code becomes equivalent to:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> table1[100];
<var>int</var> table2[100]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>#define</code> can work also with parameters to define function macros:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><dfn>#define getmax(a,b) a&gt;b?a:b </dfn></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would replace any occurrence of <code>getmax</code> followed by two arguments by the replacement expression, but also replacing each argument by its identifier, exactly as you would expect if it was a function:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><cite>// function macro</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<dfn>#define getmax(a,b) ((a)&gt;(b)?(a):(b))</dfn>

<var>int</var> main()
{
  <var>int</var> x=5, y;
  y= getmax(x,2);
  cout &lt;&lt; y &lt;&lt; endl;
  cout &lt;&lt; getmax(7,x) &lt;&lt; endl;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>5
7</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Defined macros are not affected by block structure. A macro lasts until it is undefined with the <code>#undef</code> preprocessor directive:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br></code></pre></td>
<td class="source"><pre><code><dfn>#define TABLE_SIZE 100</dfn>
<var>int</var> table1[TABLE_SIZE];
<dfn>#undef TABLE_SIZE</dfn>
<dfn>#define TABLE_SIZE 200</dfn>
<var>int</var> table2[TABLE_SIZE];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would generate the same code as:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><var>int</var> table1[100];
<var>int</var> table2[200];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Function macro definitions accept two special operators (<code>#</code> and <code>##</code>) in the replacement sequence:<br>
The operator <code>#</code>, followed by a parameter name, is replaced by a string literal that contains the argument passed (as if enclosed between double quotes):<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><dfn>#define str(x) #x</dfn>
cout &lt;&lt; str(test);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would be translated into:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"test"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
The operator <code>##</code> concatenates two arguments leaving no blank spaces between them:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><dfn>#define glue(a,b) a ## b</dfn>
glue(c,out) &lt;&lt; <kbd>"test"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This would also be translated into:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>cout &lt;&lt; <kbd>"test"</kbd>;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Because preprocessor replacements happen before any C++ syntax check, macro definitions can be a tricky feature. But, be careful: code that relies heavily on complicated macros become less readable, since the syntax expected is on many occasions different from the normal expressions programmers expect in C++.<br>
</section>
<br>
<section id="conditional_inclusions">
<h3>Conditional inclusions (#ifdef, #ifndef, #if, #endif, #else and #elif)</h3>
<br>
These directives allow to include or discard part of the code of a program if a certain condition is met.<br>
<br>
<code>#ifdef</code> allows a section of a program to be compiled only if the macro that is specified as the parameter has been defined, no matter which its value is. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><dfn>#ifdef TABLE_SIZE</dfn>
<var>int</var> table[TABLE_SIZE];
<dfn>#endif  </dfn></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, the line of code <code>int table[TABLE_SIZE];</code> is only compiled if <code>TABLE_SIZE</code> was previously defined with <code>#define</code>, independently of its value. If it was not defined, that line will not be included in the program compilation.<br>
<br>
<code>#ifndef</code> serves for the exact opposite: the code between <code>#ifndef</code> and <code>#endif</code> directives is only compiled if the specified identifier has not been previously defined. For example:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br></code></pre></td>
<td class="source"><pre><code><dfn>#ifndef TABLE_SIZE</dfn>
<dfn>#define TABLE_SIZE 100</dfn>
<dfn>#endif</dfn>
<var>int</var> table[TABLE_SIZE];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this case, if when arriving at this piece of code, the <code>TABLE_SIZE</code> macro has not been defined yet, it would be defined to a value of 100. If it already existed it would keep its previous value since the <code>#define</code> directive would not be executed.<br>
<br>
The <code>#if</code>, <code>#else</code> and <code>#elif</code> (i.e., "else if") directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows <code>#if</code> or <code>#elif</code> can only evaluate constant expressions, including macro expressions. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></code></pre></td>
<td class="source"><pre><code><dfn>#if TABLE_SIZE&gt;200</dfn>
<dfn>#undef TABLE_SIZE</dfn>
<dfn>#define TABLE_SIZE 200</dfn>
 
<dfn>#elif TABLE_SIZE&lt;50</dfn>
<dfn>#undef TABLE_SIZE</dfn>
<dfn>#define TABLE_SIZE 50</dfn>
 
<dfn>#else</dfn>
<dfn>#undef TABLE_SIZE</dfn>
<dfn>#define TABLE_SIZE 100</dfn>
<dfn>#endif</dfn>
 
<var>int</var> table[TABLE_SIZE]; </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice how the entire structure of <code>#if</code>, <code>#elif</code> and <code>#else</code> chained directives ends with <code>#endif</code>.<br>
<br>
The behavior of <code>#ifdef</code> and <code>#ifndef</code> can also be achieved by using the special operators <code>defined</code> and <code>!defined</code> respectively in any <code>#if</code> or <code>#elif</code> directive:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br></code></pre></td>
<td class="source"><pre><code><dfn>#if defined ARRAY_SIZE</dfn>
<dfn>#define TABLE_SIZE ARRAY_SIZE</dfn>
<dfn>#elif !defined BUFFER_SIZE</dfn>
<dfn>#define TABLE_SIZE 128</dfn>
<dfn>#else</dfn>
<dfn>#define TABLE_SIZE BUFFER_SIZE</dfn>
<dfn>#endif </dfn></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<section>
<br>
<section id="line_control">
<h3>Line control (#line)</h3>
When we compile a program and some error happens during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a line number, so it is easier to find the code generating the error.<br>
<br>
The <code>#line</code> directive allows us to control both things, the line numbers within the code files as well as the file name that we want that appears when an error takes place. Its format is: <br>
<br>
<code>
#line number "filename"<br>
</code>
<br>
Where <code>number</code> is the new line number that will be assigned to the next code line. The line numbers of successive lines will be increased one by one from this point on.<br>
<br>
<code>"filename"</code> is an optional parameter that allows to redefine the file name that will be shown. For example: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><dfn>#line 20 "assigning variable"</dfn>
<var>int</var> a?;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This code will generate an error that will be shown as error in file <code>"assigning variable"</code>, line 20.<br>
</section>
<br>
<section id="error_directive">
<h3>Error directive (#error)</h3>
This directive aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code><dfn>#ifndef __cplusplus</dfn>
<dfn>#error A C++ compiler is required!</dfn>
<dfn>#endif </dfn></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This example aborts the compilation process if the macro name <code>__cplusplus</code> is not defined (this macro name is defined by default in all C++ compilers).<br>
</section>
<br>
<section id="include">
<h3>Source file inclusion (#include)</h3>
This directive has been used assiduously in other sections of this tutorial. When the preprocessor finds an <code>#include</code> directive it replaces it by the entire content of the specified header or file. There are two ways to use <code>#include</code>: <br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code><dfn>#include &lt;header&gt;</dfn>
<dfn>#include "file" </dfn></code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In the first case, a <i>header</i> is specified between angle-brackets <code>&lt;&gt;</code>. This is used to include headers provided by the implementation, such as the headers that compose the standard library (<code>iostream</code>, <code>string</code>,...). Whether the headers are actually files or exist in some other form is <i>implementation-defined</i>, but in any case they shall be properly included with this directive.<br>
<br>
The syntax used in the second <code>#include</code> uses quotes, and includes a <i>file</i>. The <i>file</i> is searched for in an <i>implementation-defined</i> manner, which generally includes the current path. In the case that the file is not found, the compiler interprets the directive as a <i>header</i> inclusion, just as if the quotes (<code>""</code>) were replaced by angle-brackets (<code>&lt;&gt;</code>).<br>
</section>
<br>
<section id="pragma">
<h3>Pragma directive (#pragma)</h3>
This directive is used to specify diverse options to the compiler. These options are specific for the platform and the compiler you use. Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with <code>#pragma</code>.<br>
<br>
If the compiler does not support a specific argument for <code>#pragma</code>, it is ignored - no syntax error is generated.<br>
</section>
<br>
<section id="predefined_macro_names">
<h3>Predefined macro names</h3>
The following macro names are always defined (they all begin and end with two underscore characters, <code>_</code>):<br>
<br>
<table class="boxed">
<tr><th>macro</th><th>value</th></tr>
<tr><td><code>__LINE__</code></td><td>Integer value representing the current line in the source code file being compiled.</td></tr>
<tr><td><code>__FILE__</code></td><td>A string literal containing the presumed name of the source file being compiled.</td></tr>
<tr><td><code>__DATE__</code></td><td>A string literal in the form "Mmm dd yyyy" containing the date in which the compilation process began.</td></tr>
<tr><td><code>__TIME__</code></td><td>A string literal in the form "hh:mm:ss" containing the time at which the compilation process began.</td></tr>
<tr><td><code>__cplusplus</code></td><td>An integer value. All C++ compilers have this constant defined to some value. Its value depends on the version of the standard supported by the compiler:<br>
<ul>
<li><b><code>199711L</code></b>: ISO C++ 1998/2003</li>
<li><b><code>201103L</code></b>: ISO C++ 2011</li>
</ul>
Non conforming compilers define this constant as some value at most five digits long. Note that many compilers are not fully conforming and thus will have this constant defined as neither of the values above.<br>
</td></tr>
<tr class="cpp11"><td><code>__STDC_HOSTED__</code></td><td><code>1</code> if the implementation is a <i>hosted implementation</i> (with all standard headers available)<br>
<code>0</code> otherwise.</td></tr>
</table>
<br>
The following macros are optionally defined, generally depending on whether a feature is available:<br>
<br>
<table class="boxed">
<tr><th>macro</th><th>value</th></tr>
<tr class="cpp11"><td><code>__STDC__</code></td><td>In C: if defined to <code>1</code>, the implementation conforms to the C standard.<br>
In C++: Implementation defined.</td></tr>
<tr class="cpp11"><td><code>__STDC_VERSION__</code></td><td>In C:<br>
<ul>
<li><b><code>199401L</code></b>: ISO C 1990, Ammendment 1</li>
<li><b><code>199901L</code></b>: ISO C 1999</li>
<li><b><code>201112L</code></b>: ISO C 2011</li>
</ul>
In C++: Implementation defined.</td></tr>
<tr class="cpp11"><td><code>__STDC_MB_MIGHT_NEQ_WC__</code></td><td><code>1</Code> if multibyte encoding might give a character a different value in character literals</td></tr>
<tr class="cpp11"><td><code>__STDC_ISO_10646__</code></td><td>A value in the form <code>yyyymmL</code>, specifying the date of the Unicode standard followed by the encoding of <code>wchar_t</code> characters</td></tr>
<tr class="cpp11"><td><code>__STDCPP_STRICT_POINTER_SAFETY__</code></td><td><code>1</code> if the implementation has <i>strict pointer safety</i> (see <code><a href="/get_pointer_safety">get_pointer_safety</a></code>)</td></tr>
<tr class="cpp11"><td><code>__STDCPP_THREADS__</code></td><td><code>1</code> if the program can have more than one thread</td></tr>
</table>
<br>
Particular implementations may define additional constants.<br>
<br>
For example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br></code></pre></td>
<td class="source"><pre><code><cite>// standard macro names</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main()
{
  cout &lt;&lt; <kbd>"This is the line number "</kbd> &lt;&lt; __LINE__;
  cout &lt;&lt; <kbd>" of file "</kbd> &lt;&lt; __FILE__ &lt;&lt; <kbd>".\n"</kbd>;
  cout &lt;&lt; <kbd>"Its compilation began "</kbd> &lt;&lt; __DATE__;
  cout &lt;&lt; <kbd>" at "</kbd> &lt;&lt; __TIME__ &lt;&lt; <kbd>".\n"</kbd>;
  cout &lt;&lt; <kbd>"The compiler gives a __cplusplus value of "</kbd> &lt;&lt; __cplusplus;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>This is the line number 7 of file /home/jay/stdmacronames.cpp.
Its compilation began Nov  1 2005 at 10:12:29.
The compiler gives a __cplusplus value of 1</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/exceptions/" rel="prev">Previous:<br><b>Exceptions</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"><a href="/doc/tutorial/files/" rel="next">Next:<br><b>Input/output with files</b></a></td></tr></table><br><br>

<h2></h2>
<h2>Input/output with files</h2>
<section id="intro">
C++ provides the following classes to perform output and input of characters to/from files: <br>
<br>
<ul>
<li><b><code><a href="/ofstream">ofstream</a></code>:</b> Stream class to write on files</li>
<li><b><code><a href="/ifstream">ifstream</a></code>:</b> Stream class to read from files</li>
<li><b><code><a href="/fstream">fstream</a></code>:</b> Stream class to both read and write from/to files.</li>
</ul>
<br>
These classes are derived directly or indirectly from the classes <code>istream</code> and <code>ostream</code>. We have already used objects whose types were these classes: <code>cin</code> is an object of class <code>istream</code> and <code>cout</code> is an object of class <code>ostream</code>. Therefore, we have already been using classes that are related to our file streams. And in fact, we can use our file streams the same way we are already used to use <code>cin</code> and <code>cout</code>, with the only difference that we have to associate these streams with physical files. Let's see an example:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br></code></pre></td>
<td class="source"><pre><code><cite>// basic file operations</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  ofstream myfile;
  myfile.open (<kbd>"example.txt"</kbd>);
  myfile &lt;&lt; <kbd>"Writing this to a file.\n"</kbd>;
  myfile.close();
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>[file example.txt]
Writing this to a file.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This code creates a file called <code>example.txt</code> and inserts a sentence into it in the same way we are used to do with <code>cout</code>, but using the file stream <code>myfile</code> instead.<br>
<br>
But let's go step by step:<br>
</section>
<br>
<section id="opean_a_file">
<h3>Open a file</h3>
The first operation generally performed on an object of one of these classes is to associate it to a real file. This procedure is known as to <i>open a file</i>. An open file is represented within a program by a <i>stream</i> (i.e., an object of one of these classes; in the previous example, this was <code>myfile</code>) and any input or output operation performed on this stream object will be applied to the physical file associated to it.<br>
<br>
In order to open a file with a stream object we use its member function <code>open</code>:<br>
<br>
<code>
open (filename, mode);<br>
</code>
<br>
Where <code>filename</code> is a string representing the name of the file to be opened, and <code>mode</code> is an optional parameter with a combination of the following flags:<br>
<br>
<table class="boxed">
<tr><td><code>ios::in</code></td><td>Open for input operations.</td></tr>
<tr><td><code>ios::out</code></td><td>Open for output operations.</td></tr>
<tr><td><code>ios::binary</code></td><td>Open in binary mode.</td></tr>
<tr><td><code>ios::ate</code></td><td>Set the initial position at the end of the file.<br>
If this flag is not set, the initial position is the beginning of the file.</td></tr>
<tr><td><code>ios::app</code></td><td>All output operations are performed at the end of the file, appending the content to the current content of the file.</td></tr>
<tr><td><code>ios::trunc</code></td><td>If the file is opened for output operations and it already existed, its previous content is deleted and replaced by the new one.</td></tr>
</table>
<br>
All these flags can be combined using the bitwise operator OR (<code>|</code>). For example, if we want to open the file <code>example.bin</code> in binary mode to add data we could do it by the following call to member function <code>open</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br></code></pre></td>
<td class="source"><pre><code>ofstream myfile;
myfile.open (<kbd>"example.bin"</kbd>, ios::out | ios::app | ios::binary); </code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Each of the <code>open</code> member functions of classes <code>ofstream</code>, <code>ifstream</code> and <code>fstream</code> has a default mode that is used if the file is opened without a second argument:<br>
<br>
<table class="boxed">
<tr><th>class</th><th>default mode parameter</th></tr>
<tr><td><code>ofstream</code></td><td>ios::out</td></tr>
<tr><td><code>ifstream</code></td><td>ios::in</td></tr>
<tr><td><code>fstream</code></td><td>ios::in | ios::out</td></tr>
</table>
<br>
For <code>ifstream</code> and <code>ofstream</code> classes, <code>ios::in</code> and <code>ios::out</code> are automatically and respectively assumed, even if a mode that does not include them is passed as second argument to the <code>open</code> member function (the flags are combined).<br>
<br>
For <code>fstream</code>, the default value is only applied if the function is called without specifying any value for the mode parameter. If the function is called with any value in that parameter the default mode is overridden, not combined.<br>
<br>
File streams opened in <i>binary mode</i> perform input and output operations independently of any format considerations. Non-binary files are known as <i>text files</i>, and some translations may occur due to formatting of some special characters (like newline and carriage return characters).<br>
<br>
Since the first task that is performed on a file stream is generally to open a file, these three classes include a constructor that automatically calls the <code>open</code> member function and has the exact same parameters as this member. Therefore, we could also have declared the previous <code>myfile</code> object and conduct the same opening operation in our previous example by writing:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>ofstream myfile (<kbd>"example.bin"</kbd>, ios::out | ios::app | ios::binary);</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Combining object construction and stream opening in a single statement. Both forms to open a file are valid and equivalent.<br>
<br>
To check if a file stream was successful opening a file, you can do it by calling to member <code>is_open</code>. This member function returns a <code>bool</code> value of <code>true</code> in the case that indeed the stream object is associated with an open file, or <code>false</code> otherwise:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code><var>if</var> (myfile.is_open()) { <cite>/* ok, proceed with output */</cite> }</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
</section>
<br>
<section id="closing_a_file">
<h3>Closing a file</h3>
When we are finished with our input and output operations on a file we shall close it so that the operating system is notified and its resources become available again. For that, we call the stream's member function <code>close</code>. This member function takes flushes the associated buffers and closes the file:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>myfile.close();</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Once this member function is called, the stream object can be re-used to open another file, and the file is available again to be opened by other processes.<br>
<br>
In case that an object is destroyed while still associated with an open file, the destructor automatically calls the member function <code>close</code>.<br>
</section>
<br>
<section id="text_files">
<h3>Text files</h3>
Text file streams are those where the <code>ios::binary</code> flag is not included in their opening mode. These files are designed to store text and thus all values that are input or output from/to them can suffer some formatting transformations, which do not necessarily correspond to their literal binary value.<br>
<br>
Writing operations on text files are performed in the same way we operated with <code>cout</code>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></code></pre></td>
<td class="source"><pre><code><cite>// writing on a text file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  ofstream myfile (<kbd>"example.txt"</kbd>);
  <var>if</var> (myfile.is_open())
  {
    myfile &lt;&lt; <kbd>"This is a line.\n"</kbd>;
    myfile &lt;&lt; <kbd>"This is another line.\n"</kbd>;
    myfile.close();
  }
  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>[file example.txt]
This is a line.
This is another line.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Reading from a file can also be performed in the same way that we did with <code>cin</code>:<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br></code></pre></td>
<td class="source"><pre><code><cite>// reading a text file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<dfn>#include &lt;string&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  string line;
  ifstream myfile (<kbd>"example.txt"</kbd>);
  <var>if</var> (myfile.is_open())
  {
    <var>while</var> ( getline (myfile,line) )
    {
      cout &lt;&lt; line &lt;&lt; <kbd>'\n'</kbd>;
    }
    myfile.close();
  }

  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>; 

  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>This is a line.
This is another line.  </samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
This last example reads a text file and prints out its content on the screen. We have created a while loop that reads the file line by line, using <samp><a href="/getline">getline</a></samp>. The value returned by <samp><a href="/getline">getline</a></samp> is a reference to the stream object itself, which when evaluated as a boolean expression (as in this while-loop) is <code>true</code> if the stream is ready for more operations, and <code>false</code> if either the end of the file has been reached or if some other error occurred.<br>
</section>
<br>
<section id="checking_state_flags">
<h3>Checking state flags</h3>
The following member functions exist to check for specific states of a stream (all of them return a <code>bool</code> value): <br>
<br>
<dl>
<dt><code>bad()</code></dt>
<dd>Returns <code>true</code> if a reading or writing operation fails. For example, in the case that we try to write to a file that is not open for writing or if the device where we try to write has no space left.</dd>
<dt><code>fail()</code></dt>
<dd>Returns <code>true</code> in the same cases as <code>bad()</code>, but also in the case that a format error happens, like when an alphabetical character is extracted when we are trying to read an integer number.</dd>
<dt><code>eof()</code></dt>
<dd>Returns <code>true</code> if a file open for reading has reached the end.</dd>
<dt><code>good()</code></dt>
<dd>It is the most generic state flag: it returns <code>false</code> in the same cases in which calling any of the previous functions would return <code>true</code>. Note that <code>good</code> and <code>bad</code> are not exact opposites (<code>good</code> checks more state flags at once).</dd>
</dl>
<br>
The member function <code>clear()</code> can be used to reset the state flags.<br>
</section>
<br>
<section id="get_and_put">
<h3>get and put stream positioning</h3>
All i/o streams objects keep internally -at least- one internal position:<br>
<br>
<code>ifstream</code>, like <code>istream</code>, keeps an internal <i>get position</i> with the location of the element to be read in the next input operation.<br>
<br>
<code>ofstream</code>, like <code>ostream</code>, keeps an internal <i>put position</i> with the location where the next element has to be written.<br>
<br>
Finally, <code>fstream</code>, keeps both, the <i>get</i> and the <i>put position</i>, like <code>iostream</code>.<br>
<br>
These internal stream positions point to the locations within the stream where the next reading or writing operation is performed. These positions can be observed and modified using the following member functions: <br>
<br>
<h4>tellg() and tellp()</h4>
These two member functions with no parameters return a value of the member type <code>streampos</code>, which is a type representing the current <i>get position</i> (in the case of <code>tellg</code>) or the <i>put position</i> (in the case of <code>tellp</code>).<br>
<br>
<h4>seekg() and seekp()</h4>
These functions allow to change the location of the <i>get</i> and <i>put positions</i>. Both functions are overloaded with two different prototypes. The first form is:<br>
<br>
<code>
seekg ( position );<br>
seekp ( position );<br>
</code>
<br>
Using this prototype, the stream pointer is changed to the absolute position <code>position</code> (counting from the beginning of the file). The type for this parameter is <code>streampos</code>, which is the same type as returned by functions <code>tellg</code> and <code>tellp</code>.<br>
<br>
The other form for these functions is:<br>
<br>
<code>
seekg ( offset, direction );<br>
seekp ( offset, direction );<br>
</code>
<br>
Using this prototype, the <i>get</i> or <i>put position</i> is set to an offset value relative to some specific point determined by the parameter <code>direction</code>. <code>offset</code> is of type <code>streamoff</code>. And <code>direction</code> is of type <code>seekdir</code>, which is an <i>enumerated type</i> that determines the point from where offset is counted from, and that can take any of the following values:<br>
<br>
<table class="boxed">
<tr><td><code>ios::beg</code></td><td>offset counted from the beginning of the stream</td></tr>
<tr><td><code>ios::cur</code></td><td>offset counted from the current position</td></tr>
<tr><td><code>ios::end</code></td><td>offset counted from the end of the stream</td></tr>
</table>
<br>
The following example uses the member functions we have just seen to obtain the size of a file: <br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br></code></pre></td>
<td class="source"><pre><code><cite>// obtaining file size</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  streampos begin,end;
  ifstream myfile (<kbd>"example.bin"</kbd>, ios::binary);
  begin = myfile.tellg();
  myfile.seekg (0, ios::end);
  end = myfile.tellg();
  myfile.close();
  cout &lt;&lt; <kbd>"size is: "</kbd> &lt;&lt; (end-begin) &lt;&lt; <kbd>" bytes.\n"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>size is: 40 bytes.</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Notice the type we have used for variables <code>begin</code> and <code>end</code>:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>streampos size;</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
<code>streampos</code> is a specific type used for buffer and file positioning and is the type returned by <code>file.tellg()</code>. Values of this type can safely be subtracted from other values of the same type, and can also be converted to an integer type large enough to contain the size of the file.<br>
<br>
These stream positioning functions use two particular types: <code>streampos</code> and <code>streamoff</code>. These types are also defined as member types of the stream class:<br>
<br>
<table class="boxed">
<tr><th>Type</th><th>Member type</th><th>Description</th></tr>
<tr><td><code><a href="/streampos">streampos</a></code></td><td><code><a href="/ios#types">ios::pos_type</a></code></td><td>Defined as <code><a href="/fpos">fpos&lt;mbstate_t&gt;</a></code>.<br>
It can be converted to/from <code><a href="/streamoff">streamoff</a></code> and can be added or subtracted values of these types.</td></tr>
<tr><td><code><a href="/streamoff">streamoff</a></code></td><td><code><a href="/ios#types">ios::off_type</a></code></td><td>It is an alias of one of the fundamental integral types (such as <code>int</code> or <code>long long</code>).</td></tr>
</table>
<br>
Each of the member types above is an alias of its non-member equivalent (they are the exact same type). It does not matter which one is used. The member types are more generic, because they are the same on all stream objects (even on streams using exotic types of characters), but the non-member types are widely used in existing code for historical reasons.<br>
</section>
<br>
<section id="binary_files">
<h3>Binary files</h3>
For binary files, reading and writing data with the extraction and insertion operators (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>) and functions like <code>getline</code> is not efficient, since we do not need to format any data and data is likely not formatted in lines.<br>
<br>
File streams include two member functions specifically designed to read and write binary data sequentially: <code>write</code> and <code>read</code>. The first one (<code>write</code>) is a member function of <code>ostream</code> (inherited by <code>ofstream</code>). And <code>read</code> is a member function of <code>istream</code> (inherited by <code>ifstream</code>). Objects of class <code>fstream</code> have both. Their prototypes are:<br>
<br>
<tt>
write ( memory_block, size );<br>
read ( memory_block, size );<br>
</tt>
<br>
Where <code>memory_block</code> is of type <code>char*</code> (pointer to <code>char</code>), and represents the address of an array of bytes where the read data elements are stored or from where the data elements to be written are taken. The <code>size</code> parameter is an integer value that specifies the number of characters to be read or written from/to the memory block.<br>
<br>
<div class="auto"><table class="split"><tr><td class="rownum"><pre><code>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br></code></pre></td>
<td class="source"><pre><code><cite>// reading an entire binary file</cite>
<dfn>#include &lt;iostream&gt;</dfn>
<dfn>#include &lt;fstream&gt;</dfn>
<var>using</var> <var>namespace</var> std;

<var>int</var> main () {
  streampos size;
  <var>char</var> * memblock;

  ifstream file (<kbd>"example.bin"</kbd>, ios::in|ios::binary|ios::ate);
  <var>if</var> (file.is_open())
  {
    size = file.tellg();
    memblock = <var>new</var> <var>char</var> [size];
    file.seekg (0, ios::beg);
    file.read (memblock, size);
    file.close();

    cout &lt;&lt; <kbd>"the entire file content is in memory"</kbd>;

    <var>delete</var>[] memblock;
  }
  <var>else</var> cout &lt;&lt; <kbd>"Unable to open file"</kbd>;
  <var>return</var> 0;
}</code></pre></td>
<td class="output"><pre><samp>the entire file content is in memory</samp></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
In this example, the entire file is read and stored in a memory block. Let's examine how this is done:<br>
<br>
First, the file is open with the <code>ios::ate</code> flag, which means that the get pointer will be positioned at the end of the file. This way, when we call to member <code>tellg()</code>, we will directly obtain the size of the file.<br>
<br>
Once we have obtained the size of the file, we request the allocation of a memory block large enough to hold the entire file:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>&nbsp;</code></pre></td>
<td class="source"><pre><code>memblock = <var>new</var> <var>char</var>[size];</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
Right after that, we proceed to set the <i>get position</i> at the beginning of the file (remember that we opened the file with this pointer at the end), then we read the entire file, and finally close it:<br>
<br>
<div class="auto"><table class="snippet"><tr><td class="rownum"><pre><code>1<br>2<br>3<br></code></pre></td>
<td class="source"><pre><code>file.seekg (0, ios::beg);
file.read (memblock, size);
file.close();</code></pre></td><td class="C_btnholder"></td></tr></table></div>
<br>
<br>
At this point we could operate with the data obtained from the file. But our program simply announces that the content of the file is in memory and then finishes.<br>
</section>
<br>
<section id="buffers_and_sync">
<h3>Buffers and Synchronization</h3>
When we operate with file streams, these are associated to an internal buffer object of type <code>streambuf</code>. This buffer object may represent a memory block that acts as an intermediary between the stream and the physical file. For example, with an <code>ofstream</code>, each time the member function <code>put</code> (which writes a single character) is called, the character may be inserted in this intermediate buffer instead of being written directly to the physical file with which the stream is associated.<br>
<br>
The operating system may also define other layers of buffering for reading and writing to files.<br>
<br>
When the buffer is flushed, all the data contained in it is written to the physical medium (if it is an output stream). This process is called <i>synchronization</i> and takes place under any of the following circumstances: <br>
<br>
<ul>
<li><b>When the file is closed:</b> before closing a file, all buffers that have not yet been flushed are synchronized and all pending data is written or read to the physical medium.</li>
<li><b>When the buffer is full:</b> Buffers have a certain size. When the buffer is full it is automatically synchronized.</li>
<li><b>Explicitly, with manipulators:</b> When certain manipulators are used on streams, an explicit synchronization takes place. These manipulators are: <code><a href="/flush">flush</a></code> and <code><a href="/endl">endl</a></code>.</li>
<li><b>Explicitly, with member function sync():</b> Calling the stream's member function <code>sync()</code> causes an immediate synchronization. This function returns an <code>int</code> value equal to <tt>-1</tt> if the stream has no associated buffer or in case of failure. Otherwise (if the stream buffer was successfully synchronized) it returns <code>0</code>.</li>
</ul>
</section><table class="C_docPrevNext"><tr><td class="prev"><a href="/doc/tutorial/preprocessor/" rel="prev">Previous:<br><b>Preprocessor directives</b></a></td><td class="index"><a href="/doc/tutorial/" rel="index"><br>Index</a></td><td class="next"></td></tr></table><br><br>

<br>
<br><br><br><br><br>
<script>
  $(function() {
    var toc = $('#toc>ul');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2, h3').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
