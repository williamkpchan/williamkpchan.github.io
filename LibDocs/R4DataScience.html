<base target="_blank"><html><head><title>R4DataScience</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "R4DataScience"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>R4DataScience</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://r4ds.had.co.nz/" class="whitebut ">R4DataScience</a>
</div>
<pre>
<br>
<br>

<h2><span class="orange">Welcome</span></h2>
<a href="http://amzn.to/2aHLAQ1"><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b88ef926a004b0fce72b2526b0b5c4413666a4cb/24a30/cover.png" width="250" height="375" alt="Cover image" align="right" style="margin: 0 1em 0 1em" /></a> This is the website for 'R for Data Science'. 
This book will teach you how to do data science with R: You’ll learn how to get your data into R, get it into the most useful structure, transform it, visualise it and model it. 
In this book, you will find a practicum of skills for data science. 
Just as a chemist learns how to clean test tubes and stock a lab, you’ll learn how to clean data and draw plots—and many other things besides. 
These are the skills that allow data science to happen, and here you will find the best practices for doing each of these things with R. 
You’ll learn how to use the grammar of graphics, literate programming, and reproducible research to save time. 
You’ll also learn how to manage cognitive resources to facilitate discoveries when wrangling, visualising, and exploring data.

<h2><span class="orange">1 Introduction</span></h2>
<h2>1.1 What you will learn</h2>
Data science is a huge field, and there’s no way you can master it by reading a single book. 
The goal of this book is to give you a solid foundation in the most important tools. 
Our model of the tools needed in a typical data science project looks something like this:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png" width="75%" style="display: block; margin: auto;" />

First you must import your data into R. 

Once you’ve imported your data, it is a good idea to tidy it. 

Once you have tidy data, a common first step is to transform it. 
Transformation includes narrowing in on observations of interest (like all people in one city, or all data from the last year), creating new variables that are functions of existing variables (like computing speed from distance and time), and calculating a set of summary statistics (like counts or means). 
Together, tidying and transforming are called wrangling, because getting your data in a form that’s natural to work with often feels like a fight!

Once you have tidy data with the variables you need, there are two main engines of knowledge generation: visualisation and modelling. 
These have complementary strengths and weaknesses so any real analysis will iterate between them many times.

Visualisation is a fundamentally human activity. 
A good visualisation will show you things that you did not expect, or raise new questions about the data. 
A good visualisation might also hint that you’re asking the wrong question, or you need to collect different data. 
Visualisations can surprise you, but don’t scale particularly well because they require a human to interpret them.

Models are complementary tools to visualisation. 
Once you have made your questions sufficiently precise, you can use a model to answer them. 
Models are a fundamentally mathematical or computational tool, so they generally scale well. 
Even when they don’t, it’s usually cheaper to buy more computers than it is to buy more brains! But every model makes assumptions, and by its very nature a model cannot question its own assumptions. 
That means a model cannot fundamentally surprise you.

The last step of data science is communication, an absolutely critical part of any data analysis project. 
It doesn’t matter how well your models and visualisation have led you to understand the data unless you can also communicate your results to others.

Surrounding all these tools is programming. 
Programming is a cross-cutting tool that you use in every part of the project. 
You don’t need to be an expert programmer to be a data scientist, but learning more about programming pays off because becoming a better programmer allows you to automate common tasks, and solve new problems with greater ease.

You’ll use these tools in every data science project, but for most projects they’re not enough. 
There’s a rough 80-20 rule at play; you can tackle about 80% of every project using the tools that you’ll learn in this book, but you’ll need other tools to tackle the remaining 20%. 
Throughout this book we’ll point you to resources where you can learn more.

<h2>1.2 How this book is organised</h2>
The previous description of the tools of data science is organised roughly according to the order in which you use them in an analysis (although of course you’ll iterate through them multiple times). 
In our experience, however, this is not the best way to learn them:

Starting with data ingest and tidying is sub-optimal because 80% of the time
it’s routine and boring, and the other 20% of the time it’s weird and
frustrating. 
That’s a bad place to start learning a new subject! Instead,
we’ll start with visualisation and transformation of data that’s already been
imported and tidied. 
That way, when you ingest and tidy your own data, your
motivation will stay high because you know the pain is worth it.

Some topics are best explained with other tools. 
For example, we believe that
it’s easier to understand how models work if you already know about
visualisation, tidy data, and programming.

Programming tools are not necessarily interesting in their own right,
but do allow you to tackle considerably more challenging problems. 
We’ll
give you a selection of programming tools in the middle of the book, and
then you’ll see how they can combine with the data science tools to tackle
interesting modelling problems.

Within each chapter, we try and stick to a similar pattern: start with some motivating examples so you can see the bigger picture, and then dive into the details. 
Each section of the book is paired with exercises to help you practice what you’ve learned. 
While it’s tempting to skip the exercises, there’s no better way to learn than practicing on real problems.

<h2>1.3 What you won’t learn</h2>
There are some important topics that this book doesn’t cover. 
We believe it’s important to stay ruthlessly focused on the essentials so you can get up and running as quickly as possible. 
That means this book can’t cover every important topic.

<h3>1.3.1 Big data</h3>
This book proudly focuses on small, in-memory datasets. 
This is the right place to start because you can’t tackle big data unless you have experience with small data. 
The tools you learn in this book will easily handle hundreds of megabytes of data, and with a little care you can typically use them to work with 1-2 Gb of data. 
If you’re routinely working with larger data (10-100 Gb, say), you should learn more about <a href="https://github.com/Rdatatable/data.table">data.table</a>. 
This book doesn’t teach data.table because it has a very concise interface which makes it harder to learn since it offers fewer linguistic cues. 
But if you’re working with large data, the performance payoff is worth the extra effort required to learn it.

If your data is bigger than this, carefully consider if your big data problem might actually be a small data problem in disguise. 
While the complete data might be big, often the data needed to answer a specific question is small. 
You might be able to find a subset, subsample, or summary that fits in memory and still allows you to answer the question that you’re interested in. 
The challenge here is finding the right small data, which often requires a lot of iteration.

Another possibility is that your big data problem is actually a large number of small data problems. 
Each individual problem might fit in memory, but you have millions of them. 
For example, you might want to fit a model to each person in your dataset. 
That would be trivial if you had just 10 or 100 people, but instead you have a million. 
Fortunately each problem is independent of the others (a setup that is sometimes called embarrassingly parallel), so you just need a system (like Hadoop or Spark) that allows you to send different datasets to different computers for processing. 
Once you’ve figured out how to answer the question for a single subset using the tools described in this book, you learn new tools like sparklyr, rhipe, and ddr to solve it for the full dataset.

<h3>1.3.2 Python, Julia, and friends</h3>
In this book, you won’t learn anything about Python, Julia, or any other programming language useful for data science. 
This isn’t because we think these tools are bad. 
They’re not! And in practice, most data science teams use a mix of languages, often at least R and Python.

However, we strongly believe that it’s best to master one tool at a time. 
You will get better faster if you dive deep, rather than spreading yourself thinly over many topics. 
This doesn’t mean you should only know one thing, just that you’ll generally learn faster if you stick to one thing at a time. 
You should strive to learn new things throughout your career, but make sure your understanding is solid before you move on to the next interesting thing.

We think R is a great place to start your data science journey because it is an environment designed from the ground up to support data science. 
R is not just a programming language, but it is also an interactive environment for doing data science. 
To support interaction, R is a much more flexible language than many of its peers. 
This flexibility comes with its downsides, but the big upside is how easy it is to evolve tailored grammars for specific parts of the data science process. 
These mini languages help you think about problems as a data scientist, while supporting fluent interaction between your brain and the computer.

<h3>1.3.3 Non-rectangular data</h3>
This book focuses exclusively on rectangular data: collections of values that are each associated with a variable and an observation. 
There are lots of datasets that do not naturally fit in this paradigm: including images, sounds, trees, and text. 
But rectangular data frames are extremely common in science and industry, and we believe that they are a great place to start your data science journey.

<h3>1.3.4 Hypothesis confirmation</h3>
It’s possible to divide data analysis into two camps: hypothesis generation and hypothesis confirmation (sometimes called confirmatory analysis). 
The focus of this book is unabashedly on hypothesis generation, or data exploration. 
Here you’ll look deeply at the data and, in combination with your subject knowledge, generate many interesting hypotheses to help explain why the data behaves the way it does. 
You evaluate the hypotheses informally, using your scepticism to challenge the data in multiple ways.

The complement of hypothesis generation is hypothesis confirmation. 
Hypothesis confirmation is hard for two reasons:

You need a precise mathematical model in order to generate falsifiable
predictions. 
This often requires considerable statistical sophistication.

You can only use an observation once to confirm a hypothesis. 
As soon as
you use it more than once you’re back to doing exploratory analysis.
This means to do hypothesis confirmation you need to 'preregister'
(write out in advance) your analysis plan, and not deviate from it
even when you have seen the data. 
We’ll talk a little about some
strategies you can use to make this easier in <a href="model-intro.html#model-intro">modelling</a>.

It’s common to think about modelling as a tool for hypothesis confirmation, and visualisation as a tool for hypothesis generation. 
But that’s a false dichotomy: models are often used for exploration, and with a little care you can use visualisation for confirmation. 
The key difference is how often do you look at each observation: if you look only once, it’s confirmation; if you look more than once, it’s exploration.

<h2>1.4 Prerequisites</h2>
We’ve made a few assumptions about what you already know in order to get the most out of this book. 
You should be generally numerically literate, and it’s helpful if you have some programming experience already. 
If you’ve never programmed before, you might find <a href="http://amzn.com/1449359019">Hands on Programming with R</a> by Garrett to be a useful adjunct to this book.

There are four things you need to run the code in this book: R, RStudio, a collection of R packages called the tidyverse, and a handful of other packages. 
Packages are the fundamental units of reproducible R code. 
They include reusable functions, the documentation that describes how to use them, and sample data.

<h3>1.4.1 R</h3>
To download R, go to CRAN, the comprehensive R archive network. 
CRAN is composed of a set of mirror servers distributed around the world and is used to distribute R and R packages. 
Don’t try and pick a mirror that’s close to you: instead use the cloud mirror, <a href="https://cloud.r-project.org" class="uri">https://cloud.r-project.org</a>, which automatically figures it out for you.

A new major version of R comes out once a year, and there are 2-3 minor releases each year. 
It’s a good idea to update regularly. 
Upgrading can be a bit of a hassle, especially for major versions, which require you to reinstall all your packages, but putting it off only makes it worse.

<h3>1.4.2 RStudio</h3>
RStudio is an integrated development environment, or IDE, for R programming. 
Download and install it from <a href="http://www.rstudio.com/download" class="uri">http://www.rstudio.com/download</a>. 
RStudio is updated a couple of times a year. 
When a new version is available, RStudio will let you know. 
It’s a good idea to upgrade regularly so you can take advantage of the latest and greatest features. 
For this book, make sure you have at least RStudio 1.0.0.

When you start RStudio, you’ll see two key regions in the interface:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9a23d664f0f49bc2ef8e78bed6277dd48bd2b96d/af132/diagrams/rstudio-console.png" width="75%" style="display: block; margin: auto;" />

For now, all you need to know is that you type R code in the console pane, and press enter to run it. 
You’ll learn more as we go along!

<h3>1.4.3 The tidyverse</h3>
You’ll also need to install some R packages. 
An R package is a collection of functions, data, and documentation that extends the capabilities of base R. 
Using packages is key to the successful use of R. 
The majority of the packages that you will learn in this book are part of the so-called tidyverse. 
The packages in the tidyverse share a common philosophy of data and R programming, and are designed to work together naturally.

You can install the complete tidyverse with a single line of code:

<code>install.packages("tidyverse")</code>

On your own computer, type that line of code in the console, and then press enter to run it. 
R will download the packages from CRAN and install them on to your computer. 
If you have problems installing, make sure that you are connected to the internet, and that <a href="https://cloud.r-project.org/" class="uri">https://cloud.r-project.org/</a> isn’t blocked by your firewall or proxy.

You will not be able to use the functions, objects, and help files in a package until you load it with <code>library()</code>. 
Once you have installed a package, you can load it with the <code>library()</code> function:

<code>library(tidyverse)</a>
#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──</a>
#> ✔ ggplot2 3.3.0     ✔ purrr   0.3.4</a>
#> ✔ tibble  3.0.1     ✔ dplyr   0.8.5</a>
#> ✔ tidyr   1.0.3     ✔ stringr 1.4.0</a>
#> ✔ readr   1.3.1     ✔ forcats 0.5.0</a>
#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──</a>
#> ✖ dplyr::filter() masks stats::filter()</a>
#> ✖ dplyr::lag()    masks stats::lag()</code>

This tells you that tidyverse is loading the ggplot2, tibble, tidyr, readr, purrr, and dplyr packages. 
These are considered to be the core of the tidyverse because you’ll use them in almost every analysis.

Packages in the tidyverse change fairly frequently. 
You can see if updates are available, and optionally install them, by running <code>tidyverse_update()</code>.

<h3>1.4.4 Other packages</h3>
There are many other excellent packages that are not part of the tidyverse, because they solve problems in a different domain, or are designed with a different set of underlying principles. 
This doesn’t make them better or worse, just different. 
In other words, the complement to the tidyverse is not the messyverse, but many other universes of interrelated packages. 
As you tackle more data science projects with R, you’ll learn new packages and new ways of thinking about data.

In this book we’ll use three data packages from outside the tidyverse:

<code>install.packages(c("nycflights13", "gapminder", "Lahman"))</code>

These packages provide data on airline flights, world development, and baseball that we’ll use to illustrate key data science ideas.

<h2>1.5 Running R code</h2>
The previous section showed you a couple of examples of running R code. 
Code in the book looks like this:

<code>1 + 2</a>
#> [1] 3</a>
#> [1] 3</code>

If you run the same code in your local console, it will look like this:

<code>> 1 + 2
[1] 3</code>

There are two main differences. 
In your console, you type after the <code>></code>, called the prompt; we don’t show the prompt in the book. 
In the book, output is commented out with <code>#></code>; in your console it appears directly after your code. 
These two differences mean that if you’re working with an electronic version of the book, you can easily copy code out of the book and into the console.

Throughout the book we use a consistent set of conventions to refer to code:

Functions are in a code font and followed by parentheses, like <code>sum()</code>,
or <code>mean()</code>.

Other R objects (like data or function arguments) are in a code font,
without parentheses, like <code>flights</code> or <code>x</code>.

If we want to make it clear what package an object comes from, we’ll use
the package name followed by two colons, like <code>dplyr::mutate()</code>, or<br />
<code>nycflights13::flights</code>. 
This is also valid R code.

<h2>1.6 Getting help and learning more</h2>
This book is not an island; there is no single resource that will allow you to master R. 
As you start to apply the techniques described in this book to your own data you will soon find questions that I do not answer. 
This section describes a few tips on how to get help, and to help you keep learning.

If you get stuck, start with Google. 
Typically adding 'R' to a query is enough to restrict it to relevant results: if the search isn’t useful, it often means that there aren’t any R-specific results available. 
Google is particularly useful for error messages. 
If you get an error message and you have no idea what it means, try googling it! Chances are that someone else has been confused by it in the past, and there will be help somewhere on the web. 
(If the error message isn’t in English, run <code>Sys.setenv(LANGUAGE = "en")</code> and re-run the code; you’re more likely to find help for English error messages.)

If Google doesn’t help, try <a href="http://stackoverflow.com">stackoverflow</a>. 
Start by spending a little time searching for an existing answer, including <code>[R]</code> to restrict your search to questions and answers that use R. 
If you don’t find anything useful, prepare a minimal reproducible example or reprex. 
A good reprex makes it easier for other people to help you, and often you’ll figure out the problem yourself in the course of making it.

There are three things you need to include to make your example reproducible: required packages, data, and code.

Packages should be loaded at the top of the script, so it’s easy to
see which ones the example needs. 
This is a good time to check that you’re
using the latest version of each package; it’s possible you’ve discovered
a bug that’s been fixed since you installed the package. 
For packages
in the tidyverse, the easiest way to check is to run <code>tidyverse_update()</code>.

The easiest way to include data in a question is to use <code>dput()</code> to
generate the R code to recreate it. 
For example, to recreate the <code>mtcars</code>
dataset in R, I’d perform the following steps:

Run <code>dput(mtcars)</code> in R

Copy the output

In my reproducible script, type <code>mtcars &lt;-</code> then paste.

Try and find the smallest subset of your data that still reveals
the problem.

Spend a little bit of time ensuring that your code is easy for others to
read:

Make sure you’ve used spaces and your variable names are concise, yet
informative.

Use comments to indicate where your problem lies.

Do your best to remove everything that is not related to the problem.<br />
The shorter your code is, the easier it is to understand, and the
easier it is to fix.

Finish by checking that you have actually made a reproducible example by starting a fresh R session and copying and pasting your script in.

You should also spend some time preparing yourself to solve problems before they occur. 
Investing a little time in learning R each day will pay off handsomely in the long run. 
One way is to follow what Hadley, Garrett, and everyone else at RStudio are doing on the <a href="https://blog.rstudio.org">RStudio blog</a>. 
This is where we post announcements about new packages, new IDE features, and in-person courses. 
You might also want to follow Hadley (<a href="https://twitter.com/hadleywickham">@hadleywickham</a>) or Garrett (<a href="https://twitter.com/statgarrett">@statgarrett</a>) on Twitter, or follow <a href="https://twitter.com/rstudiotips">@rstudiotips</a> to keep up with new features in the IDE.

To keep up with the R community more broadly, we recommend reading <a href="http://www.r-bloggers.com" class="uri">http://www.r-bloggers.com</a>: it aggregates over 500 blogs about R from around the world. 
If you’re an active Twitter user, follow the <code>#rstats</code> hashtag. 
Twitter is one of the key tools that Hadley uses to keep up with new developments in the community.

<h2>1.7 Acknowledgements</h2>
This book isn’t just the product of Hadley and Garrett, but is the result of many conversations (in person and online) that we’ve had with the many people in the R community. 
There are a few people we’d like to thank in particular, because they have spent many hours answering our dumb questions and helping us to better think about data science:

Jenny Bryan and Lionel Henry for many helpful discussions around working
with lists and list-columns.

The three chapters on workflow were adapted (with permission), from
<a href="http://stat545.com/block002_hello-r-workspace-wd-project.html" class="uri">http://stat545.com/block002_hello-r-workspace-wd-project.html</a> by
Jenny Bryan.

Genevera Allen for discussions about models, modelling, the statistical
learning perspective, and the difference between hypothesis generation and
hypothesis confirmation.

Yihui Xie for his work on the <a href="https://github.com/rstudio/bookdown">bookdown</a>
package, and for tirelessly responding to my feature requests.

Bill Behrman for his thoughtful reading of the entire book, and for trying
it out with his data science class at Stanford.

The #rstats twitter community who reviewed all of the draft chapters
and provided tons of useful feedback.

Tal Galili for augmenting his dendextend package to support a section on clustering that did not make it into the final draft.

This book was written in the open, and many people contributed pull requests to fix minor problems. 
Special thanks goes to everyone who contributed via GitHub:

Thanks go to all contributers in alphabetical order: adi pradhan, Ahmed ElGabbas, Ajay Deonarine, @Alex, Andrew Landgraf, bahadir cankardes, @batpigandme, @behrman, Ben Marwick, Bill Behrman, Brandon Greenwell, Brett Klamer, Christian G. 
Warden, Christian Mongeau, Colin Gillespie, Cooper Morris, Curtis Alexander, Daniel Gromer, David Clark, Derwin McGeary, Devin Pastoor, Dylan Cashman, Earl Brown, Eric Watt, Etienne B. 
Racine, Flemming Villalona, Gregory Jefferis, @harrismcgehee, Hengni Cai, Ian Lyttle, Ian Sealy, Jakub Nowosad, Jennifer (Jenny) Bryan, @jennybc, Jeroen Janssens, Jim Hester, @jjchern, Joanne Jang, John Sears, Jon Calder, Jonathan Page, @jonathanflint, Jose Roberto Ayala Solares, Julia Stewart Lowndes, Julian During, Justinas Petuchovas, Kara Woo, @kdpsingh, Kenny Darrell, Kirill Sevastyanenko, @koalabearski, @KyleHumphrey, Lawrence Wu, Matthew Sedaghatfar, Mine Cetinkaya-Rundel, @MJMarshall, Mustafa Ascha, @nate-d-olson, Nelson Areal, Nick Clark, @nickelas, Nirmal Patel, @nwaff, @OaCantona, Patrick Kennedy, @Paul, Peter Hurford, Rademeyer Vermaak, Radu Grosu, @rlzijdeman, Robert Schuessler, @robinlovelace, @robinsones, S’busiso Mkhondwane, @seamus-mckinsey, @seanpwilliams, Shannon Ellis, @shoili, @sibusiso16, @spirgel, Steve Mortimer, @svenski, Terence Teo, Thomas Klebel, TJ Mahr, Tom Prior, Will Beasley, @yahwes, Yihui Xie, @zeal626.

<h2>1.8 Colophon</h2>
An online version of this book is available at <a href="http://r4ds.had.co.nz" class="uri">http://r4ds.had.co.nz</a>. 
It will continue to evolve in between reprints of the physical book. 
The source of the book is available at <a href="https://github.com/hadley/r4ds" class="uri">https://github.com/hadley/r4ds</a>. 
The book is powered by <a href="https://bookdown.org" class="uri">https://bookdown.org</a> which makes it easy to turn R markdown files into HTML, PDF, and EPUB.

This book was built with:

<code>sessioninfo::session_info(c("tidyverse"))</a>
#> ─ Session info ───────────────────────────────────────────────────────────────</a>
#>  setting  value                       </a>
#>  version  R version 4.0.0 (2020-04-24)</a>
#>  os       Ubuntu 16.04.6 LTS          </a>
#>  system   x86_64, linux-gnu           </a>
#>  ui       X11                         </a>
#>  language en_US.UTF-8                 </a>
#>  collate  en_US.UTF-8                 </a>
#>  ctype    en_US.UTF-8                 </a>
#>  tz       UTC                         </a>
#>  date     2020-05-08                  </a>
#> </a>
#> ─ Packages ───────────────────────────────────────────────────────────────────</a>
#>  package      * version  date       lib source        </a>
#>  askpass        1.1      2019-01-13 [1] CRAN (R 4.0.0)</a>
#>  assertthat     0.2.1    2019-03-21 [1] CRAN (R 4.0.0)</a>
#>  backports      1.1.6    2020-04-05 [1] CRAN (R 4.0.0)</a>
#>  base64enc      0.1-3    2015-07-28 [1] CRAN (R 4.0.0)</a>
#>  BH             1.72.0-3 2020-01-08 [1] CRAN (R 4.0.0)</a>
#>  broom          0.5.6    2020-04-20 [1] CRAN (R 4.0.0)</a>
#>  callr          3.4.3    2020-03-28 [1] CRAN (R 4.0.0)</a>
#>  cellranger     1.1.0    2016-07-27 [1] CRAN (R 4.0.0)</a>
#>  cli            2.0.2    2020-02-28 [1] CRAN (R 4.0.0)</a>
#>  clipr          0.7.0    2019-07-23 [1] CRAN (R 4.0.0)</a>
#>  colorspace     1.4-1    2019-03-18 [1] CRAN (R 4.0.0)</a>
#>  crayon         1.3.4    2017-09-16 [1] CRAN (R 4.0.0)</a>
#>  curl           4.3      2019-12-02 [1] CRAN (R 4.0.0)</a>
#>  DBI            1.1.0    2019-12-15 [1] CRAN (R 4.0.0)</a>
#>  dbplyr         1.4.3    2020-04-19 [1] CRAN (R 4.0.0)</a>
#>  desc           1.2.0    2018-05-01 [1] CRAN (R 4.0.0)</a>
#>  digest         0.6.25   2020-02-23 [1] CRAN (R 4.0.0)</a>
#>  dplyr        * 0.8.5    2020-03-07 [1] CRAN (R 4.0.0)</a>
#>  ellipsis       0.3.0    2019-09-20 [1] CRAN (R 4.0.0)</a>
#>  evaluate       0.14     2019-05-28 [1] CRAN (R 4.0.0)</a>
#>  fansi          0.4.1    2020-01-08 [1] CRAN (R 4.0.0)</a>
#>  farver         2.0.3    2020-01-16 [1] CRAN (R 4.0.0)</a>
#>  forcats      * 0.5.0    2020-03-01 [1] CRAN (R 4.0.0)</a>
#>  fs             1.4.1    2020-04-04 [1] CRAN (R 4.0.0)</a>
#>  generics       0.0.2    2018-11-29 [1] CRAN (R 4.0.0)</a>
#>  ggplot2      * 3.3.0    2020-03-05 [1] CRAN (R 4.0.0)</a>
#>  glue           1.4.0    2020-04-03 [1] CRAN (R 4.0.0)</a>
#>  gtable         0.3.0    2019-03-25 [1] CRAN (R 4.0.0)</a>
#>  haven          2.2.0    2019-11-08 [1] CRAN (R 4.0.0)</a>
#>  highr          0.8      2019-03-20 [1] CRAN (R 4.0.0)</a>
#>  hms            0.5.3    2020-01-08 [1] CRAN (R 4.0.0)</a>
#>  htmltools      0.4.0    2019-10-04 [1] CRAN (R 4.0.0)</a>
#>  httr           1.4.1    2019-08-05 [1] CRAN (R 4.0.0)</a>
#>  isoband        0.2.1    2020-04-12 [1] CRAN (R 4.0.0)</a>
#>  jsonlite       1.6.1    2020-02-02 [1] CRAN (R 4.0.0)</a>
#>  knitr          1.28     2020-02-06 [1] CRAN (R 4.0.0)</a>
#>  labeling       0.3      2014-08-23 [1] CRAN (R 4.0.0)</a>
#>  lattice        0.20-41  2020-04-02 [3] CRAN (R 4.0.0)</a>
#>  lifecycle      0.2.0    2020-03-06 [1] CRAN (R 4.0.0)</a>
#>  lubridate      1.7.8    2020-04-06 [1] CRAN (R 4.0.0)</a>
#>  magrittr       1.5      2014-11-22 [1] CRAN (R 4.0.0)</a>
#>  markdown       1.1      2019-08-07 [1] CRAN (R 4.0.0)</a>
#>  MASS           7.3-51.5 2019-12-20 [3] CRAN (R 4.0.0)</a>
#>  Matrix         1.2-18   2019-11-27 [3] CRAN (R 4.0.0)</a>
#>  mgcv           1.8-31   2019-11-09 [3] CRAN (R 4.0.0)</a>
#>  mime           0.9      2020-02-04 [1] CRAN (R 4.0.0)</a>
#>  modelr         0.1.7    2020-04-30 [1] CRAN (R 4.0.0)</a>
#>  munsell        0.5.0    2018-06-12 [1] CRAN (R 4.0.0)</a>
#>  nlme           3.1-147  2020-04-13 [3] CRAN (R 4.0.0)</a>
#>  openssl        1.4.1    2019-07-18 [1] CRAN (R 4.0.0)</a>
#>  pillar         1.4.4    2020-05-05 [1] CRAN (R 4.0.0)</a>
#>  pkgbuild       1.0.8    2020-05-07 [1] CRAN (R 4.0.0)</a>
#>  pkgconfig      2.0.3    2019-09-22 [1] CRAN (R 4.0.0)</a>
#>  pkgload        1.0.2    2018-10-29 [1] CRAN (R 4.0.0)</a>
#>  plogr          0.2.0    2018-03-25 [1] CRAN (R 4.0.0)</a>
#>  plyr           1.8.6    2020-03-03 [1] CRAN (R 4.0.0)</a>
#>  praise         1.0.0    2015-08-11 [1] CRAN (R 4.0.0)</a>
#>  prettyunits    1.1.1    2020-01-24 [1] CRAN (R 4.0.0)</a>
#>  processx       3.4.2    2020-02-09 [1] CRAN (R 4.0.0)</a>
#>  progress       1.2.2    2019-05-16 [1] CRAN (R 4.0.0)</a>
#>  ps             1.3.3    2020-05-08 [1] CRAN (R 4.0.0)</a>
#>  purrr        * 0.3.4    2020-04-17 [1] CRAN (R 4.0.0)</a>
#>  R6             2.4.1    2019-11-12 [1] CRAN (R 4.0.0)</a>
#>  RColorBrewer   1.1-2    2014-12-07 [1] CRAN (R 4.0.0)</a>
#>  Rcpp           1.0.4.6  2020-04-09 [1] CRAN (R 4.0.0)</a>
#>  readr        * 1.3.1    2018-12-21 [1] CRAN (R 4.0.0)</a>
#>  readxl         1.3.1    2019-03-13 [1] CRAN (R 4.0.0)</a>
#>  rematch        1.0.1    2016-04-21 [1] CRAN (R 4.0.0)</a>
#>  reprex         0.3.0    2019-05-16 [1] CRAN (R 4.0.0)</a>
#>  reshape2       1.4.4    2020-04-09 [1] CRAN (R 4.0.0)</a>
#>  rlang          0.4.6    2020-05-02 [1] CRAN (R 4.0.0)</a>
#>  rmarkdown      2.1      2020-01-20 [1] CRAN (R 4.0.0)</a>
#>  rprojroot      1.3-2    2018-01-03 [1] CRAN (R 4.0.0)</a>
#>  rstudioapi     0.11     2020-02-07 [1] CRAN (R 4.0.0)</a>
#>  rvest          0.3.5    2019-11-08 [1] CRAN (R 4.0.0)</a>
#>  scales         1.1.0    2019-11-18 [1] CRAN (R 4.0.0)</a>
#>  selectr        0.4-2    2019-11-20 [1] CRAN (R 4.0.0)</a>
#>  stringi        1.4.6    2020-02-17 [1] CRAN (R 4.0.0)</a>
#>  stringr      * 1.4.0    2019-02-10 [1] CRAN (R 4.0.0)</a>
#>  sys            3.3      2019-08-21 [1] CRAN (R 4.0.0)</a>
#>  testthat       2.3.2    2020-03-02 [1] CRAN (R 4.0.0)</a>
#>  tibble       * 3.0.1    2020-04-20 [1] CRAN (R 4.0.0)</a>
#>  tidyr        * 1.0.3    2020-05-07 [1] CRAN (R 4.0.0)</a>
#>  tidyselect     1.0.0    2020-01-27 [1] CRAN (R 4.0.0)</a>
#>  tidyverse    * 1.3.0    2019-11-21 [1] CRAN (R 4.0.0)</a>
#>  tinytex        0.22     2020-04-17 [1] CRAN (R 4.0.0)</a>
#>  utf8           1.1.4    2018-05-24 [1] CRAN (R 4.0.0)</a>
#>  vctrs          0.2.4    2020-03-10 [1] CRAN (R 4.0.0)</a>
#>  viridisLite    0.3.0    2018-02-01 [1] CRAN (R 4.0.0)</a>
#>  whisker        0.4      2019-08-28 [1] CRAN (R 4.0.0)</a>
#>  withr          2.2.0    2020-04-20 [1] CRAN (R 4.0.0)</a>
#>  xfun           0.13     2020-04-13 [1] CRAN (R 4.0.0)</a>
#>  xml2           1.3.2    2020-04-23 [1] CRAN (R 4.0.0)</a>
#>  yaml           2.2.1    2020-02-01 [1] CRAN (R 4.0.0)</a>
#> </a>
#> [1] /home/travis/R/Library</a>
#> [2] /usr/local/lib/R/site-library</a>
#> [3] /home/travis/R-bin/lib/R/library</code>

<h2><span class="orange">2 Introduction</span></h2>
The goal of the first part of this book is to get you up to speed with the basic tools of data exploration as quickly as possible. 
Data exploration is the art of looking at your data, rapidly generating hypotheses, quickly testing them, then repeating again and again and again. 
The goal of data exploration is to generate many promising leads that you can later explore in more depth.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/795c039ba2520455d833b4034befc8cf360a70ba/558a5/diagrams/data-science-explore.png" width="75%" style="display: block; margin: auto;" />

In this part of the book you will learn some useful tools that have an immediate payoff:

Visualisation is a great place to start with R programming, because the
payoff is so clear: you get to make elegant and informative plots that help
you understand data. 
In <a href="data-visualisation.html#data-visualisation">data visualisation</a> you’ll dive into visualisation,
learning the basic structure of a ggplot2 plot, and powerful techniques for
turning data into plots.

Visualisation alone is typically not enough, so in <a href="transform.html#transform">data transformation</a>
you’ll learn the key verbs that allow you to select important variables,
filter out key observations, create new variables, and compute summaries.

Finally, in <a href="exploratory-data-analysis.html#exploratory-data-analysis">exploratory data analysis</a>, you’ll combine visualisation and
transformation with your curiosity and scepticism to ask and answer
interesting questions about data.

Modelling is an important part of the exploratory process, but you don’t have the skills to effectively learn or apply it yet. 
We’ll come back to it in <a href="model-intro.html#model-intro">modelling</a>, once you’re better equipped with more data wrangling and programming tools.

Nestled among these three chapters that teach you the tools of exploration are three chapters that focus on your R workflow. 
In <a href="workflow-basics.html#workflow-basics">workflow: basics</a>, <a href="workflow-scripts.html#workflow-scripts">workflow: scripts</a>, and <a href="workflow-projects.html#workflow-projects">workflow: projects</a> you’ll learn good practices for writing and organising your R code. 
These will set you up for success in the long run, as they’ll give you the tools to stay organised when you tackle real projects.

<h2><span class="orange">3 Data visualisation</span></h2>

<h2>3.1 Introduction</h2>
<blockquote>
'The simple graph has brought more information to the data analyst’s mind
than any other device.' — John Tukey

</blockquote>
This chapter will teach you how to visualise your data using ggplot2. 
R has several systems for making graphs, but ggplot2 is one of the most elegant and most versatile. 
ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. 
With ggplot2, you can do more faster by learning one system and applying it in many places.

If you’d like to learn more about the theoretical underpinnings of ggplot2 before you start, I’d recommend reading 'The Layered Grammar of Graphics', <a href="http://vita.had.co.nz/papers/layered-grammar.pdf" class="uri">http://vita.had.co.nz/papers/layered-grammar.pdf</a>.

<h3>3.1.1 Prerequisites</h3>
This chapter focusses on ggplot2, one of the core members of the tidyverse. 
To access the datasets, help pages, and functions that we will use in this chapter, load the tidyverse by running this code:

<code>library(tidyverse)</a>
#> ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──</a>
#> ✔ ggplot2 3.3.0     ✔ purrr   0.3.4</a>
#> ✔ tibble  3.0.1     ✔ dplyr   0.8.5</a>
#> ✔ tidyr   1.0.3     ✔ stringr 1.4.0</a>
#> ✔ readr   1.3.1     ✔ forcats 0.5.0</a>
#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──</a>
#> ✖ dplyr::filter() masks stats::filter()</a>
#> ✖ dplyr::lag()    masks stats::lag()</code>

That one line of code loads the core tidyverse; packages which you will use in almost every data analysis. 
It also tells you which functions from the tidyverse conflict with functions in base R (or from other packages you might have loaded).

If you run this code and get the error message 'there is no package called ‘tidyverse’', you’ll need to first install it, then run <code>library()</code> once again.

<code>install.packages("tidyverse")</a>
library(tidyverse)</code>

You only need to install a package once, but you need to reload it every time you start a new session.

If we need to be explicit about where a function (or dataset) comes from, we’ll use the special form <code>package::function()</code>. 
For example, <code>ggplot2::ggplot()</code> tells you explicitly that we’re using the <code>ggplot()</code> function from the ggplot2 package.

<h2>3.2 First steps</h2>
Let’s use our first graph to answer a question: Do cars with big engines use more fuel than cars with small engines? You probably already have an answer, but try to make your answer precise. 
What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

<h3>3.2.1 The <code>mpg</code> data frame</h3>
You can test your answer with the <code>mpg</code> data frame found in ggplot2 (aka <code>ggplot2::mpg</code>). 
A data frame is a rectangular collection of variables (in the columns) and observations (in the rows). 
<code>mpg</code> contains observations collected by the US Environmental Protection Agency on 38 models of car.

<code>mpg</a>
#> # A tibble: 234 x 11</a>
#>   manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class </a>
#>   &lt;chr>        &lt;chr> &lt;dbl> &lt;int> &lt;int> &lt;chr>      &lt;chr> &lt;int> &lt;int> &lt;chr> &lt;chr> </a>
#> 1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…</a>
#> 2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…</a>
#> 3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…</a>
#> 4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…</a>
#> 5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…</a>
#> 6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…</a>
#> # … with 228 more rows</code>

Among the variables in <code>mpg</code> are:

<code>displ</code>, a car’s engine size, in litres.

<code>hwy</code>, a car’s fuel efficiency on the highway, in miles per gallon (mpg).
A car with a low fuel efficiency consumes more fuel than a car with a high
fuel efficiency when they travel the same distance.

To learn more about <code>mpg</code>, open its help page by running <code>?mpg</code>.

<h3>3.2.2 Creating a ggplot</h3>
To plot <code>mpg</code>, run this code to put <code>displ</code> on the x-axis and <code>hwy</code> on the y-axis:

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/27f75d757f210f2106c34e399f5d32b667a653f8/06071/visualize_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" />

The plot shows a negative relationship between engine size (<code>displ</code>) and fuel efficiency (<code>hwy</code>). 
In other words, cars with big engines use more fuel. 
Does this confirm or refute your hypothesis about fuel efficiency and engine size?

With ggplot2, you begin a plot with the function <code>ggplot()</code>. 
<code>ggplot()</code> creates a coordinate system that you can add layers to. 
The first argument of <code>ggplot()</code> is the dataset to use in the graph. 
So <code>ggplot(data = mpg)</code> creates an empty graph, but it’s not very interesting so I’m not going to show it here.

You complete your graph by adding one or more layers to <code>ggplot()</code>. 
The function <code>geom_point()</code> adds a layer of points to your plot, which creates a scatterplot. 
ggplot2 comes with many geom functions that each add a different type of layer to a plot. 
You’ll learn a whole bunch of them throughout this chapter.

Each geom function in ggplot2 takes a <code>mapping</code> argument. 
This defines how variables in your dataset are mapped to visual properties. 
The <code>mapping</code> argument is always paired with <code>aes()</code>, and the <code>x</code> and <code>y</code> arguments of <code>aes()</code> specify which variables to map to the x and y axes. 
ggplot2 looks for the mapped variables in the <code>data</code> argument, in this case, <code>mpg</code>.

<h3>3.2.3 A graphing template</h3>
Let’s turn this code into a reusable template for making graphs with ggplot2. 
To make a graph, replace the bracketed sections in the code below with a dataset, a geom function, or a collection of mappings.

<code>ggplot(data = &lt;DATA>) + </a>
  &lt;GEOM_FUNCTION>(mapping = aes(&lt;MAPPINGS>))</code>

The rest of this chapter will show you how to complete and extend this template to make different types of graphs. 
We will begin with the <code>&lt;MAPPINGS></code> component.

<h3>3.2.4 Exercises</h3>

Run <code>ggplot(data = mpg)</code>. 
What do you see?

How many rows are in <code>mpg</code>? How many columns?

What does the <code>drv</code> variable describe? Read the help for <code>?mpg</code> to find
out.

Make a scatterplot of <code>hwy</code> vs <code>cyl</code>.

What happens if you make a scatterplot of <code>class</code> vs <code>drv</code>? Why is
the plot not useful?

<h2>3.3 Aesthetic mappings</h2>
<blockquote>
'The greatest value of a picture is when it forces us to notice what we
never expected to see.' — John Tukey

</blockquote>
In the plot below, one group of points (highlighted in red) seems to fall outside of the linear trend. 
These cars have a higher mileage than you might expect. 
How can you explain these cars?

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/75fb0e8e533675ad76f647b02be462f7cfd2f1df/b7679/visualize_files/figure-html/unnamed-chunk-5-1.png" width="70%" style="display: block; margin: auto;" />

Let’s hypothesize that the cars are hybrids. 
One way to test this hypothesis is to look at the <code>class</code> value for each car. 
The <code>class</code> variable of the <code>mpg</code> dataset classifies cars into groups such as compact, midsize, and SUV. 
If the outlying points are hybrids, they should be classified as compact cars or, perhaps, subcompact cars (keep in mind that this data was collected before hybrid trucks and SUVs became popular).

You can add a third variable, like <code>class</code>, to a two dimensional scatterplot by mapping it to an aesthetic. 
An aesthetic is a visual property of the objects in your plot. 
Aesthetics include things like the size, the shape, or the color of your points. 
You can display a point (like the one below) in different ways by changing the values of its aesthetic properties. 
Since we already use the word 'value' to describe data, let’s use the word 'level' to describe aesthetic properties. 
Here we change the levels of a point’s size, shape, and color to make the point small, triangular, or blue:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2f8f27c472d7df78486e248c40931019b286361b/32a65/visualize_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" />

You can convey information about your data by mapping the aesthetics in your plot to the variables in your dataset. 
For example, you can map the colors of your points to the <code>class</code> variable to reveal the class of each car.

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy, color = class))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e86ceaf6b7f5dcad0bb0b7254f3270501dd60b50/3332a/visualize_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" />

(If you prefer British English, like Hadley, you can use <code>colour</code> instead of <code>color</code>.)

To map an aesthetic to a variable, associate the name of the aesthetic to the name of the variable inside <code>aes()</code>. 
ggplot2 will automatically assign a unique level of the aesthetic (here a unique color) to each unique value of the variable, a process known as scaling. 
ggplot2 will also add a legend that explains which levels correspond to which values.

The colors reveal that many of the unusual points are two-seater cars. 
These cars don’t seem like hybrids, and are, in fact, sports cars! Sports cars have large engines like SUVs and pickup trucks, but small bodies like midsize and compact cars, which improves their gas mileage. 
In hindsight, these cars were unlikely to be hybrids since they have large engines.

In the above example, we mapped <code>class</code> to the color aesthetic, but we could have mapped <code>class</code> to the size aesthetic in the same way. 
In this case, the exact size of each point would reveal its class affiliation. 
We get a <em>warning</em> here, because mapping an unordered variable (<code>class</code>) to an ordered aesthetic (<code>size</code>) is not a good idea.

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy, size = class))</a>
#> Warning: Using size for a discrete variable is not advised.</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7c338de8653204508c18a0b5e6bf98f3f66de257/d184c/visualize_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" />

Or we could have mapped <code>class</code> to the <em>alpha</em> aesthetic, which controls the transparency of the points, or to the shape aesthetic, which controls the shape of the points.

<code># Left</a>
ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))</a>
</a>
# Right</a>
ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4bc3b12fc5298232b9209c6b85cebae664d7b2b0/e71ad/visualize_files/figure-html/unnamed-chunk-9-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/aa31d29d26bad3c5377cc0132b7fa4b26308da88/6042a/visualize_files/figure-html/unnamed-chunk-9-2.png" width="50%" />

What happened to the SUVs? ggplot2 will only use six shapes at a time. 
By default, additional groups will go unplotted when you use the shape aesthetic.

For each aesthetic, you use <code>aes()</code> to associate the name of the aesthetic with a variable to display. 
The <code>aes()</code> function gathers together each of the aesthetic mappings used by a layer and passes them to the layer’s mapping argument. 
The syntax highlights a useful insight about <code>x</code> and <code>y</code>: the x and y locations of a point are themselves aesthetics, visual properties that you can map to variables to display information about the data.

Once you map an aesthetic, ggplot2 takes care of the rest. 
It selects a reasonable scale to use with the aesthetic, and it constructs a legend that explains the mapping between levels and values. 
For x and y aesthetics, ggplot2 does not create a legend, but it creates an axis line with tick marks and a label. 
The axis line acts as a legend; it explains the mapping between locations and values.

You can also <em>set</em> the aesthetic properties of your geom manually. 
For example, we can make all of the points in our plot blue:

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5bc19b1d6b8bb4c987c71c7128cb7b4cb5cb927a/9a57a/visualize_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

Here, the color doesn’t convey information about a variable, but only changes the appearance of the plot. 
To set an aesthetic manually, set the aesthetic by name as an argument of your geom function; i.e. it goes <em>outside</em> of <code>aes()</code>. 
You’ll need to pick a level that makes sense for that aesthetic:

The name of a color as a character string.

The size of a point in mm.

The shape of a point as a number, as shown in Figure <a href="data-visualisation.html#fig:shapes">3.1</a>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/58a48d625b4bd494cd685dd9998f5c74e9c16907/211c6/visualize_files/figure-html/shapes-1.png" alt="R has 25 built in shapes that are identified by numbers. 
There are some seeming duplicates: for example, 0, 15, and 22 are all squares. 
The difference comes from the interaction of the `colour` and `fill` aesthetics. 
The hollow shapes (0--14) have a border determined by `colour`; the solid shapes (15--18) are filled with `colour`; the filled shapes (21--24) have a border of `colour` and are filled with `fill`." width="75%" />

Figure 3.1: R has 25 built in shapes that are identified by numbers. 
There are some seeming duplicates: for example, 0, 15, and 22 are all squares. 
The difference comes from the interaction of the <code>colour</code> and <code>fill</code> aesthetics. 
The hollow shapes (0–14) have a border determined by <code>colour</code>; the solid shapes (15–18) are filled with <code>colour</code>; the filled shapes (21–24) have a border of <code>colour</code> and are filled with <code>fill</code>.

<h3>3.3.1 Exercises</h3>

What’s gone wrong with this code? Why are the points not blue?

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy, color = "blue"))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a5d53e34dd5b78eb6358b857db8037e4134ce1d7/33f7b/visualize_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" />

Which variables in <code>mpg</code> are categorical? Which variables are continuous?
(Hint: type <code>?mpg</code> to read the documentation for the dataset). 
How
can you see this information when you run <code>mpg</code>?

Map a continuous variable to <code>color</code>, <code>size</code>, and <code>shape</code>. 
How do
these aesthetics behave differently for categorical vs. continuous
variables?

What happens if you map the same variable to multiple aesthetics?

What does the <code>stroke</code> aesthetic do? What shapes does it work with?
(Hint: use <code>?geom_point</code>)

What happens if you map an aesthetic to something other than a variable
name, like <code>aes(colour = displ &lt; 5)</code>? Note, you’ll also need to specify x and y.

<h2>3.4 Common problems</h2>
As you start to run R code, you’re likely to run into problems. 
Don’t worry — it happens to everyone. 
I have been writing R code for years, and every day I still write code that doesn’t work!

Start by carefully comparing the code that you’re running to the code in the book. 
R is extremely picky, and a misplaced character can make all the difference. 
Make sure that every <code>(</code> is matched with a <code>)</code> and every <code>"</code> is paired with another <code>"</code>. 
Sometimes you’ll run the code and nothing happens. 
Check the left-hand of your console: if it’s a <code>+</code>, it means that R doesn’t think you’ve typed a complete expression and it’s waiting for you to finish it. 
In this case, it’s usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.

One common problem when creating ggplot2 graphics is to put the <code>+</code> in the wrong place: it has to come at the end of the line, not the start. 
In other words, make sure you haven’t accidentally written code like this:

<code>ggplot(data = mpg) </a>
+ geom_point(mapping = aes(x = displ, y = hwy))</code>

If you’re still stuck, try the help. 
You can get help about any R function by running <code>?function_name</code> in the console, or selecting the function name and pressing F1 in RStudio. 
Don’t worry if the help doesn’t seem that helpful - instead skip down to the examples and look for code that matches what you’re trying to do.

If that doesn’t help, carefully read the error message. 
Sometimes the answer will be buried there! But when you’re new to R, the answer might be in the error message but you don’t yet know how to understand it. 
Another great tool is Google: try googling the error message, as it’s likely someone else has had the same problem, and has gotten help online.

<h2>3.5 Facets</h2>
One way to add additional variables is with aesthetics. 
Another way, particularly useful for categorical variables, is to split your plot into facets, subplots that each display one subset of the data.

To facet your plot by a single variable, use <code>facet_wrap()</code>. 
The first argument of <code>facet_wrap()</code> should be a formula, which you create with <code>~</code> followed by a variable name (here 'formula' is the name of a data structure in R, not a synonym for 'equation'). 
The variable that you pass to <code>facet_wrap()</code> should be discrete.

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) + </a>
  facet_wrap(~ class, nrow = 2)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7b70e5c694d661644e49bcaa2fa8d923007cf718/b117d/visualize_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" />

To facet your plot on the combination of two variables, add <code>facet_grid()</code> to your plot call. 
The first argument of <code>facet_grid()</code> is also a formula. 
This time the formula should contain two variable names separated by a <code>~</code>.

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) + </a>
  facet_grid(drv ~ cyl)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/94b029204c691b958eb0c60c6915a19ee4d319bf/ceeb1/visualize_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" />

If you prefer to not facet in the rows or columns dimension, use a <code>.</code> instead of a variable name, e.g. 
<code>+ facet_grid(. 
~ cyl)</code>.

<h3>3.5.1 Exercises</h3>

What happens if you facet on a continuous variable?

What do the empty cells in plot with <code>facet_grid(drv ~ cyl)</code> mean?
How do they relate to this plot?

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = drv, y = cyl))</code>

What plots does the following code make? What does <code>.</code> do?

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) +</a>
  facet_grid(drv ~ .)</a>
</a>
ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) +</a>
  facet_grid(. 
~ cyl)</code>

Take the first faceted plot in this section:

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) + </a>
  facet_wrap(~ class, nrow = 2)</code>

What are the advantages to using faceting instead of the colour aesthetic?
What are the disadvantages? How might the balance change if you had a
larger dataset?

Read <code>?facet_wrap</code>. 
What does <code>nrow</code> do? What does <code>ncol</code> do? What other
options control the layout of the individual panels? Why doesn’t
<code>facet_grid()</code> have <code>nrow</code> and <code>ncol</code> arguments?

When using <code>facet_grid()</code> you should usually put the variable with more
unique levels in the columns. 
Why?

<h2>3.6 Geometric objects</h2>
How are these two plots similar?

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/27f75d757f210f2106c34e399f5d32b667a653f8/78a50/visualize_files/figure-html/unnamed-chunk-17-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3e4d5a44b35d0de122c81319995d5dcf484e6d71/7fb04/visualize_files/figure-html/unnamed-chunk-17-2.png" width="50%" />

Both plots contain the same x variable, the same y variable, and both describe the same data. 
But the plots are not identical. 
Each plot uses a different visual object to represent the data. 
In ggplot2 syntax, we say that they use different geoms.

A geom is the geometrical object that a plot uses to represent data. 
People often describe plots by the type of geom that the plot uses. 
For example, bar charts use bar geoms, line charts use line geoms, boxplots use boxplot geoms, and so on. 
Scatterplots break the trend; they use the point geom. 
As we see above, you can use different geoms to plot the same data. 
The plot on the left uses the point geom, and the plot on the right uses the smooth geom, a smooth line fitted to the data.

To change the geom in your plot, change the geom function that you add to <code>ggplot()</code>. 
For instance, to make the plots above, you can use this code:

<code># left</a>
ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy))</a>
</a>
# right</a>
ggplot(data = mpg) + </a>
  geom_smooth(mapping = aes(x = displ, y = hwy))</code>

Every geom function in ggplot2 takes a <code>mapping</code> argument. 
However, not every aesthetic works with every geom. 
You could set the shape of a point, but you couldn’t set the 'shape' of a line. 
On the other hand, you <em>could</em> set the linetype of a line. 
<code>geom_smooth()</code> will draw a different line, with a different linetype, for each unique value of the variable that you map to linetype.

<code>ggplot(data = mpg) + </a>
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/33b14521b673a6384c302e3df3008d1c3c034c6b/d3285/visualize_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

Here <code>geom_smooth()</code> separates the cars into three lines based on their <code>drv</code> value, which describes a car’s drivetrain. 
One line describes all of the points with a <code>4</code> value, one line describes all of the points with an <code>f</code> value, and one line describes all of the points with an <code>r</code> value. 
Here, <code>4</code> stands for four-wheel drive, <code>f</code> for front-wheel drive, and <code>r</code> for rear-wheel drive.

If this sounds strange, we can make it more clear by overlaying the lines on top of the raw data and then coloring everything according to <code>drv</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ef715987983fb850a25fda6cf2f13fbfb145949e/63c84/visualize_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

Notice that this plot contains two geoms in the same graph! If this makes you excited, buckle up. 
We will learn how to place multiple geoms in the same plot very soon.

ggplot2 provides over 40 geoms, and extension packages provide even more (see <a href="https://exts.ggplot2.tidyverse.org/gallery/" class="uri">https://exts.ggplot2.tidyverse.org/gallery/</a> for a sampling). 
The best way to get a comprehensive overview is the ggplot2 cheatsheet, which you can find at <a href="http://rstudio.com/cheatsheets" class="uri">http://rstudio.com/cheatsheets</a>. 
To learn more about any single geom, use help: <code>?geom_smooth</code>.

Many geoms, like <code>geom_smooth()</code>, use a single geometric object to display multiple rows of data. 
For these geoms, you can set the <code>group</code> aesthetic to a categorical variable to draw multiple objects. 
ggplot2 will draw a separate object for each unique value of the grouping variable. 
In practice, ggplot2 will automatically group the data for these geoms whenever you map an aesthetic to a discrete variable (as in the <code>linetype</code> example). 
It is convenient to rely on this feature because the group aesthetic by itself does not add a legend or distinguishing features to the geoms.

<code>ggplot(data = mpg) +</a>
  geom_smooth(mapping = aes(x = displ, y = hwy))</a>
              </a>
ggplot(data = mpg) +</a>
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))</a>
    </a>
ggplot(data = mpg) +</a>
  geom_smooth(</a>
    mapping = aes(x = displ, y = hwy, color = drv),</a>
    show.legend = FALSE</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4f68161679255e60089d8e7453623f9d347b6b77/be894/visualize_files/figure-html/unnamed-chunk-21-1.png" width="33%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2cd610393a828d04520144a1ff8bf669d2b9d790/86222/visualize_files/figure-html/unnamed-chunk-21-2.png" width="33%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6cb48f7f00aa119aab0db977306e6c0cd996a8d8/e4c41/visualize_files/figure-html/unnamed-chunk-21-3.png" width="33%" />

To display multiple geoms in the same plot, add multiple geom functions to <code>ggplot()</code>:

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy)) +</a>
  geom_smooth(mapping = aes(x = displ, y = hwy))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/62d36d8b7ebbc5ef9e97d3365e201a687214345b/5fbee/visualize_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" />

This, however, introduces some duplication in our code. 
Imagine if you wanted to change the y-axis to display <code>cty</code> instead of <code>hwy</code>. 
You’d need to change the variable in two places, and you might forget to update one. 
You can avoid this type of repetition by passing a set of mappings to <code>ggplot()</code>. 
ggplot2 will treat these mappings as global mappings that apply to each geom in the graph. 
In other words, this code will produce the same plot as the previous code:

<code>ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + </a>
  geom_point() + </a>
  geom_smooth()</code>

If you place mappings in a geom function, ggplot2 will treat them as local mappings for the layer. 
It will use these mappings to extend or overwrite the global mappings <em>for that layer only</em>. 
This makes it possible to display different aesthetics in different layers.

<code>ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + </a>
  geom_point(mapping = aes(color = class)) + </a>
  geom_smooth()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7891327afa80293f32eeb1537a8bc5eeeb080a5f/b81cb/visualize_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" />

You can use the same idea to specify different <code>data</code> for each layer. 
Here, our smooth line displays just a subset of the <code>mpg</code> dataset, the subcompact cars. 
The local data argument in <code>geom_smooth()</code> overrides the global data argument in <code>ggplot()</code> for that layer only.

<code>ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + </a>
  geom_point(mapping = aes(color = class)) + </a>
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9fd0c1378ccf6c177c4e69a979eb7a6ec83a7046/210c2/visualize_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" />

(You’ll learn how <code>filter()</code> works in the chapter on data transformations: for now, just know that this command selects only the subcompact cars.)

<h3>3.6.1 Exercises</h3>

What geom would you use to draw a line chart? A boxplot?
A histogram? An area chart?

Run this code in your head and predict what the output will look like.
Then, run the code in R and check your predictions.

<code>ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + </a>
  geom_point() + </a>
  geom_smooth(se = FALSE)</code>

What does <code>show.legend = FALSE</code> do? What happens if you remove it?<br />
Why do you think I used it earlier in the chapter?

What does the <code>se</code> argument to <code>geom_smooth()</code> do?

Will these two graphs look different? Why/why not?

<code>ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + </a>
  geom_point() + </a>
  geom_smooth()</a>
</a>
ggplot() + </a>
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + </a>
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))</code>

Recreate the R code necessary to generate the following graphs.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b819dffae32e7f12c87a8bbd580560f317f4523a/f6b1e/visualize_files/figure-html/unnamed-chunk-28-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/318e4be0737287c89213b736f85596e88d6e99fc/25f67/visualize_files/figure-html/unnamed-chunk-28-2.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/c189c975d29a9ae1cfdc306aa97f5f681725ed6d/59935/visualize_files/figure-html/unnamed-chunk-28-3.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d31556398e6ba4a1b7180004920183f6651ab2da/55dcd/visualize_files/figure-html/unnamed-chunk-28-4.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/86d4021ffb223d8aa907afc2cc1258f1d1f8e660/485cd/visualize_files/figure-html/unnamed-chunk-28-5.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ec80e012d371b22f36c7c88f714bc9f376b9492d/2affc/visualize_files/figure-html/unnamed-chunk-28-6.png" width="50%" />

<h2>3.7 Statistical transformations</h2>
Next, let’s take a look at a bar chart. 
Bar charts seem simple, but they are interesting because they reveal something subtle about plots. 
Consider a basic bar chart, as drawn with <code>geom_bar()</code>. 
The following chart displays the total number of diamonds in the <code>diamonds</code> dataset, grouped by <code>cut</code>. 
The <code>diamonds</code> dataset comes in ggplot2 and contains information about ~54,000 diamonds, including the <code>price</code>, <code>carat</code>, <code>color</code>, <code>clarity</code>, and <code>cut</code> of each diamond. 
The chart shows that more diamonds are available with high quality cuts than with low quality cuts.

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/80ff107e58e5bcfd21defc93467f2b3ed8ac7d07/de744/visualize_files/figure-html/unnamed-chunk-29-1.png" width="70%" style="display: block; margin: auto;" />

On the x-axis, the chart displays <code>cut</code>, a variable from <code>diamonds</code>. 
On the y-axis, it displays count, but count is not a variable in <code>diamonds</code>! Where does count come from? Many graphs, like scatterplots, plot the raw values of your dataset. 
Other graphs, like bar charts, calculate new values to plot:

bar charts, histograms, and frequency polygons bin your data
and then plot bin counts, the number of points that fall in each bin.

smoothers fit a model to your data and then plot predictions from the
model.

boxplots compute a robust summary of the distribution and then display a
specially formatted box.

The algorithm used to calculate new values for a graph is called a stat, short for statistical transformation. 
The figure below describes how this process works with <code>geom_bar()</code>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/70a3b18a1128c785d8676a48c005ee9b6a23cc00/7283c/images/visualization-stat-bar.png" width="100%" style="display: block; margin: auto;" />

You can learn which stat a geom uses by inspecting the default value for the <code>stat</code> argument. 
For example, <code>?geom_bar</code> shows that the default value for <code>stat</code> is 'count', which means that <code>geom_bar()</code> uses <code>stat_count()</code>. 
<code>stat_count()</code> is documented on the same page as <code>geom_bar()</code>, and if you scroll down you can find a section called 'Computed variables'. 
That describes how it computes two new variables: <code>count</code> and <code>prop</code>.

You can generally use geoms and stats interchangeably. 
For example, you can recreate the previous plot using <code>stat_count()</code> instead of <code>geom_bar()</code>:

<code>ggplot(data = diamonds) + </a>
  stat_count(mapping = aes(x = cut))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/80ff107e58e5bcfd21defc93467f2b3ed8ac7d07/60b92/visualize_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" />

This works because every geom has a default stat; and every stat has a default geom. 
This means that you can typically use geoms without worrying about the underlying statistical transformation. 
There are three reasons you might need to use a stat explicitly:

You might want to override the default stat. 
In the code below, I change
the stat of <code>geom_bar()</code> from count (the default) to identity. 
This lets
me map the height of the bars to the raw values of a \(y\) variable.
Unfortunately when people talk about bar charts casually, they might be
referring to this type of bar chart, where the height of the bar is already
present in the data, or the previous bar chart where the height of the bar
is generated by counting rows.

<code>demo &lt;- tribble(</a>
  ~cut,         ~freq,</a>
  "Fair",       1610,</a>
  "Good",       4906,</a>
  "Very Good",  12082,</a>
  "Premium",    13791,</a>
  "Ideal",      21551</a>
)</a>
</a>
ggplot(data = demo) +</a>
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5962e6af2f4e529f2970e5a871b53394e01b9fe6/6b704/visualize_files/figure-html/unnamed-chunk-32-1.png" width="70%" style="display: block; margin: auto;" />

(Don’t worry that you haven’t seen <code>&lt;-</code> or <code>tribble()</code> before. 
You might be
able to guess at their meaning from the context, and you’ll learn exactly
what they do soon!)

You might want to override the default mapping from transformed variables
to aesthetics. 
For example, you might want to display a bar chart of
proportion, rather than count:

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bd4332d1e865f0dd2b19be09c70fcd6d458b716d/92872/visualize_files/figure-html/unnamed-chunk-33-1.png" width="70%" style="display: block; margin: auto;" />

To find the variables computed by the stat, look for the help section
titled 'computed variables'.

You might want to draw greater attention to the statistical transformation
in your code. 
For example, you might use <code>stat_summary()</code>, which
summarises the y values for each unique x value, to draw
attention to the summary that you’re computing:

<code>ggplot(data = diamonds) + </a>
  stat_summary(</a>
    mapping = aes(x = cut, y = depth),</a>
    fun.ymin = min,</a>
    fun.ymax = max,</a>
    fun.y = median</a>
  )</a>
#> Warning: `fun.y` is deprecated. 
Use `fun` instead.</a>
#> Warning: `fun.ymin` is deprecated. 
Use `fun.min` instead.</a>
#> Warning: `fun.ymax` is deprecated. 
Use `fun.max` instead.</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d28677d83884efbb1bb3e154fcb3a8b4ad33c5a6/93328/visualize_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" />

ggplot2 provides over 20 stats for you to use. 
Each stat is a function, so you can get help in the usual way, e.g. 
<code>?stat_bin</code>. 
To see a complete list of stats, try the ggplot2 cheatsheet.

<h3>3.7.1 Exercises</h3>

What is the default geom associated with <code>stat_summary()</code>? How could
you rewrite the previous plot to use that geom function instead of the
stat function?

What does <code>geom_col()</code> do? How is it different to <code>geom_bar()</code>?

Most geoms and stats come in pairs that are almost always used in
concert. 
Read through the documentation and make a list of all the
pairs. 
What do they have in common?

What variables does <code>stat_smooth()</code> compute? What parameters control
its behaviour?

In our proportion bar chart, we need to set <code>group = 1</code>. 
Why? In other
words what is the problem with these two graphs?

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, y = ..prop..))</a>
ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))</code>

<h2>3.8 Position adjustments</h2>
There’s one more piece of magic associated with bar charts. 
You can colour a bar chart using either the <code>colour</code> aesthetic, or, more usefully, <code>fill</code>:

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, colour = cut))</a>
ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, fill = cut))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9393ff1cb19d12c3e2c6fb0907a8abec0266afd2/4506b/visualize_files/figure-html/unnamed-chunk-36-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7b810f000698f595cdf8155d0d0bdff3bbd1255e/dc244/visualize_files/figure-html/unnamed-chunk-36-2.png" width="50%" />

Note what happens if you map the fill aesthetic to another variable, like <code>clarity</code>: the bars are automatically stacked. 
Each colored rectangle represents a combination of <code>cut</code> and <code>clarity</code>.

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, fill = clarity))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b781966a14bd0a8d9569ba1bc32a66a7472ab1ad/506ac/visualize_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" />

The stacking is performed automatically by the position adjustment specified by the <code>position</code> argument. 
If you don’t want a stacked bar chart, you can use one of three other options: <code>"identity"</code>, <code>"dodge"</code> or <code>"fill"</code>.

<code>position = "identity"</code> will place each object exactly where it falls in
the context of the graph. 
This is not very useful for bars, because it
overlaps them. 
To see that overlapping we either need to make the bars
slightly transparent by setting <code>alpha</code> to a small value, or completely
transparent by setting <code>fill = NA</code>.

<code>ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + </a>
  geom_bar(alpha = 1/5, position = "identity")</a>
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + </a>
  geom_bar(fill = NA, position = "identity")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3a9772286d193f2dfec75877a51595c6e42c7b1e/5ef4a/visualize_files/figure-html/unnamed-chunk-38-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/12450cced607dd38015321ee077b3d500cf66274/a67f8/visualize_files/figure-html/unnamed-chunk-38-2.png" width="50%" />

The identity position adjustment is more useful for 2d geoms, like points,
where it is the default.

<code>position = "fill"</code> works like stacking, but makes each set of stacked bars
the same height. 
This makes it easier to compare proportions across
groups.

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bee92a133ce00474619d9988a9cffddefae7a1c5/015d7/visualize_files/figure-html/unnamed-chunk-39-1.png" width="70%" style="display: block; margin: auto;" />

<code>position = "dodge"</code> places overlapping objects directly <em>beside</em> one
another. 
This makes it easier to compare individual values.

<code>ggplot(data = diamonds) + </a>
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/448fcff74e08a75c969cbeea6e120d9c5f3caf32/4c14e/visualize_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" />

There’s one other type of adjustment that’s not useful for bar charts, but it can be very useful for scatterplots. 
Recall our first scatterplot. 
Did you notice that the plot displays only 126 points, even though there are 234 observations in the dataset?

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/27f75d757f210f2106c34e399f5d32b667a653f8/d3c00/visualize_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" />

The values of <code>hwy</code> and <code>displ</code> are rounded so the points appear on a grid and many points overlap each other. 
This problem is known as overplotting. 
This arrangement makes it hard to see where the mass of the data is. 
Are the data points spread equally throughout the graph, or is there one special combination of <code>hwy</code> and <code>displ</code> that contains 109 values?

You can avoid this gridding by setting the position adjustment to 'jitter'. 
<code>position = "jitter"</code> adds a small amount of random noise to each point. 
This spreads the points out because no two points are likely to receive the same amount of random noise.

<code>ggplot(data = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/115fc4d17743511db8db3413083ca34e7b725398/5f210/visualize_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" />

Adding randomness seems like a strange way to improve your plot, but while it makes your graph less accurate at small scales, it makes your graph <em>more</em> revealing at large scales. 
Because this is such a useful operation, ggplot2 comes with a shorthand for <code>geom_point(position = "jitter")</code>: <code>geom_jitter()</code>.

To learn more about a position adjustment, look up the help page associated with each adjustment: <code>?position_dodge</code>, <code>?position_fill</code>, <code>?position_identity</code>, <code>?position_jitter</code>, and <code>?position_stack</code>.

<h3>3.8.1 Exercises</h3>

What is the problem with this plot? How could you improve it?

<code>ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + </a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/359fed997078164ed12216dd29298615081cf52c/b74e0/visualize_files/figure-html/unnamed-chunk-43-1.png" width="70%" style="display: block; margin: auto;" />

What parameters to <code>geom_jitter()</code> control the amount of jittering?

Compare and contrast <code>geom_jitter()</code> with <code>geom_count()</code>.

What’s the default position adjustment for <code>geom_boxplot()</code>? Create
a visualisation of the <code>mpg</code> dataset that demonstrates it.

<h2>3.9 Coordinate systems</h2>
Coordinate systems are probably the most complicated part of ggplot2. 
The default coordinate system is the Cartesian coordinate system where the x and y positions act independently to determine the location of each point. 
There are a number of other coordinate systems that are occasionally helpful.

<code>coord_flip()</code> switches the x and y axes. 
This is useful (for example),
if you want horizontal boxplots. 
It’s also useful for long labels: it’s
hard to get them to fit without overlapping on the x-axis.

<code>ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + </a>
  geom_boxplot()</a>
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + </a>
  geom_boxplot() +</a>
  coord_flip()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/8e56f5c56aab9273d0e4e968b08ba038fb09e779/6a3b3/visualize_files/figure-html/unnamed-chunk-44-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e30eac02f2c9749b8a46dcf6fa893353b7e30d21/24b34/visualize_files/figure-html/unnamed-chunk-44-2.png" width="50%" />

<code>coord_quickmap()</code> sets the aspect ratio correctly for maps. 
This is very
important if you’re plotting spatial data with ggplot2 (which unfortunately
we don’t have the space to cover in this book).

<code>nz &lt;- map_data("nz")</a>
</a>
ggplot(nz, aes(long, lat, group = group)) +</a>
  geom_polygon(fill = "white", colour = "black")</a>
</a>
ggplot(nz, aes(long, lat, group = group)) +</a>
  geom_polygon(fill = "white", colour = "black") +</a>
  coord_quickmap()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1ae191a507d52b90cc5ad3cd894267457709afef/89d95/visualize_files/figure-html/unnamed-chunk-45-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d028cb1602c79e0dee31b7f31f027adea2b76eb9/d10bf/visualize_files/figure-html/unnamed-chunk-45-2.png" width="50%" />

<code>coord_polar()</code> uses polar coordinates. 
Polar coordinates reveal an
interesting connection between a bar chart and a Coxcomb chart.

<code>bar &lt;- ggplot(data = diamonds) + </a>
  geom_bar(</a>
    mapping = aes(x = cut, fill = cut), </a>
    show.legend = FALSE,</a>
    width = 1</a>
  ) + </a>
  theme(aspect.ratio = 1) +</a>
  labs(x = NULL, y = NULL)</a>
</a>
bar + coord_flip()</a>
bar + coord_polar()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6cfab2e0f0fd1550b3496b3f612d2636073cef98/f052b/visualize_files/figure-html/unnamed-chunk-46-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/42b22e13ee7afdbba6be3cf8d096b30134fd4ae5/1a919/visualize_files/figure-html/unnamed-chunk-46-2.png" width="50%" />

<h3>3.9.1 Exercises</h3>

Turn a stacked bar chart into a pie chart using <code>coord_polar()</code>.

What does <code>labs()</code> do? Read the documentation.

What’s the difference between <code>coord_quickmap()</code> and <code>coord_map()</code>?

What does the plot below tell you about the relationship between city
and highway mpg? Why is <code>coord_fixed()</code> important? What does
<code>geom_abline()</code> do?

<code>ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +</a>
  geom_point() + </a>
  geom_abline() +</a>
  coord_fixed()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/129980f5d833a281eb1320adb3be762d49048fd2/23ea3/visualize_files/figure-html/unnamed-chunk-47-1.png" width="50%" style="display: block; margin: auto;" />

<h2>3.10 The layered grammar of graphics</h2>
In the previous sections, you learned much more than how to make scatterplots, bar charts, and boxplots. 
You learned a foundation that you can use to make <em>any</em> type of plot with ggplot2. 
To see this, let’s add position adjustments, stats, coordinate systems, and faceting to our code template:

<code>ggplot(data = &lt;DATA>) + 
  &lt;GEOM_FUNCTION>(
     mapping = aes(&lt;MAPPINGS>),
     stat = &lt;STAT>, 
     position = &lt;POSITION>
  ) +
  &lt;COORDINATE_FUNCTION> +
  &lt;FACET_FUNCTION></code>

Our new template takes seven parameters, the bracketed words that appear in the template. 
In practice, you rarely need to supply all seven parameters to make a graph because ggplot2 will provide useful defaults for everything except the data, the mappings, and the geom function.

The seven parameters in the template compose the grammar of graphics, a formal system for building plots. 
The grammar of graphics is based on the insight that you can uniquely describe <em>any</em> plot as a combination of a dataset, a geom, a set of mappings, a stat, a position adjustment, a coordinate system, and a faceting scheme.

To see how this works, consider how you could build a basic plot from scratch: you could start with a dataset and then transform it into the information that you want to display (with a stat).

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d0509055ae83fd3fdac92d03642441386e382f39/6f4ff/images/visualization-grammar-1.png" width="100%" style="display: block; margin: auto;" />

Next, you could choose a geometric object to represent each observation in the transformed data. 
You could then use the aesthetic properties of the geoms to represent variables in the data. 
You would map the values of each variable to the levels of an aesthetic.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1893b4624cb3eacb925eba80868e3e1023fc2855/09d50/images/visualization-grammar-2.png" width="100%" style="display: block; margin: auto;" />

You’d then select a coordinate system to place the geoms into. 
You’d use the location of the objects (which is itself an aesthetic property) to display the values of the x and y variables. 
At that point, you would have a complete graph, but you could further adjust the positions of the geoms within the coordinate system (a position adjustment) or split the graph into subplots (faceting). 
You could also extend the plot by adding one or more additional layers, where each additional layer uses a dataset, a geom, a set of mappings, a stat, and a position adjustment.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/368a11a4f4e801c251ed1835643a0dfa85a3e2b7/1323b/images/visualization-grammar-3.png" width="100%" style="display: block; margin: auto;" />

You could use this method to build <em>any</em> plot that you imagine. 
In other words, you can use the code template that you’ve learned in this chapter to build hundreds of thousands of unique plots.

<h2><span class="orange">4 Workflow: basics</span></h2>
You now have some experience running R code. 
I didn’t give you many details, but you’ve obviously figured out the basics, or you would’ve thrown this book away in frustration! Frustration is natural when you start programming in R, because it is such a stickler for punctuation, and even one character out of place will cause it to complain. 
But while you should expect to be a little frustrated, take comfort in that it’s both typical and temporary: it happens to everyone, and the only way to get over it is to keep trying.

Before we go any further, let’s make sure you’ve got a solid foundation in running R code, and that you know about some of the most helpful RStudio features.

<h2>4.1 Coding basics</h2>
Let’s review some basics we’ve so far omitted in the interests of getting you plotting as quickly as possible. 
You can use R as a calculator:

<code>1 / 200 * 30</a>
#> [1] 0.15</a>
(59 + 73 + 2) / 3</a>
#> [1] 44.7</a>
sin(pi / 2)</a>
#> [1] 1</code>

You can create new objects with <code>&lt;-</code>:

<code>x &lt;- 3 * 4</code>

All R statements where you create objects, assignment statements, have the same form:

<code>object_name &lt;- value</code>

When reading that code say 'object name gets value' in your head.

You will make lots of assignments and <code>&lt;-</code> is a pain to type. 
Don’t be lazy and use <code>=</code>: it will work, but it will cause confusion later. 
Instead, use RStudio’s keyboard shortcut: Alt + - (the minus sign). 
Notice that RStudio automagically surrounds <code>&lt;-</code> with spaces, which is a good code formatting practice. 
Code is miserable to read on a good day, so giveyoureyesabreak and use spaces.

<h2>4.2 What’s in a name?</h2>
Object names must start with a letter, and can only contain letters, numbers, <code>_</code> and <code>.</code>. 
You want your object names to be descriptive, so you’ll need a convention for multiple words. 
I recommend snake_case where you separate lowercase words with <code>_</code>.

<code>i_use_snake_case</a>
otherPeopleUseCamelCase</a>
some.people.use.periods</a>
And_aFew.People_RENOUNCEconvention</code>

We’ll come back to code style later, in <a href="functions.html#functions">functions</a>.

You can inspect an object by typing its name:

<code>x</a>
#> [1] 12</code>

Make another assignment:

<code>this_is_a_really_long_name &lt;- 2.5</code>

To inspect this object, try out RStudio’s completion facility: type 'this', press TAB, add characters until you have a unique prefix, then press return.

Ooops, you made a mistake! <code>this_is_a_really_long_name</code> should have value 3.5 not 2.5. 
Use another keyboard shortcut to help you fix it. 
Type 'this' then press Cmd/Ctrl + ↑. 
That will list all the commands you’ve typed that start those letters. 
Use the arrow keys to navigate, then press enter to retype the command. 
Change 2.5 to 3.5 and rerun.

Make yet another assignment:

<code>r_rocks &lt;- 2 ^ 3</code>

Let’s try to inspect it:

<code>r_rock</a>
#> Error: object &#39;r_rock&#39; not found</a>
R_rocks</a>
#> Error: object &#39;R_rocks&#39; not found</code>

There’s an implied contract between you and R: it will do the tedious computation for you, but in return, you must be completely precise in your instructions. 
Typos matter. 
Case matters.

<h2>4.3 Calling functions</h2>
R has a large collection of built-in functions that are called like this:

<code>function_name(arg1 = val1, arg2 = val2, ...)</code>

Let’s try using <code>seq()</code> which makes regular sequences of numbers and, while we’re at it, learn more helpful features of RStudio. 
Type <code>se</code> and hit TAB. 
A popup shows you possible completions. 
Specify <code>seq()</code> by typing more (a 'q') to disambiguate, or by using ↑/↓ arrows to select. 
Notice the floating tooltip that pops up, reminding you of the function’s arguments and purpose. 
If you want more help, press F1 to get all the details in the help tab in the lower right pane.

Press TAB once more when you’ve selected the function you want. 
RStudio will add matching opening (<code>(</code>) and closing (<code>)</code>) parentheses for you. 
Type the arguments <code>1, 10</code> and hit return.

<code>seq(1, 10)</a>
#>  [1]  1  2  3  4  5  6  7  8  9 10</code>

Type this code and notice you get similar assistance with the paired quotation marks:

<code>x &lt;- "hello world"</code>

Quotation marks and parentheses must always come in a pair. 
RStudio does its best to help you, but it’s still possible to mess up and end up with a mismatch. 
If this happens, R will show you the continuation character '+':

<code>> x &lt;- "hello
+</code>

The <code>+</code> tells you that R is waiting for more input; it doesn’t think you’re done yet. 
Usually that means you’ve forgotten either a <code>"</code> or a <code>)</code>. 
Either add the missing pair, or press ESCAPE to abort the expression and try again.

If you make an assignment, you don’t get to see the value. 
You’re then tempted to immediately double-check the result:

<code>y &lt;- seq(1, 10, length.out = 5)</a>
y</a>
#> [1]  1.00  3.25  5.50  7.75 10.00</code>

This common action can be shortened by surrounding the assignment with parentheses, which causes assignment and 'print to screen' to happen.

<code>(y &lt;- seq(1, 10, length.out = 5))</a>
#> [1]  1.00  3.25  5.50  7.75 10.00</code>

Now look at your environment in the upper right pane:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/879c123dfbcc5fffd44d58b6da97f6cba58968c8/d96e4/screenshots/rstudio-env.png" width="597" style="display: block; margin: auto;" />

Here you can see all of the objects that you’ve created.

<h2>4.4 Exercises</h2>

Why does this code not work?

<code>my_variable &lt;- 10</a>
my_varıable</a>
#> Error in eval(expr, envir, enclos): object &#39;my_varıable&#39; not found</code>

Look carefully! (This may seem like an exercise in pointlessness, but
training your brain to notice even the tiniest difference will pay off
when programming.)

Tweak each of the following R commands so that they run correctly:

<code>library(tidyverse)</a>
</a>
ggplot(dota = mpg) + </a>
  geom_point(mapping = aes(x = displ, y = hwy))</a>
</a>
fliter(mpg, cyl = 8)</a>
filter(diamond, carat > 3)</code>

Press Alt + Shift + K. 
What happens? How can you get to the same place
using the menus?

<h2><span class="orange">5 Data transformation</span></h2>

<h2>5.1 Introduction</h2>
Visualisation is an important tool for insight generation, but it is rare that you get the data in exactly the right form you need. 
Often you’ll need to create some new variables or summaries, or maybe you just want to rename the variables or reorder the observations in order to make the data a little easier to work with. 
You’ll learn how to do all that (and more!) in this chapter, which will teach you how to transform your data using the dplyr package and a new dataset on flights departing New York City in 2013.

<h3>5.1.1 Prerequisites</h3>
In this chapter we’re going to focus on how to use the dplyr package, another core member of the tidyverse. 
We’ll illustrate the key ideas using data from the nycflights13 package, and use ggplot2 to help us understand the data.

<code>library(nycflights13)</a>
library(tidyverse)</code>

Take careful note of the conflicts message that’s printed when you load the tidyverse. 
It tells you that dplyr overwrites some functions in base R. 
If you want to use the base version of these functions after loading dplyr, you’ll need to use their full names: <code>stats::filter()</code> and <code>stats::lag()</code>.

<h3>5.1.2 nycflights13</h3>
To explore the basic data manipulation verbs of dplyr, we’ll use <code>nycflights13::flights</code>. 
This data frame contains all 336,776 flights that departed from New York City in 2013. 
The data comes from the US <a href="http://www.transtats.bts.gov/DatabaseInfo.asp?DB_ID=120&amp;Link=0">Bureau of Transportation Statistics</a>, and is documented in <code>?flights</code>.

<code>flights</a>
#> # A tibble: 336,776 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1      533            529         4      850            830</a>
#> 3  2013     1     1      542            540         2      923            850</a>
#> 4  2013     1     1      544            545        -1     1004           1022</a>
#> 5  2013     1     1      554            600        -6      812            837</a>
#> 6  2013     1     1      554            558        -4      740            728</a>
#> # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

You might notice that this data frame prints a little differently from other data frames you might have used in the past: it only shows the first few rows and all the columns that fit on one screen. 
(To see the whole dataset, you can run <code>View(flights)</code> which will open the dataset in the RStudio viewer). 
It prints differently because it’s a tibble. 
Tibbles are data frames, but slightly tweaked to work better in the tidyverse. 
For now, you don’t need to worry about the differences; we’ll come back to tibbles in more detail in <a href="wrangle-intro.html#wrangle-intro">wrangle</a>.

You might also have noticed the row of three (or four) letter abbreviations under the column names. 
These describe the type of each variable:

<code>int</code> stands for integers.

<code>dbl</code> stands for doubles, or real numbers.

<code>chr</code> stands for character vectors, or strings.

<code>dttm</code> stands for date-times (a date + a time).

There are three other common types of variables that aren’t used in this dataset but you’ll encounter later in the book:

<code>lgl</code> stands for logical, vectors that contain only <code>TRUE</code> or <code>FALSE</code>.

<code>fctr</code> stands for factors, which R uses to represent categorical variables
with fixed possible values.

<code>date</code> stands for dates.

<h3>5.1.3 dplyr basics</h3>
In this chapter you are going to learn the five key dplyr functions that allow you to solve the vast majority of your data manipulation challenges:

Pick observations by their values (<code>filter()</code>).

Reorder the rows (<code>arrange()</code>).

Pick variables by their names (<code>select()</code>).

Create new variables with functions of existing variables (<code>mutate()</code>).

Collapse many values down to a single summary (<code>summarise()</code>).

These can all be used in conjunction with <code>group_by()</code> which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. 
These six functions provide the verbs for a language of data manipulation.

All verbs work similarly:

The first argument is a data frame.

The subsequent arguments describe what to do with the data frame,
using the variable names (without quotes).

The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result. 
Let’s dive in and see how these verbs work.

<h2>5.2 Filter rows with <code>filter()</code></h2>
<code>filter()</code> allows you to subset observations based on their values. 
The first argument is the name of the data frame. 
The second and subsequent arguments are the expressions that filter the data frame. 
For example, we can select all flights on January 1st with:

<code>filter(flights, month == 1, day == 1)</a>
#> # A tibble: 842 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1      533            529         4      850            830</a>
#> 3  2013     1     1      542            540         2      923            850</a>
#> 4  2013     1     1      544            545        -1     1004           1022</a>
#> 5  2013     1     1      554            600        -6      812            837</a>
#> 6  2013     1     1      554            558        -4      740            728</a>
#> # … with 836 more rows, and 11 more variables: arr_delay &lt;dbl>, carrier &lt;chr>,</a>
#> #   flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>, air_time &lt;dbl>,</a>
#> #   distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

When you run that line of code, dplyr executes the filtering operation and returns a new data frame. 
dplyr functions never modify their inputs, so if you want to save the result, you’ll need to use the assignment operator, <code>&lt;-</code>:

<code>jan1 &lt;- filter(flights, month == 1, day == 1)</code>

R either prints out the results, or saves them to a variable. 
If you want to do both, you can wrap the assignment in parentheses:

<code>(dec25 &lt;- filter(flights, month == 12, day == 25))</a>
#> # A tibble: 719 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013    12    25      456            500        -4      649            651</a>
#> 2  2013    12    25      524            515         9      805            814</a>
#> 3  2013    12    25      542            540         2      832            850</a>
#> 4  2013    12    25      546            550        -4     1022           1027</a>
#> 5  2013    12    25      556            600        -4      730            745</a>
#> 6  2013    12    25      557            600        -3      743            752</a>
#> # … with 713 more rows, and 11 more variables: arr_delay &lt;dbl>, carrier &lt;chr>,</a>
#> #   flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>, air_time &lt;dbl>,</a>
#> #   distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

<h3>5.2.1 Comparisons</h3>
To use filtering effectively, you have to know how to select the observations that you want using the comparison operators. 
R provides the standard suite: <code>></code>, <code>>=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>!=</code> (not equal), and <code>==</code> (equal).

When you’re starting out with R, the easiest mistake to make is to use <code>=</code> instead of <code>==</code> when testing for equality. 
When this happens you’ll get an informative error:

<code>filter(flights, month = 1)</a>
#> Error: `month` (`month = 1`) must not be named, do you need `==`?</code>

There’s another common problem you might encounter when using <code>==</code>: floating point numbers. 
These results might surprise you!

<code>sqrt(2) ^ 2 == 2</a>
#> [1] FALSE</a>
1 / 49 * 49 == 1</a>
#> [1] FALSE</code>

Computers use finite precision arithmetic (they obviously can’t store an infinite number of digits!) so remember that every number you see is an approximation. 
Instead of relying on <code>==</code>, use <code>near()</code>:

<code>near(sqrt(2) ^ 2,  2)</a>
#> [1] TRUE</a>
near(1 / 49 * 49, 1)</a>
#> [1] TRUE</code>

<h3>5.2.2 Logical operators</h3>
Multiple arguments to <code>filter()</code> are combined with 'and': every expression must be true in order for a row to be included in the output. 
For other types of combinations, you’ll need to use Boolean operators yourself: <code>&amp;</code> is 'and', <code>|</code> is 'or', and <code>!</code> is 'not'. 
Figure <a href="transform.html#fig:bool-ops">5.1</a> shows the complete set of Boolean operations.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/01f4b6d39d2be8269740a3ad7946faa79f7243cf/8369a/diagrams/transform-logical.png" alt="Complete set of boolean operations. 
`x` is the left-hand circle, `y` is the right-hand circle, and the shaded region show which parts each operator selects." width="70%" />

Figure 5.1: Complete set of boolean operations. 
<code>x</code> is the left-hand circle, <code>y</code> is the right-hand circle, and the shaded region show which parts each operator selects.

The following code finds all flights that departed in November or December:

<code>filter(flights, month == 11 | month == 12)</code>

The order of operations doesn’t work like English. 
You can’t write <code>filter(flights, month == (11 | 12))</code>, which you might literally translate into 'finds all flights that departed in November or December'. 
Instead it finds all months that equal <code>11 | 12</code>, an expression that evaluates to <code>TRUE</code>. 
In a numeric context (like here), <code>TRUE</code> becomes one, so this finds all flights in January, not November or December. 
This is quite confusing!

A useful short-hand for this problem is <code>x %in% y</code>. 
This will select every row where <code>x</code> is one of the values in <code>y</code>. 
We could use it to rewrite the code above:

<code>nov_dec &lt;- filter(flights, month %in% c(11, 12))</code>

Sometimes you can simplify complicated subsetting by remembering De Morgan’s law: <code>!(x &amp; y)</code> is the same as <code>!x | !y</code>, and <code>!(x | y)</code> is the same as <code>!x &amp; !y</code>. 
For example, if you wanted to find flights that weren’t delayed (on arrival or departure) by more than two hours, you could use either of the following two filters:

<code>filter(flights, !(arr_delay > 120 | dep_delay > 120))</a>
filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120)</code>

As well as <code>&amp;</code> and <code>|</code>, R also has <code>&amp;&amp;</code> and <code>||</code>. 
Don’t use them here! You’ll learn when you should use them in <a href="functions.html#conditional-execution">conditional execution</a>.

Whenever you start using complicated, multipart expressions in <code>filter()</code>, consider making them explicit variables instead. 
That makes it much easier to check your work. 
You’ll learn how to create new variables shortly.

<h3>5.2.3 Missing values</h3>
One important feature of R that can make comparison tricky are missing values, or <code>NA</code>s ('not availables'). 
<code>NA</code> represents an unknown value so missing values are 'contagious': almost any operation involving an unknown value will also be unknown.

<code>NA > 5</a>
#> [1] NA</a>
10 == NA</a>
#> [1] NA</a>
NA + 10</a>
#> [1] NA</a>
NA / 2</a>
#> [1] NA</code>

The most confusing result is this one:

<code>NA == NA</a>
#> [1] NA</code>

It’s easiest to understand why this is true with a bit more context:

<code># Let x be Mary&#39;s age. 
We don&#39;t know how old she is.</a>
x &lt;- NA</a>
</a>
# Let y be John&#39;s age. 
We don&#39;t know how old he is.</a>
y &lt;- NA</a>
</a>
# Are John and Mary the same age?</a>
x == y</a>
#> [1] NA</a>
# We don&#39;t know!</code>

If you want to determine if a value is missing, use <code>is.na()</code>:

<code>is.na(x)</a>
#> [1] TRUE</code>

<code>filter()</code> only includes rows where the condition is <code>TRUE</code>; it excludes both <code>FALSE</code> and <code>NA</code> values. 
If you want to preserve missing values, ask for them explicitly:

<code>df &lt;- tibble(x = c(1, NA, 3))</a>
filter(df, x > 1)</a>
#> # A tibble: 1 x 1</a>
#>       x</a>
#>   &lt;dbl></a>
#> 1     3</a>
filter(df, is.na(x) | x > 1)</a>
#> # A tibble: 2 x 1</a>
#>       x</a>
#>   &lt;dbl></a>
#> 1    NA</a>
#> 2     3</code>

<h3>5.2.4 Exercises</h3>

Find all flights that

Had an arrival delay of two or more hours

Flew to Houston (<code>IAH</code> or <code>HOU</code>)

Were operated by United, American, or Delta

Departed in summer (July, August, and September)

Arrived more than two hours late, but didn’t leave late

Were delayed by at least an hour, but made up over 30 minutes in flight

Departed between midnight and 6am (inclusive)

Another useful dplyr filtering helper is <code>between()</code>. 
What does it do?
Can you use it to simplify the code needed to answer the previous
challenges?

How many flights have a missing <code>dep_time</code>? What other variables are
missing? What might these rows represent?

Why is <code>NA ^ 0</code> not missing? Why is <code>NA | TRUE</code> not missing?
Why is <code>FALSE &amp; NA</code> not missing? Can you figure out the general
rule? (<code>NA * 0</code> is a tricky counterexample!)

<h2>5.3 Arrange rows with <code>arrange()</code></h2>
<code>arrange()</code> works similarly to <code>filter()</code> except that instead of selecting rows, it changes their order. 
It takes a data frame and a set of column names (or more complicated expressions) to order by. 
If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns:

<code>arrange(flights, year, month, day)</a>
#> # A tibble: 336,776 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1      533            529         4      850            830</a>
#> 3  2013     1     1      542            540         2      923            850</a>
#> 4  2013     1     1      544            545        -1     1004           1022</a>
#> 5  2013     1     1      554            600        -6      812            837</a>
#> 6  2013     1     1      554            558        -4      740            728</a>
#> # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

Use <code>desc()</code> to re-order by a column in descending order:

<code>arrange(flights, desc(dep_delay))</a>
#> # A tibble: 336,776 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     9      641            900      1301     1242           1530</a>
#> 2  2013     6    15     1432           1935      1137     1607           2120</a>
#> 3  2013     1    10     1121           1635      1126     1239           1810</a>
#> 4  2013     9    20     1139           1845      1014     1457           2210</a>
#> 5  2013     7    22      845           1600      1005     1044           1815</a>
#> 6  2013     4    10     1100           1900       960     1342           2211</a>
#> # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

Missing values are always sorted at the end:

<code>df &lt;- tibble(x = c(5, 2, NA))</a>
arrange(df, x)</a>
#> # A tibble: 3 x 1</a>
#>       x</a>
#>   &lt;dbl></a>
#> 1     2</a>
#> 2     5</a>
#> 3    NA</a>
arrange(df, desc(x))</a>
#> # A tibble: 3 x 1</a>
#>       x</a>
#>   &lt;dbl></a>
#> 1     5</a>
#> 2     2</a>
#> 3    NA</code>

<h3>5.3.1 Exercises</h3>

How could you use <code>arrange()</code> to sort all missing values to the start?
(Hint: use <code>is.na()</code>).

Sort <code>flights</code> to find the most delayed flights. 
Find the flights that
left earliest.

Sort <code>flights</code> to find the fastest (highest speed) flights.

Which flights travelled the farthest? Which travelled the shortest?

<h2>5.4 Select columns with <code>select()</code></h2>
It’s not uncommon to get datasets with hundreds or even thousands of variables. 
In this case, the first challenge is often narrowing in on the variables you’re actually interested in. 
<code>select()</code> allows you to rapidly zoom in on a useful subset using operations based on the names of the variables.

<code>select()</code> is not terribly useful with the flights data because we only have 19 variables, but you can still get the general idea:

<code># Select columns by name</a>
select(flights, year, month, day)</a>
#> # A tibble: 336,776 x 3</a>
#>    year month   day</a>
#>   &lt;int> &lt;int> &lt;int></a>
#> 1  2013     1     1</a>
#> 2  2013     1     1</a>
#> 3  2013     1     1</a>
#> 4  2013     1     1</a>
#> 5  2013     1     1</a>
#> 6  2013     1     1</a>
#> # … with 336,770 more rows</a>
# Select all columns between year and day (inclusive)</a>
select(flights, year:day)</a>
#> # A tibble: 336,776 x 3</a>
#>    year month   day</a>
#>   &lt;int> &lt;int> &lt;int></a>
#> 1  2013     1     1</a>
#> 2  2013     1     1</a>
#> 3  2013     1     1</a>
#> 4  2013     1     1</a>
#> 5  2013     1     1</a>
#> 6  2013     1     1</a>
#> # … with 336,770 more rows</a>
# Select all columns except those from year to day (inclusive)</a>
select(flights, -(year:day))</a>
#> # A tibble: 336,776 x 16</a>
#>   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier</a>
#>      &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int>     &lt;dbl> &lt;chr>  </a>
#> 1      517            515         2      830            819        11 UA     </a>
#> 2      533            529         4      850            830        20 UA     </a>
#> 3      542            540         2      923            850        33 AA     </a>
#> 4      544            545        -1     1004           1022       -18 B6     </a>
#> 5      554            600        -6      812            837       -25 DL     </a>
#> 6      554            558        -4      740            728        12 UA     </a>
#> # … with 336,770 more rows, and 9 more variables: flight &lt;int>, tailnum &lt;chr>,</a>
#> #   origin &lt;chr>, dest &lt;chr>, air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>,</a>
#> #   minute &lt;dbl>, time_hour &lt;dttm></code>

There are a number of helper functions you can use within <code>select()</code>:

<code>starts_with("abc")</code>: matches names that begin with 'abc'.

<code>ends_with("xyz")</code>: matches names that end with 'xyz'.

<code>contains("ijk")</code>: matches names that contain 'ijk'.

<code>matches("(.)\\1")</code>: selects variables that match a regular expression.
This one matches any variables that contain repeated characters. 
You’ll
learn more about regular expressions in <a href="strings.html#strings">strings</a>.

<code>num_range("x", 1:3)</code>: matches <code>x1</code>, <code>x2</code> and <code>x3</code>.

See <code>?select</code> for more details.

<code>select()</code> can be used to rename variables, but it’s rarely useful because it drops all of the variables not explicitly mentioned. 
Instead, use <code>rename()</code>, which is a variant of <code>select()</code> that keeps all the variables that aren’t explicitly mentioned:

<code>rename(flights, tail_num = tailnum)</a>
#> # A tibble: 336,776 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1      533            529         4      850            830</a>
#> 3  2013     1     1      542            540         2      923            850</a>
#> 4  2013     1     1      544            545        -1     1004           1022</a>
#> 5  2013     1     1      554            600        -6      812            837</a>
#> 6  2013     1     1      554            558        -4      740            728</a>
#> # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tail_num &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

Another option is to use <code>select()</code> in conjunction with the <code>everything()</code> helper. 
This is useful if you have a handful of variables you’d like to move to the start of the data frame.

<code>select(flights, time_hour, air_time, everything())</a>
#> # A tibble: 336,776 x 19</a>
#>   time_hour           air_time  year month   day dep_time sched_dep_time</a>
#>   &lt;dttm>                 &lt;dbl> &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int></a>
#> 1 2013-01-01 05:00:00      227  2013     1     1      517            515</a>
#> 2 2013-01-01 05:00:00      227  2013     1     1      533            529</a>
#> 3 2013-01-01 05:00:00      160  2013     1     1      542            540</a>
#> 4 2013-01-01 05:00:00      183  2013     1     1      544            545</a>
#> 5 2013-01-01 06:00:00      116  2013     1     1      554            600</a>
#> 6 2013-01-01 05:00:00      150  2013     1     1      554            558</a>
#> # … with 336,770 more rows, and 12 more variables: dep_delay &lt;dbl>,</a>
#> #   arr_time &lt;int>, sched_arr_time &lt;int>, arr_delay &lt;dbl>, carrier &lt;chr>,</a>
#> #   flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>, distance &lt;dbl>,</a>
#> #   hour &lt;dbl>, minute &lt;dbl></code>

<h3>5.4.1 Exercises</h3>

Brainstorm as many ways as possible to select <code>dep_time</code>, <code>dep_delay</code>,
<code>arr_time</code>, and <code>arr_delay</code> from <code>flights</code>.

What happens if you include the name of a variable multiple times in
a <code>select()</code> call?

What does the <code>one_of()</code> function do? Why might it be helpful in conjunction
with this vector?

<code>vars &lt;- c("year", "month", "day", "dep_delay", "arr_delay")</code>

Does the result of running the following code surprise you? How do the
select helpers deal with case by default? How can you change that default?

<code>select(flights, contains("TIME"))</code>

<h2>5.5 Add new variables with <code>mutate()</code></h2>
Besides selecting sets of existing columns, it’s often useful to add new columns that are functions of existing columns. 
That’s the job of <code>mutate()</code>.

<code>mutate()</code> always adds new columns at the end of your dataset so we’ll start by creating a narrower dataset so we can see the new variables. 
Remember that when you’re in RStudio, the easiest way to see all the columns is <code>View()</code>.

<code>flights_sml &lt;- select(flights, </a>
  year:day, </a>
  ends_with("delay"), </a>
  distance, </a>
  air_time</a>
)</a>
mutate(flights_sml,</a>
  gain = dep_delay - arr_delay,</a>
  speed = distance / air_time * 60</a>
)</a>
#> # A tibble: 336,776 x 9</a>
#>    year month   day dep_delay arr_delay distance air_time  gain speed</a>
#>   &lt;int> &lt;int> &lt;int>     &lt;dbl>     &lt;dbl>    &lt;dbl>    &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  2013     1     1         2        11     1400      227    -9  370.</a>
#> 2  2013     1     1         4        20     1416      227   -16  374.</a>
#> 3  2013     1     1         2        33     1089      160   -31  408.</a>
#> 4  2013     1     1        -1       -18     1576      183    17  517.</a>
#> 5  2013     1     1        -6       -25      762      116    19  394.</a>
#> 6  2013     1     1        -4        12      719      150   -16  288.</a>
#> # … with 336,770 more rows</code>

Note that you can refer to columns that you’ve just created:

<code>mutate(flights_sml,</a>
  gain = dep_delay - arr_delay,</a>
  hours = air_time / 60,</a>
  gain_per_hour = gain / hours</a>
)</a>
#> # A tibble: 336,776 x 10</a>
#>    year month   day dep_delay arr_delay distance air_time  gain hours</a>
#>   &lt;int> &lt;int> &lt;int>     &lt;dbl>     &lt;dbl>    &lt;dbl>    &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  2013     1     1         2        11     1400      227    -9  3.78</a>
#> 2  2013     1     1         4        20     1416      227   -16  3.78</a>
#> 3  2013     1     1         2        33     1089      160   -31  2.67</a>
#> 4  2013     1     1        -1       -18     1576      183    17  3.05</a>
#> 5  2013     1     1        -6       -25      762      116    19  1.93</a>
#> 6  2013     1     1        -4        12      719      150   -16  2.5 </a>
#> # … with 336,770 more rows, and 1 more variable: gain_per_hour &lt;dbl></code>

If you only want to keep the new variables, use <code>transmute()</code>:

<code>transmute(flights,</a>
  gain = dep_delay - arr_delay,</a>
  hours = air_time / 60,</a>
  gain_per_hour = gain / hours</a>
)</a>
#> # A tibble: 336,776 x 3</a>
#>    gain hours gain_per_hour</a>
#>   &lt;dbl> &lt;dbl>         &lt;dbl></a>
#> 1    -9  3.78         -2.38</a>
#> 2   -16  3.78         -4.23</a>
#> 3   -31  2.67        -11.6 </a>
#> 4    17  3.05          5.57</a>
#> 5    19  1.93          9.83</a>
#> 6   -16  2.5          -6.4 </a>
#> # … with 336,770 more rows</code>

<h3>5.5.1 Useful creation functions</h3>
There are many functions for creating new variables that you can use with <code>mutate()</code>. 
The key property is that the function must be vectorised: it must take a vector of values as input, return a vector with the same number of values as output. 
There’s no way to list every possible function that you might use, but here’s a selection of functions that are frequently useful:

Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code>. 
These are all vectorised,
using the so called 'recycling rules'. 
If one parameter is shorter than
the other, it will be automatically extended to be the same length. 
This
is most useful when one of the arguments is a single number: <code>air_time / 60</code>,
<code>hours * 60 + minute</code>, etc.

Arithmetic operators are also useful in conjunction with the aggregate
functions you’ll learn about later. 
For example, <code>x / sum(x)</code> calculates
the proportion of a total, and <code>y - mean(y)</code> computes the difference from
the mean.

Modular arithmetic: <code>%/%</code> (integer division) and <code>%%</code> (remainder), where
<code>x == y * (x %/% y) + (x %% y)</code>. 
Modular arithmetic is a handy tool because
it allows you to break integers up into pieces. 
For example, in the
flights dataset, you can compute <code>hour</code> and <code>minute</code> from <code>dep_time</code> with:

<code>transmute(flights,</a>
  dep_time,</a>
  hour = dep_time %/% 100,</a>
  minute = dep_time %% 100</a>
)</a>
#> # A tibble: 336,776 x 3</a>
#>   dep_time  hour minute</a>
#>      &lt;int> &lt;dbl>  &lt;dbl></a>
#> 1      517     5     17</a>
#> 2      533     5     33</a>
#> 3      542     5     42</a>
#> 4      544     5     44</a>
#> 5      554     5     54</a>
#> 6      554     5     54</a>
#> # … with 336,770 more rows</code>

Logs: <code>log()</code>, <code>log2()</code>, <code>log10()</code>. 
Logarithms are an incredibly useful
transformation for dealing with data that ranges across multiple orders of
magnitude. 
They also convert multiplicative relationships to additive, a
feature we’ll come back to in modelling.

All else being equal, I recommend using <code>log2()</code> because it’s easy to
interpret: a difference of 1 on the log scale corresponds to doubling on
the original scale and a difference of -1 corresponds to halving.

Offsets: <code>lead()</code> and <code>lag()</code> allow you to refer to leading or lagging
values. 
This allows you to compute running differences (e.g. 
<code>x - lag(x)</code>)
or find when values change (<code>x != lag(x)</code>). 
They are most useful in
conjunction with <code>group_by()</code>, which you’ll learn about shortly.

<code>(x &lt;- 1:10)</a>
#>  [1]  1  2  3  4  5  6  7  8  9 10</a>
lag(x)</a>
#>  [1] NA  1  2  3  4  5  6  7  8  9</a>
lead(x)</a>
#>  [1]  2  3  4  5  6  7  8  9 10 NA</code>

Cumulative and rolling aggregates: R provides functions for running sums,
products, mins and maxes: <code>cumsum()</code>, <code>cumprod()</code>, <code>cummin()</code>, <code>cummax()</code>;
and dplyr provides <code>cummean()</code> for cumulative means. 
If you need rolling
aggregates (i.e. a sum computed over a rolling window), try the RcppRoll
package.

<code>x</a>
#>  [1]  1  2  3  4  5  6  7  8  9 10</a>
cumsum(x)</a>
#>  [1]  1  3  6 10 15 21 28 36 45 55</a>
cummean(x)</a>
#>  [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5</code>

Logical comparisons, <code>&lt;</code>, <code>&lt;=</code>, <code>></code>, <code>>=</code>, <code>!=</code>, and <code>==</code>, which you learned about
earlier. 
If you’re doing a complex sequence of logical operations it’s
often a good idea to store the interim values in new variables so you can
check that each step is working as expected.

Ranking: there are a number of ranking functions, but you should
start with <code>min_rank()</code>. 
It does the most usual type of ranking
(e.g. 1st, 2nd, 2nd, 4th). 
The default gives smallest values the small
ranks; use <code>desc(x)</code> to give the largest values the smallest ranks.

<code>y &lt;- c(1, 2, 2, NA, 3, 4)</a>
min_rank(y)</a>
#> [1]  1  2  2 NA  4  5</a>
min_rank(desc(y))</a>
#> [1]  5  3  3 NA  2  1</code>

If <code>min_rank()</code> doesn’t do what you need, look at the variants
<code>row_number()</code>, <code>dense_rank()</code>, <code>percent_rank()</code>, <code>cume_dist()</code>,
<code>ntile()</code>. 
See their help pages for more details.

<code>row_number(y)</a>
#> [1]  1  2  3 NA  4  5</a>
dense_rank(y)</a>
#> [1]  1  2  2 NA  3  4</a>
percent_rank(y)</a>
#> [1] 0.00 0.25 0.25   NA 0.75 1.00</a>
cume_dist(y)</a>
#> [1] 0.2 0.6 0.6  NA 0.8 1.0</code>

<h3>5.5.2 Exercises</h3>

Currently <code>dep_time</code> and <code>sched_dep_time</code> are convenient to look at, but
hard to compute with because they’re not really continuous numbers.
Convert them to a more convenient representation of number of minutes
since midnight.

Compare <code>air_time</code> with <code>arr_time - dep_time</code>. 
What do you expect to see?
What do you see? What do you need to do to fix it?

Compare <code>dep_time</code>, <code>sched_dep_time</code>, and <code>dep_delay</code>. 
How would you
expect those three numbers to be related?

Find the 10 most delayed flights using a ranking function. 
How do you want
to handle ties? Carefully read the documentation for <code>min_rank()</code>.

What does <code>1:3 + 1:10</code> return? Why?

What trigonometric functions does R provide?

<h2>5.6 Grouped summaries with <code>summarise()</code></h2>
The last key verb is <code>summarise()</code>. 
It collapses a data frame to a single row:

<code>summarise(flights, delay = mean(dep_delay, na.rm = TRUE))</a>
#> # A tibble: 1 x 1</a>
#>   delay</a>
#>   &lt;dbl></a>
#> 1  12.6</code>

(We’ll come back to what that <code>na.rm = TRUE</code> means very shortly.)

<code>summarise()</code> is not terribly useful unless we pair it with <code>group_by()</code>. 
This changes the unit of analysis from the complete dataset to individual groups. 
Then, when you use the dplyr verbs on a grouped data frame they’ll be automatically applied 'by group'. 
For example, if we applied exactly the same code to a data frame grouped by date, we get the average delay per date:

<code>by_day &lt;- group_by(flights, year, month, day)</a>
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day delay</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl></a>
#> 1  2013     1     1 11.5 </a>
#> 2  2013     1     2 13.9 </a>
#> 3  2013     1     3 11.0 </a>
#> 4  2013     1     4  8.95</a>
#> 5  2013     1     5  5.73</a>
#> 6  2013     1     6  7.15</a>
#> # … with 359 more rows</code>

Together <code>group_by()</code> and <code>summarise()</code> provide one of the tools that you’ll use most commonly when working with dplyr: grouped summaries. 
But before we go any further with this, we need to introduce a powerful new idea: the pipe.

<h3>5.6.1 Combining multiple operations with the pipe</h3>
Imagine that we want to explore the relationship between the distance and average delay for each location. 
Using what you know about dplyr, you might write code like this:

<code>by_dest &lt;- group_by(flights, dest)</a>
delay &lt;- summarise(by_dest,</a>
  count = n(),</a>
  dist = mean(distance, na.rm = TRUE),</a>
  delay = mean(arr_delay, na.rm = TRUE)</a>
)</a>
delay &lt;- filter(delay, count > 20, dest != "HNL")</a>
</a>
# It looks like delays increase with distance up to ~750 miles </a>
# and then decrease. 
Maybe as flights get longer there&#39;s more </a>
# ability to make up delays in the air?</a>
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +</a>
  geom_point(aes(size = count), alpha = 1/3) +</a>
  geom_smooth(se = FALSE)</a>
#> `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b0ecc8f8c9f2a73ef117e56fe340eb989cf22981/ef707/transform_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" />

There are three steps to prepare this data:

Group flights by destination.

Summarise to compute distance, average delay, and number of flights.

Filter to remove noisy points and Honolulu airport, which is almost
twice as far away as the next closest airport.

This code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don’t care about it. 
Naming things is hard, so this slows down our analysis.

There’s another way to tackle the same problem with the pipe, <code>%>%</code>:

<code>delays &lt;- flights %>% </a>
  group_by(dest) %>% </a>
  summarise(</a>
    count = n(),</a>
    dist = mean(distance, na.rm = TRUE),</a>
    delay = mean(arr_delay, na.rm = TRUE)</a>
  ) %>% </a>
  filter(count > 20, dest != "HNL")</code>

This focuses on the transformations, not what’s being transformed, which makes the code easier to read. 
You can read it as a series of imperative statements: group, then summarise, then filter. 
As suggested by this reading, a good way to pronounce <code>%>%</code> when reading code is 'then'.

Behind the scenes, <code>x %>% f(y)</code> turns into <code>f(x, y)</code>, and <code>x %>% f(y) %>% g(z)</code> turns into <code>g(f(x, y), z)</code> and so on. 
You can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom. 
We’ll use piping frequently from now on because it considerably improves the readability of code, and we’ll come back to it in more detail in <a href="pipes.html#pipes">pipes</a>.

Working with the pipe is one of the key criteria for belonging to the tidyverse. 
The only exception is ggplot2: it was written before the pipe was discovered. 
Unfortunately, the next iteration of ggplot2, ggvis, which does use the pipe, isn’t quite ready for prime time yet.

<h3>5.6.2 Missing values</h3>
You may have wondered about the <code>na.rm</code> argument we used above. 
What happens if we don’t set it?

<code>flights %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(mean = mean(dep_delay))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day  mean</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl></a>
#> 1  2013     1     1    NA</a>
#> 2  2013     1     2    NA</a>
#> 3  2013     1     3    NA</a>
#> 4  2013     1     4    NA</a>
#> 5  2013     1     5    NA</a>
#> 6  2013     1     6    NA</a>
#> # … with 359 more rows</code>

We get a lot of missing values! That’s because aggregation functions obey the usual rule of missing values: if there’s any missing value in the input, the output will be a missing value. 
Fortunately, all aggregation functions have an <code>na.rm</code> argument which removes the missing values prior to computation:

<code>flights %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(mean = mean(dep_delay, na.rm = TRUE))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day  mean</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl></a>
#> 1  2013     1     1 11.5 </a>
#> 2  2013     1     2 13.9 </a>
#> 3  2013     1     3 11.0 </a>
#> 4  2013     1     4  8.95</a>
#> 5  2013     1     5  5.73</a>
#> 6  2013     1     6  7.15</a>
#> # … with 359 more rows</code>

In this case, where missing values represent cancelled flights, we could also tackle the problem by first removing the cancelled flights. 
We’ll save this dataset so we can reuse it in the next few examples.

<code>not_cancelled &lt;- flights %>% </a>
  filter(!is.na(dep_delay), !is.na(arr_delay))</a>
</a>
not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(mean = mean(dep_delay))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day  mean</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl></a>
#> 1  2013     1     1 11.4 </a>
#> 2  2013     1     2 13.7 </a>
#> 3  2013     1     3 10.9 </a>
#> 4  2013     1     4  8.97</a>
#> 5  2013     1     5  5.73</a>
#> 6  2013     1     6  7.15</a>
#> # … with 359 more rows</code>

<h3>5.6.3 Counts</h3>
Whenever you do any aggregation, it’s always a good idea to include either a count (<code>n()</code>), or a count of non-missing values (<code>sum(!is.na(x))</code>). 
That way you can check that you’re not drawing conclusions based on very small amounts of data. 
For example, let’s look at the planes (identified by their tail number) that have the highest average delays:

<code>delays &lt;- not_cancelled %>% </a>
  group_by(tailnum) %>% </a>
  summarise(</a>
    delay = mean(arr_delay)</a>
  )</a>
</a>
ggplot(data = delays, mapping = aes(x = delay)) + </a>
  geom_freqpoly(binwidth = 10)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6106ced61ebaa9d5693d00fc3e9dab003d8891b6/f2760/transform_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" />

Wow, there are some planes that have an <em>average</em> delay of 5 hours (300 minutes)!

The story is actually a little more nuanced. 
We can get more insight if we draw a scatterplot of number of flights vs. average delay:

<code>delays &lt;- not_cancelled %>% </a>
  group_by(tailnum) %>% </a>
  summarise(</a>
    delay = mean(arr_delay, na.rm = TRUE),</a>
    n = n()</a>
  )</a>
</a>
ggplot(data = delays, mapping = aes(x = n, y = delay)) + </a>
  geom_point(alpha = 1/10)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e91f480bda0d9db50d82ba2e570c3155955cf091/76a31/transform_files/figure-html/unnamed-chunk-41-1.png" width="70%" style="display: block; margin: auto;" />

Not surprisingly, there is much greater variation in the average delay when there are few flights. 
The shape of this plot is very characteristic: whenever you plot a mean (or other summary) vs. group size, you’ll see that the variation decreases as the sample size increases.

When looking at this sort of plot, it’s often useful to filter out the groups with the smallest numbers of observations, so you can see more of the pattern and less of the extreme variation in the smallest groups. 
This is what the following code does, as well as showing you a handy pattern for integrating ggplot2 into dplyr flows. 
It’s a bit painful that you have to switch from <code>%>%</code> to <code>+</code>, but once you get the hang of it, it’s quite convenient.

<code>delays %>% </a>
  filter(n > 25) %>% </a>
  ggplot(mapping = aes(x = n, y = delay)) + </a>
    geom_point(alpha = 1/10)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0ff2cfe975346aafd2fb316c09d95279acb952e0/e4f5a/transform_files/figure-html/unnamed-chunk-42-1.png" width="70%" style="display: block; margin: auto;" />

<hr />
RStudio tip: a useful keyboard shortcut is Cmd/Ctrl + Shift + P. 
This resends the previously sent chunk from the editor to the console. 
This is very convenient when you’re (e.g.) exploring the value of <code>n</code> in the example above. 
You send the whole block once with Cmd/Ctrl + Enter, then you modify the value of <code>n</code> and press Cmd/Ctrl + Shift + P to resend the complete block.

<hr />
There’s another common variation of this type of pattern. 
Let’s look at how the average performance of batters in baseball is related to the number of times they’re at bat. 
Here I use data from the Lahman package to compute the batting average (number of hits / number of attempts) of every major league baseball player.

When I plot the skill of the batter (measured by the batting average, <code>ba</code>) against the number of opportunities to hit the ball (measured by at bat, <code>ab</code>), you see two patterns:

As above, the variation in our aggregate decreases as we get more
data points.

There’s a positive correlation between skill (<code>ba</code>) and opportunities to
hit the ball (<code>ab</code>). 
This is because teams control who gets to play,
and obviously they’ll pick their best players.

<code># Convert to a tibble so it prints nicely</a>
batting &lt;- as_tibble(Lahman::Batting)</a>
</a>
batters &lt;- batting %>% </a>
  group_by(playerID) %>% </a>
  summarise(</a>
    ba = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),</a>
    ab = sum(AB, na.rm = TRUE)</a>
  )</a>
</a>
batters %>% </a>
  filter(ab > 100) %>% </a>
  ggplot(mapping = aes(x = ab, y = ba)) +</a>
    geom_point() + </a>
    geom_smooth(se = FALSE)</a>
#> `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = "cs")&#39;</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dc49f30df0c46e0bff97c73c8780fa2a5fe6b790/a57ae/transform_files/figure-html/unnamed-chunk-43-1.png" width="70%" style="display: block; margin: auto;" />

This also has important implications for ranking. 
If you naively sort on <code>desc(ba)</code>, the people with the best batting averages are clearly lucky, not skilled:

<code>batters %>% </a>
  arrange(desc(ba))</a>
#> # A tibble: 19,428 x 3</a>
#>   playerID     ba    ab</a>
#>   &lt;chr>     &lt;dbl> &lt;int></a>
#> 1 abramge01     1     1</a>
#> 2 alberan01     1     1</a>
#> 3 allarko01     1     1</a>
#> 4 banisje01     1     1</a>
#> 5 bartocl01     1     1</a>
#> 6 bassdo01      1     1</a>
#> # … with 19,422 more rows</code>

You can find a good explanation of this problem at <a href="http://varianceexplained.org/r/empirical_bayes_baseball/" class="uri">http://varianceexplained.org/r/empirical_bayes_baseball/</a> and <a href="http://www.evanmiller.org/how-not-to-sort-by-average-rating.html" class="uri">http://www.evanmiller.org/how-not-to-sort-by-average-rating.html</a>.

<h3>5.6.4 Useful summary functions</h3>
Just using means, counts, and sum can get you a long way, but R provides many other useful summary functions:

Measures of location: we’ve used <code>mean(x)</code>, but <code>median(x)</code> is also
useful. 
The mean is the sum divided by the length; the median is a value
where 50% of <code>x</code> is above it, and 50% is below it.

It’s sometimes useful to combine aggregation with logical subsetting.
We haven’t talked about this sort of subsetting yet, but you’ll learn more
about it in <a href="vectors.html#subsetting-1">subsetting</a>.

<code>not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(</a>
    avg_delay1 = mean(arr_delay),</a>
    avg_delay2 = mean(arr_delay[arr_delay > 0]) # the average positive delay</a>
  )</a>
#> # A tibble: 365 x 5</a>
#> # Groups:   year, month [12]</a>
#>    year month   day avg_delay1 avg_delay2</a>
#>   &lt;int> &lt;int> &lt;int>      &lt;dbl>      &lt;dbl></a>
#> 1  2013     1     1      12.7        32.5</a>
#> 2  2013     1     2      12.7        32.0</a>
#> 3  2013     1     3       5.73       27.7</a>
#> 4  2013     1     4      -1.93       28.3</a>
#> 5  2013     1     5      -1.53       22.6</a>
#> 6  2013     1     6       4.24       24.4</a>
#> # … with 359 more rows</code>

Measures of spread: <code>sd(x)</code>, <code>IQR(x)</code>, <code>mad(x)</code>. 
The root mean squared deviation,
or standard deviation <code>sd(x)</code>, is the standard measure of spread.
The interquartile range <code>IQR(x)</code> and median absolute deviation <code>mad(x)</code>
are robust equivalents that may be more useful if you have outliers.

<code># Why is distance to some destinations more variable than to others?</a>
not_cancelled %>% </a>
  group_by(dest) %>% </a>
  summarise(distance_sd = sd(distance)) %>% </a>
  arrange(desc(distance_sd))</a>
#> # A tibble: 104 x 2</a>
#>   dest  distance_sd</a>
#>   &lt;chr>       &lt;dbl></a>
#> 1 EGE         10.5 </a>
#> 2 SAN         10.4 </a>
#> 3 SFO         10.2 </a>
#> 4 HNL         10.0 </a>
#> 5 SEA          9.98</a>
#> 6 LAS          9.91</a>
#> # … with 98 more rows</code>

Measures of rank: <code>min(x)</code>, <code>quantile(x, 0.25)</code>, <code>max(x)</code>. 
Quantiles
are a generalisation of the median. 
For example, <code>quantile(x, 0.25)</code>
will find a value of <code>x</code> that is greater than 25% of the values,
and less than the remaining 75%.

<code># When do the first and last flights leave each day?</a>
not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(</a>
    first = min(dep_time),</a>
    last = max(dep_time)</a>
  )</a>
#> # A tibble: 365 x 5</a>
#> # Groups:   year, month [12]</a>
#>    year month   day first  last</a>
#>   &lt;int> &lt;int> &lt;int> &lt;int> &lt;int></a>
#> 1  2013     1     1   517  2356</a>
#> 2  2013     1     2    42  2354</a>
#> 3  2013     1     3    32  2349</a>
#> 4  2013     1     4    25  2358</a>
#> 5  2013     1     5    14  2357</a>
#> 6  2013     1     6    16  2355</a>
#> # … with 359 more rows</code>

Measures of position: <code>first(x)</code>, <code>nth(x, 2)</code>, <code>last(x)</code>. 
These work
similarly to <code>x[1]</code>, <code>x[2]</code>, and <code>x[length(x)]</code> but let you set a default
value if that position does not exist (i.e. you’re trying to get the 3rd
element from a group that only has two elements). 
For example, we can
find the first and last departure for each day:

<code>not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(</a>
    first_dep = first(dep_time), </a>
    last_dep = last(dep_time)</a>
  )</a>
#> # A tibble: 365 x 5</a>
#> # Groups:   year, month [12]</a>
#>    year month   day first_dep last_dep</a>
#>   &lt;int> &lt;int> &lt;int>     &lt;int>    &lt;int></a>
#> 1  2013     1     1       517     2356</a>
#> 2  2013     1     2        42     2354</a>
#> 3  2013     1     3        32     2349</a>
#> 4  2013     1     4        25     2358</a>
#> 5  2013     1     5        14     2357</a>
#> 6  2013     1     6        16     2355</a>
#> # … with 359 more rows</code>

These functions are complementary to filtering on ranks. 
Filtering gives
you all variables, with each observation in a separate row:

<code>not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  mutate(r = min_rank(desc(dep_time))) %>% </a>
  filter(r %in% range(r))</a>
#> # A tibble: 770 x 20</a>
#> # Groups:   year, month, day [365]</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1     2356           2359        -3      425            437</a>
#> 3  2013     1     2       42           2359        43      518            442</a>
#> 4  2013     1     2     2354           2359        -5      413            437</a>
#> 5  2013     1     3       32           2359        33      504            442</a>
#> 6  2013     1     3     2349           2359       -10      434            445</a>
#> # … with 764 more rows, and 12 more variables: arr_delay &lt;dbl>, carrier &lt;chr>,</a>
#> #   flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>, air_time &lt;dbl>,</a>
#> #   distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm>, r &lt;int></code>

Counts: You’ve seen <code>n()</code>, which takes no arguments, and returns the
size of the current group. 
To count the number of non-missing values, use
<code>sum(!is.na(x))</code>. 
To count the number of distinct (unique) values, use
<code>n_distinct(x)</code>.

<code># Which destinations have the most carriers?</a>
not_cancelled %>% </a>
  group_by(dest) %>% </a>
  summarise(carriers = n_distinct(carrier)) %>% </a>
  arrange(desc(carriers))</a>
#> # A tibble: 104 x 2</a>
#>   dest  carriers</a>
#>   &lt;chr>    &lt;int></a>
#> 1 ATL          7</a>
#> 2 BOS          7</a>
#> 3 CLT          7</a>
#> 4 ORD          7</a>
#> 5 TPA          7</a>
#> 6 AUS          6</a>
#> # … with 98 more rows</code>

Counts are so useful that dplyr provides a simple helper if all you want is
a count:

<code>not_cancelled %>% </a>
  count(dest)</a>
#> # A tibble: 104 x 2</a>
#>   dest      n</a>
#>   &lt;chr> &lt;int></a>
#> 1 ABQ     254</a>
#> 2 ACK     264</a>
#> 3 ALB     418</a>
#> 4 ANC       8</a>
#> 5 ATL   16837</a>
#> 6 AUS    2411</a>
#> # … with 98 more rows</code>

You can optionally provide a weight variable. 
For example, you could use
this to 'count' (sum) the total number of miles a plane flew:

<code>not_cancelled %>% </a>
  count(tailnum, wt = distance)</a>
#> # A tibble: 4,037 x 2</a>
#>   tailnum      n</a>
#>   &lt;chr>    &lt;dbl></a>
#> 1 D942DN    3418</a>
#> 2 N0EGMQ  239143</a>
#> 3 N10156  109664</a>
#> 4 N102UW   25722</a>
#> 5 N103US   24619</a>
#> 6 N104UW   24616</a>
#> # … with 4,031 more rows</code>

Counts and proportions of logical values: <code>sum(x > 10)</code>, <code>mean(y == 0)</code>.
When used with numeric functions, <code>TRUE</code> is converted to 1 and <code>FALSE</code> to 0.
This makes <code>sum()</code> and <code>mean()</code> very useful: <code>sum(x)</code> gives the number of
<code>TRUE</code>s in <code>x</code>, and <code>mean(x)</code> gives the proportion.

<code># How many flights left before 5am? (these usually indicate delayed</a>
# flights from the previous day)</a>
not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(n_early = sum(dep_time &lt; 500))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day n_early</a>
#>   &lt;int> &lt;int> &lt;int>   &lt;int></a>
#> 1  2013     1     1       0</a>
#> 2  2013     1     2       3</a>
#> 3  2013     1     3       4</a>
#> 4  2013     1     4       3</a>
#> 5  2013     1     5       3</a>
#> 6  2013     1     6       2</a>
#> # … with 359 more rows</a>
</a>
# What proportion of flights are delayed by more than an hour?</a>
not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(hour_prop = mean(arr_delay > 60))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day hour_prop</a>
#>   &lt;int> &lt;int> &lt;int>     &lt;dbl></a>
#> 1  2013     1     1    0.0722</a>
#> 2  2013     1     2    0.0851</a>
#> 3  2013     1     3    0.0567</a>
#> 4  2013     1     4    0.0396</a>
#> 5  2013     1     5    0.0349</a>
#> 6  2013     1     6    0.0470</a>
#> # … with 359 more rows</code>

<h3>5.6.5 Grouping by multiple variables</h3>
When you group by multiple variables, each summary peels off one level of the grouping. 
That makes it easy to progressively roll up a dataset:

<code>daily &lt;- group_by(flights, year, month, day)</a>
(per_day   &lt;- summarise(daily, flights = n()))</a>
#> # A tibble: 365 x 4</a>
#> # Groups:   year, month [12]</a>
#>    year month   day flights</a>
#>   &lt;int> &lt;int> &lt;int>   &lt;int></a>
#> 1  2013     1     1     842</a>
#> 2  2013     1     2     943</a>
#> 3  2013     1     3     914</a>
#> 4  2013     1     4     915</a>
#> 5  2013     1     5     720</a>
#> 6  2013     1     6     832</a>
#> # … with 359 more rows</a>
(per_month &lt;- summarise(per_day, flights = sum(flights)))</a>
#> # A tibble: 12 x 3</a>
#> # Groups:   year [1]</a>
#>    year month flights</a>
#>   &lt;int> &lt;int>   &lt;int></a>
#> 1  2013     1   27004</a>
#> 2  2013     2   24951</a>
#> 3  2013     3   28834</a>
#> 4  2013     4   28330</a>
#> 5  2013     5   28796</a>
#> 6  2013     6   28243</a>
#> # … with 6 more rows</a>
(per_year  &lt;- summarise(per_month, flights = sum(flights)))</a>
#> # A tibble: 1 x 2</a>
#>    year flights</a>
#>   &lt;int>   &lt;int></a>
#> 1  2013  336776</code>

Be careful when progressively rolling up summaries: it’s OK for sums and counts, but you need to think about weighting means and variances, and it’s not possible to do it exactly for rank-based statistics like the median. 
In other words, the sum of groupwise sums is the overall sum, but the median of groupwise medians is not the overall median.

<h3>5.6.6 Ungrouping</h3>
If you need to remove grouping, and return to operations on ungrouped data, use <code>ungroup()</code>.

<code>daily %>% </a>
  ungroup() %>%             # no longer grouped by date</a>
  summarise(flights = n())  # all flights</a>
#> # A tibble: 1 x 1</a>
#>   flights</a>
#>     &lt;int></a>
#> 1  336776</code>

<h3>5.6.7 Exercises</h3>

Brainstorm at least 5 different ways to assess the typical delay
characteristics of a group of flights. 
Consider the following scenarios:

A flight is 15 minutes early 50% of the time, and 15 minutes late 50% of
the time.

A flight is always 10 minutes late.

A flight is 30 minutes early 50% of the time, and 30 minutes late 50% of
the time.

99% of the time a flight is on time. 
1% of the time it’s 2 hours late.

Which is more important: arrival delay or departure delay?

Come up with another approach that will give you the same output as
<code>not_cancelled %>% count(dest)</code> and
<code>not_cancelled %>% count(tailnum, wt = distance)</code> (without using
<code>count()</code>).

Our definition of cancelled flights (<code>is.na(dep_delay) | is.na(arr_delay)</code>
) is slightly suboptimal. 
Why? Which is the most important column?

Look at the number of cancelled flights per day. 
Is there a pattern?
Is the proportion of cancelled flights related to the average delay?

Which carrier has the worst delays? Challenge: can you disentangle the
effects of bad airports vs. bad carriers? Why/why not? (Hint: think about
<code>flights %>% group_by(carrier, dest) %>% summarise(n())</code>)

What does the <code>sort</code> argument to <code>count()</code> do. 
When might you use it?

<h2>5.7 Grouped mutates (and filters)</h2>
Grouping is most useful in conjunction with <code>summarise()</code>, but you can also do convenient operations with <code>mutate()</code> and <code>filter()</code>:

Find the worst members of each group:

<code>flights_sml %>% </a>
  group_by(year, month, day) %>%</a>
  filter(rank(desc(arr_delay)) &lt; 10)</a>
#> # A tibble: 3,306 x 7</a>
#> # Groups:   year, month, day [365]</a>
#>    year month   day dep_delay arr_delay distance air_time</a>
#>   &lt;int> &lt;int> &lt;int>     &lt;dbl>     &lt;dbl>    &lt;dbl>    &lt;dbl></a>
#> 1  2013     1     1       853       851      184       41</a>
#> 2  2013     1     1       290       338     1134      213</a>
#> 3  2013     1     1       260       263      266       46</a>
#> 4  2013     1     1       157       174      213       60</a>
#> 5  2013     1     1       216       222      708      121</a>
#> 6  2013     1     1       255       250      589      115</a>
#> # … with 3,300 more rows</code>

Find all groups bigger than a threshold:

<code>popular_dests &lt;- flights %>% </a>
  group_by(dest) %>% </a>
  filter(n() > 365)</a>
popular_dests</a>
#> # A tibble: 332,577 x 19</a>
#> # Groups:   dest [77]</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      517            515         2      830            819</a>
#> 2  2013     1     1      533            529         4      850            830</a>
#> 3  2013     1     1      542            540         2      923            850</a>
#> 4  2013     1     1      544            545        -1     1004           1022</a>
#> 5  2013     1     1      554            600        -6      812            837</a>
#> 6  2013     1     1      554            558        -4      740            728</a>
#> # … with 332,571 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

Standardise to compute per group metrics:

<code>popular_dests %>% </a>
  filter(arr_delay > 0) %>% </a>
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% </a>
  select(year:day, dest, arr_delay, prop_delay)</a>
#> # A tibble: 131,106 x 6</a>
#> # Groups:   dest [77]</a>
#>    year month   day dest  arr_delay prop_delay</a>
#>   &lt;int> &lt;int> &lt;int> &lt;chr>     &lt;dbl>      &lt;dbl></a>
#> 1  2013     1     1 IAH          11  0.000111 </a>
#> 2  2013     1     1 IAH          20  0.000201 </a>
#> 3  2013     1     1 MIA          33  0.000235 </a>
#> 4  2013     1     1 ORD          12  0.0000424</a>
#> 5  2013     1     1 FLL          19  0.0000938</a>
#> 6  2013     1     1 ORD           8  0.0000283</a>
#> # … with 131,100 more rows</code>

A grouped filter is a grouped mutate followed by an ungrouped filter. 
I generally avoid them except for quick and dirty manipulations: otherwise it’s hard to check that you’ve done the manipulation correctly.

Functions that work most naturally in grouped mutates and filters are known as window functions (vs. the summary functions used for summaries). 
You can learn more about useful window functions in the corresponding vignette: <code>vignette("window-functions")</code>.

<h3>5.7.1 Exercises</h3>

Refer back to the lists of useful mutate and filtering functions.
Describe how each operation changes when you combine it with grouping.

Which plane (<code>tailnum</code>) has the worst on-time record?

What time of day should you fly if you want to avoid delays as much
as possible?

For each destination, compute the total minutes of delay. 
For each
flight, compute the proportion of the total delay for its destination.

Delays are typically temporally correlated: even once the problem that
caused the initial delay has been resolved, later flights are delayed
to allow earlier flights to leave. 
Using <code>lag()</code>, explore how the delay
of a flight is related to the delay of the immediately preceding flight.

Look at each destination. 
Can you find flights that are suspiciously
fast? (i.e. flights that represent a potential data entry error). 
Compute
the air time of a flight relative to the shortest flight to that destination.
Which flights were most delayed in the air?

Find all destinations that are flown by at least two carriers. 
Use that
information to rank the carriers.

For each plane, count the number of flights before the first delay
of greater than 1 hour.

<h2><span class="orange">6 Workflow: scripts</span></h2>
So far you’ve been using the console to run code. 
That’s a great place to start, but you’ll find it gets cramped pretty quickly as you create more complex ggplot2 graphics and dplyr pipes. 
To give yourself more room to work, it’s a great idea to use the script editor. 
Open it up either by clicking the File menu, and selecting New File, then R script, or using the keyboard shortcut Cmd/Ctrl + Shift + N. 
Now you’ll see four panes:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/8a64bb047429d7ae0e2acae35c40e421e6439bf6/80e5d/diagrams/rstudio-editor.png" width="75%" style="display: block; margin: auto;" />

The script editor is a great place to put code you care about. 
Keep experimenting in the console, but once you have written code that works and does what you want, put it in the script editor. 
RStudio will automatically save the contents of the editor when you quit RStudio, and will automatically load it when you re-open. 
Nevertheless, it’s a good idea to save your scripts regularly and to back them up.

<h2>6.1 Running code</h2>
The script editor is also a great place to build up complex ggplot2 plots or long sequences of dplyr manipulations. 
The key to using the script editor effectively is to memorise one of the most important keyboard shortcuts: Cmd/Ctrl + Enter. 
This executes the current R expression in the console. 
For example, take the code below. 
If your cursor is at █, pressing Cmd/Ctrl + Enter will run the complete command that generates <code>not_cancelled</code>. 
It will also move the cursor to the next statement (beginning with <code>not_cancelled %>%</code>). 
That makes it easy to run your complete script by repeatedly pressing Cmd/Ctrl + Enter.

<code>library(dplyr)</a>
library(nycflights13)</a>
</a>
not_cancelled &lt;- flights %>% </a>
  filter(!is.na(dep_delay)█, !is.na(arr_delay))</a>
</a>
not_cancelled %>% </a>
  group_by(year, month, day) %>% </a>
  summarise(mean = mean(dep_delay))</code>

Instead of running expression-by-expression, you can also execute the complete script in one step: Cmd/Ctrl + Shift + S. 
Doing this regularly is a great way to check that you’ve captured all the important parts of your code in the script.

I recommend that you always start your script with the packages that you need. 
That way, if you share your code with others, they can easily see what packages they need to install. 
Note, however, that you should never include <code>install.packages()</code> or <code>setwd()</code> in a script that you share. 
It’s very antisocial to change settings on someone else’s computer!

When working through future chapters, I highly recommend starting in the editor and practicing your keyboard shortcuts. 
Over time, sending code to the console in this way will become so natural that you won’t even think about it.

<h2>6.2 RStudio diagnostics</h2>
The script editor will also highlight syntax errors with a red squiggly line and a cross in the sidebar:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2c70225e177adb09fd2c71641881d91a2a44b84f/1aee8/screenshots/rstudio-diagnostic.png" width="129" style="display: block; margin: auto;" />

Hover over the cross to see what the problem is:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3cb10a911ed68521d7fc9b1f7a8f40806c5cc640/f3daa/screenshots/rstudio-diagnostic-tip.png" width="202" style="display: block; margin: auto;" />

RStudio will also let you know about potential problems:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6f50e3e61d68a0e450e12904754e5b9cfa7ff275/54508/screenshots/rstudio-diagnostic-warn.png" width="439" style="display: block; margin: auto;" />

<h2>6.3 Exercises</h2>

Go to the RStudio Tips twitter account, <a href="https://twitter.com/rstudiotips" class="uri">https://twitter.com/rstudiotips</a>
and find one tip that looks interesting. 
Practice using it!

What other common mistakes will RStudio diagnostics report? Read
<a href="https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics" class="uri">https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics</a> to
find out.

<h2><span class="orange">7 Exploratory Data Analysis</span></h2>

<h2>7.1 Introduction</h2>
This chapter will show you how to use visualisation and transformation to explore your data in a systematic way, a task that statisticians call exploratory data analysis, or EDA for short. 
EDA is an iterative cycle. 
You:

Generate questions about your data.

Search for answers by visualising, transforming, and modelling your data.

Use what you learn to refine your questions and/or generate new questions.

EDA is not a formal process with a strict set of rules. 
More than anything, EDA is a state of mind. 
During the initial phases of EDA you should feel free to investigate every idea that occurs to you. 
Some of these ideas will pan out, and some will be dead ends. 
As your exploration continues, you will home in on a few particularly productive areas that you’ll eventually write up and communicate to others.

EDA is an important part of any data analysis, even if the questions are handed to you on a platter, because you always need to investigate the quality of your data. 
Data cleaning is just one application of EDA: you ask questions about whether your data meets your expectations or not. 
To do data cleaning, you’ll need to deploy all the tools of EDA: visualisation, transformation, and modelling.

<h3>7.1.1 Prerequisites</h3>
In this chapter we’ll combine what you’ve learned about dplyr and ggplot2 to interactively ask questions, answer them with data, and then ask new questions.

<code>library(tidyverse)</code>

<h2>7.2 Questions</h2>
<blockquote>
'There are no routine statistical questions, only questionable statistical
routines.' — Sir David Cox

</blockquote>
<blockquote>
'Far better an approximate answer to the right question, which is often
vague, than an exact answer to the wrong question, which can always be made
precise.' — John Tukey

</blockquote>
Your goal during EDA is to develop an understanding of your data. 
The easiest way to do this is to use questions as tools to guide your investigation. 
When you ask a question, the question focuses your attention on a specific part of your dataset and helps you decide which graphs, models, or transformations to make.

EDA is fundamentally a creative process. 
And like most creative processes, the key to asking <em>quality</em> questions is to generate a large <em>quantity</em> of questions. 
It is difficult to ask revealing questions at the start of your analysis because you do not know what insights are contained in your dataset. 
On the other hand, each new question that you ask will expose you to a new aspect of your data and increase your chance of making a discovery. 
You can quickly drill down into the most interesting parts of your data—and develop a set of thought-provoking questions—if you follow up each question with a new question based on what you find.

There is no rule about which questions you should ask to guide your research. 
However, two types of questions will always be useful for making discoveries within your data. 
You can loosely word these questions as:

What type of variation occurs within my variables?

What type of covariation occurs between my variables?

The rest of this chapter will look at these two questions. 
I’ll explain what variation and covariation are, and I’ll show you several ways to answer each question. 
To make the discussion easier, let’s define some terms:

A variable is a quantity, quality, or property that you can measure.

A value is the state of a variable when you measure it. 
The value of a
variable may change from measurement to measurement.

An observation is a set of measurements made under similar conditions
(you usually make all of the measurements in an observation at the same
time and on the same object). 
An observation will contain several values,
each associated with a different variable. 
I’ll sometimes refer to
an observation as a data point.

Tabular data is a set of values, each associated with a variable and an
observation. 
Tabular data is <em>tidy</em> if each value is placed in its own
'cell', each variable in its own column, and each observation in its own
row.

So far, all of the data that you’ve seen has been tidy. 
In real-life, most data isn’t tidy, so we’ll come back to these ideas again in <a href="tidy-data.html#tidy-data-1">tidy data</a>.

<h2>7.3 Variation</h2>
Variation is the tendency of the values of a variable to change from measurement to measurement. 
You can see variation easily in real life; if you measure any continuous variable twice, you will get two different results. 
This is true even if you measure quantities that are constant, like the speed of light. 
Each of your measurements will include a small amount of error that varies from measurement to measurement. 
Categorical variables can also vary if you measure across different subjects (e.g. the eye colors of different people), or different times (e.g. the energy levels of an electron at different moments).
Every variable has its own pattern of variation, which can reveal interesting information. 
The best way to understand that pattern is to visualise the distribution of the variable’s values.

<h3>7.3.1 Visualising distributions</h3>
How you visualise the distribution of a variable will depend on whether the variable is categorical or continuous. 
A variable is categorical if it can only take one of a small set of values. 
In R, categorical variables are usually saved as factors or character vectors. 
To examine the distribution of a categorical variable, use a bar chart:

<code>ggplot(data = diamonds) +</a>
  geom_bar(mapping = aes(x = cut))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/80ff107e58e5bcfd21defc93467f2b3ed8ac7d07/8f321/eda_files/figure-html/unnamed-chunk-1-1.png" width="70%" style="display: block; margin: auto;" />

The height of the bars displays how many observations occurred with each x value. 
You can compute these values manually with <code>dplyr::count()</code>:

<code>diamonds %>% </a>
  count(cut)</a>
#> # A tibble: 5 x 2</a>
#>   cut           n</a>
#>   &lt;ord>     &lt;int></a>
#> 1 Fair       1610</a>
#> 2 Good       4906</a>
#> 3 Very Good 12082</a>
#> 4 Premium   13791</a>
#> 5 Ideal     21551</code>

A variable is continuous if it can take any of an infinite set of ordered values. 
Numbers and date-times are two examples of continuous variables. 
To examine the distribution of a continuous variable, use a histogram:

<code>ggplot(data = diamonds) +</a>
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/c2c9d99b19239ba83e04f81f7046c00450b834cb/da097/eda_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" />

You can compute this by hand by combining <code>dplyr::count()</code> and <code>ggplot2::cut_width()</code>:

<code>diamonds %>% </a>
  count(cut_width(carat, 0.5))</a>
#> # A tibble: 11 x 2</a>
#>   `cut_width(carat, 0.5)`     n</a>
#>   &lt;fct>                   &lt;int></a>
#> 1 [-0.25,0.25]              785</a>
#> 2 (0.25,0.75]             29498</a>
#> 3 (0.75,1.25]             15977</a>
#> 4 (1.25,1.75]              5313</a>
#> 5 (1.75,2.25]              2002</a>
#> 6 (2.25,2.75]               322</a>
#> # … with 5 more rows</code>

A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. 
In the graph above, the tallest bar shows that almost 30,000 observations have a <code>carat</code> value between 0.25 and 0.75, which are the left and right edges of the bar.

You can set the width of the intervals in a histogram with the <code>binwidth</code> argument, which is measured in the units of the <code>x</code> variable. 
You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns. 
For example, here is how the graph above looks when we zoom into just the diamonds with a size of less than three carats and choose a smaller binwidth.

<code>smaller &lt;- diamonds %>% </a>
  filter(carat &lt; 3)</a>
  </a>
ggplot(data = smaller, mapping = aes(x = carat)) +</a>
  geom_histogram(binwidth = 0.1)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a67ba504915660f1b07f570d71cf22be04bb2a4d/dd9d1/eda_files/figure-html/unnamed-chunk-5-1.png" width="70%" style="display: block; margin: auto;" />

If you wish to overlay multiple histograms in the same plot, I recommend using <code>geom_freqpoly()</code> instead of <code>geom_histogram()</code>. 
<code>geom_freqpoly()</code> performs the same calculation as <code>geom_histogram()</code>, but instead of displaying the counts with bars, uses lines instead. 
It’s much easier to understand overlapping lines than bars.

<code>ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +</a>
  geom_freqpoly(binwidth = 0.1)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/198249d8425ec4cd653c02ad11bb10f911052917/8ddf9/eda_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" />

There are a few challenges with this type of plot, which we will come back to in <a href="exploratory-data-analysis.html#cat-cont">visualising a categorical and a continuous variable</a>.

Now that you can visualise variation, what should you look for in your plots? And what type of follow-up questions should you ask? I’ve put together a list below of the most useful types of information that you will find in your graphs, along with some follow-up questions for each type of information. 
The key to asking good follow-up questions will be to rely on your curiosity (What do you want to learn more about?) as well as your skepticism (How could this be misleading?).

<h3>7.3.2 Typical values</h3>
In both bar charts and histograms, tall bars show the common values of a variable, and shorter bars show less-common values. 
Places that do not have bars reveal values that were not seen in your data. 
To turn this information into useful questions, look for anything unexpected:

Which values are the most common? Why?

Which values are rare? Why? Does that match your expectations?

Can you see any unusual patterns? What might explain them?

As an example, the histogram below suggests several interesting questions:

Why are there more diamonds at whole carats and common fractions of carats?

Why are there more diamonds slightly to the right of each peak than there
are slightly to the left of each peak?

Why are there no diamonds bigger than 3 carats?

<code>ggplot(data = smaller, mapping = aes(x = carat)) +</a>
  geom_histogram(binwidth = 0.01)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2f153fad815267222e2c062ef0759ebe43283081/f4cd8/eda_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" />

Clusters of similar values suggest that subgroups exist in your data. 
To understand the subgroups, ask:

How are the observations within each cluster similar to each other?

How are the observations in separate clusters different from each other?

How can you explain or describe the clusters?

Why might the appearance of clusters be misleading?

The histogram below shows the length (in minutes) of 272 eruptions of the Old Faithful Geyser in Yellowstone National Park. 
Eruption times appear to be clustered into two groups: there are short eruptions (of around 2 minutes) and long eruptions (4-5 minutes), but little in between.

<code>ggplot(data = faithful, mapping = aes(x = eruptions)) + </a>
  geom_histogram(binwidth = 0.25)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5dd151aa74e67bb734eeb55a232cd67ba309da6d/a4b73/eda_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" />

Many of the questions above will prompt you to explore a relationship <em>between</em> variables, for example, to see if the values of one variable can explain the behavior of another variable. 
We’ll get to that shortly.

<h3>7.3.3 Unusual values</h3>
Outliers are observations that are unusual; data points that don’t seem to fit the pattern. 
Sometimes outliers are data entry errors; other times outliers suggest important new science. 
When you have a lot of data, outliers are sometimes difficult to see in a histogram. 
For example, take the distribution of the <code>y</code> variable from the diamonds dataset. 
The only evidence of outliers is the unusually wide limits on the x-axis.

<code>ggplot(diamonds) + </a>
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/08e98f1cb12f68014a28f7b7affb323bd1ae0e8f/ea411/eda_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" />

There are so many observations in the common bins that the rare bins are so short that you can’t see them (although maybe if you stare intently at 0 you’ll spot something). 
To make it easy to see the unusual values, we need to zoom to small values of the y-axis with <code>coord_cartesian()</code>:

<code>ggplot(diamonds) + </a>
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +</a>
  coord_cartesian(ylim = c(0, 50))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f75640b891e65c3baebdbad30f57e677a72607d4/32a65/eda_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

(<code>coord_cartesian()</code> also has an <code>xlim()</code> argument for when you need to zoom into the x-axis. 
ggplot2 also has <code>xlim()</code> and <code>ylim()</code> functions that work slightly differently: they throw away the data outside the limits.)

This allows us to see that there are three unusual values: 0, ~30, and ~60. 
We pluck them out with dplyr:

<code>unusual &lt;- diamonds %>% </a>
  filter(y &lt; 3 | y > 20) %>% </a>
  select(price, x, y, z) %>%</a>
  arrange(y)</a>
unusual</a>
#> # A tibble: 9 x 4</a>
#>   price     x     y     z</a>
#>   &lt;int> &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  5139  0      0    0   </a>
#> 2  6381  0      0    0   </a>
#> 3 12800  0      0    0   </a>
#> 4 15686  0      0    0   </a>
#> 5 18034  0      0    0   </a>
#> 6  2130  0      0    0   </a>
#> 7  2130  0      0    0   </a>
#> 8  2075  5.15  31.8  5.12</a>
#> 9 12210  8.09  58.9  8.06</code>

The <code>y</code> variable measures one of the three dimensions of these diamonds, in mm. 
We know that diamonds can’t have a width of 0mm, so these values must be incorrect. 
We might also suspect that measurements of 32mm and 59mm are implausible: those diamonds are over an inch long, but don’t cost hundreds of thousands of dollars!

It’s good practice to repeat your analysis with and without the outliers. 
If they have minimal effect on the results, and you can’t figure out why they’re there, it’s reasonable to replace them with missing values, and move on. 
However, if they have a substantial effect on your results, you shouldn’t drop them without justification. 
You’ll need to figure out what caused them (e.g. a data entry error) and disclose that you removed them in your write-up.

<h3>7.3.4 Exercises</h3>

Explore the distribution of each of the <code>x</code>, <code>y</code>, and <code>z</code> variables
in <code>diamonds</code>. 
What do you learn? Think about a diamond and how you
might decide which dimension is the length, width, and depth.

Explore the distribution of <code>price</code>. 
Do you discover anything unusual
or surprising? (Hint: Carefully think about the <code>binwidth</code> and make sure
you try a wide range of values.)

How many diamonds are 0.99 carat? How many are 1 carat? What
do you think is the cause of the difference?

Compare and contrast <code>coord_cartesian()</code> vs <code>xlim()</code> or <code>ylim()</code> when
zooming in on a histogram. 
What happens if you leave <code>binwidth</code> unset?
What happens if you try and zoom so only half a bar shows?

<h2>7.4 Missing values</h2>
If you’ve encountered unusual values in your dataset, and simply want to move on to the rest of your analysis, you have two options.

Drop the entire row with the strange values:

<code>diamonds2 &lt;- diamonds %>% </a>
  filter(between(y, 3, 20))</code>

I don’t recommend this option because just because one measurement
is invalid, doesn’t mean all the measurements are. 
Additionally, if you
have low quality data, by time that you’ve applied this approach to every
variable you might find that you don’t have any data left!

Instead, I recommend replacing the unusual values with missing values.
The easiest way to do this is to use <code>mutate()</code> to replace the variable
with a modified copy. 
You can use the <code>ifelse()</code> function to replace
unusual values with <code>NA</code>:

<code>diamonds2 &lt;- diamonds %>% </a>
  mutate(y = ifelse(y &lt; 3 | y > 20, NA, y))</code>

<code>ifelse()</code> has three arguments. 
The first argument <code>test</code> should be a logical vector. 
The result will contain the value of the second argument, <code>yes</code>, when <code>test</code> is <code>TRUE</code>, and the value of the third argument, <code>no</code>, when it is false. 
Alternatively to ifelse, use <code>dplyr::case_when()</code>. 
<code>case_when()</code> is particularly useful inside mutate when you want to create a new variable that relies on a complex combination of existing variables.

Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing. 
It’s not obvious where you should plot missing values, so ggplot2 doesn’t include them in the plot, but it does warn that they’ve been removed:

<code>ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + </a>
  geom_point()</a>
#> Warning: Removed 9 rows containing missing values (geom_point).</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4b849dfb0d4a96d87b33b8665bed3eddb9182570/613f7/eda_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" />

To suppress that warning, set <code>na.rm = TRUE</code>:

<code>ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + </a>
  geom_point(na.rm = TRUE)</code>

Other times you want to understand what makes observations with missing values different to observations with recorded values. 
For example, in <code>nycflights13::flights</code>, missing values in the <code>dep_time</code> variable indicate that the flight was cancelled. 
So you might want to compare the scheduled departure times for cancelled and non-cancelled times. 
You can do this by making a new variable with <code>is.na()</code>.

<code>nycflights13::flights %>% </a>
  mutate(</a>
    cancelled = is.na(dep_time),</a>
    sched_hour = sched_dep_time %/% 100,</a>
    sched_min = sched_dep_time %% 100,</a>
    sched_dep_time = sched_hour + sched_min / 60</a>
  ) %>% </a>
  ggplot(mapping = aes(sched_dep_time)) + </a>
    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9d52221a276e8e1b4e9577413ab4ae147c60e798/7ecf7/eda_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

However this plot isn’t great because there are many more non-cancelled flights than cancelled flights. 
In the next section we’ll explore some techniques for improving this comparison.

<h3>7.4.1 Exercises</h3>

What happens to missing values in a histogram? What happens to missing
values in a bar chart? Why is there a difference?

What does <code>na.rm = TRUE</code> do in <code>mean()</code> and <code>sum()</code>?

<h2>7.5 Covariation</h2>
If variation describes the behavior <em>within</em> a variable, covariation describes the behavior <em>between</em> variables. 
Covariation is the tendency for the values of two or more variables to vary together in a related way. 
The best way to spot covariation is to visualise the relationship between two or more variables. 
How you do that should again depend on the type of variables involved.

<h3>7.5.1 A categorical and continuous variable</h3>
It’s common to want to explore the distribution of a continuous variable broken down by a categorical variable, as in the previous frequency polygon. 
The default appearance of <code>geom_freqpoly()</code> is not that useful for that sort of comparison because the height is given by the count. 
That means if one of the groups is much smaller than the others, it’s hard to see the differences in shape. 
For example, let’s explore how the price of a diamond varies with its quality:

<code>ggplot(data = diamonds, mapping = aes(x = price)) + </a>
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1184dad3c5a90d2496b155ccb8cf89adeb82fd46/ea4b0/eda_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

It’s hard to see the difference in distribution because the overall counts differ so much:

<code>ggplot(diamonds) + </a>
  geom_bar(mapping = aes(x = cut))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/217ce57107f56cf45d56617694745ae1a9bea706/e407e/eda_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

To make the comparison easier we need to swap what is displayed on the y-axis. 
Instead of displaying count, we’ll display density, which is the count standardised so that the area under each frequency polygon is one.

<code>ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + </a>
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dfa29c31c293c4651cf9fec954b589d21e81ce75/bc2c0/eda_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" />

There’s something rather surprising about this plot - it appears that fair diamonds (the lowest quality) have the highest average price! But maybe that’s because frequency polygons are a little hard to interpret - there’s a lot going on in this plot.

Another alternative to display the distribution of a continuous variable broken down by a categorical variable is the boxplot. 
A boxplot is a type of visual shorthand for a distribution of values that is popular among statisticians. 
Each boxplot consists of:

A box that stretches from the 25th percentile of the distribution to the
75th percentile, a distance known as the interquartile range (IQR). 
In the
middle of the box is a line that displays the median, i.e. 50th percentile,
of the distribution. 
These three lines give you a sense of the spread of the
distribution and whether or not the distribution is symmetric about the
median or skewed to one side.

Visual points that display observations that fall more than 1.5 times the
IQR from either edge of the box. 
These outlying points are unusual
so are plotted individually.

A line (or whisker) that extends from each end of the box and goes to the<br />
farthest non-outlier point in the distribution.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/153b9af53b33918353fda9b691ded68cd7f62f51/5b616/images/eda-boxplot.png" width="100%" style="display: block; margin: auto;" />

Let’s take a look at the distribution of price by cut using <code>geom_boxplot()</code>:

<code>ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +</a>
  geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e4004868cf95870a316ad2acf3019d23fba7e81d/53537/eda_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" />

We see much less information about the distribution, but the boxplots are much more compact so we can more easily compare them (and fit more on one plot). 
It supports the counterintuitive finding that better quality diamonds are cheaper on average! In the exercises, you’ll be challenged to figure out why.

<code>cut</code> is an ordered factor: fair is worse than good, which is worse than very good and so on. 
Many categorical variables don’t have such an intrinsic order, so you might want to reorder them to make a more informative display. 
One way to do that is with the <code>reorder()</code> function.

For example, take the <code>class</code> variable in the <code>mpg</code> dataset. 
You might be interested to know how highway mileage varies across classes:

<code>ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +</a>
  geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1c00288d2cae2858ebf944ed7146ca7ecaedea84/f8f27/eda_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" />

To make the trend easier to see, we can reorder <code>class</code> based on the median value of <code>hwy</code>:

<code>ggplot(data = mpg) +</a>
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6815ec35089c274a4fa7915f262b14f5f740b939/78ec4/eda_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" />

If you have long variable names, <code>geom_boxplot()</code> will work better if you flip it 90°. 
You can do that with <code>coord_flip()</code>.

<code>ggplot(data = mpg) +</a>
  geom_boxplot(mapping = aes(x = reorder(class, hwy, FUN = median), y = hwy)) +</a>
  coord_flip()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d31166462e0e4169f1f600d706b58be48d7d3bc1/5da16/eda_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" />

<h4>7.5.1.1 Exercises</h4>

Use what you’ve learned to improve the visualisation of the departure times
of cancelled vs. non-cancelled flights.

What variable in the diamonds dataset is most important for predicting
the price of a diamond? How is that variable correlated with cut?
Why does the combination of those two relationships lead to lower quality
diamonds being more expensive?

Install the ggstance package, and create a horizontal boxplot.
How does this compare to using <code>coord_flip()</code>?

One problem with boxplots is that they were developed in an era of
much smaller datasets and tend to display a prohibitively large
number of 'outlying values'. 
One approach to remedy this problem is
the letter value plot. 
Install the lvplot package, and try using
<code>geom_lv()</code> to display the distribution of price vs cut. 
What
do you learn? How do you interpret the plots?

Compare and contrast <code>geom_violin()</code> with a facetted <code>geom_histogram()</code>,
or a coloured <code>geom_freqpoly()</code>. 
What are the pros and cons of each
method?

If you have a small dataset, it’s sometimes useful to use <code>geom_jitter()</code>
to see the relationship between a continuous and categorical variable.
The ggbeeswarm package provides a number of methods similar to
<code>geom_jitter()</code>. 
List them and briefly describe what each one does.

<h3>7.5.2 Two categorical variables</h3>
To visualise the covariation between categorical variables, you’ll need to count the number of observations for each combination. 
One way to do that is to rely on the built-in <code>geom_count()</code>:

<code>ggplot(data = diamonds) +</a>
  geom_count(mapping = aes(x = cut, y = color))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d9597bc475b95a4e88770f19a7a5059eacda406c/d06f7/eda_files/figure-html/unnamed-chunk-27-1.png" width="70%" style="display: block; margin: auto;" />

The size of each circle in the plot displays how many observations occurred at each combination of values. 
Covariation will appear as a strong correlation between specific x values and specific y values.

Another approach is to compute the count with dplyr:

<code>diamonds %>% </a>
  count(color, cut)</a>
#> # A tibble: 35 x 3</a>
#>   color cut           n</a>
#>   &lt;ord> &lt;ord>     &lt;int></a>
#> 1 D     Fair        163</a>
#> 2 D     Good        662</a>
#> 3 D     Very Good  1513</a>
#> 4 D     Premium    1603</a>
#> 5 D     Ideal      2834</a>
#> 6 E     Fair        224</a>
#> # … with 29 more rows</code>

Then visualise with <code>geom_tile()</code> and the fill aesthetic:

<code>diamonds %>% </a>
  count(color, cut) %>%  </a>
  ggplot(mapping = aes(x = color, y = cut)) +</a>
    geom_tile(mapping = aes(fill = n))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/57e5b19686661337a95d5489e2b33a882c2d13f5/43e32/eda_files/figure-html/unnamed-chunk-29-1.png" width="70%" style="display: block; margin: auto;" />

If the categorical variables are unordered, you might want to use the seriation package to simultaneously reorder the rows and columns in order to more clearly reveal interesting patterns. 
For larger plots, you might want to try the d3heatmap or heatmaply packages, which create interactive plots.

<h4>7.5.2.1 Exercises</h4>

How could you rescale the count dataset above to more clearly show
the distribution of cut within colour, or colour within cut?

Use <code>geom_tile()</code> together with dplyr to explore how average flight
delays vary by destination and month of year. 
What makes the
plot difficult to read? How could you improve it?

Why is it slightly better to use <code>aes(x = color, y = cut)</code> rather
than <code>aes(x = cut, y = color)</code> in the example above?

<h3>7.5.3 Two continuous variables</h3>
You’ve already seen one great way to visualise the covariation between two continuous variables: draw a scatterplot with <code>geom_point()</code>. 
You can see covariation as a pattern in the points. 
For example, you can see an exponential relationship between the carat size and price of a diamond.

<code>ggplot(data = diamonds) +</a>
  geom_point(mapping = aes(x = carat, y = price))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2d7632e385717767a24f76cae2b63d453229a8f8/a8752/eda_files/figure-html/unnamed-chunk-30-1.png" width="70%" style="display: block; margin: auto;" />

Scatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black (as above).
You’ve already seen one way to fix the problem: using the <code>alpha</code> aesthetic to add transparency.

<code>ggplot(data = diamonds) + </a>
  geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1d2491e65fc813f40801c0063e2c3af8670d49d6/4ba38/eda_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" />

But using transparency can be challenging for very large datasets. 
Another solution is to use bin. 
Previously you used <code>geom_histogram()</code> and <code>geom_freqpoly()</code> to bin in one dimension. 
Now you’ll learn how to use <code>geom_bin2d()</code> and <code>geom_hex()</code> to bin in two dimensions.

<code>geom_bin2d()</code> and <code>geom_hex()</code> divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. 
<code>geom_bin2d()</code> creates rectangular bins. 
<code>geom_hex()</code> creates hexagonal bins. 
You will need to install the hexbin package to use <code>geom_hex()</code>.

<code>ggplot(data = smaller) +</a>
  geom_bin2d(mapping = aes(x = carat, y = price))</a>
</a>
# install.packages("hexbin")</a>
ggplot(data = smaller) +</a>
  geom_hex(mapping = aes(x = carat, y = price))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5822b75f2c17708ef26aee5b5d0dc018c3dce5d1/b3d2e/eda_files/figure-html/unnamed-chunk-32-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/901bead6fc324ca8543cef0c5aa21e865bba70e3/96986/eda_files/figure-html/unnamed-chunk-32-2.png" width="50%" />

Another option is to bin one continuous variable so it acts like a categorical variable. 
Then you can use one of the techniques for visualising the combination of a categorical and a continuous variable that you learned about. 
For example, you could bin <code>carat</code> and then for each group, display a boxplot:

<code>ggplot(data = smaller, mapping = aes(x = carat, y = price)) + </a>
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6d6d752d371eb0ee6a3efcd64583413ab9d91541/67d05/eda_files/figure-html/unnamed-chunk-33-1.png" width="70%" style="display: block; margin: auto;" />

<code>cut_width(x, width)</code>, as used above, divides <code>x</code> into bins of width <code>width</code>. 
By default, boxplots look roughly the same (apart from number of outliers) regardless of how many observations there are, so it’s difficult to tell that each boxplot summarises a different number of points. 
One way to show that is to make the width of the boxplot proportional to the number of points with <code>varwidth = TRUE</code>.

Another approach is to display approximately the same number of points in each bin. 
That’s the job of <code>cut_number()</code>:

<code>ggplot(data = smaller, mapping = aes(x = carat, y = price)) + </a>
  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7ffa37525ca77ff6fe5c4c74be8edc8ec181d078/a4c3d/eda_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" />

<h4>7.5.3.1 Exercises</h4>

Instead of summarising the conditional distribution with a boxplot, you
could use a frequency polygon. 
What do you need to consider when using
<code>cut_width()</code> vs <code>cut_number()</code>? How does that impact a visualisation of
the 2d distribution of <code>carat</code> and <code>price</code>?

Visualise the distribution of carat, partitioned by price.

How does the price distribution of very large diamonds compare to small
diamonds? Is it as you expect, or does it surprise you?

Combine two of the techniques you’ve learned to visualise the
combined distribution of cut, carat, and price.

Two dimensional plots reveal outliers that are not visible in one
dimensional plots. 
For example, some points in the plot below have an
unusual combination of <code>x</code> and <code>y</code> values, which makes the points outliers
even though their <code>x</code> and <code>y</code> values appear normal when examined separately.

<code>ggplot(data = diamonds) +</a>
  geom_point(mapping = aes(x = x, y = y)) +</a>
  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7e14360ab55c263d785a490e5e04fd4c7a938df0/551e7/eda_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" />

Why is a scatterplot a better display than a binned plot for this case?

<h2>7.6 Patterns and models</h2>
Patterns in your data provide clues about relationships. 
If a systematic relationship exists between two variables it will appear as a pattern in the data. 
If you spot a pattern, ask yourself:

Could this pattern be due to coincidence (i.e. random chance)?

How can you describe the relationship implied by the pattern?

How strong is the relationship implied by the pattern?

What other variables might affect the relationship?

Does the relationship change if you look at individual subgroups of the data?

A scatterplot of Old Faithful eruption lengths versus the wait time between eruptions shows a pattern: longer wait times are associated with longer eruptions. 
The scatterplot also displays the two clusters that we noticed above.

<code>ggplot(data = faithful) + </a>
  geom_point(mapping = aes(x = eruptions, y = waiting))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/24418cc671c72c373843a22793678585c9330f8d/f3387/eda_files/figure-html/unnamed-chunk-36-1.png" width="70%" style="display: block; margin: auto;" />

Patterns provide one of the most useful tools for data scientists because they reveal covariation. 
If you think of variation as a phenomenon that creates uncertainty, covariation is a phenomenon that reduces it. 
If two variables covary, you can use the values of one variable to make better predictions about the values of the second. 
If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

Models are a tool for extracting patterns out of data. 
For example, consider the diamonds data. 
It’s hard to understand the relationship between cut and price, because cut and carat, and carat and price are tightly related. 
It’s possible to use a model to remove the very strong relationship between price and carat so we can explore the subtleties that remain. 
The following code fits a model that predicts <code>price</code> from <code>carat</code> and then computes the residuals (the difference between the predicted value and the actual value). 
The residuals give us a view of the price of the diamond, once the effect of carat has been removed.

<code>library(modelr)</a>
</a>
mod &lt;- lm(log(price) ~ log(carat), data = diamonds)</a>
</a>
diamonds2 &lt;- diamonds %>% </a>
  add_residuals(mod) %>% </a>
  mutate(resid = exp(resid))</a>
</a>
ggplot(data = diamonds2) + </a>
  geom_point(mapping = aes(x = carat, y = resid))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/05c8a573098d370df9971d1e2a718d8de70777df/da0a2/eda_files/figure-html/unnamed-chunk-37-1.png" width="70%" style="display: block; margin: auto;" />

Once you’ve removed the strong relationship between carat and price, you can see what you expect in the relationship between cut and price: relative to their size, better quality diamonds are more expensive.

<code>ggplot(data = diamonds2) + </a>
  geom_boxplot(mapping = aes(x = cut, y = resid))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3ac8a895b5417a8d93440e6895fa351d6a0bbc70/f5512/eda_files/figure-html/unnamed-chunk-38-1.png" width="70%" style="display: block; margin: auto;" />

You’ll learn how models, and the modelr package, work in the final part of the book, <a href="model-intro.html#model-intro">model</a>. 
We’re saving modelling for later because understanding what models are and how they work is easiest once you have tools of data wrangling and programming in hand.

<h2>7.7 ggplot2 calls</h2>
As we move on from these introductory chapters, we’ll transition to a more concise expression of ggplot2 code. 
So far we’ve been very explicit, which is helpful when you are learning:

<code>ggplot(data = faithful, mapping = aes(x = eruptions)) + </a>
  geom_freqpoly(binwidth = 0.25)</code>

Typically, the first one or two arguments to a function are so important that you should know them by heart. 
The first two arguments to <code>ggplot()</code> are <code>data</code> and <code>mapping</code>, and the first two arguments to <code>aes()</code> are <code>x</code> and <code>y</code>. 
In the remainder of the book, we won’t supply those names. 
That saves typing, and, by reducing the amount of boilerplate, makes it easier to see what’s different between plots. 
That’s a really important programming concern that we’ll come back in <a href="functions.html#functions">functions</a>.

Rewriting the previous plot more concisely yields:

<code>ggplot(faithful, aes(eruptions)) + </a>
  geom_freqpoly(binwidth = 0.25)</code>

Sometimes we’ll turn the end of a pipeline of data transformation into a plot. 
Watch for the transition from <code>%>%</code> to <code>+</code>. 
I wish this transition wasn’t necessary but unfortunately ggplot2 was created before the pipe was discovered.

<code>diamonds %>% </a>
  count(cut, clarity) %>% </a>
  ggplot(aes(clarity, cut, fill = n)) + </a>
    geom_tile()</code>

<h2>7.8 Learning more</h2>
If you want to learn more about the mechanics of ggplot2, I’d highly recommend grabbing a copy of the ggplot2 book: <a href="https://amzn.com/331924275X" class="uri">https://amzn.com/331924275X</a>. 
It’s been recently updated, so it includes dplyr and tidyr code, and has much more space to explore all the facets of visualisation. 
Unfortunately the book isn’t generally available for free, but if you have a connection to a university you can probably get an electronic version for free through SpringerLink.

Another useful resource is the <a href="https://amzn.com/1449316956"><em>R Graphics Cookbook</em></a> by Winston Chang. 
Much of the contents are available online at <a href="http://www.cookbook-r.com/Graphs/" class="uri">http://www.cookbook-r.com/Graphs/</a>.

I also recommend <a href="https://amzn.com/1498715230"><em>Graphical Data Analysis with R</em></a>, by Antony Unwin. 
This is a book-length treatment similar to the material covered in this chapter, but has the space to go into much greater depth.

<h2><span class="orange">8 Workflow: projects</span></h2>
One day you will need to quit R, go do something else and return to your analysis the next day. 
One day you will be working on multiple analyses simultaneously that all use R and you want to keep them separate. 
One day you will need to bring data from the outside world into R and send numerical results and figures from R back out into the world. 
To handle these real life situations, you need to make two decisions:

What about your analysis is 'real', i.e. what will you save as your
lasting record of what happened?

Where does your analysis 'live'?

<h2>8.1 What is real?</h2>
As a beginning R user, it’s OK to consider your environment (i.e. the objects listed in the environment pane) 'real'. 
However, in the long run, you’ll be much better off if you consider your R scripts as 'real'.

With your R scripts (and your data files), you can recreate the environment. 
It’s much harder to recreate your R scripts from your environment! You’ll either have to retype a lot of code from memory (making mistakes all the way) or you’ll have to carefully mine your R history.

To foster this behaviour, I highly recommend that you instruct RStudio not to preserve your workspace between sessions:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7fa44a5471d40025344176ede4169c5ad3159482/1577f/screenshots/rstudio-workspace.png" width="75%" style="display: block; margin: auto;" />

This will cause you some short-term pain, because now when you restart RStudio it will not remember the results of the code that you ran last time. 
But this short-term pain will save you long-term agony because it forces you to capture all important interactions in your code. 
There’s nothing worse than discovering three months after the fact that you’ve only stored the results of an important calculation in your workspace, not the calculation itself in your code.

There is a great pair of keyboard shortcuts that will work together to make sure you’ve captured the important parts of your code in the editor:

Press Cmd/Ctrl + Shift + F10 to restart RStudio.

Press Cmd/Ctrl + Shift + S to rerun the current script.

I use this pattern hundreds of times a week.

<h2>8.2 Where does your analysis live?</h2>
R has a powerful notion of the working directory. 
This is where R looks for files that you ask it to load, and where it will put any files that you ask it to save. 
RStudio shows your current working directory at the top of the console:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/176fc11b0b484209bd77f13ab5116b8a0d7aa13a/2b6f7/screenshots/rstudio-wd.png" width="50%" style="display: block; margin: auto;" />

And you can print this out in R code by running <code>getwd()</code>:

<code>getwd()</a>
#> [1] "/Users/hadley/Documents/r4ds/r4ds"</code>

As a beginning R user, it’s OK to let your home directory, documents directory, or any other weird directory on your computer be R’s working directory. 
But you’re six chapters into this book, and you’re no longer a rank beginner. 
Very soon now you should evolve to organising your analytical projects into directories and, when working on a project, setting R’s working directory to the associated directory.

I do not recommend it, but you can also set the working directory from within R:

<code>setwd("/path/to/my/CoolProject")</code>

But you should never do this because there’s a better way; a way that also puts you on the path to managing your R work like an expert.

<h2>8.3 Paths and directories</h2>
Paths and directories are a little complicated because there are two basic styles of paths: Mac/Linux and Windows. 
There are three chief ways in which they differ:

The most important difference is how you separate the components of the
path. 
Mac and Linux uses slashes (e.g. 
<code>plots/diamonds.pdf</code>) and Windows
uses backslashes (e.g. 
<code>plots\diamonds.pdf</code>). 
R can work with either type
(no matter what platform you’re currently using), but unfortunately,
backslashes mean something special to R, and to get a single backslash
in the path, you need to type two backslashes! That makes life frustrating,
so I recommend always using the Linux/Mac style with forward slashes.

Absolute paths (i.e. paths that point to the same place regardless of
your working directory) look different. 
In Windows they start with a drive
letter (e.g. 
<code>C:</code>) or two backslashes (e.g. 
<code>\\servername</code>) and in
Mac/Linux they start with a slash '/' (e.g. 
<code>/users/hadley</code>). 
You should
never use absolute paths in your scripts, because they hinder sharing:
no one else will have exactly the same directory configuration as you.

The last minor difference is the place that <code>~</code> points to. 
<code>~</code> is a
convenient shortcut to your home directory. 
Windows doesn’t really have
the notion of a home directory, so it instead points to your documents
directory.

<h2>8.4 RStudio projects</h2>
R experts keep all the files associated with a project together — input data, R scripts, analytical results, figures. 
This is such a wise and common practice that RStudio has built-in support for this via projects.

Let’s make a project for you to use while you’re working through the rest of this book. 
Click File > New Project, then:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/87562c4851bf4d0b0c8415dc9d6690493572e362/a6685/screenshots/rstudio-project-1.png" width="50%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0fa791e2621be297cb9c5cac0b2802223e3d7714/57d89/screenshots/rstudio-project-2.png" width="50%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dee6324df1f5c5121d1c1e9eed822ee52c87167b/1f325/screenshots/rstudio-project-3.png" width="50%" style="display: block; margin: auto;" />

Call your project <code>r4ds</code> and think carefully about which <em>subdirectory</em> you put the project in. 
If you don’t store it somewhere sensible, it will be hard to find it in the future!

Once this process is complete, you’ll get a new RStudio project just for this book. 
Check that the 'home' directory of your project is the current working directory:

<code>getwd()</a>
#> [1] /Users/hadley/Documents/r4ds/r4ds</code>

Whenever you refer to a file with a relative path it will look for it here.

Now enter the following commands in the script editor, and save the file, calling it 'diamonds.R'. 
Next, run the complete script which will save a PDF and CSV file into your project directory. 
Don’t worry about the details, you’ll learn them later in the book.

<code>library(tidyverse)</a>
</a>
ggplot(diamonds, aes(carat, price)) + </a>
  geom_hex()</a>
ggsave("diamonds.pdf")</a>
</a>
write_csv(diamonds, "diamonds.csv")</code>

Quit RStudio. 
Inspect the folder associated with your project — notice the <code>.Rproj</code> file. 
Double-click that file to re-open the project. 
Notice you get back to where you left off: it’s the same working directory and command history, and all the files you were working on are still open. 
Because you followed my instructions above, you will, however, have a completely fresh environment, guaranteeing that you’re starting with a clean slate.

In your favorite OS-specific way, search your computer for <code>diamonds.pdf</code> and you will find the PDF (no surprise) but <em>also the script that created it</em> (<code>diamonds.R</code>). 
This is huge win! One day you will want to remake a figure or just understand where it came from. 
If you rigorously save figures to files with R code and never with the mouse or the clipboard, you will be able to reproduce old work with ease!

<h2>8.5 Summary</h2>
In summary, RStudio projects give you a solid workflow that will serve you well in the future:

Create an RStudio project for each data analysis project.

Keep data files there; we’ll talk about loading them into R in
<a href="data-import.html#data-import">data import</a>.

Keep scripts there; edit them, run them in bits or as a whole.

Save your outputs (plots and cleaned data) there.

Only ever use relative paths, not absolute paths.

Everything you need is in one place, and cleanly separated from all the other projects that you are working on.

<h2><span class="orange">9 Introduction</span></h2>
In this part of the book, you’ll learn about data wrangling, the art of getting your data into R in a useful form for visualisation and modelling. 
Data wrangling is very important: without it you can’t work with your own data! There are three main parts to data wrangling:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e3f9e555d0035731c04642ceb58a03fb84b98a7d/4f070/diagrams/data-science-wrangle.png" width="75%" style="display: block; margin: auto;" />

This part of the book proceeds as follows:

In <a href="vectors.html#tibbles-1">tibbles</a>, you’ll learn about the variant of the data frame that we use
in this book: the tibble. 
You’ll learn what makes them different
from regular data frames, and how you can construct them 'by hand'.

In <a href="data-import.html#data-import">data import</a>, you’ll learn how to get your data from disk and into R.
We’ll focus on plain-text rectangular formats, but will give you pointers
to packages that help with other types of data.

In <a href="tidy-data.html#tidy-data-1">tidy data</a>, you’ll learn about tidy data, a consistent way of storing
your data that makes transformation, visualisation, and modelling easier.
You’ll learn the underlying principles, and how to get your data into a
tidy form.

Data wrangling also encompasses data transformation, which you’ve already learned a little about. 
Now we’ll focus on new skills for three specific types of data you will frequently encounter in practice:

<a href="relational-data.html#relational-data">Relational data</a> will give you tools for working with multiple
interrelated datasets.

<a href="strings.html#strings">Strings</a> will introduce regular expressions, a powerful tool for
manipulating strings.

<a href="vectors.html#factors-1">Factors</a> are how R stores categorical data. 
They are used when a variable
has a fixed set of possible values, or when you want to use a non-alphabetical
ordering of a string.

<a href="dates-and-times.html#dates-and-times">Dates and times</a> will give you the key tools for working with
dates and date-times.

<h2><span class="orange">10 Tibbles</span></h2>

<h2>10.1 Introduction</h2>
Throughout this book we work with 'tibbles' instead of R’s traditional <code>data.frame</code>. 
Tibbles <em>are</em> data frames, but they tweak some older behaviours to make life a little easier. 
R is an old language, and some things that were useful 10 or 20 years ago now get in your way. 
It’s difficult to change base R without breaking existing code, so most innovation occurs in packages. 
Here we will describe the tibble package, which provides opinionated data frames that make working in the tidyverse a little easier. 
In most places, I’ll use the term tibble and data frame interchangeably; when I want to draw particular attention to R’s built-in data frame, I’ll call them <code>data.frame</code>s.

If this chapter leaves you wanting to learn more about tibbles, you might enjoy <code>vignette("tibble")</code>.

<h3>10.1.1 Prerequisites</h3>
In this chapter we’ll explore the tibble package, part of the core tidyverse.

<code>library(tidyverse)</code>

<h2>10.2 Creating tibbles</h2>
Almost all of the functions that you’ll use in this book produce tibbles, as tibbles are one of the unifying features of the tidyverse. 
Most other R packages use regular data frames, so you might want to coerce a data frame to a tibble. 
You can do that with <code>as_tibble()</code>:

<code>as_tibble(iris)</a>
#> # A tibble: 150 x 5</a>
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</a>
#>          &lt;dbl>       &lt;dbl>        &lt;dbl>       &lt;dbl> &lt;fct>  </a>
#> 1          5.1         3.5          1.4         0.2 setosa </a>
#> 2          4.9         3            1.4         0.2 setosa </a>
#> 3          4.7         3.2          1.3         0.2 setosa </a>
#> 4          4.6         3.1          1.5         0.2 setosa </a>
#> 5          5           3.6          1.4         0.2 setosa </a>
#> 6          5.4         3.9          1.7         0.4 setosa </a>
#> # … with 144 more rows</code>

You can create a new tibble from individual vectors with <code>tibble()</code>. 
<code>tibble()</code> will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.

<code>tibble(</a>
  x = 1:5, </a>
  y = 1, </a>
  z = x ^ 2 + y</a>
)</a>
#> # A tibble: 5 x 3</a>
#>       x     y     z</a>
#>   &lt;int> &lt;dbl> &lt;dbl></a>
#> 1     1     1     2</a>
#> 2     2     1     5</a>
#> 3     3     1    10</a>
#> 4     4     1    17</a>
#> 5     5     1    26</code>

If you’re already familiar with <code>data.frame()</code>, note that <code>tibble()</code> does much less: it never changes the type of the inputs (e.g. it never converts strings to factors!), it never changes the names of variables, and it never creates row names.

It’s possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names. 
For example, they might not start with a letter, or they might contain unusual characters like a space. 
To refer to these variables, you need to surround them with backticks, <code>`</code>:

<code>tb &lt;- tibble(</a>
  `:)` = "smile", </a>
  ` ` = "space",</a>
  `2000` = "number"</a>
)</a>
tb</a>
#> # A tibble: 1 x 3</a>
#>   `:)`  ` `   `2000`</a>
#>   &lt;chr> &lt;chr> &lt;chr> </a>
#> 1 smile space number</code>

You’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.

Another way to create a tibble is with <code>tribble()</code>, short for transposed tibble. 
<code>tribble()</code> is customised for data entry in code: column headings are defined by formulas (i.e. they start with <code>~</code>), and entries are separated by commas. 
This makes it possible to lay out small amounts of data in easy to read form.

<code>tribble(</a>
  ~x, ~y, ~z,</a>
  #--|--|----</a>
  "a", 2, 3.6,</a>
  "b", 1, 8.5</a>
)</a>
#> # A tibble: 2 x 3</a>
#>   x         y     z</a>
#>   &lt;chr> &lt;dbl> &lt;dbl></a>
#> 1 a         2   3.6</a>
#> 2 b         1   8.5</code>

I often add a comment (the line starting with <code>#</code>), to make it really clear where the header is.

<h2>10.3 Tibbles vs. data.frame</h2>
There are two main differences in the usage of a tibble vs. a classic <code>data.frame</code>: printing and subsetting.

<h3>10.3.1 Printing</h3>
Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. 
This makes it much easier to work with large data. 
In addition to its name, each column reports its type, a nice feature borrowed from <code>str()</code>:

<code>tibble(</a>
  a = lubridate::now() + runif(1e3) * 86400,</a>
  b = lubridate::today() + runif(1e3) * 30,</a>
  c = 1:1e3,</a>
  d = runif(1e3),</a>
  e = sample(letters, 1e3, replace = TRUE)</a>
)</a>
#> # A tibble: 1,000 x 5</a>
#>   a                   b              c     d e    </a>
#>   &lt;dttm>              &lt;date>     &lt;int> &lt;dbl> &lt;chr></a>
#> 1 2020-05-08 23:14:55 2020-05-15     1 0.368 n    </a>
#> 2 2020-05-09 17:20:05 2020-05-20     2 0.612 l    </a>
#> 3 2020-05-09 11:43:44 2020-05-30     3 0.415 p    </a>
#> 4 2020-05-09 01:05:01 2020-05-29     4 0.212 m    </a>
#> 5 2020-05-08 21:29:18 2020-05-26     5 0.733 i    </a>
#> 6 2020-05-09 08:30:15 2020-05-22     6 0.460 n    </a>
#> # … with 994 more rows</code>

Tibbles are designed so that you don’t accidentally overwhelm your console when you print large data frames. 
But sometimes you need more output than the default display. 
There are a few options that can help.

First, you can explicitly <code>print()</code> the data frame and control the number of rows (<code>n</code>) and the <code>width</code> of the display. 
<code>width = Inf</code> will display all columns:

<code>nycflights13::flights %>% </a>
  print(n = 10, width = Inf)</code>

You can also control the default print behaviour by setting options:

<code>options(tibble.print_max = n, tibble.print_min = m)</code>: if more than <code>n</code>
rows, print only <code>m</code> rows. 
Use <code>options(tibble.print_min = Inf)</code> to always
show all rows.

Use <code>options(tibble.width = Inf)</code> to always print all columns, regardless
of the width of the screen.

You can see a complete list of options by looking at the package help with <code>package?tibble</code>.

A final option is to use RStudio’s built-in data viewer to get a scrollable view of the complete dataset. 
This is also often useful at the end of a long chain of manipulations.

<code>nycflights13::flights %>% </a>
  View()</code>

<h3>10.3.2 Subsetting</h3>
So far all the tools you’ve learned have worked with complete data frames. 
If you want to pull out a single variable, you need some new tools, <code>$</code> and <code>[[</code>. 
<code>[[</code> can extract by name or position; <code>$</code> only extracts by name but is a little less typing.

<code>df &lt;- tibble(</a>
  x = runif(5),</a>
  y = rnorm(5)</a>
)</a>
</a>
# Extract by name</a>
df$x</a>
#> [1] 0.7330 0.2344 0.6604 0.0329 0.4605</a>
df[["x"]]</a>
#> [1] 0.7330 0.2344 0.6604 0.0329 0.4605</a>
</a>
# Extract by position</a>
df[[1]]</a>
#> [1] 0.7330 0.2344 0.6604 0.0329 0.4605</code>

To use these in a pipe, you’ll need to use the special placeholder <code>.</code>:

<code>df %>% .$x</a>
#> [1] 0.7330 0.2344 0.6604 0.0329 0.4605</a>
df %>% .[["x"]]</a>
#> [1] 0.7330 0.2344 0.6604 0.0329 0.4605</code>

Compared to a <code>data.frame</code>, tibbles are more strict: they never do partial matching, and they will generate a warning if the column you are trying to access does not exist.

<h2>10.4 Interacting with older code</h2>
Some older functions don’t work with tibbles. 
If you encounter one of these functions, use <code>as.data.frame()</code> to turn a tibble back to a <code>data.frame</code>:

<code>class(as.data.frame(tb))</a>
#> [1] "data.frame"</code>

The main reason that some older functions don’t work with tibble is the <code>[</code> function. 
We don’t use <code>[</code> much in this book because <code>dplyr::filter()</code> and <code>dplyr::select()</code> allow you to solve the same problems with clearer code (but you will learn a little about it in <a href="vectors.html#vector-subsetting">vector subsetting</a>). 
With base R data frames, <code>[</code> sometimes returns a data frame, and sometimes returns a vector. 
With tibbles, <code>[</code> always returns another tibble.

<h2>10.5 Exercises</h2>

How can you tell if an object is a tibble? (Hint: try printing <code>mtcars</code>,
which is a regular data frame).

Compare and contrast the following operations on a <code>data.frame</code> and
equivalent tibble. 
What is different? Why might the default data frame
behaviours cause you frustration?

<code>df &lt;- data.frame(abc = 1, xyz = "a")</a>
df$x</a>
df[, "xyz"]</a>
df[, c("abc", "xyz")]</code>

If you have the name of a variable stored in an object, e.g. 
<code>var &lt;- "mpg"</code>,
how can you extract the reference variable from a tibble?

Practice referring to non-syntactic names in the following data frame by:

Extracting the variable called <code>1</code>.

Plotting a scatterplot of <code>1</code> vs <code>2</code>.

Creating a new column called <code>3</code> which is <code>2</code> divided by <code>1</code>.

Renaming the columns to <code>one</code>, <code>two</code> and <code>three</code>.

<code>annoying &lt;- tibble(</a>
  `1` = 1:10,</a>
  `2` = `1` * 2 + rnorm(length(`1`))</a>
)</code>

What does <code>tibble::enframe()</code> do? When might you use it?

What option controls how many additional column names are printed
at the footer of a tibble?

<h2><span class="orange">11 Data import</span></h2>

<h2>11.1 Introduction</h2>
Working with data provided by R packages is a great way to learn the tools of data science, but at some point you want to stop learning and start working with your own data. 
In this chapter, you’ll learn how to read plain-text rectangular files into R. 
Here, we’ll only scratch the surface of data import, but many of the principles will translate to other forms of data. 
We’ll finish with a few pointers to packages that are useful for other types of data.

<h3>11.1.1 Prerequisites</h3>
In this chapter, you’ll learn how to load flat files in R with the readr package, which is part of the core tidyverse.

<code>library(tidyverse)</code>

<h2>11.2 Getting started</h2>
Most of readr’s functions are concerned with turning flat files into data frames:

<code>read_csv()</code> reads comma delimited files, <code>read_csv2()</code> reads semicolon
separated files (common in countries where <code>,</code> is used as the decimal place),
<code>read_tsv()</code> reads tab delimited files, and <code>read_delim()</code> reads in files
with any delimiter.

<code>read_fwf()</code> reads fixed width files. 
You can specify fields either by their
widths with <code>fwf_widths()</code> or their position with <code>fwf_positions()</code>.
<code>read_table()</code> reads a common variation of fixed width files where columns
are separated by white space.

<code>read_log()</code> reads Apache style log files. 
(But also check out
<a href="https://github.com/Ironholds/webreadr">webreadr</a> which is built on top
of <code>read_log()</code> and provides many more helpful tools.)

These functions all have similar syntax: once you’ve mastered one, you can use the others with ease. 
For the rest of this chapter we’ll focus on <code>read_csv()</code>. 
Not only are csv files one of the most common forms of data storage, but once you understand <code>read_csv()</code>, you can easily apply your knowledge to all the other functions in readr.

The first argument to <code>read_csv()</code> is the most important: it’s the path to the file to read.

<code>heights &lt;- read_csv("data/heights.csv")</a>
#> Parsed with column specification:</a>
#> cols(</a>
#>   earn = col_double(),</a>
#>   height = col_double(),</a>
#>   sex = col_character(),</a>
#>   ed = col_double(),</a>
#>   age = col_double(),</a>
#>   race = col_character()</a>
#> )</code>

When you run <code>read_csv()</code> it prints out a column specification that gives the name and type of each column. 
That’s an important part of readr, which we’ll come back to in <a href="data-import.html#parsing-a-file">parsing a file</a>.

You can also supply an inline csv file. 
This is useful for experimenting with readr and for creating reproducible examples to share with others:

<code>read_csv("a,b,c</a>
1,2,3</a>
4,5,6")</a>
#> # A tibble: 2 x 3</a>
#>       a     b     c</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     1     2     3</a>
#> 2     4     5     6</code>

In both cases <code>read_csv()</code> uses the first line of the data for the column names, which is a very common convention. 
There are two cases where you might want to tweak this behaviour:

Sometimes there are a few lines of metadata at the top of the file. 
You can
use <code>skip = n</code> to skip the first <code>n</code> lines; or use <code>comment = "#"</code> to drop
all lines that start with (e.g.) <code>#</code>.

<code>read_csv("The first line of metadata</a>
  The second line of metadata</a>
  x,y,z</a>
  1,2,3", skip = 2)</a>
#> # A tibble: 1 x 3</a>
#>       x     y     z</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     1     2     3</a>
</a>
read_csv("# A comment I want to skip</a>
  x,y,z</a>
  1,2,3", comment = "#")</a>
#> # A tibble: 1 x 3</a>
#>       x     y     z</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     1     2     3</code>

The data might not have column names. 
You can use <code>col_names = FALSE</code> to
tell <code>read_csv()</code> not to treat the first row as headings, and instead
label them sequentially from <code>X1</code> to <code>Xn</code>:

<code>read_csv("1,2,3\n4,5,6", col_names = FALSE)</a>
#> # A tibble: 2 x 3</a>
#>      X1    X2    X3</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     1     2     3</a>
#> 2     4     5     6</code>

(<code>"\n"</code> is a convenient shortcut for adding a new line. 
You’ll learn more
about it and other types of string escape in <a href="strings.html#string-basics">string basics</a>.)

Alternatively you can pass <code>col_names</code> a character vector which will be
used as the column names:

<code>read_csv("1,2,3\n4,5,6", col_names = c("x", "y", "z"))</a>
#> # A tibble: 2 x 3</a>
#>       x     y     z</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     1     2     3</a>
#> 2     4     5     6</code>

Another option that commonly needs tweaking is <code>na</code>: this specifies the value (or values) that are used to represent missing values in your file:

<code>read_csv("a,b,c\n1,2,.", na = ".")</a>
#> # A tibble: 1 x 3</a>
#>       a     b c    </a>
#>   &lt;dbl> &lt;dbl> &lt;lgl></a>
#> 1     1     2 NA</code>

This is all you need to know to read ~75% of CSV files that you’ll encounter in practice. 
You can also easily adapt what you’ve learned to read tab separated files with <code>read_tsv()</code> and fixed width files with <code>read_fwf()</code>. 
To read in more challenging files, you’ll need to learn more about how readr parses each column, turning them into R vectors.

<h3>11.2.1 Compared to base R</h3>
If you’ve used R before, you might wonder why we’re not using <code>read.csv()</code>. 
There are a few good reasons to favour readr functions over the base equivalents:

They are typically much faster (~10x) than their base equivalents.
Long running jobs have a progress bar, so you can see what’s happening.
If you’re looking for raw speed, try <code>data.table::fread()</code>. 
It doesn’t fit
quite so well into the tidyverse, but it can be quite a bit faster.

They produce tibbles, they don’t convert character vectors to factors,
use row names, or munge the column names. 
These are common sources of
frustration with the base R functions.

They are more reproducible. 
Base R functions inherit some behaviour from
your operating system and environment variables, so import code that works
on your computer might not work on someone else’s.

<h3>11.2.2 Exercises</h3>

What function would you use to read a file where fields were separated with<br />
'|'?

Apart from <code>file</code>, <code>skip</code>, and <code>comment</code>, what other arguments do
<code>read_csv()</code> and <code>read_tsv()</code> have in common?

What are the most important arguments to <code>read_fwf()</code>?

Sometimes strings in a CSV file contain commas. 
To prevent them from
causing problems they need to be surrounded by a quoting character, like
<code>"</code> or <code>'</code>. 
By default, <code>read_csv()</code> assumes that the quoting
character will be <code>"</code>. 
What argument to <code>read_csv()</code> do you need to specify
to read the following text into a data frame?

<code>"x,y\n1,&#39;a,b&#39;"</code>

Identify what is wrong with each of the following inline CSV files.
What happens when you run the code?

<code>read_csv("a,b\n1,2,3\n4,5,6")</a>
read_csv("a,b,c\n1,2\n1,2,3,4")</a>
read_csv("a,b\n\"1")</a>
read_csv("a,b\n1,2\na,b")</a>
read_csv("a;b\n1;3")</code>

<h2>11.3 Parsing a vector</h2>
Before we get into the details of how readr reads files from disk, we need to take a little detour to talk about the <code>parse_*()</code> functions. 
These functions take a character vector and return a more specialised vector like a logical, integer, or date:

<code>str(parse_logical(c("TRUE", "FALSE", "NA")))</a>
#>  logi [1:3] TRUE FALSE NA</a>
str(parse_integer(c("1", "2", "3")))</a>
#>  int [1:3] 1 2 3</a>
str(parse_date(c("2010-01-01", "1979-10-14")))</a>
#>  Date[1:2], format: "2010-01-01" "1979-10-14"</code>

These functions are useful in their own right, but are also an important building block for readr. 
Once you’ve learned how the individual parsers work in this section, we’ll circle back and see how they fit together to parse a complete file in the next section.

Like all functions in the tidyverse, the <code>parse_*()</code> functions are uniform: the first argument is a character vector to parse, and the <code>na</code> argument specifies which strings should be treated as missing:

<code>parse_integer(c("1", "231", ".", "456"), na = ".")</a>
#> [1]   1 231  NA 456</code>

If parsing fails, you’ll get a warning:

<code>x &lt;- parse_integer(c("123", "345", "abc", "123.45"))</a>
#> Warning: 2 parsing failures.</a>
#> row col               expected actual</a>
#>   3  -- an integer                abc</a>
#>   4  -- no trailing characters    .45</code>

And the failures will be missing in the output:

<code>x</a>
#> [1] 123 345  NA  NA</a>
#> attr(,"problems")</a>
#> # A tibble: 2 x 4</a>
#>     row   col expected               actual</a>
#>   &lt;int> &lt;int> &lt;chr>                  &lt;chr> </a>
#> 1     3    NA an integer             abc   </a>
#> 2     4    NA no trailing characters .45</code>

If there are many parsing failures, you’ll need to use <code>problems()</code> to get the complete set. 
This returns a tibble, which you can then manipulate with dplyr.

<code>problems(x)</a>
#> # A tibble: 2 x 4</a>
#>     row   col expected               actual</a>
#>   &lt;int> &lt;int> &lt;chr>                  &lt;chr> </a>
#> 1     3    NA an integer             abc   </a>
#> 2     4    NA no trailing characters .45</code>

Using parsers is mostly a matter of understanding what’s available and how they deal with different types of input. 
There are eight particularly important parsers:

<code>parse_logical()</code> and <code>parse_integer()</code> parse logicals and integers
respectively. 
There’s basically nothing that can go wrong with these
parsers so I won’t describe them here further.

<code>parse_double()</code> is a strict numeric parser, and <code>parse_number()</code>
is a flexible numeric parser. 
These are more complicated than you might
expect because different parts of the world write numbers in different
ways.

<code>parse_character()</code> seems so simple that it shouldn’t be necessary. 
But
one complication makes it quite important: character encodings.

<code>parse_factor()</code> create factors, the data structure that R uses to represent
categorical variables with fixed and known values.

<code>parse_datetime()</code>, <code>parse_date()</code>, and <code>parse_time()</code> allow you to
parse various date &amp; time specifications. 
These are the most complicated
because there are so many different ways of writing dates.

The following sections describe these parsers in more detail.

<h3>11.3.1 Numbers</h3>
It seems like it should be straightforward to parse a number, but three problems make it tricky:

People write numbers differently in different parts of the world.
For example, some countries use <code>.</code> in between the integer and fractional
parts of a real number, while others use <code>,</code>.

Numbers are often surrounded by other characters that provide some
context, like '$1000' or '10%'.

Numbers often contain 'grouping' characters to make them easier to read,
like '1,000,000', and these grouping characters vary around the world.

To address the first problem, readr has the notion of a 'locale', an object that specifies parsing options that differ from place to place. 
When parsing numbers, the most important option is the character you use for the decimal mark. 
You can override the default value of <code>.</code> by creating a new locale and setting the <code>decimal_mark</code> argument:

<code>parse_double("1.23")</a>
#> [1] 1.23</a>
parse_double("1,23", locale = locale(decimal_mark = ","))</a>
#> [1] 1.23</code>

readr’s default locale is US-centric, because generally R is US-centric (i.e. the documentation of base R is written in American English). 
An alternative approach would be to try and guess the defaults from your operating system. 
This is hard to do well, and, more importantly, makes your code fragile: even if it works on your computer, it might fail when you email it to a colleague in another country.

<code>parse_number()</code> addresses the second problem: it ignores non-numeric characters before and after the number. 
This is particularly useful for currencies and percentages, but also works to extract numbers embedded in text.

<code>parse_number("$100")</a>
#> [1] 100</a>
parse_number("20%")</a>
#> [1] 20</a>
parse_number("It cost $123.45")</a>
#> [1] 123</code>

The final problem is addressed by the combination of <code>parse_number()</code> and the locale as <code>parse_number()</code> will ignore the 'grouping mark':

<code># Used in America</a>
parse_number("$123,456,789")</a>
#> [1] 1.23e+08</a>
</a>
# Used in many parts of Europe</a>
parse_number("123.456.789", locale = locale(grouping_mark = "."))</a>
#> [1] 1.23e+08</a>
</a>
# Used in Switzerland</a>
parse_number("123&#39;456&#39;789", locale = locale(grouping_mark = "&#39;"))</a>
#> [1] 1.23e+08</code>

<h3>11.3.2 Strings</h3>
It seems like <code>parse_character()</code> should be really simple — it could just return its input. 
Unfortunately life isn’t so simple, as there are multiple ways to represent the same string. 
To understand what’s going on, we need to dive into the details of how computers represent strings. 
In R, we can get at the underlying representation of a string using <code>charToRaw()</code>:

<code>charToRaw("Hadley")</a>
#> [1] 48 61 64 6c 65 79</code>

Each hexadecimal number represents a byte of information: <code>48</code> is H, <code>61</code> is a, and so on. 
The mapping from hexadecimal number to character is called the encoding, and in this case the encoding is called ASCII. 
ASCII does a great job of representing English characters, because it’s the American Standard Code for Information Interchange.

Things get more complicated for languages other than English. 
In the early days of computing there were many competing standards for encoding non-English characters, and to correctly interpret a string you needed to know both the values and the encoding. 
For example, two common encodings are Latin1 (aka ISO-8859-1, used for Western European languages) and Latin2 (aka ISO-8859-2, used for Eastern European languages). 
In Latin1, the byte <code>b1</code> is '±', but in Latin2, it’s 'ą'! Fortunately, today there is one standard that is supported almost everywhere: UTF-8. 
UTF-8 can encode just about every character used by humans today, as well as many extra symbols (like emoji!).

readr uses UTF-8 everywhere: it assumes your data is UTF-8 encoded when you read it, and always uses it when writing. 
This is a good default, but will fail for data produced by older systems that don’t understand UTF-8. 
If this happens to you, your strings will look weird when you print them. 
Sometimes just one or two characters might be messed up; other times you’ll get complete gibberish. 
For example:

<code>x1 &lt;- "El Ni\xf1o was particularly bad this year"</a>
x2 &lt;- "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"</a>
</a>
x1</a>
#> [1] "El Ni\xf1o was particularly bad this year"</a>
x2</a>
#> [1] "\x82\xb1\x82\xf1\x82ɂ\xbf\x82\xcd"</code>

To fix the problem you need to specify the encoding in <code>parse_character()</code>:

<code>parse_character(x1, locale = locale(encoding = "Latin1"))</a>
#> [1] "El Niño was particularly bad this year"</a>
parse_character(x2, locale = locale(encoding = "Shift-JIS"))</a>
#> [1] "こんにちは"</code>

How do you find the correct encoding? If you’re lucky, it’ll be included somewhere in the data documentation. 
Unfortunately, that’s rarely the case, so readr provides <code>guess_encoding()</code> to help you figure it out. 
It’s not foolproof, and it works better when you have lots of text (unlike here), but it’s a reasonable place to start. 
Expect to try a few different encodings before you find the right one.

<code>guess_encoding(charToRaw(x1))</a>
#> # A tibble: 2 x 2</a>
#>   encoding   confidence</a>
#>   &lt;chr>           &lt;dbl></a>
#> 1 ISO-8859-1       0.46</a>
#> 2 ISO-8859-9       0.23</a>
guess_encoding(charToRaw(x2))</a>
#> # A tibble: 1 x 2</a>
#>   encoding confidence</a>
#>   &lt;chr>         &lt;dbl></a>
#> 1 KOI8-R         0.42</code>

The first argument to <code>guess_encoding()</code> can either be a path to a file, or, as in this case, a raw vector (useful if the strings are already in R).

Encodings are a rich and complex topic, and I’ve only scratched the surface here. 
If you’d like to learn more I’d recommend reading the detailed explanation at <a href="http://kunststube.net/encoding/" class="uri">http://kunststube.net/encoding/</a>.

<h3>11.3.3 Factors</h3>
R uses factors to represent categorical variables that have a known set of possible values. 
Give <code>parse_factor()</code> a vector of known <code>levels</code> to generate a warning whenever an unexpected value is present:

<code>fruit &lt;- c("apple", "banana")</a>
parse_factor(c("apple", "banana", "bananana"), levels = fruit)</a>
#> Warning: 1 parsing failure.</a>
#> row col           expected   actual</a>
#>   3  -- value in level set bananana</a>
#> [1] apple  banana &lt;NA>  </a>
#> attr(,"problems")</a>
#> # A tibble: 1 x 4</a>
#>     row   col expected           actual  </a>
#>   &lt;int> &lt;int> &lt;chr>              &lt;chr>   </a>
#> 1     3    NA value in level set bananana</a>
#> Levels: apple banana</code>

But if you have many problematic entries, it’s often easier to leave as character vectors and then use the tools you’ll learn about in <a href="strings.html#strings">strings</a> and <a href="vectors.html#factors-1">factors</a> to clean them up.

<h3>11.3.4 Dates, date-times, and times</h3>
You pick between three parsers depending on whether you want a date (the number of days since 1970-01-01), a date-time (the number of seconds since midnight 1970-01-01), or a time (the number of seconds since midnight). 
When called without any additional arguments:

<code>parse_datetime()</code> expects an ISO8601 date-time. 
ISO8601 is an
international standard in which the components of a date are
organised from biggest to smallest: year, month, day, hour, minute,
second.

<code>parse_datetime("2010-10-01T2010")</a>
#> [1] "2010-10-01 20:10:00 UTC"</a>
# If time is omitted, it will be set to midnight</a>
parse_datetime("20101010")</a>
#> [1] "2010-10-10 UTC"</code>

This is the most important date/time standard, and if you work with
dates and times frequently, I recommend reading
<a href="https://en.wikipedia.org/wiki/ISO_8601" class="uri">https://en.wikipedia.org/wiki/ISO_8601</a>

<code>parse_date()</code> expects a four digit year, a <code>-</code> or <code>/</code>, the month, a <code>-</code>
or <code>/</code>, then the day:

<code>parse_date("2010-10-01")</a>
#> [1] "2010-10-01"</code>

<code>parse_time()</code> expects the hour, <code>:</code>, minutes, optionally <code>:</code> and seconds,
and an optional am/pm specifier:

<code>library(hms)</a>
parse_time("01:10 am")</a>
#> 01:10:00</a>
parse_time("20:10:01")</a>
#> 20:10:01</code>

Base R doesn’t have a great built in class for time data, so we use
the one provided in the hms package.

If these defaults don’t work for your data you can supply your own date-time <code>format</code>, built up of the following pieces:

<dl>
<dt>Year</dt>
<dd><code>%Y</code> (4 digits).
</dd>
<dd><code>%y</code> (2 digits); 00-69 -> 2000-2069, 70-99 -> 1970-1999.
</dd>
<dt>Month</dt>
<dd><code>%m</code> (2 digits).
</dd>
<dd><code>%b</code> (abbreviated name, like 'Jan').
</dd>
<dd><code>%B</code> (full name, 'January').
</dd>
<dt>Day</dt>
<dd><code>%d</code> (2 digits).
</dd>
<dd><code>%e</code> (optional leading space).
</dd>
<dt>Time</dt>
<dd><code>%H</code> 0-23 hour.
</dd>
<dd><code>%I</code> 0-12, must be used with <code>%p</code>.
</dd>
<dd><code>%p</code> AM/PM indicator.
</dd>
<dd><code>%M</code> minutes.
</dd>
<dd><code>%S</code> integer seconds.
</dd>
<dd><code>%OS</code> real seconds.
</dd>
<dd><code>%Z</code> Time zone (as name, e.g. 
<code>America/Chicago</code>). 
Beware of abbreviations:
if you’re American, note that 'EST' is a Canadian time zone that does not
have daylight savings time. 
It is <em>not</em> Eastern Standard Time! We’ll
come back to this <a href="dates-and-times.html#time-zones">time zones</a>.
</dd>
<dd><code>%z</code> (as offset from UTC, e.g. 
<code>+0800</code>).
</dd>
<dt>Non-digits</dt>
<dd><code>%.</code> skips one non-digit character.
</dd>
<dd><code>%*</code> skips any number of non-digits.
</dd>
</dl>
The best way to figure out the correct format is to create a few examples in a character vector, and test with one of the parsing functions. 
For example:

<code>parse_date("01/02/15", "%m/%d/%y")</a>
#> [1] "2015-01-02"</a>
parse_date("01/02/15", "%d/%m/%y")</a>
#> [1] "2015-02-01"</a>
parse_date("01/02/15", "%y/%m/%d")</a>
#> [1] "2001-02-15"</code>

If you’re using <code>%b</code> or <code>%B</code> with non-English month names, you’ll need to set the <code>lang</code> argument to <code>locale()</code>. 
See the list of built-in languages in <code>date_names_langs()</code>, or if your language is not already included, create your own with <code>date_names()</code>.

<code>parse_date("1 janvier 2015", "%d %B %Y", locale = locale("fr"))</a>
#> [1] "2015-01-01"</code>

<h3>11.3.5 Exercises</h3>

What are the most important arguments to <code>locale()</code>?

What happens if you try and set <code>decimal_mark</code> and <code>grouping_mark</code>
to the same character? What happens to the default value of
<code>grouping_mark</code> when you set <code>decimal_mark</code> to ','? What happens
to the default value of <code>decimal_mark</code> when you set the <code>grouping_mark</code>
to '.'?

I didn’t discuss the <code>date_format</code> and <code>time_format</code> options to
<code>locale()</code>. 
What do they do? Construct an example that shows when
they might be useful.

If you live outside the US, create a new locale object that encapsulates
the settings for the types of file you read most commonly.

What’s the difference between <code>read_csv()</code> and <code>read_csv2()</code>?

What are the most common encodings used in Europe? What are the
most common encodings used in Asia? Do some googling to find out.

Generate the correct format string to parse each of the following
dates and times:

<code>d1 &lt;- "January 1, 2010"</a>
d2 &lt;- "2015-Mar-07"</a>
d3 &lt;- "06-Jun-2017"</a>
d4 &lt;- c("August 19 (2015)", "July 1 (2015)")</a>
d5 &lt;- "12/30/14" # Dec 30, 2014</a>
t1 &lt;- "1705"</a>
t2 &lt;- "11:15:10.12 PM"</code>

<h2>11.4 Parsing a file</h2>
Now that you’ve learned how to parse an individual vector, it’s time to return to the beginning and explore how readr parses a file. 
There are two new things that you’ll learn about in this section:

How readr automatically guesses the type of each column.

How to override the default specification.

<h3>11.4.1 Strategy</h3>
readr uses a heuristic to figure out the type of each column: it reads the first 1000 rows and uses some (moderately conservative) heuristics to figure out the type of each column. 
You can emulate this process with a character vector using <code>guess_parser()</code>, which returns readr’s best guess, and <code>parse_guess()</code> which uses that guess to parse the column:

<code>guess_parser("2010-10-01")</a>
#> [1] "date"</a>
guess_parser("15:01")</a>
#> [1] "time"</a>
guess_parser(c("TRUE", "FALSE"))</a>
#> [1] "logical"</a>
guess_parser(c("1", "5", "9"))</a>
#> [1] "double"</a>
guess_parser(c("12,352,561"))</a>
#> [1] "number"</a>
</a>
str(parse_guess("2010-10-10"))</a>
#>  Date[1:1], format: "2010-10-10"</code>

The heuristic tries each of the following types, stopping when it finds a match:

logical: contains only 'F', 'T', 'FALSE', or 'TRUE'.

integer: contains only numeric characters (and <code>-</code>).

double: contains only valid doubles (including numbers like <code>4.5e-5</code>).

number: contains valid doubles with the grouping mark inside.

time: matches the default <code>time_format</code>.

date: matches the default <code>date_format</code>.

date-time: any ISO8601 date.

If none of these rules apply, then the column will stay as a vector of strings.

<h3>11.4.2 Problems</h3>
These defaults don’t always work for larger files. 
There are two basic problems:

The first thousand rows might be a special case, and readr guesses
a type that is not sufficiently general. 
For example, you might have
a column of doubles that only contains integers in the first 1000 rows.

The column might contain a lot of missing values. 
If the first 1000
rows contain only <code>NA</code>s, readr will guess that it’s a logical
vector, whereas you probably want to parse it as something more
specific.

readr contains a challenging CSV that illustrates both of these problems:

<code>challenge &lt;- read_csv(readr_example("challenge.csv"))</a>
#> Parsed with column specification:</a>
#> cols(</a>
#>   x = col_double(),</a>
#>   y = col_logical()</a>
#> )</a>
#> Warning: 1000 parsing failures.</a>
#>  row col           expected     actual                                                 file</a>
#> 1001   y 1/0/T/F/TRUE/FALSE 2015-01-16 &#39;/home/travis/R/Library/readr/extdata/challenge.csv&#39;</a>
#> 1002   y 1/0/T/F/TRUE/FALSE 2018-05-18 &#39;/home/travis/R/Library/readr/extdata/challenge.csv&#39;</a>
#> 1003   y 1/0/T/F/TRUE/FALSE 2015-09-05 &#39;/home/travis/R/Library/readr/extdata/challenge.csv&#39;</a>
#> 1004   y 1/0/T/F/TRUE/FALSE 2012-11-28 &#39;/home/travis/R/Library/readr/extdata/challenge.csv&#39;</a>
#> 1005   y 1/0/T/F/TRUE/FALSE 2020-01-13 &#39;/home/travis/R/Library/readr/extdata/challenge.csv&#39;</a>
#> .... 
... 
.................. 
.......... 
....................................................</a>
#> See problems(...) for more details.</code>

(Note the use of <code>readr_example()</code> which finds the path to one of the files included with the package)

There are two printed outputs: the column specification generated by looking at the first 1000 rows, and the first five parsing failures. 
It’s always a good idea to explicitly pull out the <code>problems()</code>, so you can explore them in more depth:

<code>problems(challenge)</a>
#> # A tibble: 1,000 x 5</a>
#>     row col   expected         actual    file                                   </a>
#>   &lt;int> &lt;chr> &lt;chr>            &lt;chr>     &lt;chr>                                  </a>
#> 1  1001 y     1/0/T/F/TRUE/FA… 2015-01-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> 2  1002 y     1/0/T/F/TRUE/FA… 2018-05-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> 3  1003 y     1/0/T/F/TRUE/FA… 2015-09-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> 4  1004 y     1/0/T/F/TRUE/FA… 2012-11-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> 5  1005 y     1/0/T/F/TRUE/FA… 2020-01-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> 6  1006 y     1/0/T/F/TRUE/FA… 2016-04-… &#39;/home/travis/R/Library/readr/extdata/…</a>
#> # … with 994 more rows</code>

A good strategy is to work column by column until there are no problems remaining. 
Here we can see that there are a lot of parsing problems with the <code>y</code> column. 
If we look at the last few rows, you’ll see that they’re dates stored in a character vector:

<code>tail(challenge)</a>
#> # A tibble: 6 x 2</a>
#>       x y    </a>
#>   &lt;dbl> &lt;lgl></a>
#> 1 0.805 NA   </a>
#> 2 0.164 NA   </a>
#> 3 0.472 NA   </a>
#> 4 0.718 NA   </a>
#> 5 0.270 NA   </a>
#> 6 0.608 NA</code>

That suggests we need to use a date parser instead. 
To fix the call, start by copying and pasting the column specification into your original call:

<code>challenge &lt;- read_csv(</a>
  readr_example("challenge.csv"), </a>
  col_types = cols(</a>
    x = col_double(),</a>
    y = col_logical()</a>
  )</a>
)</code>

Then you can fix the type of the <code>y</code> column by specifying that <code>y</code> is a date column:

<code>challenge &lt;- read_csv(</a>
  readr_example("challenge.csv"), </a>
  col_types = cols(</a>
    x = col_double(),</a>
    y = col_date()</a>
  )</a>
)</a>
tail(challenge)</a>
#> # A tibble: 6 x 2</a>
#>       x y         </a>
#>   &lt;dbl> &lt;date>    </a>
#> 1 0.805 2019-11-21</a>
#> 2 0.164 2018-03-29</a>
#> 3 0.472 2014-08-04</a>
#> 4 0.718 2015-08-16</a>
#> 5 0.270 2020-02-04</a>
#> 6 0.608 2019-01-06</code>

Every <code>parse_xyz()</code> function has a corresponding <code>col_xyz()</code> function. 
You use <code>parse_xyz()</code> when the data is in a character vector in R already; you use <code>col_xyz()</code> when you want to tell readr how to load the data.

I highly recommend always supplying <code>col_types</code>, building up from the print-out provided by readr. 
This ensures that you have a consistent and reproducible data import script. 
If you rely on the default guesses and your data changes, readr will continue to read it in. 
If you want to be really strict, use <code>stop_for_problems()</code>: that will throw an error and stop your script if there are any parsing problems.

<h3>11.4.3 Other strategies</h3>
There are a few other general strategies to help you parse files:

In the previous example, we just got unlucky: if we look at just
one more row than the default, we can correctly parse in one shot:

<code>challenge2 &lt;- read_csv(readr_example("challenge.csv"), guess_max = 1001)</a>
#> Parsed with column specification:</a>
#> cols(</a>
#>   x = col_double(),</a>
#>   y = col_date(format = ")</a>
#> )</a>
challenge2</a>
#> # A tibble: 2,000 x 2</a>
#>       x y         </a>
#>   &lt;dbl> &lt;date>    </a>
#> 1   404 NA        </a>
#> 2  4172 NA        </a>
#> 3  3004 NA        </a>
#> 4   787 NA        </a>
#> 5    37 NA        </a>
#> 6  2332 NA        </a>
#> # … with 1,994 more rows</code>

Sometimes it’s easier to diagnose problems if you just read in all
the columns as character vectors:

<code>challenge2 &lt;- read_csv(readr_example("challenge.csv"), </a>
  col_types = cols(.default = col_character())</a>
)</code>

This is particularly useful in conjunction with <code>type_convert()</code>,
which applies the parsing heuristics to the character columns in a data
frame.

<code>df &lt;- tribble(</a>
  ~x,  ~y,</a>
  "1", "1.21",</a>
  "2", "2.32",</a>
  "3", "4.56"</a>
)</a>
df</a>
#> # A tibble: 3 x 2</a>
#>   x     y    </a>
#>   &lt;chr> &lt;chr></a>
#> 1 1     1.21 </a>
#> 2 2     2.32 </a>
#> 3 3     4.56</a>
</a>
# Note the column types</a>
type_convert(df)</a>
#> Parsed with column specification:</a>
#> cols(</a>
#>   x = col_double(),</a>
#>   y = col_double()</a>
#> )</a>
#> # A tibble: 3 x 2</a>
#>       x     y</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     1  1.21</a>
#> 2     2  2.32</a>
#> 3     3  4.56</code>

If you’re reading a very large file, you might want to set <code>n_max</code> to
a smallish number like 10,000 or 100,000. 
That will accelerate your
iterations while you eliminate common problems.

If you’re having major parsing problems, sometimes it’s easier
to just read into a character vector of lines with <code>read_lines()</code>,
or even a character vector of length 1 with <code>read_file()</code>. 
Then you
can use the string parsing skills you’ll learn later to parse
more exotic formats.

<h2>11.5 Writing to a file</h2>
readr also comes with two useful functions for writing data back to disk: <code>write_csv()</code> and <code>write_tsv()</code>. 
Both functions increase the chances of the output file being read back in correctly by:

Always encoding strings in UTF-8.

Saving dates and date-times in ISO8601 format so they are easily
parsed elsewhere.

If you want to export a csv file to Excel, use <code>write_excel_csv()</code> — this writes a special character (a 'byte order mark') at the start of the file which tells Excel that you’re using the UTF-8 encoding.

The most important arguments are <code>x</code> (the data frame to save), and <code>path</code> (the location to save it). 
You can also specify how missing values are written with <code>na</code>, and if you want to <code>append</code> to an existing file.

<code>write_csv(challenge, "challenge.csv")</code>

Note that the type information is lost when you save to csv:

<code>challenge</a>
#> # A tibble: 2,000 x 2</a>
#>       x y         </a>
#>   &lt;dbl> &lt;date>    </a>
#> 1   404 NA        </a>
#> 2  4172 NA        </a>
#> 3  3004 NA        </a>
#> 4   787 NA        </a>
#> 5    37 NA        </a>
#> 6  2332 NA        </a>
#> # … with 1,994 more rows</a>
write_csv(challenge, "challenge-2.csv")</a>
read_csv("challenge-2.csv")</a>
#> Parsed with column specification:</a>
#> cols(</a>
#>   x = col_double(),</a>
#>   y = col_logical()</a>
#> )</a>
#> # A tibble: 2,000 x 2</a>
#>       x y    </a>
#>   &lt;dbl> &lt;lgl></a>
#> 1   404 NA   </a>
#> 2  4172 NA   </a>
#> 3  3004 NA   </a>
#> 4   787 NA   </a>
#> 5    37 NA   </a>
#> 6  2332 NA   </a>
#> # … with 1,994 more rows</code>

This makes CSVs a little unreliable for caching interim results—you need to recreate the column specification every time you load in. 
There are two alternatives:

<code>write_rds()</code> and <code>read_rds()</code> are uniform wrappers around the base
functions <code>readRDS()</code> and <code>saveRDS()</code>. 
These store data in R’s custom
binary format called RDS:

<code>write_rds(challenge, "challenge.rds")</a>
read_rds("challenge.rds")</a>
#> # A tibble: 2,000 x 2</a>
#>       x y         </a>
#>   &lt;dbl> &lt;date>    </a>
#> 1   404 NA        </a>
#> 2  4172 NA        </a>
#> 3  3004 NA        </a>
#> 4   787 NA        </a>
#> 5    37 NA        </a>
#> 6  2332 NA        </a>
#> # … with 1,994 more rows</code>

The feather package implements a fast binary file format that can
be shared across programming languages:

<code>library(feather)</a>
write_feather(challenge, "challenge.feather")</a>
read_feather("challenge.feather")</a>
#> # A tibble: 2,000 x 2</a>
#>       x      y</a>
#>   &lt;dbl> &lt;date></a>
#> 1   404   &lt;NA></a>
#> 2  4172   &lt;NA></a>
#> 3  3004   &lt;NA></a>
#> 4   787   &lt;NA></a>
#> 5    37   &lt;NA></a>
#> 6  2332   &lt;NA></a>
#> # ... 
with 1,994 more rows</code>

Feather tends to be faster than RDS and is usable outside of R. 
RDS supports list-columns (which you’ll learn about in <a href="many-models.html#many-models">many models</a>); feather currently does not.

<h2>11.6 Other types of data</h2>
To get other types of data into R, we recommend starting with the tidyverse packages listed below. 
They’re certainly not perfect, but they are a good place to start. 
For rectangular data:

haven reads SPSS, Stata, and SAS files.

readxl reads excel files (both <code>.xls</code> and <code>.xlsx</code>).

DBI, along with a database specific backend (e.g. 
RMySQL,
RSQLite, RPostgreSQL etc) allows you to run SQL queries against a
database and return a data frame.

For hierarchical data: use jsonlite (by Jeroen Ooms) for json, and xml2 for XML. 
Jenny Bryan has some excellent worked examples at <a href="https://jennybc.github.io/purrr-tutorial/" class="uri">https://jennybc.github.io/purrr-tutorial/</a>.

For other file types, try the <a href="https://cran.r-project.org/doc/manuals/r-release/R-data.html">R data import/export manual</a> and the <a href="https://github.com/leeper/rio">rio</a> package.

<h2><span class="orange">12 Tidy data</span></h2>

<h2>12.1 Introduction</h2>
<blockquote>
'Happy families are all alike; every unhappy family is unhappy in its
own way.' –– Leo Tolstoy

</blockquote>
<blockquote>
'Tidy datasets are all alike, but every messy dataset is messy in its
own way.' –– Hadley Wickham

</blockquote>
In this chapter, you will learn a consistent way to organise your data in R, an organisation called tidy data. 
Getting your data into this format requires some upfront work, but that work pays off in the long term. 
Once you have tidy data and the tidy tools provided by packages in the tidyverse, you will spend much less time munging data from one representation to another, allowing you to spend more time on the analytic questions at hand.

This chapter will give you a practical introduction to tidy data and the accompanying tools in the tidyr package. 
If you’d like to learn more about the underlying theory, you might enjoy the <em>Tidy Data</em> paper published in the Journal of Statistical Software, <a href="http://www.jstatsoft.org/v59/i10/paper" class="uri">http://www.jstatsoft.org/v59/i10/paper</a>.

<h3>12.1.1 Prerequisites</h3>
In this chapter we’ll focus on tidyr, a package that provides a bunch of tools to help tidy up your messy datasets. 
tidyr is a member of the core tidyverse.

<code>library(tidyverse)</code>

<h2>12.2 Tidy data</h2>
You can represent the same underlying data in multiple ways. 
The example below shows the same data organised in four different ways. 
Each dataset shows the same values of four variables <em>country</em>, <em>year</em>, <em>population</em>, and <em>cases</em>, but each dataset organises the values in a different way.

<code>table1</a>
#> # A tibble: 6 x 4</a>
#>   country      year  cases population</a>
#>   &lt;chr>       &lt;int>  &lt;int>      &lt;int></a>
#> 1 Afghanistan  1999    745   19987071</a>
#> 2 Afghanistan  2000   2666   20595360</a>
#> 3 Brazil       1999  37737  172006362</a>
#> 4 Brazil       2000  80488  174504898</a>
#> 5 China        1999 212258 1272915272</a>
#> 6 China        2000 213766 1280428583</a>
table2</a>
#> # A tibble: 12 x 4</a>
#>   country      year type           count</a>
#>   &lt;chr>       &lt;int> &lt;chr>          &lt;int></a>
#> 1 Afghanistan  1999 cases            745</a>
#> 2 Afghanistan  1999 population  19987071</a>
#> 3 Afghanistan  2000 cases           2666</a>
#> 4 Afghanistan  2000 population  20595360</a>
#> 5 Brazil       1999 cases          37737</a>
#> 6 Brazil       1999 population 172006362</a>
#> # … with 6 more rows</a>
table3</a>
#> # A tibble: 6 x 3</a>
#>   country      year rate             </a>
#> * &lt;chr>       &lt;int> &lt;chr>            </a>
#> 1 Afghanistan  1999 745/19987071     </a>
#> 2 Afghanistan  2000 2666/20595360    </a>
#> 3 Brazil       1999 37737/172006362  </a>
#> 4 Brazil       2000 80488/174504898  </a>
#> 5 China        1999 212258/1272915272</a>
#> 6 China        2000 213766/1280428583</a>
</a>
# Spread across two tibbles</a>
table4a  # cases</a>
#> # A tibble: 3 x 3</a>
#>   country     `1999` `2000`</a>
#> * &lt;chr>        &lt;int>  &lt;int></a>
#> 1 Afghanistan    745   2666</a>
#> 2 Brazil       37737  80488</a>
#> 3 China       212258 213766</a>
table4b  # population</a>
#> # A tibble: 3 x 3</a>
#>   country         `1999`     `2000`</a>
#> * &lt;chr>            &lt;int>      &lt;int></a>
#> 1 Afghanistan   19987071   20595360</a>
#> 2 Brazil       172006362  174504898</a>
#> 3 China       1272915272 1280428583</code>

These are all representations of the same underlying data, but they are not equally easy to use. 
One dataset, the tidy dataset, will be much easier to work with inside the tidyverse.

There are three interrelated rules which make a dataset tidy:

Each variable must have its own column.

Each observation must have its own row.

Each value must have its own cell.

Figure <a href="tidy-data.html#fig:tidy-structure">12.1</a> shows the rules visually.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png" alt="Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells." width="100%" />

Figure 12.1: Following three rules makes a dataset tidy: variables are in columns, observations are in rows, and values are in cells.

These three rules are interrelated because it’s impossible to only satisfy two of the three. 
That interrelationship leads to an even simpler set of practical instructions:

Put each dataset in a tibble.

Put each variable in a column.

In this example, only <code>table1</code> is tidy. 
It’s the only representation where each column is a variable.

Why ensure that your data is tidy? There are two main advantages:

There’s a general advantage to picking one consistent way of storing
data. 
If you have a consistent data structure, it’s easier to learn the
tools that work with it because they have an underlying uniformity.

There’s a specific advantage to placing variables in columns because
it allows R’s vectorised nature to shine. 
As you learned in
<a href="transform.html#mutate-funs">mutate</a> and <a href="#summary-funs">summary functions</a>, most
built-in R functions work with vectors of values. 
That makes transforming
tidy data feel particularly natural.

dplyr, ggplot2, and all the other packages in the tidyverse are designed to work with tidy data. 
Here are a couple of small examples showing how you might work with <code>table1</code>.

<code># Compute rate per 10,000</a>
table1 %>% </a>
  mutate(rate = cases / population * 10000)</a>
#> # A tibble: 6 x 5</a>
#>   country      year  cases population  rate</a>
#>   &lt;chr>       &lt;int>  &lt;int>      &lt;int> &lt;dbl></a>
#> 1 Afghanistan  1999    745   19987071 0.373</a>
#> 2 Afghanistan  2000   2666   20595360 1.29 </a>
#> 3 Brazil       1999  37737  172006362 2.19 </a>
#> 4 Brazil       2000  80488  174504898 4.61 </a>
#> 5 China        1999 212258 1272915272 1.67 </a>
#> 6 China        2000 213766 1280428583 1.67</a>
</a>
# Compute cases per year</a>
table1 %>% </a>
  count(year, wt = cases)</a>
#> # A tibble: 2 x 2</a>
#>    year      n</a>
#>   &lt;int>  &lt;int></a>
#> 1  1999 250740</a>
#> 2  2000 296920</a>
</a>
# Visualise changes over time</a>
library(ggplot2)</a>
ggplot(table1, aes(year, cases)) + </a>
  geom_line(aes(group = country), colour = "grey50") + </a>
  geom_point(aes(colour = country))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4ea3fba7cb3578cea9bb0fe6d1a02678105369bf/fa040/tidy_files/figure-html/unnamed-chunk-2-1.png" width="50%" style="display: block; margin: auto;" />

<h3>12.2.1 Exercises</h3>

Using prose, describe how the variables and observations are organised in
each of the sample tables.

Compute the <code>rate</code> for <code>table2</code>, and <code>table4a</code> + <code>table4b</code>.
You will need to perform four operations:

Extract the number of TB cases per country per year.

Extract the matching population per country per year.

Divide cases by population, and multiply by 10000.

Store back in the appropriate place.

Which representation is easiest to work with? Which is hardest? Why?

Recreate the plot showing change in cases over time using <code>table2</code>
instead of <code>table1</code>. 
What do you need to do first?

<h2>12.3 Pivoting</h2>
The principles of tidy data seem so obvious that you might wonder if you’ll ever encounter a dataset that isn’t tidy. 
Unfortunately, however, most data that you will encounter will be untidy. 
There are two main reasons:

Most people aren’t familiar with the principles of tidy data, and it’s hard
to derive them yourself unless you spend a <em>lot</em> of time working with data.

Data is often organised to facilitate some use other than analysis. 
For
example, data is often organised to make entry as easy as possible.

This means for most real analyses, you’ll need to do some tidying. 
The first step is always to figure out what the variables and observations are. 
Sometimes this is easy; other times you’ll need to consult with the people who originally generated the data.
The second step is to resolve one of two common problems:

One variable might be spread across multiple columns.

One observation might be scattered across multiple rows.

Typically a dataset will only suffer from one of these problems; it’ll only suffer from both if you’re really unlucky! To fix these problems, you’ll need the two most important functions in tidyr: <code>pivot_longer()</code> and <code>pivot_wider()</code>.

<h3>12.3.1 Longer</h3>
A common problem is a dataset where some of the column names are not names of variables, but <em>values</em> of a variable. 
Take <code>table4a</code>: the column names <code>1999</code> and <code>2000</code> represent values of the <code>year</code> variable, the values in the <code>1999</code> and <code>2000</code> columns represent values of the <code>cases</code> variable, and each row represents two observations, not one.

<code>table4a</a>
#> # A tibble: 3 x 3</a>
#>   country     `1999` `2000`</a>
#> * &lt;chr>        &lt;int>  &lt;int></a>
#> 1 Afghanistan    745   2666</a>
#> 2 Brazil       37737  80488</a>
#> 3 China       212258 213766</code>

To tidy a dataset like this, we need to pivot the offending columns into a new pair of variables. 
To describe that operation we need three parameters:

The set of columns whose names are values, not variables. 
In this example,
those are the columns <code>1999</code> and <code>2000</code>.

The name of the variable to move the column names to. 
Here it is <code>year</code>.

The name of the variable to move the column values to. 
Here it’s <code>cases</code>.

Together those parameters generate the call to <code>pivot_longer()</code>:

<code>table4a %>% </a>
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")</a>
#> # A tibble: 6 x 3</a>
#>   country     year   cases</a>
#>   &lt;chr>       &lt;chr>  &lt;int></a>
#> 1 Afghanistan 1999     745</a>
#> 2 Afghanistan 2000    2666</a>
#> 3 Brazil      1999   37737</a>
#> 4 Brazil      2000   80488</a>
#> 5 China       1999  212258</a>
#> 6 China       2000  213766</code>

The columns to pivot are specified with <code>dplyr::select()</code> style notation. 
Here there are only two columns, so we list them individually. 
Note that '1999' and '2000' are non-syntactic names (because they don’t start with a letter) so we have to surround them in backticks. 
To refresh your memory of the other ways to select columns, see <a href="transform.html#select">select</a>.

<code>year</code> and <code>cases</code> do not exist in <code>table4a</code> so we put their names in quotes.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3aea19108d39606bbe49981acda07696c0c7fcd8/2de65/images/tidy-9.png" alt="Pivoting `table4` into a longer, tidy form." width="100%" />

Figure 12.2: Pivoting <code>table4</code> into a longer, tidy form.

In the final result, the pivoted columns are dropped, and we get new <code>year</code> and <code>cases</code> columns. 
Otherwise, the relationships between the original variables are preserved. 
Visually, this is shown in Figure <a href="tidy-data.html#fig:tidy-gather">12.2</a>.

<code>pivot_longer()</code> makes datasets longer by increasing the number of rows and decreasing the number of columns. 
I don’t believe it makes sense to describe a dataset as being in 'long form'. 
Length is a relative term, and you can only say (e.g.) that dataset A is longer than dataset B.

We can use <code>pivot_longer()</code> to tidy <code>table4b</code> in a similar fashion. 
The only difference is the variable stored in the cell values:

<code>table4b %>% </a>
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")</a>
#> # A tibble: 6 x 3</a>
#>   country     year  population</a>
#>   &lt;chr>       &lt;chr>      &lt;int></a>
#> 1 Afghanistan 1999    19987071</a>
#> 2 Afghanistan 2000    20595360</a>
#> 3 Brazil      1999   172006362</a>
#> 4 Brazil      2000   174504898</a>
#> 5 China       1999  1272915272</a>
#> 6 China       2000  1280428583</code>

To combine the tidied versions of <code>table4a</code> and <code>table4b</code> into a single tibble, we need to use <code>dplyr::left_join()</code>, which you’ll learn about in <a href="relational-data.html#relational-data">relational data</a>.

<code>tidy4a &lt;- table4a %>% </a>
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")</a>
tidy4b &lt;- table4b %>% </a>
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")</a>
left_join(tidy4a, tidy4b)</a>
#> Joining, by = c("country", "year")</a>
#> # A tibble: 6 x 4</a>
#>   country     year   cases population</a>
#>   &lt;chr>       &lt;chr>  &lt;int>      &lt;int></a>
#> 1 Afghanistan 1999     745   19987071</a>
#> 2 Afghanistan 2000    2666   20595360</a>
#> 3 Brazil      1999   37737  172006362</a>
#> 4 Brazil      2000   80488  174504898</a>
#> 5 China       1999  212258 1272915272</a>
#> 6 China       2000  213766 1280428583</code>

<h3>12.3.2 Wider</h3>
<code>pivot_wider()</code> is the opposite of <code>pivot_longer()</code>. 
You use it when an observation is scattered across multiple rows. 
For example, take <code>table2</code>: an observation is a country in a year, but each observation is spread across two rows.

<code>table2</a>
#> # A tibble: 12 x 4</a>
#>   country      year type           count</a>
#>   &lt;chr>       &lt;int> &lt;chr>          &lt;int></a>
#> 1 Afghanistan  1999 cases            745</a>
#> 2 Afghanistan  1999 population  19987071</a>
#> 3 Afghanistan  2000 cases           2666</a>
#> 4 Afghanistan  2000 population  20595360</a>
#> 5 Brazil       1999 cases          37737</a>
#> 6 Brazil       1999 population 172006362</a>
#> # … with 6 more rows</code>

To tidy this up, we first analyse the representation in similar way to <code>pivot_longer()</code>. 
This time, however, we only need two parameters:

The column to take variable names from. 
Here, it’s <code>type</code>.

The column to take values from. 
Here it’s <code>count</code>.

Once we’ve figured that out, we can use <code>pivot_wider()</code>, as shown programmatically below, and visually in Figure <a href="tidy-data.html#fig:tidy-spread">12.3</a>.

<code>table2 %>%</a>
    pivot_wider(names_from = type, values_from = count)</a>
#> # A tibble: 6 x 4</a>
#>   country      year  cases population</a>
#>   &lt;chr>       &lt;int>  &lt;int>      &lt;int></a>
#> 1 Afghanistan  1999    745   19987071</a>
#> 2 Afghanistan  2000   2666   20595360</a>
#> 3 Brazil       1999  37737  172006362</a>
#> 4 Brazil       2000  80488  174504898</a>
#> 5 China        1999 212258 1272915272</a>
#> 6 China        2000 213766 1280428583</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/8350f0dda414629b9d6c354f87acf5c5f722be43/bcb84/images/tidy-8.png" alt="Pivoting `table2` into a "wider", tidy form." width="100%" />

Figure 12.3: Pivoting <code>table2</code> into a 'wider', tidy form.

As you might have guessed from their names, <code>pivot_wider()</code> and <code>pivot_longer()</code> are complements. 
<code>pivot_longer()</code> makes wide tables narrower and longer; <code>pivot_wider()</code> makes long tables shorter and wider.

<h3>12.3.3 Exercises</h3>

Why are <code>pivot_longer()</code> and <code>pivot_wider()</code> not perfectly symmetrical?<br />
Carefully consider the following example:

<code>stocks &lt;- tibble(</a>
  year   = c(2015, 2015, 2016, 2016),</a>
  half  = c(   1,    2,     1,    2),</a>
  return = c(1.88, 0.59, 0.92, 0.17)</a>
)</a>
stocks %>% </a>
  pivot_wider(names_from = year, values_from = return) %>% </a>
  pivot_longer(`2015`:`2016`, names_to = "year", values_to = "return")</code>

(Hint: look at the variable types and think about column <em>names</em>.)

<code>pivot_longer()</code> has a <code>names_ptype</code> argument, e.g.
<code>names_ptype = list(year = double())</code>. 
What does it do?

Why does this code fail?

<code>table4a %>% </a>
  pivot_longer(c(1999, 2000), names_to = "year", values_to = "cases")</a>
#> Error: Can&#39;t subset columns that don&#39;t exist.</a>
#> ✖ The locations 1999 and 2000 don&#39;t exist.</a>
#> ℹ There are only 3 columns.</code>

What would happen if you widen this table? Why? How could you add a
new column to uniquely identify each value?

<code>people &lt;- tribble(</a>
  ~name,             ~names,  ~values,</a>
  #-----------------|--------|------</a>
  "Phillip Woods",   "age",       45,</a>
  "Phillip Woods",   "height",   186,</a>
  "Phillip Woods",   "age",       50,</a>
  "Jessica Cordero", "age",       37,</a>
  "Jessica Cordero", "height",   156</a>
)</code>

Tidy the simple tibble below. 
Do you need to make it wider or longer?
What are the variables?

<code>preg &lt;- tribble(</a>
  ~pregnant, ~male, ~female,</a>
  "yes",     NA,    10,</a>
  "no",      20,    12</a>
)</code>

<h2>12.4 Separating and uniting</h2>
So far you’ve learned how to tidy <code>table2</code> and <code>table4</code>, but not <code>table3</code>. 
<code>table3</code> has a different problem: we have one column (<code>rate</code>) that contains two variables (<code>cases</code> and <code>population</code>). 
To fix this problem, we’ll need the <code>separate()</code> function. 
You’ll also learn about the complement of <code>separate()</code>: <code>unite()</code>, which you use if a single variable is spread across multiple columns.

<h3>12.4.1 Separate</h3>
<code>separate()</code> pulls apart one column into multiple columns, by splitting wherever a separator character appears. 
Take <code>table3</code>:

<code>table3</a>
#> # A tibble: 6 x 3</a>
#>   country      year rate             </a>
#> * &lt;chr>       &lt;int> &lt;chr>            </a>
#> 1 Afghanistan  1999 745/19987071     </a>
#> 2 Afghanistan  2000 2666/20595360    </a>
#> 3 Brazil       1999 37737/172006362  </a>
#> 4 Brazil       2000 80488/174504898  </a>
#> 5 China        1999 212258/1272915272</a>
#> 6 China        2000 213766/1280428583</code>

The <code>rate</code> column contains both <code>cases</code> and <code>population</code> variables, and we need to split it into two variables. 
<code>separate()</code> takes the name of the column to separate, and the names of the columns to separate into, as shown in Figure <a href="tidy-data.html#fig:tidy-separate">12.4</a> and the code below.

<code>table3 %>% </a>
  separate(rate, into = c("cases", "population"))</a>
#> # A tibble: 6 x 4</a>
#>   country      year cases  population</a>
#>   &lt;chr>       &lt;int> &lt;chr>  &lt;chr>     </a>
#> 1 Afghanistan  1999 745    19987071  </a>
#> 2 Afghanistan  2000 2666   20595360  </a>
#> 3 Brazil       1999 37737  172006362 </a>
#> 4 Brazil       2000 80488  174504898 </a>
#> 5 China        1999 212258 1272915272</a>
#> 6 China        2000 213766 1280428583</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f6fca537e77896868fedcd85d9d01031930d76c9/637d9/images/tidy-17.png" alt="Separating `table3` makes it tidy" width="75%" />

Figure 12.4: Separating <code>table3</code> makes it tidy

By default, <code>separate()</code> will split values wherever it sees a non-alphanumeric character (i.e. a character that isn’t a number or letter). 
For example, in the code above, <code>separate()</code> split the values of <code>rate</code> at the forward slash characters. 
If you wish to use a specific character to separate a column, you can pass the character to the <code>sep</code> argument of <code>separate()</code>. 
For example, we could rewrite the code above as:

<code>table3 %>% </a>
  separate(rate, into = c("cases", "population"), sep = "/")</code>

(Formally, <code>sep</code> is a regular expression, which you’ll learn more about in <a href="strings.html#strings">strings</a>.)

Look carefully at the column types: you’ll notice that <code>cases</code> and <code>population</code> are character columns. 
This is the default behaviour in <code>separate()</code>: it leaves the type of the column as is. 
Here, however, it’s not very useful as those really are numbers. 
We can ask <code>separate()</code> to try and convert to better types using <code>convert = TRUE</code>:

<code>table3 %>% </a>
  separate(rate, into = c("cases", "population"), convert = TRUE)</a>
#> # A tibble: 6 x 4</a>
#>   country      year  cases population</a>
#>   &lt;chr>       &lt;int>  &lt;int>      &lt;int></a>
#> 1 Afghanistan  1999    745   19987071</a>
#> 2 Afghanistan  2000   2666   20595360</a>
#> 3 Brazil       1999  37737  172006362</a>
#> 4 Brazil       2000  80488  174504898</a>
#> 5 China        1999 212258 1272915272</a>
#> 6 China        2000 213766 1280428583</code>

You can also pass a vector of integers to <code>sep</code>. 
<code>separate()</code> will interpret the integers as positions to split at. 
Positive values start at 1 on the far-left of the strings; negative value start at -1 on the far-right of the strings. 
When using integers to separate strings, the length of <code>sep</code> should be one less than the number of names in <code>into</code>.

You can use this arrangement to separate the last two digits of each year. 
This make this data less tidy, but is useful in other cases, as you’ll see in a little bit.

<code>table3 %>% </a>
  separate(year, into = c("century", "year"), sep = 2)</a>
#> # A tibble: 6 x 4</a>
#>   country     century year  rate             </a>
#>   &lt;chr>       &lt;chr>   &lt;chr> &lt;chr>            </a>
#> 1 Afghanistan 19      99    745/19987071     </a>
#> 2 Afghanistan 20      00    2666/20595360    </a>
#> 3 Brazil      19      99    37737/172006362  </a>
#> 4 Brazil      20      00    80488/174504898  </a>
#> 5 China       19      99    212258/1272915272</a>
#> 6 China       20      00    213766/1280428583</code>

<h3>12.4.2 Unite</h3>
<code>unite()</code> is the inverse of <code>separate()</code>: it combines multiple columns into a single column. 
You’ll need it much less frequently than <code>separate()</code>, but it’s still a useful tool to have in your back pocket.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3d98d3ba019fed3f9ee328284568d4508e479ef8/0b3e6/images/tidy-18.png" alt="Uniting `table5` makes it tidy" width="75%" />

Figure 12.5: Uniting <code>table5</code> makes it tidy

We can use <code>unite()</code> to rejoin the <em>century</em> and <em>year</em> columns that we created in the last example. 
That data is saved as <code>tidyr::table5</code>. 
<code>unite()</code> takes a data frame, the name of the new variable to create, and a set of columns to combine, again specified in <code>dplyr::select()</code> style:

<code>table5 %>% </a>
  unite(new, century, year)</a>
#> # A tibble: 6 x 3</a>
#>   country     new   rate             </a>
#>   &lt;chr>       &lt;chr> &lt;chr>            </a>
#> 1 Afghanistan 19_99 745/19987071     </a>
#> 2 Afghanistan 20_00 2666/20595360    </a>
#> 3 Brazil      19_99 37737/172006362  </a>
#> 4 Brazil      20_00 80488/174504898  </a>
#> 5 China       19_99 212258/1272915272</a>
#> 6 China       20_00 213766/1280428583</code>

In this case we also need to use the <code>sep</code> argument. 
The default will place an underscore (<code>_</code>) between the values from different columns. 
Here we don’t want any separator so we use <code>"</code>:

<code>table5 %>% </a>
  unite(new, century, year, sep = ")</a>
#> # A tibble: 6 x 3</a>
#>   country     new   rate             </a>
#>   &lt;chr>       &lt;chr> &lt;chr>            </a>
#> 1 Afghanistan 1999  745/19987071     </a>
#> 2 Afghanistan 2000  2666/20595360    </a>
#> 3 Brazil      1999  37737/172006362  </a>
#> 4 Brazil      2000  80488/174504898  </a>
#> 5 China       1999  212258/1272915272</a>
#> 6 China       2000  213766/1280428583</code>

<h3>12.4.3 Exercises</h3>

What do the <code>extra</code> and <code>fill</code> arguments do in <code>separate()</code>?
Experiment with the various options for the following two toy datasets.

<code>tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% </a>
  separate(x, c("one", "two", "three"))</a>
</a>
tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% </a>
  separate(x, c("one", "two", "three"))</code>

Both <code>unite()</code> and <code>separate()</code> have a <code>remove</code> argument. 
What does it
do? Why would you set it to <code>FALSE</code>?

Compare and contrast <code>separate()</code> and <code>extract()</code>. 
Why are there
three variations of separation (by position, by separator, and with
groups), but only one unite?

<h2>12.5 Missing values</h2>
Changing the representation of a dataset brings up an important subtlety of missing values. 
Surprisingly, a value can be missing in one of two possible ways:

Explicitly, i.e. flagged with <code>NA</code>.

Implicitly, i.e. simply not present in the data.

Let’s illustrate this idea with a very simple data set:

<code>stocks &lt;- tibble(</a>
  year   = c(2015, 2015, 2015, 2015, 2016, 2016, 2016),</a>
  qtr    = c(   1,    2,    3,    4,    2,    3,    4),</a>
  return = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)</a>
)</code>

There are two missing values in this dataset:

The return for the fourth quarter of 2015 is explicitly missing, because
the cell where its value should be instead contains <code>NA</code>.

The return for the first quarter of 2016 is implicitly missing, because it
simply does not appear in the dataset.

One way to think about the difference is with this Zen-like koan: An explicit missing value is the presence of an absence; an implicit missing value is the absence of a presence.

The way that a dataset is represented can make implicit values explicit. 
For example, we can make the implicit missing value explicit by putting years in the columns:

<code>stocks %>% </a>
  pivot_wider(names_from = year, values_from = return)</a>
#> # A tibble: 4 x 3</a>
#>     qtr `2015` `2016`</a>
#>   &lt;dbl>  &lt;dbl>  &lt;dbl></a>
#> 1     1   1.88  NA   </a>
#> 2     2   0.59   0.92</a>
#> 3     3   0.35   0.17</a>
#> 4     4  NA      2.66</code>

Because these explicit missing values may not be important in other representations of the data, you can set <code>values_drop_na = TRUE</code> in <code>pivot_longer()</code> to turn explicit missing values implicit:

<code>stocks %>% </a>
  pivot_wider(names_from = year, values_from = return) %>% </a>
  pivot_longer(</a>
    cols = c(`2015`, `2016`), </a>
    names_to = "year", </a>
    values_to = "return", </a>
    values_drop_na = TRUE</a>
  )</a>
#> # A tibble: 6 x 3</a>
#>     qtr year  return</a>
#>   &lt;dbl> &lt;chr>  &lt;dbl></a>
#> 1     1 2015    1.88</a>
#> 2     2 2015    0.59</a>
#> 3     2 2016    0.92</a>
#> 4     3 2015    0.35</a>
#> 5     3 2016    0.17</a>
#> 6     4 2016    2.66</code>

Another important tool for making missing values explicit in tidy data is <code>complete()</code>:

<code>stocks %>% </a>
  complete(year, qtr)</a>
#> # A tibble: 8 x 3</a>
#>    year   qtr return</a>
#>   &lt;dbl> &lt;dbl>  &lt;dbl></a>
#> 1  2015     1   1.88</a>
#> 2  2015     2   0.59</a>
#> 3  2015     3   0.35</a>
#> 4  2015     4  NA   </a>
#> 5  2016     1  NA   </a>
#> 6  2016     2   0.92</a>
#> # … with 2 more rows</code>

<code>complete()</code> takes a set of columns, and finds all unique combinations. 
It then ensures the original dataset contains all those values, filling in explicit <code>NA</code>s where necessary.

There’s one other important tool that you should know for working with missing values. 
Sometimes when a data source has primarily been used for data entry, missing values indicate that the previous value should be carried forward:

<code>treatment &lt;- tribble(</a>
  ~ person,           ~ treatment, ~response,</a>
  "Derrick Whitmore", 1,           7,</a>
  NA,                 2,           10,</a>
  NA,                 3,           9,</a>
  "Katherine Burke",  1,           4</a>
)</code>

You can fill in these missing values with <code>fill()</code>. 
It takes a set of columns where you want missing values to be replaced by the most recent non-missing value (sometimes called last observation carried forward).

<code>treatment %>% </a>
  fill(person)</a>
#> # A tibble: 4 x 3</a>
#>   person           treatment response</a>
#>   &lt;chr>                &lt;dbl>    &lt;dbl></a>
#> 1 Derrick Whitmore         1        7</a>
#> 2 Derrick Whitmore         2       10</a>
#> 3 Derrick Whitmore         3        9</a>
#> 4 Katherine Burke          1        4</code>

<h3>12.5.1 Exercises</h3>

Compare and contrast the <code>fill</code> arguments to <code>pivot_wider()</code> and <code>complete()</code>.

What does the direction argument to <code>fill()</code> do?

<h2>12.6 Case Study</h2>
To finish off the chapter, let’s pull together everything you’ve learned to tackle a realistic data tidying problem. 
The <code>tidyr::who</code> dataset contains tuberculosis (TB) cases broken down by year, country, age, gender, and diagnosis method. 
The data comes from the <em>2014 World Health Organization Global Tuberculosis Report</em>, available at <a href="http://www.who.int/tb/country/data/download/en/" class="uri">http://www.who.int/tb/country/data/download/en/</a>.

There’s a wealth of epidemiological information in this dataset, but it’s challenging to work with the data in the form that it’s provided:

<code>who</a>
#> # A tibble: 7,240 x 60</a>
#>   country iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544</a>
#>   &lt;chr>   &lt;chr> &lt;chr> &lt;int>       &lt;int>        &lt;int>        &lt;int>        &lt;int></a>
#> 1 Afghan… AF    AFG    1980          NA           NA           NA           NA</a>
#> 2 Afghan… AF    AFG    1981          NA           NA           NA           NA</a>
#> 3 Afghan… AF    AFG    1982          NA           NA           NA           NA</a>
#> 4 Afghan… AF    AFG    1983          NA           NA           NA           NA</a>
#> 5 Afghan… AF    AFG    1984          NA           NA           NA           NA</a>
#> 6 Afghan… AF    AFG    1985          NA           NA           NA           NA</a>
#> # … with 7,234 more rows, and 52 more variables: new_sp_m4554 &lt;int>,</a>
#> #   new_sp_m5564 &lt;int>, new_sp_m65 &lt;int>, new_sp_f014 &lt;int>,</a>
#> #   new_sp_f1524 &lt;int>, new_sp_f2534 &lt;int>, new_sp_f3544 &lt;int>,</a>
#> #   new_sp_f4554 &lt;int>, new_sp_f5564 &lt;int>, new_sp_f65 &lt;int>,</a>
#> #   new_sn_m014 &lt;int>, new_sn_m1524 &lt;int>, new_sn_m2534 &lt;int>,</a>
#> #   new_sn_m3544 &lt;int>, new_sn_m4554 &lt;int>, new_sn_m5564 &lt;int>,</a>
#> #   new_sn_m65 &lt;int>, new_sn_f014 &lt;int>, new_sn_f1524 &lt;int>,</a>
#> #   new_sn_f2534 &lt;int>, new_sn_f3544 &lt;int>, new_sn_f4554 &lt;int>,</a>
#> #   new_sn_f5564 &lt;int>, new_sn_f65 &lt;int>, new_ep_m014 &lt;int>,</a>
#> #   new_ep_m1524 &lt;int>, new_ep_m2534 &lt;int>, new_ep_m3544 &lt;int>,</a>
#> #   new_ep_m4554 &lt;int>, new_ep_m5564 &lt;int>, new_ep_m65 &lt;int>,</a>
#> #   new_ep_f014 &lt;int>, new_ep_f1524 &lt;int>, new_ep_f2534 &lt;int>,</a>
#> #   new_ep_f3544 &lt;int>, new_ep_f4554 &lt;int>, new_ep_f5564 &lt;int>,</a>
#> #   new_ep_f65 &lt;int>, newrel_m014 &lt;int>, newrel_m1524 &lt;int>,</a>
#> #   newrel_m2534 &lt;int>, newrel_m3544 &lt;int>, newrel_m4554 &lt;int>,</a>
#> #   newrel_m5564 &lt;int>, newrel_m65 &lt;int>, newrel_f014 &lt;int>,</a>
#> #   newrel_f1524 &lt;int>, newrel_f2534 &lt;int>, newrel_f3544 &lt;int>,</a>
#> #   newrel_f4554 &lt;int>, newrel_f5564 &lt;int>, newrel_f65 &lt;int></code>

This is a very typical real-life example dataset. 
It contains redundant columns, odd variable codes, and many missing values. 
In short, <code>who</code> is messy, and we’ll need multiple steps to tidy it. 
Like dplyr, tidyr is designed so that each function does one thing well. 
That means in real-life situations you’ll usually need to string together multiple verbs into a pipeline.

The best place to start is almost always to gather together the columns that are not variables. 
Let’s have a look at what we’ve got:

It looks like <code>country</code>, <code>iso2</code>, and <code>iso3</code> are three variables that
redundantly specify the country.

<code>year</code> is clearly also a variable.

We don’t know what all the other columns are yet, but given the structure
in the variable names (e.g. 
<code>new_sp_m014</code>, <code>new_ep_m014</code>, <code>new_ep_f014</code>)
these are likely to be values, not variables.

So we need to gather together all the columns from <code>new_sp_m014</code> to <code>newrel_f65</code>. 
We don’t know what those values represent yet, so we’ll give them the generic name <code>"key"</code>. 
We know the cells represent the count of cases, so we’ll use the variable <code>cases</code>. 
There are a lot of missing values in the current representation, so for now we’ll use <code>na.rm</code> just so we can focus on the values that are present.

<code>who1 &lt;- who %>% </a>
  pivot_longer(</a>
    cols = new_sp_m014:newrel_f65, </a>
    names_to = "key", </a>
    values_to = "cases", </a>
    values_drop_na = TRUE</a>
  )</a>
who1</a>
#> # A tibble: 76,046 x 6</a>
#>   country     iso2  iso3   year key          cases</a>
#>   &lt;chr>       &lt;chr> &lt;chr> &lt;int> &lt;chr>        &lt;int></a>
#> 1 Afghanistan AF    AFG    1997 new_sp_m014      0</a>
#> 2 Afghanistan AF    AFG    1997 new_sp_m1524    10</a>
#> 3 Afghanistan AF    AFG    1997 new_sp_m2534     6</a>
#> 4 Afghanistan AF    AFG    1997 new_sp_m3544     3</a>
#> 5 Afghanistan AF    AFG    1997 new_sp_m4554     5</a>
#> 6 Afghanistan AF    AFG    1997 new_sp_m5564     2</a>
#> # … with 76,040 more rows</code>

We can get some hint of the structure of the values in the new <code>key</code> column by counting them:

<code>who1 %>% </a>
  count(key)</a>
#> # A tibble: 56 x 2</a>
#>   key              n</a>
#>   &lt;chr>        &lt;int></a>
#> 1 new_ep_f014   1032</a>
#> 2 new_ep_f1524  1021</a>
#> 3 new_ep_f2534  1021</a>
#> 4 new_ep_f3544  1021</a>
#> 5 new_ep_f4554  1017</a>
#> 6 new_ep_f5564  1017</a>
#> # … with 50 more rows</code>

You might be able to parse this out by yourself with a little thought and some experimentation, but luckily we have the data dictionary handy. 
It tells us:

The first three letters of each column denote whether the column
contains new or old cases of TB. 
In this dataset, each column contains
new cases.

The next two letters describe the type of TB:

<code>rel</code> stands for cases of relapse

<code>ep</code> stands for cases of extrapulmonary TB

<code>sn</code> stands for cases of pulmonary TB that could not be diagnosed by
a pulmonary smear (smear negative)

<code>sp</code> stands for cases of pulmonary TB that could be diagnosed be
a pulmonary smear (smear positive)

The sixth letter gives the sex of TB patients. 
The dataset groups
cases by males (<code>m</code>) and females (<code>f</code>).

The remaining numbers gives the age group. 
The dataset groups cases into
seven age groups:

<code>014</code> = 0 – 14 years old

<code>1524</code> = 15 – 24 years old

<code>2534</code> = 25 – 34 years old

<code>3544</code> = 35 – 44 years old

<code>4554</code> = 45 – 54 years old

<code>5564</code> = 55 – 64 years old

<code>65</code> = 65 or older

We need to make a minor fix to the format of the column names: unfortunately the names are slightly inconsistent because instead of <code>new_rel</code> we have <code>newrel</code> (it’s hard to spot this here but if you don’t fix it we’ll get errors in subsequent steps). 
You’ll learn about <code>str_replace()</code> in <a href="strings.html#strings">strings</a>, but the basic idea is pretty simple: replace the characters 'newrel' with 'new_rel'. 
This makes all variable names consistent.

<code>who2 &lt;- who1 %>% </a>
  mutate(names_from = stringr::str_replace(key, "newrel", "new_rel"))</a>
who2</a>
#> # A tibble: 76,046 x 7</a>
#>   country     iso2  iso3   year key          cases names_from  </a>
#>   &lt;chr>       &lt;chr> &lt;chr> &lt;int> &lt;chr>        &lt;int> &lt;chr>       </a>
#> 1 Afghanistan AF    AFG    1997 new_sp_m014      0 new_sp_m014 </a>
#> 2 Afghanistan AF    AFG    1997 new_sp_m1524    10 new_sp_m1524</a>
#> 3 Afghanistan AF    AFG    1997 new_sp_m2534     6 new_sp_m2534</a>
#> 4 Afghanistan AF    AFG    1997 new_sp_m3544     3 new_sp_m3544</a>
#> 5 Afghanistan AF    AFG    1997 new_sp_m4554     5 new_sp_m4554</a>
#> 6 Afghanistan AF    AFG    1997 new_sp_m5564     2 new_sp_m5564</a>
#> # … with 76,040 more rows</code>

We can separate the values in each code with two passes of <code>separate()</code>. 
The first pass will split the codes at each underscore.

<code>who3 &lt;- who2 %>% </a>
  separate(key, c("new", "type", "sexage"), sep = "_")</a>
#> Warning: Expected 3 pieces. 
Missing pieces filled with `NA` in 2580 rows [243,</a>
#> 244, 679, 680, 681, 682, 683, 684, 685, 686, 687, 688, 689, 690, 691, 692, 903,</a>
#> 904, 905, 906, ...].</a>
who3</a>
#> # A tibble: 76,046 x 9</a>
#>   country     iso2  iso3   year new   type  sexage cases names_from  </a>
#>   &lt;chr>       &lt;chr> &lt;chr> &lt;int> &lt;chr> &lt;chr> &lt;chr>  &lt;int> &lt;chr>       </a>
#> 1 Afghanistan AF    AFG    1997 new   sp    m014       0 new_sp_m014 </a>
#> 2 Afghanistan AF    AFG    1997 new   sp    m1524     10 new_sp_m1524</a>
#> 3 Afghanistan AF    AFG    1997 new   sp    m2534      6 new_sp_m2534</a>
#> 4 Afghanistan AF    AFG    1997 new   sp    m3544      3 new_sp_m3544</a>
#> 5 Afghanistan AF    AFG    1997 new   sp    m4554      5 new_sp_m4554</a>
#> 6 Afghanistan AF    AFG    1997 new   sp    m5564      2 new_sp_m5564</a>
#> # … with 76,040 more rows</code>

Then we might as well drop the <code>new</code> column because it’s constant in this dataset. 
While we’re dropping columns, let’s also drop <code>iso2</code> and <code>iso3</code> since they’re redundant.

<code>who3 %>% </a>
  count(new)</a>
#> # A tibble: 2 x 2</a>
#>   new        n</a>
#>   &lt;chr>  &lt;int></a>
#> 1 new    73466</a>
#> 2 newrel  2580</a>
who4 &lt;- who3 %>% </a>
  select(-new, -iso2, -iso3)</code>

Next we’ll separate <code>sexage</code> into <code>sex</code> and <code>age</code> by splitting after the first character:

<code>who5 &lt;- who4 %>% </a>
  separate(sexage, c("sex", "age"), sep = 1)</a>
who5</a>
#> # A tibble: 76,046 x 7</a>
#>   country      year type  sex   age   cases names_from  </a>
#>   &lt;chr>       &lt;int> &lt;chr> &lt;chr> &lt;chr> &lt;int> &lt;chr>       </a>
#> 1 Afghanistan  1997 sp    m     014       0 new_sp_m014 </a>
#> 2 Afghanistan  1997 sp    m     1524     10 new_sp_m1524</a>
#> 3 Afghanistan  1997 sp    m     2534      6 new_sp_m2534</a>
#> 4 Afghanistan  1997 sp    m     3544      3 new_sp_m3544</a>
#> 5 Afghanistan  1997 sp    m     4554      5 new_sp_m4554</a>
#> 6 Afghanistan  1997 sp    m     5564      2 new_sp_m5564</a>
#> # … with 76,040 more rows</code>

The <code>who</code> dataset is now tidy!

I’ve shown you the code a piece at a time, assigning each interim result to a new variable. 
This typically isn’t how you’d work interactively. 
Instead, you’d gradually build up a complex pipe:

<code>who %>%</a>
  pivot_longer(</a>
    cols = new_sp_m014:newrel_f65, </a>
    names_to = "key", </a>
    values_to = "cases", </a>
    values_drop_na = TRUE</a>
  ) %>% </a>
  mutate(</a>
    key = stringr::str_replace(key, "newrel", "new_rel")</a>
  ) %>%</a>
  separate(key, c("new", "var", "sexage")) %>% </a>
  select(-new, -iso2, -iso3) %>% </a>
  separate(sexage, c("sex", "age"), sep = 1)</code>

<h3>12.6.1 Exercises</h3>

In this case study I set <code>values_drop_na = TRUE</code> just to make it easier to
check that we had the correct values. 
Is this reasonable? Think about
how missing values are represented in this dataset. 
Are there implicit
missing values? What’s the difference between an <code>NA</code> and zero?

What happens if you neglect the <code>mutate()</code> step?
(<code>mutate(names_from = stringr::str_replace(key, "newrel", "new_rel"))</code>)

I claimed that <code>iso2</code> and <code>iso3</code> were redundant with <code>country</code>.
Confirm this claim.

For each country, year, and sex compute the total number of cases of
TB. 
Make an informative visualisation of the data.

<h2>12.7 Non-tidy data</h2>
Before we continue on to other topics, it’s worth talking briefly about non-tidy data. 
Earlier in the chapter, I used the pejorative term 'messy' to refer to non-tidy data. 
That’s an oversimplification: there are lots of useful and well-founded data structures that are not tidy data. 
There are two main reasons to use other data structures:

Alternative representations may have substantial performance or space
advantages.

Specialised fields have evolved their own conventions for storing data
that may be quite different to the conventions of tidy data.

Either of these reasons means you’ll need something other than a tibble (or data frame). 
If your data does fit naturally into a rectangular structure composed of observations and variables, I think tidy data should be your default choice. 
But there are good reasons to use other structures; tidy data is not the only way.

If you’d like to learn more about non-tidy data, I’d highly recommend this thoughtful blog post by Jeff Leek: <a href="http://simplystatistics.org/2016/02/17/non-tidy-data/" class="uri">http://simplystatistics.org/2016/02/17/non-tidy-data/</a>

<h2><span class="orange">13 Relational data</span></h2>

<h2>13.1 Introduction</h2>
It’s rare that a data analysis involves only a single table of data. 
Typically you have many tables of data, and you must combine them to answer the questions that you’re interested in. 
Collectively, multiple tables of data are called relational data because it is the relations, not just the individual datasets, that are important.

Relations are always defined between a pair of tables. 
All other relations are built up from this simple idea: the relations of three or more tables are always a property of the relations between each pair. 
Sometimes both elements of a pair can be the same table! This is needed if, for example, you have a table of people, and each person has a reference to their parents.

To work with relational data you need verbs that work with pairs of tables. 
There are three families of verbs designed to work with relational data:

Mutating joins, which add new variables to one data frame from matching
observations in another.

Filtering joins, which filter observations from one data frame based on
whether or not they match an observation in the other table.

Set operations, which treat observations as if they were set elements.

The most common place to find relational data is in a <em>relational</em> database management system (or RDBMS), a term that encompasses almost all modern databases. 
If you’ve used a database before, you’ve almost certainly used SQL. 
If so, you should find the concepts in this chapter familiar, although their expression in dplyr is a little different. 
Generally, dplyr is a little easier to use than SQL because dplyr is specialised to do data analysis: it makes common data analysis operations easier, at the expense of making it more difficult to do other things that aren’t commonly needed for data analysis.

<h3>13.1.1 Prerequisites</h3>
We will explore relational data from <code>nycflights13</code> using the two-table verbs from dplyr.

<code>library(tidyverse)</a>
library(nycflights13)</code>

<h2>13.2 nycflights13</h2>
We will use the nycflights13 package to learn about relational data. 
nycflights13 contains four tibbles that are related to the <code>flights</code> table that you used in <a href="transform.html#transform">data transformation</a>:

<code>airlines</code> lets you look up the full carrier name from its abbreviated
code:

<code>airlines</a>
#> # A tibble: 16 x 2</a>
#>   carrier name                    </a>
#>   &lt;chr>   &lt;chr>                   </a>
#> 1 9E      Endeavor Air Inc. 
      </a>
#> 2 AA      American Airlines Inc. 
 </a>
#> 3 AS      Alaska Airlines Inc. 
   </a>
#> 4 B6      JetBlue Airways         </a>
#> 5 DL      Delta Air Lines Inc. 
   </a>
#> 6 EV      ExpressJet Airlines Inc.</a>
#> # … with 10 more rows</code>

<code>airports</code> gives information about each airport, identified by the <code>faa</code>
airport code:

<code>airports</a>
#> # A tibble: 1,458 x 8</a>
#>   faa   name                          lat   lon   alt    tz dst   tzone         </a>
#>   &lt;chr> &lt;chr>                       &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;chr> &lt;chr>         </a>
#> 1 04G   Lansdowne Airport            41.1 -80.6  1044    -5 A     America/New_Y…</a>
#> 2 06A   Moton Field Municipal Airp…  32.5 -85.7   264    -6 A     America/Chica…</a>
#> 3 06C   Schaumburg Regional          42.0 -88.1   801    -6 A     America/Chica…</a>
#> 4 06N   Randall Airport              41.4 -74.4   523    -5 A     America/New_Y…</a>
#> 5 09J   Jekyll Island Airport        31.1 -81.4    11    -5 A     America/New_Y…</a>
#> 6 0A9   Elizabethton Municipal Air…  36.4 -82.2  1593    -5 A     America/New_Y…</a>
#> # … with 1,452 more rows</code>

<code>planes</code> gives information about each plane, identified by its <code>tailnum</code>:

<code>planes</a>
#> # A tibble: 3,322 x 9</a>
#>   tailnum  year type           manufacturer   model  engines seats speed engine </a>
#>   &lt;chr>   &lt;int> &lt;chr>          &lt;chr>          &lt;chr>    &lt;int> &lt;int> &lt;int> &lt;chr>  </a>
#> 1 N10156   2004 Fixed wing mu… EMBRAER        EMB-1…       2    55    NA Turbo-…</a>
#> 2 N102UW   1998 Fixed wing mu… AIRBUS INDUST… A320-…       2   182    NA Turbo-…</a>
#> 3 N103US   1999 Fixed wing mu… AIRBUS INDUST… A320-…       2   182    NA Turbo-…</a>
#> 4 N104UW   1999 Fixed wing mu… AIRBUS INDUST… A320-…       2   182    NA Turbo-…</a>
#> 5 N10575   2002 Fixed wing mu… EMBRAER        EMB-1…       2    55    NA Turbo-…</a>
#> 6 N105UW   1999 Fixed wing mu… AIRBUS INDUST… A320-…       2   182    NA Turbo-…</a>
#> # … with 3,316 more rows</code>

<code>weather</code> gives the weather at each NYC airport for each hour:

<code>weather</a>
#> # A tibble: 26,115 x 15</a>
#>   origin  year month   day  hour  temp  dewp humid wind_dir wind_speed wind_gust</a>
#>   &lt;chr>  &lt;int> &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;dbl> &lt;dbl>    &lt;dbl>      &lt;dbl>     &lt;dbl></a>
#> 1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4         NA</a>
#> 2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06        NA</a>
#> 3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5         NA</a>
#> 4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7         NA</a>
#> 5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7         NA</a>
#> 6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5         NA</a>
#> # … with 26,109 more rows, and 4 more variables: precip &lt;dbl>, pressure &lt;dbl>,</a>
#> #   visib &lt;dbl>, time_hour &lt;dttm></code>

One way to show the relationships between the different tables is with a drawing:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/245292d1ea724f6c3fd8a92063dcd7bfb9758d02/5751b/diagrams/relational-nycflights.png" width="70%" style="display: block; margin: auto;" />

This diagram is a little overwhelming, but it’s simple compared to some you’ll see in the wild! The key to understanding diagrams like this is to remember each relation always concerns a pair of tables. 
You don’t need to understand the whole thing; you just need to understand the chain of relations between the tables that you are interested in.

For nycflights13:

<code>flights</code> connects to <code>planes</code> via a single variable, <code>tailnum</code>.

<code>flights</code> connects to <code>airlines</code> through the <code>carrier</code> variable.

<code>flights</code> connects to <code>airports</code> in two ways: via the <code>origin</code> and
<code>dest</code> variables.

<code>flights</code> connects to <code>weather</code> via <code>origin</code> (the location), and
<code>year</code>, <code>month</code>, <code>day</code> and <code>hour</code> (the time).

<h3>13.2.1 Exercises</h3>

Imagine you wanted to draw (approximately) the route each plane flies from
its origin to its destination. 
What variables would you need? What tables
would you need to combine?

I forgot to draw the relationship between <code>weather</code> and <code>airports</code>.
What is the relationship and how should it appear in the diagram?

<code>weather</code> only contains information for the origin (NYC) airports. 
If
it contained weather records for all airports in the USA, what additional
relation would it define with <code>flights</code>?

We know that some days of the year are 'special', and fewer people than
usual fly on them. 
How might you represent that data as a data frame?
What would be the primary keys of that table? How would it connect to the
existing tables?

<h2>13.3 Keys</h2>
The variables used to connect each pair of tables are called keys. 
A key is a variable (or set of variables) that uniquely identifies an observation. 
In simple cases, a single variable is sufficient to identify an observation. 
For example, each plane is uniquely identified by its <code>tailnum</code>. 
In other cases, multiple variables may be needed. 
For example, to identify an observation in <code>weather</code> you need five variables: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code>, and <code>origin</code>.

There are two types of keys:

A primary key uniquely identifies an observation in its own table.
For example, <code>planes$tailnum</code> is a primary key because it uniquely identifies
each plane in the <code>planes</code> table.

A foreign key uniquely identifies an observation in another table.
For example, <code>flights$tailnum</code> is a foreign key because it appears in the
<code>flights</code> table where it matches each flight to a unique plane.

A variable can be both a primary key <em>and</em> a foreign key. 
For example, <code>origin</code> is part of the <code>weather</code> primary key, and is also a foreign key for the <code>airport</code> table.

Once you’ve identified the primary keys in your tables, it’s good practice to verify that they do indeed uniquely identify each observation. 
One way to do that is to <code>count()</code> the primary keys and look for entries where <code>n</code> is greater than one:

<code>planes %>% </a>
  count(tailnum) %>% </a>
  filter(n > 1)</a>
#> # A tibble: 0 x 2</a>
#> # … with 2 variables: tailnum &lt;chr>, n &lt;int></a>
</a>
weather %>% </a>
  count(year, month, day, hour, origin) %>% </a>
  filter(n > 1)</a>
#> # A tibble: 3 x 6</a>
#>    year month   day  hour origin     n</a>
#>   &lt;int> &lt;int> &lt;int> &lt;int> &lt;chr>  &lt;int></a>
#> 1  2013    11     3     1 EWR        2</a>
#> 2  2013    11     3     1 JFK        2</a>
#> 3  2013    11     3     1 LGA        2</code>

Sometimes a table doesn’t have an explicit primary key: each row is an observation, but no combination of variables reliably identifies it. 
For example, what’s the primary key in the <code>flights</code> table? You might think it would be the date plus the flight or tail number, but neither of those are unique:

<code>flights %>% </a>
  count(year, month, day, flight) %>% </a>
  filter(n > 1)</a>
#> # A tibble: 29,768 x 5</a>
#>    year month   day flight     n</a>
#>   &lt;int> &lt;int> &lt;int>  &lt;int> &lt;int></a>
#> 1  2013     1     1      1     2</a>
#> 2  2013     1     1      3     2</a>
#> 3  2013     1     1      4     2</a>
#> 4  2013     1     1     11     3</a>
#> 5  2013     1     1     15     2</a>
#> 6  2013     1     1     21     2</a>
#> # … with 29,762 more rows</a>
</a>
flights %>% </a>
  count(year, month, day, tailnum) %>% </a>
  filter(n > 1)</a>
#> # A tibble: 64,928 x 5</a>
#>    year month   day tailnum     n</a>
#>   &lt;int> &lt;int> &lt;int> &lt;chr>   &lt;int></a>
#> 1  2013     1     1 N0EGMQ      2</a>
#> 2  2013     1     1 N11189      2</a>
#> 3  2013     1     1 N11536      2</a>
#> 4  2013     1     1 N11544      3</a>
#> 5  2013     1     1 N11551      2</a>
#> 6  2013     1     1 N12540      2</a>
#> # … with 64,922 more rows</code>

When starting to work with this data, I had naively assumed that each flight number would be only used once per day: that would make it much easier to communicate problems with a specific flight. 
Unfortunately that is not the case! If a table lacks a primary key, it’s sometimes useful to add one with <code>mutate()</code> and <code>row_number()</code>. 
That makes it easier to match observations if you’ve done some filtering and want to check back in with the original data. 
This is called a surrogate key.

A primary key and the corresponding foreign key in another table form a relation. 
Relations are typically one-to-many. 
For example, each flight has one plane, but each plane has many flights. 
In other data, you’ll occasionally see a 1-to-1 relationship. 
You can think of this as a special case of 1-to-many. 
You can model many-to-many relations with a many-to-1 relation plus a 1-to-many relation. 
For example, in this data there’s a many-to-many relationship between airlines and airports: each airline flies to many airports; each airport hosts many airlines.

<h3>13.3.1 Exercises</h3>

Add a surrogate key to <code>flights</code>.

Identify the keys in the following datasets

<code>Lahman::Batting</code>,

<code>babynames::babynames</code>

<code>nasaweather::atmos</code>

<code>fueleconomy::vehicles</code>

<code>ggplot2::diamonds</code>

(You might need to install some packages and read some documentation.)

Draw a diagram illustrating the connections between the <code>Batting</code>,
<code>Master</code>, and <code>Salaries</code> tables in the Lahman package. 
Draw another diagram
that shows the relationship between <code>Master</code>, <code>Managers</code>, <code>AwardsManagers</code>.

How would you characterise the relationship between the <code>Batting</code>,
<code>Pitching</code>, and <code>Fielding</code> tables?

<h2>13.4 Mutating joins</h2>
The first tool we’ll look at for combining a pair of tables is the mutating join. 
A mutating join allows you to combine variables from two tables. 
It first matches observations by their keys, then copies across variables from one table to the other.

Like <code>mutate()</code>, the join functions add variables to the right, so if you have a lot of variables already, the new variables won’t get printed out. 
For these examples, we’ll make it easier to see what’s going on in the examples by creating a narrower dataset:

<code>flights2 &lt;- flights %>% </a>
  select(year:day, hour, origin, dest, tailnum, carrier)</a>
flights2</a>
#> # A tibble: 336,776 x 8</a>
#>    year month   day  hour origin dest  tailnum carrier</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>  &lt;chr> &lt;chr>   &lt;chr>  </a>
#> 1  2013     1     1     5 EWR    IAH   N14228  UA     </a>
#> 2  2013     1     1     5 LGA    IAH   N24211  UA     </a>
#> 3  2013     1     1     5 JFK    MIA   N619AA  AA     </a>
#> 4  2013     1     1     5 JFK    BQN   N804JB  B6     </a>
#> 5  2013     1     1     6 LGA    ATL   N668DN  DL     </a>
#> 6  2013     1     1     5 EWR    ORD   N39463  UA     </a>
#> # … with 336,770 more rows</code>

(Remember, when you’re in RStudio, you can also use <code>View()</code> to avoid this problem.)

Imagine you want to add the full airline name to the <code>flights2</code> data. 
You can combine the <code>airlines</code> and <code>flights2</code> data frames with <code>left_join()</code>:

<code>flights2 %>%</a>
  select(-origin, -dest) %>% </a>
  left_join(airlines, by = "carrier")</a>
#> # A tibble: 336,776 x 7</a>
#>    year month   day  hour tailnum carrier name                  </a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>   &lt;chr>   &lt;chr>                 </a>
#> 1  2013     1     1     5 N14228  UA      United Air Lines Inc. 
</a>
#> 2  2013     1     1     5 N24211  UA      United Air Lines Inc. 
</a>
#> 3  2013     1     1     5 N619AA  AA      American Airlines Inc.</a>
#> 4  2013     1     1     5 N804JB  B6      JetBlue Airways       </a>
#> 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc. 
 </a>
#> 6  2013     1     1     5 N39463  UA      United Air Lines Inc. 
</a>
#> # … with 336,770 more rows</code>

The result of joining airlines to flights2 is an additional variable: <code>name</code>. 
This is why I call this type of join a mutating join. 
In this case, you could have got to the same place using <code>mutate()</code> and R’s base subsetting:

<code>flights2 %>%</a>
  select(-origin, -dest) %>% </a>
  mutate(name = airlines$name[match(carrier, airlines$carrier)])</a>
#> # A tibble: 336,776 x 7</a>
#>    year month   day  hour tailnum carrier name                  </a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>   &lt;chr>   &lt;chr>                 </a>
#> 1  2013     1     1     5 N14228  UA      United Air Lines Inc. 
</a>
#> 2  2013     1     1     5 N24211  UA      United Air Lines Inc. 
</a>
#> 3  2013     1     1     5 N619AA  AA      American Airlines Inc.</a>
#> 4  2013     1     1     5 N804JB  B6      JetBlue Airways       </a>
#> 5  2013     1     1     6 N668DN  DL      Delta Air Lines Inc. 
 </a>
#> 6  2013     1     1     5 N39463  UA      United Air Lines Inc. 
</a>
#> # … with 336,770 more rows</code>

But this is hard to generalise when you need to match multiple variables, and takes close reading to figure out the overall intent.

The following sections explain, in detail, how mutating joins work. 
You’ll start by learning a useful visual representation of joins. 
We’ll then use that to explain the four mutating join functions: the inner join, and the three outer joins. 
When working with real data, keys don’t always uniquely identify observations, so next we’ll talk about what happens when there isn’t a unique match. 
Finally, you’ll learn how to tell dplyr which variables are the keys for a given join.

<h3>13.4.1 Understanding joins</h3>
To help you learn how joins work, I’m going to use a visual representation:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/108c0749d084c03103f8e1e8276c20e06357b124/5f113/diagrams/join-setup.png" width="118" style="display: block; margin: auto;" />

<code>x &lt;- tribble(</a>
  ~key, ~val_x,</a>
     1, "x1",</a>
     2, "x2",</a>
     3, "x3"</a>
)</a>
y &lt;- tribble(</a>
  ~key, ~val_y,</a>
     1, "y1",</a>
     2, "y2",</a>
     4, "y3"</a>
)</code>

The coloured column represents the 'key' variable: these are used to match the rows between the tables. 
The grey column represents the 'value' column that is carried along for the ride. 
In these examples I’ll show a single key variable, but the idea generalises in a straightforward way to multiple keys and multiple values.

A join is a way of connecting each row in <code>x</code> to zero, one, or more rows in <code>y</code>. 
The following diagram shows each potential match as an intersection of a pair of lines.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/820b012580731f2134f90ee9c6388994c2343683/27703/diagrams/join-setup2.png" width="166" style="display: block; margin: auto;" />

(If you look closely, you might notice that we’ve switched the order of the key and value columns in <code>x</code>. 
This is to emphasise that joins match based on the key; the value is just carried along for the ride.)

In an actual join, matches will be indicated with dots. 
The number of dots = the number of matches = the number of rows in the output.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3abea0b730526c3f053a3838953c35a0ccbe8980/7f29b/diagrams/join-inner.png" width="338" style="display: block; margin: auto;" />

<h3>13.4.2 Inner join</h3>
The simplest type of join is the inner join. 
An inner join matches pairs of observations whenever their keys are equal:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3abea0b730526c3f053a3838953c35a0ccbe8980/7f29b/diagrams/join-inner.png" width="338" style="display: block; margin: auto;" />

(To be precise, this is an inner equijoin because the keys are matched using the equality operator. 
Since most joins are equijoins we usually drop that specification.)

The output of an inner join is a new data frame that contains the key, the x values, and the y values. 
We use <code>by</code> to tell dplyr which variable is the key:

<code>x %>% </a>
  inner_join(y, by = "key")</a>
#> # A tibble: 2 x 3</a>
#>     key val_x val_y</a>
#>   &lt;dbl> &lt;chr> &lt;chr></a>
#> 1     1 x1    y1   </a>
#> 2     2 x2    y2</code>

The most important property of an inner join is that unmatched rows are not included in the result. 
This means that generally inner joins are usually not appropriate for use in analysis because it’s too easy to lose observations.

<h3>13.4.3 Outer joins</h3>
An inner join keeps observations that appear in both tables. 
An outer join keeps observations that appear in at least one of the tables. 
There are three types of outer joins:

A left join keeps all observations in <code>x</code>.

A right join keeps all observations in <code>y</code>.

A full join keeps all observations in <code>x</code> and <code>y</code>.

These joins work by adding an additional 'virtual' observation to each table. 
This observation has a key that always matches (if no other key matches), and a value filled with <code>NA</code>.

Graphically, that looks like:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9c12ca9e12ed26a7c5d2aa08e36d2ac4fb593f1e/79980/diagrams/join-outer.png" width="355" style="display: block; margin: auto;" />

The most commonly used join is the left join: you use this whenever you look up additional data from another table, because it preserves the original observations even when there isn’t a match. 
The left join should be your default join: use it unless you have a strong reason to prefer one of the others.

Another way to depict the different types of joins is with a Venn diagram:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/aeab386461820b029b7e7606ccff1286f623bae1/ef0d4/diagrams/join-venn.png" width="551" style="display: block; margin: auto;" />

However, this is not a great representation. 
It might jog your memory about which join preserves the observations in which table, but it suffers from a major limitation: a Venn diagram can’t show what happens when keys don’t uniquely identify an observation.

<h3>13.4.4 Duplicate keys</h3>
So far all the diagrams have assumed that the keys are unique. 
But that’s not always the case. 
This section explains what happens when the keys are not unique. 
There are two possibilities:

One table has duplicate keys. 
This is useful when you want to
add in additional information as there is typically a one-to-many
relationship.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6faac3e996263827cb57fc5803df6192541a9a4b/c7d74/diagrams/join-one-to-many.png" width="279" style="display: block; margin: auto;" />

Note that I’ve put the key column in a slightly different position
in the output. 
This reflects that the key is a primary key in <code>y</code>
and a foreign key in <code>x</code>.

<code>x &lt;- tribble(</a>
  ~key, ~val_x,</a>
     1, "x1",</a>
     2, "x2",</a>
     2, "x3",</a>
     1, "x4"</a>
)</a>
y &lt;- tribble(</a>
  ~key, ~val_y,</a>
     1, "y1",</a>
     2, "y2"</a>
)</a>
left_join(x, y, by = "key")</a>
#> # A tibble: 4 x 3</a>
#>     key val_x val_y</a>
#>   &lt;dbl> &lt;chr> &lt;chr></a>
#> 1     1 x1    y1   </a>
#> 2     2 x2    y2   </a>
#> 3     2 x3    y2   </a>
#> 4     1 x4    y1</code>

Both tables have duplicate keys. 
This is usually an error because in
neither table do the keys uniquely identify an observation. 
When you join
duplicated keys, you get all possible combinations, the Cartesian product:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d37530bbf7749f48c02684013ae72b2996b07e25/37510/diagrams/join-many-to-many.png" width="342" style="display: block; margin: auto;" />

<code>x &lt;- tribble(</a>
  ~key, ~val_x,</a>
     1, "x1",</a>
     2, "x2",</a>
     2, "x3",</a>
     3, "x4"</a>
)</a>
y &lt;- tribble(</a>
  ~key, ~val_y,</a>
     1, "y1",</a>
     2, "y2",</a>
     2, "y3",</a>
     3, "y4"</a>
)</a>
left_join(x, y, by = "key")</a>
#> # A tibble: 6 x 3</a>
#>     key val_x val_y</a>
#>   &lt;dbl> &lt;chr> &lt;chr></a>
#> 1     1 x1    y1   </a>
#> 2     2 x2    y2   </a>
#> 3     2 x2    y3   </a>
#> 4     2 x3    y2   </a>
#> 5     2 x3    y3   </a>
#> 6     3 x4    y4</code>

<h3>13.4.5 Defining the key columns</h3>
So far, the pairs of tables have always been joined by a single variable, and that variable has the same name in both tables. 
That constraint was encoded by <code>by = "key"</code>. 
You can use other values for <code>by</code> to connect the tables in other ways:

The default, <code>by = NULL</code>, uses all variables that appear in both tables,
the so called natural join. 
For example, the flights and weather tables
match on their common variables: <code>year</code>, <code>month</code>, <code>day</code>, <code>hour</code> and
<code>origin</code>.

<code>flights2 %>% </a>
  left_join(weather)</a>
#> Joining, by = c("year", "month", "day", "hour", "origin")</a>
#> # A tibble: 336,776 x 18</a>
#>    year month   day  hour origin dest  tailnum carrier  temp  dewp humid</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>  &lt;chr> &lt;chr>   &lt;chr>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  2013     1     1     5 EWR    IAH   N14228  UA       39.0  28.0  64.4</a>
#> 2  2013     1     1     5 LGA    IAH   N24211  UA       39.9  25.0  54.8</a>
#> 3  2013     1     1     5 JFK    MIA   N619AA  AA       39.0  27.0  61.6</a>
#> 4  2013     1     1     5 JFK    BQN   N804JB  B6       39.0  27.0  61.6</a>
#> 5  2013     1     1     6 LGA    ATL   N668DN  DL       39.9  25.0  54.8</a>
#> 6  2013     1     1     5 EWR    ORD   N39463  UA       39.0  28.0  64.4</a>
#> # … with 336,770 more rows, and 7 more variables: wind_dir &lt;dbl>,</a>
#> #   wind_speed &lt;dbl>, wind_gust &lt;dbl>, precip &lt;dbl>, pressure &lt;dbl>,</a>
#> #   visib &lt;dbl>, time_hour &lt;dttm></code>

A character vector, <code>by = "x"</code>. 
This is like a natural join, but uses only
some of the common variables. 
For example, <code>flights</code> and <code>planes</code> have
<code>year</code> variables, but they mean different things so we only want to join by
<code>tailnum</code>.

<code>flights2 %>% </a>
  left_join(planes, by = "tailnum")</a>
#> # A tibble: 336,776 x 16</a>
#>   year.x month   day  hour origin dest  tailnum carrier year.y type </a>
#>    &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>  &lt;chr> &lt;chr>   &lt;chr>    &lt;int> &lt;chr></a>
#> 1   2013     1     1     5 EWR    IAH   N14228  UA        1999 Fixe…</a>
#> 2   2013     1     1     5 LGA    IAH   N24211  UA        1998 Fixe…</a>
#> 3   2013     1     1     5 JFK    MIA   N619AA  AA        1990 Fixe…</a>
#> 4   2013     1     1     5 JFK    BQN   N804JB  B6        2012 Fixe…</a>
#> 5   2013     1     1     6 LGA    ATL   N668DN  DL        1991 Fixe…</a>
#> 6   2013     1     1     5 EWR    ORD   N39463  UA        2012 Fixe…</a>
#> # … with 336,770 more rows, and 6 more variables: manufacturer &lt;chr>,</a>
#> #   model &lt;chr>, engines &lt;int>, seats &lt;int>, speed &lt;int>, engine &lt;chr></code>

Note that the <code>year</code> variables (which appear in both input data frames,
but are not constrained to be equal) are disambiguated in the output with
a suffix.

A named character vector: <code>by = c("a" = "b")</code>. 
This will
match variable <code>a</code> in table <code>x</code> to variable <code>b</code> in table <code>y</code>. 
The
variables from <code>x</code> will be used in the output.

For example, if we want to draw a map we need to combine the flights data
with the airports data which contains the location (<code>lat</code> and <code>lon</code>) of
each airport. 
Each flight has an origin and destination <code>airport</code>, so we
need to specify which one we want to join to:

<code>flights2 %>% </a>
  left_join(airports, c("dest" = "faa"))</a>
#> # A tibble: 336,776 x 15</a>
#>    year month   day  hour origin dest  tailnum carrier name    lat   lon   alt</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>  &lt;chr> &lt;chr>   &lt;chr>   &lt;chr> &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  2013     1     1     5 EWR    IAH   N14228  UA      Geor…  30.0 -95.3    97</a>
#> 2  2013     1     1     5 LGA    IAH   N24211  UA      Geor…  30.0 -95.3    97</a>
#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      Miam…  25.8 -80.3     8</a>
#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      &lt;NA>   NA    NA      NA</a>
#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      Hart…  33.6 -84.4  1026</a>
#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Chic…  42.0 -87.9   668</a>
#> # … with 336,770 more rows, and 3 more variables: tz &lt;dbl>, dst &lt;chr>,</a>
#> #   tzone &lt;chr></a>
</a>
flights2 %>% </a>
  left_join(airports, c("origin" = "faa"))</a>
#> # A tibble: 336,776 x 15</a>
#>    year month   day  hour origin dest  tailnum carrier name    lat   lon   alt</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl> &lt;chr>  &lt;chr> &lt;chr>   &lt;chr>   &lt;chr> &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  2013     1     1     5 EWR    IAH   N14228  UA      Newa…  40.7 -74.2    18</a>
#> 2  2013     1     1     5 LGA    IAH   N24211  UA      La G…  40.8 -73.9    22</a>
#> 3  2013     1     1     5 JFK    MIA   N619AA  AA      John…  40.6 -73.8    13</a>
#> 4  2013     1     1     5 JFK    BQN   N804JB  B6      John…  40.6 -73.8    13</a>
#> 5  2013     1     1     6 LGA    ATL   N668DN  DL      La G…  40.8 -73.9    22</a>
#> 6  2013     1     1     5 EWR    ORD   N39463  UA      Newa…  40.7 -74.2    18</a>
#> # … with 336,770 more rows, and 3 more variables: tz &lt;dbl>, dst &lt;chr>,</a>
#> #   tzone &lt;chr></code>

<h3>13.4.6 Exercises</h3>

Compute the average delay by destination, then join on the <code>airports</code>
data frame so you can show the spatial distribution of delays. 
Here’s an
easy way to draw a map of the United States:

<code>airports %>%</a>
  semi_join(flights, c("faa" = "dest")) %>%</a>
  ggplot(aes(lon, lat)) +</a>
    borders("state") +</a>
    geom_point() +</a>
    coord_quickmap()</code>

(Don’t worry if you don’t understand what <code>semi_join()</code> does — you’ll
learn about it next.)

You might want to use the <code>size</code> or <code>colour</code> of the points to display
the average delay for each airport.

Add the location of the origin <em>and</em> destination (i.e. the <code>lat</code> and <code>lon</code>)
to <code>flights</code>.

Is there a relationship between the age of a plane and its delays?

What weather conditions make it more likely to see a delay?

What happened on June 13 2013? Display the spatial pattern of delays,
and then use Google to cross-reference with the weather.

<h3>13.4.7 Other implementations</h3>
<code>base::merge()</code> can perform all four types of mutating join:

<table>
<thead>
<tr class="header">
<th>dplyr</th>
<th>merge</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inner_join(x, y)</code></td>
<td><code>merge(x, y)</code></td>
</tr>
<tr class="even">
<td><code>left_join(x, y)</code></td>
<td><code>merge(x, y, all.x = TRUE)</code></td>
</tr>
<tr class="odd">
<td><code>right_join(x, y)</code></td>
<td><code>merge(x, y, all.y = TRUE)</code>,</td>
</tr>
<tr class="even">
<td><code>full_join(x, y)</code></td>
<td><code>merge(x, y, all.x = TRUE, all.y = TRUE)</code></td>
</tr>
</tbody>
</table>
The advantages of the specific dplyr verbs is that they more clearly convey the intent of your code: the difference between the joins is really important but concealed in the arguments of <code>merge()</code>. 
dplyr’s joins are considerably faster and don’t mess with the order of the rows.

SQL is the inspiration for dplyr’s conventions, so the translation is straightforward:

<table>
<thead>
<tr class="header">
<th>dplyr</th>
<th>SQL</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>inner_join(x, y, by = "z")</code></td>
<td><code>SELECT * FROM x INNER JOIN y USING (z)</code></td>
</tr>
<tr class="even">
<td><code>left_join(x, y, by = "z")</code></td>
<td><code>SELECT * FROM x LEFT OUTER JOIN y USING (z)</code></td>
</tr>
<tr class="odd">
<td><code>right_join(x, y, by = "z")</code></td>
<td><code>SELECT * FROM x RIGHT OUTER JOIN y USING (z)</code></td>
</tr>
<tr class="even">
<td><code>full_join(x, y, by = "z")</code></td>
<td><code>SELECT * FROM x FULL OUTER JOIN y USING (z)</code></td>
</tr>
</tbody>
</table>
Note that 'INNER' and 'OUTER' are optional, and often omitted.

Joining different variables between the tables, e.g. 
<code>inner_join(x, y, by = c("a" = "b"))</code> uses a slightly different syntax in SQL: <code>SELECT * FROM x INNER JOIN y ON x.a = y.b</code>. 
As this syntax suggests, SQL supports a wider range of join types than dplyr because you can connect the tables using constraints other than equality (sometimes called non-equijoins).

<h2>13.5 Filtering joins</h2>
Filtering joins match observations in the same way as mutating joins, but affect the observations, not the variables. 
There are two types:

<code>semi_join(x, y)</code> keeps all observations in <code>x</code> that have a match in <code>y</code>.

<code>anti_join(x, y)</code> drops all observations in <code>x</code> that have a match in <code>y</code>.

Semi-joins are useful for matching filtered summary tables back to the original rows. 
For example, imagine you’ve found the top ten most popular destinations:

<code>top_dest &lt;- flights %>%</a>
  count(dest, sort = TRUE) %>%</a>
  head(10)</a>
top_dest</a>
#> # A tibble: 10 x 2</a>
#>   dest      n</a>
#>   &lt;chr> &lt;int></a>
#> 1 ORD   17283</a>
#> 2 ATL   17215</a>
#> 3 LAX   16174</a>
#> 4 BOS   15508</a>
#> 5 MCO   14082</a>
#> 6 CLT   14064</a>
#> # … with 4 more rows</code>

Now you want to find each flight that went to one of those destinations. 
You could construct a filter yourself:

<code>flights %>% </a>
  filter(dest %in% top_dest$dest)</a>
#> # A tibble: 141,145 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      542            540         2      923            850</a>
#> 2  2013     1     1      554            600        -6      812            837</a>
#> 3  2013     1     1      554            558        -4      740            728</a>
#> 4  2013     1     1      555            600        -5      913            854</a>
#> 5  2013     1     1      557            600        -3      838            846</a>
#> 6  2013     1     1      558            600        -2      753            745</a>
#> # … with 141,139 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

But it’s difficult to extend that approach to multiple variables. 
For example, imagine that you’d found the 10 days with highest average delays. 
How would you construct the filter statement that used <code>year</code>, <code>month</code>, and <code>day</code> to match it back to <code>flights</code>?

Instead you can use a semi-join, which connects the two tables like a mutating join, but instead of adding new columns, only keeps the rows in <code>x</code> that have a match in <code>y</code>:

<code>flights %>% </a>
  semi_join(top_dest)</a>
#> Joining, by = "dest"</a>
#> # A tibble: 141,145 x 19</a>
#>    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time</a>
#>   &lt;int> &lt;int> &lt;int>    &lt;int>          &lt;int>     &lt;dbl>    &lt;int>          &lt;int></a>
#> 1  2013     1     1      542            540         2      923            850</a>
#> 2  2013     1     1      554            600        -6      812            837</a>
#> 3  2013     1     1      554            558        -4      740            728</a>
#> 4  2013     1     1      555            600        -5      913            854</a>
#> 5  2013     1     1      557            600        -3      838            846</a>
#> 6  2013     1     1      558            600        -2      753            745</a>
#> # … with 141,139 more rows, and 11 more variables: arr_delay &lt;dbl>,</a>
#> #   carrier &lt;chr>, flight &lt;int>, tailnum &lt;chr>, origin &lt;chr>, dest &lt;chr>,</a>
#> #   air_time &lt;dbl>, distance &lt;dbl>, hour &lt;dbl>, minute &lt;dbl>, time_hour &lt;dttm></code>

Graphically, a semi-join looks like this:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/028065a7f353a932d70d2dfc82bc5c5966f768ad/85a30/diagrams/join-semi.png" width="307" style="display: block; margin: auto;" />

Only the existence of a match is important; it doesn’t matter which observation is matched. 
This means that filtering joins never duplicate rows like mutating joins do:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e1d0283160251afaeca35cba216736eb995fee00/1b3cd/diagrams/join-semi-many.png" width="312" style="display: block; margin: auto;" />

The inverse of a semi-join is an anti-join. 
An anti-join keeps the rows that <em>don’t</em> have a match:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f29a85efd53a079cc84c14ba4ba6894e238c3759/c1408/diagrams/join-anti.png" width="307" style="display: block; margin: auto;" />

Anti-joins are useful for diagnosing join mismatches. 
For example, when connecting <code>flights</code> and <code>planes</code>, you might be interested to know that there are many <code>flights</code> that don’t have a match in <code>planes</code>:

<code>flights %>%</a>
  anti_join(planes, by = "tailnum") %>%</a>
  count(tailnum, sort = TRUE)</a>
#> # A tibble: 722 x 2</a>
#>   tailnum     n</a>
#>   &lt;chr>   &lt;int></a>
#> 1 &lt;NA>     2512</a>
#> 2 N725MQ    575</a>
#> 3 N722MQ    513</a>
#> 4 N723MQ    507</a>
#> 5 N713MQ    483</a>
#> 6 N735MQ    396</a>
#> # … with 716 more rows</code>

<h3>13.5.1 Exercises</h3>

What does it mean for a flight to have a missing <code>tailnum</code>? What do the
tail numbers that don’t have a matching record in <code>planes</code> have in common?
(Hint: one variable explains ~90% of the problems.)

Filter flights to only show flights with planes that have flown at least 100
flights.

Combine <code>fueleconomy::vehicles</code> and <code>fueleconomy::common</code> to find only the
records for the most common models.

Find the 48 hours (over the course of the whole year) that have the worst
delays. 
Cross-reference it with the <code>weather</code> data. 
Can you see any
patterns?

What does <code>anti_join(flights, airports, by = c("dest" = "faa"))</code> tell you?
What does <code>anti_join(airports, flights, by = c("faa" = "dest"))</code> tell you?

You might expect that there’s an implicit relationship between plane
and airline, because each plane is flown by a single airline. 
Confirm
or reject this hypothesis using the tools you’ve learned above.

<h2>13.6 Join problems</h2>
The data you’ve been working with in this chapter has been cleaned up so that you’ll have as few problems as possible. 
Your own data is unlikely to be so nice, so there are a few things that you should do with your own data to make your joins go smoothly.

Start by identifying the variables that form the primary key in each table.
You should usually do this based on your understanding of the data, not
empirically by looking for a combination of variables that give a
unique identifier. 
If you just look for variables without thinking about
what they mean, you might get (un)lucky and find a combination that’s
unique in your current data but the relationship might not be true in
general.

For example, the altitude and longitude uniquely identify each airport,
but they are not good identifiers!

<code>airports %>% count(alt, lon) %>% filter(n > 1)</a>
#> # A tibble: 0 x 3</a>
#> # … with 3 variables: alt &lt;dbl>, lon &lt;dbl>, n &lt;int></code>

Check that none of the variables in the primary key are missing. 
If
a value is missing then it can’t identify an observation!

Check that your foreign keys match primary keys in another table. 
The
best way to do this is with an <code>anti_join()</code>. 
It’s common for keys
not to match because of data entry errors. 
Fixing these is often a lot of
work.

If you do have missing keys, you’ll need to be thoughtful about your
use of inner vs. outer joins, carefully considering whether or not you
want to drop rows that don’t have a match.

Be aware that simply checking the number of rows before and after the join is not sufficient to ensure that your join has gone smoothly. 
If you have an inner join with duplicate keys in both tables, you might get unlucky as the number of dropped rows might exactly equal the number of duplicated rows!

<h2>13.7 Set operations</h2>
The final type of two-table verb are the set operations. 
Generally, I use these the least frequently, but they are occasionally useful when you want to break a single complex filter into simpler pieces. 
All these operations work with a complete row, comparing the values of every variable. 
These expect the <code>x</code> and <code>y</code> inputs to have the same variables, and treat the observations like sets:

<code>intersect(x, y)</code>: return only observations in both <code>x</code> and <code>y</code>.

<code>union(x, y)</code>: return unique observations in <code>x</code> and <code>y</code>.

<code>setdiff(x, y)</code>: return observations in <code>x</code>, but not in <code>y</code>.

Given this simple data:

<code>df1 &lt;- tribble(</a>
  ~x, ~y,</a>
   1,  1,</a>
   2,  1</a>
)</a>
df2 &lt;- tribble(</a>
  ~x, ~y,</a>
   1,  1,</a>
   1,  2</a>
)</code>

The four possibilities are:

<code>intersect(df1, df2)</a>
#> # A tibble: 1 x 2</a>
#>       x     y</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     1     1</a>
</a>
# Note that we get 3 rows, not 4</a>
union(df1, df2)</a>
#> # A tibble: 3 x 2</a>
#>       x     y</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     1     1</a>
#> 2     2     1</a>
#> 3     1     2</a>
</a>
setdiff(df1, df2)</a>
#> # A tibble: 1 x 2</a>
#>       x     y</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     2     1</a>
</a>
setdiff(df2, df1)</a>
#> # A tibble: 1 x 2</a>
#>       x     y</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     1     2</code>

<h2><span class="orange">14 Strings</span></h2>

<h2>14.1 Introduction</h2>
This chapter introduces you to string manipulation in R. 
You’ll learn the basics of how strings work and how to create them by hand, but the focus of this chapter will be on regular expressions, or regexps for short. 
Regular expressions are useful because strings usually contain unstructured or semi-structured data, and regexps are a concise language for describing patterns in strings. 
When you first look at a regexp, you’ll think a cat walked across your keyboard, but as your understanding improves they will soon start to make sense.

<h3>14.1.1 Prerequisites</h3>
This chapter will focus on the stringr package for string manipulation, which is part of the core tidyverse.

<code>library(tidyverse)</code>

<h2>14.2 String basics</h2>
You can create strings with either single quotes or double quotes. 
Unlike other languages, there is no difference in behaviour. 
I recommend always using <code>"</code>, unless you want to create a string that contains multiple <code>"</code>.

<code>string1 &lt;- "This is a string"</a>
string2 &lt;- &#39;If I want to include a "quote" inside a string, I use single quotes&#39;</code>

If you forget to close a quote, you’ll see <code>+</code>, the continuation character:

<code>> "This is a string without a closing quote
+ 
+ 
+ HELP I&#39;M STUCK</code>

If this happen to you, press Escape and try again!

To include a literal single or double quote in a string you can use <code>\</code> to 'escape' it:

<code>double_quote &lt;- "\" # or &#39;"&#39;</a>
single_quote &lt;- &#39;\&#39;&#39; # or "&#39;"</code>

That means if you want to include a literal backslash, you’ll need to double it up: <code>"\\"</code>.

Beware that the printed representation of a string is not the same as string itself, because the printed representation shows the escapes. 
To see the raw contents of the string, use <code>writeLines()</code>:

<code>x &lt;- c("\", "\\")</a>
x</a>
#> [1] "\" "\\"</a>
writeLines(x)</a>
#> "</a>
#> \</code>

There are a handful of other special characters. 
The most common are <code>"\n"</code>, newline, and <code>"\t"</code>, tab, but you can see the complete list by requesting help on <code>"</code>: <code>?'"'</code>, or <code>?"'"</code>. 
You’ll also sometimes see strings like <code>"\u00b5"</code>, this is a way of writing non-English characters that works on all platforms:

<code>x &lt;- "\u00b5"</a>
x</a>
#> [1] "µ"</code>

Multiple strings are often stored in a character vector, which you can create with <code>c()</code>:

<code>c("one", "two", "three")</a>
#> [1] "one"   "two"   "three"</code>

<h3>14.2.1 String length</h3>
Base R contains many functions to work with strings but we’ll avoid them because they can be inconsistent, which makes them hard to remember. 
Instead we’ll use functions from stringr. 
These have more intuitive names, and all start with <code>str_</code>. 
For example, <code>str_length()</code> tells you the number of characters in a string:

<code>str_length(c("a", "R for data science", NA))</a>
#> [1]  1 18 NA</code>

The common <code>str_</code> prefix is particularly useful if you use RStudio, because typing <code>str_</code> will trigger autocomplete, allowing you to see all stringr functions:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7d1defbecac1e73595c3841f2753a09734dcb0be/0b58f/screenshots/stringr-autocomplete.png" width="70%" style="display: block; margin: auto;" />

<h3>14.2.2 Combining strings</h3>
To combine two or more strings, use <code>str_c()</code>:

<code>str_c("x", "y")</a>
#> [1] "xy"</a>
str_c("x", "y", "z")</a>
#> [1] "xyz"</code>

Use the <code>sep</code> argument to control how they’re separated:

<code>str_c("x", "y", sep = ", ")</a>
#> [1] "x, y"</code>

Like most other functions in R, missing values are contagious. 
If you want them to print as <code>"NA"</code>, use <code>str_replace_na()</code>:

<code>x &lt;- c("abc", NA)</a>
str_c("|-", x, "-|")</a>
#> [1] "|-abc-|" NA</a>
str_c("|-", str_replace_na(x), "-|")</a>
#> [1] "|-abc-|" "|-NA-|"</code>

As shown above, <code>str_c()</code> is vectorised, and it automatically recycles shorter vectors to the same length as the longest:

<code>str_c("prefix-", c("a", "b", "c"), "-suffix")</a>
#> [1] "prefix-a-suffix" "prefix-b-suffix" "prefix-c-suffix"</code>

Objects of length 0 are silently dropped. 
This is particularly useful in conjunction with <code>if</code>:

<code>name &lt;- "Hadley"</a>
time_of_day &lt;- "morning"</a>
birthday &lt;- FALSE</a>
</a>
str_c(</a>
  "Good ", time_of_day, " ", name,</a>
  if (birthday) " and HAPPY BIRTHDAY",</a>
  "."</a>
)</a>
#> [1] "Good morning Hadley."</code>

To collapse a vector of strings into a single string, use <code>collapse</code>:

<code>str_c(c("x", "y", "z"), collapse = ", ")</a>
#> [1] "x, y, z"</code>

<h3>14.2.3 Subsetting strings</h3>
You can extract parts of a string using <code>str_sub()</code>. 
As well as the string, <code>str_sub()</code> takes <code>start</code> and <code>end</code> arguments which give the (inclusive) position of the substring:

<code>x &lt;- c("Apple", "Banana", "Pear")</a>
str_sub(x, 1, 3)</a>
#> [1] "App" "Ban" "Pea"</a>
# negative numbers count backwards from end</a>
str_sub(x, -3, -1)</a>
#> [1] "ple" "ana" "ear"</code>

Note that <code>str_sub()</code> won’t fail if the string is too short: it will just return as much as possible:

<code>str_sub("a", 1, 5)</a>
#> [1] "a"</code>

You can also use the assignment form of <code>str_sub()</code> to modify strings:

<code>str_sub(x, 1, 1) &lt;- str_to_lower(str_sub(x, 1, 1))</a>
x</a>
#> [1] "apple"  "banana" "pear"</code>

<h3>14.2.4 Locales</h3>
Above I used <code>str_to_lower()</code> to change the text to lower case. 
You can also use <code>str_to_upper()</code> or <code>str_to_title()</code>. 
However, changing case is more complicated than it might at first appear because different languages have different rules for changing case. 
You can pick which set of rules to use by specifying a locale:

<code># Turkish has two i&#39;s: with and without a dot, and it</a>
# has a different rule for capitalising them:</a>
str_to_upper(c("i", "ı"))</a>
#> [1] "I" "I"</a>
str_to_upper(c("i", "ı"), locale = "tr")</a>
#> [1] "İ" "I"</code>

The locale is specified as a ISO 639 language code, which is a two or three letter abbreviation. 
If you don’t already know the code for your language, <a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes">Wikipedia</a> has a good list. 
If you leave the locale blank, it will use the current locale, as provided by your operating system.

Another important operation that’s affected by the locale is sorting. 
The base R <code>order()</code> and <code>sort()</code> functions sort strings using the current locale. 
If you want robust behaviour across different computers, you may want to use <code>str_sort()</code> and <code>str_order()</code> which take an additional <code>locale</code> argument:

<code>x &lt;- c("apple", "eggplant", "banana")</a>
</a>
str_sort(x, locale = "en")  # English</a>
#> [1] "apple"    "banana"   "eggplant"</a>
</a>
str_sort(x, locale = "haw") # Hawaiian</a>
#> [1] "apple"    "eggplant" "banana"</code>

<h3>14.2.5 Exercises</h3>

In code that doesn’t use stringr, you’ll often see <code>paste()</code> and <code>paste0()</code>.
What’s the difference between the two functions? What stringr function are
they equivalent to? How do the functions differ in their handling of
<code>NA</code>?

In your own words, describe the difference between the <code>sep</code> and <code>collapse</code>
arguments to <code>str_c()</code>.

Use <code>str_length()</code> and <code>str_sub()</code> to extract the middle character from
a string. 
What will you do if the string has an even number of characters?

What does <code>str_wrap()</code> do? When might you want to use it?

What does <code>str_trim()</code> do? What’s the opposite of <code>str_trim()</code>?

Write a function that turns (e.g.) a vector <code>c("a", "b", "c")</code> into
the string <code>a, b, and c</code>. 
Think carefully about what it should do if
given a vector of length 0, 1, or 2.

<h2>14.3 Matching patterns with regular expressions</h2>
Regexps are a very terse language that allow you to describe patterns in strings. 
They take a little while to get your head around, but once you understand them, you’ll find them extremely useful.

To learn regular expressions, we’ll use <code>str_view()</code> and <code>str_view_all()</code>. 
These functions take a character vector and a regular expression, and show you how they match. 
We’ll start with very simple regular expressions and then gradually get more and more complicated. 
Once you’ve mastered pattern matching, you’ll learn how to apply those ideas with various stringr functions.

<h3>14.3.1 Basic matches</h3>
The simplest patterns match exact strings:

<code>x &lt;- c("apple", "banana", "pear")</a>
str_view(x, "an")</code>

<script type="application/json" data-for="htmlwidget-ac96cb3ee4656e2e9ec3">{"x":{"html":"\n  apple<\/li>\n  ban<\/span>ana<\/li>\n  pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
The next step up in complexity is <code>.</code>, which matches any character (except a newline):

<code>str_view(x, ".a.")</code>

<script type="application/json" data-for="htmlwidget-e5c8c404fe174e4c81bd">{"x":{"html":"\n  apple<\/li>\n  ban<\/span>ana<\/li>\n  pear<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
But if '<code>.</code>' matches any character, how do you match the character '<code>.</code>'? You need to use an 'escape' to tell the regular expression you want to match it exactly, not use its special behaviour. 
Like strings, regexps use the backslash, <code>\</code>, to escape special behaviour. 
So to match an <code>.</code>, you need the regexp <code>\.</code>. 
Unfortunately this creates a problem. 
We use strings to represent regular expressions, and <code>\</code> is also used as an escape symbol in strings. 
So to create the regular expression <code>\.</code> we need the string <code>"\\."</code>.

<code># To create the regular expression, we need \\</a>
dot &lt;- "\\."</a>
</a>
# But the expression itself only contains one:</a>
writeLines(dot)</a>
#> \.</a>
</a>
# And this tells R to look for an explicit .</a>
str_view(c("abc", "a.c", "bef"), "a\\.c")</code>

<script type="application/json" data-for="htmlwidget-36aa3d2a04d42bbc2145">{"x":{"html":"\n  abc<\/li>\n  a.c<\/span><\/li>\n  bef<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
If <code>\</code> is used as an escape character in regular expressions, how do you match a literal <code>\</code>? Well you need to escape it, creating the regular expression <code>\\</code>. 
To create that regular expression, you need to use a string, which also needs to escape <code>\</code>. 
That means to match a literal <code>\</code> you need to write <code>"\\\\"</code> — you need four backslashes to match one!

<code>x &lt;- "a\\b"</a>
writeLines(x)</a>
#> a\b</a>
</a>
str_view(x, "\\\\")</code>

<script type="application/json" data-for="htmlwidget-febe03efa1a2d8d52a86">{"x":{"html":"\n  a\\<\/span>b<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
In this book, I’ll write regular expression as <code>\.</code> and strings that represent the regular expression as <code>"\\."</code>.

<h4>14.3.1.1 Exercises</h4>

Explain why each of these strings don’t match a <code>\</code>: <code>"\"</code>, <code>"\\"</code>, <code>"\\\"</code>.

How would you match the sequence <code>"'\</code>?

What patterns will the regular expression <code>\..\..\..</code> match?
How would you represent it as a string?

<h3>14.3.2 Anchors</h3>
By default, regular expressions will match any part of a string. 
It’s often useful to <em>anchor</em> the regular expression so that it matches from the start or end of the string. 
You can use:

<code>^</code> to match the start of the string.

<code>$</code> to match the end of the string.

<code>x &lt;- c("apple", "banana", "pear")</a>
str_view(x, "^a")</code>

<script type="application/json" data-for="htmlwidget-1fb4450895fe099f74a1">{"x":{"html":"\n  a<\/span>pple<\/li>\n  banana<\/li>\n  pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, "a$")</code>

<script type="application/json" data-for="htmlwidget-10b3b7155e8045a1b2ad">{"x":{"html":"\n  apple<\/li>\n  banana<\/span><\/li>\n  pear<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
To remember which is which, try this mnemonic which I learned from <a href="https://twitter.com/emisshula/status/323863393167613953">Evan Misshula</a>: if you begin with power (<code>^</code>), you end up with money (<code>$</code>).

To force a regular expression to only match a complete string, anchor it with both <code>^</code> and <code>$</code>:

<code>x &lt;- c("apple pie", "apple", "apple cake")</a>
str_view(x, "apple")</code>

<script type="application/json" data-for="htmlwidget-4018eef1a407a0df6b52">{"x":{"html":"\n  apple<\/span> pie<\/li>\n  apple<\/span><\/li>\n  apple<\/span> cake<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, "^apple$")</code>

<script type="application/json" data-for="htmlwidget-5b1b2f4ad92281566982">{"x":{"html":"\n  apple pie<\/li>\n  apple<\/span><\/li>\n  apple cake<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
You can also match the boundary between words with <code>\b</code>. 
I don’t often use this in R, but I will sometimes use it when I’m doing a search in RStudio when I want to find the name of a function that’s a component of other functions. 
For example, I’ll search for <code>\bsum\b</code> to avoid matching <code>summarise</code>, <code>summary</code>, <code>rowsum</code> and so on.

<h4>14.3.2.1 Exercises</h4>

How would you match the literal string <code>"$^$"</code>?

Given the corpus of common words in <code>stringr::words</code>, create regular
expressions that find all words that:

Start with 'y'.

End with 'x'

Are exactly three letters long. 
(Don’t cheat by using <code>str_length()</code>!)

Have seven letters or more.

Since this list is long, you might want to use the <code>match</code> argument to
<code>str_view()</code> to show only the matching or non-matching words.

<h3>14.3.3 Character classes and alternatives</h3>
There are a number of special patterns that match more than one character. 
You’ve already seen <code>.</code>, which matches any character apart from a newline. 
There are four other useful tools:

<code>\d</code>: matches any digit.

<code>\s</code>: matches any whitespace (e.g. space, tab, newline).

<code>[abc]</code>: matches a, b, or c.

<code>[^abc]</code>: matches anything except a, b, or c.

Remember, to create a regular expression containing <code>\d</code> or <code>\s</code>, you’ll need to escape the <code>\</code> for the string, so you’ll type <code>"\\d"</code> or <code>"\\s"</code>.

A character class containing a single character is a nice alternative to backslash escapes when you want to include a single metacharacter in a regex. 
Many people find this more readable.

<code># Look for a literal character that normally has special meaning in a regex</a>
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")</code>

<script type="application/json" data-for="htmlwidget-25c3e940e6859592f801">{"x":{"html":"\n  abc<\/li>\n  a.c<\/span><\/li>\n  a*c<\/li>\n  a c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")</code>

<script type="application/json" data-for="htmlwidget-3f27c09be0c60bb52829">{"x":{"html":"\n  abc<\/li>\n  a.c<\/li>\n  a*c<\/span><\/li>\n  a c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")</code>

<script type="application/json" data-for="htmlwidget-416566eb193bf50d04e6">{"x":{"html":"\n  abc<\/li>\n  a.c<\/li>\n  a*c<\/li>\n  a <\/span>c<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
This works for most (but not all) regex metacharacters: <code>$</code> <code>.</code> <code>|</code> <code>?</code> <code>*</code> <code>+</code> <code>(</code> <code>)</code> <code>[</code> <code>{</code>. 
Unfortunately, a few characters have special meaning even inside a character class and must be handled with backslash escapes: <code>]</code> <code>\</code> <code>^</code> and <code>-</code>.

You can use <em>alternation</em> to pick between one or more alternative patterns. 
For example, <code>abc|d..f</code> will match either ‘'abc'’, or <code>"deaf"</code>. 
Note that the precedence for <code>|</code> is low, so that <code>abc|xyz</code> matches <code>abc</code> or <code>xyz</code> not <code>abcyz</code> or <code>abxyz</code>. 
Like with mathematical expressions, if precedence ever gets confusing, use parentheses to make it clear what you want:

<code>str_view(c("grey", "gray"), "gr(e|a)y")</code>

<script type="application/json" data-for="htmlwidget-72cbf064100ce560a04c">{"x":{"html":"\n  grey<\/span><\/li>\n  gray<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>

<h4>14.3.3.1 Exercises</h4>

Create regular expressions to find all words that:

Start with a vowel.

That only contain consonants. 
(Hint: thinking about matching
'not'-vowels.)

End with <code>ed</code>, but not with <code>eed</code>.

End with <code>ing</code> or <code>ise</code>.

Empirically verify the rule 'i before e except after c'.

Is 'q' always followed by a 'u'?

Write a regular expression that matches a word if it’s probably written
in British English, not American English.

Create a regular expression that will match telephone numbers as commonly
written in your country.

<h3>14.3.4 Repetition</h3>
The next step up in power involves controlling how many times a pattern matches:

<code>?</code>: 0 or 1

<code>+</code>: 1 or more

<code>*</code>: 0 or more

<code>x &lt;- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"</a>
str_view(x, "CC?")</code>

<script type="application/json" data-for="htmlwidget-d11fc4360aa0230696d7">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, "CC+")</code>

<script type="application/json" data-for="htmlwidget-21c7483268bafca56cec">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, &#39;C[LX]+&#39;)</code>

<script type="application/json" data-for="htmlwidget-1834a22cd196f3aa03a1">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCCCLXXX<\/span>VIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
Note that the precedence of these operators is high, so you can write: <code>colou?r</code> to match either American or British spellings. 
That means most uses will need parentheses, like <code>bana(na)+</code>.

You can also specify the number of matches precisely:

<code>{n}</code>: exactly n

<code>{n,}</code>: n or more

<code>{,m}</code>: at most m

<code>{n,m}</code>: between n and m

<code>str_view(x, "C{2}")</code>

<script type="application/json" data-for="htmlwidget-28515d92cb327f90c9eb">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, "C{2,}")</code>

<script type="application/json" data-for="htmlwidget-0caf26d4e3c00206b0c5">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, "C{2,3}")</code>

<script type="application/json" data-for="htmlwidget-da0b268a2927f570ebf3">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCCC<\/span>LXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
By default these matches are 'greedy': they will match the longest string possible. 
You can make them 'lazy', matching the shortest string possible by putting a <code>?</code> after them. 
This is an advanced feature of regular expressions, but it’s useful to know that it exists:

<code>str_view(x, &#39;C{2,3}?&#39;)</code>

<script type="application/json" data-for="htmlwidget-0ed12bb554391c49c2e3">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCC<\/span>CLXXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(x, &#39;C[LX]+?&#39;)</code>

<script type="application/json" data-for="htmlwidget-ec658d41f8c4f2d124e9">{"x":{"html":"\n  1888 is the longest year in Roman numerals: MDCCCL<\/span>XXXVIII<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>

<h4>14.3.4.1 Exercises</h4>

Describe the equivalents of <code>?</code>, <code>+</code>, <code>*</code> in <code>{m,n}</code> form.

Describe in words what these regular expressions match:
(read carefully to see if I’m using a regular expression or a string
that defines a regular expression.)

<code>^.*$</code>

<code>"\\{.+\\}"</code>

<code>\d{4}-\d{2}-\d{2}</code>

<code>"\\\\{4}"</code>

Create regular expressions to find all words that:

Start with three consonants.

Have three or more vowels in a row.

Have two or more vowel-consonant pairs in a row.

Solve the beginner regexp crosswords at
<a href="https://regexcrossword.com/challenges/beginner" class="uri">https://regexcrossword.com/challenges/beginner</a>.

<h3>14.3.5 Grouping and backreferences</h3>
Earlier, you learned about parentheses as a way to disambiguate complex expressions. 
Parentheses also create a <em>numbered</em> capturing group (number 1, 2 etc.). 
A capturing group stores <em>the part of the string</em> matched by the part of the regular expression inside the parentheses. 
You can refer to the same text as previously matched by a capturing group with <em>backreferences</em>, like <code>\1</code>, <code>\2</code> etc. 
For example, the following regular expression finds all fruits that have a repeated pair of letters.

<code>str_view(fruit, "(..)\\1", match = TRUE)</code>

<script type="application/json" data-for="htmlwidget-6b83523733b890d61edc">{"x":{"html":"\n  banan<\/span>a<\/li>\n  coco<\/span>nut<\/li>\n  cucu<\/span>mber<\/li>\n  juju<\/span>be<\/li>\n  papa<\/span>ya<\/li>\n  salal<\/span> berry<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
(Shortly, you’ll also see how they’re useful in conjunction with <code>str_match()</code>.)

<h4>14.3.5.1 Exercises</h4>

Describe, in words, what these expressions will match:

<code>(.)\1\1</code>

<code>"(.)(.)\\2\\1"</code>

<code>(..)\1</code>

<code>"(.).\\1.\\1"</code>

<code>"(.)(.)(.).*\\3\\2\\1"</code>

Construct regular expressions to match words that:

Start and end with the same character.

Contain a repeated pair of letters
(e.g. 
'church' contains 'ch' repeated twice.)

Contain one letter repeated in at least three places
(e.g. 
'eleven' contains three 'e's.)

<h2>14.4 Tools</h2>
Now that you’ve learned the basics of regular expressions, it’s time to learn how to apply them to real problems. 
In this section you’ll learn a wide array of stringr functions that let you:

Determine which strings match a pattern.

Find the positions of matches.

Extract the content of matches.

Replace matches with new values.

Split a string based on a match.

A word of caution before we continue: because regular expressions are so powerful, it’s easy to try and solve every problem with a single regular expression. 
In the words of Jamie Zawinski:

<blockquote>
Some people, when confronted with a problem, think 'I know, I’ll use regular
expressions.' Now they have two problems.

</blockquote>
As a cautionary tale, check out this regular expression that checks if a email address is valid:

<code>(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)
?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;>@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>
@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"
(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;>@,;:\\".\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;>@,;
:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\"
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;>@,;:\\".\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,
;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|"(?
:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\
".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\["()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".\[\
]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)
?[ \t])*(?:@(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["
()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>
@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,
;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;>@,;:\\".
\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
"()&lt;>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()&lt;>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()&lt;>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(
?:\r\n)?[ \t])*))*)?;\s*)</code>

This is a somewhat pathological example (because email addresses are actually surprisingly complex), but is used in real code. 
See the stackoverflow discussion at <a href="http://stackoverflow.com/a/201378" class="uri">http://stackoverflow.com/a/201378</a> for more details.

Don’t forget that you’re in a programming language and you have other tools at your disposal. 
Instead of creating one complex regular expression, it’s often easier to write a series of simpler regexps. 
If you get stuck trying to create a single regexp that solves your problem, take a step back and think if you could break the problem down into smaller pieces, solving each challenge before moving onto the next one.

<h3>14.4.1 Detect matches</h3>
To determine if a character vector matches a pattern, use <code>str_detect()</code>. 
It returns a logical vector the same length as the input:

<code>x &lt;- c("apple", "banana", "pear")</a>
str_detect(x, "e")</a>
#> [1]  TRUE FALSE  TRUE</code>

Remember that when you use a logical vector in a numeric context, <code>FALSE</code> becomes 0 and <code>TRUE</code> becomes 1. 
That makes <code>sum()</code> and <code>mean()</code> useful if you want to answer questions about matches across a larger vector:

<code># How many common words start with t?</a>
sum(str_detect(words, "^t"))</a>
#> [1] 65</a>
# What proportion of common words end with a vowel?</a>
mean(str_detect(words, "[aeiou]$"))</a>
#> [1] 0.277</code>

When you have complex logical conditions (e.g. match a or b but not c unless d) it’s often easier to combine multiple <code>str_detect()</code> calls with logical operators, rather than trying to create a single regular expression. 
For example, here are two ways to find all words that don’t contain any vowels:

<code># Find all words containing at least one vowel, and negate</a>
no_vowels_1 &lt;- !str_detect(words, "[aeiou]")</a>
# Find all words consisting only of consonants (non-vowels)</a>
no_vowels_2 &lt;- str_detect(words, "^[^aeiou]+$")</a>
identical(no_vowels_1, no_vowels_2)</a>
#> [1] TRUE</code>

The results are identical, but I think the first approach is significantly easier to understand. 
If your regular expression gets overly complicated, try breaking it up into smaller pieces, giving each piece a name, and then combining the pieces with logical operations.

A common use of <code>str_detect()</code> is to select the elements that match a pattern. 
You can do this with logical subsetting, or the convenient <code>str_subset()</code> wrapper:

<code>words[str_detect(words, "x$")]</a>
#> [1] "box" "sex" "six" "tax"</a>
str_subset(words, "x$")</a>
#> [1] "box" "sex" "six" "tax"</code>

Typically, however, your strings will be one column of a data frame, and you’ll want to use filter instead:

<code>df &lt;- tibble(</a>
  word = words, </a>
  i = seq_along(word)</a>
)</a>
df %>% </a>
  filter(str_detect(word, "x$"))</a>
#> # A tibble: 4 x 2</a>
#>   word      i</a>
#>   &lt;chr> &lt;int></a>
#> 1 box     108</a>
#> 2 sex     747</a>
#> 3 six     772</a>
#> 4 tax     841</code>

A variation on <code>str_detect()</code> is <code>str_count()</code>: rather than a simple yes or no, it tells you how many matches there are in a string:

<code>x &lt;- c("apple", "banana", "pear")</a>
str_count(x, "a")</a>
#> [1] 1 3 1</a>
</a>
# On average, how many vowels per word?</a>
mean(str_count(words, "[aeiou]"))</a>
#> [1] 1.99</code>

It’s natural to use <code>str_count()</code> with <code>mutate()</code>:

<code>df %>% </a>
  mutate(</a>
    vowels = str_count(word, "[aeiou]"),</a>
    consonants = str_count(word, "[^aeiou]")</a>
  )</a>
#> # A tibble: 980 x 4</a>
#>   word         i vowels consonants</a>
#>   &lt;chr>    &lt;int>  &lt;int>      &lt;int></a>
#> 1 a            1      1          0</a>
#> 2 able         2      2          2</a>
#> 3 about        3      3          2</a>
#> 4 absolute     4      4          4</a>
#> 5 accept       5      2          4</a>
#> 6 account      6      3          4</a>
#> # … with 974 more rows</code>

Note that matches never overlap. 
For example, in <code>"abababa"</code>, how many times will the pattern <code>"aba"</code> match? Regular expressions say two, not three:

<code>str_count("abababa", "aba")</a>
#> [1] 2</a>
str_view_all("abababa", "aba")</code>

<script type="application/json" data-for="htmlwidget-b3f7c917b6c8ff580948">{"x":{"html":"\n  aba<\/span>baba<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
Note the use of <code>str_view_all()</code>. 
As you’ll shortly learn, many stringr functions come in pairs: one function works with a single match, and the other works with all matches. 
The second function will have the suffix <code>_all</code>.

<h4>14.4.1.1 Exercises</h4>

For each of the following challenges, try solving it by using both a single
regular expression, and a combination of multiple <code>str_detect()</code> calls.

Find all words that start or end with <code>x</code>.

Find all words that start with a vowel and end with a consonant.

Are there any words that contain at least one of each different
vowel?

What word has the highest number of vowels? What word has the highest
proportion of vowels? (Hint: what is the denominator?)

<h3>14.4.2 Extract matches</h3>
To extract the actual text of a match, use <code>str_extract()</code>. 
To show that off, we’re going to need a more complicated example. 
I’m going to use the <a href="https://en.wikipedia.org/wiki/Harvard_sentences">Harvard sentences</a>, which were designed to test VOIP systems, but are also useful for practicing regexps. 
These are provided in <code>stringr::sentences</code>:

<code>length(sentences)</a>
#> [1] 720</a>
head(sentences)</a>
#> [1] "The birch canoe slid on the smooth planks." </a>
#> [2] "Glue the sheet to the dark blue background."</a>
#> [3] "It&#39;s easy to tell the depth of a well."     </a>
#> [4] "These days a chicken leg is a rare dish."   </a>
#> [5] "Rice is often served in round bowls."       </a>
#> [6] "The juice of lemons makes fine punch."</code>

Imagine we want to find all sentences that contain a colour. 
We first create a vector of colour names, and then turn it into a single regular expression:

<code>colours &lt;- c("red", "orange", "yellow", "green", "blue", "purple")</a>
colour_match &lt;- str_c(colours, collapse = "|")</a>
colour_match</a>
#> [1] "red|orange|yellow|green|blue|purple"</code>

Now we can select the sentences that contain a colour, and then extract the colour to figure out which one it is:

<code>has_colour &lt;- str_subset(sentences, colour_match)</a>
matches &lt;- str_extract(has_colour, colour_match)</a>
head(matches)</a>
#> [1] "blue" "blue" "red"  "red"  "red"  "blue"</code>

Note that <code>str_extract()</code> only extracts the first match. 
We can see that most easily by first selecting all the sentences that have more than 1 match:

<code>more &lt;- sentences[str_count(sentences, colour_match) > 1]</a>
str_view_all(more, colour_match)</code>

<script type="application/json" data-for="htmlwidget-d258b2ee1c304ebe1664">{"x":{"html":"\n  It is hard to erase blue<\/span> or red<\/span> ink.<\/li>\n  The green<\/span> light in the brown box flickered<\/span>.<\/li>\n  The sky in the west is tinged with orange<\/span> red<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code></a>
str_extract(more, colour_match)</a>
#> [1] "blue"   "green"  "orange"</code>

This is a common pattern for stringr functions, because working with a single match allows you to use much simpler data structures. 
To get all matches, use <code>str_extract_all()</code>. 
It returns a list:

<code>str_extract_all(more, colour_match)</a>
#> [[1]]</a>
#> [1] "blue" "red" </a>
#> </a>
#> [[2]]</a>
#> [1] "green" "red"  </a>
#> </a>
#> [[3]]</a>
#> [1] "orange" "red"</code>

You’ll learn more about lists in <a href="vectors.html#lists">lists</a> and <a href="iteration.html#iteration">iteration</a>.

If you use <code>simplify = TRUE</code>, <code>str_extract_all()</code> will return a matrix with short matches expanded to the same length as the longest:

<code>str_extract_all(more, colour_match, simplify = TRUE)</a>
#>      [,1]     [,2] </a>
#> [1,] "blue"   "red"</a>
#> [2,] "green"  "red"</a>
#> [3,] "orange" "red"</a>
</a>
x &lt;- c("a", "a b", "a b c")</a>
str_extract_all(x, "[a-z]", simplify = TRUE)</a>
#>      [,1] [,2] [,3]</a>
#> [1,] "a"  "   "  </a>
#> [2,] "a"  "b"  "  </a>
#> [3,] "a"  "b"  "c"</code>

<h4>14.4.2.1 Exercises</h4>

In the previous example, you might have noticed that the regular
expression matched 'flickered', which is not a colour. 
Modify the
regex to fix the problem.

From the Harvard sentences data, extract:

The first word from each sentence.

All words ending in <code>ing</code>.

All plurals.

<h3>14.4.3 Grouped matches</h3>
Earlier in this chapter we talked about the use of parentheses for clarifying precedence and for backreferences when matching. 
You can also use parentheses to extract parts of a complex match. 
For example, imagine we want to extract nouns from the sentences. 
As a heuristic, we’ll look for any word that comes after 'a' or 'the'. 
Defining a 'word' in a regular expression is a little tricky, so here I use a simple approximation: a sequence of at least one character that isn’t a space.

<code>noun &lt;- "(a|the) ([^ ]+)"</a>
</a>
has_noun &lt;- sentences %>%</a>
  str_subset(noun) %>%</a>
  head(10)</a>
has_noun %>% </a>
  str_extract(noun)</a>
#>  [1] "the smooth" "the sheet"  "the depth"  "a chicken"  "the parked"</a>
#>  [6] "the sun"    "the huge"   "the ball"   "the woman"  "a helps"</code>

<code>str_extract()</code> gives us the complete match; <code>str_match()</code> gives each individual component. 
Instead of a character vector, it returns a matrix, with one column for the complete match followed by one column for each group:

<code>has_noun %>% </a>
  str_match(noun)</a>
#>       [,1]         [,2]  [,3]     </a>
#>  [1,] "the smooth" "the" "smooth" </a>
#>  [2,] "the sheet"  "the" "sheet"  </a>
#>  [3,] "the depth"  "the" "depth"  </a>
#>  [4,] "a chicken"  "a"   "chicken"</a>
#>  [5,] "the parked" "the" "parked" </a>
#>  [6,] "the sun"    "the" "sun"    </a>
#>  [7,] "the huge"   "the" "huge"   </a>
#>  [8,] "the ball"   "the" "ball"   </a>
#>  [9,] "the woman"  "the" "woman"  </a>
#> [10,] "a helps"    "a"   "helps"</code>

(Unsurprisingly, our heuristic for detecting nouns is poor, and also picks up adjectives like smooth and parked.)

If your data is in a tibble, it’s often easier to use <code>tidyr::extract()</code>. 
It works like <code>str_match()</code> but requires you to name the matches, which are then placed in new columns:

<code>tibble(sentence = sentences) %>% </a>
  tidyr::extract(</a>
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", </a>
    remove = FALSE</a>
  )</a>
#> # A tibble: 720 x 3</a>
#>   sentence                                    article noun   </a>
#>   &lt;chr>                                       &lt;chr>   &lt;chr>  </a>
#> 1 The birch canoe slid on the smooth planks. 
 the     smooth </a>
#> 2 Glue the sheet to the dark blue background. 
the     sheet  </a>
#> 3 It&#39;s easy to tell the depth of a well. 
     the     depth  </a>
#> 4 These days a chicken leg is a rare dish. 
   a       chicken</a>
#> 5 Rice is often served in round bowls. 
       &lt;NA>    &lt;NA>   </a>
#> 6 The juice of lemons makes fine punch. 
      &lt;NA>    &lt;NA>   </a>
#> # … with 714 more rows</code>

Like <code>str_extract()</code>, if you want all matches for each string, you’ll need <code>str_match_all()</code>.

<h4>14.4.3.1 Exercises</h4>

Find all words that come after a 'number' like 'one', 'two', 'three' etc.
Pull out both the number and the word.

Find all contractions. 
Separate out the pieces before and after the
apostrophe.

<h3>14.4.4 Replacing matches</h3>
<code>str_replace()</code> and <code>str_replace_all()</code> allow you to replace matches with new strings. 
The simplest use is to replace a pattern with a fixed string:

<code>x &lt;- c("apple", "pear", "banana")</a>
str_replace(x, "[aeiou]", "-")</a>
#> [1] "-pple"  "p-ar"   "b-nana"</a>
str_replace_all(x, "[aeiou]", "-")</a>
#> [1] "-ppl-"  "p--r"   "b-n-n-"</code>

With <code>str_replace_all()</code> you can perform multiple replacements by supplying a named vector:

<code>x &lt;- c("1 house", "2 cars", "3 people")</a>
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))</a>
#> [1] "one house"    "two cars"     "three people"</code>

Instead of replacing with a fixed string you can use backreferences to insert components of the match. 
In the following code, I flip the order of the second and third words.

<code>sentences %>% </a>
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% </a>
  head(5)</a>
#> [1] "The canoe birch slid on the smooth planks." </a>
#> [2] "Glue sheet the to the dark blue background."</a>
#> [3] "It&#39;s to easy tell the depth of a well."     </a>
#> [4] "These a days chicken leg is a rare dish."   </a>
#> [5] "Rice often is served in round bowls."</code>

<h4>14.4.4.1 Exercises</h4>

Replace all forward slashes in a string with backslashes.

Implement a simple version of <code>str_to_lower()</code> using <code>replace_all()</code>.

Switch the first and last letters in <code>words</code>. 
Which of those strings
are still words?

<h3>14.4.5 Splitting</h3>
Use <code>str_split()</code> to split a string up into pieces. 
For example, we could split sentences into words:

<code>sentences %>%</a>
  head(5) %>% </a>
  str_split(" ")</a>
#> [[1]]</a>
#> [1] "The"     "birch"   "canoe"   "slid"    "on"      "the"     "smooth" </a>
#> [8] "planks."</a>
#> </a>
#> [[2]]</a>
#> [1] "Glue"        "the"         "sheet"       "to"          "the"        </a>
#> [6] "dark"        "blue"        "background."</a>
#> </a>
#> [[3]]</a>
#> [1] "It&#39;s"  "easy"  "to"    "tell"  "the"   "depth" "of"    "a"     "well."</a>
#> </a>
#> [[4]]</a>
#> [1] "These"   "days"    "a"       "chicken" "leg"     "is"      "a"      </a>
#> [8] "rare"    "dish."  </a>
#> </a>
#> [[5]]</a>
#> [1] "Rice"   "is"     "often"  "served" "in"     "round"  "bowls."</code>

Because each component might contain a different number of pieces, this returns a list. 
If you’re working with a length-1 vector, the easiest thing is to just extract the first element of the list:

<code>"a|b|c|d" %>% </a>
  str_split("\\|") %>% </a>
  .[[1]]</a>
#> [1] "a" "b" "c" "d"</code>

Otherwise, like the other stringr functions that return a list, you can use <code>simplify = TRUE</code> to return a matrix:

<code>sentences %>%</a>
  head(5) %>% </a>
  str_split(" ", simplify = TRUE)</a>
#>      [,1]    [,2]    [,3]    [,4]      [,5]  [,6]    [,7]     [,8]         </a>
#> [1,] "The"   "birch" "canoe" "slid"    "on"  "the"   "smooth" "planks."    </a>
#> [2,] "Glue"  "the"   "sheet" "to"      "the" "dark"  "blue"   "background."</a>
#> [3,] "It&#39;s"  "easy"  "to"    "tell"    "the" "depth" "of"     "a"          </a>
#> [4,] "These" "days"  "a"     "chicken" "leg" "is"    "a"      "rare"       </a>
#> [5,] "Rice"  "is"    "often" "served"  "in"  "round" "bowls." "           </a>
#>      [,9]   </a>
#> [1,] "     </a>
#> [2,] "     </a>
#> [3,] "well."</a>
#> [4,] "dish."</a>
#> [5,] "</code>

You can also request a maximum number of pieces:

<code>fields &lt;- c("Name: Hadley", "Country: NZ", "Age: 35")</a>
fields %>% str_split(": ", n = 2, simplify = TRUE)</a>
#>      [,1]      [,2]    </a>
#> [1,] "Name"    "Hadley"</a>
#> [2,] "Country" "NZ"    </a>
#> [3,] "Age"     "35"</code>

Instead of splitting up strings by patterns, you can also split up by character, line, sentence and word <code>boundary()</code>s:

<code>x &lt;- "This is a sentence. 
 This is another sentence."</a>
str_view_all(x, boundary("word"))</code>

<script type="application/json" data-for="htmlwidget-b8f31ebacaee3527bb86">{"x":{"html":"\n  This<\/span> is<\/span> a<\/span> sentence<\/span>. 
 This<\/span> is<\/span> another<\/span> sentence<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code></a>
str_split(x, " ")[[1]]</a>
#> [1] "This"      "is"        "a"         "sentence." "          "This"     </a>
#> [7] "is"        "another"   "sentence."</a>
str_split(x, boundary("word"))[[1]]</a>
#> [1] "This"     "is"       "a"        "sentence" "This"     "is"       "another" </a>
#> [8] "sentence"</code>

<h4>14.4.5.1 Exercises</h4>

Split up a string like <code>"apples, pears, and bananas"</code> into individual
components.

Why is it better to split up by <code>boundary("word")</code> than <code>" "</code>?

What does splitting with an empty string (<code>"</code>) do? Experiment, and
then read the documentation.

<h3>14.4.6 Find matches</h3>
<code>str_locate()</code> and <code>str_locate_all()</code> give you the starting and ending positions of each match. 
These are particularly useful when none of the other functions does exactly what you want. 
You can use <code>str_locate()</code> to find the matching pattern, <code>str_sub()</code> to extract and/or modify them.

<h2>14.5 Other types of pattern</h2>
When you use a pattern that’s a string, it’s automatically wrapped into a call to <code>regex()</code>:

<code># The regular call:</a>
str_view(fruit, "nana")</a>
# Is shorthand for</a>
str_view(fruit, regex("nana"))</code>

You can use the other arguments of <code>regex()</code> to control details of the match:

<code>ignore_case = TRUE</code> allows characters to match either their uppercase or
lowercase forms. 
This always uses the current locale.

<code>bananas &lt;- c("banana", "Banana", "BANANA")</a>
str_view(bananas, "banana")</code>

    <script type="application/json" data-for="htmlwidget-b25b670b028f478bf741">{"x":{"html":"\n  banana<\/span><\/li>\n  Banana<\/li>\n  BANANA<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_view(bananas, regex("banana", ignore_case = TRUE))</code>

    <script type="application/json" data-for="htmlwidget-46d1193f7ba074d981c8">{"x":{"html":"\n  banana<\/span><\/li>\n  Banana<\/span><\/li>\n  BANANA<\/span><\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>

<code>multiline = TRUE</code> allows <code>^</code> and <code>$</code> to match the start and end of each
line rather than the start and end of the complete string.

<code>x &lt;- "Line 1\nLine 2\nLine 3"</a>
str_extract_all(x, "^Line")[[1]]</a>
#> [1] "Line"</a>
str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]</a>
#> [1] "Line" "Line" "Line"</code>

<code>comments = TRUE</code> allows you to use comments and white space to make
complex regular expressions more understandable. 
Spaces are ignored, as is
everything after <code>#</code>. 
To match a literal space, you’ll need to escape it:
<code>"\\ "</code>.

<code>phone &lt;- regex("</a>
  \\(?     # optional opening parens</a>
  (\\d{3}) # area code</a>
  [) -]?   # optional closing parens, space, or dash</a>
  (\\d{3}) # another three numbers</a>
  [ -]?    # optional space or dash</a>
  (\\d{3}) # three more numbers</a>
  ", comments = TRUE)</a>
</a>
str_match("514-791-8141", phone)</a>
#>      [,1]          [,2]  [,3]  [,4] </a>
#> [1,] "514-791-814" "514" "791" "814"</code>

<code>dotall = TRUE</code> allows <code>.</code> to match everything, including <code>\n</code>.

There are three other functions you can use instead of <code>regex()</code>:

<code>fixed()</code>: matches exactly the specified sequence of bytes. 
It ignores
all special regular expressions and operates at a very low level.
This allows you to avoid complex escaping and can be much faster than
regular expressions. 
The following microbenchmark shows that it’s about
3x faster for a simple example.

<code>microbenchmark::microbenchmark(</a>
  fixed = str_detect(sentences, fixed("the")),</a>
  regex = str_detect(sentences, "the"),</a>
  times = 20</a>
)</a>
#> Unit: microseconds</a>
#>   expr   min    lq  mean median    uq max neval</a>
#>  fixed  50.3  53.3  93.6   64.5  83.2 596    20</a>
#>  regex 249.5 253.7 268.8  256.9 260.2 451    20</code>

Beware using <code>fixed()</code> with non-English data. 
It is problematic because
there are often multiple ways of representing the same character. 
For
example, there are two ways to define 'á': either as a single character or
as an 'a' plus an accent:

<code>a1 &lt;- "\u00e1"</a>
a2 &lt;- "a\u0301"</a>
c(a1, a2)</a>
#> [1] "á" "á"</a>
a1 == a2</a>
#> [1] FALSE</code>

They render identically, but because they’re defined differently,
<code>fixed()</code> doesn’t find a match. 
Instead, you can use <code>coll()</code>, defined
next, to respect human character comparison rules:

<code>str_detect(a1, fixed(a2))</a>
#> [1] FALSE</a>
str_detect(a1, coll(a2))</a>
#> [1] TRUE</code>

<code>coll()</code>: compare strings using standard collation rules. 
This is
useful for doing case insensitive matching. 
Note that <code>coll()</code> takes a
<code>locale</code> parameter that controls which rules are used for comparing
characters. 
Unfortunately different parts of the world use different rules!

<code># That means you also need to be aware of the difference</a>
# when doing case insensitive matches:</a>
i &lt;- c("I", "İ", "i", "ı")</a>
i</a>
#> [1] "I" "İ" "i" "ı"</a>
</a>
str_subset(i, coll("i", ignore_case = TRUE))</a>
#> [1] "I" "i"</a>
str_subset(i, coll("i", ignore_case = TRUE, locale = "tr"))</a>
#> [1] "İ" "i"</code>

Both <code>fixed()</code> and <code>regex()</code> have <code>ignore_case</code> arguments, but they
do not allow you to pick the locale: they always use the default locale.
You can see what that is with the following code; more on stringi
later.

<code>stringi::stri_locale_info()</a>
#> $Language</a>
#> [1] "en"</a>
#> </a>
#> $Country</a>
#> [1] "US"</a>
#> </a>
#> $Variant</a>
#> [1] "</a>
#> </a>
#> $Name</a>
#> [1] "en_US"</code>

The downside of <code>coll()</code> is speed; because the rules for recognising which
characters are the same are complicated, <code>coll()</code> is relatively slow
compared to <code>regex()</code> and <code>fixed()</code>.

As you saw with <code>str_split()</code> you can use <code>boundary()</code> to match boundaries.
You can also use it with the other functions:

<code>x &lt;- "This is a sentence."</a>
str_view_all(x, boundary("word"))</code>

    <script type="application/json" data-for="htmlwidget-382a200f56fb8e6a1fd3">{"x":{"html":"\n  This<\/span> is<\/span> a<\/span> sentence<\/span>.<\/li>\n<\/ul>"},"evals":[],"jsHooks":[]}</script>
<code>str_extract_all(x, boundary("word"))</a>
#> [[1]]</a>
#> [1] "This"     "is"       "a"        "sentence"</code>

<h3>14.5.1 Exercises</h3>

How would you find all strings containing <code>\</code> with <code>regex()</code>
vs. with <code>fixed()</code>?

What are the five most common words in <code>sentences</code>?

<h2>14.6 Other uses of regular expressions</h2>
There are two useful function in base R that also use regular expressions:

<code>apropos()</code> searches all objects available from the global environment. 
This
is useful if you can’t quite remember the name of the function.

<code>apropos("replace")</a>
#> [1] "%+replace%"       "replace"          "replace_na"       "setReplaceMethod"</a>
#> [5] "str_replace"      "str_replace_all"  "str_replace_na"   "theme_replace"</code>

<code>dir()</code> lists all the files in a directory. 
The <code>pattern</code> argument takes
a regular expression and only returns file names that match the pattern.
For example, you can find all the R Markdown files in the current
directory with:

<code>head(dir(pattern = "\\.Rmd$"))</a>
#> [1] "communicate-plots.Rmd" "communicate.Rmd"       "datetimes.Rmd"        </a>
#> [4] "EDA.Rmd"               "explore.Rmd"           "factors.Rmd"</code>

(If you’re more comfortable with 'globs' like <code>*.Rmd</code>, you can convert
them to regular expressions with <code>glob2rx()</code>):

<h2>14.7 stringi</h2>
stringr is built on top of the stringi package. 
stringr is useful when you’re learning because it exposes a minimal set of functions, which have been carefully picked to handle the most common string manipulation functions. 
stringi, on the other hand, is designed to be comprehensive. 
It contains almost every function you might ever need: stringi has 244 functions to stringr’s 49.

If you find yourself struggling to do something in stringr, it’s worth taking a look at stringi. 
The packages work very similarly, so you should be able to translate your stringr knowledge in a natural way. 
The main difference is the prefix: <code>str_</code> vs. 
<code>stri_</code>.

<h3>14.7.1 Exercises</h3>

Find the stringi functions that:

Count the number of words.

Find duplicated strings.

Generate random text.

How do you control the language that <code>stri_sort()</code> uses for
sorting?

<h2><span class="orange">15 Factors</span></h2>

<h2>15.1 Introduction</h2>
In R, factors are used to work with categorical variables, variables that have a fixed and known set of possible values. 
They are also useful when you want to display character vectors in a non-alphabetical order.

Historically, factors were much easier to work with than characters. 
As a result, many of the functions in base R automatically convert characters to factors. 
This means that factors often crop up in places where they’re not actually helpful. 
Fortunately, you don’t need to worry about that in the tidyverse, and can focus on situations where factors are genuinely useful.

<h3>15.1.1 Prerequisites</h3>
To work with factors, we’ll use the forcats package, which is part of the core tidyverse. 
It provides tools for dealing with categorical variables (and it’s an anagram of factors!) using a wide range of helpers for working with factors.

<code>library(tidyverse)</code>

<h3>15.1.2 Learning more</h3>
If you want to learn more about factors, I recommend reading Amelia McNamara and Nicholas Horton’s paper, <a href="https://peerj.com/preprints/3163/"><em>Wrangling categorical data in R</em></a>. 
This paper lays out some of the history discussed in <a href="http://simplystatistics.org/2015/07/24/stringsasfactors-an-unauthorized-biography/"><em>stringsAsFactors: An unauthorized biography</em></a> and <a href="http://notstatschat.tumblr.com/post/124987394001/stringsasfactors-sigh"><em>stringsAsFactors = &lt;sigh></em></a>, and compares the tidy approaches to categorical data outlined in this book with base R methods. 
An early version of the paper help motivate and scope the forcats package; thanks Amelia &amp; Nick!

<h2>15.2 Creating factors</h2>
Imagine that you have a variable that records month:

<code>x1 &lt;- c("Dec", "Apr", "Jan", "Mar")</code>

Using a string to record this variable has two problems:

There are only twelve possible months, and there’s nothing saving you
from typos:

<code>x2 &lt;- c("Dec", "Apr", "Jam", "Mar")</code>

It doesn’t sort in a useful way:

<code>sort(x1)</a>
#> [1] "Apr" "Dec" "Jan" "Mar"</code>

You can fix both of these problems with a factor. 
To create a factor you must start by creating a list of the valid levels:

<code>month_levels &lt;- c(</a>
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", </a>
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"</a>
)</code>

Now you can create a factor:

<code>y1 &lt;- factor(x1, levels = month_levels)</a>
y1</a>
#> [1] Dec Apr Jan Mar</a>
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</a>
sort(y1)</a>
#> [1] Jan Mar Apr Dec</a>
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code>

And any values not in the set will be silently converted to NA:

<code>y2 &lt;- factor(x2, levels = month_levels)</a>
y2</a>
#> [1] Dec  Apr  &lt;NA> Mar </a>
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code>

If you want a warning, you can use <code>readr::parse_factor()</code>:

<code>y2 &lt;- parse_factor(x2, levels = month_levels)</a>
#> Warning: 1 parsing failure.</a>
#> row col           expected actual</a>
#>   3  -- value in level set    Jam</code>

If you omit the levels, they’ll be taken from the data in alphabetical order:

<code>factor(x1)</a>
#> [1] Dec Apr Jan Mar</a>
#> Levels: Apr Dec Jan Mar</code>

Sometimes you’d prefer that the order of the levels match the order of the first appearance in the data. 
You can do that when creating the factor by setting levels to <code>unique(x)</code>, or after the fact, with <code>fct_inorder()</code>:

<code>f1 &lt;- factor(x1, levels = unique(x1))</a>
f1</a>
#> [1] Dec Apr Jan Mar</a>
#> Levels: Dec Apr Jan Mar</a>
</a>
f2 &lt;- x1 %>% factor() %>% fct_inorder()</a>
f2</a>
#> [1] Dec Apr Jan Mar</a>
#> Levels: Dec Apr Jan Mar</code>

If you ever need to access the set of valid levels directly, you can do so with <code>levels()</code>:

<code>levels(f2)</a>
#> [1] "Dec" "Apr" "Jan" "Mar"</code>

<h2>15.3 General Social Survey</h2>
For the rest of this chapter, we’re going to focus on <code>forcats::gss_cat</code>. 
It’s a sample of data from the <a href="http://gss.norc.org">General Social Survey</a>, which is a long-running US survey conducted by the independent research organization NORC at the University of Chicago. 
The survey has thousands of questions, so in <code>gss_cat</code> I’ve selected a handful that will illustrate some common challenges you’ll encounter when working with factors.

<code>gss_cat</a>
#> # A tibble: 21,483 x 9</a>
#>    year marital      age race  rincome    partyid     relig     denom    tvhours</a>
#>   &lt;int> &lt;fct>      &lt;int> &lt;fct> &lt;fct>      &lt;fct>       &lt;fct>     &lt;fct>      &lt;int></a>
#> 1  2000 Never mar…    26 White $8000 to … Ind,near r… Protesta… Souther…      12</a>
#> 2  2000 Divorced      48 White $8000 to … Not str re… Protesta… Baptist…      NA</a>
#> 3  2000 Widowed       67 White Not appli… Independent Protesta… No deno…       2</a>
#> 4  2000 Never mar…    39 White Not appli… Ind,near r… Orthodox… Not app…       4</a>
#> 5  2000 Divorced      25 White Not appli… Not str de… None      Not app…       1</a>
#> 6  2000 Married       25 White $20000 - … Strong dem… Protesta… Souther…      NA</a>
#> # … with 21,477 more rows</code>

(Remember, since this dataset is provided by a package, you can get more information about the variables with <code>?gss_cat</code>.)

When factors are stored in a tibble, you can’t see their levels so easily. 
One way to see them is with <code>count()</code>:

<code>gss_cat %>%</a>
  count(race)</a>
#> # A tibble: 3 x 2</a>
#>   race      n</a>
#>   &lt;fct> &lt;int></a>
#> 1 Other  1959</a>
#> 2 Black  3129</a>
#> 3 White 16395</code>

Or with a bar chart:

<code>ggplot(gss_cat, aes(race)) +</a>
  geom_bar()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1b438e44f3ae67e36b2a498025a97fb7c06cae56/d3739/factors_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" />

By default, ggplot2 will drop levels that don’t have any values. 
You can force them to display with:

<code>ggplot(gss_cat, aes(race)) +</a>
  geom_bar() +</a>
  scale_x_discrete(drop = FALSE)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b97445c864da7ef61cb2d1c387af210d842b9d9f/fbf7e/factors_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" />

These levels represent valid values that simply did not occur in this dataset. 
Unfortunately, dplyr doesn’t yet have a <code>drop</code> option, but it will in the future.

When working with factors, the two most common operations are changing the order of the levels, and changing the values of the levels. 
Those operations are described in the sections below.

<h3>15.3.1 Exercise</h3>

Explore the distribution of <code>rincome</code> (reported income). 
What makes the
default bar chart hard to understand? How could you improve the plot?

What is the most common <code>relig</code> in this survey? What’s the most
common <code>partyid</code>?

Which <code>relig</code> does <code>denom</code> (denomination) apply to? How can you find
out with a table? How can you find out with a visualisation?

<h2>15.4 Modifying factor order</h2>
It’s often useful to change the order of the factor levels in a visualisation. 
For example, imagine you want to explore the average number of hours spent watching TV per day across religions:

<code>relig_summary &lt;- gss_cat %>%</a>
  group_by(relig) %>%</a>
  summarise(</a>
    age = mean(age, na.rm = TRUE),</a>
    tvhours = mean(tvhours, na.rm = TRUE),</a>
    n = n()</a>
  )</a>
</a>
ggplot(relig_summary, aes(tvhours, relig)) + geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/460a04377a25cb23e3f2778bdc7a6318cbbbfff3/46331/factors_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" />

It is difficult to interpret this plot because there’s no overall pattern. 
We can improve it by reordering the levels of <code>relig</code> using <code>fct_reorder()</code>. 
<code>fct_reorder()</code> takes three arguments:

<code>f</code>, the factor whose levels you want to modify.

<code>x</code>, a numeric vector that you want to use to reorder the levels.

Optionally, <code>fun</code>, a function that’s used if there are multiple values of
<code>x</code> for each value of <code>f</code>. 
The default value is <code>median</code>.

<code>ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +</a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a7337cb353cb6e12125487c04de6a332855cf1e0/f25fe/factors_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" />

Reordering religion makes it much easier to see that people in the 'Don’t know' category watch much more TV, and Hinduism &amp; Other Eastern religions watch much less.

As you start making more complicated transformations, I’d recommend moving them out of <code>aes()</code> and into a separate <code>mutate()</code> step. 
For example, you could rewrite the plot above as:

<code>relig_summary %>%</a>
  mutate(relig = fct_reorder(relig, tvhours)) %>%</a>
  ggplot(aes(tvhours, relig)) +</a>
    geom_point()</code>

What if we create a similar plot looking at how average age varies across reported income level?

<code>rincome_summary &lt;- gss_cat %>%</a>
  group_by(rincome) %>%</a>
  summarise(</a>
    age = mean(age, na.rm = TRUE),</a>
    tvhours = mean(tvhours, na.rm = TRUE),</a>
    n = n()</a>
  )</a>
</a>
ggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f9c8925a5301d5d8746b8d4ef7d39db3bc6c490c/11fbb/factors_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

Here, arbitrarily reordering the levels isn’t a good idea! That’s because <code>rincome</code> already has a principled order that we shouldn’t mess with. 
Reserve <code>fct_reorder()</code> for factors whose levels are arbitrarily ordered.

However, it does make sense to pull 'Not applicable' to the front with the other special levels. 
You can use <code>fct_relevel()</code>. 
It takes a factor, <code>f</code>, and then any number of levels that you want to move to the front of the line.

<code>ggplot(rincome_summary, aes(age, fct_relevel(rincome, "Not applicable"))) +</a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a1cf13e815d77f7ed79ef60b6ba842397c1d6ba8/fc13e/factors_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

Why do you think the average age for 'Not applicable' is so high?

Another type of reordering is useful when you are colouring the lines on a plot. 
<code>fct_reorder2()</code> reorders the factor by the <code>y</code> values associated with the largest <code>x</code> values. 
This makes the plot easier to read because the line colours line up with the legend.

<code>by_age &lt;- gss_cat %>%</a>
  filter(!is.na(age)) %>%</a>
  count(age, marital) %>%</a>
  group_by(age) %>%</a>
  mutate(prop = n / sum(n))</a>
</a>
ggplot(by_age, aes(age, prop, colour = marital)) +</a>
  geom_line(na.rm = TRUE)</a>
</a>
ggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +</a>
  geom_line() +</a>
  labs(colour = "marital")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a0e424cf313ebc84c2ba8e2503e3c8822637aab3/fd9e7/factors_files/figure-html/unnamed-chunk-20-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/420864bff72c032441a73361283a2cc9a6b01987/226ef/factors_files/figure-html/unnamed-chunk-20-2.png" width="50%" />

Finally, for bar plots, you can use <code>fct_infreq()</code> to order levels in increasing frequency: this is the simplest type of reordering because it doesn’t need any extra variables. 
You may want to combine with <code>fct_rev()</code>.

<code>gss_cat %>%</a>
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%</a>
  ggplot(aes(marital)) +</a>
    geom_bar()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0c3e62beb3ab30f8413e9ba8e5bed1fdebbe23d1/574aa/factors_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" />

<h3>15.4.1 Exercises</h3>

There are some suspiciously high numbers in <code>tvhours</code>. 
Is the mean a good
summary?

For each factor in <code>gss_cat</code> identify whether the order of the levels is
arbitrary or principled.

Why did moving 'Not applicable' to the front of the levels move it to the
bottom of the plot?

<h2>15.5 Modifying factor levels</h2>
More powerful than changing the orders of the levels is changing their values. 
This allows you to clarify labels for publication, and collapse levels for high-level displays. 
The most general and powerful tool is <code>fct_recode()</code>. 
It allows you to recode, or change, the value of each level. 
For example, take the <code>gss_cat$partyid</code>:

<code>gss_cat %>% count(partyid)</a>
#> # A tibble: 10 x 2</a>
#>   partyid                n</a>
#>   &lt;fct>              &lt;int></a>
#> 1 No answer            154</a>
#> 2 Don&#39;t know             1</a>
#> 3 Other party          393</a>
#> 4 Strong republican   2314</a>
#> 5 Not str republican  3032</a>
#> 6 Ind,near rep        1791</a>
#> # … with 4 more rows</code>

The levels are terse and inconsistent. 
Let’s tweak them to be longer and use a parallel construction.

<code>gss_cat %>%</a>
  mutate(partyid = fct_recode(partyid,</a>
    "Republican, strong"    = "Strong republican",</a>
    "Republican, weak"      = "Not str republican",</a>
    "Independent, near rep" = "Ind,near rep",</a>
    "Independent, near dem" = "Ind,near dem",</a>
    "Democrat, weak"        = "Not str democrat",</a>
    "Democrat, strong"      = "Strong democrat"</a>
  )) %>%</a>
  count(partyid)</a>
#> # A tibble: 10 x 2</a>
#>   partyid                   n</a>
#>   &lt;fct>                 &lt;int></a>
#> 1 No answer               154</a>
#> 2 Don&#39;t know                1</a>
#> 3 Other party             393</a>
#> 4 Republican, strong     2314</a>
#> 5 Republican, weak       3032</a>
#> 6 Independent, near rep  1791</a>
#> # … with 4 more rows</code>

<code>fct_recode()</code> will leave levels that aren’t explicitly mentioned as is, and will warn you if you accidentally refer to a level that doesn’t exist.

To combine groups, you can assign multiple old levels to the same new level:

<code>gss_cat %>%</a>
  mutate(partyid = fct_recode(partyid,</a>
    "Republican, strong"    = "Strong republican",</a>
    "Republican, weak"      = "Not str republican",</a>
    "Independent, near rep" = "Ind,near rep",</a>
    "Independent, near dem" = "Ind,near dem",</a>
    "Democrat, weak"        = "Not str democrat",</a>
    "Democrat, strong"      = "Strong democrat",</a>
    "Other"                 = "No answer",</a>
    "Other"                 = "Don&#39;t know",</a>
    "Other"                 = "Other party"</a>
  )) %>%</a>
  count(partyid)</a>
#> # A tibble: 8 x 2</a>
#>   partyid                   n</a>
#>   &lt;fct>                 &lt;int></a>
#> 1 Other                   548</a>
#> 2 Republican, strong     2314</a>
#> 3 Republican, weak       3032</a>
#> 4 Independent, near rep  1791</a>
#> 5 Independent            4119</a>
#> 6 Independent, near dem  2499</a>
#> # … with 2 more rows</code>

You must use this technique with care: if you group together categories that are truly different you will end up with misleading results.

If you want to collapse a lot of levels, <code>fct_collapse()</code> is a useful variant of <code>fct_recode()</code>. 
For each new variable, you can provide a vector of old levels:

<code>gss_cat %>%</a>
  mutate(partyid = fct_collapse(partyid,</a>
    other = c("No answer", "Don&#39;t know", "Other party"),</a>
    rep = c("Strong republican", "Not str republican"),</a>
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),</a>
    dem = c("Not str democrat", "Strong democrat")</a>
  )) %>%</a>
  count(partyid)</a>
#> # A tibble: 4 x 2</a>
#>   partyid     n</a>
#>   &lt;fct>   &lt;int></a>
#> 1 other     548</a>
#> 2 rep      5346</a>
#> 3 ind      8409</a>
#> 4 dem      7180</code>

Sometimes you just want to lump together all the small groups to make a plot or table simpler. 
That’s the job of <code>fct_lump()</code>:

<code>gss_cat %>%</a>
  mutate(relig = fct_lump(relig)) %>%</a>
  count(relig)</a>
#> # A tibble: 2 x 2</a>
#>   relig          n</a>
#>   &lt;fct>      &lt;int></a>
#> 1 Protestant 10846</a>
#> 2 Other      10637</code>

The default behaviour is to progressively lump together the smallest groups, ensuring that the aggregate is still the smallest group. 
In this case it’s not very helpful: it is true that the majority of Americans in this survey are Protestant, but we’ve probably over collapsed.

Instead, we can use the <code>n</code> parameter to specify how many groups (excluding other) we want to keep:

<code>gss_cat %>%</a>
  mutate(relig = fct_lump(relig, n = 10)) %>%</a>
  count(relig, sort = TRUE) %>%</a>
  print(n = Inf)</a>
#> # A tibble: 10 x 2</a>
#>    relig                       n</a>
#>    &lt;fct>                   &lt;int></a>
#>  1 Protestant              10846</a>
#>  2 Catholic                 5124</a>
#>  3 None                     3523</a>
#>  4 Christian                 689</a>
#>  5 Other                     458</a>
#>  6 Jewish                    388</a>
#>  7 Buddhism                  147</a>
#>  8 Inter-nondenominational   109</a>
#>  9 Moslem/islam              104</a>
#> 10 Orthodox-christian         95</code>

<h3>15.5.1 Exercises</h3>

How have the proportions of people identifying as Democrat, Republican, and
Independent changed over time?

How could you collapse <code>rincome</code> into a small set of categories?

<h2><span class="orange">16 Dates and times</span></h2>

<h2>16.1 Introduction</h2>
This chapter will show you how to work with dates and times in R. 
At first glance, dates and times seem simple. 
You use them all the time in your regular life, and they don’t seem to cause much confusion. 
However, the more you learn about dates and times, the more complicated they seem to get. 
To warm up, try these three seemingly simple questions:

Does every year have 365 days?

Does every day have 24 hours?

Does every minute have 60 seconds?

I’m sure you know that not every year has 365 days, but do you know the full rule for determining if a year is a leap year? (It has three parts.) You might have remembered that many parts of the world use daylight savings time (DST), so that some days have 23 hours, and others have 25. 
You might not have known that some minutes have 61 seconds because every now and then leap seconds are added because the Earth’s rotation is gradually slowing down.

Dates and times are hard because they have to reconcile two physical phenomena (the rotation of the Earth and its orbit around the sun) with a whole raft of geopolitical phenomena including months, time zones, and DST. 
This chapter won’t teach you every last detail about dates and times, but it will give you a solid grounding of practical skills that will help you with common data analysis challenges.

<h3>16.1.1 Prerequisites</h3>
This chapter will focus on the lubridate package, which makes it easier to work with dates and times in R. 
lubridate is not part of core tidyverse because you only need it when you’re working with dates/times. 
We will also need nycflights13 for practice data.

<code>library(tidyverse)</a>
</a>
library(lubridate)</a>
library(nycflights13)</code>

<h2>16.2 Creating date/times</h2>
There are three types of date/time data that refer to an instant in time:

A date. 
Tibbles print this as <code>&lt;date></code>.

A time within a day. 
Tibbles print this as <code>&lt;time></code>.

A date-time is a date plus a time: it uniquely identifies an
instant in time (typically to the nearest second). 
Tibbles print this
as <code>&lt;dttm></code>. 
Elsewhere in R these are called POSIXct, but I don’t think
that’s a very useful name.

In this chapter we are only going to focus on dates and date-times as R doesn’t have a native class for storing times. 
If you need one, you can use the hms package.

You should always use the simplest possible data type that works for your needs. 
That means if you can use a date instead of a date-time, you should. 
Date-times are substantially more complicated because of the need to handle time zones, which we’ll come back to at the end of the chapter.

To get the current date or date-time you can use <code>today()</code> or <code>now()</code>:

<code>today()</a>
#> [1] "2020-05-08"</a>
now()</a>
#> [1] "2020-05-08 21:18:59 UTC"</code>

Otherwise, there are three ways you’re likely to create a date/time:

From a string.

From individual date-time components.

From an existing date/time object.

They work as follows.

<h3>16.2.1 From strings</h3>
Date/time data often comes as strings. 
You’ve seen one approach to parsing strings into date-times in <a href="data-import.html#readr-datetimes">date-times</a>. 
Another approach is to use the helpers provided by lubridate. 
They automatically work out the format once you specify the order of the component. 
To use them, identify the order in which year, month, and day appear in your dates, then arrange 'y', 'm', and 'd' in the same order. 
That gives you the name of the lubridate function that will parse your date. 
For example:

<code>ymd("2017-01-31")</a>
#> [1] "2017-01-31"</a>
mdy("January 31st, 2017")</a>
#> [1] "2017-01-31"</a>
dmy("31-Jan-2017")</a>
#> [1] "2017-01-31"</code>

These functions also take unquoted numbers. 
This is the most concise way to create a single date/time object, as you might need when filtering date/time data. 
<code>ymd()</code> is short and unambiguous:

<code>ymd(20170131)</a>
#> [1] "2017-01-31"</code>

<code>ymd()</code> and friends create dates. 
To create a date-time, add an underscore and one or more of 'h', 'm', and 's' to the name of the parsing function:

<code>ymd_hms("2017-01-31 20:11:59")</a>
#> [1] "2017-01-31 20:11:59 UTC"</a>
mdy_hm("01/31/2017 08:01")</a>
#> [1] "2017-01-31 08:01:00 UTC"</code>

You can also force the creation of a date-time from a date by supplying a timezone:

<code>ymd(20170131, tz = "UTC")</a>
#> [1] "2017-01-31 UTC"</code>

<h3>16.2.2 From individual components</h3>
Instead of a single string, sometimes you’ll have the individual components of the date-time spread across multiple columns. 
This is what we have in the flights data:

<code>flights %>% </a>
  select(year, month, day, hour, minute)</a>
#> # A tibble: 336,776 x 5</a>
#>    year month   day  hour minute</a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl>  &lt;dbl></a>
#> 1  2013     1     1     5     15</a>
#> 2  2013     1     1     5     29</a>
#> 3  2013     1     1     5     40</a>
#> 4  2013     1     1     5     45</a>
#> 5  2013     1     1     6      0</a>
#> 6  2013     1     1     5     58</a>
#> # … with 336,770 more rows</code>

To create a date/time from this sort of input, use <code>make_date()</code> for dates, or <code>make_datetime()</code> for date-times:

<code>flights %>% </a>
  select(year, month, day, hour, minute) %>% </a>
  mutate(departure = make_datetime(year, month, day, hour, minute))</a>
#> # A tibble: 336,776 x 6</a>
#>    year month   day  hour minute departure          </a>
#>   &lt;int> &lt;int> &lt;int> &lt;dbl>  &lt;dbl> &lt;dttm>             </a>
#> 1  2013     1     1     5     15 2013-01-01 05:15:00</a>
#> 2  2013     1     1     5     29 2013-01-01 05:29:00</a>
#> 3  2013     1     1     5     40 2013-01-01 05:40:00</a>
#> 4  2013     1     1     5     45 2013-01-01 05:45:00</a>
#> 5  2013     1     1     6      0 2013-01-01 06:00:00</a>
#> 6  2013     1     1     5     58 2013-01-01 05:58:00</a>
#> # … with 336,770 more rows</code>

Let’s do the same thing for each of the four time columns in <code>flights</code>. 
The times are represented in a slightly odd format, so we use modulus arithmetic to pull out the hour and minute components. 
Once I’ve created the date-time variables, I focus in on the variables we’ll explore in the rest of the chapter.

<code>make_datetime_100 &lt;- function(year, month, day, time) {</a>
  make_datetime(year, month, day, time %/% 100, time %% 100)</a>
}</a>
</a>
flights_dt &lt;- flights %>% </a>
  filter(!is.na(dep_time), !is.na(arr_time)) %>% </a>
  mutate(</a>
    dep_time = make_datetime_100(year, month, day, dep_time),</a>
    arr_time = make_datetime_100(year, month, day, arr_time),</a>
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),</a>
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)</a>
  ) %>% </a>
  select(origin, dest, ends_with("delay"), ends_with("time"))</a>
</a>
flights_dt</a>
#> # A tibble: 328,063 x 9</a>
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     </a>
#>   &lt;chr>  &lt;chr>     &lt;dbl>     &lt;dbl> &lt;dttm>              &lt;dttm>             </a>
#> 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00</a>
#> 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00</a>
#> 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00</a>
#> 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00</a>
#> 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00</a>
#> 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00</a>
#> # … with 328,057 more rows, and 3 more variables: arr_time &lt;dttm>,</a>
#> #   sched_arr_time &lt;dttm>, air_time &lt;dbl></code>

With this data, I can visualise the distribution of departure times across the year:

<code>flights_dt %>% </a>
  ggplot(aes(dep_time)) + </a>
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1f3074c6fc1656b0619b04a5dd513f226857c4ed/16a6d/datetimes_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" />

Or within a single day:

<code>flights_dt %>% </a>
  filter(dep_time &lt; ymd(20130102)) %>% </a>
  ggplot(aes(dep_time)) + </a>
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a2f7b4118cc7e13403639a58ad8c653afcc31d9c/da6aa/datetimes_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

Note that when you use date-times in a numeric context (like in a histogram), 1 means 1 second, so a binwidth of 86400 means one day. 
For dates, 1 means 1 day.

<h3>16.2.3 From other types</h3>
You may want to switch between a date-time and a date. 
That’s the job of <code>as_datetime()</code> and <code>as_date()</code>:

<code>as_datetime(today())</a>
#> [1] "2020-05-08 UTC"</a>
as_date(now())</a>
#> [1] "2020-05-08"</code>

Sometimes you’ll get date/times as numeric offsets from the 'Unix Epoch', 1970-01-01. 
If the offset is in seconds, use <code>as_datetime()</code>; if it’s in days, use <code>as_date()</code>.

<code>as_datetime(60 * 60 * 10)</a>
#> [1] "1970-01-01 10:00:00 UTC"</a>
as_date(365 * 10 + 2)</a>
#> [1] "1980-01-01"</code>

<h3>16.2.4 Exercises</h3>

What happens if you parse a string that contains invalid dates?

<code>ymd(c("2010-10-10", "bananas"))</code>

What does the <code>tzone</code> argument to <code>today()</code> do? Why is it important?

Use the appropriate lubridate function to parse each of the following dates:

<code>d1 &lt;- "January 1, 2010"</a>
d2 &lt;- "2015-Mar-07"</a>
d3 &lt;- "06-Jun-2017"</a>
d4 &lt;- c("August 19 (2015)", "July 1 (2015)")</a>
d5 &lt;- "12/30/14" # Dec 30, 2014</code>

<h2>16.3 Date-time components</h2>
Now that you know how to get date-time data into R’s date-time data structures, let’s explore what you can do with them. 
This section will focus on the accessor functions that let you get and set individual components. 
The next section will look at how arithmetic works with date-times.

<h3>16.3.1 Getting components</h3>
You can pull out individual parts of the date with the accessor functions <code>year()</code>, <code>month()</code>, <code>mday()</code> (day of the month), <code>yday()</code> (day of the year), <code>wday()</code> (day of the week), <code>hour()</code>, <code>minute()</code>, and <code>second()</code>.

<code>datetime &lt;- ymd_hms("2016-07-08 12:34:56")</a>
</a>
year(datetime)</a>
#> [1] 2016</a>
month(datetime)</a>
#> [1] 7</a>
mday(datetime)</a>
#> [1] 8</a>
</a>
yday(datetime)</a>
#> [1] 190</a>
wday(datetime)</a>
#> [1] 6</code>

For <code>month()</code> and <code>wday()</code> you can set <code>label = TRUE</code> to return the abbreviated name of the month or day of the week. 
Set <code>abbr = FALSE</code> to return the full name.

<code>month(datetime, label = TRUE)</a>
#> [1] Jul</a>
#> 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... 
&lt; Dec</a>
wday(datetime, label = TRUE, abbr = FALSE)</a>
#> [1] Friday</a>
#> 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... 
&lt; Saturday</code>

We can use <code>wday()</code> to see that more flights depart during the week than on the weekend:

<code>flights_dt %>% </a>
  mutate(wday = wday(dep_time, label = TRUE)) %>% </a>
  ggplot(aes(x = wday)) +</a>
    geom_bar()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ff45aefe4ee51bfa4c2d828c8834c99b87ea3f4e/1a30c/datetimes_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" />

There’s an interesting pattern if we look at the average departure delay by minute within the hour. 
It looks like flights leaving in minutes 20-30 and 50-60 have much lower delays than the rest of the hour!

<code>flights_dt %>% </a>
  mutate(minute = minute(dep_time)) %>% </a>
  group_by(minute) %>% </a>
  summarise(</a>
    avg_delay = mean(arr_delay, na.rm = TRUE),</a>
    n = n()) %>% </a>
  ggplot(aes(minute, avg_delay)) +</a>
    geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/219d3aa975b9b3cc601dd1a2a255a4a5954c13ad/60967/datetimes_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

Interestingly, if we look at the <em>scheduled</em> departure time we don’t see such a strong pattern:

<code>sched_dep &lt;- flights_dt %>% </a>
  mutate(minute = minute(sched_dep_time)) %>% </a>
  group_by(minute) %>% </a>
  summarise(</a>
    avg_delay = mean(arr_delay, na.rm = TRUE),</a>
    n = n())</a>
</a>
ggplot(sched_dep, aes(minute, avg_delay)) +</a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/72e5e238b49e0a4a46f665d16262c0209e7efd22/41f89/datetimes_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

So why do we see that pattern with the actual departure times? Well, like much data collected by humans, there’s a strong bias towards flights leaving at 'nice' departure times. 
Always be alert for this sort of pattern whenever you work with data that involves human judgement!

<code>ggplot(sched_dep, aes(minute, n)) +</a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b0ab5bc9eabf9db7eeda0f5e7dde3807fba92fe8/f70e6/datetimes_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

<h3>16.3.2 Rounding</h3>
An alternative approach to plotting individual components is to round the date to a nearby unit of time, with <code>floor_date()</code>, <code>round_date()</code>, and <code>ceiling_date()</code>. 
Each function takes a vector of dates to adjust and then the name of the unit round down (floor), round up (ceiling), or round to. 
This, for example, allows us to plot the number of flights per week:

<code>flights_dt %>% </a>
  count(week = floor_date(dep_time, "week")) %>% </a>
  ggplot(aes(week, n)) +</a>
    geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/cc2922b42f04f49699ca4bd2f0cc0e3d27cbe3d4/a3355/datetimes_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" />

Computing the difference between a rounded and unrounded date can be particularly useful.

<h3>16.3.3 Setting components</h3>
You can also use each accessor function to set the components of a date/time:

<code>(datetime &lt;- ymd_hms("2016-07-08 12:34:56"))</a>
#> [1] "2016-07-08 12:34:56 UTC"</a>
</a>
year(datetime) &lt;- 2020</a>
datetime</a>
#> [1] "2020-07-08 12:34:56 UTC"</a>
month(datetime) &lt;- 01</a>
datetime</a>
#> [1] "2020-01-08 12:34:56 UTC"</a>
hour(datetime) &lt;- hour(datetime) + 1</a>
datetime</a>
#> [1] "2020-01-08 13:34:56 UTC"</code>

Alternatively, rather than modifying in place, you can create a new date-time with <code>update()</code>. 
This also allows you to set multiple values at once.

<code>update(datetime, year = 2020, month = 2, mday = 2, hour = 2)</a>
#> [1] "2020-02-02 02:34:56 UTC"</code>

If values are too big, they will roll-over:

<code>ymd("2015-02-01") %>% </a>
  update(mday = 30)</a>
#> [1] "2015-03-02"</a>
ymd("2015-02-01") %>% </a>
  update(hour = 400)</a>
#> [1] "2015-02-17 16:00:00 UTC"</code>

You can use <code>update()</code> to show the distribution of flights across the course of the day for every day of the year:

<code>flights_dt %>% </a>
  mutate(dep_hour = update(dep_time, yday = 1)) %>% </a>
  ggplot(aes(dep_hour)) +</a>
    geom_freqpoly(binwidth = 300)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/48a3832bc37e9c0dfeb47cad942b99e47b9e5fce/e4221/datetimes_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" />

Setting larger components of a date to a constant is a powerful technique that allows you to explore patterns in the smaller components.

<h3>16.3.4 Exercises</h3>

How does the distribution of flight times within a day change over the
course of the year?

Compare <code>dep_time</code>, <code>sched_dep_time</code> and <code>dep_delay</code>. 
Are they consistent?
Explain your findings.

Compare <code>air_time</code> with the duration between the departure and arrival.
Explain your findings. 
(Hint: consider the location of the airport.)

How does the average delay time change over the course of a day?
Should you use <code>dep_time</code> or <code>sched_dep_time</code>? Why?

On what day of the week should you leave if you want to minimise the
chance of a delay?

What makes the distribution of <code>diamonds$carat</code> and
<code>flights$sched_dep_time</code> similar?

Confirm my hypothesis that the early departures of flights in minutes
20-30 and 50-60 are caused by scheduled flights that leave early.
Hint: create a binary variable that tells you whether or not a flight
was delayed.

<h2>16.4 Time spans</h2>
Next you’ll learn about how arithmetic with dates works, including subtraction, addition, and division. 
Along the way, you’ll learn about three important classes that represent time spans:

durations, which represent an exact number of seconds.

periods, which represent human units like weeks and months.

intervals, which represent a starting and ending point.

<h3>16.4.1 Durations</h3>
In R, when you subtract two dates, you get a difftime object:

<code># How old is Hadley?</a>
h_age &lt;- today() - ymd(19791014)</a>
h_age</a>
#> Time difference of 14817 days</code>

A difftime class object records a time span of seconds, minutes, hours, days, or weeks. 
This ambiguity can make difftimes a little painful to work with, so lubridate provides an alternative which always uses seconds: the duration.

<code>as.duration(h_age)</a>
#> [1] "1280188800s (~40.57 years)"</code>

Durations come with a bunch of convenient constructors:

<code>dseconds(15)</a>
#> [1] "15s"</a>
dminutes(10)</a>
#> [1] "600s (~10 minutes)"</a>
dhours(c(12, 24))</a>
#> [1] "43200s (~12 hours)" "86400s (~1 days)"</a>
ddays(0:5)</a>
#> [1] "0s"                "86400s (~1 days)"  "172800s (~2 days)"</a>
#> [4] "259200s (~3 days)" "345600s (~4 days)" "432000s (~5 days)"</a>
dweeks(3)</a>
#> [1] "1814400s (~3 weeks)"</a>
dyears(1)</a>
#> [1] "31557600s (~1 years)"</code>

Durations always record the time span in seconds. 
Larger units are created by converting minutes, hours, days, weeks, and years to seconds at the standard rate (60 seconds in a minute, 60 minutes in an hour, 24 hours in day, 7 days in a week, 365 days in a year).

You can add and multiply durations:

<code>2 * dyears(1)</a>
#> [1] "63115200s (~2 years)"</a>
dyears(1) + dweeks(12) + dhours(15)</a>
#> [1] "38869200s (~1.23 years)"</code>

You can add and subtract durations to and from days:

<code>tomorrow &lt;- today() + ddays(1)</a>
last_year &lt;- today() - dyears(1)</code>

However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:

<code>one_pm &lt;- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")</a>
</a>
one_pm</a>
#> [1] "2016-03-12 13:00:00 EST"</a>
one_pm + ddays(1)</a>
#> [1] "2016-03-13 14:00:00 EDT"</code>

Why is one day after 1pm on March 12, 2pm on March 13?! If you look carefully at the date you might also notice that the time zones have changed. 
Because of DST, March 12 only has 23 hours, so if we add a full days worth of seconds we end up with a different time.

<h3>16.4.2 Periods</h3>
To solve this problem, lubridate provides periods. 
Periods are time spans but don’t have a fixed length in seconds, instead they work with 'human' times, like days and months. 
That allows them work in a more intuitive way:

<code>one_pm</a>
#> [1] "2016-03-12 13:00:00 EST"</a>
one_pm + days(1)</a>
#> [1] "2016-03-13 13:00:00 EDT"</code>

Like durations, periods can be created with a number of friendly constructor functions.

<code>seconds(15)</a>
#> [1] "15S"</a>
minutes(10)</a>
#> [1] "10M 0S"</a>
hours(c(12, 24))</a>
#> [1] "12H 0M 0S" "24H 0M 0S"</a>
days(7)</a>
#> [1] "7d 0H 0M 0S"</a>
months(1:6)</a>
#> [1] "1m 0d 0H 0M 0S" "2m 0d 0H 0M 0S" "3m 0d 0H 0M 0S" "4m 0d 0H 0M 0S"</a>
#> [5] "5m 0d 0H 0M 0S" "6m 0d 0H 0M 0S"</a>
weeks(3)</a>
#> [1] "21d 0H 0M 0S"</a>
years(1)</a>
#> [1] "1y 0m 0d 0H 0M 0S"</code>

You can add and multiply periods:

<code>10 * (months(6) + days(1))</a>
#> [1] "60m 10d 0H 0M 0S"</a>
days(50) + hours(25) + minutes(2)</a>
#> [1] "50d 25H 2M 0S"</code>

And of course, add them to dates. 
Compared to durations, periods are more likely to do what you expect:

<code># A leap year</a>
ymd("2016-01-01") + dyears(1)</a>
#> [1] "2016-12-31 06:00:00 UTC"</a>
ymd("2016-01-01") + years(1)</a>
#> [1] "2017-01-01"</a>
</a>
# Daylight Savings Time</a>
one_pm + ddays(1)</a>
#> [1] "2016-03-13 14:00:00 EDT"</a>
one_pm + days(1)</a>
#> [1] "2016-03-13 13:00:00 EDT"</code>

Let’s use periods to fix an oddity related to our flight dates. 
Some planes appear to have arrived at their destination <em>before</em> they departed from New York City.

<code>flights_dt %>% </a>
  filter(arr_time &lt; dep_time) </a>
#> # A tibble: 10,633 x 9</a>
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     </a>
#>   &lt;chr>  &lt;chr>     &lt;dbl>     &lt;dbl> &lt;dttm>              &lt;dttm>             </a>
#> 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00</a>
#> 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00</a>
#> 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00</a>
#> 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00</a>
#> 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00</a>
#> 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00</a>
#> # … with 10,627 more rows, and 3 more variables: arr_time &lt;dttm>,</a>
#> #   sched_arr_time &lt;dttm>, air_time &lt;dbl></code>

These are overnight flights. 
We used the same date information for both the departure and the arrival times, but these flights arrived on the following day. 
We can fix this by adding <code>days(1)</code> to the arrival time of each overnight flight.

<code>flights_dt &lt;- flights_dt %>% </a>
  mutate(</a>
    overnight = arr_time &lt; dep_time,</a>
    arr_time = arr_time + days(overnight * 1),</a>
    sched_arr_time = sched_arr_time + days(overnight * 1)</a>
  )</code>

Now all of our flights obey the laws of physics.

<code>flights_dt %>% </a>
  filter(overnight, arr_time &lt; dep_time) </a>
#> # A tibble: 0 x 10</a>
#> # … with 10 variables: origin &lt;chr>, dest &lt;chr>, dep_delay &lt;dbl>,</a>
#> #   arr_delay &lt;dbl>, dep_time &lt;dttm>, sched_dep_time &lt;dttm>, arr_time &lt;dttm>,</a>
#> #   sched_arr_time &lt;dttm>, air_time &lt;dbl>, overnight &lt;lgl></code>

<h3>16.4.3 Intervals</h3>
It’s obvious what <code>dyears(1) / ddays(365)</code> should return: one, because durations are always represented by a number of seconds, and a duration of a year is defined as 365 days worth of seconds.

What should <code>years(1) / days(1)</code> return? Well, if the year was 2015 it should return 365, but if it was 2016, it should return 366! There’s not quite enough information for lubridate to give a single clear answer. 
What it does instead is give an estimate, with a warning:

<code>years(1) / days(1)</a>
#> [1] 365</code>

If you want a more accurate measurement, you’ll have to use an interval. 
An interval is a duration with a starting point: that makes it precise so you can determine exactly how long it is:

<code>next_year &lt;- today() + years(1)</a>
(today() %--% next_year) / ddays(1)</a>
#> [1] 365</code>

To find out how many periods fall into an interval, you need to use integer division:

<code>(today() %--% next_year) %/% days(1)</a>
#> [1] 365</code>

<h3>16.4.4 Summary</h3>
How do you pick between duration, periods, and intervals? As always, pick the simplest data structure that solves your problem. 
If you only care about physical time, use a duration; if you need to add human times, use a period; if you need to figure out how long a span is in human units, use an interval.

Figure <a href="dates-and-times.html#fig:dt-algebra">16.1</a> summarises permitted arithmetic operations between the different data types.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0020136325ea844476bc61eb7e95d2ac5aeebf00/893e9/diagrams/datetimes-arithmetic.png" alt="The allowed arithmetic operations between pairs of date/time classes." width="70%" />

Figure 16.1: The allowed arithmetic operations between pairs of date/time classes.

<h3>16.4.5 Exercises</h3>

Why is there <code>months()</code> but no <code>dmonths()</code>?

Explain <code>days(overnight * 1)</code> to someone who has just started
learning R. 
How does it work?

Create a vector of dates giving the first day of every month in 2015.
Create a vector of dates giving the first day of every month
in the <em>current</em> year.

Write a function that given your birthday (as a date), returns
how old you are in years.

Why can’t <code>(today() %--% (today() + years(1))) / months(1)</code> work?

<h2>16.5 Time zones</h2>
Time zones are an enormously complicated topic because of their interaction with geopolitical entities. 
Fortunately we don’t need to dig into all the details as they’re not all important for data analysis, but there are a few challenges we’ll need to tackle head on.

The first challenge is that everyday names of time zones tend to be ambiguous. 
For example, if you’re American you’re probably familiar with EST, or Eastern Standard Time. 
However, both Australia and Canada also have EST! To avoid confusion, R uses the international standard IANA time zones. 
These use a consistent naming scheme '&lt;area>/&lt;location>', typically in the form '&lt;continent>/&lt;city>' (there are a few exceptions because not every country lies on a continent). 
Examples include 'America/New_York', 'Europe/Paris', and 'Pacific/Auckland'.

You might wonder why the time zone uses a city, when typically you think of time zones as associated with a country or region within a country. 
This is because the IANA database has to record decades worth of time zone rules. 
In the course of decades, countries change names (or break apart) fairly frequently, but city names tend to stay the same. 
Another problem is that name needs to reflect not only to the current behaviour, but also the complete history. 
For example, there are time zones for both 'America/New_York' and 'America/Detroit'. 
These cities both currently use Eastern Standard Time but in 1969-1972 Michigan (the state in which Detroit is located), did not follow DST, so it needs a different name. 
It’s worth reading the raw time zone database (available at <a href="http://www.iana.org/time-zones" class="uri">http://www.iana.org/time-zones</a>) just to read some of these stories!

You can find out what R thinks your current time zone is with <code>Sys.timezone()</code>:

<code>Sys.timezone()</a>
#> [1] "UTC"</code>

(If R doesn’t know, you’ll get an <code>NA</code>.)

And see the complete list of all time zone names with <code>OlsonNames()</code>:

<code>length(OlsonNames())</a>
#> [1] 607</a>
head(OlsonNames())</a>
#> [1] "Africa/Abidjan"     "Africa/Accra"       "Africa/Addis_Ababa"</a>
#> [4] "Africa/Algiers"     "Africa/Asmara"      "Africa/Asmera"</code>

In R, the time zone is an attribute of the date-time that only controls printing. 
For example, these three objects represent the same instant in time:

<code>(x1 &lt;- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))</a>
#> [1] "2015-06-01 12:00:00 EDT"</a>
(x2 &lt;- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))</a>
#> [1] "2015-06-01 18:00:00 CEST"</a>
(x3 &lt;- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))</a>
#> [1] "2015-06-02 04:00:00 NZST"</code>

You can verify that they’re the same time using subtraction:

<code>x1 - x2</a>
#> Time difference of 0 secs</a>
x1 - x3</a>
#> Time difference of 0 secs</code>

Unless otherwise specified, lubridate always uses UTC. 
UTC (Coordinated Universal Time) is the standard time zone used by the scientific community and roughly equivalent to its predecessor GMT (Greenwich Mean Time). 
It does not have DST, which makes a convenient representation for computation. 
Operations that combine date-times, like <code>c()</code>, will often drop the time zone. 
In that case, the date-times will display in your local time zone:

<code>x4 &lt;- c(x1, x2, x3)</a>
x4</a>
#> [1] "2015-06-01 12:00:00 EDT" "2015-06-01 12:00:00 EDT"</a>
#> [3] "2015-06-01 12:00:00 EDT"</code>

You can change the time zone in two ways:

Keep the instant in time the same, and change how it’s displayed.
Use this when the instant is correct, but you want a more natural
display.

<code>x4a &lt;- with_tz(x4, tzone = "Australia/Lord_Howe")</a>
x4a</a>
#> [1] "2015-06-02 02:30:00 +1030" "2015-06-02 02:30:00 +1030"</a>
#> [3] "2015-06-02 02:30:00 +1030"</a>
x4a - x4</a>
#> Time differences in secs</a>
#> [1] 0 0 0</code>

(This also illustrates another challenge of times zones: they’re not
all integer hour offsets!)

Change the underlying instant in time. 
Use this when you have an
instant that has been labelled with the incorrect time zone, and you
need to fix it.

<code>x4b &lt;- force_tz(x4, tzone = "Australia/Lord_Howe")</a>
x4b</a>
#> [1] "2015-06-01 12:00:00 +1030" "2015-06-01 12:00:00 +1030"</a>
#> [3] "2015-06-01 12:00:00 +1030"</a>
x4b - x4</a>
#> Time differences in hours</a>
#> [1] -14.5 -14.5 -14.5</code>

<h2><span class="orange">17 Introduction</span></h2>
In this part of the book, you’ll improve your programming skills. 
Programming is a cross-cutting skill needed for all data science work: you must use a computer to do data science; you cannot do it in your head, or with pencil and paper.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d39f84e23319e35a76bbf972c76e29595aaeab2c/cc7d1/diagrams/data-science-program.png" width="75%" style="display: block; margin: auto;" />

Programming produces code, and code is a tool of communication. 
Obviously code tells the computer what you want it to do. 
But it also communicates meaning to other humans. 
Thinking about code as a vehicle for communication is important because every project you do is fundamentally collaborative. 
Even if you’re not working with other people, you’ll definitely be working with future-you! Writing clear code is important so that others (like future-you) can understand why you tackled an analysis in the way you did. 
That means getting better at programming also involves getting better at communicating. 
Over time, you want your code to become not just easier to write, but easier for others to read.

Writing code is similar in many ways to writing prose. 
One parallel which I find particularly useful is that in both cases rewriting is the key to clarity. 
The first expression of your ideas is unlikely to be particularly clear, and you may need to rewrite multiple times. 
After solving a data analysis challenge, it’s often worth looking at your code and thinking about whether or not it’s obvious what you’ve done. 
If you spend a little time rewriting your code while the ideas are fresh, you can save a lot of time later trying to recreate what your code did. 
But this doesn’t mean you should rewrite every function: you need to balance what you need to achieve now with saving time in the long run. 
(But the more you rewrite your functions the more likely your first attempt will be clear.)

In the following four chapters, you’ll learn skills that will allow you to both tackle new programs and to solve existing problems with greater clarity and ease:

In <a href="pipes.html#pipes">pipes</a>, you will dive deep into the pipe, <code>%>%</code>, and learn more
about how it works, what the alternatives are, and when not to use it.

Copy-and-paste is a powerful tool, but you should avoid doing it more than
twice. 
Repeating yourself in code is dangerous because it can easily lead
to errors and inconsistencies. 
Instead, in <a href="functions.html#functions">functions</a>, you’ll learn
how to write functions which let you extract out repeated code so that
it can be easily reused.

As you start to write more powerful functions, you’ll need a solid
grounding in R’s data structures, provided by <a href="vectors.html#vectors">vectors</a>. 
You must master
the four common atomic vectors, the three important S3 classes built on
top of them, and understand the mysteries of the list and data frame.

Functions extract out repeated code, but you often need to repeat the
same actions on different inputs. 
You need tools for iteration that
let you do similar things again and again. 
These tools include for loops
and functional programming, which you’ll learn about in <a href="iteration.html#iteration">iteration</a>.

<h2>17.1 Learning more</h2>
The goal of these chapters is to teach you the minimum about programming that you need to practice data science, which turns out to be a reasonable amount. 
Once you have mastered the material in this book, I strongly believe you should invest further in your programming skills. 
Learning more about programming is a long-term investment: it won’t pay off immediately, but in the long term it will allow you to solve new problems more quickly, and let you reuse your insights from previous problems in new scenarios.

To learn more you need to study R as a programming language, not just an interactive environment for data science. 
We have written two books that will help you do so:

<a href="https://amzn.com/1449359019"><em>Hands on Programming with R</em></a>,
by Garrett Grolemund. 
This is an introduction to R as a programming language
and is a great place to start if R is your first programming language. 
It
covers similar material to these chapters, but with a different style and
different motivation examples (based in the casino). 
It’s a useful complement
if you find that these four chapters go by too quickly.

<a href="https://amzn.com/1466586966"><em>Advanced R</em></a> by Hadley Wickham. 
This dives into the
details of R the programming language. 
This is a great place to start if you
have existing programming experience. 
It’s also a great next step once you’ve
internalised the ideas in these chapters. 
You can read it online at
<a href="http://adv-r.had.co.nz" class="uri">http://adv-r.had.co.nz</a>.

<h2><span class="orange">18 Pipes</span></h2>

<h2>18.1 Introduction</h2>
Pipes are a powerful tool for clearly expressing a sequence of multiple operations. 
So far, you’ve been using them without knowing how they work, or what the alternatives are. 
Now, in this chapter, it’s time to explore the pipe in more detail. 
You’ll learn the alternatives to the pipe, when you shouldn’t use the pipe, and some useful related tools.

<h3>18.1.1 Prerequisites</h3>
The pipe, <code>%>%</code>, comes from the magrittr package by Stefan Milton Bache. 
Packages in the tidyverse load <code>%>%</code> for you automatically, so you don’t usually load magrittr explicitly. 
Here, however, we’re focussing on piping, and we aren’t loading any other packages, so we will load it explicitly.

<code>library(magrittr)</code>

<h2>18.2 Piping alternatives</h2>
The point of the pipe is to help you write code in a way that is easier to read and understand. 
To see why the pipe is so useful, we’re going to explore a number of ways of writing the same code. 
Let’s use code to tell a story about a little bunny named Foo Foo:

<blockquote>
Little bunny Foo Foo<br />
Went hopping through the forest<br />
Scooping up the field mice<br />
And bopping them on the head

</blockquote>
This is a popular Children’s poem that is accompanied by hand actions.

We’ll start by defining an object to represent little bunny Foo Foo:

<code>foo_foo &lt;- little_bunny()</code>

And we’ll use a function for each key verb: <code>hop()</code>, <code>scoop()</code>, and <code>bop()</code>. 
Using this object and these verbs, there are (at least) four ways we could retell the story in code:

Save each intermediate step as a new object.

Overwrite the original object many times.

Compose functions.

Use the pipe.

We’ll work through each approach, showing you the code and talking about the advantages and disadvantages.

<h3>18.2.1 Intermediate steps</h3>
The simplest approach is to save each step as a new object:

<code>foo_foo_1 &lt;- hop(foo_foo, through = forest)</a>
foo_foo_2 &lt;- scoop(foo_foo_1, up = field_mice)</a>
foo_foo_3 &lt;- bop(foo_foo_2, on = head)</code>

The main downside of this form is that it forces you to name each intermediate element. 
If there are natural names, this is a good idea, and you should do it. 
But many times, like this in this example, there aren’t natural names, and you add numeric suffixes to make the names unique. 
That leads to two problems:

The code is cluttered with unimportant names

You have to carefully increment the suffix on each line.

Whenever I write code like this, I invariably use the wrong number on one line and then spend 10 minutes scratching my head and trying to figure out what went wrong with my code.

You may also worry that this form creates many copies of your data and takes up a lot of memory. 
Surprisingly, that’s not the case. 
First, note that proactively worrying about memory is not a useful way to spend your time: worry about it when it becomes a problem (i.e. you run out of memory), not before. 
Second, R isn’t stupid, and it will share columns across data frames, where possible. 
Let’s take a look at an actual data manipulation pipeline where we add a new column to <code>ggplot2::diamonds</code>:

<code>diamonds &lt;- ggplot2::diamonds</a>
diamonds2 &lt;- diamonds %>% </a>
  dplyr::mutate(price_per_carat = price / carat)</a>
</a>
pryr::object_size(diamonds)</a>
#> Registered S3 method overwritten by &#39;pryr&#39;:</a>
#>   method      from</a>
#>   print.bytes Rcpp</a>
#> 3.46 MB</a>
pryr::object_size(diamonds2)</a>
#> 3.89 MB</a>
pryr::object_size(diamonds, diamonds2)</a>
#> 3.89 MB</code>

<code>pryr::object_size()</code> gives the memory occupied by all of its arguments. 
The results seem counterintuitive at first:

<code>diamonds</code> takes up 3.46 MB,

<code>diamonds2</code> takes up 3.89 MB,

<code>diamonds</code> and <code>diamonds2</code> together take up 3.89 MB!

How can that work? Well, <code>diamonds2</code> has 10 columns in common with <code>diamonds</code>: there’s no need to duplicate all that data, so the two data frames have variables in common. 
These variables will only get copied if you modify one of them. 
In the following example, we modify a single value in <code>diamonds$carat</code>. 
That means the <code>carat</code> variable can no longer be shared between the two data frames, and a copy must be made. 
The size of each data frame is unchanged, but the collective size increases:

<code>diamonds$carat[1] &lt;- NA</a>
pryr::object_size(diamonds)</a>
#> 3.46 MB</a>
pryr::object_size(diamonds2)</a>
#> 3.89 MB</a>
pryr::object_size(diamonds, diamonds2)</a>
#> 4.32 MB</code>

(Note that we use <code>pryr::object_size()</code> here, not the built-in <code>object.size()</code>. 
<code>object.size()</code> only takes a single object so it can’t compute how data is shared across multiple objects.)

<h3>18.2.2 Overwrite the original</h3>
Instead of creating intermediate objects at each step, we could overwrite the original object:

<code>foo_foo &lt;- hop(foo_foo, through = forest)</a>
foo_foo &lt;- scoop(foo_foo, up = field_mice)</a>
foo_foo &lt;- bop(foo_foo, on = head)</code>

This is less typing (and less thinking), so you’re less likely to make mistakes. 
However, there are two problems:

Debugging is painful: if you make a mistake you’ll need to re-run the
complete pipeline from the beginning.

The repetition of the object being transformed (we’ve written <code>foo_foo</code> six
times!) obscures what’s changing on each line.

<h3>18.2.3 Function composition</h3>
Another approach is to abandon assignment and just string the function calls together:

<code>bop(</a>
  scoop(</a>
    hop(foo_foo, through = forest),</a>
    up = field_mice</a>
  ), </a>
  on = head</a>
)</code>

Here the disadvantage is that you have to read from inside-out, from right-to-left, and that the arguments end up spread far apart (evocatively called the
<a href="https://en.wikipedia.org/wiki/Dagwood_sandwich">dagwood sandwhich</a> problem). 
In short, this code is hard for a human to consume.

<h3>18.2.4 Use the pipe</h3>
Finally, we can use the pipe:

<code>foo_foo %>%</a>
  hop(through = forest) %>%</a>
  scoop(up = field_mice) %>%</a>
  bop(on = head)</code>

This is my favourite form, because it focusses on verbs, not nouns. 
You can read this series of function compositions like it’s a set of imperative actions. 
Foo Foo hops, then scoops, then bops. 
The downside, of course, is that you need to be familiar with the pipe. 
If you’ve never seen <code>%>%</code> before, you’ll have no idea what this code does. 
Fortunately, most people pick up the idea very quickly, so when you share your code with others who aren’t familiar with the pipe, you can easily teach them.

The pipe works by performing a 'lexical transformation': behind the scenes, magrittr reassembles the code in the pipe to a form that works by overwriting an intermediate object. 
When you run a pipe like the one above, magrittr does something like this:

<code>my_pipe &lt;- function(.) {</a>
  . 
&lt;- hop(., through = forest)</a>
  . 
&lt;- scoop(., up = field_mice)</a>
  bop(., on = head)</a>
}</a>
my_pipe(foo_foo)</code>

This means that the pipe won’t work for two classes of functions:

Functions that use the current environment. 
For example, <code>assign()</code>
will create a new variable with the given name in the current environment:

<code>assign("x", 10)</a>
x</a>
#> [1] 10</a>
</a>
"x" %>% assign(100)</a>
x</a>
#> [1] 10</code>

The use of assign with the pipe does not work because it assigns it to
a temporary environment used by <code>%>%</code>. 
If you do want to use assign with the
pipe, you must be explicit about the environment:

<code>env &lt;- environment()</a>
"x" %>% assign(100, envir = env)</a>
x</a>
#> [1] 100</code>

Other functions with this problem include <code>get()</code> and <code>load()</code>.

Functions that use lazy evaluation. 
In R, function arguments
are only computed when the function uses them, not prior to calling the
function. 
The pipe computes each element in turn, so you can’t
rely on this behaviour.

One place that this is a problem is <code>tryCatch()</code>, which lets you capture
and handle errors:

<code>tryCatch(stop("!"), error = function(e) "An error")</a>
#> [1] "An error"</a>
</a>
stop("!") %>% </a>
  tryCatch(error = function(e) "An error")</a>
#> Error in eval(lhs, parent, parent): !</code>

There are a relatively wide class of functions with this behaviour,
including <code>try()</code>, <code>suppressMessages()</code>, and <code>suppressWarnings()</code>
in base R.

<h2>18.3 When not to use the pipe</h2>
The pipe is a powerful tool, but it’s not the only tool at your disposal, and it doesn’t solve every problem! Pipes are most useful for rewriting a fairly short linear sequence of operations. 
I think you should reach for another tool when:

Your pipes are longer than (say) ten steps. 
In that case, create
intermediate objects with meaningful names. 
That will make debugging easier,
because you can more easily check the intermediate results, and it makes
it easier to understand your code, because the variable names can help
communicate intent.

You have multiple inputs or outputs. 
If there isn’t one primary object
being transformed, but two or more objects being combined together,
don’t use the pipe.

You are starting to think about a directed graph with a complex
dependency structure. 
Pipes are fundamentally linear and expressing
complex relationships with them will typically yield confusing code.

<h2>18.4 Other tools from magrittr</h2>
All packages in the tidyverse automatically make <code>%>%</code> available for you, so you don’t normally load magrittr explicitly. 
However, there are some other useful tools inside magrittr that you might want to try out:

When working with more complex pipes, it’s sometimes useful to call a
function for its side-effects. 
Maybe you want to print out the current
object, or plot it, or save it to disk. 
Many times, such functions don’t
return anything, effectively terminating the pipe.

To work around this problem, you can use the 'tee' pipe. 
<code>%T>%</code> works like
<code>%>%</code> except that it returns the left-hand side instead of the right-hand
side. 
It’s called 'tee' because it’s like a literal T-shaped pipe.

<code>rnorm(100) %>%</a>
  matrix(ncol = 2) %>%</a>
  plot() %>%</a>
  str()</a>
#>  NULL</a>
</a>
rnorm(100) %>%</a>
  matrix(ncol = 2) %T>%</a>
  plot() %>%</a>
  str()</a>
#>  num [1:50, 1:2] -0.387 -0.785 -1.057 -0.796 -1.756 ...</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9fe6faafc26c889e3f90d7d2bd6db069d2f61eda/1182a/pipes_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/492414c1f615c4918233a9644978db45f095c3a3/a1367/pipes_files/figure-html/unnamed-chunk-12-2.png" width="70%" style="display: block; margin: auto;" />

If you’re working with functions that don’t have a data frame based API<br />
(i.e. you pass them individual vectors, not a data frame and expressions
to be evaluated in the context of that data frame), you might find <code>%$%</code>
useful. 
It 'explodes' out the variables in a data frame so that you can
refer to them explicitly. 
This is useful when working with many functions
in base R:

<code>mtcars %$%</a>
  cor(disp, mpg)</a>
#> [1] -0.848</code>

For assignment magrittr provides the <code>%&lt;>%</code> operator which allows you to
replace code like:

<code>mtcars &lt;- mtcars %>% </a>
  transform(cyl = cyl * 2)</code>

with

<code>mtcars %&lt;>% transform(cyl = cyl * 2)</code>

I’m not a fan of this operator because I think assignment is such a
special operation that it should always be clear when it’s occurring.
In my opinion, a little bit of duplication (i.e. repeating the
name of the object twice) is fine in return for making assignment
more explicit.

<h2><span class="orange">19 Functions</span></h2>

<h2>19.1 Introduction</h2>
One of the best ways to improve your reach as a data scientist is to write functions. 
Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting. 
Writing a function has three big advantages over using copy-and-paste:

You can give a function an evocative name that makes your code easier to
understand.

As requirements change, you only need to update code in one place, instead
of many.

You eliminate the chance of making incidental mistakes when you copy and
paste (i.e. updating a variable name in one place, but not in another).

Writing good functions is a lifetime journey. 
Even after using R for many years I still learn new techniques and better ways of approaching old problems. 
The goal of this chapter is not to teach you every esoteric detail of functions but to get you started with some pragmatic advice that you can apply immediately.

As well as practical advice for writing functions, this chapter also gives you some suggestions for how to style your code. 
Good code style is like correct punctuation. 
Youcanmanagewithoutit, but it sure makes things easier to read! As with styles of punctuation, there are many possible variations. 
Here we present the style we use in our code, but the most important thing is to be consistent.

<h3>19.1.1 Prerequisites</h3>
The focus of this chapter is on writing functions in base R, so you won’t need any extra packages.

<h2>19.2 When should you write a function?</h2>
You should consider writing a function whenever you’ve copied and pasted a block of code more than twice (i.e. you now have three copies of the same code). 
For example, take a look at this code. 
What does it do?

<code>df &lt;- tibble::tibble(</a>
  a = rnorm(10),</a>
  b = rnorm(10),</a>
  c = rnorm(10),</a>
  d = rnorm(10)</a>
)</a>
</a>
df$a &lt;- (df$a - min(df$a, na.rm = TRUE)) / </a>
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))</a>
df$b &lt;- (df$b - min(df$b, na.rm = TRUE)) / </a>
  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE))</a>
df$c &lt;- (df$c - min(df$c, na.rm = TRUE)) / </a>
  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))</a>
df$d &lt;- (df$d - min(df$d, na.rm = TRUE)) / </a>
  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))</code>

You might be able to puzzle out that this rescales each column to have a range from 0 to 1. 
But did you spot the mistake? I made an error when copying-and-pasting the code for <code>df$b</code>: I forgot to change an <code>a</code> to a <code>b</code>. 
Extracting repeated code out into a function is a good idea because it prevents you from making this type of mistake.

To write a function you need to first analyse the code. 
How many inputs does it have?

<code>(df$a - min(df$a, na.rm = TRUE)) /</a>
  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))</code>

This code only has one input: <code>df$a</code>. 
(If you’re surprised that <code>TRUE</code> is not an input, you can explore why in the exercise below.) To make the inputs more clear, it’s a good idea to rewrite the code using temporary variables with general names. 
Here this code only requires a single numeric vector, so I’ll call it <code>x</code>:

<code>x &lt;- df$a</a>
(x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))</a>
#>  [1] 0.289 0.751 0.000 0.678 0.853 1.000 0.172 0.611 0.612 0.601</code>

There is some duplication in this code. 
We’re computing the range of the data three times, so it makes sense to do it in one step:

<code>rng &lt;- range(x, na.rm = TRUE)</a>
(x - rng[1]) / (rng[2] - rng[1])</a>
#>  [1] 0.289 0.751 0.000 0.678 0.853 1.000 0.172 0.611 0.612 0.601</code>

Pulling out intermediate calculations into named variables is a good practice because it makes it more clear what the code is doing. 
Now that I’ve simplified the code, and checked that it still works, I can turn it into a function:

<code>rescale01 &lt;- function(x) {</a>
  rng &lt;- range(x, na.rm = TRUE)</a>
  (x - rng[1]) / (rng[2] - rng[1])</a>
}</a>
rescale01(c(0, 5, 10))</a>
#> [1] 0.0 0.5 1.0</code>

There are three key steps to creating a new function:

You need to pick a name for the function. 
Here I’ve used <code>rescale01</code>
because this function rescales a vector to lie between 0 and 1.

You list the inputs, or arguments, to the function inside <code>function</code>.
Here we have just one argument. 
If we had more the call would look like
<code>function(x, y, z)</code>.

You place the code you have developed in body of the function, a
<code>{</code> block that immediately follows <code>function(...)</code>.

Note the overall process: I only made the function after I’d figured out how to make it work with a simple input. 
It’s easier to start with working code and turn it into a function; it’s harder to create a function and then try to make it work.

At this point it’s a good idea to check your function with a few different inputs:

<code>rescale01(c(-10, 0, 10))</a>
#> [1] 0.0 0.5 1.0</a>
rescale01(c(1, 2, 3, NA, 5))</a>
#> [1] 0.00 0.25 0.50   NA 1.00</code>

As you write more and more functions you’ll eventually want to convert these informal, interactive tests into formal, automated tests. 
That process is called unit testing. 
Unfortunately, it’s beyond the scope of this book, but you can learn about it in <a href="http://r-pkgs.had.co.nz/tests.html" class="uri">http://r-pkgs.had.co.nz/tests.html</a>.

We can simplify the original example now that we have a function:

<code>df$a &lt;- rescale01(df$a)</a>
df$b &lt;- rescale01(df$b)</a>
df$c &lt;- rescale01(df$c)</a>
df$d &lt;- rescale01(df$d)</code>

Compared to the original, this code is easier to understand and we’ve eliminated one class of copy-and-paste errors. 
There is still quite a bit of duplication since we’re doing the same thing to multiple columns. 
We’ll learn how to eliminate that duplication in <a href="iteration.html#iteration">iteration</a>, once you’ve learned more about R’s data structures in <a href="vectors.html#vectors">vectors</a>.

Another advantage of functions is that if our requirements change, we only need to make the change in one place. 
For example, we might discover that some of our variables include infinite values, and <code>rescale01()</code> fails:

<code>x &lt;- c(1:10, Inf)</a>
rescale01(x)</a>
#>  [1]   0   0   0   0   0   0   0   0   0   0 NaN</code>

Because we’ve extracted the code into a function, we only need to make the fix in one place:

<code>rescale01 &lt;- function(x) {</a>
  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)</a>
  (x - rng[1]) / (rng[2] - rng[1])</a>
}</a>
rescale01(x)</a>
#>  [1] 0.000 0.111 0.222 0.333 0.444 0.556 0.667 0.778 0.889 1.000   Inf</code>

This is an important part of the 'do not repeat yourself' (or DRY) principle. 
The more repetition you have in your code, the more places you need to remember to update when things change (and they always do!), and the more likely you are to create bugs over time.

<h3>19.2.1 Exercises</h3>

Why is <code>TRUE</code> not a parameter to <code>rescale01()</code>? What would happen if
<code>x</code> contained a single missing value, and <code>na.rm</code> was <code>FALSE</code>?

In the second variant of <code>rescale01()</code>, infinite values are left
unchanged. 
Rewrite <code>rescale01()</code> so that <code>-Inf</code> is mapped to 0, and
<code>Inf</code> is mapped to 1.

Practice turning the following code snippets into functions. 
Think about
what each function does. 
What would you call it? How many arguments does it
need? Can you rewrite it to be more expressive or less duplicative?

<code>mean(is.na(x))</a>
</a>
x / sum(x, na.rm = TRUE)</a>
</a>
sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE)</code>

write your own functions to compute the variance and skewness of a numeric vector.
Variance is defined as
\[
\mathrm{Var}(x) = \frac{1}{n - 1} \sum_{i=1}^n (x_i - \bar{x}) ^2 \text{,}
\]
where \(\bar{x} = (\sum_i^n x_i) / n\) is the sample mean.
Skewness is defined as
\[
\mathrm{Skew}(x) = \frac{\frac{1}{n-2}\left(\sum_{i=1}^n(x_i - \bar x)^3\right)}{\mathrm{Var}(x)^{3/2}} \text{.}
\]

Write <code>both_na()</code>, a function that takes two vectors of the same length
and returns the number of positions that have an <code>NA</code> in both vectors.

What do the following functions do? Why are they useful even though they
are so short?

<code>is_directory &lt;- function(x) file.info(x)$isdir</a>
is_readable &lt;- function(x) file.access(x, 4) == 0</code>

Read the <a href="https://en.wikipedia.org/wiki/Little_Bunny_Foo_Foo">complete lyrics</a>
to 'Little Bunny Foo Foo'. 
There’s a lot of duplication in this song.
Extend the initial piping example to recreate the complete song, and use
functions to reduce the duplication.

<h2>19.3 Functions are for humans and computers</h2>
It’s important to remember that functions are not just for the computer, but are also for humans. 
R doesn’t care what your function is called, or what comments it contains, but these are important for human readers. 
This section discusses some things that you should bear in mind when writing functions that humans can understand.

The name of a function is important. 
Ideally, the name of your function will be short, but clearly evoke what the function does. 
That’s hard! But it’s better to be clear than short, as RStudio’s autocomplete makes it easy to type long names.

Generally, function names should be verbs, and arguments should be nouns. 
There are some exceptions: nouns are ok if the function computes a very well known noun (i.e. 
<code>mean()</code> is better than <code>compute_mean()</code>), or accessing some property of an object (i.e. 
<code>coef()</code> is better than <code>get_coefficients()</code>). 
A good sign that a noun might be a better choice is if you’re using a very broad verb like 'get', 'compute', 'calculate', or 'determine'. 
Use your best judgement and don’t be afraid to rename a function if you figure out a better name later.

<code># Too short</a>
f()</a>
</a>
# Not a verb, or descriptive</a>
my_awesome_function()</a>
</a>
# Long, but clear</a>
impute_missing()</a>
collapse_years()</code>

If your function name is composed of multiple words, I recommend using 'snake_case', where each lowercase word is separated by an underscore. 
camelCase is a popular alternative. 
It doesn’t really matter which one you pick, the important thing is to be consistent: pick one or the other and stick with it. 
R itself is not very consistent, but there’s nothing you can do about that. 
Make sure you don’t fall into the same trap by making your code as consistent as possible.

<code># Never do this!</a>
col_mins &lt;- function(x, y) {}</a>
rowMaxes &lt;- function(y, x) {}</code>

If you have a family of functions that do similar things, make sure they have consistent names and arguments. 
Use a common prefix to indicate that they are connected. 
That’s better than a common suffix because autocomplete allows you to type the prefix and see all the members of the family.

<code># Good</a>
input_select()</a>
input_checkbox()</a>
input_text()</a>
</a>
# Not so good</a>
select_input()</a>
checkbox_input()</a>
text_input()</code>

A good example of this design is the stringr package: if you don’t remember exactly which function you need, you can type <code>str_</code> and jog your memory.

Where possible, avoid overriding existing functions and variables. 
It’s impossible to do in general because so many good names are already taken by other packages, but avoiding the most common names from base R will avoid confusion.

<code># Don&#39;t do this!</a>
T &lt;- FALSE</a>
c &lt;- 10</a>
mean &lt;- function(x) sum(x)</code>

Use comments, lines starting with <code>#</code>, to explain the 'why' of your code. 
You generally should avoid comments that explain the 'what' or the 'how'. 
If you can’t understand what the code does from reading it, you should think about how to rewrite it to be more clear. 
Do you need to add some intermediate variables with useful names? Do you need to break out a subcomponent of a large function so you can name it? However, your code can never capture the reasoning behind your decisions: why did you choose this approach instead of an alternative? What else did you try that didn’t work? It’s a great idea to capture that sort of thinking in a comment.

Another important use of comments is to break up your file into easily readable chunks. 
Use long lines of <code>-</code> and <code>=</code> to make it easy to spot the breaks.

<code># Load data --------------------------------------</a>
</a>
# Plot data --------------------------------------</code>

RStudio provides a keyboard shortcut to create these headers (Cmd/Ctrl + Shift + R), and will display them in the code navigation drop-down at the bottom-left of the editor:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d33d4b289a029867f9c0700b47b6082a71ae6011/d3ee0/screenshots/rstudio-nav.png" width="125" style="display: block; margin: auto;" />

<h3>19.3.1 Exercises</h3>

Read the source code for each of the following three functions, puzzle out
what they do, and then brainstorm better names.

<code>f1 &lt;- function(string, prefix) {</a>
  substr(string, 1, nchar(prefix)) == prefix</a>
}</a>
f2 &lt;- function(x) {</a>
  if (length(x) &lt;= 1) return(NULL)</a>
  x[-length(x)]</a>
}</a>
f3 &lt;- function(x, y) {</a>
  rep(y, length.out = length(x))</a>
}</code>

Take a function that you’ve written recently and spend 5 minutes
brainstorming a better name for it and its arguments.

Compare and contrast <code>rnorm()</code> and <code>MASS::mvrnorm()</code>. 
How could you make
them more consistent?

Make a case for why <code>norm_r()</code>, <code>norm_d()</code> etc would be better than
<code>rnorm()</code>, <code>dnorm()</code>. 
Make a case for the opposite.

<h2>19.4 Conditional execution</h2>
An <code>if</code> statement allows you to conditionally execute code. 
It looks like this:

<code>if (condition) {</a>
  # code executed when condition is TRUE</a>
} else {</a>
  # code executed when condition is FALSE</a>
}</code>

To get help on <code>if</code> you need to surround it in backticks: <code>?`if`</code>. 
The help isn’t particularly helpful if you’re not already an experienced programmer, but at least you know how to get to it!

Here’s a simple function that uses an <code>if</code> statement. 
The goal of this function is to return a logical vector describing whether or not each element of a vector is named.

<code>has_name &lt;- function(x) {</a>
  nms &lt;- names(x)</a>
  if (is.null(nms)) {</a>
    rep(FALSE, length(x))</a>
  } else {</a>
    !is.na(nms) &amp; nms != "</a>
  }</a>
}</code>

This function takes advantage of the standard return rule: a function returns the last value that it computed. 
Here that is either one of the two branches of the <code>if</code> statement.

<h3>19.4.1 Conditions</h3>
The <code>condition</code> must evaluate to either <code>TRUE</code> or <code>FALSE</code>. 
If it’s a vector, you’ll get a warning message; if it’s an <code>NA</code>, you’ll get an error. 
Watch out for these messages in your own code:

<code>if (c(TRUE, FALSE)) {}</a>
#> Warning in if (c(TRUE, FALSE)) {: the condition has length > 1 and only the</a>
#> first element will be used</a>
#> NULL</a>
</a>
if (NA) {}</a>
#> Error in if (NA) {: missing value where TRUE/FALSE needed</code>

You can use <code>||</code> (or) and <code>&amp;&amp;</code> (and) to combine multiple logical expressions. 
These operators are 'short-circuiting': as soon as <code>||</code> sees the first <code>TRUE</code> it returns <code>TRUE</code> without computing anything else. 
As soon as <code>&amp;&amp;</code> sees the first <code>FALSE</code> it returns <code>FALSE</code>. 
You should never use <code>|</code> or <code>&amp;</code> in an <code>if</code> statement: these are vectorised operations that apply to multiple values (that’s why you use them in <code>filter()</code>). 
If you do have a logical vector, you can use <code>any()</code> or <code>all()</code> to collapse it to a single value.

Be careful when testing for equality. 
<code>==</code> is vectorised, which means that it’s easy to get more than one output. 
Either check the length is already 1, collapse with <code>all()</code> or <code>any()</code>, or use the non-vectorised <code>identical()</code>. 
<code>identical()</code> is very strict: it always returns either a single <code>TRUE</code> or a single <code>FALSE</code>, and doesn’t coerce types. 
This means that you need to be careful when comparing integers and doubles:

<code>identical(0L, 0)</a>
#> [1] FALSE</code>

You also need to be wary of floating point numbers:

<code>x &lt;- sqrt(2) ^ 2</a>
x</a>
#> [1] 2</a>
x == 2</a>
#> [1] FALSE</a>
x - 2</a>
#> [1] 4.44e-16</code>

Instead use <code>dplyr::near()</code> for comparisons, as described in <a href="transform.html#comparisons">comparisons</a>.

And remember, <code>x == NA</code> doesn’t do anything useful!

<h3>19.4.2 Multiple conditions</h3>
You can chain multiple if statements together:

<code>if (this) {</a>
  # do that</a>
} else if (that) {</a>
  # do something else</a>
} else {</a>
  # </a>
}</code>

But if you end up with a very long series of chained <code>if</code> statements, you should consider rewriting. 
One useful technique is the <code>switch()</code> function. 
It allows you to evaluate selected code based on position or name.

<code>#> function(x, y, op) {
#>   switch(op,
#>     plus = x + y,
#>     minus = x - y,
#>     times = x * y,
#>     divide = x / y,
#>     stop("Unknown op!")
#>   )
#> }</code>

Another useful function that can often eliminate long chains of <code>if</code> statements is <code>cut()</code>. 
It’s used to discretise continuous variables.

<h3>19.4.3 Code style</h3>
Both <code>if</code> and <code>function</code> should (almost) always be followed by squiggly brackets (<code>{}</code>), and the contents should be indented by two spaces. 
This makes it easier to see the hierarchy in your code by skimming the left-hand margin.

An opening curly brace should never go on its own line and should always be followed by a new line. 
A closing curly brace should always go on its own line, unless it’s followed by <code>else</code>. 
Always indent the code inside curly braces.

<code># Good</a>
if (y &lt; 0 &amp;&amp; debug) {</a>
  message("Y is negative")</a>
}</a>
</a>
if (y == 0) {</a>
  log(x)</a>
} else {</a>
  y ^ x</a>
}</a>
</a>
# Bad</a>
if (y &lt; 0 &amp;&amp; debug)</a>
message("Y is negative")</a>
</a>
if (y == 0) {</a>
  log(x)</a>
} </a>
else {</a>
  y ^ x</a>
}</code>

It’s ok to drop the curly braces if you have a very short <code>if</code> statement that can fit on one line:

<code>y &lt;- 10</a>
x &lt;- if (y &lt; 20) "Too low" else "Too high"</code>

I recommend this only for very brief <code>if</code> statements. 
Otherwise, the full form is easier to read:

<code>if (y &lt; 20) {</a>
  x &lt;- "Too low" </a>
} else {</a>
  x &lt;- "Too high"</a>
}</code>

<h3>19.4.4 Exercises</h3>

What’s the difference between <code>if</code> and <code>ifelse()</code>? Carefully read the help
and construct three examples that illustrate the key differences.

Write a greeting function that says 'good morning', 'good afternoon',
or 'good evening', depending on the time of day. 
(Hint: use a time
argument that defaults to <code>lubridate::now()</code>. 
That will make it
easier to test your function.)

Implement a <code>fizzbuzz</code> function. 
It takes a single number as input. 
If
the number is divisible by three, it returns 'fizz'. 
If it’s divisible by
five it returns 'buzz'. 
If it’s divisible by three and five, it returns
'fizzbuzz'. 
Otherwise, it returns the number. 
Make sure you first write
working code before you create the function.

How could you use <code>cut()</code> to simplify this set of nested if-else statements?

<code>if (temp &lt;= 0) {</a>
  "freezing"</a>
} else if (temp &lt;= 10) {</a>
  "cold"</a>
} else if (temp &lt;= 20) {</a>
  "cool"</a>
} else if (temp &lt;= 30) {</a>
  "warm"</a>
} else {</a>
  "hot"</a>
}</code>

How would you change the call to <code>cut()</code> if I’d used <code>&lt;</code> instead of <code>&lt;=</code>?
What is the other chief advantage of <code>cut()</code> for this problem? (Hint:
what happens if you have many values in <code>temp</code>?)

What happens if you use <code>switch()</code> with numeric values?

What does this <code>switch()</code> call do? What happens if <code>x</code> is 'e'?

<code>switch(x, </a>
  a = ,</a>
  b = "ab",</a>
  c = ,</a>
  d = "cd"</a>
)</code>

Experiment, then carefully read the documentation.

<h2>19.5 Function arguments</h2>
The arguments to a function typically fall into two broad sets: one set supplies the data to compute on, and the other supplies arguments that control the details of the computation. 
For example:

In <code>log()</code>, the data is <code>x</code>, and the detail is the <code>base</code> of the logarithm.

In <code>mean()</code>, the data is <code>x</code>, and the details are how much data to trim
from the ends (<code>trim</code>) and how to handle missing values (<code>na.rm</code>).

In <code>t.test()</code>, the data are <code>x</code> and <code>y</code>, and the details of the test are
<code>alternative</code>, <code>mu</code>, <code>paired</code>, <code>var.equal</code>, and <code>conf.level</code>.

In <code>str_c()</code> you can supply any number of strings to <code>...</code>, and the details
of the concatenation are controlled by <code>sep</code> and <code>collapse</code>.

Generally, data arguments should come first. 
Detail arguments should go on the end, and usually should have default values. 
You specify a default value in the same way you call a function with a named argument:

<code># Compute confidence interval around mean using normal approximation</a>
mean_ci &lt;- function(x, conf = 0.95) {</a>
  se &lt;- sd(x) / sqrt(length(x))</a>
  alpha &lt;- 1 - conf</a>
  mean(x) + se * qnorm(c(alpha / 2, 1 - alpha / 2))</a>
}</a>
</a>
x &lt;- runif(100)</a>
mean_ci(x)</a>
#> [1] 0.498 0.610</a>
mean_ci(x, conf = 0.99)</a>
#> [1] 0.480 0.628</code>

The default value should almost always be the most common value. 
The few exceptions to this rule are to do with safety. 
For example, it makes sense for <code>na.rm</code> to default to <code>FALSE</code> because missing values are important. 
Even though <code>na.rm = TRUE</code> is what you usually put in your code, it’s a bad idea to silently ignore missing values by default.

When you call a function, you typically omit the names of the data arguments, because they are used so commonly. 
If you override the default value of a detail argument, you should use the full name:

<code># Good</a>
mean(1:10, na.rm = TRUE)</a>
</a>
# Bad</a>
mean(x = 1:10, , FALSE)</a>
mean(, TRUE, x = c(1:10, NA))</code>

You can refer to an argument by its unique prefix (e.g. 
<code>mean(x, n = TRUE)</code>), but this is generally best avoided given the possibilities for confusion.

Notice that when you call a function, you should place a space around <code>=</code> in function calls, and always put a space after a comma, not before (just like in regular English). 
Using whitespace makes it easier to skim the function for the important components.

<code># Good</a>
average &lt;- mean(feet / 12 + inches, na.rm = TRUE)</a>
</a>
# Bad</a>
average&lt;-mean(feet/12+inches,na.rm=TRUE)</code>

<h3>19.5.1 Choosing names</h3>
The names of the arguments are also important. 
R doesn’t care, but the readers of your code (including future-you!) will. 
Generally you should prefer longer, more descriptive names, but there are a handful of very common, very short names. 
It’s worth memorising these:

<code>x</code>, <code>y</code>, <code>z</code>: vectors.

<code>w</code>: a vector of weights.

<code>df</code>: a data frame.

<code>i</code>, <code>j</code>: numeric indices (typically rows and columns).

<code>n</code>: length, or number of rows.

<code>p</code>: number of columns.

Otherwise, consider matching names of arguments in existing R functions. 
For example, use <code>na.rm</code> to determine if missing values should be removed.

<h3>19.5.2 Checking values</h3>
As you start to write more functions, you’ll eventually get to the point where you don’t remember exactly how your function works. 
At this point it’s easy to call your function with invalid inputs. 
To avoid this problem, it’s often useful to make constraints explicit. 
For example, imagine you’ve written some functions for computing weighted summary statistics:

<code>wt_mean &lt;- function(x, w) {</a>
  sum(x * w) / sum(w)</a>
}</a>
wt_var &lt;- function(x, w) {</a>
  mu &lt;- wt_mean(x, w)</a>
  sum(w * (x - mu) ^ 2) / sum(w)</a>
}</a>
wt_sd &lt;- function(x, w) {</a>
  sqrt(wt_var(x, w))</a>
}</code>

What happens if <code>x</code> and <code>w</code> are not the same length?

<code>wt_mean(1:6, 1:3)</a>
#> [1] 7.67</code>

In this case, because of R’s vector recycling rules, we don’t get an error.

It’s good practice to check important preconditions, and throw an error (with <code>stop()</code>), if they are not true:

<code>wt_mean &lt;- function(x, w) {</a>
  if (length(x) != length(w)) {</a>
    stop("`x` and `w` must be the same length", call. 
= FALSE)</a>
  }</a>
  sum(w * x) / sum(w)</a>
}</code>

Be careful not to take this too far. 
There’s a tradeoff between how much time you spend making your function robust, versus how long you spend writing it. 
For example, if you also added a <code>na.rm</code> argument, I probably wouldn’t check it carefully:

<code>wt_mean &lt;- function(x, w, na.rm = FALSE) {</a>
  if (!is.logical(na.rm)) {</a>
    stop("`na.rm` must be logical")</a>
  }</a>
  if (length(na.rm) != 1) {</a>
    stop("`na.rm` must be length 1")</a>
  }</a>
  if (length(x) != length(w)) {</a>
    stop("`x` and `w` must be the same length", call. 
= FALSE)</a>
  }</a>
  </a>
  if (na.rm) {</a>
    miss &lt;- is.na(x) | is.na(w)</a>
    x &lt;- x[!miss]</a>
    w &lt;- w[!miss]</a>
  }</a>
  sum(w * x) / sum(w)</a>
}</code>

This is a lot of extra work for little additional gain. 
A useful compromise is the built-in <code>stopifnot()</code>: it checks that each argument is <code>TRUE</code>, and produces a generic error message if not.

<code>wt_mean &lt;- function(x, w, na.rm = FALSE) {</a>
  stopifnot(is.logical(na.rm), length(na.rm) == 1)</a>
  stopifnot(length(x) == length(w))</a>
  </a>
  if (na.rm) {</a>
    miss &lt;- is.na(x) | is.na(w)</a>
    x &lt;- x[!miss]</a>
    w &lt;- w[!miss]</a>
  }</a>
  sum(w * x) / sum(w)</a>
}</a>
wt_mean(1:6, 6:1, na.rm = "foo")</a>
#> Error in wt_mean(1:6, 6:1, na.rm = "foo"): is.logical(na.rm) is not TRUE</code>

Note that when using <code>stopifnot()</code> you assert what should be true rather than checking for what might be wrong.

<h3>19.5.3 Dot-dot-dot (…)</h3>
Many functions in R take an arbitrary number of inputs:

<code>sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</a>
#> [1] 55</a>
stringr::str_c("a", "b", "c", "d", "e", "f")</a>
#> [1] "abcdef"</code>

How do these functions work? They rely on a special argument: <code>...</code> (pronounced dot-dot-dot). 
This special argument captures any number of arguments that aren’t otherwise matched.

It’s useful because you can then send those <code>...</code> on to another function. 
This is a useful catch-all if your function primarily wraps another function. 
For example, I commonly create these helper functions that wrap around <code>str_c()</code>:

<code>commas &lt;- function(...) stringr::str_c(..., collapse = ", ")</a>
commas(letters[1:10])</a>
#> [1] "a, b, c, d, e, f, g, h, i, j"</a>
</a>
rule &lt;- function(..., pad = "-") {</a>
  title &lt;- paste0(...)</a>
  width &lt;- getOption("width") - nchar(title) - 5</a>
  cat(title, " ", stringr::str_dup(pad, width), "\n", sep = ")</a>
}</a>
rule("Important output")</a>
#> Important output -----------------------------------------------------------</code>

Here <code>...</code> lets me forward on any arguments that I don’t want to deal with to <code>str_c()</code>. 
It’s a very convenient technique. 
But it does come at a price: any misspelled arguments will not raise an error. 
This makes it easy for typos to go unnoticed:

<code>x &lt;- c(1, 2)</a>
sum(x, na.mr = TRUE)</a>
#> [1] 4</code>

If you just want to capture the values of the <code>...</code>, use <code>list(...)</code>.

<h3>19.5.4 Lazy evaluation</h3>
Arguments in R are lazily evaluated: they’re not computed until they’re needed. 
That means if they’re never used, they’re never called. 
This is an important property of R as a programming language, but is generally not important when you’re writing your own functions for data analysis. 
You can read more about lazy evaluation at <a href="http://adv-r.had.co.nz/Functions.html#lazy-evaluation" class="uri">http://adv-r.had.co.nz/Functions.html#lazy-evaluation</a>.

<h3>19.5.5 Exercises</h3>

What does <code>commas(letters, collapse = "-")</code> do? Why?

It’d be nice if you could supply multiple characters to the <code>pad</code> argument,
e.g. 
<code>rule("Title", pad = "-+")</code>. 
Why doesn’t this currently work? How
could you fix it?

What does the <code>trim</code> argument to <code>mean()</code> do? When might you use it?

The default value for the <code>method</code> argument to <code>cor()</code> is
<code>c("pearson", "kendall", "spearman")</code>. 
What does that mean? What
value is used by default?

<h2>19.6 Return values</h2>
Figuring out what your function should return is usually straightforward: it’s why you created the function in the first place! There are two things you should consider when returning a value:

Does returning early make your function easier to read?

Can you make your function pipeable?

<h3>19.6.1 Explicit return statements</h3>
The value returned by the function is usually the last statement it evaluates, but you can choose to return early by using <code>return()</code>. 
I think it’s best to save the use of <code>return()</code> to signal that you can return early with a simpler solution. 
A common reason to do this is because the inputs are empty:

<code>complicated_function &lt;- function(x, y, z) {</a>
  if (length(x) == 0 || length(y) == 0) {</a>
    return(0)</a>
  }</a>
    </a>
  # Complicated code here</a>
}</code>

Another reason is because you have a <code>if</code> statement with one complex block and one simple block. 
For example, you might write an if statement like this:

<code>f &lt;- function() {</a>
  if (x) {</a>
    # Do </a>
    # something</a>
    # that</a>
    # takes</a>
    # many</a>
    # lines</a>
    # to</a>
    # express</a>
  } else {</a>
    # return something short</a>
  }</a>
}</code>

But if the first block is very long, by the time you get to the <code>else</code>, you’ve forgotten the <code>condition</code>. 
One way to rewrite it is to use an early return for the simple case:

<code></a>
f &lt;- function() {</a>
  if (!x) {</a>
    return(something_short)</a>
  }</a>
</a>
  # Do </a>
  # something</a>
  # that</a>
  # takes</a>
  # many</a>
  # lines</a>
  # to</a>
  # express</a>
}</code>

This tends to make the code easier to understand, because you don’t need quite so much context to understand it.

<h3>19.6.2 Writing pipeable functions</h3>
If you want to write your own pipeable functions, it’s important to think about the return value. 
Knowing the return value’s object type will mean that your pipeline will 'just work'. 
For example, with dplyr and tidyr the object type is the data frame.

There are two basic types of pipeable functions: transformations and side-effects. 
With transformations, an object is passed to the function’s first argument and a modified object is returned. 
With side-effects, the passed object is not transformed. 
Instead, the function performs an action on the object, like drawing a plot or saving a file. 
Side-effects functions should 'invisibly' return the first argument, so that while they’re not printed they can still be used in a pipeline. 
For example, this simple function prints the number of missing values in a data frame:

<code>show_missings &lt;- function(df) {</a>
  n &lt;- sum(is.na(df))</a>
  cat("Missing values: ", n, "\n", sep = ")</a>
  </a>
  invisible(df)</a>
}</code>

If we call it interactively, the <code>invisible()</code> means that the input <code>df</code> doesn’t get printed out:

<code>show_missings(mtcars)</a>
#> Missing values: 0</code>

But it’s still there, it’s just not printed by default:

<code>x &lt;- show_missings(mtcars) </a>
#> Missing values: 0</a>
class(x)</a>
#> [1] "data.frame"</a>
dim(x)</a>
#> [1] 32 11</code>

And we can still use it in a pipe:

<code>mtcars %>% </a>
  show_missings() %>% </a>
  mutate(mpg = ifelse(mpg &lt; 20, NA, mpg)) %>% </a>
  show_missings() </a>
#> Missing values: 0</a>
#> Missing values: 18</code>

<h2>19.7 Environment</h2>
The last component of a function is its environment. 
This is not something you need to understand deeply when you first start writing functions. 
However, it’s important to know a little bit about environments because they are crucial to how functions work. 
The environment of a function controls how R finds the value associated with a name. 
For example, take this function:

<code>f &lt;- function(x) {</a>
  x + y</a>
} </code>

In many programming languages, this would be an error, because <code>y</code> is not defined inside the function. 
In R, this is valid code because R uses rules called lexical scoping to find the value associated with a name. 
Since <code>y</code> is not defined inside the function, R will look in the environment where the function was defined:

<code>y &lt;- 100</a>
f(10)</a>
#> [1] 110</a>
</a>
y &lt;- 1000</a>
f(10)</a>
#> [1] 1010</code>

This behaviour seems like a recipe for bugs, and indeed you should avoid creating functions like this deliberately, but by and large it doesn’t cause too many problems (especially if you regularly restart R to get to a clean slate).

The advantage of this behaviour is that from a language standpoint it allows R to be very consistent. 
Every name is looked up using the same set of rules. 
For <code>f()</code> that includes the behaviour of two things that you might not expect: <code>{</code> and <code>+</code>. 
This allows you to do devious things like:

<code>`+` &lt;- function(x, y) {</a>
  if (runif(1) &lt; 0.1) {</a>
    sum(x, y)</a>
  } else {</a>
    sum(x, y) * 1.1</a>
  }</a>
}</a>
table(replicate(1000, 1 + 2))</a>
#> </a>
#>   3 3.3 </a>
#> 100 900</a>
rm(`+`)</code>

This is a common phenomenon in R. 
R places few limits on your power. 
You can do many things that you can’t do in other programming languages. 
You can do many things that 99% of the time are extremely ill-advised (like overriding how addition works!). 
But this power and flexibility is what makes tools like ggplot2 and dplyr possible. 
Learning how to make best use of this flexibility is beyond the scope of this book, but you can read about in <a href="http://adv-r.had.co.nz"><em>Advanced R</em></a>.

<h2><span class="orange">20 Vectors</span></h2>

<h2>20.1 Introduction</h2>
So far this book has focussed on tibbles and packages that work with them. 
But as you start to write your own functions, and dig deeper into R, you need to learn about vectors, the objects that underlie tibbles. 
If you’ve learned R in a more traditional way, you’re probably already familiar with vectors, as most R resources start with vectors and work their way up to tibbles. 
I think it’s better to start with tibbles because they’re immediately useful, and then work your way down to the underlying components.

Vectors are particularly important as most of the functions you will write will work with vectors. 
It is possible to write functions that work with tibbles (like ggplot2, dplyr, and tidyr), but the tools you need to write such functions are currently idiosyncratic and immature. 
I am working on a better approach, <a href="https://github.com/hadley/lazyeval" class="uri">https://github.com/hadley/lazyeval</a>, but it will not be ready in time for the publication of the book. 
Even when complete, you’ll still need to understand vectors, it’ll just make it easier to write a user-friendly layer on top.

<h3>20.1.1 Prerequisites</h3>
The focus of this chapter is on base R data structures, so it isn’t essential to load any packages. 
We will, however, use a handful of functions from the purrr package to avoid some inconsistencies in base R.

<code>library(tidyverse)</code>

<h2>20.2 Vector basics</h2>
There are two types of vectors:

Atomic vectors, of which there are six types:
logical, integer, double, character, complex, and
raw. 
Integer and double vectors are collectively known as
numeric vectors.

Lists, which are sometimes called recursive vectors because lists can
contain other lists.

The chief difference between atomic vectors and lists is that atomic vectors are homogeneous, while lists can be heterogeneous. 
There’s one other related object: <code>NULL</code>. 
<code>NULL</code> is often used to represent the absence of a vector (as opposed to <code>NA</code> which is used to represent the absence of a value in a vector). 
<code>NULL</code> typically behaves like a vector of length 0. 
Figure <a href="vectors.html#fig:datatypes">20.1</a> summarises the interrelationships.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png" alt="The hierarchy of R's vector types" width="50%" />

Figure 20.1: The hierarchy of R’s vector types

Every vector has two key properties:

Its type, which you can determine with <code>typeof()</code>.

<code>typeof(letters)</a>
#> [1] "character"</a>
typeof(1:10)</a>
#> [1] "integer"</code>

Its length, which you can determine with <code>length()</code>.

<code>x &lt;- list("a", "b", 1:10)</a>
length(x)</a>
#> [1] 3</code>

Vectors can also contain arbitrary additional metadata in the form of attributes. 
These attributes are used to create augmented vectors which build on additional behaviour. 
There are three important types of augmented vector:

Factors are built on top of integer vectors.

Dates and date-times are built on top of numeric vectors.

Data frames and tibbles are built on top of lists.

This chapter will introduce you to these important vectors from simplest to most complicated. 
You’ll start with atomic vectors, then build up to lists, and finish off with augmented vectors.

<h2>20.3 Important types of atomic vector</h2>
The four most important types of atomic vector are logical, integer, double, and character. 
Raw and complex are rarely used during a data analysis, so I won’t discuss them here.

<h3>20.3.1 Logical</h3>
Logical vectors are the simplest type of atomic vector because they can take only three possible values: <code>FALSE</code>, <code>TRUE</code>, and <code>NA</code>. 
Logical vectors are usually constructed with comparison operators, as described in <a href="transform.html#comparisons">comparisons</a>. 
You can also create them by hand with <code>c()</code>:

<code>1:10 %% 3 == 0</a>
#>  [1] FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE FALSE</a>
</a>
c(TRUE, TRUE, FALSE, NA)</a>
#> [1]  TRUE  TRUE FALSE    NA</code>

<h3>20.3.2 Numeric</h3>
Integer and double vectors are known collectively as numeric vectors. 
In R, numbers are doubles by default. 
To make an integer, place an <code>L</code> after the number:

<code>typeof(1)</a>
#> [1] "double"</a>
typeof(1L)</a>
#> [1] "integer"</a>
1.5L</a>
#> [1] 1.5</code>

The distinction between integers and doubles is not usually important, but there are two important differences that you should be aware of:

Doubles are approximations. 
Doubles represent floating point numbers that
can not always be precisely represented with a fixed amount of memory.
This means that you should consider all doubles to be approximations.
For example, what is square of the square root of two?

<code>x &lt;- sqrt(2) ^ 2</a>
x</a>
#> [1] 2</a>
x - 2</a>
#> [1] 4.44e-16</code>

This behaviour is common when working with floating point numbers: most
calculations include some approximation error. 
Instead of comparing floating
point numbers using <code>==</code>, you should use <code>dplyr::near()</code> which allows for
some numerical tolerance.

Integers have one special value: <code>NA</code>, while doubles have four:
<code>NA</code>, <code>NaN</code>, <code>Inf</code> and <code>-Inf</code>. 
All three special values <code>NaN</code>, <code>Inf</code> and <code>-Inf</code> can arise during division:

<code>c(-1, 0, 1) / 0</a>
#> [1] -Inf  NaN  Inf</code>

Avoid using <code>==</code> to check for these other special values. 
Instead use the
helper functions <code>is.finite()</code>, <code>is.infinite()</code>, and <code>is.nan()</code>:

<table>
<thead>
<tr class="header">
<th></th>
<th>0</th>
<th>Inf</th>
<th>NA</th>
<th>NaN</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>is.finite()</code></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is.infinite()</code></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is.na()</code></td>
<td></td>
<td></td>
<td>x</td>
<td>x</td>
</tr>
<tr class="even">
<td><code>is.nan()</code></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
</tr>
</tbody>
</table>

<h3>20.3.3 Character</h3>
Character vectors are the most complex type of atomic vector, because each element of a character vector is a string, and a string can contain an arbitrary amount of data.

You’ve already learned a lot about working with strings in <a href="strings.html#strings">strings</a>. 
Here I wanted to mention one important feature of the underlying string implementation: R uses a global string pool. 
This means that each unique string is only stored in memory once, and every use of the string points to that representation. 
This reduces the amount of memory needed by duplicated strings. 
You can see this behaviour in practice with <code>pryr::object_size()</code>:

<code>x &lt;- "This is a reasonably long string."</a>
pryr::object_size(x)</a>
#> Registered S3 method overwritten by &#39;pryr&#39;:</a>
#>   method      from</a>
#>   print.bytes Rcpp</a>
#> 152 B</a>
</a>
y &lt;- rep(x, 1000)</a>
pryr::object_size(y)</a>
#> 8.14 kB</code>

<code>y</code> doesn’t take up 1,000x as much memory as <code>x</code>, because each element of <code>y</code> is just a pointer to that same string. 
A pointer is 8 bytes, so 1000 pointers to a 136 B string is 8 * 1000 + 136 = 8.13 kB.

<h3>20.3.4 Missing values</h3>
Note that each type of atomic vector has its own missing value:

<code>NA            # logical</a>
#> [1] NA</a>
NA_integer_   # integer</a>
#> [1] NA</a>
NA_real_      # double</a>
#> [1] NA</a>
NA_character_ # character</a>
#> [1] NA</code>

Normally you don’t need to know about these different types because you can always use <code>NA</code> and it will be converted to the correct type using the implicit coercion rules described next. 
However, there are some functions that are strict about their inputs, so it’s useful to have this knowledge sitting in your back pocket so you can be specific when needed.

<h3>20.3.5 Exercises</h3>

Describe the difference between <code>is.finite(x)</code> and <code>!is.infinite(x)</code>.

Read the source code for <code>dplyr::near()</code> (Hint: to see the source code,
drop the <code>()</code>). 
How does it work?

A logical vector can take 3 possible values. 
How many possible
values can an integer vector take? How many possible values can
a double take? Use google to do some research.

Brainstorm at least four functions that allow you to convert a double to an
integer. 
How do they differ? Be precise.

What functions from the readr package allow you to turn a string
into logical, integer, and double vector?

<h2>20.4 Using atomic vectors</h2>
Now that you understand the different types of atomic vector, it’s useful to review some of the important tools for working with them. 
These include:

How to convert from one type to another, and when that happens
automatically.

How to tell if an object is a specific type of vector.

What happens when you work with vectors of different lengths.

How to name the elements of a vector.

How to pull out elements of interest.

<h3>20.4.1 Coercion</h3>
There are two ways to convert, or coerce, one type of vector to another:

Explicit coercion happens when you call a function like <code>as.logical()</code>,
<code>as.integer()</code>, <code>as.double()</code>, or <code>as.character()</code>. 
Whenever you find
yourself using explicit coercion, you should always check whether you can
make the fix upstream, so that the vector never had the wrong type in
the first place. 
For example, you may need to tweak your readr
<code>col_types</code> specification.

Implicit coercion happens when you use a vector in a specific context
that expects a certain type of vector. 
For example, when you use a logical
vector with a numeric summary function, or when you use a double vector
where an integer vector is expected.

Because explicit coercion is used relatively rarely, and is largely easy to understand, I’ll focus on implicit coercion here.

You’ve already seen the most important type of implicit coercion: using a logical vector in a numeric context. 
In this case <code>TRUE</code> is converted to <code>1</code> and <code>FALSE</code> converted to <code>0</code>. 
That means the sum of a logical vector is the number of trues, and the mean of a logical vector is the proportion of trues:

<code>x &lt;- sample(20, 100, replace = TRUE)</a>
y &lt;- x > 10</a>
sum(y)  # how many are greater than 10?</a>
#> [1] 38</a>
mean(y) # what proportion are greater than 10?</a>
#> [1] 0.38</code>

You may see some code (typically older) that relies on implicit coercion in the opposite direction, from integer to logical:

<code>if (length(x)) {</a>
  # do something</a>
}</code>

In this case, 0 is converted to <code>FALSE</code> and everything else is converted to <code>TRUE</code>. 
I think this makes it harder to understand your code, and I don’t recommend it. 
Instead be explicit: <code>length(x) > 0</code>.

It’s also important to understand what happens when you try and create a vector containing multiple types with <code>c()</code>: the most complex type always wins.

<code>typeof(c(TRUE, 1L))</a>
#> [1] "integer"</a>
typeof(c(1L, 1.5))</a>
#> [1] "double"</a>
typeof(c(1.5, "a"))</a>
#> [1] "character"</code>

An atomic vector can not have a mix of different types because the type is a property of the complete vector, not the individual elements. 
If you need to mix multiple types in the same vector, you should use a list, which you’ll learn about shortly.

<h3>20.4.2 Test functions</h3>
Sometimes you want to do different things based on the type of vector. 
One option is to use <code>typeof()</code>. 
Another is to use a test function which returns a <code>TRUE</code> or <code>FALSE</code>. 
Base R provides many functions like <code>is.vector()</code> and <code>is.atomic()</code>, but they often return surprising results. 
Instead, it’s safer to use the <code>is_*</code> functions provided by purrr, which are summarised in the table below.

<table>
<thead>
<tr class="header">
<th></th>
<th>lgl</th>
<th>int</th>
<th>dbl</th>
<th>chr</th>
<th>list</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>is_logical()</code></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is_integer()</code></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_double()</code></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>is_numeric()</code></td>
<td></td>
<td>x</td>
<td>x</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_character()</code></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
<td></td>
</tr>
<tr class="even">
<td><code>is_atomic()</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td></td>
</tr>
<tr class="odd">
<td><code>is_list()</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>x</td>
</tr>
<tr class="even">
<td><code>is_vector()</code></td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
</tr>
</tbody>
</table>
Each predicate also comes with a 'scalar' version, like <code>is_scalar_atomic()</code>, which checks that the length is 1. 
This is useful, for example, if you want to check that an argument to your function is a single logical value.

<h3>20.4.3 Scalars and recycling rules</h3>
As well as implicitly coercing the types of vectors to be compatible, R will also implicitly coerce the length of vectors. 
This is called vector recycling, because the shorter vector is repeated, or recycled, to the same length as the longer vector.

This is generally most useful when you are mixing vectors and 'scalars'. 
I put scalars in quotes because R doesn’t actually have scalars: instead, a single number is a vector of length 1. 
Because there are no scalars, most built-in functions are vectorised, meaning that they will operate on a vector of numbers. 
That’s why, for example, this code works:

<code>sample(10) + 100</a>
#>  [1] 107 104 103 109 102 101 106 110 105 108</a>
runif(10) > 0.5</a>
#>  [1] FALSE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE</code>

In R, basic mathematical operations work with vectors. 
That means that you should never need to perform explicit iteration when performing simple mathematical computations.

It’s intuitive what should happen if you add two vectors of the same length, or a vector and a 'scalar', but what happens if you add two vectors of different lengths?

<code>1:10 + 1:2</a>
#>  [1]  2  4  4  6  6  8  8 10 10 12</code>

Here, R will expand the shortest vector to the same length as the longest, so called recycling. 
This is silent except when the length of the longer is not an integer multiple of the length of the shorter:

<code>1:10 + 1:3</a>
#> Warning in 1:10 + 1:3: longer object length is not a multiple of shorter object</a>
#> length</a>
#>  [1]  2  4  6  5  7  9  8 10 12 11</code>

While vector recycling can be used to create very succinct, clever code, it can also silently conceal problems. 
For this reason, the vectorised functions in tidyverse will throw errors when you recycle anything other than a scalar. 
If you do want to recycle, you’ll need to do it yourself with <code>rep()</code>:

<code>tibble(x = 1:4, y = 1:2)</a>
#> Error: Tibble columns must have compatible sizes.</a>
#> * Size 4: Existing data.</a>
#> * Size 2: Column `y`.</a>
#> ℹ Only values of size one are recycled.</a>
</a>
tibble(x = 1:4, y = rep(1:2, 2))</a>
#> # A tibble: 4 x 2</a>
#>       x     y</a>
#>   &lt;int> &lt;int></a>
#> 1     1     1</a>
#> 2     2     2</a>
#> 3     3     1</a>
#> 4     4     2</a>
</a>
tibble(x = 1:4, y = rep(1:2, each = 2))</a>
#> # A tibble: 4 x 2</a>
#>       x     y</a>
#>   &lt;int> &lt;int></a>
#> 1     1     1</a>
#> 2     2     1</a>
#> 3     3     2</a>
#> 4     4     2</code>

<h3>20.4.4 Naming vectors</h3>
All types of vectors can be named. 
You can name them during creation with <code>c()</code>:

<code>c(x = 1, y = 2, z = 4)</a>
#> x y z </a>
#> 1 2 4</code>

Or after the fact with <code>purrr::set_names()</code>:

<code>set_names(1:3, c("a", "b", "c"))</a>
#> a b c </a>
#> 1 2 3</code>

Named vectors are most useful for subsetting, described next.

<h3>20.4.5 Subsetting</h3>
So far we’ve used <code>dplyr::filter()</code> to filter the rows in a tibble. 
<code>filter()</code> only works with tibble, so we’ll need new tool for vectors: <code>[</code>. 
<code>[</code> is the subsetting function, and is called like <code>x[a]</code>. 
There are four types of things that you can subset a vector with:

A numeric vector containing only integers. 
The integers must either be all
positive, all negative, or zero.

Subsetting with positive integers keeps the elements at those positions:

<code>x &lt;- c("one", "two", "three", "four", "five")</a>
x[c(3, 2, 5)]</a>
#> [1] "three" "two"   "five"</code>

By repeating a position, you can actually make a longer output than
input:

<code>x[c(1, 1, 5, 5, 5, 2)]</a>
#> [1] "one"  "one"  "five" "five" "five" "two"</code>

Negative values drop the elements at the specified positions:

<code>x[c(-1, -3, -5)]</a>
#> [1] "two"  "four"</code>

It’s an error to mix positive and negative values:

<code>x[c(1, -1)]</a>
#> Error in x[c(1, -1)]: only 0&#39;s may be mixed with negative subscripts</code>

The error message mentions subsetting with zero, which returns no values:

<code>x[0]</a>
#> character(0)</code>

This is not useful very often, but it can be helpful if you want to create
unusual data structures to test your functions with.

Subsetting with a logical vector keeps all values corresponding to a
<code>TRUE</code> value. 
This is most often useful in conjunction with the
comparison functions.

<code>x &lt;- c(10, 3, NA, 5, 8, 1, NA)</a>
</a>
# All non-missing values of x</a>
x[!is.na(x)]</a>
#> [1] 10  3  5  8  1</a>
</a>
# All even (or missing!) values of x</a>
x[x %% 2 == 0]</a>
#> [1] 10 NA  8 NA</code>

If you have a named vector, you can subset it with a character vector:

<code>x &lt;- c(abc = 1, def = 2, xyz = 5)</a>
x[c("xyz", "def")]</a>
#> xyz def </a>
#>   5   2</code>

Like with positive integers, you can also use a character vector to
duplicate individual entries.

The simplest type of subsetting is nothing, <code>x[]</code>, which returns the
complete <code>x</code>. 
This is not useful for subsetting vectors, but it is useful
when subsetting matrices (and other high dimensional structures) because
it lets you select all the rows or all the columns, by leaving that
index blank. 
For example, if <code>x</code> is 2d, <code>x[1, ]</code> selects the first row and
all the columns, and <code>x[, -1]</code> selects all rows and all columns except
the first.

To learn more about the applications of subsetting, reading the 'Subsetting' chapter of <em>Advanced R</em>: <a href="http://adv-r.had.co.nz/Subsetting.html#applications" class="uri">http://adv-r.had.co.nz/Subsetting.html#applications</a>.

There is an important variation of <code>[</code> called <code>[[</code>. 
<code>[[</code> only ever extracts a single element, and always drops names. 
It’s a good idea to use it whenever you want to make it clear that you’re extracting a single item, as in a for loop. 
The distinction between <code>[</code> and <code>[[</code> is most important for lists, as we’ll see shortly.

<h3>20.4.6 Exercises</h3>

What does <code>mean(is.na(x))</code> tell you about a vector <code>x</code>? What about
<code>sum(!is.finite(x))</code>?

Carefully read the documentation of <code>is.vector()</code>. 
What does it actually
test for? Why does <code>is.atomic()</code> not agree with the definition of
atomic vectors above?

Compare and contrast <code>setNames()</code> with <code>purrr::set_names()</code>.

Create functions that take a vector as input and returns:

The last value. 
Should you use <code>[</code> or <code>[[</code>?

The elements at even numbered positions.

Every element except the last value.

Only even numbers (and no missing values).

Why is <code>x[-which(x > 0)]</code> not the same as <code>x[x &lt;= 0]</code>?

What happens when you subset with a positive integer that’s bigger
than the length of the vector? What happens when you subset with a
name that doesn’t exist?

<h2>20.5 Recursive vectors (lists)</h2>
Lists are a step up in complexity from atomic vectors, because lists can contain other lists. 
This makes them suitable for representing hierarchical or tree-like structures. 
You create a list with <code>list()</code>:

<code>x &lt;- list(1, 2, 3)</a>
x</a>
#> [[1]]</a>
#> [1] 1</a>
#> </a>
#> [[2]]</a>
#> [1] 2</a>
#> </a>
#> [[3]]</a>
#> [1] 3</code>

A very useful tool for working with lists is <code>str()</code> because it focusses on the structure, not the contents.

<code>str(x)</a>
#> List of 3</a>
#>  $ : num 1</a>
#>  $ : num 2</a>
#>  $ : num 3</a>
</a>
x_named &lt;- list(a = 1, b = 2, c = 3)</a>
str(x_named)</a>
#> List of 3</a>
#>  $ a: num 1</a>
#>  $ b: num 2</a>
#>  $ c: num 3</code>

Unlike atomic vectors, <code>list()</code> can contain a mix of objects:

<code>y &lt;- list("a", 1L, 1.5, TRUE)</a>
str(y)</a>
#> List of 4</a>
#>  $ : chr "a"</a>
#>  $ : int 1</a>
#>  $ : num 1.5</a>
#>  $ : logi TRUE</code>

Lists can even contain other lists!

<code>z &lt;- list(list(1, 2), list(3, 4))</a>
str(z)</a>
#> List of 2</a>
#>  $ :List of 2</a>
#>   ..$ : num 1</a>
#>   ..$ : num 2</a>
#>  $ :List of 2</a>
#>   ..$ : num 3</a>
#>   ..$ : num 4</code>

<h3>20.5.1 Visualising lists</h3>
To explain more complicated list manipulation functions, it’s helpful to have a visual representation of lists. 
For example, take these three lists:

<code>x1 &lt;- list(c(1, 2), c(3, 4))</a>
x2 &lt;- list(list(1, 2), list(3, 4))</a>
x3 &lt;- list(1, list(2, list(3)))</code>

I’ll draw them as follows:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5ba72e78f2df8568c1be82236659558b0e06904c/04521/diagrams/lists-structure.png" width="75%" style="display: block; margin: auto;" />

There are three principles:

Lists have rounded corners. 
Atomic vectors have square corners.

Children are drawn inside their parent, and have a slightly darker
background to make it easier to see the hierarchy.

The orientation of the children (i.e. rows or columns) isn’t important,
so I’ll pick a row or column orientation to either save space or illustrate
an important property in the example.

<h3>20.5.2 Subsetting</h3>
There are three ways to subset a list, which I’ll illustrate with a list named <code>a</code>:

<code>a &lt;- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))</code>

<code>[</code> extracts a sub-list. 
The result will always be a list.

<code>str(a[1:2])</a>
#> List of 2</a>
#>  $ a: int [1:3] 1 2 3</a>
#>  $ b: chr "a string"</a>
str(a[4])</a>
#> List of 1</a>
#>  $ d:List of 2</a>
#>   ..$ : num -1</a>
#>   ..$ : num -5</code>

Like with vectors, you can subset with a logical, integer, or character
vector.

<code>[[</code> extracts a single component from a list. 
It removes a level of
hierarchy from the list.

<code>str(a[[1]])</a>
#>  int [1:3] 1 2 3</a>
str(a[[4]])</a>
#> List of 2</a>
#>  $ : num -1</a>
#>  $ : num -5</code>

<code>$</code> is a shorthand for extracting named elements of a list. 
It works
similarly to <code>[[</code> except that you don’t need to use quotes.

<code>a$a</a>
#> [1] 1 2 3</a>
a[["a"]]</a>
#> [1] 1 2 3</code>

The distinction between <code>[</code> and <code>[[</code> is really important for lists, because <code>[[</code> drills down into the list while <code>[</code> returns a new, smaller list. 
Compare the code and output above with the visual representation in Figure <a href="vectors.html#fig:lists-subsetting">20.2</a>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2f3f752cae25018554d484464f117e600ff365a2/37627/diagrams/lists-subsetting.png" alt="Subsetting a list, visually." width="75%" />

Figure 20.2: Subsetting a list, visually.

<h3>20.5.3 Lists of condiments</h3>
The difference between <code>[</code> and <code>[[</code> is very important, but it’s easy to get confused. 
To help you remember, let me show you an unusual pepper shaker.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3354d06efb9f3ac5d49b7dd43951ec6f3502eef0/cd3ca/images/pepper.jpg" width="25%" style="display: block; margin: auto;" />

If this pepper shaker is your list <code>x</code>, then, <code>x[1]</code> is a pepper shaker containing a single pepper packet:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/efe811d3409439242952777e8cb46664d703a035/21bb3/images/pepper-1.jpg" width="25%" style="display: block; margin: auto;" />

<code>x[2]</code> would look the same, but would contain the second packet. 
<code>x[1:2]</code> would be a pepper shaker containing two pepper packets.

<code>x[[1]]</code> is:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/087cf9a5f502365fdba7be5591d680b7fd31c38b/25cd4/images/pepper-2.jpg" width="25%" style="display: block; margin: auto;" />

If you wanted to get the content of the pepper package, you’d need <code>x[[1]][[1]]</code>:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a1be90e429cb8bd47badc5b5fc0f75686282e91d/76d16/images/pepper-3.jpg" width="25%" style="display: block; margin: auto;" />

<h3>20.5.4 Exercises</h3>

Draw the following lists as nested sets:

<code>list(a, b, list(c, d), list(e, f))</code>

<code>list(list(list(list(list(list(a))))))</code>

What happens if you subset a tibble as if you’re subsetting a list?
What are the key differences between a list and a tibble?

<h2>20.6 Attributes</h2>
Any vector can contain arbitrary additional metadata through its attributes. 
You can think of attributes as named list of vectors that can be attached to any object.
You can get and set individual attribute values with <code>attr()</code> or see them all at once with <code>attributes()</code>.

<code>x &lt;- 1:10</a>
attr(x, "greeting")</a>
#> NULL</a>
attr(x, "greeting") &lt;- "Hi!"</a>
attr(x, "farewell") &lt;- "Bye!"</a>
attributes(x)</a>
#> $greeting</a>
#> [1] "Hi!"</a>
#> </a>
#> $farewell</a>
#> [1] "Bye!"</code>

There are three very important attributes that are used to implement fundamental parts of R:

Names are used to name the elements of a vector.

Dimensions (dims, for short) make a vector behave like a matrix or array.

Class is used to implement the S3 object oriented system.

You’ve seen names above, and we won’t cover dimensions because we don’t use matrices in this book. 
It remains to describe the class, which controls how generic functions work. 
Generic functions are key to object oriented programming in R, because they make functions behave differently for different classes of input. 
A detailed discussion of object oriented programming is beyond the scope of this book, but you can read more about it in <em>Advanced R</em> at <a href="http://adv-r.had.co.nz/OO-essentials.html#s3" class="uri">http://adv-r.had.co.nz/OO-essentials.html#s3</a>.

Here’s what a typical generic function looks like:

<code>as.Date</a>
#> function (x, ...) </a>
#> UseMethod("as.Date")</a>
#> &lt;bytecode: 0x2fa0fa0></a>
#> &lt;environment: namespace:base></code>

The call to 'UseMethod' means that this is a generic function, and it will call a specific method, a function, based on the class of the first argument. 
(All methods are functions; not all functions are methods). 
You can list all the methods for a generic with <code>methods()</code>:

<code>methods("as.Date")</a>
#> [1] as.Date.character   as.Date.default     as.Date.factor     </a>
#> [4] as.Date.numeric     as.Date.POSIXct     as.Date.POSIXlt    </a>
#> [7] as.Date.vctrs_sclr* as.Date.vctrs_vctr*</a>
#> see &#39;?methods&#39; for accessing help and source code</code>

For example, if <code>x</code> is a character vector, <code>as.Date()</code> will call <code>as.Date.character()</code>; if it’s a factor, it’ll call <code>as.Date.factor()</code>.

You can see the specific implementation of a method with <code>getS3method()</code>:

<code>getS3method("as.Date", "default")</a>
#> function (x, ...) </a>
#> {</a>
#>     if (inherits(x, "Date")) </a>
#>         x</a>
#>     else if (is.logical(x) &amp;&amp; all(is.na(x))) </a>
#>         .Date(as.numeric(x))</a>
#>     else stop(gettextf("do not know how to convert &#39;%s&#39; to class %s", </a>
#>         deparse1(substitute(x)), dQuote("Date")), domain = NA)</a>
#> }</a>
#> &lt;bytecode: 0x53c6430></a>
#> &lt;environment: namespace:base></a>
getS3method("as.Date", "numeric")</a>
#> function (x, origin, ...) </a>
#> {</a>
#>     if (missing(origin)) </a>
#>         stop("&#39;origin&#39; must be supplied")</a>
#>     as.Date(origin, ...) + x</a>
#> }</a>
#> &lt;bytecode: 0x7b4bcd0></a>
#> &lt;environment: namespace:base></code>

The most important S3 generic is <code>print()</code>: it controls how the object is printed when you type its name at the console. 
Other important generics are the subsetting functions <code>[</code>, <code>[[</code>, and <code>$</code>.

<h2>20.7 Augmented vectors</h2>
Atomic vectors and lists are the building blocks for other important vector types like factors and dates. 
I call these augmented vectors, because they are vectors with additional attributes, including class. 
Because augmented vectors have a class, they behave differently to the atomic vector on which they are built. 
In this book, we make use of four important augmented vectors:

Factors

Dates

Date-times

Tibbles

These are described below.

<h3>20.7.1 Factors</h3>
Factors are designed to represent categorical data that can take a fixed set of possible values. 
Factors are built on top of integers, and have a levels attribute:

<code>x &lt;- factor(c("ab", "cd", "ab"), levels = c("ab", "cd", "ef"))</a>
typeof(x)</a>
#> [1] "integer"</a>
attributes(x)</a>
#> $levels</a>
#> [1] "ab" "cd" "ef"</a>
#> </a>
#> $class</a>
#> [1] "factor"</code>

<h3>20.7.2 Dates and date-times</h3>
Dates in R are numeric vectors that represent the number of days since 1 January 1970.

<code>x &lt;- as.Date("1971-01-01")</a>
unclass(x)</a>
#> [1] 365</a>
</a>
typeof(x)</a>
#> [1] "double"</a>
attributes(x)</a>
#> $class</a>
#> [1] "Date"</code>

Date-times are numeric vectors with class <code>POSIXct</code> that represent the number of seconds since 1 January 1970. 
(In case you were wondering, 'POSIXct' stands for 'Portable Operating System Interface', calendar time.)

<code>x &lt;- lubridate::ymd_hm("1970-01-01 01:00")</a>
unclass(x)</a>
#> [1] 3600</a>
#> attr(,"tzone")</a>
#> [1] "UTC"</a>
</a>
typeof(x)</a>
#> [1] "double"</a>
attributes(x)</a>
#> $class</a>
#> [1] "POSIXct" "POSIXt" </a>
#> </a>
#> $tzone</a>
#> [1] "UTC"</code>

The <code>tzone</code> attribute is optional. 
It controls how the time is printed, not what absolute time it refers to.

<code>attr(x, "tzone") &lt;- "US/Pacific"</a>
x</a>
#> [1] "1969-12-31 17:00:00 PST"</a>
</a>
attr(x, "tzone") &lt;- "US/Eastern"</a>
x</a>
#> [1] "1969-12-31 20:00:00 EST"</code>

There is another type of date-times called POSIXlt. 
These are built on top of named lists:

<code>y &lt;- as.POSIXlt(x)</a>
typeof(y)</a>
#> [1] "list"</a>
attributes(y)</a>
#> $names</a>
#>  [1] "sec"    "min"    "hour"   "mday"   "mon"    "year"   "wday"   "yday"  </a>
#>  [9] "isdst"  "zone"   "gmtoff"</a>
#> </a>
#> $class</a>
#> [1] "POSIXlt" "POSIXt" </a>
#> </a>
#> $tzone</a>
#> [1] "US/Eastern" "EST"        "EDT"</code>

POSIXlts are rare inside the tidyverse. 
They do crop up in base R, because they are needed to extract specific components of a date, like the year or month. 
Since lubridate provides helpers for you to do this instead, you don’t need them. 
POSIXct’s are always easier to work with, so if you find you have a POSIXlt, you should always convert it to a regular data time <code>lubridate::as_date_time()</code>.

<h3>20.7.3 Tibbles</h3>
Tibbles are augmented lists: they have class 'tbl_df' + 'tbl' + 'data.frame', and <code>names</code> (column) and <code>row.names</code> attributes:

<code>tb &lt;- tibble::tibble(x = 1:5, y = 5:1)</a>
typeof(tb)</a>
#> [1] "list"</a>
attributes(tb)</a>
#> $names</a>
#> [1] "x" "y"</a>
#> </a>
#> $row.names</a>
#> [1] 1 2 3 4 5</a>
#> </a>
#> $class</a>
#> [1] "tbl_df"     "tbl"        "data.frame"</code>

The difference between a tibble and a list is that all the elements of a data frame must be vectors with the same length. 
All functions that work with tibbles enforce this constraint.

Traditional data.frames have a very similar structure:

<code>df &lt;- data.frame(x = 1:5, y = 5:1)</a>
typeof(df)</a>
#> [1] "list"</a>
attributes(df)</a>
#> $names</a>
#> [1] "x" "y"</a>
#> </a>
#> $class</a>
#> [1] "data.frame"</a>
#> </a>
#> $row.names</a>
#> [1] 1 2 3 4 5</code>

The main difference is the class. 
The class of tibble includes 'data.frame' which means tibbles inherit the regular data frame behaviour by default.

<h3>20.7.4 Exercises</h3>

What does <code>hms::hms(3600)</code> return? How does it print? What primitive
type is the augmented vector built on top of? What attributes does it
use?

Try and make a tibble that has columns with different lengths. 
What
happens?

Based on the definition above, is it ok to have a list as a
column of a tibble?

<h2><span class="orange">21 Iteration</span></h2>

<h2>21.1 Introduction</h2>
In <a href="functions.html#functions">functions</a>, we talked about how important it is to reduce duplication in your code by creating functions instead of copying-and-pasting. 
Reducing code duplication has three main benefits:

It’s easier to see the intent of your code, because your eyes are
drawn to what’s different, not what stays the same.

It’s easier to respond to changes in requirements. 
As your needs
change, you only need to make changes in one place, rather than
remembering to change every place that you copied-and-pasted the
code.

You’re likely to have fewer bugs because each line of code is
used in more places.

One tool for reducing duplication is functions, which reduce duplication by identifying repeated patterns of code and extract them out into independent pieces that can be easily reused and updated. 
Another tool for reducing duplication is iteration, which helps you when you need to do the same thing to multiple inputs: repeating the same operation on different columns, or on different datasets.
In this chapter you’ll learn about two important iteration paradigms: imperative programming and functional programming. 
On the imperative side you have tools like for loops and while loops, which are a great place to start because they make iteration very explicit, so it’s obvious what’s happening. 
However, for loops are quite verbose, and require quite a bit of bookkeeping code that is duplicated for every for loop. 
Functional programming (FP) offers tools to extract out this duplicated code, so each common for loop pattern gets its own function. 
Once you master the vocabulary of FP, you can solve many common iteration problems with less code, more ease, and fewer errors.

<h3>21.1.1 Prerequisites</h3>
Once you’ve mastered the for loops provided by base R, you’ll learn some of the powerful programming tools provided by purrr, one of the tidyverse core packages.

<code>library(tidyverse)</code>

<h2>21.2 For loops</h2>
Imagine we have this simple tibble:

<code>df &lt;- tibble(</a>
  a = rnorm(10),</a>
  b = rnorm(10),</a>
  c = rnorm(10),</a>
  d = rnorm(10)</a>
)</code>

We want to compute the median of each column. 
You <em>could</em> do with copy-and-paste:

<code>median(df$a)</a>
#> [1] -0.246</a>
median(df$b)</a>
#> [1] -0.287</a>
median(df$c)</a>
#> [1] -0.0567</a>
median(df$d)</a>
#> [1] 0.144</code>

But that breaks our rule of thumb: never copy and paste more than twice. 
Instead, we could use a for loop:

<code>output &lt;- vector("double", ncol(df))  # 1. 
output</a>
for (i in seq_along(df)) {            # 2. 
sequence</a>
  output[[i]] &lt;- median(df[[i]])      # 3. 
body</a>
}</a>
output</a>
#> [1] -0.2458 -0.2873 -0.0567  0.1443</code>

Every for loop has three components:

The output: <code>output &lt;- vector("double", length(x))</code>.
Before you start the loop, you must always allocate sufficient space
for the output. 
This is very important for efficiency: if you grow
the for loop at each iteration using <code>c()</code> (for example), your for loop
will be very slow.

A general way of creating an empty vector of given length is the <code>vector()</code>
function. 
It has two arguments: the type of the vector ('logical',
'integer', 'double', 'character', etc) and the length of the vector.

The sequence: <code>i in seq_along(df)</code>. 
This determines what to loop over:
each run of the for loop will assign <code>i</code> to a different value from
<code>seq_along(df)</code>. 
It’s useful to think of <code>i</code> as a pronoun, like 'it'.

You might not have seen <code>seq_along()</code> before. 
It’s a safe version of the
familiar <code>1:length(l)</code>, with an important difference: if you have a
zero-length vector, <code>seq_along()</code> does the right thing:

<code>y &lt;- vector("double", 0)</a>
seq_along(y)</a>
#> integer(0)</a>
1:length(y)</a>
#> [1] 1 0</code>

You probably won’t create a zero-length vector deliberately, but
it’s easy to create them accidentally. 
If you use <code>1:length(x)</code> instead
of <code>seq_along(x)</code>, you’re likely to get a confusing error message.

The body: <code>output[[i]] &lt;- median(df[[i]])</code>. 
This is the code that does
the work. 
It’s run repeatedly, each time with a different value for <code>i</code>.
The first iteration will run <code>output[[1]] &lt;- median(df[[1]])</code>,
the second will run <code>output[[2]] &lt;- median(df[[2]])</code>, and so on.

That’s all there is to the for loop! Now is a good time to practice creating some basic (and not so basic) for loops using the exercises below. 
Then we’ll move on some variations of the for loop that help you solve other problems that will crop up in practice.

<h3>21.2.1 Exercises</h3>

Write for loops to:

Compute the mean of every column in <code>mtcars</code>.

Determine the type of each column in <code>nycflights13::flights</code>.

Compute the number of unique values in each column of <code>iris</code>.

Generate 10 random normals from distributions with means of -10, 0, 10, and 100.

Think about the output, sequence, and body before you start writing
the loop.

Eliminate the for loop in each of the following examples by taking
advantage of an existing function that works with vectors:

<code>out &lt;- "</a>
for (x in letters) {</a>
  out &lt;- stringr::str_c(out, x)</a>
}</a>
</a>
x &lt;- sample(100)</a>
sd &lt;- 0</a>
for (i in seq_along(x)) {</a>
  sd &lt;- sd + (x[i] - mean(x)) ^ 2</a>
}</a>
sd &lt;- sqrt(sd / (length(x) - 1))</a>
</a>
x &lt;- runif(100)</a>
out &lt;- vector("numeric", length(x))</a>
out[1] &lt;- x[1]</a>
for (i in 2:length(x)) {</a>
  out[i] &lt;- out[i - 1] + x[i]</a>
}</code>

Combine your function writing and for loop skills:

Write a for loop that <code>prints()</code> the lyrics to the children’s song
'Alice the camel'.

Convert the nursery rhyme 'ten in the bed' to a function. 
Generalise
it to any number of people in any sleeping structure.

Convert the song '99 bottles of beer on the wall' to a function.
Generalise to any number of any vessel containing any liquid on
any surface.

It’s common to see for loops that don’t preallocate the output and instead
increase the length of a vector at each step:

<code>output &lt;- vector("integer", 0)</a>
for (i in seq_along(x)) {</a>
  output &lt;- c(output, lengths(x[[i]]))</a>
}</a>
output</code>

How does this affect performance? Design and execute an experiment.

<h2>21.3 For loop variations</h2>
Once you have the basic for loop under your belt, there are some variations that you should be aware of. 
These variations are important regardless of how you do iteration, so don’t forget about them once you’ve mastered the FP techniques you’ll learn about in the next section.

There are four variations on the basic theme of the for loop:

Modifying an existing object, instead of creating a new object.

Looping over names or values, instead of indices.

Handling outputs of unknown length.

Handling sequences of unknown length.

<h3>21.3.1 Modifying an existing object</h3>
Sometimes you want to use a for loop to modify an existing object. 
For example, remember our challenge from <a href="functions.html#functions">functions</a>. 
We wanted to rescale every column in a data frame:

<code>df &lt;- tibble(</a>
  a = rnorm(10),</a>
  b = rnorm(10),</a>
  c = rnorm(10),</a>
  d = rnorm(10)</a>
)</a>
rescale01 &lt;- function(x) {</a>
  rng &lt;- range(x, na.rm = TRUE)</a>
  (x - rng[1]) / (rng[2] - rng[1])</a>
}</a>
</a>
df$a &lt;- rescale01(df$a)</a>
df$b &lt;- rescale01(df$b)</a>
df$c &lt;- rescale01(df$c)</a>
df$d &lt;- rescale01(df$d)</code>

To solve this with a for loop we again think about the three components:

Output: we already have the output — it’s the same as the input!

Sequence: we can think about a data frame as a list of columns, so
we can iterate over each column with <code>seq_along(df)</code>.

Body: apply <code>rescale01()</code>.

This gives us:

<code>for (i in seq_along(df)) {</a>
  df[[i]] &lt;- rescale01(df[[i]])</a>
}</code>

Typically you’ll be modifying a list or data frame with this sort of loop, so remember to use <code>[[</code>, not <code>[</code>. 
You might have spotted that I used <code>[[</code> in all my for loops: I think it’s better to use <code>[[</code> even for atomic vectors because it makes it clear that I want to work with a single element.

<h3>21.3.2 Looping patterns</h3>
There are three basic ways to loop over a vector. 
So far I’ve shown you the most general: looping over the numeric indices with <code>for (i in seq_along(xs))</code>, and extracting the value with <code>x[[i]]</code>. 
There are two other forms:

Loop over the elements: <code>for (x in xs)</code>. 
This is most useful if you only
care about side-effects, like plotting or saving a file, because it’s
difficult to save the output efficiently.

Loop over the names: <code>for (nm in names(xs))</code>. 
This gives you name, which
you can use to access the value with <code>x[[nm]]</code>. 
This is useful if you want
to use the name in a plot title or a file name. 
If you’re creating
named output, make sure to name the results vector like so:

<code>results &lt;- vector("list", length(x))</a>
names(results) &lt;- names(x)</code>

Iteration over the numeric indices is the most general form, because given the position you can extract both the name and the value:

<code>for (i in seq_along(x)) {</a>
  name &lt;- names(x)[[i]]</a>
  value &lt;- x[[i]]</a>
}</code>

<h3>21.3.3 Unknown output length</h3>
Sometimes you might not know how long the output will be. 
For example, imagine you want to simulate some random vectors of random lengths. 
You might be tempted to solve this problem by progressively growing the vector:

<code>means &lt;- c(0, 1, 2)</a>
</a>
output &lt;- double()</a>
for (i in seq_along(means)) {</a>
  n &lt;- sample(100, 1)</a>
  output &lt;- c(output, rnorm(n, means[[i]]))</a>
}</a>
str(output)</a>
#>  num [1:138] 0.912 0.205 2.584 -0.789 0.588 ...</code>

But this is not very efficient because in each iteration, R has to copy all the data from the previous iterations. 
In technical terms you get 'quadratic' (\(O(n^2)\)) behaviour which means that a loop with three times as many elements would take nine (\(3^2\)) times as long to run.

A better solution to save the results in a list, and then combine into a single vector after the loop is done:

<code>out &lt;- vector("list", length(means))</a>
for (i in seq_along(means)) {</a>
  n &lt;- sample(100, 1)</a>
  out[[i]] &lt;- rnorm(n, means[[i]])</a>
}</a>
str(out)</a>
#> List of 3</a>
#>  $ : num [1:76] -0.3389 -0.0756 0.0402 0.1243 -0.9984 ...</a>
#>  $ : num [1:17] -0.11 1.149 0.614 0.77 1.392 ...</a>
#>  $ : num [1:41] 1.88 2.46 2.62 1.82 1.88 ...</a>
str(unlist(out))</a>
#>  num [1:134] -0.3389 -0.0756 0.0402 0.1243 -0.9984 ...</code>

Here I’ve used <code>unlist()</code> to flatten a list of vectors into a single vector. 
A stricter option is to use <code>purrr::flatten_dbl()</code> — it will throw an error if the input isn’t a list of doubles.

This pattern occurs in other places too:

You might be generating a long string. 
Instead of <code>paste()</code>ing together
each iteration with the previous, save the output in a character vector and
then combine that vector into a single string with
<code>paste(output, collapse = ")</code>.

You might be generating a big data frame. 
Instead of sequentially
<code>rbind()</code>ing in each iteration, save the output in a list, then use
<code>dplyr::bind_rows(output)</code> to combine the output into a single
data frame.

Watch out for this pattern. 
Whenever you see it, switch to a more complex result object, and then combine in one step at the end.

<h3>21.3.4 Unknown sequence length</h3>
Sometimes you don’t even know how long the input sequence should run for. 
This is common when doing simulations. 
For example, you might want to loop until you get three heads in a row. 
You can’t do that sort of iteration with the for loop. 
Instead, you can use a while loop. 
A while loop is simpler than for loop because it only has two components, a condition and a body:

<code>while (condition) {</a>
  # body</a>
}</code>

A while loop is also more general than a for loop, because you can rewrite any for loop as a while loop, but you can’t rewrite every while loop as a for loop:

<code>for (i in seq_along(x)) {</a>
  # body</a>
}</a>
</a>
# Equivalent to</a>
i &lt;- 1</a>
while (i &lt;= length(x)) {</a>
  # body</a>
  i &lt;- i + 1 </a>
}</code>

Here’s how we could use a while loop to find how many tries it takes to get three heads in a row:

<code>flip &lt;- function() sample(c("T", "H"), 1)</a>
</a>
flips &lt;- 0</a>
nheads &lt;- 0</a>
</a>
while (nheads &lt; 3) {</a>
  if (flip() == "H") {</a>
    nheads &lt;- nheads + 1</a>
  } else {</a>
    nheads &lt;- 0</a>
  }</a>
  flips &lt;- flips + 1</a>
}</a>
flips</a>
#> [1] 21</code>

I mention while loops only briefly, because I hardly ever use them. 
They’re most often used for simulation, which is outside the scope of this book. 
However, it is good to know they exist so that you’re prepared for problems where the number of iterations is not known in advance.

<h3>21.3.5 Exercises</h3>

Imagine you have a directory full of CSV files that you want to read in.
You have their paths in a vector,
<code>files &lt;- dir("data/", pattern = "\\.csv$", full.names = TRUE)</code>, and now
want to read each one with <code>read_csv()</code>. 
Write the for loop that will
load them into a single data frame.

What happens if you use <code>for (nm in names(x))</code> and <code>x</code> has no names?
What if only some of the elements are named? What if the names are
not unique?

Write a function that prints the mean of each numeric column in a data
frame, along with its name. 
For example, <code>show_mean(iris)</code> would print:

<code>show_mean(iris)</a>
#> Sepal.Length: 5.84</a>
#> Sepal.Width:  3.06</a>
#> Petal.Length: 3.76</a>
#> Petal.Width:  1.20</code>

(Extra challenge: what function did I use to make sure that the numbers
lined up nicely, even though the variable names had different lengths?)

What does this code do? How does it work?

<code>trans &lt;- list( </a>
  disp = function(x) x * 0.0163871,</a>
  am = function(x) {</a>
    factor(x, labels = c("auto", "manual"))</a>
  }</a>
)</a>
for (var in names(trans)) {</a>
  mtcars[[var]] &lt;- trans[[var]](mtcars[[var]])</a>
}</code>

<h2>21.4 For loops vs. functionals</h2>
For loops are not as important in R as they are in other languages because R is a functional programming language. 
This means that it’s possible to wrap up for loops in a function, and call that function instead of using the for loop directly.

To see why this is important, consider (again) this simple data frame:

<code>df &lt;- tibble(</a>
  a = rnorm(10),</a>
  b = rnorm(10),</a>
  c = rnorm(10),</a>
  d = rnorm(10)</a>
)</code>

Imagine you want to compute the mean of every column. 
You could do that with a for loop:

<code>output &lt;- vector("double", length(df))</a>
for (i in seq_along(df)) {</a>
  output[[i]] &lt;- mean(df[[i]])</a>
}</a>
output</a>
#> [1] -0.326  0.136  0.429 -0.250</code>

You realise that you’re going to want to compute the means of every column pretty frequently, so you extract it out into a function:

<code>col_mean &lt;- function(df) {</a>
  output &lt;- vector("double", length(df))</a>
  for (i in seq_along(df)) {</a>
    output[i] &lt;- mean(df[[i]])</a>
  }</a>
  output</a>
}</code>

But then you think it’d also be helpful to be able to compute the median, and the standard deviation, so you copy and paste your <code>col_mean()</code> function and replace the <code>mean()</code> with <code>median()</code> and <code>sd()</code>:

<code>col_median &lt;- function(df) {</a>
  output &lt;- vector("double", length(df))</a>
  for (i in seq_along(df)) {</a>
    output[i] &lt;- median(df[[i]])</a>
  }</a>
  output</a>
}</a>
col_sd &lt;- function(df) {</a>
  output &lt;- vector("double", length(df))</a>
  for (i in seq_along(df)) {</a>
    output[i] &lt;- sd(df[[i]])</a>
  }</a>
  output</a>
}</code>

Uh oh! You’ve copied-and-pasted this code twice, so it’s time to think about how to generalise it. 
Notice that most of this code is for-loop boilerplate and it’s hard to see the one thing (<code>mean()</code>, <code>median()</code>, <code>sd()</code>) that is different between the functions.

What would you do if you saw a set of functions like this:

<code>f1 &lt;- function(x) abs(x - mean(x)) ^ 1</a>
f2 &lt;- function(x) abs(x - mean(x)) ^ 2</a>
f3 &lt;- function(x) abs(x - mean(x)) ^ 3</code>

Hopefully, you’d notice that there’s a lot of duplication, and extract it out into an additional argument:

<code>f &lt;- function(x, i) abs(x - mean(x)) ^ i</code>

You’ve reduced the chance of bugs (because you now have 1/3 of the original code), and made it easy to generalise to new situations.

We can do exactly the same thing with <code>col_mean()</code>, <code>col_median()</code> and <code>col_sd()</code> by adding an argument that supplies the function to apply to each column:

<code>col_summary &lt;- function(df, fun) {</a>
  out &lt;- vector("double", length(df))</a>
  for (i in seq_along(df)) {</a>
    out[i] &lt;- fun(df[[i]])</a>
  }</a>
  out</a>
}</a>
col_summary(df, median)</a>
#> [1] -0.5185  0.0278  0.1730 -0.6116</a>
col_summary(df, mean)</a>
#> [1] -0.326  0.136  0.429 -0.250</code>

The idea of passing a function to another function is an extremely powerful idea, and it’s one of the behaviours that makes R a functional programming language. 
It might take you a while to wrap your head around the idea, but it’s worth the investment. 
In the rest of the chapter, you’ll learn about and use the purrr package, which provides functions that eliminate the need for many common for loops. 
The apply family of functions in base R (<code>apply()</code>, <code>lapply()</code>, <code>tapply()</code>, etc) solve a similar problem, but purrr is more consistent and thus is easier to learn.

The goal of using purrr functions instead of for loops is to allow you to break common list manipulation challenges into independent pieces:

How can you solve the problem for a single element of the list? Once
you’ve solved that problem, purrr takes care of generalising your
solution to every element in the list.

If you’re solving a complex problem, how can you break it down into
bite-sized pieces that allow you to advance one small step towards a
solution? With purrr, you get lots of small pieces that you can
compose together with the pipe.

This structure makes it easier to solve new problems. 
It also makes it easier to understand your solutions to old problems when you re-read your old code.

<h3>21.4.1 Exercises</h3>

Read the documentation for <code>apply()</code>. 
In the 2d case, what two for loops
does it generalise?

Adapt <code>col_summary()</code> so that it only applies to numeric columns
You might want to start with an <code>is_numeric()</code> function that returns
a logical vector that has a TRUE corresponding to each numeric column.

<h2>21.5 The map functions</h2>
The pattern of looping over a vector, doing something to each element and saving the results is so common that the purrr package provides a family of functions to do it for you. 
There is one function for each type of output:

<code>map()</code> makes a list.

<code>map_lgl()</code> makes a logical vector.

<code>map_int()</code> makes an integer vector.

<code>map_dbl()</code> makes a double vector.

<code>map_chr()</code> makes a character vector.

Each function takes a vector as input, applies a function to each piece, and then returns a new vector that’s the same length (and has the same names) as the input. 
The type of the vector is determined by the suffix to the map function.

Once you master these functions, you’ll find it takes much less time to solve iteration problems. 
But you should never feel bad about using a for loop instead of a map function. 
The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work. 
The important thing is that you solve the problem that you’re working on, not write the most concise and elegant code (although that’s definitely something you want to strive towards!).

Some people will tell you to avoid for loops because they are slow. 
They’re wrong! (Well at least they’re rather out of date, as for loops haven’t been slow for many years.) The chief benefits of using functions like <code>map()</code> is not speed, but clarity: they make your code easier to write and to read.

We can use these functions to perform the same computations as the last for loop. 
Those summary functions returned doubles, so we need to use <code>map_dbl()</code>:

<code>map_dbl(df, mean)</a>
#>      a      b      c      d </a>
#> -0.326  0.136  0.429 -0.250</a>
map_dbl(df, median)</a>
#>       a       b       c       d </a>
#> -0.5185  0.0278  0.1730 -0.6116</a>
map_dbl(df, sd)</a>
#>     a     b     c     d </a>
#> 0.921 0.485 0.982 1.156</code>

Compared to using a for loop, focus is on the operation being performed (i.e. 
<code>mean()</code>, <code>median()</code>, <code>sd()</code>), not the bookkeeping required to loop over every element and store the output. 
This is even more apparent if we use the pipe:

<code>df %>% map_dbl(mean)</a>
#>      a      b      c      d </a>
#> -0.326  0.136  0.429 -0.250</a>
df %>% map_dbl(median)</a>
#>       a       b       c       d </a>
#> -0.5185  0.0278  0.1730 -0.6116</a>
df %>% map_dbl(sd)</a>
#>     a     b     c     d </a>
#> 0.921 0.485 0.982 1.156</code>

There are a few differences between <code>map_*()</code> and <code>col_summary()</code>:

All purrr functions are implemented in C. 
This makes them a little faster
at the expense of readability.

The second argument, <code>.f</code>, the function to apply, can be a formula, a
character vector, or an integer vector. 
You’ll learn about those handy
shortcuts in the next section.

<code>map_*()</code> uses … ([dot dot dot]) to pass along additional arguments
to <code>.f</code> each time it’s called:

<code>map_dbl(df, mean, trim = 0.5)</a>
#>       a       b       c       d </a>
#> -0.5185  0.0278  0.1730 -0.6116</code>

The map functions also preserve names:

<code>z &lt;- list(x = 1:3, y = 4:5)</a>
map_int(z, length)</a>
#> x y </a>
#> 3 2</code>

<h3>21.5.1 Shortcuts</h3>
There are a few shortcuts that you can use with <code>.f</code> in order to save a little typing. 
Imagine you want to fit a linear model to each group in a dataset. 
The following toy example splits up the <code>mtcars</code> dataset into three pieces (one for each value of cylinder) and fits the same linear model to each piece:

<code>models &lt;- mtcars %>% </a>
  split(.$cyl) %>% </a>
  map(function(df) lm(mpg ~ wt, data = df))</code>

The syntax for creating an anonymous function in R is quite verbose so purrr provides a convenient shortcut: a one-sided formula.

<code>models &lt;- mtcars %>% </a>
  split(.$cyl) %>% </a>
  map(~lm(mpg ~ wt, data = .))</code>

Here I’ve used <code>.</code> as a pronoun: it refers to the current list element (in the same way that <code>i</code> referred to the current index in the for loop).

When you’re looking at many models, you might want to extract a summary statistic like the \(R^2\). 
To do that we need to first run <code>summary()</code> and then extract the component called <code>r.squared</code>. 
We could do that using the shorthand for anonymous functions:

<code>models %>% </a>
  map(summary) %>% </a>
  map_dbl(~.$r.squared)</a>
#>     4     6     8 </a>
#> 0.509 0.465 0.423</code>

But extracting named components is a common operation, so purrr provides an even shorter shortcut: you can use a string.

<code>models %>% </a>
  map(summary) %>% </a>
  map_dbl("r.squared")</a>
#>     4     6     8 </a>
#> 0.509 0.465 0.423</code>

You can also use an integer to select elements by position:

<code>x &lt;- list(list(1, 2, 3), list(4, 5, 6), list(7, 8, 9))</a>
x %>% map_dbl(2)</a>
#> [1] 2 5 8</code>

<h3>21.5.2 Base R</h3>
If you’re familiar with the apply family of functions in base R, you might have noticed some similarities with the purrr functions:

<code>lapply()</code> is basically identical to <code>map()</code>, except that <code>map()</code> is
consistent with all the other functions in purrr, and you can use the
shortcuts for <code>.f</code>.

Base <code>sapply()</code> is a wrapper around <code>lapply()</code> that automatically
simplifies the output. 
This is useful for interactive work but is
problematic in a function because you never know what sort of output
you’ll get:

<code>x1 &lt;- list(</a>
  c(0.27, 0.37, 0.57, 0.91, 0.20),</a>
  c(0.90, 0.94, 0.66, 0.63, 0.06), </a>
  c(0.21, 0.18, 0.69, 0.38, 0.77)</a>
)</a>
x2 &lt;- list(</a>
  c(0.50, 0.72, 0.99, 0.38, 0.78), </a>
  c(0.93, 0.21, 0.65, 0.13, 0.27), </a>
  c(0.39, 0.01, 0.38, 0.87, 0.34)</a>
)</a>
</a>
threshold &lt;- function(x, cutoff = 0.8) x[x > cutoff]</a>
x1 %>% sapply(threshold) %>% str()</a>
#> List of 3</a>
#>  $ : num 0.91</a>
#>  $ : num [1:2] 0.9 0.94</a>
#>  $ : num(0)</a>
x2 %>% sapply(threshold) %>% str()</a>
#>  num [1:3] 0.99 0.93 0.87</code>

<code>vapply()</code> is a safe alternative to <code>sapply()</code> because you supply an
additional argument that defines the type. 
The only problem with
<code>vapply()</code> is that it’s a lot of typing:
<code>vapply(df, is.numeric, logical(1))</code> is equivalent to
<code>map_lgl(df, is.numeric)</code>. 
One advantage of <code>vapply()</code> over purrr’s map
functions is that it can also produce matrices — the map functions only
ever produce vectors.

I focus on purrr functions here because they have more consistent names and arguments, helpful shortcuts, and in the future will provide easy parallelism and progress bars.

<h3>21.5.3 Exercises</h3>

Write code that uses one of the map functions to:

Compute the mean of every column in <code>mtcars</code>.

Determine the type of each column in <code>nycflights13::flights</code>.

Compute the number of unique values in each column of <code>iris</code>.

Generate 10 random normals from distributions with means of -10, 0, 10, and 100.

How can you create a single vector that for each column in a data frame
indicates whether or not it’s a factor?

What happens when you use the map functions on vectors that aren’t lists?
What does <code>map(1:5, runif)</code> do? Why?

What does <code>map(-2:2, rnorm, n = 5)</code> do? Why?
What does <code>map_dbl(-2:2, rnorm, n = 5)</code> do? Why?

Rewrite <code>map(x, function(df) lm(mpg ~ wt, data = df))</code> to eliminate the
anonymous function.

<h2>21.6 Dealing with failure</h2>
When you use the map functions to repeat many operations, the chances are much higher that one of those operations will fail. 
When this happens, you’ll get an error message, and no output. 
This is annoying: why does one failure prevent you from accessing all the other successes? How do you ensure that one bad apple doesn’t ruin the whole barrel?

In this section you’ll learn how to deal with this situation with a new function: <code>safely()</code>. 
<code>safely()</code> is an adverb: it takes a function (a verb) and returns a modified version. 
In this case, the modified function will never throw an error. 
Instead, it always returns a list with two elements:

<code>result</code> is the original result. 
If there was an error, this will be <code>NULL</code>.

<code>error</code> is an error object. 
If the operation was successful, this will be
<code>NULL</code>.

(You might be familiar with the <code>try()</code> function in base R. 
It’s similar, but because it sometimes returns the original result and it sometimes returns an error object it’s more difficult to work with.)

Let’s illustrate this with a simple example: <code>log()</code>:

<code>safe_log &lt;- safely(log)</a>
str(safe_log(10))</a>
#> List of 2</a>
#>  $ result: num 2.3</a>
#>  $ error : NULL</a>
str(safe_log("a"))</a>
#> List of 2</a>
#>  $ result: NULL</a>
#>  $ error :List of 2</a>
#>   ..$ message: chr "non-numeric argument to mathematical function"</a>
#>   ..$ call   : language .Primitive("log")(x, base)</a>
#>   ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"</code>

When the function succeeds, the <code>result</code> element contains the result and the <code>error</code> element is <code>NULL</code>. 
When the function fails, the <code>result</code> element is <code>NULL</code> and the <code>error</code> element contains an error object.

<code>safely()</code> is designed to work with map:

<code>x &lt;- list(1, 10, "a")</a>
y &lt;- x %>% map(safely(log))</a>
str(y)</a>
#> List of 3</a>
#>  $ :List of 2</a>
#>   ..$ result: num 0</a>
#>   ..$ error : NULL</a>
#>  $ :List of 2</a>
#>   ..$ result: num 2.3</a>
#>   ..$ error : NULL</a>
#>  $ :List of 2</a>
#>   ..$ result: NULL</a>
#>   ..$ error :List of 2</a>
#>   .. 
..$ message: chr "non-numeric argument to mathematical function"</a>
#>   .. 
..$ call   : language .Primitive("log")(x, base)</a>
#>   .. 
..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"</code>

This would be easier to work with if we had two lists: one of all the errors and one of all the output. 
That’s easy to get with <code>purrr::transpose()</code>:

<code>y &lt;- y %>% transpose()</a>
str(y)</a>
#> List of 2</a>
#>  $ result:List of 3</a>
#>   ..$ : num 0</a>
#>   ..$ : num 2.3</a>
#>   ..$ : NULL</a>
#>  $ error :List of 3</a>
#>   ..$ : NULL</a>
#>   ..$ : NULL</a>
#>   ..$ :List of 2</a>
#>   .. 
..$ message: chr "non-numeric argument to mathematical function"</a>
#>   .. 
..$ call   : language .Primitive("log")(x, base)</a>
#>   .. 
..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"</code>

It’s up to you how to deal with the errors, but typically you’ll either look at the values of <code>x</code> where <code>y</code> is an error, or work with the values of <code>y</code> that are ok:

<code>is_ok &lt;- y$error %>% map_lgl(is_null)</a>
x[!is_ok]</a>
#> [[1]]</a>
#> [1] "a"</a>
y$result[is_ok] %>% flatten_dbl()</a>
#> [1] 0.0 2.3</code>

Purrr provides two other useful adverbs:

Like <code>safely()</code>, <code>possibly()</code> always succeeds. 
It’s simpler than <code>safely()</code>,
because you give it a default value to return when there is an error.

<code>x &lt;- list(1, 10, "a")</a>
x %>% map_dbl(possibly(log, NA_real_))</a>
#> [1] 0.0 2.3  NA</code>

<code>quietly()</code> performs a similar role to <code>safely()</code>, but instead of capturing
errors, it captures printed output, messages, and warnings:

<code>x &lt;- list(1, -1)</a>
x %>% map(quietly(log)) %>% str()</a>
#> List of 2</a>
#>  $ :List of 4</a>
#>   ..$ result  : num 0</a>
#>   ..$ output  : chr "</a>
#>   ..$ warnings: chr(0) </a>
#>   ..$ messages: chr(0) </a>
#>  $ :List of 4</a>
#>   ..$ result  : num NaN</a>
#>   ..$ output  : chr "</a>
#>   ..$ warnings: chr "NaNs produced"</a>
#>   ..$ messages: chr(0)</code>

<h2>21.7 Mapping over multiple arguments</h2>
So far we’ve mapped along a single input. 
But often you have multiple related inputs that you need iterate along in parallel. 
That’s the job of the <code>map2()</code> and <code>pmap()</code> functions. 
For example, imagine you want to simulate some random normals with different means. 
You know how to do that with <code>map()</code>:

<code>mu &lt;- list(5, 10, -3)</a>
mu %>% </a>
  map(rnorm, n = 5) %>% </a>
  str()</a>
#> List of 3</a>
#>  $ : num [1:5] 5.63 7.1 4.39 3.37 4.99</a>
#>  $ : num [1:5] 9.34 9.33 9.52 11.32 10.64</a>
#>  $ : num [1:5] -2.49 -4.75 -2.11 -2.78 -2.42</code>

What if you also want to vary the standard deviation? One way to do that would be to iterate over the indices and index into vectors of means and sds:

<code>sigma &lt;- list(1, 5, 10)</a>
seq_along(mu) %>% </a>
  map(~rnorm(5, mu[[.]], sigma[[.]])) %>% </a>
  str()</a>
#> List of 3</a>
#>  $ : num [1:5] 4.82 5.74 4 2.06 5.72</a>
#>  $ : num [1:5] 6.51 0.529 10.381 14.377 12.269</a>
#>  $ : num [1:5] -11.51 2.66 8.52 -10.56 -7.89</code>

But that obfuscates the intent of the code. 
Instead we could use <code>map2()</code> which iterates over two vectors in parallel:

<code>map2(mu, sigma, rnorm, n = 5) %>% str()</a>
#> List of 3</a>
#>  $ : num [1:5] 3.83 4.52 5.12 3.23 3.59</a>
#>  $ : num [1:5] 13.55 3.8 8.16 12.31 8.39</a>
#>  $ : num [1:5] -15.872 -13.3 12.141 0.469 14.794</code>

<code>map2()</code> generates this series of function calls:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/68a21c4a103426c3b311c9dcfad8fe379d4892f1/55c9d/diagrams/lists-map2.png" width="70%" style="display: block; margin: auto;" />

Note that the arguments that vary for each call come <em>before</em> the function; arguments that are the same for every call come <em>after</em>.

Like <code>map()</code>, <code>map2()</code> is just a wrapper around a for loop:

<code>map2 &lt;- function(x, y, f, ...) {</a>
  out &lt;- vector("list", length(x))</a>
  for (i in seq_along(x)) {</a>
    out[[i]] &lt;- f(x[[i]], y[[i]], ...)</a>
  }</a>
  out</a>
}</code>

You could also imagine <code>map3()</code>, <code>map4()</code>, <code>map5()</code>, <code>map6()</code> etc, but that would get tedious quickly. 
Instead, purrr provides <code>pmap()</code> which takes a list of arguments. 
You might use that if you wanted to vary the mean, standard deviation, and number of samples:

<code>n &lt;- list(1, 3, 5)</a>
args1 &lt;- list(n, mu, sigma)</a>
args1 %>%</a>
  pmap(rnorm) %>% </a>
  str()</a>
#> List of 3</a>
#>  $ : num 5.39</a>
#>  $ : num [1:3] 5.41 2.08 9.58</a>
#>  $ : num [1:5] -23.85 -2.96 -6.56 8.46 -5.21</code>

That looks like:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/88993b07b533d99ca08ce805d0a25e909745b03c/b6d84/diagrams/lists-pmap-unnamed.png" width="70%" style="display: block; margin: auto;" />

If you don’t name the list’s elements, <code>pmap()</code> will use positional matching when calling the function. 
That’s a little fragile, and makes the code harder to read, so it’s better to name the arguments:

<code>args2 &lt;- list(mean = mu, sd = sigma, n = n)</a>
args2 %>% </a>
  pmap(rnorm) %>% </a>
  str()</code>

That generates longer, but safer, calls:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6da05576a8c55e4ee1ecb2e2c5c9a35e710abacd/b9ea6/diagrams/lists-pmap-named.png" width="70%" style="display: block; margin: auto;" />

Since the arguments are all the same length, it makes sense to store them in a data frame:

<code>params &lt;- tribble(</a>
  ~mean, ~sd, ~n,</a>
    5,     1,  1,</a>
   10,     5,  3,</a>
   -3,    10,  5</a>
)</a>
params %>% </a>
  pmap(rnorm)</a>
#> [[1]]</a>
#> [1] 6.02</a>
#> </a>
#> [[2]]</a>
#> [1]  8.68 18.29  6.13</a>
#> </a>
#> [[3]]</a>
#> [1] -12.24  -5.76  -8.93  -4.22   8.80</code>

As soon as your code gets complicated, I think a data frame is a good approach because it ensures that each column has a name and is the same length as all the other columns.

<h3>21.7.1 Invoking different functions</h3>
There’s one more step up in complexity - as well as varying the arguments to the function you might also vary the function itself:

<code>f &lt;- c("runif", "rnorm", "rpois")</a>
param &lt;- list(</a>
  list(min = -1, max = 1), </a>
  list(sd = 5), </a>
  list(lambda = 10)</a>
)</code>

To handle this case, you can use <code>invoke_map()</code>:

<code>invoke_map(f, param, n = 5) %>% str()</a>
#> List of 3</a>
#>  $ : num [1:5] 0.479 0.439 -0.471 0.348 -0.581</a>
#>  $ : num [1:5] 2.48 3.9 7.54 -9.12 3.94</a>
#>  $ : int [1:5] 6 11 5 8 9</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/46ce0bbefff56809de8d5276120031a21e1bbbf1/753f2/diagrams/lists-invoke.png" width="1110" style="display: block; margin: auto;" />

The first argument is a list of functions or character vector of function names. 
The second argument is a list of lists giving the arguments that vary for each function. 
The subsequent arguments are passed on to every function.

And again, you can use <code>tribble()</code> to make creating these matching pairs a little easier:

<code>sim &lt;- tribble(</a>
  ~f,      ~params,</a>
  "runif", list(min = -1, max = 1),</a>
  "rnorm", list(sd = 5),</a>
  "rpois", list(lambda = 10)</a>
)</a>
sim %>% </a>
  mutate(sim = invoke_map(f, params, n = 10))</code>

<h2>21.8 Walk</h2>
Walk is an alternative to map that you use when you want to call a function for its side effects, rather than for its return value. 
You typically do this because you want to render output to the screen or save files to disk - the important thing is the action, not the return value. 
Here’s a very simple example:

<code>x &lt;- list(1, "a", 3)</a>
</a>
x %>% </a>
  walk(print)</a>
#> [1] 1</a>
#> [1] "a"</a>
#> [1] 3</code>

<code>walk()</code> is generally not that useful compared to <code>walk2()</code> or <code>pwalk()</code>. 
For example, if you had a list of plots and a vector of file names, you could use <code>pwalk()</code> to save each file to the corresponding location on disk:

<code>library(ggplot2)</a>
plots &lt;- mtcars %>% </a>
  split(.$cyl) %>% </a>
  map(~ggplot(., aes(mpg, wt)) + geom_point())</a>
paths &lt;- stringr::str_c(names(plots), ".pdf")</a>
</a>
pwalk(list(paths, plots), ggsave, path = tempdir())</code>

<code>walk()</code>, <code>walk2()</code> and <code>pwalk()</code> all invisibly return <code>.x</code>, the first argument. 
This makes them suitable for use in the middle of pipelines.

<h2>21.9 Other patterns of for loops</h2>
Purrr provides a number of other functions that abstract over other types of for loops. 
You’ll use them less frequently than the map functions, but they’re useful to know about. 
The goal here is to briefly illustrate each function, so hopefully it will come to mind if you see a similar problem in the future. 
Then you can go look up the documentation for more details.

<h3>21.9.1 Predicate functions</h3>
A number of functions work with predicate functions that return either a single <code>TRUE</code> or <code>FALSE</code>.

<code>keep()</code> and <code>discard()</code> keep elements of the input where the predicate is <code>TRUE</code> or <code>FALSE</code> respectively:

<code>iris %>% </a>
  keep(is.factor) %>% </a>
  str()</a>
#> &#39;data.frame&#39;:    150 obs. 
of  1 variable:</a>
#>  $ Species: Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...</a>
</a>
iris %>% </a>
  discard(is.factor) %>% </a>
  str()</a>
#> &#39;data.frame&#39;:    150 obs. 
of  4 variables:</a>
#>  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...</a>
#>  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...</a>
#>  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...</a>
#>  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...</code>

<code>some()</code> and <code>every()</code> determine if the predicate is true for any or for all of
the elements.

<code>x &lt;- list(1:5, letters, list(10))</a>
</a>
x %>% </a>
  some(is_character)</a>
#> [1] TRUE</a>
</a>
x %>% </a>
  every(is_vector)</a>
#> [1] TRUE</code>

<code>detect()</code> finds the first element where the predicate is true; <code>detect_index()</code> returns its position.

<code>x &lt;- sample(10)</a>
x</a>
#>  [1] 10  6  1  3  2  4  5  8  9  7</a>
</a>
x %>% </a>
  detect(~ . 
> 5)</a>
#> [1] 10</a>
</a>
x %>% </a>
  detect_index(~ . 
> 5)</a>
#> [1] 1</code>

<code>head_while()</code> and <code>tail_while()</code> take elements from the start or end of a vector while a predicate is true:

<code>x %>% </a>
  head_while(~ . 
> 5)</a>
#> [1] 10  6</a>
</a>
x %>% </a>
  tail_while(~ . 
> 5)</a>
#> [1] 8 9 7</code>

<h3>21.9.2 Reduce and accumulate</h3>
Sometimes you have a complex list that you want to reduce to a simple list by repeatedly applying a function that reduces a pair to a singleton. 
This is useful if you want to apply a two-table dplyr verb to multiple tables. 
For example, you might have a list of data frames, and you want to reduce to a single data frame by joining the elements together:

<code>dfs &lt;- list(</a>
  age = tibble(name = "John", age = 30),</a>
  sex = tibble(name = c("John", "Mary"), sex = c("M", "F")),</a>
  trt = tibble(name = "Mary", treatment = "A")</a>
)</a>
</a>
dfs %>% reduce(full_join)</a>
#> Joining, by = "name"</a>
#> Joining, by = "name"</a>
#> # A tibble: 2 x 4</a>
#>   name    age sex   treatment</a>
#>   &lt;chr> &lt;dbl> &lt;chr> &lt;chr>    </a>
#> 1 John     30 M     &lt;NA>     </a>
#> 2 Mary     NA F     A</code>

Or maybe you have a list of vectors, and want to find the intersection:

<code>vs &lt;- list(</a>
  c(1, 3, 5, 6, 10),</a>
  c(1, 2, 3, 7, 8, 10),</a>
  c(1, 2, 3, 4, 8, 9, 10)</a>
)</a>
</a>
vs %>% reduce(intersect)</a>
#> [1]  1  3 10</code>

The reduce function takes a 'binary' function (i.e. a function with two primary inputs), and applies it repeatedly to a list until there is only a single element left.

Accumulate is similar but it keeps all the interim results. 
You could use it to implement a cumulative sum:

<code>x &lt;- sample(10)</a>
x</a>
#>  [1]  7  5 10  9  8  3  1  4  2  6</a>
x %>% accumulate(`+`)</a>
#>  [1]  7 12 22 31 39 42 43 47 49 55</code>

<h3>21.9.3 Exercises</h3>

Implement your own version of <code>every()</code> using a for loop. 
Compare it with
<code>purrr::every()</code>. 
What does purrr’s version do that your version doesn’t?

Create an enhanced <code>col_summary()</code> that applies a summary function to every
numeric column in a data frame.

A possible base R equivalent of <code>col_summary()</code> is:

<code>col_sum3 &lt;- function(df, f) {</a>
  is_num &lt;- sapply(df, is.numeric)</a>
  df_num &lt;- df[, is_num]</a>
</a>
  sapply(df_num, f)</a>
}</code>

But it has a number of bugs as illustrated with the following inputs:

<code>df &lt;- tibble(</a>
  x = 1:3, </a>
  y = 3:1,</a>
  z = c("a", "b", "c")</a>
)</a>
# OK</a>
col_sum3(df, mean)</a>
# Has problems: don&#39;t always return numeric vector</a>
col_sum3(df[1:2], mean)</a>
col_sum3(df[1], mean)</a>
col_sum3(df[0], mean)</code>

What causes the bugs?

<h2><span class="orange">22 Introduction</span></h2>
Now that you are equipped with powerful programming tools we can finally return to modelling. 
You’ll use your new tools of data wrangling and programming, to fit many models and understand how they work. 
The focus of this book is on exploration, not confirmation or formal inference. 
But you’ll learn a few basic tools that help you understand the variation within your models.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e5bf2a8f4c787a12facbc0b4191fc82bd192f4c5/4e5d2/diagrams/data-science-model.png" width="75%" style="display: block; margin: auto;" />

The goal of a model is to provide a simple low-dimensional summary of a dataset. 
Ideally, the model will capture true 'signals' (i.e. patterns generated by the phenomenon of interest), and ignore 'noise' (i.e. random variation that you’re not interested in). 
Here we only cover 'predictive' models, which, as the name suggests, generate predictions. 
There is another type of model that we’re not going to discuss: 'data discovery' models. 
These models don’t make predictions, but instead help you discover interesting relationships within your data. 
(These two categories of models are sometimes called supervised and unsupervised, but I don’t think that terminology is particularly illuminating.)

This book is not going to give you a deep understanding of the mathematical theory that underlies models. 
It will, however, build your intuition about how statistical models work, and give you a family of useful tools that allow you to use models to better understand your data:

In <a href="model-basics.html#model-basics">model basics</a>, you’ll learn how models work mechanistically, focussing on
the important family of linear models. 
You’ll learn general tools for gaining
insight into what a predictive model tells you about your data, focussing on
simple simulated datasets.

In <a href="model-building.html#model-building">model building</a>, you’ll learn how to use models to pull out known
patterns in real data. 
Once you have recognised an important pattern
it’s useful to make it explicit in a model, because then you can
more easily see the subtler signals that remain.

In <a href="many-models.html#many-models">many models</a>, you’ll learn how to use many simple models to help
understand complex datasets. 
This is a powerful technique, but to access
it you’ll need to combine modelling and programming tools.

These topics are notable because of what they don’t include: any tools for quantitatively assessing models. 
That is deliberate: precisely quantifying a model requires a couple of big ideas that we just don’t have the space to cover here. 
For now, you’ll rely on qualitative assessment and your natural scepticism. 
In <a href="model-building.html#learning-more-about-models">Learning more about models</a>, we’ll point you to other resources where you can learn more.

<h2>22.1 Hypothesis generation vs. hypothesis confirmation</h2>
In this book, we are going to use models as a tool for exploration, completing the trifecta of the tools for EDA that were introduced in Part 1. 
This is not how models are usually taught, but as you will see, models are an important tool for exploration. 
Traditionally, the focus of modelling is on inference, or for confirming that an hypothesis is true. 
Doing this correctly is not complicated, but it is hard. 
There is a pair of ideas that you must understand in order to do inference correctly:

Each observation can either be used for exploration or confirmation,
not both.

You can use an observation as many times as you like for exploration,
but you can only use it once for confirmation. 
As soon as you use an
observation twice, you’ve switched from confirmation to exploration.

This is necessary because to confirm a hypothesis you must use data independent of the data that you used to generate the hypothesis. 
Otherwise you will be over optimistic. 
There is absolutely nothing wrong with exploration, but you should never sell an exploratory analysis as a confirmatory analysis because it is fundamentally misleading.

If you are serious about doing an confirmatory analysis, one approach is to split your data into three pieces before you begin the analysis:

60% of your data goes into a training (or exploration) set. 
You’re
allowed to do anything you like with this data: visualise it and fit tons
of models to it.

20% goes into a query set. 
You can use this data to compare models
or visualisations by hand, but you’re not allowed to use it as part of
an automated process.

20% is held back for a test set. 
You can only use this data ONCE, to
test your final model.

This partitioning allows you to explore the training data, occasionally generating candidate hypotheses that you check with the query set. 
When you are confident you have the right model, you can check it once with the test data.

(Note that even when doing confirmatory modelling, you will still need to do EDA. 
If you don’t do any EDA you will remain blind to the quality problems with your data.)

<h2><span class="orange">23 Model basics</span></h2>

<h2>23.1 Introduction</h2>
The goal of a model is to provide a simple low-dimensional summary of a dataset. 
In the context of this book we’re going to use models to partition data into patterns and residuals. 
Strong patterns will hide subtler trends, so we’ll use models to help peel back layers of structure as we explore a dataset.

However, before we can start using models on interesting, real, datasets, you need to understand the basics of how models work. 
For that reason, this chapter of the book is unique because it uses only simulated datasets. 
These datasets are very simple, and not at all interesting, but they will help you understand the essence of modelling before you apply the same techniques to real data in the next chapter.

There are two parts to a model:

First, you define a family of models that express a precise, but
generic, pattern that you want to capture. 
For example, the pattern
might be a straight line, or a quadratic curve. 
You will express
the model family as an equation like <code>y = a_1 * x + a_2</code> or
<code>y = a_1 * x ^ a_2</code>. 
Here, <code>x</code> and <code>y</code> are known variables from your
data, and <code>a_1</code> and <code>a_2</code> are parameters that can vary to capture
different patterns.

Next, you generate a fitted model by finding the model from the
family that is the closest to your data. 
This takes the generic model
family and makes it specific, like <code>y = 3 * x + 7</code> or <code>y = 9 * x ^ 2</code>.

It’s important to understand that a fitted model is just the closest model from a family of models. 
That implies that you have the 'best' model (according to some criteria); it doesn’t imply that you have a good model and it certainly doesn’t imply that the model is 'true'. 
George Box puts this well in his famous aphorism:

<blockquote>
All models are wrong, but some are useful.

</blockquote>
It’s worth reading the fuller context of the quote:

<blockquote>
Now it would be very remarkable if any system existing in the real world
could be exactly represented by any simple model. 
However, cunningly chosen
parsimonious models often do provide remarkably useful approximations. 
For
example, the law PV = RT relating pressure P, volume V and temperature T of
an 'ideal' gas via a constant R is not exactly true for any real gas, but it
frequently provides a useful approximation and furthermore its structure is
informative since it springs from a physical view of the behavior of gas
molecules.

For such a model there is no need to ask the question 'Is the model true?'.
If 'truth' is to be the 'whole truth' the answer must be 'No'. 
The only
question of interest is 'Is the model illuminating and useful?'.

</blockquote>
The goal of a model is not to uncover truth, but to discover a simple approximation that is still useful.

<h3>23.1.1 Prerequisites</h3>
In this chapter we’ll use the modelr package which wraps around base R’s modelling functions to make them work naturally in a pipe.

<code>library(tidyverse)</a>
</a>
library(modelr)</a>
options(na.action = na.warn)</code>

<h2>23.2 A simple model</h2>
Lets take a look at the simulated dataset <code>sim1</code>, included with the modelr package. 
It contains two continuous variables, <code>x</code> and <code>y</code>. 
Let’s plot them to see how they’re related:

<code>ggplot(sim1, aes(x, y)) + </a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a4a9720cb2ddb61fac2e9a33464a1067d3e50ab7/74c8f/model-basics_files/figure-html/unnamed-chunk-1-1.png" width="70%" style="display: block; margin: auto;" />

You can see a strong pattern in the data. 
Let’s use a model to capture that pattern and make it explicit. 
It’s our job to supply the basic form of the model. 
In this case, the relationship looks linear, i.e. 
<code>y = a_0 + a_1 * x</code>. 
Let’s start by getting a feel for what models from that family look like by randomly generating a few and overlaying them on the data. 
For this simple case, we can use <code>geom_abline()</code> which takes a slope and intercept as parameters. 
Later on we’ll learn more general techniques that work with any model.

<code>models &lt;- tibble(</a>
  a1 = runif(250, -20, 40),</a>
  a2 = runif(250, -5, 5)</a>
)</a>
</a>
ggplot(sim1, aes(x, y)) + </a>
  geom_abline(aes(intercept = a1, slope = a2), data = models, alpha = 1/4) +</a>
  geom_point() </code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2dbc833cc9a39f97d09b404bd853619222eb4fa1/0f7b2/model-basics_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" />

There are 250 models on this plot, but a lot are really bad! We need to find the good models by making precise our intuition that a good model is 'close' to the data. 
We need a way to quantify the distance between the data and a model. 
Then we can fit the model by finding the value of <code>a_0</code> and <code>a_1</code> that generate the model with the smallest distance from this data.

One easy place to start is to find the vertical distance between each point and the model, as in the following diagram. 
(Note that I’ve shifted the x values slightly so you can see the individual distances.)

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/058c12bd5970195d8647da4b07dd6dbb9d7c1500/bb09c/model-basics_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" />

This distance is just the difference between the y value given by the model (the prediction), and the actual y value in the data (the response).

To compute this distance, we first turn our model family into an R function. 
This takes the model parameters and the data as inputs, and gives values predicted by the model as output:

<code>model1 &lt;- function(a, data) {</a>
  a[1] + data$x * a[2]</a>
}</a>
model1(c(7, 1.5), sim1)</a>
#>  [1]  8.5  8.5  8.5 10.0 10.0 10.0 11.5 11.5 11.5 13.0 13.0 13.0 14.5 14.5 14.5</a>
#> [16] 16.0 16.0 16.0 17.5 17.5 17.5 19.0 19.0 19.0 20.5 20.5 20.5 22.0 22.0 22.0</code>

Next, we need some way to compute an overall distance between the predicted and actual values. 
In other words, the plot above shows 30 distances: how do we collapse that into a single number?

One common way to do this in statistics to use the 'root-mean-squared deviation'. 
We compute the difference between actual and predicted, square them, average them, and the take the square root. 
This distance has lots of appealing mathematical properties, which we’re not going to talk about here. 
You’ll just have to take my word for it!

<code>measure_distance &lt;- function(mod, data) {</a>
  diff &lt;- data$y - model1(mod, data)</a>
  sqrt(mean(diff ^ 2))</a>
}</a>
measure_distance(c(7, 1.5), sim1)</a>
#> [1] 2.67</code>

Now we can use purrr to compute the distance for all the models defined above. 
We need a helper function because our distance function expects the model as a numeric vector of length 2.

<code>sim1_dist &lt;- function(a1, a2) {</a>
  measure_distance(c(a1, a2), sim1)</a>
}</a>
</a>
models &lt;- models %>% </a>
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))</a>
models</a>
#> # A tibble: 250 x 3</a>
#>       a1      a2  dist</a>
#>    &lt;dbl>   &lt;dbl> &lt;dbl></a>
#> 1 -15.2   0.0889  30.8</a>
#> 2  30.1  -0.827   13.2</a>
#> 3  16.0   2.27    13.2</a>
#> 4 -10.6   1.38    18.7</a>
#> 5 -19.6  -1.04    41.8</a>
#> 6   7.98  4.59    19.3</a>
#> # … with 244 more rows</code>

Next, let’s overlay the 10 best models on to the data. 
I’ve coloured the models by <code>-dist</code>: this is an easy way to make sure that the best models (i.e. the ones with the smallest distance) get the brighest colours.

<code>ggplot(sim1, aes(x, y)) + </a>
  geom_point(size = 2, colour = "grey30") + </a>
  geom_abline(</a>
    aes(intercept = a1, slope = a2, colour = -dist), </a>
    data = filter(models, rank(dist) &lt;= 10)</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/91b60bea723c053834f974791fe562e959130ca3/47cde/model-basics_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" />

We can also think about these models as observations, and visualising with a scatterplot of <code>a1</code> vs <code>a2</code>, again coloured by <code>-dist</code>. 
We can no longer directly see how the model compares to the data, but we can see many models at once. 
Again, I’ve highlighted the 10 best models, this time by drawing red circles underneath them.

<code>ggplot(models, aes(a1, a2)) +</a>
  geom_point(data = filter(models, rank(dist) &lt;= 10), size = 4, colour = "red") +</a>
  geom_point(aes(colour = -dist))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d7a7fbf048c522bcb242d31d2a87e7d4e9852857/28572/model-basics_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" />

Instead of trying lots of random models, we could be more systematic and generate an evenly spaced grid of points (this is called a grid search). 
I picked the parameters of the grid roughly by looking at where the best models were in the plot above.

<code>grid &lt;- expand.grid(</a>
  a1 = seq(-5, 20, length = 25),</a>
  a2 = seq(1, 3, length = 25)</a>
  ) %>% </a>
  mutate(dist = purrr::map2_dbl(a1, a2, sim1_dist))</a>
</a>
grid %>% </a>
  ggplot(aes(a1, a2)) +</a>
  geom_point(data = filter(grid, rank(dist) &lt;= 10), size = 4, colour = "red") +</a>
  geom_point(aes(colour = -dist)) </code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/122e3e46ec5c7b4bdcc5c85d8dc84cb668bc8db6/e7a34/model-basics_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" />

When you overlay the best 10 models back on the original data, they all look pretty good:

<code>ggplot(sim1, aes(x, y)) + </a>
  geom_point(size = 2, colour = "grey30") + </a>
  geom_abline(</a>
    aes(intercept = a1, slope = a2, colour = -dist), </a>
    data = filter(grid, rank(dist) &lt;= 10)</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/66c99fbafe08ad3fe385d24fe34807401aa2a7d4/d44aa/model-basics_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

You could imagine iteratively making the grid finer and finer until you narrowed in on the best model. 
But there’s a better way to tackle that problem: a numerical minimisation tool called Newton-Raphson search. 
The intuition of Newton-Raphson is pretty simple: you pick a starting point and look around for the steepest slope. 
You then ski down that slope a little way, and then repeat again and again, until you can’t go any lower. 
In R, we can do that with <code>optim()</code>:

<code>best &lt;- optim(c(0, 0), measure_distance, data = sim1)</a>
best$par</a>
#> [1] 4.22 2.05</a>
</a>
ggplot(sim1, aes(x, y)) + </a>
  geom_point(size = 2, colour = "grey30") + </a>
  geom_abline(intercept = best$par[1], slope = best$par[2])</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f2d6d1b3267f7d6c26ab52afbd58d815da5c4f67/e0e6a/model-basics_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" />

Don’t worry too much about the details of how <code>optim()</code> works. 
It’s the intuition that’s important here. 
If you have a function that defines the distance between a model and a dataset, an algorithm that can minimise that distance by modifying the parameters of the model, you can find the best model. 
The neat thing about this approach is that it will work for any family of models that you can write an equation for.

There’s one more approach that we can use for this model, because it’s a special case of a broader family: linear models. 
A linear model has the general form <code>y = a_1 + a_2 * x_1 + a_3 * x_2 + ... 
+ a_n * x_(n - 1)</code>. 
So this simple model is equivalent to a general linear model where n is 2 and <code>x_1</code> is <code>x</code>. 
R has a tool specifically designed for fitting linear models called <code>lm()</code>. 
<code>lm()</code> has a special way to specify the model family: formulas. 
Formulas look like <code>y ~ x</code>, which <code>lm()</code> will translate to a function like <code>y = a_1 + a_2 * x</code>. 
We can fit the model and look at the output:

<code>sim1_mod &lt;- lm(y ~ x, data = sim1)</a>
coef(sim1_mod)</a>
#> (Intercept)           x </a>
#>        4.22        2.05</code>

These are exactly the same values we got with <code>optim()</code>! Behind the scenes <code>lm()</code> doesn’t use <code>optim()</code> but instead takes advantage of the mathematical structure of linear models. 
Using some connections between geometry, calculus, and linear algebra, <code>lm()</code> actually finds the closest model in a single step, using a sophisticated algorithm. 
This approach is both faster, and guarantees that there is a global minimum.

<h3>23.2.1 Exercises</h3>

One downside of the linear model is that it is sensitive to unusual values
because the distance incorporates a squared term. 
Fit a linear model to
the simulated data below, and visualise the results. 
Rerun a few times to
generate different simulated datasets. 
What do you notice about the model?

<code>sim1a &lt;- tibble(</a>
  x = rep(1:10, each = 3),</a>
  y = x * 1.5 + 6 + rt(length(x), df = 2)</a>
)</code>

One way to make linear models more robust is to use a different distance
measure. 
For example, instead of root-mean-squared distance, you could use
mean-absolute distance:

<code>measure_distance &lt;- function(mod, data) {</a>
  diff &lt;- data$y - model1(mod, data)</a>
  mean(abs(diff))</a>
}</code>

Use <code>optim()</code> to fit this model to the simulated data above and compare it
to the linear model.

One challenge with performing numerical optimisation is that it’s only
guaranteed to find one local optimum. 
What’s the problem with optimising
a three parameter model like this?

<code>model1 &lt;- function(a, data) {</a>
  a[1] + data$x * a[2] + a[3]</a>
}</code>

<h2>23.3 Visualising models</h2>
For simple models, like the one above, you can figure out what pattern the model captures by carefully studying the model family and the fitted coefficients. 
And if you ever take a statistics course on modelling, you’re likely to spend a lot of time doing just that. 
Here, however, we’re going to take a different tack. 
We’re going to focus on understanding a model by looking at its predictions. 
This has a big advantage: every type of predictive model makes predictions (otherwise what use would it be?) so we can use the same set of techniques to understand any type of predictive model.

It’s also useful to see what the model doesn’t capture, the so-called residuals which are left after subtracting the predictions from the data. 
Residuals are powerful because they allow us to use models to remove striking patterns so we can study the subtler trends that remain.

<h3>23.3.1 Predictions</h3>
To visualise the predictions from a model, we start by generating an evenly spaced grid of values that covers the region where our data lies. 
The easiest way to do that is to use <code>modelr::data_grid()</code>. 
Its first argument is a data frame, and for each subsequent argument it finds the unique variables and then generates all combinations:

<code>grid &lt;- sim1 %>% </a>
  data_grid(x) </a>
grid</a>
#> # A tibble: 10 x 1</a>
#>       x</a>
#>   &lt;int></a>
#> 1     1</a>
#> 2     2</a>
#> 3     3</a>
#> 4     4</a>
#> 5     5</a>
#> 6     6</a>
#> # … with 4 more rows</code>

(This will get more interesting when we start to add more variables to our model.)

Next we add predictions. 
We’ll use <code>modelr::add_predictions()</code> which takes a data frame and a model. 
It adds the predictions from the model to a new column in the data frame:

<code>grid &lt;- grid %>% </a>
  add_predictions(sim1_mod) </a>
grid</a>
#> # A tibble: 10 x 2</a>
#>       x  pred</a>
#>   &lt;int> &lt;dbl></a>
#> 1     1  6.27</a>
#> 2     2  8.32</a>
#> 3     3 10.4 </a>
#> 4     4 12.4 </a>
#> 5     5 14.5 </a>
#> 6     6 16.5 </a>
#> # … with 4 more rows</code>

(You can also use this function to add predictions to your original dataset.)

Next, we plot the predictions. 
You might wonder about all this extra work compared to just using <code>geom_abline()</code>. 
But the advantage of this approach is that it will work with <em>any</em> model in R, from the simplest to the most complex. 
You’re only limited by your visualisation skills. 
For more ideas about how to visualise more complex model types, you might try <a href="http://vita.had.co.nz/papers/model-vis.html" class="uri">http://vita.had.co.nz/papers/model-vis.html</a>.

<code>ggplot(sim1, aes(x)) +</a>
  geom_point(aes(y = y)) +</a>
  geom_line(aes(y = pred), data = grid, colour = "red", size = 1)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e8556aebc491ff45a409e981bf34e81e10f381b0/86a5c/model-basics_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

<h3>23.3.2 Residuals</h3>
The flip-side of predictions are residuals. 
The predictions tells you the pattern that the model has captured, and the residuals tell you what the model has missed. 
The residuals are just the distances between the observed and predicted values that we computed above.

We add residuals to the data with <code>add_residuals()</code>, which works much like <code>add_predictions()</code>. 
Note, however, that we use the original dataset, not a manufactured grid. 
This is because to compute residuals we need actual y values.

<code>sim1 &lt;- sim1 %>% </a>
  add_residuals(sim1_mod)</a>
sim1</a>
#> # A tibble: 30 x 3</a>
#>       x     y  resid</a>
#>   &lt;int> &lt;dbl>  &lt;dbl></a>
#> 1     1  4.20 -2.07 </a>
#> 2     1  7.51  1.24 </a>
#> 3     1  2.13 -4.15 </a>
#> 4     2  8.99  0.665</a>
#> 5     2 10.2   1.92 </a>
#> 6     2 11.3   2.97 </a>
#> # … with 24 more rows</code>

There are a few different ways to understand what the residuals tell us about the model. 
One way is to simply draw a frequency polygon to help us understand the spread of the residuals:

<code>ggplot(sim1, aes(resid)) + </a>
  geom_freqpoly(binwidth = 0.5)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1a3369f2ce148e38998974845de0eab0786577af/150ba/model-basics_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

This helps you calibrate the quality of the model: how far away are the predictions from the observed values? Note that the average of the residual will always be 0.

You’ll often want to recreate plots using the residuals instead of the original predictor. 
You’ll see a lot of that in the next chapter.

<code>ggplot(sim1, aes(x, resid)) + </a>
  geom_ref_line(h = 0) +</a>
  geom_point() </code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/839434c6c2c883efca1d60305f35b8cc16831733/c6c81/model-basics_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" />

This looks like random noise, suggesting that our model has done a good job of capturing the patterns in the dataset.

<h3>23.3.3 Exercises</h3>

Instead of using <code>lm()</code> to fit a straight line, you can use <code>loess()</code>
to fit a smooth curve. 
Repeat the process of model fitting,
grid generation, predictions, and visualisation on <code>sim1</code> using
<code>loess()</code> instead of <code>lm()</code>. 
How does the result compare to
<code>geom_smooth()</code>?

<code>add_predictions()</code> is paired with <code>gather_predictions()</code> and
<code>spread_predictions()</code>. 
How do these three functions differ?

What does <code>geom_ref_line()</code> do? What package does it come from?
Why is displaying a reference line in plots showing residuals
useful and important?

Why might you want to look at a frequency polygon of absolute residuals?
What are the pros and cons compared to looking at the raw residuals?

<h2>23.4 Formulas and model families</h2>
You’ve seen formulas before when using <code>facet_wrap()</code> and <code>facet_grid()</code>. 
In R, formulas provide a general way of getting 'special behaviour'. 
Rather than evaluating the values of the variables right away, they capture them so they can be interpreted by the function.

The majority of modelling functions in R use a standard conversion from formulas to functions. 
You’ve seen one simple conversion already: <code>y ~ x</code> is translated to <code>y = a_1 + a_2 * x</code>. 
If you want to see what R actually does, you can use the <code>model_matrix()</code> function. 
It takes a data frame and a formula and returns a tibble that defines the model equation: each column in the output is associated with one coefficient in the model, the function is always <code>y = a_1 * out1 + a_2 * out_2</code>. 
For the simplest case of <code>y ~ x1</code> this shows us something interesting:

<code>df &lt;- tribble(</a>
  ~y, ~x1, ~x2,</a>
  4, 2, 5,</a>
  5, 1, 6</a>
)</a>
model_matrix(df, y ~ x1)</a>
#> # A tibble: 2 x 2</a>
#>   `(Intercept)`    x1</a>
#>           &lt;dbl> &lt;dbl></a>
#> 1             1     2</a>
#> 2             1     1</code>

The way that R adds the intercept to the model is just by having a column that is full of ones. 
By default, R will always add this column. 
If you don’t want, you need to explicitly drop it with <code>-1</code>:

<code>model_matrix(df, y ~ x1 - 1)</a>
#> # A tibble: 2 x 1</a>
#>      x1</a>
#>   &lt;dbl></a>
#> 1     2</a>
#> 2     1</code>

The model matrix grows in an unsurprising way when you add more variables to the the model:

<code>model_matrix(df, y ~ x1 + x2)</a>
#> # A tibble: 2 x 3</a>
#>   `(Intercept)`    x1    x2</a>
#>           &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1             1     2     5</a>
#> 2             1     1     6</code>

This formula notation is sometimes called 'Wilkinson-Rogers notation', and was initially described in <em>Symbolic Description of Factorial Models for Analysis of Variance</em>, by G. 
N. 
Wilkinson and C. 
E. 
Rogers <a href="https://www.jstor.org/stable/2346786" class="uri">https://www.jstor.org/stable/2346786</a>. 
It’s worth digging up and reading the original paper if you’d like to understand the full details of the modelling algebra.

The following sections expand on how this formula notation works for categorical variables, interactions, and transformation.

<h3>23.4.1 Categorical variables</h3>
Generating a function from a formula is straight forward when the predictor is continuous, but things get a bit more complicated when the predictor is categorical. 
Imagine you have a formula like <code>y ~ sex</code>, where sex could either be male or female. 
It doesn’t make sense to convert that to a formula like <code>y = x_0 + x_1 * sex</code> because <code>sex</code> isn’t a number - you can’t multiply it! Instead what R does is convert it to <code>y = x_0 + x_1 * sex_male</code> where <code>sex_male</code> is one if <code>sex</code> is male and zero otherwise:

<code>df &lt;- tribble(</a>
  ~ sex, ~ response,</a>
  "male", 1,</a>
  "female", 2,</a>
  "male", 1</a>
)</a>
model_matrix(df, response ~ sex)</a>
#> # A tibble: 3 x 2</a>
#>   `(Intercept)` sexmale</a>
#>           &lt;dbl>   &lt;dbl></a>
#> 1             1       1</a>
#> 2             1       0</a>
#> 3             1       1</code>

You might wonder why R also doesn’t create a <code>sexfemale</code> column. 
The problem is that would create a column that is perfectly predictable based on the other columns (i.e. 
<code>sexfemale = 1 - sexmale</code>). 
Unfortunately the exact details of why this is a problem is beyond the scope of this book, but basically it creates a model family that is too flexible, and will have infinitely many models that are equally close to the data.

Fortunately, however, if you focus on visualising predictions you don’t need to worry about the exact parameterisation. 
Let’s look at some data and models to make that concrete. 
Here’s the <code>sim2</code> dataset from modelr:

<code>ggplot(sim2) + </a>
  geom_point(aes(x, y))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/57559610e75704126f543f28864265112f38c8a4/0e054/model-basics_files/figure-html/unnamed-chunk-26-1.png" width="70%" style="display: block; margin: auto;" />

We can fit a model to it, and generate predictions:

<code>mod2 &lt;- lm(y ~ x, data = sim2)</a>
</a>
grid &lt;- sim2 %>% </a>
  data_grid(x) %>% </a>
  add_predictions(mod2)</a>
grid</a>
#> # A tibble: 4 x 2</a>
#>   x      pred</a>
#>   &lt;chr> &lt;dbl></a>
#> 1 a      1.15</a>
#> 2 b      8.12</a>
#> 3 c      6.13</a>
#> 4 d      1.91</code>

Effectively, a model with a categorical <code>x</code> will predict the mean value for each category. 
(Why? Because the mean minimises the root-mean-squared distance.) That’s easy to see if we overlay the predictions on top of the original data:

<code>ggplot(sim2, aes(x)) + </a>
  geom_point(aes(y = y)) +</a>
  geom_point(data = grid, aes(y = pred), colour = "red", size = 4)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ce82f10d6563801b0099230cbbffd14d14cac6b4/c7431/model-basics_files/figure-html/unnamed-chunk-28-1.png" width="70%" style="display: block; margin: auto;" />

You can’t make predictions about levels that you didn’t observe. 
Sometimes you’ll do this by accident so it’s good to recognise this error message:

<code>tibble(x = "e") %>% </a>
  add_predictions(mod2)</a>
#> Error in model.frame.default(Terms, newdata, na.action = na.action, xlev = object$xlevels): factor x has new level e</code>

<h3>23.4.2 Interactions (continuous and categorical)</h3>
What happens when you combine a continuous and a categorical variable? <code>sim3</code> contains a categorical predictor and a continuous predictor. 
We can visualise it with a simple plot:

<code>ggplot(sim3, aes(x1, y)) + </a>
  geom_point(aes(colour = x2))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/657aaee7ff2a936c6f857437012564ccac9cdb64/7539e/model-basics_files/figure-html/unnamed-chunk-30-1.png" width="70%" style="display: block; margin: auto;" />

There are two possible models you could fit to this data:

<code>mod1 &lt;- lm(y ~ x1 + x2, data = sim3)</a>
mod2 &lt;- lm(y ~ x1 * x2, data = sim3)</code>

When you add variables with <code>+</code>, the model will estimate each effect independent of all the others. 
It’s possible to fit the so-called interaction by using <code>*</code>. 
For example, <code>y ~ x1 * x2</code> is translated to <code>y = a_0 + a_1 * x1 + a_2 * x2 + a_12 * x1 * x2</code>. 
Note that whenever you use <code>*</code>, both the interaction and the individual components are included in the model.

To visualise these models we need two new tricks:

We have two predictors, so we need to give <code>data_grid()</code> both variables.
It finds all the unique values of <code>x1</code> and <code>x2</code> and then generates all
combinations.

To generate predictions from both models simultaneously, we can use
<code>gather_predictions()</code> which adds each prediction as a row. 
The
complement of <code>gather_predictions()</code> is <code>spread_predictions()</code> which adds
each prediction to a new column.

Together this gives us:

<code>grid &lt;- sim3 %>% </a>
  data_grid(x1, x2) %>% </a>
  gather_predictions(mod1, mod2)</a>
grid</a>
#> # A tibble: 80 x 4</a>
#>   model    x1 x2     pred</a>
#>   &lt;chr> &lt;int> &lt;fct> &lt;dbl></a>
#> 1 mod1      1 a      1.67</a>
#> 2 mod1      1 b      4.56</a>
#> 3 mod1      1 c      6.48</a>
#> 4 mod1      1 d      4.03</a>
#> 5 mod1      2 a      1.48</a>
#> 6 mod1      2 b      4.37</a>
#> # … with 74 more rows</code>

We can visualise the results for both models on one plot using facetting:

<code>ggplot(sim3, aes(x1, y, colour = x2)) + </a>
  geom_point() + </a>
  geom_line(data = grid, aes(y = pred)) + </a>
  facet_wrap(~ model)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d72c35e1b97df23230f8e37b945d643983a1ac05/dda32/model-basics_files/figure-html/unnamed-chunk-33-1.png" width="70%" style="display: block; margin: auto;" />

Note that the model that uses <code>+</code> has the same slope for each line, but different intercepts. 
The model that uses <code>*</code> has a different slope and intercept for each line.

Which model is better for this data? We can take look at the residuals. 
Here I’ve facetted by both model and <code>x2</code> because it makes it easier to see the pattern within each group.

<code>sim3 &lt;- sim3 %>% </a>
  gather_residuals(mod1, mod2)</a>
</a>
ggplot(sim3, aes(x1, resid, colour = x2)) + </a>
  geom_point() + </a>
  facet_grid(model ~ x2)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4a6e9fef8625713e354e21a9aff9aa7cf11eefac/e6e48/model-basics_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" />

There is little obvious pattern in the residuals for <code>mod2</code>. 
The residuals for <code>mod1</code> show that the model has clearly missed some pattern in <code>b</code>, and less so, but still present is pattern in <code>c</code>, and <code>d</code>. 
You might wonder if there’s a precise way to tell which of <code>mod1</code> or <code>mod2</code> is better. 
There is, but it requires a lot of mathematical background, and we don’t really care. 
Here, we’re interested in a qualitative assessment of whether or not the model has captured the pattern that we’re interested in.

<h3>23.4.3 Interactions (two continuous)</h3>
Let’s take a look at the equivalent model for two continuous variables. 
Initially things proceed almost identically to the previous example:

<code>mod1 &lt;- lm(y ~ x1 + x2, data = sim4)</a>
mod2 &lt;- lm(y ~ x1 * x2, data = sim4)</a>
</a>
grid &lt;- sim4 %>% </a>
  data_grid(</a>
    x1 = seq_range(x1, 5), </a>
    x2 = seq_range(x2, 5) </a>
  ) %>% </a>
  gather_predictions(mod1, mod2)</a>
grid</a>
#> # A tibble: 50 x 4</a>
#>   model    x1    x2   pred</a>
#>   &lt;chr> &lt;dbl> &lt;dbl>  &lt;dbl></a>
#> 1 mod1   -1    -1    0.996</a>
#> 2 mod1   -1    -0.5 -0.395</a>
#> 3 mod1   -1     0   -1.79 </a>
#> 4 mod1   -1     0.5 -3.18 </a>
#> 5 mod1   -1     1   -4.57 </a>
#> 6 mod1   -0.5  -1    1.91 </a>
#> # … with 44 more rows</code>

Note my use of <code>seq_range()</code> inside <code>data_grid()</code>. 
Instead of using every unique value of <code>x</code>, I’m going to use a regularly spaced grid of five values between the minimum and maximum numbers. 
It’s probably not super important here, but it’s a useful technique in general. 
There are two other useful arguments to <code>seq_range()</code>:

<code>pretty = TRUE</code> will generate a 'pretty' sequence, i.e. something that looks
nice to the human eye. 
This is useful if you want to produce tables of
output:

<code>seq_range(c(0.0123, 0.923423), n = 5)</a>
#> [1] 0.0123 0.2401 0.4679 0.6956 0.9234</a>
seq_range(c(0.0123, 0.923423), n = 5, pretty = TRUE)</a>
#> [1] 0.0 0.2 0.4 0.6 0.8 1.0</code>

<code>trim = 0.1</code> will trim off 10% of the tail values. 
This is useful if the
variables have a long tailed distribution and you want to focus on generating
values near the center:

<code>x1 &lt;- rcauchy(100)</a>
seq_range(x1, n = 5)</a>
#> [1] -115.9  -83.5  -51.2  -18.8   13.5</a>
seq_range(x1, n = 5, trim = 0.10)</a>
#> [1] -13.84  -8.71  -3.58   1.55   6.68</a>
seq_range(x1, n = 5, trim = 0.25)</a>
#> [1] -2.1735 -1.0594  0.0547  1.1687  2.2828</a>
seq_range(x1, n = 5, trim = 0.50)</a>
#> [1] -0.725 -0.268  0.189  0.647  1.104</code>

<code>expand = 0.1</code> is in some sense the opposite of <code>trim()</code> it expands the
range by 10%.

<code>x2 &lt;- c(0, 1)</a>
seq_range(x2, n = 5)</a>
#> [1] 0.00 0.25 0.50 0.75 1.00</a>
seq_range(x2, n = 5, expand = 0.10)</a>
#> [1] -0.050  0.225  0.500  0.775  1.050</a>
seq_range(x2, n = 5, expand = 0.25)</a>
#> [1] -0.125  0.188  0.500  0.812  1.125</a>
seq_range(x2, n = 5, expand = 0.50)</a>
#> [1] -0.250  0.125  0.500  0.875  1.250</code>

Next let’s try and visualise that model. 
We have two continuous predictors, so you can imagine the model like a 3d surface. 
We could display that using <code>geom_tile()</code>:

<code>ggplot(grid, aes(x1, x2)) + </a>
  geom_tile(aes(fill = pred)) + </a>
  facet_wrap(~ model)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/aea18f54f77e87d1c6fd6000f4eb4e712d565be7/78b67/model-basics_files/figure-html/unnamed-chunk-39-1.png" width="70%" style="display: block; margin: auto;" />

That doesn’t suggest that the models are very different! But that’s partly an illusion: our eyes and brains are not very good at accurately comparing shades of colour. 
Instead of looking at the surface from the top, we could look at it from either side, showing multiple slices:

<code>ggplot(grid, aes(x1, pred, colour = x2, group = x2)) + </a>
  geom_line() +</a>
  facet_wrap(~ model)</a>
ggplot(grid, aes(x2, pred, colour = x1, group = x1)) + </a>
  geom_line() +</a>
  facet_wrap(~ model)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/434d2990bc06b20bafee0353ae99371245dfa1f8/17d08/model-basics_files/figure-html/unnamed-chunk-40-1.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/18cc2da66e65e75bac880b8ad7ddc44ba28c2b77/68994/model-basics_files/figure-html/unnamed-chunk-40-2.png" width="70%" style="display: block; margin: auto;" />

This shows you that interaction between two continuous variables works basically the same way as for a categorical and continuous variable. 
An interaction says that there’s not a fixed offset: you need to consider both values of <code>x1</code> and <code>x2</code> simultaneously in order to predict <code>y</code>.

You can see that even with just two continuous variables, coming up with good visualisations are hard. 
But that’s reasonable: you shouldn’t expect it will be easy to understand how three or more variables simultaneously interact! But again, we’re saved a little because we’re using models for exploration, and you can gradually build up your model over time. 
The model doesn’t have to be perfect, it just has to help you reveal a little more about your data.

I spent some time looking at the residuals to see if I could figure if <code>mod2</code> did better than <code>mod1</code>. 
I think it does, but it’s pretty subtle. 
You’ll have a chance to work on it in the exercises.

<h3>23.4.4 Transformations</h3>
You can also perform transformations inside the model formula. 
For example, <code>log(y) ~ sqrt(x1) + x2</code> is transformed to <code>log(y) = a_1 + a_2 * sqrt(x1) + a_3 * x2</code>. 
If your transformation involves <code>+</code>, <code>*</code>, <code>^</code>, or <code>-</code>, you’ll need to wrap it in <code>I()</code> so R doesn’t treat it like part of the model specification. 
For example, <code>y ~ x + I(x ^ 2)</code> is translated to <code>y = a_1 + a_2 * x + a_3 * x^2</code>. 
If you forget the <code>I()</code> and specify <code>y ~ x ^ 2 + x</code>, R will compute <code>y ~ x * x + x</code>. 
<code>x * x</code> means the interaction of <code>x</code> with itself, which is the same as <code>x</code>. 
R automatically drops redundant variables so <code>x + x</code> become <code>x</code>, meaning that <code>y ~ x ^ 2 + x</code> specifies the function <code>y = a_1 + a_2 * x</code>. 
That’s probably not what you intended!

Again, if you get confused about what your model is doing, you can always use <code>model_matrix()</code> to see exactly what equation <code>lm()</code> is fitting:

<code>df &lt;- tribble(</a>
  ~y, ~x,</a>
   1,  1,</a>
   2,  2, </a>
   3,  3</a>
)</a>
model_matrix(df, y ~ x^2 + x)</a>
#> # A tibble: 3 x 2</a>
#>   `(Intercept)`     x</a>
#>           &lt;dbl> &lt;dbl></a>
#> 1             1     1</a>
#> 2             1     2</a>
#> 3             1     3</a>
model_matrix(df, y ~ I(x^2) + x)</a>
#> # A tibble: 3 x 3</a>
#>   `(Intercept)` `I(x^2)`     x</a>
#>           &lt;dbl>    &lt;dbl> &lt;dbl></a>
#> 1             1        1     1</a>
#> 2             1        4     2</a>
#> 3             1        9     3</code>

Transformations are useful because you can use them to approximate non-linear functions. 
If you’ve taken a calculus class, you may have heard of Taylor’s theorem which says you can approximate any smooth function with an infinite sum of polynomials. 
That means you can use a polynomial function to get arbitrarily close to a smooth function by fitting an equation like <code>y = a_1 + a_2 * x + a_3 * x^2 + a_4 * x ^ 3</code>. 
Typing that sequence by hand is tedious, so R provides a helper function: <code>poly()</code>:

<code>model_matrix(df, y ~ poly(x, 2))</a>
#> # A tibble: 3 x 3</a>
#>   `(Intercept)` `poly(x, 2)1` `poly(x, 2)2`</a>
#>           &lt;dbl>         &lt;dbl>         &lt;dbl></a>
#> 1             1     -7.07e- 1         0.408</a>
#> 2             1     -7.85e-17        -0.816</a>
#> 3             1      7.07e- 1         0.408</code>

However there’s one major problem with using <code>poly()</code>: outside the range of the data, polynomials rapidly shoot off to positive or negative infinity. 
One safer alternative is to use the natural spline, <code>splines::ns()</code>.

<code>library(splines)</a>
model_matrix(df, y ~ ns(x, 2))</a>
#> # A tibble: 3 x 3</a>
#>   `(Intercept)` `ns(x, 2)1` `ns(x, 2)2`</a>
#>           &lt;dbl>       &lt;dbl>       &lt;dbl></a>
#> 1             1       0           0    </a>
#> 2             1       0.566      -0.211</a>
#> 3             1       0.344       0.771</code>

Let’s see what that looks like when we try and approximate a non-linear function:

<code>sim5 &lt;- tibble(</a>
  x = seq(0, 3.5 * pi, length = 50),</a>
  y = 4 * sin(x) + rnorm(length(x))</a>
)</a>
</a>
ggplot(sim5, aes(x, y)) +</a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3f5e33ef98bb63163a783cfa6335dbdee8f31682/814eb/model-basics_files/figure-html/unnamed-chunk-44-1.png" width="70%" style="display: block; margin: auto;" />

I’m going to fit five models to this data.

<code>mod1 &lt;- lm(y ~ ns(x, 1), data = sim5)</a>
mod2 &lt;- lm(y ~ ns(x, 2), data = sim5)</a>
mod3 &lt;- lm(y ~ ns(x, 3), data = sim5)</a>
mod4 &lt;- lm(y ~ ns(x, 4), data = sim5)</a>
mod5 &lt;- lm(y ~ ns(x, 5), data = sim5)</a>
</a>
grid &lt;- sim5 %>% </a>
  data_grid(x = seq_range(x, n = 50, expand = 0.1)) %>% </a>
  gather_predictions(mod1, mod2, mod3, mod4, mod5, .pred = "y")</a>
</a>
ggplot(sim5, aes(x, y)) + </a>
  geom_point() +</a>
  geom_line(data = grid, colour = "red") +</a>
  facet_wrap(~ model)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/75afea4610f461be8d845716e916bffe7836051c/10856/model-basics_files/figure-html/unnamed-chunk-45-1.png" width="70%" style="display: block; margin: auto;" />

Notice that the extrapolation outside the range of the data is clearly bad. 
This is the downside to approximating a function with a polynomial. 
But this is a very real problem with every model: the model can never tell you if the behaviour is true when you start extrapolating outside the range of the data that you have seen. 
You must rely on theory and science.

<h3>23.4.5 Exercises</h3>

What happens if you repeat the analysis of <code>sim2</code> using a model without
an intercept. 
What happens to the model equation? What happens to the
predictions?

Use <code>model_matrix()</code> to explore the equations generated for the models
I fit to <code>sim3</code> and <code>sim4</code>. 
Why is <code>*</code> a good shorthand for interaction?

Using the basic principles, convert the formulas in the following two
models into functions. 
(Hint: start by converting the categorical variable
into 0-1 variables.)

<code>mod1 &lt;- lm(y ~ x1 + x2, data = sim3)</a>
mod2 &lt;- lm(y ~ x1 * x2, data = sim3)</code>

For <code>sim4</code>, which of <code>mod1</code> and <code>mod2</code> is better? I think <code>mod2</code> does a
slightly better job at removing patterns, but it’s pretty subtle. 
Can you
come up with a plot to support my claim?

<h2>23.5 Missing values</h2>
Missing values obviously can not convey any information about the relationship between the variables, so modelling functions will drop any rows that contain missing values. 
R’s default behaviour is to silently drop them, but <code>options(na.action = na.warn)</code> (run in the prerequisites), makes sure you get a warning.

<code>df &lt;- tribble(</a>
  ~x, ~y,</a>
  1, 2.2,</a>
  2, NA,</a>
  3, 3.5,</a>
  4, 8.3,</a>
  NA, 10</a>
)</a>
</a>
mod &lt;- lm(y ~ x, data = df)</a>
#> Warning: Dropping 2 rows with missing values</code>

To suppress the warning, set <code>na.action = na.exclude</code>:

<code>mod &lt;- lm(y ~ x, data = df, na.action = na.exclude)</code>

You can always see exactly how many observations were used with <code>nobs()</code>:

<code>nobs(mod)</a>
#> [1] 3</code>

<h2>23.6 Other model families</h2>
This chapter has focussed exclusively on the class of linear models, which assume a relationship of the form <code>y = a_1 * x1 + a_2 * x2 + ... 
+ a_n * xn</code>. 
Linear models additionally assume that the residuals have a normal distribution, which we haven’t talked about. 
There are a large set of model classes that extend the linear model in various interesting ways. 
Some of them are:

Generalised linear models, e.g. 
<code>stats::glm()</code>. 
Linear models assume that
the response is continuous and the error has a normal distribution.
Generalised linear models extend linear models to include non-continuous
responses (e.g. binary data or counts). 
They work by defining a distance
metric based on the statistical idea of likelihood.

Generalised additive models, e.g. 
<code>mgcv::gam()</code>, extend generalised
linear models to incorporate arbitrary smooth functions. 
That means you can
write a formula like <code>y ~ s(x)</code> which becomes an equation like
<code>y = f(x)</code> and let <code>gam()</code> estimate what that function is (subject to some
smoothness constraints to make the problem tractable).

Penalised linear models, e.g. 
<code>glmnet::glmnet()</code>, add a penalty term to
the distance that penalises complex models (as defined by the distance
between the parameter vector and the origin). 
This tends to make
models that generalise better to new datasets from the same population.

Robust linear models, e.g. 
<code>MASS::rlm()</code>, tweak the distance to downweight
points that are very far away. 
This makes them less sensitive to the presence
of outliers, at the cost of being not quite as good when there are no
outliers.

Trees, e.g. 
<code>rpart::rpart()</code>, attack the problem in a completely different
way than linear models. 
They fit a piece-wise constant model, splitting the
data into progressively smaller and smaller pieces. 
Trees aren’t terribly
effective by themselves, but they are very powerful when used in aggregate
by models like random forests (e.g. 
<code>randomForest::randomForest()</code>) or
gradient boosting machines (e.g. 
<code>xgboost::xgboost</code>.)

These models all work similarly from a programming perspective. 
Once you’ve mastered linear models, you should find it easy to master the mechanics of these other model classes. 
Being a skilled modeller is a mixture of some good general principles and having a big toolbox of techniques. 
Now that you’ve learned some general tools and one useful class of models, you can go on and learn more classes from other sources.

<h2><span class="orange">24 Model building</span></h2>

<h2>24.1 Introduction</h2>
In the previous chapter you learned how linear models work, and learned some basic tools for understanding what a model is telling you about your data. 
The previous chapter focussed on simulated datasets. 
This chapter will focus on real data, showing you how you can progressively build up a model to aid your understanding of the data.

We will take advantage of the fact that you can think about a model partitioning your data into pattern and residuals. 
We’ll find patterns with visualisation, then make them concrete and precise with a model. 
We’ll then repeat the process, but replace the old response variable with the residuals from the model. 
The goal is to transition from implicit knowledge in the data and your head to explicit knowledge in a quantitative model. 
This makes it easier to apply to new domains, and easier for others to use.

For very large and complex datasets this will be a lot of work. 
There are certainly alternative approaches - a more machine learning approach is simply to focus on the predictive ability of the model. 
These approaches tend to produce black boxes: the model does a really good job at generating predictions, but you don’t know why. 
This is a totally reasonable approach, but it does make it hard to apply your real world knowledge to the model. 
That, in turn, makes it difficult to assess whether or not the model will continue to work in the long-term, as fundamentals change. 
For most real models, I’d expect you to use some combination of this approach and a more classic automated approach.

It’s a challenge to know when to stop. 
You need to figure out when your model is good enough, and when additional investment is unlikely to pay off. 
I particularly like this quote from reddit user Broseidon241:

<blockquote>
A long time ago in art class, my teacher told me 'An artist needs to know
when a piece is done. 
You can’t tweak something into perfection - wrap it up.
If you don’t like it, do it over again. 
Otherwise begin something new'. 
Later
in life, I heard 'A poor seamstress makes many mistakes. 
A good seamstress
works hard to correct those mistakes. 
A great seamstress isn’t afraid to
throw out the garment and start over.'

– Broseidon241, <a href="https://www.reddit.com/r/datascience/comments/4irajq" class="uri">https://www.reddit.com/r/datascience/comments/4irajq</a>

</blockquote>

<h3>24.1.1 Prerequisites</h3>
We’ll use the same tools as in the previous chapter, but add in some real datasets: <code>diamonds</code> from ggplot2, and <code>flights</code> from nycflights13. 
We’ll also need lubridate in order to work with the date/times in <code>flights</code>.

<code>library(tidyverse)</a>
library(modelr)</a>
options(na.action = na.warn)</a>
</a>
library(nycflights13)</a>
library(lubridate)</code>

<h2>24.2 Why are low quality diamonds more expensive?</h2>
In previous chapters we’ve seen a surprising relationship between the quality of diamonds and their price: low quality diamonds (poor cuts, bad colours, and inferior clarity) have higher prices.

<code>ggplot(diamonds, aes(cut, price)) + geom_boxplot()</a>
ggplot(diamonds, aes(color, price)) + geom_boxplot()</a>
ggplot(diamonds, aes(clarity, price)) + geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e4004868cf95870a316ad2acf3019d23fba7e81d/0a8f1/model-building_files/figure-html/unnamed-chunk-1-1.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1e15e29c59c247c8f6c3de358a5e40535147a5b6/d1959/model-building_files/figure-html/unnamed-chunk-1-2.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1858fa7c375f36d8e1d74d54b7873c5b433c11d6/f3eac/model-building_files/figure-html/unnamed-chunk-1-3.png" width="70%" style="display: block; margin: auto;" />

Note that the worst diamond color is J (slightly yellow), and the worst clarity is I1 (inclusions visible to the naked eye).

<h3>24.2.1 Price and carat</h3>
It looks like lower quality diamonds have higher prices because there is an important confounding variable: the weight (<code>carat</code>) of the diamond. 
The weight of the diamond is the single most important factor for determining the price of the diamond, and lower quality diamonds tend to be larger.

<code>ggplot(diamonds, aes(carat, price)) + </a>
  geom_hex(bins = 50)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5b59fef5c806ba405ec5b5d1b9baeda7767eb3b9/6b7df/model-building_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" />

We can make it easier to see how the other attributes of a diamond affect its relative <code>price</code> by fitting a model to separate out the effect of <code>carat</code>. 
But first, lets make a couple of tweaks to the diamonds dataset to make it easier to work with:

Focus on diamonds smaller than 2.5 carats (99.7% of the data)

Log-transform the carat and price variables.

<code>diamonds2 &lt;- diamonds %>% </a>
  filter(carat &lt;= 2.5) %>% </a>
  mutate(lprice = log2(price), lcarat = log2(carat))</code>

Together, these changes make it easier to see the relationship between <code>carat</code> and <code>price</code>:

<code>ggplot(diamonds2, aes(lcarat, lprice)) + </a>
  geom_hex(bins = 50)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3b47c0617bc217aeac037a24c79dcd4460e94600/ff56a/model-building_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" />

The log-transformation is particularly useful here because it makes the pattern linear, and linear patterns are the easiest to work with. 
Let’s take the next step and remove that strong linear pattern. 
We first make the pattern explicit by fitting a model:

<code>mod_diamond &lt;- lm(lprice ~ lcarat, data = diamonds2)</code>

Then we look at what the model tells us about the data. 
Note that I back transform the predictions, undoing the log transformation, so I can overlay the predictions on the raw data:

<code>grid &lt;- diamonds2 %>% </a>
  data_grid(carat = seq_range(carat, 20)) %>% </a>
  mutate(lcarat = log2(carat)) %>% </a>
  add_predictions(mod_diamond, "lprice") %>% </a>
  mutate(price = 2 ^ lprice)</a>
</a>
ggplot(diamonds2, aes(carat, price)) + </a>
  geom_hex(bins = 50) + </a>
  geom_line(data = grid, colour = "red", size = 1)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/58f41cd9ce600fa08951b66a427c4c96e24545a2/c0129/model-building_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" />

That tells us something interesting about our data. 
If we believe our model, then the large diamonds are much cheaper than expected. 
This is probably because no diamond in this dataset costs more than $19,000.

Now we can look at the residuals, which verifies that we’ve successfully removed the strong linear pattern:

<code>diamonds2 &lt;- diamonds2 %>% </a>
  add_residuals(mod_diamond, "lresid")</a>
</a>
ggplot(diamonds2, aes(lcarat, lresid)) + </a>
  geom_hex(bins = 50)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/991564d1322700702e9594b57b073b38e77d5a43/a392e/model-building_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" />

Importantly, we can now re-do our motivating plots using those residuals instead of <code>price</code>.

<code>ggplot(diamonds2, aes(cut, lresid)) + geom_boxplot()</a>
ggplot(diamonds2, aes(color, lresid)) + geom_boxplot()</a>
ggplot(diamonds2, aes(clarity, lresid)) + geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5c79b696ae61c1df6c73b271d004dc2e50db9118/4c290/model-building_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0524842326b3312522b09ace806a3230c4c5d8c8/29f96/model-building_files/figure-html/unnamed-chunk-8-2.png" width="70%" style="display: block; margin: auto;" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/67f25ffbb28a4a86e7702f80c297382b17ab1daa/d0c75/model-building_files/figure-html/unnamed-chunk-8-3.png" width="70%" style="display: block; margin: auto;" />

Now we see the relationship we expect: as the quality of the diamond increases, so too does its relative price. 
To interpret the <code>y</code> axis, we need to think about what the residuals are telling us, and what scale they are on. 
A residual of -1 indicates that <code>lprice</code> was 1 unit lower than a prediction based solely on its weight. 
\(2^{-1}\) is 1/2, points with a value of -1 are half the expected price, and residuals with value 1 are twice the predicted price.

<h3>24.2.2 A more complicated model</h3>
If we wanted to, we could continue to build up our model, moving the effects we’ve observed into the model to make them explicit. 
For example, we could include <code>color</code>, <code>cut</code>, and <code>clarity</code> into the model so that we also make explicit the effect of these three categorical variables:

<code>mod_diamond2 &lt;- lm(lprice ~ lcarat + color + cut + clarity, data = diamonds2)</code>

This model now includes four predictors, so it’s getting harder to visualise. 
Fortunately, they’re currently all independent which means that we can plot them individually in four plots. 
To make the process a little easier, we’re going to use the <code>.model</code> argument to <code>data_grid</code>:

<code>grid &lt;- diamonds2 %>% </a>
  data_grid(cut, .model = mod_diamond2) %>% </a>
  add_predictions(mod_diamond2)</a>
grid</a>
#> # A tibble: 5 x 5</a>
#>   cut       lcarat color clarity  pred</a>
#>   &lt;ord>      &lt;dbl> &lt;chr> &lt;chr>   &lt;dbl></a>
#> 1 Fair      -0.515 G     VS2      11.2</a>
#> 2 Good      -0.515 G     VS2      11.3</a>
#> 3 Very Good -0.515 G     VS2      11.4</a>
#> 4 Premium   -0.515 G     VS2      11.4</a>
#> 5 Ideal     -0.515 G     VS2      11.4</a>
</a>
ggplot(grid, aes(cut, pred)) + </a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9b298d46e48bd182a5509623284b6cac7dbcd338/d0afb/model-building_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

If the model needs variables that you haven’t explicitly supplied, <code>data_grid()</code> will automatically fill them in with 'typical' value. 
For continuous variables, it uses the median, and categorical variables it uses the most common value (or values, if there’s a tie).

<code>diamonds2 &lt;- diamonds2 %>% </a>
  add_residuals(mod_diamond2, "lresid2")</a>
</a>
ggplot(diamonds2, aes(lcarat, lresid2)) + </a>
  geom_hex(bins = 50)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0f0c8bf73611dab6e6045f0ad9cc8899751862f3/99754/model-building_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" />

This plot indicates that there are some diamonds with quite large residuals - remember a residual of 2 indicates that the diamond is 4x the price that we expected. 
It’s often useful to look at unusual values individually:

<code>diamonds2 %>% </a>
  filter(abs(lresid2) > 1) %>% </a>
  add_predictions(mod_diamond2) %>% </a>
  mutate(pred = round(2 ^ pred)) %>% </a>
  select(price, pred, carat:table, x:z) %>% </a>
  arrange(price)</a>
#> # A tibble: 16 x 11</a>
#>   price  pred carat cut     color clarity depth table     x     y     z</a>
#>   &lt;int> &lt;dbl> &lt;dbl> &lt;ord>   &lt;ord> &lt;ord>   &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1  1013   264  0.25 Fair    F     SI2      54.4    64  4.3   4.23  2.32</a>
#> 2  1186   284  0.25 Premium G     SI2      59      60  5.33  5.28  3.12</a>
#> 3  1186   284  0.25 Premium G     SI2      58.8    60  5.33  5.28  3.12</a>
#> 4  1262  2644  1.03 Fair    E     I1       78.2    54  5.72  5.59  4.42</a>
#> 5  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66</a>
#> 6  1415   639  0.35 Fair    G     VS2      65.9    54  5.57  5.53  3.66</a>
#> # … with 10 more rows</code>

Nothing really jumps out at me here, but it’s probably worth spending time considering if this indicates a problem with our model, or if there are errors in the data. 
If there are mistakes in the data, this could be an opportunity to buy diamonds that have been priced low incorrectly.

<h3>24.2.3 Exercises</h3>

In the plot of <code>lcarat</code> vs. 
<code>lprice</code>, there are some bright vertical
strips. 
What do they represent?

If <code>log(price) = a_0 + a_1 * log(carat)</code>, what does that say about
the relationship between <code>price</code> and <code>carat</code>?

Extract the diamonds that have very high and very low residuals.
Is there anything unusual about these diamonds? Are they particularly bad
or good, or do you think these are pricing errors?

Does the final model, <code>mod_diamond2</code>, do a good job of predicting
diamond prices? Would you trust it to tell you how much to spend
if you were buying a diamond?

<h2>24.3 What affects the number of daily flights?</h2>
Let’s work through a similar process for a dataset that seems even simpler at first glance: the number of flights that leave NYC per day. 
This is a really small dataset — only 365 rows and 2 columns — and we’re not going to end up with a fully realised model, but as you’ll see, the steps along the way will help us better understand the data. 
Let’s get started by counting the number of flights per day and visualising it with ggplot2.

<code>daily &lt;- flights %>% </a>
  mutate(date = make_date(year, month, day)) %>% </a>
  group_by(date) %>% </a>
  summarise(n = n())</a>
daily</a>
#> # A tibble: 365 x 2</a>
#>   date           n</a>
#>   &lt;date>     &lt;int></a>
#> 1 2013-01-01   842</a>
#> 2 2013-01-02   943</a>
#> 3 2013-01-03   914</a>
#> 4 2013-01-04   915</a>
#> 5 2013-01-05   720</a>
#> 6 2013-01-06   832</a>
#> # … with 359 more rows</a>
</a>
ggplot(daily, aes(date, n)) + </a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/47069e959c0eab56e5ce42d6266a4c56195b3577/f5a72/model-building_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" />

<h3>24.3.1 Day of week</h3>
Understanding the long-term trend is challenging because there’s a very strong day-of-week effect that dominates the subtler patterns. 
Let’s start by looking at the distribution of flight numbers by day-of-week:

<code>daily &lt;- daily %>% </a>
  mutate(wday = wday(date, label = TRUE))</a>
ggplot(daily, aes(wday, n)) + </a>
  geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7146dd919921021b101ffb1dabf3250126c1c608/84801/model-building_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" />

There are fewer flights on weekends because most travel is for business. 
The effect is particularly pronounced on Saturday: you might sometimes leave on Sunday for a Monday morning meeting, but it’s very rare that you’d leave on Saturday as you’d much rather be at home with your family.

One way to remove this strong pattern is to use a model. 
First, we fit the model, and display its predictions overlaid on the original data:

<code>mod &lt;- lm(n ~ wday, data = daily)</a>
</a>
grid &lt;- daily %>% </a>
  data_grid(wday) %>% </a>
  add_predictions(mod, "n")</a>
</a>
ggplot(daily, aes(wday, n)) + </a>
  geom_boxplot() +</a>
  geom_point(data = grid, colour = "red", size = 4)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3f35d8093ffdcb5e80da1624d4e31037ee3fce79/0804e/model-building_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" />

Next we compute and visualise the residuals:

<code>daily &lt;- daily %>% </a>
  add_residuals(mod)</a>
daily %>% </a>
  ggplot(aes(date, resid)) + </a>
  geom_ref_line(h = 0) + </a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/5733ba4d7ddd2a82fbc355cc00c39f33748b8ee5/1b398/model-building_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" />

Note the change in the y-axis: now we are seeing the deviation from the expected number of flights, given the day of week. 
This plot is useful because now that we’ve removed much of the large day-of-week effect, we can see some of the subtler patterns that remain:

Our model seems to fail starting in June: you can still see a strong
regular pattern that our model hasn’t captured. 
Drawing a plot with one
line for each day of the week makes the cause easier to see:

<code>ggplot(daily, aes(date, resid, colour = wday)) + </a>
  geom_ref_line(h = 0) + </a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/856117add58a5c7377a388b4f90dae2c33f1444f/d79aa/model-building_files/figure-html/unnamed-chunk-17-1.png" width="70%" style="display: block; margin: auto;" />

Our model fails to accurately predict the number of flights on Saturday:
during summer there are more flights than we expect, and during Fall there
are fewer. 
We’ll see how we can do better to capture this pattern in the
next section.

There are some days with far fewer flights than expected:

<code>daily %>% </a>
  filter(resid &lt; -100)</a>
#> # A tibble: 11 x 4</a>
#>   date           n wday  resid</a>
#>   &lt;date>     &lt;int> &lt;ord> &lt;dbl></a>
#> 1 2013-01-01   842 Tue   -109.</a>
#> 2 2013-01-20   786 Sun   -105.</a>
#> 3 2013-05-26   729 Sun   -162.</a>
#> 4 2013-07-04   737 Thu   -229.</a>
#> 5 2013-07-05   822 Fri   -145.</a>
#> 6 2013-09-01   718 Sun   -173.</a>
#> # … with 5 more rows</code>

If you’re familiar with American public holidays, you might spot New Year’s
day, July 4th, Thanksgiving and Christmas. 
There are some others that don’t
seem to correspond to public holidays. 
You’ll work on those in one
of the exercises.

There seems to be some smoother long term trend over the course of a year.
We can highlight that trend with <code>geom_smooth()</code>:

<code>daily %>% </a>
  ggplot(aes(date, resid)) + </a>
  geom_ref_line(h = 0) + </a>
  geom_line(colour = "grey50") + </a>
  geom_smooth(se = FALSE, span = 0.20)</a>
#> `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d204bef3c7ee9eba763024bdf89c7bfdece1cbe5/08100/model-building_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

There are fewer flights in January (and December), and more in summer
(May-Sep). 
We can’t do much with this pattern quantitatively, because we
only have a single year of data. 
But we can use our domain knowledge to
brainstorm potential explanations.

<h3>24.3.2 Seasonal Saturday effect</h3>
Let’s first tackle our failure to accurately predict the number of flights on Saturday. 
A good place to start is to go back to the raw numbers, focussing on Saturdays:

<code>daily %>% </a>
  filter(wday == "Sat") %>% </a>
  ggplot(aes(date, n)) + </a>
    geom_point() + </a>
    geom_line() +</a>
    scale_x_date(NULL, date_breaks = "1 month", date_labels = "%b")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b370bbda10ec283e3768fad49801f740f5a95a76/36908/model-building_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

(I’ve used both points and lines to make it more clear what is data and what is interpolation.)

I suspect this pattern is caused by summer holidays: many people go on holiday in the summer, and people don’t mind travelling on Saturdays for vacation. 
Looking at this plot, we might guess that summer holidays are from early June to late August. 
That seems to line up fairly well with the <a href="http://schools.nyc.gov/Calendar/2013-2014+School+Year+Calendars.htm">state’s school terms</a>: summer break in 2013 was Jun 26–Sep 9.

Why are there more Saturday flights in the Spring than the Fall? I asked some American friends and they suggested that it’s less common to plan family vacations during the Fall because of the big Thanksgiving and Christmas holidays. 
We don’t have the data to know for sure, but it seems like a plausible working hypothesis.

Lets create a 'term' variable that roughly captures the three school terms, and check our work with a plot:

<code>term &lt;- function(date) {</a>
  cut(date, </a>
    breaks = ymd(20130101, 20130605, 20130825, 20140101),</a>
    labels = c("spring", "summer", "fall") </a>
  )</a>
}</a>
</a>
daily &lt;- daily %>% </a>
  mutate(term = term(date)) </a>
</a>
daily %>% </a>
  filter(wday == "Sat") %>% </a>
  ggplot(aes(date, n, colour = term)) +</a>
  geom_point(alpha = 1/3) + </a>
  geom_line() +</a>
  scale_x_date(NULL, date_breaks = "1 month", date_labels = "%b")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4a0624d5c1208316a770bf584f6cc003a9291223/a815a/model-building_files/figure-html/unnamed-chunk-21-1.png" width="70%" style="display: block; margin: auto;" />

(I manually tweaked the dates to get nice breaks in the plot. 
Using a visualisation to help you understand what your function is doing is a really powerful and general technique.)

It’s useful to see how this new variable affects the other days of the week:

<code>daily %>% </a>
  ggplot(aes(wday, n, colour = term)) +</a>
    geom_boxplot()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f1447818a0ab86ab2d7a08666c82b2d9621c3ae3/a24a7/model-building_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" />

It looks like there is significant variation across the terms, so fitting a separate day of week effect for each term is reasonable. 
This improves our model, but not as much as we might hope:

<code>mod1 &lt;- lm(n ~ wday, data = daily)</a>
mod2 &lt;- lm(n ~ wday * term, data = daily)</a>
</a>
daily %>% </a>
  gather_residuals(without_term = mod1, with_term = mod2) %>% </a>
  ggplot(aes(date, resid, colour = model)) +</a>
    geom_line(alpha = 0.75)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7a6a3f95dbb588c379043d922f3d1aa9b3df1dee/37e31/model-building_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" />

We can see the problem by overlaying the predictions from the model on to the raw data:

<code>grid &lt;- daily %>% </a>
  data_grid(wday, term) %>% </a>
  add_predictions(mod2, "n")</a>
</a>
ggplot(daily, aes(wday, n)) +</a>
  geom_boxplot() + </a>
  geom_point(data = grid, colour = "red") + </a>
  facet_wrap(~ term)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2c1efc71384e2fedf52b5894155a42ef074ad6fe/0033d/model-building_files/figure-html/unnamed-chunk-24-1.png" width="70%" style="display: block; margin: auto;" />

Our model is finding the <em>mean</em> effect, but we have a lot of big outliers, so mean tends to be far away from the typical value. 
We can alleviate this problem by using a model that is robust to the effect of outliers: <code>MASS::rlm()</code>. 
This greatly reduces the impact of the outliers on our estimates, and gives a model that does a good job of removing the day of week pattern:

<code>mod3 &lt;- MASS::rlm(n ~ wday * term, data = daily)</a>
</a>
daily %>% </a>
  add_residuals(mod3, "resid") %>% </a>
  ggplot(aes(date, resid)) + </a>
  geom_hline(yintercept = 0, size = 2, colour = "white") + </a>
  geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bcbd14248e9d6ad62363735a90cc6fa2513e94a5/0230b/model-building_files/figure-html/unnamed-chunk-25-1.png" width="70%" style="display: block; margin: auto;" />

It’s now much easier to see the long-term trend, and the positive and negative outliers.

<h3>24.3.3 Computed variables</h3>
If you’re experimenting with many models and many visualisations, it’s a good idea to bundle the creation of variables up into a function so there’s no chance of accidentally applying a different transformation in different places. 
For example, we could write:

<code>compute_vars &lt;- function(data) {</a>
  data %>% </a>
    mutate(</a>
      term = term(date), </a>
      wday = wday(date, label = TRUE)</a>
    )</a>
}</code>

Another option is to put the transformations directly in the model formula:

<code>wday2 &lt;- function(x) wday(x, label = TRUE)</a>
mod3 &lt;- lm(n ~ wday2(date) * term(date), data = daily)</code>

Either approach is reasonable. 
Making the transformed variable explicit is useful if you want to check your work, or use them in a visualisation. 
But you can’t easily use transformations (like splines) that return multiple columns. 
Including the transformations in the model function makes life a little easier when you’re working with many different datasets because the model is self contained.

<h3>24.3.4 Time of year: an alternative approach</h3>
In the previous section we used our domain knowledge (how the US school term affects travel) to improve the model. 
An alternative to using our knowledge explicitly in the model is to give the data more room to speak. 
We could use a more flexible model and allow that to capture the pattern we’re interested in. 
A simple linear trend isn’t adequate, so we could try using a natural spline to fit a smooth curve across the year:

<code>library(splines)</a>
mod &lt;- MASS::rlm(n ~ wday * ns(date, 5), data = daily)</a>
</a>
daily %>% </a>
  data_grid(wday, date = seq_range(date, n = 13)) %>% </a>
  add_predictions(mod) %>% </a>
  ggplot(aes(date, pred, colour = wday)) + </a>
    geom_line() +</a>
    geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7cb2854427ac5cbe2fbc9668e466554062eeee50/a7de5/model-building_files/figure-html/unnamed-chunk-28-1.png" width="70%" style="display: block; margin: auto;" />

We see a strong pattern in the numbers of Saturday flights. 
This is reassuring, because we also saw that pattern in the raw data. 
It’s a good sign when you get the same signal from different approaches.

<h3>24.3.5 Exercises</h3>

Use your Google sleuthing skills to brainstorm why there were fewer than
expected flights on Jan 20, May 26, and Sep 1. 
(Hint: they all have the
same explanation.) How would these days generalise to another year?

What do the three days with high positive residuals represent?
How would these days generalise to another year?

<code>daily %>% </a>
  top_n(3, resid)</a>
#> # A tibble: 3 x 5</a>
#>   date           n wday  resid term </a>
#>   &lt;date>     &lt;int> &lt;ord> &lt;dbl> &lt;fct></a>
#> 1 2013-11-30   857 Sat   112. 
 fall </a>
#> 2 2013-12-01   987 Sun    95.5 fall </a>
#> 3 2013-12-28   814 Sat    69.4 fall</code>

Create a new variable that splits the <code>wday</code> variable into terms, but only
for Saturdays, i.e. it should have <code>Thurs</code>, <code>Fri</code>, but <code>Sat-summer</code>,
<code>Sat-spring</code>, <code>Sat-fall</code>. 
How does this model compare with the model with
every combination of <code>wday</code> and <code>term</code>?

Create a new <code>wday</code> variable that combines the day of week, term
(for Saturdays), and public holidays. 
What do the residuals of
that model look like?

What happens if you fit a day of week effect that varies by month
(i.e. 
<code>n ~ wday * month</code>)? Why is this not very helpful?

What would you expect the model <code>n ~ wday + ns(date, 5)</code> to look like?
Knowing what you know about the data, why would you expect it to be
not particularly effective?

We hypothesised that people leaving on Sundays are more likely to be
business travellers who need to be somewhere on Monday. 
Explore that
hypothesis by seeing how it breaks down based on distance and time: if
it’s true, you’d expect to see more Sunday evening flights to places that
are far away.

It’s a little frustrating that Sunday and Saturday are on separate ends
of the plot. 
Write a small function to set the levels of the
factor so that the week starts on Monday.

<h2>24.4 Learning more about models</h2>
We have only scratched the absolute surface of modelling, but you have hopefully gained some simple, but general-purpose tools that you can use to improve your own data analyses. 
It’s OK to start simple! As you’ve seen, even very simple models can make a dramatic difference in your ability to tease out interactions between variables.

These modelling chapters are even more opinionated than the rest of the book. 
I approach modelling from a somewhat different perspective to most others, and there is relatively little space devoted to it. 
Modelling really deserves a book on its own, so I’d highly recommend that you read at least one of these three books:

<em>Statistical Modeling: A Fresh Approach</em> by Danny Kaplan,
<a href="http://project-mosaic-books.com/?page_id=13" class="uri">http://project-mosaic-books.com/?page_id=13</a>. 
This book provides
a gentle introduction to modelling, where you build your intuition,
mathematical tools, and R skills in parallel. 
The book replaces a traditional
'introduction to statistics' course, providing a curriculum that is up-to-date
and relevant to data science.

<em>An Introduction to Statistical Learning</em> by Gareth James, Daniela Witten,
Trevor Hastie, and Robert Tibshirani, <a href="http://www-bcf.usc.edu/~gareth/ISL/" class="uri">http://www-bcf.usc.edu/~gareth/ISL/</a>
(available online for free). 
This book presents a family of modern modelling
techniques collectively known as statistical learning. 
For an even deeper
understanding of the math behind the models, read the classic
<em>Elements of Statistical Learning</em> by Trevor Hastie, Robert Tibshirani, and
Jerome Friedman, <a href="https://web.stanford.edu/~hastie/Papers/ESLII.pdf" class="uri">https://web.stanford.edu/~hastie/Papers/ESLII.pdf</a> (also
available online for free).

<em>Applied Predictive Modeling</em> by Max Kuhn and Kjell Johnson,
<a href="http://appliedpredictivemodeling.com" class="uri">http://appliedpredictivemodeling.com</a>. 
This book is a companion to the
caret package and provides practical tools for dealing with real-life
predictive modelling challenges.

<h2><span class="orange">25 Many models</span></h2>

<h2>25.1 Introduction</h2>
In this chapter you’re going to learn three powerful ideas that help you to work with large numbers of models with ease:

Using many simple models to better understand complex datasets.

Using list-columns to store arbitrary data structures in a data frame.
For example, this will allow you to have a column that contains linear
models.

Using the broom package, by David Robinson, to turn models into tidy
data. 
This is a powerful technique for working with large numbers of models
because once you have tidy data, you can apply all of the techniques that
you’ve learned about earlier in the book.

We’ll start by diving into a motivating example using data about life expectancy around the world. 
It’s a small dataset but it illustrates how important modelling can be for improving your visualisations. 
We’ll use a large number of simple models to partition out some of the strongest signals so we can see the subtler signals that remain. 
We’ll also see how model summaries can help us pick out outliers and unusual trends.

The following sections will dive into more detail about the individual techniques:

In <a href="many-models.html#list-columns-1">list-columns</a>, you’ll learn more about the list-column data structure,
and why it’s valid to put lists in data frames.

In <a href="many-models.html#creating-list-columns">creating list-columns</a>, you’ll learn the three main ways in which you’ll
create list-columns.

In <a href="many-models.html#simplifying-list-columns">simplifying list-columns</a> you’ll learn how to convert list-columns back
to regular atomic vectors (or sets of atomic vectors) so you can work
with them more easily.

In <a href="many-models.html#making-tidy-data-with-broom">making tidy data with broom</a>, you’ll learn about the full set of tools
provided by broom, and see how they can be applied to other types of
data structure.

This chapter is somewhat aspirational: if this book is your first introduction to R, this chapter is likely to be a struggle. 
It requires you have to deeply internalised ideas about modelling, data structures, and iteration. 
So don’t worry if you don’t get it — just put this chapter aside for a few months, and come back when you want to stretch your brain.

<h3>25.1.1 Prerequisites</h3>
Working with many models requires many of the packages of the tidyverse (for data exploration, wrangling, and programming) and modelr to facilitate modelling.

<code>library(modelr)</a>
library(tidyverse)</code>

<h2>25.2 gapminder</h2>
To motivate the power of many simple models, we’re going to look into the 'gapminder' data. 
This data was popularised by Hans Rosling, a Swedish doctor and statistician. 
If you’ve never heard of him, stop reading this chapter right now and go watch one of his videos! He is a fantastic data presenter and illustrates how you can use data to present a compelling story. 
A good place to start is this short video filmed in conjunction with the BBC: <a href="https://www.youtube.com/watch?v=jbkSRLYSojo" class="uri">https://www.youtube.com/watch?v=jbkSRLYSojo</a>.

The gapminder data summarises the progression of countries over time, looking at statistics like life expectancy and GDP. 
The data is easy to access in R, thanks to Jenny Bryan who created the gapminder package:

<code>library(gapminder)</a>
gapminder</a>
#> # A tibble: 1,704 x 6</a>
#>   country     continent  year lifeExp      pop gdpPercap</a>
#>   &lt;fct>       &lt;fct>     &lt;int>   &lt;dbl>    &lt;int>     &lt;dbl></a>
#> 1 Afghanistan Asia       1952    28.8  8425333      779.</a>
#> 2 Afghanistan Asia       1957    30.3  9240934      821.</a>
#> 3 Afghanistan Asia       1962    32.0 10267083      853.</a>
#> 4 Afghanistan Asia       1967    34.0 11537966      836.</a>
#> 5 Afghanistan Asia       1972    36.1 13079460      740.</a>
#> 6 Afghanistan Asia       1977    38.4 14880372      786.</a>
#> # … with 1,698 more rows</code>

In this case study, we’re going to focus on just three variables to answer the question 'How does life expectancy (<code>lifeExp</code>) change over time (<code>year</code>) for each country (<code>country</code>)?'. 
A good place to start is with a plot:

<code>gapminder %>% </a>
  ggplot(aes(year, lifeExp, group = country)) +</a>
    geom_line(alpha = 1/3)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1c742124830f13eda516579eacf98e2caa20d741/67891/model-many_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" />

This is a small dataset: it only has ~1,700 observations and 3 variables. 
But it’s still hard to see what’s going on! Overall, it looks like life expectancy has been steadily improving. 
However, if you look closely, you might notice some countries that don’t follow this pattern. 
How can we make those countries easier to see?

One way is to use the same approach as in the last chapter: there’s a strong signal (overall linear growth) that makes it hard to see subtler trends. 
We’ll tease these factors apart by fitting a model with a linear trend. 
The model captures steady growth over time, and the residuals will show what’s left.

You already know how to do that if we had a single country:

<code>nz &lt;- filter(gapminder, country == "New Zealand")</a>
nz %>% </a>
  ggplot(aes(year, lifeExp)) + </a>
  geom_line() + </a>
  ggtitle("Full data = ")</a>
</a>
nz_mod &lt;- lm(lifeExp ~ year, data = nz)</a>
nz %>% </a>
  add_predictions(nz_mod) %>%</a>
  ggplot(aes(year, pred)) + </a>
  geom_line() + </a>
  ggtitle("Linear trend + ")</a>
</a>
nz %>% </a>
  add_residuals(nz_mod) %>% </a>
  ggplot(aes(year, resid)) + </a>
  geom_hline(yintercept = 0, colour = "white", size = 3) + </a>
  geom_line() + </a>
  ggtitle("Remaining pattern")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/eeb6968125f501f56980824ea70a256a20e5960c/1f95f/model-many_files/figure-html/unnamed-chunk-3-1.png" width="33%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1c176b7f49e3e4f61028cd4b24820bc2b8256235/922ca/model-many_files/figure-html/unnamed-chunk-3-2.png" width="33%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dedb27e8ef87d071c9249f3a40476aa186eb9405/34bcc/model-many_files/figure-html/unnamed-chunk-3-3.png" width="33%" />

How can we easily fit that model to every country?

<h3>25.2.1 Nested data</h3>
You could imagine copy and pasting that code multiple times; but you’ve already learned a better way! Extract out the common code with a function and repeat using a map function from purrr. 
This problem is structured a little differently to what you’ve seen before. 
Instead of repeating an action for each variable, we want to repeat an action for each country, a subset of rows. 
To do that, we need a new data structure: the nested data frame. 
To create a nested data frame we start with a grouped data frame, and 'nest' it:

<code>by_country &lt;- gapminder %>% </a>
  group_by(country, continent) %>% </a>
  nest()</a>
</a>
by_country</a>
#> # A tibble: 142 x 3</a>
#> # Groups:   country, continent [710]</a>
#>   country     continent data             </a>
#>   &lt;fct>       &lt;fct>     &lt;list>           </a>
#> 1 Afghanistan Asia      &lt;tibble [12 × 4]></a>
#> 2 Albania     Europe    &lt;tibble [12 × 4]></a>
#> 3 Algeria     Africa    &lt;tibble [12 × 4]></a>
#> 4 Angola      Africa    &lt;tibble [12 × 4]></a>
#> 5 Argentina   Americas  &lt;tibble [12 × 4]></a>
#> 6 Australia   Oceania   &lt;tibble [12 × 4]></a>
#> # … with 136 more rows</code>

(I’m cheating a little by grouping on both <code>continent</code> and <code>country</code>. 
Given <code>country</code>, <code>continent</code> is fixed, so this doesn’t add any more groups, but it’s an easy way to carry an extra variable along for the ride.)

This creates a data frame that has one row per group (per country), and a rather unusual column: <code>data</code>. 
<code>data</code> is a list of data frames (or tibbles, to be precise). 
This seems like a crazy idea: we have a data frame with a column that is a list of other data frames! I’ll explain shortly why I think this is a good idea.

The <code>data</code> column is a little tricky to look at because it’s a moderately complicated list, and we’re still working on good tools to explore these objects. 
Unfortunately using <code>str()</code> is not recommended as it will often produce very long output. 
But if you pluck out a single element from the <code>data</code> column you’ll see that it contains all the data for that country (in this case, Afghanistan).

<code>by_country$data[[1]]</a>
#> # A tibble: 12 x 4</a>
#>    year lifeExp      pop gdpPercap</a>
#>   &lt;int>   &lt;dbl>    &lt;int>     &lt;dbl></a>
#> 1  1952    28.8  8425333      779.</a>
#> 2  1957    30.3  9240934      821.</a>
#> 3  1962    32.0 10267083      853.</a>
#> 4  1967    34.0 11537966      836.</a>
#> 5  1972    36.1 13079460      740.</a>
#> 6  1977    38.4 14880372      786.</a>
#> # … with 6 more rows</code>

Note the difference between a standard grouped data frame and a nested data frame: in a grouped data frame, each row is an observation; in a nested data frame, each row is a group. 
Another way to think about a nested dataset is we now have a meta-observation: a row that represents the complete time course for a country, rather than a single point in time.

<h3>25.2.2 List-columns</h3>
Now that we have our nested data frame, we’re in a good position to fit some models. 
We have a model-fitting function:

<code>country_model &lt;- function(df) {</a>
  lm(lifeExp ~ year, data = df)</a>
}</code>

And we want to apply it to every data frame. 
The data frames are in a list, so we can use <code>purrr::map()</code> to apply <code>country_model</code> to each element:

<code>models &lt;- map(by_country$data, country_model)</code>

However, rather than leaving the list of models as a free-floating object, I think it’s better to store it as a column in the <code>by_country</code> data frame. 
Storing related objects in columns is a key part of the value of data frames, and why I think list-columns are such a good idea. 
In the course of working with these countries, we are going to have lots of lists where we have one element per country. 
So why not store them all together in one data frame?

In other words, instead of creating a new object in the global environment, we’re going to create a new variable in the <code>by_country</code> data frame. 
That’s a job for <code>dplyr::mutate()</code>:

<code>by_country &lt;- by_country %>% </a>
  mutate(model = map(data, country_model))</a>
by_country</a>
#> # A tibble: 142 x 4</a>
#> # Groups:   country, continent [710]</a>
#>   country     continent data              model </a>
#>   &lt;fct>       &lt;fct>     &lt;list>            &lt;list></a>
#> 1 Afghanistan Asia      &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 2 Albania     Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 3 Algeria     Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 4 Angola      Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 5 Argentina   Americas  &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 6 Australia   Oceania   &lt;tibble [12 × 4]> &lt;lm>  </a>
#> # … with 136 more rows</code>

This has a big advantage: because all the related objects are stored together, you don’t need to manually keep them in sync when you filter or arrange. 
The semantics of the data frame takes care of that for you:

<code>by_country %>% </a>
  filter(continent == "Europe")</a>
#> # A tibble: 30 x 4</a>
#> # Groups:   country, continent [710]</a>
#>   country                continent data              model </a>
#>   &lt;fct>                  &lt;fct>     &lt;list>            &lt;list></a>
#> 1 Albania                Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 2 Austria                Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 3 Belgium                Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 4 Bosnia and Herzegovina Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 5 Bulgaria               Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 6 Croatia                Europe    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> # … with 24 more rows</a>
by_country %>% </a>
  arrange(continent, country)</a>
#> # A tibble: 142 x 4</a>
#> # Groups:   country, continent [710]</a>
#>   country      continent data              model </a>
#>   &lt;fct>        &lt;fct>     &lt;list>            &lt;list></a>
#> 1 Algeria      Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 2 Angola       Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 3 Benin        Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 4 Botswana     Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 5 Burkina Faso Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> 6 Burundi      Africa    &lt;tibble [12 × 4]> &lt;lm>  </a>
#> # … with 136 more rows</code>

If your list of data frames and list of models were separate objects, you have to remember that whenever you re-order or subset one vector, you need to re-order or subset all the others in order to keep them in sync. 
If you forget, your code will continue to work, but it will give the wrong answer!

<h3>25.2.3 Unnesting</h3>
Previously we computed the residuals of a single model with a single dataset. 
Now we have 142 data frames and 142 models. 
To compute the residuals, we need to call <code>add_residuals()</code> with each model-data pair:

<code>by_country &lt;- by_country %>% </a>
  mutate(</a>
    resids = map2(data, model, add_residuals)</a>
  )</a>
by_country</a>
#> # A tibble: 142 x 5</a>
#> # Groups:   country, continent [710]</a>
#>   country     continent data              model  resids           </a>
#>   &lt;fct>       &lt;fct>     &lt;list>            &lt;list> &lt;list>           </a>
#> 1 Afghanistan Asia      &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> 2 Albania     Europe    &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> 3 Algeria     Africa    &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> 4 Angola      Africa    &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> 5 Argentina   Americas  &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> 6 Australia   Oceania   &lt;tibble [12 × 4]> &lt;lm>   &lt;tibble [12 × 5]></a>
#> # … with 136 more rows</code>

But how you can plot a list of data frames? Instead of struggling to answer that question, let’s turn the list of data frames back into a regular data frame. 
Previously we used <code>nest()</code> to turn a regular data frame into an nested data frame, and now we do the opposite with <code>unnest()</code>:

<code>resids &lt;- unnest(by_country, resids)</a>
resids</a>
#> # A tibble: 1,704 x 9</a>
#> # Groups:   country, continent [710]</a>
#>   country    continent data        model  year lifeExp     pop gdpPercap   resid</a>
#>   &lt;fct>      &lt;fct>     &lt;list>      &lt;lis> &lt;int>   &lt;dbl>   &lt;int>     &lt;dbl>   &lt;dbl></a>
#> 1 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1952    28.8  8.43e6      779. 
-1.11  </a>
#> 2 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1957    30.3  9.24e6      821. 
-0.952 </a>
#> 3 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1962    32.0  1.03e7      853. 
-0.664 </a>
#> 4 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1967    34.0  1.15e7      836. 
-0.0172</a>
#> 5 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1972    36.1  1.31e7      740. 
 0.674 </a>
#> 6 Afghanist… Asia      &lt;tibble [1… &lt;lm>   1977    38.4  1.49e7      786. 
 1.65  </a>
#> # … with 1,698 more rows</code>

Note that each regular column is repeated one for each row in the nested column.

Now we have regular data frame, we can plot the residuals:

<code>resids %>% </a>
  ggplot(aes(year, resid)) +</a>
    geom_line(aes(group = country), alpha = 1 / 3) + </a>
    geom_smooth(se = FALSE)</a>
#> `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = "cs")&#39;</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/a842de6e0a45074fa0882fb0b9ab9ce8647551b4/fc426/model-many_files/figure-html/unnamed-chunk-12-1.png" width="70%" style="display: block; margin: auto;" />

Facetting by continent is particularly revealing:

<code>resids %>% </a>
  ggplot(aes(year, resid, group = country)) +</a>
    geom_line(alpha = 1 / 3) + </a>
    facet_wrap(~continent)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3a02b4918f33a977e51b7e8a50f8dcdf5cee8118/3d571/model-many_files/figure-html/unnamed-chunk-13-1.png" width="70%" style="display: block; margin: auto;" />

It looks like we’ve missed some mild patterns. 
There’s also something interesting going on in Africa: we see some very large residuals which suggests our model isn’t fitting so well there. 
We’ll explore that more in the next section, attacking it from a slightly different angle.

<h3>25.2.4 Model quality</h3>
Instead of looking at the residuals from the model, we could look at some general measurements of model quality. 
You learned how to compute some specific measures in the previous chapter. 
Here we’ll show a different approach using the broom package. 
The broom package provides a general set of functions to turn models into tidy data. 
Here we’ll use <code>broom::glance()</code> to extract some model quality metrics. 
If we apply it to a model, we get a data frame with a single row:

<code>broom::glance(nz_mod)</a>
#> # A tibble: 1 x 11</a>
#>   r.squared adj.r.squared sigma statistic p.value    df logLik   AIC   BIC</a>
#>       &lt;dbl>         &lt;dbl> &lt;dbl>     &lt;dbl>   &lt;dbl> &lt;int>  &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     0.954         0.949 0.804      205. 
5.41e-8     2  -13.3  32.6  34.1</a>
#> # … with 2 more variables: deviance &lt;dbl>, df.residual &lt;int></code>

We can use <code>mutate()</code> and <code>unnest()</code> to create a data frame with a row for each country:

<code>by_country %>% </a>
  mutate(glance = map(model, broom::glance)) %>% </a>
  unnest(glance)</a>
#> # A tibble: 142 x 16</a>
#> # Groups:   country, continent [710]</a>
#>   country continent data  model resids r.squared adj.r.squared sigma statistic</a>
#>   &lt;fct>   &lt;fct>     &lt;lis> &lt;lis> &lt;list>     &lt;dbl>         &lt;dbl> &lt;dbl>     &lt;dbl></a>
#> 1 Afghan… Asia      &lt;tib… &lt;lm>  &lt;tibb…     0.948         0.942 1.22      181. 
</a>
#> 2 Albania Europe    &lt;tib… &lt;lm>  &lt;tibb…     0.911         0.902 1.98      102. 
</a>
#> 3 Algeria Africa    &lt;tib… &lt;lm>  &lt;tibb…     0.985         0.984 1.32      662. 
</a>
#> 4 Angola  Africa    &lt;tib… &lt;lm>  &lt;tibb…     0.888         0.877 1.41       79.1</a>
#> 5 Argent… Americas  &lt;tib… &lt;lm>  &lt;tibb…     0.996         0.995 0.292    2246. 
</a>
#> 6 Austra… Oceania   &lt;tib… &lt;lm>  &lt;tibb…     0.980         0.978 0.621     481. 
</a>
#> # … with 136 more rows, and 7 more variables: p.value &lt;dbl>, df &lt;int>,</a>
#> #   logLik &lt;dbl>, AIC &lt;dbl>, BIC &lt;dbl>, deviance &lt;dbl>, df.residual &lt;int></code>

This isn’t quite the output we want, because it still includes all the list columns. 
This is default behaviour when <code>unnest()</code> works on single row data frames. 
To suppress these columns we use <code>.drop = TRUE</code>:

<code>glance &lt;- by_country %>% </a>
  mutate(glance = map(model, broom::glance)) %>% </a>
  unnest(glance, .drop = TRUE)</a>
#> Warning: The `.drop` argument of `unnest()` is deprecated as of tidyr 1.0.0.</a>
#> All list-columns are now preserved.</a>
#> This warning is displayed once every 8 hours.</a>
#> Call `lifecycle::last_warnings()` to see where this warning was generated.</a>
glance</a>
#> # A tibble: 142 x 16</a>
#> # Groups:   country, continent [710]</a>
#>   country continent data  model resids r.squared adj.r.squared sigma statistic</a>
#>   &lt;fct>   &lt;fct>     &lt;lis> &lt;lis> &lt;list>     &lt;dbl>         &lt;dbl> &lt;dbl>     &lt;dbl></a>
#> 1 Afghan… Asia      &lt;tib… &lt;lm>  &lt;tibb…     0.948         0.942 1.22      181. 
</a>
#> 2 Albania Europe    &lt;tib… &lt;lm>  &lt;tibb…     0.911         0.902 1.98      102. 
</a>
#> 3 Algeria Africa    &lt;tib… &lt;lm>  &lt;tibb…     0.985         0.984 1.32      662. 
</a>
#> 4 Angola  Africa    &lt;tib… &lt;lm>  &lt;tibb…     0.888         0.877 1.41       79.1</a>
#> 5 Argent… Americas  &lt;tib… &lt;lm>  &lt;tibb…     0.996         0.995 0.292    2246. 
</a>
#> 6 Austra… Oceania   &lt;tib… &lt;lm>  &lt;tibb…     0.980         0.978 0.621     481. 
</a>
#> # … with 136 more rows, and 7 more variables: p.value &lt;dbl>, df &lt;int>,</a>
#> #   logLik &lt;dbl>, AIC &lt;dbl>, BIC &lt;dbl>, deviance &lt;dbl>, df.residual &lt;int></code>

(Pay attention to the variables that aren’t printed: there’s a lot of useful stuff there.)

With this data frame in hand, we can start to look for models that don’t fit well:

<code>glance %>% </a>
  arrange(r.squared)</a>
#> # A tibble: 142 x 16</a>
#> # Groups:   country, continent [710]</a>
#>   country continent data  model resids r.squared adj.r.squared sigma statistic</a>
#>   &lt;fct>   &lt;fct>     &lt;lis> &lt;lis> &lt;list>     &lt;dbl>         &lt;dbl> &lt;dbl>     &lt;dbl></a>
#> 1 Rwanda  Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0172      -0.0811   6.56     0.175</a>
#> 2 Botswa… Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0340      -0.0626   6.11     0.352</a>
#> 3 Zimbab… Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0562      -0.0381   7.21     0.596</a>
#> 4 Zambia  Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0598      -0.0342   4.53     0.636</a>
#> 5 Swazil… Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0682      -0.0250   6.64     0.732</a>
#> 6 Lesotho Africa    &lt;tib… &lt;lm>  &lt;tibb…    0.0849      -0.00666  5.93     0.927</a>
#> # … with 136 more rows, and 7 more variables: p.value &lt;dbl>, df &lt;int>,</a>
#> #   logLik &lt;dbl>, AIC &lt;dbl>, BIC &lt;dbl>, deviance &lt;dbl>, df.residual &lt;int></code>

The worst models all appear to be in Africa. 
Let’s double check that with a plot. 
Here we have a relatively small number of observations and a discrete variable, so <code>geom_jitter()</code> is effective:

<code>glance %>% </a>
  ggplot(aes(continent, r.squared)) + </a>
    geom_jitter(width = 0.5)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/000b1eb2494bf98135b5505be6afc98228ccd662/d1d89/model-many_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

We could pull out the countries with particularly bad \(R^2\) and plot the data:

<code>bad_fit &lt;- filter(glance, r.squared &lt; 0.25)</a>
</a>
gapminder %>% </a>
  semi_join(bad_fit, by = "country") %>% </a>
  ggplot(aes(year, lifeExp, colour = country)) +</a>
    geom_line()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/524deb0d0fd716d2d47f641092267560b99aa0c7/56507/model-many_files/figure-html/unnamed-chunk-19-1.png" width="70%" style="display: block; margin: auto;" />

We see two main effects here: the tragedies of the HIV/AIDS epidemic and the Rwandan genocide.

<h3>25.2.5 Exercises</h3>

A linear trend seems to be slightly too simple for the overall trend.
Can you do better with a quadratic polynomial? How can you interpret
the coefficients of the quadratic? (Hint you might want to transform
<code>year</code> so that it has mean zero.)

Explore other methods for visualising the distribution of \(R^2\) per
continent. 
You might want to try the ggbeeswarm package, which provides
similar methods for avoiding overlaps as jitter, but uses deterministic
methods.

To create the last plot (showing the data for the countries with the
worst model fits), we needed two steps: we created a data frame with
one row per country and then semi-joined it to the original dataset.
It’s possible to avoid this join if we use <code>unnest()</code> instead of
<code>unnest(.drop = TRUE)</code>. 
How?

<h2>25.3 List-columns</h2>
Now that you’ve seen a basic workflow for managing many models, let’s dive back into some of the details. 
In this section, we’ll explore the list-column data structure in a little more detail. 
It’s only recently that I’ve really appreciated the idea of the list-column. 
List-columns are implicit in the definition of the data frame: a data frame is a named list of equal length vectors. 
A list is a vector, so it’s always been legitimate to use a list as a column of a data frame. 
However, base R doesn’t make it easy to create list-columns, and <code>data.frame()</code> treats a list as a list of columns:.

<code>data.frame(x = list(1:3, 3:5))</a>
#>   x.1.3 x.3.5</a>
#> 1     1     3</a>
#> 2     2     4</a>
#> 3     3     5</code>

You can prevent <code>data.frame()</code> from doing this with <code>I()</code>, but the result doesn’t print particularly well:

<code>data.frame(</a>
  x = I(list(1:3, 3:5)), </a>
  y = c("1, 2", "3, 4, 5")</a>
)</a>
#>         x       y</a>
#> 1 1, 2, 3    1, 2</a>
#> 2 3, 4, 5 3, 4, 5</code>

Tibble alleviates this problem by being lazier (<code>tibble()</code> doesn’t modify its inputs) and by providing a better print method:

<code>tibble(</a>
  x = list(1:3, 3:5), </a>
  y = c("1, 2", "3, 4, 5")</a>
)</a>
#> # A tibble: 2 x 2</a>
#>   x         y      </a>
#>   &lt;list>    &lt;chr>  </a>
#> 1 &lt;int [3]> 1, 2   </a>
#> 2 &lt;int [3]> 3, 4, 5</code>

It’s even easier with <code>tribble()</code> as it can automatically work out that you need a list:

<code>tribble(</a>
   ~x, ~y,</a>
  1:3, "1, 2",</a>
  3:5, "3, 4, 5"</a>
)</a>
#> # A tibble: 2 x 2</a>
#>   x         y      </a>
#>   &lt;list>    &lt;chr>  </a>
#> 1 &lt;int [3]> 1, 2   </a>
#> 2 &lt;int [3]> 3, 4, 5</code>

List-columns are often most useful as intermediate data structure. 
They’re hard to work with directly, because most R functions work with atomic vectors or data frames, but the advantage of keeping related items together in a data frame is worth a little hassle.

Generally there are three parts of an effective list-column pipeline:

You create the list-column using one of <code>nest()</code>, <code>summarise()</code> + <code>list()</code>,
or <code>mutate()</code> + a map function, as described in <a href="many-models.html#creating-list-columns">Creating list-columns</a>.

You create other intermediate list-columns by transforming existing
list columns with <code>map()</code>, <code>map2()</code> or <code>pmap()</code>. 
For example,
in the case study above, we created a list-column of models by transforming
a list-column of data frames.

You simplify the list-column back down to a data frame or atomic vector,
as described in <a href="many-models.html#simplifying-list-columns">Simplifying list-columns</a>.

<h2>25.4 Creating list-columns</h2>
Typically, you won’t create list-columns with <code>tibble()</code>. 
Instead, you’ll create them from regular columns, using one of three methods:

With <code>tidyr::nest()</code> to convert a grouped data frame into a nested data
frame where you have list-column of data frames.

With <code>mutate()</code> and vectorised functions that return a list.

With <code>summarise()</code> and summary functions that return multiple results.

Alternatively, you might create them from a named list, using <code>tibble::enframe()</code>.

Generally, when creating list-columns, you should make sure they’re homogeneous: each element should contain the same type of thing. 
There are no checks to make sure this is true, but if you use purrr and remember what you’ve learned about type-stable functions, you should find it happens naturally.

<h3>25.4.1 With nesting</h3>
<code>nest()</code> creates a nested data frame, which is a data frame with a list-column of data frames. 
In a nested data frame each row is a meta-observation: the other columns give variables that define the observation (like country and continent above), and the list-column of data frames gives the individual observations that make up the meta-observation.

There are two ways to use <code>nest()</code>. 
So far you’ve seen how to use it with a grouped data frame. 
When applied to a grouped data frame, <code>nest()</code> keeps the grouping columns as is, and bundles everything else into the list-column:

<code>gapminder %>% </a>
  group_by(country, continent) %>% </a>
  nest()</a>
#> # A tibble: 142 x 3</a>
#> # Groups:   country, continent [710]</a>
#>   country     continent data             </a>
#>   &lt;fct>       &lt;fct>     &lt;list>           </a>
#> 1 Afghanistan Asia      &lt;tibble [12 × 4]></a>
#> 2 Albania     Europe    &lt;tibble [12 × 4]></a>
#> 3 Algeria     Africa    &lt;tibble [12 × 4]></a>
#> 4 Angola      Africa    &lt;tibble [12 × 4]></a>
#> 5 Argentina   Americas  &lt;tibble [12 × 4]></a>
#> 6 Australia   Oceania   &lt;tibble [12 × 4]></a>
#> # … with 136 more rows</code>

You can also use it on an ungrouped data frame, specifying which columns you want to nest:

<code>gapminder %>% </a>
  nest(year:gdpPercap)</a>
#> Warning: All elements of `...` must be named.</a>
#> Did you want `data = c(year, lifeExp, pop, gdpPercap)`?</a>
#> # A tibble: 142 x 3</a>
#>   country     continent data             </a>
#>   &lt;fct>       &lt;fct>     &lt;list>           </a>
#> 1 Afghanistan Asia      &lt;tibble [12 × 4]></a>
#> 2 Albania     Europe    &lt;tibble [12 × 4]></a>
#> 3 Algeria     Africa    &lt;tibble [12 × 4]></a>
#> 4 Angola      Africa    &lt;tibble [12 × 4]></a>
#> 5 Argentina   Americas  &lt;tibble [12 × 4]></a>
#> 6 Australia   Oceania   &lt;tibble [12 × 4]></a>
#> # … with 136 more rows</code>

<h3>25.4.2 From vectorised functions</h3>
Some useful functions take an atomic vector and return a list. 
For example, in <a href="strings.html#strings">strings</a> you learned about <code>stringr::str_split()</code> which takes a character vector and returns a list of character vectors. 
If you use that inside mutate, you’ll get a list-column:

<code>df &lt;- tribble(</a>
  ~x1,</a>
  "a,b,c", </a>
  "d,e,f,g"</a>
) </a>
</a>
df %>% </a>
  mutate(x2 = stringr::str_split(x1, ","))</a>
#> # A tibble: 2 x 2</a>
#>   x1      x2       </a>
#>   &lt;chr>   &lt;list>   </a>
#> 1 a,b,c   &lt;chr [3]></a>
#> 2 d,e,f,g &lt;chr [4]></code>

<code>unnest()</code> knows how to handle these lists of vectors:

<code>df %>% </a>
  mutate(x2 = stringr::str_split(x1, ",")) %>% </a>
  unnest()</a>
#> Warning: `cols` is now required.</a>
#> Please use `cols = c(x2)`</a>
#> # A tibble: 7 x 2</a>
#>   x1      x2   </a>
#>   &lt;chr>   &lt;chr></a>
#> 1 a,b,c   a    </a>
#> 2 a,b,c   b    </a>
#> 3 a,b,c   c    </a>
#> 4 d,e,f,g d    </a>
#> 5 d,e,f,g e    </a>
#> 6 d,e,f,g f    </a>
#> # … with 1 more row</code>

(If you find yourself using this pattern a lot, make sure to check out <code>tidyr::separate_rows()</code> which is a wrapper around this common pattern).

Another example of this pattern is using the <code>map()</code>, <code>map2()</code>, <code>pmap()</code> from purrr. 
For example, we could take the final example from <a href="iteration.html#invoking-different-functions">Invoking different functions</a> and rewrite it to use <code>mutate()</code>:

<code>sim &lt;- tribble(</a>
  ~f,      ~params,</a>
  "runif", list(min = -1, max = 1),</a>
  "rnorm", list(sd = 5),</a>
  "rpois", list(lambda = 10)</a>
)</a>
</a>
sim %>%</a>
  mutate(sims = invoke_map(f, params, n = 10))</a>
#> # A tibble: 3 x 3</a>
#>   f     params           sims      </a>
#>   &lt;chr> &lt;list>           &lt;list>    </a>
#> 1 runif &lt;named list [2]> &lt;dbl [10]></a>
#> 2 rnorm &lt;named list [1]> &lt;dbl [10]></a>
#> 3 rpois &lt;named list [1]> &lt;int [10]></code>

Note that technically <code>sim</code> isn’t homogeneous because it contains both double and integer vectors. 
However, this is unlikely to cause many problems since integers and doubles are both numeric vectors.

<h3>25.4.3 From multivalued summaries</h3>
One restriction of <code>summarise()</code> is that it only works with summary functions that return a single value. 
That means that you can’t use it with functions like <code>quantile()</code> that return a vector of arbitrary length:

<code>mtcars %>% </a>
  group_by(cyl) %>% </a>
  summarise(q = quantile(mpg))</a>
#> Error: Column `q` must be length 1 (a summary value), not 5</code>

You can however, wrap the result in a list! This obeys the contract of <code>summarise()</code>, because each summary is now a list (a vector) of length 1.

<code>mtcars %>% </a>
  group_by(cyl) %>% </a>
  summarise(q = list(quantile(mpg)))</a>
#> # A tibble: 3 x 2</a>
#>     cyl q        </a>
#>   &lt;dbl> &lt;list>   </a>
#> 1     4 &lt;dbl [5]></a>
#> 2     6 &lt;dbl [5]></a>
#> 3     8 &lt;dbl [5]></code>

To make useful results with unnest, you’ll also need to capture the probabilities:

<code>probs &lt;- c(0.01, 0.25, 0.5, 0.75, 0.99)</a>
mtcars %>% </a>
  group_by(cyl) %>% </a>
  summarise(p = list(probs), q = list(quantile(mpg, probs))) %>% </a>
  unnest()</a>
#> Warning: `cols` is now required.</a>
#> Please use `cols = c(p, q)`</a>
#> # A tibble: 15 x 3</a>
#>     cyl     p     q</a>
#>   &lt;dbl> &lt;dbl> &lt;dbl></a>
#> 1     4  0.01  21.4</a>
#> 2     4  0.25  22.8</a>
#> 3     4  0.5   26  </a>
#> 4     4  0.75  30.4</a>
#> 5     4  0.99  33.8</a>
#> 6     6  0.01  17.8</a>
#> # … with 9 more rows</code>

<h3>25.4.4 From a named list</h3>
Data frames with list-columns provide a solution to a common problem: what do you do if you want to iterate over both the contents of a list and its elements? Instead of trying to jam everything into one object, it’s often easier to make a data frame: one column can contain the elements, and one column can contain the list. 
An easy way to create such a data frame from a list is <code>tibble::enframe()</code>.

<code>x &lt;- list(</a>
  a = 1:5,</a>
  b = 3:4, </a>
  c = 5:6</a>
) </a>
</a>
df &lt;- enframe(x)</a>
df</a>
#> # A tibble: 3 x 2</a>
#>   name  value    </a>
#>   &lt;chr> &lt;list>   </a>
#> 1 a     &lt;int [5]></a>
#> 2 b     &lt;int [2]></a>
#> 3 c     &lt;int [2]></code>

The advantage of this structure is that it generalises in a straightforward way - names are useful if you have character vector of metadata, but don’t help if you have other types of data, or multiple vectors.

Now if you want to iterate over names and values in parallel, you can use <code>map2()</code>:

<code>df %>% </a>
  mutate(</a>
    smry = map2_chr(name, value, ~ stringr::str_c(.x, ": ", .y[1]))</a>
  )</a>
#> # A tibble: 3 x 3</a>
#>   name  value     smry </a>
#>   &lt;chr> &lt;list>    &lt;chr></a>
#> 1 a     &lt;int [5]> a: 1 </a>
#> 2 b     &lt;int [2]> b: 3 </a>
#> 3 c     &lt;int [2]> c: 5</code>

<h3>25.4.5 Exercises</h3>

List all the functions that you can think of that take a atomic vector and
return a list.

Brainstorm useful summary functions that, like <code>quantile()</code>, return
multiple values.

What’s missing in the following data frame? How does <code>quantile()</code> return
that missing piece? Why isn’t that helpful here?

<code>mtcars %>% </a>
  group_by(cyl) %>% </a>
  summarise(q = list(quantile(mpg))) %>% </a>
  unnest()</a>
#> Warning: `cols` is now required.</a>
#> Please use `cols = c(q)`</a>
#> # A tibble: 15 x 2</a>
#>     cyl     q</a>
#>   &lt;dbl> &lt;dbl></a>
#> 1     4  21.4</a>
#> 2     4  22.8</a>
#> 3     4  26  </a>
#> 4     4  30.4</a>
#> 5     4  33.9</a>
#> 6     6  17.8</a>
#> # … with 9 more rows</code>

What does this code do? Why might might it be useful?

<code>mtcars %>% </a>
  group_by(cyl) %>% </a>
  summarise_each(funs(list))</code>

<h2>25.5 Simplifying list-columns</h2>
To apply the techniques of data manipulation and visualisation you’ve learned in this book, you’ll need to simplify the list-column back to a regular column (an atomic vector), or set of columns. 
The technique you’ll use to collapse back down to a simpler structure depends on whether you want a single value per element, or multiple values:

If you want a single value, use <code>mutate()</code> with <code>map_lgl()</code>,
<code>map_int()</code>, <code>map_dbl()</code>, and <code>map_chr()</code> to create an atomic vector.

If you want many values, use <code>unnest()</code> to convert list-columns back
to regular columns, repeating the rows as many times as necessary.

These are described in more detail below.

<h3>25.5.1 List to vector</h3>
If you can reduce your list column to an atomic vector then it will be a regular column. 
For example, you can always summarise an object with its type and length, so this code will work regardless of what sort of list-column you have:

<code>df &lt;- tribble(</a>
  ~x,</a>
  letters[1:5],</a>
  1:3,</a>
  runif(5)</a>
)</a>
  </a>
df %>% mutate(</a>
  type = map_chr(x, typeof),</a>
  length = map_int(x, length)</a>
)</a>
#> # A tibble: 3 x 3</a>
#>   x         type      length</a>
#>   &lt;list>    &lt;chr>      &lt;int></a>
#> 1 &lt;chr [5]> character      5</a>
#> 2 &lt;int [3]> integer        3</a>
#> 3 &lt;dbl [5]> double         5</code>

This is the same basic information that you get from the default tbl print method, but now you can use it for filtering. 
This is a useful technique if you have a heterogeneous list, and want to filter out the parts aren’t working for you.

Don’t forget about the <code>map_*()</code> shortcuts - you can use <code>map_chr(x, "apple")</code> to extract the string stored in <code>apple</code> for each element of <code>x</code>. 
This is useful for pulling apart nested lists into regular columns. 
Use the <code>.null</code> argument to provide a value to use if the element is missing (instead of returning <code>NULL</code>):

<code>df &lt;- tribble(</a>
  ~x,</a>
  list(a = 1, b = 2),</a>
  list(a = 2, c = 4)</a>
)</a>
df %>% mutate(</a>
  a = map_dbl(x, "a"),</a>
  b = map_dbl(x, "b", .null = NA_real_)</a>
)</a>
#> # A tibble: 2 x 3</a>
#>   x                    a     b</a>
#>   &lt;list>           &lt;dbl> &lt;dbl></a>
#> 1 &lt;named list [2]>     1     2</a>
#> 2 &lt;named list [2]>     2    NA</code>

<h3>25.5.2 Unnesting</h3>
<code>unnest()</code> works by repeating the regular columns once for each element of the list-column. 
For example, in the following very simple example we repeat the first row 4 times (because there the first element of <code>y</code> has length four), and the second row once:

<code>tibble(x = 1:2, y = list(1:4, 1)) %>% unnest(y)</a>
#> # A tibble: 5 x 2</a>
#>       x     y</a>
#>   &lt;int> &lt;dbl></a>
#> 1     1     1</a>
#> 2     1     2</a>
#> 3     1     3</a>
#> 4     1     4</a>
#> 5     2     1</code>

This means that you can’t simultaneously unnest two columns that contain different number of elements:

<code># Ok, because y and z have the same number of elements in</a>
# every row</a>
df1 &lt;- tribble(</a>
  ~x, ~y,           ~z,</a>
   1, c("a", "b"), 1:2,</a>
   2, "c",           3</a>
)</a>
df1</a>
#> # A tibble: 2 x 3</a>
#>       x y         z        </a>
#>   &lt;dbl> &lt;list>    &lt;list>   </a>
#> 1     1 &lt;chr [2]> &lt;int [2]></a>
#> 2     2 &lt;chr [1]> &lt;dbl [1]></a>
df1 %>% unnest(y, z)</a>
#> Warning: unnest() has a new interface. 
See ?unnest for details.</a>
#> Try `df %>% unnest(c(y, z))`, with `mutate()` if needed</a>
#> # A tibble: 3 x 3</a>
#>       x y         z</a>
#>   &lt;dbl> &lt;chr> &lt;dbl></a>
#> 1     1 a         1</a>
#> 2     1 b         2</a>
#> 3     2 c         3</a>
</a>
# Doesn&#39;t work because y and z have different number of elements</a>
df2 &lt;- tribble(</a>
  ~x, ~y,           ~z,</a>
   1, "a",         1:2,  </a>
   2, c("b", "c"),   3</a>
)</a>
df2</a>
#> # A tibble: 2 x 3</a>
#>       x y         z        </a>
#>   &lt;dbl> &lt;list>    &lt;list>   </a>
#> 1     1 &lt;chr [1]> &lt;int [2]></a>
#> 2     2 &lt;chr [2]> &lt;dbl [1]></a>
df2 %>% unnest(y, z)</a>
#> Warning: unnest() has a new interface. 
See ?unnest for details.</a>
#> Try `df %>% unnest(c(y, z))`, with `mutate()` if needed</a>
#> # A tibble: 4 x 3</a>
#>       x y         z</a>
#>   &lt;dbl> &lt;chr> &lt;dbl></a>
#> 1     1 a         1</a>
#> 2     1 a         2</a>
#> 3     2 b         3</a>
#> 4     2 c         3</code>

The same principle applies when unnesting list-columns of data frames. 
You can unnest multiple list-cols as long as all the data frames in each row have the same number of rows.

<h3>25.5.3 Exercises</h3>

Why might the <code>lengths()</code> function be useful for creating atomic
vector columns from list-columns?

List the most common types of vector found in a data frame. 
What makes
lists different?

<h2>25.6 Making tidy data with broom</h2>
The broom package provides three general tools for turning models into tidy data frames:

<code>broom::glance(model)</code> returns a row for each model. 
Each column gives a
model summary: either a measure of model quality, or complexity, or a
combination of the two.

<code>broom::tidy(model)</code> returns a row for each coefficient in the model. 
Each
column gives information about the estimate or its variability.

<code>broom::augment(model, data)</code> returns a row for each row in <code>data</code>, adding
extra values like residuals, and influence statistics.

<h2><span class="orange">26 Introduction</span></h2>
So far, you’ve learned the tools to get your data into R, tidy it into a form convenient for analysis, and then understand your data through transformation, visualisation and modelling. 
However, it doesn’t matter how great your analysis is unless you can explain it to others: you need to communicate your results.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3e0445f7fc16698cc4402445259d84aa411dddc3/9abcb/diagrams/data-science-communicate.png" width="75%" style="display: block; margin: auto;" />

Communication is the theme of the following four chapters:

In <a href="r-markdown.html#r-markdown">R Markdown</a>, you will learn about R Markdown, a tool for integrating
prose, code, and results. 
You can use R Markdown in notebook mode for
analyst-to-analyst communication, and in report mode for
analyst-to-decision-maker communication. 
Thanks to the power of R Markdown
formats, you can even use the same document for both purposes.

In <a href="graphics-for-communication.html#graphics-for-communication">Graphics for communication</a>, you will learn how to take your exploratory
graphics and turn them into expository graphics, graphics that help the
newcomer to your analysis understand what’s going on as quickly and
easily as possible.

In <a href="r-markdown-formats.html#r-markdown-formats">R Markdown formats</a>, you’ll learn a little about the many other varieties
of outputs you can produce using R Markdown, including dashboards, websites,
and books.

We’ll finish up with <a href="r-markdown-workflow.html#r-markdown-workflow">R Markdown workflow</a>, where you’ll learn about the
'analysis notebook' and how to systematically record your successes and
failures so that you can learn from them.

Unfortunately, these chapters focus mostly on the technical mechanics of communication, not the really hard problems of communicating your thoughts to other humans. 
However, there are lot of other great books about communication, which we’ll point you to at the end of each chapter.

<h2><span class="orange">27 R Markdown</span></h2>

<h2>27.1 Introduction</h2>
R Markdown provides an unified authoring framework for data science, combining your code, its results, and your prose commentary. 
R Markdown documents are fully reproducible and support dozens of output formats, like PDFs, Word files, slideshows, and more.

R Markdown files are designed to be used in three ways:

For communicating to decision makers, who want to focus on the conclusions,
not the code behind the analysis.

For collaborating with other data scientists (including future you!), who
are interested in both your conclusions, and how you reached them (
i.e. the code).

As an environment in which to <em>do</em> data science, as a modern day lab
notebook where you can capture not only what you did, but also what you
were thinking.

R Markdown integrates a number of R packages and external tools. 
This means that help is, by-and-large, not available through <code>?</code>. 
Instead, as you work through this chapter, and use R Markdown in the future, keep these resources close to hand:

R Markdown Cheat Sheet: <em>Help > Cheatsheets > R Markdown Cheat Sheet</em>,

R Markdown Reference Guide: <em>Help > Cheatsheets > R Markdown Reference
Guide</em>.

Both cheatsheets are also available at <a href="http://rstudio.com/cheatsheets" class="uri">http://rstudio.com/cheatsheets</a>.

<h3>27.1.1 Prerequisites</h3>
You need the rmarkdown package, but you don’t need to explicitly install it or load it, as RStudio automatically does both when needed.

<h2>27.2 R Markdown basics</h2>
This is an R Markdown file, a plain text file that has the extension <code>.Rmd</code>:

<code>---
title: "Diamond sizes"
date: 2016-08-25
output: html_document
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)

smaller &lt;- diamonds %>% 
  filter(carat &lt;= 2.5)
```

We have data about `r nrow(diamonds)` diamonds. 
Only 
`r nrow(diamonds) - nrow(smaller)` are larger than
2.5 carats. 
The distribution of the remainder is shown
below:

```{r, echo = FALSE}
smaller %>% 
  ggplot(aes(carat)) + 
  geom_freqpoly(binwidth = 0.01)
```</code>

It contains three important types of content:

An (optional) YAML header surrounded by <code>---</code>s.

Chunks of R code surrounded by <code>```</code>.

Text mixed with simple text formatting like <code># heading</code> and <code>_italics_</code>.

When you open an <code>.Rmd</code>, you get a notebook interface where code and output are interleaved. 
You can run each code chunk by clicking the Run icon (it looks like a play button at the top of the chunk), or by pressing Cmd/Ctrl + Shift + Enter. 
RStudio executes the code and displays the results inline with the code:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/853becd7fc7d20e3a63f52b23f522d6f0d06e066/88250/rmarkdown/diamond-sizes-notebook.png" width="75%" style="display: block; margin: auto;" />

To produce a complete report containing all text, code, and results, click 'Knit' or press Cmd/Ctrl + Shift + K. 
You can also do this programmatically with <code>rmarkdown::render("1-example.Rmd")</code>. 
This will display the report in the viewer pane, and create a self-contained HTML file that you can share with others.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bd9201291793647e2187bf21af706afac255b2aa/28e87/rmarkdown/diamond-sizes-report.png" width="75%" style="display: block; margin: auto;" />

When you knit the document, R Markdown sends the .Rmd file to knitr, <a href="http://yihui.name/knitr/" class="uri">http://yihui.name/knitr/</a>, which executes all of the code chunks and creates a new markdown (.md) document which includes the code and its output. 
The markdown file generated by knitr is then processed by pandoc, <a href="http://pandoc.org/" class="uri">http://pandoc.org/</a>, which is responsible for creating the finished file. 
The advantage of this two step workflow is that you can create a very wide range of output formats, as you’ll learn about in <a href="r-markdown-formats.html#r-markdown-formats">R markdown formats</a>.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/61d189fd9cdf955058415d3e1b28dd60e1bd7c9b/9791d/images/rmarkdownflow.png" width="75%" style="display: block; margin: auto;" />

To get started with your own <code>.Rmd</code> file, select <em>File > New File > R Markdown…</em> in the menubar. 
RStudio will launch a wizard that you can use to pre-populate your file with useful content that reminds you how the key features of R Markdown work.

The following sections dive into the three components of an R Markdown document in more details: the markdown text, the code chunks, and the YAML header.

<h3>27.2.1 Exercises</h3>

Create a new notebook using <em>File > New File > R Notebook</em>. 
Read the
instructions. 
Practice running the chunks. 
Verify that you can modify
the code, re-run it, and see modified output.

Create a new R Markdown document with <em>File > New File > R Markdown…</em>
Knit it by clicking the appropriate button. 
Knit it by using the
appropriate keyboard short cut. 
Verify that you can modify the
input and see the output update.

Compare and contrast the R notebook and R markdown files you created
above. 
How are the outputs similar? How are they different? How are
the inputs similar? How are they different? What happens if you
copy the YAML header from one to the other?

Create one new R Markdown document for each of the three built-in
formats: HTML, PDF and Word. 
Knit each of the three documents.
How does the output differ? How does the input differ? (You may need
to install LaTeX in order to build the PDF output — RStudio will
prompt you if this is necessary.)

<h2>27.3 Text formatting with Markdown</h2>
Prose in <code>.Rmd</code> files is written in Markdown, a lightweight set of conventions for formatting plain text files. 
Markdown is designed to be easy to read and easy to write. 
It is also very easy to learn. 
The guide below shows how to use Pandoc’s Markdown, a slightly extended version of Markdown that R Markdown understands.

<code>Text formatting 
------------------------------------------------------------

*italic*  or _italic_
**bold**   __bold__
`code`
superscript^2^ and subscript~2~

Headings
------------------------------------------------------------

# 1st Level Header

## 2nd Level Header

### 3rd Level Header

Lists
------------------------------------------------------------

*   Bulleted list item 1

*   Item 2

    * Item 2a

    * Item 2b

1. 
 Numbered list item 1

1. 
 Item 2. 
The numbers are incremented automatically in the output.

Links and images
------------------------------------------------------------

&lt;http://example.com>

[linked phrase](http://example.com)

![optional caption text](path/to/img.png)

Tables 
------------------------------------------------------------

First Header  | Second Header
------------- | -------------
Content Cell  | Content Cell
Content Cell  | Content Cell</code>

The best way to learn these is simply to try them out. 
It will take a few days, but soon they will become second nature, and you won’t need to think about them. 
If you forget, you can get to a handy reference sheet with <em>Help > Markdown Quick Reference</em>.

<h3>27.3.1 Exercises</h3>

Practice what you’ve learned by creating a brief CV. 
The title should be
your name, and you should include headings for (at least) education or
employment. 
Each of the sections should include a bulleted list of
jobs/degrees. 
Highlight the year in bold.

Using the R Markdown quick reference, figure out how to:

Add a footnote.

Add a horizontal rule.

Add a block quote.

Copy and paste the contents of <code>diamond-sizes.Rmd</code> from
<a href="https://github.com/hadley/r4ds/tree/master/rmarkdown" class="uri">https://github.com/hadley/r4ds/tree/master/rmarkdown</a> in to a local
R markdown document. 
Check that you can run it, then add text after the
frequency polygon that describes its most striking features.

<h2>27.4 Code chunks</h2>
To run code inside an R Markdown document, you need to insert a chunk. 
There are three ways to do so:

The keyboard shortcut Cmd/Ctrl + Alt + I

The 'Insert' button icon in the editor toolbar.

By manually typing the chunk delimiters <code>```{r}</code> and <code>```</code>.

Obviously, I’d recommend you learn the keyboard shortcut. 
It will save you a lot of time in the long run!

You can continue to run the code using the keyboard shortcut that by now (I hope!) you know and love: Cmd/Ctrl + Enter. 
However, chunks get a new keyboard shortcut: Cmd/Ctrl + Shift + Enter, which runs all the code in the chunk. 
Think of a chunk like a function. 
A chunk should be relatively self-contained, and focussed around a single task.

The following sections describe the chunk header which consists of <code>```{r</code>, followed by an optional chunk name, followed by comma separated options, followed by <code>}</code>. 
Next comes your R code and the chunk end is indicated by a final <code>```</code>.

<h3>27.4.1 Chunk name</h3>
Chunks can be given an optional name: <code>```{r by-name}</code>. 
This has three advantages:

You can more easily navigate to specific chunks using the drop-down
code navigator in the bottom-left of the script editor:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6fcddff214345601f998805adce94ab0e21d8615/2a098/screenshots/rmarkdown-chunk-nav.png" width="30%" style="display: block; margin: auto;" />

Graphics produced by the chunks will have useful names that make
them easier to use elsewhere. 
More on that in <a href="graphics-for-communication.html#other-important-options">other important options</a>.

You can set up networks of cached chunks to avoid re-performing expensive
computations on every run. 
More on that below.

There is one chunk name that imbues special behaviour: <code>setup</code>. 
When you’re in a notebook mode, the chunk named setup will be run automatically once, before any other code is run.

<h3>27.4.2 Chunk options</h3>
Chunk output can be customised with options, arguments supplied to chunk header. 
Knitr provides almost 60 options that you can use to customize your code chunks. 
Here we’ll cover the most important chunk options that you’ll use frequently. 
You can see the full list at <a href="http://yihui.name/knitr/options/" class="uri">http://yihui.name/knitr/options/</a>.

The most important set of options controls if your code block is executed and what results are inserted in the finished report:

<code>eval = FALSE</code> prevents code from being evaluated. 
(And obviously if the
code is not run, no results will be generated). 
This is useful for
displaying example code, or for disabling a large block of code without
commenting each line.

<code>include = FALSE</code> runs the code, but doesn’t show the code or results
in the final document. 
Use this for setup code that you don’t want
cluttering your report.

<code>echo = FALSE</code> prevents code, but not the results from appearing in the
finished file. 
Use this when writing reports aimed at people who don’t
want to see the underlying R code.

<code>message = FALSE</code> or <code>warning = FALSE</code> prevents messages or warnings
from appearing in the finished file.

<code>results = 'hide'</code> hides printed output; <code>fig.show = 'hide'</code> hides
plots.

<code>error = TRUE</code> causes the render to continue even if code returns an error.
This is rarely something you’ll want to include in the final version
of your report, but can be very useful if you need to debug exactly
what is going on inside your <code>.Rmd</code>. 
It’s also useful if you’re teaching R
and want to deliberately include an error. 
The default, <code>error = FALSE</code> causes
knitting to fail if there is a single error in the document.

The following table summarises which types of output each option supressess:

<table>
<thead>
<tr class="header">
<th>Option</th>
<th>Run code</th>
<th>Show code</th>
<th>Output</th>
<th>Plots</th>
<th>Messages</th>
<th>Warnings</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>eval = FALSE</code></td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="even">
<td><code>include = FALSE</code></td>
<td></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr class="odd">
<td><code>echo = FALSE</code></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>results = "hide"</code></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><code>fig.show = "hide"</code></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>message = FALSE</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
<td></td>
</tr>
<tr class="odd">
<td><code>warning = FALSE</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>

<h3>27.4.3 Table</h3>
By default, R Markdown prints data frames and matrices as you’d see them in the console:

<code>mtcars[1:5, ]</a>
#>                    mpg cyl disp  hp drat   wt qsec vs am gear carb</a>
#> Mazda RX4         21.0   6  160 110 3.90 2.62 16.5  0  1    4    4</a>
#> Mazda RX4 Wag     21.0   6  160 110 3.90 2.88 17.0  0  1    4    4</a>
#> Datsun 710        22.8   4  108  93 3.85 2.32 18.6  1  1    4    1</a>
#> Hornet 4 Drive    21.4   6  258 110 3.08 3.21 19.4  1  0    3    1</a>
#> Hornet Sportabout 18.7   8  360 175 3.15 3.44 17.0  0  0    3    2</code>

If you prefer that data be displayed with additional formatting you can use the <code>knitr::kable</code> function. 
The code below generates Table <a href="r-markdown.html#tab:kable">27.1</a>.

<code>knitr::kable(</a>
  mtcars[1:5, ], </a>
  caption = "A knitr kable."</a>
)</code>

<table>
<caption>Table 27.1: A knitr kable.</caption>
<thead>
<tr class="header">
<th></th>
<th align="right">mpg</th>
<th align="right">cyl</th>
<th align="right">disp</th>
<th align="right">hp</th>
<th align="right">drat</th>
<th align="right">wt</th>
<th align="right">qsec</th>
<th align="right">vs</th>
<th align="right">am</th>
<th align="right">gear</th>
<th align="right">carb</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Mazda RX4</td>
<td align="right">21.0</td>
<td align="right">6</td>
<td align="right">160</td>
<td align="right">110</td>
<td align="right">3.90</td>
<td align="right">2.62</td>
<td align="right">16.5</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td>Mazda RX4 Wag</td>
<td align="right">21.0</td>
<td align="right">6</td>
<td align="right">160</td>
<td align="right">110</td>
<td align="right">3.90</td>
<td align="right">2.88</td>
<td align="right">17.0</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td>Datsun 710</td>
<td align="right">22.8</td>
<td align="right">4</td>
<td align="right">108</td>
<td align="right">93</td>
<td align="right">3.85</td>
<td align="right">2.32</td>
<td align="right">18.6</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>Hornet 4 Drive</td>
<td align="right">21.4</td>
<td align="right">6</td>
<td align="right">258</td>
<td align="right">110</td>
<td align="right">3.08</td>
<td align="right">3.21</td>
<td align="right">19.4</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td>Hornet Sportabout</td>
<td align="right">18.7</td>
<td align="right">8</td>
<td align="right">360</td>
<td align="right">175</td>
<td align="right">3.15</td>
<td align="right">3.44</td>
<td align="right">17.0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
Read the documentation for <code>?knitr::kable</code> to see the other ways in which you can customise the table. 
For even deeper customisation, consider the xtable, stargazer, pander, tables, and ascii packages. 
Each provides a set of tools for returning formatted tables from R code.

There is also a rich set of options for controlling how figures are embedded. 
You’ll learn about these in <a href="graphics-for-communication.html#saving-your-plots">saving your plots</a>.

<h3>27.4.4 Caching</h3>
Normally, each knit of a document starts from a completely clean slate. 
This is great for reproducibility, because it ensures that you’ve captured every important computation in code. 
However, it can be painful if you have some computations that take a long time. 
The solution is <code>cache = TRUE</code>. 
When set, this will save the output of the chunk to a specially named file on disk. 
On subsequent runs, knitr will check to see if the code has changed, and if it hasn’t, it will reuse the cached results.

The caching system must be used with care, because by default it is based on the code only, not its dependencies. 
For example, here the <code>processed_data</code> chunk depends on the <code>raw_data</code> chunk:

<code>```{r raw_data}
rawdata &lt;- readr::read_csv("a_very_large_file.csv")
```

```{r processed_data, cache = TRUE}
processed_data &lt;- rawdata %>% 
  filter(!is.na(import_var)) %>% 
  mutate(new_variable = complicated_transformation(x, y, z))
```</code>

Caching the <code>processed_data</code> chunk means that it will get re-run if the dplyr pipeline is changed, but it won’t get rerun if the <code>read_csv()</code> call changes. 
You can avoid that problem with the <code>dependson</code> chunk option:

<code>```{r processed_data, cache = TRUE, dependson = "raw_data"}
processed_data &lt;- rawdata %>% 
  filter(!is.na(import_var)) %>% 
  mutate(new_variable = complicated_transformation(x, y, z))
```</code>

<code>dependson</code> should contain a character vector of <em>every</em> chunk that the cached chunk depends on. 
Knitr will update the results for the cached chunk whenever it detects that one of its dependencies have changed.

Note that the chunks won’t update if <code>a_very_large_file.csv</code> changes, because knitr caching only tracks changes within the <code>.Rmd</code> file. 
If you want to also track changes to that file you can use the <code>cache.extra</code> option. 
This is an arbitrary R expression that will invalidate the cache whenever it changes. 
A good function to use is <code>file.info()</code>: it returns a bunch of information about the file including when it was last modified. 
Then you can write:

<code>```{r raw_data, cache.extra = file.info("a_very_large_file.csv")}
rawdata &lt;- readr::read_csv("a_very_large_file.csv")
```</code>

As your caching strategies get progressively more complicated, it’s a good idea to regularly clear out all your caches with <code>knitr::clean_cache()</code>.

I’ve used the advice of <a href="https://twitter.com/drob/status/738786604731490304">David Robinson</a> to name these chunks: each chunk is named after the primary object that it creates. 
This makes it easier to understand the <code>dependson</code> specification.

<h3>27.4.5 Global options</h3>
As you work more with knitr, you will discover that some of the default chunk options don’t fit your needs and you want to change them. 
You can do this by calling <code>knitr::opts_chunk$set()</code> in a code chunk. 
For example, when writing books and tutorials I set:

<code>knitr::opts_chunk$set(</a>
  comment = "#>",</a>
  collapse = TRUE</a>
)</code>

This uses my preferred comment formatting, and ensures that the code and output are kept closely entwined. 
On the other hand, if you were preparing a report, you might set:

<code>knitr::opts_chunk$set(</a>
  echo = FALSE</a>
)</code>

That will hide the code by default, so only showing the chunks you deliberately choose to show (with <code>echo = TRUE</code>). 
You might consider setting <code>message = FALSE</code> and <code>warning = FALSE</code>, but that would make it harder to debug problems because you wouldn’t see any messages in the final document.

<h3>27.4.6 Inline code</h3>
There is one other way to embed R code into an R Markdown document: directly into the text, with: <code>`r `</code>. 
This can be very useful if you mention properties of your data in the text. 
For example, in the example document I used at the start of the chapter I had:

<blockquote>
We have data about <code>`r nrow(diamonds)`</code> diamonds.
Only <code>`r nrow(diamonds) - nrow(smaller)`</code> are larger
than 2.5 carats. 
The distribution of the remainder is shown below:

</blockquote>
When the report is knit, the results of these computations are inserted into the text:

<blockquote>
We have data about 53940 diamonds. 
Only 126 are larger than
2.5 carats. 
The distribution of the remainder is shown below:

</blockquote>
When inserting numbers into text, <code>format()</code> is your friend. 
It allows you to set the number of <code>digits</code> so you don’t print to a ridiculous degree of accuracy, and a <code>big.mark</code> to make numbers easier to read. 
I’ll often combine these into a helper function:

<code>comma &lt;- function(x) format(x, digits = 2, big.mark = ",")</a>
comma(3452345)</a>
#> [1] "3,452,345"</a>
comma(.12358124331)</a>
#> [1] "0.12"</code>

<h3>27.4.7 Exercises</h3>

Add a section that explores how diamond sizes vary by cut, colour,
and clarity. 
Assume you’re writing a report for someone who doesn’t know
R, and instead of setting <code>echo = FALSE</code> on each chunk, set a global
option.

Download <code>diamond-sizes.Rmd</code> from
<a href="https://github.com/hadley/r4ds/tree/master/rmarkdown" class="uri">https://github.com/hadley/r4ds/tree/master/rmarkdown</a>. 
Add a section
that describes the largest 20 diamonds, including a table that displays
their most important attributes.

Modify <code>diamonds-sizes.Rmd</code> to use <code>comma()</code> to produce nicely
formatted output. 
Also include the percentage of diamonds that are
larger than 2.5 carats.

Set up a network of chunks where <code>d</code> depends on <code>c</code> and <code>b</code>, and
both <code>b</code> and <code>c</code> depend on <code>a</code>. 
Have each chunk print <code>lubridate::now()</code>,
set <code>cache = TRUE</code>, then verify your understanding of caching.

<h2>27.5 Troubleshooting</h2>
Troubleshooting R Markdown documents can be challenging because you are no longer in an interactive R environment, and you will need to learn some new tricks. 
The first thing you should always try is to recreate the problem in an interactive session. 
Restart R, then 'Run all chunks' (either from Code menu, under Run region), or with the keyboard shortcut Ctrl + Alt + R. 
If you’re lucky, that will recreate the problem, and you can figure out what’s going on interactively.

If that doesn’t help, there must be something different between your interactive environment and the R markdown environment. 
You’re going to need to systematically explore the options. 
The most common difference is the working directory: the working directory of an R Markdown is the directory in which it lives. 
Check the working directory is what you expect by including <code>getwd()</code> in a chunk.

Next, brainstorm all the things that might cause the bug. 
You’ll need to systematically check that they’re the same in your R session and your R markdown session. 
The easiest way to do that is to set <code>error = TRUE</code> on the chunk causing the problem, then use <code>print()</code> and <code>str()</code> to check that settings are as you expect.

<h2>27.6 YAML header</h2>
You can control many other 'whole document' settings by tweaking the parameters of the YAML header. 
You might wonder what YAML stands for: it’s 'yet another markup language', which is designed for representing hierarchical data in a way that’s easy for humans to read and write. 
R Markdown uses it to control many details of the output. 
Here we’ll discuss two: document parameters and bibliographies.

<h3>27.6.1 Parameters</h3>
R Markdown documents can include one or more parameters whose values can be set when you render the report. 
Parameters are useful when you want to re-render the same report with distinct values for various key inputs. 
For example, you might be producing sales reports per branch, exam results by student, or demographic summaries by country. 
To declare one or more parameters, use the <code>params</code> field.

This example uses a <code>my_class</code> parameter to determine which class of cars to display:

<code>---
output: html_document
params:
  my_class: "suv"
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)

class &lt;- mpg %>% filter(class == params$my_class)
```

# Fuel economy for `r params$my_class`s

```{r, message = FALSE}
ggplot(class, aes(displ, hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```</code>

As you can see, parameters are available within the code chunks as a read-only list named <code>params</code>.

You can write atomic vectors directly into the YAML header. 
You can also run arbitrary R expressions by prefacing the parameter value with <code>!r</code>. 
This is a good way to specify date/time parameters.

<code>params:</a>
  start: !r lubridate::ymd("2015-01-01")</a>
  snapshot: !r lubridate::ymd_hms("2015-01-01 12:30:00")</code>

In RStudio, you can click the 'Knit with Parameters' option in the Knit dropdown menu to set parameters, render, and preview the report in a single user friendly step. 
You can customise the dialog by setting other options in the header. 
See <a href="http://rmarkdown.rstudio.com/developer_parameterized_reports.html#parameter_user_interfaces" class="uri">http://rmarkdown.rstudio.com/developer_parameterized_reports.html#parameter_user_interfaces</a> for more details.

Alternatively, if you need to produce many such paramterised reports, you can call <code>rmarkdown::render()</code> with a list of <code>params</code>:

<code>rmarkdown::render("fuel-economy.Rmd", params = list(my_class = "suv"))</code>

This is particularly powerful in conjunction with <code>purrr:pwalk()</code>. 
The following example creates a report for each value of <code>class</code> found in <code>mpg</code>. 
First we create a data frame that has one row for each class, giving the <code>filename</code> of the report and the <code>params</code>:

<code>reports &lt;- tibble(</a>
  class = unique(mpg$class),</a>
  filename = stringr::str_c("fuel-economy-", class, ".html"),</a>
  params = purrr::map(class, ~ list(my_class = .))</a>
)</a>
reports</a>
#> # A tibble: 7 x 3</a>
#>   class   filename                  params          </a>
#>   &lt;chr>   &lt;chr>                     &lt;list>          </a>
#> 1 compact fuel-economy-compact.html &lt;named list [1]></a>
#> 2 midsize fuel-economy-midsize.html &lt;named list [1]></a>
#> 3 suv     fuel-economy-suv.html     &lt;named list [1]></a>
#> 4 2seater fuel-economy-2seater.html &lt;named list [1]></a>
#> 5 minivan fuel-economy-minivan.html &lt;named list [1]></a>
#> 6 pickup  fuel-economy-pickup.html  &lt;named list [1]></a>
#> # … with 1 more row</code>

Then we match the column names to the argument names of <code>render()</code>, and use purrr’s parallel walk to call <code>render()</code> once for each row:

<code>reports %>% </a>
  select(output_file = filename, params) %>% </a>
  purrr::pwalk(rmarkdown::render, input = "fuel-economy.Rmd")</code>

<h3>27.6.2 Bibliographies and Citations</h3>
Pandoc can automatically generate citations and a bibliography in a number of styles. 
To use this feature, specify a bibliography file using the <code>bibliography</code> field in your file’s header. 
The field should contain a path from the directory that contains your .Rmd file to the file that contains the bibliography file:

<code>bibliography: rmarkdown.bib</code>

You can use many common bibliography formats including BibLaTeX, BibTeX, endnote, medline.

To create a citation within your .Rmd file, use a key composed of ‘@’ + the citation identifier from the bibliography file. 
Then place the citation in square brackets. 
Here are some examples:

<code>Separate multiple citations with a `;`: Blah blah [@smith04; @doe99].</a>
</a>
You can add arbitrary comments inside the square brackets: </a>
Blah blah [see @doe99, pp. 
33-35; also @smith04, ch. 
1].</a>
</a>
Remove the square brackets to create an in-text citation: @smith04 </a>
says blah, or @smith04 [p. 
33] says blah.</a>
</a>
Add a `-` before the citation to suppress the author&#39;s name: </a>
Smith says blah [-@smith04].</code>

When R Markdown renders your file, it will build and append a bibliography to the end of your document. 
The bibliography will contain each of the cited references from your bibliography file, but it will not contain a section heading. 
As a result it is common practice to end your file with a section header for the bibliography, such as <code># References</code> or <code># Bibliography</code>.

You can change the style of your citations and bibliography by referencing a CSL (citation style language) file in the <code>csl</code> field:

<code>bibliography: rmarkdown.bib</a>
csl: apa.csl</code>

As with the bibliography field, your csl file should contain a path to the file. 
Here I assume that the csl file is in the same directory as the .Rmd file. 
A good place to find CSL style files for common bibliography styles is <a href="http://github.com/citation-style-language/styles" class="uri">http://github.com/citation-style-language/styles</a>.

<h2>27.7 Learning more</h2>
R Markdown is still relatively young, and is still growing rapidly. 
The best place to stay on top of innovations is the official R Markdown website: <a href="http://rmarkdown.rstudio.com" class="uri">http://rmarkdown.rstudio.com</a>.

There are two important topics that we haven’t covered here: collaboration, and the details of accurately communicating your ideas to other humans. 
Collaboration is a vital part of modern data science, and you can make your life much easier by using version control tools, like Git and GitHub. 
We recommend two free resources that will teach you about Git:

'Happy Git with R': a user friendly introduction to Git and GitHub from
R users, by Jenny Bryan. 
The book is freely available online:
<a href="http://happygitwithr.com" class="uri">http://happygitwithr.com</a>

The 'Git and GitHub' chapter of <em>R Packages</em>, by Hadley. 
You can also
read it for free online: <a href="http://r-pkgs.had.co.nz/git.html" class="uri">http://r-pkgs.had.co.nz/git.html</a>.

I have also not touched on what you should actually write in order to clearly communicate the results of your analysis. 
To improve your writing, I highly recommend reading either <a href="https://amzn.com/0134080416"><em>Style: Lessons in Clarity and Grace</em></a> by Joseph M. 
Williams &amp; Joseph Bizup, or <a href="https://amzn.com/0205296327"><em>The Sense of Structure: Writing from the Reader’s Perspective</em></a> by George Gopen. 
Both books will help you understand the structure of sentences and paragraphs, and give you the tools to make your writing more clear. 
(These books are rather expensive if purchased new, but they’re used by many English classes so there are plenty of cheap second-hand copies). 
George Gopen also has a number of short articles on writing at <a href="https://www.georgegopen.com/the-litigation-articles.html" class="uri">https://www.georgegopen.com/the-litigation-articles.html</a>. 
They are aimed at lawyers, but almost everything applies to data scientists too.

<h2><span class="orange">28 Graphics for communication</span></h2>

<h2>28.1 Introduction</h2>
In <a href="exploratory-data-analysis.html#exploratory-data-analysis">exploratory data analysis</a>, you learned how to use plots as tools for <em>exploration</em>. 
When you make exploratory plots, you know—even before looking—which variables the plot will display. 
You made each plot for a purpose, could quickly look at it, and then move on to the next plot. 
In the course of most analyses, you’ll produce tens or hundreds of plots, most of which are immediately thrown away.

Now that you understand your data, you need to <em>communicate</em> your understanding to others. 
Your audience will likely not share your background knowledge and will not be deeply invested in the data. 
To help others quickly build up a good mental model of the data, you will need to invest considerable effort in making your plots as self-explanatory as possible. 
In this chapter, you’ll learn some of the tools that ggplot2 provides to do so.

This chapter focuses on the tools you need to create good graphics. 
I assume that you know what you want, and just need to know how to do it. 
For that reason, I highly recommend pairing this chapter with a good general visualisation book. 
I particularly like <a href="https://amzn.com/0321934075"><em>The Truthful Art</em></a>, by Albert Cairo. 
It doesn’t teach the mechanics of creating visualisations, but instead focuses on what you need to think about in order to create effective graphics.

<h3>28.1.1 Prerequisites</h3>
In this chapter, we’ll focus once again on ggplot2. 
We’ll also use a little dplyr for data manipulation, and a few ggplot2 extension packages, including ggrepel and viridis. 
Rather than loading those extensions here, we’ll refer to their functions explicitly, using the <code>::</code> notation. 
This will help make it clear which functions are built into ggplot2, and which come from other packages. 
Don’t forget you’ll need to install those packages with <code>install.packages()</code> if you don’t already have them.

<code>library(tidyverse)</code>

<h2>28.2 Label</h2>
The easiest place to start when turning an exploratory graphic into an expository graphic is with good labels. 
You add labels with the <code>labs()</code> function. 
This example adds a plot title:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = class)) +</a>
  geom_smooth(se = FALSE) +</a>
  labs(title = "Fuel efficiency generally decreases with engine size")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bec977635bf6fb8316d7b52b3e1c45ec8bf8fcdf/0f0d2/communicate-plots_files/figure-html/unnamed-chunk-2-1.png" width="70%" style="display: block; margin: auto;" />

The purpose of a plot title is to summarise the main finding. 
Avoid titles that just describe what the plot is, e.g. 
'A scatterplot of engine displacement vs. fuel economy'.

If you need to add more text, there are two other useful labels that you can use in ggplot2 2.2.0 and above (which should be available by the time you’re reading this book):

<code>subtitle</code> adds additional detail in a smaller font beneath the title.

<code>caption</code> adds text at the bottom right of the plot, often used to describe
the source of the data.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = class)) +</a>
  geom_smooth(se = FALSE) +</a>
  labs(</a>
    title = "Fuel efficiency generally decreases with engine size",</a>
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",</a>
    caption = "Data from fueleconomy.gov"</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/abc86387ed5c48bbbd07d2f21de76dd6b7777961/49835/communicate-plots_files/figure-html/unnamed-chunk-3-1.png" width="70%" style="display: block; margin: auto;" />

You can also use <code>labs()</code> to replace the axis and legend titles. 
It’s usually a good idea to replace short variable names with more detailed descriptions, and to include the units.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  geom_smooth(se = FALSE) +</a>
  labs(</a>
    x = "Engine displacement (L)",</a>
    y = "Highway fuel economy (mpg)",</a>
    colour = "Car type"</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4e9a8fa579a16c8544c694b86a744d1aad7b569b/1b6fe/communicate-plots_files/figure-html/unnamed-chunk-4-1.png" width="70%" style="display: block; margin: auto;" />

It’s possible to use mathematical equations instead of text strings. 
Just switch <code>"</code> out for <code>quote()</code> and read about the available options in <code>?plotmath</code>:

<code>df &lt;- tibble(</a>
  x = runif(10),</a>
  y = runif(10)</a>
)</a>
ggplot(df, aes(x, y)) +</a>
  geom_point() +</a>
  labs(</a>
    x = quote(sum(x[i] ^ 2, i == 1, n)),</a>
    y = quote(alpha + beta + frac(delta, theta))</a>
  )</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/14ce276459099f53b15d7e056a63b1cbb1af2c7b/5bfc7/communicate-plots_files/figure-html/unnamed-chunk-5-1.png" width="50%" style="display: block; margin: auto;" />

<h3>28.2.1 Exercises</h3>

Create one plot on the fuel economy data with customised <code>title</code>,
<code>subtitle</code>, <code>caption</code>, <code>x</code>, <code>y</code>, and <code>colour</code> labels.

The <code>geom_smooth()</code> is somewhat misleading because the <code>hwy</code> for
large engines is skewed upwards due to the inclusion of lightweight
sports cars with big engines. 
Use your modelling tools to fit and display
a better model.

Take an exploratory graphic that you’ve created in the last month, and add
informative titles to make it easier for others to understand.

<h2>28.3 Annotations</h2>
In addition to labelling major components of your plot, it’s often useful to label individual observations or groups of observations. 
The first tool you have at your disposal is <code>geom_text()</code>. 
<code>geom_text()</code> is similar to <code>geom_point()</code>, but it has an additional aesthetic: <code>label</code>. 
This makes it possible to add textual labels to your plots.

There are two possible sources of labels. 
First, you might have a tibble that provides labels. 
The plot below isn’t terribly useful, but it illustrates a useful approach: pull out the most efficient car in each class with dplyr, and then label it on the plot:

<code>best_in_class &lt;- mpg %>%</a>
  group_by(class) %>%</a>
  filter(row_number(desc(hwy)) == 1)</a>
</a>
ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  geom_text(aes(label = model), data = best_in_class)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/c1120319d4e4f3685be52d5c2bdafb69de10a580/e8deb/communicate-plots_files/figure-html/unnamed-chunk-6-1.png" width="70%" style="display: block; margin: auto;" />

This is hard to read because the labels overlap with each other, and with the points. 
We can make things a little better by switching to <code>geom_label()</code> which draws a rectangle behind the text. 
We also use the <code>nudge_y</code> parameter to move the labels slightly above the corresponding points:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  geom_label(aes(label = model), data = best_in_class, nudge_y = 2, alpha = 0.5)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/44ba87b7456f4192f02410ce32e58f7c8d57a602/5c6a2/communicate-plots_files/figure-html/unnamed-chunk-7-1.png" width="70%" style="display: block; margin: auto;" />

That helps a bit, but if you look closely in the top-left hand corner, you’ll notice that there are two labels practically on top of each other. 
This happens because the highway mileage and displacement for the best cars in the compact and subcompact categories are exactly the same. 
There’s no way that we can fix these by applying the same transformation for every label. 
Instead, we can use the ggrepel package by Kamil Slowikowski. 
This useful package will automatically adjust labels so that they don’t overlap:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  geom_point(size = 3, shape = 1, data = best_in_class) +</a>
  ggrepel::geom_label_repel(aes(label = model), data = best_in_class)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6afc3b95b2ea24d3fc542cceb7e9d8fa102d4c28/7e476/communicate-plots_files/figure-html/unnamed-chunk-8-1.png" width="70%" style="display: block; margin: auto;" />

Note another handy technique used here: I added a second layer of large, hollow points to highlight the points that I’ve labelled.

You can sometimes use the same idea to replace the legend with labels placed directly on the plot. 
It’s not wonderful for this plot, but it isn’t too bad. 
(<code>theme(legend.position = "none"</code>) turns the legend off — we’ll talk about it more shortly.)

<code>class_avg &lt;- mpg %>%</a>
  group_by(class) %>%</a>
  summarise(</a>
    displ = median(displ),</a>
    hwy = median(hwy)</a>
  )</a>
</a>
ggplot(mpg, aes(displ, hwy, colour = class)) +</a>
  ggrepel::geom_label_repel(aes(label = class),</a>
    data = class_avg,</a>
    size = 6,</a>
    label.size = 0,</a>
    segment.color = NA</a>
  ) +</a>
  geom_point() +</a>
  theme(legend.position = "none")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/56d4cebeb02f092326f179b23362c85a29de587a/d3a83/communicate-plots_files/figure-html/unnamed-chunk-9-1.png" width="70%" style="display: block; margin: auto;" />

Alternatively, you might just want to add a single label to the plot, but you’ll still need to create a data frame. 
Often, you want the label in the corner of the plot, so it’s convenient to create a new data frame using <code>summarise()</code> to compute the maximum values of x and y.

<code>label &lt;- mpg %>%</a>
  summarise(</a>
    displ = max(displ),</a>
    hwy = max(hwy),</a>
    label = "Increasing engine size is \nrelated to decreasing fuel economy."</a>
  )</a>
</a>
ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point() +</a>
  geom_text(aes(label = label), data = label, vjust = "top", hjust = "right")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4c2bfe9f6ea7692266cc7a518a07c5d43da0dd6c/2b8e4/communicate-plots_files/figure-html/unnamed-chunk-10-1.png" width="70%" style="display: block; margin: auto;" />

If you want to place the text exactly on the borders of the plot, you can use <code>+Inf</code> and <code>-Inf</code>. 
Since we’re no longer computing the positions from <code>mpg</code>, we can use <code>tibble()</code> to create the data frame:

<code>label &lt;- tibble(</a>
  displ = Inf,</a>
  hwy = Inf,</a>
  label = "Increasing engine size is \nrelated to decreasing fuel economy."</a>
)</a>
</a>
ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point() +</a>
  geom_text(aes(label = label), data = label, vjust = "top", hjust = "right")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b06d6fc7bf280c1e4188854a332a4220e10c37d5/bdab2/communicate-plots_files/figure-html/unnamed-chunk-11-1.png" width="70%" style="display: block; margin: auto;" />

In these examples, I manually broke the label up into lines using <code>"\n"</code>. 
Another approach is to use <code>stringr::str_wrap()</code> to automatically add line breaks, given the number of characters you want per line:

<code>"Increasing engine size is related to decreasing fuel economy." %>%</a>
  stringr::str_wrap(width = 40) %>%</a>
  writeLines()</a>
#> Increasing engine size is related to</a>
#> decreasing fuel economy.</code>

Note the use of <code>hjust</code> and <code>vjust</code> to control the alignment of the label. 
Figure <a href="graphics-for-communication.html#fig:just">28.1</a> shows all nine possible combinations.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/8bb843d250309d1714fa2a6f729bd5da65af358a/e4c22/communicate-plots_files/figure-html/just-1.png" alt="All nine combinations of `hjust` and `vjust`." width="60%" />

Figure 28.1: All nine combinations of <code>hjust</code> and <code>vjust</code>.

Remember, in addition to <code>geom_text()</code>, you have many other geoms in ggplot2 available to help annotate your plot. 
A few ideas:

Use <code>geom_hline()</code> and <code>geom_vline()</code> to add reference lines. 
I often make
them thick (<code>size = 2</code>) and white (<code>colour = white</code>), and draw them
underneath the primary data layer. 
That makes them easy to see, without
drawing attention away from the data.

Use <code>geom_rect()</code> to draw a rectangle around points of interest. 
The
boundaries of the rectangle are defined by aesthetics <code>xmin</code>, <code>xmax</code>,
<code>ymin</code>, <code>ymax</code>.

Use <code>geom_segment()</code> with the <code>arrow</code> argument to draw attention
to a point with an arrow. 
Use aesthetics <code>x</code> and <code>y</code> to define the
starting location, and <code>xend</code> and <code>yend</code> to define the end location.

The only limit is your imagination (and your patience with positioning annotations to be aesthetically pleasing)!

<h3>28.3.1 Exercises</h3>

Use <code>geom_text()</code> with infinite positions to place text at the
four corners of the plot.

Read the documentation for <code>annotate()</code>. 
How can you use it to add a text
label to a plot without having to create a tibble?

How do labels with <code>geom_text()</code> interact with faceting? How can you
add a label to a single facet? How can you put a different label in
each facet? (Hint: think about the underlying data.)

What arguments to <code>geom_label()</code> control the appearance of the background
box?

What are the four arguments to <code>arrow()</code>? How do they work? Create a series
of plots that demonstrate the most important options.

<h2>28.4 Scales</h2>
The third way you can make your plot better for communication is to adjust the scales. 
Scales control the mapping from data values to things that you can perceive. 
Normally, ggplot2 automatically adds scales for you. 
For example, when you type:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class))</code>

ggplot2 automatically adds default scales behind the scenes:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  scale_x_continuous() +</a>
  scale_y_continuous() +</a>
  scale_colour_discrete()</code>

Note the naming scheme for scales: <code>scale_</code> followed by the name of the aesthetic, then <code>_</code>, then the name of the scale. 
The default scales are named according to the type of variable they align with: continuous, discrete, datetime, or date. 
There are lots of non-default scales which you’ll learn about below.

The default scales have been carefully chosen to do a good job for a wide range of inputs. 
Nevertheless, you might want to override the defaults for two reasons:

You might want to tweak some of the parameters of the default scale.
This allows you to do things like change the breaks on the axes, or the
key labels on the legend.

You might want to replace the scale altogether, and use a completely
different algorithm. 
Often you can do better than the default because
you know more about the data.

<h3>28.4.1 Axis ticks and legend keys</h3>
There are two primary arguments that affect the appearance of the ticks on the axes and the keys on the legend: <code>breaks</code> and <code>labels</code>. 
Breaks controls the position of the ticks, or the values associated with the keys. 
Labels controls the text label associated with each tick/key. 
The most common use of <code>breaks</code> is to override the default choice:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point() +</a>
  scale_y_continuous(breaks = seq(15, 40, by = 5))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/706da3674a79b7226f36c1bc29030ebcca6fa2ff/6496c/communicate-plots_files/figure-html/unnamed-chunk-14-1.png" width="70%" style="display: block; margin: auto;" />

You can use <code>labels</code> in the same way (a character vector the same length as <code>breaks</code>), but you can also set it to <code>NULL</code> to suppress the labels altogether. 
This is useful for maps, or for publishing plots where you can’t share the absolute numbers.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point() +</a>
  scale_x_continuous(labels = NULL) +</a>
  scale_y_continuous(labels = NULL)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7950c5b40e9d9f957b3dc4c8b8ae68a9353a2e96/1d4ac/communicate-plots_files/figure-html/unnamed-chunk-15-1.png" width="70%" style="display: block; margin: auto;" />

You can also use <code>breaks</code> and <code>labels</code> to control the appearance of legends. 
Collectively axes and legends are called guides. 
Axes are used for x and y aesthetics; legends are used for everything else.

Another use of <code>breaks</code> is when you have relatively few data points and want to highlight exactly where the observations occur. 
For example, take this plot that shows when each US president started and ended their term.

<code>presidential %>%</a>
  mutate(id = 33 + row_number()) %>%</a>
  ggplot(aes(start, id)) +</a>
    geom_point() +</a>
    geom_segment(aes(xend = end, yend = id)) +</a>
    scale_x_date(NULL, breaks = presidential$start, date_labels = "&#39;%y")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ebee3bb8c5ca82e85cceb216460f57671d372ece/2d716/communicate-plots_files/figure-html/unnamed-chunk-16-1.png" width="70%" style="display: block; margin: auto;" />

Note that the specification of breaks and labels for date and datetime scales is a little different:

<code>date_labels</code> takes a format specification, in the same form as
<code>parse_datetime()</code>.

<code>date_breaks</code> (not shown here), takes a string like '2 days' or '1 month'.

<h3>28.4.2 Legend layout</h3>
You will most often use <code>breaks</code> and <code>labels</code> to tweak the axes. 
While they both also work for legends, there are a few other techniques you are more likely to use.

To control the overall position of the legend, you need to use a <code>theme()</code> setting. 
We’ll come back to themes at the end of the chapter, but in brief, they control the non-data parts of the plot. 
The theme setting <code>legend.position</code> controls where the legend is drawn:

<code>base &lt;- ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class))</a>
</a>
base + theme(legend.position = "left")</a>
base + theme(legend.position = "top")</a>
base + theme(legend.position = "bottom")</a>
base + theme(legend.position = "right") # the default</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/37f725f47110e57cd33f5e9941ea0757716c1b07/e99ed/communicate-plots_files/figure-html/unnamed-chunk-17-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/98fffa78b52c7f47c91d8225202ae33b8179c40d/71ac6/communicate-plots_files/figure-html/unnamed-chunk-17-2.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/aacf99488efd12ddd2d5f73b3d3e1c8a4b19c9a0/a0235/communicate-plots_files/figure-html/unnamed-chunk-17-3.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7e30e12f9bcfd2d6d1aaa89041dd6f76427a71c1/0590b/communicate-plots_files/figure-html/unnamed-chunk-17-4.png" width="50%" />

You can also use <code>legend.position = "none"</code> to suppress the display of the legend altogether.

To control the display of individual legends, use <code>guides()</code> along with <code>guide_legend()</code> or <code>guide_colourbar()</code>. 
The following example shows two important settings: controlling the number of rows the legend uses with <code>nrow</code>, and overriding one of the aesthetics to make the points bigger. 
This is particularly useful if you have used a low <code>alpha</code> to display many points on a plot.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(colour = class)) +</a>
  geom_smooth(se = FALSE) +</a>
  theme(legend.position = "bottom") +</a>
  guides(colour = guide_legend(nrow = 1, override.aes = list(size = 4)))</a>
#> `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39;</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/41f946dcc43588b8a017175601c5eaabae7cb3c7/00564/communicate-plots_files/figure-html/unnamed-chunk-18-1.png" width="70%" style="display: block; margin: auto;" />

<h3>28.4.3 Replacing a scale</h3>
Instead of just tweaking the details a little, you can instead replace the scale altogether. 
There are two types of scales you’re mostly likely to want to switch out: continuous position scales and colour scales. 
Fortunately, the same principles apply to all the other aesthetics, so once you’ve mastered position and colour, you’ll be able to quickly pick up other scale replacements.

It’s very useful to plot transformations of your variable. 
For example, as we’ve seen in <a href="diamond-prices">diamond prices</a> it’s easier to see the precise relationship between <code>carat</code> and <code>price</code> if we log transform them:

<code>ggplot(diamonds, aes(carat, price)) +</a>
  geom_bin2d()</a>
</a>
ggplot(diamonds, aes(log10(carat), log10(price))) +</a>
  geom_bin2d()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/07ab619164b2a68ccc689d34d4ad113c19a21ec2/6b7c3/communicate-plots_files/figure-html/unnamed-chunk-19-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b5aaed1bbba7fad61bba706e9a0102157dac09f0/80ffb/communicate-plots_files/figure-html/unnamed-chunk-19-2.png" width="50%" />

However, the disadvantage of this transformation is that the axes are now labelled with the transformed values, making it hard to interpret the plot. 
Instead of doing the transformation in the aesthetic mapping, we can instead do it with the scale. 
This is visually identical, except the axes are labelled on the original data scale.

<code>ggplot(diamonds, aes(carat, price)) +</a>
  geom_bin2d() + </a>
  scale_x_log10() + </a>
  scale_y_log10()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ea6bee272cd6b693b9fb7cb5bfc4b5528353b2b3/dc3c2/communicate-plots_files/figure-html/unnamed-chunk-20-1.png" width="70%" style="display: block; margin: auto;" />

Another scale that is frequently customised is colour. 
The default categorical scale picks colours that are evenly spaced around the colour wheel. 
Useful alternatives are the ColorBrewer scales which have been hand tuned to work better for people with common types of colour blindness. 
The two plots below look similar, but there is enough difference in the shades of red and green that the dots on the right can be distinguished even by people with red-green colour blindness.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = drv))</a>
</a>
ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = drv)) +</a>
  scale_colour_brewer(palette = "Set1")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/80298187a88fdcb23d7977d9a1f1b89ece6c9566/109cb/communicate-plots_files/figure-html/unnamed-chunk-21-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2c62a3cc755287b16fd753ab4b99b612a38b1ef5/02260/communicate-plots_files/figure-html/unnamed-chunk-21-2.png" width="50%" />

Don’t forget simpler techniques. 
If there are just a few colours, you can add a redundant shape mapping. 
This will also help ensure your plot is interpretable in black and white.

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = drv, shape = drv)) +</a>
  scale_colour_brewer(palette = "Set1")</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ac65cb86be8fde7778f3487aa94093ae1190a689/24267/communicate-plots_files/figure-html/unnamed-chunk-22-1.png" width="70%" style="display: block; margin: auto;" />

The ColorBrewer scales are documented online at <a href="http://colorbrewer2.org/" class="uri">http://colorbrewer2.org/</a> and made available in R via the RColorBrewer package, by Erich Neuwirth. 
Figure <a href="graphics-for-communication.html#fig:brewer">28.2</a> shows the complete list of all palettes. 
The sequential (top) and diverging (bottom) palettes are particularly useful if your categorical values are ordered, or have a 'middle'. 
This often arises if you’ve used <code>cut()</code> to make a continuous variable into a categorical variable.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/31479e206c47592ecdff7bbe58a40c5f53211e56/7c25f/communicate-plots_files/figure-html/brewer-1.png" alt="All ColourBrewer scales." width="70%" />

Figure 28.2: All ColourBrewer scales.

When you have a predefined mapping between values and colours, use <code>scale_colour_manual()</code>. 
For example, if we map presidential party to colour, we want to use the standard mapping of red for Republicans and blue for Democrats:

<code>presidential %>%</a>
  mutate(id = 33 + row_number()) %>%</a>
  ggplot(aes(start, id, colour = party)) +</a>
    geom_point() +</a>
    geom_segment(aes(xend = end, yend = id)) +</a>
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/23242f16e96a5d684e766f6db6916cdd2cbbb6c2/8e514/communicate-plots_files/figure-html/unnamed-chunk-23-1.png" width="70%" style="display: block; margin: auto;" />

For continuous colour, you can use the built-in <code>scale_colour_gradient()</code> or <code>scale_fill_gradient()</code>. 
If you have a diverging scale, you can use <code>scale_colour_gradient2()</code>. 
That allows you to give, for example, positive and negative values different colours. 
That’s sometimes also useful if you want to distinguish points above or below the mean.

Another option is <code>scale_colour_viridis()</code> provided by the viridis package. 
It’s a continuous analog of the categorical ColorBrewer scales. 
The designers, Nathaniel Smith and Stéfan van der Walt, carefully tailored a continuous colour scheme that has good perceptual properties. 
Here’s an example from the viridis vignette.

<code>df &lt;- tibble(</a>
  x = rnorm(10000),</a>
  y = rnorm(10000)</a>
)</a>
ggplot(df, aes(x, y)) +</a>
  geom_hex() +</a>
  coord_fixed()</a>
</a>
ggplot(df, aes(x, y)) +</a>
  geom_hex() +</a>
  viridis::scale_fill_viridis() +</a>
  coord_fixed()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/33f3fe919e9c0269ba734702b274e0599eaa3fb7/d735a/communicate-plots_files/figure-html/unnamed-chunk-24-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/137655fab43815f3de31aa49731daac2351228dd/aa098/communicate-plots_files/figure-html/unnamed-chunk-24-2.png" width="50%" />

Note that all colour scales come in two variety: <code>scale_colour_x()</code> and <code>scale_fill_x()</code> for the <code>colour</code> and <code>fill</code> aesthetics respectively (the colour scales are available in both UK and US spellings).

<h3>28.4.4 Exercises</h3>

Why doesn’t the following code override the default scale?

<code>ggplot(df, aes(x, y)) +</a>
  geom_hex() +</a>
  scale_colour_gradient(low = "white", high = "red") +</a>
  coord_fixed()</code>

What is the first argument to every scale? How does it compare to <code>labs()</code>?

Change the display of the presidential terms by:

Combining the two variants shown above.

Improving the display of the y axis.

Labelling each term with the name of the president.

Adding informative plot labels.

Placing breaks every 4 years (this is trickier than it seems!).

Use <code>override.aes</code> to make the legend on the following plot easier to see.

<code>ggplot(diamonds, aes(carat, price)) +</a>
  geom_point(aes(colour = cut), alpha = 1/20)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1d4f87e305599ceb8920c8506b31aead523841e7/c93fe/communicate-plots_files/figure-html/unnamed-chunk-26-1.png" width="50%" style="display: block; margin: auto;" />

<h2>28.5 Zooming</h2>
There are three ways to control the plot limits:

Adjusting what data are plotted

Setting the limits in each scale

Setting <code>xlim</code> and <code>ylim</code> in <code>coord_cartesian()</code>

To zoom in on a region of the plot, it’s generally best to use <code>coord_cartesian()</code>. 
Compare the following two plots:

<code>ggplot(mpg, mapping = aes(displ, hwy)) +</a>
  geom_point(aes(color = class)) +</a>
  geom_smooth() +</a>
  coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))</a>
</a>
mpg %>%</a>
  filter(displ >= 5, displ &lt;= 7, hwy >= 10, hwy &lt;= 30) %>%</a>
  ggplot(aes(displ, hwy)) +</a>
  geom_point(aes(color = class)) +</a>
  geom_smooth()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/68229115445b93eb8e7d41784e50cf58e0bb00c7/90428/communicate-plots_files/figure-html/unnamed-chunk-27-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ffa19700101ce7791667abb26f82b56cf5eeb850/818a1/communicate-plots_files/figure-html/unnamed-chunk-27-2.png" width="50%" />

You can also set the <code>limits</code> on individual scales. 
Reducing the limits is basically equivalent to subsetting the data. 
It is generally more useful if you want <em>expand</em> the limits, for example, to match scales across different plots. 
For example, if we extract two classes of cars and plot them separately, it’s difficult to compare the plots because all three scales (the x-axis, the y-axis, and the colour aesthetic) have different ranges.

<code>suv &lt;- mpg %>% filter(class == "suv")</a>
compact &lt;- mpg %>% filter(class == "compact")</a>
</a>
ggplot(suv, aes(displ, hwy, colour = drv)) +</a>
  geom_point()</a>
</a>
ggplot(compact, aes(displ, hwy, colour = drv)) +</a>
  geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/34e8638fc6a1d3b63c0e9c1e242385658239fe21/a9772/communicate-plots_files/figure-html/unnamed-chunk-28-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f0f29fd73ea19d52c7fc641dffff0e8e26b77dd3/bf4ac/communicate-plots_files/figure-html/unnamed-chunk-28-2.png" width="50%" />

One way to overcome this problem is to share scales across multiple plots, training the scales with the <code>limits</code> of the full data.

<code>x_scale &lt;- scale_x_continuous(limits = range(mpg$displ))</a>
y_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))</a>
col_scale &lt;- scale_colour_discrete(limits = unique(mpg$drv))</a>
</a>
ggplot(suv, aes(displ, hwy, colour = drv)) +</a>
  geom_point() +</a>
  x_scale +</a>
  y_scale +</a>
  col_scale</a>
</a>
ggplot(compact, aes(displ, hwy, colour = drv)) +</a>
  geom_point() +</a>
  x_scale +</a>
  y_scale +</a>
  col_scale</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/4936c7df1a3038bf45cd82a2db8d307343ff02bc/15f5f/communicate-plots_files/figure-html/unnamed-chunk-29-1.png" width="50%" /><img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/fa7315f5c6baca33c7228e00dfebd2e6e950e3c1/ce18f/communicate-plots_files/figure-html/unnamed-chunk-29-2.png" width="50%" />

In this particular case, you could have simply used faceting, but this technique is useful more generally, if for instance, you want spread plots over multiple pages of a report.

<h2>28.6 Themes</h2>
Finally, you can customise the non-data elements of your plot with a theme:

<code>ggplot(mpg, aes(displ, hwy)) +</a>
  geom_point(aes(color = class)) +</a>
  geom_smooth(se = FALSE) +</a>
  theme_bw()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3e50eccae0d8a90687d0e0086bbd2c7e39da2181/e774f/communicate-plots_files/figure-html/unnamed-chunk-30-1.png" width="70%" style="display: block; margin: auto;" />

ggplot2 includes eight themes by default, as shown in Figure <a href="graphics-for-communication.html#fig:themes">28.3</a>. 
Many more are included in add-on packages like ggthemes (<a href="https://github.com/jrnold/ggthemes" class="uri">https://github.com/jrnold/ggthemes</a>), by Jeffrey Arnold.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6be25cfb939e69d72df9fbc68e7a0334e1febefe/10e92/images/visualization-themes.png" alt="The eight themes built-in to ggplot2." width="70%" />

Figure 28.3: The eight themes built-in to ggplot2.

Many people wonder why the default theme has a grey background. 
This was a deliberate choice because it puts the data forward while still making the grid lines visible. 
The white grid lines are visible (which is important because they significantly aid position judgements), but they have little visual impact and we can easily tune them out. 
The grey background gives the plot a similar typographic colour to the text, ensuring that the graphics fit in with the flow of a document without jumping out with a bright white background. 
Finally, the grey background creates a continuous field of colour which ensures that the plot is perceived as a single visual entity.

It’s also possible to control individual components of each theme, like the size and colour of the font used for the y axis. 
Unfortunately, this level of detail is outside the scope of this book, so you’ll need to read the <a href="https://amzn.com/331924275X">ggplot2 book</a> for the full details. 
You can also create your own themes, if you are trying to match a particular corporate or journal style.

<h2>28.7 Saving your plots</h2>
There are two main ways to get your plots out of R and into your final write-up: <code>ggsave()</code> and knitr. 
<code>ggsave()</code> will save the most recent plot to disk:

<code>ggplot(mpg, aes(displ, hwy)) + geom_point()</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/27f75d757f210f2106c34e399f5d32b667a653f8/aa4e4/communicate-plots_files/figure-html/unnamed-chunk-31-1.png" width="70%" style="display: block; margin: auto;" />

<code>ggsave("my-plot.pdf")</a>
#> Saving 7 x 4.32 in image</code>

If you don’t specify the <code>width</code> and <code>height</code> they will be taken from the dimensions of the current plotting device. 
For reproducible code, you’ll want to specify them.

Generally, however, I think you should be assembling your final reports using R Markdown, so I want to focus on the important code chunk options that you should know about for graphics. 
You can learn more about <code>ggsave()</code> in the documentation.

<h3>28.7.1 Figure sizing</h3>
The biggest challenge of graphics in R Markdown is getting your figures the right size and shape. 
There are five main options that control figure sizing: <code>fig.width</code>, <code>fig.height</code>, <code>fig.asp</code>, <code>out.width</code> and <code>out.height</code>. 
Image sizing is challenging because there are two sizes (the size of the figure created by R and the size at which it is inserted in the output document), and multiple ways of specifying the size (i.e., height, width, and aspect ratio: pick two of three).

I only ever use three of the five options:

I find it most aesthetically pleasing for plots to have a consistent
width. 
To enforce this, I set <code>fig.width = 6</code> (6") and <code>fig.asp = 0.618</code>
(the golden ratio) in the defaults. 
Then in individual chunks, I only
adjust <code>fig.asp</code>.

I control the output size with <code>out.width</code> and set it to a percentage
of the line width. 
I default to <code>out.width = "70%"</code>
and <code>fig.align = "center"</code>. 
That give plots room to breathe, without taking
up too much space.

To put multiple plots in a single row I set the <code>out.width</code> to
<code>50%</code> for two plots, <code>33%</code> for 3 plots, or <code>25%</code> to 4 plots, and set
<code>fig.align = "default"</code>. 
Depending on what I’m trying to illustrate (
e.g. show data or show plot variations), I’ll also tweak <code>fig.width</code>, as
discussed below.

If you find that you’re having to squint to read the text in your plot, you need to tweak <code>fig.width</code>. 
If <code>fig.width</code> is larger than the size the figure is rendered in the final doc, the text will be too small; if <code>fig.width</code> is smaller, the text will be too big. 
You’ll often need to do a little experimentation to figure out the right ratio between the <code>fig.width</code> and the eventual width in your document. 
To illustrate the principle, the following three plots have <code>fig.width</code> of 4, 6, and 8 respectively:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bd3974800c17e2685b5ed94ee7bb5a9e55278027/81c6e/communicate-plots_files/figure-html/unnamed-chunk-34-1.png" width="70%" style="display: block; margin: auto;" />
<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/1eb071c46c5f1aae2ed63a51590c632864c9ae8b/0af71/communicate-plots_files/figure-html/unnamed-chunk-35-1.png" width="70%" style="display: block; margin: auto;" />
<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ae73d8ecda562ca276df2dd128056adde1a6d5cc/820f4/communicate-plots_files/figure-html/unnamed-chunk-36-1.png" width="70%" style="display: block; margin: auto;" />

If you want to make sure the font size is consistent across all your figures, whenever you set <code>out.width</code>, you’ll also need to adjust <code>fig.width</code> to maintain the same ratio with your default <code>out.width</code>. 
For example, if your default <code>fig.width</code> is 6 and <code>out.width</code> is 0.7, when you set <code>out.width = "50%"</code> you’ll need to set <code>fig.width</code> to 4.3 (6 * 0.5 / 0.7).

<h3>28.7.2 Other important options</h3>
When mingling code and text, like I do in this book, I recommend setting <code>fig.show = "hold"</code> so that plots are shown after the code. 
This has the pleasant side effect of forcing you to break up large blocks of code with their explanations.

To add a caption to the plot, use <code>fig.cap</code>. 
In R Markdown this will change the figure from inline to 'floating'.

If you’re producing PDF output, the default graphics type is PDF. 
This is a good default because PDFs are high quality vector graphics. 
However, they can produce very large and slow plots if you are displaying thousands of points. 
In that case, set <code>dev = "png"</code> to force the use of PNGs. 
They are slightly lower quality, but will be much more compact.

It’s a good idea to name code chunks that produce figures, even if you don’t routinely label other chunks. 
The chunk label is used to generate the file name of the graphic on disk, so naming your chunks makes it much easier to pick out plots and reuse in other circumstances (i.e. if you want to quickly drop a single plot into an email or a tweet).

<h2>28.8 Learning more</h2>
The absolute best place to learn more is the ggplot2 book: <a href="https://amzn.com/331924275X"><em>ggplot2: Elegant graphics for data analysis</em></a>. 
It goes into much more depth about the underlying theory, and has many more examples of how to combine the individual pieces to solve practical problems. 
Unfortunately, the book is not available online for free, although you can find the source code at <a href="https://github.com/hadley/ggplot2-book" class="uri">https://github.com/hadley/ggplot2-book</a>.

Another great resource is the ggplot2 extensions gallery <a href="https://exts.ggplot2.tidyverse.org/gallery/" class="uri">https://exts.ggplot2.tidyverse.org/gallery/</a>. 
This site lists many of the packages that extend ggplot2 with new geoms and scales. 
It’s a great place to start if you’re trying to do something that seems hard with ggplot2.

<h2><span class="orange">29 R Markdown formats</span></h2>

<h2>29.1 Introduction</h2>
So far you’ve seen R Markdown used to produce HTML documents. 
This chapter gives a brief overview of some of the many other types of output you can produce with R Markdown. 
There are two ways to set the output of a document:

Permanently, by modifying the YAML header:

<code>title: "Viridis Demo"</a>
output: html_document</code>

Transiently, by calling <code>rmarkdown::render()</code> by hand:

<code>rmarkdown::render("diamond-sizes.Rmd", output_format = "word_document")</code>

This is useful if you want to programmatically produce multiple types of
output.

RStudio’s knit button renders a file to the first format listed in its <code>output</code> field. 
You can render to additional formats by clicking the dropdown menu beside the knit button.

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7c96cd0503aa3fcc9cd1ee60c354e8c1dea1c7f4/d7c98/screenshots/rmarkdown-knit.png" width="206" style="display: block; margin: auto;" />

<h2>29.2 Output options</h2>
Each output format is associated with an R function. 
You can either write <code>foo</code> or <code>pkg::foo</code>. 
If you omit <code>pkg</code>, the default is assumed to be rmarkdown. 
It’s important to know the name of the function that makes the output because that’s where you get help. 
For example, to figure out what parameters you can set with <code>html_document</code>, look at <code>?rmarkdown::html_document</code>.

To override the default parameter values, you need to use an expanded <code>output</code> field. 
For example, if you wanted to render an <code>html_document</code> with a floating table of contents, you’d use:

<code>output:</a>
  html_document:</a>
    toc: true</a>
    toc_float: true</code>

You can even render to multiple outputs by supplying a list of formats:

<code>output:</a>
  html_document:</a>
    toc: true</a>
    toc_float: true</a>
  pdf_document: default</code>

Note the special syntax if you don’t want to override any of the default options.

<h2>29.3 Documents</h2>
The previous chapter focused on the default <code>html_document</code> output. 
There are a number of basic variations on that theme, generating different types of documents:

<code>pdf_document</code> makes a PDF with LaTeX (an open source document layout
system), which you’ll need to install. 
RStudio will prompt you if you
don’t already have it.

<code>word_document</code> for Microsoft Word documents (<code>.docx</code>).

<code>odt_document</code> for OpenDocument Text documents (<code>.odt</code>).

<code>rtf_document</code> for Rich Text Format (<code>.rtf</code>) documents.

<code>md_document</code> for a Markdown document. 
This isn’t typically useful by
itself, but you might use it if, for example, your corporate CMS or
lab wiki uses markdown.

<code>github_document</code>: this is a tailored version of <code>md_document</code>
designed for sharing on GitHub.

Remember, when generating a document to share with decision makers, you can turn off the default display of code by setting global options in the setup chunk:

<code>knitr::opts_chunk$set(echo = FALSE)</code>

For <code>html_document</code>s another option is to make the code chunks hidden by default, but visible with a click:

<code>output:</a>
  html_document:</a>
    code_folding: hide</code>

<h2>29.4 Notebooks</h2>
A notebook, <code>html_notebook</code>, is a variation on a <code>html_document</code>. 
The rendered outputs are very similar, but the purpose is different. 
A <code>html_document</code> is focused on communicating with decision makers, while a notebook is focused on collaborating with other data scientists. 
These different purposes lead to using the HTML output in different ways. 
Both HTML outputs will contain the fully rendered output, but the notebook also contains the full source code. 
That means you can use the <code>.nb.html</code> generated by the notebook in two ways:

You can view it in a web browser, and see the rendered output. 
Unlike
<code>html_document</code>, this rendering always includes an embedded copy of
the source code that generated it.

You can edit it in RStudio. 
When you open an <code>.nb.html</code> file, RStudio will
automatically recreate the <code>.Rmd</code> file that generated it. 
In the future, you
will also be able to include supporting files (e.g. 
<code>.csv</code> data files), which
will be automatically extracted when needed.

Emailing <code>.nb.html</code> files is a simple way to share analyses with your colleagues. 
But things will get painful as soon as they want to make changes. 
If this starts to happen, it’s a good time to learn Git and GitHub. 
Learning Git and GitHub is definitely painful at first, but the collaboration payoff is huge. 
As mentioned earlier, Git and GitHub are outside the scope of the book, but there’s one tip that’s useful if you’re already using them: use both <code>html_notebook</code> and <code>github_document</code> outputs:

<code>output:</a>
  html_notebook: default</a>
  github_document: default</code>

<code>html_notebook</code> gives you a local preview, and a file that you can share via email. 
<code>github_document</code> creates a minimal md file that you can check into git. 
You can easily see how the results of your analysis (not just the code) change over time, and GitHub will render it for you nicely online.

<h2>29.5 Presentations</h2>
You can also use R Markdown to produce presentations. 
You get less visual control than with a tool like Keynote or PowerPoint, but automatically inserting the results of your R code into a presentation can save a huge amount of time. 
Presentations work by dividing your content into slides, with a new slide beginning at each first (<code>#</code>) or second (<code>##</code>) level header. 
You can also insert a horizontal rule (<code>***</code>) to create a new slide without a header.

R Markdown comes with three presentation formats built-in:

<code>ioslides_presentation</code> - HTML presentation with ioslides

<code>slidy_presentation</code> - HTML presentation with W3C Slidy

<code>beamer_presentation</code> - PDF presentation with LaTeX Beamer.

Two other popular formats are provided by packages:

<code>revealjs::revealjs_presentation</code> - HTML presentation with reveal.js.
Requires the revealjs package.

rmdshower, <a href="https://github.com/MangoTheCat/rmdshower" class="uri">https://github.com/MangoTheCat/rmdshower</a>, provides a
wrapper around the shower, <a href="https://github.com/shower/shower" class="uri">https://github.com/shower/shower</a>,
presentation engine

<h2>29.6 Dashboards</h2>
Dashboards are a useful way to communicate large amounts of information visually and quickly. 
Flexdashboard makes it particularly easy to create dashboards using R Markdown and a convention for how the headers affect the layout:

Each level 1 header (<code>#</code>) begins a new page in the dashboard.

Each level 2 header (<code>##</code>) begins a new column.

Each level 3 header (<code>###</code>) begins a new row.

For example, you can produce this dashboard:

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/af4786e2d97be5851ec2db90372003f0384d3deb/1d30c/screenshots/rmarkdown-flexdashboard.png" width="75%" style="display: block; margin: auto;" />

Using this code:

<code>---
title: "Diamonds distribution dashboard"
output: flexdashboard::flex_dashboard
---

```{r setup, include = FALSE}
library(ggplot2)
library(dplyr)
knitr::opts_chunk$set(fig.width = 5, fig.asp = 1/3)
```

## Column 1

### Carat

```{r}
ggplot(diamonds, aes(carat)) + geom_histogram(binwidth = 0.1)
```

### Cut

```{r}
ggplot(diamonds, aes(cut)) + geom_bar()
```

### Colour

```{r}
ggplot(diamonds, aes(color)) + geom_bar()
```

## Column 2

### The largest diamonds

```{r}
diamonds %>% 
  arrange(desc(carat)) %>% 
  head(100) %>% 
  select(carat, cut, color, price) %>% 
  DT::datatable()
```</code>

Flexdashboard also provides simple tools for creating sidebars, tabsets, value boxes, and gauges. 
To learn more about flexdashboard visit <a href="http://rmarkdown.rstudio.com/flexdashboard/" class="uri">http://rmarkdown.rstudio.com/flexdashboard/</a>.

<h2>29.7 Interactivity</h2>
Any HTML format (document, notebook, presentation, or dashboard) can contain interactive components.

<h3>29.7.1 htmlwidgets</h3>
HTML is an interactive format, and you can take advantage of that interactivity with htmlwidgets, R functions that produce interactive HTML visualisations. 
For example, take the leaflet map below. 
If you’re viewing this page on the web, you can drag the map around, zoom in and out, etc. 
You obviously can’t do that in a book, so rmarkdown automatically inserts a static screenshot for you.

<code>library(leaflet)</a>
leaflet() %>%</a>
  setView(174.764, -36.877, zoom = 16) %>% </a>
  addTiles() %>%</a>
  addMarkers(174.764, -36.877, popup = "Maungawhau") </code>

<script type="application/json" data-for="htmlwidget-ac96cb3ee4656e2e9ec3">{"x":{"options":{"crs":{"crsClass":"L.CRS.EPSG3857","code":null,"proj4def":null,"projectedBounds":null,"options":{}}},"setView":[[-36.877,174.764],16,[]],"calls":[{"method":"addTiles","args":["//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",null,null,{"minZoom":0,"maxZoom":18,"tileSize":256,"subdomains":"abc","errorTileUrl":"","tms":false,"noWrap":false,"zoomOffset":0,"zoomReverse":false,"opacity":1,"zIndex":1,"detectRetina":false,"attribution":"&copy; <a href=\"http://openstreetmap.org\">OpenStreetMap<\/a> contributors, <a href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA<\/a>"}]},{"method":"addMarkers","args":[-36.877,174.764,null,null,null,{"interactive":true,"draggable":false,"keyboard":true,"title":"","alt":"","zIndexOffset":0,"opacity":1,"riseOnHover":false,"riseOffset":250},"Maungawhau",null,null,null,null,{"interactive":false,"permanent":false,"direction":"auto","opacity":1,"offset":[0,0],"textsize":"10px","textOnly":false,"className":"","sticky":true},null]}],"limits":{"lat":[-36.877,-36.877],"lng":[174.764,174.764]}},"evals":[],"jsHooks":[]}</script>
The great thing about htmlwidgets is that you don’t need to know anything about HTML or JavaScript to use them. 
All the details are wrapped inside the package, so you don’t need to worry about it.

There are many packages that provide htmlwidgets, including:

dygraphs, <a href="http://rstudio.github.io/dygraphs/" class="uri">http://rstudio.github.io/dygraphs/</a>, for interactive time
series visualisations.

DT, <a href="http://rstudio.github.io/DT/" class="uri">http://rstudio.github.io/DT/</a>, for interactive tables.

threejs, <a href="https://github.com/bwlewis/rthreejs" class="uri">https://github.com/bwlewis/rthreejs</a> for interactive 3d plots.

DiagrammeR, <a href="http://rich-iannone.github.io/DiagrammeR/" class="uri">http://rich-iannone.github.io/DiagrammeR/</a> for diagrams
(like flow charts and simple node-link diagrams).

To learn more about htmlwidgets and see a more complete list of packages that provide them visit <a href="http://www.htmlwidgets.org/" class="uri">http://www.htmlwidgets.org/</a>.

<h3>29.7.2 Shiny</h3>
htmlwidgets provide client-side interactivity — all the interactivity happens in the browser, independently of R. 
On one hand, that’s great because you can distribute the HTML file without any connection to R. 
However, that fundamentally limits what you can do to things that have been implemented in HTML and JavaScript. 
An alternative approach is to use shiny, a package that allows you to create interactivity using R code, not JavaScript.

To call Shiny code from an R Markdown document, add <code>runtime: shiny</code> to the header:

<code>title: "Shiny Web App"</a>
output: html_document</a>
runtime: shiny</code>

Then you can use the 'input' functions to add interactive components to the document:

<code>library(shiny)</a>
</a>
textInput("name", "What is your name?")</a>
numericInput("age", "How old are you?", NA, min = 0, max = 150)</code>

<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2aba7a4cbe02efbfdc51c3deb1281795f731331b/79421/screenshots/rmarkdown-shiny.png" width="357" style="display: block; margin: auto;" />
You can then refer to the values with <code>input$name</code> and <code>input$age</code>, and the code that uses them will be automatically re-run whenever they change.

I can’t show you a live shiny app here because shiny interactions occur on the server-side. 
This means that you can write interactive apps without knowing JavaScript, but you need a server to run them on. 
This introduces a logistical issue: Shiny apps need a Shiny server to be run online. 
When you run shiny apps on your own computer, shiny automatically sets up a shiny server for you, but you need a public facing shiny server if you want to publish this sort of interactivity online. 
That’s the fundamental trade-off of shiny: you can do anything in a shiny document that you can do in R, but it requires someone to be running R.

Learn more about Shiny at <a href="http://shiny.rstudio.com/" class="uri">http://shiny.rstudio.com/</a>.

<h2>29.8 Websites</h2>
With a little additional infrastructure you can use R Markdown to generate a complete website:

Put your <code>.Rmd</code> files in a single directory. 
<code>index.Rmd</code> will become
the home page.

Add a YAML file named <code>_site.yml</code> provides the navigation for the site.
For example:

<code>name: "my-website"
navbar:
  title: "My Website"
  left:
    - text: "Home"
      href: index.html
    - text: "Viridis Colors"
      href: 1-example.html
    - text: "Terrain Colors"
      href: 3-inline.html</code>

Execute <code>rmarkdown::render_site()</code> to build <code>_site</code>, a directory of files ready to deploy as a standalone static website, or if you use an RStudio Project for your website directory. 
RStudio will add a Build tab to the IDE that you can use to build and preview your site.

Read more at <a href="http://rmarkdown.rstudio.com/rmarkdown_websites.html" class="uri">http://rmarkdown.rstudio.com/rmarkdown_websites.html</a>.

<h2>29.9 Other formats</h2>
Other packages provide even more output formats:

The bookdown package, <a href="https://github.com/rstudio/bookdown" class="uri">https://github.com/rstudio/bookdown</a>,
makes it easy to write books, like this one. 
To learn more, read
<a href="https://bookdown.org/yihui/bookdown/"><em>Authoring Books with R Markdown</em></a>,
by Yihui Xie, which is, of course, written in bookdown. 
Visit
<a href="http://www.bookdown.org" class="uri">http://www.bookdown.org</a> to see other bookdown books written by the
wider R community.

The prettydoc package, <a href="https://github.com/yixuan/prettydoc/" class="uri">https://github.com/yixuan/prettydoc/</a>,
provides lightweight document formats with a range of attractive
themes.

The rticles package, <a href="https://github.com/rstudio/rticles" class="uri">https://github.com/rstudio/rticles</a>, compiles a
selection of formats tailored for specific scientific journals.

See <a href="http://rmarkdown.rstudio.com/formats.html" class="uri">http://rmarkdown.rstudio.com/formats.html</a> for a list of even more formats. 
You can also create your own by following the instructions at <a href="http://rmarkdown.rstudio.com/developer_custom_formats.html" class="uri">http://rmarkdown.rstudio.com/developer_custom_formats.html</a>.

<h2>29.10 Learning more</h2>
To learn more about effective communication in these different formats I recommend the following resources:

To improve your presentation skills, I recommend
<a href="https://amzn.com/0321820800"><em>Presentation Patterns</em></a>, by Neal Ford,
Matthew McCollough, and Nathaniel Schutta. 
It provides a set of effective
patterns (both low- and high-level) that you can apply to improve your
presentations.

If you give academic talks, I recommend reading the <a href="https://github.com/jtleek/talkguide"><em>Leek group guide
to giving talks</em></a>.

I haven’t taken it myself, but I’ve heard good things about Matt
McGarrity’s online course on public speaking:
<a href="https://www.coursera.org/learn/public-speaking" class="uri">https://www.coursera.org/learn/public-speaking</a>.

If you are creating a lot of dashboards, make sure to read Stephen Few’s
<a href="https://amzn.com/0596100167">Information Dashboard Design: The Effective Visual Communication
of Data</a>. 
It will help you create dashboards
that are truly useful, not just pretty to look at.

Effectively communicating your ideas often benefits from some
knowledge of graphic design. 
<a href="http://amzn.com/0133966151"><em>The Non-Designer’s Design
Book</em></a> is a great place to start.

<h2><span class="orange">30 R Markdown workflow</span></h2>
Earlier, we discussed a basic workflow for capturing your R code where you work interactively in the <em>console</em>, then capture what works in the <em>script editor</em>. 
R Markdown brings together the console and the script editor, blurring the lines between interactive exploration and long-term code capture. 
You can rapidly iterate within a chunk, editing and re-executing with Cmd/Ctrl + Shift + Enter. 
When you’re happy, you move on and start a new chunk.

R Markdown is also important because it so tightly integrates prose and code. 
This makes it a great analysis notebook because it lets you develop code and record your thoughts. 
An analysis notebook shares many of the same goals as a classic lab notebook in the physical sciences. 
It:

Records what you did and why you did it. 
Regardless of how great your
memory is, if you don’t record what you do, there will come a time when
you have forgotten important details. 
Write them down so you don’t forget!

Supports rigorous thinking. 
You are more likely to come up with a strong
analysis if you record your thoughts as you go, and continue to reflect
on them. 
This also saves you time when you eventually write up your
analysis to share with others.

Helps others understand your work. 
It is rare to do data analysis by
yourself, and you’ll often be working as part of a team. 
A lab notebook
helps you share not only what you’ve done, but why you did it with your
colleagues or lab mates.

Much of the good advice about using lab notebooks effectively can also be translated to analysis notebooks. 
I’ve drawn on my own experiences and Colin Purrington’s advice on lab notebooks (<a href="http://colinpurrington.com/tips/lab-notebooks" class="uri">http://colinpurrington.com/tips/lab-notebooks</a>) to come up with the following tips:

Ensure each notebook has a descriptive title, an evocative filename, and a
first paragraph that briefly describes the aims of the analysis.

Use the YAML header date field to record the date you started working on the
notebook:

<code>date: 2016-08-23</code>

Use ISO8601 YYYY-MM-DD format so that’s there no ambiguity. 
Use it
even if you don’t normally write dates that way!

If you spend a lot of time on an analysis idea and it turns out to be a
dead end, don’t delete it! Write up a brief note about why it failed and
leave it in the notebook. 
That will help you avoid going down the same
dead end when you come back to the analysis in the future.

Generally, you’re better off doing data entry outside of R. 
But if you
do need to record a small snippet of data, clearly lay it out using
<code>tibble::tribble()</code>.

If you discover an error in a data file, never modify it directly, but
instead write code to correct the value. 
Explain why you made the fix.

Before you finish for the day, make sure you can knit the notebook
(if you’re using caching, make sure to clear the caches). 
That will
let you fix any problems while the code is still fresh in your mind.

If you want your code to be reproducible in the long-run (i.e. so you can
come back to run it next month or next year), you’ll need to track the
versions of the packages that your code uses. 
A rigorous approach is to use
packrat, <a href="http://rstudio.github.io/packrat/" class="uri">http://rstudio.github.io/packrat/</a>, which stores packages
in your project directory, or checkpoint,
<a href="https://github.com/RevolutionAnalytics/checkpoint" class="uri">https://github.com/RevolutionAnalytics/checkpoint</a>, which will reinstall
packages available on a specified date. 
A quick and dirty hack is to include
a chunk that runs <code>sessionInfo()</code> — that won’t let you easily recreate
your packages as they are today, but at least you’ll know what they were.

You are going to create many, many, many analysis notebooks over the course
of your career. 
How are you going to organise them so you can find them
again in the future? I recommend storing them in individual projects,
and coming up with a good naming scheme.

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
