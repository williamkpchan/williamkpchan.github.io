<base target="_blank"><html><head><title>htmx notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var topicEnd = "<br>";
  var bookid = "htmx notes"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>htmx notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br><br>
<div id="toc"></div></center><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="htmxExamples.html" class="redbut goldblackgrad black ULine">♦htmx Examples</a>
<a href="https://apostrophecms.com/blog/htmx-examples-and-how-to-use-it" class="whitebut ">htmx examples</a>
<a href="https://blog.logrocket.com/using-htmx-modern-apps-classic-techniques/" class="whitebut ">using htmx</a>
</div>
<pre><br><br>

<h2>HTMX Examples</h2>

<div id="HTMXExamplestoc" class="toc"><a href="#HTMXExamplestopic-0" target="_self"><pk>What Is HTMX?</pk></a><br><a href="#HTMXExamplestopic-1" target="_self"><pk>HTMX Overview: Syntax, Features, and Capabilities</pk></a><br><a href="#HTMXExamplestopic-2" target="_self"> Request Triggers</a><br><a href="#HTMXExamplestopic-3" target="_self"> Query Parameters and Body Data</a><br><a href="#HTMXExamplestopic-4" target="_self"> Result Content Handling</a><br><a href="#HTMXExamplestopic-5" target="_self"><pk>HTMX in Action: Integration With ApostropheCMS</pk></a><br><a href="#HTMXExamplestopic-6" target="_self"> Getting Started</a><br><a href="#HTMXExamplestopic-7" target="_self"> Integrating HTMX</a><br><a href="#HTMXExamplestopic-8" target="_self"> Adding a Load More Button With HTMX</a><br><a href="#HTMXExamplestopic-9" target="_self"> Using HTMX to Implement Infinite Scrolling</a><br><a href="#HTMXExamplestopic-10" target="_self"> Achieving Live Content Filtering Through HTMX</a><br></div></center>
<br>
HTMX aims to provide access to modern browser functionality directly in HTML code, without a single line of JavaScript.

<h3 id="HTMXExamplestopic-0"><pk>What Is HTMX?</pk></h3>
<a href="https://htmx.org/" target="_blank">HTMX</a> is a small, dependency-free, extendable library that allows you to access modern browser features directly from HTML, instead of using JavaScript.

Specifically, it gives you access to AJAX (i.e., fetching content without reloading the whole page), CSS Transitions, WebSockets, and Server Sent Events directly via HTML attributes.

An example! Take a look at this snippet:

&lt;button hx-get="/api/v1/hello-world" hx-swap="outerHTML"&gt;Click Me&lt;/button&gt;

The special hx-get and hx-swap attributes tell HTMX:

<em>“When a user clicks on this button, instruct the browser to perform an AJAX request to the ‘/api/v1/hello-world’ endpoint, and replace the entire button with the HTML content returned by the server”</em>

In JavaScript, achieving the same result would take dozens of lines of code.
That is the power of HTMX!

<h3 id="HTMXExamplestopic-1"><pk>HTMX Overview: Syntax, Features, and Capabilities</pk></h3>

The core idea behind HTMX is the ability to send AJAX requests directly from HTML, with no JavaScript involved.
This is possible thanks to the following attributes:


<a href="https://htmx.org/attributes/hx-get/" target="_blank"><b>hx-get</b></a>: To perform a GET request to the given URL.
<a href="https://htmx.org/attributes/hx-post/" target="_blank"><b>hx-post</b></a>: To perform a POST request to the given URL.
<a href="https://htmx.org/attributes/hx-put/" target="_blank"><b>hx-put</b></a>: To perform a PUT request to the given URL.
<a href="https://htmx.org/attributes/hx-patch/" target="_blank"><b>hx-patch</b></a>: To perform a PATCH request to the given URL.
<a href="https://htmx.org/attributes/hx-delete/" target="_blank"><b>hx-delete</b></a>: To perform a DELETE request to the given URL.


When a specific event is triggered, the HTML element involving one of these HTMX attributes will make an AJAX request of the specified type to the given URL.
Consider the example below:

 &lt;button hx-post="/api/v1/products/buy"&gt;Buy&lt;/button&gt;

This tells the browser:

<em>“When a user clicks on the &lt;button&gt;, make a POST request to the URL ‘/api/v1/products/buy’ and load the response into the inner HTML of the &lt;button&gt;”</em>

<h3 id="HTMXExamplestopic-2"> Request Triggers</h3>

By default, AJAX requests made by HTMX are triggered by the “natural” event associated with the HTML element:


change: For &lt;input&gt;, &lt;textarea&gt; and &lt;select&gt; elements.
submit: For the &lt;form&gt; element.
click: For every other element.


Going back to the snippet seen earlier, it should now be clear why the action that triggers the request is a click, even if not specified.

To modify the default trigger behavior, you can use the <a href="https://htmx.org/attributes/hx-trigger/" target="_blank">hx-trigger</a> attribute to set which HTML event will cause the request.
Check out the <a href="https://developer.mozilla.org/en-US/docs/Web/Events#event_listing" target="_blank">list of events supported by HTML</a>.

Take a look at the example below:
&lt;span hx-get="/api/v1/products" hx-trigger="mouseenter"&gt;Hover Me!&lt;/span&gt;

This tells the browser:

<em>"When a user moves the mouse over the &lt;span&gt;, perform a GET request to the URL ‘/api/v1/products’ and render the response in the inner HTML of the &lt;span&gt;”</em>

Keep in mind that hx-trigger also supports <a href="https://htmx.org/docs/#trigger-modifiers" target="_blank">modifiers</a> and <a href="https://htmx.org/docs/#trigger-filters" target="_blank">filters</a> to tailor the triggering logic to your needs.
Plus, HTMX provides the following <a href="https://htmx.org/docs/#special-events" target="_blank">special events</a>:


load: Fires when the element is loaded for the first time.
revealed: Fires once when the element is scrolled into the viewport.
intersect: Fires once when the element intersects with the viewport.
As opposed to revealed, it accepts an optional CSS selector of the root element for intersection and a float number between 0.0 and 1.0 to indicate the amount of intersection to trigger the event on.


<h3 id="HTMXExamplestopic-3"> Query Parameters and Body Data</h3>

The way HTMX handles parameters and body data changes depending on the type of the request:


<b>GET</b><b> requests</b>: The query parameters should be specified in the URL passed to hx-get.
By default, hx-get does not automatically include any parameters to the request.
Anyway, you can control that with the <a href="https://htmx.org/attributes/hx-params/" target="_blank">hx-params</a> attribute as explained in the documentation.
<b>Non-</b><b>GET</b><b> requests</b>: If an element is a &lt;form&gt;, the body will include the values of all inputs within it, using their name attribute as the parameter name.
If it is not a &lt;form&gt;, the body will include the values of all the inputs of the nearest enclosing &lt;form&gt;.
Otherwise, if it has a value attribute, it will be used in the body.
When the default behavior is not enough, the <a href="https://htmx.org/attributes/hx-include/" target="_blank">hx-include</a> and <a href="https://htmx.org/attributes/hx-params/" target="_blank">hx-params</a> attributes allows you to control which values and which parameters to set, respectively.
Otherwise, you can programmatically modify the body fields by listening to the <a href="https://htmx.org/events/#htmx:configRequest" target="_blank">htmx:configRequest</a> event.


<h3 id="HTMXExamplestopic-4"> Result Content Handling</h3>

By default, HTMX replaces the inner HTML of the element firing the request with the HTML returned by the AJAX call.
This means that HTMX-compliant AJAX endpoints should return HTML code.

To change the swap strategy, use the <a href="https://htmx.org/attributes/hx-swap/" target="_blank">hx-swap</a> attribute.
That supports the following values:


innerHTML: Replace the inner HTML of the target element.
outerHTML: Replace the entire target element with the response.
beforebegin: Insert the response before the target element.
afterbegin: Insert the response before the first child of the target element.
beforeend: Insert the response after the last child of the target element.
afterend: Insert the response after the target element.
delete: Delete the target element regardless of the response.
none: Does not append the content from the response.


You can change the target element the swap logic refers to with the <a href="https://htmx.org/attributes/hx-target/" target="_blank">hx-target</a> attribute, which accepts a <a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors" target="_blank">CSS selector</a>.
Note that the attribute supports multiple triggers, each one separated by comma.

Focus now on the following snippet:

&lt;button
hx-post="/api/v1/comments"
hx-trigger="click"
hx-swap=".comments"
hx-target="afterend"
&gt;
Comment
&lt;/button&gt;

This tells the browser:

<em>“When a user clicks the &lt;button&gt;, perform a POST request to the URL ‘/api/v1/comments’ and add the resulting HTML to the .comments element”</em>

<h3 id="HTMXExamplestopic-5"><pk>HTMX in Action: Integration With ApostropheCMS</pk></h3>

You now know what HTMX is, why it was created, and what it brings to the table.
All that remains is to see it in action in a real-world example.
What better way to do that than by integrating it with <a href="https://apostrophecms.com/" target="_blank">Apostrophe</a>? If you are not familiar with this technology, ApostropheCMS is an open-source CMS and website builder built on top of modern technologies such as MongoDB and Node.js.

The starting point will be the blog application built in the <a href="https://apostrophecms.com/blog/how-to-build-a-blog-apostrophe" target="_blank">“How</a><a href="https://apostrophecms.com/blog/how-to-build-a-blog-apostrophe" target="_blank"> to Build a Blog with the Apostrophe Blog Module”</a> tutorial.
You will learn how to add HTMX and use it to achieve the following dynamic interactions:


“Load More” functionality
Infinite scroll loading
Live content filtering 


Let’s dive in!

<h3 id="HTMXExamplestopic-6"> Getting Started</h3>

First, make sure to meet <a href="https://v3.docs.apostrophecms.org/guide/setting-up.html#system-requirements" target="_blank">ApostropheCMS's system requirements</a>.
Next, launch the command below to clone the <a href="https://github.com/Tonel/apostrophe-blog" target="_blank">GitHub repository of the blog application</a> you will soon extend with HTMX:

git clone https://github.com/Tonel/apostrophe-blog

Install the project’s dependencies:

npm install

Then, fire the following command to build the ApostropheCMS UI and start up the blog:

npm run dev

Open https://localhost:3000 in the browser and you should see:

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp09d1lv19ox9xoc1jrjwa00-apostrophe-ui-start-htmx-1.full.png" alt="HTMX Apostrophe UI">
 
<figcaption>

</figcaption>
 
</figure>

Follow the instructions, log in, and get familiar with the application.
Play with the UI and populate the blog with several posts.

You can then find the blog's home page at http://localhost:3000/blog.

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp09d1lk19ttapoch2rakdb0-htmx-blog-example-2.full.png" alt="htmx blog example">
 
<figcaption>

</figcaption>
 
</figure>

Great! If you want to learn more about how this application works and was built, take a look at our <a href="https://apostrophecms.com/blog/how-to-build-a-blog-apostrophe" target="_blank">tutorial</a>.

<h3 id="HTMXExamplestopic-7"> Integrating HTMX</h3>

<a href="https://htmx.org/docs/#installing" target="_blank">As stated in the documentation</a>, integrating HTMX into an application boils down to adding a &lt;script&gt; tag to the document &lt;head&gt;.
No build tools or special configurations are required.

The fastest way to get going is to load the library via a CDN:

&lt;script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"&gt;&lt;/script&gt;

The goal of this section is to use HTMX to add dynamic interactions to the blog home page.
So, you need to add the &lt;script&gt; instruction to the HTML document of that page.

To add HTMX to the blog home page, follow the /modules/@apostrophecms/blog-page/views/ path and open the index.html file.
Paste the following line after the title block:

{% block extraHead %}
&lt;script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"&gt;&lt;/script&gt;
{% endblock %}

extraHead is a block from the <a href="https://v3.docs.apostrophecms.org/guide/layout-template.html" target="_blank">ApostropheCMS core layout template</a> that allows you to add HTML elements at the end of the &lt;head&gt; tag.

If you instead want to have HTMX in all pages, you can add it to your project's dependencies with:

npm install htmx.org

Then, import it in the modules/asset/ui/src/index.js file:

import 'htmx.org';

export default () =&gt; {
// your own project-level JS...
};

Open http://localhost:3000/blog in the browser and inspect its source code.
You should see the following HTML:

&lt;!DOCTYPE html&gt;
&lt;html lang="en" &gt;
&lt;head&gt;
  &lt;link href="/apos-frontend/default/apos-bundle.css" rel="stylesheet" /&gt;
  &lt;title&gt;My Fantastic Blog &lt;/title&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
  &lt;script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;!-- Omitted for brevity...
--&gt;

Well done! The HTMX dependency script was added as required.

<h3 id="HTMXExamplestopic-8"> Adding a Load More Button With HTMX</h3>

Right now, when the blog has more than 10 posts, the home page shows a pagination element.

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp09cy6e19tlapocfhguis2c-htmx-blog-index-3.full.png" alt="htmx blog index">
 
<figcaption>

</figcaption>
 
</figure>

Click on one of these buttons, and you will be redirected to the selected page.
For example, “2” brings you to /blog?page=2.
What if you wanted to replace that interaction with a “Load More” button? Thanks to HTMX, that will take only a few lines of code!

When the “Load More” button is clicked, the page should perform an AJAX request to retrieve the HTML to render other blog post cards.
You could think of using HTMX to make the button target the /blog?page=2 endpoint and swap the current content with the retrieved HTML.
However, keep in mind that /blog?page=2 returns the entire HTML of a new page.
Following this approach is not recommended, as you ideally want to replace only a small portion of the page not the all the page.
Specifically, you want to swap the “Load More” button with the new blog post tabs.

To get close to the goal, you can take advantage of the <a href="https://v3.docs.apostrophecms.org/reference/api/pages.html#get-url-aposrefresh-1" target="_blank">aposRefresh=1</a> parameter.
This query parameter instructs ApostropheCMS to return the rendered HTML of the inner template, excluding the wrapping markup.

For example, the /blog?page=2&amp;aposRefresh=1 endpoint returns something like:

&lt;div class="bg-container"&gt;
&lt;h1 class="bg-h1"&gt;My Fantastic Blog&lt;/h1&gt;
&lt;h3&gt;Filters&lt;/h3&gt;
&lt;ul class="bg-filter-list"&gt;
  &lt;li&gt;
&lt;a href="/blog?year=2023"&gt;2023&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
&lt;a href="/blog?year=2022"&gt;2022&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
&lt;a href="/blog?year=2021"&gt;2021&lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
&lt;a class="is-active" href="/blog"&gt;All&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Blog post&lt;/h3&gt;
&lt;div class="bg-preview-card"&gt;
  &lt;div class="bg-preview-date"&gt;
Released on September 4, 2022
  &lt;/div&gt;
  &lt;div class="bg-preview-title"&gt;
&lt;a href="/blog/lorem-ipsum-8"&gt;Lorem Ipsum 8&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class="bg-preview-card"&gt;
  &lt;div class="bg-preview-date"&gt;
Released on August 2, 2022
  &lt;/div&gt;
  &lt;div class="bg-preview-title"&gt;
&lt;a href="/blog/lorem-ipsum-12"&gt;Lorem Ipsum 12&lt;/a&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;!-- Omitted for brevity...
--&gt;
&lt;/div&gt;

Much better! As you can see, this HTML involves only a partial section of the page.
At the same time, it still includes the title and filter elements.
To ignore them, you can change the index.html file so that it behaves differently based on the presence of a custom query parameter.

Achieve that by updating the rendering logic inside the main block of /modules/@apostrophecms/blog-page/views/index.html as follows:

{% block main %}
{% if data.query.showOnlyList != "1" %}
  &lt;div class="bg-container"&gt;
&lt;h1 class="bg-h1"&gt;{{ data.page.title }}&lt;/h1&gt;
&lt;h3&gt;{{ __t('aposBlog:filters') }}&lt;/h3&gt;

{% render filters.render({
   filters: data.piecesFilters,
   query: data.query,
   url: data.page._url
}) %}

&lt;h3&gt;{{ __t('aposBlog:pluralLabel') }}&lt;/h3&gt;

{{ renderBlogList() }}
  &lt;/div&gt;
{% else %}
  {{ renderBlogList() }}
{% endif %}
{% endblock %}

Now, when the showOnlyList=1 query parameter is present, the endpoint for the blog home page will return only the list of blog posts.
Otherwise, it will return the entire page as before.

You may be wondering what renderBlogList() is.
This is a custom <a href="https://mozilla.github.io/nunjucks/templating.html#macro" target="_blank">Nunjucks macro</a> that renders the list of blog post cards and the “Load More” button:

{% set page = data.query.page | default(1) | int %}
{% for piece in data.pieces %}
  &lt;div class="bg-preview-card"&gt;
&lt;div class="bg-preview-date"&gt;
{{ __t('aposBlog:releasedOn') }} {{ piece.publishedAt | date('MMMM D, YYYY') }}
&lt;/div&gt;
&lt;div class="bg-preview-title"&gt;
&lt;a href="{{ piece._url }}"&gt;{{ piece.title }}&lt;/a&gt;
&lt;/div&gt;
  &lt;/div&gt;
{% endfor %}
&lt;div class="load-more-div"&gt;
  {% if page != data.totalPages %}
&lt;button
hx-get="/blog?page={{page + 1}}&amp;year={{data.query.year}}&amp;showOnlyList=1&amp;aposRefresh=1"
hx-target=".load-more-div"
hx-swap="outerHTML"
&gt;
Load More
&lt;/button&gt;
  {% endif %}
&lt;/div&gt;
{% endmacro %}

Focus on the .load-more-div HTML element.
That is where the HTMX magic happens!

page is a variable that stores the current page of the blog posts to render.
If there are still some blogs to load, the “Load More” button is added to the page.
When the user clicks it, the webpage makes an AJAX request to the endpoint specified in hx-get.
This will return the rendered HTML with the list of the posts related to the next page, considering the optional year filter.
HTMX will then replace the outer HTML of the .load-more-div element with that content.

Put it all together, and you will get:

&lt;!-- /modules/@apostrophecms/blog-page/views/index.html --&gt;

{% extends data.outerLayout %}

{% import "filters.html" as filters %}
{% import "@apostrophecms/pager:macros.html" as pager with context %}

{% block title %}{{ data.page.title }} {% endblock %}

{% block extraHead %}
&lt;script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"&gt;&lt;/script&gt;
{% endblock %}

{% macro renderBlogList() %}
{% set page = data.query.page | default(1) | int %}
{% for piece in data.pieces %}
  &lt;div class="bg-preview-card"&gt;
&lt;div class="bg-preview-date"&gt;
{{ __t('aposBlog:releasedOn') }} {{ piece.publishedAt | date('MMMM D, YYYY') }}
&lt;/div&gt;
&lt;div class="bg-preview-title"&gt;
&lt;a href="{{ piece._url }}"&gt;{{ piece.title }}&lt;/a&gt;
&lt;/div&gt;
  &lt;/div&gt;
{% endfor %}
&lt;div class="load-more-div"&gt;
  {% if page != data.totalPages %}
&lt;button
hx-get="/blog?page={{page + 1}}&amp;year={{data.query.year}}&amp;showOnlyList=1&amp;aposRefresh=1"
hx-target=".load-more-div"
hx-swap="outerHTML"
&gt;
Load More
&lt;/button&gt;
  {% endif %}
&lt;/div&gt;
{% endmacro %}

{% block main %}
{% if data.query.showOnlyList != "1" %}
  &lt;div class="bg-container"&gt;
&lt;h1 class="bg-h1"&gt;{{ data.page.title }}&lt;/h1&gt;
&lt;h3&gt;{{ __t('aposBlog:filters') }}&lt;/h3&gt;

{% render filters.render({
   filters: data.piecesFilters,
   query: data.query,
   url: data.page._url
}) %}

&lt;h3&gt;{{ __t('aposBlog:pluralLabel') }}&lt;/h3&gt;

{{ renderBlogList() }}
  &lt;/div&gt;
{% else %}
  {{ renderBlogList() }}
{% endif %}
{% endblock %}

Note that the pagination element has been removed by the template.
You no longer need it.

Style the “Load More” button in /modules/asset/ui/src/scss/_blog.scss, and you are ready to test it.
This is how your new http://localhost:3000/blog page behaves:

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp35f1ot01xntzocw8v7jab6-htmx-load-more-function-4.full.gif" alt="">
 
<figcaption>

</figcaption>
 
</figure>

If you inspect the “Network” section of the browser's DevTools, you will notice that the “Load More” button triggers the following AJAX call:

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp09cyne19oq9xocipkqx39a-htmx-dev-tools-5.full.png" alt="htmx dev tools">
 
<figcaption>

</figcaption>
 
</figure>

This will return the HTML containing the new blog post cards to add to the page.

Congrats! You just used HTMX to add a click-to-load feature to your blog.

<b>Note</b>: You can find the entire code of this example in the htmx-load-more branch <a href="https://github.com/Tonel/apostrophe-blog/tree/htmx-load-more" target="_blank">of the GitHub repository supporting the article</a>.

<h3 id="HTMXExamplestopic-9"> Using HTMX to Implement Infinite Scrolling</h3>

Now that you have seen how to implement a “Load More” button with HTMX, achieving infinite scrolling is easy.
All you have to do is change the renderBlogList() function as follows:

{% macro renderBlogList() %}
{% set page = data.query.page | default(1) | int %}
{% for piece in data.pieces %}
  &lt;div class="bg-preview-card"
 {% if loop.last %}
   hx-get="/blog?page={{page + 1}}&amp;year={{data.query.year}}&amp;showOnlyList=1&amp;aposRefresh=1"
   hx-trigger="revealed"
   hx-swap="afterend"
 {% endif %}
  &gt;
&lt;div class="bg-preview-date"&gt;
{{ __t('aposBlog:releasedOn') }} {{ piece.publishedAt | date('MMMM D, YYYY') }}
&lt;/div&gt;
&lt;div class="bg-preview-title"&gt;
&lt;a href="{{ piece._url }}"&gt;{{ piece.title }}&lt;/a&gt;
&lt;/div&gt;
  &lt;/div&gt;
{% endfor %}
{% endmacro %}

The <a href="https://htmx.org/attributes/hx-trigger/" target="_blank">revealed</a> HTMX event triggers when an element is scrolled into the viewport.
By adding it to the last blog post card, you can implement infinite scroll loading behavior:

<figure>
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp73doub05kmtzocxahltgjd-htmx-viewport-6.full.gif" alt="">
 
<figcaption>

</figcaption>
 
</figure>

Awesome! Focus on the scrollbar to notice that the page adds dynamic content as the user scrolls down.

<b>Note</b>: You can find the complete code of this example in the htmx-infinite-scrolling branch.

<h3 id="HTMXExamplestopic-10"> Achieving Live Content Filtering Through HTMX</h3>

The goal here is to use HTMX to dynamically update the content of the page when clicking on a year filter button.
In this case, you do not have to update the blog post list, but replace it entirely.
Also, you need to override the HTML section that contains the filters to ensure that the correct button is enabled.

First, update filters.html to introduce the HTMX logic:

&lt;!-- /modules/@apostrophecms/blog-page/views/filters.html --&gt;

{%- macro here(url, changes) -%}
{{ url | build({
year: data.query.year
}, {
excludeContainer: 1,
aposRefresh: 1
}, changes) }}
{%- endmacro -%}

{% fragment render(data) %}
&lt;ul class="bg-filter-list"&gt;
  {% for year in data.filters.year %}
&lt;li&gt;
  &lt;button
class="{{ 'is-active' if data.query.year == year.value }}"
hx-get="{{ here(data.url, { year: year.value })}}"
hx-target=".blog-page"
hx-swap="outerHTML"
  &gt;
{{ __t(year.label) }}
  &lt;/button&gt;
&lt;/li&gt;
  {% endfor %}
&lt;/ul&gt;
{% endfragment %}

Note that the year filter elements are no longer links, but buttons that target a specific endpoint via HTMX.
In particular, here() has been updated to produce the URL required to dynamically retrieve the desired HTML content.
Keep in mind that build() accepts as many query parameter objects as you need.

The excludeContainer query parameter will control the rendering logic in the index.html file as below:

&lt;!-- /modules/@apostrophecms/blog-page/views/filters.html --&gt;

{% extends data.outerLayout %}

{% import "filters.html" as filters %}
{% import "@apostrophecms/pager:macros.html" as pager with context %}

{% block title %}{{ data.page.title }} {% endblock %}

{% block extraHead %}
&lt;script src="https://unpkg.com/htmx.org@1.9.6" integrity="sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni" crossorigin="anonymous"&gt;&lt;/script&gt;
{% endblock %}

{% block main %}
{% if data.query.excludeContainer != "1" %}
  &lt;div class="bg-container"&gt;
&lt;h1 class="bg-h1"&gt;{{ data.page.title }}&lt;/h1&gt;
{% endif %}
   &lt;div class="blog-page"&gt;
&lt;h3&gt;{{ __t('aposBlog:filters') }}&lt;/h3&gt;
{% render filters.render({
 filters: data.piecesFilters,
 query: data.query,
 url: data.page._url
}) %}
&lt;h3&gt;{{ __t('aposBlog:pluralLabel') }}&lt;/h3&gt;
{% for piece in data.pieces %}
  &lt;div class="bg-preview-card"&gt;
&lt;div class="bg-preview-date"&gt;
{{ __t('aposBlog:releasedOn') }} {{ piece.publishedAt | date('MMMM D, YYYY') }}
&lt;/div&gt;
&lt;div class="bg-preview-title"&gt;
&lt;a href="{{ piece._url }}"&gt;{{ piece.title }}&lt;/a&gt;
&lt;/div&gt;
  &lt;/div&gt;
{% endfor %}
&lt;div class="pagination"&gt;
  {{ pager.render({ page: data.currentPage, total: data.totalPages }, data.url | build({ excludeContainer: null })) }}
&lt;/div&gt;
&lt;/div&gt;
{% if data.query.excludeContainer != "1" %}
  &lt;/div&gt;
{% endif %}
{% endblock %}

The home page of the blog will now have real-time filtering capabilities:
  <img src="https://apos-website-prod.s3.us-east-1.amazonaws.com/attachments/clp74r07d05kyt7ocoeea7qwh-htmx-filtering-capabilities-7-1.full.gif" alt="">

Awesome! You have just learned how HTMX simplifies the integration of dynamic interactions into an existing frontend application.

The next step is to add a loader through the <a href="https://htmx.org/attributes/hx-indicator/" target="_blank">hx-indicator</a> attribute.
<a href="https://htmx.org/docs/" target="_blank">Check out the docs</a> to see all the other cool features HTMX has to offer!

<b>Note</b>: You can find the entire code of the example in the htmx-content-filtering branch.

<h2>Htmx Reference</h2>
<br>
<div id="HtmxReferencetoc" class="toc"><a href="#HtmxReferencetopic-0" target="_self" onclick="jumpto(0)"><pk>Core Attribute Reference</pk></a><br><a href="#HtmxReferencetopic-1" target="_self" onclick="jumpto(1)"><pk>Additional Attribute Reference</pk></a><br><a href="#HtmxReferencetopic-2" target="_self" onclick="jumpto(2)"><pk>CSS Class Reference</pk></a><br><a href="#HtmxReferencetopic-3" target="_self" onclick="jumpto(3)"><pk>HTTP Header Reference</pk></a><br><a href="#HtmxReferencetopic-4" target="_self" onclick="jumpto(4)"> Request Headers Reference</a><br><a href="#HtmxReferencetopic-5" target="_self" onclick="jumpto(5)"> Response Headers Reference</a><br><a href="#HtmxReferencetopic-6" target="_self" onclick="jumpto(6)"><pk>Event Reference</pk></a><br><a href="#HtmxReferencetopic-7" target="_self" onclick="jumpto(7)"><pk>JavaScript API Reference</pk></a><br><a href="#HtmxReferencetopic-8" target="_self" onclick="jumpto(8)"><pk>Configuration Reference</pk></a><br></div></center>
<h3 id="HtmxReferencetopic-0"><pk>Core Attribute Reference</pk></h3> 
The most common attributes when using htmx.
<a href="https://htmx.org/attributes/hx-get/"><gr>hx-get</gr></a>
issues a <gr>GET</gr> to the specified URL
<a href="https://htmx.org/attributes/hx-post/"><gr>hx-post</gr></a>
issues a <gr>POST</gr> to the specified URL
<a href="https://htmx.org/attributes/hx-on/"><gr>hx-on*</gr></a>
handle events with inline scripts on elements
<a href="https://htmx.org/attributes/hx-push-url/"><gr>hx-push-url</gr></a>
push a URL into the browser location bar to create history
<a href="https://htmx.org/attributes/hx-select/"><gr>hx-select</gr></a>
select content to swap in from a response
<a href="https://htmx.org/attributes/hx-select-oob/"><gr>hx-select-oob</gr></a>
select content to swap in from a response, somewhere other than the target (out of band)
<a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a>
controls how content will swap in (<gr>outerHTML</gr>, <gr>beforeend</gr>, <gr>afterend</gr>, …)
<a href="https://htmx.org/attributes/hx-swap-oob/"><gr>hx-swap-oob</gr></a>
mark element to swap in from a response (out of band)
<a href="https://htmx.org/attributes/hx-target/"><gr>hx-target</gr></a>
specifies the target element to be swapped
<a href="https://htmx.org/attributes/hx-trigger/"><gr>hx-trigger</gr></a>
specifies the event that triggers the request
<a href="https://htmx.org/attributes/hx-vals/"><gr>hx-vals</gr></a>
add values to submit with the request (JSON format)

<h3 id="HtmxReferencetopic-1"><pk>Additional Attribute Reference</pk></h3> 
All other attributes available in htmx.

<a href="https://htmx.org/attributes/hx-boost/"><gr>hx-boost</gr></a>
add <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Progressive_enhancement">progressive enhancement</a> for links and forms
<a href="https://htmx.org/attributes/hx-confirm/"><gr>hx-confirm</gr></a>
shows a <gr>confirm()</gr> dialog before issuing a request
<a href="https://htmx.org/attributes/hx-delete/"><gr>hx-delete</gr></a>
issues a <gr>DELETE</gr> to the specified URL
<a href="https://htmx.org/attributes/hx-disable/"><gr>hx-disable</gr></a>
disables htmx processing for the given node and any children nodes
<a href="https://htmx.org/attributes/hx-disabled-elt/"><gr>hx-disabled-elt</gr></a>
adds the <gr>disabled</gr> attribute to the specified elements while a request is in flight
<a href="https://htmx.org/attributes/hx-disinherit/"><gr>hx-disinherit</gr></a>
control and disable automatic attribute inheritance for child nodes
<a href="https://htmx.org/attributes/hx-encoding/"><gr>hx-encoding</gr></a>
changes the request encoding type
<a href="https://htmx.org/attributes/hx-ext/"><gr>hx-ext</gr></a>
extensions to use for this element
<a href="https://htmx.org/attributes/hx-headers/"><gr>hx-headers</gr></a>
adds to the headers that will be submitted with the request
<a href="https://htmx.org/attributes/hx-history/"><gr>hx-history</gr></a>
prevent sensitive data being saved to the history cache
<a href="https://htmx.org/attributes/hx-history-elt/"><gr>hx-history-elt</gr></a>
the element to snapshot and restore during history navigation
<a href="https://htmx.org/attributes/hx-include/"><gr>hx-include</gr></a>
include additional data in requests
<a href="https://htmx.org/attributes/hx-indicator/"><gr>hx-indicator</gr></a>
the element to put the <gr>htmx-request</gr> class on during the request
<a href="https://htmx.org/attributes/hx-inherit/"><gr>hx-inherit</gr></a>
control and enable automatic attribute inheritance for child nodes if it has been disabled by default
<a href="https://htmx.org/attributes/hx-params/"><gr>hx-params</gr></a>
filters the parameters that will be submitted with a request
<a href="https://htmx.org/attributes/hx-patch/"><gr>hx-patch</gr></a>
issues a <gr>PATCH</gr> to the specified URL
<a href="https://htmx.org/attributes/hx-preserve/"><gr>hx-preserve</gr></a>
specifies elements to keep unchanged between requests
<a href="https://htmx.org/attributes/hx-prompt/"><gr>hx-prompt</gr></a>
shows a <gr>prompt()</gr> before submitting a request
<a href="https://htmx.org/attributes/hx-put/"><gr>hx-put</gr></a>
issues a <gr>PUT</gr> to the specified URL
<a href="https://htmx.org/attributes/hx-replace-url/"><gr>hx-replace-url</gr></a>
replace the URL in the browser location bar
<a href="https://htmx.org/attributes/hx-request/"><gr>hx-request</gr></a>
configures various aspects of the request
<a href="https://htmx.org/attributes/hx-sync/"><gr>hx-sync</gr></a>
control how requests made by different elements are synchronized
<a href="https://htmx.org/attributes/hx-validate/"><gr>hx-validate</gr></a>
force elements to validate themselves before a request
<a href="https://htmx.org/attributes/hx-vars/"><gr>hx-vars</gr></a>
adds values dynamically to the parameters to submit with the request (deprecated, please use <a href="https://htmx.org/attributes/hx-vals/"><gr>hx-vals</gr></a>)

<h3 id="HtmxReferencetopic-2"><pk>CSS Class Reference</pk></h3> 

<gr>htmx-added</gr>
Applied to a new piece of content before it is swapped, removed after it is settled.
<gr>htmx-indicator</gr>
A dynamically generated class that will toggle visible (opacity:1) when a <gr>htmx-request</gr> class is present
<gr>htmx-request</gr>
Applied to either the element or the element specified with <a href="https://htmx.org/attributes/hx-indicator/"><gr>hx-indicator</gr></a> while a request is ongoing
<gr>htmx-settling</gr>
Applied to a target after content is swapped, removed after it is settled. The duration can be modified via <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a>.
<gr>htmx-swapping</gr>
Applied to a target before any content is swapped, removed after it is swapped. The duration can be modified via <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a>.

<h3 id="HtmxReferencetopic-3"><pk>HTTP Header Reference</pk></h3> 
<h3 id="HtmxReferencetopic-4"> Request Headers Reference</h3> 

<gr>HX-Boosted</gr>
indicates that the request is via an element using <a href="https://htmx.org/attributes/hx-boost/">hx-boost</a>
<gr>HX-Current-URL</gr>
the current URL of the browser
<gr>HX-History-Restore-Request</gr>
“true” if the request is for history restoration after a miss in the local history cache
<gr>HX-Prompt</gr>
the user response to an <a href="https://htmx.org/attributes/hx-prompt/">hx-prompt</a>
<gr>HX-Request</gr>
always “true”
<gr>HX-Target</gr>
the <gr>id</gr> of the target element if it exists
<gr>HX-Trigger-Name</gr>
the <gr>name</gr> of the triggered element if it exists
<gr>HX-Trigger</gr>
the <gr>id</gr> of the triggered element if it exists

<h3 id="HtmxReferencetopic-5"> Response Headers Reference</h3> 

<a href="https://htmx.org/headers/hx-location/"><gr>HX-Location</gr></a>
allows you to do a client-side redirect that does not do a full page reload
<a href="https://htmx.org/headers/hx-push-url/"><gr>HX-Push-Url</gr></a>
pushes a new url into the history stack
<gr>HX-Redirect</gr>
can be used to do a client-side redirect to a new location
<gr>HX-Refresh</gr>
if set to “true” the client-side will do a full refresh of the page
<a href="https://htmx.org/headers/hx-replace-url/"><gr>HX-Replace-Url</gr></a>
replaces the current URL in the location bar
<gr>HX-Reswap</gr>
allows you to specify how the response will be swapped. See <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> for possible values
<gr>HX-Retarget</gr>
a CSS selector that updates the target of the content update to a different element on the page
<gr>HX-Reselect</gr>
a CSS selector that allows you to choose which part of the response is used to be swapped in. Overrides an existing <a href="https://htmx.org/attributes/hx-select/"><gr>hx-select</gr></a> on the triggering element
<a href="https://htmx.org/headers/hx-trigger/"><gr>HX-Trigger</gr></a>
allows you to trigger client-side events
<a href="https://htmx.org/headers/hx-trigger/"><gr>HX-Trigger-After-Settle</gr></a>
allows you to trigger client-side events after the settle step
<a href="https://htmx.org/headers/hx-trigger/"><gr>HX-Trigger-After-Swap</gr></a>
allows you to trigger client-side events after the swap step

<h3 id="HtmxReferencetopic-6"><pk>Event Reference</pk></h3> 

<a href="https://htmx.org/events/#htmx:abort"><gr>htmx:abort</gr></a>
send this event to an element to abort a request
<a href="https://htmx.org/events/#htmx:afterOnLoad"><gr>htmx:afterOnLoad</gr></a>
triggered after an AJAX request has completed processing a successful response
<a href="https://htmx.org/events/#htmx:afterProcessNode"><gr>htmx:afterProcessNode</gr></a>
triggered after htmx has initialized a node
<a href="https://htmx.org/events/#htmx:afterRequest"><gr>htmx:afterRequest</gr></a>
triggered after an AJAX request has completed
<a href="https://htmx.org/events/#htmx:afterSettle"><gr>htmx:afterSettle</gr></a>
triggered after the DOM has settled
<a href="https://htmx.org/events/#htmx:afterSwap"><gr>htmx:afterSwap</gr></a>
triggered after new content has been swapped in
<a href="https://htmx.org/events/#htmx:beforeCleanupElement"><gr>htmx:beforeCleanupElement</gr></a>
triggered before htmx <a href="https://htmx.org/attributes/hx-disable/">disables</a> an element or removes it from the DOM
<a href="https://htmx.org/events/#htmx:beforeOnLoad"><gr>htmx:beforeOnLoad</gr></a>
triggered before any response processing occurs
<a href="https://htmx.org/events/#htmx:beforeProcessNode"><gr>htmx:beforeProcessNode</gr></a>
triggered before htmx initializes a node
<a href="https://htmx.org/events/#htmx:beforeRequest"><gr>htmx:beforeRequest</gr></a>
triggered before an AJAX request is made
<a href="https://htmx.org/events/#htmx:beforeSwap"><gr>htmx:beforeSwap</gr></a>
triggered before a swap is done, allows you to configure the swap
<a href="https://htmx.org/events/#htmx:beforeSend"><gr>htmx:beforeSend</gr></a>
triggered just before an ajax request is sent
<a href="https://htmx.org/events/#htmx:configRequest"><gr>htmx:configRequest</gr></a>
triggered before the request, allows you to customize parameters, headers
<a href="https://htmx.org/events/#htmx:confirm"><gr>htmx:confirm</gr></a>
triggered after a trigger occurs on an element, allows you to cancel (or delay) issuing the AJAX request
<a href="https://htmx.org/events/#htmx:historyCacheError"><gr>htmx:historyCacheError</gr></a>
triggered on an error during cache writing
<a href="https://htmx.org/events/#htmx:historyCacheMiss"><gr>htmx:historyCacheMiss</gr></a>
triggered on a cache miss in the history subsystem
<a href="https://htmx.org/events/#htmx:historyCacheMissError"><gr>htmx:historyCacheMissError</gr></a>
triggered on a unsuccessful remote retrieval
<a href="https://htmx.org/events/#htmx:historyCacheMissLoad"><gr>htmx:historyCacheMissLoad</gr></a>
triggered on a successful remote retrieval
<a href="https://htmx.org/events/#htmx:historyRestore"><gr>htmx:historyRestore</gr></a>
triggered when htmx handles a history restoration action
<a href="https://htmx.org/events/#htmx:beforeHistorySave"><gr>htmx:beforeHistorySave</gr></a>
triggered before content is saved to the history cache
<a href="https://htmx.org/events/#htmx:load"><gr>htmx:load</gr></a>
triggered when new content is added to the DOM
<a href="https://htmx.org/events/#htmx:noSSESourceError"><gr>htmx:noSSESourceError</gr></a>
triggered when an element refers to a SSE event in its trigger, but no parent SSE source has been defined
<a href="https://htmx.org/events/#htmx:onLoadError"><gr>htmx:onLoadError</gr></a>
triggered when an exception occurs during the onLoad handling in htmx
<a href="https://htmx.org/events/#htmx:oobAfterSwap"><gr>htmx:oobAfterSwap</gr></a>
triggered after an out of band element as been swapped in
<a href="https://htmx.org/events/#htmx:oobBeforeSwap"><gr>htmx:oobBeforeSwap</gr></a>
triggered before an out of band element swap is done, allows you to configure the swap
<a href="https://htmx.org/events/#htmx:oobErrorNoTarget"><gr>htmx:oobErrorNoTarget</gr></a>
triggered when an out of band element does not have a matching ID in the current DOM
<a href="https://htmx.org/events/#htmx:prompt"><gr>htmx:prompt</gr></a>
triggered after a prompt is shown
<a href="https://htmx.org/events/#htmx:pushedIntoHistory"><gr>htmx:pushedIntoHistory</gr></a>
triggered after an url is pushed into history
<a href="https://htmx.org/events/#htmx:responseError"><gr>htmx:responseError</gr></a>
triggered when an HTTP response error (non-<gr>200</gr> or <gr>300</gr> response code) occurs
<a href="https://htmx.org/events/#htmx:sendError"><gr>htmx:sendError</gr></a>
triggered when a network error prevents an HTTP request from happening
<a href="https://htmx.org/events/#htmx:sseError"><gr>htmx:sseError</gr></a>
triggered when an error occurs with a SSE source
<a href="/events#htmx:sseOpen"><gr>htmx:sseOpen</gr></a>
triggered when a SSE source is opened
<a href="https://htmx.org/events/#htmx:swapError"><gr>htmx:swapError</gr></a>
triggered when an error occurs during the swap phase
<a href="https://htmx.org/events/#htmx:targetError"><gr>htmx:targetError</gr></a>
triggered when an invalid target is specified
<a href="https://htmx.org/events/#htmx:timeout"><gr>htmx:timeout</gr></a>
triggered when a request timeout occurs
<a href="https://htmx.org/events/#htmx:validation:validate"><gr>htmx:validation:validate</gr></a>
triggered before an element is validated
<a href="https://htmx.org/events/#htmx:validation:failed"><gr>htmx:validation:failed</gr></a>
triggered when an element fails validation
<a href="https://htmx.org/events/#htmx:validation:halted"><gr>htmx:validation:halted</gr></a>
triggered when a request is halted due to validation errors
<a href="https://htmx.org/events/#htmx:xhr:abort"><gr>htmx:xhr:abort</gr></a>
triggered when an ajax request aborts
<a href="https://htmx.org/events/#htmx:xhr:loadend"><gr>htmx:xhr:loadend</gr></a>
triggered when an ajax request ends
<a href="https://htmx.org/events/#htmx:xhr:loadstart"><gr>htmx:xhr:loadstart</gr></a>
triggered when an ajax request starts
<a href="https://htmx.org/events/#htmx:xhr:progress"><gr>htmx:xhr:progress</gr></a>
triggered periodically during an ajax request that supports progress events

<h3 id="HtmxReferencetopic-7"><pk>JavaScript API Reference</pk></h3> 

<a href="https://htmx.org/api/#addClass"><gr>htmx.addClass()</gr></a>
Adds a class to the given element
<a href="https://htmx.org/api/#ajax"><gr>htmx.ajax()</gr></a>
Issues an htmx-style ajax request
<a href="https://htmx.org/api/#closest"><gr>htmx.closest()</gr></a>
Finds the closest parent to the given element matching the selector
<a href="https://htmx.org/api/#config"><gr>htmx.config</gr></a>
A property that holds the current htmx config object
<a href="https://htmx.org/api/#createEventSource"><gr>htmx.createEventSource</gr></a>
A property holding the function to create SSE EventSource objects for htmx
<a href="https://htmx.org/api/#createWebSocket"><gr>htmx.createWebSocket</gr></a>
A property holding the function to create WebSocket objects for htmx
<a href="https://htmx.org/api/#defineExtension"><gr>htmx.defineExtension()</gr></a>
Defines an htmx <a rel="noopener" target="_blank" href="https://extensions.htmx.org">extension</a>
<a href="https://htmx.org/api/#find"><gr>htmx.find()</gr></a>
Finds a single element matching the selector
<a href="https://htmx.org/api/#find"><gr>htmx.findAll()</gr> <gr>htmx.findAll(elt, selector)</gr></a>
Finds all elements matching a given selector
<a href="https://htmx.org/api/#logAll"><gr>htmx.logAll()</gr></a>
Installs a logger that will log all htmx events
<a href="https://htmx.org/api/#logger"><gr>htmx.logger</gr></a>
A property set to the current logger (default is <gr>null</gr>)
<a href="https://htmx.org/api/#off"><gr>htmx.off()</gr></a>
Removes an event listener from the given element
<a href="https://htmx.org/api/#on"><gr>htmx.on()</gr></a>
Creates an event listener on the given element, returning it
<a href="https://htmx.org/api/#onLoad"><gr>htmx.onLoad()</gr></a>
Adds a callback handler for the <gr>htmx:load</gr> event
<a href="https://htmx.org/api/#parseInterval"><gr>htmx.parseInterval()</gr></a>
Parses an interval declaration into a millisecond value
<a href="https://htmx.org/api/#process"><gr>htmx.process()</gr></a>
Processes the given element and its children, hooking up any htmx behavior
<a href="https://htmx.org/api/#remove"><gr>htmx.remove()</gr></a>
Removes the given element
<a href="https://htmx.org/api/#removeClass"><gr>htmx.removeClass()</gr></a>
Removes a class from the given element
<a href="https://htmx.org/api/#removeExtension"><gr>htmx.removeExtension()</gr></a>
Removes an htmx <a rel="noopener" target="_blank" href="https://extensions.htmx.org">extension</a>
<a href="https://htmx.org/api/#swap"><gr>htmx.swap()</gr></a>
Performs swapping (and settling) of HTML content
<a href="https://htmx.org/api/#takeClass"><gr>htmx.takeClass()</gr></a>
Takes a class from other elements for the given element
<a href="https://htmx.org/api/#toggleClass"><gr>htmx.toggleClass()</gr></a>
Toggles a class from the given element
<a href="https://htmx.org/api/#trigger"><gr>htmx.trigger()</gr></a>
Triggers an event on an element
<a href="https://htmx.org/api/#values"><gr>htmx.values()</gr></a>
Returns the input values associated with the given element

<h3 id="HtmxReferencetopic-8"><pk>Configuration Reference</pk></h3> 
Htmx has some configuration options that can be accessed either programmatically or declaratively.  They are
listed below:

<gr>htmx.config.historyEnabled</gr>
defaults to <gr>true</gr>, really only useful for testing
<gr>htmx.config.historyCacheSize</gr>
defaults to 10
<gr>htmx.config.refreshOnHistoryMiss</gr>
defaults to <gr>false</gr>, if set to <gr>true</gr> htmx will issue a full page refresh on history misses rather than use an AJAX request
<gr>htmx.config.defaultSwapStyle</gr>
defaults to <gr>innerHTML</gr>
<gr>htmx.config.defaultSwapDelay</gr>
defaults to 0
<gr>htmx.config.defaultSettleDelay</gr>
defaults to 20
<gr>htmx.config.includeIndicatorStyles</gr>
defaults to <gr>true</gr> (determines if the indicator styles are loaded)
<gr>htmx.config.indicatorClass</gr>
defaults to <gr>htmx-indicator</gr>
<gr>htmx.config.requestClass</gr>
defaults to <gr>htmx-request</gr>
<gr>htmx.config.addedClass</gr>
defaults to <gr>htmx-added</gr>
<gr>htmx.config.settlingClass</gr>
defaults to <gr>htmx-settling</gr>
<gr>htmx.config.swappingClass</gr>
defaults to <gr>htmx-swapping</gr>
<gr>htmx.config.allowEval</gr>
defaults to <gr>true</gr>, can be used to disable htmx’s use of eval for certain features (e.g. trigger filters)
<gr>htmx.config.allowScriptTags</gr>
defaults to <gr>true</gr>, determines if htmx will process script tags found in new content
<gr>htmx.config.inlineScriptNonce</gr>
defaults to <gr>''</gr>, meaning that no nonce will be added to inline scripts
<gr>htmx.config.inlineSlyeNonce</gr>
defaults to <gr>''</gr>, meaning that no nonce will be added to inline styles
<gr>htmx.config.attributesToSettle</gr>
defaults to <gr>["class", "style", "width", "height"]</gr>, the attributes to settle during the settling phase
<gr>htmx.config.wsReconnectDelay</gr>
defaults to <gr>full-jitter</gr>
<gr>htmx.config.wsBinaryType</gr>
defaults to <gr>blob</gr>, the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/WebSocket/binaryType">the type of binary data</a> being received over the WebSocket connection
<gr>htmx.config.disableSelector</gr>
defaults to <gr>[hx-disable], [data-hx-disable]</gr>, htmx will not process elements with this attribute on it or a parent
<gr>htmx.config.withCredentials</gr>
defaults to <gr>false</gr>, allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates
<gr>htmx.config.timeout</gr>
defaults to 0, the number of milliseconds a request can take before automatically being terminated
<gr>htmx.config.scrollBehavior</gr>
defaults to ‘instant’, the behavior for a boosted link on page transitions. The allowed values are <gr>auto</gr>, <gr>instant</gr> and <gr>smooth</gr>. Instant will scroll instantly in a single jump, smooth will scroll smoothly, while auto will behave like a vanilla link.
<gr>htmx.config.defaultFocusScroll</gr>
if the focused element should be scrolled into view, defaults to false and can be overridden using the <a href="https://htmx.org/attributes/hx-swap/#focus-scroll">focus-scroll</a> swap modifier.
<gr>htmx.config.getCacheBusterParam</gr>
defaults to false, if set to true htmx will append the target element to the <gr>GET</gr> request in the format <gr>org.htmx.cache-buster=targetElementId</gr>
<gr>htmx.config.globalViewTransitions</gr>
if set to <gr>true</gr>, htmx will use the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">View Transition</a> API when swapping in new content.
<gr>htmx.config.methodsThatUseUrlParams</gr>
defaults to <gr>["get"]</gr>, htmx will format requests with these methods by encoding their parameters in the URL, not the request body
<gr>htmx.config.selfRequestsOnly</gr>
defaults to <gr>true</gr>, whether to only allow AJAX requests to the same domain as the current document
<gr>htmx.config.ignoreTitle</gr>
defaults to <gr>false</gr>, if set to <gr>true</gr> htmx will not update the title of the document when a <gr>title</gr> tag is found in new content
<gr>htmx.config.scrollIntoViewOnBoost</gr>
defaults to <gr>true</gr>, whether or not the target of a boosted element is scrolled into the viewport. If <gr>hx-target</gr> is omitted on a boosted element, the target defaults to <gr>body</gr>, causing the page to scroll to the top.
<gr>htmx.config.triggerSpecsCache</gr>
defaults to <gr>null</gr>, the cache to store evaluated trigger specifications into, improving parsing performance at the cost of more memory usage. You may define a simple object to use a never-clearing cache, or implement your own system using a <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy object</a>
<gr>htmx.config.allowNestedOobSwaps</gr>
defaults to <gr>true</gr>, whether to process OOB swaps on elements that are nested within the main response element. See <a href="https://htmx.org/attributes/hx-swap-oob/#nested-oob-swaps">Nested OOB Swaps</a>.

You can set them directly in javascript, or you can use a <gr>meta</gr> tag:
<gr>&lt;meta name="htmx-config" content='{"defaultSwapStyle":"outerHTML"}'></gr>

    
<h2><pk>hx-boost</pk></h2>
The <gr>hx-boost</gr> attribute allows you to “boost” normal anchors and form tags to use AJAX instead.
This has the <a rel="noopener" target="_blank" href="https://en.wikipedia.org/wiki/Progressive_enhancement">nice fallback</a> that, if the user does not have javascript enabled, the site will continue to work.
For anchor tags, clicking on the anchor will issue a <gr>GET</gr> request to the url specified in the <gr>href</gr> and will push the url so that a history entry is created.
The target is the <gr>&lt;body></gr> tag, and the <gr>innerHTML</gr> swap strategy is used by default.
All of these can be modified by using the appropriate attributes, except the <gr>click</gr> trigger.
For forms the request will be converted into a <gr>GET</gr> or <gr>POST</gr>, based on the method in the <gr>method</gr> attribute and will be triggered by a <gr>submit</gr>.
Again, the target will be the <gr>body</gr> of the page, and the <gr>innerHTML</gr> swap will be used.
The url will <em>not</em> be pushed, however, and no history entry will be created.
(You can use the 
<a href="https://htmx.org/attributes/hx-push-url/">hx-push-url</a> attribute if you want the url to be pushed.)
Here is an example of some boosted links:
<gr>&lt;div hx-boost="true">
  &lt;a href="/page1">Go To Page 1&lt;/a>
  &lt;a href="/page2">Go To Page 2&lt;/a>
&lt;/div></gr>

These links will issue an ajax <gr>GET</gr> request to the respective URLs and replace the body’s inner content with it.
Here is an example of a boosted form:
<gr>&lt;form hx-boost="true" action="/example" method="post">
    &lt;input name="email" type="email" placeholder="Enter email...">
    &lt;button>Submit&lt;/button>
&lt;/form></gr>

This form will issue an ajax <gr>POST</gr> to the given URL and replace the body’s inner content with it.
<h2>&emsp;Notes</h2>
<gr>hx-boost</gr> is inherited and can be placed on a parent element Only links that are to the same domain and that are not local anchors will be boosted All requests are done via AJAX, so keep that in mind when doing things like redirects To find out if the request results from a boosted anchor or form, look for <a href="https://htmx.org/reference/#request_headers"><gr>HX-Boosted</gr></a> in the request header Selectively disable boost on child elements with <gr>hx-boost="false"</gr>

Disable the replacement of elements via boost, and their children, with <a href="https://htmx.org/attributes/hx-preserve/"><gr>hx-preserve="true"</gr></a>

<h2><pk>hx-confirm</pk></h2>
The <gr>hx-confirm</gr> attribute allows you to confirm an action before issuing a request.
This can be useful in cases where the action is destructive and you want to ensure that the user really wants to do it.
Here is an example:
<gr>&lt;button hx-delete="/account" hx-confirm="Are you sure you wish to delete your account?">
  Delete My Account
&lt;/button></gr>

<h2>&emsp;Event details</h2>
The event triggered by <gr>hx-confirm</gr> contains additional properties in its <gr>detail</gr>:

triggeringEvent: the event that triggered the original request issueRequest(skipConfirmation=false): a callback which can be used to confirm the AJAX request question: the value of the <gr>hx-confirm</gr> attribute on the HTML element

<h2>&emsp;Notes</h2>
<gr>hx-confirm</gr> is inherited and can be placed on a parent element

<gr>hx-confirm</gr> uses the browser’s <gr>window.confirm</gr> by default.
You can customize this behavior as shown <a href="https://htmx.org/examples/confirm/">in this example</a>.
a boolean <gr>skipConfirmation</gr> can be passed to the <gr>issueRequest</gr> callback; if true (defaults to false), the <gr>window.confirm</gr> will not be called and the AJAX request is issued directly
<h2><pk>hx-delete</pk></h2>
The <gr>hx-delete</gr> attribute will cause an element to issue a <gr>DELETE</gr> to the specified URL and swap the HTML into the DOM using a swap strategy:
<gr>&lt;button hx-delete="/account" hx-target="body">
  Delete Your Account
&lt;/button></gr>

This example will cause the <gr>button</gr> to issue a <gr>DELETE</gr> to <gr>/account</gr> and swap the returned HTML into the <gr>innerHTML</gr> of the <gr>body</gr>.
<h2>&emsp;Notes</h2>
<gr>hx-delete</gr> is not inherited You can control the target of the swap using the <a href="https://htmx.org/attributes/hx-target/">hx-target</a> attribute You can control the swap strategy by using the <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> attribute You can control what event triggers the request with the <a href="https://htmx.org/attributes/hx-trigger/">hx-trigger</a> attribute You can control the data submitted with the request in various ways, documented here: <a href="https://htmx.org/docs/#parameters">Parameters</a>

To remove the element following a successful <gr>DELETE</gr>, return a <gr>200</gr> status code with an empty body; if the server responds with a <gr>204</gr>, no swap takes place, documented here: <a href="https://htmx.org/docs/#requests">Requests &amp; Responses</a>

<h2><pk>hx-disable</pk></h2>
The <gr>hx-disable</gr> attribute will disable htmx processing for a given element and all its children.
This can be useful as a backup for HTML escaping, when you include user generated content in your site, and you want to prevent malicious scripting attacks.
The value of the tag is ignored, and it cannot be reversed by any content beneath it.
<h2>&emsp;Notes</h2>
<gr>hx-disable</gr> is inherited
<h2><pk>hx-disabled-elt</pk></h2>
The <gr>hx-disabled-elt</gr> attribute allows you to specify elements that will have the <gr>disabled</gr> attribute added to them for the duration of the request.
The value of this attribute can be:

A CSS query selector of the element to disable.

<gr>this</gr> to disable the element itself

<gr>closest &lt;CSS selector></gr> which will find the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/closest">closest</a> ancestor element or itself, that matches the given CSS selector
(e.g.
<gr>closest fieldset</gr> will disable the closest to the element <gr>fieldset</gr>).

<gr>find &lt;CSS selector></gr> which will find the first child descendant element that matches the given CSS selector

<gr>next</gr> which resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/nextElementSibling">element.nextElementSibling</a>


<gr>next &lt;CSS selector></gr> which will scan the DOM forward for the first element that matches the given CSS selector
(e.g.
<gr>next button</gr> will disable the closest following sibling <gr>button</gr> element)

<gr>previous</gr> which resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/previousElementSibling">element.previousElementSibling</a>


<gr>previous &lt;CSS selector></gr> which will scan the DOM backwards for the first element that matches the given CSS selector.
(e.g <gr>previous input</gr> will disable the closest previous sibling <gr>input</gr> element)

Here is an example with a button that will disable itself during a request:
<gr>&lt;button hx-post="/example" hx-disabled-elt="this">
    Post It!
&lt;/button></gr>

When a request is in flight, this will cause the button to be marked with <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/disabled">the <gr>disabled</gr> attribute</a>, which will prevent further clicks from occurring.
The <gr>hx-disabled-elt</gr> attribute also supports specifying multiple CSS selectors separated by commas to disable multiple elements during the request.
Here is an example that disables buttons and text input fields of a particular form during the request:
<gr>&lt;form hx-post="/example" hx-disabled-elt="find input[type='text'], find button">
    &lt;input type="text" placeholder="Type here...">
    &lt;button type="submit">Send&lt;/button>
&lt;/form></gr>

<h2>&emsp;Notes</h2>
<gr>hx-disabled-elt</gr> is inherited and can be placed on a parent element
<h2><pk>hx-disinherit</pk></h2>
The default behavior for htmx is to “inherit” many attributes automatically: that is, an attribute such as
<a href="https://htmx.org/attributes/hx-target/">hx-target</a> may be placed on a parent element, and all child elements will inherit that target.
The <gr>hx-disinherit</gr> attribute allows you to control this automatic attribute inheritance.
An example scenario is to allow you to place an <gr>hx-boost</gr> on the <gr>body</gr> element of a page, but overriding that behavior in a specific part of the page to allow for more specific behaviors.
htmx evaluates attribute inheritance as follows:

when <gr>hx-disinherit</gr> is set on a parent node


<gr>hx-disinherit="*"</gr> all attribute inheritance for this element will be disabled

<gr>hx-disinherit="hx-select hx-get hx-target"</gr> disable inheritance for only one or multiple specified attributes



<gr>&lt;div hx-boost="true" hx-select="#content" hx-target="#content" hx-disinherit="*">
  &lt;a href="/page1">Go To Page 1&lt;/a> &lt;!-- boosted with the attribute settings above -->
  &lt;a href="/page2" hx-boost="unset">Go To Page 1&lt;/a> &lt;!-- not boosted -->
  &lt;button hx-get="/test" hx-target="this">&lt;/button> &lt;!-- hx-select is not inherited -->
&lt;/div></gr>

<gr>&lt;div hx-boost="true" hx-select="#content" hx-target="#content" hx-disinherit="hx-target">
  &lt;!-- hx-select is automatically set to parent's value; hx-target is not inherited -->
  &lt;button hx-get="/test">&lt;/button>
&lt;/div></gr>

<gr>&lt;div hx-select="#content">
  &lt;div hx-boost="true" hx-target="#content" hx-disinherit="hx-select">
    &lt;!-- hx-target is automatically inherited from parent's value -->
    &lt;!-- hx-select is not inherited, because the direct parent does
    disables inheritance, despite not specifying hx-select itself -->
    &lt;button hx-get="/test">&lt;/button>
  &lt;/div>
&lt;/div></gr>

<h2>&emsp;Notes</h2>
Read more about <a href="https://htmx.org/docs/#inheritance">Attribute Inheritance</a>

<h2><pk>hx-encoding</pk></h2>
The <gr>hx-encoding</gr> attribute allows you to switch the request encoding from the usual <gr>application/x-www-form-urlencoded</gr> encoding to <gr>multipart/form-data</gr>, usually to support file uploads in an ajax request.
The value of this attribute should be <gr>multipart/form-data</gr>.
The <gr>hx-encoding</gr> tag may be placed on parent elements.
<h2>&emsp;Notes</h2>
<gr>hx-encoding</gr> is inherited and can be placed on a parent element
<h2><pk>hx-ext</pk></h2>
The <gr>hx-ext</gr> attribute enables an htmx <a rel="noopener" target="_blank" href="https://extensions.htmx.org">extension</a> for an element and all its children.
The value can be a single extension name or a comma separated list of extensions to apply.
The <gr>hx-ext</gr> tag may be placed on parent elements if you want a plugin to apply to an entire swath of the DOM,
and on the <gr>body</gr> tag for it to apply to all htmx requests.
<h2>&emsp;Notes</h2>
<gr>hx-ext</gr> is both inherited and merged with parent elements, so you can specify extensions on any element in the DOM hierarchy and it will apply to all child elements.



You can ignore an extension that is defined by a parent node using <gr>hx-ext="ignore:extensionName"</gr> 


<gr>&lt;div hx-ext="example">
  "Example" extension is used in this part of the tree...
  &lt;div hx-ext="ignore:example">
    ...
but it will not be used in this part.
  &lt;/div>
&lt;/div></gr>

<h2><pk>hx-get</pk></h2>
The <gr>hx-get</gr> attribute will cause an element to issue a <gr>GET</gr> to the specified URL and swap the HTML into the DOM using a swap strategy:
<gr>  &lt;div hx-get="/example">Get Some HTML&lt;/div></gr>

This example will cause the <gr>div</gr> to issue a <gr>GET</gr> to <gr>/example</gr> and swap the returned HTML into the <gr>innerHTML</gr> of the <gr>div</gr>.
<h3>&emsp;&emsp;Notes</h3>
<gr>hx-get</gr> is not inherited By default <gr>hx-get</gr> does not include any parameters.
You can use the <a href="https://htmx.org/attributes/hx-params/">hx-params</a> attribute to change this You can control the target of the swap using the <a href="https://htmx.org/attributes/hx-target/">hx-target</a> attribute You can control the swap strategy by using the <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> attribute You can control what event triggers the request with the <a href="https://htmx.org/attributes/hx-trigger/">hx-trigger</a> attribute You can control the data submitted with the request in various ways, documented here: <a href="https://htmx.org/docs/#parameters">Parameters</a>

An empty <gr>hx-get:""</gr> will make a get request to the current url and will swap the current HTML page 
<h2><pk>hx-headers</pk></h2>
The <gr>hx-headers</gr> attribute allows you to add to the headers that will be submitted with an AJAX request.
By default, the value of this attribute is a list of name-expression values in <a rel="noopener" target="_blank" href="https://www.json.org/json-en.html">JSON (JavaScript Object Notation)</a> format.
If you wish for <gr>hx-headers</gr> to <em>evaluate</em> the values given, you can prefix the values with <gr>javascript:</gr> or <gr>js:</gr>.
<gr>  &lt;div hx-get="/example" hx-headers='{"myHeader": "My Value"}'>Get Some HTML, Including A Custom Header in the Request&lt;/div></gr>

<h2>&emsp;Security Considerations</h2>
By default, the value of <gr>hx-headers</gr> must be valid <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Glossary/JSON">JSON</a>.

It is <strong>not</strong> dynamically computed.
If you use the <gr>javascript:</gr> prefix, be aware that you are introducing security considerations, especially when dealing with user input such as query strings or user-generated content, which could introduce a <a rel="noopener" target="_blank" href="https://owasp.org/www-community/attacks/xss/">Cross-Site Scripting (XSS)</a> vulnerability.


<h2>&emsp;Notes</h2>
<gr>hx-headers</gr> is inherited and can be placed on a parent element.
A child declaration of a header overrides a parent declaration.
<h2><pk>hx-history-elt</pk></h2>
The <gr>hx-history-elt</gr> attribute allows you to specify the element that will be used to snapshot and restore page state during navigation.
By default, the <gr>body</gr> tag is used.
This is typically good enough for most setups, but you may want to narrow it down to a child element.
Just make sure that the element is always visible in your application, or htmx will not be able to restore history navigation properly.
Here is an example:
<gr>&lt;html>
&lt;body>
&lt;div id="content" hx-history-elt>
 ...
&lt;/div>
&lt;/body>
&lt;/html></gr>

<h2>&emsp;Notes</h2>
<gr>hx-history-elt</gr> is not inherited In most cases we don’t recommend narrowing the history snapshot
<h2><pk>hx-history</pk></h2>
  Set the <gr>hx-history</gr> attribute to <gr>false</gr> on any element in the current document, or any html fragment loaded into the current document by htmx, to prevent sensitive data being saved to the localStorage cache when htmx takes a snapshot of the page state.

History navigation will work as expected, but on restoration the URL will be requested from the server instead of the history cache.
Here is an example:
<gr>&lt;html>
&lt;body>
&lt;div hx-history="false">
 ...
&lt;/div>
&lt;/body>
&lt;/html></gr>

<h2>&emsp;Notes</h2>
<gr>hx-history="false"</gr> can be present <em>anywhere</em> in the document to embargo the current page state from the history cache (i.e.
even outside the element specified for the history snapshot <a href="https://htmx.org/attributes/hx-history-elt/">hx-history-elt</a>).
<h2><pk>hx-include</pk></h2>
The <gr>hx-include</gr> attribute allows you to include additional element values in an AJAX request.
The value of this attribute can be:

A CSS query selector of the elements to include.

<gr>this</gr> which will include the descendants of the element.

<gr>closest &lt;CSS selector></gr> which will find the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/closest">closest</a> ancestor element or itself, that matches the given CSS selector
(e.g.
<gr>closest tr</gr> will target the closest table row to the element).

<gr>find &lt;CSS selector></gr> which will find the first child descendant element that matches the given CSS selector.

<gr>next &lt;CSS selector></gr> which will scan the DOM forward for the first element that matches the given CSS selector.
(e.g.
<gr>next .error</gr> will target the closest following sibling element with <gr>error</gr> class)

<gr>previous &lt;CSS selector></gr> which will scan the DOM backwards for the first element that matches the given CSS selector.
(e.g <gr>previous .error</gr> will target the closest previous sibling with <gr>error</gr> class)

Here is an example that includes a separate input value:
<gr>&lt;div>
    &lt;button hx-post="/register" hx-include="[name='email']">
        Register!
    &lt;/button>
    Enter email: &lt;input name="email" type="email"/>
&lt;/div></gr>

This is a little contrived as you would typically enclose both of these elements in a <gr>form</gr> and submit the value automatically, but it demonstrates the concept.
Note that if you include a non-input element, all input elements enclosed in that element will be included.
<h2>&emsp;Notes</h2>
<gr>hx-include</gr> is inherited and can be placed on a parent element While <gr>hx-include</gr> is inherited, it is evaluated from the element triggering the request.
It is easy to get confused when working with the extended selectors such as <gr>find</gr> and <gr>closest</gr>.<gr>&lt;div hx-include="find input">
    &lt;button hx-post="/register">
        Register!
    &lt;/button>
    Enter email: &lt;input name="email" type="email"/>
&lt;/div></gr>

In the above example, when clicking on the button, the <gr>find input</gr> selector is resolved from the button itself, which does not return any element here, since the button doesn’t have any <gr>input</gr> child, thus in this case, raises an error.
A standard CSS selector resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Document/querySelectorAll">document.querySelectorAll</a> and will include multiple elements, while the extended selectors such as <gr>find</gr> or <gr>next</gr> only return a single element at most to include
<h2><pk>hx-indicator</pk></h2>
The <gr>hx-indicator</gr> attribute allows you to specify the element that will have the <gr>htmx-request</gr> class added to it for the duration of the request.
This can be used to show spinners or progress indicators while the request is in flight.
The value of this attribute is a CSS query selector of the element or elements to apply the class to,
or the keyword <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/closest"><gr>closest</gr></a>, followed by a CSS selector, which will find the closest ancestor element or itself, that matches the given CSS selector (e.g.
<gr>closest tr</gr>);
Here is an example with a spinner adjacent to the button:
<gr>&lt;div>
    &lt;button hx-post="/example" hx-indicator="#spinner">
        Post It!
    &lt;/button>
    &lt;img  id="spinner" class="htmx-indicator" src="/img/bars.svg"/>
&lt;/div></gr>

When a request is in flight, this will cause the <gr>htmx-request</gr> class to be added to the <gr>#spinner</gr> image.
The image also has the <gr>htmx-indicator</gr> class on it, which defines an opacity transition that will show the spinner:
<gr>    .htmx-indicator{
        opacity:0;
        transition: opacity 500ms ease-in;
    }
    .htmx-request .htmx-indicator{
        opacity:1
    }
    .htmx-request.htmx-indicator{
        opacity:1
    }</gr>

If you would prefer a different effect for showing the spinner you could define and use your own indicator CSS.
Here is an example that uses <gr>display</gr> rather than opacity (Note that we use <gr>my-indicator</gr> instead of <gr>htmx-indicator</gr>):
<gr>    .my-indicator{
        display:none;
    }
    .htmx-request .my-indicator{
        display:inline;
    }
    .htmx-request.my-indicator{
        display:inline;
    }</gr>

Note that the target of the <gr>hx-indicator</gr> selector need not be the exact element that you want to show: it can be any element in the parent hierarchy of the indicator.
Finally, note that the <gr>htmx-request</gr> class by default is added to the element causing the request, so you can place an indicator inside of that element and not need to explicitly call it out with the <gr>hx-indicator</gr> attribute:
<gr>&lt;button hx-post="/example">
    Post It!
   &lt;img  class="htmx-indicator" src="/img/bars.svg"/>
&lt;/button></gr>

<h2>&emsp;Demo</h2>
This simulates what a spinner might look like in that situation:
<button classes="toggle htmx-request:3s">
    Post It!
   <img src="/img/bars.svg"></button>
<h2>&emsp;Notes</h2>
<gr>hx-indicator</gr> is inherited and can be placed on a parent element In the absence of an explicit indicator, the <gr>htmx-request</gr> class will be added to the element triggering the request If you want to use your own CSS but still use <gr>htmx-indicator</gr> as class name, then you need to disable <gr>includeIndicatorStyles</gr>.
See <a href="https://htmx.org/docs/#config">Configuring htmx</a>.
The easiest way is to add this to the <gr>&lt;head></gr> of your HTML:

<gr>&lt;meta name="htmx-config" content='{"includeIndicatorStyles": false}'></gr>

<h2><pk>hx-inherit</pk></h2>
The default behavior for htmx is to “inherit” many attributes automatically: that is, an attribute such as
<a href="https://htmx.org/attributes/hx-target/">hx-target</a> may be placed on a parent element, and all child elements will inherit that target.
Some people do not like this feature and instead prefer to explicitly specify inheritance for attributes.
To support this mode of development, htmx offers the <gr>htmx.config.disableInheritance</gr> setting, which can be set to
<gr>false</gr> to prevent inheritance from being the default behavior for any of the htmx attributes.
The <gr>hx-inherit</gr> attribute allows you to control the inheritance of attributes manually.
htmx evaluates attribute inheritance as follows:

when <gr>hx-inherit</gr> is set on a parent node


<gr>inherit="*"</gr> all attribute inheritance for this element will be enabled

<gr>hx-inherit="hx-select hx-get hx-target"</gr> enable inheritance for only one or multiple specified attributes



Here is an example of a div that shares an <gr>hx-target</gr> attribute for a set of anchor tags when <gr>htmx.config.disableInheritance</gr> is set to false:
<gr>&lt;div hx-target="#tab-container" hx-inherit="hx-target">
  &lt;a hx-boost="true" href="/tab1">Tab 1&lt;/a>
  &lt;a hx-boost="true" href="/tab2">Tab 2&lt;/a>
  &lt;a hx-boost="true" href="/tab3">Tab 3&lt;/a>
&lt;/div></gr>

<h2>&emsp;Notes</h2>
Read more about <a href="https://htmx.org/docs/#inheritance">Attribute Inheritance</a>

<h2><pk>hx-on</pk></h2>
The <gr>hx-on*</gr> attributes allow you to embed scripts inline to respond to events directly on an element; similar to the 
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers#using_onevent_properties"><gr>onevent</gr> properties</a> found in HTML, such as <gr>onClick</gr>.
The <gr>hx-on*</gr> attributes improve upon <gr>onevent</gr> by enabling the handling of any arbitrary JavaScript event,
for enhanced <a href="/essays/locality-of-behaviour/">Locality of Behaviour (LoB)</a> even when dealing with non-standard DOM events.
For example, these attributes allow you to handle <a href="/reference#events">htmx events</a>.
With <gr>hx-on</gr> attributes, you specify the event name as part of the attribute name, after a colon.
So, for example, if you want to respond to a <gr>click</gr> event, you would use the attribute <gr>hx-on:click</gr>:
<gr>&lt;div hx-on:click="alert('Clicked!')">Click&lt;/div></gr>

Note that this syntax can be used to capture all htmx events, as well as most other custom events, in addition to the standard DOM events.
One gotcha to note is that DOM attributes do not preserve case.
This means, unfortunately, an attribute like
<gr>hx-on:htmx:beforeRequest</gr> <strong>will not work</strong>, because the DOM lowercases the attribute names.
Fortunately, htmx supports both camel case event names and also <a href="https://htmx.org/docs/#events">kebab-case event names</a>, so you can use <gr>hx-on:htmx:before-request</gr> instead.
In order to make writing htmx-based event handlers a little easier, you can use the shorthand double-colon <gr>hx-on::</gr> for htmx events, and omit the “htmx” part:
<gr>&lt;!-- These two are equivalent -->
&lt;button hx-get="/info" hx-on:htmx:before-request="alert('Making a request!')">
    Get Info!
&lt;/button>

&lt;button hx-get="/info" hx-on::before-request="alert('Making a request!')">
    Get Info!
&lt;/button>
</gr>

If you wish to handle multiple different events, you can simply add multiple attributes to an element:
<gr>&lt;button hx-get="/info"
        hx-on::before-request="alert('Making a request!')"
        hx-on::after-request="alert('Done making a request!')">
    Get Info!
&lt;/button></gr>

Finally, in order to make this feature compatible with some templating languages (e.g.
<a rel="noopener" target="_blank" href="https://react.dev/learn/writing-markup-with-jsx">JSX</a>) that do not like having a colon (<gr>:</gr>)
in HTML attributes, you may use dashes in the place of colons for both the long form and the shorthand form:
<gr>&lt;!-- These two are equivalent -->
&lt;button hx-get="/info" hx-on-htmx-before-request="alert('Making a request!')">
    Get Info!
&lt;/button>

&lt;button hx-get="/info" hx-on--before-request="alert('Making a request!')">
    Get Info!
&lt;/button>
</gr>

<h3>&emsp;&emsp;hx-on (deprecated)</h3>
The value is an event name, followed by a colon <gr>:</gr>, followed by the script:
<gr>&lt;button hx-get="/info" hx-on="htmx:beforeRequest: alert('Making a request!')">
    Get Info!
&lt;/button></gr>

Multiple handlers can be defined by putting them on new lines:
<gr>&lt;button hx-get="/info" hx-on="htmx:beforeRequest: alert('Making a request!')
                              htmx:afterRequest: alert('Done making a request!')">
    Get Info!
&lt;/button></gr>

<h3>&emsp;&emsp;Symbols</h3>
Like <gr>onevent</gr>, two symbols are made available to event handler scripts:


<gr>this</gr> - The element on which the <gr>hx-on</gr> attribute is defined

<gr>event</gr> - The event that triggered the handler

<h3>&emsp;&emsp;Notes</h3>
<gr>hx-on</gr> is <em>not</em> inherited, however due to
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling_and_capture">event bubbling</a>,
<gr>hx-on</gr> attributes on parent elements will typically be triggered by events on child elements

<gr>hx-on:*</gr> and <gr>hx-on</gr> cannot be used together on the same element; if <gr>hx-on:*</gr> is present, the value of an <gr>hx-on</gr> attribute on the same element will be ignored.
The two forms can be mixed in the same document, however.
<h2><pk>hx-params</pk></h2>
The <gr>hx-params</gr> attribute allows you to filter the parameters that will be submitted with an AJAX request.
The possible values of this attribute are:


<gr>*</gr> - Include all parameters (default)

<gr>none</gr> - Include no parameters

<gr>not &lt;param-list></gr> - Include all except the comma separated list of parameter names

<gr>&lt;param-list></gr> - Include all the comma separated list of parameter names

<gr>  &lt;div hx-get="/example" hx-params="*">Get Some HTML, Including Params&lt;/div></gr>

This div will include all the parameters that a <gr>POST</gr> would, but they will be URL encoded and included in the URL, as per usual with a <gr>GET</gr>.
<h2>&emsp;Notes</h2>
<gr>hx-params</gr> is inherited and can be placed on a parent element
<h2><pk>hx-patch</pk></h2>
The <gr>hx-patch</gr> attribute will cause an element to issue a <gr>PATCH</gr> to the specified URL and swap the HTML into the DOM using a swap strategy:
<gr>&lt;button hx-patch="/account" hx-target="body">
  Patch Your Account
&lt;/button></gr>

This example will cause the <gr>button</gr> to issue a <gr>PATCH</gr> to <gr>/account</gr> and swap the returned HTML into the <gr>innerHTML</gr> of the <gr>body</gr>.
<h2>&emsp;Notes</h2>
<gr>hx-patch</gr> is not inherited You can control the target of the swap using the <a href="https://htmx.org/attributes/hx-target/">hx-target</a> attribute You can control the swap strategy by using the <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> attribute You can control what event triggers the request with the <a href="https://htmx.org/attributes/hx-trigger/">hx-trigger</a> attribute You can control the data submitted with the request in various ways, documented here: <a href="https://htmx.org/docs/#parameters">Parameters</a>

<h2><pk>hx-post</pk></h2>
The <gr>hx-post</gr> attribute will cause an element to issue a <gr>POST</gr> to the specified URL and swap the HTML into the DOM using a swap strategy:
<gr>&lt;button hx-post="/account/enable" hx-target="body">
  Enable Your Account
&lt;/button></gr>

This example will cause the <gr>button</gr> to issue a <gr>POST</gr> to <gr>/account/enable</gr> and swap the returned HTML into the <gr>innerHTML</gr> of the <gr>body</gr>.
<h2>&emsp;Notes</h2>
<gr>hx-post</gr> is not inherited You can control the target of the swap using the <a href="https://htmx.org/attributes/hx-target/">hx-target</a> attribute You can control the swap strategy by using the <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> attribute You can control what event triggers the request with the <a href="https://htmx.org/attributes/hx-trigger/">hx-trigger</a> attribute You can control the data submitted with the request in various ways, documented here: <a href="https://htmx.org/docs/#parameters">Parameters</a>

<h2><pk>hx-preserve</pk></h2>
The <gr>hx-preserve</gr> attribute allows you to keep an element unchanged during HTML replacement.
Elements with <gr>hx-preserve</gr> set are preserved by <gr>id</gr> when htmx updates any ancestor element.
You <em>must</em> set an unchanging <gr>id</gr> on elements for <gr>hx-preserve</gr> to work.
The response requires an element with the same <gr>id</gr>, but its type and other attributes are ignored.
Note that some elements cannot unfortunately be preserved properly, such as <gr>&lt;input type="text"></gr> (focus and caret position are lost), iframes or certain types of videos.
To tackle some of these cases we recommend the <a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/htmx-extensions/blob/main/src/morphdom-swap/README.md">morphdom extension</a>, which does a more elaborate DOM reconciliation.
<h2>&emsp;Notes</h2>
<gr>hx-preserve</gr> is not inherited
<h2><pk>hx-prompt</pk></h2>
The <gr>hx-prompt</gr> attribute allows you to show a prompt before issuing a request.
The value of the prompt will be included in the request in the <gr>HX-Prompt</gr> header.
Here is an example:
<gr>&lt;button hx-delete="/account" hx-prompt="Enter your account name to confirm deletion">
  Delete My Account
&lt;/button></gr>

<h2>&emsp;Notes</h2>
<gr>hx-prompt</gr> is inherited and can be placed on a parent element
<h2><pk>hx-push-url</pk></h2>
The <gr>hx-push-url</gr> attribute allows you to push a URL into the browser <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">location history</a>.
This creates a new history entry, allowing navigation with the browser’s back and forward buttons.
htmx snapshots the current DOM and saves it into its history cache, and restores from this cache on navigation.
The possible values of this attribute are:


<gr>true</gr>, which pushes the fetched URL into history.

<gr>false</gr>, which disables pushing the fetched URL if it would otherwise be pushed due to inheritance or <a href="/attributes/hx-boost"><gr>hx-boost</gr></a>.
A URL to be pushed into the location bar.
This may be relative or absolute, as per <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState"><gr>history.pushState()</gr></a>.

Here is an example:
<gr>&lt;div hx-get="/account" hx-push-url="true">
  Go to My Account
&lt;/div></gr>

This will cause htmx to snapshot the current DOM to <gr>localStorage</gr> and push the URL `/account’ into the browser location bar.
Another example:
<gr>&lt;div hx-get="/account" hx-push-url="/account/home">
  Go to My Account
&lt;/div></gr>

This will push the URL `/account/home’ into the location history.
<h2>&emsp;Notes</h2>
<gr>hx-push-url</gr> is inherited and can be placed on a parent element The <a href="https://htmx.org/headers/hx-push-url/"><gr>HX-Push-Url</gr> response header</a> has similar behavior and can override this attribute.
The <a href="https://htmx.org/attributes/hx-history-elt/"><gr>hx-history-elt</gr> attribute</a> allows changing which element is saved in the history cache.
<h2><pk>hx-put</pk></h2>
The <gr>hx-put</gr> attribute will cause an element to issue a <gr>PUT</gr> to the specified URL and swap the HTML into the DOM using a swap strategy:
<gr>&lt;button hx-put="/account" hx-target="body">
  Put Money In Your Account
&lt;/button></gr>

This example will cause the <gr>button</gr> to issue a <gr>PUT</gr> to <gr>/account</gr> and swap the returned HTML into the <gr>innerHTML</gr> of the <gr>body</gr>.
<h2>&emsp;Notes</h2>
<gr>hx-put</gr> is not inherited You can control the target of the swap using the <a href="https://htmx.org/attributes/hx-target/">hx-target</a> attribute You can control the swap strategy by using the <a href="https://htmx.org/attributes/hx-swap/">hx-swap</a> attribute You can control what event triggers the request with the <a href="https://htmx.org/attributes/hx-trigger/">hx-trigger</a> attribute You can control the data submitted with the request in various ways, documented here: <a href="https://htmx.org/docs/#parameters">Parameters</a>

<h2><pk>hx-replace-url</pk></h2>
The <gr>hx-replace-url</gr> attribute allows you to replace the current url of the browser <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">location history</a>.
The possible values of this attribute are:


<gr>true</gr>, which replaces the fetched URL in the browser navigation bar.

<gr>false</gr>, which disables replacing the fetched URL if it would otherwise be replaced due to inheritance.
A URL to be replaced into the location bar.
This may be relative or absolute, as per <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState"><gr>history.replaceState()</gr></a>.

Here is an example:
<gr>&lt;div hx-get="/account" hx-replace-url="true">
  Go to My Account
&lt;/div></gr>

This will cause htmx to snapshot the current DOM to <gr>localStorage</gr> and replace the URL `/account’ in the browser location bar.
Another example:
<gr>&lt;div hx-get="/account" hx-replace-url="/account/home">
  Go to My Account
&lt;/div></gr>

This will replace the URL `/account/home’ in the browser location bar.
<h2>&emsp;Notes</h2>
<gr>hx-replace-url</gr> is inherited and can be placed on a parent element The <a href="https://htmx.org/headers/hx-replace-url/"><gr>HX-Replace-Url</gr> response header</a> has similar behavior and can override this attribute.
The <a href="https://htmx.org/attributes/hx-history-elt/"><gr>hx-history-elt</gr> attribute</a> allows changing which element is saved in the history cache.
The <a href="https://htmx.org/attributes/hx-push-url/"><gr>hx-push-url</gr> attribute</a> is a similar and more commonly used attribute, which creates a new history entry rather than replacing the current one.
<h2><pk>hx-request</pk></h2>
The <gr>hx-request</gr> attribute allows you to configure various aspects of the request via the following attributes:


<gr>timeout</gr> - the timeout for the request, in milliseconds

<gr>credentials</gr> - if the request will send credentials

<gr>noHeaders</gr> - strips all headers from the request

These attributes are set using a JSON-like syntax:
<gr>&lt;div ...
hx-request='{"timeout":100}'>
  ...
&lt;/div></gr>

You may make the values dynamically evaluated by adding the <gr>javascript:</gr> or <gr>js:</gr> prefix:
<gr>&lt;div ...
hx-request='js: timeout:getTimeoutSetting() '>
  ...
&lt;/div></gr>

<h2>&emsp;Notes</h2>
<gr>hx-request</gr> is merge-inherited and can be placed on a parent element
<h2><pk>hx-select-oob</pk></h2>
The <gr>hx-select-oob</gr> attribute allows you to select content from a response to be swapped in via an out-of-band swap.<br>
The value of this attribute is comma separated list of elements to be swapped out of band.
This attribute is almost always paired with <a href="https://htmx.org/attributes/hx-select/">hx-select</a>.
Here is an example that selects a subset of the response content:
<gr>&lt;div>
   &lt;div id="alert">&lt;/div>
    &lt;button hx-get="/info" 
            hx-select="#info-details" 
            hx-swap="outerHTML"
            hx-select-oob="#alert">
        Get Info!
    &lt;/button>
&lt;/div></gr>

This button will issue a <gr>GET</gr> to <gr>/info</gr> and then select the element with the id <gr>info-details</gr>,
which will replace the entire button in the DOM, and, in addition, pick out an element with the id <gr>alert</gr> in the response and swap it in for div in the DOM with the same ID.
Each value in the comma separated list of values can specify any valid <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a> strategy by separating the selector and the swap strategy with a <gr>:</gr>.
For example, to prepend the alert content instead of replacing it:
<gr>&lt;div>
   &lt;div id="alert">&lt;/div>
    &lt;button hx-get="/info"
            hx-select="#info-details"
            hx-swap="outerHTML"
            hx-select-oob="#alert:afterbegin">
        Get Info!
    &lt;/button>
&lt;/div></gr>

<h2>&emsp;Notes</h2>
<gr>hx-select-oob</gr> is inherited and can be placed on a parent element
<h2><pk>hx-select</pk></h2>
The <gr>hx-select</gr> attribute allows you to select the content you want swapped from a response.
The value of this attribute is a CSS query selector of the element or elements to select from the response.
Here is an example that selects a subset of the response content:
<gr>&lt;div>
    &lt;button hx-get="/info" hx-select="#info-details" hx-swap="outerHTML">
        Get Info!
    &lt;/button>
&lt;/div></gr>

So this button will issue a <gr>GET</gr> to <gr>/info</gr> and then select the element with the id <gr>info-detail</gr>,
which will replace the entire button in the DOM.
<h2>&emsp;Notes</h2>
<gr>hx-select</gr> is inherited and can be placed on a parent element
<h2><pk>hx-swap-oob</pk></h2>
The <gr>hx-swap-oob</gr> attribute allows you to specify that some content in a response should be swapped into the DOM somewhere other than the target, that is “Out of Band”.
This allows you to piggy back updates to other element updates on a response.
Consider the following response HTML:
<gr>&lt;div>
 ...
&lt;/div>
&lt;div id="alerts" hx-swap-oob="true">
    Saved!
&lt;/div>
</gr>

The first div will be swapped into the target the usual manner.
The second div, however, will be swapped in as a replacement for the element with the id <gr>alerts</gr>, and will not end up in the target.
The value of the <gr>hx-swap-oob</gr> can be:

<gr>true</gr> any valid <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a> value any valid <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a> value, followed by a colon, followed by a CSS selector

If the value is <gr>true</gr> or <gr>outerHTML</gr> (which are equivalent) the element will be swapped inline.
If a swap value is given, that swap strategy will be used.
If a selector is given, all elements matched by that selector will be swapped.
If not, the element with an ID matching the new content will be swapped.
<h3>&emsp;&emsp;Troublesome Tables</h3>
Note that you can use a <gr>template</gr> tag to encapsulate types of elements that, by the HTML spec, can’t stand on their own in the DOM (<gr>&lt;tr></gr>, <gr>&lt;td></gr>, <gr>&lt;th></gr>, <gr>&lt;thead></gr>, <gr>&lt;tbody></gr>, <gr>&lt;tfoot></gr>, <gr>&lt;colgroup></gr>, <gr>&lt;caption></gr> &amp; <gr>&lt;col></gr>).
Here is an example with an out of band swap of a table row being encapsulated in this way:
<gr>&lt;div>
    ...
&lt;/div>
&lt;template>
    &lt;tr id="row" hx-swap-oob="true">
        ...
    &lt;/tr>
&lt;/template></gr>

Note that these template tags will be removed from the final content of the page.
<h2>&emsp;Nested OOB Swaps</h2>
By default, any element with <gr>hx-swap-oob=</gr> attribute anywhere in the response is processed for oob swap behavior, including when an element is nested within the main response element.
This can be problematic when using <a rel="noopener" target="_blank" href="https://htmx.org/essays/template-fragments/">template fragments</a> where a fragment may be reused as a oob-swap target and also as part of a bigger fragment.
When the bigger fragment is the main response the inner fragment will still be processed as an oob swap, removing it from the dom.
This behavior can be changed by setting the config <gr>htmx.config.allowNestedOobSwaps</gr> to <gr>false</gr>.
If this config option is <gr>false</gr>, OOB swaps are only processed when the element is <em>adjacent to</em> the main response element, OOB swaps elsewhere will be ignored and oob-swap-related attributes stripped.
<h2>&emsp;Notes</h2>
<gr>hx-swap-oob</gr> is not inherited
<h2><pk>hx-swap</pk></h2>
The <gr>hx-swap</gr> attribute allows you to specify how the response will be swapped in relative to the
<a href="https://htmx.org/attributes/hx-target/">target</a> of an AJAX request.
If you do not specify the option, the default is
<gr>htmx.config.defaultSwapStyle</gr> (<gr>innerHTML</gr>).
The possible values of this attribute are:


<gr>innerHTML</gr> - Replace the inner html of the target element

<gr>outerHTML</gr> - Replace the entire target element with the response

<gr>textContent</gr> - Replace the text content of the target element, without parsing the response as HTML

<gr>beforebegin</gr> - Insert the response before the target element

<gr>afterbegin</gr> - Insert the response before the first child of the target element

<gr>beforeend</gr> - Insert the response after the last child of the target element

<gr>afterend</gr> - Insert the response after the target element

<gr>delete</gr> - Deletes the target element regardless of the response

<gr>none</gr>- Does not append content from response (out of band items will still be processed).

These options are based on standard DOM naming and the 
<a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML"><gr>Element.insertAdjacentHTML</gr></a> specification.
So in this code:
<gr>  &lt;div hx-get="/example" hx-swap="afterend">Get Some HTML &amp; Append It&lt;/div></gr>

The <gr>div</gr> will issue a request to <gr>/example</gr> and append the returned content after the <gr>div</gr>
<h3>&emsp;&emsp;Modifiers</h3>
The <gr>hx-swap</gr> attributes supports modifiers for changing the behavior of the swap.
They are outlined below.
<h4>Transition: <gr>transition</gr></h4>
If you want to use the new <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">View Transitions</a> API when a swap occurs, you can use the <gr>transition:true</gr> option for your swap.
You can also enable this feature globally by setting the <gr>htmx.config.globalViewTransitions</gr> config setting to <gr>true</gr>.
<h4>Timing: <gr>swap</gr> &amp; <gr>settle</gr></h4>
You can modify the amount of time that htmx will wait after receiving a response to swap the content by including a <gr>swap</gr> modifier:
<gr>  &lt;!-- this will wait 1s before doing the swap after it is received -->
  &lt;div hx-get="/example" hx-swap="innerHTML swap:1s">Get Some HTML &amp; Append It&lt;/div></gr>

Similarly, you can modify the time between the swap and the settle logic by including a <gr>settle</gr> modifier:
<gr>  &lt;!-- this will wait 1s before doing the swap after it is received -->
  &lt;div hx-get="/example" hx-swap="innerHTML settle:1s">Get Some HTML &amp; Append It&lt;/div></gr>

These attributes can be used to synchronize htmx with the timing of CSS transition effects.
<h4>Title: <gr>ignoreTitle</gr></h4>
By default, htmx will update the title of the page if it finds a <gr>&lt;title></gr> tag in the response content.
You can turn off this behavior by setting the <gr>ignoreTitle</gr> option to true.
<h4>Scrolling: <gr>scroll</gr> &amp; <gr>show</gr></h4>
You can also change the scrolling behavior of the target element by using the <gr>scroll</gr> and <gr>show</gr> modifiers, both of which take the values <gr>top</gr> and <gr>bottom</gr>:
<gr>  &lt;!-- this fixed-height div will scroll to the bottom of the div after content is appended -->
  &lt;div style="height:200px; overflow: scroll" 
       hx-get="/example" 
       hx-swap="beforeend scroll:bottom">
     Get Some HTML &amp; Append It &amp; Scroll To Bottom
  &lt;/div></gr>

<gr>  &lt;!-- this will get some content and add it to #another-div, then ensure that the top of #another-div is visible in the 
       viewport -->
  &lt;div hx-get="/example" 
       hx-swap="innerHTML show:top"
       hx-target="#another-div">
    Get Some Content
  &lt;/div></gr>

If you wish to target a different element for scrolling or showing, you may place a CSS selector after the <gr>scroll:</gr> or <gr>show:</gr>, followed by <gr>:top</gr> or <gr>:bottom</gr>:
<gr>  &lt;!-- this will get some content and swap it into the current div, then ensure that the top of #another-div is visible in the 
       viewport -->
  &lt;div hx-get="/example" 
       hx-swap="innerHTML show:#another-div:top">
    Get Some Content
  &lt;/div></gr>

You may also use <gr>window:top</gr> and <gr>window:bottom</gr> to scroll to the top and bottom of the current window.
<gr>  &lt;!-- this will get some content and swap it into the current div, then ensure that the viewport is scrolled to the
       very top -->
  &lt;div hx-get="/example" 
       hx-swap="innerHTML show:window:top">
    Get Some Content
  &lt;/div></gr>

For boosted links and forms the default behaviour is <gr>show:top</gr>.
You can disable it globally with
<a href="https://htmx.org/api/#config">htmx.config.scrollIntoViewOnBoost</a> or you can use <gr>hx-swap="show:none"</gr> on an element basis.
<gr>&lt;form action="/example" hx-swap="show:none">
  ...
&lt;/form></gr>

<h4>Focus scroll</h4>
htmx preserves focus between requests for inputs that have a defined id attribute.
By default htmx prevents auto-scrolling to focused inputs between requests which can be unwanted behavior on longer requests when the user has already scrolled away.
To enable focus scroll you can use <gr>focus-scroll:true</gr>.
<gr>  &lt;input id="name" hx-get="/validation" 
       hx-swap="outerHTML focus-scroll:true"/></gr>

Alternatively, if you want the page to automatically scroll to the focused element after each request you can change the htmx global configuration value <gr>htmx.config.defaultFocusScroll</gr> to true.
Then disable it for specific requests using <gr>focus-scroll:false</gr>.
<gr>  &lt;input id="name" hx-get="/validation" 
       hx-swap="outerHTML focus-scroll:false"/></gr>

<h2>&emsp;Notes</h2>
<gr>hx-swap</gr> is inherited and can be placed on a parent element The default value of this attribute is <gr>innerHTML</gr>

Due to DOM limitations, it’s not possible to use the <gr>outerHTML</gr> method on the <gr>&lt;body></gr> element.
htmx will change <gr>outerHTML</gr> on <gr>&lt;body></gr> to use <gr>innerHTML</gr>.
The default swap delay is 0ms The default settle delay is 20ms
<h2><pk>hx-sync</pk></h2>
The <gr>hx-sync</gr> attribute allows you to synchronize AJAX requests between multiple elements.
The <gr>hx-sync</gr> attribute consists of a CSS selector to indicate the element to synchronize on, followed optionally by a colon and then by an optional syncing strategy.
The available strategies are:


<gr>drop</gr> - drop (ignore) this request if an existing request is in flight (the default)

<gr>abort</gr> - drop (ignore) this request if an existing request is in flight, and, if that is not the case, 
<em>abort</em> this request if another request occurs while it is still in flight

<gr>replace</gr> - abort the current request, if any, and replace it with this request

<gr>queue</gr> - place this request in the request queue associated with the given element

The <gr>queue</gr> modifier can take an additional argument indicating exactly how to queue:


<gr>queue first</gr> - queue the first request to show up while a request is in flight

<gr>queue last</gr> - queue the last request to show up while a request is in flight

<gr>queue all</gr> - queue all requests that show up while a request is in flight

<h2>&emsp;Notes</h2>
<gr>hx-sync</gr> is inherited and can be placed on a parent element

This example resolves a race condition between a form’s submit request and an individual input’s validation request.
Normally, without using <gr>hx-sync</gr>, filling out the input and immediately submitting the form triggers two parallel requests to <gr>/validate</gr> and <gr>/store</gr>.
Using <gr>hx-sync="closest form:abort"</gr> on the input will watch for requests on the form and abort the input’s request if a form request is present or starts while the input request is in flight.
<gr>&lt;form hx-post="/store">
    &lt;input id="title" name="title" type="text" 
        hx-post="/validate" 
        hx-trigger="change"
        hx-sync="closest form:abort">
    &lt;button type="submit">Submit&lt;/button>
&lt;/form></gr>

If you’d rather prioritize the validation request over the submit request, you can use the <gr>drop</gr> strategy.
This example will prioritize the validation request over the submit request so that if a validation request is in flight, the form cannot be submitted.
<gr>&lt;form hx-post="/store">
    &lt;input id="title" name="title" type="text" 
        hx-post="/validate" 
        hx-trigger="change"
        hx-sync="closest form:drop"
    >
    &lt;button type="submit">Submit&lt;/button>
&lt;/form></gr>

When dealing with forms that contain many inputs, you can prioritize the submit request over all input validation requests using the hx-sync <gr>replace</gr> strategy on the form tag.
This will cancel any in-flight validation requests and issue only the <gr>hx-post="/store"</gr> request.
If you’d rather abort the submit request and prioritize any existing validation requests you can use the <gr>hx-sync="this:abort"</gr> strategy on the form tag.
<gr>&lt;form hx-post="/store" hx-sync="this:replace">
    &lt;input id="title" name="title" type="text" hx-post="/validate" hx-trigger="change" />
    &lt;button type="submit">Submit&lt;/button>
&lt;/form></gr>

When implementing active search functionality the hx-trigger attribute’s <gr>delay</gr> modifier can be used to debounce the user’s input and avoid making multiple requests while the user types.
However, once a request is made, if the user begins typing again a new request will begin even if the previous one has not finished processing.
This example will cancel any in-flight requests and use only the last request.
In cases where the search input is contained within the target, then using <gr>hx-sync</gr> like this also helps reduce the chances that the input will be replaced while the user is still typing.
<gr>&lt;input type="search" 
    hx-get="/search" 
    hx-trigger="keyup changed delay:500ms, search" 
    hx-target="#search-results"
    hx-sync="this:replace"></gr>

<h2><pk>hx-target</pk></h2>
The <gr>hx-target</gr> attribute allows you to target a different element for swapping than the one issuing the AJAX request.
The value of this attribute can be:

A CSS query selector of the element to target.

<gr>this</gr> which indicates that the element that the <gr>hx-target</gr> attribute is on is the target.

<gr>closest &lt;CSS selector></gr> which will find the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/closest">closest</a> ancestor element or itself, that matches the given CSS selector
(e.g.
<gr>closest tr</gr> will target the closest table row to the element).

<gr>find &lt;CSS selector></gr> which will find the first child descendant element that matches the given CSS selector.

<gr>next</gr> which resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/nextElementSibling">element.nextElementSibling</a>


<gr>next &lt;CSS selector></gr> which will scan the DOM forward for the first element that matches the given CSS selector.
(e.g.
<gr>next .error</gr> will target the closest following sibling element with <gr>error</gr> class)

<gr>previous</gr> which resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/previousElementSibling">element.previousElementSibling</a>


<gr>previous &lt;CSS selector></gr> which will scan the DOM backwards for the first element that matches the given CSS selector.
(e.g <gr>previous .error</gr> will target the closest previous sibling with <gr>error</gr> class)

Here is an example that targets a div:
<gr>&lt;div>
    &lt;div id="response-div">&lt;/div>
    &lt;button hx-post="/register" hx-target="#response-div" hx-swap="beforeend">
        Register!
    &lt;/button>
&lt;/div></gr>

The response from the <gr>/register</gr> url will be appended to the <gr>div</gr> with the id <gr>response-div</gr>.
This example uses <gr>hx-target="this"</gr> to make a link that updates itself when clicked:
<gr>&lt;a hx-post="/new-link" hx-target="this" hx-swap="outerHTML">New link&lt;/a></gr>

<h2>&emsp;Notes</h2>
<gr>hx-target</gr> is inherited and can be placed on a parent element
<h2><pk>hx-trigger</pk></h2>
The <gr>hx-trigger</gr> attribute allows you to specify what triggers an AJAX request.
A trigger value can be one of the following:

An event name (e.g.
“click” or “my-custom-event”) followed by an event filter and a set of event modifiers A polling definition of the form <gr>every &lt;timing declaration></gr>

A comma-separated list of such events

<h3>&emsp;&emsp;Standard Events</h3>
A standard event, such as <gr>click</gr> can be specified as the trigger like so:
<gr>&lt;div hx-get="/clicked" hx-trigger="click">Click Me&lt;/div></gr>

<h4>Standard Event Filters</h4>
Events can be filtered by enclosing a boolean javascript expression in square brackets after the event name.
If this expression evaluates to <gr>true</gr> the event will be triggered, otherwise it will be ignored.
<gr>&lt;div hx-get="/clicked" hx-trigger="click[ctrlKey]">Control Click Me&lt;/div></gr>

This event will trigger if a click event is triggered with the <gr>event.ctrlKey</gr> property set to true.
Conditions can also refer to global functions or state
<gr>&lt;div hx-get="/clicked" hx-trigger="click[checkGlobalState()]">Control Click Me&lt;/div></gr>

And can also be combined using the standard javascript syntax
<gr>&lt;div hx-get="/clicked" hx-trigger="click[ctrlKey&amp;&amp;shiftKey]">Control-Shift Click Me&lt;/div></gr>

Note that all symbols used in the expression will be resolved first against the triggering event, and then next against the global namespace, so <gr>myEvent[foo]</gr> will first look for a property named <gr>foo</gr> on the event, then look for a global symbol with the name <gr>foo</gr>
<h4>Standard Event Modifiers</h4>
Standard events can also have modifiers that change how they behave.
The modifiers are:


<gr>once</gr> - the event will only trigger once (e.g.
the first click)

<gr>changed</gr> - the event will only change if the value of the element has changed.
Please pay attention <gr>change</gr> is the name of the event and <gr>changed</gr> is the name of the modifier.

<gr>delay:&lt;timing declaration></gr> - a delay will occur before an event triggers a request.
If the event is seen again it will reset the delay.

<gr>throttle:&lt;timing declaration></gr> - a throttle will occur after an event triggers a request.
If the event is seen again before the delay completes, it is ignored, the element will trigger at the end of the delay.

<gr>from:&lt;Extended CSS selector></gr> - allows the event that triggers a request to come from another element in the document (e.g.
listening to a key event on the body, to support hot keys)

A standard CSS selector resolves to all elements matching that selector.
Thus, <gr>from:input</gr> would listen on every input on the page.
The CSS selector is only evaluated once and is not re-evaluated when the page changes.
If you need to detect dynamically added elements use an event filter, for example <gr>click[event.target.matches('input')]</gr>

The extended CSS selector here allows for the following non-standard CSS values:


<gr>document</gr> - listen for events on the document

<gr>window</gr> - listen for events on the window

<gr>closest &lt;CSS selector></gr> - finds the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/closest">closest</a> ancestor element or itself, matching the given css selector

<gr>find &lt;CSS selector></gr> - finds the closest child matching the given css selector

<gr>next</gr> resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/nextElementSibling">element.nextElementSibling</a>


<gr>next &lt;CSS selector></gr> scans the DOM forward for the first element that matches the given CSS selector.
(e.g.
<gr>next .error</gr> will target the closest following sibling element with <gr>error</gr> class)

<gr>previous</gr> resolves to <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/Element/previousElementSibling">element.previousElementSibling</a>


<gr>previous &lt;CSS selector></gr> scans the DOM backwards for the first element that matches the given CSS selector.
(e.g <gr>previous .error</gr> will target the closest previous sibling with <gr>error</gr> class)





<gr>target:&lt;CSS selector></gr> - allows you to filter via a CSS selector on the target of the event.
This can be useful when you want to listen for triggers from elements that might not be in the DOM at the point of initialization, by, for example, listening on the body,
but with a target filter for a child element

<gr>consume</gr> - if this option is included the event will not trigger any other htmx requests on parents (or on elements listening on parents)

<gr>queue:&lt;queue option></gr> - determines how events are queued if an event occurs while a request for another event is in flight.
Options are:


<gr>first</gr> - queue the first event

<gr>last</gr> - queue the last event (default)

<gr>all</gr> - queue all events (issue a request for each event)

<gr>none</gr> - do not queue new events



Here is an example of a search box that searches on <gr>keyup</gr>, but only if the search value has changed and the user hasn’t typed anything new for 1 second:
<gr>&lt;input name="q"
       hx-get="/search" hx-trigger="keyup changed delay:1s"
       hx-target="#search-results"/></gr>

The response from the <gr>/search</gr> url will be appended to the <gr>div</gr> with the id <gr>search-results</gr>.
<h3>&emsp;&emsp;Non-standard Events</h3>
There are some additional non-standard events that htmx supports:


<gr>load</gr> - triggered on load (useful for lazy-loading something)

<gr>revealed</gr> - triggered when an element is scrolled into the viewport (also useful for lazy-loading).
If you are using <gr>overflow</gr> in css like <gr>overflow-y: scroll</gr> you should use <gr>intersect once</gr> instead of <gr>revealed</gr>.

<gr>intersect</gr> - fires once when an element first intersects the viewport.
This supports two additional options:


<gr>root:&lt;selector></gr> - a CSS selector of the root element for intersection

<gr>threshold:&lt;float></gr> - a floating point number between 0.0 and 1.0, indicating what amount of intersection to fire the event on



<h3>&emsp;&emsp;Triggering via the <gr>HX-Trigger</gr> header</h3>
If you’re trying to fire an event from <gr>HX-Trigger</gr> response  header, you will likely want to use the <gr>from:body</gr> modifier.
E.g.
if you send a header like this <gr>HX-Trigger: my-custom-event</gr> with a response, an element would likely need to look like this:
<gr>  &lt;div hx-get="/example" hx-trigger="my-custom-event from:body">
    Triggered by HX-Trigger header...
  &lt;/div></gr>

in order to fire.
This is because the header will likely trigger the event in a different DOM hierarchy than the element that you wish to be triggered.
For a similar reason, you will often listen for hot keys from the body.
<h3>&emsp;&emsp;Polling</h3>
By using the syntax <gr>every &lt;timing declaration></gr> you can have an element poll periodically:
<gr>&lt;div hx-get="/latest_updates" hx-trigger="every 1s">
  Nothing Yet!
&lt;/div></gr>

This example will issue a <gr>GET</gr> to the <gr>/latest_updates</gr> URL every second and swap the results into the innerHTML of this div.
If you want to add a filter to polling, it should be added <em>after</em> the poll declaration:
<gr>&lt;div hx-get="/latest_updates" hx-trigger="every 1s [someConditional]">
  Nothing Yet!
&lt;/div></gr>

<h3>&emsp;&emsp;Multiple Triggers</h3>
Multiple triggers can be provided, separated by commas.
Each trigger gets its own options.
<gr>  &lt;div hx-get="/news" hx-trigger="load, click delay:1s">&lt;/div></gr>

This example will load <gr>/news</gr> immediately on page load, and then again with a delay of one second after each click.
<h3>&emsp;&emsp;Via JavaScript</h3>
The AJAX request can be triggered via JavaScript <a href="https://htmx.org/api/#trigger"><gr>htmx.trigger()</gr></a>, too.
<h2>&emsp;Notes</h2>
<gr>hx-trigger</gr> is not inherited

<gr>hx-trigger</gr> can be used without an AJAX request, in which case it will only fire the <gr>htmx:trigger</gr> event In order to pass a CSS selector that contains whitespace (e.g.
<gr>form input</gr>) to the <gr>from</gr>- or <gr>target</gr>-modifier, surround the selector in parentheses or curly brackets (e.g.
<gr>from:(form input)</gr> or <gr>from:nearest (form input)</gr>)
<h2><pk>hx-validate</pk></h2>
The <gr>hx-validate</gr> attribute will cause an element to validate itself by way of the <a href="https://htmx.org/docs/#validation">HTML5 Validation API</a> before it submits a request.
Only <gr>&lt;form></gr> elements validate data by default, but other elements do not.
Adding <gr>hx-validate="true"</gr> to <gr>&lt;input></gr>, <gr>&lt;textarea></gr> or <gr>&lt;select></gr> enables validation before sending requests.
<h2>&emsp;Notes</h2>
<gr>hx-validate</gr> is not inherited
<h2><pk>hx-vals</pk></h2>
The <gr>hx-vals</gr> attribute allows you to add to the parameters that will be submitted with an AJAX request.
By default, the value of this attribute is a list of name-expression values in <a rel="noopener" target="_blank" href="https://www.json.org/json-en.html">JSON (JavaScript Object Notation)</a> format.
If you wish for <gr>hx-vals</gr> to <em>evaluate</em> the values given, you can prefix the values with <gr>javascript:</gr> or <gr>js:</gr>.
<gr>  &lt;div hx-get="/example" hx-vals='{"myVal": "My Value"}'>Get Some HTML, Including A Value in the Request&lt;/div>

  &lt;div hx-get="/example" hx-vals='js:{myVal: calculateValue()}'>Get Some HTML, Including a Dynamic Value from Javascript in the Request&lt;/div></gr>

When using evaluated code you can access the <gr>event</gr> object.
This example includes the value of the last typed key within the input.
<gr>  &lt;div hx-get="/example" hx-trigger="keyup" hx-vals='js:{lastKey: event.key}'>
    &lt;input type="text" />
  &lt;/div></gr>

<h2>&emsp;Security Considerations</h2>
By default, the value of <gr>hx-vals</gr> must be valid <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Glossary/JSON">JSON</a>.

It is <strong>not</strong> dynamically computed.
If you use the <gr>javascript:</gr> prefix, be aware that you are introducing security considerations, especially when dealing with user input such as query strings or user-generated content, which could introduce a <a rel="noopener" target="_blank" href="https://owasp.org/www-community/attacks/xss/">Cross-Site Scripting (XSS)</a> vulnerability.


<h2>&emsp;Notes</h2>
<gr>hx-vals</gr> is inherited and can be placed on a parent element.
A child declaration of a variable overrides a parent declaration.
Input values with the same name will be overridden by variable declarations.
<h2><pk>hx-vars</pk></h2>
  <strong>NOTE: <gr>hx-vars</gr> has been deprecated in favor of <a href="https://htmx.org/attributes/hx-vals/"><gr>hx-vals</gr></a>, which is safer by default.</strong>
The <gr>hx-vars</gr> attribute allows you to dynamically add to the parameters that will be submitted with an AJAX request.
The value of this attribute is a comma separated list of <gr>name</gr>:<gr>&lt;expression></gr> values, the same as the internal syntax of javascript <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Object_literals">Object Literals</a>.
<gr>  &lt;div hx-get="/example" hx-vars="myVar:computeMyVar()">Get Some HTML, Including A Dynamic Value in the Request&lt;/div></gr>

<h2>&emsp;Security Considerations</h2>
The expressions in <gr>hx-vars</gr> are dynamically computed which allows you to add JavaScript code that will be executed.
Be careful to <strong>never</strong> trust user input in your expressions as this may lead to a <a rel="noopener" target="_blank" href="https://owasp.org/www-community/attacks/xss/">Cross-Site Scripting (XSS)</a> vulnerability.
If you are dealing with user input such as query strings or user-generated content, consider using <a href="https://htmx.org/attributes/hx-vals/">hx-vals</a> which is a safer alternative.

<h2>&emsp;Notes</h2>
<gr>hx-vars</gr> is inherited and can be placed on a parent element.
A child declaration of a variable overrides a parent declaration.
Input values with the same name will be overridden by variable declarations.
<h2><pk>HX-Location Response Header</pk></h2>
  This response header can be used to trigger a client side redirection without reloading the whole page.
Instead of changing the page’s location it will act like following a <a href="https://htmx.org/attributes/hx-boost/"><gr>hx-boost</gr> link</a>, creating a new history entry, issuing an ajax request to the value of the header and pushing the path into history.
A sample response would be:
<gr>HX-Location: /test</gr>

Which would push the client to test as if the user had clicked on <gr>&lt;a href="/test" hx-boost="true"></gr> If you want to redirect to a specific target on the page rather than the default of document.body, you can pass more details along with the event, by using JSON for the value of the header:
<gr>HX-Location: {"path":"/test2", "target":"#testdiv"}</gr>

Path is required and is url to load the response from.
The rest of the data mirrors the <a href="https://htmx.org/api/#ajax"><gr>ajax</gr> api</a> context, which is:


<gr>source</gr> - the source element of the request

<gr>event</gr> - an event that “triggered” the request

<gr>handler</gr> - a callback that will handle the response HTML

<gr>target</gr> - the target to swap the response into

<gr>swap</gr> - how the response will be swapped in relative to the target

<gr>values</gr> - values to submit with the request

<gr>headers</gr> - headers to submit with the request

<gr>select</gr> - allows you to select the content you want swapped from a response
<h2><pk>HX-Push-Url Response Header</pk></h2>
The <gr>HX-Push-Url</gr> header allows you to push a URL into the browser <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">location history</a>.
This creates a new history entry, allowing navigation with the browser’s back and forward buttons.
This is similar to the <a href="https://htmx.org/attributes/hx-push-url/"><gr>hx-push-url</gr> attribute</a>.
If present, this header overrides any behavior defined with attributes.
The possible values for this header are:

A URL to be pushed into the location bar.
This may be relative or absolute, as per <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History/pushState"><gr>history.pushState()</gr></a>.

<gr>false</gr>, which prevents the browser’s history from being updated.
<h2><pk>HX-Replace-Url Response Header</pk></h2>
The <gr>HX-Replace-Url</gr> header allows you to replace the current URL in the browser <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History_API">location history</a>.
This does not create a new history entry; in effect, it removes the previous current URL from the browser’s history.
This is similar to the <a href="https://htmx.org/attributes/hx-replace-url/"><gr>hx-replace-url</gr> attribute</a>.
If present, this header overrides any behavior defined with attributes.
The possible values for this header are:

A URL to replace the current URL in the location bar.
This may be relative or absolute, as per <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState"><gr>history.replaceState()</gr></a>, but must have the same origin as the current URL.

<gr>false</gr>, which prevents the browser’s current URL from being updated.
<h2><pk>HX-Trigger Response Headers</pk></h2>
These response headers can be used to trigger client side actions on the target element within a response to htmx.
You can trigger a single event or as many uniquely named events as you would like.
The headers are:


<gr>HX-Trigger</gr> - trigger events as soon as the response is received.

<gr>HX-Trigger-After-Settle</gr> - trigger events after the <a href="https://htmx.org/docs/#request-operations">settling step</a>.

<gr>HX-Trigger-After-Swap</gr> - trigger events after the <a href="https://htmx.org/docs/#request-operations">swap step</a>.

To trigger a single event with no additional details you can simply send the event name in a header like so:
<gr>HX-Trigger: myEvent</gr> This will trigger <gr>myEvent</gr> on the triggering element and will bubble up to the body.
As an example you could listen for this event like this:
<gr>document.body.addEventListener("myEvent", function(evt){
    alert("myEvent was triggered!");
})</gr>

… or like this, if you’re trying to trigger some element without using JS code:
<gr>&lt;!-- Since it bubbles up to the &lt;body>, we must use the `from:body` modifier below -->
&lt;div hx-trigger="myEvent from:body" hx-get="/example">&lt;/div></gr>

If you want to pass details along with the event, you can move to JSON for the value of the trigger:
<gr>HX-Trigger: {"showMessage":"Here Is A Message"}</gr> To handle this event you would write the following code:
<gr>document.body.addEventListener("showMessage", function(evt){
    alert(evt.detail.value);
})</gr>

Note that the value of the message was put into the <gr>detail.value</gr> slot.
If you wish to pass multiple pieces of data you can use a nested JSON object on the right hand side of the JSON object:
<gr>HX-Trigger: {"showMessage":{"level" : "info", "message" : "Here Is A Message"}}</gr> And handle this event like so:
<gr>document.body.addEventListener("showMessage", function(evt){
   if(evt.detail.level === "info"){
     alert(evt.detail.message);   
   }
})</gr>

Each property of the JSON object on the right hand side will be copied onto the details object for the event.
<h3>&emsp;&emsp;Multiple Triggers</h3>
If you wish to invoke multiple events, you can simply add additional properties to the top level JSON object:
<gr>HX-Trigger: {"event1":"A message", "event2":"Another message"}</gr> You may also trigger multiple events with no additional details by sending event names separated by commas, like so:
<gr>HX-Trigger: event1, event2</gr> Using events gives you a lot of flexibility to add functionality to normal htmx responses.

<h2>Javascript API</h2>
<br>
<div id="toc" class="JavascriptAPItoc"><a href="#JavascriptAPItopic-0" target="_self">Method - <gr>htmx.addClass()</gr></a><br><a href="#JavascriptAPItopic-1" target="_self">Method - <gr>htmx.ajax()</gr></a><br><a href="#JavascriptAPItopic-2" target="_self">Method - <gr>htmx.closest()</gr></a><br><a href="#JavascriptAPItopic-3" target="_self">Property - <gr>htmx.config</gr></a><br><a href="#JavascriptAPItopic-4" target="_self">Property - <gr>htmx.createEventSource</gr></a><br><a href="#JavascriptAPItopic-5" target="_self">Property - <gr>htmx.createWebSocket</gr></a><br><a href="#JavascriptAPItopic-6" target="_self">Method - <gr>htmx.defineExtension()</gr></a><br><a href="#JavascriptAPItopic-7" target="_self">Method - <gr>htmx.find()</gr></a><br><a href="#JavascriptAPItopic-8" target="_self">Method - <gr>htmx.findAll()</gr></a><br><a href="#JavascriptAPItopic-9" target="_self">Method - <gr>htmx.logAll()</gr></a><br><a href="#JavascriptAPItopic-10" target="_self">Method - <gr>htmx.logNone()</gr></a><br><a href="#JavascriptAPItopic-11" target="_self">Property - <gr>htmx.logger</gr></a><br><a href="#JavascriptAPItopic-12" target="_self">Method - <gr>htmx.off()</gr></a><br><a href="#JavascriptAPItopic-13" target="_self">Method - <gr>htmx.on()</gr></a><br><a href="#JavascriptAPItopic-14" target="_self">Method - <gr>htmx.onLoad()</gr></a><br><a href="#JavascriptAPItopic-15" target="_self">Method - <gr>htmx.parseInterval()</gr></a><br><a href="#JavascriptAPItopic-16" target="_self">Method - <gr>htmx.process()</gr></a><br><a href="#JavascriptAPItopic-17" target="_self">Method - <gr>htmx.remove()</gr></a><br><a href="#JavascriptAPItopic-18" target="_self">Method - <gr>htmx.removeClass()</gr></a><br><a href="#JavascriptAPItopic-19" target="_self">Method - <gr>htmx.removeExtension()</gr></a><br><a href="#JavascriptAPItopic-20" target="_self">Method - <gr>htmx.swap()</gr></a><br><a href="#JavascriptAPItopic-21" target="_self">Method - <gr>htmx.takeClass()</gr></a><br><a href="#JavascriptAPItopic-22" target="_self">Method - <gr>htmx.toggleClass()</gr></a><br><a href="#JavascriptAPItopic-23" target="_self">Method - <gr>htmx.trigger()</gr></a><br><a href="#JavascriptAPItopic-24" target="_self">Method - <gr>htmx.values()</gr></a><br></div></center>
While it is not a focus of the library, htmx does provide a small API of helper methods, intended mainly for <a rel="noopener" target="_blank" href="https://extensions.htmx.org">extension development</a> or for working with <a href="https://htmx.org/events/">events</a>.
The <a rel="noopener" target="_blank" href="https://hyperscript.org">hyperscript</a> project is intended to provide more extensive scripting support for htmx-based applications.

<h3 id="JavascriptAPItopic-0">Method - <gr>htmx.addClass()</gr></h3>
This method adds a class to the given element.

<h5>Parameters</h5>
<gr>elt</gr> - the element to add the class to
<gr>class</gr> - the class to add

or

<gr>elt</gr> - the element to add the class to
<gr>class</gr> - the class to add
<gr>delay</gr> - delay (in milliseconds ) before class is added


<h5>Example</h5>
<gr>  // add the class 'myClass' to the element with the id 'demo'
  htmx.addClass(htmx.find('#demo'), 'myClass');

  // add the class 'myClass' to the element with the id 'demo' after 1 second
  htmx.addClass(htmx.find('#demo'), 'myClass', 1000);</gr>

<h3 id="JavascriptAPItopic-1">Method - <gr>htmx.ajax()</gr></h3>
Issues an htmx-style AJAX request. This method returns a Promise, so a callback can be executed after the content has been inserted into the DOM.

<h5>Parameters</h5>
<gr>verb</gr> - ‘GET’, ‘POST’, etc.
<gr>path</gr> - the URL path to make the AJAX
<gr>element</gr> - the element to target (defaults to the <gr>body</gr>)

or

<gr>verb</gr> - ‘GET’, ‘POST’, etc.
<gr>path</gr> - the URL path to make the AJAX
<gr>selector</gr> - a selector for the target

or

<gr>verb</gr> - ‘GET’, ‘POST’, etc.
<gr>path</gr> - the URL path to make the AJAX
<gr>context</gr> - a context object that contains any of the following

<gr>source</gr> - the source element of the request, <gr>hx-*</gr> attrs which affect the request will be resolved against that element and its ancestors
<gr>event</gr> - an event that “triggered” the request
<gr>handler</gr> - a callback that will handle the response HTML
<gr>target</gr> - the target to swap the response into
<gr>swap</gr> - how the response will be swapped in relative to the target
<gr>values</gr> - values to submit with the request
<gr>headers</gr> - headers to submit with the request
<gr>select</gr> - allows you to select the content you want swapped from a response




<h5>Example</h5>
<gr>    // issue a GET to /example and put the response HTML into #myDiv
    htmx.ajax('GET', '/example', '#myDiv')

    // issue a GET to /example and replace #myDiv with the response
    htmx.ajax('GET', '/example', {target:'#myDiv', swap:'outerHTML'})

    // execute some code after the content has been inserted into the DOM
    htmx.ajax('GET', '/example', '#myDiv').then(() =&gt; {
      // this code will be executed after the 'htmx:afterOnLoad' event,
      // and before the 'htmx:xhr:loadend' event
      console.log('Content inserted successfully!');
    });</gr>


<h3 id="JavascriptAPItopic-2">Method - <gr>htmx.closest()</gr></h3>
Finds the closest matching element in the given elements parentage, inclusive of the element

<h5>Parameters</h5>
<gr>elt</gr> - the element to find the selector from
<gr>selector</gr> - the selector to find


<h5>Example</h5>
<gr>  // find the closest enclosing div of the element with the id 'demo'
  htmx.closest(htmx.find('#demo'), 'div');</gr>

<h3 id="JavascriptAPItopic-3">Property - <gr>htmx.config</gr></h3>
A property holding the configuration htmx uses at runtime.
Note that using a <a href="https://htmx.org/docs/#config">meta tag</a> is the preferred mechanism for setting these properties.

<h5>Properties</h5>
<gr>attributesToSettle:["class", "style", "width", "height"]</gr> - array of strings: the attributes to settle during the settling phase
<gr>refreshOnHistoryMiss:false</gr> - boolean: if set to <gr>true</gr> htmx will issue a full page refresh on history misses rather than use an AJAX request
<gr>defaultSettleDelay:20</gr> - int: the default delay between completing the content swap and settling attributes
<gr>defaultSwapDelay:0</gr> - int: the default delay between receiving a response from the server and doing the swap
<gr>defaultSwapStyle:'innerHTML'</gr> - string: the default swap style to use if <a href="https://htmx.org/attributes/hx-swap/"><gr>hx-swap</gr></a> is omitted
<gr>historyCacheSize:10</gr> - int: the number of pages to keep in <gr>localStorage</gr> for history support
<gr>historyEnabled:true</gr> - boolean: whether or not to use history
<gr>includeIndicatorStyles:true</gr> - boolean: if true, htmx will inject a small amount of CSS into the page to make indicators invisible unless the <gr>htmx-indicator</gr> class is present
<gr>indicatorClass:'htmx-indicator'</gr> - string: the class to place on indicators when a request is in flight
<gr>requestClass:'htmx-request'</gr> - string: the class to place on triggering elements when a request is in flight
<gr>addedClass:'htmx-added'</gr> - string: the class to temporarily place on elements that htmx has added to the DOM
<gr>settlingClass:'htmx-settling'</gr> - string: the class to place on target elements when htmx is in the settling phase
<gr>swappingClass:'htmx-swapping'</gr> - string: the class to place on target elements when htmx is in the swapping phase
<gr>allowEval:true</gr> - boolean: allows the use of eval-like functionality in htmx, to enable <gr>hx-vars</gr>, trigger conditions &amp; script tag evaluation.  Can be set to <gr>false</gr> for CSP compatibility.
<gr>allowScriptTags:true</gr> - boolean: allows script tags to be evaluated in new content
<gr>inlineScriptNonce:''</gr> - string: the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/HTML/Global_attributes/nonce">nonce</a> to add to inline scripts
<gr>inlineStyleNonce:''</gr> - string: the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/HTML/Global_attributes/nonce">nonce</a> to add to inline styles
<gr>withCredentials:false</gr> - boolean: allow cross-site Access-Control requests using credentials such as cookies, authorization headers or TLS client certificates
<gr>timeout:0</gr> - int: the number of milliseconds a request can take before automatically being terminated
<gr>wsReconnectDelay:'full-jitter'</gr> - string/function: the default implementation of <gr>getWebSocketReconnectDelay</gr> for reconnecting after unexpected connection loss by the event code <gr>Abnormal Closure</gr>, <gr>Service Restart</gr> or <gr>Try Again Later</gr>
<gr>wsBinaryType:'blob'</gr> - string: the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/API/WebSocket/binaryType">the type of binary data</a> being received over the WebSocket connection
<gr>disableSelector:"[hx-disable], [data-hx-disable]"</gr> - array of strings: htmx will not process elements with this attribute on it or a parent
<gr>scrollBehavior:'smooth'</gr> - string: the behavior for a boosted link on page transitions. The allowed values are <gr>auto</gr> and <gr>smooth</gr>. Smooth will smoothscroll to the top of the page while auto will behave like a vanilla link.
<gr>defaultFocusScroll:false</gr> - boolean: if the focused element should be scrolled into view, can be overridden using the <a href="https://htmx.org/attributes/hx-swap/#focus-scroll">focus-scroll</a> swap modifier
<gr>getCacheBusterParam:false</gr> - boolean: if set to true htmx will append the target element to the <gr>GET</gr> request in the format <gr>org.htmx.cache-buster=targetElementId</gr>
<gr>globalViewTransitions:false</gr> - boolean: if set to <gr>true</gr>, htmx will use the <a rel="noopener" target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/View_Transitions_API">View Transition</a> API when swapping in new content.
<gr>methodsThatUseUrlParams:["get"]</gr> - array of strings: htmx will format requests with these methods by encoding their parameters in the URL, not the request body
<gr>selfRequestsOnly:true</gr> - boolean: whether to only allow AJAX requests to the same domain as the current document
<gr>ignoreTitle:false</gr> - boolean: if set to <gr>true</gr> htmx will not update the title of the document when a <gr>title</gr> tag is found in new content
<gr>scrollIntoViewOnBoost:true</gr> - boolean: whether or not the target of a boosted element is scrolled into the viewport. If <gr>hx-target</gr> is omitted on a boosted element, the target defaults to <gr>body</gr>, causing the page to scroll to the top.
<gr>triggerSpecsCache:null</gr> - object: the cache to store evaluated trigger specifications into, improving parsing performance at the cost of more memory usage. You may define a simple object to use a never-clearing cache, or implement your own system using a <a rel="noopener" target="_blank" href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Proxy">proxy object</a> |


<h5>Example</h5>
<gr>  // update the history cache size to 30
  htmx.config.historyCacheSize = 30;</gr>

<h3 id="JavascriptAPItopic-4">Property - <gr>htmx.createEventSource</gr></h3>
A property used to create new <a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/htmx-extensions/blob/main/src/sse/README.md">Server Sent Event</a> sources.  This can be updated to provide custom SSE setup.

<h5>Value</h5>
<gr>func(url)</gr> - a function that takes a URL string and returns a new <gr>EventSource</gr>


<h5>Example</h5>
<gr>  // override SSE event sources to not use credentials
  htmx.createEventSource = function(url) {
    return new EventSource(url, {withCredentials:false});
  };</gr>

<h3 id="JavascriptAPItopic-5">Property - <gr>htmx.createWebSocket</gr></h3>
A property used to create new <a rel="noopener" target="_blank" href="https://github.com/bigskysoftware/htmx-extensions/blob/main/src/ws/README.md">WebSocket</a>.  This can be updated to provide custom WebSocket setup.

<h5>Value</h5>
<gr>func(url)</gr> - a function that takes a URL string and returns a new <gr>WebSocket</gr>


<h5>Example</h5>
<gr>  // override WebSocket to use a specific protocol
  htmx.createWebSocket = function(url) {
    return new WebSocket(url, ['wss']);
  };</gr>

<h3 id="JavascriptAPItopic-6">Method - <gr>htmx.defineExtension()</gr></h3>
Defines a new htmx <a rel="noopener" target="_blank" href="https://extensions.htmx.org">extension</a>.

<h5>Parameters</h5>
<gr>name</gr> - the extension name
<gr>ext</gr> - the extension definition


<h5>Example</h5>
<gr>  // defines a silly extension that just logs the name of all events triggered
  htmx.defineExtension("silly", {
    onEvent : function(name, evt) {
      console.log("Event " + name + " was triggered!")
    }
  });</gr>

<h3 id="JavascriptAPItopic-7">Method - <gr>htmx.find()</gr></h3>
Finds an element matching the selector

<h5>Parameters</h5>
<gr>selector</gr> - the selector to match

or

<gr>elt</gr> - the root element to find the matching element in, inclusive
<gr>selector</gr> - the selector to match


<h5>Example</h5>
<gr>    // find div with id my-div
    var div = htmx.find("#my-div")

    // find div with id another-div within that div
    var anotherDiv = htmx.find(div, "#another-div")</gr>

<h3 id="JavascriptAPItopic-8">Method - <gr>htmx.findAll()</gr></h3>
Finds all elements matching the selector

<h5>Parameters</h5>
<gr>selector</gr> - the selector to match

or

<gr>elt</gr> - the root element to find the matching elements in, inclusive
<gr>selector</gr> - the selector to match


<h5>Example</h5>
<gr>    // find all divs
    var allDivs = htmx.findAll("div")

    // find all paragraphs within a given div
    var allParagraphsInMyDiv = htmx.findAll(htmx.find("#my-div"), "p")</gr>

<h3 id="JavascriptAPItopic-9">Method - <gr>htmx.logAll()</gr></h3>
Log all htmx events, useful for debugging.

<h5>Example</h5>
<gr>    htmx.logAll();</gr>

<h3 id="JavascriptAPItopic-10">Method - <gr>htmx.logNone()</gr></h3>
Log no htmx events, call this to turn off the debugger if you previously enabled it.

<h5>Example</h5>
<gr>    htmx.logNone();</gr>

<h3 id="JavascriptAPItopic-11">Property - <gr>htmx.logger</gr></h3>
The logger htmx uses to log with

<h5>Value</h5>
<gr>func(elt, eventName, detail)</gr> - a function that takes an element, eventName and event detail and logs it


<h5>Example</h5>
<gr>    htmx.logger = function(elt, event, data) {
        if(console) {
            console.log("INFO:", event, elt, data);
        }
    }</gr>

<h3 id="JavascriptAPItopic-12">Method - <gr>htmx.off()</gr></h3>
Removes an event listener from an element

<h5>Parameters</h5>
<gr>eventName</gr> - the event name to remove the listener from
<gr>listener</gr> - the listener to remove

or

<gr>target</gr> - the element to remove the listener from
<gr>eventName</gr> - the event name to remove the listener from
<gr>listener</gr> - the listener to remove


<h5>Example</h5>
<gr>    // remove this click listener from the body
    htmx.off("click", myEventListener);

    // remove this click listener from the given div
    htmx.off("#my-div", "click", myEventListener)</gr>

<h3 id="JavascriptAPItopic-13">Method - <gr>htmx.on()</gr></h3>
Adds an event listener to an element

<h5>Parameters</h5>
<gr>eventName</gr> - the event name to add the listener for
<gr>listener</gr> - the listener to add

or

<gr>target</gr> - the element to add the listener to
<gr>eventName</gr> - the event name to add the listener for
<gr>listener</gr> - the listener to add


<h5>Example</h5>
<gr>    // add a click listener to the body
    var myEventListener = htmx.on("click", function(evt){ console.log(evt); });

    // add a click listener to the given div
    var myEventListener = htmx.on("#my-div", "click", function(evt){ console.log(evt); });</gr>

<h3 id="JavascriptAPItopic-14">Method - <gr>htmx.onLoad()</gr></h3>
Adds a callback for the <gr>htmx:load</gr> event. This can be used to process new content, for example initializing the content with a javascript library

<h5>Parameters</h5>
<gr>callback(elt)</gr> - the callback to call on newly loaded content


<h5>Example</h5>
<gr>    htmx.onLoad(function(elt){
        MyLibrary.init(elt);
    })</gr>

<h3 id="JavascriptAPItopic-15">Method - <gr>htmx.parseInterval()</gr></h3>
Parses an interval string consistent with the way htmx does.  Useful for plugins that have timing-related attributes.
Caution: Accepts an int followed by either <gr>s</gr> or <gr>ms</gr>. All other values use <gr>parseFloat</gr>

<h5>Parameters</h5>
<gr>str</gr> - timing string


<h5>Example</h5>
<gr>    // returns 3000
    var milliseconds = htmx.parseInterval("3s");

    // returns 3 - Caution
    var milliseconds = htmx.parseInterval("3m");</gr>

<h3 id="JavascriptAPItopic-16">Method - <gr>htmx.process()</gr></h3>
Processes new content, enabling htmx behavior.  This can be useful if you have content that is added to the DOM outside of the normal htmx request cycle but still want htmx attributes to work.

<h5>Parameters</h5>
<gr>elt</gr> - element to process


<h5>Example</h5>
<gr>  document.body.innerHTML = "&lt;div hx-get='/example'&gt;Get it!&lt;/div&gt;"
  // process the newly added content
  htmx.process(document.body);</gr>

<h3 id="JavascriptAPItopic-17">Method - <gr>htmx.remove()</gr></h3>
Removes an element from the DOM

<h5>Parameters</h5>
<gr>elt</gr> - element to remove

or

<gr>elt</gr> - element to remove
<gr>delay</gr> - delay (in milliseconds ) before element is removed


<h5>Example</h5>
<gr>  // removes my-div from the DOM
  htmx.remove(htmx.find("#my-div"));

  // removes my-div from the DOM after a delay of 2 seconds
  htmx.remove(htmx.find("#my-div"), 2000);</gr>

<h3 id="JavascriptAPItopic-18">Method - <gr>htmx.removeClass()</gr></h3>
Removes a class from the given element

<h5>Parameters</h5>
<gr>elt</gr> - element to remove the class from
<gr>class</gr> - the class to remove

or

<gr>elt</gr> - element to remove the class from
<gr>class</gr> - the class to remove
<gr>delay</gr> - delay (in milliseconds ) before class is removed


<h5>Example</h5>
<gr>  // removes .myClass from my-div
  htmx.removeClass(htmx.find("#my-div"), "myClass");

  // removes .myClass from my-div after 6 seconds
  htmx.removeClass(htmx.find("#my-div"), "myClass", 6000);</gr>

<h3 id="JavascriptAPItopic-19">Method - <gr>htmx.removeExtension()</gr></h3>
Removes the given extension from htmx

<h5>Parameters</h5>
<gr>name</gr> - the name of the extension to remove


<h5>Example</h5>
<gr>  htmx.removeExtension("my-extension");</gr>

<h3 id="JavascriptAPItopic-20">Method - <gr>htmx.swap()</gr></h3>
Performs swapping (and settling) of HTML content

<h5>Parameters</h5>
<gr>target</gr> - the HTML element or string selector of swap target
<gr>content</gr> - string representation of content to be swapped
<gr>swapSpec</gr> - swapping specification, representing parameters from <gr>hx-swap</gr>

<gr>swapStyle</gr> (required) - swapping style (<gr>innerHTML</gr>, <gr>outerHTML</gr>, <gr>beforebegin</gr> etc)
<gr>swapDelay</gr>, <gr>settleDelay</gr> (number) - delays before swapping and settling respectively
<gr>transition</gr> (bool) - whether to use HTML transitions for swap
<gr>ignoreTitle</gr> (bool) - disables page title updates
<gr>head</gr> (string) - specifies <gr>head</gr> tag handling strategy (<gr>merge</gr> or <gr>append</gr>). Leave empty to disable head handling
<gr>scroll</gr>, <gr>scrollTarget</gr>, <gr>show</gr>, <gr>showTarget</gr>, <gr>focusScroll</gr> - specifies scroll handling after swap


<gr>swapOptions</gr> - additional <em>optional</em> parameters for swapping

<gr>select</gr> - selector for the content to be swapped (equivalent of <gr>hx-select</gr>)
<gr>selectOOB</gr> - selector for the content to be swapped out-of-band (equivalent of <gr>hx-select-oob</gr>)
<gr>eventInfo</gr> - an object to be attached to <gr>htmx:afterSwap</gr> and <gr>htmx:afterSettle</gr> elements
<gr>anchor</gr> - an anchor element that triggered scroll, will be scrolled into view on settle. Provides simple alternative to full scroll handling
<gr>contextElement</gr> - DOM element that serves as context to swapping operation. Currently used to find extensions enabled for specific element
<gr>afterSwapCallback</gr>, <gr>afterSettleCallback</gr> - callback functions called after swap and settle respectively. Take no arguments




<h5>Example</h5>
<gr>    // swap #output element inner HTML with div element with "Swapped!" text
    htmx.swap("#output", "&lt;div&gt;Swapped!&lt;/div&gt;", {swapStyle: 'innerHTML'});</gr>

<h3 id="JavascriptAPItopic-21">Method - <gr>htmx.takeClass()</gr></h3>
Takes the given class from its siblings, so that among its siblings, only the given element will have the class.

<h5>Parameters</h5>
<gr>elt</gr> - the element that will take the class
<gr>class</gr> - the class to take


<h5>Example</h5>
<gr>  // takes the selected class from tab2's siblings
  htmx.takeClass(htmx.find("#tab2"), "selected");</gr>

<h3 id="JavascriptAPItopic-22">Method - <gr>htmx.toggleClass()</gr></h3>
Toggles the given class on an element

<h5>Parameters</h5>
<gr>elt</gr> - the element to toggle the class on
<gr>class</gr> - the class to toggle


<h5>Example</h5>
<gr>  // toggles the selected class on tab2
  htmx.toggleClass(htmx.find("#tab2"), "selected");</gr>

<h3 id="JavascriptAPItopic-23">Method - <gr>htmx.trigger()</gr></h3>
Triggers a given event on an element

<h5>Parameters</h5>
<gr>elt</gr> - the element to trigger the event on
<gr>name</gr> - the name of the event to trigger
<gr>detail</gr> - details for the event


<h5>Example</h5>
<gr>  // triggers the myEvent event on #tab2 with the answer 42
  htmx.trigger("#tab2", "myEvent", {answer:42});</gr>

<h3 id="JavascriptAPItopic-24">Method - <gr>htmx.values()</gr></h3>
Returns the input values that would resolve for a given element via the htmx value resolution mechanism

<h5>Parameters</h5>
<gr>elt</gr> - the element to resolve values on
<gr>request type</gr> - the request type (e.g. <gr>get</gr> or <gr>post</gr>)  non-GET’s will include the enclosing form of the element.
Defaults to <gr>post</gr>


<h5>Example</h5>
<gr>  // gets the values associated with this form
  var values = htmx.values(htmx.find("#myForm"));</gr>












<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
});
</script>
