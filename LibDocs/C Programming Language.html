<html>
<head>
<title>C Programming Language</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px; font-family: monospace, monospace;}
strong, h1, h2 {color: gold;}
img {max-width:90%; width: 50%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style>
</head>
<body onkeypress="chkKey()">
<center><h1>C Programming Language</h1>
<div id="toc">
<a href="#Basics">Basics</a> .&emsp;
<a href="#VariableDeclarationDefinitionandScope">Variable Declaration, Definition and Scope</a> .&emsp;
<a href="#DataTypes">Data Types</a> .&emsp;
<a href="#StorageClasses">Storage Classes</a> .&emsp;
<a href="#InputOutput">Input/Output</a> .&emsp;
<a href="#Operators">Operators</a> .&emsp;
<a href="#Preprocessor">Preprocessor</a> .&emsp;
<a href="#Array&amp;Strings">Array &amp; Strings</a> .&emsp;
<a href="#ControlStatements">Control Statements</a> .&emsp;
<a href="#Functions">Functions</a> .&emsp;
<a href="#Pointers">Pointers</a> .&emsp;
<a href="#EnumStructandUnion">Enum, Struct and Union</a> .&emsp;
<a href="#MemoryManagement">Memory Management</a> .&emsp;
<a href="#FileHandling">File Handling</a> .&emsp;
<a href="#Puzzles">Puzzles</a> .&emsp;
<a href="#Misc">Misc</a> .&emsp;<br><br>
</div>
</center>
<pre>
C is a procedural programming language. 
It was initially developed by Dennis Ritchie as a system programming language to write operating system. 
The main features of C language include low-level access to memory, simple set of keywords, and clean style, these features make C language suitable for system programming like operating system or compiler development.
<strong><a name="Basics"></a>Basics: </strong>
<ol>
<li><a href="http://geeksquiz.com/c-language-set-1-introduction/">C Language Introduction</a></li>
<li><a href="https://www.geeksforgeeks.org/c-programming-language-standard/">C Programming Language Standard</a></li>
<li><a href="https://www.geeksforgeeks.org/int-1-sign-bit-31-data-bits-keyword-in-c/">int (1 sign bit + 31 data bits) keyword in C</a></li>
<li><a href="https://www.geeksforgeeks.org/fine-write-void-main-cc/">Is it fine to write “void main()” or “main()” in C/C++?</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-int-main-int-mainvoid/">Difference between “int main()” and “int main(void)” in C/C++?</a></li>
<li><a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Macros and Preprocessors in C</a></li>
<li><a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/">Compiling a C program:- Behind the Scenes</a></li>
<li><a href="https://www.geeksforgeeks.org/benefits-c-language-programming-languages/">Benefits of C over other languages</a></li>
<li><a href="https://www.geeksforgeeks.org/program-error-signals/">Program error signals</a></li>
<li><a href="https://www.geeksforgeeks.org/escape-sequences-c/">Escape sequences in C</a></li>
<li><a href="https://www.geeksforgeeks.org/line-splicing-in-c-cpp/">Line Slicing in C</a></li>
<li><a href="https://www.geeksforgeeks.org/cc-tokens/">C/ C++ Tokens</a></li>
</ol>
<strong><a name="VariableDeclarationDefinitionandScope"></a>Variable Declaration, Definition and Scope</strong>:
<ol>
<li><a title="Permalink to Variables and Keywords in C" href="http://geeksquiz.com/variables-and-keywords-in-c/">Variables and Keywords in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-16/">How are variables scoped in C – Static or Dynamic?</a></li>
<li><a href="https://www.geeksforgeeks.org/scope-rules-in-c/">Scope rules in C</a></li>
<li><a href="https://www.geeksforgeeks.org/how-linkers-resolve-multiply-defined-global-symbols/">How Linkers Resolve Multiply Defined Global Symbols?</a></li>
<li><a href="http://geeksquiz.com/c-language-2/variable-declaration-and-scope/">Quiz on Variable Declaration and Scope</a></li>
<li><a href="https://www.geeksforgeeks.org/complicated-declarations-in-c/">Complicated declarations in C</a></li>
<li><a title="Permalink to G-Fact 19 (Redeclaration of global variable in C)" href="https://www.geeksforgeeks.org/g-fact-19-redeclaration-of-global-variable-in-c/" rel="bookmark">Redeclaration of global variable in C</a></li>
<li><a href="https://www.geeksforgeeks.org/internal-linkage-external-linkage-c/">Internal and External Linkage</a></li>
<li><a href="https://www.geeksforgeeks.org/different-ways-declare-variable-constant-c-c/">Declare variable as constant</a></li>
<li><a href="https://www.geeksforgeeks.org/variable-name-not-start-numbers-c/">Why variables doesn&#8217;t start with numbers</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-19-redeclaration-of-global-variable-in-c/">Redeclaration of global variables</a></li>
<li><a href="https://www.geeksforgeeks.org/initialization-global-static-variables-c/">Initialization of global and static variables</a></li>
</ol>
<strong><a name="DataTypes"></a>Data Types: </strong>
<ol>
<li><a title="Permalink to Data Types in C" href="http://geeksquiz.com/data-types-in-c/">Data Types in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-94/">Use of bool in C</a></li>
<li><a title="Permanent link to Integer Promotions in C" href="https://www.geeksforgeeks.org/integer-promotions-in-c/" rel="bookmark">Integer Promotions in C</a></li>
<li><a href="http://geeksquiz.com/c-language-2/data-types/">Quiz on Data Types in C</a></li>
<li><a title="Permanent link to Comparison of a float with a value in C" href="https://www.geeksforgeeks.org/comparison-float-value-c/" rel="bookmark">Comparison of a float with a value in C</a></li>
<li><a href="https://www.geeksforgeeks.org/need-long-data-type-c-cpp/">Need of long data type in C</a></li>
<li><a href="https://www.geeksforgeeks.org/size_t-data-type-c-language/">size_t data type in C</a></li>
<li><a href="https://www.geeksforgeeks.org/interesting-facts-about-data-types-and-modifiers-in-c-cpp/">Interesting facts about data-types and modifiers</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-float-double-c-cpp/">Float and Double in C</a></li>
<li><a href="https://www.geeksforgeeks.org/character-arithmetic-c-c/">Character arithmetic in C</a></li>
<li><a href="https://www.geeksforgeeks.org/type-conversion-c/">Typecasting in C</a></li>
</ol>
<strong><a name="StorageClasses"></a>Storage Classes: </strong>
<ol>
<li><a href="http://geeksquiz.com/storage-classes-in-c/">Storage Classes in C</a></li>
<li><a href="http://geeksquiz.com/static-variables-in-c/">Static Variables in C</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">Understanding “extern” keyword in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-53/">What are the default values of static variables in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c/">Understanding “volatile” qualifier in C</a></li>
<li><a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">Const Qualifier in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-80/">Initialization of static variables in C</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-register-keyword/">Understanding “register” keyword in C</a></li>
<li><a href="http://geeksquiz.com/c-language-2/storage-classes/">Quiz on Storage Classes in C</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-volatile-qualifier-c-set-1-introduction/">Understanding volatile qualifier in C- Set 1</a></li>
</ol>
<strong><a name="InputOutput"></a>Input/Output: </strong>
<ol>
<li><a href="https://www.geeksforgeeks.org/g-fact-10/">Returned values of printf() and scanf()</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-11/">What is return type of getchar(), fgetc() and getc() ?</a></li>
<li><a href="https://www.geeksforgeeks.org/scansets-in-c/">Scansets in C</a></li>
<li><a href="https://www.geeksforgeeks.org/puts-vs-printf-for-printing-a-string/">puts() vs printf() for printing a string</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-31/">What is use of %n in printf() ?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-print-using-printf/">How to print % using printf()?</a></li>
<li><a href="http://geeksquiz.com/c-language-2/input-and-output/">Quiz on Input Output in C</a></li>
<li><a title="Permanent link to What is the difference between printf, sprintf and fprintf?" href="http://geeksquiz.com/difference-printf-sprintf-fprintf/" rel="bookmark">Difference between printf, sprintf and fprintf?</a></li>
<li><a title="Permanent link to Difference between getc(), getchar(), getch() and getche()" href="http://geeksquiz.com/difference-getchar-getch-getc-getche/" rel="bookmark">Difference between getc(), getchar(), getch() and getche()</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-d-format-specifier-c-language/">Difference between %d and %i format specifier</a></li>
<li><a href="https://www.geeksforgeeks.org/use-fflushstdin-c/">Use of fflush(stdin) in C</a></li>
<li><a href="https://www.geeksforgeeks.org/clearing-the-input-buffer-in-cc/">Clearing input buffer in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/scanf-and-fscanf-in-c-simple-yet-poweful/">scanf() and fscanf() in C </a></li>
<li><a href="https://www.geeksforgeeks.org/getchar_unlocked-faster-input-cc-competitive-programming/">getchar_unlocked() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/problem-with-scanf-when-there-is-fgetsgetsscanf-after-it/">Problem with scanf()</a></li>
<li><a href="https://www.geeksforgeeks.org/differentiate-printable-control-character-c/">Differentiate printable and control character</a></li>
<li><a href="https://www.geeksforgeeks.org/rand-and-srand-in-ccpp/">rand() and srand() in C/C++</a></li>
</ol>
<strong><a name="Operators"></a>Operators: </strong>
<ol>
<li><a href="http://geeksquiz.com/operators-in-c-set-1-arithmetic-operators/">Introduction to operators in C and Arithmetic Operators</a></li>
<li><a href="http://geeksquiz.com/operators-in-c-set-2-relational-and-logical-operators/">Relational and Logical Operators in C</a></li>
<li><a href="https://www.geeksforgeeks.org/interesting-facts-bitwise-operators-c/">Bitwise Operators in C</a></li>
<li><a href="https://www.geeksforgeeks.org/c-operator-precedence-associativity/">Operator Precedence and Associativity in C</a></li>
<li><a href="https://www.geeksforgeeks.org/evaluation-order-of-operands/">Evaluation order of operands</a></li>
<li><a href="https://www.geeksforgeeks.org/comna-in-c-and-c/">Comma in C and C++</a></li>
<li><a title="Permalink to sizeof operator in C" href="http://geeksquiz.com/sizeof-operator-c/">sizeof operator in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-9/">Operands for sizeof operator</a></li>
<li><a href="https://www.geeksforgeeks.org/a-comma-operator-question/">A comma operator question</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-78/">Result of comma operator as l-value in C and C++</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-74/">Order of operands for logical operators</a></li>
<li><a href="https://www.geeksforgeeks.org/increment-decrement-operators-require-l-value-expression/">Increment (Decrement) operators require L-value Expression</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-59/">Precedence of postfix ++ and prefix ++ in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/modulus-on-negative-numbers/">Modulus on Negative Numbers</a></li>
<li><a href="https://www.geeksforgeeks.org/cc-ternary-operator-some-interesting-observations/">C/C++ Ternary Operator – Some Interesting Observations</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-40/">Pre-increment (or pre-decrement) in C++</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-between-p-p-and-p/">Difference between ++*p, *p++ and *++p</a></li>
<li><a href="https://www.geeksforgeeks.org/results-of-comparison-operations-in-c-and-c/">Results of comparison operations in C and C++</a></li>
<li><a href="https://www.geeksforgeeks.org/to-find-sum-of-two-numbers-without-using-any-operator/">To find sum of two numbers without using any operator</a></li>
<li><a href="https://www.geeksforgeeks.org/sequence-points-in-c-set-1/">Sequence Points in C</a></li>
<li><a title="Permalink to Execution of printf with ++ operators" href="https://www.geeksforgeeks.org/execution-printf-operators/" rel="bookmark">Execution of printf with ++ operators</a></li>
<li><a href="https://www.geeksforgeeks.org/anything-written-sizeof-never-executed-c/">Anything written in sizeof() is never executed</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-strlen-sizeof-string-c-reviewed/">Difference between strlen() and sizeof()</a></li>
<li><a href="https://www.geeksforgeeks.org/and-operators-in-c/">Stringizing and Token-pasting operator</a></li>
</ol>
<strong><a name="Preprocessor"></a>Preprocessor</strong>:
<ol>
<li><a href="https://www.geeksforgeeks.org/write-a-c-macro-printx-which-prints-x/">Write a C macro PRINT(x) which prints x</a></li>
<li><a href="https://www.geeksforgeeks.org/variable-length-arguments-for-macros/">Variable length arguments for Macros</a></li>
<li><a href="https://www.geeksforgeeks.org/multiline-macros-in-c/">Multiline macros in C</a></li>
<li><a href="https://www.geeksforgeeks.org/crash-macro-interpretation/">CRASH() macro – interpretation</a></li>
<li><a href="https://www.geeksforgeeks.org/the-offsetof-macro/">The OFFSETOF() macro, </a></li>
<li><a href="https://www.geeksforgeeks.org/branch-prediction-macros-in-gcc/">Branch prediction macros in GCC</a></li>
<li><a title="Permanent link to Diffference between #define and const in C?" href="http://geeksquiz.com/diffference-define-const-c/" rel="bookmark">Diffference between #define and const in C?</a></li>
<li><a title="Permalink to A C Programming Language Puzzle" href="https://www.geeksforgeeks.org/a-c-puzzle/" rel="bookmark">A C Programming Language Puzzle</a></li>
<li><a title="Permalink to What’s difference between header files “stdio.h” and “stdlib.h” ?" href="http://geeksquiz.com/whats-difference-between-and/" rel="bookmark">What’s difference between header files “stdio.h” and “stdlib.h” ?</a></li>
<li><a title="Permalink to How to print a variable name in C?" href="http://geeksquiz.com/how-to-print-a-variable-name-in-c/" rel="bookmark">How to print a variable name in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/constants-in-c/">Constants in C</a></li>
<li><a href="https://www.geeksforgeeks.org/preprocessor-works-c/">How a Preprocessor works</a></li>
<li><a href="https://www.geeksforgeeks.org/cc-preprocessors/">Preprocessor Directives : Behind the scene-1</a></li>
<li><a href="https://www.geeksforgeeks.org/cpp-preprocessor-directives-set-2/">Preprocessor Directives : Behind the scene-2</a></li>
<li><a href="https://www.geeksforgeeks.org/isgraph-c-library-function/">isgraph() library function</a></li>
<li><a href="https://www.geeksforgeeks.org/write-header-file-c/">write your own header file in C</a></li>
<li><a href="https://www.geeksforgeeks.org/difftime-c-library-function/">difftime() library function</a></li>
<li><a href="https://www.geeksforgeeks.org/tmpnam-function-c/">tmpnam() library function</a></li>
<li><a href="https://www.geeksforgeeks.org/_generic-keyword-c/">_Generic keyword in C</a></li>
<li><a href="https://www.geeksforgeeks.org/c-library-math-h-functions/">math.h library functions</a></li>
<li><a href="https://www.geeksforgeeks.org/typedef-versus-define-c/">typedef versus #define in C</a></li>
<li><a href="https://www.geeksforgeeks.org/strftime-function-in-c/">strftime() library function</a></li>
<li><a href="https://www.geeksforgeeks.org/exec-family-of-functions-in-c/">exec family of functions</a></li>
</ol>
<strong><a name="Array&amp;Strings"></a>Arrays &amp; Strings</strong>:
<ol>
<li><a title="Permalink to Arrays in C Language | Set 1 (Introduction)" href="http://geeksquiz.com/arrays-in-c-language-set-1-introduction/" rel="bookmark">Introduction to Arrays in C Language</a></li>
<li><a href="https://www.geeksforgeeks.org/strings-in-c-2/">Strings in C Language</a></li>
<li><a href="http://geeksquiz.com/arrays-in-c-language-set-2-interesting-array-properties/">Properties of array in C Language</a></li>
<li><a href="https://www.geeksforgeeks.org/using-sizof-operator-with-array-paratmeters/">Do not use sizeof for array parameters</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-92/">Initialization of variables sized arrays in C</a></li>
<li><a href="https://www.geeksforgeeks.org/are-array-members-deeply-copied/">Are array members deeply copied?</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact/">What is the difference between single quoted and double quoted declaration of char array?</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-44/">Initialization of a multidimensional arrays in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/write-one-line-functions-for-strcat-and-strcmp/">Write one line functions for strcat() and strcmp()</a></li>
<li><a href="http://geeksquiz.com/whats-difference-between-char-s-and-char-s-in-c/">What’s difference between char s[] and char *s in C</a></li>
<li><a href="https://www.geeksforgeeks.org/gets-is-risky-to-use/">gets() is risky to use!</a></li>
<li><a href="https://www.geeksforgeeks.org/swap-strings-in-c/">C function to Swap strings, </a></li>
<li><a href="https://www.geeksforgeeks.org/storage-for-strings-in-c/">Storage for Strings in C</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-pointer-array-c/">Difference between array and pointer</a></li>
<li><a title="Permanent link to How to dynamically allocate a 2D array in C?" href="https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/" rel="bookmark">How to dynamically allocate a 2D array in C?</a></li>
<li><a title="Permanent link to How to pass a 2D array as a parameter in C?" href="https://www.geeksforgeeks.org/pass-2d-array-parameter-c/" rel="bookmark">How to pass a 2D array as a parameter in C?</a></li>
<li><a title="Permalink to How to write long strings in Multi-lines C/C++?" href="http://geeksquiz.com/how-to-write-long-strings-in-multi-lines-cc/" rel="bookmark">How to write long strings in Multi-lines C/C++?</a></li>
<li><a title="Permalink to What are the data types for which it is not possible to create an array?" href="http://geeksquiz.com/can-we-have-an-array-of-all-types-in-c/" rel="bookmark">What are the data types for which it is not possible to create an array?</a></li>
<li><a title="Permalink to Variable Length Arrays in C and C++" href="https://www.geeksforgeeks.org/variable-length-arrays-in-c-and-c/" rel="bookmark">Variable Length Arrays in C and C++</a></li>
<li><a href="https://www.geeksforgeeks.org/a-shorthand-array-notation-in-c-for-repeated-values/">Short hand array notation</a></li>
<li><a href="https://www.geeksforgeeks.org/accessing-array-bounds-ccpp/">Accessing array out of bounds</a></li>
<li><a href="https://www.geeksforgeeks.org/strcpy-in-c-cpp/">strcpy() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/strcmp-in-c-cpp/">strcmp() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/strdup-strdndup-functions-c/">strdup() and strdndup() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/pass-array-value-c/">Pass an array by value</a></li>
<li><a href="https://www.geeksforgeeks.org/quickly-reverse-string-c/">Reverse a string in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/strpbrk-in-c/">strpbrk() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/strcoll-in-cc/">strcoll() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/ispunct-function-c/">ispunct() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/strspn-function-c/">strspn() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/isalpha-isdigit-functions-c-example/">isalpha() and isdigit() in C/C++</a></li>
</ol>
<strong><a name="ControlStatements"></a>Control Statements: </strong>
<ol>
<li><a href="https://www.geeksforgeeks.org/g-fact-51/">What should be data type of case labels of switch statement in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/for-versus-while/">For Versus While</a></li>
<li><a href="https://www.geeksforgeeks.org/a-nested-loop-puzzle/">A nested loop puzzle</a></li>
<li><a href="https://www.geeksforgeeks.org/interesting-facts-about-switch-statement-in-c/">switch statement in C</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-while1-while0-c-language/">Difference between while(1) and while(0)</a></li>
<li><a href="https://www.geeksforgeeks.org/goto-statement-in-c-cpp/">goto statement </a></li>
<li><a href="https://www.geeksforgeeks.org/continue-statement-cpp/">Continue Statement</a></li>
<li><a href="https://www.geeksforgeeks.org/break-statement-cc/">Break Statement</a></li>
<li><a href="https://www.geeksforgeeks.org/using-range-switch-case-cc/">Using range in switch case</a></li>
</ol>
<strong><a name="Functions"></a>Functions</strong>:
<ol>
<li><a href="http://geeksquiz.com/functions-in-c/">Functions in C</a></li>
<li><a href="https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/">Importance of function prototype in C</a></li>
<li><a href="https://www.geeksforgeeks.org/functions-that-are-executed-before-and-after-main-in-c/">Functions that are executed before and after main() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/">return statement vs exit() in main()</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-count-variable-numbers-of-arguments-in-c/">How to Count Variable Numbers of Arguments in C?, </a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-20/">What is evaluation order of function parameters in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/does-c-support-function-overloading/">Does C support function overloading?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-can-i-return-multiple-values-from-a-function/">How can we return multiple values from a function?</a></li>
<li><a href="https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/">What is the purpose of a function prototype?</a></li>
<li><a href="https://www.geeksforgeeks.org/what-are-static-functions-in-c/">Static functions in C</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-exit-abort-and-assert/">exit(), abort() and assert()</a></li>
<li><a href="https://www.geeksforgeeks.org/implicit-return-type-int-c-language/">Implicit return type int in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-95/">What happens when a function is called before its declaration in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/_noreturn-function-specifier-c/">_Noreturn function specifier in C</a></li>
<li><a href="https://www.geeksforgeeks.org/exit-vs-_exit-c-cpp/">exit() vs _Exit()</a></li>
<li><a href="https://www.geeksforgeeks.org/predefined-identifier-__func__-c/">__func__ identifier in C</a></li>
<li><a href="https://www.geeksforgeeks.org/callbacks-in-c/">Callback function in C</a></li>
<li><a href="https://www.geeksforgeeks.org/nested-functions-c/">Nested functions in C</a></li>
<li><a href="https://www.geeksforgeeks.org/parameter-passing-techniques-in-c-cpp/">Parameter Passing Techniques</a></li>
<li><a href="https://www.geeksforgeeks.org/power-function-cc/">pow() function in C</a></li>
<li><a href="https://www.geeksforgeeks.org/tolower-function-in-c/">tolower() function in C</a></li>
<li><a href="https://www.geeksforgeeks.org/time-function-in-c/">time() function in C</a></li>
</ol>
<strong><a name="Pointers"></a>Pointers</strong>:
<ol>
<li><a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">Introduction to pointers in C and C++</a></li>
<li><a href="https://www.geeksforgeeks.org/double-pointer-pointer-pointer-c/">Double Pointer (Pointer to Pointer) in C</a></li>
<li><a href="https://www.geeksforgeeks.org/why-c-treats-array-parameters-as-pointers/">Why C treats array parameters as pointers?</a></li>
<li><a href="https://www.geeksforgeeks.org/dereference-reference-dereference-reference/">Output of the program | Dereference, Reference, Dereference, Reference</a></li>
<li><a title="Permalink to Dangling, Void , Null and Wild Pointers" href="https://www.geeksforgeeks.org/dangling-void-null-wild-pointers/" rel="bookmark">Dangling, Void , Null and Wild Pointers</a></li>
<li><a href="https://www.geeksforgeeks.org/an-uncommon-representation-of-array-elements/">An Uncommon representation of array elements</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-declare-a-pointer-to-a-function/">How to declare a pointer to a function?</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-5/">Pointer vs Array in C</a></li>
<li><a title="Permanent link to void pointer in C" href="http://geeksquiz.com/void-pointer-c/" rel="bookmark">void pointer in C</a></li>
<li><a title="Permalink NULL pointer in C !" href="http://geeksquiz.com/few-bytes-on-null-pointer-in-c/" rel="bookmark">NULL pointer in C !</a></li>
<li><a title="Permanent link to Function Pointer in C" href="https://www.geeksforgeeks.org/function-pointer-in-c/" rel="bookmark">Function Pointer in C</a></li>
<li><a href="http://geeksquiz.com/what-are-near-far-and-huge-pointers/">near, far and huge pointers</a></li>
<li><a title="Permanent link to Generic Linked List in C" href="https://www.geeksforgeeks.org/generic-linked-list-in-c-2/" rel="bookmark">Generic Linked List in C</a></li>
<li><a href="https://www.geeksforgeeks.org/restrict-keyword-c/">restrict keyword in C</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-const-char-p-char-const-p-const-char-const-p/">const char *p, char * const p and const char * const p</a></li>
<li><a href="https://www.geeksforgeeks.org/pointer-array-array-pointer/">Pointer to an Array</a></li>
</ol>
<a name="EnumStructandUnion"></a><strong>Enum, Struct and Union</strong>:
<ol>
<li><a href="http://geeksquiz.com/enumeration-enum-c/">Enum in C</a></li>
<li><a title="Permanent link to Structures in C" href="http://geeksquiz.com/structures-c/" rel="bookmark">Structures in C</a></li>
<li><a href="http://geeksquiz.com/union-c/">Union in C</a></li>
<li><a href="https://www.geeksforgeeks.org/struct-hack/">Struct Hack</a></li>
<li><a href="https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">Structure Member Alignment, Padding and Data Packing</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-68/">Operations on struct variables in C</a></li>
<li><a href="https://www.geeksforgeeks.org/bit-fields-c/">Bit Fields in C</a></li>
<li><a title="Permalink to Structure Sorting (By Multiple Rules) in C++" href="https://www.geeksforgeeks.org/structure-sorting-in-c/" rel="bookmark">Structure Sorting (By Multiple Rules) in C++</a></li>
<li><a href="https://www.geeksforgeeks.org/flexible-array-members-structure-c/">Flexible array members in structure</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-structure-union-c/">Difference between Structure and Union</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-c-structures-c-structures/">Difference between C structures and C++ structures</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-38-anonymous-union-and-structure/">Anonymous Union and Structure in C</a></li>
<li><a href="https://www.geeksforgeeks.org/compound-literals-c/">Compound Literals in C</a></li>
</ol>
<strong><a name="MemoryManagement"></a>Memory Management</strong>:
<ol>
<li><a href="https://www.geeksforgeeks.org/memory-layout-of-c-program/">Memory Layout of C Programs,</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-deallocate-memory-without-using-free-in-c/">How to deallocate memory without using free() in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/calloc-versus-malloc/">calloc() versus malloc()</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-88/">How does free() know the size of memory to be deallocated?</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-66/">Use of realloc()</a></li>
<li><a href="https://www.geeksforgeeks.org/what-is-memory-leak-how-can-we-avoid/">What is Memory Leak? How can we avoid?</a></li>
</ol>
<strong><a name="FileHandling"></a>File Handling</strong>:
<ol>
<li><a href="https://www.geeksforgeeks.org/g-fact-82/">fseek() vs rewind() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/eof-and-feof-in-c/">EOF, getc() and feof() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/fopen-for-an-existing-file-in-write-mode/">fopen() for an existing file in write mode</a></li>
<li><a href="https://www.geeksforgeeks.org/readwrite-structure-file-c/">Read/Write structure to a file</a></li>
<li><a href="https://www.geeksforgeeks.org/fgets-gets-c-language/">fgets() and gets() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/basics-file-handling-c/">Basics of File Handling</a></li>
<li><a href="https://www.geeksforgeeks.org/fsetpos-set-file-position-in-c/">fsetpos() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/rename-function-in-ccpp/">rename function in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/tmpfile-function-c/">tmpfile() function in C</a></li>
<li><a href="https://www.geeksforgeeks.org/fgetc-fputc-c/">fgetc() and fputc() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/fseek-in-c-with-example/">fseek() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/ftell-c-example/">ftell() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/lseek-in-c-to-read-the-alternate-nth-byte-and-write-it-in-another-file/">lseek() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-delete-file/">remove function in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-merge-contents-two-files-third-file/">Merge contents of two files into a third file</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-print-contents-file/">Print contents of file in C</a></li>
</ol>
<strong><a name="Puzzles"></a>Puzzles</strong>:
<ol>
<li><a href="http://geeksquiz.com/c-program-to-print-numbers-from-1-to-n-without-using-semicolon/">C Program to print numbers from 1 to N without using semicolon?</a></li>
<li><a href="https://www.geeksforgeeks.org/to-find-sum-of-two-numbers-without-using-any-operator/">How to find sum of two numbers without using any operator</a></li>
<li><a href="https://www.geeksforgeeks.org/how-will-you-show-memory-representation-of-c-variables/">How will you show memory representation of C variables?</a></li>
<li><a href="https://www.geeksforgeeks.org/condition-to-print-helloword/">Condition To Print “HelloWord”</a></li>
<li><a href="https://www.geeksforgeeks.org/changeadd-only-one-character-and-print-exactly-20-times/">Change/add only one character and print ‘*’ exactly 20 times</a></li>
<li><a href="https://www.geeksforgeeks.org/how-can-we-sum-the-digits-of-a-given-number-in-single-statement/">How can we sum the digits of a given number in single statement?</a></li>
<br/>
<li><a href="https://www.geeksforgeeks.org/what-is-the-best-way-in-c-to-convert-a-number-to-a-string/">What is the best way in C to convert a number to a string?</a></li>
<li><a href="https://www.geeksforgeeks.org/calculate-logn-in-one-line/">Calculate Logn in one line</a></li>
<li><a href="https://www.geeksforgeeks.org/even-or-odd-without-using-condtional-statement/">Print “Even” or “Odd” without using Conditional statement</a></li>
<li><a href="https://www.geeksforgeeks.org/how-will-you-print-numbers-from-1-to-200-without-using-loop/">How will you print numbers from 1 to 100 without using loop?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-can-we-sum-the-digits-of-a-given-number-in-single-statement/">How can we sum the digits of a given number in single statement?</a></li>
<li><a href="https://www.geeksforgeeks.org/write-a-c-program-to-print-geeks-for-geeks-without-using-a-semicolon/">How will you print “Geeks for Geeks” without using a semicolon</a></li>
<li><a href="https://www.geeksforgeeks.org/write-a-c-function-to-round-floating-point-numbers/">Write a one line C function to round floating point numbers</a></li>
<li><a href="https://www.geeksforgeeks.org/implement-your-own-sizeof/">How will implement Your Own sizeof</a></li>
<li><a href="https://www.geeksforgeeks.org/count-set-bits-floating-point-number/">How to count set bits in a floating point number in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/c-puzzle/">How to change the output of printf() in main() ?</a></li>
<li><a href="https://www.geeksforgeeks.org/find-length-string-without-strlen-loop/">How to find length of a string without string.h and loop in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/implement-itoa/">Implement your own itoa()</a></li>
<li><a href="https://www.geeksforgeeks.org/write-a-c-program-that-doesnt-terminate-when-ctrlc-is-pressed/">Write a C program that does not terminate when Ctrl+C is pressed</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-measure-time-taken-by-a-program-in-c/">How to measure time taken by a function in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/print-long-int-number-c-using-putchar/">Print a long int in C using putchar() only</a></li>
<li><a title="Permanent link to Convert a floating point number to string in C" href="https://www.geeksforgeeks.org/convert-floating-point-number-string/" rel="bookmark">Convert a floating point number to string in C</a></li>
<li><a title="Permanent link to How to write a running C code without main()?" href="https://www.geeksforgeeks.org/write-running-c-code-without-main/" rel="bookmark">How to write a running C code without main()?</a></li>
<li><a title="Permanent link to Write your own memcpy()" href="https://www.geeksforgeeks.org/write-memcpy/" rel="bookmark">Write your own memcpy()</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-print-characters-without-using-format-specifiers/">C program to print characters without using format specifiers</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-print-string-without-quote-singe-double-program/">C program to print a string without any quote (singe or double) in the program</a></li>
<li><a href="https://www.geeksforgeeks.org/execute-else-statements-cc-simultaneously/">Execute both if and else statements simultaneously</a></li>
<li><a href="https://www.geeksforgeeks.org/print-hello-world-c-without-using-header-file/">Print “Hello World” without using any header file</a></li>
</ol>
<strong><a name="Misc"></a>Misc</strong>:
<ol>
<li><a href="https://www.geeksforgeeks.org/quine-a-self-reproducing-program/">Quine – A self-reproducing program</a></li>
<li><a href="https://www.geeksforgeeks.org/complicated-declarations-in-c/">Complicated declarations in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-94/">Use of bool in C</a></li>
<li><a href="https://www.geeksforgeeks.org/sequence-points-in-c-set-1/">Sequence Points in C | Set 1</a></li>
<li><a href="https://www.geeksforgeeks.org/optimization-techniques-set-2-swapping/">Optimization Techniques | Set 2 (swapping), </a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-72/">ASCII NUL, ASCII 0 (’0?) and Numeric literal 0</a></li>
<li><a href="https://www.geeksforgeeks.org/little-and-big-endian-mystery/">Little and Big Endian Mystery, </a></li>
<li><a href="https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/">Comparator function of qsort() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/program-to-validate-an-ip-address/">Program to validate an IP address</a></li>
<li><a title="Permanent link to Multithreading in C" href="https://www.geeksforgeeks.org/multithreading-c-2/" rel="bookmark">Multithreading in C</a></li>
<li><a title="Permanent link to Assertions in C/C++" href="http://geeksquiz.com/assertions-cc/" rel="bookmark">Assertions in C/C++</a></li>
<li><a href="http://geeksquiz.com/fork-system-call/">fork() in C</a></li>
<li><a title="Permalink to Interesting Facts in C Programming" href="https://www.geeksforgeeks.org/interesting-facts-in-c-programming/" rel="bookmark">Interesting Facts in C Programming</a></li>
<li><a title="Permalink to Precision of floating point numbers in C++ (floor(), ceil(), trunc(), round() and setprecision())" href="https://www.geeksforgeeks.org/precision-of-floating-point-numbers-in-c-floor-ceil-trunc-round-and-setprecision/" rel="bookmark">Precision of floating point numbers in C++ (floor(), ceil(), trunc(), round() and setprecision())</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact22-concept-of-setjump-and-longjump/">setjump() and longjump() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-37-nextafter-nexttoward-c/">nextafter() and nexttoward() in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/pthread_cancel-c-example/">pthread_cancel() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/pthread_equal-c-example/">pthread_equal() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/pthread_self-c-example/">pthread_self() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/local-labels-in-c/">Local Labels in C</a></li>
<li><a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/">lvalue and rvalue in C</a></li>
<li><a href="https://www.geeksforgeeks.org/get-stack-size-set-stack-size-thread-attribute-c/">Get and set the stack size of thread attribute</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-fork-exec/">Difference between fork() and exec()</a></li>
<li><a href="https://www.geeksforgeeks.org/errors-in-cc/">Errors in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/c-considered-faster-languages/">Why is C considered faster than other languages</a></li>
<li><a href="https://www.geeksforgeeks.org/incompatibilities-between-c-and-cpp/"> Incompatibilities between C and C++</a></li>
<li><a href="https://www.geeksforgeeks.org/convert-cc-code-to-assembly-language/">Convert C/C++ code to assembly language</a></li>
<li><a href="https://www.geeksforgeeks.org/error-handling-c-programs/">Error Handling in C</a></li>
<li><a href="https://www.geeksforgeeks.org/executing-main-in-c-behind-the-scene/">Executing main() in C/C++ : Behind the scene</a></li>
<li><a href="https://www.geeksforgeeks.org/hygienic-macros-introduction/">Hygienic Macros in C</a></li>
<li><a href="https://www.geeksforgeeks.org/command-line-arguments-in-c-cpp/">Command line arguments in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/scanf-fscanf-sscanf-scanf_s-fscanf_s-sscanf_s/">scanf(), fscanf(), sscanf(), scanf_s(), fscanf_s(), sscanf_s()</a></li>
<li><a href="https://www.geeksforgeeks.org/interesting-facts-in-c-programming/">Some Interesting Facts in C Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/database-connectivity-using-cc/">Database Connectivity using C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/function-interposition-in-c-with-an-example-of-user-defined-malloc/">Function Interposition in C</a></li>
<li><a href="https://www.geeksforgeeks.org/macros-vs-functions/">Macros vs Functions</a></li>
<li><a href="https://www.geeksforgeeks.org/write-memcpy/">Write your own memcpy() and memmove()</a></li>
</ol>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<h2>C Language Introduction</h2>
C is a procedural programming language. 
It was initially developed by Dennis Ritchie in the year 1972. 
<!--more-->It was mainly developed as a system programming language to write an operating system. 
The main features of C language include low-level access to memory, a simple set of keywords, and clean style, these features make C language suitable for system programmings like an operating system or compiler development.<br />
Many later languages have borrowed syntax/features directly or indirectly from C language. 
Like syntax of Java, PHP, JavaScript, and many other languages are mainly based on C language. 
C++ is nearly a superset of C language (There are few programs that may compile in C, but not in C++). 
<strong>Beginning with C programming:</strong>
<ol>
<li><b>Structure of a C program</b><br />
After the above discussion, we can formally assess the structure of a C program. 
By structure, it is meant that any program can be written in this structure only. 
Writing a C program in any other structure will hence lead to a Compilation Error.
The structure of a C program is as follows:
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/StructureOfCprogram.png" alt="">
The components of the above structure are:
<ol>
<li><b>Header Files Inclusion</b>: The first and foremost component is the inclusion of the Header files in a C program.<br />
A header file is a file with extension .h which contains C function declarations and macro definitions to be shared between several source files.
Some of C Header files:
<ul>
<li>stddef.h &#8211;  Defines several useful types and macros.</li>
<li>stdint.h  &#8211;  Defines exact width integer types.</li>
<li>stdio.h   &#8211;  Defines core input and output functions</li>
<li>stdlib.h  &#8211;  Defines numeric conversion functions, pseudo-random network generator, memory allocation</li>
<li>string.h  &#8211;  Defines string handling functions</li>
<li>math.h  &#8211;  Defines common mathematical functions</li>
</ul>
<b>Syntax to include a header file in C:</b>
<pre>
#include 
</pre>
</li>
<li><b>Main Method Declaration:</b> The next part of a C program is to declare the main() function. 
The syntax to declare the main function is:
<b>Syntax to Declare main method:</b>
<pre>
int main()
{}
</pre>
</li>
<li><b>Variable Declaration:</b> The next part of any C program is the variable declaration. 
It refers to the variables that are to be used in the function. 
Please note that in the C program, no variable can be used without being declared. 
Also in a C program, the variables are to be declared before any operation in the function.
<b>Example:</b>
<pre>
int main()
{
    <b>int a;</b>
.
.
</pre>
</li>
<li><b>Body:</b> Body of a function in C program, refers to the operations that are performed in the functions. 
It can be anything like manipulations, searching, sorting, printing, etc.
<b>Example:</b>
<pre>
int main()
{
    int a;
    <b>printf("%d", a);</b>
.
.
</pre>
</li>
<li><b>Return Statement:</b> The last part in any C program is the return statement. 
The return statement refers to the returning of the values from a function. 
This return statement and return value depend upon the return type of the function. 
For example, if the return type is void, then there will be no return statement. 
In any other case, there will be a return statement and the return value will be of the type of the specified return type.
<b>Example:</b>
          
<pre>
int main()
{
    int a;
    printf("%d", a);
    <b>return 0;</b>
}
</pre></li></ol>
</li>
<li><strong>Writing first program:</strong><br />
Following is first program in C
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Let us analyze the program line by line.<br />
<em><strong>Line 1: [ #include &lt;stdio.h&gt; ]</strong></em> In a C program, all lines that start with <strong># </strong>are processed by <a href="http://en.wikipedia.org/wiki/C_preprocessor">preprocessor </a>which is a program invoked by the compiler. 
In a very basic term, <a href="http://en.wikipedia.org/wiki/C_preprocessor">preprocessor </a>takes a C program and produces another C program. 
The produced program has no lines starting with #, all such lines are processed by the preprocessor. 
In the above example, preprocessor copies the preprocessed code of stdio.h to our file. 
The .h files are called header files in C. 
These header files generally contain declaration of functions. 
We need stdio.h for the function printf() used in the program. 
<em><strong>Line 2 [ int main(void) ]</strong></em> There must to be starting point from where execution of compiled C program begins. 
In C, the execution typically begins with first line of main(). 
The void written in brackets indicates that the main doesn&#8217;t take any parameter (See <a href="https://www.geeksforgeeks.org/difference-int-main-int-mainvoid/">this </a>for more details). 
main() can be written to take parameters also. 
We will be covering that in future posts.<br />
The int written before main indicates return type of main(). 
The value returned by main indicates status of program termination. 
See <a href="https://www.geeksforgeeks.org/fine-write-void-main-cc/">this </a>post for more details on return type.
<em><strong>Line 3 and 6: [ { and } ]</strong></em> In C language, a pair of curly brackets define a scope and mainly used in functions and control statements like if, else, loops. 
All functions must start and end with curly brackets. 
<em><strong>Line 4 [ printf(&#8220;GeeksQuiz&#8221;); ]</strong></em> <a href="http://www.cplusplus.com/reference/cstdio/printf/">printf()</a> is a standard library function to print something on standard output. 
The semicolon at the end of printf indicates line termination. 
In C, semicolon is always used to indicate end of statement. 
<em><strong>Line 5 [ return 0; ]</strong></em> The return statement returns the value from main(). 
The returned value may be used by operating system to know termination status of your program. 
The value 0 typically means successful termination.
</li>
<li><strong>How to excecute the above program:</strong><br />
Inorder to execute the above program, we need to have a compiler to compile and run our programs. 
There are certain online compilers like <a href="https://ide.geeksforgeeks.org/">https://ide.geeksforgeeks.org/</a>, <a href="http://ideone.com/">http://ideone.com/</a> or <a href="http://codepad.org/">http://codepad.org/</a> that can be used to start C without installing a compiler.<br />
<em><strong></strong></em>
<em><strong>Windows:</strong></em> There are many compilers available freely for compilation of C programs like <a href="http://www.codeblocks.org/downloads/26">Code Blocks </a> and <a href="http://www.bloodshed.net/download.html">Dev-CPP</a>. 
  We strongly recommend Code Blocks.
<em><strong>Linux:</strong></em> For Linux, <a href="http://en.wikipedia.org/wiki/GNU_Compiler_Collection">gcc </a>comes bundled with the linux,  Code Blocks can also be used with Linux.</li></ol>
<h2>C Programming Language Standard</h2>
The idea of this article is to introduce C standard. 
<strong>What to do when a C program produces different results in two different compilers?</strong><br />
For example, consider the following simple C program.<!--more-->
<code class="keyword bold">void</code> <code class="plain">main() {&nbsp; } </code>
The above program fails in gcc as the return type of main is void, but it compiles in Turbo C. 
How do we decide whether it is a legitimate C program or not? 

Consider the following program as another example. 
It produces different results in different compilers.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d\n"</code><code class="plain">, i++, i++, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
2 1 3 - using g++ 4.2.1 on Linux.i686
1 2 3 - using SunStudio C++ 5.9 on Linux.i686
2 1 3 - using g++ 4.2.1 on SunOS.x86pc
1 2 3 - using SunStudio C++ 5.9 on SunOS.x86pc
1 2 3 - using g++ 4.2.1 on SunOS.sun4u
1 2 3 - using SunStudio C++ 5.9 on SunOS.sun4u</pre>
Source: <a href="http://stackoverflow.com/questions/376278/parameter-evaluation-order-before-a-function-calling-in-c">Stackoverflow</a>
Which compiler is right?
The answer to all such questions is C standard. 
In all such cases we need to see what C standard says about such programs.
<strong>What is C standard?</strong><br />
The latest C standard is <a href="http://en.wikipedia.org/wiki/C11_(C_standard_revision)">ISO/IEC 9899:2011</a>, also known as <a href="http://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11 </a>as the final draft was published in 2011. 
 Before C11, there was <a href="http://en.wikipedia.org/wiki/C99">C99</a>. 
The C11 final draft is available <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf">here</a>. 
See <a href="http://en.wikipedia.org/wiki/C_(programming_language)#History">this </a>for complete history of C standards.
<strong>Can we know behavior of all programs from C standard?</strong><br />
C standard leaves some behavior of many C constructs as <a href="http://en.wikipedia.org/wiki/Undefined_behavior">undefined </a>and some as <a href="http://en.wikipedia.org/wiki/Unspecified_behavior">unspecified </a>to simplify the specification and allow some flexibility in implementation. 
For example, in C the use of any automatic variable before it has been initialized yields undefined behavior  and order of evaluations of subexpressions is unspecified. 
This specifically frees the compiler to do whatever is easiest or most efficient, should such a program be submitted.
<strong>So what is the conclusion about above two examples?</strong><br />
Let us consider the first example which is “void main() {}”, the standard says following about prototype of main().
<pre>
The function called at program startup is named main. 
The implementation 
declares no prototype for this function. 
It shall be defined with a return 
type of int and with no parameters:
       int main(void) { /* ...*/ }
or with two parameters (referred to here as argc and argv, though any names 
may be used, as they are local to the function in which they are declared):
       int main(int argc, char *argv[]) { /* ...*/ }
or equivalent;10) or in some other implementation-defined manner.
</pre>
So the return type void doesn&#8217;t follow the standard and it&#8217;s something allowed by certain compilers.
Let us talk about second example. 
Note the following statement in C standard is listed under unspecified behavior.
<pre>The order in which the function designator, arguments, and 
subexpressions within the arguments are evaluated in a function 
call (6.5.2.2). 
</pre>
<strong>What to do with programs whose behavior is undefined or unspecified in standard?</strong><br />
As a programmer, it is never a good idea to use programming constructs whose behaviour is undefined or unspecified, such programs should always be discouraged. 
The output of such programs may change with compiler and/or machine.
<h2>int (1 sign bit + 31 data bits) keyword in C</h2>
In C programming language a most common keyword ‘int’ is used to define any positive or negative integer. 
But there is a difference between an integer and the numbers which can be represented with the help of the keyword ‘int’. 
Not every integer can be represented with the keyword ‘int’. 
According to MinGW the size of one ‘int’ is 4 bytes which is equal to 32 bits (1 byte=8 bits). 
It is still a myth somewhere that ‘int’ can represent an integer or ‘int’ is used to represent integers. 
Integer is a very vast category of numbers where as one ‘int’ has limited and exact amount of memory (size of ‘int’ is 4 bytes or 32 bits) to store what is being represented by it. 
An ‘int’ type variable in C language is able to store only numbers till 2147483647. 
Beyond this number ‘int’ fails to store precisely and even not correctly. 
‘int’ is a 32 bit data type. 
Whenever a number is being assigned to an ‘int’ type variable, it is first converted to its binary representation (that is in 0’s and 1’s) then it is kept in memory at specific location. 
An ‘int’ is actually 1 sign bit + 31 data bits, that is 31 bits are available for storing the number being assigned to a ‘int’ type variable and 1 bit is reserved for maintaining the sign of the number which is either + or  &#8211; . 
The sign is also represented by binary digits, 0 for positive sign and 1 for negative sign. 
Let us understand this by an example.<br />
<b>Example &#8211;</b> Consider, 
<pre>int num=2147483647; </pre>
At this point first 2147483647 will be converted into its binary form which is equal to:<br />
1111111111111111111111111111111.
1111111111111111111111111111111 is a 31 digit binary number which will be assigned to variable num’s right most 31 bits and the 32nd bit will have a zero(0) as the number being assigned to variable num is a positive number. 
If we try to store any number greater than 2147483647 into an ‘int’ type variable then we will lose information.
<h2>Is it fine to write &#8220;void main()&#8221; or &#8220;main()&#8221; in C/C++?</h2>
The definition
<code class="keyword bold">void</code> <code class="plain">main() { </code><code class="comments">/* ...*/</code> <code class="plain">} </code>
is not and never has been C++, nor has it even been C. 
<!--more-->See the ISO C++ standard 3.6.1[2] or the ISO C standard 5.1.2.2.1. 
A conforming implementation accepts
<code class="color1 bold">int</code> <code class="plain">main() { </code><code class="comments">/* ...*/</code> <code class="plain">}</code>
and<br/>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc, </code><code class="color1 bold">char</code><code class="plain">* argv[]) { </code><code class="comments">/* ...*/</code> <code class="plain">}</code>
A conforming implementation may provide more versions of main(), but they must all have return type int. 
The int returned by main() is a way for a program to return a value to &#8220;the system&#8221; that invokes it. 
On systems that doesn&#8217;t provide such a facility the return value is ignored, but that doesn&#8217;t make &#8220;void main()&#8221; legal C++ or legal C. 
<strong><em>Even if your compiler accepts &#8220;void main()&#8221; avoid it, or risk being considered ignorant by C and C++ programmers.<br />
In C++, main() need not contain an explicit return statement. 
In that case, the value returned is 0, meaning successful execution.</em></strong> For example:
<code class="preprocessor">#include &lt;iostream> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"This program returns the integer value 0\n"</code><code class="plain">; </code>
<code class="plain">}</code>
Note also that neither ISO C++ nor C99 allows you to leave the type out of a declaration. 
That is, in contrast to C89 and ARM C++ ,&#8221;int&#8221; is not assumed where a type is missing in a declaration. 
Consequently:
<code class="preprocessor">#include &lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">main() { </code><code class="comments">/* ...*/</code> <code class="plain">}</code>
is an error because the return type of main() is missing.
Source: <a href="http://www.stroustrup.com/bs_faq2.html#void-main">http://www.stroustrup.com/bs_faq2.html#void-main</a>
To summarize above, it is never a good idea to use &#8220;void main()&#8221; or just &#8220;main()&#8221; as it doesn&#8217;t confirm standards. 
It may be allowed by some compilers though.
<h2>Difference between &#8220;int main()&#8221; and &#8220;int main(void)&#8221; in C/C++?</h2>
Consider the following two definitions of main().<!--more-->
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/*&nbsp; */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
and
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/*&nbsp; */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
What is the difference?
In C++, there is no difference, both are same.
Both definitions work in C also, but the second definition with void is considered technically better as it clearly specifies that main can only be called without any parameter.<br />
In C, if a function signature doesn&#8217;t specify any argument, it means that the function can be called with any number of parameters or without any parameters. 
For example, try to compile and run following two C programs (remember to save your files as .c). 
Note the difference between two signatures of fun().
<code class="comments">// Program 1 (Compiles and runs fine in C, but not in C++) </code>
<code class="keyword bold">void</code> <code class="plain">fun() {&nbsp; }&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(10, </code><code class="string">"GfG"</code><code class="plain">, </code><code class="string">"GQ"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The above program compiles and runs fine (See <a href="http://ideone.com/AQoVZW">this</a>), but the following program fails in compilation (see <a href="http://ideone.com/IXojiK">this</a>)
<code class="comments">// Program 2 (Fails in compilation in both C and C++) </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="keyword bold">void</code><code class="plain">) {&nbsp; } </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(10, </code><code class="string">"GfG"</code><code class="plain">, </code><code class="string">"GQ"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Unlike C, in C++, both of the above programs fails in compilation. 
In C++, both fun() and fun(void) are same.
So the difference is, in C, <em>int main()</em> can be called with any number of arguments, but <em>int main(void)</em> can only be called without any argument. 
Although it doesn&#8217;t make any difference most of the times, using &#8220;int main(void)&#8221; is a recommended practice in C.
<strong>Exercise:</strong><br />
Predict the output of following <strong>C</strong> programs.
<strong>Question 1</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(--i){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">main(10); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<strong>Question 2</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(--i){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">main(10); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<h2>Interesting Facts about Macros and Preprocessors in C</h2>
In a C program, all lines that start with <strong>#</strong> are processed by preprocessor which is a special program invoked by the compiler.<!--more--> In a very basic term, preprocessor takes a C program and produces another C program without any <strong>#</strong>.
Following are some interesting facts about preprocessors in C.<br />
<strong>1)</strong> When we use <em><strong>include</strong> </em>directive,  the contents of included header file (after preprocessing) are copied to the current file.<br />
Angular brackets <strong>&lt;</strong> and <strong>&gt;</strong> instruct the preprocessor to look in the standard folder where all header files are held.  Double quotes <strong>&#8220;</strong> and <strong>&#8220;</strong> instruct the preprocessor to look into the current folder (current directory).<br />
<strong>2) </strong>When we use<em><strong> define </strong></em>for a constant, the preprocessor produces a C program where the defined constant is searched and matching tokens are replaced with the given expression. 
For example in the following program <em>max </em>is defined as 100.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define max 100 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"max is %d"</code><code class="plain">, max); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
max is 100
</pre>

<strong>3)</strong> The macros can take function like arguments, the arguments are not checked for data type. 
For example, the following macro INCREMENT(x) can be used for x of any data type.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define INCREMENT(x) ++x </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr = </code><code class="string">"GeeksQuiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s&nbsp; "</code><code class="plain">, INCREMENT(ptr)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, INCREMENT(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
eeksQuiz  11
</pre>
<strong>4)</strong> The macro arguments are not evaluated before macro expansion. 
For example, consider the following program
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define MULTIPLY(a, b) a*b </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The macro is expended as 2 + 3 * 3 + 5, not as 5*8 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, MULTIPLY(2+3, 3+5)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Output: 16</code>
<b>Output:</b>
<pre>
16
</pre>
The previous problem can be solved using following program
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="comments">//here, instead of writing a*a we write (a)*(b) </code>
<code class="preprocessor">#define MULTIPLY(a, b) (a)*(b) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The macro is expended as (2 + 3) * (3 + 5), as 5*8 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, MULTIPLY(2+3, 3+5)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Santanu </code>
<b>Output:</b>
<pre>
40
</pre>
<strong>5)</strong> The tokens passed to macros can be concatenated using operator <strong>##</strong> called Token-Pasting operator.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define merge(a, b) a##b </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, merge(12, 34)); </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
1234
</pre>
<strong>6)</strong> A token passed to macro can be converted to a string literal by using # before it.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define get(a) #a </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksQuiz is changed to "GeeksQuiz" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, get(GeeksQuiz)); </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
GeeksQuiz
</pre>
<strong>7)</strong> The macros can be written in multiple lines using &#8216;\&#8217;. 
The last line doesn&#8217;t need to have &#8216;\&#8217;.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define PRINT(i, limit) while (i &lt; limit) \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz "</code><code class="plain">); \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">PRINT(i, 3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
GeeksQuiz GeeksQuiz GeeksQuiz
</pre>
<strong>8) </strong>The macros with arguments should be avoided as they cause problems sometimes. 
And Inline functions should be preferred as there is type checking parameter evaluation in inline functions. 
From <a href="http://en.wikipedia.org/wiki/C99">C99</a> onward, inline functions are supported by C language also.<br />
For example consider the following program. 
From first look the output seems to be 1, but it produces 36 as output.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define square(x) x*x </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Expanded as 36/6*6 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 36/square(6);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
36
</pre>
If we use inline functions, we get the expected output. 
Also, the program given in point 4 above can be corrected using inline functions.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">static</code> <code class="keyword bold">inline</code> <code class="color1 bold">int</code> <code class="plain">square(</code><code class="color1 bold">int</code> <code class="plain">x) { </code><code class="keyword bold">return</code> <code class="plain">x*x; } </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="color1 bold">int</code> <code class="plain">x = 36/square(6); </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
1
</pre>
<strong>9)</strong> Preprocessors also support if-else directives which are typically used for conditional compilation.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="preprocessor">#if VERBOSE >= 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Trace Message"</code><code class="plain">); </code>
<code class="preprocessor">#endif </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
No Output
</pre>
<strong>10)</strong> A header file may be included more than one time directly or indirectly, this leads to problems of redeclaration of same variables/functions. 
To avoid this problem, directives like <em><strong>defined</strong></em>, <em><strong>ifdef </strong></em>and <em><strong>ifndef </strong></em> are used.<br />
<strong>11)</strong> There are some standard macros which can be used to print program file (__FILE__), Date of compilation (__DATE__), Time of compilation (__TIME__) and Line Number in C code (__LINE__)
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Current File :%s\n"</code><code class="plain">, __FILE__ ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Current Date :%s\n"</code><code class="plain">, __DATE__ ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Current Time :%s\n"</code><code class="plain">, __TIME__ ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Line Number :%d\n"</code><code class="plain">, __LINE__ ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Current File :/usr/share/IDE_PROGRAMS/C/other/081c548d50135ed88cfa0296159b05ca/081c548d50135ed88cfa0296159b05ca.c
Current Date :Sep  4 2019
Current Time :10:17:43
Line Number :9
</pre>
<strong>12)</strong> We can remove already defined macros using : </br><strong>#undef MACRO_NAME</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define LIMIT 100 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,LIMIT); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">//removing defined macro LIMIT </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef LIMIT </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">//Next line causes error as LIMIT is not defined </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,LIMIT); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Santanu </code>
Following program is executed correctly as we have declared LIMIT as an integer variable after removing previously defined macro LIMIT
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define LIMIT 1000 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,LIMIT); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">//removing defined macro LIMIT </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef LIMIT </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">//Declare LIMIT as integer again </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">LIMIT=1001; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n%d"</code><code class="plain">,LIMIT); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
1000
1001
</pre>
Another interesting fact about macro using (<strong>#undef</strong>)
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="comments">//div function prototype </code>
<code class="color1 bold">float</code> <code class="functions bold">div</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">, </code><code class="color1 bold">float</code><code class="plain">); </code>
<code class="preprocessor">#define div(x, y) x/y </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="comments">//use of macro div </code>
<code class="comments">//Note: %0.2f for taking two decimal value after point </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%0.2f"</code><code class="plain">,</code><code class="functions bold">div</code><code class="plain">(10.0,5.0)); </code>
<code class="comments">//removing defined macro div </code>
<code class="preprocessor">#undef div </code>
<code class="comments">//function div is called as macro definition is removed </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n%0.2f"</code><code class="plain">,</code><code class="functions bold">div</code><code class="plain">(10.0,5.0)); </code>
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//div function definition </code>
<code class="color1 bold">float</code> <code class="functions bold">div</code><code class="plain">(</code><code class="color1 bold">float</code> <code class="plain">x, </code><code class="color1 bold">float</code> <code class="plain">y){ </code>
<code class="keyword bold">return</code> <code class="plain">y/x; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Santanu </code>
<b>Output:</b>
<pre>
2.00
0.50
</pre>
You may like to take a <a href="http://geeksquiz.com/c-language/macro-preprocessor/">Quiz on Macros and Preprocessors in C</a>
<h2>Compiling a C program:- Behind the Scenes</h2>
C is a high-level language and it needs a compiler to convert it into an executable code so that the program can be run on our machine.
<h3><strong>How do we compile and run a C program?</strong></h3>
Below are the steps we use on an Ubuntu machine with gcc compiler.
<ul>
<li><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compilation.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compilation.png" alt="compilation"></a>
We first create a C program using an editor and save the file as filename.c
<pre><strong> $ vi filename.c</strong></pre>
The diagram on right shows a simple program to add two numbers.</li>
<li><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil31.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil31.png" alt="compil31"></a>
Then compile it using below command.
<pre><strong> $ gcc –Wall filename.c –o filename</strong></pre>
The option -Wall enables all compiler&#8217;s warning messages. 
This option is recommended to generate better code.<br />
The option -o is used to specify the output file name. 
If we do not use this option, then an output file with name a.out is generated.</li>
<li><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil21.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil21.png" alt="compil21"></a>
After compilation executable is generated and we run the generated executable using below command.
<pre><strong> $ ./filename</strong> </pre>
</li>
</ul>

<h3><strong>What goes inside the compilation process?</strong></h3>
Compiler converts a C program into an executable. 
There are four phases for a C program to become an executable:
<ol>
<li>      Pre-processing</li>
<li>      Compilation</li>
<li>      Assembly</li>
<li>      Linking</li>
</ol>
By executing below command, We get the all intermediate files in the current directory along with the executable.
<pre>
<strong> $gcc –Wall –save-temps filename.c –o filename</strong> </pre>
The following screenshot shows all generated intermediate files.<br />
 <a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil4.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil4.png" alt="compil4"></a>
Let us one by one see what these intermediate files contain.
<h3><u><center><strong>Pre-processing</strong></u></center></h3>
This is the first phase through which source code is passed. 
This phase include: 
<ul>
<li>Removal of Comments</li>
<li>Expansion of Macros</li>
<li>Expansion of the included files.</li>
<li>Conditional compilation</li>
</ul>
The preprocessed output is stored in the <strong>filename.i</strong>. 
Let’s see what’s inside filename.i: using <strong>$vi filename.i</strong> 
<pre><a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil5.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil5.png" alt="compil5"></a>
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compile6.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compile6.png" alt="compile6"></a>
</pre>
In the above output, source file is filled with lots and lots of info, but at the end our code is preserved.<br />
<strong>Analysis:</strong>
<ul>
<li> printf contains now a + b rather than add(a, b) that’s because macros have expanded.</li>
<li> Comments are stripped off.</li>
<li> <strong>#include&lt;stdio.h&gt;</strong> is missing instead we see lots of code. 
So header files has been expanded and included in our source file.</li>
</ul>
</li>
<h3><u><center><strong>Compiling</strong></center></u></h3>
The next step is to compile filename.i and produce an; intermediate compiled output file <strong>filename.s</strong>. 
This file is in assembly level instructions. 
Let’s see through this file using<strong> $vi filename.s </strong>
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/image2.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/image2.png" alt="image"></a>
The snapshot shows that it is in assembly language, which assembler can understand. 
<h3><u><center><strong>Assembly</strong></center></u></h3>
In this phase the filename.s is taken as input and turned into <strong>filename.o</strong> by assembler. 
This file contain machine level instructions. 
At this phase, only existing code is converted into machine language, the function calls like printf() are not resolved. 
Let’s view this file using <strong>$vi filename.o</strong>
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil7.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil7.png" alt="compil7"></a>
<h3><u><center><strong>Linking</strong></center></u></h3>
This is the final phase in which all the linking of function calls with their definitions are done. 
Linker knows where all these functions are implemented. 
Linker does some extra work also, it adds some extra code to our program which is required when the program starts and ends. 
For example, there is a code which is required for setting up the environment like passing command line arguments. 
This task can be easily verified by using <strong>$size filename.o</strong> and <strong>$size filename</strong>. 
Through these commands, we know that how output file increases from an object file to an executable file. 
This is because of the extra code that linker adds with our program.<br />
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil8.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/compil8.png" alt="compil8"></a>
<br />
Note that GCC by default does dynamic linking, so printf() is dynamically linked in above  program. 
Refer <a href="https://www.geeksforgeeks.org/static-vs-dynamic-libraries/">this</a>, <a href="https://www.geeksforgeeks.org/working-with-shared-libraries-set-1/">this</a> and <a href="https://www.geeksforgeeks.org/working-with-shared-libraries-set-2/">this</a> for more details on static and dynamic linkings.
<h2>Benefits of C language over other programming languages</h2>
<a href="https://www.geeksforgeeks.org/c/">C</a> is a middle-level programming language developed by Dennis Ritchie during the early 1970s while working at AT&amp;T Bell Labs in the USA. 
The objective of its development was in the context of the re-design of the UNIX operating system to enable it to be used on multiple computers.
Earlier the language B was now used for improving the UNIX system. 
Being a high-level language, B allowed much faster production of code than in assembly language. 
Still, B suffered from drawbacks as it did not understand data-types and did not provide the use of “structures”.
These drawbacks became the driving force for Ritchie for development of a new programming language called C. 
He kept most of language B’s syntax and added data-types and many other required changes. 
Eventually, C was developed during 1971-73, containing both high-level functionality and the detailed features required to program an operating system. 
Hence, many of the UNIX components including UNIX kernel itself were eventually rewritten in C.
<p style="text-align: center"><strong><u>Benefits of C language</u></strong>
<ol>
<li>
    As a middle-level language, C combines the features of both high-level and low-level languages. 
It can be used for low-level programming, such as scripting for drivers and kernels and it also supports functions of high-level programming languages, such as scripting for software applications etc.
 </li>
<li>
    C is a structured programming language which allows a complex program to be broken into simpler programs called functions. 
It also allows free movement of data across these functions.
 </li>
<li>
    Various features of C including direct access to machine level hardware APIs, the presence of C compilers, deterministic resource use and dynamic memory allocation make C language an optimum choice for scripting applications and drivers of embedded systems.
 </li>
<li>
    C language is case-sensitive which means lowercase and uppercase letters are treated differently.
 </li>
<li>
    C is highly portable and is used for scripting system applications which form a major part of Windows, UNIX, and Linux operating system.
 </li>
<li>
    C is a general-purpose programming language and can efficiently work on enterprise applications, games, graphics, and applications requiring calculations, etc.
 </li>
<li>
    C language has a rich library which provides a number of built-in functions. 
It also offers dynamic memory allocation.
 </li>
<li>
    C implements algorithms and data structures swiftly, facilitating faster computations in programs. 
This has enabled the use of C in applications requiring higher degrees of calculations like <a href="https://en.wikipedia.org/wiki/Matlab">MATLAB</a> and <a href="https://en.wikipedia.org/wiki/Wolfram_Mathematica">Mathematica</a>.
 </li>
</ul>
<strong>Riding on these advantages, C became dominant and spread quickly beyond Bell Labs replacing many well-known languages of that time, such as ALGOL, B, PL/I, FORTRAN, etc. 
C language has become available on a very wide range of platforms, from embedded microcontrollers to supercomputers.</strong>
<blockquote>The C language has formed the basis for many languages including C++, C&#8211;, C#, Objective-C, BitC, C-shell, csh, D, Java, JavaScript, Go, Rust, Julia, Limbo, LPC, PHP, Python, Perl, Seed7, Vala, Verilog and many more other languages are there.</blockquote>
<h2>Program error signals</h2>
Signals in computers are a way of communication between the process and the OS. 
When a running program undergoes some serious error then the OS sends a signal to the process and the process further may not execute. 
Some processes may have a signal handler which does some important tasks before the process leaves the CPU.
Signal and interrupt are basically same but a small distinction exists i.e interrupts are generated by the processor and handled by the kernel but signals are generated by the kernel and handled by the process. 
Error signals generally causes termination of the program and a core dump file is created named core, which stores the state of the process at the moment of termination. 
This file can be investigated using debugger to know the cause of program termination.
<b>Error signals:</b>
<ul>
<li><b>SIGFPE &#8211;</b><br />
This error signal denotes some arithmetic error that occurred like division by zero, floating point error. 
If a program stores integer data in a location which is then used as a floating-point operation, this causes an “invalid operation” exception as the processor cannot recognize the data as a floating-point value. 
But this signal does not specify the type of floating point error.
</li>
<li><b>SIGILL &#8211;</b><br />
This signal denotes illegal instruction. 
When a garbage instruction or instruction which a program has no privilege to execute, is executed then this signal is generated. 
C does not produce illegal instruction so there is no chance of facing such error signal, as the probable cause may be that the object file may be corrupted. 
This signal is also generated when stack overflow occurs.
</li>
<li><b>SIGSEGV &#8211;</b><br />
The signal is generated when process tries to access memory location not allocated to it, like de-referencing a wild pointer which leads to &#8220;segmentation fault&#8221;. 
The signal is only generated when a program goes far from its memory space so that it can be detected by the memory protection mechanism.<br />
The name is an abbreviation for “segmentation violation”.
</li>
<li><b>SIGBUS &#8211;</b><br />
The name is an abbreviation for “Bus error&#8221;. 
This signal is also produced when an invalid memory is accessed. 
It may seem to be same like SIGSEGV but in SIGSEGV, the memory location referenced is valid but in case of SIGBUS, memory referenced does not exist i.e de-referencing a memory location out of memory space.
</li>
<li><b>SIGABRT &#8211;</b><br />
If an error itself is detected by the program then this signal is generated using call to abort(). 
This signal is also used by standard library to report an internal error. 
assert() function in c++ also uses abort() to generate this signal.
</li>
<li><b>SIGSYS &#8211;</b><br />
This signal is sent to process when an invalid argument is passed to a system call.
</li>
<li><b>SIGTRAP &#8211;</b><br />
This signal is send to process when an exception is occurred. 
This is requested by the debugger to get informed. 
For example, if a variable changes its value then this will trigger it.
</li>
</ul>
Refer for &#8211; <a href="https://www.geeksforgeeks.org/segmentation-fault-sigsegv-vs-bus-error-sigbus/" rel="noopener">Segmentation Fault (SIGSEGV) vs Bus Error (SIGBUS)</a>
<h2>Line Splicing in C/C++</h2>
While writing a program, sometimes we give comment about the working of the code in the comment section with the help of single/double comment line. 
But we had never thought that if at the end of this comment line if we use \(backslash) character then what will happen?
The answer of the above question is line Splicing. 
Lines terminated by a \ are spliced together with the next line very early in the process of translation. 
<a href="http://en.cppreference.com/w/cpp/language/translation_phases">§2.2 Phases of translation</a>.<br />
Actually whenever at the end of the comment line if we use \(backslash) character then it deletes the backslash character and the preceding next line of code only from the entire program or we can say that the ending \(backslash)<strong> makes the new line also as a comment for the compiler.</strong>
<code class="comments">// C program to illustrate the concept of Line splicing. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Line Splicing\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello GFG\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"welcome"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
welcome
</pre>
Explanation: In the above program as we can see when we use the \(backslash) character at the end of comment line. 
Then the next line of code is treated as comment in the program and the output is welcome.
<h2>C/C++ Tokens</h2>
A token is the smallest element of a program that is meaningful to the compiler. 
Tokens can be classified as follows:
<ol>
<li>Keywords</li>
<li>Identifiers</li>
<li>Constants</li>
<li>Strings</li>
<li>Special Symbols</li>
<li>Operators</li>
</ol>
<ol>
<ol>
<li><strong>Keyword: </strong>Keywords are pre-defined or reserved words in a programming language. 
Each keyword is meant to perform a specific function in a program. 
Since keywords are referred names for a compiler, they can’t be used as variable names because by doing so, we are trying to assign a new meaning to the keyword which is not allowed. 
You cannot redefine keywords. 
However, you can specify text to be substituted for keywords before compilation by using C/C++ preprocessor directives.<strong>C</strong> language supports <strong>32</strong> keywords which are given below:
<pre><strong>
auto         double      int        struct
break        else        long       switch
case         enum        register   typedef
char         extern      return     union
const        float       short      unsigned
continue     for         signed     void
default      goto        sizeof     volatile
do           if          static     while
 </strong></pre>
While in <strong>C++</strong> there are<strong> 31 </strong> additional keywords other than <strong>C</strong> Keywords they are:
<pre><strong>
asm          bool        catch          class
const_cast   delete      dynamic_cast   explicit 
export       false       friend         inline 
mutable      namespace   new            operator 
private      protected   public         reinterpret_cast
static_cast  template    this           throw
true         try         typeid         typename 
using        virtual     wchar_t 
</strong></pre>
</li>
<li><strong>Identifiers: </strong>Identifiers are used as the general terminology for naming of variables, functions and arrays. 
These are user defined names consisting of arbitrarily long sequence of letters and digits with either a letter or the underscore(_) as a first character. 
Identifier names must differ in spelling and case from any keywords. 
You cannot use keywords as identifiers; they are reserved for special use. 
Once declared, you can use the identifier in later program statements to refer to the associated value. 
A special kind of identifier, called a statement label, can be used in goto statements.<br />
<strong><br />
There are certain rules that should be followed while naming c identifiers:<br />
</strong>
<ul>
<li>They must begin with a letter or underscore(_).</li>
<li>They must consist of only letters, digits, or underscore. 
No other special character is allowed.</li>
<li>It should not be a keyword.</li>
<li>It must not contain white space.</li>
<li>It should be up to 31 characters long as only first 31 characters are significant.</li>
</ul>
Some examples of c identifiers:
<table style="width: 100%">
<tbody>
<tr>
<th>name</th>
<th>Remark</th>
</tr>
<tr>
<td>_A9</td>
<td>Valid</td>
</tr>
<tr>
<td>Temp.var</td>
<td>Invalid as it contains special character other than the underscore</td>
</tr>
<tr>
<td>void</td>
<td>Invalid as it is a keyword</td>
</tr>
</tbody>
</table>
<strong>C program: </strong>
<pre> void main()
{
  int a = 10;
}
</pre>
In the above program there are <strong>2 identifiers: </strong>
<ol>
<li><strong>main: </strong>method name.</li>
<li><strong>a: </strong>variable name.</li>
</ol>
</li>
<li><strong>Constants: </strong>Constants are also like normal variables. 
But, only difference is, their values can not be modified by the program once they are defined. 
Constants refer to fixed values. 
They are also called as literals.<br />
Constants may belong to any of the data type.<strong>Syntax:</strong>
<b>const data_type variable_name;</b> (or) <b>const data_type *variable_name;</b><br />
<strong>Types of Constants:</strong>
<ol>
<li>Integer constants &#8211; Example: 0, 1, 1218, 12482</li>
<li>Real or Floating point constants &#8211; Example: 0.0, 1203.03, 30486.184</li>
<li>Octal &amp; Hexadecimal constants &#8211; Example: octal: (013 )<sub>8</sub> = (11)<sub>10, </sub>Hexadecimal: (013)<sub>16</sub> = (19)<sub>10</sub></li>
<li>Character constants -Example: &#8216;a&#8217;, &#8216;A&#8217;, &#8216;z&#8217;</li>
<li>String constants -Example: &#8220;GeeksforGeeks&#8221;</li>
</ol>
</li>
<li><strong>Strings: </strong>Strings are nothing but an array of characters ended with a null character (‘\0’).This null character indicates the end of the string. 
Strings are always enclosed in double quotes. 
Whereas, a character is enclosed in single quotes in C and C++.<strong>Declarations for String:</strong>
<ul>
<li>char string[20] = {‘g’, ’e’, ‘e’, ‘k’, ‘s’, ‘f’, ‘o’, ‘r’, ‘g’, ’e’, ‘e’, ‘k’, ‘s’, ‘\0’};</li>
<li>char string[20] = “geeksforgeeks”;</li>
<li>char string [] = “geeksforgeeks”;</li>
</ul>
<strong>Difference between above declarations are:</strong>
<ol>
<li>when we declare char as “string[20]”, 20 bytes of memory space is allocated for holding the string value.</li>
<li>When we declare char as “string[]”, memory space will be allocated as per the requirement during execution of the program.</li>
</ol>
</li>
<li><strong>Special Symbols: </strong>The following special symbols are used in C having some special meaning and thus, cannot be used for some other purpose.[] () {}, ; * = #
<ul>
<li><strong>Brackets[]:</strong> Opening and closing brackets are used as array element reference. 
These indicate single and multidimensional subscripts.</li>
<li><strong>Parentheses(): </strong>These special symbols are used to indicate function calls and function parameters.</li>
<li><strong>Braces{}:</strong> These opening and ending curly braces marks the start and end of a block of code containing more than one executable statement.</li>
<li><strong>comma (, ): </strong> It is used to separate more than one statements like for separating parameters in function calls.</li>
<li><strong>semi colon :</strong> It is an operator that essentially invokes something called an initialization list.</li>
<li><strong>asterick (*): </strong> It is used to create pointer variable.</li>
<li><strong>assignment operator: </strong> It is used to assign values.</li>
<li><strong>pre processor(#): </strong> The preprocessor is a macro processor that is used automatically by the compiler to transform your program before actual compilation.</li>
</ul>
<li><strong>Operators: </strong>Operators are symbols that triggers an action when applied to C variables and other objects. 
The data items on which operators act upon are called operands.<br />
Depending on the number of operands that an operator can act upon, operators can be classified as follows:
<ul>
<li><strong>Unary Operators:</strong> Those operators that require only single operand to act upon are known as unary operators.For Example increment and decrement operators</li>
<li><strong>Binary Operators:</strong> Those operators that require two operands to act upon are called binary operators.<strong> Binary operators are classified into :</strong>
<ol>
<li>Arithmetic operators</li>
<li>Relational Operators</li>
<li>Logical Operators</li>
<li>Assignment Operators</li>
<li>Conditional Operators</li>
<li>Bitwise Operators</li>
</ol>
<strong>Ternary Operators:</strong> These operators requires three operands to act upon. 
For Example Conditional operator(?:).
For more information about operators <a href="https://www.geeksforgeeks.org/c/#Operators">click</a></li>
</ul></li></ol></ol>
<h2>Variables and Keywords in C</h2>
A <strong>variable </strong>in simple terms is a storage place which has some memory allocated to it. 
Basically, a variable used to store some form of data. 
Different types of variables require different amounts of memory, and have some specific set of operations which can be applied on them.<!--more-->
<strong>Variable Declaration:</strong><br />
A typical variable declaration is of the form: 
<pre>
  type variable_name;
    or for multiple variables:
  type variable1_name, variable2_name, variable3_name;</pre>
A variable name can consist of alphabets (both upper and lower case), numbers and the underscore &#8216;_&#8217; character. 
However, the name must not start with a number.
<strong>Difference b/w variable declaration and definition</strong><br />
Variable declaration refers to the part where a variable is first declared or introduced before its first use. 
Variable definition is the part where the variable is assigned a memory location and a value. 
 Most of the times, variable declaration and definition are done together.
See the following C program for better clarification:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaration and definition of variable 'a123' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a123 = </code><code class="string">'a'</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This is also both declaration and definition as 'b' is allocated </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// memory and assigned some garbage value.&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">b;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// multiple declarations and definitions </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">_c, _d45, e;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Let us print a variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c \n"</code><code class="plain">, a123); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>a</pre>
Is it possible to have separate declaration and definition?<br />
It is possible in case of <a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">extern variables</a> and <a href="http://quiz.geeksforgeeks.org/functions-in-c/">functions</a>. 
See question 1 of <a href="http://quiz.geeksforgeeks.org/commonly-asked-c-programming-interview-questions-set-1/">this </a>for more details.
&nbsp;<br />
&nbsp;<br />
<strong>Keywords</strong> are specific reserved words in C each of which has a specific feature associated with it. 
Almost all of the words which help us use the functionality of the C language are included in the list of keywords. 
So you can imagine that the list of keywords is not going to be a small one!
There are a total of 32 keywords in C: 
<pre>
   auto       break    case     char     const     continue
   default    do       double   else     enum      extern
   float      for      goto     if       int       long
   register   return   short    signed   sizeof    static
   struct     switch   typedef  union    unsigned  void
   volatile   while </pre>
Most of these keywords have already been discussed in the various sub-sections of the <a href="https://www.geeksforgeeks.org/c/">C language</a>, like Data Types, Storage Classes, Control Statements, Functions etc.
Let us discuss some of the other keywords which allow us to use the basic functionality of C:
<strong><a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">const</a></strong>:  const can be used to declare constant variables. 
Constant variables are variables which, when initialized, can&#8217;t change their value. 
Or in other words, the value assigned to them cannot be modified further down in the program.<br />
Syntax: 
<pre>const data_type var_name = var_value; </pre>
Note: Constant variables must be initialized during their declaration. 
const keyword is also used with pointers. 
Please refer the <a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">const qualifier in C</a> for understanding the same.
          
<strong><a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">extern</a></strong>: extern simply tells us that the variable is defined elsewhere and not within the same block where it is used. 
Basically, the value is assigned to it in a different block and this can be overwritten/changed in a different block as well. 
So an extern variable is nothing but a global variable initialized with a legal value where it is declared in order to be used elsewhere. 
It can be accessed within any function/block. 
Also, a normal global variable can me made extern as well by placing the &#8216;extern&#8217; keyword before its declaration/definition in any function/block. 
This basically signifies that we are not initializing a new variable but instead we are using/accessing the global variable only. 
The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program.<br />
Syntax: 
<pre>extern data_type var_name = var_value;</pre>
<strong>static</strong>: static keyword is used to declare static variables, which are popularly used while writing programs in C language. 
Static variables have a property of preserving their value even after they are out of their scope! Hence, static variables preserve the value of their last use in their scope. 
So we can say that they are initialized only once and exist till the termination of the program. 
Thus, no new memory is allocated because they are not re-declared. 
Their scope is local to the function to which they were defined. 
Global static variables can be accessed anywhere within that file as their scope is local to the file. 
By default, they are assigned the value 0 by the compiler.<br />
Syntax: 
<pre>static data_type var_name = var_value;</pre>
<strong>void</strong>: void is a special data type. 
But what makes it so special? void, as it literally means, is an empty data type. 
It means it has nothing or it holds no value. 
For example, when it is used as the return data type for a function it simply represents that the function returns no value. 
Similarly, when its added to a function heading, it represents that the function takes no arguments.<br />
Note: void also has a significant use with pointers. 
Please refer to the <a href="http://quiz.geeksforgeeks.org/void-pointer-c/">void pointer in C</a> for understanding the same.
<strong>typedef</strong>: typedef is used to give a new name to an already existing or even a custom data type (like a structure). 
It comes in very handy at times, for example in a case when the name of the structure defined by you is very long or you just need a short-hand notation of a per-existing data type.
Let&#8217;s implement the keywords which we have discussed above. 
Take a look at the following code which is a working example to demonstrate these keywords:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// declaring and initializing an extern variable </code>
<code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">x = 9;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// declaring and initializing a global variable </code>
<code class="comments">// simply int z; would have initialized z with </code>
<code class="comments">// the default value of a global variable which is 0 </code>
<code class="color1 bold">int</code> <code class="plain">z=10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// using typedef to give a short name to long long int&nbsp; </code>
<code class="comments">// very convenient to use now due to the short name </code>
<code class="keyword bold">typedef</code> <code class="color1 bold">long</code> <code class="color1 bold">long</code> <code class="color1 bold">int</code> <code class="plain">LL;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// function which prints square of a no. 
and which has void as its </code>
<code class="comments">// return data type </code>
<code class="keyword bold">void</code> <code class="plain">calSquare(</code><code class="color1 bold">int</code> <code class="plain">arg)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The square of %d is %d\n"</code><code class="plain">,arg,arg*arg); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Here void means function main takes no parameters </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring a constant variable, its value cannot be modified </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">a = 32;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring a&nbsp; char variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">b = </code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// telling the compiler that the variable z is an extern variable&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and has been defined elsewhere (above the main function) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">LL c = 1000000; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello World!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the above variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"This is the value of the constant variable 'a': %d\n"</code><code class="plain">,a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"'b' is a char variable. 
Its value is %c\n"</code><code class="plain">,b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"'c' is a long long int variable. 
Its value is %lld\n"</code><code class="plain">,c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"These are the values of the extern variables 'x' and 'z'"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" respectively: %d and %d\n"</code><code class="plain">,x,z); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// value of extern variable x modified </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x=2;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// value of extern variable z modified </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">z=5;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the modified values of extern variables 'x' and 'z' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"These are the modified values of the extern variables"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" 'x' and 'z' respectively: %d and %d\n"</code><code class="plain">,x,z); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using a static variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The value of static variable 'y' is NOT initialized to 5 after the "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"first iteration! See for yourself :)\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(x > 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">y = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">y++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing value at each iteration </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The value of y is %d\n"</code><code class="plain">,y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x--; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print square of 5 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">calSquare(5);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Bye! See you soon. 
:)\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Hello World
This is the value of the constant variable 'a': 32
'b' is a char variable. 
Its value is G
'c' is a long long int variable. 
Its value is 1000000
These are the values of the extern variables 'x' and 'z' respectively: 9 and 10
These are the modified values of the extern variables 'x' and 'z' respectively: 2 and 5
The value of static variable 'y' is NOT initialized to 5 after the first iteration! See for yourself :)
The value of y is 6
The value of y is 7
The square of 5 is 25
Bye! See you soon. 
:)</pre>
<h2>How are variables scoped in C &#8211; Static or Dynamic?</h2>
In C, variables are always <a href="http://en.wikipedia.org/wiki/Scope_%28programming%29#Lexical_scoping">statically (or lexically) scoped</a> i.e., binding of a variable can be determined by  program text and is independent of the run-time function call stack. 
<!--more-->
For example, output for the below program is 0, i.e., the value returned by f() is not dependent on who is calling it. 
f() always returns the value of global variable x.
<code class="preprocessor"># include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x = 0; </code>
<code class="color1 bold">int</code> <code class="plain">f() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">g() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">f(); </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, g()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="plain">} </code>
<h2>Scope rules in C</h2>
Scope of an identifier is the part of the program where the identifier may directly be accessible. 
In C, all identifiers are <a href="https://www.geeksforgeeks.org/static-and-dynamic-scoping/">lexically(or statically) scoped</a>. 
C scope rules can be covered under the following two categories.<!--more-->
There are basically 4 scope rules:
<table width="100%" style="table-layout:fixed;">
<thead>
<tr>
<th>Scope</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Scope</td>
<td>Scope of a Identifier starts at the beginning of the file and ends at the end of the file. 
It refers to only those Identifiers that are declared outside of all functions. 
The Identifiers of File scope are visible all over the file Identifiers having file scope are global</td>
</tr>
<tr>
<td>Block Scope</td>
<td>Scope of a Identifier begins at opening of the block / ‘{‘ and ends at the end of the block / ‘}’. 
Identifiers with block scope are local to their block</td>
</tr>
<tr>
<td>Function Prototype Scope</td>
<td>Identifiers declared in function prototype are visible within the prototype</td>
</tr>
<tr>
<td>Function scope</td>
<td>Function scope begins at the opening of the function and ends with the closing of it. 
Function scope is applicable to labels only. 
A label declared is used as a target to goto statement and both goto and label statement must be in same function</td>
</tr>
</tbody>
</table>
Let&#8217;s discuss each scope rules with examples.
<ol>
<li><strong>File Scope:</strong> These variables are usually declared outside of all of the functions and blocks, at the top of the program and can be accessed from any portion of the program. 
These are also called the global scope variables as they can be globally accessed.<br />
<strong>Example 1:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10, y&nbsp; = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The outer block contains declaration of x and y, so&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// following statement is valid and prints 10 and 20 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// y is declared again, so outer block y is not accessible&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// in this block </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y = 40; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// Changes the outer block variable x to 11 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x++;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="comments">// Changes this block's variable y to 41 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">y++;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This statement accesses only outer block's variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>Before change within main: 5
After change within main: 10</pre>
<strong>Example 2:</strong>
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">// function prototype scope </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// function prototype scope </code>
<code class="comments">//(not part of a function definition) </code>
<code class="color1 bold">int</code> <code class="plain">Sub(</code><code class="color1 bold">int</code> <code class="plain">num1, </code><code class="color1 bold">int</code> <code class="plain">num2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// file scope </code>
<code class="color1 bold">int</code> <code class="plain">num1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Funntion to subtract </code>
<code class="color1 bold">int</code> <code class="plain">Sub(</code><code class="color1 bold">int</code> <code class="plain">num1, </code><code class="color1 bold">int</code> <code class="plain">num2) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(num1-num2); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver method </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, Sub(10,5)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">func1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// label in scope even&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// though declared later </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label_exec; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">label_exec:; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// label ignores block scope </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label_exec;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">funct2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// throwserror:&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// as label is in f() not g() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label_exec;&nbsp; </code>
<code class="plain">} </code>
<em>Note:</em> To restrict access to the current file only, global variables can be marked as static.</li>
<li><strong>Block Scope:</strong> A Block is a set of statements enclosed within left and right braces i.e. 
&#8216;{&#8216; and &#8216;}&#8217; respectively. 
Blocks may be nested in C(a block may contain other blocks inside it). 
A variable declared inside a block is accessible in the block and all inner blocks of that block, but not accessible outside the block. 
Basically these are local to the blocks in which the variables are defined and are not accessible outside.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Error: x is not accessible here </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
x = 10, y = 20
x = 11, y = 41
x = 11, y = 20
</pre>
</li>
<li><strong>Function Prototype Scope:</strong> These variables range includes within the function parameter list. 
The scope of the these variables begins right after the declaration in the function prototype and runs to the end of the declarations list. 
These scope doesnot include the function definition, but just the function prototype.<br />
<strong>Example:</strong>
<code class="comments">// C program to illustrate scope of variables </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Initialization of local variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1, y = 2, z = 3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// changing the variables x & y </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">y = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %f, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// changing z </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">z = 100; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %f, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>5</pre>
</li>
<li><strong>Function Scope:</strong> A Function scope begins at the opening of the function and ends with the closing of it. 
Function scope is applicable to labels only. 
A label declared is used as a target to go to the statement and both goto and label statement must be in the same function.<br />
<strong>Example:</strong>
                    </li></ol>
Now various questions may arise with respect to the scope of access of variables:<br />
<b>What if the inner block itself has one variable with the same name?</b><br />
If an inner block declares a variable with the same name as the variable declared by the outer block, then the visibility of the outer block variable ends at the pint of the declaration by inner block.
<b>What about functions and parameters passed to functions?</b><br />
A function itself is a block. 
Parameters and other local variables of a function follow the same block scope rules.
<b>Can variables of the block be accessed in another subsequent block?</b><br />
No, a variable declared in a block can only be accessed inside the block and all inner blocks of this block. 
          
<strong>For example:</strong> the following program produces a compiler error.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Error: x is not accessible here </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Error:</strong>
<pre>
prog.c: In function 'main':
prog.c:8:15: error: 'x' undeclared (first use in this function)
  printf("%d", x); // Error: x is not accessible here
               ^
prog.c:8:15: note: each undeclared identifier is 
reported only once for each function it appears in
</pre>
<strong>Example:</strong>
<code class="comments">// C program to illustrate scope of variables </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Initialization of local variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1, y = 2, z = 3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// changing the variables x & y </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">y = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %f, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// changing z </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">z = 100; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %f, z = %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x, y, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre> 
x = 1, y = 2, z = 3
x = 10, y = 20.000000, z = 3 
x = 10, y = 20.000000, z = 100 
</pre>
<h2>How Linkers Resolve Global Symbols Defined at  Multiple Places?</h2>
At compile time, the compiler exports each global symbol to the assembler as either strong or weak, and the assembler encodes this information implicitly in the symbol table of the relocatable object file. 
Functions and initialized global variables get strong symbols. 
Uninitialized global variables get weak symbols.<br />
For the following example programs, buf, bufp0, main, and swap are strong symbols; bufp1 is a weak symbol.
<code class="comments">/* main.c */</code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">void</code> <code class="plain">swap(); </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">buf[2] = {1, 2}; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">swap(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="comments">/* swap.c */</code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">buf[]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*bufp0 = &buf[0]; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*bufp1; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">void</code> <code class="plain">swap() </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">temp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">bufp1 = &buf[1]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">temp = *bufp0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*bufp0 = *bufp1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*bufp1 = temp; </code>
<code class="plain">} </code>
Given this notion of strong and weak symbols, Unix linkers use the following rules for dealing with multiple defined symbols:<br />
<strong>Rule 1:</strong> Multiple strong symbols (with same variable name) are not allowed.<br />
<strong>Rule 2:</strong> Given a strong symbol and multiple weak symbols, choose the strong symbol.<br />
<strong>Rule 3:</strong> Given multiple weak symbols, choose any of the weak symbols.<br />
For example, suppose we attempt to compile and link the following two C modules:
<code class="comments">/* foo1.c */</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code class="color1 bold">int</code> <code class="plain">main()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">/* bar1.c */</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
In this case, the linker will generate an error message because the strong symbol main is defined multiple times (<strong>rule 1</strong>):
<pre>
$ gcc foo1.c bar1.c
/tmp/cca015022.o: In function ‘main’:
/tmp/cca015022.o(.text+0x0): multiple definition of ‘main’
/tmp/cca015021.o(.text+0x0): first defined here
</pre>
Similarly, the linker will generate an error message for the following modules because the strong symbol x is defined twice (<strong>rule 1</strong>):
<code class="comments">/* foo2.c */</code>
<code class="color1 bold">int</code> <code class="plain">x = 15213; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">/* bar2.c */</code>
<code class="color1 bold">int</code> <code class="plain">x = 15213; </code>
<code class="keyword bold">void</code> <code class="plain">f() </code>
<code class="plain">{ </code>
<code class="plain">} </code>
However, if x is uninitialized in one module, then the linker will quietly choose the strong symbol defined in the other (<strong>rule 2</strong>) as is the case in following program:
<code class="comments">/* foo3.c */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">f(</code><code class="keyword bold">void</code><code class="plain">); </code>
<code class="color1 bold">int</code> <code class="plain">x = 15213; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">f(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d\n"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">/* bar3.c */</code>
<code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="keyword bold">void</code> <code class="plain">f() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">x = 15212; </code>
<code class="plain">} </code>
At run time, function f() changes the value of x from 15213 to 15212, which might come as a unwelcome surprise to the author of function main! Notice that the linker normally gives no indication that it has detected multiple definitions of x.
<pre>
$ gcc -o gfg foo3.c bar3.c
$ ./gfg
x = 15212
</pre>
The same thing can happen if there are two weak definitions of x (<strong>rule 3</strong>):
<code class="comments">/*a.c*/</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">b(</code><code class="keyword bold">void</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 2016; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d "</code><code class="plain">,x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">/*b.c*/</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">b() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 2017; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="plain">} </code>
The <strong>application of rules 2 and 3</strong> can introduce some insidious run-time bugs that are incomprehensible to the unwary programmer, especially if the duplicate symbol definitions have different types.<br />
Example : &#8220;x&#8221; is defined as an int in one module and a double in another.
<code class="comments">/*a.c*/</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">b(</code><code class="keyword bold">void</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x = 2016; </code>
<code class="color1 bold">int</code> <code class="plain">y = 2017; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = 0x%x y = 0x%x \n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">/*b.c*/</code>
<code class="color1 bold">double</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">b() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = -0.0; </code>
<code class="plain">} </code>
<strong>Execution:</strong>
<pre>
$ gcc a.c b.c -o geeksforgeeks
$ ./geeksforgeeks
x = 0x0 y = 0x80000000
</pre>
This is a subtle and nasty bug, especially because it occurs silently, with no warning from the compilation system, and because it typically manifests itself much later in the execution of the program, far away from where the error occurred. 
In a large system with hundreds of modules, a bug of this kind is extremely hard to fix, especially because many programmers are not aware of how linkers work. 
When in doubt, invoke the linker with a flag such as the gcc -fno-common flag, which triggers an error if it encounters multiple defined global symbols.
Source : http://csapp.cs.cmu.edu/public/ch7-preview.pdf
<h1 style="display:inline">C Variable Declaration and Scope</h2>
		</header>
<div id="mtq_quiz_area-1" class="mtq_quiz_area mtq_color_green"> 
  <!--Quiz generated using mTouch Quiz Version 3.1.3 by G. 
Michael Guy (http://gmichaelguy.com/quizplugin/)-->
        
    
   <!-- Here code starts for pagination -->
  
  <!-- <a class="page" data-pageid="0">First</a> -->
          <a class="page current" data-pageid="0">1</a><a class="page" data-pageid="1">2</a>        <!-- <a class="page" data-pageid="<?php# echo $total_pagination_btn-1; ?>">Last</a> -->
  
  <!-- Here code ends for pagination -->
  <!-- Shortcode entered mtouchquiz id=65 --> 
  <!-- Shortcode interpreted mtouchquiz id=65 alerts=off singlepage=on hints=on startscreen=off finalscreen=off multiplechances=off showanswers=now show_stamps=on randomq=off randoma=off status=on labels=on title=on proofread=off list=off time=off scoring=off formid= vform=on autoadvance=off autosubmit=off inform=off forcecf=off forcegf=off offset=1 questions=17 firstid=576 lastid=5719 color=green --> 
  <!--form action="" method="post" class="quiz-form" id="quiz-65"-->
      <div id="mtq_quiztitle-1" class="mtq_quiztitle" style='display:none'>
  <h2 style="margin-bottom:0px;">C Variable Declaration and Scope</h3>
  
      <noscript>
  <div id="mtq_javawarning-1" class="mtq_javawarning">
  Please wait while the activity loads.</br> If this activity does not load, try refreshing your browser. 
Also, this page requires javascript. 
Please visit using a browser with javascript enabled. 
  If loading fails, click here to try again  
  </noscript>
    
  <!-- root element for mtqscrollable -->
  <div id="mtq_question_container-1" >
  
          <table class='mtq_question_heading_table'><tr><td>Question 1<div id='mtq_stamp-1-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-1-1' class='mtq_question_text'>Consider the following two C lines
<pre class="brush: c; title: ; notranslate" title="">
int var1;
extern int var2;
</pre>
Which of the following statements is correct
<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-1-1-1' onclick='mtq_button_click(1,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 1, Choice 1'>A<div id='mtq_marker-1-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-1-1' class='mtq_answer_text'>Both statements only declare variables, don't define them.</td></tr><tr id='mtq_row-1-2-1' onclick='mtq_button_click(1,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 1, Choice 2'>B<div id='mtq_marker-1-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-2-1' class='mtq_answer_text'>First statement declares and defines var1, but second statement only declares var2</td></tr><tr id='mtq_row-1-3-1' onclick='mtq_button_click(1,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 1, Choice 3'>C<div id='mtq_marker-1-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-3-1' class='mtq_answer_text'>Both statements declare define variables var1 and var2</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-1/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-1-1' class='mtq_explanation'>Question 1 Explanation:&nbsp; See <a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">Understanding “extern” keyword in C</a><table class='mtq_question_heading_table'><tr><td>Question 2<div id='mtq_stamp-2-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-2-1' class='mtq_question_text'>Predict the output
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int var = 20;
int main()
{
    int var = var;
    printf(&quot;%d &quot;, var);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-2-1-1' onclick='mtq_button_click(2,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 2, Choice 1'>A<div id='mtq_marker-2-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-1-1' class='mtq_answer_text'>Garbage Value</td></tr><tr id='mtq_row-2-2-1' onclick='mtq_button_click(2,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 2, Choice 2'>B<div id='mtq_marker-2-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-2-1' class='mtq_answer_text'>20</td></tr><tr id='mtq_row-2-3-1' onclick='mtq_button_click(2,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 2, Choice 3'>C<div id='mtq_marker-2-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-3-1' class='mtq_answer_text'>Compiler Error</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-2-1' class='mtq_explanation'>Question 2 Explanation:&nbsp; First var is declared, then value is assigned to it. 
As soon as var is declared as a local variable, it hides the global variable var.<table class='mtq_question_heading_table'><tr><td>Question 3<div id='mtq_stamp-3-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-3-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
extern int var;
int main()
{
    var = 10;
    printf(&quot;%d &quot;, var);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-3-1-1' onclick='mtq_button_click(3,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 3, Choice 1'>A<div id='mtq_marker-3-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-1-1' class='mtq_answer_text'>Compiler Error: var is not defined</td></tr><tr id='mtq_row-3-2-1' onclick='mtq_button_click(3,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 3, Choice 2'>B<div id='mtq_marker-3-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-2-1' class='mtq_answer_text'>20</td></tr><tr id='mtq_row-3-3-1' onclick='mtq_button_click(3,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 3, Choice 3'>C<div id='mtq_marker-3-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-3-1' class='mtq_answer_text'>0</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-3/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-3-1' class='mtq_explanation'>Question 3 Explanation:&nbsp; var is only declared and not defined (no memory allocated for it)
Refer:<a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/"> Understanding “extern” keyword in C</a><table class='mtq_question_heading_table'><tr><td>Question 4<div id='mtq_stamp-4-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-4-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
extern int var = 0;
int main()
{
    var = 10;
    printf(&quot;%d &quot;, var);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-4-1-1' onclick='mtq_button_click(4,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 4, Choice 1'>A<div id='mtq_marker-4-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-1-1' class='mtq_answer_text'>10</td></tr><tr id='mtq_row-4-2-1' onclick='mtq_button_click(4,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 4, Choice 2'>B<div id='mtq_marker-4-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-2-1' class='mtq_answer_text'>Compiler Error: var is not defined</td></tr><tr id='mtq_row-4-3-1' onclick='mtq_button_click(4,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 4, Choice 3'>C<div id='mtq_marker-4-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-3-1' class='mtq_answer_text'>0</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-4/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-4-1' class='mtq_explanation'>Question 4 Explanation:&nbsp; If a variable is only declared and an initializer is also provided with that declaration, then the memory for that variable will be allocated i.e. 
that variable will be considered as defined.
Refer: <a href="http://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">Understanding “extern” keyword in C</a>
<table class='mtq_question_heading_table'><tr><td>Question 5<div id='mtq_stamp-5-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-5-1' class='mtq_question_text'>Output?
<pre class="brush: c; title: ; notranslate" title="">
int main()
{
  {
      int var = 10;
  }
  {
      printf(&quot;%d&quot;, var);  
  }
  return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-5-1-1' onclick='mtq_button_click(5,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 5, Choice 1'>A<div id='mtq_marker-5-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-1-1' class='mtq_answer_text'>10</td></tr><tr id='mtq_row-5-2-1' onclick='mtq_button_click(5,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 5, Choice 2'>B<div id='mtq_marker-5-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-2-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-5-3-1' onclick='mtq_button_click(5,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 5, Choice 3'>C<div id='mtq_marker-5-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-3-1' class='mtq_answer_text'>Garbage Value</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-5/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-5-1' class='mtq_explanation'>Question 5 Explanation:&nbsp; x is not accessible.
The curly brackets define a block of scope. 
Anything declared between curly brackets goes out of scope after the closing bracket.<table class='mtq_question_heading_table'><tr><td>Question 6<div id='mtq_stamp-6-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-6-1' class='mtq_question_text'>Output? 
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
  int x = 1, y = 2, z = 3;
  printf(&quot; x = %d, y = %d, z = %d n&quot;, x, y, z);
  {
       int x = 10;
       float y = 20;
       printf(&quot; x = %d, y = %f, z = %d n&quot;, x, y, z);
       {
             int z = 100;
             printf(&quot; x = %d, y = %f, z = %d n&quot;, x, y, z);
       }
  }
  return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-6-1-1' onclick='mtq_button_click(6,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 6, Choice 1'>A<div id='mtq_marker-6-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-1-1' class='mtq_answer_text'><pre> x = 1, y = 2, z = 3
 x = 10, y = 20.000000, z = 3
 x = 1, y = 2, z = 100</pre>
</td></tr><tr id='mtq_row-6-2-1' onclick='mtq_button_click(6,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 6, Choice 2'>B<div id='mtq_marker-6-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-2-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-6-3-1' onclick='mtq_button_click(6,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 6, Choice 3'>C<div id='mtq_marker-6-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-3-1' class='mtq_answer_text'><pre> x = 1, y = 2, z = 3
 x = 10, y = 20.000000, z = 3
 x = 10, y = 20.000000, z = 100 </pre></td></tr><tr id='mtq_row-6-4-1' onclick='mtq_button_click(6,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 6, Choice 4'>D<div id='mtq_marker-6-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-4-1' class='mtq_answer_text'><pre> x = 1, y = 2, z = 3
 x = 1, y = 2, z = 3
 x = 1, y = 2, z = 3</pre></td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-6/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-6-1' class='mtq_explanation'>Question 6 Explanation:&nbsp; See <a href="http://www.geeksforgeeks.org/scope-rules-in-c/">Scope rules in C</a><table class='mtq_question_heading_table'><tr><td>Question 7<div id='mtq_stamp-7-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-7-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
int main()
{
  int x = 032;
  printf(&quot;%d&quot;, x);
  return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-7-1-1' onclick='mtq_button_click(7,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 7, Choice 1'>A<div id='mtq_marker-7-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-1-1' class='mtq_answer_text'>32</td></tr><tr id='mtq_row-7-2-1' onclick='mtq_button_click(7,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 7, Choice 2'>B<div id='mtq_marker-7-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-2-1' class='mtq_answer_text'>0</td></tr><tr id='mtq_row-7-3-1' onclick='mtq_button_click(7,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 7, Choice 3'>C<div id='mtq_marker-7-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-3-1' class='mtq_answer_text'>26</td></tr><tr id='mtq_row-7-4-1' onclick='mtq_button_click(7,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 7, Choice 4'>D<div id='mtq_marker-7-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-4-1' class='mtq_answer_text'>50</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-7/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-7-1' class='mtq_explanation'>Question 7 Explanation:&nbsp; When a constant value starts with 0, it is considered as octal number. 
Therefore the value of x is 3*8 + 2 = 26<table class='mtq_question_heading_table'><tr><td>Question 8<div id='mtq_stamp-8-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-8-1' class='mtq_question_text'>Consider the following C program, which variable has the longest scope?
<pre class="brush: c; title: ; notranslate" title="">
int a;
int main()
{
   int b;
   // ..
   // ..
}
int c;
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-8-1-1' onclick='mtq_button_click(8,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 8, Choice 1'>A<div id='mtq_marker-8-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-1-1' class='mtq_answer_text'>a</td></tr><tr id='mtq_row-8-2-1' onclick='mtq_button_click(8,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 8, Choice 2'>B<div id='mtq_marker-8-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-2-1' class='mtq_answer_text'>b</td></tr><tr id='mtq_row-8-3-1' onclick='mtq_button_click(8,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 8, Choice 3'>C<div id='mtq_marker-8-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-3-1' class='mtq_answer_text'>c</td></tr><tr id='mtq_row-8-4-1' onclick='mtq_button_click(8,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 8, Choice 4'>D<div id='mtq_marker-8-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-4-1' class='mtq_answer_text'>All have same scope</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-8-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-8-1' class='mtq_explanation'>Question 8 Explanation:&nbsp; a is accessible everywhere.
b is limited to main()
c is accessible only after its declaration.<table class='mtq_question_heading_table'><tr><td>Question 9<div id='mtq_stamp-9-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-9-1' class='mtq_question_text'>Consider the following variable declarations and definitions in C
<pre class="brush: c; title: ; notranslate" title="">
i) int var_9 = 1;
ii) int 9_var = 2;
iii) int _ = 3;
</pre>
Choose the correct statement w.r.t. 
above variables.<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-9-1-1' onclick='mtq_button_click(9,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 9, Choice 1'>A<div id='mtq_marker-9-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-1-1' class='mtq_answer_text'>Both i) and iii) are valid.</td></tr><tr id='mtq_row-9-2-1' onclick='mtq_button_click(9,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 9, Choice 2'>B<div id='mtq_marker-9-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-2-1' class='mtq_answer_text'>Only i) is valid.</td></tr><tr id='mtq_row-9-3-1' onclick='mtq_button_click(9,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 9, Choice 3'>C<div id='mtq_marker-9-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-3-1' class='mtq_answer_text'>Both i) and ii) are valid.</td></tr><tr id='mtq_row-9-4-1' onclick='mtq_button_click(9,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 9, Choice 4'>D<div id='mtq_marker-9-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-4-1' class='mtq_answer_text'>All are valid.</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><b><a href="https://www.geeksforgeeks.org/c-quiz-101-gq/">C Quiz - 101</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-c-quiz-101-question-5/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-9-1' class='mtq_explanation'>Question 9 Explanation:&nbsp; In C language, a variable name can consists of letters, digits and underscore i.e. 
_ . 
But a variable name has to start with either letter or underscore. 
It can't start with a digit. 
So valid variables are var_9 and _ from the above question. 
Even two back to back underscore i.e. 
__ is also a valid variable name. 
Even _9 is a valid variable. 
But 9var and 9_ are invalid variables in C. 
This will be caught at the time of compilation itself. 
That's why the correct answer is A).
&nbsp;<table class='mtq_question_heading_table'><tr><td>Question 10<div id='mtq_stamp-10-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-10-1' class='mtq_question_text'>Find out the correct statement for the following program.
<pre class="brush: c; title: ; notranslate" title="">
#include &quot;stdio.h&quot;
int * gPtr;
int main()
{
 int * lPtr = NULL;
 if(gPtr == lPtr)
 {
   printf(&quot;Equal!&quot;);
 }
 else
 {
  printf(&quot;Not Equal&quot;);
 }
 return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-10-1-1' onclick='mtq_button_click(10,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 10, Choice 1'>A<div id='mtq_marker-10-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-1-1' class='mtq_answer_text'>It’ll always print Equal.</td></tr><tr id='mtq_row-10-2-1' onclick='mtq_button_click(10,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 10, Choice 2'>B<div id='mtq_marker-10-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-2-1' class='mtq_answer_text'>It’ll always print Not Equal.</td></tr><tr id='mtq_row-10-3-1' onclick='mtq_button_click(10,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 10, Choice 3'>C<div id='mtq_marker-10-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-3-1' class='mtq_answer_text'>Since gPtr isn’t initialized in the program, it’ll print sometimes Equal and at other times Not Equal.</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/variable-declaration-and-scope-gq/">C Variable Declaration and Scope</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><b><a href="https://www.geeksforgeeks.org/c-quiz-109-gq/">C Quiz - 109</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-c-quiz-109-question-4/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-10-1' class='mtq_explanation'>Question 10 Explanation:&nbsp; It should be noted that global variables such gPtr (which is a global pointer to int) are initialized to ZERO. 
That’s why gPtr (which is a global pointer and initialized implicitly) and lPtr (which a is local pointer and initialized explicitly) would have same value i.e. 
correct answer is a. 
               <!--End of mtqscrollable items-->
<h2>Complicated declarations in C</h2>
Most of the times declarations are simple to read, but it is hard to read some declarations which involve pointer to functions. 
For example, consider the following declaration from &#8220;signal.h&#8221;.<!--more-->
<code class="keyword bold">void</code> <code class="plain">(*bsd_signal(</code><code class="color1 bold">int</code><code class="plain">, </code><code class="keyword bold">void</code> <code class="plain">(*)(</code><code class="color1 bold">int</code><code class="plain">)))(</code><code class="color1 bold">int</code><code class="plain">); </code>
Let us see the steps to read complicated declarations.
<strong>1)</strong>  Convert C declaration to postfix format and read from right to left.<br />
<strong>2)</strong>  To convert expression to postfix, start from innermost parenthesis, If innermost parenthesis is not present then start from declarations name and go right first. 
When first ending parenthesis encounters then go left. 
Once whole parenthesis is parsed then come out from parenthesis.<br />
<strong>3) </strong> Continue until complete declaration has been parsed.
Let us start with simple example. 
Below examples are from “K &amp; R”  book.
<code class="plain">1)&nbsp; </code><code class="color1 bold">int</code> <code class="plain">(*fp) (); </code>
Let us convert above expression to postfix format. 
For the above example, there is no innermost parenthesis, that&#8217;s why, we will print declaration name i.e. 
&#8220;fp&#8221;. 
Next step is, go to right side of expression, but there is nothing on right side of &#8220;fp&#8221; to parse, that&#8217;s why go to left side. 
On left side we found &#8220;*&#8221;, now print &#8220;*&#8221; and come out of parenthesis. 
We will get postfix expression as below.
<pre>
  fp  *  ()  int
</pre>
Now read postfix expression from left to right. 
e.g. 
fp is pointer to function returning int
Let us see some more examples.
<code class="plain">2) </code><code class="color1 bold">int</code> <code class="plain">(*daytab)[13] </code>
Postfix    :  daytab * [13] int<br />
Meaning    :  daytab is pointer to array of 13 integers.
<code class="plain">3) </code><code class="keyword bold">void</code> <code class="plain">(*f[10]) (</code><code class="color1 bold">int</code><code class="plain">, </code><code class="color1 bold">int</code><code class="plain">) </code>
Postfix    :  f[10] * (int, int) void<br />
Meaning    :  f is an array of 10 pointer to function(which takes 2 arguments of type int) returning void
<code class="plain">4) </code><code class="color1 bold">char</code> <code class="plain">(*(*x())[]) () </code>
Postfix    : x () * [] * () char<br />
Meaning    : x is a function returning pointer to array of pointers to function returnging char
<code class="plain">5) </code><code class="color1 bold">char</code> <code class="plain">(*(*x[3])())[5] </code>
Postfix    : x[3] * () * [5] char<br />
Meaning    : x is an array of 3 pointers to function returning pointer to array of 5 char’s
<code class="plain">6) </code><code class="color1 bold">int</code> <code class="plain">*(*(*arr[5])()) () </code>
Postfix    : arr[5] * () * () * int<br />
Meaning    : arr is an array of 5 pointers to functions returning pointer to function returning pointer to integer
<code class="plain">7) </code><code class="keyword bold">void</code> <code class="plain">(*bsd_signal(</code><code class="color1 bold">int</code> <code class="plain">sig, </code><code class="keyword bold">void</code> <code class="plain">(*func)(</code><code class="color1 bold">int</code><code class="plain">)))(</code><code class="color1 bold">int</code><code class="plain">); </code>
Postfix    : bsd_signal(int sig, void(*func)(int))  *  (int)  void<br />
Meaning    : bsd_signal is a function that takes integer &amp; a pointer to a function(that takes integer as argument and returns void) and returns pointer to a function(that take integer as argument and returns void)
<h2>Redeclaration of global variable in C</h2>
Consider the below two programs:
<code class="comments">// Program 1 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
Output in C: 
<pre>redeclaration of ‘x’ with no linkage</pre>
<code class="comments">// Program 2 </code>
<code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="color1 bold">int</code> <code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
Output in C: 
<pre>5</pre>
In C, the first program fails in compilation, but second program works fine. 
In C++, both programs fail in compilation.
<strong><br />
C allows a global variable to be declared again when first declaration doesn&#8217;t initialize the variable.</strong>
The below program fails in both C also as the global variable is initialized in first declaration itself.
<code class="color1 bold">int</code> <code class="plain">x = 5; </code>
<code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre> error: redefinition of ‘x’</pre>
<h2>Internal Linkage and External Linkage in C</h2>
It is often quite hard to distinguish between scope and linkage, and the roles they play. 
This article focuses on scope and linkage, and how they are used in C language.<br />
<strong> Note: </strong> All C programs have been compiled on 64 bit GCC 4.9.2. 
Also, the terms &#8220;identifier&#8221; and &#8220;name&#8221; have been used interchangeably in this article.
<p align="center"><strong><br />
Definitions </strong>
<ul>
<li><strong>Scope :</strong> Scope of an identifier is the part of the program where the identifier may directly be accessible. 
In C, all identifiers are lexically (or statically) scoped.</li>
<li><strong>Linkage :</strong> Linkage describes how names can or can not refer to the same entity throughout the whole program or one single translation unit.<br />
The above sounds similar to Scope, but it is not so. 
To understand what the above means, let us dig deeper into the compilation process.</li>
<li><strong>Translation Unit : </strong>A translation unit is a file containing source code, header files and other dependencies. 
All of these sources are grouped together in a file for they are used to produce one single executable object. 
It is important to link the sources together in a meaningful way. 
For example, the compiler should know that <code>printf</code> definition lies in <code>stdio</code> header file.</li>
</ul>
In C and C++, a program that consists of multiple source code files is compiled <em>one at a time</em>. 
Until the compilation process, a variable can be described by it&#8217;s scope. 
It is only when the linking process starts, that linkage property comes into play. 
Thus, <strong>scope is a property handled by compiler, whereas linkage is a property handled by linker.</strong>
The Linker links the resources together in the <em>linking</em> stage of compilation process. 
The Linker is a program that takes multiple machine code files as input, and produces an executable object code. 
It resolves symbols (i.e, fetches definition of symbols such as &#8220;+&#8221; etc..) and arranges objects in address space.
Linkage is a property that describes how variables should be linked by the linker. 
Should a variable be available for another file to use? Should a variable be used only in the file declared? Both are decided by linkage.<br />
Linkage thus allows you to couple names together on a per file basis, scope determines visibility of those names.<br />
<strong>There are 2 types of linkage:</strong>
<ol>
<li> <b> Internal Linkage</b>: An identifier implementing internal linkage is not accessible outside the translation unit it is declared in. 
Any identifier within the unit can access an identifier having internal linkage. 
It is implemented by the keyword <code><a href="https://www.geeksforgeeks.org/static-variables-in-c/">static</a></code>. 
An internally linked identifier is stored in initialized or uninitialized segment of RAM. 
(<strong>note:</strong> <code> static </code> also has a meaning in reference to scope, but that is not discussed here).<br />
Some Examples:
<p align="center"><b>Animals.cpp</b>
<code class="comments">// C code to illustrate Internal Linkage </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">animals = 8; </code>
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">i = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">call_me(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d"</code><code class="plain">, i, animals); </code>
<code class="plain">} </code>
The above code implements static linkage on identifier <code>animals</code>. 
Consider <code>Feed.cpp</code> is located in the same translation unit.
<p align="center"><b>Feed.cpp</b>
<code class="comments">// C code to illustrate Internal Linkage </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">call_me(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">animals = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, animals); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
On compiling Animals.cpp first and then Feed.cpp, we get
<pre>
Output : 5 8 2
</pre>
Now, consider that Feed.cpp is located in a different translation unit. 
It will compile and run as above only if we use <code>#include "Animals.cpp"</code>.<br />
Consider Wash.cpp located in a 3rd translation unit.
<p align="center"><b> Wash.cpp </b>
<code class="comments">// C code to illustrate Internal Linkage </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include "animal.cpp" // note that animal is included. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">call_me(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n having fun washing!"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">animals = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, animals); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
On compiling, we get:
          
<pre>
Output : 5 8
having fun washing!
10
</pre>
There are 3 translation units (Animals, Feed, Wash) which are using <code>animals</code> code.<br />
This leads us to conclude that each translation unit accesses it&#8217;s own copy of <code>animals</code>. 
That is why we have <code>animals</code> = 8 for <code>Animals.cpp</code>, <code>animals</code> = 2 for <code>Feed.cpp</code> and <code>animals</code> = 10 for <code>Wash.cpp</code>. 
A file. 
This behavior eats up memory and decreases performance.
Another property of internal linkage is that it is<strong> only implemented when the variable has global scope</strong>, and all constants are by default internally linked.
<b> Usage :  </b> As we know, an internally linked variable is passed by copy. 
Thus, if a header file has a function <code>fun1()</code> and the source code in which it is included in also has <code>fun1()</code> but with a different definition, then the 2 functions will not clash with each other. 
Thus, we commonly use internal linkage to hide translation-unit-local helper functions from the global scope. 
For example, we might include a header file that contains a method to read input from the user, in a file that may describe another method to read input from the user. 
Both of these functions are independent of each other when linked.
</li>
<li>
<b> External Linkage: </b> An identifier implementing external linkage is visible to <strong>every translation unit</strong>. 
Externally linked identifiers are <em> shared </em> between translation units and are considered to be located at the outermost level of the program. 
In practice, this means that you must define an identifier in a place which is visible to all, such that it has only one visible definition. 
It is the default linkage for globally scoped variables and functions. 
Thus, all instances of a particular identifier with external linkage refer to the same identifier in the program. 
The keyword <code><a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">extern</a></code> implements external linkage.
When we use the keyword <code>extern</code>, we tell the linker to look for the definition elsewhere. 
Thus, the declaration of an externally linked identifier does not take up any space. 
<code>Extern</code> identifiers are generally stored in initialized/uninitialized or text segment of RAM.
<strong> Please do go through <a /> <a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">Understanding extern keyword in C </a></a> before proceeding to the following examples. 
</strong><br />
It is possible to use an <code>extern</code> variable in a local scope. 
This shall further outline the differences between linkage and scope. 
Consider the following code:
<code class="comments">// C code to illustrate External Linkage </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">foo() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">b; </code><code class="comments">// line 1 </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">bar() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">c = b; </code><code class="comments">// error </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">foo(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">bar(); </code>
<code class="plain">} </code>
<pre>
Error: 'b' was not declared in this scope
</pre>
<strong><br />
Explanation :</strong> The variable <code>b</code> has local scope in the function <code>foo</code>, even though it is an <code>extern</code> variable. 
Note that compilation takes place before linking; i.e scope is a concept that can be used only during compile phase. 
After the program is compiled there is no such concept as &#8220;scope of variable&#8221;.
During compilation, scope of <code>b</code> is considered. 
It has local scope in <code>foo()</code>. 
When the compiler sees the <code>extern</code> declaration, it trusts that there is a definition of <code>b</code> somewhere and lets the linker handle the rest.
However, the same compiler will go through the <code>bar()</code> function and try to find variable <code>b</code>. 
Since <code>b</code> has been declared <code>extern</code>, it has not been given memory yet by the compiler; it does not exist yet. 
The compiler will let the linker find the definition of <code>b</code> in the translation unit, and then the linker will assign <code>b</code> the value specified in definition. 
It is only then that <code>b</code> will exist and be assigned memory. 
However, since there is no declaration given at compile time within the scope of <code>bar()</code>, or even in global scope, the compiler complains with the error above. 
Given that it is the compiler&#8217;s job to make sure that all variables are used within their scopes, it complains when it sees <code>b</code> in <code>bar()</code>, when <code>b</code> has been declared in <code>foo()</code>&#8216;s scope. 
The compiler will stop compiling and the program will not be passed to the linker.
We can fix the program by declaring <code>b</code> as a global variable, by moving line 1 to before <code>foo</code>&#8216;s definition.
          
Let us look at another example
<code class="comments">// C code to illustrate External Linkage </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="color1 bold">int</code> <code class="plain">z = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">y; </code><code class="comments">// line 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d"</code><code class="plain">, x, y, z); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">y = 2; </code>
<pre>
Output: 10 2 5
</pre>
We can explain the output by observing behaviour of external linkage. 
We define 2 variables <code>x</code> and <code>z</code> in <em>global</em> scope. 
By default, both of them have external linkage. 
Now, when we declare <code>y</code> as <code>extern</code>, we tell the compiler that there exists a <code>y</code> with some definition within the same translation unit. 
Note that this is during the compile time phase, where the compiler trusts the <code>extern</code> keyword and compiles the rest of the program. 
The next line, <code> extern int z </code> has no effect on <code>z</code>, as <code> z </code> is externally linked by default when we declared it as a global variable outside the program. 
When we encounter <code>printf</code> line, the compiler sees 3 variables, all 3 having been declared before, and all 3 being used within their scopes (in the <code>printf</code> function). 
The program thus compiles successfully, even though the compiler does not know the definition of <code>y</code>
The next phase is linking. 
The linker goes through the compiled code and finds <code>x</code> and <code>z</code> first. 
As they are global variables, they are externally linked by default. 
The linker then updates value of <code>x</code> and <code>z</code> throughout the entire translation unit as 10 and 5. 
If there are any references to <code>x</code> and <code>z</code> in any other file in the translation unit, they are set to 10 and 5.
Now, the linker comes to <code>extern int y</code> and tries to find any definition of <code>y</code> within the translation unit. 
It looks through every file in the translation unit to find definition of <code>y</code>. 
If it does not find any definition, a linker error will be thrown. 
In our program, we have given the definition outside <code>main()</code>, which has already been compiled for us. 
Thus, the linker finds that definition and updates <code>y</code>.
<h2>Different ways to declare variable as constant in C and C++</h2>
There are many different ways to make the variable as constant
<ol>
<li>
<strong>Using <a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">const keyword</a>:</strong> The const keyword specifies that a variable or object value is constant and can&#8217;t be modified at the compilation time.
<code class="comments">// C program to demonstrate const specifier </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">num = 1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">num = 5; </code><code class="comments">// Modifying the value </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
It will throw as error like:
<strong>error: assignment of read-only variable ‘num’</strong>
</pre>
</li>
<li>
<strong>Using <a href="https://www.geeksforgeeks.org/enumeration-enum-c/">enum keyword</a>:</strong> Enumeration (or enum) is a user defined data type in  C and C++. 
It is mainly used to assign names to integral constants, that make a program easy to read and maintain.
<code class="comments">// In C and C++ internally the default </code>
<code class="comments">// type of 'var' is int </code>
<code class="keyword bold">enum</code> <code class="plain">VARS { var = 42 }; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// In C++ 11 (can have any integral type): </code>
<code class="keyword bold">enum</code> <code class="plain">: type { var = 42; } </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// where mytype = int, char, long etc. 
</code>
<code class="comments">// but it can't be float, double or </code>
<code class="comments">// user defined data type. 
</code>
<strong>Note:</strong> The data types of <strong>enum</strong> are of course limited as we can see in above example.
</li>
<li><strong>Using <a href="https://www.geeksforgeeks.org/understanding-constexper-specifier-in-c/">constexpr</a> keyword:</strong> Using constexpr in C++(not in C) can be used to declare variable as a guaranteed constant. 
But it would fail to compile if its initializer isn&#8217;t a constant expression.
<code class="preprocessor">#include &lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">var = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">constexpr </code><code class="color1 bold">int</code> <code class="plain">k = var; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; k; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Above program will throw an error i.e.,
<pre>error: the value of ‘var’ is not usable in a constant expression</pre>
because the variable &#8216;var&#8217; in not constant expression. 
Hence in order to make it as constant, we have to declare the variable &#8216;var&#8217; with <strong>const</strong> keyword.
</li>
<li><strong>Using <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Macros</a>:</strong> We can also use Macros to define constant, but there is a catch,
<pre>#define var 5</pre>
Since Macros are handled by the pre-processor(the pre-processor does text replacement in our source file, replacing all occurrences of &#8216;var&#8217; with the literal 5) not by the compiler.<br />
Hence it wouldn&#8217;t be recommended because Macros doesn&#8217;t carry type checking information and also prone to error. 
In fact not quite constant as &#8216;var&#8217; can be redefined like this, 
<h3>C++</h3>
<code class="comments">// C++ program to demonstrate the problems </code>
<code class="comments">// in 'Macros' </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define var 5 </code>
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, var); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#ifdef var </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef var </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// redefine var as 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#define var 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#endif </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, var); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C</h3>
<code class="comments">// C program to demonstrate the problems </code>
<code class="comments">// in 'Macros' </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define var 5 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, var); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#ifdef var </code>
<code class="preprocessor">#undef var </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// redefine var as 10 </code>
<code class="preprocessor">#define var 10 </code>
<code class="preprocessor">#endif </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, var); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<strong>Output:</strong>
5 10
</pre></li></ol>
<blockquote>Note: <strong>preprocessor</strong> and <strong>enum</strong> only works as a literal constant and integers constant respectively. 
Hence they only define the symbolic name of constant. 
Therefore if you need a constant variable with a specific memory address use either &#8216;const&#8217; or &#8216;constexpr&#8217; according to the requirement.</blockquote>
<h2>Why variable name does not start with numbers in C ?</h2>
In C, apart from keywords everything in the C program is treated as Identifier. 
Identifier can be the names given to variables, constants, functions and user-defined data. 
A variable name can consist of alphabets (upper case, lower case), numbers (0-9) and _ (underscore) character. 
But the name of any variable must not start with a number. 
Now we must have the answer that why can&#8217;t we name a variable starting with number. 
Following might be the reason for it. 
The compiler has 7 phase as fellows:
<pre>
    Lexical Analysis
    Syntax Analysis
    Semantic Analysis
    Intermediate Code Generation
    Code Optimization
    Code Generation
    Symbol Table
</pre>
Backtracking is avoided in lexical analysis phase while compiling the piece of code. 
The variable like Apple; , the compiler will know its a identifier right away when it meets letter &#8216;A&#8217; character in the lexical Analysis phase. 
However, a variable like 123apple; , compiler won&#8217;t be able to decide if its a number or identifier until it hits &#8216;a&#8217; and it needs backtracking to go in the lexical analysis phase to identify that it is a variable. 
But it is not supported in compiler.<br />
When you&#8217;re parsing the token you only have to look at the first character to determine if it&#8217;s an identifier or literal and then send it to the correct function for processing. 
So that&#8217;s a performance optimization.
<h2>Initialization of global and static variables in C</h2>
Predict the output of following C programs.<!--more-->
<code class="comments">// PROGRAM 1 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">*p = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(p)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*p = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *p); </code>
<code class="plain">} </code>
<code class="comments">// PROGRAM 2 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">*p = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(p)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*p = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *p); </code>
<code class="plain">} </code>
Both of the above programs don&#8217;t compile in C. 
We get the following compiler error in C. 
<pre>error: initializer element is not constant</pre>
In C, static and global variables are initialized by the compiler itself. 
Therefore, they must be initialized with a constant value.
Note that the above programs compile and run fine in C++, and produce the output as 10.
As an exercise, predict the output of following program in both C and C++.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(x+5); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">y = fun(20); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, y); </code>
<code class="plain">}</code>
<h2>Data Types in C</h2>
Each variable in C has an associated data type. 
Each data type requires different amounts of memory and has some specific operations which can be performed over it. 
Let us briefly describe them one by one:
Following are the examples of some very common data types used in C:
<ul>
<li><strong>char:</strong> The most basic data type in C. 
It stores a single character and requires a single byte of memory in almost all compilers.
</li>
<li><strong>int: </strong>As the name suggests, an int variable is used to store an integer.
</li>
<li><strong>float:</strong> It is used to store decimal numbers (numbers with floating point value) with single precision.
</li>
<li><strong>double:</strong> It is used to store decimal numbers (numbers with floating point value) with double precision.
</li>
</ul>
Different data types also have different ranges upto which they can store numbers. 
These ranges may vary from compiler to compiler. 
Below is list of ranges along with the memory requirement and format specifiers on 32 bit gcc compiler.
<table width="100%" style="table-layout:fixed;">
<thead>
<th>Data Type
</th>
<th>Memory (bytes)
</th>
<th>Range
</th>
<th>Format Specifier
</th>
</thead>
<tbody>
<tr>
<td>short int
</td>
<td>2
</td>
<td>-32,768 to 32,767
</td>
<td>%hd
</td>
</tr>
<tr>
</td>
<td>unsigned short int
</td>
<td>2
</td>
<td>0 to 65,535
</td>
<td>%hu
</td>
</tr>
<tr>
</td>
<td>unsigned int
</td>
<td>4
</td>
<td>0 to 4,294,967,295
</td>
<td>%u
</td>
</tr>
<tr>
</td>
<td>int
</td>
<td>4
</td>
<td>-2,147,483,648 to 2,147,483,647
</td>
<td>%d
</td>
</tr>
<tr>
</td>
<td>long int
</td>
<td>4
</td>
<td>-2,147,483,648 to 2,147,483,647
</td>
<td>%ld
</td>
</tr>
<tr>
</td>
<td>unsigned long int
</td>
<td>4
</td>
<td>0 to 4,294,967,295
</td>
<td>%lu
</td>
</tr>
<tr>
</td>
<td>long long int
</td>
<td>8
</td>
<td>-(2^63) to (2^63)-1
</td>
<td>%lld
</td>
</tr>
<tr>
</td>
<td>unsigned long long int
</td>
<td>8
</td>
<td>0 to 18,446,744,073,709,551,615
</td>
<td>%llu
</td>
</tr>
<tr>
</td>
<td>signed char
</td>
<td>1
</td>
<td>-128 to 127
</td>
<td>%c
</td>
</tr>
<tr>
</td>
<td>unsigned char
</td>
<td>1
</td>
<td>0 to 255
</td>
<td>%c
</td>
</tr>
<tr>
</td>
<td>float
</td>
<td>4
</td>
<td>
</td>
<td>%f
</td>
</tr>
<tr>
</td>
<td>double
</td>
<td>8
</td>
<td>
</td>
<td>%lf
</td>
</tr>
<tr>
</td>
<td>long double
</td>
<td>12
</td>
<td>
</td>
<td>%Lf
</td>
</tr>
</tbody>
</table>
We can use the<a href="http://quiz.geeksforgeeks.org/sizeof-operator-c/"> sizeof() operator </a>to check the size of a variable. 
See the following C program for the usage of the various data types:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">b =</code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">c = 3.14; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello World!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//printing the variables defined above along with their sizes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello! I am a character. 
My value is %c and "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"my size is %lu byte.\n"</code><code class="plain">, b,</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//can use sizeof(b) above as well </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello! I am an integer. 
My value is %d and "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"my size is %lu&nbsp; bytes.\n"</code><code class="plain">, a,</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//can use sizeof(a) above as well </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello! I am a double floating point variable."</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" My value is %lf and my size is %lu bytes.\n"</code><code class="plain">,c,</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">double</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//can use sizeof(c) above as well </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Bye! See you soon. 
:)\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Hello World!
Hello! I am a character. 
My value is G and my size is 1 byte.
Hello! I am an integer. 
My value is 1 and my size is 4  bytes.
Hello! I am a double floating point variable. 
My value is 3.140000 and my size i
s 8 bytes.
Bye! See you soon. 
:)</pre>
<h2>Use of bool in C</h2>
<strong>Prerequisite: </strong><a href="https://www.geeksforgeeks.org/bool-data-type-in-c/">Bool Data Type in C++</a>
The <a href="http://en.wikipedia.org/wiki/C99">C99 standard for C language</a> supports bool variables. 
<!--more--> Unlike C++, where no header file is needed to use bool, a header file &#8220;stdbool.h&#8221; must be included to use bool in C. 
If we save the below program as .c, it will not compile, but if we save it as .cpp, it will work fine.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">arr[2] = {</code><code class="keyword bold">true</code><code class="plain">, </code><code class="keyword bold">false</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
If we include the header file &#8220;stdbool.h&#8221; in the above program, it will work fine as a C  program. 
     <br/>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">arr[2] = {</code><code class="keyword bold">true</code><code class="plain">, </code><code class="keyword bold">false</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Integer Promotions in C</h2>
Some data types like <em>char </em>, <em>short int </em> take less number of bytes than <em>int</em>, these data types are automatically promoted to <em>int </em>or <em>unsigned int</em><!--more--> when an operation is performed on them. 
This is called integer promotion. 
For example no arithmetic calculation happens on smaller types like <em>char</em>, <em>short </em>and <em>enum</em>. 
They are first converted to <em>int </em>or <em>unsigned int</em>, and then arithmetic is done on them. 
If an <em>int </em>can represent all values of the original type, the value is converted to an <em>int </em></em>. 
Otherwise, it is converted to an <em>unsigned int.</em>
For example see the following program.
<code class="preprocessor">#include &lt;stdio.h>&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a = 30, b = 40, c = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">d = (a * b) / c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%d "</code><code class="plain">, d);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>120</pre>
At first look, the expression (a*b)/c seems to cause arithmetic overflow because signed characters can have values only from -128 to 127 (in most of the C compilers), and the value of subexpression ‘(a*b)’ is 1200 which is greater than 128. 
But integer promotion happens here in arithmetic done on char types and we get the appropriate result without any overflow.
Consider the following program as <strong>another example</strong>.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a = 0xfb; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">char</code> <code class="plain">b = 0xfb; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %c"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nb = %c"</code><code class="plain">, b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a == b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nSame"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nNot Same"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output:
<pre>a = ?
b = ?
Not Same </pre>
When we print &#8216;a&#8217; and &#8216;b&#8217;, same character is printed, but when we compare them, we get the output as &#8220;Not Same&#8221;.<br />
&#8216;a&#8217; and &#8216;b&#8217; have same binary representation as <em>char</em>. 
But when comparison operation is performed on &#8216;a&#8217; and &#8216;b&#8217;, they are first converted to int. 
&#8216;a&#8217; is a signed <em>char</em>, when it is converted to <em>int</em>, its value becomes -5 (signed value of 0xfb). 
 &#8216;b&#8217; is <em>unsigned char</em>, when it is converted to <em>int</em>, its value becomes 251. 
The values -5 and 251 have different representations as <em>int</em>, so we get the output as &#8220;Not Same&#8221;.
We will soon be discussing integer conversion rules between signed and unsigned, int and long int, etc.
<h1 style="display:inline">C Data Types</h2>
		</header>
<div id="mtq_quiz_area-1" class="mtq_quiz_area mtq_color_green"> 
  <!--Quiz generated using mTouch Quiz Version 3.1.3 by G. 
Michael Guy (http://gmichaelguy.com/quizplugin/)-->
        
    
   <!-- Here code starts for pagination -->
  
  <!-- <a class="page" data-pageid="0">First</a> -->
          <a class="page current" data-pageid="0">1</a><a class="page" data-pageid="1">2</a>        <!-- <a class="page" data-pageid="<?php# echo $total_pagination_btn-1; ?>">Last</a> -->
  
  <!-- Here code ends for pagination -->
  <!-- Shortcode entered mtouchquiz id=30 --> 
  <!-- Shortcode interpreted mtouchquiz id=3off alerts=off singlepage=on hints=on startscreen=off finalscreen=off multiplechances=off showanswers=now show_stamps=on randomq=off randoma=off status=on labels=on title=on proofread=off list=off time=off scoring=off formid= vform=on autoadvance=off autosubmit=off inform=off forcecf=off forcegf=off offset=1 questions=14 firstid=175 lastid=2192 color=green --> 
  <!--form action="" method="post" class="quiz-form" id="quiz-30"-->
      <div id="mtq_quiztitle-1" class="mtq_quiztitle" style='display:none'>
  <h2 style="margin-bottom:0px;">C Data Types</h3>
  
      <noscript>
  <div id="mtq_javawarning-1" class="mtq_javawarning">
  Please wait while the activity loads.</br> If this activity does not load, try refreshing your browser. 
Also, this page requires javascript. 
Please visit using a browser with javascript enabled. 
  If loading fails, click here to try again  
  </noscript>
    
  <!-- root element for mtqscrollable -->
  <div id="mtq_question_container-1" >
  
          <table class='mtq_question_heading_table'><tr><td>Question 1<div id='mtq_stamp-1-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-1-1' class='mtq_question_text'>Predict the output of following program. 
Assume that the numbers are stored in 2's complement form.
<pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt; 
int  main() 
{ 
   unsigned int x = -1; 
   int y = ~0; 
   if (x == y) 
      printf(&quot;same&quot;); 
   else
      printf(&quot;not same&quot;); 
   return 0; 
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-1-1-1' onclick='mtq_button_click(1,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 1, Choice 1'>A<div id='mtq_marker-1-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-1-1' class='mtq_answer_text'>same</td></tr><tr id='mtq_row-1-2-1' onclick='mtq_button_click(1,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 1, Choice 2'>B<div id='mtq_marker-1-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-2-1' class='mtq_answer_text'>not same</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-1/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-1-1' class='mtq_explanation'>Question 1 Explanation:&nbsp; -1 and ~0 essentially have same bit pattern, hence x and y must be same. 
In the comparison, y is promoted to unsigned and compared against x (See <a href="http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.xlcpp101.aix.doc/language_ref/cplr066.html">this </a>for promotion rules). 
The result is “same”. 
However, when interpreted as signed and unsigned their numerical values will differ. 
x is MAXUNIT and y is -1. 
Since we have %u for y also, the output will be MAXUNIT and MAXUNIT.
<table class='mtq_question_heading_table'><tr><td>Question 2<div id='mtq_stamp-2-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-2-1' class='mtq_question_text'>Which of the following is not a valid declaration in C?
<pre class="brush: c; title: ; notranslate" title="">
1. 
short int x;
</pre>
<pre class="brush: c; title: ; notranslate" title="">
2. 
signed short x;
</pre>
<pre class="brush: c; title: ; notranslate" title="">
3. 
short x;
</pre>
<pre class="brush: c; title: ; notranslate" title="">
4. 
unsigned short x;
</pre>
<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-2-1-1' onclick='mtq_button_click(2,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 2, Choice 1'>A<div id='mtq_marker-2-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-1-1' class='mtq_answer_text'>3 and 4</td></tr><tr id='mtq_row-2-2-1' onclick='mtq_button_click(2,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 2, Choice 2'>B<div id='mtq_marker-2-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-2-1' class='mtq_answer_text'>2</td></tr><tr id='mtq_row-2-3-1' onclick='mtq_button_click(2,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 2, Choice 3'>C<div id='mtq_marker-2-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-3-1' class='mtq_answer_text'>1</td></tr><tr id='mtq_row-2-4-1' onclick='mtq_button_click(2,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 2, Choice 4'>D<div id='mtq_marker-2-4-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-4-1' class='mtq_answer_text'>All are valid</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-2-1' class='mtq_explanation'>Question 2 Explanation:&nbsp; All are valid. 
First 3 mean the same thing. 
 4th means unsigned.<table class='mtq_question_heading_table'><tr><td>Question 3<div id='mtq_stamp-3-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-3-1' class='mtq_question_text'>Predict the output
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
   float c = 5.0;
   printf (&quot;Temperature in Fahrenheit is %.2f&quot;, (9/5)*c + 32);
   return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-3-1-1' onclick='mtq_button_click(3,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 3, Choice 1'>A<div id='mtq_marker-3-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-1-1' class='mtq_answer_text'>Temperature in Fahrenheit is 41.00</td></tr><tr id='mtq_row-3-2-1' onclick='mtq_button_click(3,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 3, Choice 2'>B<div id='mtq_marker-3-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-2-1' class='mtq_answer_text'>Temperature in Fahrenheit is 37.00</td></tr><tr id='mtq_row-3-3-1' onclick='mtq_button_click(3,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 3, Choice 3'>C<div id='mtq_marker-3-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-3-1' class='mtq_answer_text'>Temperature in Fahrenheit is 0.00</td></tr><tr id='mtq_row-3-4-1' onclick='mtq_button_click(3,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 3, Choice 4'>D<div id='mtq_marker-3-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-4-1' class='mtq_answer_text'>Compiler Error</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-3/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-3-1' class='mtq_explanation'>Question 3 Explanation:&nbsp; Since 9 and 5 are integers, integer arithmetic happens in subexpression (9/5) and we get 1 as its value.
To fix the above program, we can use 9.0 instead of 9 or 5.0 instead of 5 so that floating point arithmetic happens.
<table class='mtq_question_heading_table'><tr><td>Question 4<div id='mtq_stamp-4-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-4-1' class='mtq_question_text'>Predict the output of following C program
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    char a = '
    printf(&quot;%d&quot;, a);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-4-1-1' onclick='mtq_button_click(4,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 4, Choice 1'>A<div id='mtq_marker-4-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-4-2-1' onclick='mtq_button_click(4,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 4, Choice 2'>B<div id='mtq_marker-4-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-2-1' class='mtq_answer_text'>12</td></tr><tr id='mtq_row-4-3-1' onclick='mtq_button_click(4,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 4, Choice 3'>C<div id='mtq_marker-4-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-3-1' class='mtq_answer_text'>10</td></tr><tr id='mtq_row-4-4-1' onclick='mtq_button_click(4,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 4, Choice 4'>D<div id='mtq_marker-4-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-4-1' class='mtq_answer_text'>Empty</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-4/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-4-1' class='mtq_explanation'>Question 4 Explanation:&nbsp; The value '\012' means the character with value 12 in octal, which is decimal 10.
Note: It is equivalent to char a = 012 and int a = ‘\012’ and int a = 012. 
<table class='mtq_question_heading_table'><tr><td>Question 5<div id='mtq_stamp-5-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-5-1' class='mtq_question_text'>In C, sizes of an integer and a pointer must be same.<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-5-1-1' onclick='mtq_button_click(5,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 5, Choice 1'>A<div id='mtq_marker-5-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-1-1' class='mtq_answer_text'>True</td></tr><tr id='mtq_row-5-2-1' onclick='mtq_button_click(5,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 5, Choice 2'>B<div id='mtq_marker-5-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-2-1' class='mtq_answer_text'>False</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-5/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-5-1' class='mtq_explanation'>Question 5 Explanation:&nbsp; Sizes of integer and pointer are compiler dependent. 
The both sizes need not be same.<table class='mtq_question_heading_table'><tr><td>Question 6<div id='mtq_stamp-6-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-6-1' class='mtq_question_text'>Output?
<pre class="brush: c; title: ; notranslate" title="">
int main()
{
    void *vptr, v;
    v = 0;
    vptr = &amp;v;
    printf(&quot;%v&quot;, *vptr);
    getchar();
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-6-1-1' onclick='mtq_button_click(6,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 6, Choice 1'>A<div id='mtq_marker-6-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-1-1' class='mtq_answer_text'>0</td></tr><tr id='mtq_row-6-2-1' onclick='mtq_button_click(6,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 6, Choice 2'>B<div id='mtq_marker-6-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-2-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-6-3-1' onclick='mtq_button_click(6,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 6, Choice 3'>C<div id='mtq_marker-6-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-3-1' class='mtq_answer_text'>Garbage Value</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-6/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-6-1' class='mtq_explanation'>Question 6 Explanation:&nbsp; void is not a valid type for declaring variables. 
void * is valid though.<table class='mtq_question_heading_table'><tr><td>Question 7<div id='mtq_stamp-7-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-7-1' class='mtq_question_text'>Assume that the size of char is 1 byte and negatives are stored in 2's complement form
<pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
    char c = 125;
    c = c+10;
    printf(&quot;%d&quot;, c);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-7-1-1' onclick='mtq_button_click(7,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 7, Choice 1'>A<div id='mtq_marker-7-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-1-1' class='mtq_answer_text'>135</td></tr><tr id='mtq_row-7-2-1' onclick='mtq_button_click(7,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 7, Choice 2'>B<div id='mtq_marker-7-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-2-1' class='mtq_answer_text'>+INF</td></tr><tr id='mtq_row-7-3-1' onclick='mtq_button_click(7,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 7, Choice 3'>C<div id='mtq_marker-7-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-3-1' class='mtq_answer_text'>-121</td></tr><tr id='mtq_row-7-4-1' onclick='mtq_button_click(7,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 7, Choice 4'>D<div id='mtq_marker-7-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-4-1' class='mtq_answer_text'>-8</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-variable-declaration-and-scope-question-8/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-7-1' class='mtq_explanation'>Question 7 Explanation:&nbsp; 125 is represented as 01111101 in binary and when we add 10 i.e 1010 in binary it becomes : 10000111. 
Now what does this number represent?
Firstly, you should know that char can store numbers only -128 to 127 since the most significant bit is kept for sign bit. 
Therefore 10000111 represents a negative number. 
To check which number it represents we find the 2’s complement of it and get 01111001 which is = 121 in decimal system. 
Hence, the number 10000111 represents -121.<table class='mtq_question_heading_table'><tr><td>Question 8<div id='mtq_stamp-8-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-8-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    if (sizeof(int) &gt; -1)
        printf(&quot;Yes&quot;);
    else
        printf(&quot;No&quot;);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-8-1-1' onclick='mtq_button_click(8,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 8, Choice 1'>A<div id='mtq_marker-8-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-1-1' class='mtq_answer_text'>Yes</td></tr><tr id='mtq_row-8-2-1' onclick='mtq_button_click(8,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 8, Choice 2'>B<div id='mtq_marker-8-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-2-1' class='mtq_answer_text'>No</td></tr><tr id='mtq_row-8-3-1' onclick='mtq_button_click(8,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 8, Choice 3'>C<div id='mtq_marker-8-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-3-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-8-4-1' onclick='mtq_button_click(8,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 8, Choice 4'>D<div id='mtq_marker-8-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-4-1' class='mtq_answer_text'>Runtime Error</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-8/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-8-1' class='mtq_explanation'>Question 8 Explanation:&nbsp; In C, when an integer value is compared with an unsigned it, the int is promoted to unsigned. 
Negative numbers are stored in 2's complement form and unsigned value of the 2's complement form is much higher than the sizeof int.<table class='mtq_question_heading_table'><tr><td>Question 9<div id='mtq_stamp-9-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-9-1' class='mtq_question_text'>Suppose n and p are unsigned int variables in a C program. 
We wish to set p to <sup>n</sup>C<sub>3</sub>. 
If n is large, which of the following statements is most likely to set p correctly?
<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-9-1-1' onclick='mtq_button_click(9,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 9, Choice 1'>A<div id='mtq_marker-9-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-1-1' class='mtq_answer_text'>p = n * (n-1) * (n-2) / 6;</td></tr><tr id='mtq_row-9-2-1' onclick='mtq_button_click(9,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 9, Choice 2'>B<div id='mtq_marker-9-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-2-1' class='mtq_answer_text'> p = n * (n-1) / 2 * (n-2) / 3;</td></tr><tr id='mtq_row-9-3-1' onclick='mtq_button_click(9,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 9, Choice 3'>C<div id='mtq_marker-9-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-3-1' class='mtq_answer_text'>p  = n * (n-1) / 3 * (n-2) / 2;</td></tr><tr id='mtq_row-9-4-1' onclick='mtq_button_click(9,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 9, Choice 4'>D<div id='mtq_marker-9-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-4-1' class='mtq_answer_text'>p = n * (n-1) * (n-2) / 6.0;</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><b><a href="https://www.geeksforgeeks.org/gate-cs-2014-set-2-gq/">GATE-CS-2014-(Set-2)</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/gate-gate-cs-2014-set-2-question-21/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-9-1' class='mtq_explanation'>Question 9 Explanation:&nbsp; As n is large, the product n*(n-1)*(n-2) will go out of the range(overflow) and it will return a value different from what is expected. 
Therefore, option <strong>(A)</strong> and <strong>(D)</strong> are eliminated.
So we consider a shorter product n*(n-1).
n*(n-1) is always an even number. 
So the subexpression " n * (n-1) / 2 " in option B would always produce an integer, which means no precision loss in this subexpression. 
And when we consider " n*(n-1)/2*(n-2) ", it will always give a number which is a multiple of 3. 
So dividing it with 3 won't have any loss.<table class='mtq_question_heading_table'><tr><td>Question 10<div id='mtq_stamp-10-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-10-1' class='mtq_question_text'>Output of following program?
<pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
    float x = 0.1;
    if ( x == 0.1 )
        printf(&quot;IF&quot;);
    else if (x == 0.1f)
        printf(&quot;ELSE IF&quot;);
    else
        printf(&quot;ELSE&quot;);
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-10-1-1' onclick='mtq_button_click(10,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 10, Choice 1'>A<div id='mtq_marker-10-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-1-1' class='mtq_answer_text'>ELSE IF</td></tr><tr id='mtq_row-10-2-1' onclick='mtq_button_click(10,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 10, Choice 2'>B<div id='mtq_marker-10-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-2-1' class='mtq_answer_text'>IF</td></tr><tr id='mtq_row-10-3-1' onclick='mtq_button_click(10,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 10, Choice 3'>C<div id='mtq_marker-10-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-3-1' class='mtq_answer_text'>ELSE</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/data-types-gq/">C Data Types</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-data-types-question-9/">Discuss it</a></b></br><br></br>                <!--End of mtqscrollable items-->
<h2>Comparison of a float with a value in C</h2>
Predict the output of following C program.<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x = 0.1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(x == 0.1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"IF"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(x == 0.1f) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ELSE IF"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ELSE"</code><code class="plain">); </code>
<code class="plain">} </code>
The output of above program is &#8220;<em><strong>ELSE IF</strong></em>&#8221; which means the expression &#8220;x == 0.1&#8221; returns false and expression &#8220;x == 0.1f&#8221; returns true. 
Let consider the of following program to understand the reason behind the above output.<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x = 0.1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(x), </code><code class="keyword bold">sizeof</code><code class="plain">(0.1), </code><code class="keyword bold">sizeof</code><code class="plain">(0.1f)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
The output of above program is "<em><strong>4 8 4</strong></em>" on a typical C compiler.
It actually prints size of float, size of double and size of float.
</pre>
The values used in an expression are considered as double (<a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format">double precision floating point format</a>) unless a &#8216;f&#8217; is specified at the end. 
So the expression &#8220;x==0.1&#8221; has a double on right side and float which are stored in a <a href="http://en.wikipedia.org/wiki/Single_precision_floating-point_format">single precision floating point format</a> on left side. 
In such situations float is promoted to double (see <a href="http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.xlcpp101.aix.doc/language_ref/cplr066.html">this</a>). 
The double precision format uses more bits for precision than single precision format.<br />
The binary equivalent of 0.1<sub>10</sub> can be written as (0.00011001100110011&#8230;)<sub>2</sub> which will goes up to infinity(See <a href="https://www.geeksforgeeks.org/convert-decimal-fraction-binary-number/">this</a> article to know more about conversion). 
Since the precision of float is less than the double therefore after certain point(23 in float and 52 in double) it would truncate the result. 
Hence after promotion of float into double(at the time of comparison) compiler will pad the remaining bits with zeroes. 
Hence we get the different result in which decimal equivalent of both would be different. 
For instance,
<pre>
In float 
=&gt; (0.1)<sub>10</sub> = (0.00011001100110011001100)<sub>2</sub>
In double after promotion of float ...(1)
=&gt; (0.1)<sub>10</sub> = (0.00011001100110011001100000000000000000...)<sub>2</sub>
  ^ padding zeroes here
In double without promotion ... 
(2)
=&gt; (0.1)<sub>10</sub> = (0.0001100110011001100110011001100110011001100110011001)<sub>2</sub>
Hence we can see the result of both equations are different.
Therefore 'if' statement can never be executed.
</pre>
Note that the promotion of float to double can only cause mismatch when a value (like 0.1) uses more precision bits than the bits of single precision. 
For example, the following C program prints &#8220;IF&#8221;.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x = 0.5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(x == 0.5) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"IF"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(x == 0.5f) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ELSE IF"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ELSE"</code><code class="plain">); </code>
<code class="plain">} </code>
Output: 
<pre>IF</pre>
Here binary equivalent of 0.5<sub>10</sub> is (0.100000&#8230;)<sub>2</sub><br />
 (No precision will be lost in both float and double type). 
Therefore if compiler pad the extra zeroes at the time of promotion then we would get the same result in decimal equivalent of both left and right side in comparison(x == 0.5).<br />
You can refer <a href="https://www.geeksforgeeks.org/floating-point-representation-basics/">Floating Point Representation – Basics</a> for representation of floating point numbers.
<h2>Is there any need of &#8220;long&#8221; data type in C and C++?</h2>
In <a href="https://www.geeksforgeeks.org/c/">C</a> and <a href="https://www.geeksforgeeks.org/c-plus-plus/">C++</a>, there are four different data type available for holding the integers i.e.,<strong> short, int, long</strong> and <strong>long long</strong>. 
Each of these data type requires different amounts of memory.<br />
But there is a catch, the size of <strong>&#8220;long&#8221;</strong> data type is not fixed unlike other data types. 
It varies from architectures, operating system and even with compiler that we are using. 
In some of the systems it behaves like an <strong>int</strong> data type or a <strong>long long</strong> data type as follows:
<pre>
  <strong>OS </strong>              <strong>Architecture</strong>          <strong>Size</strong>
Windows       IA-32                     4 bytes
Windows       Intel® 64 or IA-64        4 bytes
Linux         IA-32                     4 bytes
Linux         Intel® 64 or IA-64        8 bytes
Mac OS X      IA-32                     4 bytes
Mac OS X      Intel® 64 or IA-64        8 bytes 
</pre>
Well it also varies from compiler. 
But before this, let&#8217;s understand about the concept of <a href="https://en.wikipedia.org/wiki/Cross_compiler">cross compiler</a>. 
<em><br />
A cross compiler is a compiler capable of creating executable code for a platform other than the one on which the compiler is running.</em> For instance, if I compile the following programs in 64 bit architecture running a 64 bit Ubuntu, I will get the result like this:
<code class="comments">// C program to check the size of 'long' </code>
<code class="comments">//&nbsp; data type </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of int = %ld\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of long = %ld\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">long</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of long long = %ld"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">long</code> <code class="color1 bold">long</code><code class="plain">)); </code>
<code class="plain">} </code>
<pre>
<strong>Output in 32 bit gcc compiler:-</strong>
Size of int = 4
Size of long = 4
Size of long long = 8
<strong>Output in 64 bit gcc compiler:-</strong>
Size of int = 4
Size of long = 8
Size of long long = 8
</pre>
See <a href="https://www.geeksforgeeks.org/compile-32-bit-program-64-bit-gcc-c-c/">this</a> article to know more about how to compile a program with 32-bit or 64-bit gcc compiler.
From above we conclude that size of only &#8220;long&#8221; data type varies from compiler. 
Now the question is what exactly is happening here? Let&#8217;s discuss it in the way of how compiler allocates memory internally.
CPU calls data from RAM by giving the address of the location to MAR (Memory Address Register). 
The location is found and the data is transferred to MDR (Memory Data Register). 
This data is recorded in one of the Registers in the Processor for further processing. 
That’s why size of Data Bus determines the size of Registers in Processor. 
Now, a 32 bit register can call data of 4 bytes size only, at a time. 
And if the data size exceeds 32 bits, then it would required two cycles of fetching to have the data in it. 
This slows down the speed of 32 bit Machine compared to 64 bit, which would complete the operation in ONE fetch cycle only. 
So, obviously for the smaller data, it makes no difference if my processors are clocked at the same speed. 
Compilers are designed to generate the most efficient code for the target machine architecture.
So, in short the size of a variable is compiler dependent as it generates the instructions based on the target architecture and system architecture that only deals with the size of data bus and it’s transfer.<br />
<strong>Note</strong>: Interestingly we don&#8217;t have any need of &#8220;long&#8221; data type as their replacement(int, long long) is already available from <a href="https://en.wikipedia.org/wiki/C99">C99</a> standard.
<blockquote><strong>Suggestion</strong>: If it is important to you for integer types to have the same size on all Intel platforms, then consider replacing <strong>&#8220;long&#8221;</strong> by either <strong>&#8220;int&#8221;</strong> or <strong>&#8220;long long&#8221;</strong>. 
The size of the &#8220;int&#8221; integer type is 4 bytes and the size of the &#8220;long long&#8221; integer type is 8 bytes for all the above combinations of operating system, architecture and compiler.</blockquote>
<h2>What is the size_t data type in C?</h2>
<strong>size_t</strong> is an unsigned integral data type which is defined in various header files such as:
<code class="plain">&lt;stddef.h>, &lt;stdio.h>, &lt;stdlib.h>, &lt;string.h>, &lt;</code><code class="functions bold">time</code><code class="plain">.h>, &lt;wchar.h> </code>
It&#8217;s a type which is used to represent the size of objects in bytes and is therefore used as the return type by the <strong>sizeof</strong> <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stddef.h.html" rel="noopener">operator</a>. 
It is guaranteed to be big enough to contain the size of the biggest object the host system can handle. 
Basically the maximum permissible size is dependent on the compiler; if the compiler is 32 bit then it is simply a typedef(i.e., alias) for <strong>unsigned int</strong> but if the compiler is 64 bit then it would be a typedef for <strong>unsigned long long</strong>. 
The <strong>size_t</strong> data type is never negative.
Therefore many C library functions like <em>malloc, memcpy and strlen</em> declare their arguments and return type as <strong>size_t</strong>. 
For instance,
<code class="comments">// Declaration of various standard library functions. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Here argument of 'n' refers to maximum blocks that can be </code>
<code class="comments">// allocated which is guaranteed to be non-negative. 
</code>
<code class="keyword bold">void</code> <code class="plain">*</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">n); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// While copying 'n' bytes from 's2' to 's1' </code>
<code class="comments">// n must be non-negative integer. 
</code>
<code class="keyword bold">void</code> <code class="plain">*</code><code class="functions bold">memcpy</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*s1, </code><code class="keyword bold">void</code> <code class="keyword bold">const</code> <code class="plain">*s2, </code><code class="color1 bold">size_t</code> <code class="plain">n); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// strlen() uses size_t because the length of any string </code>
<code class="comments">// will always be at least 0. 
</code>
<code class="color1 bold">size_t</code> <code class="functions bold">strlen</code><code class="plain">(</code><code class="color1 bold">char</code> <code class="keyword bold">const</code> <code class="plain">*s); </code>
<strong>size_t</strong> or any unsigned type might be seen used as loop variable as loop variables are typically greater than or equal to 0.
<strong>Note:</strong> When we use a <strong>size_t</strong> object, we have to make sure that in all the contexts it is used, including arithmetic, we want only non-negative values. 
For instance, the following program would definitely give the unexpected result:
<code class="comments">// C program to demonstrate that size_t or </code>
<code class="comments">// any unsigned int type should be used&nbsp; </code>
<code class="comments">// carefully when used in a loop. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define N 10 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a[N]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This is fine. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">n = 0; n &lt; N; ++n) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[n] = n; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// But reverse cycles are tricky for unsigned&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// types as they can lead to infinite loops. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">n = N-1; n >= 0; --n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, a[n]); </code>
<code class="plain">} </code>
<pre>
<strong>Output</strong>
Infinite loop and then segmentation fauilt</pre>
<h2>Interesting facts about data-types and modifiers in C/C++</h2>
Here are some logical and interesting facts about data-types and the modifiers associated with data-types:-
<strong>1. 
</strong>If no data type is given to a variable, the compiler automatically converts it to int data type.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">signed</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">signed</code> <code class="plain">b; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// size of a and b is equal to the size of int </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The size of a is %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(a));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The size of b is %d"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(b));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The size of a is 4
The size of b is 4
</pre>
<strong>2. 
</strong>Signed is the default modifier for char and int data types.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">y; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = -1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">y = -2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x is %d and y is %d"</code><code class="plain">, x, y); </code>
<code class="plain">} </code>
Output:
<pre>
x is -1 and y is -2.
</pre>
<strong>3.</strong> We can&#8217;t use any modifiers in float data type. 
If programmer tries to use it ,the compiler automatically gives compile time error.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">signed</code> <code class="color1 bold">float</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">short</code> <code class="color1 bold">float</code> <code class="plain">b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
[Error] both 'signed' and 'float' in declaration specifiers
[Error] both 'short' and 'float' in declaration specifiers
</pre>
<strong>4.</strong> Only long modifier is allowed in double data types. 
We cant use any other specifier with double data type. 
If we try any other specifier, compiler will give compile time error.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">double</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">short</code> <code class="color1 bold">double</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">signed</code> <code class="color1 bold">double</code> <code class="plain">b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
[Error] both 'short' and 'double' in declaration specifiers
[Error] both 'signed' and 'double' in declaration specifiers
</pre>
<h2>Difference between float and double in C/C++</h2>
For representing floating point numbers, we use <strong>float</strong>, <strong>double</strong> and <strong>long double</strong>.
<strong>What&#8217;s the difference ?</strong>
<strong>double</strong> has 2x more precision then <strong>float</strong>.
<strong>float</strong> is a 32 bit IEEE 754 single precision Floating Point Number1 bit for the sign, (8 bits for the exponent, and 23* for the value), i.e. 
float has 7 decimal digits of precision.
<strong>double</strong> is a 64 bit IEEE 754 double precision Floating Point Number (1 bit for the sign, 11 bits for the exponent, and 52* bits for the value), i.e. 
double has 15 decimal digits of precision.
Let&#8217;s take a example(example taken from <a href="https://stackoverflow.com/a/2388838/6942060">here</a>) :<br />
For a quadratic equation <strong>x2 &#8211; 4.0000000 x + 3.9999999 = 0</strong>, the exact roots to 10 significant digits are, r1 = 2.000316228 and r2 = 1.999683772
<code class="comments">// C program to demonstrate&nbsp; </code>
<code class="comments">// double and float precision values </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// utility function which calculate roots of&nbsp; </code>
<code class="comments">// quadratic equation using double values </code>
<code class="keyword bold">void</code> <code class="plain">double_solve(</code><code class="color1 bold">double</code> <code class="plain">a, </code><code class="color1 bold">double</code> <code class="plain">b, </code><code class="color1 bold">double</code> <code class="plain">c){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">d = b*b - 4.0*a*c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">sd = </code><code class="functions bold">sqrt</code><code class="plain">(d); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">r1 = (-b + sd) / (2.0*a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">r2 = (-b - sd) / (2.0*a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%.5f\t%.5f\n"</code><code class="plain">, r1, r2); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// utility function which calculate roots of&nbsp; </code>
<code class="comments">// quadratic equation using float values </code>
<code class="keyword bold">void</code> <code class="plain">float_solve(</code><code class="color1 bold">float</code> <code class="plain">a, </code><code class="color1 bold">float</code> <code class="plain">b, </code><code class="color1 bold">float</code> <code class="plain">c){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">d = b*b - 4.0f*a*c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">sd = sqrtf(d); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">r1 = (-b + sd) / (2.0f*a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">r2 = (-b - sd) / (2.0f*a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%.5f\t%.5f\n"</code><code class="plain">, r1, r2); </code>
<code class="plain">}&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// driver program </code>
<code class="color1 bold">int</code> <code class="plain">main(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fa = 1.0f; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fb = -4.0000000f; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fc = 3.9999999f; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">da = 1.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">db = -4.0000000; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">dc = 3.9999999; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"roots of equation x2 - 4.0000000 x + 3.9999999 = 0 are : \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"for float values: \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">float_solve(fa, fb, fc); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"for double values: \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">double_solve(da, db, dc); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp; </code>
Output:
<pre>
roots of equation x2 - 4.0000000 x + 3.9999999 = 0 are : 
for float values: 
2.00000    2.00000
for double values: 
2.00032    1.99968
</pre>
<h2>Character arithmetic in C and C++</h2>
As already known character known character range is between -128 to 127 or 0 to 255. 
This point has to be kept in mind while doing character arithmetic. 
To understand better let&#8217;s take an example.
<code class="comments">// C program to demonstrate character arithmetic. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch1 = 125, ch2 = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ch1 = ch1 + ch2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, ch1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c\n"</code><code class="plain">, ch1 - ch2 - 4); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
-121
y 
</pre>
So %d specifier causes an integer value to be printed and %c specifier causes a character value to printed. 
But care has to taken that while using %c specifier the integer value should not exceed 127.<br />
So far so good.
But for c++ it plays out a little different.
Look at this example to understand better.
<code class="comments">// A C++ program to demonstrate character </code>
<code class="comments">// arithmetic in C++. 
</code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch = 65; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ch &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ch + 0 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="color1 bold">char</code><code class="plain">(ch + 32) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
A
65
a 
</pre>
Without a &#8216;+&#8217; operator character value is printed. 
But when used along with &#8216;+&#8217; operator behaved differently. 
Use of &#8216;+&#8217; operator implicitly typecasts it to an &#8216;int&#8217;. 
So to conclude, in character arithmetic, typecasting of char variable to &#8216;char&#8217; is explicit and to &#8216;int&#8217; it is implicit. 
<h2>Type Conversion in C</h2>
A type cast is basically a conversion from one type to another. 
There are two types of type conversion:
<ol>
<li><strong>Implicit Type Conversion</strong>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Implicit-Type-Conversion-in-c.png" alt="">
Also known as ‘automatic type conversion’.
<ul>
<li> Done by the compiler on its own, without any external trigger from the user.</li>
<li>Generally takes place when in an expression more than one data type is present. 
In such condition type conversion (type promotion) takes place to avoid lose of data.</li>
<li>All the data types of the variables are upgraded to the data type of the variable with largest data type.
<pre><strong>    
       bool -&gt; char -&gt; short int -&gt; int -&gt; 
       unsigned int -&gt; long -&gt; unsigned -&gt; 
       long long -&gt; float -&gt; double -&gt; long double
</strong></pre>
</li>
<li> It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to unsigned), and overflow can occur (when long long is implicitly converted to float).</li>
</ul>
<strong>Example of Type Implicit Conversion:</strong>
<code class="comments">// An example of implicit conversion </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10;&nbsp;&nbsp;&nbsp; </code><code class="comments">// integer x </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">y = </code><code class="string">'a'</code><code class="plain">;&nbsp; </code><code class="comments">// character c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// y implicitly converted to int. 
ASCII&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// value of 'a' is 97 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = x + y; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// x is implicitly converted to float </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">z = x + 1.0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, z = %f"</code><code class="plain">, x, z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>x = 107, z = 108.000000</pre></li></ol>
<ol start="2">
<li><strong>Explicit Type Conversion</strong>&#8211;
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Explicit-Type-Conversion.png" alt="">
 This process is also called type casting and it is user defined. 
Here the user can type cast the result to make it of a particular data type.
The syntax in C:
<pre>(type) expression</pre>
Type indicated the data type to which the final result is converted.
<code class="comments">// C program to demonstrate explicit type casting </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 1.2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Explicit conversion from double to int </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sum = (</code><code class="color1 bold">int</code><code class="plain">)x + 1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sum = %d"</code><code class="plain">, sum); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>sum = 2</pre>
Advantages of Type Conversion
<ul>
<li>This is done to take advantage of certain features of type hierarchies or type representations.</li>
<li>It helps us to compute expressions containing variables of different data types.</li>
</ul></li></ol>
<strong>Related articles:</strong>
<ul>
<li><a href="https://www.geeksforgeeks.org/catch-block-and-type-conversion-in-c/"> Catch Block and Type Casting in C</a></li>
<li><a href="https://www.geeksforgeeks.org/integer-promotions-in-c/">Integer Promotion</a></li>
</ul>
<h2>Storage Classes in C</h2>
Storage Classes are used to describe the features of a variable/function. 
These features basically include the scope, visibility and life-time which help us to trace the existence of a particular variable during the runtime of a program.<!--more-->
<strong>C language uses 4 storage classes</strong>, namely:
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Storage-Classes-In-C.png" alt="">
<ol>
<li><strong>auto</strong>: This is the default storage class for all the variables declared inside a function or a block. 
Hence, the keyword auto is rarely used while writing programs in C language. 
Auto variables can be only accessed within the block/function they have been declared and not outside them (which defines their scope). 
Of course, these can be accessed within nested blocks within the parent block/function in which the auto variable was declared. 
However, they can be accessed outside their scope as well using the concept of pointers given here by pointing to the very exact memory location where the variables resides. 
They are assigned a garbage value by default whenever they are declared.
</li>
</br>
<li><strong><a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">extern</a></strong>: Extern storage class simply tells us that the variable is defined elsewhere and not within the same block where it is used. 
Basically, the value is assigned to it in a different block and this can be overwritten/changed in a different block as well. 
So an extern variable is nothing but a global variable initialized with a legal value where it is declared in order to be used elsewhere. 
It can be accessed within any function/block. 
Also, a normal global variable can be made extern as well by placing the &#8216;extern&#8217; keyword before its declaration/definition in any function/block. 
This basically signifies that we are not initializing a new variable but instead we are using/accessing the global variable only. 
The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program. 
For more information on how extern variables work, have a look at this <a href="https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/">link</a>.
</li>

<li><strong><a href="http://quiz.geeksforgeeks.org/static-variables-in-c/">static</a></strong>: This storage class is used to declare static variables which are popularly used while writing programs in C language. 
Static variables have a property of preserving their value even after they are out of their scope! Hence, static variables preserve the value of their last use in their scope. 
So we can say that they are initialized only once and exist till the termination of the program. 
Thus, no new memory is allocated because they are not re-declared. 
Their scope is local to the function to which they were defined. 
Global static variables can be accessed anywhere in the program. 
By default, they are assigned the value 0 by the compiler.
</li>
</br>
<li><strong><a href="https://www.geeksforgeeks.org/understanding-register-keyword/">register</a></strong>: This storage class declares register variables which have the same functionality as that of the auto variables. 
The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free register is available. 
This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. 
If a free register is not available, these are then stored in the memory only. 
Usually few variables which are to be accessed very frequently in a program are declared with the register keyword which improves the running time of the program. 
An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers.</li></ol>
To specify the storage class for a variable, the following syntax is to be followed:
Syntax: 
<pre>
storage_class var_data_type var_name; </pre>
</br>
Functions follow the same syntax as given above for variables. 
Have a look at the following C example for further clarification: 
<code class="comments">// A C program to demonstrate different storage </code>
<code class="comments">// classes </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// declaring the variable which is to be made extern </code>
<code class="comments">// an intial value can also be initialized to x </code>
<code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">autoStorageClass() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nDemonstrating auto class\n\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring an auto variable (simply </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// writing "int a=32;" works as well) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">auto</code> <code class="color1 bold">int</code> <code class="plain">a = 32; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the auto variable 'a' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of the variable 'a'"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" declared as auto: %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"--------------------------------"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">registerStorageClass() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nDemonstrating register class\n\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring a register variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">register</code> <code class="color1 bold">char</code> <code class="plain">b = </code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the register variable 'b' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of the variable 'b'"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" declared as register: %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"--------------------------------"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">externStorageClass() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nDemonstrating extern class\n\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// telling the compiler that the variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// z is an extern variable and has been </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// defined elsewhere (above the main </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// function) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the extern variables 'x' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of the variable 'x'"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" declared as extern: %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// value of extern variable x modified </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the modified values of </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// extern variables 'x' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Modified value of the variable 'x'"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" declared as extern: %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"--------------------------------"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">staticStorageClass() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nDemonstrating static class\n\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using a static variable 'y' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Declaring 'y' as static inside the loop.\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"But this declaration will occur only"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" once as 'y' is static.\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"If not, then every time the value of 'y' "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"will be the declared value 5"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" as in the case of variable 'p'\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nLoop started:\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 1; i &lt; 5; i++) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declaring the static variable 'y' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">y = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare a non-static variable 'p' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Incrementing the value of y and p by 1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">y++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">p++; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing value of y at each iteration </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nThe value of 'y', "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"declared as static, in %d "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"iteration is %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i, y); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing value of p at each iteration </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The value of non-static variable 'p', "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"in %d iteration is %d\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i, p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nLoop ended:\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"--------------------------------"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"A program to demonstrate"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" Storage Classes in C\n\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To demonstrate auto Storage Class </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">autoStorageClass(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To demonstrate register Storage Class </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">registerStorageClass(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To demonstrate extern Storage Class </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">externStorageClass(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To demonstrate static Storage Class </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">staticStorageClass(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// exiting </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n\nStorage Classes demonstrated"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is improved by RishabhPrabhu </code>
<b>Output:</b>
<blockquote>
A program to demonstrate Storage Classes in C
Demonstrating auto class
Value of the variable &#8216;a&#8217; declared as auto: 32<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
Demonstrating register class
Value of the variable &#8216;b&#8217; declared as register: 71<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
Demonstrating extern class
Value of the variable &#8216;x&#8217; declared as extern: 0<br />
Modified value of the variable &#8216;x&#8217; declared as extern: 2<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;<br />
Demonstrating static class
Declaring &#8216;y&#8217; as static inside the loop.<br />
But this declaration will occur only once as &#8216;y&#8217; is static.<br />
If not, then every time the value of &#8216;y&#8217; will be the declared value 5 as in the case of variable &#8216;p&#8217;
Loop started:
The value of &#8216;y&#8217;, declared as static, in 1 iteration is 6<br />
The value of non-static variable &#8216;p&#8217;, in 1 iteration is 11
The value of &#8216;y&#8217;, declared as static, in 2 iteration is 7<br />
The value of non-static variable &#8216;p&#8217;, in 2 iteration is 11
The value of &#8216;y&#8217;, declared as static, in 3 iteration is 8<br />
The value of non-static variable &#8216;p&#8217;, in 3 iteration is 11
The value of &#8216;y&#8217;, declared as static, in 4 iteration is 9<br />
The value of non-static variable &#8216;p&#8217;, in 4 iteration is 11
Loop ended:<br />
&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;
Storage Classes demonstrated
</blockquote>
<h2>Static Variables in C</h2>
Static variables have a property of preserving their value even after they are out of their scope!<!--more-->Hence, static variables preserve their previous value in their previous scope and are not initialized again in the new scope.<br />
Syntax: 
<pre>
static data_type var_name = var_value; </pre>
</br><br />
Following are some interesting facts about static variables in C.
<strong>1)</strong> A static int variable remains in memory while the program is running. 
A normal or auto variable is destroyed when a function call where the variable was declared is over. 

For example, we can use static int to count a number of times a function is called, but an auto variable can&#8217;t be used for this purpose.
For example below program prints &#8220;1 2&#8221;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">count++; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">count; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>1 2</pre>
But below program prints 1 1
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">count++; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">count; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>1 1</pre>
</br><br />
<strong>2)</strong> Static variables are allocated memory in data segment, not stack segment. 
See <a href="https://www.geeksforgeeks.org/memory-layout-of-c-program/">memory layout of C programs</a> for details.
</br><br />
<strong>3) </strong>Static variables (like global variables) are initialized as 0 if not initialized explicitly. 
For example in the below program, value of x is printed as 0, while value of y is something garbage. 
See <a href="https://www.geeksforgeeks.org/g-fact-53/">this </a>for more details.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d \n %d"</code><code class="plain">, x, y); </code>
<code class="plain">}</code>
Output: 
<pre>0 
[some_garbage_value] </pre>
</br><br />
<strong>4)</strong> In C, static variables can only be initialized using constant literals. 
For example, following program fails in compilation. 
See <a href="https://www.geeksforgeeks.org/g-fact-80/">this </a>for more details.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">initializer(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">50; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = initializer(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" value of i = %d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
          
<pre> In function 'main':
9:5: error: initializer element is not constant
     static int i = initializer();
     ^</pre>
Please note that this condition doesn&#8217;t hold in C++. 
So if you save the program as a C++ program, it would compile \and run fine.
&nbsp;
<strong>5)</strong> Static global variables and functions are also possible in C/C++. 
The purpose of these is to limit scope of a variable or function to a file. 
Please refer <a href="https://www.geeksforgeeks.org/what-are-static-functions-in-c/">Static functions in C</a> for more details.
<strong>6)</strong> Static variables should not be declared inside structure. 
The reason is C compiler requires the entire structure elements to be placed together (i.e.) memory allocation for structure members should be contiguous. 
It is possible to declare structure inside the function (stack segment) or allocate memory dynamically(heap segment) or it can be even global (BSS or data segment). 
Whatever might be the case, all structure members should reside in the same memory segment because the value for the structure element is fetched by counting the offset of the element from the beginning address of the structure. 
Separating out one member alone to data segment defeats the purpose of static variable and it is possible to have an entire structure as static.
</br><br />
<strong>Related Articles:</strong>
<ul>
<li><a href="https://www.geeksforgeeks.org/static-keyword-cpp/">Static Keyword in C++ </a></li>
<li><a href="https://www.geeksforgeeks.org/c-plus-plus-gq/static-keyword-gq/">Quiz on Static Keyword</a></li>
<li><a href="https://www.geeksforgeeks.org/stati/">Static data members in C++</a></li>
<li><a href="https://www.geeksforgeeks.org/static-objects-destroyed/">When are static objects destroyed?</a></li>
<li><a href="https://www.geeksforgeeks.org/some-interesting-facts-about-static-member-functions-in-c/">Interesting facts about static member functions</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-29/">Can static functions be virtual?</a></li>
<li><a href="https://www.geeksforgeeks.org/static-keyword-in-java/">Comparison of static keyword in C++ and Java</a></li>
<li><a href="https://www.geeksforgeeks.org/what-are-static-functions-in-c/">Static functions in C</a></li>
</ul>
<h2>Understanding &#8220;extern&#8221; keyword in C</h2>
I&#8217;m sure this post will be as interesting and informative to C virgins (i.e. 
beginners) as it will be to those who are well-versed in C. 
So let me start by saying that the <code>extern</code> keyword applies to C variables (data objects) and C functions. 
<!--more-->Basically, the <code>extern</code> keyword extends the visibility of the C variables and C functions. 
That&#8217;s probably the reason why it was named <code>extern</code>.
Though most people probably understand the difference between the &#8220;declaration&#8221; and the &#8220;definition&#8221; of a variable or function, for the sake of completeness, I would like to clarify them.
<ul>
<li><b>Declaration</b> of a variable or function simply declares that the variable or function exists somewhere in the program, but the memory is not allocated for them. 
The declaration of a variable or function serves an important role&#8211;it tells the program what its type is going to be. 
In case of <em>function</em> declarations, it also tells the program the arguments, their data types, the order of those arguments, and the return type of the function. 
So that&#8217;s all about the declaration.</li>
<li>Coming to the <b>definition</b>, when we <em>define</em> a variable or function, in addition to everything that a declaration does, it also allocates memory for that variable or function. 
Therefore, we can think of definition as a superset of the declaration (or declaration as a subset of definition).</li>
</ul>
A variable or function can be <em>declared</em> any number of times, but it can be <em>defined</em> only once. 
(Remember the basic principle that you can&#8217;t have two locations of the same variable or function).
Now back to the <code>extern</code> keyword. 
First, Let&#8217;s consider the use of <code>extern</code> in functions. 
It turns out that when a function is declared or defined, the <code>extern</code> keyword is implicitly assumed. 
When we write.
<pre>
    int foo(int arg1, char arg2);
</pre>
The compiler treats it as:
<pre>
    extern int foo(int arg1, char arg2);
</pre>
Since the <code>extern</code> keyword extends the the function&#8217;s visibility to the whole program, the function can be used (called) anywhere in any of the files of the whole program, provided those files contain a declaration of the function. 
(With the declaration of the function in place, the compiler knows the definition of the function exists somewhere else and it goes ahead and compiles the file). 
So that&#8217;s all about <code>extern</code> and functions.
Now let&#8217;s consider the use of <code>extern</code> with variables. 
To begin with, how would you <em>declare</em> a variable without <em>defining</em> it? You would do something like this:
<pre>
    extern int var;
</pre>
Here, an integer type variable called <code>var</code> has been declared (it hasn&#8217;t been defined yet, so no memory allocation for <code>var</code> so far). 
And we can do this declaration as many times as we want. 
So far so good. 
🙂
Now, how would you <em>define</em> <code>var</code>? You would do this:
<pre>
    int var;
</pre>
In this line, an integer type variable called <code>var</code> has been both declared <b>and</b> defined (remember that <em>definition</em> is the superset of <em>declaration</em>). 
Since this is a <em>definition</em>, the memory for <code>var</code> is also allocated. 
Now here comes the surprise. 
When we declared/defined a function, we saw that the <code>extern</code> keyword was present implicitly. 
But this isn&#8217;t the case with variables. 
If it were, memory would never be allocated for them. 
Therefore, we need to include the <code>extern</code> keyword explicitly when we want to declare variables without defining them. 
Also, as the <code>extern</code> keyword extends the visibility to the whole program, by using the <code>extern</code> keyword with a variable, we can use the variable anywhere in the program provided we include its declaration the variable is defined somewhere.
Now let us try to understand <code>extern</code> with examples.
Example 1:
<code class="color1 bold">int</code> <code class="plain">var; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">var = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
This program compiles successfully. 
<code>var</code> is defined (and declared implicitly) globally.
          
Example 2:
<code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">var; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
This program compiles successfully. 
Here <code>var</code> is declared only. 
Notice var is never used so no problems arise.
Example 3:
<code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">var; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">var = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
This program throws an error in compilation because <code>var</code> is declared but not defined anywhere. 
Essentially, the var isn&#8217;t allocated any memory. 
And the program is trying to change the value to 10 of a variable that doesn&#8217;t exist at all.
Example 4:
<code class="preprocessor">#include "somefile.h" </code>
<code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">var; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">var = 10; </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Assuming that somefile.h contains the definition of <code>var</code>, this program will compile successfully.
Example 5:
<code class="keyword bold">extern</code> <code class="color1 bold">int</code> <code class="plain">var = 0; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">var = 10; </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Do you think this program will work? Well, here comes another surprise from C standards. 
They say that..if a variable is only declared and an initializer is also provided with that declaration, then the memory for that variable will be allocated&#8211;in other words, that variable will be considered as defined. 
Therefore, as per the C standard, this program will compile successfully and work.
So that was a preliminary look at the <code>extern</code> keyword in C.
In short, we can say:
<ol>
<li> A declaration can be done any number of times but definition only once.</li>
<li> the <code>extern</code> keyword is used to extend the visibility of variables/functions.</li>
<li> Since functions are visible throughout the program by default, the use of <code>extern</code> is not needed in function declarations or definitions. 
Its use is implicit.</li>
<li> When <code>extern</code> is used with a variable, it&#8217;s only declared, not defined.</li>
<li> As an exception, when an <code>extern</code> variable is declared with initialization, it is taken as the definition of the variable as well.</li>
</ol>
<h2>What are the default values of static variables in C?</h2>
In C, if an object that has static storage duration is not initialized explicitly, then:<!--more--><br />
— if it has pointer type, it is initialized to a  NULL pointer;<br />
— if it has arithmetic type, it is initialized to (positive or unsigned) zero;<br />
— if it is an aggregate, every member is initialized (recursively) according to these rules;<br />
— if it is a union, the first named member is initialized (recursively) according to these rules. 
For example, following program prints:<br />
<em>Value of g = 0<br />
Value of sg = 0<br />
Value of s = 0<br />
</em>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">g;&nbsp; </code><code class="comments">//g = 0, global objects have static storage duration </code>
<code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">gs; </code><code class="comments">//gs = 0, global static objects have static storage duration </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">s; </code><code class="comments">//s = 0, static objects have static storage duration </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of g = %d"</code><code class="plain">, g); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nValue of gs = %d"</code><code class="plain">, gs); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nValue of s = %d"</code><code class="plain">, s); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
<h2>Understanding &#8220;volatile&#8221; qualifier in C | Set 2 (Examples)</h2>
The volatile keyword is intended to prevent the compiler from applying any optimizations on objects that can change in ways that cannot be determined by the compiler.<!--more--> 
Objects declared as volatile are omitted from optimization because their values can be changed by code outside the scope of current code at any time. 
The system always reads the current value of a volatile object from the memory location rather than keeping its value in temporary register at the point it is requested, even if a previous instruction asked for a value from the same object. 
So the simple question is, how can value of a variable change in such a way that compiler cannot predict. 
Consider the following cases for answer to this question.<br />
<em><br />
1) Global variables modified by an interrupt service routine outside the scope: </em> For example, a global variable can represent a data port (usually global pointer referred as memory mapped IO) which will be updated dynamically. 
The code reading data port must be declared as volatile in order to fetch latest data available at the port. 
Failing to declare variable as volatile, the compiler will optimize the code in such a way that it will read the port only once and keeps using the same value in a temporary register to speed up the program (speed optimization). 
In general, an ISR used to update these data port when there is an interrupt due to availability of new data

<em>2) Global variables within a multi-threaded application:</em> There are multiple ways for threads communication, viz, message passing, shared memory, mail boxes, etc. 
A global variable is weak form of shared memory. 
When two threads sharing information via global variable, they need to be qualified with volatile. 
Since threads run asynchronously, any update of global variable due to one thread should be fetched freshly by another consumer thread. 
Compiler can read the global variable and can place them in temporary variable of current thread context. 
To nullify the effect of compiler optimizations, such global variables to be qualified as volatile
If we do not use volatile qualifier, the following problems may arise<br />
1) Code may not work as expected when optimization is turned on.<br />
2) Code may not work as expected when interrupts are enabled and used.
Let us see an example to understand how compilers interpret volatile keyword. 
Consider below code, we are changing value of const object using pointer and we are compiling code without optimization option. 
Hence compiler won&#8217;t do any optimization and will change value of const object.
<code class="comments">/* Compile code without optimization option */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">local = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code><code class="plain">*) &local; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Initial value of local : %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Modified value of local: %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
When we compile code with “–save-temps” option of gcc it generates 3 output files
1) preprocessed code (having .i extention)<br />
2) assembly code (having .s extention) and<br />
3) object code (having .o option). 
We compile code without optimization, that’s why the size of assembly code will be larger (which is highlighted in red color below).
Output:
<pre>
  [narendra@ubuntu]$ gcc volatile.c -o volatile –save-temps
  [narendra@ubuntu]$ ./volatile
  Initial value of local : 10
  Modified value of local: 100
  [narendra@ubuntu]$ ls -l volatile.s
  -rw-r–r– 1 narendra narendra <font color="red">731</font> 2016-11-19 16:19 volatile.s
  [narendra@ubuntu]$
</pre>
Let us compile same code with optimization option (i.e. 
-O option). 
In thr below code, &#8220;local&#8221; is declared as const (and non-volatile), GCC compiler does optimization and ignores the instructions which try to change value of const object. 
Hence value of const object remains same.
<code class="comments">/* Compile code with optimization option */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">local = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code><code class="plain">*) &local; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Initial value of local : %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Modified value of local: %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
For above code, compiler does optimization, that’s why the size of assembly code will reduce.
Output:
<pre>
  [narendra@ubuntu]$ gcc -O3 volatile.c -o volatile –save-temps
  [narendra@ubuntu]$ ./volatile
  Initial value of local : 10
  Modified value of local: 10
  [narendra@ubuntu]$ ls -l volatile.s
  -rw-r–r– 1 narendra narendra <font color="red">626</font> 2016-11-19 16:21 volatile.s
</pre>
Let us declare const object as volatile and compile code with optimization option. 
Although we compile code with optimization option, value of const object will change, because variable is declared as volatile that means don’t do any optimization.
<code class="comments">/* Compile code with optimization option */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="keyword bold">volatile</code> <code class="color1 bold">int</code> <code class="plain">local = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code><code class="plain">*) &local; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Initial value of local : %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Modified value of local: %d \n"</code><code class="plain">, local); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
  [narendra@ubuntu]$ gcc -O3 volatile.c -o volatile –save-temp
  [narendra@ubuntu]$ ./volatile
  Initial value of local : 10
  Modified value of local: 100
  [narendra@ubuntu]$ ls -l volatile.s
  -rw-r–r– 1 narendra narendra <font color="red">711</font> 2016-11-19 16:22 volatile.s
  [narendra@ubuntu]$
</pre>
The above example may not be a good practical example, the purpose was to explain how compilers interpret volatile keyword. 
As a practical example, think of touch sensor on mobile phones. 
The driver abstracting touch sensor will read the location of touch and send it to higher level applications. 
The driver itself should not modify (const-ness) the read location, and make sure it reads the touch input every time fresh (volatile-ness). 
Such driver must read the touch sensor input in const volatile manner.
<strong>Note : </strong> The above codes are compiler specific and may not work on all compilers. 
The purpose of the examples is to make readers understand the concept.
<strong>Related Article : </strong><br />
<a href="https://www.geeksforgeeks.org/understanding-volatile-qualifier-c-set-1-introduction/">Understanding “volatile” qualifier in C | Set 1 (Introduction)</a>
Refer following links for more details on volatile keyword:<br />
<a href="http://drdobbs.com/cpp/184403766">Volatile: A programmer&#8217;s best friend</a><br />
<a href="https://www.securecoding.cert.org/confluence/display/cplusplus/CON01-CPP.+Do+not+use+volatile+as+a+synchronization+primitive">Do not use volatile as a synchronization primitive</a>
<h2>Const Qualifier in C</h2>
The qualifier const can be applied to the declaration of any variable to specify that its value will not be changed ( Which depends upon where const variables are stored, we may change the value of const variable by using pointer ).<!--more--> The result is implementation-defined if an attempt is made to change a const.<br />
<strong>1) Pointer to variable.</strong>
<code class="color1 bold">int</code> <code class="plain">*ptr; </code>
We can change the value of ptr and we can also change the value of object ptr pointing to. 
Pointer and value pointed by pointer both are stored in the read-write area. 
See the following code fragment.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = &i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* pointer to integer */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* pointer is pointing to another variable */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* we can change value stored by pointer */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
    *ptr: 10
    *ptr: 20
    *ptr: 100
</pre>
</br><br />
<strong><br />
2) Pointer to constant.</strong><br />
Pointer to constant can be declared in following two ways.
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*ptr; </code>
or 
<code class="color1 bold">int</code> <code class="keyword bold">const</code> <code class="plain">*ptr; </code>
We can change the pointer to point to any other integer variable, but cannot change the value of the object (entity) pointed using pointer ptr. 
The pointer is stored in the read-write area (stack in the present case). 
The object pointed may be in the read-only or read-write area. 
Let us see the following examples.
<code class="preprocessor">#include &lt;stdio.h>&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* ptr is pointer to constant */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*ptr = &i;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* error: object pointed cannot be modified </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">using the pointer ptr */</code>&nbsp;&nbsp;&nbsp;&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">/* valid */</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
 error: assignment of read-only location ‘*ptr’
</pre>
Following is another example where variable i itself is constant.
<code class="preprocessor">#include &lt;stdio.h>&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* i is stored in read only area*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="keyword bold">const</code> <code class="plain">i = 10;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* pointer to integer constant. 
Here i&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">is of type "const int", and &i is of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">type "const int *".&nbsp; And p is of type&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">"const int", types are matching no issue */</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="keyword bold">const</code> <code class="plain">*ptr = &i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* error */</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* valid. 
We call it up qualification. 
In&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">C/C++, the type of "int *" is allowed to up&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">qualify to the type "const int *". 
The type of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">&j is "int *" and is implicitly up qualified by&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">the compiler to "const int *" */</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
 error: assignment of read-only location ‘*ptr’
</pre>
Down qualification is not allowed in C++ and may cause warnings in C. 
Following is another example with down qualification.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="keyword bold">const</code> <code class="plain">j = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* ptr is pointing an integer object */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = &i;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr: %d\n"</code><code class="plain">, *ptr);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* The below assignment is invalid in C++, results in error&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">In C, the compiler *may* throw a warning, but casting is&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">implicitly allowed */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* In C++, it is called 'down qualification'. 
The type of expression&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">&j is "const int *" and the type of ptr is "int *". 
The&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">assignment "ptr = &j" causes to implicitly remove const-ness&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">from the expression &j. 
C++ being more type restrictive, will not&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">allow implicit down qualification. 
However, C++ allows implicit&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">up qualification. 
The reason being, const qualified identifiers&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">are bound to be placed in read-only memory (but not always). 
If&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">C++ allows above kind of assignment (ptr = &j), we can use 'ptr'&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">to modify value of j which is in read-only memory. 
The&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">consequences are implementation dependent, the program may fail&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">at runtime. 
So strict type checking helps clean code.*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Reference: </code>
<code class="comments">// <a href="http://www.dansaks.com/articles/1999-02%20const%20T%20vs%20T%20const.pdf">http://www.dansaks.com/articles/1999-02%20const%20T%20vs%20T%20const.pdf</a> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// More interesting stuff on C/C++ @ <a href="http://www.dansaks.com/articles.shtml">http://www.dansaks.com/articles.shtml</a> </code>
</br><br />
<strong>3) Constant pointer to variable.</strong>
<code class="color1 bold">int</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr; </code>
Above declaration is a constant pointer to an integer variable, means we can change the value of object pointed by pointer, but cannot change the pointer to point another variable. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 20; </code>
<code class="comments">/* constant pointer to integer */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr = &i;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100;&nbsp;&nbsp;&nbsp; </code><code class="comments">/* valid */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">/* error */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
 error: assignment of read-only variable ‘ptr’
</pre>
</br><br />
<strong>4) constant pointer to constant</strong>
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr; </code>
Above declaration is a constant pointer to a constant variable which means we cannot change value pointed by the pointer as well as we cannot point the pointer to other variables. 
Let us see with an example. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 20; </code>
<code class="comments">/* constant pointer to constant integer */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr = &i;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr: %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &j;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">/* error */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 100;&nbsp;&nbsp; </code><code class="comments">/* error */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
     error: assignment of read-only variable ‘ptr’
     error: assignment of read-only location ‘*ptr’
</pre>
<h2>Initialization of static variables in C</h2>
In C, static variables can only be initialized using constant literals. 
For example, following program fails in compilation.<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">initializer(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">50; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = initializer(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" value of i = %d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
If we change the program to following, then it works without any error.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = 50; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" value of i = %d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The reason for this is simple: All objects with static storage duration must be initialized (set to their initial values) before execution of main() starts. 
So a value which is not known at translation time cannot be used for initialization of static variables.
Thanks to Venki and Prateek for their contribution.
<h2>Understanding &#8220;register&#8221; keyword in C</h2>
Registers are faster than memory to access, so the variables which are most frequently used in a C program can be put in registers using <em>register </em>keyword. 
<!--more--> The keyword <em>register</em> hints to compiler that a given variable can be put in a register. 
It&#8217;s compiler&#8217;s choice to put it in a register or not. 
Generally, compilers themselves do optimizations and put the variables in register. 
1) If you use &amp; operator with a register variable then compiler may give an error or warning (depending upon the compiler you are using), because when we say a variable is a register, it may be stored in a register instead of memory and accessing address of a register is invalid. 
Try below program.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">register</code> <code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code><code class="plain">* a = &i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
2) <em>register</em> keyword can be used with pointer variables. 
Obviously, a register can have address of a memory location. 
There would not be any problem with the below program.<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">register</code> <code class="color1 bold">int</code><code class="plain">* a = &i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
3) Register is a storage class, and C doesn&#8217;t allow multiple storage class specifiers for a variable. 
So, <em>register </em> can not be used with <em>static </em>. 
Try below program.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">register</code> <code class="keyword bold">static</code> <code class="color1 bold">int</code><code class="plain">* a = &i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
4) Register can only be used within a block (local), it can not be used in the <em>global</em> scope (outside main).
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// error (global scope) </code>
<code class="keyword bold">register</code> <code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// works (inside a block) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">register</code> <code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Compile Errors:</strong>
<pre>
prog.c:3:14: error: register name not specified for 'x'
 register int x = 10;//error (global scope)
              ^
</pre>
5) There is no limit on number of register variables in a C program, but the point is compiler may put some variables in register and some not.
<h1 style="display:inline">C Storage Classes and Type Qualifiers</h2>
		</header>
<div id="mtq_quiz_area-1" class="mtq_quiz_area mtq_color_green"> 
  <!--Quiz generated using mTouch Quiz Version 3.1.3 by G. 
Michael Guy (http://gmichaelguy.com/quizplugin/)-->
        
    
   <!-- Here code starts for pagination -->
  
  <!-- <a class="page" data-pageid="0">First</a> -->
          <a class="page current" data-pageid="0">1</a><a class="page" data-pageid="1">2</a><a class="page" data-pageid="2">3</a><a class="page" data-pageid="3">4</a>        <!-- <a class="page" data-pageid="<?php# echo $total_pagination_btn-1; ?>">Last</a> -->
  
  <!-- Here code ends for pagination -->
  <!-- Shortcode entered mtouchquiz id=29 --> 
  <!-- Shortcode interpreted mtouchquiz id=29 alerts=off singlepage=on hints=on startscreen=off finalscreen=off multiplechances=off showanswers=now show_stamps=on randomq=off randoma=off status=on labels=on title=on proofread=off list=off time=off scoring=off formid= vform=on autoadvance=off autosubmit=off inform=off forcecf=off forcegf=off offset=1 questions=31 firstid=163 lastid=4927 color=green --> 
  <!--form action="" method="post" class="quiz-form" id="quiz-29"-->
      <div id="mtq_quiztitle-1" class="mtq_quiztitle" style='display:none'>
  <h2 style="margin-bottom:0px;">C Storage Classes and Type Qualifiers</h3>
  
      <noscript>
  <div id="mtq_javawarning-1" class="mtq_javawarning">
  Please wait while the activity loads.</br> If this activity does not load, try refreshing your browser. 
Also, this page requires javascript. 
Please visit using a browser with javascript enabled. 
  If loading fails, click here to try again  
  </noscript>
    
  <!-- root element for mtqscrollable -->
  <div id="mtq_question_container-1" >
  
          <table class='mtq_question_heading_table'><tr><td>Question 1<div id='mtq_stamp-1-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-1-1' class='mtq_question_text'>Which of the following is not a storage class specifier in C?<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-1-1-1' onclick='mtq_button_click(1,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 1, Choice 1'>A<div id='mtq_marker-1-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-1-1' class='mtq_answer_text'>auto</td></tr><tr id='mtq_row-1-2-1' onclick='mtq_button_click(1,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 1, Choice 2'>B<div id='mtq_marker-1-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-2-1' class='mtq_answer_text'>register</td></tr><tr id='mtq_row-1-3-1' onclick='mtq_button_click(1,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 1, Choice 3'>C<div id='mtq_marker-1-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-3-1' class='mtq_answer_text'>static</td></tr><tr id='mtq_row-1-4-1' onclick='mtq_button_click(1,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 1, Choice 4'>D<div id='mtq_marker-1-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-4-1' class='mtq_answer_text'>extern</td></tr><tr id='mtq_row-1-5-1' onclick='mtq_button_click(1,5,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-5-1' class='mtq_css_letter_button mtq_letter_button_4'  alt='Question 1, Choice 5'>E<div id='mtq_marker-1-5-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-5-1' class='mtq_answer_text'>volatile</td></tr><tr id='mtq_row-1-6-1' onclick='mtq_button_click(1,6,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-6-1' class='mtq_css_letter_button mtq_letter_button_5'  alt='Question 1, Choice 6'>F<div id='mtq_marker-1-6-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-6-1' class='mtq_answer_text'>typedef</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-question-1/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-1-1' class='mtq_explanation'>Question 1 Explanation:&nbsp; volatile is not a <a href="http://msdn.microsoft.com/en-us/library/w9hwbe3d(v=vs.80).aspx">storage class specifier</a>. 
volatile and const are <a href="http://msdn.microsoft.com/en-us/library/888bfst6%28VS.80%29.aspx">type qualifiers</a>.
<table class='mtq_question_heading_table'><tr><td>Question 2<div id='mtq_stamp-2-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-2-1' class='mtq_question_text'>Output of following program?
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    static int i=5;
    if(--i){
        main();
        printf(&quot;%d &quot;,i);
    }
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-2-1-1' onclick='mtq_button_click(2,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 2, Choice 1'>A<div id='mtq_marker-2-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-1-1' class='mtq_answer_text'>4 3 2 1</td></tr><tr id='mtq_row-2-2-1' onclick='mtq_button_click(2,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 2, Choice 2'>B<div id='mtq_marker-2-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-2-1' class='mtq_answer_text'>1 2 3 4</td></tr><tr id='mtq_row-2-3-1' onclick='mtq_button_click(2,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 2, Choice 3'>C<div id='mtq_marker-2-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-3-1' class='mtq_answer_text'>0 0 0 0</td></tr><tr id='mtq_row-2-4-1' onclick='mtq_button_click(2,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 2, Choice 4'>D<div id='mtq_marker-2-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-4-1' class='mtq_answer_text'>Compiler Error</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-2-1' class='mtq_explanation'>Question 2 Explanation:&nbsp; A static variable is shared among all calls of a function. 
All calls to main() in the given program share the same i. 
i becomes 0 before the printf() statement in all calls to main().
<table class='mtq_question_heading_table'><tr><td>Question 3<div id='mtq_stamp-3-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-3-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    static int i=5;
    if (--i){
        printf(&quot;%d &quot;,i);
        main();
    }
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-3-1-1' onclick='mtq_button_click(3,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 3, Choice 1'>A<div id='mtq_marker-3-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-1-1' class='mtq_answer_text'>4 3 2 1</td></tr><tr id='mtq_row-3-2-1' onclick='mtq_button_click(3,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 3, Choice 2'>B<div id='mtq_marker-3-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-2-1' class='mtq_answer_text'>1 2 3 4</td></tr><tr id='mtq_row-3-3-1' onclick='mtq_button_click(3,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 3, Choice 3'>C<div id='mtq_marker-3-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-3-1' class='mtq_answer_text'>4 4 4 4</td></tr><tr id='mtq_row-3-4-1' onclick='mtq_button_click(3,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 3, Choice 4'>D<div id='mtq_marker-3-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-4-1' class='mtq_answer_text'>0 0 0 0</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-3/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-3-1' class='mtq_explanation'>Question 3 Explanation:&nbsp; Since i is static variable, it is shared among all calls to main(). 
So is reduced by 1 by every function call.<table class='mtq_question_heading_table'><tr><td>Question 4<div id='mtq_stamp-4-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-4-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    int x = 5;
    int * const ptr = &amp;x;
    ++(*ptr);
    printf(&quot;%d&quot;, x);
  
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-4-1-1' onclick='mtq_button_click(4,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 4, Choice 1'>A<div id='mtq_marker-4-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-4-2-1' onclick='mtq_button_click(4,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 4, Choice 2'>B<div id='mtq_marker-4-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-2-1' class='mtq_answer_text'>Runtime Error</td></tr><tr id='mtq_row-4-3-1' onclick='mtq_button_click(4,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 4, Choice 3'>C<div id='mtq_marker-4-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-3-1' class='mtq_answer_text'>6</td></tr><tr id='mtq_row-4-4-1' onclick='mtq_button_click(4,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 4, Choice 4'>D<div id='mtq_marker-4-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-4-1' class='mtq_answer_text'>5</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-4/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-4-1' class='mtq_explanation'>Question 4 Explanation:&nbsp; See following declarations to know the difference between constant pointer and a pointer to a constant. 
<strong>int * const ptr</strong> —> ptr is constant pointer. 
You can change the value at the location pointed by pointer p, but you can not change p to point to other location.
<strong>int const * ptr</strong> —> ptr is a pointer to a constant. 
You can change ptr to point other variable. 
But you cannot change the value pointed by ptr.
Therefore above program works well because we have a constant pointer and we are not changing ptr to point to any other location. 
We are only icrementing value pointed by ptr.
<table class='mtq_question_heading_table'><tr><td>Question 5<div id='mtq_stamp-5-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-5-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    int x = 5;
    int const * ptr = &amp;x;
    ++(*ptr);
    printf(&quot;%d&quot;, x);
  
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-5-1-1' onclick='mtq_button_click(5,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 5, Choice 1'>A<div id='mtq_marker-5-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-5-2-1' onclick='mtq_button_click(5,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 5, Choice 2'>B<div id='mtq_marker-5-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-2-1' class='mtq_answer_text'>Runtime Error</td></tr><tr id='mtq_row-5-3-1' onclick='mtq_button_click(5,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 5, Choice 3'>C<div id='mtq_marker-5-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-3-1' class='mtq_answer_text'>6</td></tr><tr id='mtq_row-5-4-1' onclick='mtq_button_click(5,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 5, Choice 4'>D<div id='mtq_marker-5-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-4-1' class='mtq_answer_text'>5</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-5/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-5-1' class='mtq_explanation'>Question 5 Explanation:&nbsp; See following declarations to know the difference between constant pointer and a pointer to a constant. 
<strong>int * const ptr</strong> —> ptr is constant pointer. 
You can change the value at the location pointed by pointer p, but you can not change p to point to other location.
<strong>int const * ptr</strong> —> ptr is a pointer to a constant. 
You can change ptr to point other variable. 
But you cannot change the value pointed by ptr.
In the above program, ptr is a pointer to a constant. 
So the value pointed cannot be changed.
<table class='mtq_question_heading_table'><tr><td>Question 6<div id='mtq_stamp-6-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-6-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
  typedef static int *i;
  int j;
  i a = &amp;j;
  printf(&quot;%d&quot;, *a);
  return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-6-1-1' onclick='mtq_button_click(6,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 6, Choice 1'>A<div id='mtq_marker-6-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-1-1' class='mtq_answer_text'>Runtime Error</td></tr><tr id='mtq_row-6-2-1' onclick='mtq_button_click(6,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 6, Choice 2'>B<div id='mtq_marker-6-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-2-1' class='mtq_answer_text'>0</td></tr><tr id='mtq_row-6-3-1' onclick='mtq_button_click(6,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 6, Choice 3'>C<div id='mtq_marker-6-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-3-1' class='mtq_answer_text'>Garbage Value</td></tr><tr id='mtq_row-6-4-1' onclick='mtq_button_click(6,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 6, Choice 4'>D<div id='mtq_marker-6-4-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-4-1' class='mtq_answer_text'>Compiler Error </td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-6/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-6-1' class='mtq_explanation'>Question 6 Explanation:&nbsp; Compiler Error -&gt; Multiple Storage classes for a.
In C, typedef is considered as a <a href="http://www.itee.uq.edu.au/~comp2303/Leslie_C_ref/C/CONCEPT/storage_class.html">storage class</a>. 
The Error message may be different on different compilers.<table class='mtq_question_heading_table'><tr><td>Question 7<div id='mtq_stamp-7-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-7-1' class='mtq_question_text'>Output?
<pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
   typedef int i;
   i a = 0;
   printf(&quot;%d&quot;, a);
   return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-7-1-1' onclick='mtq_button_click(7,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 7, Choice 1'>A<div id='mtq_marker-7-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-7-2-1' onclick='mtq_button_click(7,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 7, Choice 2'>B<div id='mtq_marker-7-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-2-1' class='mtq_answer_text'>Runtime Error</td></tr><tr id='mtq_row-7-3-1' onclick='mtq_button_click(7,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 7, Choice 3'>C<div id='mtq_marker-7-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-3-1' class='mtq_answer_text'>0</td></tr><tr id='mtq_row-7-4-1' onclick='mtq_button_click(7,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 7, Choice 4'>D<div id='mtq_marker-7-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-4-1' class='mtq_answer_text'>1</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-7/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-7-1' class='mtq_explanation'>Question 7 Explanation:&nbsp; There is no problem with the program. 
It simply creates a user defined type i and creates a variable a of type i.<table class='mtq_question_heading_table'><tr><td>Question 8<div id='mtq_stamp-8-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-8-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
  typedef int *i;
  int j = 10;
  i *a = &amp;j;
  printf(&quot;%d&quot;, **a);
  return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-8-1-1' onclick='mtq_button_click(8,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 8, Choice 1'>A<div id='mtq_marker-8-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-8-2-1' onclick='mtq_button_click(8,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 8, Choice 2'>B<div id='mtq_marker-8-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-2-1' class='mtq_answer_text'>Garbage Value</td></tr><tr id='mtq_row-8-3-1' onclick='mtq_button_click(8,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 8, Choice 3'>C<div id='mtq_marker-8-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-3-1' class='mtq_answer_text'>10</td></tr><tr id='mtq_row-8-4-1' onclick='mtq_button_click(8,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 8, Choice 4'>D<div id='mtq_marker-8-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-4-1' class='mtq_answer_text'>0</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-8/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-8-1' class='mtq_explanation'>Question 8 Explanation:&nbsp; Compiler Error -> Initialization with incompatible pointer type.
The line typedef int *i makes i as type int *. 
So, the declaration of a means a is pointer to a pointer. 
The Error message may be different on different compilers. 
<table class='mtq_question_heading_table'><tr><td>Question 9<div id='mtq_stamp-9-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-9-1' class='mtq_question_text'>Output?
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int fun()
{
  static int num = 16;
  return num--;
}
int main()
{
  for(fun(); fun(); fun())
    printf(&quot;%d &quot;, fun());
  return 0;
}
</pre>
<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-9-1-1' onclick='mtq_button_click(9,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 9, Choice 1'>A<div id='mtq_marker-9-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-1-1' class='mtq_answer_text'>Infinite loop</td></tr><tr id='mtq_row-9-2-1' onclick='mtq_button_click(9,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 9, Choice 2'>B<div id='mtq_marker-9-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-2-1' class='mtq_answer_text'>13 10 7 4 1</td></tr><tr id='mtq_row-9-3-1' onclick='mtq_button_click(9,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 9, Choice 3'>C<div id='mtq_marker-9-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-3-1' class='mtq_answer_text'>14 11 8 5 2</td></tr><tr id='mtq_row-9-4-1' onclick='mtq_button_click(9,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 9, Choice 4'>D<div id='mtq_marker-9-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-4-1' class='mtq_answer_text'>15 12 8 5 2</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-9/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-9-1' class='mtq_explanation'>Question 9 Explanation:&nbsp; Since <em>num </em>is static in <em>fun()</em>, the old value of <em>num </em>is preserved for subsequent functions calls. 
Also, since the statement return <em>num</em>– is postfix, it returns the old value of <em>num</em>, and updates the value for next function call.
<pre>
fun() called first time: num = 16 // for loop initialization done;
In test condition, compiler checks for non zero value
fun() called again : num = 15
printf("%d \n", fun());:<strong>num=14 -&gt;printed</strong>
Increment/decrement condition check
fun(); called again : num = 13
----------------
fun() called second time: num: 13 
In test condition,compiler checks for non zero value
fun() called again : num = 12
printf("%d \n", fun());:<strong>num=11 -&gt;printed</strong>
fun(); called again : num = 10
--------
fun() called second time : num = 10 
In test condition,compiler checks for non zero value
fun() called again : num = 9
printf("%d \n", fun());:<strong>num=8 -&gt;printed</strong>
fun(); called again   : num = 7
--------------------------------
fun() called second time: num = 7
In test condition,compiler checks for non zero value
fun() called again : num = 6
printf("%d \n", fun());:<strong>num=5 -&gt;printed</strong>
fun(); called again   : num = 4
-----------
fun() called second time: num: 4 
In test condition,compiler checks for non zero value
fun() called again : num = 3
printf("%d \n", fun());:<strong>num=2 -&gt;printed</strong>
fun(); called again   : num = 1
----------
fun() called second time: num: 1 
In test condition,compiler checks for non zero value
fun() called again : num = 0 =&gt; <strong>STOP</strong> </pre>
<table class='mtq_question_heading_table'><tr><td>Question 10<div id='mtq_stamp-10-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-10-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main() 
{ 
  int x = 10; 
  static int y = x; 
  
  if(x == y) 
     printf(&quot;Equal&quot;); 
  else if(x &gt; y) 
     printf(&quot;Greater&quot;); 
  else
     printf(&quot;Less&quot;); 
  return 0; 
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-10-1-1' onclick='mtq_button_click(10,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 10, Choice 1'>A<div id='mtq_marker-10-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-1-1' class='mtq_answer_text'>Compiler Error</td></tr><tr id='mtq_row-10-2-1' onclick='mtq_button_click(10,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 10, Choice 2'>B<div id='mtq_marker-10-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-2-1' class='mtq_answer_text'>Equal</td></tr><tr id='mtq_row-10-3-1' onclick='mtq_button_click(10,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 10, Choice 3'>C<div id='mtq_marker-10-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-3-1' class='mtq_answer_text'>Greater</td></tr><tr id='mtq_row-10-4-1' onclick='mtq_button_click(10,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 10, Choice 4'>D<div id='mtq_marker-10-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-4-1' class='mtq_answer_text'>Less</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/storage-classes-gq/">C Storage Classes and Type Qualifiers</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-storage-classes-and-type-qualifiers-question-10/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-10-1' class='mtq_explanation'>Question 10 Explanation:&nbsp; In C, static variables can only be initialized using constant literals. 
This is allowed in C++ though. 
 See <a href="https://www.geeksforgeeks.org/g-fact-80/">this </a>GFact for details. 
               <!--End of mtqscrollable items-->
<h2>Understanding &#8220;volatile&#8221; qualifier in C | Set 1 (Introduction)</h2>
In spite of tons of literature on C language, &#8220;<strong>volatile</strong>&#8221; keyword is somehow not understood well (even by experienced C programmers). 
We think that the main reason for this is due to not having real-world use-case of a &#8216;<em>volatile</em>&#8216; variable in typical C programs that are written in high level language. 
Basically, unless you&#8217;re doing some low level hardware programming in C, you probably won&#8217;t use a variable while is qualified as &#8220;<strong>volatile</strong>&#8220;. 
By low level programming, we mean a piece of C code which is dealing with peripheral devices, IO ports (mainly memory mapped IO ports), Interrupt Service Routines (ISRs) which interact with Hardware. 
That&#8217;s why it&#8217;s not so straight forward to have a sample working C program which can easily show-case the exact effect of &#8220;<em>volatile</em>&#8221; keyword. 
In fact, in this article, if we could explain the meaning and purpose of &#8216;<em>volatile</em>&#8216;, it would serve as basic groundwork for further study and use of &#8216;volatile&#8217; in C. 
To understand &#8216;volatile&#8217;, we first need to have some background about what a compiler does to a C program. 
At high level, we know that a compiler converts C code to Machine code so that the executable can be run without having actual source code. 
Similar to other technologies, compiler technology had also evolved a lot. 
While translating Source code to Machine code, compilers typically try to optimize the output so that lesser Machine code needs to be executed finally. 
One such optimization is removing unnecessary Machine code for accessing variable which is not changing from Compiler&#8217;s perspective. 
Suppose we have the following code:
<code class="plain">uint32 status = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">while</code> <code class="plain">(status == 0) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/*Let us assume that status isn't being changed&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">in this while loop or may be in our whole program*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/*So long as status (which could be reflecting&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">status of some IO port) is ZERO, do something*/</code>
<code class="plain">} </code>
An optimizing Compiler would see that <em>status</em> isn&#8217;t being changed by <em>while</em> loop. 
So there&#8217;s no need to access <em>status</em> variable again and again after each iteration of loop. 
So the Compiler would convert this loop to a infinite loop i.e. 
<em>while (1)</em> so that the Machine code to read <em>status</em> isn&#8217;t needed. 
Please note that compiler isn&#8217;t aware of that <em>status</em> is a special variable which can be changed from outside the current program at any point of time e.g. 
some IO operation happened on a peripheral device for which device IO port was memory mapped to this variable. 
So in reality, we want complier to access <em>status</em> variable after every loop iteration even though it isn&#8217;t modified by our program which is being compiled by Compiler.
One can argue that we can turn-off all the compiler optimizations for such programs so that we don&#8217;t run into this situation. 
This is not an option due to multiple reasons such as<br />
A) Each compiler implementation is different so it&#8217;s not a portable solution<br />
B) Just because of one variable, we don&#8217;t want to turn of all the other optimizations which compiler does at other portions of our program.<br />
C) By turning off all the optimizations, our low level program couldn&#8217;t work as expected e.g. 
too much increase in size or delayed execution.
That&#8217;s where &#8220;<strong>volatile</strong>&#8221; comes in picture. 
Basically, we need to instruct Compiler that <em>status</em> is special variable so that no such optimization are allowed on this variable. 
With this, we would define our variable as follows:
<code class="keyword bold">volatile</code> <code class="plain">uint32 status = 0; </code>
For simplicity of explanation purpose, we chose the above example. 
But in general, <strong>volatile</strong> is used with pointers such as follows:
<code class="keyword bold">volatile</code> <code class="plain">uint32 * statusPtr = 0xF1230000 </code>
Here, <em>statusPtr</em> is pointing to a memory location (e.g. 
for some IO port) at which the content can change at any point of time from some peripheral device. 
Please note that our program might not have any control or knowledge about when that memory would change. 
So we would make it &#8220;<strong>volatile</strong>&#8221; so that compiler doesn&#8217;t perform optimization for the <em>volatile</em> variable which is pointed by <em>statusPtr</em>.
In the context of our discussion about &#8220;<strong>volatile</strong>&#8220;, we quote C language standard i.e. 
ISO/IEC 9899 C11 &#8211; clause 6.7.3 
<em>&#8220;An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects.&#8221; </em>
<em>&#8220;A volatile declaration may be used to describe an object corresponding to a memory-mapped input/output port or an object accessed by an asynchronously interrupting function. 
Actions on objects so declared shall not be ‘‘optimized out’’ by an implementation or reordered except as permitted by the rules for evaluating expressions.&#8221;</em>
Basically, C standard says that &#8220;<strong>volatile</strong>&#8221; variables can change from outside the program and that&#8217;s why compilers aren&#8217;t supposed to optimize their access. 
Now, you can guess that having too many &#8216;<strong>volatile</strong>&#8216; variables in your program would also result in lesser &#038; lesser compiler optimization. 
We hope it gives you enough background about meaning and purpose of &#8220;volatile&#8221;.
From this article, we would like you to take-away the concept of &#8220;<strong>volatile variable &#8211;> don&#8217;t do complier optimization for that variable</strong>&#8220;!
The following article explains volatile through more examples.<br />
<a href="https://www.geeksforgeeks.org/understanding-volatile-qualifier-in-c/">Understanding “volatile” qualifier in C | Set 2 (Examples)</a>
If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href = "http://www.contribute.geeksforgeeks.org ">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. 
See your article appearing on the GeeksforGeeks main page and help other Geeks.
<h2>Return values of printf() and scanf() in C/C++</h2>
What values do the <strong>printf() </strong> and <strong>scanf() functions return ?</strong> 
<ul>
<li> <strong>printf() : </strong> It returns <strong>total number of Characters Printed</strong>, Or negative value if an output error or an encoding error
<strong>Example 1:</strong> The printf() function in the code written below returns 6. 
As &#8216;CODING&#8217; contains 6 characters.
<code class="comments">// C/C++ program to demonstrate return value </code>
<code class="comments">// of printf() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">st[] = </code><code class="string">"CODING"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"While printing "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">", the value returned by printf() is : %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, st)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<strong>Output:</strong> While printing CODING, the value returned by printf() is : 6
</pre>
<strong>Example 2:</strong> The printf() function in the code written below returns 9. 
As &#8216;123456789&#8217; contains 9 characters.<br/>
<code class="comments">// C/C++ program to demonstrate return value </code>
<code class="comments">// of printf() </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">int</code> <code class="plain">n = 123456789; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"While printing "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">", the value returned by printf() is : %d"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, n)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<strong>Output:</strong> While printing 123456789, the value returned by printf() is : 9
</pre>
</li>
<li> <strong>scanf() : </strong> It returns <strong>total number of Inputs Scanned successfully</strong>,  or EOF if input failure occurs before the first receiving argument was assigned.
<strong>Example 1:</strong> The first scanf() function in the code written below returns 1, as it is scanning 1 item. 
Similarly second scanf() returns 2 as it is scanning 2 inputs and third scanf() returns 3 as it is scanning 3 inputs.
<code class="comments">// C/C++ program to demonstrate return value </code>
<code class="comments">// of printf() </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a[100], b[100], c[100]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scanf() with one input </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n First scanf() returns : %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, a)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scanf() with two inputs </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Second scanf() returns : %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s%s"</code><code class="plain">, a, b)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scanf() with three inputs </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Third scanf() returns : %d"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s%s%s"</code><code class="plain">, a, b, c)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<strong>Input:</strong>
Hey!
welcome to
geeks for geeks
<strong>Output:</strong>
 First scanf() returns : 1
 Second scanf() returns : 2
 Third scanf() returns : 3
</pre>
</li>
</ul>
<h2>What is return type of getchar(), fgetc() and getc() ?</h2>
In C, return type of getchar(), fgetc() and getc() is int (not char). 
So it is recommended to assign the returned values of these functions to an integer type variable. 
<!--more-->
<code class="color1 bold">char</code> <code class="plain">ch;&nbsp; </code><code class="comments">/* May cause problems */</code>&nbsp;&nbsp;
<code class="keyword bold">while</code> <code class="plain">((ch = </code><code class="functions bold">getchar</code><code class="plain">()) != EOF)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(ch); </code>
<code class="plain">} </code>
Here is a version that uses integer to compare the value of getchar().
<code class="color1 bold">int</code> <code class="plain">in;&nbsp;&nbsp; </code>
<code class="keyword bold">while</code> <code class="plain">((in = </code><code class="functions bold">getchar</code><code class="plain">()) != EOF)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(in); </code>
<code class="plain">} </code>
See <a href="http://en.wikipedia.org/wiki/C_file_input/output#The_EOF_pitfall">this </a> for more details. 
<h2>Scansets in C</h2>
scanf family functions support scanset specifiers which are represented by %[]. 
Inside scanset, we can specify single character or range of characters.<!--more--> While processing scanset, scanf will process only those characters which are part of scanset. 
We can define scanset by putting characters inside squre brackets. 
Please note that the scansets are case-sensitive.
Let us see with example. 
Below example will store only capital letters to character array &#8216;str&#8217;, any other character will not be stored inside character array.
<code class="comments">/* A simple scanset example */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[128]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a string: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[A-Z]s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"You entered: %s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
  [root@centos-6 C]# ./scan-set 
  Enter a string: GEEKs_for_geeks
  You entered: GEEK
</pre>
If first character of scanset is &#8216;^&#8217;, then the specifier will stop reading after first occurrence of that character. 
For example, given below scanset will read all characters but stops after first occurrence of &#8216;o&#8217;<br/>
<code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[^o]s"</code><code class="plain">, str); </code>
Let us see with example.
<code class="comments">/* Another scanset example with ^ */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[128]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a string: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[^o]s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"You entered: %s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
  [root@centos-6 C]# ./scan-set 
  Enter a string: http://geeks for geeks
  You entered: http://geeks f
  [root@centos-6 C]# 
</pre>
Let us implement gets() function by using scan set. 
gets() function reads a line from stdin into the buffer pointed to by s until either a terminating newline or EOF found.
<code class="comments">/* implementation of gets() function using scanset */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[128]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a string with spaces: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[^\n]s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"You entered: %s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
  [root@centos-6 C]# ./gets 
  Enter a string with spaces: Geeks For Geeks
  You entered: Geeks For Geeks
  [root@centos-6 C]# 
</pre>
As a side note, using gets() may not be a good idea in general. 
Check below note from Linux man page.
<em>Never  use  gets(). 
Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. 
It has  been  used  to  break  computer security. 
Use fgets() instead. 
</em>Also see <a href="https://www.geeksforgeeks.org/gets-is-risky-to-use/">this </a>post.
<h2>puts() vs printf() for printing a string</h2>
In C, given a string variable <em>str</em>, which of the following two should be preferred to print it to stdout? <!--more-->
<pre>
  1)  puts(str);
</pre>
<pre>
  2)  printf(str);
</pre>
puts() can be preferred for printing a string because it is generally less expensive (implementation of puts() is generally simpler than printf()), and if the string has formatting characters like &#8216;%&#8217;, then printf() would give unexpected results. 
Also, if str is a user input string, then use of printf() might cause security issues (see <a href="http://www.cis.syr.edu/~wedu/seed/Labs/Vulnerability/Format_String/files/formatstring-1.2.pdf">this </a>for details).<br />
Also note that puts() moves the cursor to next line. 
If you do not want the cursor to be moved to next line, then you can use following variation of puts().
<pre>
   fputs(str, stdout)
</pre>
You can try following programs for testing the above discussed differences between puts() and printf().
<strong>Program 1</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Geeksfor"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Geeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Program 2</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"Geeksfor"</code><code class="plain">, stdout); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"Geeks"</code><code class="plain">, stdout); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Program 3</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// % is intentionally put here to show side effects of using printf(str) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geek%sforGeek%s"</code><code class="plain">);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Program 4</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Geek%sforGeek%s"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>What is use of %n in printf() ?</h2>
In C printf(), %n is a special format specifier which instead of printing something causes printf() to load the variable pointed by the  corresponding argument with a value equal to the number of characters that have been printed by printf() before the occurrence of %n.<!--more-->
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191009172738/n-in-printf.jpg"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191009172738/n-in-printf.jpg" alt=""></a>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"geeks for %ngeeks "</code><code class="plain">, &c); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The above program prints &#8220;geeks for geeks 10&#8221;. 
The first printf() prints &#8220;geeks for geeks&#8221;. 
The second printf() prints 10 as there are 10 characters printed (the 10 characters are &#8220;geeks for &#8220;) before %n in first printf() and c is set to 10 by first printf().
<h2>How to print % using printf()?</h2>
Asked by Tanuj
Here is the standard prototype of printf function in C.<br />
<!--more-->
<pre>
          int printf(const char *format, ...);
</pre>
The format string is composed of zero or more   directives:  ordinary  characters  (not  %),  which  are  copied  unchanged to the output stream; and conversion specifications, each  of  argument (and it is an  error  if  insufficiently  many  arguments  are  given).
The character % is followed by one of the following characters.
The flag character<br />
The field width<br />
The precision<br />
The length modifier<br />
The conversion specifier: 
See <a href="http://swoolley.org/man.cgi/3/printf">http://swoolley.org/man.cgi/3/printf</a> for details of all the above characters. 
The main thing to note in the standard is the below line about conversion specifier.
<pre>
A `%' is written. 
No argument is converted. 
The complete conversion specification is`%%'.
</pre>
So we can print &#8220;%&#8221; using &#8220;%%&#8221;
<code class="comments">/* Program to print %*/</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="comments">/* Program to print %*/</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%%"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
We can also print &#8220;%&#8221; using below.
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, </code><code class="string">'%'</code><code class="plain">); </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, </code><code class="string">"%"</code><code class="plain">); </code>
<h1 style="display:inline">C Input and Output</h2>
		</header>
<div id="mtq_quiz_area-1" class="mtq_quiz_area mtq_color_green"> 
  <!--Quiz generated using mTouch Quiz Version 3.1.3 by G. 
Michael Guy (http://gmichaelguy.com/quizplugin/)-->
        
    
   <!-- Here code starts for pagination -->
  
  <!-- <a class="page" data-pageid="0">First</a> -->
          <a class="page current" data-pageid="0">1</a><a class="page" data-pageid="1">2</a><a class="page" data-pageid="2">3</a>        <!-- <a class="page" data-pageid="<?php# echo $total_pagination_btn-1; ?>">Last</a> -->
  
  <!-- Here code ends for pagination -->
  <!-- Shortcode entered mtouchquiz id=1 --> 
  <!-- Shortcode interpreted mtouchquiz id=1 alerts=off singlepage=on hints=on startscreen=off finalscreen=off multiplechances=off showanswers=now show_stamps=on randomq=off randoma=off status=on labels=on title=on proofread=off list=off time=off scoring=off formid= vform=on autoadvance=off autosubmit=off inform=off forcecf=off forcegf=off offset=1 questions=25 firstid=1 lastid=5661 color=green --> 
  <!--form action="" method="post" class="quiz-form" id="quiz-1"-->
      <div id="mtq_quiztitle-1" class="mtq_quiztitle" style='display:none'>
  <h2 style="margin-bottom:0px;">C Input and Output</h3>
  
      <noscript>
  <div id="mtq_javawarning-1" class="mtq_javawarning">
  Please wait while the activity loads.</br> If this activity does not load, try refreshing your browser. 
Also, this page requires javascript. 
Please visit using a browser with javascript enabled. 
  If loading fails, click here to try again  
  </noscript>
    
  <!-- root element for mtqscrollable -->
  <div id="mtq_question_container-1" >
  
          <table class='mtq_question_heading_table'><tr><td>Question 1<div id='mtq_stamp-1-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-1-1' class='mtq_question_text'>Predict the output of following program?
<pre class="brush: c; title: ; notranslate" title="">
#include &quot;stdio.h&quot;
int main()
{
    char arr[100];
    printf(&quot;%d&quot;, scanf(&quot;%s&quot;, arr));
    /* Suppose that input value given
        for above scanf is &quot;GeeksQuiz&quot; */
    return 1;
}
</pre>
<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-1-1-1' onclick='mtq_button_click(1,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 1, Choice 1'>A<div id='mtq_marker-1-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-1-1' class='mtq_answer_text'>9</td></tr><tr id='mtq_row-1-2-1' onclick='mtq_button_click(1,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 1, Choice 2'>B<div id='mtq_marker-1-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-2-1' class='mtq_answer_text'>1</td></tr><tr id='mtq_row-1-3-1' onclick='mtq_button_click(1,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 1, Choice 3'>C<div id='mtq_marker-1-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-3-1' class='mtq_answer_text'>10</td></tr><tr id='mtq_row-1-4-1' onclick='mtq_button_click(1,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-1-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 1, Choice 4'>D<div id='mtq_marker-1-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-1-4-1' class='mtq_answer_text'>100</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-1/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-1-1' class='mtq_explanation'>Question 1 Explanation:&nbsp; In C, scanf returns the no. 
of inputs it has successfully read. 
See <a href="http://geeksforgeeks.org/archives/674">http://geeksforgeeks.org/archives/674</a><table class='mtq_question_heading_table'><tr><td>Question 2<div id='mtq_stamp-2-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-2-1' class='mtq_question_text'>Predict output of the following program
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
   printf(&quot;new_c_questionby&quot;);
   printf(&quot;rgeeksforgeeks&quot;); 
   getchar();
   return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-2-1-1' onclick='mtq_button_click(2,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 2, Choice 1'>A<div id='mtq_marker-2-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-1-1' class='mtq_answer_text'>ew_c_question<br>
geeksforgeeks</br></td></tr><tr id='mtq_row-2-2-1' onclick='mtq_button_click(2,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 2, Choice 2'>B<div id='mtq_marker-2-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-2-1' class='mtq_answer_text'>new_c_ques<br>
geeksforgeeks</br></td></tr><tr id='mtq_row-2-3-1' onclick='mtq_button_click(2,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 2, Choice 3'>C<div id='mtq_marker-2-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-3-1' class='mtq_answer_text'><br>
geeksforgeeks</br></td></tr><tr id='mtq_row-2-4-1' onclick='mtq_button_click(2,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-2-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 2, Choice 4'>D<div id='mtq_marker-2-4-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-2-4-1' class='mtq_answer_text'>Depends on terminal configuration</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-2-1' class='mtq_explanation'>Question 2 Explanation:&nbsp; See <a href="http://stackoverflow.com/questions/17236242/usage-of-b-and-r-in-c">http://stackoverflow.com/questions/17236242/usage-of-b-and-r-in-c</a><table class='mtq_question_heading_table'><tr><td>Question 3<div id='mtq_stamp-3-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-3-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main() 
{ 
  printf(&quot; &quot;GEEKS %% FOR %% GEEKS&quot;&quot;); 
  getchar(); 
  return 0; 
}</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-3-1-1' onclick='mtq_button_click(3,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 3, Choice 1'>A<div id='mtq_marker-3-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-1-1' class='mtq_answer_text'>“GEEKS % FOR % GEEKS”</td></tr><tr id='mtq_row-3-2-1' onclick='mtq_button_click(3,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 3, Choice 2'>B<div id='mtq_marker-3-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-2-1' class='mtq_answer_text'>GEEKS % FOR % GEEKS</td></tr><tr id='mtq_row-3-3-1' onclick='mtq_button_click(3,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 3, Choice 3'>C<div id='mtq_marker-3-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-3-1' class='mtq_answer_text'> \"GEEKS %% FOR %% GEEKS\"</td></tr><tr id='mtq_row-3-4-1' onclick='mtq_button_click(3,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-3-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 3, Choice 4'>D<div id='mtq_marker-3-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-3-4-1' class='mtq_answer_text'>GEEKS %% FOR %% GEEKS</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-3/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-3-1' class='mtq_explanation'>Question 3 Explanation:&nbsp; Backslash (\\\\) works as escape character for double quote (“). 
For explanation of %%, see <a href="http://www.geeksforgeeks.org/how-to-print-using-printf/">http://www.geeksforgeeks.org/how-to-print-using-printf/</a><table class='mtq_question_heading_table'><tr><td>Question 4<div id='mtq_stamp-4-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-4-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
// Assume base address of &quot;GeeksQuiz&quot; to be 1000
int main()
{
   printf(5 + &quot;GeeksQuiz&quot;);
   return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-4-1-1' onclick='mtq_button_click(4,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 4, Choice 1'>A<div id='mtq_marker-4-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-1-1' class='mtq_answer_text'>GeeksQuiz</td></tr><tr id='mtq_row-4-2-1' onclick='mtq_button_click(4,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 4, Choice 2'>B<div id='mtq_marker-4-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-2-1' class='mtq_answer_text'>Quiz</td></tr><tr id='mtq_row-4-3-1' onclick='mtq_button_click(4,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 4, Choice 3'>C<div id='mtq_marker-4-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-3-1' class='mtq_answer_text'>1005</td></tr><tr id='mtq_row-4-4-1' onclick='mtq_button_click(4,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-4-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 4, Choice 4'>D<div id='mtq_marker-4-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-4-4-1' class='mtq_answer_text'>Compile-time error</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-4/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-4-1' class='mtq_explanation'>Question 4 Explanation:&nbsp; <strong>printf</strong> is a library function defined under <em>stdio.h</em> header file. 
The compiler adds 5 to the base address of the string through the expression<em> <strong>5 + "GeeksQuiz" </strong></em>. 
Then the string "Quiz" gets passed to the standard library function as an argument.<table class='mtq_question_heading_table'><tr><td>Question 5<div id='mtq_stamp-5-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-5-1' class='mtq_question_text'>Predict the output of the below program:
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;%c &quot;, 5[&quot;GeeksQuiz&quot;]);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-5-1-1' onclick='mtq_button_click(5,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 5, Choice 1'>A<div id='mtq_marker-5-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-1-1' class='mtq_answer_text'>Compile-time error</td></tr><tr id='mtq_row-5-2-1' onclick='mtq_button_click(5,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 5, Choice 2'>B<div id='mtq_marker-5-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-2-1' class='mtq_answer_text'>Runtime error</td></tr><tr id='mtq_row-5-3-1' onclick='mtq_button_click(5,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 5, Choice 3'>C<div id='mtq_marker-5-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-3-1' class='mtq_answer_text'>Q</td></tr><tr id='mtq_row-5-4-1' onclick='mtq_button_click(5,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-5-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 5, Choice 4'>D<div id='mtq_marker-5-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-5-4-1' class='mtq_answer_text'>s</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-5/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-5-1' class='mtq_explanation'>Question 5 Explanation:&nbsp; The crux of the program lies in the expression: <strong>5["GeeksQuiz"]</strong>
This expression is broken down by the compiler as: <strong>*(5 + "GeeksQuiz")</strong>. 
Adding 5 to the base address of the string increments the pointer(lets say a pointer was pointing to the start(<strong>G</strong>) of the string initially) to point to <strong>Q</strong>. 
Applying <strong>value-of</strong> operator gives the character at the location pointed to by the pointer i.e. 
Q.<table class='mtq_question_heading_table'><tr><td>Question 6<div id='mtq_stamp-6-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-6-1' class='mtq_question_text'>Predict the output of below program:
<pre class="brush: c; title: ; notranslate" title="">
#include &lt;stdio.h&gt;
int main()
{
    printf(&quot;%c &quot;, &quot;GeeksQuiz&quot;[5]);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-6-1-1' onclick='mtq_button_click(6,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 6, Choice 1'>A<div id='mtq_marker-6-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-1-1' class='mtq_answer_text'>Compile-time error</td></tr><tr id='mtq_row-6-2-1' onclick='mtq_button_click(6,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 6, Choice 2'>B<div id='mtq_marker-6-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-2-1' class='mtq_answer_text'>Runtime error</td></tr><tr id='mtq_row-6-3-1' onclick='mtq_button_click(6,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 6, Choice 3'>C<div id='mtq_marker-6-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-3-1' class='mtq_answer_text'>Q</td></tr><tr id='mtq_row-6-4-1' onclick='mtq_button_click(6,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-6-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 6, Choice 4'>D<div id='mtq_marker-6-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-6-4-1' class='mtq_answer_text'>s</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-6/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-6-1' class='mtq_explanation'>Question 6 Explanation:&nbsp; The crux of the program lies in the expression: <strong>"GeeksQuiz"[5]</strong>.
This expression is broken down by the compiler as: *(“GeeksQuiz” + 5). 
Adding 5 to the base address of the string increments the pointer(lets say a pointer was pointing to the start(<strong>G</strong>) of the string initially) to point to Q. 
Applying <strong>value-of</strong> operator gives the character at the location pointed to by the pointer i.e. 
Q.<table class='mtq_question_heading_table'><tr><td>Question 7<div id='mtq_stamp-7-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-7-1' class='mtq_question_text'>Which of the following is true<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-7-1-1' onclick='mtq_button_click(7,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 7, Choice 1'>A<div id='mtq_marker-7-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-1-1' class='mtq_answer_text'>gets() can read a string with newline chacters but a normal scanf() with %s can not.</td></tr><tr id='mtq_row-7-2-1' onclick='mtq_button_click(7,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 7, Choice 2'>B<div id='mtq_marker-7-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-2-1' class='mtq_answer_text'>gets() can read a string with spaces but a normal scanf() with %s can not.</td></tr><tr id='mtq_row-7-3-1' onclick='mtq_button_click(7,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 7, Choice 3'>C<div id='mtq_marker-7-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-3-1' class='mtq_answer_text'>gets() can always replace scanf() without any additional code.</td></tr><tr id='mtq_row-7-4-1' onclick='mtq_button_click(7,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-7-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 7, Choice 4'>D<div id='mtq_marker-7-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-7-4-1' class='mtq_answer_text'>None of the above</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-7-2/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-7-1' class='mtq_explanation'>Question 7 Explanation:&nbsp; gets() can read a string with spaces but a normal scanf() with %s can not. 
Consider following program as an example.
If we enter "Geeks Quiz" as input in below program, the program prints "Geeks"
But in the following program, if we enter "Geeks Quiz", it prints "Geeks Quiz"
<table class='mtq_question_heading_table'><tr><td>Question 8<div id='mtq_stamp-8-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-8-1' class='mtq_question_text'>Which of the following is true<table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-8-1-1' onclick='mtq_button_click(8,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 8, Choice 1'>A<div id='mtq_marker-8-1-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-1-1' class='mtq_answer_text'>gets() doesn't do any array bound testing and should not be used. 
</td></tr><tr id='mtq_row-8-2-1' onclick='mtq_button_click(8,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 8, Choice 2'>B<div id='mtq_marker-8-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-2-1' class='mtq_answer_text'>fgets() should be used in place of gets() only for files, otherwise gets() is fine</td></tr><tr id='mtq_row-8-3-1' onclick='mtq_button_click(8,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 8, Choice 3'>C<div id='mtq_marker-8-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-3-1' class='mtq_answer_text'>gets() cannot read strings with spaces</td></tr><tr id='mtq_row-8-4-1' onclick='mtq_button_click(8,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-8-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 8, Choice 4'>D<div id='mtq_marker-8-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-8-4-1' class='mtq_answer_text'>None of the above</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-8/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-8-1' class='mtq_explanation'>Question 8 Explanation:&nbsp; See <a href="http://www.geeksforgeeks.org/gets-is-risky-to-use/">gets() is risky to use!</a><table class='mtq_question_heading_table'><tr><td>Question 9<div id='mtq_stamp-9-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-9-1' class='mtq_question_text'>What does the following C statement mean?
<pre class="brush: c; title: ; notranslate" title="">
 scanf(&quot;%4s&quot;, str);
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-9-1-1' onclick='mtq_button_click(9,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 9, Choice 1'>A<div id='mtq_marker-9-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-1-1' class='mtq_answer_text'>Read exactly 4 characters from console.</td></tr><tr id='mtq_row-9-2-1' onclick='mtq_button_click(9,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 9, Choice 2'>B<div id='mtq_marker-9-2-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-2-1' class='mtq_answer_text'>Read maximum 4 characters from console.</td></tr><tr id='mtq_row-9-3-1' onclick='mtq_button_click(9,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 9, Choice 3'>C<div id='mtq_marker-9-3-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-3-1' class='mtq_answer_text'>Read a string str in multiples of 4</td></tr><tr id='mtq_row-9-4-1' onclick='mtq_button_click(9,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-9-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 9, Choice 4'>D<div id='mtq_marker-9-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-9-4-1' class='mtq_answer_text'>Nothing</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-9/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-9-1' class='mtq_explanation'>Question 9 Explanation:&nbsp; Try following program, enter GeeksQuiz, the output would be "Geek"
<pre>
#include &lt;stdio.h&gt;
int main()
{
    char str[50] = {0};
    scanf("%4s", str);
    printf(str);
    getchar();
    return 0;
}
</pre><table class='mtq_question_heading_table'><tr><td>Question 10<div id='mtq_stamp-10-1' class='mtq_stamp'></td></tr></table><div id='mtq_question_text-10-1' class='mtq_question_text'><pre class="brush: c; title: ; notranslate" title="">
#include&lt;stdio.h&gt;
int main()
{
    char *s = &quot;Geeks Quiz&quot;;
    int n = 7;
    printf(&quot;%.*s&quot;, n, s);
    return 0;
}
</pre><table class='mtq_answer_table'><colgroup><col class='mtq_oce_first'/></colgroup><tr id='mtq_row-10-1-1' onclick='mtq_button_click(10,1,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-1-1' class='mtq_css_letter_button mtq_letter_button_0'  alt='Question 10, Choice 1'>A<div id='mtq_marker-10-1-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-1-1' class='mtq_answer_text'>Geeks Quiz</td></tr><tr id='mtq_row-10-2-1' onclick='mtq_button_click(10,2,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-2-1' class='mtq_css_letter_button mtq_letter_button_1'  alt='Question 10, Choice 2'>B<div id='mtq_marker-10-2-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-2-1' class='mtq_answer_text'>Nothing is printed</td></tr><tr id='mtq_row-10-3-1' onclick='mtq_button_click(10,3,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-3-1' class='mtq_css_letter_button mtq_letter_button_2'  alt='Question 10, Choice 3'>C<div id='mtq_marker-10-3-1' class='mtq_marker mtq_correct_marker' alt='Correct'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-3-1' class='mtq_answer_text'>Geeks Q</td></tr><tr id='mtq_row-10-4-1' onclick='mtq_button_click(10,4,1)' class='mtq_clickable'><td class='mtq_letter_button_td'><div id='mtq_button-10-4-1' class='mtq_css_letter_button mtq_letter_button_3'  alt='Question 10, Choice 4'>D<div id='mtq_marker-10-4-1' class='mtq_marker mtq_wrong_marker' alt='Wrong'></td><td class='mtq_answer_td'><div id='mtq_answer_text-10-4-1' class='mtq_answer_text'>Geeks Qu</td></tr></table><b><a href="https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/">C Input and Output</a>&nbsp;&nbsp;&nbsp;&nbsp;</b><br><b><a href=" https://www.geeksforgeeks.org/c-input-and-output-question-10/">Discuss it</a></b></br><br></br><div id='mtq_question_explanation-10-1' class='mtq_explanation'>Question 10 Explanation:&nbsp; .* means The precision is not specified in the format string, but as an additional integer value argument preceding the argument that has to be formatted. 
               <!--End of mtqscrollable items-->
<h2>What is the difference between printf, sprintf and fprintf?</h2>
<u><strong>printf:</strong></u><br />
printf function is used to print character stream of data on stdout console.<!--more-->
<strong>Syntax :</strong>  
<pre>
 int printf(const char* str, ...); </pre>
<strong>Example : </strong><br/>
<code class="comments">// simple print on stdout&nbsp; </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"hello geeksquiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<strong>Output :</strong> 
<pre> hello geeksquiz</pre>
<u><strong>sprintf:</strong></u><br />
Syntax:  
<pre>
int sprintf(char *str, const char *string,...); </pre>
String print function instead of printing on console store it on char buffer which are specified in sprintf
<strong>Example :</strong> 
<code class="comments">// Example program to demonstrate sprintf() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">buffer[50]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20, c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">c = a + b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">sprintf</code><code class="plain">(buffer, </code><code class="string">"Sum of %d and %d is %d"</code><code class="plain">, a, b, c); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The string "sum of 10 and 20 is 30" is stored&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// into buffer instead of printing on stdout </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, buffer); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output :</strong> 
<pre>Sum of 10 and 20 is 30</pre>
<u><strong>fprintf:</strong></u><br />
fprintf is used to print the string content in file but not on stdout console.
<pre>
int fprintf(FILE *fptr, const char *str, ...);</pre>
<strong>Example : </strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, n=2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[50]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//open file sample.txt in write mode </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fptr = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"sample.txt"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fptr == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Could not open file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Enter a name"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">gets</code><code class="plain">(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(fptr,</code><code class="string">"%d.%s\n"</code><code class="plain">, i, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Input: GeeksforGeeks
       GeeksQuiz
<strong>Output :</strong>  sample.txt file now having output as 
0. 
GeeksforGeeks
1. 
GeeksQuiz</pre>
Thank you for reading, i will soon update with scanf, fscanf, sscanf keep tuned.
<h2>Difference between  getc(), getchar(), getch() and getche()</h2>
All of these functions read a character from input and return an integer value. 
The integer is returned to accommodate a special value used to indicate failure. 
<!--more--> The value EOF is generally used for this purpose.
<u><strong>getc():</strong></u><br />
It reads a single character from a given input stream and returns the corresponding integer value (typically ASCII value of read character) on success. 
It returns EOF on failure.
Syntax: 
<pre>int getc(FILE *stream); </pre>

Example:
<code class="comments">// Example for getc() in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, </code><code class="functions bold">getc</code><code class="plain">(stdin)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
<pre>
Input: g (press enter key)
Output: g </pre>
An Example Application : <a href="https://www.geeksforgeeks.org/c-program-compare-two-files-report-mismatches/">C program to compare two files and report mismatches</a>
<u><strong>getchar():</strong></u><br />
The difference between getc() and getchar() is getc() can read from any input stream, but getchar() reads from standard input. 
So getchar() is equivalent to getc(stdin). 
Syntax: 
<pre>int getchar(void); </pre>
Example:
<code class="comments">// Example for getchar() in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, </code><code class="functions bold">getchar</code><code class="plain">()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Input: g(press enter key)
Output: g </pre>
<u><strong>getch():</strong></u><br />
getch() is a nonstandard function and is present in conio.h header file which is mostly used by MS-DOS compilers like Turbo C. 
It is not part of the C standard library or ISO C, nor is it defined by POSIX (Source: http://en.wikipedia.org/wiki/Conio.h)<br />
Like above functions, it reads also a single character from keyboard. 
But it does not use any buffer, so the entered character is immediately returned without waiting for the enter key.<br />
Syntax:  
<pre>int getch();</pre>
Example:
<code class="comments">// Example for getch() in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;conio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, getch());&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre>
Input:  g (Without enter key)
Output: Program terminates immediately.
        But when you use DOS shell in Turbo C, 
        it shows a single g, i.e., 'g'</pre>
<u><strong>getche()</strong></u><br />
Like getch(), this is also a non-standard function present in conio.h. 
It reads a single character from the keyboard and displays immediately on output screen without waiting for enter key.
Syntax: 
<pre>int getche(void); </pre>
Example:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;conio.h> </code>
<code class="comments">// Example for getche() in C </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, getche()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre>
Input: g(without enter key as it is not buffered)
Output: Program terminates immediately.
        But when you use DOS shell in Turbo C, 
        double g, i.e., 'gg'</pre>
<h2>Difference between %d and %i format specifier in C language</h2>
A format specifier is a sequence formed by an initial percentage sign (%) indicates a format specifier, which is used to specify the type and format of the data to be retrieved from the stream and stored into the locations pointed by the additional arguments. 
In short it tell us which type of data to store and which type of data to print.
<strong>For example</strong> &#8211; If we want to read and print integer using scanf() and printf() function, either %i or %d is used but there is subtle difference in both <strong>%i</strong> and <strong>%d</strong> format specifier.
<blockquote>%d specifies signed decimal integer while %i specifies integer.<br/>
            </blockquote>
<p align="center"><strong>%d and %i behave similar with printf</strong>
There is no difference between the %i and %d format specifiers for printf. 
Consider a following example.
<code class="comments">// C program to demonstrate </code>
<code class="comments">// the behavior of %i and %d&nbsp; </code>
<code class="comments">// with printf statement </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num = 9; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print value using %d </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of num using %%d is = %d\n"</code><code class="plain">, num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print value using %i </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of num using %%i is = %i\n"</code><code class="plain">, num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<b>Output:</b>
Value of num using %d is = 9
Value of num using %i is = 9
</pre>
<p align="center"><strong>%d and %i behavior is different in scanf</strong>
<strong>%d assume base 10 while %i auto detects the base</strong>. 
Therefore, both specifiers behaves differently while they are used with an input specifier. 
So, 012 would be 10 with %i but 12 with %d.
<ul>
<li>
		<strong>%d</strong> takes integer value as signed decimal integer i.e. 
it takes negative values along with positive values but values should be in decimal otherwise it will print garbage value. 
Consider a following example.
	</li>
<li>
		<strong>%i</strong> takes integer value as integer value with decimal, hexadecimal or octal type.<br />
		To enter a value in hexadecimal format &#8211; value should be provided by preceding &#8220;0x&#8221; and value in octal format &#8211; value should be provided by preceding &#8220;0&#8221;.
	</li>
</ul>
Consider a following example.
<code class="comments">// C program to demonstrate the difference </code>
<code class="comments">// between %i and %d specifier </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a, b, c; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter value of a in decimal format:"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter value of b in octal format: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%i"</code><code class="plain">, &b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter value of c in hexadecimal format: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%i"</code><code class="plain">, &c); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %i, b = %i, c = %i"</code><code class="plain">, a, b, c); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<b>Output:</b>
Enter value of a in decimal format:12
Enter value of b in octal format: 012
Enter value of c in hexadecimal format: 0x12
a = 12, b = 10, c = 18
</pre>
<strong>Explanation:</strong><br />
The decimal value of a as 12 is 12<br />
The decimal value of b as 12(octal) is 10<br />
The decimal value of c as 12(hexadecimal) is 18
<h2>Use of fflush(stdin) in C</h2>
fflush() is typically used for output stream only. 
Its purpose is to clear (or flush) the output buffer and move the buffered data to console (in case of stdout) or disk (in case of file output stream). 
Below is its syntax.
<pre><b>fflush(FILE *ostream);</b>
ostream points to an output stream 
or an update stream in which the 
most recent operation was not input, 
the fflush function causes any 
unwritten data for that stream to 
be delivered to the host environment 
to be written to the file; otherwise, 
the behavior is undefined.</pre>
<strong>Can we use it for input stream like stdin?</strong><br />
As per C standard, it is undefined behavior to use fflush(stdin). 
However some compilers like <a href="https://msdn.microsoft.com/en-us/library/9yky46tz.aspx">Microsoft visual studio allows it</a> allow it. 
How is it used in these in these compilers? While taking an input string with spaces, the buffer does not get cleared for the next input and considers the previous input for the same. 
To solve this problem fflush(stdin) is. 
used to clear the stream/buffer. 
<code class="comments">// C program to illustrate situation </code>
<code class="comments">// where flush(stdin) is required only </code>
<code class="comments">// in certain compilers. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;2; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[^\n]s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// fflush(stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>
geeks   
geeksforgeeks
</pre>
Output:
<pre>
geeks 
geeks 
</pre>
The code above takes only single input and gives the same result for the second input. 
Reason is because as the string is already stored in the buffer i.e. 
stream is not cleared yet as it was expecting string with spaces or new line. 
So, to handle this situation fflush(stdin) is used.
<code class="comments">// C program to illustrate flush(stdin) </code>
<code class="comments">// This program works as expected only </code>
<code class="comments">// in certain compilers like Microsoft </code>
<code class="comments">// visual studio. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i&lt;2; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%[^\n]s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// used to clear the buffer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and accept the next string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fflush</code><code class="plain">(stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Input:
<pre>
geeks
geeksforgeeks
</pre>
Output:
<pre>
geeks 
geeksforgeeks
</pre>
<p align="center"><b>Is it good to use fflush(stdin)?</b>
Although using “fflush(stdin)” after “scanf()” statement also clears the input buffer in certain compilers, it is not recommended to use it as it is undefined behavior by language standard. 
In C and C++, we have different methods to clear the buffer discussed in this <a href="https://www.geeksforgeeks.org/clearing-the-input-buffer-in-cc/"> <b>post</b></a>.
Reference:<br />
<a href="https://stackoverflow.com/questions/2979209/using-fflushstdin">https://stackoverflow.com/questions/2979209/using-fflushstdin</a>
<h2>Clearing The Input Buffer In C/C++</h2>
<strong>What is a buffer?</strong><br />
A temporary storage area is called buffer. 
All standard input and output devices contain an input and output buffer. 
In standard C/C++, streams are buffered, for example in the case of standard input, when we press the key on keyboard, it isn’t sent to your program, rather it is buffered by operating system till the time is allotted to that program.
<strong><br />
How does it effect Programming?</strong><br />
On various occasions you may need to clear the unwanted buffer so as to get the next input in the desired container and not in the buffer of previous variable. 
For example, in case of C after encountering “scanf()” , if we need to input a character array or character ,and in case of C++, after encountering“cin” statement, we require to input a character array or a string , we require to clear the input buffer or else the desired input is occupied by buffer of previous variable, not by the desired container.On pressing “Enter” (carriage return) on output screen after the first input , as the buffer of previous variable was the space for new container(as we did’nt clear it) , the program skips the following input of container.
<strong>In case of <a href="https://www.geeksforgeeks.org/c/">C Programming </a></strong><br/>
<code class="comments">// C Code to explain why not&nbsp; </code>
<code class="comments">// clearing the input buffer </code>
<code class="comments">// causes undesired outputs </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[80], ch; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Scan input from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksforGeeks for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Scan character from user-&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 'a' for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ch = </code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing character array,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// prints “GeeksforGeeks”) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This does not print&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// character 'a' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>GeeksforGeeks
a
</pre>
Output:
<pre>
GeeksforGeeks
</pre>
<strong>In case of <a href="https://www.geeksforgeeks.org/c-plus-plus/">C++</a></strong>
<code class="comments">// C++ Code to explain why </code>
<code class="comments">// not clearing the input&nbsp; </code>
<code class="comments">// buffer causes undesired </code>
<code class="comments">// outputs </code>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;vector> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch[80]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Enter input from user&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// - 4 for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin >> a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get input from user - </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// "GeeksforGeeks" for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin.getline(ch,80); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints 4 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing string : This does&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not print string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ch &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>4
GeeksforGeeks
</pre>
Output:
<pre>
4
</pre>
In both the above codes, the output is not printed as desired. 
Reason to this is an occupied Buffer. 
The &#8220;\n&#8221; character goes remains there in buffer and read as next input.
 <br />
<strong>How can it be resolved?</strong>
<strong>In case of C :</strong>
<ol>
<li><strong>Using “ while ((getchar()) != &#8216;\n&#8217;); ” </strong>: Typing “while ((getchar()) != &#8216;\n&#8217;);” reads the buffer characters till the end and discards them(including newline)  and using it after the “scanf()” statement clears the input buffer and allows the input in the desired container.
<code class="comments">// C Code to explain why adding&nbsp; </code>
<code class="comments">// "while ( (getchar()) != '\n');" </code>
<code class="comments">// after "scanf()" statement&nbsp; </code>
<code class="comments">// flushes the input buffer </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[80], ch; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scan input from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksforGeeks for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// flushes the standard input </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (clears the input buffer) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">((</code><code class="functions bold">getchar</code><code class="plain">()) != </code><code class="string">'\n'</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scan character from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 'a' for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ch = </code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing character array,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// prints “GeeksforGeeks”) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing character a: It&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// will print 'a' this time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>GeeksforGeeks
a
</pre>
Output:
          
<pre>
GeeksforGeeks
a
</pre></li></ol>
<ol start="2">
<li><strong>Using “ fflush(stdin) ” </strong>: Typing “fflush(stdin)” after “scanf()” statement also clears the input buffer but use of it is avoided and is termed to be “undefined” for input stream as per the C++11 standards.</li>
</ol>
<strong>In case of C++ :</strong>
<ol>
<li><strong>Using  “ cin.ignore(numeric_limits::max(),&#8217;\n&#8217;); ” </strong>:- Typing “cin.ignore(numeric_limits::max(),&#8217;\n&#8217;);” after the “cin” statement discards everything in the input stream including the newline.
<code class="comments">// C++ Code to explain how&nbsp; </code>
<code class="comments">// "cin.ignore(numeric_limits </code>
<code class="comments">// &lt;streamsize>::max(),'\n');"&nbsp; </code>
<code class="comments">// discards the input buffer </code>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// for &lt;streamsize> </code>
<code class="preprocessor">#include&lt;ios>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// for numeric_limits </code>
<code class="preprocessor">#include&lt;limits>&nbsp; </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[80]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Enter input from user </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// - 4 for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin >> a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// discards the input buffer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin.ignore(numeric_limits&lt;streamsize>::max(),</code><code class="string">'\n'</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get input from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksforGeeks for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin.getline(str, 80); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints 4 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing string : This </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// will print string now </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>4
GeeksforGeeks
</pre>
Output:
<pre>
4
GeeksforGeeks
</pre></li></ol>
<ol start="2">
<li><strong>Using  “ cin.sync() ” : </strong> Typing “cin.sync()” after the “cin” statement discards all that is left in buffer. 
Though “cin.sync()” <strong>does not work</strong> in all implementations (According to C++11 and above standards).
<code class="comments">// C++ Code to explain how " cin.sync();"&nbsp; </code>
<code class="comments">// discards the input buffer </code>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;ios>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="preprocessor">#include&lt;limits>&nbsp; </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[80]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Enter input from user </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// - 4 for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin >> a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Discards the input buffer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin.sync(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get input from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksforGeeks for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin.getline(str, 80); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints 4 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing string - this&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// will print string now </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>
4
GeeksforGeeks
</pre>
Output:
<pre>
4
</pre></li></ol>
<ol start="3">
<li><strong>Using “ cin &gt;&gt; ws ” :</strong> Typing “cin&gt;&gt;ws” after “cin” statement tells the compiler to ignore buffer and also to discard all the whitespaces before the actual content of string or character array.
<code class="comments">// C++ Code to explain how "cin >> ws"&nbsp; </code>
<code class="comments">// discards the input buffer along with&nbsp; </code>
<code class="comments">// initial white spaces of string </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;vector>&nbsp; </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">string s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Enter input from user - </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 4 for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin >> a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Discards the input buffer and </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// intial white spaces of string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cin >> ws; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get input from user -&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// GeeksforGeeks for example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">getline(cin, s); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints 4 and GeeksforGeeks :&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// will execute print a and s </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; s &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>
4
GeeksforGeeks
</pre>
Output:
<pre>
4
GeeksforGeeks
</pre></li></ol>
<h2>scanf() and fscanf() in C &#8211; Simple Yet Poweful</h2>
Many of us know the traditional uses of scanf. 
Well, here are some of the lesser known facts
How to read only a part of the input that we need? For example, consider some input stream that contains only characters followed by an integer or a float. 
And we need to scan only that integer or float.<br />
That is ,<br />
Input: &#8220;this is the value 100&#8221;,<br />
Output: value read is 100
Input : &#8220;this is the value 21.2&#8221;,<br />
Output : value read is 21.2<br/>
<code class="comments">/* C program to demonstrate that we can </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">ignore some string in scanf() */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"This is the value %d"</code><code class="plain">, &a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Input value read : a = %d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Input&nbsp; : This is the value 100 </code>
<code class="comments">// Output : Input value read : a = 100 </code>
Now, assume we don&#8217;t know what the preceding characters are but we surely know that the last value is an integer. 
How can we scan the last value as an integer? 
Below solution works only if input string has no spaces.
<code class="comments">/* Sample C program to demonstrate use of *s */</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%*s %d"</code><code class="plain">, &a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Input value read : a=%d"</code><code class="plain">,a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Input: "blablabla 25" </code>
<code class="comments">// Output: Value read : 25 </code>
<strong>Explanation</strong>: The %*s in scanf is used to ignore some input as required. 
In this case, it ignores the input until the next space or new line. 
Similarly if you write %*d it will ignore integers until the next space or new line. 
The above fact may not seem as an useful trick at the first glance. 
Inorder to understand its usage, let us first see fscanf().
<strong>fscanf() : </strong> Tired of all the clumpsy syntax to read from files? well, fscanf comes to the rescue. 
<pre>
int fscanf(FILE *ptr, const char *format, ...) </pre>
fscanf reads from a file pointed by the FILE pointer (ptr), instead of reading from the input stream.
Consider the following text file abc.txt 
<pre>
NAME    AGE   CITY
abc     12    hyderbad
bef     25    delhi
cce     65    bangalore  </pre>
Now, we want to read only the city field of the above text file, ignoring all the other fields. 
A combination of fscanf and the trick mentioned above does this with ease
<code class="comments">/*c program demonstrating fscanf and its usage*/</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code><code class="plain">* ptr = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"abc.txt"</code><code class="plain">,</code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ptr==NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"no such file."</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Assuming that abc.txt has content in below </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">format </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">NAME&nbsp;&nbsp;&nbsp; AGE&nbsp;&nbsp; CITY </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">abc&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp; hyderbad </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">bef&nbsp;&nbsp;&nbsp;&nbsp; 25&nbsp;&nbsp;&nbsp; delhi </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">cce&nbsp;&nbsp;&nbsp;&nbsp; 65&nbsp;&nbsp;&nbsp; bangalore */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code><code class="plain">* buf[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(</code><code class="functions bold">fscanf</code><code class="plain">(ptr,</code><code class="string">"%*s %*s %s "</code><code class="plain">,buf)==1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, buf); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
CITY
hyderbad
delhi
bangalore </pre>
<strong>Exercise:</strong> Count the number of words, characters and lines in a file using fscanf!
<h2>getchar_unlocked() &#8211; faster input in C/C++ for Competitive Programming</h2>
<a href="http://linux.die.net/man/3/getchar_unlocked">getchar_unlocked()</a> is similar to getchar() with the exception that it is not thread safe. 
 Below is an example code.
<code class="comments">// A simple C program to demonstrate </code>
<code class="comments">// working of getchar_unlocked() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Syntax is same as getchar() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">c = getchar_unlocked(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Entered character is %c"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre>
Input: g
Output: Entered character is g </pre>
Following are some important points:
<ol>
<li>Since it is not thread safe, all overheads of mutual exclusion are avoided and it is faster than getchar().</li>
<li> Can be especially useful for competitive programming problems with “<em>Warning: Large I/O data, be careful with certain languages (though most should be OK if the algorithm is well designed)</em>”.
<li> There is no issue with using getchar_unlocked() even in multithreaded environment as long as the thread using it is the only thread accessing file object</li>
<li> One more difference with getchar() is, it is not a C standard library function, but a POSIX function. 
It may not work on Windows based compilers. 
</li>
<li><em><strong>It is a known fact than scanf() is faster than cin and getchar() is faster than scanf() in general. 
getchar_unlocked() is faster than getchar(), hence fastest of all.</strong></em></li>
<li> Similarly, there are getc_unlocked()  putc_unlocked(), and putchar_unlocked() which are non-thread-safe versions of getc(), putc() and putchar() respectively.
<code class="comments">// A simple C program to demonstrate </code>
<code class="comments">// working of putchar_unlocked() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Syntax is same as getchar() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">c = getchar_unlocked(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">putchar_unlocked(c); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre>
Input: g
Output: g
</pre></li></ol>
As an exercise, the readers may try solutions given <a href="https://www.geeksforgeeks.org/fast-io-for-competitive-programming/">here</a> with getchar_unlocked() and compare performance with getchar(). 

<h2>Problem with scanf() when there is fgets()/gets()/scanf() after it</h2>
Consider below simple program in C. 
The program reads an integer using scanf(), then reads a string using fgets().
<code class="comments">// C program to demonstrate the problem when </code>
<code class="comments">// fgets()/gets() is used after scanf() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fgets</code><code class="plain">(str, 100, stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, str = %s"</code><code class="plain">, x, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input
<pre>10
test</pre>
Output: 
<pre>x = 10, str =  </pre>
The problem with above code is scanf() reads an integer and leaves a newline character in buffer. 
So fgets() only reads newline and the string &#8220;test&#8221; is ignored by the program.
The similar problem occurs when scanf() is used in a loop.
<code class="comments">// C program to demonstrate the problem when </code>
<code class="comments">// scanf() is used in a loop </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"......Enter q to quit......\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">do</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a character\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, &c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c\n"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(c != </code><code class="string">'q'</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input
<pre>a
b
q</pre>
Output: 
<pre>......Enter q to quit......
Enter a character
a
Enter a character
Enter a character
b
Enter a character
Enter a character
q</pre>
We can notice that above program prints an extra &#8220;Enter a character&#8221; followed by an extra new line. 
This happens because every scanf() leaves a newline character in buffer that is read by next scanf.
<strong>How to solve above problem?</strong>
<ol>
<li> We can make scanf() to read a new line by using an extra &#8220;\n&#8221;, i.e., <strong>scanf(&#8220;%d\n&#8221;, &#038;x) </strong>. 
In fact <strong>scanf(&#8220;%d &#8220;, &#038;x) </strong> also works (Note extra space).</li>
<li> We can add a getchar() after scanf() to read an extra newline.</li>
</ol>
<strong>See <a href="https://ide.geeksforgeeks.org/nnfP2h">this</a> and <a href="https://ide.geeksforgeeks.org/BAD6dR">this</a> for corrected programs.</strong>
Same <a href="https://www.geeksforgeeks.org/difference-between-scanner-and-bufferreader-class-in-java/">problem occurs with Scanner in Java when nextLine() is used after nextXXX()</a>.
<h2>Differentiate printable and control character in C ?</h2>
Given a character we need to find if it printable or not. 
We also need to find if it is control character or not. 
A character is known as printable character if it occupies printing space.<br />
For the standard ASCII character set (used by the &#8220;C&#8221; locale), control characters are those between ASCII codes 0x00 (NUL) and 0x1f (US), plus 0x7f (DEL).
Examples:
<pre>
Input : a
Output :a is printable character
        a is not control character
        
Input :\r
Output : is not printable character
         is control character
</pre>
To find the difference between a printable character and a control character we can use some predefined functions, which are declared in the &#8220;ctype.h&#8221; header file. 

The i<strong>sprint()</strong> function checks whether a character is a printable character or not. 
isprint() function takes single argument in the form of an integer and returns a value of type int. 
We can pass a char type argument internally they acts as a int by specifying ASCII value.
The <strong>iscntrl()</strong> function is used to checks whether a character is a control character or not. 
iscntrl() function also take a single argument and return an integer.
<code class="comments">// C program to illustrate isprint() and iscntrl() functions. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch = </code><code class="string">'a'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(isprint(ch)) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c is printable character\n"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c is not printable character\n"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">iscntrl</code><code class="plain">(ch)) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c is control character\n"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c is not control character"</code><code class="plain">, ch); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
a is printable character
a is not control character
</pre>
<h2>rand() and srand() in C/C++</h2>
<p align="center"><strong>rand ()</strong>
rand() function is used in C to generate random numbers. 
If we generate a sequence of random number with rand() function, it will create the same sequence again and again every time program runs. 
Say if we are generating 5 random numbers in C with the help of rand() in a loop, then every time we compile and run the program our output must be the same sequence of numbers.<br />
<strong>Syntax:</strong>
<pre>
<b> int rand(void):</b> 
returns a pseudo-random number in the range of 0 to RAND_MAX.
<strong>RAND_MAX:</strong> is a constant whose default value may vary 
between implementations but it is granted to be at least 32767.</pre>
<br/>
<code class="comments">// C program to generate random numbers </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This program will create same sequence of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// random numbers on every program run&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i&lt;5; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code><code class="plain">, </code><code class="functions bold">rand</code><code class="plain">()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>NOTE:</b> This program will create same sequence of random numbers on every program run.<br />
Output 1:
<pre>453 1276 3425 89</pre>
Output 2:
<pre>453 1276 3425 89</pre>
Output n:
<pre>453 1276 3425 89</pre>
<p align="center"><strong>srand()</strong>
The srand() function sets the starting point for producing a series of pseudo-random integers. 
If srand() is not called, the rand() seed is set as if srand(1) were called at program start. 
Any other value for seed sets the generator to a different starting point.<br />
<strong>Syntax:</strong>
<pre><b>void srand( unsigned seed ):</b> 
Seeds the pseudo-random number generator used by rand() 
with the value seed.</pre>
<b>Note:</b> The pseudo-random number generator should only be seeded once, before any calls to rand(), and the start of the program. 
It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.<br />
Standard practice is to use the result of a call to <b>srand(time(0))</b> as the seed. 
However, time() returns a time_t value which vary everytime and hence the pseudo-random number vary for every program call.
<code class="comments">// C program to generate random numbers </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include&lt;time.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This program will create different sequence of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// random numbers on every program run&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Use current time as seed for random generator </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">srand</code><code class="plain">(</code><code class="functions bold">time</code><code class="plain">(0)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i&lt;5; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code><code class="plain">, </code><code class="functions bold">rand</code><code class="plain">()); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>NOTE:</b> This program will create different sequence of random numbers on every program run.<br />
Output 1:
<pre>453 1432 325 89</pre>
Output 2:
<pre>8976 21234 45 8975</pre>
Output n:
<pre>563 9873 12321 24132</pre>
<p align="center"><strong>How srand() and rand() are related to each other?</strong>
srand() sets the seed which is used by rand to generate &#8220;random&#8221; numbers. 
If you don&#8217;t call srand before your first call to rand, it&#8217;s as if you had called srand(1) to set the seed to one.<br />
In short, <strong>srand() — Set Seed for rand() Function</strong>.<br />
&nbsp;
<h2>Operators in C | Set 1 (Arithmetic Operators)</h2>
<img src="https://www.geeksforgeeks.org/wp-content/uploads/Operators-In-C.png" alt="">
Operators are the foundation of any programming language. 
Thus the functionality of C language is incomplete without the use of operators. 
Operators allow us to perform different kinds of operations on operands. 
In C, operators in Can be categorized in following categories: <!--more--> 
<ul>
<li><strong>Arithmetic Operator</strong>s (+, -, *, /, %, post-increment, pre-increment, post-decrement, pre-decrement)</li>
<li><strong>Relational Operators</strong> (==, !=, &gt;, &lt;, &gt;= &amp; &lt;=) Logical Operators (&amp;&amp;, || and !) </li>
<li><strong>Bitwise Operators </strong>(&amp;, |, ^, ~, &gt;&gt; and &lt;&lt;)</li>
<li><strong>Assignment Operator</strong>s (=, +=, -=, *=, etc)</li>
<li><strong>Other Operators</strong> (conditional, comma, sizeof, address, redirecton)</li>
</ul>
<strong>Arithmetic Operators:</strong> These are used to perform arithmetic/mathematical operations on operands. 
The binary operators falling in this category are:
<ul>
<ul>
<li><strong>Addition:</strong> The <strong>&#8216;+&#8217;</strong> operator adds two operands. 
For example, <strong>x+y</strong>.</li>
<li><strong>Subtraction:</strong> The <strong>&#8216;-&#8216;</strong> operator subtracts two operands. 
For example, <strong>x-y</strong>.</li>
<li><strong>Multiplication:</strong> The <strong>&#8216;*&#8217;</strong> operator multiplies two operands. 
For example, <strong>x*y</strong>.</li>
<li><strong>Division:</strong> The <strong>&#8216;/&#8217;</strong> operator divides the first operand by the second. 
For example, <strong>x/y</strong>.</li>
<li><strong>Modulus:</strong> The <strong>&#8216;%&#8217;</strong> operator returns the remainder when first operand is divided by the second. 
For example, <strong>x%y</strong>.</li>
</ul>
</ul>
<h3>C</h3>
<code class="comments">// C program to demonstrate working of binary arithmetic operators </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, res; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing a and b </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and b is %d\n"</code><code class="plain">, a, b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a + b; </code><code class="comments">// addition </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a+b is %d\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a - b; </code><code class="comments">// subtraction </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a-b is %d\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a * b; </code><code class="comments">// multiplication </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a*b is %d\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a / b; </code><code class="comments">// division </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a/b is %d\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a % b; </code><code class="comments">// modulus </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a%b is %d\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, res;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing a and b&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;</code><code class="string">"a is "</code><code class="plain">&lt;&lt;a&lt;&lt;</code><code class="string">" and b is "</code><code class="plain">&lt;&lt;b&lt;&lt;</code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// addition </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a + b;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a+b is: "</code><code class="plain">&lt;&lt; res &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// subtraction </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a - b;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a-b is: "</code><code class="plain">&lt;&lt; res &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// multiplication </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a * b;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a*b is: "</code><code class="plain">&lt;&lt; res &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// division&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a / b;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a/b is: "</code><code class="plain">&lt;&lt; res &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// modulus&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a % b;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a%b is: "</code><code class="plain">&lt;&lt; res &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
a is 10 and b is: 4
a+b is: 14
a-b is: 6
a*b is: 40
a/b is: 2
a%b is: 2
</pre>
The ones falling into the category of unary arithmetic operators are:
<ul>
<li><strong>Increment:</strong> The <strong>&#8216;++&#8217;</strong> operator is used to increment the value of an integer. 
When placed before the variable name (also called pre-increment operator), its value is incremented instantly. 
For example, <strong>++x</strong>.<br />
And when it is placed after the variable name (also called post-increment operator), its value is preserved temporarily until the execution of this statement and it gets updated before the execution of the next statement. 
For example, <strong>x++</strong>.</li>
<li><strong>Decrement:</strong> The <strong>&#8216; &#8211; &#8211; &#8216;</strong> operator is used to decrement the value of an integer. 
When placed before the variable name (also called pre-decrement operator), its value is decremented instantly. 
For example, <strong> &#8211; &#8211; x</strong>.<br />
And when it is placed after the variable name (also called post-decrement operator), its value is preserved temporarily until the execution of this statement and it gets updated before the execution of the next statement. 
For example, <strong>x &#8211; &#8211;</strong>.</li>
</ul>
<h3>C</h3>
<code class="comments">// C program to demonstrate working of Unary arithmetic operators </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, res; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// post-increment example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 10 only, a is not updated yet </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and res is %d\n"</code><code class="plain">, a, res); </code><code class="comments">// a becomes 11 now </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// post-decrement example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 11 only, a is not updated yet </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a--; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and res is %d\n"</code><code class="plain">, a, res); </code><code class="comments">// a becomes 10 now </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pre-increment example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 11 now since a is updated here itself </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = ++a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a and res have same values = 11 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and res is %d\n"</code><code class="plain">, a, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pre-decrement example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 10 only since a is updated here itself </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = --a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a and res have same values = 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and res is %d\n"</code><code class="plain">, a, res); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, res; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// post-increment example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 10 only, a is not updated yet </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a becomes 11 now </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is "</code><code class="plain">&lt;&lt;a&lt;&lt;</code><code class="string">" and res is "</code><code class="plain">&lt;&lt;res&lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// post-decrement example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 11 only, a is not updated yet </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = a--; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a becomes 10 now </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is "</code><code class="plain">&lt;&lt;a&lt;&lt;</code><code class="string">" and res is "</code><code class="plain">&lt;&lt;res&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pre-increment example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 11 now since a is updated here itself </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = ++a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a and res have same values = 11 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is "</code><code class="plain">&lt;&lt;a&lt;&lt;</code><code class="string">" and res is "</code><code class="plain">&lt;&lt;res&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pre-decrement example: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// res is assigned 10 only since a is updated here itself </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res = --a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a and res have same values = 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is "</code><code class="plain">&lt;&lt;a&lt;&lt;</code><code class="string">" and res is "</code><code class="plain">&lt;&lt;res&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
a is 11 and res is 10
a is 10 and res is 11
a is 11 and res is 11
a is 10 and res is 10
</pre>
We will soon be discussing other categories of operators in different posts.
To know about <strong>Operator Precedence and Associativity</strong>, refer <a href="https://www.geeksforgeeks.org/c-operator-precedence-associativity/">this </a>link:
<a href="http://quiz.geeksforgeeks.org/c-language-2/operators/">Quiz on Operators in C</a>
<h2>Operators in C | Set 2 (Relational and Logical Operators)</h2>
We have discussed <a href="https://www.geeksforgeeks.org/operators-c-c/"><strong>Introduction to Operators in C </strong></a> where we got an overall idea of what types of Operators, C and C++ support and its basic implementations. 
Following that, we studied <a href="https://www.geeksforgeeks.org/operators-in-c-set-1-arithmetic-operators/"><strong>Arithmetic Operators</strong></a> where we got a detailed understanding of the types and use of Arithmetic operators in C and C++. 
In this article, let&#8217;s try to understand the types and uses of<strong> Relational and Logical Operators</strong>.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Operators-In-C.png" alt="">
<center><strong>Relational Operators</strong></center><br />
Relational operators are used for comparison of two values to understand the type of relationship a pair of number shares. 
For example, less than, greater than, equal to etc. 
Let&#8217;s see them one by one
<ol>
<li><strong>Equal to operator:</strong> Represented as <strong>&#8216;==&#8217;</strong>, the equal to operator checks whether the two given operands are equal or not. 
If so, it returns true. 
Otherwise it returns false. 
For example, <strong>5==5</strong> will return true.</li>
<li><strong>Not equal to operator:</strong> Represented as <strong>&#8216;!=&#8217;</strong>, the not equal to operator checks whether the two given operands are equal or not. 
If not, it returns true. 
Otherwise it returns false. 
It is the exact boolean complement of the <strong>&#8216;==&#8217;</strong> operator. 
For example, <strong>5!=5</strong> will return false.</li>
<li><strong>Greater than operator:</strong> Represented as <strong>&#8216;&gt;&#8217;</strong>, the greater than operator checks whether the first operand is greater than the second operand or not. 
If so, it returns true. 
Otherwise it returns false. 
For example, <strong>6&gt;5</strong> will return true.</li>
<li>Less than operator: Represented as <strong>&#8216;&lt;&#8216;</strong>, the less than operator checks whether the first operand is lesser than the second operand. 
If so, it returns true. 
Otherwise it returns false. 
For example, <strong>6&lt;5</strong> will return false.</li>
<li><strong>Greater than or equal to operator:</strong> Represented as <strong>&#8216;&gt;=&#8217;</strong>, the greater than or equal to operator checks whether the first operand is greater than or equal to the second operand. 
If so, it returns true else it returns false. 
For example, <strong>5&gt;=5</strong> will return true.</li>
<li><strong>Less than or equal to operator: Represented as </strong><strong>&#8216;&lt;=&#8217;</strong>, the less than or equal tooperator checks whether the first operand is less than or equal to the second operand. 
If so, it returns true else false. 
For example, <strong>5&lt;=5</strong> will also return true.</li>
</ol>
<strong>Examples:</strong><br />
<h3>C</h3>
<code class="comments">// C program to demonstrate working of relational operators </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// greater than example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is less than or equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// greater than equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a >= b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than or equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is lesser than b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// less than example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a &lt; b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is less than b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than or equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// lesser than equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a &lt;= b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is lesser than or equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a == b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a and b are not equal\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a != b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is not equal to b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is equal b\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to demonstrate working of logical operators </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// greater than example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is less than or equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// greater than equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a >= b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than or equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is lesser than b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// less than example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a &lt; b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is less than b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than or equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// lesser than equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a &lt;= b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is lesser than or equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a == b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a and b are not equal\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not equal to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a != b) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is not equal to b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is equal b\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
a is greater than b
a is greater than or equal to b
a is greater than or equal to b
a is greater than b
a and b are not equal
a is not equal to b
</pre>
</br>
<center><strong>Logical Operators:</strong></center><br />
They are used to combine two or more conditions/constraints or to complement the evaluation of the original condition under consideration. 
They are described below:
<ol>
<li><strong>Logical AND operator:</strong> The <strong>&#8216;&amp;&amp;&#8217;</strong> operator returns true when both the conditions under consideration are satisfied. 
Otherwise it returns false. 
For example, <strong>a &amp;&amp; b</strong> returns true when both a and b are true (i.e. 
non-zero).</li>
<li><strong>Logical OR operator:</strong> The <strong>&#8216;||&#8217;</strong> operator returns true even if one (or both) of the conditions under consideration is satisfied. 
Otherwise it returns false. 
For example, <strong>a || b</strong> returns true if one of a or b or both are true (i.e. 
non-zero). 
Of course, it returns true when both a and b are true.</li>
<li><strong>Logical NOT operator:</strong> The <strong>&#8216;!&#8217;</strong> operator returns true the condition in consideration is not satisfied. 
Otherwise it returns false. 
For example, <strong>!a</strong> returns true if a is false, i.e. 
when a=0.</li>
</ol>
<strong>Examples:</strong><br />
<h3>C</h3>
<code class="comments">// C program to demonstrate working of logical operators </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, c = 10, d = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical operators </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical AND example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b && c == d) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than b AND c is equal to d\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"AND condition not satisfied\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical AND example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b || c == d) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is greater than b OR c is equal to d\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Neither a is greater than b nor c is equal "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" to d\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical NOT example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(!a) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is zero\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is not zero"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to demonstrate working of </code>
<code class="comments">// logical operators </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4, c = 10, d = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical operators </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical AND example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b && c == d) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than b AND c is equal to d\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"AND condition not satisfied\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical AND example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a > b || c == d) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is greater than b OR c is equal to d\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Neither a is greater than b nor c is equal "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" to d\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical NOT example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(!a) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is zero\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"a is not zero"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
AND condition not satisfied
a is greater than b OR c is equal to d
a is not zero
</pre>
<center><strong>Short-Circuiting in Logical Operators:</strong></center>
<ul>
<li>In case of <strong>logical AND</strong>, the second operand is not evaluated if first operand is false. 
For example, program 1 below doesn&#8217;t print &#8220;GeeksQuiz&#8221; as the first operand of logical AND itself is false.<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a == b) && </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a == b) && cout &lt;&lt; </code><code class="string">"GeeksQuiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
No Output
</pre>
But below program prints &#8220;GeeksQuiz&#8221; as first operand of logical AND is true.<br />
<h3>C</h3>
          
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a != b) && </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a != b) && cout &lt;&lt; </code><code class="string">"GeeksQuiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
GeeksQuiz
</pre>
</li>
&nbsp;
<li>In case of <strong>logical OR</strong>, the second operand is not evaluated if first operand is true. 
For example, program 1 below doesn&#8217;t print &#8220;GeeksQuiz&#8221; as the first operand of logical OR itself is true.<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a != b) || </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a != b) || cout &lt;&lt; </code><code class="string">"GeeksQuiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
No Output
</pre>
But below program prints &#8220;GeeksQuiz&#8221; as first operand of logical OR is false.<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a == b) || </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksQuiz"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">res = ((a == b) || cout &lt;&lt; </code><code class="string">"GeeksQuiz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
GeeksQuiz
</pre>
</li>
</ul>
<a href="http://quiz.geeksforgeeks.org/c-language-2/operators/">Quiz on Operators in C</a>
<h2>Bitwise Operators in C/C++</h2>
In C, the following 6 operators are bitwise operators (work at bit-level)<!--more--> 
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Operators-In-C.png" alt="">
<ol>
<li>The <strong>&amp; (bitwise AND)</strong> in C or C++ takes two numbers as operands and does AND on every bit of two numbers. 
 The result of AND is 1 only if both bits are 1.
</li>
<li>The <strong>| (bitwise OR)</strong> in C or C++ takes two numbers as operands and does OR on every bit of two numbers. 
 The result of OR is 1 if any of the two bits is 1.
</li>
<li>The <strong>^ (bitwise XOR)</strong> in C or C++ takes two numbers as operands and does XOR on every bit of two numbers. 
 The result of XOR is 1 if the two bits are different.
</li>
<li>The <strong>&lt;&lt; (left shift)</strong> in C or C++ takes two numbers, left shifts the bits of the first operand, the second operand decides the number of places to shift.
</li>
<li>The <strong>&gt;&gt; (right shift)</strong> in C or C++ takes two numbers, right shifts the bits of the first operand, the second operand decides the number of places to shift.
</li>
<li>The <strong>~ (bitwise NOT)</strong> in C or C++ takes one number and inverts all bits of it</li></ol>
<strong>Example:</strong><br/>
<code class="comments">// C Program to demonstrate use of bitwise operators </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a = 5(00000101), b = 9(00001001) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">char</code> <code class="plain">a = 5, b = 9; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 00000001 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %d, b = %d\n"</code><code class="plain">, a, b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a&b = %d\n"</code><code class="plain">, a & b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 00001101 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a|b = %d\n"</code><code class="plain">, a | b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 00001100 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a^b = %d\n"</code><code class="plain">, a ^ b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 11111010 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"~a = %d\n"</code><code class="plain">, a = ~a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 00010010 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"b&lt;&lt;1 = %d\n"</code><code class="plain">, b &lt;&lt; 1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The result is 00000100 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"b>>1 = %d\n"</code><code class="plain">, b >> 1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
a = 5, b = 9
a&b = 1
a|b = 13
a^b = 12
~a = 250
b<<1 = 18
b>>1 = 4
</pre>
<p align="center"><strong>Interesting facts about bitwise operators</strong>
<ol>
<li><strong>The left shift and right shift operators should not be used for negative numbers</strong>. 
If any of the operands is a negative number, it results in undefined behaviour. 
For example results of both -1 &lt;&lt; 1 and 1 &lt;&lt; -1 is undefined. 
Also, if the number is shifted more than the size of integer, the behaviour is undefined. 
For example, 1 &lt;&lt; 33 is undefined if integers are stored using 32 bits. 
See <a href="https://wiki.sei.cmu.edu/confluence/display/c/INT34-C.+Do+not+shift+an+expression+by+a+negative+number+of+bits+or+by+greater+than+or+equal+to+the+number+of+bits+that+exist+in+the+operand">this</a> for more details.</li>
<li><strong> The bitwise XOR operator is the most useful operator from technical interview perspective.</strong>  It is used in many problems. 
A simple example could be &#8220;Given a set of numbers where all elements occur even number of times except one number, find the odd occurring number&#8221; This problem can be efficiently solved by just doing XOR of all numbers.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to return the only odd </code>
<code class="comments">// occurring element </code>
<code class="color1 bold">int</code> <code class="plain">findOdd(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">res = 0, i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res ^= arr[i]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">res; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Method </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 12, 12, 14, 90, 14, 14, 14 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="keyword bold">sizeof</code><code class="plain">(arr) / </code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The odd occurring element is %d "</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">findOdd(arr, n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
The odd occurring element is 90
</pre>
The following are many other interesting problems using XOR operator.
<ol style="list-style-type:lower-roman">
<li><a href="https://www.geeksforgeeks.org/find-the-missing-number/">Find the Missing Number</a></li>
<li><a href="https://www.geeksforgeeks.org/swap-two-numbers-without-using-temporary-variable/">swap two numbers without using a temporary variable</a></li>
<li><a href="https://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-1/">A Memory Efficient Doubly Linked List</a></li>
<li><a href="https://www.geeksforgeeks.org/find-two-non-repeating-elements-in-an-array-of-repeating-elements/">Find the two non-repeating elements</a>.</li>
<li><a href="https://www.geeksforgeeks.org/find-the-two-numbers-with-odd-occurences-in-an-unsorted-array/">Find the two numbers with odd occurences in an unsorted-array</a>.</li>
<li><a href="https://www.geeksforgeeks.org/add-two-numbers-without-using-arithmetic-operators/">Add two numbers without using arithmetic operators</a>.</li>
<li><a href="https://www.geeksforgeeks.org/swap-bits-in-a-given-number/">Swap bits in a given number/</a>.</li>
<li><a href="https://www.geeksforgeeks.org/count-number-of-bits-to-be-flipped-to-convert-a-to-b/">Count number of bits to be flipped to convert a to b</a> .</li>
<li><a href="https://www.geeksforgeeks.org/find-the-element-that-appears-once/">Find the element that appears once</a>.</li>
<li> <a href="https://www.geeksforgeeks.org/detect-if-two-integers-have-opposite-signs/">Detect if two integers have opposite signs.</a></li>
</ol>
.
<li><strong>The bitwise operators should not be used in place of logical operators.</strong> The result of logical operators (&amp;&amp;, || and !) is either 0 or 1, but bitwise operators return an integer value. 
Also, the logical operators consider any non-zero operand as 1. 
For example, consider the following program, the results of &amp; and &amp;&amp; are different for same operands.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 2, y = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(x & y) ? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"True "</code><code class="plain">) : </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"False "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(x && y) ? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"True "</code><code class="plain">) : </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"False "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
False True
</pre>
</li>
<li><strong>The left-shift and right-shift operators are equivalent to multiplication and division by 2 respectively.</strong> As mentioned in point 1, it works only if numbers are positive.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 19; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x &lt;&lt; 1 = %d\n"</code><code class="plain">, x &lt;&lt; 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x >> 1 = %d\n"</code><code class="plain">, x >> 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
x << 1 = 38
x >> 1 = 9
</pre>
</li>
<li><strong>The &amp; operator can be used to quickly check if a number is odd or even. 
</strong>The value of expression (x &amp; 1) would be non-zero only if x is odd, otherwise the value would be zero.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 19; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(x & 1) ? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Odd"</code><code class="plain">) : </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Even"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Odd
</pre>
</li>
<li><strong>The ~ operator should be used carefully.</strong> The result of ~ operator on a small number can be a big number if the result is stored in an unsigned variable. 
And the result may be a negative number if the result is stored in a signed variable (assuming that the negative numbers are stored in 2&#8217;s complement form where the leftmost bit is the sign bit)
<code class="comments">// Note that the output of the following </code>
<code class="comments">// program is compiler dependent </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Signed Result %d \n"</code><code class="plain">, ~x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Unsigned Result %ud \n"</code><code class="plain">, ~x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Signed Result -2 
Unsigned Result 4294967294d
</pre>
</li>
<strong>Important Links:</strong> 
<ol>
<li><a href="https://www.geeksforgeeks.org/bits-manipulation-important-tactics/">Bits manipulation (Important tactics)</a></li>
<li><a href="https://www.geeksforgeeks.org/bitwise-hacks-for-competitive-programming/">Bitwise Hacks for Competitive Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/bit-tricks-competitive-programming/">Bit Tricks for Competitive Programming</a></li></ol>
<h2>Operator Precedence and Associativity in C</h2>
<u><strong>Operator precedence</strong></u> determines which operator is performed first in an expression with more than one operators with different precedence.
<b>For example:</b> Solve 
<pre>10 + 20 * 30</pre>
<a href="https://media.geeksforgeeks.org/wp-content/uploads/20190708163349/Operators-Precedence.jpg"><img src="https://media.geeksforgeeks.org/wp-content/uploads/20190708163349/Operators-Precedence.jpg" alt=""></a>

<pre>
<b>10 + 20 * 30</b> is calculated as <b>10 + (20 * 30)</b>
and not as <b>(10 + 20) * 30</b></pre>
<u><b>Operators Associativity</b></u> is used when two operators of same precedence appear in an expression. 
Associativity can be either <strong>L</strong>eft<strong> t</strong>o <strong>R</strong>ight or<strong> R</strong>ight<strong> t</strong>o <strong>L</strong>eft. 
<strong>For example:</strong> &#8216;*&#8217; and &#8216;/&#8217; have same precedence and their associativity is <strong>L</strong>eft<strong> t</strong>o <strong>R</strong>ight, so the expression &#8220;100 / 10 * 10&#8221; is treated as &#8220;(100 / 10) * 10&#8221;.
<a href="https://media.geeksforgeeks.org/wp-content/uploads/20190708164646/Operators-Associativity-1.jpg"><img src="https://media.geeksforgeeks.org/wp-content/uploads/20190708164646/Operators-Associativity-1.jpg" alt=""></a>
<blockquote><b>Operators Precedence and Associativity are two characteristics of operators that determine the evaluation order of sub-expressions in absence of brackets</b></blockquote>
<b>For example:</b> Solve 
<pre>100 + 200 / 10 - 3 * 10</pre>
<a href="https://media.geeksforgeeks.org/wp-content/uploads/20190708173715/Operator-Precedence-and-Associativity-2.jpg"><img src="https://media.geeksforgeeks.org/wp-content/uploads/20190708173715/Operator-Precedence-and-Associativity-2.jpg" alt=""></a>
<strong>1) Associativity is only used when there are two or more operators of same precedence.</strong><br />
The point to note is associativity doesn&#8217;t define the order in which operands of a single operator are evaluated. 
For example, consider the following program, associativity of the + operator is left to right, but it doesn&#8217;t mean f1() is always called before f2(). 
The output of the following program is in-fact compiler dependent. 
See <a href="https://www.geeksforgeeks.org/evaluation-order-of-operands/">this</a> for details.
<code class="comments">// Associativity is not used in the below program. 
</code>
<code class="comments">// Output is compiler dependent. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">x = 0; </code>
<code class="color1 bold">int</code> <code class="plain">f1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">f2()  </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<strong>2) All operators with the same precedence have same associativity</strong><br />
This is necessary, otherwise, there won&#8217;t be any way for the compiler to decide evaluation order of expressions which have two operators of same precedence and different associativity. 
For example + and &#8211; have the same associativity.
<strong>3) Precedence and associativity of postfix ++ and prefix ++ are different</strong><br />
Precedence of postfix ++ is more than prefix ++, their associativity is also different. 
Associativity of postfix ++ is left to right and associativity of prefix ++ is right to left. 
See <a href="https://www.geeksforgeeks.org/difference-between-p-p-and-p/">this</a> for examples.
<strong>4) Comma has the least precedence among all operators and should be used carefully</strong> For example consider the following program, the output is 1. 
See <a href="https://www.geeksforgeeks.org/a-comma-operator-question/">this</a> and <a href="https://www.geeksforgeeks.org/comna-in-c-and-c/">this</a> for more details.
          
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 1, 2, 3; </code><code class="comments">// Evaluated as (a = 1), 2, 3 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<strong>5) There is no chaining of comparison operators in C</strong><br />
In Python, expression like &#8220;c &gt; b &gt; a&#8221; is treated as &#8220;c &gt; b and b &gt; a&#8221;, but this type of chaining doesn&#8217;t happen in C. 
For example consider the  following program. 
The output of following program is &#8220;FALSE&#8221;. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20, c = 30; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (c > b > a) is treated as ((c  > b) > a), associativity of '>' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// is left to right. 
Therefore the value becomes ((30 > 20) > 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// which becomes (1 > 20) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(c > b > a) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"TRUE"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"FALSE"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Please see the following precedence and associativity table for reference.
<table width="90%" border="1" cellspacing="0" cellpadding="2">
<tbody>
<tr> 
<th>
<p align="center"><b>Operator</b>
</th>
<th><b>Description</b></th>
<th> 
<p align="center"><b>Associativity</b>
</th>
</tr>
<tr>
<td align="center"><span style="font-size: small">( )<br />
[ ]<br />
.<br />
-&gt;<br />
++ &#8212;</span></td>
<td><span style="font-size: small">Parentheses (function call) (see Note 1)<br />
Brackets (array subscript)<br />
Member selection via object name<br />
Member selection via pointer<br />
Postfix increment/decrement (see Note 2)</span></td>
<td valign="top">
<p align="center"><span style="font-size: small">left-to-right</span>
</td>
</tr>
<tr> 
<td align="center"><span><span style="font-size: small"><span>++ &#8212;<br />
+ &#8211;<br />
! ~<br />
(<i>type</i>)<br />
*<br />
&amp;<br />
sizeof</span> </span></span></td>
<td><span style="font-size: small">Prefix increment/decrement<br />
Unary plus/minus<br />
Logical negation/bitwise complement<br />
Cast (convert value to temporary value of <i>type</i>)<br />
Dereference<br />
Address (of operand)<br />
Determine size in bytes on this implementation</span></td>
<td align="center" valign="top"><span style="font-size: small">right-to-left</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">*  /  %</span></td>
<td><span style="font-size: sma ll">Multiplication/division/modulus</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">+  &#8211;</span></td>
<td><span style="font-size: small">Addition/subtraction</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">&lt;&lt;  &gt;&gt;</span></td>
<td><span style="font-size: small">Bitwise shift left, Bitwise shift right</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">&lt;  &lt;=<br />
&gt;  &gt;=</span></td>
<td><span style="font-size: small">Relational less than/less than or equal to<br />
Relational greater than/greater  than or equal to</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">==  !=</span></td>
<td><span style="font-size: small">Relational is equal to/is not equal to</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">&amp;</span></td>
<td><span style="font-size: small">Bitwise AND</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">^</span></td>
<td><span style="font-size: small">Bitwise exclusive OR</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">|</span></td>
<td><span style="font-size: small">Bitwise inclusive OR</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">&amp;&amp;</span></td>
<td><span style="font-size: small">Logical AND</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">| |</span></td>
<td><span style="font-size: small">Logical OR</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">? :</span></td>
<td><span style="font-size: small">Ternary conditional</span></td>
<td align="center" valign="top"><span style="font-size: small">right-to-left</span></td>
</tr>
<tr>
<td align="center"><span style="font-size: small">=<br />
+=  -=<br />
*=  /=<br />
%=  &amp;=<br />
^=  |=<br />
&lt;&lt;=  &gt;&gt;=</span></td>
<td><span style="font-size: small">Assignment<br />
Addition/subtraction assignment<br />
Multiplication/division assignment<br />
Modulus/bitwise AND assignment<br />
Bitwise exclusive/inclusive OR assignment<br />
Bitwise shift left/right assignment</span></td>
<td align="center" valign="top"><span style="font-size: small">right-to-left</span></td>
</tr>
<tr>
<td>
<p align="center"><span style="font-size: small">, </span>
</td>
<td><span style="font-size: small">Comma (separate expressions)</span></td>
<td align="center" valign="top"><span style="font-size: small">left-to-right</span></td>
</tr>
</tbody>
</table>
It is good to know precedence and associativity rules, but the best thing is to use brackets, especially for less commonly used operators (operators other than +, -, *.. 
etc). 
Brackets increase the readability of the code as the reader doesn&#8217;t have to see the table to find out the order.
<h2>Evaluation order of operands</h2>
Consider the below program. 
<!--more--><br />
<h3>C++</h3>
<code class="comments">// C++ implementation </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">x = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">f1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">f2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; (</code><code class="string">"%d "</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">x = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">f1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">f2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">x = </code><code class="value">0</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">f1() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = </code><code class="value">5</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">f2() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = </code><code class="value">10</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.printf(</code><code class="string">"%d "</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Rajput-Ji </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python3 implementation of the above approach&nbsp; </code>
<code class="keyword">class</code> <code class="plain">A(): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x </code><code class="keyword">=</code> <code class="value">0</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">def</code> <code class="plain">f1(): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">A.x </code><code class="keyword">=</code> <code class="value">5</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">A.x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">def</code> <code class="plain">f2(): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">A.x </code><code class="keyword">=</code> <code class="value">10</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">A.x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="comments"># Driver Code </code>
<code class="plain">p </code><code class="keyword">=</code> <code class="plain">A.f1() </code><code class="keyword">+</code> <code class="plain">A.f2(); </code>
<code class="functions">print</code><code class="plain">(A.x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed by mits </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# implementation of the above approach </code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">x = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">f1() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">f2() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main(String[] args) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.WriteLine(</code><code class="string">"{0} "</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code has been contributed </code>
<code class="comments">// by 29AjayKumar </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP implementation of the above approach&nbsp; </code>
<code class="variable">$x</code> <code class="plain">= 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">function</code> <code class="plain">f1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">global</code> <code class="variable">$x</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$x</code> <code class="plain">= 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="variable">$x</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">function</code> <code class="plain">f2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">global</code> <code class="variable">$x</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$x</code> <code class="plain">= 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="variable">$x</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="variable">$p</code> <code class="plain">= f1() + f2(); </code>
<code class="functions">print</code><code class="plain">(</code><code class="variable">$x</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by mits </code>
<code class="plain">?> </code>
<br />
<b>Output:</b>
<pre>10</pre>
What would the output of the above program &#8211; &#8216;5&#8217; or &#8217;10&#8217;?<br />
The output is undefined as the order of evaluation of f1() + f2() is not mandated by standard. 
The compiler is free to first call either f1() or f2(). 
Only when equal level precedence operators appear in an expression, the associativity comes into picture. 
For example, f1()  +  f2()  +  f3() will be considered as (f1()  +  f2())  +  f3(). 
But among first pair, which function (the operand) evaluated first is not defined by the standard. 

Thanks to Venki for suggesting the solution.
<h2>Comma in C and C++</h2>
In C and C++, comma (, ) can be used in two contexts: <!--more-->
1) Comma as an operator:<br />
The comma operator (represented by the token, ) is a binary operator that evaluates its first operand and discards the result, it then evaluates the second operand and returns this value (and type). 
The comma operator has the lowest precedence of any C operator, and acts as a <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence point</a>. 
<code class="comments">/* comma as an operator */</code>
<code class="color1 bold">int</code> <code class="plain">i = (5, 10); </code><code class="comments">/* 10 is assigned to i*/</code>
<code class="color1 bold">int</code> <code class="plain">j = (f1(), f2()); </code><code class="comments">/* f1() is called (evaluated) first followed by f2().&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">The returned value of f2() is assigned to j */</code>
2) Comma as a separator:<br />
Comma acts as a separator when used with function calls and definitions, function like macros, variable declarations, enum declarations, and similar constructs.<br/>
<code class="comments">/* comma as a separator */</code>
<code class="color1 bold">int</code> <code class="plain">a = 1, b = 2; </code>
<code class="keyword bold">void</code> <code class="plain">fun(x, y); </code>
The use of comma as a separator should not be confused with the use as an operator. 
For example, in below statement, f1() and f2() can be called in any order. 
<code class="comments">/* Comma acts as a separator here and doesn't enforce any sequence.&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">Therefore, either f1() or f2() can be called first */</code>
<code class="keyword bold">void</code> <code class="plain">fun(f1(), f2()); </code>
See <a href="https://www.ibm.com/support/knowledgecenter/SSGH3R_16.1.0/com.ibm.xlcpp161.aix.doc/language_ref/co.html">this</a> for C vs C++ differences of using comma operator.
You can try below programs to check your understanding of comma in C.
<code class="comments">// PROGRAM 1 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y = 15; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, (x, y)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// PROGRAM 2:&nbsp; Thanks to Shekhu for suggesting this program </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y = (x++, ++x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// PROGRAM 3:&nbsp; Thanks to Venki for suggesting this program </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10, y; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The following is equivalent </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to y = x + 2 and x += 3, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// with two printings </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">y = (x++, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d\n"</code><code class="plain">, x), </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++x, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d\n"</code><code class="plain">, x), </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x++); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that last expression is evaluated </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// but side effect is not updated to y </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"y = %d\n"</code><code class="plain">, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d\n"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
3) Comma operator in place of a semicolon.<br />
We know that in C and C++, every statement is terminated with a semicolon but comma operator also used to terminate the statement after satisfying the following rules.
<ul>
<li>The variable declaration statements must be terminated with semicolon.</li>
<li>The statements after declaration statement can be terminated by comma operator.</li>
<li>The last statement of the program must be terminated by semicolon.</li>
</ul>
<strong>Examples:</strong>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"First Line\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Second Line\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Third Line\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Last line"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
First Line
Second Line
Third Line
Last line
</pre>
<h2>sizeof operator in C</h2>
<strong><em>Sizeof</em></strong>  is a much used operator in the <a href="https://www.geeksforgeeks.org/c-programming-language/">C or C++</a>. 
It is a compile time unary operator which can be used to compute the size of its operand. 
<!--more-->The result of sizeof is of unsigned integral type which is usually denoted by size_t. 
sizeof can be applied to any data-type, including primitive types such as integer and floating-point types, pointer types, or compound datatypes such as Structure, union etc.
</br><br />
<strong>Usage</strong><br />
<em>sizeof()</em> operator is used in different way according to the operand type.

<strong>1.</strong> When operand is a Data Type.<br />
When <em>sizeof()</em> is used with the data types such as int, float, char&#8230; etc it simply returns the amount of memory is allocated to that data types.
Let&#8217;s see example:<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">double</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">double</code><code class="plain">)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
1
4
4
8
</pre>
<strong>Note</strong>: sizeof() may give different output according to machine, we have run our program on 32 bit gcc compiler.
<strong>2.</strong> When operand is an expression.<br />
When <em>sizeof()</em> is used with the expression, it returns size of the expression. 
Let see example:<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">d = 10.21; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(a + d)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">d = 10.21; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(a + d)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
8
</pre>
As we know from first case size of int and double is 4 and 8 respectively, a is int variable while d is a double variable. 
The final result will be a double, Hence the output of our program is 8 bytes.
</br>
<strong>Need of Sizeof</strong><br />
<strong>1.</strong> To find out number of elements in a array.<br />
Sizeof can be used to calculate number of elements of the array automatically. 
Let see Example :<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 7, 98, 0, 12, 35, 99, 14 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Number of elements:%lu "</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(arr) / </code><code class="keyword bold">sizeof</code><code class="plain">(arr[0])); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 7, 98,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">0, 12, 35, 99, 14 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Number of elements: "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt;(</code><code class="keyword bold">sizeof</code><code class="plain">(arr) / </code><code class="keyword bold">sizeof</code><code class="plain">(arr[0])); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Number of elements: 11
</pre>
<strong>2.</strong> To <a href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/">allocate a block of memory dynamically</a>.<br />
sizeof is greatly used in dynamic memory allocation. 
For example, if we want to allocate memory for which is sufficient to hold 10 integers and we don&#8217;t know the sizeof(int) in that particular machine. 
We can allocate with the help of sizeof.
<code class="color1 bold">int</code><code class="plain">* ptr = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(10 * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<h2>Operands for sizeof operator</h2>
In C, sizeof operator works on following kind of operands: <!--more-->
1) <em>type-name</em>:  type-name must be specified in parentheses.
<code class="keyword bold">sizeof</code> <code class="plain">(type-name)&nbsp; </code>
2) <em>expression</em>:  expression can be specified with or without the parentheses. 
<br/>
<code class="keyword bold">sizeof</code> <code class="plain">expression </code>
The expression is used only for getting the type of operand and not evaluated. 
For example, below code prints value of i as 5.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 5; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">int_size = </code><code class="keyword bold">sizeof</code><code class="plain">(i++); </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n size of i = %d"</code><code class="plain">, int_size); </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Value of i = %d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output of the above program:<br />
size of i   =  depends on compiler<br />
value of i = 5 
<h2>A comma operator question</h2>
Consider the following C programs.<!--more-->
<code class="comments">// PROGRAM 1 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 1, 2, 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The above program fails in compilation, but the following program compiles fine and prints 1.
<code class="comments">// PROGRAM 2 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 1, 2, 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
And the following program prints 3, why?<br/>
<code class="comments">// PROGRAM 3 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = (1, 2, 3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
In a C/C++ program, comma is used in two contexts:  (1) A separator (2) An Operator. 
(See <a href="https://www.geeksforgeeks.org/comna-in-c-and-c/">this </a>for more details). 
Comma works just as a separator in PROGRAM 1 and we get compilation error in this program. 
Comma works as an operator in PROGRAM 2. 
<a href="https://www.geeksforgeeks.org/g-fact-41/">Precedence of comma operator is least in operator precedence table</a>. 
So the assignment operator takes precedence over comma and the expression &#8220;a = 1, 2, 3&#8221; becomes equivalent to &#8220;(a = 1), 2, 3&#8221;. 
That is why we get output as 1 in the second program. 
In PROGRAM 3, brackets are used so comma operator is executed first and we get the output as 3 (See <a href="http://en.wikipedia.org/wiki/Comma_operator">the Wiki page</a> for more details). 
<h2>Result of comma operator as l-value in C and C++</h2>
Using result of comma operator as l-value is not valid in C. 
But in C++, result of comma operator can be used as l-value if the right operand of the comma operator is l-value.<!--more-->
For example, if we compile the following program as a C++ program, then it works and prints b = 30. 
And if we compile the same program as C program, then it gives warning/error in compilation (Warning in Dev C++ and error in Code Blocks).
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">(a, b) = 30; </code><code class="comments">// Since b is l-value, this statement is valid in C++, but not in C. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"b = %d"</code><code class="plain">, b); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
C++ Output:<br />
<em>b = 30</em> 
<h2>Order of operands for logical operators</h2>
The order of operands of logical operators &amp;&amp;, || are important in C/C++.<!--more-->
In mathematics, logical AND, OR, etc&#8230; operations are commutative. 
The result will not change even if we swap RHS and LHS of the operator.
In C/C++ (may be in other languages as well)  even though these operators are commutative, their order is critical. 
For example see the following code,<br/>
<code class="comments">// Traverse every alternative node </code>
<code class="keyword bold">while</code><code class="plain">( pTemp && pTemp->Next ) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Jump over to next node </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">pTemp = pTemp->Next->Next; </code>
<code class="plain">} </code>
The first part <em>pTemp</em> will be evaluated against NULL and followed by <em>pTemp-&gt;Next</em>. 
If <em>pTemp-&gt;Next </em>is placed first, the pointer <em>pTemp</em> will be dereferenced and there will be runtime error when <em>pTemp</em> is NULL.
It is mandatory to follow the order. 
Infact, it helps in generating efficient code. 
When the pointer <em>pTemp</em> is NULL, the second part will not be evaluated since the outcome of AND (&amp;&amp;) expression is guaranteed to be 0.
<h2>Increment (Decrement) operators require L-value Expression</h2>
What will be the output of the following program? <!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, ++(-i)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>A) <span style="color: #ff0000">11</span> B) <span style="color: #ff0000">10</span> C) <span style="color: #ff0000">-9</span> D) <span style="color: #ff0000">None</span></pre>
<strong>Answer:</strong> D, None &#8211; Compilation Error.
<strong>Explanation:</strong>
In C/C++ the pre-increment (decrement) and the post-increment (decrement) operators require an L-value expression as operand. 
Providing an <a href="http://en.wikipedia.org/wiki/Value_(computer_science)">R-value</a> or a <em>const</em> qualified variable results in compilation error.
In the above program, the expression <em>-i</em> results in R-value which is operand of pre-increment operator. 
The pre-increment operator requires an L-value as operand, hence the compiler throws an error.
The increment/decrement operators needs to update the operand after the <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence point</a>, so they need an L-value. 
The unary operators such as -, +, won&#8217;t need L-value as operand. 
The expression <em>-(++i)</em> is valid.
In C++ the rules are little complicated because of references. 
We can apply these pre/post increment (decrement) operators on references variables that are not qualified by <em>const</em>. 
References can also be returned from functions.
<h2>Precedence of postfix ++ and prefix ++ in C/C++</h2>
In C/C++, precedence of Prefix ++ (or Prefix &#8211;) has higher priority than dereference (*) operator, and precedence of Postfix ++ (or Postfix &#8211;) is higher than both Prefix ++ and *. 
<!--more-->
If p is a pointer then *p++ is equivalent to *(p++) and ++*p is equivalent to ++(*p) (both Prefix ++ and * are right associative).
For example, program 1 prints <em>&#8216;h&#8217;</em> and program 2 prints <em>&#8216;e&#8217;</em>.<br/>
<code class="comments">// Program 1 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[] = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">++*p; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %c"</code><code class="plain">, *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>  h</pre>
<code class="comments">// Program 2 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[] = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*p++; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %c"</code><code class="plain">, *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>  e</pre>
<h2>Modulus on Negative Numbers</h2>
What will be the output of the following C program? 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 3, b = -8, c = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a % b / c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
<pre>1</pre>
% and / have same precedence and left to right associativity. 
So % is performed first which results in 3 and / is performed next resulting in 1. 
The emphasis is, <strong><em>sign of left operand is appended to result</em></strong><strong><em> in case of modulus operator in C</em></strong>.<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// a positive and b negative. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 3, b = -8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a % b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
<pre>3</pre>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// a negative and b positive </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = -3, b = 8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a % b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
<pre>-3</pre>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// a and b both negative </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = -3, b = -8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a % b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
<pre>-3</pre>
<h2>C/C++ Ternary Operator &#8211; Some Interesting Observations</h2>
Predict the output of following C++ program. 
<!--more-->
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;line-height: 18px;font-size: 12px"> </span>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">test = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"First  character "</code> <code class="plain">&lt;&lt; </code><code class="string">'1'</code> <code class="plain">&lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Second character "</code> <code class="plain">&lt;&lt; (test ? 3 : </code><code class="string">'1'</code><code class="plain">) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
One would expect the output will be same in both the print statements. 
However, the output will be,<br/>
<code class="plain">First  character 1 </code>
<code class="plain">Second character 49 </code>
Why the second statement printing 49? Read on the ternary expression.
<!--more-->
<strong><span style="color: #0000ff">Ternary Operator (C/C++):</span></strong>
A ternary operator has the following form,
<em>exp<sub>1</sub> ? exp<sub>2</sub> : exp<sub>3</sub></em>
The expression <em>exp<sub>1</sub></em> will be evaluated always. 
Execution of <em>exp<sub>2</sub></em> and <em>exp<sub>3</sub></em> depends on the outcome of <em>exp<sub>1</sub></em>. 
If the outcome of <em>exp<sub>1</sub></em> is non zero <em>exp<sub>2</sub></em> will be evaluated, otherwise <em>exp</em><sub><em>3</em></sub> will be evaluated.
<strong>Side Effects:</strong>
<strong> </strong>Any side effects of <em>exp<sub>1</sub></em> will be evaluated and updated immediately before executing <em>exp<sub>2</sub></em> or <em>exp<sub>3</sub></em>. 
In other words, there is <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence point</a> after the evaluation of condition in the ternary expression. 
If either <em>exp<sub>2</sub></em> or <em>exp<sub>3</sub></em> have side effects, only one of them will be evaluated.
<strong>Return Type:</strong>
<strong> </strong>It is another interesting fact. 
The ternary operator has return type. 
The return type depends on exp<sub>2</sub>, and <em>convertibility</em> of exp<sub>3</sub> into exp<sub>2</sub> as per usual\overloaded conversion rules. 
If they are not convertible, the compiler throws an error. 
See the examples below,
          
The following program compiles without any error. 
The return type of ternary expression is expected to be <em>float</em> (as that of exp<sub>2</sub>) and exp<sub>3</sub> (i.e. 
literal <em>zero &#8211; int </em>type) is implicitly convertible to <em>float.</em>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">test = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fvalue = 3.111f; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; (test ? fvalue : 0) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="plain">  </code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The following program will not compile, because the compiler is unable to find return type of ternary expression or implicit conversion is unavailable between exp<sub>2</sub> (<em>char array</em>) and exp<sub>3</sub> (<em>int</em>).
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">test = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; test ? </code><code class="string">"A String"</code> <code class="plain">: 0 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The following program *may* compile, or but fails at runtime. 
The return type of ternary expression is bounded to type (<em>char *</em>), yet the expression returns <em>int</em>, hence the program fails. 
Literally, the program tries to print string at 0th address at runtime.
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">test = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; (test ? </code><code class="string">"A String"</code> <code class="plain">: 0) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
We can observe that <em>exp<sub>2</sub></em> is considered as output type and <em>exp<sub>3</sub></em> will be converted into <em>exp<sub>2</sub></em> at runtime. 
If the conversion is implicit the compiler inserts stubs for conversion. 
If the conversion is explicit the compiler throws an error. 
If any compiler misses to catch such error, the program may fail at runtime.
<strong>Best Practice:</strong>
It is the power of C++ type system that avoids such bugs. 
Make sure both the expressions <em>exp<sub>2</sub></em> and <em>exp<sub>3</sub></em> return same type or atleast safely convertible types. 
We can see other idioms like C++ <em>convert union</em> for safe conversion.
<h2>Pre-increment (or pre-decrement) in C++</h2>
In C++,  pre-increment (or pre-decrement) can be used as <a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/">l-value</a>, but post-increment (or post-decrement) can not be used as l-value. 
<!--more-->
For example, following program prints <em>a = 20</em> (++a is used as l-value)
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// Pre-increment (or pre-decrement) </code>
<code class="preprocessor">#include &lt;cstdio> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++a = 20; </code><code class="comments">// works </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
a = 20
</pre>
The above program works whereas the following program fails in compilation with error <em>&#8220;non-lvalue in assignment&#8221;</em> (a++ is used as l-value)<br/>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// Post-increment (or post-decrement) </code>
<code class="preprocessor">#include &lt;cstdio> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a++ = 20; </code><code class="comments">// error </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
prog.cpp: In function 'int main()':
prog.cpp:6:5: error: lvalue required as left operand of assignment
 a++ = 20; // error 
     ^
</pre>
<p align="center"><strong>How ++a is different from a++ as lvalue?</strong>
It is because <code>++a</code> returns an <em>lvalue</em>, which is basically a reference to the variable to which we can further assign — just like an ordinary variable. 
It could also be assigned to a reference as follows:
<pre>
int &amp;ref = ++a; // valid
int &amp;ref = a++; // invalid
</pre>
Whereas if you recall how <code>a++</code> works, it doesn&#8217;t immediately increment the value it holds. 
For brevity, you can think of it as getting incremented in the next statement. 
So what basically happens is that <code>a++</code> returns an <em>rvalue</em>, which is basically just a value like the value of an expression which is not stored. 
You can think of <code>a++ = 20;</code> as follows after being processed:
<pre>
int a = 10;
// On compilation, a++ is replaced by the value of a which is an rvalue:
10 = 20; // Invalid
// Value of a is incremented
a = a + 1;
</pre>
That should help to understand why <code>a++ = 20;</code> won&#8217;t work.
<h2>Difference between ++*p, *p++ and *++p</h2>
Predict the output of following C programs.<!--more-->
<code class="comments">// PROGRAM 1 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++*p; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[0] = %d, arr[1] = %d, *p = %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0], arr[1], *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// PROGRAM 2 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*p++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[0] = %d, arr[1] = %d, *p = %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0], arr[1], *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// PROGRAM 3 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*++p; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[0] = %d, arr[1] = %d, *p = %d"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0], arr[1], *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The output of above programs and all such programs can be easily guessed by remembering following simple rules about postfix ++, prefix ++ and * (dereference) operators<br />
<strong>1)</strong> Precedence of prefix ++ and * is same. 
Associativity of both is right to left.<br />
<strong>2)</strong> Precedence of postfix ++ is higher than both * and prefix ++. 
Associativity of postfix ++ is left to right.
(Refer: <a href="https://www.geeksforgeeks.org/operators-c-c/">Precedence Table</a>)
The expression <strong>++*p</strong> has two operators of same precedence, so compiler looks for assoiativity. 
Associativity of operators is right to left. 
Therefore the expression is treated as <em><strong>++(*p)</strong></em>. 
Therefore the output of first program is &#8220;<em>arr[0] = 11, arr[1] = 20, *p = 11</em>&#8220;.
The expression <strong>*p++</strong> is treated as<em><strong> *(p++)</strong> </em>as the precedence of postfix ++ is higher than *. 
Therefore the output of second program is &#8220;<em>arr[0] = 10, arr[1] = 20, *p = 20</em>&#8220;.
The expression <strong>*++p</strong> has two operators of same precedence, so compiler looks for assoiativity. 
Associativity of operators is right to left. 
Therefore the expression is treated as <em><strong>*(++p)</strong></em>. 
Therefore the output of second program is &#8220;<em>arr[0] = 10, arr[1] = 20, *p = 20</em>&#8220;.
<h2>Results of comparison operations in C and C++</h2>
In C, data type of result of comparison operations is int. 
For example, see the following program.<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10, y = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d \n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(x == y)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d \n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(x &lt; y)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>4
4</pre>
Whereas in C++, type of results of comparison operations is bool. 
For example, see the following program.<br/>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10, y = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(x == y) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(x &lt; y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1
1</pre>
<h2>To find sum of two numbers without using any operator</h2>
Write a program to find sum of positive integers without using any operator. 
Only use of printf() is allowed. 
No other library function can be used.<!--more-->
<strong>Solution</strong><br />
It&#8217;s a trick question. 
We can use printf() to find sum of two numbers as printf() returns the number of characters printed. 
The <a href="http://www.cplusplus.com/reference/clibrary/cstdio/printf/">width field in printf()</a> can be used to find the sum of two numbers. 
We can use &#8216;*&#8217; which indicates the minimum width of output. 
For example, in the statement &#8220;printf(&#8220;%*d&#8221;, width, num);&#8221;, the specified &#8216;width&#8217; is substituted in place of *, and &#8216;num&#8217; is printed within the minimum width specified. 
If number of digits in &#8216;num&#8217; is smaller than the specified &#8216;width&#8217;, the output is padded with blank spaces. 
If number of digits are more, the output is printed as it is (not truncated). 
In the following program, add() returns sum of x and y. 
It prints 2 spaces within the width specified using x and y. 
So total characters printed is equal to sum of x and y. 
That is why add() returns x+y.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">add(</code><code class="color1 bold">int</code> <code class="plain">x, </code><code class="color1 bold">int</code> <code class="plain">y) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%*c%*c"</code><code class="plain">, x, </code><code class="string">' '</code><code class="plain">, y, </code><code class="string">' '</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Sum = %d"</code><code class="plain">, add(3, 4)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
       Sum = 7
</pre>
The output is seven spaces followed by &#8220;Sum = 7&#8221;. 
We can avoid the leading spaces by using carriage return. 
Thanks to <strong>krazyCoder</strong> and <strong>Sandeep</strong> for suggesting this. 
The following program prints output without any leading spaces.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">add(</code><code class="color1 bold">int</code> <code class="plain">x, </code><code class="color1 bold">int</code> <code class="plain">y) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%*c%*c"</code><code class="plain">, x, </code><code class="string">'\r'</code><code class="plain">, y, </code><code class="string">'\r'</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Sum = %d"</code><code class="plain">, add(3, 4)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
      Sum = 7
</pre>
Another Method :<br />
<h3>C</h3>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="color1 bold">int</code> <code class="plain">a=10,b=5,sum; </code>
<code class="keyword bold">while</code><code class="plain">(b>0){ </code>
<code class="plain">a++; </code>
<code class="plain">b--; </code>
<code class="plain">} </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Sum=%d"</code><code class="plain">,a); </code>
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java code&nbsp; </code>
<code class="keyword">class</code> <code class="plain">GfG { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args)&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="keyword">int</code> <code class="plain">a=</code><code class="value">10</code><code class="plain">,b=</code><code class="value">5</code><code class="plain">,sum;&nbsp; </code>
<code class="keyword">while</code><code class="plain">(b></code><code class="value">0</code><code class="plain">){&nbsp; </code>
<code class="plain">a++;&nbsp; </code>
<code class="plain">b--;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="plain">System.out.println(a);&nbsp; </code>
<code class="plain">} </code>
<code class="plain">}&nbsp; </code>
<h3>Python 3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python 3 Code </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">if</code> <code class="plain">__name__ </code><code class="keyword">=</code><code class="keyword">=</code> <code class="string">'__main__'</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a </code><code class="keyword">=</code> <code class="value">10</code><code class="plain">; b </code><code class="keyword">=</code> <code class="value">5</code><code class="plain">; </code><code class="functions">sum</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(b > </code><code class="value">0</code><code class="plain">): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a </code><code class="keyword">=</code> <code class="plain">a </code><code class="keyword">+</code> <code class="value">1</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b </code><code class="keyword">=</code> <code class="plain">b </code><code class="keyword">-</code> <code class="value">1</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">print</code><code class="plain">(</code><code class="string">"Sum ="</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed&nbsp; </code>
<code class="comments"># by Akanksha Rai </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# code </code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">public</code> <code class="keyword">class</code> <code class="plain">GFG{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">public</code> <code class="keyword">void</code> <code class="plain">Main (){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">a=10,b=5;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(b>0){&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a++;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b--;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(a);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="comments">//This code is contributed by Tushil.&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP Code </code>
<code class="variable">$a</code> <code class="plain">= 10; </code>
<code class="variable">$b</code> <code class="plain">= 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">while</code><code class="plain">(</code><code class="variable">$b</code> <code class="plain">> 0) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$a</code><code class="plain">++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$b</code><code class="plain">--; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="functions">echo</code> <code class="string">"Sum = "</code><code class="plain">, </code><code class="variable">$a</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Dinesh. 
</code>
<code class="plain">?> </code>
<strong>Output:</strong>
<pre>
sum = 15
</pre>
<h2>Sequence Points in C | Set 1</h2>
In this post, we will try to cover many ambiguous questions like following.<!--more-->
Guess the output of following programs.
<code class="comments">// PROGRAM 1 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">f1() { </code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Geeks"</code><code class="plain">); </code><code class="keyword bold">return</code> <code class="plain">1;} </code>
<code class="color1 bold">int</code> <code class="plain">f2() { </code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"forGeeks"</code><code class="plain">); </code><code class="keyword bold">return</code> <code class="plain">1;} </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() + f2();&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// PROGRAM 2 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">x = 20; </code>
<code class="color1 bold">int</code> <code class="plain">f1() { x = x+10; </code><code class="keyword bold">return</code> <code class="plain">x;} </code>
<code class="color1 bold">int</code> <code class="plain">f2() { x = x-5;&nbsp; </code><code class="keyword bold">return</code> <code class="plain">x;} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() + f2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"p = %d"</code><code class="plain">, p); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// PROGRAM 3 </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = i++*i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, p); </code>
<code class="plain">} </code>
The output of all of the above programs is <a href="http://en.wikipedia.org/wiki/Undefined_behavior">undefined</a> or <a href="http://en.wikipedia.org/wiki/Unspecified_behavior">unspecified</a>. 
The output may be different with different compilers and different machines. 
It is like asking the value of undefined automatic variable. 

The reason for undefined behavior in PROGRAM 1 is, the operator &#8216;+&#8217; doesn&#8217;t have standard defined order of evaluation for its operands. 
Either f1() or f2() may be executed first. 
So output may be either &#8220;GeeksforGeeks&#8221;  or &#8220;forGeeksGeeks&#8221;.<br />
Similar to operator &#8216;+&#8217;, most of the other similar operators like &#8216;-&#8216;, &#8216;/&#8217;, &#8216;*&#8217;, Bitwise AND &#038;, Bitwise OR |, .. 
etc don&#8217;t have a standard defined order for evaluation for its operands.
Evaluation of an expression may also produce side effects. 
For example, in the above program 2, the final values of p is ambiguous. 
Depending on the order of expression evaluation, if f1() executes first, the value of p will be 55, otherwise 40.
The output of program 3 is also undefined. 
It may be 64, 72, or may be something else. 
The subexpression i++ causes a side effect, it modifies i&#8217;s value, which leads to undefined behavior since i is also referenced elsewhere in the same expression.
Unlike above cases, <em>at certain specified points in the execution sequence called <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence points</a>, all side effects of previous evaluations are guaranteed to be complete</em>. 
A <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence point</a> defines any point in a computer program&#8217;s execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. 
Following are the sequence points listed in the C standard:
<strong>— The end of the first operand of the following operators: </strong><br />
  a) logical AND &#038;&#038;<br />
  b) logical OR ||<br />
  c) conditional ?<br />
  d) comma ,
For example, the output of following programs is guaranteed to be &#8220;GeeksforGeeks&#8221; on all compilers/machines.
<code class="comments">// Following 3 lines are common in all of the below programs </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">f1() { </code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Geeks"</code><code class="plain">); </code><code class="keyword bold">return</code> <code class="plain">1;} </code>
<code class="color1 bold">int</code> <code class="plain">f2() { </code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"forGeeks"</code><code class="plain">); </code><code class="keyword bold">return</code> <code class="plain">1;} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// PROGRAM 4 </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Since && defines a sequence point after first operand, it is&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// guaranteed that f1() is completed first. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1() && f2();&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// PROGRAM 5 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Since comma operator defines a sequence point after first operand, it is </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// guaranteed that f1() is completed first. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = (f1(), f2()); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// PROGRAM 6 </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Since ? operator defines a sequence point after first operand, it is&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// guaranteed that f1() is completed first. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">p = f1()? f2(): 3;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
</br><br />
<strong>— The end of a full expression. 
This category includes following expression statements </strong><br />
a) Any full statement ended with semicolon like &#8220;a = b;&#8221;<br />
b) return statements<br />
c) The controlling expressions of if, switch, while, or do-while statements.<br />
d) All three expressions in a for statement.
The above list of sequence points is partial. 
We will be covering all remaining sequence points in the next post on Sequence Point.
<h2>Execution of printf with ++ operators</h2>
Consider below C++ program and predict its output.
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d"</code><code class="plain">, i, ++i, i++); </code>
The above invokes undefined behaviour by referencing both &#8216;i&#8217; and &#8216;i++&#8217; in the argument list. 
It is not defined in which order the arguments are evaluated. 
Different compilers may choose different orders. 
A single compiler can also choose different orders at different times.
For example below three printf statements may also cause undefined behavior.<br/>
<code class="comments">// All three printf() statements&nbsp; </code>
<code class="comments">// in this cause undefined behavior </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">volatile</code> <code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n %d %d"</code><code class="plain">, a, a++); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n %d %d"</code><code class="plain">, a++, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n %d %d %d "</code><code class="plain">, a, a++, ++a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Therefore, it is not recommended Not to do two or more than two pre or post increment operators in the same statement.<br />
This means that there&#8217;s absolutely no temporal ordering in this process. 
The arguments can be evaluated in any order, and the process of their evaluation can be intertwined in any way.
<h2>Anything written in sizeof() is never executed in C</h2>
In C/C++ sizeof() operator is used to find size of a date type or variable. 
Expressions written in sizeof() are never executed.
Examples:
<code class="comments">// C program to demonstrate that the </code>
<code class="comments">// expressions written in sizeof() are </code>
<code class="comments">// never executed </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The printf in sizeof is not executed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Only the return type of printf is&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// considered and its size is evaluated </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// by sizeof, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"hey"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Output:
4
</pre>
Even if we assign a value inside sizeof(), the changes are not reflected.<br/>
<code class="comments">// One more C program to demonstrate that&nbsp; </code>
<code class="comments">// the expressions written in sizeof() are </code>
<code class="comments">// never executed </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">b = </code><code class="keyword bold">sizeof</code><code class="plain">(a = 6); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a = %d,&nbsp; b = %d\n"</code><code class="plain">, a, b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre>
Output:
a = 5, b = 4
</pre>
<h2>Difference between strlen() and sizeof() for string in C</h2>
<!-- Problem Statement -->
<p align="center"><b><a href="https://www.geeksforgeeks.org/sizeof-operator-c/">sizeof()</a></b>
Sizeof operator  is a compile time unary operator which can be used to compute the size of its operand. 

<ul>
<li>The result of sizeof is of unsigned integral type which is usually denoted by size_t.</li>
<li>sizeof can be applied to any data-type, including primitive types such as integer and floating-point types, pointer types, or compound datatypes such as Structure, union etc.</li>
</ul>
<p align="center"><b>strlen()</b>
strlen() is a predefined function in C whose definition is contained in the header file &#8220;string.h&#8221;. 
<ul>
<li>strlen() accepts a pointer to an array as argument and walks through memory at run time from the address we give it looking for a <b>NULL</b> character and counts up how many memory locations it passed before it finds one.</li>
<li>
The main task of strlen() is to count the length of an array or string.</li>
<p align="center"><strong>sizeof vs strlen()</strong>
<ol>
<li><strong>Type:</strong> Sizeof operator  is a unary operator whereas strlen() is a predefined function in C</li>
<li><strong>Data types supported: </strong>Sizeof gives actual size of any type of data (allocated) in bytes (including the null values) whereas get the length of an array of chars/string.</li>
<li><strong>Evaluation size: </strong>sizeof() is a compile-time expression giving you the size of a type or a variable&#8217;s type. 
It doesn&#8217;t care about the value of the variable.<br />
Strlen on the other hand, gives you the length of a C-style NULL-terminated string.
</li>
<li><strong>Summary: </strong>The two are almost different concepts and used for different purposes.</li>
<li><strong>In context of C++:</strong>  In C++, you do not need any of them as such.<br />
<strong>strlen()</strong> in  C-style strings can be replaced by <strong>C++ std::strings</strong>.<br />
<strong>sizeof() in C</strong> is as an argument to functions like malloc(), memcpy() or memset() can be replaced by<strong> C++ (use new, std::copy(), and std::fill() or constructors)</strong>.</li></ol>
<code class="comments">// C program to demonstrate difference&nbsp; </code>
<code class="comments">// between strlen() and sizeof() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"November"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Length of String is %lu\n"</code><code class="plain">, </code><code class="functions bold">strlen</code><code class="plain">(str)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of String is %lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(str)); </code>
<code class="plain">} </code>
Output:
<pre>
Length of String is 8
Size of String is 9
</pre>
Since size of char in C is 1 byte but then also we find that strlen() gave one less value than sizeof().
<b>Explanation :</b> We know, that every string terminates with a NULL character (&#8220;\0&#8221;).<br />
<strong>strlen()</strong> searches for that NULL character and counts the number of memory address passed, So it actually counts the number of elements present in the string before the NULL character, here which is 8.<br />
<strong>sizeof()</strong> operator returns actual amount of memory allocated for the operand passed to it. 
Here the operand is an array of characters which contains 9 characters including Null character and size of 1 character is 1 byte. 
So, here the total size is 9 bytes.<br />
<strong>Try to guess the output of following program:</strong>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a[] = {</code><code class="string">"Geeks for"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">b[] = {</code><code class="string">'G'</code><code class="plain">,</code><code class="string">'e'</code><code class="plain">,</code><code class="string">'e'</code><code class="plain">,</code><code class="string">'k'</code><code class="plain">,</code><code class="string">'s'</code><code class="plain">,</code><code class="string">' '</code><code class="plain">,</code><code class="string">'f'</code><code class="plain">,</code><code class="string">'o'</code><code class="plain">,</code><code class="string">'r'</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"sizeof(a) = "</code> <code class="plain">&lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"\nstrlen(a) = "</code><code class="plain">&lt;&lt; </code><code class="functions bold">strlen</code><code class="plain">(a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;&nbsp; </code><code class="string">"\nsizeof(b) = "</code> <code class="plain">&lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;&nbsp; </code><code class="string">"\nstrlen(b) = "</code> <code class="plain">&lt;&lt; </code><code class="functions bold">strlen</code><code class="plain">(b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The strlen function looks for a null character and behaves abnormally if it doesn&#8217;t find it.<br />
Output:
<pre>
sizeof(a) = 10
strlen(a) = 9
sizeof(b) = 9
strlen(b) = 11
</pre>
<h2># and ## Operators in C</h2>
<p align="center"><strong>Stringizing operator (#)</strong>
This operator causes the corresponding actual argument to be enclosed in double quotation marks. 
The # operator, which is generally called the<em> stringize</em> operator, turns the argument it precedes into a quoted string. 
For more on pre-processor directives &#8211; refer <a href="https://www.geeksforgeeks.org/cc-preprocessors/">this</a><br />
<strong>Examples :</strong>
<ol>
<li>The following preprocessor turns the line printf(mkstr(geeksforgeeks)); into printf(&#8220;geeksforgeeks&#8221;);
<code class="comments">// CPP program to illustrate (#) operator </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define mkstr(s) #s </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(mkstr(geeksforgeeks)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
geeksforgeeks
</pre>
</li>
<li>In this program, value of a is replaced by macro.
<code class="comments">// CPP program to illustrate (#) operator </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define a 8.3297 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Value of a is "</code> <code class="plain">&lt;&lt; a &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Value of a is 8.3297
</pre>
</li>
<li>This program finds out maximum out of two numbers using macro
<code class="comments">// CPP program to illustrate (#) operator </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define MAX(i, j) (((i) > (j)) ? i : j) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a, b; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 250; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b = 25; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"The maximum is "</code> <code class="plain">&lt;&lt; MAX(a, b) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
The maximum is 250
</pre></li></ol>
<p align="center"><strong>Token-pasting operator (##)</strong> 
Allows tokens used as actual arguments to be concatenated to form other tokens. 
It is often useful to merge two tokens into one while expanding macros. 
This is called token pasting or token concatenation. 
The ‘##’ pre-processing operator performs token pasting. 
When a macro is expanded, the two tokens on either side of each ‘##’ operator are combined into a single token, which then replaces the ‘##’ and the two original tokens in the macro expansion.<br />
<strong>Examples :</strong>
<ol>
<li>The preprocessor transforms printf(&#8220;%d&#8221;, concat(x, y)); into printf(&#8220;%d&#8221;, xy);
<code class="comments">// CPP program to illustrate (##) operator </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define concat(a, b) a##b </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">xy = 30; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, concat(x, y)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
30
</pre></li></ol>
<strong>Application: </strong> The ## provides a way to concatenate actual arguments during macro expansion. 
If a parameter in the replacement text is adjacent to a ##, the parameter is replaced by the actual argument, the  ## and surrounding white space are removed, and the result is re-scanned. 
<h2>Write a C macro PRINT(x) which prints x</h2>
At the first look, it seems that writing a C macro which prints its argument is child&#8217;s play. 
<!--more--> Following program should work i.e. 
it should print <em>x</em>
<code class="preprocessor">#define PRINT(x) (x) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">,PRINT(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
But it would issue compile error because the data type of <em>x</em>, which is taken as variable by the compiler, is unknown. 
Now it doesn&#8217;t look so obvious. 
Isn&#8217;t it? Guess what, the followings also won&#8217;t work 
<code class="preprocessor">#define PRINT(x) ('x') </code>
<code class="preprocessor">#define PRINT(x) ("x") </code>
But if we know one of lesser known traits of C language, writing such a macro is really a child&#8217;s play. 
🙂 In C, there&#8217;s a # directive, also called &#8216;Stringizing Operator&#8217;, which does this magic. 
Basically # directive converts its argument in a string. 
Voila! it is so simple to do the rest. 
So the above program can be modified as below.<br/>
<code class="preprocessor">#define PRINT(x) (#x) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">,PRINT(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now if the input is <em>PRINT(x)</em>, it would print <em>x</em>. 
In fact, if the input is <em>PRINT(geeks)</em>, it would print <em>geeks</em>.
You may find the details of this directive from Microsoft portal <a href="http://msdn.microsoft.com/en-us/library/7e3a913x(VS.80).aspx"><strong>here</strong></a>.<br />
<em>
<h2>Variable length arguments for Macros</h2>
Like functions, we can also pass variable length arguments to macros. 
For this we will use the following preprocessor identifiers.<!--more-->
To support variable length arguments in macro, we must include ellipses (&#8230;) in macro definition. 
There is also &#8220;__VA_ARGS__&#8221; preprocessing identifier which takes care of variable length argument substitutions which are provided to macro. 
Concatenation operator ## (aka paste operator) is used to concatenate variable arguments. 
Let us see with example. 
Below macro takes variable length argument like &#8220;printf()&#8221; function. 
This macro is for error logging. 
The macro prints filename followed by line number, and finally it prints info/error message. 
First arguments &#8220;prio&#8221; determines the priority of message, i.e. 
whether it is information message or error, &#8220;stream&#8221; may be &#8220;standard output&#8221; or &#8220;standard error&#8221;. 
 It displays INFO messages on stdout and ERROR messages on stderr stream. 
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define INFO&nbsp;&nbsp;&nbsp; 1 </code>
<code class="preprocessor">#define ERR 2 </code>
<code class="preprocessor">#define STD_OUT stdout </code>
<code class="preprocessor">#define STD_ERR stderr </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define LOG_MESSAGE(prio, stream, msg, ...) do {\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str;\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(prio == INFO)\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str = </code><code class="string">"INFO"</code><code class="plain">;\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(prio == ERR)\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str = </code><code class="string">"ERR"</code><code class="plain">;\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(stream, </code><code class="string">"[%s] : %s : %d : "</code><code class="plain">msg</code><code class="string">" \n"</code><code class="plain">, \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str, __FILE__, __LINE__, ##__VA_ARGS__);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">while</code> <code class="plain">(0) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*s = </code><code class="string">"Hello"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* display normal message */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">LOG_MESSAGE(ERR, STD_ERR, </code><code class="string">"Failed to open file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* provide string as argument */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">LOG_MESSAGE(INFO, STD_OUT, </code><code class="string">"%s Geeks for Geeks"</code><code class="plain">, s); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* provide integer as arguments */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">LOG_MESSAGE(INFO, STD_OUT, </code><code class="string">"%d + %d = %d"</code><code class="plain">, 10, 20, (10 + 20)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Compile and run the above program, it produces below result.
<pre>
  [narendra@/media/partition/GFG]$ ./variable_length 
  [ERR] : variable_length.c : 26 : Failed to open file 
  [INFO] : variable_length.c : 27 : Hello Geeks for Geeks 
  [INFO] : variable_length.c : 28 : 10 + 20 = 30 
  [narendra@/media/partition/GFG]$
</pre>
<h2>Multiline macros in C</h2>
In this article, we will discuss how to write a multi-line macro. 
We can write multi-line macro same like function, but each statement ends with &#8220;\&#8221;. 
Let us see with example.<!--more--> Below is simple macro, which accepts input number from user, and prints whether entered number is even or odd.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define MACRO(num, str) {\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, num);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" is"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %s number"</code><code class="plain">, str);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a number: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num & 1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Odd"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Even"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
At first look, the code looks OK, but when we try to compile this code, it gives compilation error.
<pre>
[narendra@/media/partition/GFG]$ make macro
cc     macro.c   -o macro
macro.c: In function ‘main’:
macro.c:19:2: error: ‘else’ without a previous ‘if’
make: *** [macro] Error 1
[narendra@/media/partition/GFG]$ 
</pre>
Let us see what mistake we did while writing macro. 
We have enclosed macro in curly braces. 
According to C-language rule, each C-statement should end with semicolon. 
That&#8217;s why we have ended MACRO with semicolon. 
Here is a mistake. 
Let us see how compile expands this macro.
<pre>
if (num & 1)
{
    -------------------------
    ---- Macro expansion ----
    -------------------------
};    /* Semicolon at the end of MACRO, and here is ERROR */
else 
{
   -------------------------
   ---- Macro expansion ----
   -------------------------
};
</pre>
We have ended macro with semicolon. 
When compiler expands macro, it puts semicolon after &#8220;if&#8221; statement. 
Because of semicolon between &#8220;if and else statement&#8221; compiler gives compilation error. 
Above program will work fine, if we ignore &#8220;else&#8221; part.
To overcome this limitation, we can enclose our macro in &#8220;do-while(0)&#8221; statement. 
Our modified macro will look like this.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define MACRO(num, str) do {\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, num);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" is"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %s number"</code><code class="plain">, str);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">while</code><code class="plain">(0) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a number: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num & 1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Odd"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Even"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Compile and run above code, now this code will work fine.
<pre>
[narendra@/media/partition/GFG]$ make macro
cc     macro.c   -o macro
[narendra@/media/partition/GFG]$ ./macro 
Enter a number: 9
9 is Odd number
[narendra@/media/partition/GFG]$ ./macro 
Enter a number: 10
10 is Even number
[narendra@/media/partition/GFG]$ 
</pre>
We have enclosed macro in &#8220;do &#8211; while(0)&#8221; loop and at the end of while, we have put condition as &#8220;while(0)&#8221;, that&#8217;s why this loop will execute only one time.
Similarly, instead of &#8220;do &#8211; while(0)&#8221; loop we can enclose multi-line macro in parenthesis. 
We can achieve the same result by using this trick. 
Let us see example.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define MACRO(num, str) ({\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, num);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" is"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %s number"</code><code class="plain">, str);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">);\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a number: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num & 1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Odd"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">MACRO(num, </code><code class="string">"Even"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@/media/partition/GFG]$ make macro
cc     macro.c   -o macro
[narendra@/media/partition/GFG]$ ./macro 
Enter a number: 10
10 is Even number
[narendra@/media/partition/GFG]$ ./macro 
Enter a number: 15
15 is Odd number
[narendra@/media/partition/GFG]$ 
</pre>
<h2>CRASH() macro &#8211; interpretation</h2>
Given below a small piece of code from an open source project, <!--more-->
<code class="preprocessor">#ifndef __cplusplus </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">typedef</code> <code class="keyword bold">enum</code> <code class="plain">BoolenTag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">false</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">true</code>
<code class="plain">} </code><code class="color1 bold">bool</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#endif </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define CRASH() do { \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">((</code><code class="keyword bold">void</code><code class="plain">(*)())0)(); \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">while</code><code class="plain">(</code><code class="keyword bold">false</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">CRASH(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Can you interpret above code?
It is simple, a step by step approach is given below,
The statement <em>while(false)</em> is meant only for testing purpose. 
Consider the following operation,
<pre>((void(*)())0)();</pre>
It can be achieved as follows,
<pre><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">0;                      /* literal zero */</span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">(0); </span><span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">( ()0 );                /* 0 being casted to some type */</span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">( (*) 0 );              /* 0 casted some pointer type */</span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">( (*)() 0 );            /* 0 casted as pointer to some function */</span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">( void (*)(void) 0 );   /* Interpret 0 as address of function </span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px"> taking nothing and returning nothing */</span>
<span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;font-size: 12px;line-height: 18px">( void (*)(void) 0 )(); /* Invoke the function */</span></pre>
So the given code is invoking the function whose code is stored at location zero, in other words, trying to execute an instruction stored at location zero. 
On systems with memory protection (MMU) the OS will throw an exception (segmentation fault) and on systems without such protection (small embedded systems), it will execute and error will propagate further.
<h2>The OFFSETOF() macro</h2>
We know that the elements in a structure will be stored in sequential order of their declaration.<!--more-->
How to extract the displacement of an element in a structure? We can make use of <a href="http://en.wikipedia.org/wiki/Offsetof">offsetof</a> macro.
Usually we call structure and union types (or <em>classes with trivial constructors</em>) as <em>plain old data</em> (POD) types, which will be used to <em>aggregate other data types</em>. The following non-standard macro can be used to get the displacement of an element in bytes from the base address of the structure variable.
<pre><strong>#define OFFSETOF(TYPE, ELEMENT) ((size_t)&amp;(((TYPE *)0)-&gt;ELEMENT))</strong></pre>
Zero is casted to type of structure and required element&#8217;s address is accessed, which is casted to <em>size_t</em>. 
As per standard <em>size_t</em> is of type <em>unsigned int</em>. 
The overall expression results in the number of bytes after which the ELEMENT being placed in the structure.
For example, the following code returns 16 bytes (padding is considered on 32 bit machine) as displacement of the character variable <em>c</em> in the structure Pod.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define OFFSETOF(TYPE, ELEMENT) ((size_t)&(((TYPE *)0)->ELEMENT)) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">typedef</code> <code class="keyword bold">struct</code> <code class="plain">PodTag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">    i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain"> d; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">   c; </code>
<code class="plain">} PodType; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, OFFSETOF(PodType, c) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
In the above code, the following expression will return the displacement of element <em>c</em> in the structure <em>PodType</em>.
<pre><strong>OFFSETOF(PodType, c);</strong></pre>
After preprocessing stage the above macro expands to
<code class="plain">((</code><code class="color1 bold">size_t</code><code class="plain">)&(((PodType *)0)->c)) </code>
Since we are considering 0 as address of the structure variable, c will be placed after 16 bytes of its base address i.e. 
0x00 + 0x10. 
Applying &amp; on the structure element (in this case it is c) returns the address of the element which is 0x10. 
Casting the address to <em>unsigned int</em> (size_t) results in number of bytes the element is placed in the structure.
<strong>Note:</strong> We may consider the address operator &amp; is redundant. 
Without address operator in macro, the code de-references the element of structure placed at NULL address. 
It causes an access violation exception (segmentation fault) at runtime.
<em>Note that there are other ways to implement offsetof macro according to compiler behaviour. 
The ultimate goal is to extract displacement of the element. 
</em><em><strong>We will see practical usage of offsetof macro in liked lists to connect similar objects (for example thread pool) in another article.</strong></em>
Article compiled by <strong>Venki</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
<h2>Branch prediction macros in GCC</h2>
One of the most used optimization techniques in the Linux kernel is &#8221; __builtin_expect&#8221;. 
When working with conditional code (if-else statements), we often know which branch is true and which is not. 
<!--more-->If compiler knows this information in advance, it can generate most optimized code.
Let us see macro definition of &#8220;likely()&#8221; and &#8220;unlikely()&#8221; macros from linux kernel code &#8220;<a href="http://lxr.linux.no/linux+v3.6.5/include/linux/compiler.h">http://lxr.linux.no/linux+v3.6.5/include/linux/compiler.h</a>&#8221; [line no 146 and 147].
<code class="preprocessor">#define likely(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __builtin_expect(!!(x), 1) </code>
<code class="preprocessor">#define unlikely(x)&nbsp;&nbsp;&nbsp; __builtin_expect(!!(x), 0) </code>
In the following example, we are marking branch as likely true:<br/>
<code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*home_dir ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">home_dir = </code><code class="functions bold">getenv</code><code class="plain">(</code><code class="string">"HOME"</code><code class="plain">); </code>
<code class="keyword bold">if</code> <code class="plain">(likely(home_dir))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"home directory: %s\n"</code><code class="plain">, home_dir); </code>
<code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">perror</code><code class="plain">(</code><code class="string">"getenv"</code><code class="plain">); </code>
For above example, we have marked &#8220;if&#8221; condition as &#8220;likely()&#8221; true, so compiler will put true code immediately after branch, and false code within the branch instruction. 
In this way compiler can achieve optimization. 
But don&#8217;t use &#8220;likely()&#8221; and &#8220;unlikely()&#8221; macros blindly. 
If prediction is correct, it means there is zero cycle of jump instruction, but if prediction is wrong, then it will take several cycles, because processor needs to flush it&#8217;s pipeline which is worst than no prediction.
Accessing memory is the slowest CPU operation as compared to other CPU operations. 
To avoid this limitation, CPU uses &#8220;CPU caches&#8221; e.g L1-cache, L2-cache etc. 
The idea behind cache is, copy some part of memory into CPU itself. 
We can access cache memory much faster than any other memory. 
But the problem is, limited size of &#8220;cache memory&#8221;, we can&#8217;t copy entire memory into cache. 
So, the CPU has to guess which memory is going to be used in the near future and load that memory into the CPU cache and above macros are hint to load memory into the CPU cache.
<h2>Diffference between #define and const in C?</h2>
<strong>#define</strong> is a <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">preprocessor directive</a>. 
Things defined by #define are replaced by the preprocessor before compilation begins. 
<!--more-->
<strong>const</strong> variables are actual variables like other normal variable.
The big advantage of const over #define is type checking. 
We can also have poitners to const varaibles, we can pass them around, typecast them and any other thing that can be done with a normal variable. 
One disadvantage that one could think of is extra space for variable which is immaterial due to optimizations done by compilers.
In general const is a better option if we have a choice. 
There are situations when #define cannot be replaced by const. 
For example, #define can take parameters (See <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">this </a>for example). 
#define can also be used to replace some text in a program with another text.
<h2>A C Programming Language Puzzle</h2>
Give a = 12 and b = 36 write a C function/macro that returns 3612 without using arithmetic, strings  and predefined functions.<!--more-->
<strong>We strongly recommend you to minimize your browser and try this yourself first.</strong>
Below is one solution that uses String <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Token-Pasting Operator</a> (##) of C macros. 
For example, the expression &#8220;a##b&#8221; prints concatenation of &#8216;a&#8217; and &#8216;b&#8217;. 

Below is a working C code.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define merge(a, b) b##a </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, merge(12, 36)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>3612</pre>
Thanks to an anonymous user to suggest this solution.
<h2>What’s difference between header files &#8220;stdio.h&#8221; and &#8220;stdlib.h&#8221; ?</h2>
<p style="text-align: justify"><span style="font-weight: 400">These are two important header files used in C programming. 
While “&lt;stdio.h&gt;” is header file for <strong>St</strong>andar<strong>d</strong> <strong>I</strong>nput <strong>O</strong>utput, “&lt;stdlib.h&gt;” is header file for <strong>St</strong>andar<strong>d</strong> <strong>Lib</strong>rary. 
One easy way to differentiate these two header files is that “&lt;stdio.h&gt;” contains declaration of <em>printf()</em> and <em>scanf()</em> while “&lt;stdlib.h&gt;” contains declaration of <em>malloc() </em>and <em>free()</em>. 
In that sense, the main difference in these two header files can considered that, while “&lt;stdio.h&gt;” contains header information for ‘File related Input/Output’ functions, “&lt;stdlib.h&gt;” contains header information for ‘Memory Allocation/Freeing’ functions. 
</span>
<p style="text-align: justify"><span style="font-weight: 400">Wait a minute, you said &#8220;&lt;stdio.h&gt;&#8221; is for file related IO but <em>printf()</em> and <em>scanf()</em> don&#8217;t deal with files&#8230; or are they? As  a basic principle, in C (due to its association with UNIX history), keyboard and display are also treated as &#8216;files&#8217;! In fact keyboard input is the default <em>stdin</em> file stream while display output is the default <em>stdout</em> file stream. 
Also, please note that, though “&lt;stdlib.h&gt;” contains declaration of other types of functions as well that aren’t related to memory such as <em>atoi()</em>, <em>exit()</em>, <em>rand()</em> etc. 
yet for our purpose and simplicity, we can remember <em>malloc()</em> and <em>free()</em> for “&lt;stdlib.h&gt;”.</span>
<p style="text-align: justify"><span style="font-weight: 400">It should be noted that a header file can contain not only function declaration but definition of constants and variables as well. 
Even macros and definition of new data types can also be added in a header file. </span>
<p style="text-align: justify"><span style="font-weight: 400">Please do Like/Tweet/G+1 if you find the above useful. 
Also, please do leave us comment for further clarification or info. 
We would love to help and learn 🙂</span>
<h2>How to print a variable name in C?</h2>
How to print and store a variable name in  string variable?<!--more-->
<strong>We strongly recommend you to minimize your browser and try this yourself first</strong>
In C, there’s a # directive, also called ‘Stringizing Operator’, which does this magic. 
Basically # directive converts its argument in a string. 
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define getName(var)&nbsp; #var </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">myVar; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, getName(myVar)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
<b>Output:</b>
<pre>
myVar
</pre>
</br>
We can also store variable name in a string using <a href="http://quiz.geeksforgeeks.org/sprintf-in-c/">sprintf() in C</a>.
<code class="preprocessor"># include &lt;stdio.h> </code>
<code class="preprocessor"># define getName(var, str)&nbsp; sprintf(str, "%s", #var)&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">myVar; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">getName(myVar, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
<b>Output:</b>
<pre>
myVar
</pre>
<h2>Constants in C/C++</h2>
As the name suggests the name constants is given to such variables or values in C/C++ programming language which cannot be modified once they are defined. 
They are fixed values in a program. 
There can be any types of constants like integer, float, octal, hexadecimal, character constants etc. 
Every constant has some range. 
The integers that are too big to fit into an int will be taken as long. 
Now there are various ranges that differ from unsigned to signed bits. 
Under the signed bit, the range of an int varies from -128 to +127 and under the unsigned bit, int varies from 0 to 255. 
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Constants-in-C.png" alt="" class="aligncenter size-full wp-image-257009" srcset="https://www.geeksforgeeks.org/wp-content/uploads/Constants-in-C.png 800w, https://www.geeksforgeeks.org/wp-content/uploads/Constants-in-C-300x146.png 300w, https://www.geeksforgeeks.org/wp-content/uploads/Constants-in-C-768x372.png 768w, https://www.geeksforgeeks.org/wp-content/uploads/Constants-in-C-660x320.png 660w" sizes="(max-width: 800px) 100vw, 800px" />
<strong>Defining Constants:</strong><br />
In C/C++ program we can define constants in two ways as shown below:
<ol>
<li>Using <em>#define</em> preprocessor directive</li>
<li>Using a <em>const</em> keyword</li>
</ol>
<strong>Literals:</strong> The values assigned to each constant variables are referred to as the <em>literals</em>. 
Generally, both terms, constants and literals are used interchangeably. 
For eg, &#8220;<em>const int = 5;</em>&#8220;, is a constant expression and the value 5 is refered to as constant integer literal.<br />
Refer here for various <a href="https://www.geeksforgeeks.org/types-of-literals-in-c-c-with-examples/" rel="noopener">Types of Literals in C++</a>.
Let us now learn about above two ways in details:
<ol>
<li>
<strong>Using <em>#define</em> preprocessor directive:</strong> This directive is used to declare an alias name for existing variable or any value. 
We can use this to declare a constant as shown below:
<pre>#define identifierName value</pre>
<ul>
<li><strong>identifierName:</strong> It is the name given to constant.</li>
<li><strong>value:</strong> This refers to any value assigned to identifierName.</li>
</ul>
<strong>Example:</strong><br />
<h3>C</h3>
<code class="preprocessor">#include&lt;stdio.h>&nbsp; </code>
<code class="preprocessor">#define val 10&nbsp; </code>
<code class="preprocessor">#define floatVal 4.5&nbsp; </code>
<code class="preprocessor">#define charVal 'G'&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integer Constant: %d\n"</code><code class="plain">,val);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Floating point Constant: %.1f\n"</code><code class="plain">,floatVal);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Character Constant: %c\n"</code><code class="plain">,charVal);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define val 10&nbsp; </code>
<code class="preprocessor">#define floatVal 4.5&nbsp; </code>
<code class="preprocessor">#define charVal 'G'&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Integer Constant: "</code> <code class="plain">&lt;&lt; val &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Floating point Constant: "</code> <code class="plain">&lt;&lt; floatVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Character Constant: "</code><code class="plain">&lt;&lt; charVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Integer Constant: 10
Floating point Constant: 4.5
Character Constant: G
</pre>
Refer<a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/"> Macros and Preprocessors in C</a> for details.
</li>
<li>
<strong>using a <em>const</em> keyword</strong>: Using <em>const</em> keyword to define constants is as simple as defining variables, the difference is you will have to precede the definition with a <em>const</em> keyword. 
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/How-To-Declare-Constants.png" alt="">
Below program shows how to use const to declare costants of different data types:<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// int constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">intVal = 10;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Real constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">float</code> <code class="plain">floatVal = 4.14; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// char constant&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">charVal = </code><code class="string">'A'</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// string constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">stringVal[10] = </code><code class="string">"ABC"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integer constant:%d \n"</code><code class="plain">, intVal ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Floating point constant: %.2f\n"</code><code class="plain">, floatVal ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Character constant: %c\n"</code><code class="plain">, charVal ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String constant: %s\n"</code><code class="plain">, stringVal); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// int constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">intVal = 10;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Real constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">float</code> <code class="plain">floatVal = 4.14; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// char constant&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">charVal = </code><code class="string">'A'</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// string constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="plain">string stringVal = </code><code class="string">"ABC"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Integer Constant: "</code> <code class="plain">&lt;&lt; intVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Floating point Constant: "</code> <code class="plain">&lt;&lt; floatVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Character Constant: "</code><code class="plain">&lt;&lt; charVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"String Constant: "</code><code class="plain">&lt;&lt; stringVal &lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
Integer constant: 10 
Floating point constant: 4.14
Character constant: A 
String constant: ABC 
</pre>
Refer <a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">Const Qualifier in C for details</a>.</li></ol>
<h2>How a Preprocessor works in C?</h2>
<a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/">Compiling a C program &#8211; Behind the Scene</a>
A Preprocessor is a system software (a computer program that is designed to run on computer&#8217;s hardware and application programs). 
It performs preprocessing of the High Level Language(HLL). 
Preprocessing is the first step of the language processing system. 
Language processing system translates the high level language to machine level language or absolute machine code(i.e. 
to the form that can be understood by machine).
<ul>
<li>The preprocessor doesn&#8217;t know about the scope rules of C. 
Preprocessor directives like #define  come into effect as soon as they are seen and remain in effect until the end of the file that contains them; the program&#8217;s block structure is irrelevant.</li>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Preprocessor.png">
<strong>A Preprocessor mainly performs three tasks on the HLL code :</strong>
<ol>
<li><strong>Removing comments :</strong> It removes all the comments. 
A comment is written only for the humans to understand the code. 
So, it is obvious that they are of no use to a machine. 
So, preprocessor removes all of them as they are not required in the execution and won&#8217;t be executed as well.
This is how to see a file with removed comments in linux) :<br />
Write a C code (let the file name be <em>prog.c</em>). 
Preprocess it using the command <strong>gcc -E prog.c</strong>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Capture-1.png"><br />
You will see the output with the code having no comments.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/1-2.png"><br />
This file is saved with a &#8216;.i&#8217; extension (prog.i) which will be input to the compiler.
</li>
<li><strong>File inclusion : </strong>Including all the files from library that our program needs. 
In HLL we write <strong>#include</strong> which is a directive for the preprocessor that tells it to include the contents of the library file specified. 
For example, #include<stdio.h> will tell the preprocessor to include all the contents in the library file stdio.h.<br />
This can also be written using double quotes &#8211; #include &#8220;stdio.h&#8221;<br />
<strong>Note:</strong> If the filename is enclosed within angle brackets, the file is searched for in the standard compiler include paths. 
If the filename is enclosed within double quotes, the search path is expanded to include the current source directory.
</li>
<li><strong><a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Macro</a> expansion : </strong> Macros can be called as small functions that are not as overhead to process. 
If we have to write a function (having a small definition) that needs to be called recursively (again and again), then we should prefer a macro over a function.<br />
So, defining these macros is done by preprocessor. 
<pre><strong>#define SI 1000</strong></pre>
is a simple example of a macro.
<ul>
<li>
There are two types of macros: Object-like (do not take parameters) and function-like (Can take parameters)
<pre>// object-like macro
#define <identifier> <replacement token list>      
// function-like macro          
#define <identifier>(<parameter list>) <replacement token list>  </pre>
</li>
<li>You can delete a macro definition  with #undef:
<pre>
// delete the macro
# undef <identifier></li>    
<li> We can write <a href="https://www.geeksforgeeks.org/multiline-macros-in-c/">multi-line macro</a> same like function, but each statement ends with “\”. 
                
                    
    
        
<i id="run-and-edit-button" title="Edit Code" lang="cpp"  class="material-icons code-sidebar-button">edit</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="cpp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i>
<i title="Dark Mode" class="material-icons code-sidebar-button dark-editor-button">brightness_4</i>
        
    
                    
                    <table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><code class="preprocessor">#include &lt;stdio.h> </code><code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;<code class="preprocessor">#define MACRO(num, str) {\ </code><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, num);\ </code><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" is"</code><code class="plain">);\ </code><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %s number"</code><code class="plain">, str);\ </code><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">);\ </code><code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}</code></td></tr></tbody></table>
                    
                
                
                    </li></ol>
<h2>C/C++ Preprocessors</h2>
As the name suggests Preprocessors are programs that process our source code before compilation. 
There are a number of steps involved between writing a program and executing a program in C / C++. 
Let us have a look at these steps before we actually start learning about Preprocessors.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Preprocessor-In-C.png" alt="">
You can see the intermediate steps in the above diagram. 
The source code written by programmers is stored in the file program.c. 
This file is then processed by preprocessors and an expanded source code file is generated named program. 
This expanded file is compiled by the compiler and an object code file is generated named program .obj. 
Finally, the linker links this object code file to the object code of the library functions to generate the executable file program.exe. 

Preprocessor programs provide preprocessors directives which tell the compiler to preprocess the source code before compiling. 
All of these preprocessor directives begin with a &#8216;#&#8217; (hash) symbol. 
This (&#8216;#&#8217;) symbol at the beginning of a statement in a C/C++ program indicates that it is a pre-processor directive. 
We can place these preprocessor directives anywhere in our program. 
Examples of some preprocessor directives are: <em>#include</em>, <em>#define</em>, <em>#ifndef</em> etc.
<strong>There are 4 main types of preprocessor directives:</strong>
<ol>
<li>Macros</li>
<li>File Inclusion</li>
<li>Conditional Compilation</li>
<li>Other directives</li>
</ol>
Let us now learn about each of these directives in details.
<ul>
<li>
<strong>Macros</strong>: Macros are a piece of code in a program which is given some name. 
Whenever this name is encountered by the compiler the compiler replaces the name with the actual piece of code. 
The &#8216;#define&#8217; directive is used to define a macro. 
Let us now understand the macro definition with the help of a program:<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// macro definition </code>
<code class="preprocessor">#define LIMIT 5 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; LIMIT; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d \n"</code><code class="plain">,i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// macro definition </code>
<code class="preprocessor">#define LIMIT 5 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; LIMIT; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; i &lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
0
1
2
3
4
</pre>
In the above program, when the compiler executes the word LIMIT it replaces it with 5. 
The word &#8216;LIMIT&#8217; in the macro definition is called a macro template and &#8216;5&#8217; is macro expansion.<br />
<strong>Note</strong>: There is no semi-colon(&#8216;;&#8217;) at the end of macro definition. 
Macro definitions do not need a semi-colon to end.
<strong>Macros with arguments</strong>: We can also pass arguments to macros. 
Macros defined with arguments works similarly as functions. 
Let us understand this with a program:<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// macro with parameter </code>
<code class="preprocessor">#define AREA(l, b) (l * b) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">l1 = 10, l2 = 5, area; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">area = AREA(l1, l2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Area of rectangle is: %d"</code><code class="plain">, area); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// macro with parameter </code>
<code class="preprocessor">#define AREA(l, b) (l * b) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">l1 = 10, l2 = 5, area; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">area = AREA(l1, l2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; </code><code class="string">"Area of rectangle is: "</code> <code class="plain">&lt;&lt; area; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
Area of rectangle is: 50
</pre>
We can see from the above program that whenever the compiler finds AREA(l, b) in the program it replaces it with the statement (l*b) . 
Not only this, the values passed to the macro template AREA(l, b) will also be replaced in the statement (l*b). 
Therefore AREA(10, 5) will be equal to 10*5.
</li>
<li>
<strong>File Inclusion</strong>: This type of preprocessor directive tells the compiler to include a file in the source code program. 
There are two types of files which can be included by the user in the program:
<ol>
<li>
<strong>Header File or Standard files</strong>: These files contains definition of pre-defined functions like printf(), scanf() etc. 
These files must be included for working with these functions. 
Different function are declared in different header files. 
For example standard I/O funuctions are in &#8216;iostream&#8217; file whereas functions which perform string operations are in &#8216;string&#8217; file.<br />
<strong>Syntax</strong>:
          
<pre>
#include&lt; <em>file_name </em>&gt;
</pre>
where <em>file_name</em> is the name of file to be included. 
The &#8216;&lt;&#8216; and &#8216;&gt;&#8217; brackets tells the compiler to look for the file in standard directory.
</li>
<li>
<strong>user defined files</strong>: When a program becomes very large, it is good practice to divide it into smaller files and include whenever needed. 
These types of files are user defined files. 
These files can be included as:
<pre>
#include"<em>filename</em>"
</pre></li></ol>
</li>
<li>
<strong>Conditional Compilation</strong>: Conditional Compilation directives are type of directives which helps to compile a specific portion of the program or to skip compilation of some specific part of the program based on some conditions. 
This can be done with the help of two preprocessing commands &#8216;<strong>ifdef</strong>&#8216; and &#8216;<strong>endif</strong>&#8216;.<br />
<strong>Syntax</strong>:
<pre>
#ifdef macro_name
    statement1;
    statement2;
    statement3;
    .
    .
    .
    statementN;
#endif
</pre>
If the macro with name as &#8216;<em>macroname</em>&#8216; is defined then the block of statements will execute normally but if it is not defined, the compiler will simply skip this block of statements.
</li>
<li>
<strong>Other directives</strong>: Apart from the above directives there are two more directives which are not commonly used. 
These are:
<ol>
<li>
<strong>#undef Directive</strong>: The #undef directive is used to undefine an existing macro. 
This directive works as:
<pre>
#undef LIMIT
</pre>
Using this statement will undefine the existing macro LIMIT. 
After this statement every &#8220;#ifdef LIMIT&#8221; statement will evaluate to false.
</li>
<li>
<strong>#pragma Directive</strong>: This directive is a special purpose directive and is used to turn on or off some features. 
This type of directives are compiler-specific i.e., they vary from compiler to compiler. 
Some of the #pragma directives are discussed below:
<ul>
<li>
<strong>#pragma startup</strong> and <strong>#pragma exit</strong>: These directives helps us to specify the functions that are needed to run before program startup( before the control passes to main()) and just before program exit (just before the control returns from main()).<br />
<strong>Note:</strong> Below program will not work with GCC compilers.<br />
Look at the below program:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func1(); </code>
<code class="keyword bold">void</code> <code class="plain">func2(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#pragma startup func1 </code>
<code class="preprocessor">#pragma exit func2 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside func1()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside func2()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">func1(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">func2(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside main()\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Inside func1()
Inside main()
Inside func2()
</pre>
The above code will produce the output as given below when run on GCC compilers:
<pre>
Inside main()
</pre>
This happens because GCC does not supports #pragma startup or exit. 
However you can use the below code for a similar output on GCC compilers.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func1(); </code>
<code class="keyword bold">void</code> <code class="plain">func2(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">__attribute__((constructor)) func1(); </code>
<code class="keyword bold">void</code> <code class="plain">__attribute__((destructor)) func2(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func1() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside func1()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func2() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside func2()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside main()\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</li>
<li>
<strong>#pragma warn Directive:</strong> This directive is used to hide the warning message which are displayed during compilation.<br />
We can hide the warnings as shown below:
<ul>
<li><strong>#pragma warn -rvl</strong>:  This directive hides those warning which are raised when a function which is supposed to return a value does not returns a value.</li>
<li><strong>#pragma warn -par</strong>: This directive hides those warning which are raised when a function does not uses the parameters passed to it.</li>
<li><strong>#pragma warn -rch</strong>: This directive hides those warning which are raised when a code is unreachable. 
For example: any code written after the <em>return</em> statement in a function is unreachable.</li>
</ul>
</li>
</ul></li></ol>
</li>
</ul>
<h2>C/C++ Preprocessor directives | Set 2</h2>
<a href="https://www.geeksforgeeks.org/cc-preprocessors/">C/C++ Preprocessor directives basics</a>
<strong>Preprocessor directives:</strong> In almost every program we come across in C/C++, we see a few lines at the top of the program preceded by a hash (#) sign. 
These lines are preprocessed by the compiler before actual compilation begins. 
The end of these lines are identified by the newline character &#8216;\n&#8217; , no semicolon &#8216;;&#8217; is needed to terminate these lines.<br />
Preprocessor directives are mostly used in defining macros, evaluating conditional statements, source file inclusion, pragma directive, line control, error detection etc.
<strong>In this post, we will discuss about some more types of preprocessor directives given below:</strong>
<ol>
<li>Conditional Compilation</li>
<li>Line control</li>
<li>Error directive</li>
</ol>
Let us now have a look about each one of these directives in details:
<ul>
<li>
<strong>Conditional Compilation</strong>: Conditional Compilation directives help to compile a specific portion of the program or let us skip compilation of some specific part of the program based on some conditions. 
In our <a href="https://www.geeksforgeeks.org/cc-preprocessors/">previous article</a>, we have discussed about two such directives &#8216;<strong>ifdef</strong>&#8216; and &#8216;<strong>endif</strong>&#8216;. 
In this post we will discuss <strong>#ifndef</strong>, <strong>#if</strong>,<strong> #else </strong>and<strong> #elif</strong>.
<ol>
<li><b>#ifdef</b>: This directive is the simplest conditional directive. 
This block is called a conditional group. 
The controlled text will get included in the preprocessor output iff the macroname is defined. 
The controlled text inside a conditional will embrace preprocessing directives. 
They are executed only if the conditional succeeds. 
You can nest these in multiple layers, but they must be completely nested. 
In other words, ‘#endif’ always matches the nearest ‘#ifdef’ (or ‘#ifndef’, or ‘#if’). 
Also, you can&#8217;t begin a conditional group in one file and finish it in another.
<b>Syntax:</b>
<pre>#ifdef MACRO
    controlled text
#endif /* macroname */
</pre>
</li>
<li><strong>#ifndef</strong>: We know that the in #ifdef directive if the macroname is defined, then the block of statements following the #ifdef directive will execute normally but if it is not defined, the compiler will simply skip this block of statements. 
The #ifndef directive is simply opposite to that of the #ifdef directive. 
In case of #ifndef , the block of statements between #ifndef and #endif will be executed only if the macro or the identifier with #ifndef is not defined.<br />
<strong>Syntax :</strong>
<pre>
ifndef macro_name
    statement1;
    statement2;
    statement3;
    .
    .
    .
    statementN;
endif
</pre>
If the macro with name as ‘macroname‘ is not defined using the #define directive then only the block of statements will execute.
</li>
<li>
<strong>#if, #else and #elif</strong>: These directives works together and control compilation of portions of the program using some conditions. 
If the condition with the #if directive evaluates to a non zero value, then the group of line immediately after the #if directive will be executed otherwise if the condition with the #elif directive evaluates to a non zero value, then the group of line immediately after the #elif directive will be executed else the lines after #else directive will be executed.<br />
<strong>Syntax:</strong>
<pre>
#if macro_condition
   statements
#elif macro_condition
   statements
#else
   statements
#endif
</pre>
Example:
<code class="preprocessor">#include&lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define gfg 7 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="preprocessor">#if gfg > 200 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef gfg </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#define gfg 200 </code>
<code class="preprocessor">#elif gfg &lt; 50 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef gfg </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#define gfg 50 </code>
<code class="preprocessor">#else </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#undef gfg </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#define gfg 100 </code>
<code class="preprocessor">#endif </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">std::cout &lt;&lt; gfg;&nbsp; </code><code class="comments">// gfg = 50 </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
Output:
<pre>
50
</pre>
Notice how the entire structure of #if, #elif and #else chained directives ends with #endif.</li></ol>
</li>
<li>
<strong>Line control ( #line )</strong>: Whenever we compile a program, there are chances of occurrence of some error in the program. 
Whenever compiler identifies error in the program it provides us with the filename in which error is found along with the list of lines and with the exact line numbers where the error is. 
This makes easy for us to find and rectify error.<br />
However we can control what information should the compiler provide during errors in compilation using the #line directive.<br />
<strong>Syntax:</strong>
<pre>
#line number "filename"
</pre>
<strong>number</strong> &#8211; line number that will be assigned to the next code line. 
The line numbers of successive lines will be increased one by one from this point on.<br />
<strong>&#8220;filename&#8221;</strong> &#8211; optional parameter that allows to redefine the file name that will be shown.
</li>
<li><strong> Error directive ( #error )</strong>: This directive aborts the compilation process when it is found in the program during compilation and produces an error which is optional and can be specified as a parameter.<br />
<strong>Syntax:</strong>
<pre>
#error optional_error
</pre>
Here, <strong>optional_error</strong> is any error specified by the user which will be shown when this derective is found in the program.<br />
Example:
<code class="preprocessor">#ifndef GeeksforGeeks </code>
<code class="preprocessor">#error GeeksforGeeks not found ! </code>
<code class="preprocessor">#endif&nbsp;&nbsp; </code>
Output:
<pre>
error: #error GeeksforGeeks not found !
</pre>
</li>
</ul>
<h2>isgraph() C library function</h2>
The C library function <strong> isgraph()</strong> checks whether a character is a graphic character or not.<br />
Characters that have graphical representation are known are <strong>graphic characters</strong>. 
For example: &#8216;:&#8217; &#8216;;&#8217;  &#8216;?&#8217;  &#8216;@&#8217; etc.
<strong>Syntax &#8211;</strong>
<pre>#include &lt;ctype.h>
int isgraph(int ch);
</pre>
<strong>Return Value &#8211;</strong>  function returns <strong>nonzero </strong> if ch is any printable character other than a space, else it returns 0.
For ASCII environments, printable characters are in the range of <strong>0X21 </strong>through <strong> 0X7E</strong>.
<b>Code &#8211;</b>
<code class="comments">// code to check graphical character </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">var1 = </code><code class="string">'g'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">var2 = </code><code class="string">' '</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">var3 = </code><code class="string">'1'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isgraph</code><code class="plain">(var1))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var1 = |%c| can be printed\n"</code><code class="plain">, var1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var1 = |%c| can't be printed\n"</code><code class="plain">, var1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isgraph</code><code class="plain">(var2))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var2 = |%c| can be printed\n"</code><code class="plain">, var2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var2 = |%c| can't be printed\n"</code><code class="plain">, var2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isgraph</code><code class="plain">(var3))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var3 = |%c| can be printed\n"</code><code class="plain">, var3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"var3 = |%c| can't be printed\n"</code><code class="plain">, var3); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<b>Output &#8211;</b>
<pre>
var1 = |g| can be printed
var2 = | | can't be printed
var3 = |1| can be printed
</pre>
<b>Code &#8211;</b>
<code class="comments">// code to print all Graphical Characters </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In C programming All graphic "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"characters are: \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;= 127; ++i)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isgraph</code><code class="plain">(i) != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c "</code><code class="plain">, i);&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output &#8211;</b>
<pre>
In C programming All graphic characters are: 
! " # $ % &amp; ' ( ) * +, - . 
/ 0 1 2 3 4 5 6 7 8 9 
: ;  ? @ A B C D E F G H I J K L M N O P Q R S T U
 V W X Y Z [ \ ] ^ _ ` a b c d e f g h i j k l m n
 o p q r s t u v w x y z { | } ~ 
</pre>
<h2>How to write your own header file in C?</h2>
As we all know that files with .h extension  are called <b>header files </b>in C. 
These header files generally contain function declarations which we can be used in our main C program, like for e.g. 
there is need to include stdio.h in our C program to use function printf() in the program. 
So the question arises, is it possible to create your own header file?
The answer to the above is <strong>yes</strong>. 
header files are simply files in which you can declare your own functions that you can use in your main program or these can be used while writing large C programs.<br />
<b>NOTE:</b>Header files generally contain definitions of data types, function prototypes and C preprocessor commands.
<strong>Below is the short example of creating your own header file and using it accordingly.</strong>
<ol>
<li><strong>Creating myhead.h : </strong>Write the below code and then save the file as <b>myhead.h</b> or you can give any name but the extension should be .h indicating its a header file.
<code class="comments">// It is not recommended to put function definitions&nbsp; </code>
<code class="comments">// in a header file. 
Ideally there should be only </code>
<code class="comments">// function declarations. 
Purpose of this code is </code>
<code class="comments">// to only demonstrate working of header files. 
</code>
<code class="keyword bold">void</code> <code class="plain">add(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Added value=%d\n"</code><code class="plain">, a + b); </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">multiply(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Multiplied value=%d\n"</code><code class="plain">, a * b); </code>
<code class="plain">} </code>
</li>
<li><strong>Including the .h file in other program :</strong> Now as we need to include stdio.h as #include in order to use printf() function. 
We will also need to include the above header file myhead.h as <b>#include&#8221;myhead.h&#8221;</b>. 
The &#8221; &#8221; here are used to instructs the <a href="https://www.geeksforgeeks.org/cc-preprocessors/">preprocessor </a>to look into the present folder and into the standard folder of all header files if not found in present folder. 
So, if you wish to use angular brackets instead of &#8221; &#8221; to include your header file you can save it in the standard folder of header files otherwise. 
If you are using &#8221; &#8221; you need to ensure that the header file you created is saved in the same folder in which you will save the C file using this header file.</li>
<li><strong>Using the created header file : </strong>
<code class="comments">// C program to use the above created header file </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include "myhead.h" </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">add(4, 6); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*This calls add function written in myhead.h&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">and therefore no compilation error.*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">multiply(5, 5); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Same for the multiply function in myhead.h </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"BYE!See you Soon"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Added value:10
Multiplied value:25
BYE!See you Soon
</pre>
<b>NOTE : </b>The above code compiles successfully and prints the above output only if you have created the header file and saved it in the same folder the above c file is saved.</li>
</ol>
<strong>Important Points:</strong><br />
The creation of header files are needed generally while writing large C programs so that the modules can share the function definitions, prototypes etc.
<ul>
<li>Function and type declarations, global variables, structure declarations and in some cases, inline functions; definitions  which need to be centralized in one file.</li>
<li>In a header file, do not use redundant or other header files; only minimal set of statements.</li>
<li>Don’t put function definitions in a header. 
Put these things in a separate .c file.</li>
<li>Include Declarations for functions and variables whose definitions will be visible to the linker. 
Also, definitions of data structures and enumerations that are shared among multiple source files.</li>
<li>In short, Put only what is necessary and keep the header file concised.</li>
</ul>
This article is merely to give you idea about the creation of header files and using the same but this is not what actually happens when you write a large C program. 
The creation of header files are needed generally while writing large C programs so that the modules can share the function definitions, prototypes etc.
<h2>difftime() C library function</h2>
The C library function <strong>difftime()</strong> returns the difference, in <em>seconds</em> between <em>starting time</em> and <em>ending time.</em>(<strong>ending time-starting time</strong>)
<pre>
// It is present in time.h header file
#include 
<strong>Syntax : </strong>
double difftime(time_t time2, time_t time1);
<strong>Parameters:</strong>
time1 : Lower bound of the time interval
        whose length is calculated.
time2 : Higher bound of the time interval
        whose length is calculated.
<strong>Return value : </strong>
Returns the difference between time1 and 
time2 (as measured in seconds).</font>
</pre>
<code class="comments">// C program to demonstrate working of </code>
<code class="comments">// difftime() </code>
<code class="preprocessor">#include &lt;time.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sec; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">time_t</code> <code class="plain">time1, time2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Current time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">time</code><code class="plain">(&time1);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(sec = 1; sec &lt;= 6; sec++)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sleep(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// time after sleep in loop. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">time</code><code class="plain">(&time2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Difference is&nbsp; %.2f seconds"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">difftime</code><code class="plain">(time2, time1)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Difference is 6.00 seconds
</pre>
<h2>tmpnam() function in C</h2>
The tmpnam() function is a special function which is declared inside &#8220;stdio.h&#8221; header file. 
It generates a different temporary file name each time it is called up to at least TMP_MAX names. 
Here TMP_MAX represents maximum number of different file names that can be produce by tmpnam() function. 
If it is called more than TMP_MAX times, the behavior is implementation dependent.Here, L_tmpnam define the size needed for an array of char to hold the result of tmpnam.
<strong>Syntax :</strong>
<pre><strong>char *tmpnam(char *str)</strong>
<strong>s :</strong> The character array to copy the file name.
It generates and returns a valid temporary 
filename which does not exist. 
If str is null then it simply returns the tmp file name.</pre>
<code class="comments">// C program to generate random temporary file names. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// L_tmpnam declared in the stdio.h file. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// L_tmpnam define length of the generated file name. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">generate[L_tmpnam + 1]; </code><code class="comments">// Add +1 for the null character. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">tmpnam</code><code class="plain">(generate); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(generate); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
The file names are dependent on running machine, which can be anything.
Example: /tmp/fileRTOA0m
         \s260.
         \s3ok.
         \s5gg. 
etc
</pre>
<h2>_Generic keyword in C</h2>
A major drawback of <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Macro in C/C++</a>  is that the arguments are strongly typed checked i.e. 
a macro can operate on different types of variables(like char, int ,double,..) without type checking.
<code class="comments">// C program to illustrate macro function. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define INC(P) ++P </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*p = </code><code class="string">"Geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s&nbsp; "</code><code class="plain">, INC(p)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, INC(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
eeks 11
</pre>
Therefore we avoid to use Macro. 
But after the implementation of C11 standard in C programming, we can use Macro with the help of a new keyword i.e. 
&#8220;_Generic&#8221;. 
We can define MACRO for the different types of data types. 
For example, the following macro INC(x) translates to INCl(x), INC(x) or INCf(x) depending on the type of x:
<pre>
#define INC(x) _Generic((x), long double: INCl, \
      default: INC, \
      float: INCf)(x)
</pre>
Example:-
<code class="comments">// C program to illustrate macro function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// _Generic keyword acts as a switch that chooses&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// operation based on data type of argument. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, _Generic( 1.0L, </code><code class="color1 bold">float</code><code class="plain">:1, </code><code class="color1 bold">double</code><code class="plain">:2,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">double</code><code class="plain">:3, </code><code class="keyword bold">default</code><code class="plain">:0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, _Generic( 1L, </code><code class="color1 bold">float</code><code class="plain">:1, </code><code class="color1 bold">double</code><code class="plain">:2,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">double</code><code class="plain">:3, </code><code class="keyword bold">default</code><code class="plain">:0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, _Generic( 1.0L, </code><code class="color1 bold">float</code><code class="plain">:1, </code><code class="color1 bold">double</code><code class="plain">:2,&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">double</code><code class="plain">:3)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
Note: If you are running C11 compiler then the below mentioned output will be come.
<pre>
3
0
3
</pre>
<code class="comments">// C program to illustrate macro function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define geeks(T) _Generic( (T), char: 1, int: 2, long: 3, default: 0) </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// char returns ASCII value which is int type.&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, geeks(</code><code class="string">'A'</code><code class="plain">));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Here A is a string. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,geeks(</code><code class="string">"A"</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
2
0
</pre>
<h2>C Library math.h functions</h2>
The <strong>math.h</strong> header defines various mathematical functions and one macro. 
All the functions available in this library take <strong>double</strong> as an argument and return <strong>double</strong> as the result. 
Let us discuss some important functions one by one.
1. 
<strong>double ceil(double x)</strong>: The C library function double ceil(double x) returns the smallest integer value greater than or equal to x. 
<pre>syntax : double ceil(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of ceil function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="color1 bold">float</code> <code class="plain">val1, val2, val3, val4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">val1 = 1.6; </code>
<code class="plain">val2 = 1.2; </code>
<code class="plain">val3 = -2.8; </code>
<code class="plain">val4 = -2.3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"value1 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">ceil</code><code class="plain">(val1)); </code>
<code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"value2 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">ceil</code><code class="plain">(val2)); </code>
<code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"value3 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">ceil</code><code class="plain">(val3)); </code>
<code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"value4 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">ceil</code><code class="plain">(val4)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
value1 = 2.0
value2 = 2.0
value3 = -2.0
value4 = -2.0
</pre>
2. 
<strong>double floor(double x): </strong> The C library function double floor(double x) returns the largest integer value less than or equal to x. 
<pre>syntax : double floor(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of floor function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">val1, val2, val3, val4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val1 = 1.6; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val2 = 1.2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val3 = -2.8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val4 = -2.3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value1 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">floor</code><code class="plain">(val1)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value2 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">floor</code><code class="plain">(val2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value3 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">floor</code><code class="plain">(val3)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value4 = %.1lf\n"</code><code class="plain">, </code><code class="functions bold">floor</code><code class="plain">(val4)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Value1 = 1.0
Value2 = 1.0
Value3 = -3.0
Value4 = -3.0
</pre>
3. 
<strong>double fabs(double x)</strong>: The C library function double fabs(double x) returns the absolute value of x.
<pre>syntax : double fabs(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of fabs function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a, b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 1234; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">b = -344; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The absolute value of %d is %lf\n"</code><code class="plain">, a, </code><code class="functions bold">fabs</code><code class="plain">(a)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The absolute value of %d is %lf\n"</code><code class="plain">, b, </code><code class="functions bold">fabs</code><code class="plain">(b)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The absolute value of 1234 is 1234.000000
The absolute value of -344 is 344.000000
</pre>
4. 
<strong>double log(double x)</strong>: The C library function double log(double x) returns the natural logarithm (base-e logarithm) of x.
<pre>syntax : double log(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of log function </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, ret; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 2.7; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* finding log(2.7) */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">log</code><code class="plain">(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"log(%lf) = %lf"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
log(2.700000) = 0.993252
</pre>
5. 
<strong>double log10(double x)</strong>: The C library function double log10(double x) returns the common logarithm (base-10 logarithm) of x.
<pre>syntax : double log10(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of log10 function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, ret; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 10000; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* finding value of log1010000 */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">log10</code><code class="plain">(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"log10(%lf) = %lf\n"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
log10(10000.000000) = 4.000000
</pre>
6. 
<strong>double fmod(double x, double y) </strong>: The C library function double fmod(double x, double y) returns the remainder of x divided by y.
<pre>syntax : double fmod(double x, double y) </pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of fmod function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">a, b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">a = 8.2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">b = 5.7; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">c = 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Remainder of %f / %d is %lf\n"</code><code class="plain">, a, c, </code><code class="functions bold">fmod</code><code class="plain">(a, c)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Remainder of %f / %f is %lf\n"</code><code class="plain">, a, b, </code><code class="functions bold">fmod</code><code class="plain">(a, b)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
          
<pre>
Remainder of 8.200000 / 3 is 2.200000
Remainder of 8.200000 / 5.700000 is 2.500000
</pre>
7. 
<strong>double sqrt(double x)</strong>: The C library function double sqrt(double x) returns the square root of x.
<pre>syntax : double sqrt(double x)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of sqrt function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Square root of %lf is %lf\n"</code><code class="plain">, 225.0, </code><code class="functions bold">sqrt</code><code class="plain">(225.0) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Square root of %lf is %lf\n"</code><code class="plain">, 300.0, </code><code class="functions bold">sqrt</code><code class="plain">(300.0) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Square root of 225.000000 is 15.000000
Square root of 300.000000 is 17.320508
</pre>
8. 
<strong>double pow(double x, double y)</strong>: The C library function double pow(double x, double y) returns x raised to the power of y i.e. 
xy.
<pre>syntax : double pow(double x, double y)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of pow function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value 8.0 ^ 3 = %lf\n"</code><code class="plain">, </code><code class="functions bold">pow</code><code class="plain">(8.0, 3)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value 3.05 ^ 1.98 = %lf"</code><code class="plain">, </code><code class="functions bold">pow</code><code class="plain">(3.05, 1.98)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Value 8.0 ^ 3 = 512.000000
Value 3.05 ^ 1.98 = 9.097324
</pre>
9. 
<strong>double modf(double x, double *integer)</strong>: The C library function double modf(double x, double *integer) returns the fraction component (part after the decimal), and sets integer to the integer component.
<pre>syntax : double modf(double x, double *integer)</pre>
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of modf function </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, fractpart, intpart; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 8.123456; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">fractpart = </code><code class="functions bold">modf</code><code class="plain">(x, &intpart); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integral part = %lf\n"</code><code class="plain">, intpart); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Fraction Part = %lf \n"</code><code class="plain">, fractpart); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Integral part = 8.000000
Fraction Part = 0.123456 
</pre>
10. 
<strong>double exp(double x)</strong>: The C library function double exp(double x) returns the value of e raised to the xth power.
<pre>syntax : double exp(double x)</pre>
Following code represents 
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of exp function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The exponential value of %lf is %lf\n"</code><code class="plain">, x, </code><code class="functions bold">exp</code><code class="plain">(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The exponential value of %lf is %lf\n"</code><code class="plain">, x+1, </code><code class="functions bold">exp</code><code class="plain">(x+1)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The exponential value of %lf is %lf\n"</code><code class="plain">, x+2, </code><code class="functions bold">exp</code><code class="plain">(x+2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The exponential value of 0.000000 is 1.000000
The exponential value of 1.000000 is 2.718282
The exponential value of 2.000000 is 7.389056
</pre>
11. 
<strong>double cos(double x) </strong>: The C library function double cos(double x) returns the cosine of a radian angle x.
          
<pre>syntax : double cos(double x) </pre>
<strong>Note : </strong>Same syntax can be used for other trignometric functions like sin, tan etc.
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of cos function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define PI 3.14159265 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, ret, val; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 60.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val = PI / 180.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">cos</code><code class="plain">( x*val ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The cosine of %lf is %lf degrees\n"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 90.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val = PI / 180.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">cos</code><code class="plain">( x*val ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The cosine of %lf is %lf degrees\n"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The cosine of 60.000000 is 0.500000 degrees
The cosine of 90.000000 is 0.000000 degrees
</pre>
12. 
<strong>double acos(double x) :</strong> The C library function double acos(double x) returns the arc cosine of x in radians.
<pre>syntax : double acos(double x)</pre>
<strong>Note : </strong>Same syntax can be used for other arc trignometric functions like asin, atan etc.
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of acos function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define PI 3.14159265 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, ret, val; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 0.9; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">val = 180.0 / PI; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">acos</code><code class="plain">(x) * val; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The arc cosine of %lf is %lf degrees"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The arc cosine of 0.900000 is 25.855040 degrees
</pre>
13. 
<strong>double tanh(double x): </strong> The C library function double tanh(double x) returns the hyperbolic tangent of x.
<pre>syntax : double tanh(double x) </pre>
<strong>Note : </strong>Same syntax can be used for other hyperbolic trignometric functions like sinh, cosh etc.
<code class="comments">// C code to illustrate </code>
<code class="comments">// the use of tanh function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x, ret; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 0.5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">tanh</code><code class="plain">(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The hyperbolic tangent of %lf is %lf degrees"</code><code class="plain">, x, ret); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The hyperbolic tangent of 0.500000 is 0.462117 degrees
</pre>
<h2>typedef versus #define in C</h2>
<strong>typedef</strong>: The typedef is used to give data type a new name. 
For example,
<code class="comments">// C program to demonstrate typedef </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// After this line BYTE can be used </code>
<code class="comments">// in place of unsigned char </code>
<code class="keyword bold">typedef</code> <code class="plain">unsigned </code><code class="color1 bold">char</code> <code class="color1 bold">BYTE</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">BYTE</code> <code class="plain">b1, b2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">b1 = </code><code class="string">'c'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c "</code><code class="plain">, b1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>c</pre>
<strong>#define</strong> in C is a directive which is used to #define alias. 
<br/>
<code class="comments">// C program to demonstrate #define </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// After this line HYD is replaced by </code>
<code class="comments">// "Hyderabad" </code>
<code class="preprocessor">#define HYD "Hyderabad" </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s "</code><code class="plain">, HYD); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>Hyderabad</pre>
<strong>Difference between typedef and #define:</strong>
<ol>
<li>typedef is limited to giving symbolic names to types only, whereas #define can be used to define an alias for values as well, e.g., you can define 1 as ONE, 3.14 as PI, etc.</li>
<li>typedef interpretation is performed by the compiler where #define statements are performed by preprocessor.</li>
<li>#define should not be terminated with a semicolon, but typedef should be terminated with semicolon.</li>
<li>#define will just copy-paste the definition values at the point of use, while typedef is the actual definition of a new type.</li>
<li>typedef follows the scope rule which means if a new type is defined in a scope (inside a function), then the new type name will only be visible till the scope is there. 
In case of #define, when preprocessor  encounters #define, it replaces all the occurrences, after that (No scope rule is followed).</li>
</ol>
<code class="comments">// C program to demonstrate importance </code>
<code class="comments">// of typedef over #define for data types </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">typedef</code> <code class="color1 bold">char</code><code class="plain">* ptr; </code>
<code class="preprocessor">#define PTR char* </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr a, b, c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">PTR x, y, z; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof a:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(a) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof b:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(b) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof c:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(c) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof x:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(x) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof y:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(y) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof z:%u\n"</code> <code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(z) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
sizeof a:8
sizeof b:8
sizeof c:8
sizeof x:8
sizeof y:1
sizeof z:1
</pre>
From the output of the above program size of “a” which is a pointer is 8 (on a machine where pointers are stored using 8 bytes). 
In the above program, when the compiler comes to
<pre>
typedef char* ptr;
ptr a, b, c;</pre>
the statement effectively becomes
<pre>char *a, *b, *c;</pre>
This declares a, b, c as char*.
In contrast, #define works like this:
<pre>#define PTR char*
PTR x, y, z;
</pre>
the statement effectively becomes 
<pre>char *x, y, z;</pre>
This makes x, y and z different, as, x is pointer-to-a char, whereas, y and z are char variables. 
When we declare macros with pointers while defining if we declare more than one identifier then the actual definition is given to the first identifier and for the rest non-pointer definition is given. 
In the above case x will be declared as char*, so its size is the size of a pointer, whereas, y and z will be declared as char so, their size will be 1 byte.
<h2>strftime() function in C/C++</h2>
strftime() is a function in C which is used to format date and time. 
It comes under the header file time.h, which also contains a structure named struct tm which is used to hold the time and date. 
The syntax of strftime() is as shown below :
<pre>size_t strftime(char *s, size_t max, const char *format, 
      const struct tm *tm); </pre>
strftime() function formats the broken-down time tm according to the formatting rules specified in format and store it in character array s.
<strong>Some format specifiers for strftime() are shown as follows :</strong><br />
%x = Preferred date representation<br />
%I = Hour as a decimal number (12-hour clock).<br />
%M = Minutes in decimal ranging from 00 to 59.<br />
%p = Either &#8220;AM&#8221; or &#8220;PM&#8221; according to the given time value, etc.<br />
%a = Abbreviated weekday name<br />
%A = Full weekday name<br />
%b = Abbreviated month name<br />
%B = Full month name    March<br />
%c = Date and time representation<br />
%d = Day of the month (01-31)<br />
%H = Hour in 24h format (00-23)<br />
%I = Hour in 12h format (01-12)<br />
%j = Day of the year (001-366)<br />
%m = Month as a decimal number (01-12)<br />
%M = Minute (00-59)
<strong>Structure struct tm is defined in time.h as follows :</strong>
<pre>
struct tm 
{
   int tm_sec;         // seconds
   int tm_min;         // minutes
   int tm_hour;        // hours
   int tm_mday;        // day of the month
   int tm_mon;         // month
   int tm_year;        // The number of years since 1900
   int tm_wday;        // day of the week
   int tm_yday;        // day in the year
   int tm_isdst;       // daylight saving time    
};
</pre>
<code class="comments">// C program to demonstrate the&nbsp; </code>
<code class="comments">// working of strftime() </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;time.h>&nbsp; </code>
<code class="preprocessor">#define Size 50 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">time_t</code> <code class="plain">t ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="color1 bold">tm</code> <code class="plain">*tmp ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">MY_TIME[Size]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">time</code><code class="plain">( &t ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//localtime() uses the time pointed by t , </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to fill a tm structure with the&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// values that represent the&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// corresponding local time. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">tmp = </code><code class="functions bold">localtime</code><code class="plain">( &t ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using strftime to display time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strftime</code><code class="plain">(MY_TIME, </code><code class="keyword bold">sizeof</code><code class="plain">(MY_TIME), </code><code class="string">"%x - %I:%M%p"</code><code class="plain">, tmp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Formatted date & time : %s\n"</code><code class="plain">, MY_TIME ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
<pre>
Formatted date &amp; time : 03/20/17 - 02:55PM
</pre>
<p align="center"><strong>Why and when do we use strftime() ?</strong>
When we are making a software/application which will output the current time and most important in many different formats on the user&#8217;s demand. 
Then in that case we will use this function. 
Its specialty is that we can display date and time in many <a href="http://man7.org/linux/man-pages/man3/strftime.3.html">different </a>formats.
<strong>Reference: </strong><a href="http://man7.org/linux/man-pages/man3/strftime.3.html">http://man7.org/linux/man-pages/man3/strftime.3.html>Linux Man Page</a>
<h2>exec family of functions in C</h2>
The exec family of functions replaces the current running process with a new process. 
It can be used to run a C program by using another C program. 
It comes under the header file <b>unistd.h. </b>There are many members in the exec family which are shown below with examples.
<ul>
<li><b>execvp </b>: Using this command, the created child process does not have to run the same program as the parent process does. 
The <b>exec</b> type system calls allow a process to run any program files, which include a binary executable or a shell script . <b>Syntax:</b>
<pre>int execvp (const char *file, char *const argv[]);</pre>
<strong>file:</strong> points to the file name associated with the file being executed.<br />
<strong>argv:</strong>  is a null terminated array of character pointers.
Let us see a small example to show how to use execvp() function in C. 
We will have two .C files , <b>EXEC.c</b> and <b>execDemo.c</b> and we will replace the execDemo.c with EXEC.c by calling execvp() function in execDemo.c .<br/>
<code class="comments">//EXEC.c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;unistd.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I am EXEC.c called by execvp() "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now,create an executable file of EXEC.c using command
<pre>gcc EXEC.c -o EXEC</pre>
<code class="comments">//execDemo.c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="preprocessor">#include&lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//A null terminated array of character&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//pointers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*args[]={</code><code class="string">"./EXEC"</code><code class="plain">,NULL}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">execvp(args[0],args); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*All statements are ignored after execvp() call as this whole&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">process(execDemo.c) is replaced by another process (EXEC.c) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Ending-----"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now, create an executable file of execDemo.c using command
<pre>gcc execDemo.c -o execDemo</pre>
After running the executable file of execDemo.cby using command ./excDemo, we get the following output:
<pre>I AM EXEC.c called by execvp()
</pre>
When the file execDemo.c is compiled, as soon as the statement execvp(args[0],args) is executed, this very program is replaced by the program EXEC.c. 
&#8220;Ending&#8212;&#8211;&#8221; is not printed because because as soon as the execvp() function is called, this program is replaced by the program EXEC.c.</li>
<li><b>execv </b>: This is very similar to execvp() function in terms of syntax as well. 
The syntax of <b>execv()</b> is as shown below:<b>Syntax:</b>
<pre>int execv(const char *path, char *const argv[]);</pre>
<strong>path:</strong> should point to the path of the file being executed.<br />
<strong>argv[]:</strong> is a null terminated array of character pointers.
Let us see a small example to show how to use execv() function in C. 
This example is similar to the example shown above for execvp() . 
We will have two .C files , <b>EXEC.c</b> and <b>execDemo.c</b> and we will replace the execDemo.c with EXEC.c by calling execv() function in execDemo.c .
<code class="comments">//EXEC.c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;unistd.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I am EXEC.c called by execv() "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now,create an executable file of EXEC.c using command
<pre>gcc EXEC.c -o EXEC</pre>
<code class="comments">//execDemo.c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="preprocessor">#include&lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//A null terminated array of character&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//pointers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*args[]={</code><code class="string">"./EXEC"</code><code class="plain">,NULL}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">execv(args[0],args); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*All statements are ignored after execvp() call as this whole&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">process(execDemo.c) is replaced by another process (EXEC.c) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Ending-----"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now, create an executable file of execDemo.c using command
<pre>gcc execDemo.c -o execDemo</pre>
After running the executable file of execDemo.c by using command ./excDemo, we get the following output:
<pre>I AM EXEC.c called by execv()
</pre>
</li>
<li><b> execlp and execl </b>: These two also serve the same purpose but the syntax of them are a bit different which is as shown below:<b>Syntax:</b>
<pre>int execlp(const char *file, const char *arg,.../* (char  *) NULL */);
int execl(const char *path, const char *arg,.../* (char  *) NULL */);
</pre>
<strong>file:</strong>  file name associated with the file being executed<br />
<b>const char *arg</b> <strong>and ellipses</strong> : describe a list of one or more pointers to null-terminated strings that represent the argument list available to the executed program.
The same C programs shown above can be executed with execlp() or execl() functions and they will perform the same task i.e. 
replacing the current process the with a new process.</li>
<li><b> execvpe and execle </b>: These two also serve the same purpose but the syntax of them are a bit different from all the above members of exec family. 
The synatxes of both of them are shown below :<br />
<b>Syntax:</b>
<pre>int execvpe(const char *file, char *const argv[],char *const envp[]);
<b>Syntax:</b>
int execle(const char *path, const char *arg, .../*, (char *) NULL, 
char * const envp[] */);
</pre>
The syntaxes above shown has one different argument from all the above exec members, i.e.<br />
<b>char * const envp[]: </b>allow the caller to specify the environment of the executed program via the argument envp.<br />
<strong>envp:</strong>This argument is an array of pointers to null-terminated strings and must be terminated by a null pointer. 
The other functions take the environment for the new process image from the external variable environ in the calling process.</li>
</ul>
<b><u>Reference:</u></b> <a href="https://linux.die.net/man/3/execvp">exec(3) man page</a>
<h2>Arrays in C/C++</h2>
An array in C or C++ is a collection of items stored at contiguous memory locations and elements can be accessed randomly using indices of an array. 
They are used to store similar type of elements as in the data type must be the same for all elements. 
They can be used to store collection of primitive data types such as int, float, double, char, etc of any particular type. 
To add to it, an array in C or C++ can store derived data types such as the structures, pointers etc. 
Given below is the picturesque representation of an array.
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/05/Arrays.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/gq/2015/05/Arrays.png" alt="arrays"  class="aligncenter size-full wp-image-28052" /></a>
<strong>Why do we need arrays?</strong><br />
We can use normal variables (v1, v2, v3, ..) when we have a small number of objects, but if we want to store a large number of instances, it becomes difficult to manage them with normal variables. 
The idea of an array is to represent many instances in one variable.
<strong>Array declaration in C/C++:</strong><br />
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Array-Declaration-In-C.png" alt="" class="aligncenter size-full wp-image-256995" srcset="https://www.geeksforgeeks.org/wp-content/uploads/Array-Declaration-In-C.png 800w, https://www.geeksforgeeks.org/wp-content/uploads/Array-Declaration-In-C-300x162.png 300w, https://www.geeksforgeeks.org/wp-content/uploads/Array-Declaration-In-C-768x416.png 768w, https://www.geeksforgeeks.org/wp-content/uploads/Array-Declaration-In-C-660x357.png 660w" sizes="(max-width: 800px) 100vw, 800px" />

There are various ways in which we can declare an array. 
It can be done by specifying its type and size, by initializing it or both.
<ol>
<li><b>Array declaration by specifying size</b>
<code class="comments">// Array declaration by specifying size </code>
<code class="color1 bold">int</code> <code class="plain">arr1[10]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// With recent C/C++ versions, we can also </code>
<code class="comments">// declare an array of user specified size </code>
<code class="color1 bold">int</code> <code class="plain">n = 10; </code>
<code class="color1 bold">int</code> <code class="plain">arr2[n]; </code>
</li>
<li><b>Array declaration by initializing elements</b>
<code class="comments">// Array declaration by initializing elements </code>
<code class="color1 bold">int</code> <code class="plain">arr[] = { 10, 20, 30, 40 } </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Compiler creates an array of size 4. 
</code>
<code class="comments">// above is same as&nbsp; "int arr[4] = {10, 20, 30, 40}" </code>
</li>
<li><b>Array declaration by specifying size and initializing elements</b>
<code class="comments">// Array declaration by specifying size and initializing </code>
<code class="comments">// elements </code>
<code class="color1 bold">int</code> <code class="plain">arr[6] = { 10, 20, 30, 40 } </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Compiler creates an array of size 6, initializes first </code>
<code class="comments">// 4 elements as specified by user and rest two elements as 0. 
</code>
<code class="comments">// above is same as&nbsp; "int arr[] = {10, 20, 30, 40, 0, 0}" </code></li></ol>
<strong>Advantages of an Array in C/C++:</strong>
<ol>
<li>Random access of elements using array index.</li>
<li>Use of less line of code as it creates a single array of multiple elements.</li>
<li>Easy access to all the elements.</li>
<li>Traversal through the array becomes easy using a single loop.</li>
<li>Sorting becomes easy as it can be accomplished by writing less line of code.</li>
</ol>
<strong>Disadvantages of an Array in C/C++:</strong>
<ol>
<li>Allows a fixed number of elements to be entered which is decided at the time of declaration. 
Unlike a linked list, an array in C is not dynamic.</li>
<li>Insertion and deletion of elements can be costly since the elements are needed to be managed in accordance with the new memory allocation.</li>
</ol>
<strong>Facts about Array in C/C++:</strong>  
<ul>
<li><strong>Accessing Array Elements:</strong><br />
Array elements are accessed by using an integer index. 
Array index starts with 0 and goes till size of array minus 1.<br />
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Array-In-C.png" alt="" class="aligncenter size-full wp-image-256988" srcset="https://www.geeksforgeeks.org/wp-content/uploads/Array-In-C.png 800w, https://www.geeksforgeeks.org/wp-content/uploads/Array-In-C-300x142.png 300w, https://www.geeksforgeeks.org/wp-content/uploads/Array-In-C-768x363.png 768w, https://www.geeksforgeeks.org/wp-content/uploads/Array-In-C-660x312.png 660w" sizes="(max-width: 800px) 100vw, 800px" />
<strong>Example:</strong><br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0] = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[2] = -10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[3 / 2] = 2; </code><code class="comments">// this is same as arr[1] = 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[3] = arr[0]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d %d"</code><code class="plain">, arr[0], arr[1], arr[2], arr[3]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0] = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[2] = -10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// this is same as arr[1] = 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[3 / 2] = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[3] = arr[0]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; arr[0] &lt;&lt; </code><code class="string">" "</code> <code class="plain">&lt;&lt; arr[1] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt; </code><code class="string">" "</code> <code class="plain">&lt;&lt; arr[2] &lt;&lt; </code><code class="string">" "</code> <code class="plain">&lt;&lt; arr[3]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
5 2 -10 5
</pre>
</li>
<li><strong>No Index Out of bound Checking:</strong><br />
There is no index out of bounds checking in C/C++, for example, the following program compiles fine but may produce unexpected output when run.<br />
<h3>C</h3>
<code class="comments">// This C program compiles fine </code>
<code class="comments">// as index out of bound </code>
<code class="comments">// is not checked in C. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[3]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[-2]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// This C++ program compiles fine </code>
<code class="comments">// as index out of bound </code>
<code class="comments">// is not checked in C. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; arr[3] &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; arr[-2] &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
          
<pre>
2008101287 4195777
</pre>
</li>
<li>In C, it is not compiler error to initialize an array with more elements than the specified size. 
For example, the below program compiles fine and shows just Warning.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Array declaration by initializing it with more </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// elements than specified size. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2] = { 10, 20, 30, 40, 50 }; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Warnings:</strong>
<pre>
prog.c: In function 'main':
prog.c:7:25: warning: excess elements in array initializer
  int arr[2] = { 10, 20, 30, 40, 50 };
 ^
prog.c:7:25: note: (near initialization for 'arr')
prog.c:7:29: warning: excess elements in array initializer
  int arr[2] = { 10, 20, 30, 40, 50 };
     ^
prog.c:7:29: note: (near initialization for 'arr')
prog.c:7:33: warning: excess elements in array initializer
  int arr[2] = { 10, 20, 30, 40, 50 };
         ^
prog.c:7:33: note: (near initialization for 'arr')
</pre>
<strong>Note:</strong> The program won&#8217;t compile in C++. 
If we save the above program as a .cpp, the program generates compiler error <em>&#8220;error: too many initializers for &#8216;int [2]'&#8221;</em>.
</li>
<li><strong>The elements are stored at contiguous memory locations</strong><br />
<strong>Example:</strong><br />
<h3>C</h3>
<code class="comments">// C program to demonstrate that array elements are stored </code>
<code class="comments">// contiguous locations </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// an array of 10 integers.&nbsp; If arr[0] is stored at </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// address x, then arr[1] is stored at x + sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// arr[2] is stored at x + sizeof(int) + sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and so on. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5], i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of integer in this compiler is %lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; 5; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The use of '&' before a variable name, yields </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// address of variable. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Address arr[%d] is %p\n"</code><code class="plain">, i, &arr[i]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to demonstrate that array elements </code>
<code class="comments">// are stored contiguous locations </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// an array of 10 integers.&nbsp; If arr[0] is stored at </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// address x, then arr[1] is stored at x + sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// arr[2] is stored at x + sizeof(int) + sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and so on. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5], i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Size of integer in this compiler is "</code> <code class="plain">&lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">) &lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; 5; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The use of '&' before a variable name, yields </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// address of variable. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Address arr["</code> <code class="plain">&lt;&lt; i &lt;&lt; </code><code class="string">"] is "</code> <code class="plain">&lt;&lt; &arr[i] &lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Size of integer in this compiler is 4
Address arr[0] is 0x7ffd636b4260
Address arr[1] is 0x7ffd636b4264
Address arr[2] is 0x7ffd636b4268
Address arr[3] is 0x7ffd636b426c
Address arr[4] is 0x7ffd636b4270
</pre>
</li>
</ul>
<strong>Array vs Pointers</strong><br />
Arrays and pointer are two different things (we can check by applying sizeof). 
The confusion happens because array name indicates the address of first element and arrays are always passed as pointers (even if we use square bracket). 
Please see <a href="https://www.geeksforgeeks.org/difference-pointer-array-c/">Difference between pointer and array in C?</a> for more details.
<strong>What is vector in C++?</strong><br />
Vector in C++ is a class in STL that represents an array. 
The advantages of vector over normal arrays are,     
<ul>
<li>We do not need pass size as an extra parameter when we declare a  vector i.e, Vectors support dynamic sizes (we do not have to initially specify size of a vector). 
We can also resize a vector.</li>
<li>Vectors have many in-built function like, removing an element, etc.</li>
<li></li>
<li>To know more about functionalities provided by vector, please refer <a href="https://www.geeksforgeeks.org/vector-in-cpp-stl/">vector in C++</a> for more details.</li>
</ul>
<strong>Related Articles</strong>:
<ul>
<li><a href="https://www.geeksforgeeks.org/arrays-in-c-language-set-2-interesting-array-properties/">Array is C/C++ | Set 2</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-44/">Initialization of multidimensional arrays in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-print-size-of-an-array-in-a-function-in-c/">How to print size of array parameter in C++?</a></li>
<li><a href="https://www.geeksforgeeks.org/arrays-in-c-language-set-2-interesting-array-properties/">Properties of arrays in C language</a></li>
<li><a href="https://www.geeksforgeeks.org/c-program-find-largest-element-array/">Maximum element in an array</a></li>
<li><a href="https://www.geeksforgeeks.org/array-sum-in-cpp-stl/">Array sum in C++ STL</a></li>
<li><a href="https://www.geeksforgeeks.org/sort-c-stl/">Sort an array in C++</a></li>
</ul>
<h2>Strings in C</h2>
Strings are defined as an array of characters. 
The difference between a character array and a string is the string is terminated with a special character &#8216;\0&#8217;.<br />
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113124735/CString.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20191113124735/CString.png" alt=""></a>
<br />
<strong>Declaration of strings</strong>: Declaring a string is as simple as declaring a one dimensional array. 
Below is the basic syntax for declaring a string.
<pre>
char str_name[size];
</pre>
In the above syntax str_name is any name given to the string variable and size is used define the length of the string, i.e the number of characters strings will store. 
Please keep in mind that there is an extra terminating character which is the Null character (&#8216;\0&#8217;) used to indicate termination of string which differs strings from normal character arrays.

<strong>Initializing a String</strong>: A string can be initialized in different ways. 
We will explain this with the help of an example. 
Below is an example to declare a string with name as str and initialize it with &#8220;GeeksforGeeks&#8221;.
<pre>
1. 
char str[] = "GeeksforGeeks";
2. 
char str[50] = "GeeksforGeeks";
3. 
char str[] = {'G','e','e','k','s','f','o','r','G','e','e','k','s','\0'};
4. 
char str[14] = {'G','e','e','k','s','f','o','r','G','e','e','k','s','\0'};
</pre>
Below is the memory representation of a string &#8220;Geeks&#8221;.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/finnnal.png" alt="">
Let us now look at a sample program to get a clear understanding of declaring and initializing a string in C and also how to print a string.
<code class="comments">// C program to illustrate strings </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declare and initialize string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"Geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">,str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Geeks
</pre>
We can see in the above program that strings can be printed using a normal printf statements just like we print any other variable. 
Unlike arrays we do not need to print a string, character by character. 
The C language does not provide an inbuilt data type for strings but it has an access specifier &#8220;<strong>%s</strong>&#8221; which can be used to directly print and read strings.
<strong>Below is a sample program to read a string from user</strong>:
<code class="comments">// C program to read strings </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[50]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// reading string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">,str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">,str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
You can see in the above program that string can also be read using a single scanf statement. 
Also you might be thinking that why we have not used the &#8216;&amp;&#8217; sign with string name &#8216;str&#8217; in scanf statement! To understand this you will have to recall your knowledge of scanf. 
We know that the &#8216;&amp;&#8217; sign is used to provide the address of the variable to the scanf() function to store the value read in memory. 
As str[] is a character array so using str without braces &#8216;[&#8216; and &#8216;]&#8217; will give the base address of this string. 
That&#8217;s why we have not used &#8216;&amp;&#8217; in this case as we are already providing the base address of the string to scanf.
<strong>Passing strings to function</strong>: As strings are character arrays, so we can pass strings to function in a same way we pass an array to a function. 
Below is a sample program to do this:
<code class="comments">// C program to illustrate how to&nbsp; </code>
<code class="comments">// pass string to functions </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">printStr(</code><code class="color1 bold">char</code> <code class="plain">str[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String is : %s"</code><code class="plain">,str); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declare and initialize string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print string by passing string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to a different function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printStr(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
String is : GeeksforGeeks
</pre>
<strong>Related Articles</strong>:
<ul>
<li><a href="https://www.geeksforgeeks.org/puts-vs-printf-for-printing-a-string/">puts() vs printf() to print a string</li>
<li><a href="https://www.geeksforgeeks.org/swap-strings-in-c/">Swap strings in C</a></li>
<li><a href="https://www.geeksforgeeks.org/storage-for-strings-in-c/">Storage for strings in C</a></li>
<li><a href="https://www.geeksforgeeks.org/gets-is-risky-to-use/">gets() is risky to use!</a></li>
</ul>
<h2>Arrays in C Language | Set 2 (Properties)</h2>
We have introduced arrays in set 1 (<a href="http://quiz.geeksforgeeks.org/arrays-in-c-language-set-1-introduction/">Introduction to arrays in C</a>).<!--more-->
In this post array properties in C are discussed.
1) In C, it is possible to have array of all types except void and functions. 
See <a href="http://quiz.geeksforgeeks.org/can-we-have-an-array-of-all-types-in-c/">this </a>for details.
2) In C, array and pointer are different. 
They seem similar because array name gives address of first element and array elements are accessed using pointer arithmetic. 
See <a href="https://www.geeksforgeeks.org/difference-pointer-array-c/">array vs pointer in C</a> for details. 
3) Arrays are always passed as pointer to functions. 
See <a href="http://quiz.geeksforgeeks.org/how-arrays-are-passed-to-functions-in-cc/">this </a>for details.
4) A character array initialized with double quoted string has last element as &#8216;\0&#8217;. 
See <a href="https://www.geeksforgeeks.org/g-fact/">this </a>for details.
5) Like other variables, arrays can be allocated memory in any of the three segments, data, heap, and stack (See <a href="https://www.geeksforgeeks.org/memory-layout-of-c-program/">this </a>for details). 
 Dynamically allocated arrays are allocated memory on heap, static or global arrays are allocated memory on data segment and local arrays are allocated memory on stack segment. 
<h2>Do not use sizeof for array parameters</h2>
Consider the below program. 
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">arr[])&nbsp;&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* sizeof should not be used here to get number&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">of elements in array*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr_size = </code><code class="keyword bold">sizeof</code><code class="plain">(arr)/</code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); </code><code class="comments">/* incorrect use of sizeof*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; arr_size; i++)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i] = i;&nbsp; </code><code class="comments">/*executed only once */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[4] = {0, 0 ,0, 0}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">fun(arr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* use of sizeof is fine here*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; </code><code class="keyword bold">sizeof</code><code class="plain">(arr)/</code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code> <code class="plain">,arr[i]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">();&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
Output: 0 0 0 0 on a <a href="http://en.wikipedia.org/wiki/IA-32">IA-32 machine</a>.
The function fun() receives an array parameter arr[] and tries to find out number of elements in arr[] using sizeof operator.<br />
In C, array parameters are treated as pointers (See <a href="https://www.geeksforgeeks.org/why-c-treats-array-parameters-as-pointers/"><strong>this</strong></a> for details). 
So the expression sizeof(arr)/sizeof(arr[0]) becomes sizeof(int *)/sizeof(int) which results in 1 for IA 32 bit machine (size of int and int * is 4) and the for loop inside fun() is executed only once irrespective of the size of the array. 

Therefore, sizeof should not be used to get number of elements in such cases. 
A separate parameter for array size (or length) should be passed to fun(). 
So the <strong>corrected program is:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">size_t</code> <code class="plain">arr_size)&nbsp;&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; arr_size; i++)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i] = i;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[4] = {0, 0 ,0, 0}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">fun(arr, 4); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; </code><code class="keyword bold">sizeof</code><code class="plain">(arr)/</code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code><code class="plain">, arr[i]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">();&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
<h2>Initialization of variables sized arrays in C</h2>
The C99 standard allows variable sized arrays (see <a href="https://www.geeksforgeeks.org/g-fact-8/">this</a>). 
But, unlike the normal arrays, variable sized arrays cannot be initialized. 
<!--more-->
For example, the following program compiles and runs fine on a C99 compatible compiler.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">M = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[M][M]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; M; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; M; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i][j] = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
0 0
0 0
</pre>
But the following fails with compilation error.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">M = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[M][M] = {0}; </code><code class="comments">// Trying to initialize all values as 0 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; M; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; M; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Compiler Error: variable-sized object may not be initialized
</pre>
<h2>Are array members deeply copied?</h2>
In C/C++, we can assign a struct (or class in C++ only) variable to another variable of same type. 
<!--more--> When we assign a struct variable to another, all members of the variable are copied to the other struct variable. 
But what happens when the structure contains pointer to dynamically allocated memory and what if it contains an array?
In the following C++ program, struct variable st1 contains pointer to dynamically allocated memory. 
When we assign st1 to st2, str pointer of st2 also start pointing to same memory location. 
This kind of copying is called <a href="http://en.wikipedia.org/wiki/Object_copy#Shallow_copy">Shallow Copy</a>.
<code class="preprocessor"># include &lt;iostream> </code>
<code class="preprocessor"># include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">test </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">test st1, st2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st1.str = </code><code class="keyword bold">new</code> <code class="color1 bold">char</code><code class="plain">[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(st1.str, </code><code class="string">"GeeksforGeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st2 = st1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st1.str[0] = </code><code class="string">'X'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st1.str[1] = </code><code class="string">'Y'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Since copy was shallow, both strings are same */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"st1's str = "</code> <code class="plain">&lt;&lt; st1.str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"st2's str = "</code> <code class="plain">&lt;&lt; st2.str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output:<br />
st1&#8217;s str = XYeksforGeeks<br />
st2&#8217;s str = XYeksforGeeks
Now, what about arrays?  <em>The point to note is that the array members are not shallow copied, compiler automatically performs <a href="http://en.wikipedia.org/wiki/Object_copy#Deep_copy">Deep Copy</a> for array members.</em>. 
In the following program, struct test contains array member str[]. 
When we assign st1 to st2, st2 has a new copy of the array. 
So st2 is not changed when we change str[] of st1.
<code class="preprocessor"># include &lt;iostream> </code>
<code class="preprocessor"># include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">test </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[20]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">test st1, st2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(st1.str, </code><code class="string">"GeeksforGeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st2 = st1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st1.str[0] = </code><code class="string">'X'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">st1.str[1] = </code><code class="string">'Y'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Since copy was Deep, both arrays are different */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"st1's str = "</code> <code class="plain">&lt;&lt; st1.str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"st2's str = "</code> <code class="plain">&lt;&lt; st2.str &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
st1&#8217;s str = XYeksforGeeks<br />
st2&#8217;s str = GeeksforGeeks
Therefore, for C++ classes, we don&#8217;t need to write our own copy constructor and assignment operator for array members as the default behavior is Deep copy for arrays.
<h2>What is the difference between single quoted and double quoted declaration of char array?</h2>
In C/C++, when a character array is initialized with a double quoted string and array size is not specified, compiler automatically allocates one extra space for string terminator &#8216;\0&#8217;. 
For example, following program prints 6 as output. 
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// size of arr[] is 6 as it is '\0' terminated&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[] = </code><code class="string">"geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(arr)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>6</pre>
If array size is specified as 5 in the above program then the program works without any warning/error and prints 5 in C, but causes compilation error in C++.<br/>
<code class="comments">// Works in C, but compilation error in C++ </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// arr[] is not terminated with '\0' </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// and its size is 5 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[5] = </code><code class="string">"geeks"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(arr)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>5</pre>
When character array is initialized with comma separated list of characters and array size is not specified, compiler doesn&#8217;t create extra space for string terminator &#8216;\0&#8217;. 
For example, following program prints 5.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// arr[] is not terminated with '\0'&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// and its size is 5&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[]= {</code><code class="string">'g'</code><code class="plain">, </code><code class="string">'e'</code><code class="plain">, </code><code class="string">'e'</code><code class="plain">, </code><code class="string">'k'</code><code class="plain">, </code><code class="string">'s'</code><code class="plain">};&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(arr)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>5</pre>
<h2>Initialization of a multidimensional arrays in C/C++</h2>
In C/C++, initialization of a multidimensional arrays can have left most dimension as optional. 
Except the left most dimension, all other dimensions must be specified.<br />
 <!--more--><br />
For example, following program fails in compilation because two dimensions are not specified.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a[][][2] = { {{1, 2}, {3, 4}},&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{{5, 6}, {7, 8}} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">};&nbsp; </code><code class="comments">// error </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(a));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Following 2 programs work without any error.
<code class="comments">// Program 1 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a[][2] = {{1,2},{3,4}}; </code><code class="comments">// Works </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(a)); </code><code class="comments">// prints 4*sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Program 2 </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a[][2][2] = { {{1, 2}, {3, 4}},&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{{5, 6}, {7, 8}} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code><code class="comments">// Works </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(a)); </code><code class="comments">// prints 8*sizeof(int) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Write one line functions for strcat() and strcmp()</h2>
Recursion can be used to do both tasks in one line. 
Below are one line implementations for stracat() and strcmp(). 
<!--more-->
<code class="comments">/* my_strcat(dest, src) copies data of src to dest.&nbsp; To do so, it first reaches end of the string dest using recursive calls my_strcat(++dest, src).&nbsp; Once end of dest is reached, data is copied using&nbsp; </code>
<code class="comments">(*dest++ = *src++)?&nbsp; my_strcat(dest, src).*/</code>
<code class="keyword bold">void</code> <code class="plain">my_strcat(</code><code class="color1 bold">char</code> <code class="plain">*dest, </code><code class="color1 bold">char</code> <code class="plain">*src) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">(*dest)? my_strcat(++dest, src): (*dest++ = *src++)? my_strcat(dest, src): 0 ; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* driver function to test above function */</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">dest[100] = </code><code class="string">"geeksfor"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*src = </code><code class="string">"geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">my_strcat(dest, src); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %s "</code><code class="plain">, dest); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
The function my_strcmp() is simple compared to my_strcmp().
<code class="comments">/* my_strcmp(a, b) returns 0 if strings a and b are same, otherwise 1.&nbsp;&nbsp; It recursively increases a and b pointers. 
At any point if *a is not equal to *b then 1 is returned.&nbsp; If we reach end of both strings at the same time then 0 is returned.*/</code>
<code class="color1 bold">int</code> <code class="plain">my_strcmp(</code><code class="color1 bold">char</code> <code class="plain">*a, </code><code class="color1 bold">char</code> <code class="plain">*b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(*a == *b && *b == </code><code class="string">'\0'</code><code class="plain">)? 0 : (*a == *b)? my_strcmp(++a, ++b): 1; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* driver function to test above function */</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*a = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*b = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(my_strcmp(a, b) == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" String are same "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" String are not same "</code><code class="plain">);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
The above functions do very basic string concatenation and string comparison. 
These functions do not provide same functionality as standard library functions. 

Please write comments if you find the above code incorrect, or find better ways to solve the same problem.
<h2>What&#8217;s difference between char s[] and char *s in C?</h2>
Consider below two statements in C. 
What is the difference between the two?
<pre>
   char s[] = "geeksquiz";
   char *s  = "geeksquiz";
</pre>
<strong>Below are the key differences:</strong></br><br />
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/CommonArticleDesign18-min.png" alt="">
The statements &#8216;<strong>char s[] = &#8220;geeksquiz&#8221;</strong>&#8216; creates a character array which is like any other array and we can do all array operations. 
The only special thing about this array is, although we have initialized it with 9 elements, its size is 10 (Compiler automatically adds &#8216;\0&#8217;)<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s[] = </code><code class="string">"geeksquiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s[0] = </code><code class="string">'j'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n%s"</code><code class="plain">, s); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>10
jeeksquiz</pre>
The statement &#8216;<strong>char *s  = &#8220;geeksquiz&#8221;</strong>&#8216; creates a string literal. 
The string literal is stored in the read-only part of memory by most of the compilers. 
The C and C++ standards say that string literals have static storage duration, any attempt at modifying them gives undefined behaviour.<br />
<strong>s</strong> is just a pointer and like any other pointer stores address of string literal.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*s = </code><code class="string">"geeksquiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Uncommenting below line would cause undefined behaviour </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (Caused segmentation fault on gcc) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//&nbsp; s[0] = 'j';&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>8</pre>
Running above program may generate a warning also &#8220;warning: deprecated conversion from string constant to ‘char*’&#8221;. 
This warning occurs because s is not a const pointer, but stores address of the read-only location. 
The warning can be avoided by the pointer to const.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*s = </code><code class="string">"geeksquiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>gets() is risky to use!</h2>
Consider the below program. 
<code class="keyword bold">void</code> <code class="plain">read() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">gets</code><code class="plain">(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
The code looks simple, it reads string from standard input and prints the entered string, but it suffers from <a href="http://en.wikipedia.org/wiki/Buffer_overflow">Buffer Overflow</a> as gets() doesn&#8217;t do any array bound testing. 
gets() keeps on reading until it sees a newline character. 
To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.<br/>
<code class="preprocessor">#define MAX_LIMIT 20 </code>
<code class="keyword bold">void</code> <code class="plain">read() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[MAX_LIMIT]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fgets</code><code class="plain">(str, MAX_LIMIT, stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
<h2>C function to Swap strings</h2>
Let us consider the below program. 
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">swap(</code><code class="color1 bold">char</code> <code class="plain">*str1, </code><code class="color1 bold">char</code> <code class="plain">*str2) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*temp = str1; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">str1 = str2; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">str2 = temp; </code>
<code class="plain">}&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str1 = </code><code class="string">"geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str2 = </code><code class="string">"forgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">swap(str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is %s, str2 is %s"</code><code class="plain">, str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output of the program is<em> str1 is geeks, str2 is forgeeks</em>. 
So the above swap() function doesn’t swap strings. 
The function just changes local pointer variables and the changes are not reflected outside the function.
Let us see the correct ways for swapping strings:
<strong>Method 1(Swap Pointers)</strong><br />
If you are <a href="https://www.geeksforgeeks.org/storage-for-strings-in-c/">using character pointer for strings </a>(not arrays) then change str1 and str2 to point each other’s data. 
i.e., swap pointers. 
In a function, if we want to change a pointer (and obviously we want changes to be reflected outside the function) then we need to pass a pointer to the pointer.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Swaps strings by swapping pointers */</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">swap1(</code><code class="color1 bold">char</code> <code class="plain">**str1_ptr, </code><code class="color1 bold">char</code> <code class="plain">**str2_ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*temp = *str1_ptr; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*str1_ptr = *str2_ptr; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*str2_ptr = temp; </code>
<code class="plain">}&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str1 = </code><code class="string">"geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str2 = </code><code class="string">"forgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">swap1(&str1, &str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is %s, str2 is %s"</code><code class="plain">, str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
This method cannot be applied if strings are stored using character arrays.
<strong>Method 2(Swap Data)</strong><br />
If you are <a href="https://www.geeksforgeeks.org/storage-for-strings-in-c/">using character arrays to store strings</a> then preferred way is to swap the data of both arrays. 
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">/* Swaps strings by swapping data*/</code>
<code class="keyword bold">void</code> <code class="plain">swap2(</code><code class="color1 bold">char</code> <code class="plain">*str1, </code><code class="color1 bold">char</code> <code class="plain">*str2) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*temp = (</code><code class="color1 bold">char</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">((</code><code class="functions bold">strlen</code><code class="plain">(str1) + 1) * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(temp, str1); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str2, temp); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(temp); </code>
<code class="plain">}&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str1[10] = </code><code class="string">"geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str2[10] = </code><code class="string">"forgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">swap2(str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is %s, str2 is %s"</code><code class="plain">, str1, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
This method cannot be applied for strings stored in read-only block of memory. 
</br><br />
<h2>Storage for Strings in C</h2>
In C, a string can be referred to either using a character pointer or as a character array. 
<!--more-->
<strong>Strings as character arrays</strong>
<code class="color1 bold">char</code> <code class="plain">str[4] = </code><code class="string">"GfG"</code><code class="plain">; </code><code class="comments">/*One extra for string terminator*/</code>
<code class="comments">/*&nbsp;&nbsp;&nbsp; OR&nbsp;&nbsp;&nbsp; */</code>
<code class="color1 bold">char</code> <code class="plain">str[4] = {‘G’, ‘f’, ‘G’, </code><code class="string">'&#092;&#048;'</code><code class="plain">}; </code><code class="comments">/* '&#092;&#048;' is string terminator */</code>
When strings are declared as character arrays, they are stored like other types of arrays in C. 
For example, if str[] is an <a href="http://icecube.wisc.edu/~dglo/c_class/vstorage.html">auto variable</a> then string is stored in stack segment, if it’s a global or static variable then stored in <a href="http://en.wikipedia.org/wiki/Data_segment">data segment</a>, etc.
<strong>Strings using character pointers</strong><br />
Using character pointer strings can be stored in two ways:
<strong>1) </strong>Read only string in a shared segment.<br />
When a string value is directly assigned to a pointer, in most of the compilers, it’s stored in a read-only block (generally in data segment) that is shared among functions. 
<code class="color1 bold">char</code> <code class="plain">*str&nbsp; =&nbsp; </code><code class="string">"GfG"</code><code class="plain">;&nbsp;&nbsp; </code>
In the above line &#8220;GfG&#8221; is stored in a shared read-only location, but pointer str is stored in a read-write memory. 
You can change str to point something else but cannot change value at present str. 
So this kind of string should only be used when we don&#8217;t want to modify string at a later stage in the program.
<strong>2)</strong> Dynamically allocated in heap segment.<br />
Strings are stored like other dynamically allocated things in C and can be shared among functions.
<code class="color1 bold">char</code> <code class="plain">*str; </code>
<code class="color1 bold">int</code> <code class="plain">size = 4; </code><code class="comments">/*one extra for ‘&#092;&#048;’*/</code>
<code class="plain">str = (</code><code class="color1 bold">char</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)*size); </code>
<code class="plain">*(str+0) = </code><code class="string">'G'</code><code class="plain">;&nbsp; </code>
<code class="plain">*(str+1) = </code><code class="string">'f'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="plain">*(str+2) = </code><code class="string">'G'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="plain">*(str+3) = </code><code class="string">'&#092;&#048;'</code><code class="plain">;&nbsp;&nbsp; </code>
 </br><br />
Let us see some examples to better understand the above ways to store strings.
<strong>Example 1 (Try to modify string) </strong><br />
The below program may crash (gives segmentation fault error) because the line *(str+1) = ‘n’ tries to write a read only memory.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">str = </code><code class="string">"GfG"</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">/* Stored in read only part of data segment */</code>
<code class="undefined spaces">&nbsp;</code><code class="plain">*(str+1) = </code><code class="string">'n'</code><code class="plain">; </code><code class="comments">/* Problem:&nbsp; trying to modify read only memory */</code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Below program works perfectly fine as str[] is stored in writable stack segment.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"GfG"</code><code class="plain">;&nbsp; </code><code class="comments">/* Stored in stack segment like other auto variables */</code>
<code class="undefined spaces">&nbsp;</code><code class="plain">*(str+1) = </code><code class="string">'n'</code><code class="plain">;&nbsp;&nbsp; </code><code class="comments">/* No problem: String is now GnG */</code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Below program also works perfectly fine as data at str is stored in writable heap segment.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">size = 4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Stored in heap segment like other dynamically allocated things */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str = (</code><code class="color1 bold">char</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)*size); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+0) = </code><code class="string">'G'</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+1) = </code><code class="string">'f'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+2) = </code><code class="string">'G'</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+3) = </code><code class="string">'&#092;&#048;'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+1) = </code><code class="string">'n'</code><code class="plain">;&nbsp; </code><code class="comments">/* No problem: String is now GnG */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<strong>Example 2 (Try to return string from a function)</strong><br />
The below program works perfectly fine as the string is stored in a shared segment and data stored remains there even after return of getString()
<code class="color1 bold">char</code> <code class="plain">*getString() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str = </code><code class="string">"GfG"</code><code class="plain">; </code><code class="comments">/* Stored in read only part of shared segment */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* No problem: remains at address str after getString() returns*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">str;&nbsp;&nbsp; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, getString());&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The below program also works perfectly fine as the string is stored in heap segment and data stored in heap segment persists even after the return of getString()
<code class="color1 bold">char</code> <code class="plain">*getString() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">size = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str = (</code><code class="color1 bold">char</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">)*size); </code><code class="comments">/*Stored in heap segment*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+0) = </code><code class="string">'G'</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+1) = </code><code class="string">'f'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+2) = </code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">*(str+3) = </code><code class="string">'&#092;&#048;'</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* No problem: string remains at str after getString() returns */</code>&nbsp;&nbsp;&nbsp;&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">str;&nbsp;&nbsp; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, getString());&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
But, the below program may print some garbage data as string is stored in stack frame of function getString() and data may not be there after getString() returns.
<code class="color1 bold">char</code> <code class="plain">*getString() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"GfG"</code><code class="plain">; </code><code class="comments">/* Stored in stack segment */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Problem: string may not be present after getSting() returns */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">str;&nbsp; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, getString());&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Difference between pointer and array in C?</h2>
Pointers are used for storing address of dynamically allocated arrays and for arrays which are passed as arguments to functions. 
<!--more-->In other contexts, arrays and pointer are two different things, see the following programs to justify this statement. 
<em>Behavior of sizeof operator</em><br />
<h3>C</h3>
<code class="comments">// 1st program to show that array and pointers are different </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// sizof(int) * (number of element in arr[]) is printed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of arr[] %ld\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(arr)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// sizeof a pointer is printed which is same for all type&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// of pointers (char *, void *, etc) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of ptr %ld"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(ptr)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// 1st program to show that array and pointers are different </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// sizof(int) * (number of element in arr[]) is printed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Size of arr[] "</code><code class="plain">&lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(arr)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// sizeof a pointer is printed which is same for all type&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// of pointers (char *, void *, etc) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Size of ptr "</code><code class="plain">&lt;&lt; </code><code class="keyword bold">sizeof</code><code class="plain">(ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>

<strong>Output:</strong>
<pre>Size of arr[] 24
Size of ptr 8</pre>
<em>Assigning any address to an array variable is not allowed. 
</em>
<code class="comments">// IInd program to show that array and pointers are different </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20}, x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = &x; </code><code class="comments">// This is fine </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">arr = &x;&nbsp; </code><code class="comments">// Compiler Error </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre> Compiler Error: incompatible types when assigning to 
              type 'int[2]' from type 'int *' </pre>
See the <a href="https://www.geeksforgeeks.org/g-fact-5/">previous post</a> on this topic for more differences. 
<em><strong>Although array and pointer are different things, following properties of array make them look similar.</strong></em>
<ol>
<li><em>Array name gives address of first element of array.</em><br />
Consider the following program for example.<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assigns address of array to ptr </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of first element is %d"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// 1st program to show that array and pointers are different </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assigns address of array to ptr </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Value of first element is "</code> <code class="plain">&lt;&lt; *ptr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>Value of first element is 10</pre>
</li>
&nbsp;
<li><em>Array members are accessed using pointer arithmetic.</em><br />
Compiler uses pointer arithmetic to access array element. 
For example, an expression like &#8220;arr[i]&#8221; is treated as *(arr + i) by the compiler. 
That is why the expressions like *(arr + i) work for array arr, and expressions like ptr[i] also work for pointer ptr.
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[2] = %d\n"</code><code class="plain">, arr[2]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*(arr + 2) = %d\n"</code><code class="plain">, *(arr + 2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"ptr[2] = %d\n"</code><code class="plain">, ptr[2]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*(ptr + 2) = %d\n"</code><code class="plain">, *(ptr + 2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"arr[2] = "</code><code class="plain">&lt;&lt; arr[2] &lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"*(arr + 2) = "</code><code class="plain">&lt;&lt; *(arr + 2)&lt;&lt;</code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"ptr[2] = "</code><code class="plain">&lt;&lt; ptr[2]&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"*(ptr + 2) = "</code><code class="plain">&lt;&lt; *(ptr + 2)&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output: </strong>
<pre>arr[2] = 30
*(arr + 2) = 30
ptr[2] = 30
*(ptr + 2) = 30 
</pre>
</li>
&nbsp;
<li><em>Array parameters are always passed as pointers, even when we use square brackets.</em>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">ptr[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// size of a pointer is printed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(ptr) = %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(ptr)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// This allowed because ptr is a pointer, not array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*ptr = %d "</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50, 60}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(arr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output: </strong>
<pre>sizeof(ptr) = 8
*ptr = 10</pre></li></ol>
Please refer <a href="https://www.geeksforgeeks.org/g-fact-5/">Pointer vs Array in C</a> for more details.
<h2>How to dynamically allocate a 2D array in C?</h2>
Following are different ways to create a 2D array on heap (or dynamically allocate a 2D array).<!--more-->
In the following examples, we have considered &#8216;<strong>r</strong>&#8216; as number of rows, &#8216;<strong>c</strong>&#8216; as number of columns and we created a 2D array with r = 3, c = 4 and following values 
<pre>
  1  2  3  4
  5  6  7  8
  9  10 11 12 </pre>
<strong>1) Using a single pointer:</strong><br />
A simple way is to allocate memory block of size r*c and access elements using simple pointer arithmetic. 
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r = 3, c = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*arr = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(r * c * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j, count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*(arr + i*c + j) = ++count; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, *(arr + i*c + j)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Code for further processing and free the&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">dynamically allocated memory */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 11 12</pre>

<strong>2) Using an array of pointers</strong><br />
We can create an array of pointers of size r. 
Note that from C99, C language allows variable sized arrays. 
After creating an array of pointers, we can dynamically allocate memory for every row.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r = 3, c = 4, i, j, count; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*arr[r]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i] = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(c * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that arr[i][j] is same as *(*(arr+i)+j) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i][j] = ++count; </code><code class="comments">// Or *(*(arr+i)+j) = ++count </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Code for further processing and free the&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">dynamically allocated memory */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 11 12</pre>
<strong>3) Using pointer to a pointer</strong><br />
We can create an array of pointers also dynamically using a double pointer. 
Once we have an array pointers allocated dynamically, we can dynamically allocate memory and for every row like method 2.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r = 3, c = 4, i, j, count; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">**arr = (</code><code class="color1 bold">int</code> <code class="plain">**)</code><code class="functions bold">malloc</code><code class="plain">(r * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">*)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i] = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(c * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that arr[i][j] is same as *(*(arr+i)+j) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i][j] = ++count;&nbsp; </code><code class="comments">// OR *(*(arr+i)+j) = ++count </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;&nbsp; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Code for further processing and free the&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">dynamically allocated memory */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 11 12</pre>
<strong>4) Using double pointer and one malloc call </strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r=3, c=4, len=0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr, **arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">count = 0,i,j; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">len = </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">*) * r + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">) * c * r; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr = (</code><code class="color1 bold">int</code> <code class="plain">**)</code><code class="functions bold">malloc</code><code class="plain">(len); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// ptr is now pointing to the first element in of 2D array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = (</code><code class="color1 bold">int</code> <code class="plain">*)(arr + r); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for loop to point rows pointer to appropriate location in 2D array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i] = (ptr + c * i); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[i][j] = ++count; </code><code class="comments">// OR *(*(arr+i)+j) = ++count </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; r; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; c; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 11 12</pre>
Thanks to <a href="https://disqus.com/by/itrishansh/">Trishansh Bhardwaj</a> for suggesting this 4th method.
<h2>How to pass a 2D array as a parameter in C?</h2>
This post is an extension of <a href="https://www.geeksforgeeks.org/dynamically-allocate-2d-array-c/">How to dynamically allocate a 2D array in C?</a> <!--more-->
A one dimensional array can be easily passed as a pointer, but syntax for passing a 2D array to a function can be difficult to remember. 
  One important thing for passing multidimensional arrays is, first array dimension does not have to be  specified. 
The second (and any subsequent) dimensions must be given
<strong>1) When both dimensions are available globally (either as a macro or as a global constant).</strong>
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">M = 3; </code>
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">N = 3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">print(</code><code class="color1 bold">int</code> <code class="plain">arr[M][N]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; M; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; N; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print(arr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9</pre>
<strong>2) When only second dimension is available globally (either as a macro or as a global constant).</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">N = 3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">print(</code><code class="color1 bold">int</code> <code class="plain">arr[][N], </code><code class="color1 bold">int</code> <code class="plain">m) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; m; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; N; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print(arr, 3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9</pre>
The above method is fine if second dimension is fixed and is not user specified. 
The following methods handle cases when second dimension can also change.
<strong>3) If compiler is C99 compatible</strong><br />
From C99, C language supports variable sized arrays to be passed simply by specifying the variable dimensions (See <a href="http://ideone.com/qMHs3q">this </a>for an example run)
<code class="comments">// The following program works only if your compiler is C99 compatible. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// n must be passed before the 2D array </code>
<code class="keyword bold">void</code> <code class="plain">print(</code><code class="color1 bold">int</code> <code class="plain">m, </code><code class="color1 bold">int</code> <code class="plain">n, </code><code class="color1 bold">int</code> <code class="plain">arr[][n]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; m; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; n; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i][j]); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">m = 3, n = 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print(m, n, arr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output on a C99 compatible compiler: 
<pre>1 2 3 4 5 6 7 8 9</pre>
If compiler is not C99 compatible, then we can use one of the following methods to pass a variable sized 2D array.
<strong>4) Using a single pointer</strong><br />
In this method, we must typecast the 2D array when passing to function.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">print(</code><code class="color1 bold">int</code> <code class="plain">*arr, </code><code class="color1 bold">int</code> <code class="plain">m, </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; m; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; n; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, *((arr+i*n) + j)); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">m = 3, n = 3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// We can also use "print(&arr[0][0], m, n);" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print((</code><code class="color1 bold">int</code> <code class="plain">*)arr, m, n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9</pre>
<h2>How to write long strings in Multi-lines C/C++?</h2>
Image a situation where we want to use or print a long long string in C or C++, how to do this?
In C/C++, we can break a string at any point in the middle using two double quotes in the middle. 
Below is a simple example to demonstrate the same. 
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// We can put two double quotes anywhere in a string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str1&nbsp; = </code><code class="string">"geeks"</code><code class="string">"quiz"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// We can put space line break between two double quotes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str2&nbsp; = </code><code class="string">"Qeeks"</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="string">"Quiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str3&nbsp; = </code><code class="string">"Qeeks"</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Quiz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(str1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(str3); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Geeks"</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="comments">// Breaking string in multiple lines </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"forGeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
<em>geeksquiz<br />
QeeksQuiz<br />
QeeksQuiz<br />
GeeksforGeeks</em>
Below are few examples with long long strings broken using two double quotes for better readability.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str = </code><code class="string">"These are reserved words in C language are int, float, "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"if, else, for, while etc. 
An Identifier is a sequence of"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"letters and digits, but must start with a letter. 
"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Underscore ( _ ) is treated as a letter. 
Identifiers are "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"case sensitive. 
Identifiers are used to name variables,"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"functions etc."</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">}&nbsp; </code>
Output: <em>These are reserved words in C language are int, float, if, else, for, while etc. 
An Identifier is a sequence ofletters and digits, but must start with a letter. 
Underscore ( _ ) is treated as a letter. 
Identifiers are case sensitive. 
Identifiers are used to name variables,functions etc.</em>
Similarly, we can write long strings in printf and or cout.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*str = </code><code class="string">"An Identifier is a sequence of"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"letters and digits, but must start with a letter. 
"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Underscore ( _ ) is treated as a letter. 
Identifiers are "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"case sensitive. 
Identifiers are used to name variables,"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"functions etc."</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"These are reserved words in C language are int, float, "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"if, else, for, while etc. 
%s "</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">}</code>
Output: <em>These are reserved words in C language are int, float, if, else, for, while etc. 
An Identifier is a sequence ofletters and digits, but must start with a letter. 
Underscore ( _ ) is treated as a letter. 
Identifiers are case sensitive. 
Identifiers are used to name variables,functions etc.</em>
<h2>What are the data types for which it is not possible to create an array?</h2>
In C, it is possible to have array of all types except following.<br />
1) void.<br />
2) functions.<!--more-->
For example, below program throws compiler error
<pre>
int main()
{
    void arr[100];
}
</pre>
Output: 
<pre>error: declaration of 'arr' as array of voids </pre>
But we can have array of void pointers and function pointers. 
The below program works fine.
<pre>
int main()
{
    void *arr[100];
}
</pre>
See <a href="https://www.geeksforgeeks.org/function-pointer-in-c/">examples of function pointers</a> for details of array function pointers. 
<h2>Variable Length Arrays in C and C++</h2>
Variable length arrays is a feature where we can allocate an auto array (on stack) of variable size. 
C supports variable sized arrays from C99 standard. 
For example, the below program compiles and runs fine in C.
Also note that in <a href="https://en.wikipedia.org/wiki/C99">C99</a> or <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a> standards, there is feature called <a href="https://en.wikipedia.org/wiki/Flexible_array_member">“flexible array members”</a>, which works same as the above.<br />
<!--more-->
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[n]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// ...... 
</code>
<code class="plain">}&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(6); </code>
<code class="plain">} </code>
But C++ standard (till <a href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11</a>) doesn&#8217;t support variable sized arrays. 
The C++11 standard mentions array size as a constant-expression See (See 8.3.4 on page 179 of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">N3337</a>). 
So the above program may not be a valid C++ program. 
The program may work in GCC compiler, because GCC compiler provides an extension to support them.
As a side note, the latest <a href="https://en.wikipedia.org/wiki/C%2B%2B14">C++14</a> (See 8.3.4 on page 184 of <a href="https://isocpp.org/files/papers/N3690.pdf">N3690</a>) mentions array size as a simple expression (not constant-expression).
<p align="center"><strong>Implementation</strong>
<code class="comments">//C program for variable length members in structures in GCC before C99. 
</code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//A structure of type student </code>
<code class="keyword bold">struct</code> <code class="plain">student </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">stud_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">struct_size; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">stud_name[0]; </code><code class="comments">//variable length array must be last. 
</code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//Memory allocation and initialisation of structure </code>
<code class="keyword bold">struct</code> <code class="plain">student *createStudent(</code><code class="keyword bold">struct</code> <code class="plain">student *s, </code><code class="color1 bold">int</code> <code class="plain">id, </code><code class="color1 bold">char</code> <code class="plain">a[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s = </code><code class="functions bold">malloc</code><code class="plain">( </code><code class="keyword bold">sizeof</code><code class="plain">(*s) + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">) * </code><code class="functions bold">strlen</code><code class="plain">(a) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->stud_id = id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->name_len = </code><code class="functions bold">strlen</code><code class="plain">(a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(s->stud_name, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->struct_size = ( </code><code class="keyword bold">sizeof</code><code class="plain">(*s) + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">) * </code><code class="functions bold">strlen</code><code class="plain">(s->stud_name) ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">s;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Print student details </code>
<code class="keyword bold">void</code> <code class="plain">printStudent(</code><code class="keyword bold">struct</code> <code class="plain">student *s) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Student_id : %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Stud_Name&nbsp; : %s\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Name_Length: %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Allocated_Struct_size: %d\n\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->stud_id, s->stud_name, s->name_len, s->struct_size);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//Value of Allocated_Struct_size here is in bytes. 
</code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//Driver Code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">student *s1, *s2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s1=createStudent(s1, 523, </code><code class="string">"Sanjayulsha"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s2=createStudent(s2, 535, </code><code class="string">"Cherry"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printStudent(s1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printStudent(s2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//size in bytes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of Struct student: %lu\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">student)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//size in bytes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of Struct pointer: %lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s1)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Student_id : 523
Stud_Name : Sanjayulsha
Name_Length: 11
Allocated_Struct_size: 23 
Student_id : 535
Stud_Name : Cherry
Name_Length: 6
Allocated_Struct_size: 18
Size of Struct student: 12
Size of Struct pointer: 8
</pre>
<h2>A shorthand array notation in C for repeated values</h2>
In C, when there are many repeated values, we can use a shorthand array notation to define array. 
Below program demonstrates same.
<code class="comments">// C program to demonstrate working of shorthand </code>
<code class="comments">// array rotation. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This line is same as </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// int array[10] = {1, 1, 1, 1, 0, 0, 2, 2, 2, 2}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">array[10] = {[0 ... 
3]1, [6 ... 
9]2}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; 10; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, array[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>1 1 1 1 0 0 2 2 2 2 
</pre>
Note that middle gap of 2 is automatically filled with 0.
<h2>Accessing array out of bounds in C/C++</h2>
Perquisite : <a href="https://www.geeksforgeeks.org/arrays-in-c-language-set-1-introduction/">Arrays in C/C++</a>
In high level languages such as Java, there are functions which prevent you from accessing array out of bound by generating a exception such as java.lang.ArrayIndexOutOfBoundsException. 
But in case of C, there is no such functionality, so programmer need to take care of this situation.
<p align="center"><strong>What if programmer accidentally accesses any index of array which is out of bound ? </strong>
C don&#8217;t provide any specification which deal with problem of accessing invalid index. 
As per ISO C standard it is called <strong>Undefined Behavior</strong>.<br />
An undefined behavior (UB) is a result of executing computer code whose behavior is not prescribed by the language specification to which the code can adhere to, for the current state of the program (e.g. 
memory). 
This generally happens when the translator of the source code makes certain assumptions, but these assumptions are not satisfied during execution.
<p align="center"><strong>Examples of Undefined Behavior while accessing array out of bounds</strong>
<ol>
<li><strong>Access non allocated location of memory: </strong> The program can access some piece of memory which is owned by it.
<code class="comments">// Program to demonstrate&nbsp; </code>
<code class="comments">// accessing array out of bounds </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {1,2,3,4,5}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr [0] is %d\n"</code><code class="plain">, arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// arr[10] is out of bound </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[10] is %d\n"</code><code class="plain">, arr[10]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output :
<pre>
arr [0] is 1
arr[10] is -1786647872
</pre>
It can be observed here, that arr[10] is accessing a memory location containing a garbage value.</li>
<li><strong>Segmentation fault:</strong> The program can access some piece of memory which is not owned by it, which can cause crashing of program such as segmentation fault.
<code class="comments">// Program to demonstrate&nbsp; </code>
<code class="comments">// accessing array out of bounds </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {1,2,3,4,5}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr [0] is %d\n"</code><code class="plain">,arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[10] is %d\n"</code><code class="plain">,arr[10]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// allocation memory to out of bound&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// element </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[10] = 11; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"arr[10] is %d\n"</code><code class="plain">,arr[10]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output :<br />
Runtime Error : Segmentation Fault (SIGSEGV)</li></ol>
<strong>Important Points:</strong>
<ul>
<li>Stay inside the bounds of the array in C programming while using arrays to avoid any such errors.</li>
<li>C++ however offers the <a href="https://www.geeksforgeeks.org/vector-in-cpp-stl/">std::vector</a> class template, which does not require to perform bounds checking. 
A vector also has the <a href="https://www.geeksforgeeks.org/stdbasic_stringat/">std::at()</a> member function which can perform bounds-checking.</li>
</ul>
<h2>strcpy in C/C++</h2>
strcpy() is a standard library function in C/C++ and is used to copy one string to another. 
In C it is present in <strong>string.h</strong> header file and in C++ it is present in <strong>cstring</strong> header file. 
<strong>Syntax:</strong>
<pre>
<strong>char* strcpy(char* dest, const char* src);</strong>
</pre>
<b>Paramters:</b> This method accepts following paramters:
<ul>
<li><strong>dest</strong>: Pointer to the destination array where the content is to be copied.
</li>
<li><strong>src: </strong> string which will be copied.
</li>
</ul>
<strong>Return Value:</strong> After copying the source string to the destination string, the strcpy() function returns a pointer to the destination string.
Below program explains different usages of this library function:
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">// strcpy() function ic C/C++ </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str1[]=</code><code class="string">"Hello Geeks!"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str2[] = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str3[40]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str4[40]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str5[] = </code><code class="string">"GfG"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str2, str1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str3, </code><code class="string">"Copy successful"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str4, str5); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"str1: %s\nstr2: %s\nstr3: %s\nstr4: %s\n"</code><code class="plain">, str1, str2, str3, str4); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
str1: Hello Geeks!
str2: Hello Geeks!
str3: copy successful
str4: GfG
</pre>
<p align="center"><strong>Important Points</strong>
<ul>
<li>This function copies the entire string to the destination string. 
It doesn&#8217;t append the source string to the destination string. 
In other words, we can say that it replaces the content of destination string by the content of source string.</li>
<li>It does not affect the source string. 
The source string remains same after copying.</li>
<li>This function only works with C style strings and not C++ style strings i.e. 
it only works with strings of type <strong>char str[];</strong> and not <strong>string s1;</strong> which are created using standard string data type available in C++ and not C.</li>
</ul>
<h2>strcmp() in C/C++</h2>
strcmp() is a built-in library function and is declared in <strong>&lt;string.h&gt;</strong> header file. 
This function takes two strings as arguments and compare these two strings lexicographically.
<strong>Syntax:</strong>:
<pre>
int strcmp(const char *leftStr, const char *rightStr );
</pre>
In the above prototype, function srtcmp takes two strings as parameters and returns an integer value based on the comparison of strings. 

<ul>
<li>strcmp() compares the <strong>two strings lexicographically</strong> means it starts comparison character by character starting from the first character until the characters in both strings are equal or a NULL character is encountered.</li>
<li>If first character in both strings are equal, then this function will check the second character, if this is also equal then it will check the third and so on</li>
<li>This process will be continued until a character in either string is NULL or the characters are unequal.</li>
</ul>
<p align="center"><strong>What does strcmp() return?</strong>
This function can return<strong> three different integer values</strong> based on the comparison:
<ol>
<li><strong>Zero ( 0 )</strong>: A value equal to zero when both strings are found to be identical. 
That is, That is, All of the characters in both strings are same.
<pre>All characters of strings are same</pre>
<code class="comments">// C program to illustrate </code>
<code class="comments">// strcmp() function </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">leftStr[] = </code><code class="string">"g f g"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">rightStr[] = </code><code class="string">"g f g"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Using strcmp() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">res = </code><code class="functions bold">strcmp</code><code class="plain">(leftStr, rightStr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(res==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are equal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are unequal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nValue returned by strcmp() is:&nbsp; %d"</code> <code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Strings are equal
Value returned by strcmp() is:  0
</pre>
</li>
<li><strong>Greater than zero ( &gt;0 )</strong>: A value greater than zero is returned when the first not matching character in leftStr have the greater ASCII value than the corresponding character in rightStr or we can also say
<pre>If character in leftStr is lexicographically
<strong>after</strong> the character of rightStr </pre>
<code class="comments">// C program to illustrate </code>
<code class="comments">// strcmp() function </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// z has greater ASCII value than g </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">leftStr[] = </code><code class="string">"zfz"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">rightStr[] = </code><code class="string">"gfg"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">res = </code><code class="functions bold">strcmp</code><code class="plain">(leftStr, rightStr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(res==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are equal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are unequal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nValue of result: %d"</code> <code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Strings are unequal
Value returned by strcmp() is:  19
</pre>
</li>
<li><strong>Less than Zero ( &lt;0 )</strong>: A value less than zero is returned when the first not matching character in leftStr have lesser ASCII value than the corresponding character in rightStr.
<pre>If character in leftStr is lexicographically
<strong>before</strong> the character of rightStr</pre>
<code class="comments">// C program to illustrate </code>
<code class="comments">// strcmp() function </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// b has less ASCII value than g </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">leftStr[] = </code><code class="string">"bfb"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">rightStr[] = </code><code class="string">"gfg"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">res = </code><code class="functions bold">strcmp</code><code class="plain">(leftStr, rightStr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(res==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are equal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Strings are unequal"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nValue returned by strcmp() is:&nbsp; %d"</code> <code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Strings are unequal
Value returned by strcmp() is:  -5
</pre>
</li>
</ul>
<strong>Important point : </strong> When the strings are not same, you will find that the value returned by the strcmp() function is the difference between the ASCII values of first unmatched character  in leftStr and rightStr in both the cases.<br />
&nbsp;<br />
<h2>strdup() and strndup() functions in C/C++</h2>
The <b>strdup()</b> and <b>strndup()</b> functions are used to duplicate a string. 
<strong>strdup() :</strong><br />
<u>Syntax :</u> <em>char *strdup(const char *s);</em><br />
This function returns a pointer to a null-terminated byte string, which is a duplicate of the string pointed to by <em><b>s</b></em>. 
The memory obtained is done dynamically using <a href="https://www.geeksforgeeks.org/calloc-versus-malloc/">malloc</a> and hence it can be freed using <a href="https://www.geeksforgeeks.org/g-fact-30/">free()</a>.<br />
It returns a pointer to the duplicated string <em><b>s</b></em>.
Below is the C implementation to show the use of strdup() function in C:<br/>
<code class="comments">// C program to demonstrate strdup() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">source[] = </code><code class="string">"GeeksForGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// A copy of source is created dynamically </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and pointer to copy is returned. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code><code class="plain">* target = strdup(source);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, target); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
GeeksForGeeks</pre>
<strong>strndup() :</strong><br />
<u>syntax</u>: <em>char *strndup(const char *s, size_t n);</em><br />
This function is similar to strdup(), but copies at most <b></em>n</em></b> bytes. 
<b>Note</b>: If s is longer than n, then only n bytes are copied, and a NULL (&#8221;) is added at the end.
Below is the C implementation to show the use of strndup() function in C:
<code class="comments">// C program to demonstrate strndup() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">source[] = </code><code class="string">"GeeksForGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 5 bytes of source are copied to a new memory </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// allocated dynamically and pointer to copied </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// memory is returned. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code><code class="plain">* target = strndup(source, 5); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, target); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Geeks</pre>
Reference: <a href="http://man7.org/linux/man-pages/man3/strdupa.3.html">Linux man(7)</a>
<h2>How to pass an array by value in C ?</h2>
In C, array name represents address and when we pass an array, we actually pass address and the parameter receiving function always accepts them as pointers (even if we use [], refer <a href="https://www.geeksforgeeks.org/why-c-treats-array-parameters-as-pointers/">this</a> for details). 
<strong>How to pass array by value, i.e., how to make sure that we have a new copy of array when we pass it to function?</strong><br />
This can be done by wrapping the array in a structure and creating a variable of type of that structure and assigning values to that array. 
After that, passing the variable to some other function and modifying it as per requirements. 
Note that <a href="https://www.geeksforgeeks.org/are-array-members-deeply-copied/">array members are copied when passed as parameter, but dynamic arrays are not</a>. 
So this solution works only for non-dynamic arrays (created without new or malloc).
Let&#8217;s see an example to demonstrate the above fact using a C program:<br/>
<code class="comments">// C program to demonstrate passing an array </code>
<code class="comments">// by value using structures. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor"># define SIZE 5 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A wrapper for array to make sure that array </code>
<code class="comments">// is passed by value. 
</code>
<code class="keyword bold">struct</code> <code class="plain">ArrayWrapper </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[SIZE]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// An array is passed by value wrapped in temp </code>
<code class="keyword bold">void</code> <code class="plain">modify(</code><code class="keyword bold">struct</code> <code class="plain">ArrayWrapper temp) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = temp.arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Display array contents </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In 'modify()', before modification\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; SIZE; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, ptr[i]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Modify the array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; SIZE; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr[i] = 100; </code><code class="comments">// OR *(ptr + i) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nIn 'modify()', after modification\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; SIZE; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, ptr[i]); </code><code class="comments">// OR *(ptr + i) </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">ArrayWrapper obj; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;SIZE; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">obj.arr[i] = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">modify(obj); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Display array contents </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n\nIn 'Main', after calling modify() \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; SIZE; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, obj.arr[i]); </code><code class="comments">// Not changed </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
In 'modify()', before modification
10 10 10 10 10 
In 'modify()', after modification
100 100 100 100 100 
In 'Main', after calling modify() 
10 10 10 10 10 
</pre>
<strong><br />
Reference: </strong><br />
<a href="http://stackoverflow.com/questions/11158858/c-pass-array-by-value">http://stackoverflow.com/questions/11158858/c-pass-array-by-value</a>
<h2>Different methods to reverse a string in C/C++</h2>
Given a string, write a C/C++ program to reverse it.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/string-reverse.jpg" alt="string-reverse">
<ol>
<li><strong>Write own reverse function by swapping characters: </strong> One simple solution is two write our own reverse function to reverse a <a href="https://www.geeksforgeeks.org/c-string-class-and-its-applications/">string in C++</a>.
<code class="comments">// A Simple C++ program to reverse a string </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to reverse a string </code>
<code class="keyword bold">void</code> <code class="plain">reverseStr(string& str) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = str.length(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Swap character starting from two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// corners </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; n / 2; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap(str[i], str[n - i - 1]); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">string str = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">reverseStr(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; str; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output :
<pre>skeegrofskeeg</pre>
</li>

<li><strong>Using inbuilt &#8220;reverse&#8221; function:</strong> There is a direct function in &#8220;algorithm&#8221; header file for doing reverse that saves our time when programming.
<pre>// Reverses elements in [begin, end]
void reverse (BidirectionalIterator begin, 
BidirectionalIterator end);
</pre>
<code class="comments">// A quickly written program for reversing a string </code>
<code class="comments">// using reverse() </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">string str = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Reverse str[beign..end] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">reverse(str.begin(), str.end()); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; str; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output :
<pre>skeegrofskeeg</pre>
</li>
<li><strong>Only printing reverse</strong>:
<code class="comments">// C++ program to print reverse of a string </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to reverse a string </code>
<code class="keyword bold">void</code> <code class="plain">reverse(string str) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=str.length()-1; i>=0; i--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; str[i];&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">string s = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">reverse(s); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
skeegrofskeeG
</pre>
</li>
<li><strong>Getting reverse of a const string: </strong>
<code class="comments">// C++ program to get reverse of a cosnt string </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to reverse string and return </code>
<code class="comments">// reverse string pointer of that </code>
<code class="color1 bold">char</code><code class="plain">* reverseConstString(</code><code class="color1 bold">char</code> <code class="keyword bold">const</code><code class="plain">* str) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// find length of string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="functions bold">strlen</code><code class="plain">(str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create dynamic pointer char array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*rev = </code><code class="keyword bold">new</code> <code class="color1 bold">char</code><code class="plain">[n+1]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// copy of string to ptr array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(rev, str); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Swap character starting from two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// corners </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0, j=n-1; i&lt;j; i++,j--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap(rev[i], rev[j]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// return pointer of reversed string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">rev; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*s = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, reverseConstString(s)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
skeeGrofskeeG
</pre></li></ol>
<h2>strpbrk() in C</h2>
This function <strong> finds the first character in the string s1 that matches any character specified in s2</strong> (It excludes terminating null-characters).<br />
<pre>
<strong>Syntax : </strong>
char *strpbrk(const char *s1, const char *s2)
<strong>Parameters :</strong>
s1 : string to be scanned.
s2 : string containing the characters to match.
<strong>Return Value :</strong>
It returns a pointer to the character in s1 that 
matches one of the characters in s2, else returns NULL.
</pre>
<code class="comments">// C code to demonstrate the working of </code>
<code class="comments">// strpbrk </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declaring three strings </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s1[] = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s2[] = </code><code class="string">"app"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s3[] = </code><code class="string">"kite"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code><code class="plain">* r, *t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Checks for matching character </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// no match found </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">r = </code><code class="functions bold">strpbrk</code><code class="plain">(s1, s2);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(r != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"First matching character: %c\n"</code><code class="plain">, *r); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Character not found"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Checks for matching character </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// first match found at "e" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t = </code><code class="functions bold">strpbrk</code><code class="plain">(s1, s3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(t != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nFirst matching character: %c\n"</code><code class="plain">, *t); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Character not found"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Character not found
First matching character: e
</pre>
<strong>Practical Application</strong><br />
This function can be used in game of lottery where the person having string with letter<br />
coming first in victory wins, i.e. 
this can be used at any place where first person wins.<br/>
<code class="comments">// C code to demonstrate practical application </code>
<code class="comments">// of strpbrk </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Initializing victory string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s1[] = </code><code class="string">"victory"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declaring lottery strings </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s2[] = </code><code class="string">"a23"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s3[] = </code><code class="string">"i22"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code><code class="plain">* r, *t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Use of strpbrk() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">r = </code><code class="functions bold">strpbrk</code><code class="plain">(s1, s2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t = </code><code class="functions bold">strpbrk</code><code class="plain">(s1, s3); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Checks if player 1 has won lottery </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(r != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Congrats u have won"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Better luck next time"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Checks if player 2 has won lottery </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(t != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nCongrats u have won"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Better luck next time"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
Better luck next time
Congrats u have won
</pre>
 
<h2>strcoll() in C/C++</h2>
<strong>strcoll()</strong> is a built-in library function and is declared in <strong>&lt;string.h&gt;</strong> header file. 
This function compares the string pointed to by <em>str1</em> with the one pointed by <em>str2</em>.The <strong>strcoll()</strong> function performs the comparison based on the rules of the current locale&#8217;s<strong> LC_COLLATE</strong> category.<br />
<strong>Syntax:</strong>
<pre>int strcoll(const char *str1, const char *str2)</pre>
<strong>Parameters:</strong> Function strcoll() takes two strings as parameters and returns an integer value.
<pre><strong>Value</strong>                  <strong> Meaning</strong>
less than zero         <em> str1</em> is less than <em>str2</em>
zero                   <em> str1</em> is equal to <em>str2</em>
greater than zero      <em> str1</em> is greater than <em>str2</em></pre>
<ol>
<li><strong>less than zero :</strong> When<em> str1</em> is less than <em>str2</em>
<code class="comments">// C program to illustrate strcoll() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str1[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str2[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ret; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str1, </code><code class="string">"geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str2, </code><code class="string">"GEEKSFORGEEKS"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">strcoll</code><code class="plain">(str1, str2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ret > 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is greater than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(ret &lt; 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is lesser than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is equal to str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
str1 is greater than str2
</pre>
</li>
<li><strong>greater than zero :</strong>when <em> str1</em> is greater than <em>str2</em>
<code class="comments">// C program to illustrate strcoll() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str1[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str2[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ret; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str1, </code><code class="string">"GEEKSFORGEEKS"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str2, </code><code class="string">"geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">strcoll</code><code class="plain">(str1, str2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ret > 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is greater than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(ret &lt; 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is lesser than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is equal to str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
str1 is lesser than str2
</pre>
</li>
<li>
<strong>Is equal to zero :</strong> when <em> str1</em> is equal to <em>str2</em>
<code class="comments">// C program to illustrate strcoll() </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str1[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str2[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ret; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str1, </code><code class="string">"GEEKSFORGEEKS"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(str2, </code><code class="string">"GEEKSFORGEEKS"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ret = </code><code class="functions bold">strcoll</code><code class="plain">(str1, str2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ret > 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is greater than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(ret &lt; 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is lesser than str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"str1 is equal to str2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
str1 is equal to str2
</pre></li></ol>
Related Function : <strong><a href="https://www.geeksforgeeks.org/strcmp-in-c-cpp/">strcmp()</a>, <a href="https://www.geeksforgeeks.org/stdmemcmp-in-cpp/">memcmp()</a></strong>
<h2>ispunct() function in C</h2>
The <strong>ispunct()</strong> function checks whether a character is a punctuation character or not.<br />
The term &#8220;<strong>punctuation</strong>&#8221; as defined by this function includes all printable characters that are neither alphanumeric nor a space. 
For example &#8216;@&#8217;, &#8216;$&#8217;, etc.<br />
This function is defined in <strong>ctype.h</strong> header file</font>.
<h2>syntax:</h2>
<pre><strong>int ispunct(int ch);</strong>
<strong>ch:</strong> character to be checked.
<strong>Return Value  :</strong> function return <strong>nonzero</strong>
 if character is a punctuation character;
 otherwise <strong>zero</strong> is returned. 
</pre>
<code class="comments">// Program to check punctuation </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The puncuations in str are '!' and ',' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"welcome! to GeeksForGeeks, "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0, count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(str[i]) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ispunct(str[i])) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Sentence contains %d punctuation"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" characters.\n"</code><code class="plain">, count); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<font size="+1">Output:</font>
<pre>
<!-- Your Output -->
Sentence contains 2 punctuation characters.
</pre>
<code class="comments">// C program to print all Punctuations </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"All punctuation characters in C"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" programming are: \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt;= 255; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ispunct(i) != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
All punctuation characters in C programming are: 
! " # $ % &amp; ' ( ) * +, - . 
/ : ;  ? @ [ \ ] ^ _ ` { | } ~
</pre>
<h2>strspn() function in C</h2>
The <strong>strspn()</strong> function returns the length of the initial substring of the string pointed to by <em>str1</em> that is made up of only those character contained in the string pointed to by <em>str2</em>.
Syntax :
<pre><strong>size_t strspn(const char *str1, const char *str2)</strong>
<strong>str1 :</strong> string to be scanned.
<strong>str2 :</strong> string containing the 
characters to match.
<strong>Return Value :</strong> This function
returns the number of characters
in the initial segment of str1 
which consist only of characters 
from str2.</pre>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// C program to illustrate strspn() function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">len = </code><code class="functions bold">strspn</code><code class="plain">(</code><code class="string">"geeks for geeks"</code><code class="plain">,</code><code class="string">"geek"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Length of initial segment matching : %d\n"</code><code class="plain">, len );&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>Length of initial segment matching 4</pre>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// C program to illustrate strspn() function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">len = </code><code class="functions bold">strspn</code><code class="plain">(</code><code class="string">"i am"</code><code class="plain">,</code><code class="string">"xyz"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Length of initial segment matching : %d\n"</code><code class="plain">, len ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>Length of initial segment matching 0</pre>
<h2>isalpha() and isdigit() functions in C with cstring examples.</h2>
<b>isalpha(c)</b> is a function in C which can be used to check if the passed character is an alphabet or not. 
It returns a non-zero value if it&#8217;s an alphabet else it returns 0. 
For example, it returns non-zero values for &#8216;a&#8217; to &#8216;z&#8217; and &#8216;A&#8217; to &#8216;Z&#8217; and zeroes for other characters.
Similarly, <b>isdigit(c)</b> is a function in C which can be used to check if the passed character is a digit or not. 
It returns a non-zero value if it&#8217;s a digit else it returns 0. 
For example, it returns a non-zero value for &#8216;0&#8217; to &#8216;9&#8217; and zero for others.
<strong>Avoiding common errors :</strong> It is important to note this article does not cover strings! Only Cstrings. 
Cstrings are an array of single characters (char) in their behaviour. 
There are advantages and disadvantages to this.
<strong>Example Problem :</strong> Given a cstring <b>str</b>, find the number of alphabetic letters and number of decimal digits in that cstring.
<strong>Examples:</strong>
<pre>
Input: 12abc12
Output: Alphabetic_letters = 3, Decimal_digits = 4
Input: 123 GeeksForGeeks is Number 1
Output: Alphabetic_letters = 21, Decimal_digits = 4
</pre>
<!-- To show strongly recommend and practice link    -->
<div id="practiceLinkDiv">
<h3><a href="https://ide.geeksforgeeks.org/">Recommended: Please try your approach on <b><i><u>{IDE}</u></i></b> first, before moving on to the solution.</a></h3>
<b>Explanation And Approach:</b>
<code class="comments">// C program to demonstrate working of isalpha() and </code>
<code class="comments">// isdigit(). 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"12abc12"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">alphabet = 0, number = 0, i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; str[i]!= </code><code class="string">'\0'</code><code class="plain">; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// check for alphabets </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isalpha</code><code class="plain">(str[i]) != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">alphabet++; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// check for decimal digits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">isdigit</code><code class="plain">(str[i]) != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">number++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Alphabetic_letters = %d, "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Decimal_digits = %d\n"</code><code class="plain">, alphabet, number); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Alphabetic_letters = 3, Decimal_digits = 4
</pre>
<h2>Data type of case labels of switch statement in C++?</h2>
In C++ switch statement, the expression of each case label must be an integer constant expression. 
<!--more-->
For example, the following program fails in compilation.
<code class="comments">/* Using non-const in case label */</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">switch</code><code class="plain">(c)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">i: </code><code class="comments">// not a "const int" expression </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of c = %d"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*Some more cases */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Putting <em>const </em>before<em> i </em>makes the above program work.<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">switch</code><code class="plain">(c)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">i:&nbsp; </code><code class="comments">// Works fine </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of c = %d"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*Some more cases */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Note : The above fact is only for C++. 
In C, both programs produce an error. 
In C, using an integer literal does not cause an error.
<strong>Program to find the largest number between two numbers using switch case:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n1=10,n2=11; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// n1 > n2 (10 > 11) is false so using&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// logical operator '>', n1 > n2 produces 0 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// (0 means false, 1 means true) So, case 0&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// is executed as 10 > 11 is false. 
Here we&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// have used type cast to convert boolean to int,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// to avoid warning. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">switch</code><code class="plain">((</code><code class="color1 bold">int</code><code class="plain">)(n1 > n2))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">0:&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is the largest\n"</code><code class="plain">, n2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is the largest\n"</code><code class="plain">, n1); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// n1 &lt; n2 (10 &lt; 11) is true so using logical&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// operator '&lt;', n1 &lt; n2 produces 1 (1 means true,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// 0 means false) So, default is executed as we </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// don't have case 1 to be executed. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">switch</code><code class="plain">((</code><code class="color1 bold">int</code><code class="plain">)(n1 &lt; n2)) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">0:&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is the largest\n"</code><code class="plain">, n1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is the largest\n"</code><code class="plain">, n2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Santanu </code>
<h2>For Versus While</h2>
<strong>Question:</strong> Is there any example for which the following two loops will not work same way? <!--more-->
<code class="comments">/*Program 1 --> For loop*/</code>
<code class="keyword bold">for</code> <code class="plain">(&lt;init-stmnt>; &lt;boolean-expr>; &lt;incr-stmnt>)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;body-statements> </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/*Program 2 --> While loop*/</code>
<code class="plain">&lt;init-stmnt>; </code>
<code class="keyword bold">while</code> <code class="plain">(&lt;boolean-expr>)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;body-statements> </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;incr-stmnt> </code>
<code class="plain">} </code>
<strong>Solution:</strong><br />
If the body-statements contains continue, then the two programs will work in different ways
See the below examples: Program 1 will print &#8220;loop&#8221; 3 times but Program 2 will go in an infinite loop.
<strong>Example for program 1</strong>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"loop "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">continue</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
<strong>Example for program 2</strong>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">(i &lt; 3) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"loop"</code><code class="plain">); </code><code class="comments">/* printed infinite times */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">continue</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code><code class="comments">/*This statement is never executed*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
Please write comments if you want to add more solutions for the above question.
<h2>A nested loop puzzle</h2>
Which of the following two code segments is faster?  Assume that compiler makes no optimizations. 
<!--more-->
<code class="comments">/* FIRST */</code>
<code class="keyword bold">for</code><code class="plain">(i=0;i&lt;10;i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(j=0;j&lt;100;j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
<code class="comments">/* SECOND */</code>
<code class="keyword bold">for</code><code class="plain">(i=0;i&lt;100;i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(j=0;j&lt;10;j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
Both code segments provide same functionality, and the code inside the two for loops would be executed same number of times in both code segments.<br />
If we take a closer look then we can see that the SECOND does more operations than the FIRST. 
It executes all three parts (assignment, comparison and increment) of the for loop more times than the corresponding parts of FIRST:
<ol>
<li>The SECOND executes assignment operations ( j = 0 or i = 0) 101 times while FIRST executes only 11 times.
</li>
<li>The SECOND does 101 + 1100  comparisons (i &lt; 100 or j &lt; 10) while the FIRST does 11 + 1010 comparisons (i &lt; 10 or  j &lt; 100).
</li>
<li>The SECOND executes 1100 increment operations (i++ or j++) while the FIRST executes 1010 increment operation.</li></ol>
Below C++ code counts the number of increment operations executed in FIRST and SECOND, and prints the counts.<br/>
<code class="comments">//program to count number of increment&nbsp; </code>
<code class="comments">//operations in FIRST and SECOND&nbsp; </code>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c1 = 0, c2 = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* FIRST */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0;i&lt;10;i++,c1++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j=0;j&lt;100;j++, c1++); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* SECOND */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;100; i++, c2++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j=0; j&lt;10; j++, c2++); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">" Count in FIRST = "</code> <code class="plain">&lt;&lt;c1 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">" Count in SECOND&nbsp; = "</code> <code class="plain">&lt;&lt;c2 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Count in FIRST = 1010
 Count in SECOND  = 1100
</pre>
Below C++ code counts the number of comparison operations executed by FIRST and SECOND
<code class="comments">//program to count the number of comparison&nbsp; </code>
<code class="comments">//operations executed by FIRST and SECOND */ </code>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">c1 = 0, c2 = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* FIRST */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; ++c1&&i&lt;10; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j=0; ++c1&&j&lt;100;j++); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* SECOND */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; ++c2&&i&lt;100; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j=0; ++c2&&j&lt;10; j++); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//do something </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">" Count fot FIRST&nbsp; "</code> <code class="plain">&lt;&lt;c1 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">" Count fot SECOND&nbsp; "</code> <code class="plain">&lt;&lt;c2 &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Count fot FIRST  1021
 Count fot SECOND  1201
</pre>
Thanks to <a href="https://www.geeksforgeeks.org/forums/users/dheeraj">Dheeraj </a>for suggesting the solution.
Please write comments if you find any of the answers/codes incorrect, or you want to share more information about the topics discussed above.
<h2>Interesting facts about switch statement in C</h2>
Prerequisite &#8211; <a href="https://www.geeksforgeeks.org/switch-statement-cc/">Switch Statement in C</a><br />
Switch  is a control statement that allows a value to change control of execution.<!--more-->
<code class="comments">// Following is a simple program to demonstrate syntax of switch. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">3: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 3"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1, 2 and 3"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output: 
<pre>Choice is 2</pre>
Following are some interesting facts about switch statement.
<em><strong>1) The expression used in switch must be  integral type ( int, char and enum).</strong></em> Any other type of expression is not allowed.
<code class="comments">// float is not allowed in switch </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x = 1.1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1.1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1, 2 and 3"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output: 
<pre> Compiler Error: switch quantity not an integer</pre>
In Java, String is also allowed in switch (See <a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html">this</a>)
<em><strong>2) All the statements following a matching case execute until a break statement is reached.</strong></em>
<code class="comments">// There is no break in all cases </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">3: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 3\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1, 2 and 3\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output: 
<pre>
Choice is 2
Choice is 3
Choice other than 1, 2 and 3</pre>
<code class="comments">// There is no break in some cases </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">3: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 3\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">4: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 4\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1, 2, 3 and 4\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"After Switch"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>Choice is 2
Choice is 3
Choice is 4
After Switch</pre>
<em><strong>3) The default block can be placed anywhere.</strong></em> The position of default doesn&#8217;t matter, it is still executed if no match found.
<code class="comments">// The default block is placed above other cases. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1 and 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>Choice other than 1 and 2</pre>
<em><strong>4) The integral expressions used in labels must be a constant expressions</strong></em>
<code class="comments">// A program with variable expressions in labels </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {1, 2, 3}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">arr[0]: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice 1\n"</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">arr[1]: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice 2\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">arr[2]: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice 3\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
          
<pre>Compiler Error: case label does not reduce to an integer constant</pre>
<em><strong>5) The statements written above cases are never executed</strong></em> After the switch statement, the control transfers to the matching case, the statements written before case are not executed. 
<code class="comments">// Statements before all cases are never executed </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = x + 1;&nbsp; </code><code class="comments">// This statement is not executed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice other than 1 and 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output: 
<pre>Choice is 1</pre>
<em><strong>6) Two case labels cannot have same value</strong></em>
<code class="comments">// Program where two case labels have same value </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 1"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1+1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Choice is 2"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output: 
<pre>Compiler Error: duplicate case value</pre>
<h2>Difference between while(1) and while(0) in C language</h2>
Prerequisite: <a href="https://www.geeksforgeeks.org/loops-in-c-and-c/" rel="noopener">while loop in C/C++</a>
In most computer programming languages, a while loop is a control flow statement that allows code to be executed repeatedly based on a given boolean condition. 
The boolean condition is either true or false
<p align="center"><strong>while(1)</strong>
It is an infinite loop which will run till a break statement is issued explicitly. 
Interestingly not while(1) but any integer which is non-zero will give the similar effect as while(1). 
Therefore, while(1), while(2) or while(-255), all will give infinite loop only.
<pre>
while(1) or while(any non-zero integer)
{ 
    // loop runs infinitely
}</pre>
A simple usage of while(1) can be in the Client-Server program. 
In the program, the server runs in an infinite while loop to receive the packets sent from the clients.<br />
But practically, it is not advisable to use while(1) in real-world because it increases the CPU usage and also blocks the code i.e one cannot come out from the while(1) until the program is closed manually. 
while(1) can be used at a place where condition needs to be true always.<br />
<h3>C</h3>
<code class="comments">// C program to illustrate while(1) </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">( 1 )&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"%d\n"</code><code class="plain">, ++i ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code><code class="comments">// Used to come&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// out of loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="color1 bold">int</code> <code class="plain">i = 0;&nbsp; </code>
<code class="keyword bold">while</code> <code class="plain">( 1 )&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ++i &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 5) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Used to come&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// out of loop&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
1
2
3
4
5
</pre>
<p align="center"><strong>while(0)</strong>
It is opposite of while(1). 
It means condition will always be false and thus code in while will never get executed.
<pre>
while(0)
{ 
    // loop does not run
}
</pre>
<h3>C</h3>
<code class="comments">// C program to illustrate while(0) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0, flag=0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">( 0 )&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This line will never get executed&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"%d\n"</code><code class="plain">, ++i );&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">flag++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 5) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(flag==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Didn't execute the loop!"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0, flag=0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">( 0 )&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This line will never get executed&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ++i &lt;&lt; </code><code class="string">"\n"</code><code class="plain">;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">flag++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 5) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(flag==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Didn't execute the loop!"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
Didn't execute the loop!
</pre>
<h2>goto statement in C/C++</h2>
The goto statement is a jump statement which is sometimes also referred to as unconditional jump statement. 
The goto statement can be used to jump from anywhere to anywhere within a function.<br />
<strong>Syntax</strong>:
<pre>
Syntax1      |   Syntax2
----------------------------
goto label;  |    label:  
. 
          |    .
. 
          |    .
. 
          |    .
label:       |    goto label;
</pre>
In the above syntax, the first line tells the compiler to go to or jump to the statement marked as a label. 
Here label is a user-defined identifier which indicates the target statement. 
The statement immediately followed after &#8216;label:&#8217; is the destination statement. 
The &#8216;label:&#8217; can also appear before the &#8216;goto label;&#8217; statement in the above syntax.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/goto.png" alt="goto" class="aligncenter size-full wp-image-201539" /><br />
Below are some examples on how to use goto statement:<br />
<strong>Examples:</strong>
<ul>
<li>
<strong>Type 1</strong>: In this case, we will see a situation similar to as shown in Syntax1 above. 
Suppose we need to write a program where we need to check if a number is even or not and print accordingly using the goto statement. 
Below program explains how to do this:<br />
<h3>C</h3>
<br/>
<code class="comments">// C program to check if a number is </code>
<code class="comments">// even or not using goto statement </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// function to check even or not </code>
<code class="keyword bold">void</code> <code class="plain">checkEvenOrNot(</code><code class="color1 bold">int</code> <code class="plain">num) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num % 2 == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// jump to even </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">even;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// jump to odd </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">odd;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">even: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is even"</code><code class="plain">, num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// return if even </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">;&nbsp; </code>
<code class="plain">odd: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d is odd"</code><code class="plain">, num); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num = 26; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">checkEvenOrNot(num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to check if a number is </code>
<code class="comments">// even or not using goto statement </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// function to check even or not </code>
<code class="keyword bold">void</code> <code class="plain">checkEvenOrNot(</code><code class="color1 bold">int</code> <code class="plain">num) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num % 2 == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// jump to even </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">even;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// jump to odd </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">odd;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">even: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; num &lt;&lt; </code><code class="string">" is even"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// return if even </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">;&nbsp; </code>
<code class="plain">odd: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; num &lt;&lt; </code><code class="string">" is odd"</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num = 26; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">checkEvenOrNot(num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
26 is even
</pre>
</li>
<li>
<strong>Type 2:</strong>: In this case, we will see a situation similar to as shown in Syntax1 above. 
Suppose we need to write a program which prints numbers from 1 to 10 using the goto statement. 
Below program explains how to do this.<br />
<h3>C</h3>
<code class="comments">// C program to print numbers </code>
<code class="comments">// from 1 to 10 using goto statement </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// function to print numbers from 1 to 10 </code>
<code class="keyword bold">void</code> <code class="plain">printNumbers() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 1; </code>
<code class="plain">label: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">,n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(n &lt;= 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNumbers(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to print numbers </code>
<code class="comments">// from 1 to 10 using goto statement </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// function to print numbers from 1 to 10 </code>
<code class="keyword bold">void</code> <code class="plain">printNumbers() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 1; </code>
<code class="plain">label: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; n &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(n &lt;= 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNumbers(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
1 2 3 4 5 6 7 8 9 10
</pre>
</li>
</ul>
<p align="center"><strong>Disadvantages of using goto statement:</strong>
<ul>
<li>The use of goto statement is highly discouraged as it makes the program logic very complex.</li>
<li>use of goto makes the task of analyzing and verifying the correctness of programs (particularly those involving loops) very difficult.</li>
<li>Use of goto can be simply avoided using <a href="https://www.geeksforgeeks.org/break-statement-cc/">break</a> and <a href="https://www.geeksforgeeks.org/continue-statement-cpp/">continue</a> statements.</li>
</ul>
<h2>Continue Statement in C/C++</h2>
Continue is also a loop control statement just like the <a href="https://www.geeksforgeeks.org/break-statement-cc/">break statement</a>. 
<em>continue</em> statement is opposite to that of break <em>statement</em>, instead of terminating the loop, it forces to execute the next iteration of the loop.<br />
As the name suggest the continue statement forces the loop to continue or execute the next iteration. 
When the continue statement is executed in the loop, the code inside the loop following the continue statement will be skipped and next iteration of the loop will begin.<br />
<strong>Syntax</strong>:
<pre>
continue;
</pre>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/continue.png" alt=""><br />
<strong>Example</strong>:<br />
Consider the situation when you need to write a program which prints number from 1 to 10 and but not 6. 
It is specified that you have to do this using loop and only one loop is allowed to use.<br />
Here comes the usage of continue statement. 
What we can do here is we can run a loop from 1 to 10 and every time we have to compare the value of iterator with 6. 
If it is equal to 6 we will use the <em>continue</em> statement to continue to next iteration without printing anything otherwise we will print the value.<br />
Below is the implementation of the above idea:<br />
<h3>C</h3>
<code class="comments">// C program to explain the use&nbsp; </code>
<code class="comments">// of continue statement&nbsp; </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop from 1 to 10&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 1; i &lt;= 10; i++) {&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If i is equals to 6,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// continue to next iteration&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// without printing&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 6)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">continue</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// otherwise print the value of i&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// C++ program to explain the use </code>
<code class="comments">// of continue statement </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop from 1 to 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 1; i &lt;= 10; i++) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If i is equals to 6, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// continue to next iteration </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// without printing </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i == 6) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">continue</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// otherwise print the value of i </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; i &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
1 2 3 4 5 7 8 9 10 
</pre>
The <em>continue</em> statement can be used with any other loop also like while or do while in a similar way as it is used with for loop above.
<strong>Exercise Problem:</strong><br />
Given a number n, print triangular pattern. 
We are allowed to use only one loop. 
<pre>
Input: 7
Output:
*
* * 
* * *
* * * *
* * * * *
* * * * * *
* * * * * * *</pre>
Solution :<a href="https://www.geeksforgeeks.org/print-pattern-using-one-loop-continue-statement/"> Print the pattern by using one loop | Set 2 (Using Continue Statement)</a>
<h2>Break Statement in C/C++</h2>
The break in C or C++ is a loop control statement which is used to terminate the loop. 
As soon as the break statement is encountered from within a loop, the loop iterations stops there and control returns from the loop immediately to the first statement after the loop.<br />
<strong>Syntax:</strong>
<pre>
break;
</pre>
Basically break statements are used in the situations when we are not sure about the actual number of iterations for the loop or we want to terminate the loop based on some condition.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/break.png" alt=""><br />
<strong>We will see here the usage of break statement with three different types of loops:</strong>
<ol>
<li>Simple loops</li>
<li>Nested loops</li>
<li>Infinite loops</li>
</ol>
Let us now look at the examples for each of the above three types of loops using break statement.
<ol>
<li><strong>Simple loops</strong>: Consider the situation where we want to search an element in an array. 
To do this, use a loop to traverse the array starting from the first index and compare the array elements with the given key.<br />
Below is the implementation of this idea:
<h3>C</h3>
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">// Linear Search&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">findElement(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">size, </code><code class="color1 bold">int</code> <code class="plain">key)&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop to traverse array and search for key&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; size; i++) {&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(arr[i] == key) {&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Element found at position: %d"</code><code class="plain">, (i + 1));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 5, 6 };&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// no of elements </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 6;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// key to be searched&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">key = 3;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling function to find the key&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">findElement(arr, n, key);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// Linear Search </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">findElement(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">size, </code><code class="color1 bold">int</code> <code class="plain">key) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop to traverse array and search for key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; size; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(arr[i] == key) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Element found at position: "</code> <code class="plain">&lt;&lt; (i + 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 5, 6 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 6; </code><code class="comments">// no of elements </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">key = 3; </code><code class="comments">// key to be searched </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling function to find the key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">findElement(arr, n, key); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
Element found at index: 3
</pre>
The above code runs fine with no errors. 
But the above code is not efficient. 
The above code completes all the iterations even after the element is found. 
Suppose there are <strong>1000</strong> elements in the array and the key to be searched is present at 1st position so the above approach will execute <strong>999</strong> iterations which are of no purpose and are useless.<br />
To avoid these useless iterations, we can use the break statement in our program. 
Once the break statement is encountered the control from the loop will return immediately after the condition gets satisfied. 
So will use the break statement with the if condition which compares the key with array elements as shown below:
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Linear Search </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">findElement(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">size, </code><code class="color1 bold">int</code> <code class="plain">key) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop to traverse array and search for key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; size; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(arr[i] == key) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Element found at position: %d"</code><code class="plain">, (i + 1));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using break to terminate loop execution </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 5, 6 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// no of elements </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 6;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// key to be searched </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">key = 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling function to find the key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">findElement(arr, n, key); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Linear Search </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">findElement(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">size, </code><code class="color1 bold">int</code> <code class="plain">key) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop to traverse array and search for key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; size; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(arr[i] == key) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Element found at position: "</code> <code class="plain">&lt;&lt; (i + 1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using break to terminate loop execution </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 2, 3, 4, 5, 6 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 6; </code><code class="comments">// no of elements </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">key = 3; </code><code class="comments">// key to be searched </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling function to find the key </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">findElement(arr, n, key); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
Element found at position: 3
</pre>
</li>
<li><strong>Nested Loops</strong>: We can also use break statement while working with nested loops. 
If the break statement is used in the innermost loop. 
The control  will come out only from the innermost loop. 
Below is the example of using break with nested loops:
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Nested loops </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// nested for loops with break statement </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// at inner loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; 5; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j = 1; j &lt;= 10; j++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(j > 3) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Nested loops </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// nested for loops with break statement </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// at inner loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; 5; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">j = 1; j &lt;= 10; j++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(j > 3) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"*"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
***
***
***
***
***
</pre>
In the above code we can clearly see that the inner loop is programmed to execute for 10 iterations. 
But as soon as the value of <strong>j</strong> becomes greater than 3 the inner loop stops executing which restricts the number of iteration of the inner loop to 3 iterations only. 
However the iteration of outer loop remains unaffected.<br />
<strong>Therefore, break applies to only the loop within which it is present.</strong>
</li>
<li>
<strong>Infinite Loops</strong>: break statement can be included in an infinite loop with a condition in order to terminate the execution of the infinite loop.<br />
Consider the below infinite loop:
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Infinite loops </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop initialization expression </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// infinite while loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Infinite loops </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop initialization expression </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// infinite while loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; i &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Note</strong>: Please donot run the above program in your compiler as it is an infinite loop so you may have to forcefully exit the compiler to terminate the program.
In the above program, the loop condition based on which the loop terminates is always true. 
So, the loop executes infinite number of times. 
We can correct this by using the break statement as shown below:
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Infinite loops </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop initialization expression </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// infinite while loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i > 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// using break statement&nbsp; </code>
<code class="comments">// in Infinite loops </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// loop initialization expression </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// infinite while loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(i > 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; i &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
1 2 3 4 5 6 7 8 9 10 
</pre>
The above code restricts the number of loop iterations to 10.</li></ol>
Apart from this, break can be used in Switch case statements too.
<h2>Using range in switch case in C/C++</h2>
<!-- Problem Statement --><br />
You all are familiar with <a href="https://www.geeksforgeeks.org/switch-statement-cc/">switch case</a> in C/C++, but did you know <strong>you can use range of numbers</strong> instead of a single number or character in case statement.
<ul>
<li>That is the case range extension of the GNU C compiler and not standard C or C++</li>
<li>You can specify a range of consecutive values in a single case label, like this:
<pre><strong>case low ... 
high:</strong></pre>
</li>
<li>It can be used for ranges of ASCII character codes like this:
<pre> <strong>case 'A' ... 
'Z':</strong></pre>
</li>
<li>You need to Write spaces around the ellipses<strong> &#8230; </strong>. 
For example, write this:
<pre>// Correct  -   <strong>case 1 ... 
5:</strong>
// Wrong -    <strong>case 1...5:</strong></pre>
</li>
</ul>
<code class="comments">// C program to illustrate </code>
<code class="comments">// using range in switch case </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 1, 5, 15, 20 }; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; 4; i++)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(arr[i])&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1 ... 
6: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d in range 1 to 6\n"</code><code class="plain">, arr[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">19 ... 
20: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d in range 19 to 20\n"</code><code class="plain">, arr[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">default</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d not in range\n"</code><code class="plain">, arr[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
1 in range 1 to 6
5 in range 1 to 6
15 not in range
20 in range 19 to 20
</pre>
<strong>Exercise :</strong> You can try above program for char array by modifying char array and case statement.
<strong>Error conditions:</strong>
<ol>
<li><strong>low > high : </strong>The compiler gives with an error message.</li>
<li><strong>Overlapping case values : </strong>If the value of a case label is within a case range that has already been used in the switch statement, the compiler gives an error message.</li>
</ol>
<h2>Functions in C/C++</h2>
A function is a set of statements that take inputs, do some specific computation and produces output. 
The idea is to put some commonly or repeatedly done task together and make a function so that instead of writing the same code again and again for different inputs, we can call the function.
&nbsp;<br />
<strong>Example: </strong><br />
Below is a simple C/C++ program to demonstrate functions.<br />
<h3>C</h3>
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// An example function that takes two parameters 'x' and 'y' </code>
<code class="comments">// as input and returns max of two input numbers </code>
<code class="color1 bold">int</code> <code class="plain">max(</code><code class="color1 bold">int</code> <code class="plain">x, </code><code class="color1 bold">int</code> <code class="plain">y) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(x > y) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">y; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// main function that doesn't receive any parameter and </code>
<code class="comments">// returns integer. 
</code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling above function to find max of 'a' and 'b' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">m = max(a, b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"m is %d"</code><code class="plain">, m); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">max(</code><code class="color1 bold">int</code> <code class="plain">x, </code><code class="color1 bold">int</code> <code class="plain">y)&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(x > y)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">y;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling above function to find max of 'a' and 'b'&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">m = max(a, b);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"m is "</code> <code class="plain">&lt;&lt; m;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">} </code>
<br />
<strong>Output: </strong>
<pre>m is 20</pre>

<strong><br />
Why do we need functions?</strong>
<ul>
<li>Functions help us in reducing code redundancy. 
If functionality is performed at multiple places in software, then rather than writing the same code, again and again, we create a function and call it everywhere. 
This also helps in maintenance as we have to change at one place if we make future changes to the functionality.</li>
<li>Functions make code modular. 
Consider a big file having many lines of codes. 
It becomes really simple to read and use the code if the code is divided into functions.</li>
<li>Functions provide abstraction. 
For example, we can use library functions without worrying about their internal working.</li>
</ul>
<strong>Function Declaration</strong><br />
A function declaration tells the compiler about the number of parameters function takes, data-types of parameters and return type of function. 
Putting parameter names in function declaration is optional in the function declaration, but it is necessary to put them in the definition. 
Below are an example of function declarations. 
(parameter names are not there in below declarations)
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Function-Prototype-in-c.png" alt="">
<code class="comments">// A function that takes two integers as parameters </code>
<code class="comments">// and returns an integer </code>
<code class="color1 bold">int</code> <code class="plain">max(</code><code class="color1 bold">int</code><code class="plain">, </code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function that takes a int pointer and an int variable as parameters </code>
<code class="comments">// and returns an pointer of type int </code>
<code class="color1 bold">int</code> <code class="plain">*swap(</code><code class="color1 bold">int</code><code class="plain">*,</code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function that takes a charas parameters </code>
<code class="comments">// and returns an reference variable </code>
<code class="color1 bold">char</code> <code class="plain">*call(</code><code class="color1 bold">char</code> <code class="plain">b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function that takes a char and an int as parameters </code>
<code class="comments">// and returns an integer </code>
<code class="color1 bold">int</code> <code class="plain">fun(</code><code class="color1 bold">char</code><code class="plain">, </code><code class="color1 bold">int</code><code class="plain">); </code>
It is always recommended to declare a function before it is used (See <a href="https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/">this</a>, <a href="https://www.geeksforgeeks.org/g-fact-95/">this </a>and <a href="https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/">this </a>for details) 
In C, we can do both declaration and definition at the same place, like done in the above example program. 
C also allows to declare and define functions separately, this is especially needed in case of library functions. 
The library functions are declared in header files and defined in library files. 
Below is an example declaration. 
&nbsp;<br />
<strong>Parameter Passing to functions</strong><br />
The parameters passed to function are called <em><strong>actual parameters</strong></em>. 
For example, in the above program 10 and 20 are actual parameters.<br />
The parameters received by function are called <em><strong>formal parameters</strong></em>. 
For example, in the above program x and y are formal parameters.<br />
There are two most popular ways to pass parameters.
<em><strong>Pass by Value:</strong></em> In this parameter passing method, values of actual parameters are copied to function&#8217;s formal parameters and the two types of parameters are stored in different memory locations. 
So any changes made inside functions are not reflected in actual parameters of caller.
<em><strong>Pass by Reference</strong></em> Both actual and formal parameters refer to same locations, so any changes made inside the function are actually reflected in actual parameters of caller.
          
In C, parameters are always passed by value. 
Parameters are always passed by value in C. 
For example. 
in the below code, value of x is not modified using the function fun().<br />
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 30; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">x) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 30; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"x = "</code> <code class="plain">&lt;&lt; x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>x = 20</pre>
However, in C, we can use pointers to get the effect of pass by reference. 
For example, consider the below program. 
The function fun() expects a pointer ptr to an integer (or an address of an integer). 
It modifies the value at the address ptr. 
The dereference operator * is used to access the value at an address. 
In the statement ‘*ptr = 30’, value at address ptr is changed to 30. 
The address operator &amp; is used to get the address of a variable of any data type. 
In the function call statement ‘fun(&amp;x)’, the address of x is passed so that x can be modified using its address.<br />
<h3>C</h3>
<code class="preprocessor"># include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">*ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 30; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">fun(&x); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">*ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 30; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(&x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"x = "</code> <code class="plain">&lt;&lt; x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
Output: 
<pre>x = 30</pre>
&nbsp;<br />
<strong>Following are some important points about functions in C.</strong><br />
<strong>1) </strong>Every C program has a function called main() that is called by operating system when a user runs the program.
<strong>2)</strong> Every function has a return type. 
If a function doesn&#8217;t return any value, then void is used as return type. 
Moreover, if the return type of the function is void, we still can use return statement in the body of function definition by not specifying any constant, variable, etc. 
with it, by only mentioning the &#8216;return;&#8217; statement which would symbolise the termination of the function as shown below:
<code class="keyword bold">void</code> <code class="plain">function name(</code><code class="color1 bold">int</code> <code class="plain">a) </code>
<code class="plain">{ </code>
<code class="plain">.......&nbsp; </code><code class="comments">//Function Body </code>
<code class="keyword bold">return</code><code class="plain">;&nbsp; </code><code class="comments">//Function execution would get terminated </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<strong>3)</strong> In C, functions can return any type except arrays and functions. 
We can get around this limitation by returning pointer to array or pointer to function.<br />
<strong>4)</strong> Empty parameter list in C mean that the parameter list is not specified and function can be called with any parameters. 
In C, it is not a good idea to declare a function like fun(). 
To declare a function that can only be called without any parameter, we should use &#8220;void fun(void)&#8221;.<br />
As a side note, in C++, empty list means function can only be called without any parameter. 
In C++, both void fun() and void fun(void) are same.<br />
<strong>5)</strong>If in a C program, a function is called before its declaration then the C compiler automatically assumes the declaration of that function in the following way:<br />
int function name();<br />
And in that case if the return type of that function is different than INT ,compiler would show an error.
&nbsp;
<strong>More on Functions in C/C++:</strong>
<ul>
<li> <a href="https://www.geeksforgeeks.org/c-language-2-gq/functions-gq/">Quiz on function in C</a></li>
<li><a href="https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/">Importance of function prototype in C</a></li>
<li><a href="https://www.geeksforgeeks.org/functions-that-are-executed-before-and-after-main-in-c/">Functions that are executed before and after main() in C</a></li>
<li><a href="https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/">return statement vs exit() in main()</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-count-variable-numbers-of-arguments-in-c/">How to Count Variable Numbers of Arguments in C?, </a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-20/">What is evaluation order of function parameters in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/does-c-support-function-overloading/">Does C support function overloading?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-can-i-return-multiple-values-from-a-function/">How can we return multiple values from a function?</a></li>
<li><a href="https://www.geeksforgeeks.org/what-is-the-purpose-of-a-function-prototype/">What is the purpose of a function prototype?</a></li>
<li><a href="https://www.geeksforgeeks.org/what-are-static-functions-in-c/">Static functions in C</a></li>
<li><a href="https://www.geeksforgeeks.org/understanding-exit-abort-and-assert/">exit(), abort() and assert()</a></li>
<li><a href="https://www.geeksforgeeks.org/implicit-return-type-int-c-language/">Implicit return type int in C</a></li>
<li><a href="https://www.geeksforgeeks.org/g-fact-95/">What happens when a function is called before its declaration in C?</a></li>
</ul>
<h2>Importance of function prototype in C</h2>
Function prototype tells compiler about number of parameters function takes, data-types of parameters and return type of function. 
<!--more-->By using this information, compiler cross checks function parameters and their data-type with function definition and function call. 
If we ignore function prototype, program may compile with warning, and may work properly. 
But some times, it will give strange output and it is very hard to find such programming mistakes. 
Let us see with examples
<code class="preprocessor">#include &lt;errno.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc, </code><code class="color1 bold">char</code> <code class="plain">*argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(argv[1], </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(stderr, </code><code class="string">"%s\n"</code><code class="plain">, </code><code class="functions bold">strerror</code><code class="plain">(</code><code class="functions bold">errno</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="functions bold">errno</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"file exist\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Above program checks existence of file, provided from command line, if given file is exist, then the program prints &#8220;file exist&#8221;, otherwise it prints appropriate error message. 
Let us provide a filename, which does not exist in file system, and check the output of program on x86_64 architecture.
<pre>
[narendra@/media/partition/GFG]$ ./file_existence hello.c
Segmentation fault (core dumped)
</pre>
Why this program crashed, instead it should show appropriate error message. 
This program will work fine on x86 architecture, but will crash on x86_64 architecture. 
Let us see what was wrong with code. 
Carefully go through the program, deliberately I haven&#8217;t included prototype of &#8220;strerror()&#8221; function. 
This function returns &#8220;pointer to character&#8221;, which will print error message which depends on errno passed to this function. 
Note that x86 architecture is ILP-32 model, means integer, pointers and long are 32-bit wide, that&#8217;s why program will work correctly on this architecture. 
But x86_64 is LP-64 model, means long and pointers are 64 bit wide. 
<em>In C language, when we don&#8217;t provide prototype of function, the compiler assumes that function returns an integer</em>. 
In our example, we haven&#8217;t included &#8220;string.h&#8221; header file (strerror&#8217;s prototype is declared in this file), that&#8217;s why compiler assumed that function returns integer. 
But its return type is pointer to character. 
In x86_64, pointers are 64-bit wide and integers are 32-bits wide, that&#8217;s why while returning from function, the returned address gets truncated (i.e. 
32-bit wide address, which is size of integer on x86_64) which is invalid and when we try to dereference this address, the result is segmentation fault.
Now include the &#8220;string.h&#8221; header file and check the output, the program will work correctly.
<pre>
[narendra@/media/partition/GFG]$ ./file_existence hello.c
No such file or directory
</pre>
Consider one more example.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = </code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(p == NULL) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">perror</code><code class="plain">(</code><code class="string">"malloc()"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">-1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*p = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(p); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Above code will work fine on IA-32 model, but will fail on IA-64 model. 
Reason for failure of this code is we haven&#8217;t included prototype of malloc() function and returned value is truncated in IA-64 model.
<h2>Functions that are executed before and after main() in C</h2>
With GCC family of C compilers, we can mark some functions to execute before and after main(). 
<!--more-->So some startup code can be executed before main() starts, and some cleanup code can be executed after main() ends. 
<!--more--> For example, in the following program, myStartupFun() is called before main() and myCleanupFun() is called after main().
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Apply the constructor attribute to myStartupFun() so that it </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">is executed before main() */</code>
<code class="keyword bold">void</code> <code class="plain">myStartupFun (</code><code class="keyword bold">void</code><code class="plain">) __attribute__ ((constructor)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Apply the destructor attribute to myCleanupFun() so that it </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">is executed after main() */</code>
<code class="keyword bold">void</code> <code class="plain">myCleanupFun (</code><code class="keyword bold">void</code><code class="plain">) __attribute__ ((destructor)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* implementation of myStartupFun */</code>
<code class="keyword bold">void</code> <code class="plain">myStartupFun (</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"startup code before main()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* implementation of myCleanupFun */</code>
<code class="keyword bold">void</code> <code class="plain">myCleanupFun (</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"cleanup code after main()\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main (</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"hello\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
startup code before main()
hello
cleanup code after main()
</pre>
Like the above feature, GCC has added many other interesting features to standard C language. 
See <a href="http://drdobbs.com/cpp/184401956">this </a> for more details.
<strong>Related Article : </strong><br />
<a href="https://www.geeksforgeeks.org/executing-main-in-c-behind-the-scene/">Executing main() in C – behind the scene</a>
<h2>return statement vs exit() in main()</h2>
In C++, what is the difference between <em>exit(0)</em> and <em>return 0</em> ?<!--more-->
When <em>exit(0)</em> is used to exit from program, destructors for locally scoped non-static objects are not called. 
But destructors are called if return 0 is used. 
</br><br />
<strong>Program 1 &#8211; &#8211; uses exit(0) to exit</strong><br/>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">class</code> <code class="plain">Test { </code>
<code class="keyword bold">public</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">Test() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Constructor\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">~Test(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Destructor"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">Test t1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// using exit(0) to exit from main </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:<br />
<em>Inside Test&#8217;s Constructor</em>
<strong>Program 2 &#8211; uses return 0 to exit</strong>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">class</code> <code class="plain">Test { </code>
<code class="keyword bold">public</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">Test() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Constructor\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">~Test(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Destructor"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">Test t1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// using return 0 to exit from main </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
<em>Inside Test&#8217;s Constructor<br />
Inside Test&#8217;s Destructor<br />
</em>
Calling destructors is sometimes important, for example, if destructor has code to release resources like closing files. 
Note that static objects will be cleaned up even if we call exit(). 
For example, see following program.
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">class</code> <code class="plain">Test { </code>
<code class="keyword bold">public</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">Test() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Constructor\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">~Test(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Inside Test's Destructor"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="plain">Test t1;&nbsp; </code><code class="comments">// Note that t1 is static </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:<br />
<em>Inside Test&#8217;s Constructor<br />
Inside Test&#8217;s Destructor<br />
</em>
<h2>How to Count Variable Numbers of Arguments in C?</h2>
C supports variable numbers of arguments. 
But there is no language provided way for finding out total number of arguments passed. 
<!--more-->User has to handle this in one of the following ways:<br />
1) By passing first argument as count of arguments.<br />
2) By passing last argument as NULL (or 0).<br />
3) Using some printf (or scanf) like mechanism where first argument has placeholders for rest of the arguments.
Following is an example that uses first argument <em>arg_count</em> to hold count of other arguments.
<code class="preprocessor">#include &lt;stdarg.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// this function returns minimum of integer numbers passed.&nbsp; First&nbsp; </code>
<code class="comments">// argument is count of numbers. 
</code>
<code class="color1 bold">int</code> <code class="plain">min(</code><code class="color1 bold">int</code> <code class="plain">arg_count, ...) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">min, a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// va_list is a type to hold information about variable arguments </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">va_list</code> <code class="plain">ap;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// va_start must be called before accessing variable argument list </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">va_start</code><code class="plain">(ap, arg_count);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// Now arguments can be accessed one by one using va_arg macro </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// Initialize min as first argument in list&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">min = </code><code class="functions bold">va_arg</code><code class="plain">(ap, </code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// traverse rest of the arguments to find out minimum </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 2; i &lt;= arg_count; i++) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">((a = </code><code class="functions bold">va_arg</code><code class="plain">(ap, </code><code class="color1 bold">int</code><code class="plain">)) &lt; min) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">min = a; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">//va_end should be executed before the function returns whenever </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// va_start has been previously used in that function&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">va_end</code><code class="plain">(ap);&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">min; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">count = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Find minimum of 5 numbers: (12, 67, 6, 7, 100) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Minimum value is %d"</code><code class="plain">, min(count, 12, 67, 6, 7, 100)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
<em>Minimum value is 6</em>
<h2>What is evaluation order of function parameters in C?</h2>
It is compiler dependent in C. 
It is never safe to depend on the order of evaluation of side effects. 
For example, a function call like below may very well behave differently from one compiler to another:<!--more-->
<code class="keyword bold">void</code> <code class="plain">func (</code><code class="color1 bold">int</code><code class="plain">, </code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">i = 2; </code>
<code class="plain">func (i++, i++); </code>
There is no guarantee (in either the C or the C++ standard language definitions) that the increments will be evaluated in any particular order. 
Either increment might happen first. 
func might get the arguments `2, 3&#8242;, or it might get `3, 2&#8242;, or even `2, 2&#8242;. 
Source: <a href="http://gcc.gnu.org/onlinedocs/gcc/Non_002dbugs.html">http://gcc.gnu.org/onlinedocs/gcc/Non_002dbugs.html</a>
<h2>Does C support function overloading?</h2>
First of all, what is function overloading? Function overloading is a feature of a programming language that allows one to have many functions with same name but with different signatures.<!--more--><br />
This feature is present in most of the Object Oriented Languages such as C++ and Java. 
But C (not Object Oriented Language) doesn&#8217;t support this feature. 
However, one can achieve the similar functionality in C indirectly. 
One of the approach is as follows.
Have a void * type of pointer as an argument to the function. 
And another argument telling the actual data type of the first argument that is being passed.
<pre>
   int foo(void * arg1, int arg2);
</pre>
Suppose, arg2 can be interpreted as follows. 
0 = Struct1 type variable, 1 = Struct2 type variable etc. 
Here Struct1 and Struct2 are user defined struct types.
While calling the function foo at different places&#8230;
<pre>
    foo(arg1, 0);   /*Here, arg1 is pointer to struct type Struct1 variable*/
    foo(arg1, 1);    /*Here, arg1 is pointer to struct type Struct2 variable*/
</pre>
Since the second argument of the foo keeps track the data type of the first type, inside the function foo, one can get the actual data type of the first argument by typecast accordingly. 
i.e. 
inside the foo function
<code class="keyword bold">if</code><code class="plain">(arg2 == 0) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">struct1PtrVar = (Struct1 *)arg1; </code>
<code class="plain">} </code>
<code class="keyword bold">else</code> <code class="keyword bold">if</code><code class="plain">(arg2 == 1) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">struct2PtrVar = (Struct2 *)arg1; </code>
<code class="plain">} </code>
<code class="keyword bold">else</code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/*Error Handling*/</code>
<code class="plain">} </code>
There can be several other ways of implementing function overloading in C. 
But all of them will have to use pointers &#8211; the most powerful feature of C.<br />
In fact, it is said that without using the pointers, one can&#8217;t use C efficiently &#038; effectively in a real world program!
<h2>How can I return multiple values from a function?</h2>
We all know that a function in C can return only one value. 
So how do we achieve the purpose of returning multiple values.<br />
Well, first take a look at the declaration of a function.<br />
<!--more-->
<code class="color1 bold">int</code> <code class="plain">foo(</code><code class="color1 bold">int</code> <code class="plain">arg1, </code><code class="color1 bold">int</code> <code class="plain">arg2); </code>
So we can notice here that our interface to the function is through arguments and return value only. 
(Unless we talk about modifying the globals inside the function)
Let us take a deeper look&#8230;Even though a function can return only one value but that value can be of pointer type. 
That&#8217;s correct, now you&#8217;re speculating right!<br />
We can declare the function such that, it returns a structure type user defined variable or a pointer to it . 
And by the property of a structure, we know that a structure in C can hold multiple values of asymmetrical types (i.e. 
one int variable, four char variables, two float variables and so on&#8230;)
If we want the function to return multiple values of same data types, we could return the pointer to array of that data types.
We can also make the function return multiple values by using the arguments of the function. 
How? By providing the pointers as arguments.
Usually, when a function needs to return several values, we use one pointer in return instead of several pointers as arguments.
Please see<strong> <a href="https://www.geeksforgeeks.org/how-to-return-multiple-values-from-a-function-in-c-or-cpp/">How to return multiple values from a function in C or C++?</a> </strong>for more details.
<h2>What is the purpose of a function prototype?</h2>
The Function prototype serves the following purposes &#8211;<br />
<!--more--><br />
        1) It tells the return type of the data that the function will return.<br />
        2) It tells the number of arguments passed to the function.<br />
        3) It tells the data types of the each of the passed arguments.<br />
        4) Also it tells the order in which the arguments are passed to the function.
        Therefore essentially, function prototype specifies the input/output interlace to the function i.e. 
what to give to the function and what to expect from the function.
        Prototype of a function is also called signature of the function.
<strong>What if one doesn&#8217;t specify the function prototype?</strong><br />
Output of below kind of programs is generally asked at many places.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">foo(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">foo() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"foo called"</code><code class="plain">); </code>
<code class="plain">} </code>
If one doesn&#8217;t specify the function prototype, the behavior is specific to C standard (either C90 or C99) that the compilers implement. 
Up to C90 standard, C compilers assumed the return type of the omitted function prototype as int. 
And this assumption at compiler side may lead to unspecified program behavior.
Later C99 standard specified that compilers can no longer assume return type as int. 
Therefore, C99 became more restrict in type checking of function prototype. 
But to make C99 standard backward compatible, in practice, compilers throw the warning saying that the return type is assumed as int. 
But they go ahead with compilation. 
Thus, it becomes the responsibility of programmers to make sure that the assumed function prototype and the actual function type matches.
To avoid all this implementation specifics of C standards, it is best to have function prototype.
<h2>Static functions in C</h2>
Prerequisite : <a href="https://www.geeksforgeeks.org/static-variables-in-c/">Static variables in C</a>
In C, functions are global by default. 
The “<em>static</em>” keyword before a function name makes it static. 
For example, below function <em>fun() </em>is static. 
<!--more-->
<code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">fun(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I am a static function "</code><code class="plain">); </code>
<code class="plain">} </code>
Unlike global functions in C, access to static functions is restricted to the file where they are declared. 
Therefore, when we want to restrict access to functions, we make them static. 
Another reason for making functions static can be reuse of the same function name in other files.
For example, if we store following program in one file <em>file1.c</em>
<code class="comments">/* Inside file1.c */</code>&nbsp;
<code class="keyword bold">static</code> <code class="keyword bold">void</code> <code class="plain">fun1(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"fun1 called"</code><code class="plain">); </code>
<code class="plain">} </code>
And store following program in another file <em>file2.c</em>
<code class="comments">/* Iinside file2.c&nbsp; */</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">fun1();&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp; </code>
<code class="plain">} </code>
Now, if we compile the above code with command “<em>gcc  file2.c file1.c</em>”,  we get the error <em>“undefined reference to `fun1&#8217;”</em> . 
This is because <em>fun1()</em> is declared <em>static </em>in <em>file1.c</em> and cannot be used in <em>file2.c</em>. 
<h2>exit(), abort() and assert()</h2>
<strong>exit()</strong>
<code class="keyword bold">void</code> <code class="functions bold">exit</code> <code class="plain">( </code><code class="color1 bold">int</code> <code class="plain">status );&nbsp; </code>
exit() terminates the process normally. 
<!--more--><br />
status:  Status value returned to the parent process. 
Generally, a status value of 0 or EXIT_SUCCESS indicates success, and any other value or the constant EXIT_FAILURE is used to indicate an error. 
exit() performs following operations.<br />
* Flushes unwritten buffered data.<br />
* Closes all open files.<br />
* Removes temporary files.<br />
* Returns an integer exit status to the operating system.
The C standard <a href="http://www.cplusplus.com/reference/clibrary/cstdlib/atexit/">atexit() </a>function can be used to customize exit() to perform additional actions at program termination.
Example use of exit.
<code class="comments">/* exit example */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">* pFile; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">pFile = </code><code class="functions bold">fopen</code> <code class="plain">(</code><code class="string">"myfile.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(pFile == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Error opening file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code> <code class="plain">(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* file operations here */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br>
When exit() is called, any open file descriptors belonging to the process are closed and any children of the process are inherited by process 1, init, and the process parent is sent a SIGCHLD signal.
The mystery behind exit() is that it takes only integer args in the range 0 &#8211; 255 . 
Out of range exit values can result in unexpected exit codes. 
An exit value greater than 255 returns an exit code modulo 256.<br />
For example, exit 9999 gives an exit code of 15 i.e. 
(9999 % 256 = 15).
Below is the C implementation to illustrate the above fact:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;sys/wait.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pid_t pid = fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( pid == 0 ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(9999); </code><code class="comments">//passing value more than 255 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">status; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">waitpid(pid, &status, 0); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( WIFEXITED(status) ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">exit_status = WEXITSTATUS(status); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Exit code: %d\n"</code><code class="plain">, exit_status); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Exit code: 15
</pre>
Note that the above code may not work with online compiler as fork() is disabled.
Explanation: It is effect of 8-bit integer overflow. 
After 255 (all 8 bits set) comes 0.<br />
So the output is  &#8220;exit code modulo 256&#8221;. 
The output above is actually the modulo of the value 9999 and 256 i.e. 
15.
</br><br />
<strong>abort()</strong>
<code class="keyword bold">void</code> <code class="functions bold">abort</code> <code class="plain">( </code><code class="keyword bold">void</code> <code class="plain">); </code>
Unlike exit() function, abort() may not close files that are open. 
It may also not delete temporary files and may not flush stream buffer. 
Also, it does not call functions registered with <a href="http://www.cplusplus.com/reference/clibrary/cstdlib/atexit/">atexit()</a>.
          
This function actually terminates the process by raising a SIGABRT signal, and your program can include a handler to intercept this signal (see <a href="http://msdn.microsoft.com/en-us/library/xdkz3x12%28VS.80%29.aspx">this</a>).
So programs like below might not write &#8220;Geeks for Geeks&#8221; to &#8220;tempfile.txt&#8221;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"C:\\myfile.txt"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n could not open file "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">}&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(fp, </code><code class="string">"%s"</code><code class="plain">, </code><code class="string">"Geeks for Geeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* .......*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* .......*/</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Something went wrong so terminate here */</code>&nbsp;&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">abort</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp; </code>
If we want to make sure that data is written to files and/or buffers are flushed then we should either use exit() or include a signal handler for SIGABRT.
</br><br />
<strong>assert()</strong>
<code class="keyword bold">void</code> <code class="functions bold">assert</code><code class="plain">( </code><code class="color1 bold">int</code> <code class="plain">expression ); </code>
If expression evaluates to 0 (false), then the expression, sourcecode filename, and line number are sent to the standard error, and then  abort()  function is called. 
If the identifier NDEBUG (&#8220;no debug&#8221;) is defined with #define NDEBUG then the macro assert does nothing.
Common error outputting is in the form:
<em>    Assertion failed: expression, file filename, line line-number </em>
<code class="preprocessor">#include&lt;assert.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">open_record(</code><code class="color1 bold">char</code> <code class="plain">*record_name) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">assert</code><code class="plain">(record_name != NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Rest of code */</code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">open_record(NULL); </code>
<code class="plain">} </code>
<strong>Related Article : </strong><br />
<a href="https://www.geeksforgeeks.org/exit-vs-_exit-c-cpp/">exit() vs _Exit() in C and C++</a>
<h2>Implicit return type int in C</h2>
Predict the output of following C program.<!--more-->
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">x*x; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, fun(10)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 100
The important thing to note is, there is no return type for fun(), the program still compiles and runs fine in most of the C compilers. 
In C, if we do not specify a return type, compiler assumes an implicit return type as int. 
However, C99 standard doesn&#8217;t allow return type to be omitted even if return type is int. 
This was allowed in older C standard C89.
In C++, the above program is not valid except few old C++ compilers like Turbo C++. 
Every function should specify the return type in C++.
<h2>What happens when a function is called before its declaration in C?</h2>
In C, if a function is called before its declaration, the <strong>compiler assumes return type of the function as int</strong>.<!--more-->
For example, the following program fails in compilation.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that fun() is not declared&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">char</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="string">'G'</code><code class="plain">; </code>
<code class="plain">} </code>
if the function <strong>char fun()</strong> in above code is defined before main() then it will compile and run perfectly.<br />
for example, the following program will run properly.<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">char</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="string">'G'</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that fun() is not declared&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The following program compiles and run fine because function is defined before main().
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">10; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, fun()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>What about parameters?</strong> compiler assumes nothing about parameters. 
Therefore, the compiler will not be able to perform compile-time checking of argument types and arity when the function is applied to some arguments. 
This can cause problems. 
For example, the following program compiled fine in GCC and produced garbage value as output. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main (</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, sum(10, 5)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">sum (</code><code class="color1 bold">int</code> <code class="plain">b, </code><code class="color1 bold">int</code> <code class="plain">c, </code><code class="color1 bold">int</code> <code class="plain">a) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(a+b+c); </code>
<code class="plain">} </code>
There is this misconception that the compiler assumes input parameters also int. 
Had compiler assumed input parameters int, the above program would have failed in compilation.
It is always recommended to declare a function before its use so that we don&#8217;t see any surprises when the program is run (See <a href="https://www.geeksforgeeks.org/importance-of-function-prototype-in-c/">this </a>for more details).
<strong>Source: </strong><br />
<a href="http://en.wikipedia.org/wiki/Function_prototype#Uses">http://en.wikipedia.org/wiki/Function_prototype#Uses</a>
<h2>_Noreturn function specifier in C</h2>
After the removal of &#8220;noreturn&#8221; keyword, C11 standard (known as final draft) of C programming language introduce a new &#8220;_Noreturn&#8221; function specifier that specify that the function does not return to the function that it was called from. 
If the programmer try to return any value from that function which is declared as _Noreturn type, then the compiler automatically generates a compile time error.
<code class="comments">// C program to show how _Noreturn type&nbsp; </code>
<code class="comments">// function behave if it has return statement. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// With return value </code>
<code class="plain">_Noreturn </code><code class="keyword bold">void</code> <code class="plain">view() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">10; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Ready to begin...\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">view(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"NOT over till now\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Ready to begin...
After that abnormal termination of program.
compiler error:[Warning] function declared 'noreturn' has a 'return' statement
</pre>
<code class="comments">// C program to illustrate the working&nbsp; </code>
<code class="comments">// of _Noreturn type function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Nothing to return </code>
<code class="plain">_Noreturn </code><code class="keyword bold">void</code> <code class="plain">show() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"BYE BYE"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Ready to begin...\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"NOT over till now\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Ready to begin...
BYE BYE
</pre>
Reference: <a href="http://en.cppreference.com/w/c/language/_Noreturn">http://en.cppreference.com/w/c/language/_Noreturn</a>
<h2>exit() vs _Exit() in C and C++</h2>
In C, <a href="https://www.geeksforgeeks.org/understanding-exit-abort-and-assert/">exit()</a> terminates the calling process without executing the rest code which is after the exit() function.
Example:-
<code class="comments">// C program to illustrate exit() function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"START"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code><code class="comments">// The program is terminated here </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This line is not printed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"End of program"</code><code class="plain">); </code>
<code class="plain">} </code>
Output:
<pre>
START
</pre>
Now the question is that if we have exit() function then why C11 standard introduced _Exit()? Actually exit() function performs some cleaning before termination of the program like connection termination, buffer flushes etc. 
The _Exit() function in C/C++ gives normal termination of a program without performing any cleanup tasks. 
For example it does not execute functions registered with atexit.
Syntax: 
<pre>
// Here the exit_code represent the exit status 
// of the program which can be 0 or non-zero.
// The _Exit() function returns nothing.
void _Exit(int exit_code);
</pre>
<code class="comments">// C++ program to demonstrate use of _Exit() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">exit_code = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Termination using _Exit"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">_Exit(exit_code); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">} </code>
Output:
<pre>
</pre>
<strong>Showing difference through programs:</strong>
<code class="comments">// A C++ program to show difference </code>
<code class="comments">// between exit() and _Exit() </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Exiting"</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">atexit</code><code class="plain">(fun); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(10); </code>
<code class="plain">} </code>
Output 
<pre>
Exiting</pre>
If we replace exit with _Exit(), then nothing is printed.
<code class="comments">// A C++ program to show difference </code>
<code class="comments">// between exit() and _Exit() </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Exiting"</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">atexit</code><code class="plain">(fun); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">_Exit(10); </code>
<code class="plain">} </code>
Output 
<pre>
</pre>
<h2>Predefined Identifier __func__ in C</h2>
Before we start discussing about <em>__func__</em>, let us write some code snippet and anticipate the output:
<code class="preprocessor">#include “studio.h” </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(“%s”,__func__); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Will it compile error due to not defining variable <em>__func__</em> ? Well, as you would have guessed so far, it won’t give any compile error and it’d print <strong>main</strong>! 
C language standard (i.e. 
C99 and C11) defines a predefined identifier as follows in clause 6.4.2.2:
&#8220;<em>The identifier __func__ shall be implicitly declared by the translator as if, immediately following the opening brace of each function definition, the declaration
static const char __func__[] = &#8220;function-name&#8221;;
appeared, where function-name is the name of the lexically-enclosing function.</em>&#8221;
It means that C compiler implicitly adds <em>__func__</em> in every function so that it can be used in that function to get the function name. 
To understand it better, let us write this code:
<code class="preprocessor">#include “stdio.h” </code>
<code class="keyword bold">void</code> <code class="plain">foo(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(“%s”,__func__); </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">bar(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(“%s”,__func__); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">foo(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">bar(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
And it’ll give output as <strong>foobar</strong>. 
A use case of this predefined identifier could be logging the output of a big program where a programmer can use <em>__func__</em> to get the current function instead of mentioning the complete function name explicitly. 
Now what happens if we define one more variable of name <em>__func__</em>
<code class="preprocessor">#include “stdio.h” </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">__func__ = 10; </code>
<code class="color1 bold">int</code>&nbsp; <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(“%d”,__func__); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Since C standard says compiler implicitly defines <em>__func__</em> for each function as the function-name, we should not defined <em>__func__</em> at the first place. 
You might get error but C standard says “undefined behaviour” if someone explicitly defines <em>__func__</em> .
Just to finish the discussion on Predefined Identifier <em>__func__</em>, let us mention Predefined Macros as well (such as __FILE__ and __LINE__ etc.) Basically, C standard clause 6.10.8 mentions several predefined macros out of which <em>__FILE__</em> and <em>__LINE__</em> are of relevance here. 
It’s worthwhile to see the output of the following code snippet:
<code class="preprocessor">#include "stdio.h" </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In file:%s, function:%s() and line:%d"</code><code class="plain">,__FILE__,__func__,__LINE__); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Instead of explaining the output, we will leave this to you to guess and understand the role of <em>__FILE__</em> and <em>__LINE__</em>!
Please do Like/Tweet/G+1 if you find the above useful. 
Also, please do leave us comment for further clarification or info. 
We would love to help and learn 🙂
<h2>Callbacks in C</h2>
A callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time [Source : <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">Wiki</a>]. 
In simple language, If a reference of a function is passed to another function as an argument to call it, then it will be called as a Callback function.
In C, a callback function is a function that is called through a <a href="https://www.geeksforgeeks.org/function-pointer-in-c/">function pointer</a>. 
Below is a simple example in C to illustrate the above definition to make it more clear:<br/>
<code class="comments">// A simple C program to demonstrate callback </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">A() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I am function A\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// callback function </code>
<code class="keyword bold">void</code> <code class="plain">B(</code><code class="keyword bold">void</code> <code class="plain">(*ptr)()) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(*ptr) (); </code><code class="comments">// callback to A </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">(*ptr)() = &A; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calling function B and passing </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// address of the function A as argument </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">B(ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
I am function A
</pre>
In C++ STL, <a href="https://www.geeksforgeeks.org/functors-in-cpp/">functors</a> are also used for this purpose. 
<h2>Nested functions in C</h2>
Some programmer thinks that defining a function inside an another function is known as &#8220;nested function&#8221;. 
But the reality is that it is not a nested function, it is treated as lexical scoping. 
Lexical scoping is not valid in C because the compiler cant reach/find the correct memory location of the inner function.
Nested function <strong>is not supported</strong> by C because we cannot define a function within another function in C. 
We can declare a function inside a function, but it&#8217;s not a nested function.<br />
Because nested functions definitions can not <a href="https://www.geeksforgeeks.org/g-fact-24/">access local variables</a> of the surrounding blocks, they can access only global variables of the containing module. 
This is done so that lookup of global variables doesn&#8217;t have to go through the directory. 
As in C, there are two nested scopes: local and global (and beyond this, built-ins). 
Therefore, nested functions have only a limited use. 
If we try to approach nested function in C, then we will get compile time error.
<code class="comments">// C program to illustrate the </code>
<code class="comments">// concept of Nested function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Main"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">fun() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"fun"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// defining view() function inside fun() function. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">view() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"view"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">view(); </code>
<code class="plain">} </code>
Output:
<pre>
Compile time error: undefined reference to `view'
</pre>
An extension of the GNU C Compiler allows the declarations of nested functions. 
The declarations of nested functions under GCC&#8217;s extension need to be prefix/start with the<a href="https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/"> auto keyword</a>.
<code class="comments">// C program of nested function </code>
<code class="comments">// with the help of gcc extension </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">auto</code> <code class="color1 bold">int</code> <code class="plain">view(); </code><code class="comments">// declare function with auto keyword </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">view(); </code><code class="comments">// calling function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Main\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">view() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"View\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GEEKS"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
view
Main
GEEKS
</pre>
<h2>Parameter Passing Techniques in C/C++</h2>
There are different ways in which parameter data can be passed into and out of methods and functions. 
Let us assume that a function <em>B()</em> is called from another function <em>A()</em>. 
In this case <em>A</em> is called the <em><strong>&#8220;caller function&#8221;</strong></em> and <em>B</em> is called the <em><strong>&#8220;called function or callee function&#8221;</strong></em>. 
Also, the arguments which <em>A</em> sends to <em>B</em> are called <em>actual arguments</em> and the parameters of <em>B</em> are called <em>formal arguments</em>.
<p align="center"><strong>Terminology</strong>
<ul>
<li><strong>Formal Parameter :</strong> A variable and its type as they appear in the prototype of the function or method.</li>
<li><strong>Actual Parameter :</strong> The variable or expression corresponding to a formal parameter that appears in the function or method call in the calling environment.</li>
<li><strong>Modes:</strong>
<ul>
<li><strong>IN:</strong> Passes info from caller to calle.</li>
<li><strong>OUT:</strong> Callee writes values in caller.</li>
<li><strong>IN/OUT:</strong> Caller tells callee value of variable, which may be updated by callee.</li>
</ul>
</li>
</ul>
<p align="center"><strong>Important methods of Parameter Passing</strong>
<ol>
<li><strong>Pass By Value : </strong> This method uses <em>in-mode</em> semantics. 
Changes made to formal parameter do not get transmitted back to the caller. 
Any modifications to the formal parameter variable inside the called function or method affect only the separate storage location and will not be reflected in the actual parameter in the calling environment. 
This method is also called as<strong> <em>call by value</em></strong>.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Call-By-Value.png" alt="">
<code class="comments">// C program to illustrate </code>
<code class="comments">// call by value </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a += b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In func, a = %d b = %d\n"</code><code class="plain">, a, b); </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 5, y = 7; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Passing parameters </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">func(x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In main, x = %d y = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
In func, a = 12 b = 7
In main, x = 5 y = 7
</pre>
Languages like C, C++, Java support this type of parameter passing. 
<a href="https://www.geeksforgeeks.org/g-fact-31-java-is-strictly-pass-by-value/">Java in fact is strictly call by value.</a><br />
<strong>Shortcomings:</strong>
<ul>
<li>Inefficiency in storage allocation</li>
<li>For objects and arrays, the copy semantics are costly</li>
</ul>
</li>
<li><strong>Pass by reference(aliasing) : </strong> This technique uses <em>in/out-mode</em> semantics. 
Changes made to formal parameter do get transmitted back to the caller through parameter passing. 
Any changes to the formal parameter are reflected in the actual parameter in the calling environment as formal parameter receives a reference (or pointer) to the actual data. 
This method is also called as &lt;<strong>em&gt;call by reference</em></strong>. 
This method is efficient in both time and space.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Call-By-Reference.png" alt="">
<code class="comments">// C program to illustrate </code>
<code class="comments">// call by reference </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">swapnum(</code><code class="color1 bold">int</code><code class="plain">* i, </code><code class="color1 bold">int</code><code class="plain">* j) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">temp = *i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*i = *j; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*j = temp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10, b = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// passing parameters </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swapnum(&a, &b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"a is %d and b is %d\n"</code><code class="plain">, a, b); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
a is 20 and b is 10
</pre>
C and C++ both support call by value as well as call by reference whereas Java does&#8217;nt support call by reference.<br />
<strong>Shortcomings:</strong>
<ul>
<li>Many potential scenarios can occur</li>
<li>Programs are difficult to understand sometimes</li>
</ul></li></ol>
<p align="center"><strong>Other methods of Parameter Passing</strong>
These techniques are older and were used in earlier programming languages like Pascal, Algol and Fortran. 
These techniques are not applicable in high level languages.
<ol>
<li> <strong>Pass by Result : </strong>This method uses <em>out-mode</em> semantics. 
Just before control is transfered back to the caller, the value of the formal parameter is transmitted back to the actual parameter.T his method is sometimes called <em>call by result</em>. 
In general, pass by result technique is implemented by copy.
</li>
<li><strong>Pass by Value-Result :</strong> This method uses <em>in/out-mode</em> semantics. 
It is a combination of Pass-by-Value and Pass-by-result. 
Just before the control is transferred back to the caller, the value of the formal parameter is transmitted back to the actual parameter. 
This method is sometimes called as <em>call by value-result</em></li>
<li><strong>Pass by name : </strong>This technique is used in programming language such as <strong><em>Algol</em></strong>. 
In this technique, symbolic &#8220;<em>name</em>&#8221; of a variable is passed, which allows it both to be accessed and update.<br />
Example:<br />
To double the value of <em>C[j]</em>, you can pass its name (not its value) into the following procedure.
<pre>
procedure double(x);
  real x;
begin 
  x:=x*2
end;
</pre>
In general, the effect of pass-by-name is to textually substitute the argument in a procedure call for the corresponding parameter in the body of the procedure.<br />
Implications of Pass-by-Name mechanism:
<ul>
<li>The argument expression is re-evaluated each time the formal parameter is passed.</li>
<li>The procedure can change the values of variables used in the argument expression and hence change the expression&#8217;s value.</li>
</ul></li></ol>
<h2>Power Function in C/C++</h2>
Given two numbers base and exponent, pow() function finds x raised to the power of y i.e. 
x<sup>y</sup>. 
Basically in C exponent value is calculated using the pow() function.<br />
<strong>Example:</strong>
<pre>
<strong>Input:</strong> 2.0, 5.0
<strong>Output:</strong> 32
<strong>Explanation: </strong>
pow(2.0, 5.0) executes 2.0 raised to
the power 5.0, which equals 32
<strong>Input:</strong> 5.0, 2.0
<strong>Output:</strong> 25
<strong>Explanation: </strong>
pow(5.0, 2.0) executes 5.0 raised to
the power 2.0, which equals 25
</pre>
<strong>Syntax:</strong>
<pre>double pow(double x, double y);</pre>
<strong>Parameters:</strong> The method takes two arguments:
<ul>
<li><strong>x :</strong> floating point base value</li>
<li><strong>y :</strong> floating point power value</li>
</ul>
<strong>Program:</strong><br />
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// power function </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 6.1, y = 4.8; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Storing the answer in result. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">result = </code><code class="functions bold">pow</code><code class="plain">(x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%.2lf"</code><code class="plain">, result); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// power function </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 6.1, y = 4.8; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Storing the answer in result. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">result = </code><code class="functions bold">pow</code><code class="plain">(x, y); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// printing the result upto 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// decimal place </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; result &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
5882.79
</pre>
<p align="center"><strong>Working of pow() function with integers</strong>
The pow() function takes &#8216;double&#8217; as the arguments and returns a &#8216;double&#8217; value. 
This function does not always work for integers. 
One such example is pow(5, 2). 
When assigned to an integer, it outputs 24 on some compilers and works fine for some other compilers. 
But pow(5, 2) without any assignment to an integer outputs 25. 
<ul>
<li>This is because 5<sup>2</sup> (i.e. 
25) might be stored as 24.9999999 or 25.0000000001 because the return type is double. 
When assigned to int, 25.0000000001 becomes 25 but 24.9999999 will give output 24.</li>
<li>To overcome this and output the accurate answer in integer format, we can add 0.5 to the result and typecast it to <strong>int</strong> e.g  (int)(pow(5, 2)+0.5) will give the correct answer(25, in above example), irrespective of the compiler.</li>
</ul>
<h3>C</h3>
<code class="comments">// C program to illustrate </code>
<code class="comments">// working with integers in </code>
<code class="comments">// power function </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Using typecasting for </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// integer result </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = (</code><code class="color1 bold">int</code><code class="plain">)(</code><code class="functions bold">pow</code><code class="plain">(5, 2) + 0.5); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C++</h3>
<code class="comments">// CPP program to illustrate </code>
<code class="comments">// working with integers in </code>
<code class="comments">// power function </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Using typecasting for </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// integer result </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = (</code><code class="color1 bold">int</code><code class="plain">)(</code><code class="functions bold">pow</code><code class="plain">(5, 2) + 0.5); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
25
</pre>
<h2>tolower() function in C</h2>
The <strong>tolower()</strong> function is defined in the <strong>ctype.h</strong> header file. 
If the character passed is a uppercase alphabet then the tolower() function converts a uppercase alphabet to an lowercase alphabet.
<strong>Syntax:</strong>
<pre>int tolower(int ch);</pre>
<strong>Parameter:</strong> This method takes a mandatory parameter <strong>ch</strong> which is the character to be converted to lowercase.
<strong>Return Value:</strong> This function returns the <strong>lowercase character</strong> corresponding to the ch.
Below programs illustrate the tolower() function in C:
<strong>Example 1:-</strong>
<code class="comments">// C program to demonstrate </code>
<code class="comments">// example of tolower() function. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Character to be converted to lowercase </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch = </code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// convert ch to lowercase using toLower() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c in lowercase is represented as = %c"</code><code class="plain">, ch, </code><code class="functions bold">tolower</code><code class="plain">(ch)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
G in lowercase is represented as = g
</pre>
<strong>Example 2:-</strong>
<code class="comments">// C program to demonstrate </code>
<code class="comments">// example of tolower() function. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;ctype.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">j = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"GEEKSFORGEEKS\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Character to be converted to lowercase </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch = </code><code class="string">'G'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// convert ch to lowercase using toLower() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(str[j]) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ch = str[j]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// convert ch to lowercase using toLower() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(</code><code class="functions bold">tolower</code><code class="plain">(ch)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">j++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
geeksforgeeks
</pre>
<h2>time() function in C</h2>
The time() function is defined in time.h (ctime in C++) header file. 
This function returns the time since 00:00:00 UTC, January 1, 1970 (Unix timestamp) in seconds. 
If second is not a null pointer, the returned value is also stored in the object pointed to by second.
<strong>Syntax:</strong>
<pre>time_t time( time_t *second )</pre>
<strong>Parameter:</strong> This function accepts single parameter <em>second</em>. 
This parameter is used to set the time_t object which store the time.
<strong>Return Value:</strong> This function returns current calender time as a object of type time_t.
<strong>Program 1:</strong>
<code class="comments">// C program to demonstrate </code>
<code class="comments">// example of time() function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;time.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">time_t</code> <code class="plain">seconds; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">seconds = </code><code class="functions bold">time</code><code class="plain">(NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Seconds since January 1, 1970 = %ld\n"</code><code class="plain">, seconds); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Seconds since January 1, 1970 = 1538123990
</pre>
<strong>Example 2:</strong>
<code class="comments">// C program to demonstrate </code>
<code class="comments">// example of time() function. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;time.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">time_t</code> <code class="plain">seconds; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Stores time seconds </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">time</code><code class="plain">(&seconds); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Seconds since January 1, 1970 = %ld\n"</code><code class="plain">, seconds); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Seconds since January 1, 1970 = 1538123990
</pre>
<h2>Pointers in C and C++ | Set 1 (Introduction, Arithmetic and Array)</h2>
Pointers store address of variables or a memory location. 
<pre>
// General syntax
<strong>datatype *var_name; </strong>
// An example pointer "ptr" that holds
// address of an integer variable or holds
// address of a memory whose value(s) can
// be accessed as integer values through "ptr"
<strong>int *ptr;  </strong>
</pre>
<strong>Using a Pointer:</strong>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/How-Pointer-Works-In-C.png" alt="">
To use pointers in C, we must understand below two operators.
<ul>
<li> To access address of a variable to a pointer, we use the unary operator <strong>&amp; </strong>(ampersand) that returns the address of that variable. 
For example &amp;x gives us address of variable x.
<code class="comments">// The output of this program can be different </code>
<code class="comments">// in different runs. 
Note that the program </code>
<code class="comments">// prints address of a variable and a variable </code>
<code class="comments">// can be assigned different address in different </code>
<code class="comments">// runs. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints address of x </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%p"</code><code class="plain">, &x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</li>
<li> One more operator is <strong>unary *</strong> (Asterisk) which is used for two things :
<ul>
<li>  To declare a pointer variable: When a pointer variable is declared in C/C++, there must a * before its name.
<code class="comments">// C program to demonstrate declaration of </code>
<code class="comments">// pointer variables. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 1) Since there is * in declaration, ptr </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// becomes a pointer varaible (a variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// that stores address of another variable) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// 2) Since there is int before *, ptr is </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pointer to an integer type variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// & operator before x is used to get address </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// of x. 
The address of x is assigned to ptr. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
</li>

<li>To access the value stored in the address we use the unary operator (*) that returns the value of the variable located at the address specified by its operand.
<code class="comments">// C program to demonstrate use of * for pointers in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// A normal integer variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">Var = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// A pointer variable that holds address of var. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = &Var; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This line prints value at address stored in ptr. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Value stored is value of variable "var" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of Var = %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The output of this line may be different in different </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// runs even on same machine. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Address of Var = %p\n"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// We can also use ptr as lvalue (Left hand </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// side of assignment) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 20; </code><code class="comments">// Value at address is now 20 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This prints 20 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"After doing *ptr = 20, *ptr is %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>Value of Var = 10
Address of Var = 0x7fffa057dd4
After doing *ptr = 20, *ptr is 20
</pre>
Below is pictorial representation of above program:<br />
<a href="https://media.geeksforgeeks.org/wp-content/uploads/pointers-in-c.png"><img src="https://media.geeksforgeeks.org/wp-content/uploads/pointers-in-c.png" alt="pointers in c" class="aligncenter size-full wp-image-148135" /></a>
</li>
</ul>
</li>
</ul>
&nbsp;
<strong>Pointer Expressions and Pointer Arithmetic</strong><br />
A limited set of arithmetic operations can be performed on pointers. 
A pointer may be:
<ul>
<li>incremented ( ++ )</li>
<li>decremented ( &#8212; ) </li>
<li>an integer may be added to a pointer ( + or += )</li>
<li>an integer may be subtracted from a pointer ( &#8211; or -= )</li>
</ul>
Pointer arithmetic is meaningless unless performed on an array.<br />
Note : Pointers contain addresses. 
Adding two addresses makes no sense, because there is no idea what it would point to. 
Subtracting two addresses lets you compute the offset between these two addresses.
<code class="comments">// C++ program to illustrate Pointer Arithmetic </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare an array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">v[3] = {10, 100, 200}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare pointer variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assign the address of v[0] to ptr </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = v; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of *ptr = %d\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of ptr = %p\n\n"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Increment pointer ptr by 1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<pre>
Output:Value of *ptr = 10
Value of ptr = 0x7ffcae30c710
Value of *ptr = 100
Value of ptr = 0x7ffcae30c714
Value of *ptr = 200
Value of ptr = 0x7ffcae30c718
</pre>
<a href="https://media.geeksforgeeks.org/wp-content/uploads/Untitled-presentation-31.png"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Untitled-presentation-31.png" alt="Untitled presentation (3)"></a>
&nbsp;
<strong>Array Name as Pointers </strong><br />
An array name acts like a pointer constant. 
The value of this pointer constant is the address of the first element.<br />
For example, if we have an array named val then <strong>val</strong> and <strong>&amp;val[0]</strong> can be used interchangeably. 
<code class="comments">// C++ program to illustrate Array Name as Pointers in C++ </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">geeks() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare an array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">val[3] = { 5, 10, 15}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare pointer variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assign address of val[0] to ptr. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// We can use ptr=&val[0];(both are same) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = val ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Elements of the array are: "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; ptr[0] &lt;&lt; </code><code class="string">" "</code> <code class="plain">&lt;&lt; ptr[1] &lt;&lt; </code><code class="string">" "</code> <code class="plain">&lt;&lt; ptr[2]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">geeks(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Output:
Elements of the array are: 5 10 15
</pre>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/PointersInC.png" alt="Untitled presentation (2)" class="aligncenter size-full wp-image-148224" /><br />
Now if this ptr is sent to a function as an argument then the array val can be accessed in a similar fashion. 
&nbsp;
<strong>Pointers and Multidimensional Arrays</strong><br />
Consider pointer notation for the two-dimensional numeric arrays. 
consider the following declaration
<pre>int nums[2][3]  =  { {16, 18, 20}, {25, 26, 27} };</pre>
<strong> In general, nums[i][j] is equivalent to *(*(nums+i)+j)</strong>
<table width="100%">
<thead>
<tr>
<th style="padding:8px;background-color:#4CB96B;text-align:center">Pointer Notation</th>
<th style="padding:8px;background-color:#4CB96B;text-align:center">Array Notation</th>
<th style="padding:8px;background-color:#4CB96B;text-align:center">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">*(*nums)</td>
<td style="text-align:center">nums[0][0]</td>
<td style="text-align:center">16</td>
</tr>
<tr>
<td>*(*nums + 1)</td>
<td>nums[0][1]</td>
<td>18</td>
</tr>
<tr>
<td style="text-align:center">*(*nums + 2)</td>
<td style="text-align:center">nums[0][2]</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td>*(*(nums + 1))</td>
<td>nums[1][0]</td>
<td>25</td>
</tr>
<tr>
<td style="text-align:center">*(*(nums + 1) + 1)</td>
<td style="text-align:center">nums[1][1]</td>
<td style="text-align:center">26</td>
</tr>
<tr>
<td>*(*(nums + 1) + 2)</td>
<td>nums[1][2]</td>
<td>27</td>
</tr>
</tbody>
</table>
<strong>Related Articles</strong>: 
<ul>
<li>
<a href="https://www.geeksforgeeks.org/pass-2d-array-parameter-c/">How to pass a 2D array as a parameter in C?</a></li>
<li><a href="https://www.geeksforgeeks.org/multidimensional-pointer-arithmetic-in-cc/">Multidimensional Pointer Arithmetic in C/C++</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-pointer-array-c/">Pointer vs Array</a></li>
<li><a href="https://www.geeksforgeeks.org/why-c-treats-array-parameters-as-pointers/">Why C treats array parameters as pointers?</a></li>
<li><a href="http://quiz.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/">What’s difference between “array” and “&amp;array” for “int array[5]”?</a></li>
</ul>
<strong><br />
<a href="https://www.geeksforgeeks.org/applications-of-pointers-in-c-cpp/">Applications of pointers in C/C++.</a></strong>
&nbsp;
<strong>Quizzes</strong> &#8211; <a href="http://quiz.geeksforgeeks.org/c-language-2/pointers/">Quiz on Pointer Basics</a> , <a href="http://quiz.geeksforgeeks.org/c-language-2/advanced-pointer-c/">Quiz on Advanced Pointer</a>
<strong>Reference: </strong><br />
<a href="https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html">https://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_PointerReference.html</a>
<h2>Double Pointer (Pointer to Pointer) in C</h2>
Prerequisite : <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">Pointers in C and C++ </a>
We already know that a pointer points to a location in memory and thus used to store the address of variables. 
So, when we define a pointer to pointer. 
The first pointer is used to store the address of the variable. 
And the second pointer is used to store the address of the first pointer. 
That is why they are also known as double pointers.
<strong>How to declare a pointer to pointer in C?</strong><br />
Declaring Pointer to Pointer is similar to declaring pointer in C. 
The difference is we have to place an additional &#8216;*&#8217; before the name of pointer.<br />
<strong>Syntax</strong>:
<pre>
int **ptr;    // declaring double pointers
</pre>
Below diagram explains the concept of Double Pointers:
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Double-Pointer-in-C.png" alt="">
The above diagram shows the memory representation of a pointer to pointer. 
The first pointer ptr1 stores the address of the variable and the second pointer ptr2 stores the address of the first pointer.
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/How-Pointer-Works-In-C.png" alt="">
Let us understand this more clearly with the help of the below program:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// C program to demonstrate pointer to pointer </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">var = 789; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pointer for var </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// double pointer for ptr2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">**ptr1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// storing address of var in ptr2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr2 = &var; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Storing address of ptr2 in ptr1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr1 = &ptr2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Displaying value of var using </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// both single and double pointers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of var = %d\n"</code><code class="plain">, var ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of var using single pointer = %d\n"</code><code class="plain">, *ptr2 ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of var using double pointer = %d\n"</code><code class="plain">, **ptr1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output:
<pre>
Value of var = 789
Value of var using single pointer = 789
Value of var using double pointer = 789
</pre>
<strong>Related Post : </strong><br />
<a href="https://www.geeksforgeeks.org/function-pointer-in-c/">Function Pointer in C</a>
<h2>Why C treats array parameters as pointers?</h2>
In C, array parameters are treated as pointers. 
The following two definitions of foo() look different, but to the compiler they mean exactly the same thing. 
<!--more--> It&#8217;s preferable to use whichever syntax is more accurate for readability. 
If the pointer coming in really is the base address of a whole array, then we should use [ ].
<code class="keyword bold">void</code> <code class="plain">foo(</code><code class="color1 bold">int</code> <code class="plain">arr_param[])&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Silly but valid. 
Just changes the local pointer */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">arr_param = NULL;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">foo(</code><code class="color1 bold">int</code> <code class="plain">*arr_param)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* ditto */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">arr_param = NULL;&nbsp; </code>
<code class="plain">} </code>
<strong>Array parameters treated as pointers because of efficiency</strong>. 
It is inefficient to copy the array data in terms of both memory and time; and most of the times, when we pass an array our intention is to just tell the array we interested in, not to create a copy of the array.
Asked by Shobhit
<h2>Output of the program | Dereference, Reference, Dereference, Reference&#8230;.</h2>
Predict the output of below program<br />
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c\n"</code><code class="plain">, *&*&*ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: g
Explanation:  The operator * is used for dereferencing and the operator &amp; is used to get the address. 
These operators cancel effect of each other when used one after another. 
We can apply them alternatively any no. 
of times. 
For example *ptr gives us g,  &amp;*ptr gives address of g, *&amp;*ptr again g, &amp;*&amp;*ptr address of g, and finally *&amp;*&amp;*ptr gives ‘g’
Now try below
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr = </code><code class="string">"geeksforgeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, *&*&ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Dangling, Void , Null and Wild Pointers</h2>
 
<p align="center"><strong> <strong>Dangling pointer</strong></strong>
A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer. 
There are <strong>three</strong> different ways where Pointer acts as dangling pointer
<ol>
<li><strong>De-allocation of memory</strong>
<code class="comments">// Deallocating a memory pointed by ptr causes </code>
<code class="comments">// dangling pointer </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// After below free call, ptr becomes a&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// dangling pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(ptr);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// No more a dangling pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = NULL; </code>
<code class="plain">} </code>
</li>
<li><strong>Function Call</strong>
<code class="comments">// The pointer pointing to local variable becomes </code>
<code class="comments">// dangling when local variable is not static. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">*fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// x is local variable and goes out of </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// scope after an execution of fun() is </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// over. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">&x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = fun(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fflush</code><code class="plain">(stdin); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// p points to something which is not </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// valid anymore </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
A garbage Address
</pre>
The above problem doesn&#8217;t appear (or p doesn&#8217;t become dangling) if x is a static variable.
<code class="comments">// The pointer pointing to local variable doesn't </code>
<code class="comments">// become dangling when local variable is static. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">*fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// x now has scope throughout the program </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">x = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">&x; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = fun(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fflush</code><code class="plain">(stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Not a dangling pointer as it points </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to static variable. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,*p); </code>
<code class="plain">} </code>
Output: 
<pre> 5</pre>
</li>
<li><strong>Variable goes out of scope </strong>
<pre>
void main()
{
   int *ptr;
   .....
   .....
   {
       int ch;
       ptr = &amp;ch;
   } 
   ..... 
 
   // Here ptr is dangling pointer
}
</pre></li></ol>
 
<p align="center"> <strong><a href="http://quiz.geeksforgeeks.org/void-pointer-c/">Void pointer</a></strong> 
Void pointer is a specific pointer type &#8211; void * &#8211; a pointer that points to some data location in storage, which doesn&#8217;t have any specific type. 
Void refers to the type. 
Basically the type of data that it points to is can be any. 
If we assign address of char data type to void pointer it will become char Pointer, if int data type then int pointer and so on. 
Any pointer type is convertible to a void pointer hence it can point to any value.<br />
<strong>Important Points</strong>
<ol>
<li>void pointers <strong>cannot be dereferenced</strong>. 
It can however be done using typecasting the void pointer</li>
<li>Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size.</li>
</ol>
<strong>Example:</strong>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">y = 5.5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//A void pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">*ptr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (int*)ptr - does type casting of void&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// *((int*)ptr) dereferences the typecasted&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// void pointer variable. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integer variable is = %d"</code><code class="plain">, *( (</code><code class="color1 bold">int</code><code class="plain">*) ptr) ); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// void pointer is now float </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &y;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nFloat variable is= %f"</code><code class="plain">, *( (</code><code class="color1 bold">float</code><code class="plain">*) ptr) ); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Integer variable is = 4
Float variable is= 5.500000</pre>
Refer <a href="http://quiz.geeksforgeeks.org/void-pointer-c/">void pointer article</a> for details.
 
          
<p align="center"><strong><a href="http://quiz.geeksforgeeks.org/few-bytes-on-null-pointer-in-c/">NULL Pointer</a></strong>
NULL Pointer is a pointer which is pointing to nothing. 
In case, if we don’t have address to be assigned to a pointer, then we can simply use NULL.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Null Pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = NULL; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The value of ptr is %p"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>
The value of ptr is (nil)
</pre>
<strong>Important Points</strong>
<ol>
<li><strong> NULL vs Uninitialized pointer &#8211; </strong> An uninitialized pointer stores an undefined value. 
A null pointer stores a defined value, but one that is defined by the environment to not be a valid address for any member or object.</li>
<li><strong>NULL vs Void Pointer</strong> &#8211; Null pointer is a value, while void pointer is a type</li>
</ol>
 
<p align="center"><strong><a href="https://www.geeksforgeeks.org/what-are-wild-pointers-how-can-we-avoid/">Wild pointer</a></strong>
A pointer which has not been initialized to anything (not even NULL) is known as wild pointer. 
The pointer may be initialized to a non-NULL garbage value that may not be a valid address.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p;&nbsp; </code><code class="comments">/* wild pointer */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// p is not a wild pointer now </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">p = &x; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>An Uncommon representation of array elements</h2>
Consider the below program. 
<!--more-->
<code class="color1 bold">int</code> <code class="plain">main( ) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2] = {0,1}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"First Element = %d\n"</code><code class="plain">,arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Pretty Simple program.. 
huh&#8230; Output will be 0.
Now if you replace <em>arr[0] </em>with <em>0[arr]</em>, the output would be same. 
Because compiler converts the array operation in pointers before accessing the array elements.
e.g. 
<em>arr[0]</em> would be <em>*(arr + 0) </em>and therefore 0[arr] would be <em>*(0 + arr)</em> and you know that both <em>*(arr + 0)</em> and <em>*(0 + arr) </em>are same.
<h2>How to declare a pointer to a function?</h2>
Well, we assume that you know what does it mean by pointer in C. 
So how do we create a pointer to an integer in C?<br />
Huh..it is pretty simple..<!--more-->
<pre>
int * ptrInteger; /*We have put a * operator between int 
                    and ptrInteger to create a pointer.*/
</pre>
Here ptrInteger is a pointer to integer. 
If you understand this, then logically we should not have any problem in declaring a  pointer to a function 🙂
So let us first see ..how do we declare a function? For example,
<pre>
int foo(int);
</pre>
Here foo is a function that returns int and takes one argument of int type. 
So as a logical guy will think, by putting a * operator between int and foo(int) should create a pointer to a function i.e.
<pre>
int * foo(int);
</pre>
But Oops..C operator precedence also plays role here ..so in this case, operator () will take priority over operator *. 
And the above declaration will mean &#8211; a function foo with one argument of int type and return value of int * i.e. 
integer pointer. 
So it did something that we didn&#8217;t want to do. 
🙁
So as a next logical step, we have to bind operator * with foo somehow. 
And for this, we would change the default precedence of C operators using () operator.
<pre>
int (*foo)(int);
</pre>
That&#8217;s it. 
Here * operator is with foo which is a function name. 
And it did the same that we wanted to do.
So that wasn&#8217;t as difficult as we thought earlier! 
<h2>Pointer vs Array in C</h2>
Most of the time, pointer and array accesses can be treated as acting the same, the major exceptions being:
1) the sizeof operator<br />
o sizeof(array) returns the amount of memory used by all elements in array<br />
o sizeof(pointer) only returns the amount of memory used by the pointer variable itself
2) the &amp; operator<br />
o &amp;array is an alias for &amp;array[0] and returns the address of the first element in array<br />
o &amp;pointer returns the address of pointer
3) a string literal initialization of a character array<br />
o char array[] = &#8220;abc&#8221; sets the first four elements in array to &#8216;a&#8217;, &#8216;b&#8217;, &#8216;c&#8217;, and &#8216;\0&#8217;<br />
o char *pointer = &#8220;abc&#8221; sets pointer to the address of the &#8220;abc&#8221; string (which may be stored in read-only memory and thus unchangeable)
4) Pointer variable can be assigned a value whereas array variable cannot be.
<pre>
int a[10];
int *p; 
p=a; /*legal*/
a=p; /*illegal*/ </pre>
5) Arithmetic on pointer variable is allowed. 
<pre>
p++; /*Legal*/
a++; /*illegal*/ </pre>
<strong><br />
Please refer <a href="https://www.geeksforgeeks.org/difference-pointer-array-c/"> Difference between pointer and array in C?</a> for more details.</strong>
<h2>void pointer in C / C++</h2>
A void pointer is a pointer that has no associated data type with it. 
A void pointer can hold address of any type and can be typcasted to any type.<!--more-->
<code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="color1 bold">char</code> <code class="plain">b = </code><code class="string">'x'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">*p = &a;&nbsp; </code><code class="comments">// void pointer holds address of int 'a' </code>
<code class="plain">p = &b; </code><code class="comments">// void pointer holds address of char 'b' </code>
<strong>Advantages of void pointers:</strong><br />
<strong>1) </strong>malloc() and calloc() return void * type and this allows these functions to be used to allocate memory of any data type (just because of void *) 
<i id="run-and-edit-button" title="Edit Code" lang="plain"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="plain" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="plain"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="plain" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">int main(void) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">// Note that malloc() returns void * which can be&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">// typecasted to any type like int *, char *, .. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">int *x = malloc(sizeof(int) * n); </code>
<code class="plain">} </code>
Note that the above program compiles in C, but doesn&#8217;t compile in C++. 
In C++, we must explicitly typecast return value of malloc to (int *).
<strong>2)</strong> void pointers in C are used to implement generic functions in C. 
For example <a href="https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/">compare function which is used in qsort()</a>. 
<strong>Some Interesting Facts:</strong><br />
<strong>1)</strong>  void pointers cannot be dereferenced. 
For example the following program doesn&#8217;t compile.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">*ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Compiler Error: 'void*' is not a pointer-to-object type </pre>
The following program compiles and runs fine.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">*ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *(</code><code class="color1 bold">int</code> <code class="plain">*)ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>10</pre>
<strong>2) </strong> The <a href="https://www.geeksforgeeks.org/c-programming-language-standard/">C standard</a> doesn&#8217;t allow pointer arithmetic with void pointers. 
However,  in GNU C it is allowed  by considering the size of void is 1. 
For example the following program compiles and runs fine in gcc.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a[2] = {1, 2}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">*ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = ptr + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, *(</code><code class="color1 bold">int</code> <code class="plain">*)ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>2</pre>
Note that the above program may not work in other compilers.
<h2>NULL pointer in C</h2>
<p style="text-align: justify">At the very high level, we can think of NULL as a null pointer which is used in C for various purposes. 
Some of the most common use cases for NULL are<br />
a) To initialize a pointer variable when that pointer variable isn’t assigned any valid memory address yet.<br />
b) To check for a null pointer before accessing any pointer variable. 
By doing so, we can perform error handling in pointer related code e.g. 
dereference pointer variable only if it’s not NULL.<br />
c) To pass a null pointer to a function argument when we don’t want to pass any valid memory address.
<p style="text-align: justify">The example of a is
<code class="color1 bold">int</code> <code class="plain">* pInt = NULL; </code>
<p style="text-align: justify">The example of b is
<code class="keyword bold">if</code><code class="plain">(pInt != NULL) </code><code class="comments">/*We could use if(pInt) as well*/</code>
<code class="plain">{ </code><code class="comments">/*Some code*/</code><code class="plain">} </code>
<code class="keyword bold">else</code>
<code class="plain">{ </code><code class="comments">/*Some code*/</code><code class="plain">} </code>
<p style="text-align: justify">The example of c is
<code class="color1 bold">int</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">*ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="comments">/*Fun specific stuff is done with ptr here*/</code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">10; </code>
<code class="plain">} </code>
<code class="plain">fun(NULL); </code>
<p style="text-align: justify">It should be noted that NULL pointer is different from an uninitialized and dangling pointer. 
In a specific program context, all uninitialized or dangling or NULL pointers are invalid but NULL is a specific invalid pointer which is mentioned in C standard and has specific purposes. 
What we mean is that uninitialized and dangling pointers are invalid but they can point to some memory address that may be accessible through the memory access is unintended.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*i, *j; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ii = NULL, *jj = NULL; </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">if</code><code class="plain">(i == j) </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"This might get printed if both i and j are same by chance."</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">if</code><code class="plain">(ii == jj) </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"This is always printed coz ii and jj are same."</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">By specifically mentioning NULL pointer, C standard gives mechanism using which a C programmer can use and check whether a given pointer is legitimate or not. But what exactly is NULL and how it’s defined? Strictly speaking, NULL expands to an implementation-defined null pointer constant which is defined in many header files such as “<em>stdio.h</em>”, “<em>stddef.h</em>”, “<em>stdlib.h</em>” etc. 
Let us see what C standards say about null pointer. 
From C11 standard clause 6.3.2.3,
<p style="text-align: justify">“<em>An integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. 
If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.</em>”
<p style="text-align: justify">Before we proceed further on this NULL discussion :), let’s mention few lines about C standard just in case you wants to refer it for further study. 
Please note that ISO/IEC 9899:2011 is the C language&#8217;s latest standard which was published in Dec 2011. 
This is also called the C11 standard. 
For completeness, let us mention that previous standards for C were C99, C90 (also known as ISO C) and C89 (also known as ANSI C). 
Though the actual C11 standard can be purchased from ISO, there’s a draft document which is available in public domain for free.
<p style="text-align: justify">Coming to our discussion, NULL macro is defined as <em>((void *)0)</em> in header files of most of the C compiler implementations. 
But C standard is saying that 0 is also a null pointer constant. 
It means that the following is also perfectly legal as per standard.
<code class="color1 bold">int</code> <code class="plain">* ptr = 0; </code>
<p style="text-align: justify">Please note that 0 in the above C statement is used in pointer-context and it’s different from 0 as integer. 
This is one of the reasons why the usage of NULL is preferred because it makes it explicit in code that programmer is using null pointer, not integer 0. 
Another important concept about NULL is that “<em>NULL expands to an implementation-defined null pointer constant</em>”. 
This statement is also from C11 clause 7.19. 
It means that internal representation of the null pointer could be non-zero bit pattern to convey NULL pointer. 
That’s why NULL always needn’t be internally represented as all zeros bit pattern. 
A compiler implementation can choose to represent “null pointer constant” as a bit pattern for all 1s or anything else. 
But again, as a C programmer, we needn’t worry much on the internal value of the null pointer unless we are involved in Compiler coding or even below the level of coding. 
Having said so, typically NULL is represented as all bits set to 0 only. 
To know this on a specific platform, one can use the following
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,NULL); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">Most likely, it’s printing 0 which is the typical internal null pointer value but again it can vary depending on the C compiler/platform. 
You can try few other things in above program such as <em>printf(“‘%c“,NULL)</em> or <em>printf(“%s”,NULL)</em> and even <em>printf(“%f”,NULL)</em>. 
The outputs of these are going to be different depending on the platform used but it’d be interesting especially usage of <em>%f</em> with NULL!
<p style="text-align: justify">Can we use <em>sizeof()</em> operator on NULL in C? Well, usage of <em>sizeof(NULL)</em> is allowed but the exact size would depend on platform.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(NULL)); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">Since NULL is defined as <em>((void*)0)</em>, we can think of NULL as a special pointer and its size would be equal to any pointer. 
If the pointer size of a platform is 4 bytes, the output of the above program would be 4. 
But if pointer size on a platform is 8 bytes, the output of the above program would be 8.
          
<p style="text-align: justify">What about dereferencing of NULL? What’s going to happen if we use the following C code
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">* ptr = NULL; </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,*ptr); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">On some machines, the above would compile successfully but crashes when the program is run through it needn&#8217;t show the same behaviour across all the machines. 
Again it depends on a lot of factors. 
But the idea of mentioning the above snippet is that we should always check for NULL before accessing it.
<p style="text-align: justify">Since NULL is typically defined as <em>((void*)0)</em>, let us discuss a little bit about <em>void</em> type as well. 
As per C11 standard clause 6.2.5, “<em>The void type comprises an empty set of values; it is an incomplete object type that cannot be completed</em>”. Even C11 clause 6.5.3.4 mentions that “<em>The sizeof operator shall not be applied to an expression that has function type or an incomplete type, to the parenthesized name of such a type, or to an expression that designates a bit-field member.</em>” Basically, it means that <em>void</em> is an incomplete type whose size doesn’t make any sense in C programs but implementations (such as gcc) can choose <em>sizeof(void)</em> as 1 so that the flat memory pointed by void pointer can be viewed as untyped memory i.e. 
a sequence of bytes. 
But the output of the following needn’t to same on all platforms.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">void</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">On gcc, the above would output 1. 
What about <em>sizeof(void *)</em>? Here C11 has mentioned guidelines. 
From clause 6.2.5, “<em>A pointer to void shall have the same representation and alignment requirements as a pointer to a character type</em>”. 
That’s why the output of the following would be same as any pointer size on a machine.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">,</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*)); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<p style="text-align: justify">Inspite of mentioning machine dependent stuff as above, we as C programmers should always strive to make our code as portable as possible. 
So we can conclude on NULL as follows:
<p style="text-align: justify">1. 
Always initialize pointer variables as NULL.<br />
2. 
Always perform a NULL check before accessing any pointer.
<p style="text-align: justify">Please do Like/Tweet/G+1 if you find the above useful. 
Also, please do leave us to comment for further clarification or info. 
We would love to help and learn 🙂
<h2>Function Pointer in C</h2>
In C, like <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">normal data pointers </a>(int *, char *, etc), we can have pointers to functions. 
Following is a simple example that shows declaration and function call using function pointer.<!--more-->
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="comments">// A normal function with an int parameter </code>
<code class="comments">// and void return type </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">a) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of a is %d\n"</code><code class="plain">, a); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// fun_ptr is a pointer to function fun()&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">(*fun_ptr)(</code><code class="color1 bold">int</code><code class="plain">) = &fun; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* The above line is equivalent of following two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">void (*fun_ptr)(int); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">fun_ptr = &fun;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Invoking fun() using fun_ptr </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(*fun_ptr)(10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Value of a is 10</pre>
Why do we need an extra bracket around function pointers like fun_ptr in above example?<br />
If we remove bracket, then the expression &#8220;void (*fun_ptr)(int)&#8221; becomes &#8220;void *fun_ptr(int)&#8221; which is declaration of a function that returns void pointer. 
See following post for details.<br />
<a href="https://www.geeksforgeeks.org/how-to-declare-a-pointer-to-a-function/">How to declare a pointer to a function?</a>
<strong>Following are some interesting facts about function pointers.</strong>
&nbsp;<br />
<strong>1)</strong> Unlike normal pointers, a function pointer points to code, not data. 
Typically a function pointer stores the start of executable code.

<strong>2) </strong>Unlike normal pointers, we do not allocate de-allocate memory using function pointers.
&nbsp;<br />
<strong>3)</strong> A function&#8217;s name can also be used to get functions&#8217; address. 
For example, in the below program, we have removed address operator &#8216;&#038;&#8217; in assignment. 
We have also changed function call by removing *, the program still works.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="comments">// A normal function with an int parameter </code>
<code class="comments">// and void return type </code>
<code class="keyword bold">void</code> <code class="plain">fun(</code><code class="color1 bold">int</code> <code class="plain">a) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of a is %d\n"</code><code class="plain">, a); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">(*fun_ptr)(</code><code class="color1 bold">int</code><code class="plain">) = fun;&nbsp; </code><code class="comments">// & removed </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun_ptr(10);&nbsp; </code><code class="comments">// * removed </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>Value of a is 10</pre>
&nbsp;<br />
<strong>4)</strong> Like normal pointers, we can have an array of function pointers. 
Below example in point 5 shows syntax for array of pointers.
&nbsp;<br />
<strong>5)</strong> Function pointer can be used in place of switch case. 
For example, in below program, user is asked for a choice between 0 and 2 to do different tasks.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">add(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Addition is %d\n"</code><code class="plain">, a+b); </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">subtract(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Subtraction is %d\n"</code><code class="plain">, a-b); </code>
<code class="plain">} </code>
<code class="keyword bold">void</code> <code class="plain">multiply(</code><code class="color1 bold">int</code> <code class="plain">a, </code><code class="color1 bold">int</code> <code class="plain">b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Multiplication is %d\n"</code><code class="plain">, a*b); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// fun_ptr_arr is an array of function pointers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">(*fun_ptr_arr[])(</code><code class="color1 bold">int</code><code class="plain">, </code><code class="color1 bold">int</code><code class="plain">) = {add, subtract, multiply}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">ch, a = 15, b = 10; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter Choice: 0 for add, 1 for subtract and 2 "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"for multiply\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &ch); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ch > 2) </code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(*fun_ptr_arr[ch])(a, b); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Enter Choice: 0 for add, 1 for subtract and 2 for multiply
2
Multiplication is 150 </pre>
&nbsp;<br />
<strong>6) </strong>Like normal data pointers, a function pointer can be passed as an argument and can also be returned from a function.<br />
For example, consider the following C program where wrapper() receives a void fun() as parameter and calls the passed function.
<code class="comments">// A simple C program to show function pointers as parameter </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Two simple functions </code>
<code class="keyword bold">void</code> <code class="plain">fun1() { </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Fun1\n"</code><code class="plain">); } </code>
<code class="keyword bold">void</code> <code class="plain">fun2() { </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Fun2\n"</code><code class="plain">); } </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function that receives a simple function </code>
<code class="comments">// as parameter and calls the function </code>
<code class="keyword bold">void</code> <code class="plain">wrapper(</code><code class="keyword bold">void</code> <code class="plain">(*fun)()) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wrapper(fun1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wrapper(fun2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
This point in particular is very useful in C. 
 In C, we can use function pointers to avoid code redundancy. 
For example a simple <a href="http://www.cplusplus.com/reference/cstdlib/qsort/">qsort()</a> function can be used to sort arrays in ascending order or descending or by any other order in case of array of structures. 
Not only this, with function pointers and void pointers, it is possible to use qsort for any data type. 
<code class="comments">// An example for qsort and comparator </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A sample comparator function that is used </code>
<code class="comments">// for sorting an integer array in ascending order. 
</code>
<code class="comments">// To sort any array for any other data type and/or </code>
<code class="comments">// criteria, all we need to do is write more compare </code>
<code class="comments">// functions.&nbsp; And we can use the same qsort() </code>
<code class="color1 bold">int</code> <code class="plain">compare (</code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">* a, </code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">* b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">( *(</code><code class="color1 bold">int</code><code class="plain">*)a - *(</code><code class="color1 bold">int</code><code class="plain">*)b ); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 5, 15, 12, 90, 80}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="keyword bold">sizeof</code><code class="plain">(arr)/</code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]), i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">qsort</code> <code class="plain">(arr, n, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">), compare); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>5 10 12 15 80 90</pre>
Similar to qsort(), we can write our own functions that can be used for any data type and can do different tasks without code redundancy. 
Below is an example search function that can be used for any data type. 
In fact we can use this search function to find close elements (below a threshold) by writing a customized compare function.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdbool.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A compare function that is used for searching an integer </code>
<code class="comments">// array </code>
<code class="color1 bold">bool</code> <code class="plain">compare (</code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">* a, </code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">* b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">( *(</code><code class="color1 bold">int</code><code class="plain">*)a == *(</code><code class="color1 bold">int</code><code class="plain">*)b ); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// General purpose search() function that can be used </code>
<code class="comments">// for searching an element *x in an array arr[] of </code>
<code class="comments">// arr_size. 
Note that void pointers are used so that </code>
<code class="comments">// the function can be called by passing a pointer of </code>
<code class="comments">// any type.&nbsp; ele_size is size of an array element </code>
<code class="color1 bold">int</code> <code class="plain">search(</code><code class="keyword bold">void</code> <code class="plain">*arr, </code><code class="color1 bold">int</code> <code class="plain">arr_size, </code><code class="color1 bold">int</code> <code class="plain">ele_size, </code><code class="keyword bold">void</code> <code class="plain">*x, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">compare (</code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">* , </code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">*)) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Since char takes one byte, we can use char pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for any type/ To get pointer arithmetic correct, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// we need to multiply index with size of an array </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// element ele_size </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr = (</code><code class="color1 bold">char</code> <code class="plain">*)arr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;arr_size; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(compare(ptr + i*ele_size, x)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If element not found </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">-1; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {2, 5, 7, 90, 70}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="keyword bold">sizeof</code><code class="plain">(arr)/</code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 7; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Returned index is %d "</code><code class="plain">, search(arr, n, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">), &x, compare)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Returned index is 2</pre>
The above search function can be used for any data type by writing a separate customized compare(). 
&nbsp;<br />
<strong>7)</strong> Many object oriented features in C++ are implemented using function pointers in C. 
For example <a href="https://www.geeksforgeeks.org/virtual-functions-and-runtime-polymorphism-in-c-set-1-introduction/">virtual functions</a>. 
 Class methods are another example implemented using function pointers. 
Refer <a href="http://www.cs.rit.edu/~ats/books/ooc.pdf">this book</a> for more details.
<strong>Related Article:</strong><a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">Pointers in C and C++ | Set 1 (Introduction, Arithmetic and Array)</a>
<h2>What are near, far and huge pointers?</h2>
These are some old concepts used in 16 bit intel architectures in the days of MS DOS, not much useful anymore. 
<!--more-->
<strong>Near pointer</strong> is used to store 16 bit addresses means within current segment on a 16 bit machine. 
The limitation is that we can only access 64kb of data at a time.
<strong>A far pointer</strong> is typically 32 bit that can access memory outside current segment.  To use this, compiler allocates a segment register to store segment address, then another register to store offset within current segment.
Like far pointer, <strong>huge pointer</strong> is also typically 32 bit and can access outside segment. 
In case of far pointers, a segment is fixed. In far pointer, the segment part cannot be modified, but in Huge it can be
See below links for more details.
<a href="http://www.answers.com/Q/What_are_near_far_and_huge_pointers_in_C" rel="nofollow">http://www.answers.com/Q/What_are_near_far_and_huge_pointers_in_C</a>
<a href="https://www.quora.com/What-is-the-difference-between-near-far-huge-pointers-in-C-C++" rel="nofollow">https://www.quora.com/What-is-the-difference-between-near-far-huge-pointers-in-C-C++</a>
<a href="http://stackoverflow.com/questions/8727122/explain-the-difference-between-near-far-and-huge-pointers-in-c" rel="nofollow">http://stackoverflow.com/questions/8727122/explain-the-difference-between-near-far-and-huge-pointers-in-c</a>
<h2>Generic Linked List in C</h2>
Unlike <a href="https://www.geeksforgeeks.org/c-plus-plus/">C++</a> and <a href="https://www.geeksforgeeks.org/java/">Java</a>, <a href="https://www.geeksforgeeks.org/c/">C</a> doesn&#8217;t support generics. 
How to create a linked list in C that can be used for any data type? In C, we can use <a href="http://geeksquiz.com/void-pointer-c/">void pointer</a> and function pointer to implement the same functionality. 
<!--more--> The great thing about void pointer is it can be used to point to any data type. 
Also, size of all types of pointers is always is same, so we can always allocate a linked list node. 
Function pointer is needed process actual content stored at address pointed by void pointer. 
Following is a sample C code to demonstrate working of generic linked list.
<code class="comments">// C program for generic linked list </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* A linked list node */</code>
<code class="keyword bold">struct</code> <code class="plain">Node </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Any data type can be stored in this node </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code>&nbsp; <code class="plain">*data; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Node *next; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Function to add a node at the beginning of Linked List. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">This function expects a pointer to the data to be added </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">and size of the data type */</code>
<code class="keyword bold">void</code> <code class="plain">push(</code><code class="keyword bold">struct</code> <code class="plain">Node** head_ref, </code><code class="keyword bold">void</code> <code class="plain">*new_data, </code><code class="color1 bold">size_t</code> <code class="plain">data_size) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Allocate memory for node </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Node* new_node = (</code><code class="keyword bold">struct</code> <code class="plain">Node*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">Node)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">new_node->data&nbsp; = </code><code class="functions bold">malloc</code><code class="plain">(data_size); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">new_node->next = (*head_ref); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy contents of new_data to newly allocated memory. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assumption: char takes 1 byte. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;data_size; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*(</code><code class="color1 bold">char</code> <code class="plain">*)(new_node->data + i) = *(</code><code class="color1 bold">char</code> <code class="plain">*)(new_data + i); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Change head pointer as new node is added at the beginning </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(*head_ref)&nbsp;&nbsp;&nbsp; = new_node; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Function to print nodes in a given linked list. 
fpitr is used </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">to access the function to be used for printing current node data. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">Note that different data types need different specifier in printf() */</code>
<code class="keyword bold">void</code> <code class="plain">printList(</code><code class="keyword bold">struct</code> <code class="plain">Node *node, </code><code class="keyword bold">void</code> <code class="plain">(*fptr)(</code><code class="keyword bold">void</code> <code class="plain">*)) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(node != NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(*fptr)(node->data); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">node = node->next; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to print an integer </code>
<code class="keyword bold">void</code> <code class="plain">printInt(</code><code class="keyword bold">void</code> <code class="plain">*n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d"</code><code class="plain">, *(</code><code class="color1 bold">int</code> <code class="plain">*)n); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to print a float </code>
<code class="keyword bold">void</code> <code class="plain">printFloat(</code><code class="keyword bold">void</code> <code class="plain">*f) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %f"</code><code class="plain">, *(</code><code class="color1 bold">float</code> <code class="plain">*)f); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Driver program to test above function */</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Node *start = NULL; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Create and print an int linked list </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned int_size = </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {10, 20, 30, 40, 50}, i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=4; i>=0; i--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">push(&start, &arr[i], int_size); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Created integer linked list is \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printList(start, printInt); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Create and print a float linked list </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned float_size = </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">start = NULL; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">arr2[] = {10.1, 20.2, 30.3, 40.4, 50.5}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=4; i>=0; i--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">push(&start, &arr2[i], float_size); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n\nCreated float linked list is \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printList(start, printFloat); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Created integer linked list is
 10 20 30 40 50
Created float linked list is
 10.100000 20.200001 30.299999 40.400002 50.500000</pre>
<h2>restrict keyword in C</h2>
In the <a href="https://www.geeksforgeeks.org/c/">C programming language </a>(after 99 standard), a new keyword is introduced known as restrict.
<ul>
<li> restrict keyword is mainly used in pointer declarations as a type qualifier for pointers.</li>
<li>It doesn&#8217;t add any new functionality. 
It is only a way for programmer to inform about an optimizations that compiler can make.</li>
<li>When we use restrict with a pointer ptr, it tells the compiler that ptr is the only way to access the object pointed by it and compiler doesn&#8217;t need to add any additional checks.</li>
<li>If a programmer uses restrict keyword and violate the above condition, result is undefined behavior.</li>
<li>restrict is not supported by C++. 
It is a C only keyword.</li>
</ul>
<code class="comments">// C program to use restrict keyword. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Note that the purpose of restrict is to </code>
<code class="comments">// show only syntax. 
It doesn't change anything </code>
<code class="comments">// in output (or logic). 
It is just a way for </code>
<code class="comments">// programmer to tell compiler about an&nbsp; </code>
<code class="comments">// optimization </code>
<code class="keyword bold">void</code> <code class="plain">use(</code><code class="color1 bold">int</code><code class="plain">* a, </code><code class="color1 bold">int</code><code class="plain">* b, </code><code class="color1 bold">int</code><code class="plain">* restrict c) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*a += *c; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Since c is restrict, compiler will </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not reload value at address c in </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// its assembly code. 
Therefore generated </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// assembly code is optimized </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*b += *c;&nbsp;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 50, b = 60, c = 70; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">use(&a, &b, &c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d"</code><code class="plain">, a, b, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>120 130 70
</pre>
<h2>Difference between const char *p, char * const p and const char * const p</h2>
Prerequisite: <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">Pointers</a><br />
There is a lot of confusion when char, const, *, p are all used in different permutaions and meanings change according to which is placed where. 
Following article focus on differentiation and usage of all of these. 
The qualifier <a href="https://www.geeksforgeeks.org/const-qualifier-in-c/">const</a> can be applied to the declaration of any variable to specify that its value will not be changed. 
const keyword applies to whatever is immediately to its left. 
If there is nothing to its left, it applies to whatever is immediately to its right. 
<ol>
<li><strong>const char *ptr :</strong> This is a pointer to a constant character.<strong> You cannot change the value pointed by ptr, but you can change the pointer itself</strong>. 
&#8220;const char *&#8221; is a (non-const) pointer to a const char.</strong>
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">// char const *p </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a =</code><code class="string">'A'</code><code class="plain">, b =</code><code class="string">'B'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//*ptr = b; illegal statement (assignment of read-only location *ptr) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// ptr can be changed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"value pointed to by ptr: %c\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &b; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"value pointed to by ptr: %c\n"</code><code class="plain">, *ptr); </code>
<code class="plain">} </code>
Output:
<pre>
value pointed to by ptr:A
value pointed to by ptr:B
</pre>
<strong>NOTE:</strong> There is no difference between <strong> const char *p and  char const *p</strong> as both are pointer to a const char and position of &#8216;*'(asterik) is also same.
</li>
<li><strong>char *const ptr : </strong>This is a constant pointer to non-constant character. 
<strong>You cannot change the pointer p, but can change the value pointed by ptr.</strong>
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">// char* const p </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a =</code><code class="string">'A'</code><code class="plain">, b =</code><code class="string">'B'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Value pointed to by ptr: %c\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Address ptr is pointing to: %d\n\n"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//ptr = &b; illegal statement (assignment of read-only variable ptr) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// changing the value at the address ptr is pointing to </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = b;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Value pointed to by ptr: %c\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Address ptr is pointing to: %d\n"</code><code class="plain">, ptr); </code>
<code class="plain">} </code>
Output:
<pre>
Value pointed to by ptr: A
Address ptr is pointing to: -1443150762
Value pointed to by ptr: B
Address ptr is pointing to: -1443150762
</pre>
<strong>NOTE:</strong> Pointer always points to same address, only the value at the location is changed.
</li>
<li>
<strong>const char * const ptr : </strong>This is a constant pointer to constant character. 
<strong>You can neither change the value pointed by ptr nor the pointer ptr. 
</strong>
<code class="comments">// C program to illustrate&nbsp; </code>
<code class="comments">//const char * const ptr&nbsp; </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a =</code><code class="string">'A'</code><code class="plain">, b =</code><code class="string">'B'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*</code><code class="keyword bold">const</code> <code class="plain">ptr = &a; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Value pointed to by ptr: %c\n"</code><code class="plain">, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Address ptr is pointing to: %d\n\n"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// ptr = &b; illegal statement (assignment of read-only variable ptr) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// *ptr = b; illegal statement (assignment of read-only location *ptr) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">} </code>
Output:
<pre>
Value pointed to by ptr: A
Address ptr is pointing to: -255095482
</pre>
<strong>NOTE: char const * const ptr</strong> is same as <strong>const char *const ptr</strong>.</li></ol>
<a href="https://www.geeksforgeeks.org/c-plus-plus-gq/const-keyword-gq/">Quiz on const keyword</a>
<h2>Pointer to an Array | Array Pointer</h2>
Prerequisite: <a href="https://www.geeksforgeeks.org/pointers-in-c-and-c-set-1-introduction-arithmetic-and-array/">Pointers Introduction</a><br />
<!-- Problem Statement -->
<p align="center"><b> Pointer to Array</b>
Consider the following program:<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5] = { 1, 2, 3, 4, 5 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%p\n"</code><code class="plain">, ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
In this program, we have a pointer <i>ptr</i> that points to the 0<sup>th</sup> element of the array. 
Similarly, we can also declare a pointer that can point to whole array instead of only one element of the array. 
This pointer is useful when talking about multidimensional arrays.<br />
<b>Syntax:</b>
<pre><strong>data_type (*var_name)[size_of_array]</strong>;
</pre>
<strong>Example: </strong>
<pre>int (*ptr)[10];</pre>
Here <i>ptr</i> is pointer that can point to an array of 10 integers. 
Since subscript have higher precedence than indirection, it is necessary to enclose the indirection operator and pointer name inside parentheses. 
Here the type of ptr is &#8216;pointer to an array of 10 integers&#8217;.<br />
<strong>Note : </strong> The pointer that points to the 0<sup>th</sup> element of array and the pointer that points to the whole array are totally different. 
The following program shows this:
<code class="comments">// C program to understand difference between&nbsp; </code>
<code class="comments">// pointer to an integer and pointer to an </code>
<code class="comments">// array of integers.&nbsp; </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Pointer to an integer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Pointer to an array of 5 integers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">(*ptr)[5];&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[5]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Points to 0th element of the arr. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Points to the whole array arr. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = &arr;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"p = %p, ptr = %p\n"</code><code class="plain">, p, ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">p++;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"p = %p, ptr = %p\n"</code><code class="plain">, p, ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>p = 0x7fff4f32fd50, ptr = 0x7fff4f32fd50
p = 0x7fff4f32fd54, ptr = 0x7fff4f32fd64</pre>
<strong><i>p</i></strong>:  is pointer to 0<sup>th</sup> element of the array <i>arr</i>, while <strong><i>ptr</i></strong> is a pointer that points to the whole array <i>arr</i>. 
<ul>
<li>The base type of <i>p</i> is int while base type of <i>ptr</i> is &#8216;an array of 5 integers&#8217;.</li>
<li>We know that the pointer arithmetic is performed relative to the base size, so if we write ptr++, then the pointer <i>ptr</i> will be shifted forward by 20 bytes.</li>
</ul>
The following figure shows the pointer p and ptr. 
Darker arrow denotes pointer to an array.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram1-1.png">
On dereferencing a pointer expression we get a value pointed to by that pointer expression. 
Pointer to an array points to an array, so on dereferencing it, we should get the array, and the name of array denotes the base address. 
So whenever a pointer to an array is dereferenced, we get the base address of the array to which it points.
<code class="comments">// C program to illustrate sizes of </code>
<code class="comments">// pointer of array </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = { 3, 5, 6, 7, 9 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">(*ptr)[5] = &arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"p = %p, ptr = %p\n"</code><code class="plain">, p, ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*p = %d, *ptr = %p\n"</code><code class="plain">, *p, *ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(p) = %lu, sizeof(*p) = %lu\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(p), </code><code class="keyword bold">sizeof</code><code class="plain">(*p)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(ptr) = %lu, sizeof(*ptr) = %lu\n"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(ptr), </code><code class="keyword bold">sizeof</code><code class="plain">(*ptr)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
<!-- Your Output -->p = 0x7ffde1ee5010, ptr = 0x7ffde1ee5010
*p = 3, *ptr = 0x7ffde1ee5010
sizeof(p) = 8, sizeof(*p) = 4
sizeof(ptr) = 8, sizeof(*ptr) = 20
</pre>
<p align="center"><b>Pointer to Multidimensional Arrays</b>
<b>
          
<ol>
<li>Pointers and two dimensional Arrays:</b> In a two dimensional array, we can access each element by using two subscripts, where first subscript represents the row number and second subscript represents the column number. 
The elements of 2-D array can be accessed with the help of pointer notation also. 
Suppose arr is a 2-D array, we can access any element <i>arr[i][j]</i> of the array using the pointer expression <b>*(*(arr + i) + j)</b>. 
Now we&#8217;ll see how this expression can be derived.<br />
Let us take a two dimensional array <i>arr[3][4]</i>:
<pre>int arr[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12} };</pre>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram1-2.png">
Since memory in a computer is organized linearly it is not possible to store the 2-D array in rows and columns. 
The concept of rows and columns is only theoretical, actually, a 2-D array is stored in row-major order i.e rows are placed next to each other. 
The following figure shows how the above 2-D array will be stored in memory.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram2.png"><br />
Each row can be considered as a 1-D array, so a two-dimensional array can be considered as a collection of one-dimensional arrays that are placed one after another. 
In other words, we can say that 2-D dimensional arrays that are placed one after another. 
So here <i>arr</i> is an array of 3 elements where each element is a 1-D array of 4 integers.<br />
We know that the name of an array is a constant pointer that points to 0<sup>th</sup> 1-D array and contains address 5000. 
Since <i>arr</i> is a &#8216;pointer to an array of 4 integers&#8217;, according to pointer arithmetic the expression arr + 1 will represent the address 5016 and expression arr + 2 will represent address 5032.<br />
So we can say that <i>arr</i> points to the 0<sup>th</sup> 1-D array, <i>arr + 1</i> points to the 1<sup>st</sup> 1-D array and <i>arr + 2</i> points to the 2<sup>nd</sup> 1-D array. 
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram3.png"><br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-06-10-005619.png">
In general we can write:
<pre><strong>arr + i  Points to i<sup>th</sup> element of arr -&gt;
Points to i<sup>th</sup> 1-D array</strong></pre>
<ul>
<li>Since arr + i points to i<sup>th</sup> element of <i>arr</i>, on dereferencing it will get i<sup>th</sup> element of <i>arr</i> which is of course a 1-D array. 
Thus the expression <i>*(arr + i)</i> gives us the base address of i<sup>th</sup> 1-D array.</li>
<li>We know, the pointer expression <i>*(arr + i)</i> is equivalent to the subscript expression <i>arr[i]</i>. 
So <i>*(arr + i)</i> which is same as <i>arr[i]</i> gives us the base address of i<sup>th</sup> 1-D array.</li>
</ul>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/addresspointer.png">
<strong>In general we can write:</strong>
<pre>*(arr + i)  -  arr[i]  -  Base address of i<sup>th</sup> 1-D array -&gt; Points to 0<sup>th</sup> element of i<sup>th</sup> 1-D array</pre>
<strong>Note:</strong> Both the expressions <i>(arr + i)</i> and <i>*(arr + i)</i> are pointers, but their base type are different. 
The base type of <i>(arr + i)</i> is &#8216;an array of 4 units&#8217; while the base type of *(arr + i) or arr[i] is int.
<ul>
<li>To access an individual element of our 2-D array, we should be able to access any j<sup>th</sup> element of i<sup>th</sup> 1-D array.</li>
<li>Since the base type of <i>*(arr + i)</i> is <i>int</i> and it contains the address of 0<sup>th</sup> element of i<sup>th</sup> 1-D array, we can get the addresses of subsequent elements in the i<sup>th</sup> 1-D array by adding integer values to <i>*(arr + i)</i>.</li>
<li> For example <i>*(arr + i) + 1</i> will represent the address of 1<sup>st</sup> element of 1<sup>st</sup>element of i<sup>th</sup> 1-D array and <i>*(arr+i)+2</i> will represent the address of 2<sup>nd</sup> element of i<sup>th</sup> 1-D array.</li>
<li> Similarly *(arr + i) + j will represent the address of j<sup>th</sup> element of i<sup>th</sup> 1-D array. 
On dereferencing this expression we can get the j<sup>th</sup> element of the i<sup>th</sup> 1-D array.</li>
</ul>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/arraypointer.png"><br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/pointereg.png">
          
<code class="comments">// C program to print the values and&nbsp; </code>
<code class="comments">// address of elements of a 2-D array </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[3][4] = { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ 10, 11, 12, 13 }, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ 20, 21, 22, 23 }, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ 30, 31, 32, 33 } </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Address of %dth array = %p %p\n"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i, arr[i], *(arr + i)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; 4; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d "</code><code class="plain">, arr[i][j], *(*(arr + i) + j)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Address of 0th array = 0x7ffe50edd580 0x7ffe50edd580
10 10 11 11 12 12 13 13 
Address of 1th array = 0x7ffe50edd590 0x7ffe50edd590
20 20 21 21 22 22 23 23 
Address of 2th array = 0x7ffe50edd5a0 0x7ffe50edd5a0
30 30 31 31 32 32 33 33
</pre>
<li><b>Pointers and Three Dimensional Arrays</b><br />
In a three dimensional array we can access each element by using three subscripts. 
Let us take a 3-D array-
<pre>int arr[2][3][2] = { {{5, 10}, {6, 11}, {7, 12}}, {{20, 30}, {21, 31}, {22, 32}} };</pre>
We can consider a three dimensional array to be an array of 2-D array i.e each element of a 3-D array is considered to be a 2-D array. 
The 3-D array <i>arr</i> can be considered as an array consisting of two elements where each element is a 2-D array. 
The name of the array <i>arr</i> is a pointer to the 0<sup>th</sup> 2-D array.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/diagram.png"><br />
Thus the pointer expression <strong>*(*(*(arr + i ) + j ) + k) is equivalent to the subscript expression arr[i][j][k].</strong><br />
We know the expression *(arr + i) is equivalent to arr[i] and the expression *(*(arr + i) + j) is equivalent arr[i][j]. 
So we can say that arr[i] represents the base address of i<sup>th</sup> 2-D array and arr[i][j] represents the base address of the j<sup>th</sup> 1-D array.
<code class="comments">// C program to print the elements of 3-D </code>
<code class="comments">// array using pointer notation </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2][3][2] = { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{5, 10}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{6, 11}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{7, 12}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{20, 30}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{21, 31}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{22, 32}, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, j, k; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; 2; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(j = 0; j &lt; 3; j++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(k = 0; k &lt; 2; k++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\t"</code><code class="plain">, *(*(*(arr + i) + j) +k)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>5    10    
6    11    
7    12    
20    30    
21    31    
22    32</pre>
The following figure shows how the 3-D array used in the above program is stored in memory.<br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram12-1.png"></li></ol>
<p align="center"><B>Subscripting Pointer to an Array</b>
Suppose <i>arr</i> is a 2-D array with 3 rows and 4 columns and <i>ptr</i> is a pointer to an array of 4 integers, and <i>ptr</i> contains the base address of array <i>arr</i>.
<pre>int arr[3][4] = {{10, 11, 12, 13}, {20, 21, 22, 23}, {30, 31, 32, 33}};
int (*ptr)[4];
ptr = arr;</pre>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Diagram12-2.png"><br />
Since <i>ptr</i> is a pointer to an array of 4 integers, <i>ptr + i</i> will point to i<sup>th</sup> row. 
On dereferencing <i>ptr + i</i>, we get base address of i<sup>th</sup> row. 
To access the address of j<sup>th</sup> element of i<sup>th</sup> row we can add j to the pointer expression <i>*(ptr + i)</i>. 
So the pointer expression <i>*(ptr + i) + j</i> gives the address of j<sup>th</sup> element of i<sup>th</sup> row and the pointer expression <i>*(*(ptr + i)+j)</i> gives the value of the j<sup>th</sup> element of i<sup>th</sup> row.<br />
We know that the pointer expression *(*(ptr + i) + j) is equivalent to subscript expression ptr[i][j]. 
So if we have a pointer variable containing the base address of 2-D array, then we can access the elements of array by double subscripting that pointer variable.
<code class="comments">// C program to print elements of a 2-D array&nbsp; </code>
<code class="comments">// by scripting a pointer to an array&nbsp; </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[3][4] = {&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{10, 11, 12, 13},&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{20, 21, 22, 23},&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{30, 31, 32, 33}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">(*ptr)[4]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%p %p %p\n"</code><code class="plain">, ptr, ptr + 1, ptr + 2); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%p %p %p\n"</code><code class="plain">, *ptr, *(ptr + 1), *(ptr + 2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d\n"</code><code class="plain">, **ptr, *(*(ptr + 1) + 2), *(*(ptr + 2) + 3)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d\n"</code><code class="plain">, ptr[0][0], ptr[1][2], ptr[2][3]); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>0x7ffead967560 0x7ffead967570 0x7ffead967580
0x7ffead967560 0x7ffead967570 0x7ffead967580
10 22 33
10 22 33</pre>
<h2>Enumeration (or enum) in C</h2>
Enumeration (or enum) is a user defined data type in C. 
 It is mainly used to assign names to integral constants, the names make a program easy to read and maintain.<!--more-->
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Enum-In-C.png" alt="">
<pre>enum State {Working = 1, Failed = 0}; </pre>
The keyword &#8216;enum&#8217; is used to declare new enumeration types in C and C++. 
 Following is an example of enum declaration.
<pre>
// The name of enumeration is "flag" and the constant
// are the values of the flag. 
By default, the values
// of the constants are as follows:
// constant1 = 0, constant2 = 1, constant3 = 2 and 
// so on.
enum flag{constant1, constant2, constant3, ....... 
};
</pre>
Variables of type enum can also be defined. 
They can be defined in two ways:
<pre>
// In both of the below cases, "day" is 
// defined as the variable of type week. 
enum week{Mon, Tue, Wed};
enum week day;
// <strong>Or</strong>
enum week{Mon, Tue, Wed}day;
</pre>
<code class="comments">// An example program to demonstrate working </code>
<code class="comments">// of enum in C </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">enum</code> <code class="plain">week{Mon, Tue, Wed, Thur, Fri, Sat, Sun}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">enum</code> <code class="plain">week day; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">day = Wed; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">,day); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp; </code>
Output:
<pre>
2
</pre>
In the above example, we declared &#8220;day&#8221; as the variable and the value of &#8220;Wed&#8221; is allocated to day, which is 2. 
So as a result, 2 is printed.
Another example of enumeration is:
<code class="comments">// Another example program to demonstrate working </code>
<code class="comments">// of enum in C </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">enum</code> <code class="plain">year{Jan, Feb, Mar, Apr, May, Jun, Jul,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Aug, Sep, Oct, Nov, Dec}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=Jan; i&lt;=Dec; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
0 1 2 3 4 5 6 7 8 9 10 11
</pre>
In this example, the for loop will run from i = 0 to i = 11, as initially the value of i is Jan which is 0 and the value of Dec is 11. 
 
 <br />
 
<strong>Interesting facts about initialization of enum.</strong><br />
<strong>1.</strong> Two enum names can have same value. 
For example, in the following C program both &#8216;Failed&#8217; and &#8216;Freezed&#8217; have same value 0.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">enum</code> <code class="plain">State {Working = 1, Failed = 0, Freezed = 0}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d, %d, %d"</code><code class="plain">, Working, Failed, Freezed); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>1, 0, 0</pre>
</br><br />
<strong>2.</strong> If we do not explicitly assign values to enum names, the compiler by default assigns values starting from 0. 
For example, in the following C program, sunday gets value 0, monday gets 1, and so on.
          
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">enum</code> <code class="plain">day {sunday, monday, tuesday, wednesday, thursday, friday, saturday}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">enum</code> <code class="plain">day d = thursday; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The day number stored in d is %d"</code><code class="plain">, d); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>The day number stored in d is 4</pre>
</br><br />
<strong>3.</strong> We can assign values to some name in any order. 
All unassigned names get value as value of previous name plus one.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">enum</code> <code class="plain">day {sunday = 1, monday, tuesday = 5, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wednesday, thursday = 10, friday, saturday}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d %d %d %d %d"</code><code class="plain">, sunday, monday, tuesday, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">wednesday, thursday, friday, saturday); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 5 6 10 11 12</pre>
</br><br />
<strong>4.</strong> The value assigned to enum names must be some integeral constant, i.e., the value must be in range from minimum possible integer value to maximum possible integer value.
</br><br />
<strong>5.</strong> All enum constants must be unique in their scope. 
For example, the following program fails in compilation.
<code class="keyword bold">enum</code> <code class="plain">state&nbsp; {working, failed}; </code>
<code class="keyword bold">enum</code> <code class="plain">result {failed, passed}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; { </code><code class="keyword bold">return</code> <code class="plain">0; } </code>
Output: 
<pre>
Compile Error: 'failed' has a previous declaration as 'state failed'</pre>
</br><br />
<strong>Exercise:</strong><br />
Predict the output of following C programs
Program 1:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">enum</code> <code class="plain">day {sunday = 1, tuesday, wednesday, thursday, friday, saturday}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">enum</code> <code class="plain">day d = thursday; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The day number stored in d is %d"</code><code class="plain">, d); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
</br><br />
Program 2:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">enum</code> <code class="plain">State {WORKING = 0, FAILED, FREEZED}; </code>
<code class="keyword bold">enum</code> <code class="plain">State currState = 2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">enum</code> <code class="plain">State FindState() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">currState; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">(FindState() == WORKING)? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"WORKING"</code><code class="plain">): </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"NOT WORKING"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
<strong>Enum vs Macro</strong><br />
We can also use macros to define names constants. 
For example we can define &#8216;Working&#8217; and &#8216;Failed&#8217; using following macro.
<code class="preprocessor">#define Working 0 </code>
<code class="preprocessor">#define Failed 1 </code>
<code class="preprocessor">#define Freezed 2 </code>
There are multiple advantages of using enum over macro when many related named constants have integral values.<br />
a) Enums follow scope rules.<br />
b) Enum variables are automatically assigned values. 
Following is simpler
<code class="keyword bold">enum</code> <code class="plain">state&nbsp; {Working, Failed, Freezed}; </code>
<h2>Structures in C</h2>
<em><strong>What is a structure?</strong></em><br />
A structure is a user defined data type in C/C++. 
A structure creates a data type that can be used to group items of possibly different types into a single type. 
<!--more-->
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Structure-In-C.png" alt="">
&nbsp;<br />
<em><strong>How to create a structure?</strong></em><br />
&#8216;struct&#8217; keyword is used to create a structure. 
Following is an example.
<code class="keyword bold">struct</code> <code class="plain">address </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">name[50]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">street[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">city[50]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">state[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">pin; </code>
<code class="plain">};</code>
&nbsp;<br />
<em><strong>How to declare structure variables?</strong></em><br />
A structure variable can either be declared with structure declaration or as a separate declaration like basic types.
<code class="comments">// A variable declaration with structure declaration. 
</code>
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">} p1;&nbsp; </code><code class="comments">// The variable p1 is declared with 'Point' </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A variable declaration like basic data types </code>
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">};&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1;&nbsp; </code><code class="comments">// The variable p1 is declared like a normal variable </code>
<code class="plain">}</code>
Note: In C++, the struct keyword is optional before in declaration of a variable. 
In C, it is mandatory.

<em><strong>How to initialize structure members?</strong></em><br />
Structure members <strong>cannot be</strong> initialized with declaration. 
For example the following C program fails in compilation.
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 0;&nbsp; </code><code class="comments">// COMPILER ERROR:&nbsp; cannot initialize members here </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y = 0;&nbsp; </code><code class="comments">// COMPILER ERROR:&nbsp; cannot initialize members here </code>
<code class="plain">};&nbsp; </code>
The reason for above error is simple, when a datatype is declared, no memory is allocated for it. 
Memory is allocated only when variables are created.
Structure members <strong>can be</strong> initialized using curly braces &#8216;{}&#8217;. 
For example, following is a valid initialization.
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">};&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// A valid initialization. 
member x gets value 0 and y </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// gets value 1.&nbsp; The order of declaration is followed. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {0, 1};&nbsp; </code>
<code class="plain">}</code>
&nbsp;<br />
<em><strong>How to access structure elements?</strong></em><br />
Structure members are accessed using dot (.) operator. 
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {0, 1}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Accessing members of point p1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">p1.x = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"x = %d, y = %d"</code><code class="plain">, p1.x, p1.y); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>
x = 20, y = 1
</pre>
&nbsp;<br />
<strong>What is designated Initialization?</strong><br />
Designated Initialization allows structure members to be initialized in any order. 
This feature has been added in <a href="https://www.geeksforgeeks.org/c-programming-language-standard/">C99 standard</a>.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y, z; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Examples of initialization using designated initialization </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {.y = 0, .z = 1, .x = 2}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p2 = {.x = 20}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"x = %d, y = %d, z = %d\n"</code><code class="plain">, p1.x, p1.y, p1.z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"x = %d"</code><code class="plain">, p2.x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
x = 2, y = 0, z = 1
x = 20
</pre>
This feature is not available in C++ and works only in C.
&nbsp;<br />
<em><strong>What is an array of structures?</strong></em><br />
Like other primitive data types, we can create an array of structures.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Create an array of structures </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point arr[10]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Access array members </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0].x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0].y = 20; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d"</code><code class="plain">, arr[0].x, arr[0].y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
10 20
</pre>
&nbsp;<br />
<em><strong>What is a structure pointer?</strong></em><br />
Like primitive types, we can have pointer to a structure. 
If we have a pointer to structure, members are accessed using arrow ( -&gt; ) operator.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {1, 2}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// p2 is a pointer to structure p1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point *p2 = &p1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Accessing structure members using structure pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d"</code><code class="plain">, p2->x, p2->y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>
1 2
</pre>
<strong>What is structure member alignment?</strong><br />
See <a href="https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/">https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/</a>
<strong>Limitations of C Structures</strong>
In C language, Structures provide a method for packing together data of different types. 
A Structure is a helpful tool to handle a group of logically related data items. 
However, C structures have some limitations.
<li>The C structure does not allow the struct data type to be treated like built-in data types:</li>
<li>We cannot use operators like +,- etc. 
on Structure variables. 
For example, consider the following code:
<code class="keyword bold">struct</code> <code class="plain">number </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">number n1,n2,n3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n1.x=4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n2.x=3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n3=n1+n2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/*Output: </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">prog.c: In function 'main': </code>
<code class="comments">prog.c:10:7: error:&nbsp; </code>
<code class="comments">invalid operands to binary + (have 'struct number' and 'struct number') </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">n3=n1+n2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">*/</code>
</li>
<li><strong> No Data Hiding:</strong> C Structures do not permit data hiding. 
Structure members can be accessed by any function, anywhere in the scope of the Structure.</li>
<li><strong>Functions inside Structure:</strong> C structures do not permit functions inside Structure</li>
<li><strong>Static Members:</strong> C Structures cannot have static members inside their body</li>
<li><strong>Access Modifiers:</strong> C Programming language do not support access modifiers. 
So they cannot be used in C Structures.</li>
<li><strong>Construction creation in Structure:</strong> Structures in C cannot have constructor inside Structures.</li>
</ul>
<strong>Related Article : <a href="https://www.geeksforgeeks.org/difference-c-structures-c-structures/" rel="noopener">C Structures vs C++ Structures</strong></a>
<h2>Union in C</h2>
Like <a href="https://www.geeksforgeeks.org/structures-c/">Structures</a>, union is a user defined data type. 
In union, all members share the same memory location. 
<!--more-->
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Union-in-C.png" alt="">
For example in the following C program, both x and y share the same location.<!--more-->  If we change x, we can see the changes being reflected in y.<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Declaration of union is same as structures </code>
<code class="keyword bold">union</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// A union variable t </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">test t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x = 2; </code><code class="comments">// t.y also gets value 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"After making x = 2:\n x = %d, y = %d\n\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x, t.y); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.y = 10; </code><code class="comments">// t.x is also updated to 10 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"After making y = 10:\n x = %d, y = %d\n\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x, t.y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
After making x = 2:
 x = 2, y = 2
After making y = 10:
 x = 10, y = 10
</pre>
&nbsp;<br />
<strong>How is the size of union decided by compiler?</strong><br />
Size of a union is taken according the size of largest member in union. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">union</code> <code class="plain">test1 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">} Test1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">union</code> <code class="plain">test2 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">y; </code>
<code class="plain">} Test2; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">union</code> <code class="plain">test3 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">y; </code>
<code class="plain">} Test3; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(test1) = %lu, sizeof(test2) = %lu, "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"sizeof(test3) = %lu"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(Test1), </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(Test2), </code><code class="keyword bold">sizeof</code><code class="plain">(Test3)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
sizeof(test1) = 4, sizeof(test2) = 4, sizeof(test3) = 40
</pre>
&nbsp;<br />
<strong>Pointers to unions?</strong><br />
Like structures, we can have pointers to unions and can access members using the arrow operator (-&gt;). 
The following example demonstrates the same.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">union</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">test p1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">p1.x = 65; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// p2 is a pointer to union p1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">test* p2 = &p1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Accessing union members using pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %c"</code><code class="plain">, p2->x, p2->y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
65 A
</pre>
&nbsp;<br />
<strong>What are applications of union?</strong><br />
Unions can be useful in many situations where we want to use the same memory for two or more members. 
For example, suppose we want to implement a binary tree data structure where each leaf node has a double data value, while each internal node has pointers to two children, but no data. 
If we declare this as: 
<code class="keyword bold">struct</code> <code class="plain">NODE { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">NODE* left; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">NODE* right; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">data; </code>
<code class="plain">}; </code>
then every node requires 16 bytes, with half the bytes wasted for each type of node. 
On the other hand, if we declare a node as following, then we can save space.
<code class="keyword bold">struct</code> <code class="plain">NODE { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">is_leaf; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">NODE* left; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">NODE* right; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} internal; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">data; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} info; </code>
<code class="plain">}; </code>
The above example is taken from <a href="http://dl.flipkart.com/dl/computer-systems-programmer-s-perspective-english-2nd/p/itmdzfy9eaaapjhs?pid=9780137133369&amp;srno=t_2&amp;query=computer+systems%3A+a+programmer%27s+perspective&amp;affid=sandeepgfg">Computer Systems : A Programmer&#8217;s Perspective (English) 2nd Edition</a> book.
<h2>Struct Hack</h2>
What will be the size of following structure?<!--more-->
<code class="keyword bold">struct</code> <code class="plain">employee </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">emp_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code>&nbsp;&nbsp;&nbsp; <code class="plain">name[0]; </code>
<code class="plain">}; </code>
4 + 4 + 0 = 8 bytes.
And what about size of &#8220;name[0]&#8221;. 
In gcc, when we create an array of zero length, it is considered as array of incomplete type that&#8217;s why gcc reports its size as &#8220;0&#8221; bytes. 
This technique is known as &#8220;Stuct Hack&#8221;. 
When we create array of zero length inside structure, it must be (and only) last member of structure. 
Shortly we will see how to use it.<br />
&#8220;Struct Hack&#8221; technique is used to create variable length member in a structure. 
In the above structure, string length of &#8220;name&#8221; is not fixed, so we can use &#8220;name&#8221; as variable length array.
Let us see below memory allocation.
<pre>struct employee *e = malloc(sizeof(*e) + sizeof(char) * 128); </pre>
is equivalent to
<code class="keyword bold">struct</code> <code class="plain">employee </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">emp_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code>&nbsp;&nbsp;&nbsp; <code class="plain">name[128]; </code><code class="comments">/* character array of size 128 */</code>
<code class="plain">}; </code>
And below memory allocation 
<pre>struct employee *e = malloc(sizeof(*e) + sizeof(char) * 1024); </pre>
is equivalent to
<code class="keyword bold">struct</code> <code class="plain">employee </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">emp_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code>&nbsp;&nbsp;&nbsp; <code class="plain">name[1024]; </code><code class="comments">/* character array of size 1024 */</code>
<code class="plain">}; </code>
Note: since name is character array, in malloc instead of &#8220;sizeof(char) * 128&#8221;, we can use &#8220;128&#8221; directly. 
sizeof is used to avoid confusion.
Now we can use &#8220;name&#8221; same as pointer. 
e.g. 
<pre>e->emp_id 	= 100;
e->name_len	= strlen("Geeks For Geeks");
strncpy(e->name, "Geeks For Geeks", e->name_len);</pre>
When we allocate memory as given above, compiler will allocate memory to store &#8220;emp_id&#8221; and &#8220;name_len&#8221; plus contiguous memory to store &#8220;name&#8221;. 
When we use this technique, gcc guaranties that, &#8220;name&#8221; will get contiguous memory.<br />
Obviously there are other ways to solve problem, one is we can use character pointer. 
But there is no guarantee that character pointer will get contiguous memory, and we can take advantage of this contiguous memory. 
For example, by using this technique, we can allocate and deallocate memory by using single malloc and free call (because memory is contagious). 
Other advantage of this is, suppose if we want to write data, we can write whole data by using single &#8220;write()&#8221; call. 
e.g.
<pre>
write(fd, e, sizeof(*e) + name_len); /* write emp_id + name_len + name */ </pre>
If we use character pointer, then we need 2 write calls to write data. 
e.g.
<pre>write(fd, e, sizeof(*e)); 		/* write emp_id + name_len */
write(fd, e->name, e->name_len);	/* write name */</pre>
Note: In C99, there is feature called &#8220;flexible array members&#8221;, which works same as &#8220;Struct Hack&#8221;
<h2>Structure Member Alignment, Padding and Data Packing</h2>
What do we mean by data alignment, structure packing and padding?
Predict the output of following program.<!--more-->
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Alignment requirements </code>
<code class="comments">// (typical 32 bit machine) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// char         1 byte </code>
<code class="comments">// short int    2 bytes </code>
<code class="comments">// int          4 bytes </code>
<code class="comments">// double       8 bytes </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// structure A </code>
<code class="keyword bold">typedef</code> <code class="keyword bold">struct</code> <code class="plain">structa_tag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">       c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">short</code> <code class="color1 bold">int</code> <code class="plain">  s; </code>
<code class="plain">} structa_t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// structure B </code>
<code class="keyword bold">typedef</code> <code class="keyword bold">struct</code> <code class="plain">structb_tag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">short</code> <code class="color1 bold">int</code> <code class="plain">  s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">       c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">        i; </code>
<code class="plain">} structb_t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// structure C </code>
<code class="keyword bold">typedef</code> <code class="keyword bold">struct</code> <code class="plain">structc_tag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">       c; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">     d; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s; </code>
<code class="plain">} structc_t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// structure D </code>
<code class="keyword bold">typedef</code> <code class="keyword bold">struct</code> <code class="plain">structd_tag </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">     d; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">       c; </code>
<code class="plain">} structd_t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(structa_t) = %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(structa_t)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(structb_t) = %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(structb_t)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(structc_t) = %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(structc_t)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof(structd_t) = %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(structd_t)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Before moving further, write down your answer on a paper, and read on. 
If you urge to see explanation, you may miss to understand any lacuna in your analogy. 
<strong>Data Alignment:</strong>
Every data type in C/C++ will have alignment requirement (infact it is mandated by processor architecture, not by language). A processor will have processing word length as that of data bus size. 
On a 32 bit machine, the processing word size will be 4 bytes.
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/MemoryAlignment1.gif"><img class="aligncenter size-full wp-image-9731" alt="" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/MemoryAlignment1.gif"></a>
<strong> </strong>Historically memory is byte addressable and arranged sequentially. 
If the memory is arranged as single bank of one byte width, the processor needs to issue 4 memory read cycles to fetch an integer. 
It is more economical to read all 4 bytes of integer in one memory cycle. 
To take such advantage, the memory will be arranged as group of 4 banks as shown in the above figure.
The memory addressing still be sequential. 
If bank 0 occupies an address X, bank 1, bank 2 and bank 3 will be at (X + 1), (X + 2) and (X + 3) addresses. 
If an integer of 4 bytes is allocated on X address (X is multiple of 4), the processor needs only one memory cycle to read entire integer.
Where as, if the integer is allocated at an address other than multiple of 4, it spans across two rows of the banks as shown in the below figure. 
Such an integer requires two memory read cycle to fetch the data.
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/MemoryAlignment2.gif"><img class="aligncenter size-full wp-image-9732" alt="" src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/MemoryAlignment2.gif"></a>
A variable&#8217;s <em><strong>data alignment</strong></em> deals with the way the data stored in these banks. 
For example, the natural alignment of <em><strong>int</strong></em> on 32-bit machine is 4 bytes. 
When a data type is naturally aligned, the CPU fetches it in minimum read cycles.
Similarly, the natural alignment of <strong><em>short int</em></strong> is 2 bytes. 
It means, a <em><strong>short int</strong></em> can be stored in bank 0 &#8211; bank 1 pair or bank 2 &#8211; bank 3 pair. 
A <strong><em>double</em></strong> requires 8 bytes, and occupies two rows in the memory banks. 
Any misalignment of <strong><em>double</em></strong> will force more than two read cycles to fetch <strong><em>double</em></strong> data.
Note that a <strong>double</strong> variable will be allocated on 8 byte boundary on 32 bit machine and requires two memory read cycles. 
On a 64 bit machine, based on number of banks, <strong>double</strong> variable will be allocated on 8 byte boundary and requires only one memory read cycle.
<strong>Structure Padding:</strong>
          
<strong> </strong>In C/C++ a structures are used as data pack. 
It doesn&#8217;t provide any data encapsulation or data hiding features (C++ case is an exception due to its semantic similarity with classes).
Because of the alignment requirements of various data types, every member of structure should be naturally aligned. 
The members of structure allocated sequentially increasing order. 
Let us analyze each struct declared in the above program.
<strong>Output of Above Program:</strong>
<strong><span style="color: #3366ff">For the sake of convenience, assume every structure type variable is allocated on 4 byte boundary (say 0x0000), i.e. 
the base address of structure is multiple of 4 (need not necessary always, see explanation of structc_t).</span></strong>
<strong><span style="color: #3366ff">structure A</span></strong>
<span style="color: #3366ff">The <em>structa_t</em> first element is <em>char</em> which is one byte aligned, followed by <em>short int</em>. 
short int is 2 byte aligned. 
If the the short int element is immediately allocated after the char element, it will start at an odd address boundary. 
The compiler will insert a padding byte after the char to ensure short int will have an address multiple of 2 (i.e. 
2 byte aligned). 
The total size of structa_t will be sizeof(char) + 1 (padding) + sizeof(short), 1 + 1 + 2 = 4 bytes.</span>
<strong><span style="color: #3366ff">structure B</span></strong>
<span style="color: #3366ff">The first member of <em>structb_t</em> is short int followed by char. 
Since char can be on any byte boundary no padding required in between short int and char, on total they occupy 3 bytes. 
The next member is int. 
If the int is allocated immediately, it will start at an odd byte boundary. 
We need 1 byte padding after the char member to make the address of next int member is 4 byte aligned. 
On total, the <em>structb_t</em> requires 2 + 1 + 1 (padding) + 4 = 8 bytes.</span>
<span style="color: #808080"><strong><span style="color: #3366ff">structure C &#8211; Every structure will also have alignment requirements</span></strong></span>
<span style="color: #3366ff">Applying same analysis, <em>structc_t</em> needs sizeof(char) + 7 byte padding + sizeof(double) + sizeof(int) = 1 + 7 + 8 + 4 = 20 bytes. 
However, the sizeof(structc_t) will be 24 bytes. 
It is because, along with structure members, structure type variables will also have natural alignment. 
Let us understand it by an example. 
</span><span style="color: #3366ff">Say, we declared an array of structc_t as shown below</span>
          
<pre><span style="color: #3366ff">structc_t structc_array[3];</span></pre>
<span style="color: #3366ff">Assume, the base address of <em>structc_array</em> is 0x0000 for easy calculations. 
If the structc_t occupies 20 (0x14) bytes as we calculated, the second structc_t array element (indexed at 1) will be at 0x0000 + 0x0014 = 0x0014. 
It is the start address of index 1 element of array. 
The double member of this structc_t will be allocated on 0x0014 + 0x1 + 0x7 = 0x001C (decimal 28) which is not multiple of 8 and conflicting with the alignment requirements of double. 
As we mentioned on the top, the alignment requirement of double is 8 bytes.</span>
<span style="color: #3366ff">Inorder to avoid such misalignment, compiler will introduce alignment requirement to every structure. 
It will be as that of the largest member of the structure. 
In our case alignment of structa_t is 2, structb_t is 4 and structc_t is 8. 
If we need nested structures, the size of largest inner structure will be the alignment of immediate larger structure.</span>
<span style="color: #3366ff">In structc_t of the above program, there will be padding of 4 bytes after int member to make the structure size multiple of its alignment. 
Thus the sizeof (structc_t) is 24 bytes. It guarantees correct alignment even in arrays. 
You can cross check.</span>
<strong><span style="color: #3366ff">structure D &#8211; How to Reduce Padding?</span></strong>
<span style="color: #3366ff">By now, it may be clear that padding is unavoidable. 
There is a way to minimize padding. 
The programmer should declare the structure members in their increasing/decreasing order of size. 
An example is structd_t given in our code, whose size is 16 bytes in lieu of 24 bytes of structc_t.</span>
<strong>What is structure packing?</strong>
Some times it is mandatory to avoid padded bytes among the members of structure. 
For example, reading contents of ELF file header or BMP or JPEG file header. 
We need to define a structure similar to that of the header layout and map it. 
However, care should be exercised in accessing such members. 
Typically reading byte by byte is an option to avoid misaligned exceptions. 
There will be hit on performance.
Most of the compilers provide non standard extensions to switch off the default padding like pragmas or command line switches. 
Consult the documentation of respective compiler for more details.
<strong>Pointer Mishaps:</strong>
There is possibility of potential error while dealing with pointer arithmetic. 
For example, dereferencing a generic pointer (void *) as shown below can cause misaligned exception,
          
<pre>// Deferencing a generic pointer (not safe)
// There is no guarantee that pGeneric is integer aligned
*(int *)pGeneric;</pre>
It is possible above type of code in programming. 
If the pointer <em>pGeneric</em> is not aligned as per the requirements of casted data type, there is possibility to get misaligned exception.
Infact few processors will not have the last two bits of address decoding, and there is no way to access <em>misaligned</em> address. 
The processor generates misaligned exception, if the programmer tries to access such address.
<strong>A note on malloc() returned pointer</strong>
The pointer returned by malloc() is <em>void *</em>. 
It can be converted to any data type as per the need of programmer. 
The implementer of malloc() should return a pointer that is aligned to maximum size of primitive data types (those defined by compiler). 
It is usually aligned to 8 byte boundary on 32 bit machines.
<strong>Object File Alignment, Section Alignment, Page Alignment</strong>
These are specific to operating system implementer, compiler writers and are beyond the scope of this article. 
Infact, I don&#8217;t have much information.
<strong>General Questions:</strong>
<span style="color: #0000ff">1. 
Is alignment applied for stack?</span>
Yes. 
The stack is also memory. 
The system programmer should load the stack pointer with a memory address that is properly aligned. 
Generally, the processor won&#8217;t check stack alignment, it is the programmer&#8217;s responsibility to ensure proper alignment of stack memory. 
Any misalignment will cause run time surprises.
For example, if the processor word length is 32 bit, stack pointer also should be aligned to be multiple of 4 bytes.
<span style="color: #0000ff">2. 
If <em>char</em> data is placed in a bank other bank 0, it will be placed on wrong data lines during memory read. 
How the processor handles <em>char</em> type?</span>
Usually, the processor will recognize the data type based on instruction (e.g. 
LDRB on ARM processor). 
Depending on the bank it is stored, the processor shifts the byte onto least significant data lines.
<span style="color: #0000ff">3. 
When arguments passed on stack, are they subjected to alignment?</span>
Yes. 
The compiler helps programmer in making proper alignment. 
For example, if a 16-bit value is pushed onto a 32-bit wide stack, the value is automatically padded with zeros out to 32 bits. Consider the following program.
<code class="keyword bold">void</code> <code class="plain">argument_alignment_check( </code><code class="color1 bold">char</code> <code class="plain">c1, </code><code class="color1 bold">char</code> <code class="plain">c2 ) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Considering downward stack </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// (on upward stack the output will be negative) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Displacement %d\n"</code><code class="plain">, (</code><code class="color1 bold">int</code><code class="plain">)&c2 - (</code><code class="color1 bold">int</code><code class="plain">)&c1); </code>
<code class="plain">} </code>
The output will be 4 on a 32 bit machine. 
It is because each character occupies 4 bytes due to alignment requirements.
<span style="color: #0000ff">4. 
What will happen if we try to access a misaligned data?</span>
It depends on processor architecture. 
If the access is misaligned, the processor automatically issues sufficient memory read cycles and packs the data properly onto the data bus. 
The penalty is on performance. 
Where as few processors will not have last two address lines, which means there is no-way to access odd byte boundary. 
Every data access must be aligned (4 bytes) properly. 
A misaligned access is critical exception on such processors. 
If the exception is ignored, read data will be incorrect and hence the results.
<span style="color: #0000ff">5. 
Is there any way to query alignment requirements of a data type.</span>
Yes. 
Compilers provide non standard extensions for such needs. 
For example, __alignof() in Visual Studio helps in getting the alignment requirements of data type. 
Read MSDN for details.
<span style="color: #0000ff">6. 
When memory reading is efficient in reading 4 bytes at a time on 32 bit machine, why should a <strong>double</strong> type be aligned on 8 byte boundary?</span>
          
It is important to note that most of the processors will have math co-processor, called Floating Point Unit (FPU). 
Any floating point operation in the code will be translated into FPU instructions. 
The main processor is nothing to do with floating point execution. 
All this will be done behind the scenes.
As per standard, double type will occupy 8 bytes. 
And, every floating point operation performed in FPU will be of 64 bit length. 
Even float types will be promoted to 64 bit prior to execution.
The 64 bit length of FPU registers forces double type to be allocated on 8 byte boundary. 
I am assuming (I don’t have concrete information) in case of FPU operations, data fetch might be different, I mean the data bus, since it goes to FPU. 
Hence, the address decoding will be different for double types (which is expected to be on 8 byte boundary). 
It means, <em>the address decoding circuits of floating point unit will not have last 3 pins</em>.
<strong>Answers:</strong>
<pre>sizeof(structa_t) = 4
sizeof(structb_t) = 8
sizeof(structc_t) = 24
sizeof(structd_t) = 16</pre>
<strong>Update: 1-May-2013</strong>
It is observed that on latest processors we are getting size of struct_c as 16 bytes. 
I yet to read relevant documentation. 
I will update once I got proper information (written to few experts in hardware).
On older processors (AMD Athlon X2) using same set of tools (GCC 4.7) I got struct_c size as 24 bytes. 
The size depends on how memory banking organized at the hardware level.
<h2>Operations on struct variables in C</h2>
In C, the only operation that can be applied to <em>struct </em>variables is assignment. 
Any other operation (e.g. 
equality check) is not allowed on <em>struct </em>variables. 
<!--more--><br />
For example, program 1 works without any error and program 2 fails in compilation. 
<strong>Program 1</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {10, 20}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p2 = p1; </code><code class="comments">// works: contents of p1 are copied to p2 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" p2.x = %d, p2.y = %d"</code><code class="plain">, p2.x, p2.y); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
<strong>Program 2</strong><br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Point { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p1 = {10, 20}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Point p2 = p1; </code><code class="comments">// works: contents of p1 are copied to p2 </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(p1 == p2)&nbsp; </code><code class="comments">// compiler error: cannot do equality check for&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// whole structures </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"p1 and p2 are same "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Bit Fields in C</h2>
In C, we can specify size (in bits) of structure and union members. 
The idea is to use memory efficiently when we know that the value of a field or group of fields will never exceed a limit or is withing a small range. 
<!--more-->
For example, consider the following declaration of date without the use of bit fields.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A simple representation of the date </code>
<code class="keyword bold">struct</code> <code class="plain">date { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">d; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">m; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of date is %lu bytes\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">date)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">date dt = { 31, 12, 2014 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Date is %d/%d/%d"</code><code class="plain">, dt.d, dt.m, dt.y); </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
Size of date is 12 bytes
Date is 31/12/2014
</pre>
The above representation of &#8216;date&#8217; takes 12 bytes on a compiler where an unsigned int takes 4 bytes. 
Since we know that the value of d is always from 1 to 31, the value of m is from 1 to 12, we can optimize the space using bit fields.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Space optimized representation of the date </code>
<code class="keyword bold">struct</code> <code class="plain">date { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// d has value between 1 and 31, so 5 bits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// are sufficient </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">d : 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// m has value between 1 and 12, so 4 bits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// are sufficient </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">m : 4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of date is %lu bytes\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">date)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">date dt = { 31, 12, 2014 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Date is %d/%d/%d"</code><code class="plain">, dt.d, dt.m, dt.y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>
Size of date is 8 bytes
Date is 31/12/2014
</pre>
However if the same code is written using signed int and the value of the fields goes beyond the bits allocated to the variable and something interesting can happen. 
For example consider the same code but with signed integers:
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Space optimized representation of the date </code>
<code class="keyword bold">struct</code> <code class="plain">date { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// d has value between 1 and 31, so 5 bits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// are sufficient </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">d : 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// m has value between 1 and 12, so 4 bits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// are sufficient </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">m : 4; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of date is %lu bytes\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">date)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">date dt = { 31, 12, 2014 }; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Date is %d/%d/%d"</code><code class="plain">, dt.d, dt.m, dt.y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>
Size of date is 8 bytes
Date is -1/-4/2014
</pre>
The output comes out to be negative. 
What happened behind is that the value 31 was stored in 5 bit signed integer which is equal to 11111. 
The MSB is a 1, so it&#8217;s a negative number and you need to calculate the 2&#8217;s complement of the binary number to get its actual value which is what is done internally. 
By calculating 2&#8217;s complement you will arrive at the value 00001 which is equivalent to decimal number 1 and since it was a negative number you get a -1. 
A similar thing happens to 12 in which case you get 4-bit representation as 1100 which on calculating 2&#8217;s complement you get the value of -4.
<strong>Following are some interesting facts about bit fields in C.</strong>
<strong>1)</strong> A special unnamed bit field of size 0 is used to force alignment on next boundary. 
 For example consider the following program.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A structure without forced alignment </code>
<code class="keyword bold">struct</code> <code class="plain">test1 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 8; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A structure with forced alignment </code>
<code class="keyword bold">struct</code> <code class="plain">test2 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">: 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 8; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of test1 is %lu bytes\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">test1)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of test2 is %lu bytes\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">test2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>
Size of test1 is 4 bytes
Size of test2 is 8 bytes
</pre>
&nbsp;
<strong>2)</strong> We cannot have pointers to bit field members as they may not start at a byte boundary. 
          
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">test t; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Uncommenting the following line will make </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the program compile and run </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Address of t.x is %p"</code><code class="plain">, &t.x); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The below line works fine as z is not a </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// bit field member </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Address of t.z is %p"</code><code class="plain">, &t.z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong> 
<pre>prog.c: In function 'main':
prog.c:14:1: error: cannot take address of bit-field 'x'
 printf("Address of t.x is %p", &t.x); 
 ^
</pre>
&nbsp;
<strong>3) </strong> It is implementation defined to assign an out-of-range value to a bit field member.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">z : 2; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">test t; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, t.x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong> 
<pre>Implementation-Dependent</pre>
&nbsp;
<strong>4)</strong> In C++, we can have static members in a structure/class, but bit fields cannot be static.
<code class="comments">// The below C++ program compiles and runs fine </code>
<code class="keyword bold">struct</code> <code class="plain">test1 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() {} </code>
<b>Output:</b>
<pre>
</pre>
<code class="comments">// But below C++ program fails in the compilation </code>
<code class="comments">// as bit fields cannot be static </code>
<code class="keyword bold">struct</code> <code class="plain">test1 { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 5; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() {} </code>
<strong>Output:</strong>
<pre>
prog.cpp:5:29: error: static member 'x' cannot be a bit-field
     static unsigned int x : 5;
     ^
</pre>
&nbsp;
<strong>5)</strong>  Array of bit fields is not allowed. 
For example, the below program fails in the compilation.
          
<code class="keyword bold">struct</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x[10] : 5; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>prog.c:3:1: error: bit-field 'x' has invalid type
 unsigned int x[10]: 5; 
 ^
</pre>
&nbsp;<br />
&nbsp;
<strong>Exercise:</strong><br />
Predict the output of following programs. 
Assume that unsigned int takes 4 bytes and long int takes 8 bytes.<br />
<strong>1)</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 33; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%lu"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">test)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
&nbsp;
<strong>2)</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">int</code> <code class="plain">y : 33; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="plain">}; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">test t; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code><code class="plain">* ptr1 = &t.x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code><code class="plain">* ptr2 = &t.z; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, ptr2 - ptr1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
&nbsp;
3) 
<code class="keyword bold">union</code> <code class="plain">test { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">x : 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">y : 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">z; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">test t; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x = 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.y = 4; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.z = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"t.x = %d, t.y = %d, t.z = %d"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t.x, t.y, t.z); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
&nbsp;
<strong>4)</strong> Use bit fields in C to figure out a way whether a machine is little-endian or big-endian.
<h2>Structure Sorting (By Multiple Rules) in C++</h2>
Prerequisite : <a href="http://quiz.geeksforgeeks.org/structures-c/">Structures in C</a>
Name and marks in different subjects (physics, chemistry and maths) are given for all students. 
The task is to compute total marks and ranks of all students. 
And finally display all students sorted by rank. 
Rank of student is computed using below rules.
<ol>
<li> If total marks are different, then students with higher marks gets better rank.</li>
<li> If total marks are same, then students with higher marks in Maths gets better rank.</li>
<li> If total marks are same and marks in Maths are also same, then students with better marks in Physics gets better rank.</li>
<li> If all marks (total, Maths, Physics and Chemistry) are same, then any student can be assigned bedtter rank.</li>
</ol>
<div id="practiceLinkDiv">
<h3>
    <a href="https://practice.geeksforgeeks.org/problems/sonam-bewafa-asks-questions/0">Recommended: Please solve it on &#8220;<b><i><u>PRACTICE</u></i></b> &#8221; first, before moving on to the solution.</a><br />
</h3>
We use below structure to store details of students.
<pre>
struct Student 
{
    string name; // Given
    int math;  // Marks in math (Given)
    int phy;   // Marks in Physics (Given)
    int che;   // Marks in Chemistry (Given)
    int total; // Total marks (To be filled)
    int rank;  // Rank of student (To be filled)
};  
</pre>
We use <a href="https://www.geeksforgeeks.org/sort-c-stl/">std::sort()</a> for <strong>Structure Sorting</strong>. 
In Structure sorting, all the respective properties possessed by the structure object are sorted on the basis of one (or more) property of the object.
In this example, marks of students in different subjects are provided by user. 
These marks in individual subjects are added to calculate the total marks of the student, which is then used to sort different students on the basis of their ranks (as explained above).
<code class="comments">// C++ program to demonstrate structure sorting in C++ </code>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Student&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">string name; </code><code class="comments">// Given </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">math;&nbsp; </code><code class="comments">// Marks in math (Given) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">phy;&nbsp;&nbsp; </code><code class="comments">// Marks in Physics (Given) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">che;&nbsp;&nbsp; </code><code class="comments">// Marks in Chemistry (Given) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">total; </code><code class="comments">// Total marks (To be filled) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">rank;&nbsp; </code><code class="comments">// Rank of student (To be filled) </code>
<code class="plain">};&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function for comparing two students according </code>
<code class="comments">// to given rules </code>
<code class="color1 bold">bool</code> <code class="plain">compareTwoStudents(Student a, Student b) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If total marks are not same then </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// returns true for higher total </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a.total != b.total ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">a.total > b.total; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If marks in Maths are not same then </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// returns true for higher marks </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(a.math != b.math) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">a.math > b.math; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(a.phy > b.phy); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Fills total marks and ranks of all Students </code>
<code class="keyword bold">void</code> <code class="plain">computeRanks(Student a[], </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To calculate total marks for all Students </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[i].total = a[i].math + a[i].phy + a[i].che; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Sort structure array using user defined </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// function compareTwoStudents() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sort(a, a+5, compareTwoStudents); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assigning ranks after sorting </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[i].rank = i+1; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// array of structure objects </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Student a[n]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Details of Student 1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[0].name = </code><code class="string">"Bryan"</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[0].math = 80 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[0].phy = 95 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[0].che = 85 ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Details of Student 2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[1].name= </code><code class="string">"Kevin"</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[1].math= 95 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[1].phy= 85 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[1].che= 99 ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Details of Student 3 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[2].name = </code><code class="string">"Nick"</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[2].math = 95 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[2].phy = 85 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[2].che = 80 ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Details of Student 4 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[3].name = </code><code class="string">"AJ"</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[3].math = 80 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[3].phy = 70 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[3].che = 90 ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Details of Student 5 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[4].name = </code><code class="string">"Howie"</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[4].math = 80 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[4].phy = 80 ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a[4].che = 80 ; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">computeRanks(a, n); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//Column names for displaying data </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Rank"</code> <code class="plain">&lt;&lt;</code><code class="string">"t"</code> <code class="plain">&lt;&lt; </code><code class="string">"Name"</code> <code class="plain">&lt;&lt; </code><code class="string">"t"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Maths"</code> <code class="plain">&lt;&lt;</code><code class="string">"t"</code> <code class="plain">&lt;&lt;</code><code class="string">"Physics"</code> <code class="plain">&lt;&lt;</code><code class="string">"t"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt; </code><code class="string">"Chemistry"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"t"</code> <code class="plain">&lt;&lt; </code><code class="string">"Totaln"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Display details of Students </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a[i].rank &lt;&lt; </code><code class="string">"t"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a[i].name &lt;&lt; </code><code class="string">"t"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a[i].math &lt;&lt; </code><code class="string">"t"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt; a[i].phy &lt;&lt; </code><code class="string">"t"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt; a[i].che &lt;&lt; </code><code class="string">"tt"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; a[i].total &lt;&lt;</code><code class="string">"t"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt;</code><code class="string">"n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output: </strong>
<pre>
Rank	Name	Maths	Physics	Chemistry	Total
1	Kevin	95	85	99		279	
2	Nick	95	85	80		260	
3	Bryan	80	95	85		260	
4	Howie	80	80	80		240	
5	AJ	80	70	90		240	
</pre>
<strong>Related Articles:</strong><br />
<a href="https://www.geeksforgeeks.org/sort-c-stl/">sort() in C++ STL</a><br />
<a href="https://www.geeksforgeeks.org/comparator-function-of-qsort-in-c/">Comparator function of qsort() in C</a><br />
<a href="https://www.geeksforgeeks.org/c-qsort-vs-c-sort/">C qsort() vs C++ sort()</a><br />
<a href="https://www.geeksforgeeks.org/sort-array-according-count-set-bits/">Sort an array according to count of set bits</a>
<h2>Flexible Array Members in a structure in C</h2>
Flexible Array Member(FAM) is a feature introduced in the C99 standard of the C programming language.
<ul>
<li>For the <a href="https://www.geeksforgeeks.org/structures-c/">structures</a> in C programming language from C99 standard onwards, we can declare an array <strong>without a dimension</strong> and whose size is flexible in nature.</li>
<li>Such an array inside the structure should preferably be declared as the <strong>last member</strong> of structure and its size is variable(can be changed be at runtime).</li>
<li>The structure must contain at least one more named member in addition to the flexible array member.</li>
</ul>
<strong>What must be the size of the structure below?</strong>
<code class="keyword bold">struct</code> <code class="plain">student </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">stud_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">struct_size; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">stud_name[]; </code>
<code class="plain">}; </code>
<pre>The size of structure is = 4 + 4 + 4 + <strong>0</strong> = 12</pre>
In the above code snippet, the size i.e length of array &#8220;stud_name&#8221; isn&#8217;t fixed and is an FAM. 

The memory allocation using flexible array members(as per C99 standards) for the above example can be done as:
<pre>
 struct student *s = malloc( sizeof(*s) + sizeof(char [strlen(stud_name)])  );
</pre>
<strong>Note:</strong> While using flexible array members in structures some convention regarding actual size of the member is defined.<br />
In the above example the convention is that the member &#8220;stud_name&#8221; has character size. 
<strong>For Example, Consider the following structure: </strong>
<pre>
Input : id = 15, name = "Kartik" 
Output : Student_id : 15
         Stud_Name  : Kartik
         Name_Length: 6
         <strong>Allocated_Struct_size: 18</strong>
</pre>
<strong>Memory allocation of above structure: </strong>
<pre>
struct student *s = 
        malloc( sizeof(*s) + sizeof(char [strlen("Kartik")]));
</pre>
Its structure representation is equal to:
<code class="keyword bold">struct</code> <code class="plain">student </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">stud_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">struct_size; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">stud_name[6]; </code><code class="comments">//character array of length 6 </code>
<code class="plain">}; </code>
<p align="center"><strong>Implementation</strong>
<code class="comments">// C program for variable length members in </code>
<code class="comments">// structures in GCC </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A structure of type student </code>
<code class="keyword bold">struct</code> <code class="plain">student </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">stud_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">name_len; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// This is used to store size of flexible </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// character array stud_name[] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">struct_size; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Flexible Array Member(FAM) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// variable length array must be last </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// member of structure </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">stud_name[]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Memory allocation and initialisation of structure </code>
<code class="keyword bold">struct</code> <code class="plain">student *createStudent(</code><code class="keyword bold">struct</code> <code class="plain">student *s, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">id, </code><code class="color1 bold">char</code> <code class="plain">a[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Allocating memory according to user provided </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// array of characters </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s = </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">malloc</code><code class="plain">( </code><code class="keyword bold">sizeof</code><code class="plain">(*s) + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">) * </code><code class="functions bold">strlen</code><code class="plain">(a)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->stud_id = id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->name_len = </code><code class="functions bold">strlen</code><code class="plain">(a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(s->stud_name, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Assigning size according to size of stud_name </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// which is a copy of user provided array a[]. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->struct_size = </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(*s) + </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">) * </code><code class="functions bold">strlen</code><code class="plain">(s->stud_name)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">s; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Print student details </code>
<code class="keyword bold">void</code> <code class="plain">printStudent(</code><code class="keyword bold">struct</code> <code class="plain">student *s) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Student_id : %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Stud_Name : %s\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Name_Length: %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"Allocated_Struct_size: %d\n\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->stud_id, s->stud_name, s->name_len, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s->struct_size); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Value of Allocated_Struct_size is in bytes here </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">student *s1 = createStudent(s1, 523, </code><code class="string">"Cherry"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">student *s2 = createStudent(s2, 535, </code><code class="string">"Sanjayulsha"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printStudent(s1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printStudent(s2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Size in struct student </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of Struct student: %lu\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">student)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Size in struct pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Size of Struct pointer: %lu"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">sizeof</code><code class="plain">(s1)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
Student_id : 523
Stud_Name : SanjayKanna
Name_Length: 11
Allocated_Struct_size: 23
Student_id : 535
Stud_Name : Cherry
Name_Length: 6
Allocated_Struct_size: 18
Size of Struct student: 12
Size of Struct pointer: 8
</pre>
<strong>Important Points:</strong>
<ol>
<li>Adjacent memory locations are used to store structure members in memory.</li>
<li>In previous standards of the C programming language, we were able to declare a zero size array member in place of a flexible array member. 
The GCC compiler with C89 standard considers it as zero size array.</li>
</ol>
<h2>Difference between Structure and Union in C</h2>
<p align="center"><strong><a href="https://www.geeksforgeeks.org/structures-c/">structures in C</a></strong>
A structure is a user-defined data type available in C that allows to combining data items of different kinds. 
Structures are used to represent a record.<br />
<strong>Defining a structure:</strong> To define a structure, you must use the <strong>struct</strong> statement. 
The struct statement defines a new data type, with more than or equal to one member. 
The format of the struct statement is as follows:
<pre>
   struct [structure name]
   {
       member definition;
       member definition;
       ...
       member definition;
   };
  </pre>
<p align="center"><strong><a href="https://www.geeksforgeeks.org/union-c/">union</a></strong>
A union is a special data type available in C that allows storing different data types in the same memory location. 
You can define a union with many members, but only one member can contain a value at any given time. 
Unions provide an efficient way of using the same memory location for multiple purposes.<br />
<strong>Defining a Union:</strong> To define a union, you must use the <strong>union</strong> statement in the same way as you did while defining a structure. 
The union statement defines a new data type with more than one member for your program. 
The format of the union statement is as follows:

<pre>
    union [union name]
    {
       member definition;
       member definition;
       ...
       member definition;
    };
</pre>
<p align="center"><strong>Similarities between Structure and Union</strong>
<ol>
<li>Both are user-defined data types used to store data of different types as a single unit.</li>
<li>Their members can be objects of any type, including other structures and unions or arrays. 
A member can also consist of a bit field.</li>
<li>Both structures and unions support only assignment = and sizeof operators. 
The two structures or unions in the assignment must have the same members and member types.</li>
<li>A structure or a union can be passed by value to functions and returned by value by functions. 
The argument must have the same type as the function parameter. 
A structure or union is passed by value just like a scalar variable as a corresponding parameter.</li>
<li> <strong>&#8216;.&#8217;</strong> operator is used for accessing members.
</ol>
<p align="center"><strong>Differences</strong>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Structure-vs-Union.png" alt=""> 
<code class="comments">// C program to illustrate differences&nbsp; </code>
<code class="comments">// between structure and Union </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// declaring structure </code>
<code class="keyword bold">struct</code> <code class="plain">struct_example </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">integer; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">decimal; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">name[20]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// declaraing union </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="keyword bold">union</code> <code class="plain">union_example </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">integer; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">decimal; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">name[20]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// creating variable for structure&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and initializing values difference&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// six </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">struct_example s={18,38,</code><code class="string">"geeksforgeeks"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// creating variable for union&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and initializing values </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code> <code class="plain">union_example u={18,38,</code><code class="string">"geeksforgeeks"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"structure data:\n integer: %d\n"</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"decimal: %.2f\n name: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer, s.decimal, s.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nunion data:\n integeer: %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"decimal: %.2f\n name: %s\n"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer, u.decimal, u.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// difference two and three </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nsizeof structure : %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"sizeof union : %d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(u)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// difference five </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Accessing all members at a time:"</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer = 183; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.decimal = 90; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(s.name, </code><code class="string">"geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"structure data:\n integer: %d\n "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"decimal: %.2f\n name: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer, s.decimal, s.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer = 183; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.decimal = 90; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(u.name, </code><code class="string">"geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nunion data:\n integeer: %d\n "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"decimal: %.2f\n name: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer, u.decimal, u.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Accessing one member at time:"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nstructure data:"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer = 240; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\ninteger: %d"</code><code class="plain">, s.integer); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.decimal = 120; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\ndecimal: %f"</code><code class="plain">, s.decimal); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(s.name, </code><code class="string">"C programming"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nname: %s\n"</code><code class="plain">, s.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n union data:"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer = 240; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\ninteger: %d"</code><code class="plain">, u.integer); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.decimal = 120; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\ndecimal: %f"</code><code class="plain">, u.decimal); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(u.name, </code><code class="string">"C programming"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nname: %s\n"</code><code class="plain">, u.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//difference four </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nAltering a member value:\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer = 1218; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"structure data:\n integer: %d\n "</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" decimal: %.2f\n name: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">s.integer, s.decimal, s.name); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer = 1218; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"union data:\n integer: %d\n"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" decimal: %.2f\n name: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">u.integer, u.decimal, u.name);&nbsp; </code>
<code class="plain">} </code>
Output:
<pre>
structure data:
 integer: 18
 decimal: 38.00
 name: geeksforgeeks
union data:
 integeer: 18
 decimal: 0.00
 name: ?
sizeof structure: 28
sizeof union: 20
 Accessing all members at a time: structure data:
 integer: 183
 decimal: 90.00
 name: geeksforgeeks
union data:
 integeer: 1801807207
 decimal: 277322871721159510000000000.00
 name: geeksforgeeks
 Accessing one member at a time:
structure data:
integer: 240
decimal: 120.000000
name: C programming
 union data:
integer: 240
decimal: 120.000000
name: C programming
Altering a member value:
structure data:
 integer: 1218
 decimal: 120.00
 name: C programming
union data:
 integer: 1218
 decimal: 0.00
 name: ?
</pre>
In my opinion, structure is better because as memory is shared in union ambiguity is more.<br />
<h2>Difference between C structures and C++ structures</h2>
In C++, struct and class are exactly the same things, except for that struct defaults to public visibility and class defaults to private visibility.<br />
<strong>Some important differences between the C and C++ structures:</strong>
<ol>
<li><strong>Member functions inside structure</strong>: Structures in C cannot have member functions inside structure but Structures in C++ can have member functions along with data members.
</li>
<li><strong>Direct Initialization:</strong> We cannot directly initialize structure data members in C but we can do it in C++.<br />
<h3>C</h3>
<code class="comments">// C program to demonstrate that direct </code>
<code class="comments">// member initialization is not possible in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Record { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 7; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Record s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, s.x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">/* Output :&nbsp; Compiler Error </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">6:8: error: expected ':', ', ', ';', '}' or&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">'__attribute__' before '=' token </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">int x = 7; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">^ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">In function 'main': */</code>
<h3>C++</h3>
<code class="comments">// CPP program to initialize data member in c++ </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Record { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 7; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Record s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; s.x &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Output </code>
<code class="comments">// 7 </code>
<br />
<strong>Output:</strong>
<pre>7</pre>
</li>
<li><strong>Using struct keyword:</strong> In C, we need to use struct to declare a struct variable. 
In C++, struct is not necessary. 
For example, let there be a structure for Record. 
In C, we must use &#8220;struct Record&#8221; for Record variables. 
In C++, we need not use struct and using ‘Record‘ only would work.</li>
<li><strong>Static Members:</strong> C structures cannot have static members but is allowed in C++.<br />
<h3>C</h3>
<code class="comments">// C program with structure static member </code>
<code class="keyword bold">struct</code> <code class="plain">Record { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">/* 6:5: error: expected specifier-qualifier-list&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">before 'static' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">static int x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">^*/</code>
<h3>C++</h3>
<code class="comments">// C++ program with structure static member </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Record { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">x; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<br />
This will generate an error in C but no error in C++.
</li>
<li><strong>Constructor creation in structure</strong>: Structures in C cannot have constructor inside structure but Structures in C++ can have Constructor creation.<br />
<h3>C</h3>
<code class="comments">// C program to demonstrate that Constructor is not allowed </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Student { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">roll; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Student(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">roll = x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Student s(2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, s.x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">/* Output :&nbsp; Compiler Error </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">[Error] expected specifier-qualifier-list&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">before 'Student' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">[Error] expected declaration specifiers or&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">'...' before numeric constant </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">[Error] 's' undeclared (first use&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">5555555555in this function) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">In function 'main': */</code>
<h3>C++</h3>
<code class="comments">// CPP program to initialize data member in c++ </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">struct</code> <code class="plain">Student { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">roll; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Student(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">roll = x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Student s(2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; s.roll; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">// Output </code>
<code class="comments">// 2 </code>
<br />
<strong>Output:</strong>
<pre>2</pre>
</li>
<li><strong>sizeof operator: </strong> This operator will generate <strong>0</strong> for an empty structure in C whereas <strong>1</strong> for an empty structure in C++.
<code class="comments">// C program to illustrate empty structure </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// empty structure </code>
<code class="keyword bold">struct</code> <code class="plain">Record { </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Record s; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d\n"</code><code class="plain">, </code><code class="keyword bold">sizeof</code><code class="plain">(s)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output in C:
<pre>
0
</pre>
Output in C++:
<pre>
1</pre>
</li>
<li><strong>Data Hiding:</strong> C structures do not allow concept of Data hiding but is permitted in C++ as C++ is an object oriented language whereas C is not.
</li>
<li><strong>Access Modifiers:</strong> C structures do not have access modifiers as these modifiers are not supported by the language. 
C++ structures can have this concept as it is inbuilt in the language.</li></ol>
<strong>Related Article:</strong> <a href="https://www.geeksforgeeks.org/g-fact-76/">Structure vs Class in C++</a>
<h2>Anonymous Union and Structure in C</h2>
In <a href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11</a> standard of C, anonymous Unions and structures were added. 
Anonymous unions/structures are also known as unnamed unions/structures as they don&#8217;t have names. 
Since there is no names, direct objects(or variables) of them are not created and we use them in nested structure or unions. 
Definition is just like that of a normal union just without a name or tag. 
For example,
<pre>
// Anonymous union example
union 
{
   char alpha;
   int num;
};
</pre>
<pre>
// Anonymous structure example
struct 
{
   char alpha;
   int num;
};</pre>
Since there is no variable and no name, we can directly access members. 
This accessibility works only inside the scope where the anonymous union is defined. 
Following is a complete working example of anonymous union.
<code class="comments">// C Program to demonstrate working of anonymous union </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">Scope </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Anonymous union </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">union</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">alpha; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Scope x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x.num = 65; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that members of union are accessed directly </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x.alpha = %c, x.num = %d"</code><code class="plain">, x.alpha, x.num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
x.alpha = A, x.num = 65</pre>
<code class="comments">// C Program to demonstrate working of anonymous struct </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">struct</code> <code class="plain">Scope </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Anonymous structure </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">alpha; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">num; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">Scope x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x.num = 65; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x.alpha = </code><code class="string">'B'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note that members of structure are accessed directly </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x.alpha = %c, x.num = %d"</code><code class="plain">, x.alpha, x.num); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
x.alpha = B, x.num = 65</pre>
<strong>What about C++?</strong><br />
Anonymous Unions and Structures are NOT part of C++ 11 standard, but most of the C++ compilers support them. 
Since this is a C only feature, the C++ implementations don&#8217;t allow to anonymous struct/union to have private or protected members, static members, and functions. 
<h2>Compound Literals in C</h2>
Consider below program in C.
<code class="comments">// Please make sure that you compile this program </code>
<code class="comments">// using a C compiler, not a C++ compiler (Save your </code>
<code class="comments">// file .cpp). 
If using online compiler, select "C" </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Compound literal (an array is created without </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// any name and address of first element is assigned </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// to p.&nbsp; This is equivalent to: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// int arr[] = {2, 4, 6}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// int *p = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = (</code><code class="color1 bold">int</code> <code class="plain">[]){2, 4, 6}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d %d"</code><code class="plain">, p[0], p[1], p[2]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>2 4 6</pre>
The above example is an example of compound literals. 
Compound literals were introduced in <a href="https://en.wikipedia.org/wiki/C99">C99 standard of C</a>. 
Compound literals feature allows us to create unnamed objects with given list of initialized values. 
In the above example, an array is created without any name. 
Address of first element of array is assigned to pointer p.
<strong>What is the use of it?</strong><br />
Compound literals are mainly used with structures and are particularly useful when passing structures variables to functions. 
We can pass a structure object without defining it<br />
For example, consider the below code.
<code class="comments">// Please make sure that you compile this program </code>
<code class="comments">// using a C compiler, not a C++ compiler (Save your </code>
<code class="comments">// file .cpp). 
If using online compiler, select "C" </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Structure to represent a 2D point </code>
<code class="keyword bold">struct</code> <code class="plain">Point </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x, y; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Utility function to print point </code>
<code class="keyword bold">void</code> <code class="plain">printPoint(</code><code class="keyword bold">struct</code> <code class="plain">Point p) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d, %d"</code><code class="plain">, p.x, p.y); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling printPoint() without creating any temporary </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Point variable in main() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">printPoint((</code><code class="keyword bold">struct</code> <code class="plain">Point){2, 3}); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/*&nbsp; Without compound literal, above statement would have </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">been written as </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">struct Point temp = {2, 3}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">printPoint(temp);&nbsp; */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>2, 3</pre>
<h2>Memory Layout of C Programs</h2>
A typical memory representation of C program consists of following sections.<!--more-->
1. 
Text segment<br />
2. 
Initialized data segment<br />
3. 
Uninitialized data segment<br />
4. 
Stack<br />
5. 
Heap
<a href="https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg"><img class="aligncenter size-medium wp-image-14281" title="Memory-Layout" src="https://media.geeksforgeeks.org/wp-content/uploads/memoryLayoutC.jpg" alt=""></a>
<br />
A typical memory layout of a running process
<strong>1. 
Text Segment:</strong><br />
A text segment , also known as a code segment or simply as text, is one of the sections of a program in an object file or in memory, which contains executable instructions.
As a memory region, a text segment may be placed below the heap or stack in order to prevent heaps and stack overflows from overwriting it.

Usually, the text segment is sharable so that only a single copy needs to be in memory for frequently executed programs, such as text editors, the C compiler, the shells, and so on. 
Also, the text segment is often read-only, to prevent a program from accidentally modifying its instructions.
<strong>2. 
Initialized Data Segment:</strong><br />
Initialized data segment, usually called simply the Data Segment. 
A data segment is a portion of virtual address space of a program, which contains the global variables and static variables that are initialized by the programmer.
Note that, data segment is not read-only, since the values of the variables can be altered at run time.
This segment can be further classified into initialized read-only area and initialized read-write area.
For instance the global string defined by char s[] = “hello world” in C and a C statement like int debug=1 outside the main (i.e. 
global) would be stored in initialized read-write area. 
And a global C statement like const char* string = “hello world” makes the string literal “hello world” to be stored in initialized read-only area and the character pointer variable string in initialized read-write area.
Ex: static int i = 10 will be stored in data segment and global int i = 10 will also be stored in data segment
<strong>3. 
Uninitialized Data Segment:</strong><br />
Uninitialized data segment, often called the “bss” segment, named after an ancient assembler operator that stood for “block started by symbol.” Data in this segment is initialized by the kernel to arithmetic 0 before the program starts executing
uninitialized data starts at the end of the data segment and contains all global variables and static variables that are initialized to zero or do not have explicit initialization in source code.
For instance a variable declared static int i; would be contained in the BSS segment.<br />
For instance a global variable declared int j; would be contained in the BSS segment.
<strong>4. 
Stack:</strong><br />
The stack area traditionally adjoined the heap area and grew the opposite direction; when the stack pointer met the heap pointer, free memory was exhausted. 
(With modern large address spaces and virtual memory techniques they may be placed almost anywhere, but they still typically grow opposite directions.)
The stack area contains the program stack, a LIFO structure, typically located in the higher parts of memory. 
On the standard PC x86 computer architecture it grows toward address zero; on some other architectures it grows the opposite direction. 
A “stack pointer” register tracks the top of the stack; it is adjusted each time a value is “pushed” onto the stack. 
The set of values pushed for one function call is termed a “stack frame”; A stack frame consists at minimum of a return address.
Stack, where automatic variables are stored, along with information that is saved each time a function is called. 
Each time a function is called, the address of where to return to and certain information about the caller’s environment, such as some of the machine registers, are saved on the stack. 
The newly called function then allocates room on the stack for its automatic and temporary variables. 
This is how recursive functions in C can work. 
Each time a recursive function calls itself, a new stack frame is used, so one set of variables doesn’t interfere with the variables from another instance of the function.
<strong>5. 
Heap:</strong><br />
Heap is the segment where dynamic memory allocation usually takes place.
The heap area begins at the end of the BSS segment and grows to larger addresses from there.The Heap area is managed by malloc, realloc, and free, which may use the brk and sbrk system calls to adjust its size (note that the use of brk/sbrk and a single “heap area” is not required to fulfill the contract of malloc/realloc/free; they may also be implemented using mmap to reserve potentially non-contiguous regions of virtual memory into the process’ virtual address space). 
The Heap area is shared by all shared libraries and dynamically loaded modules in a process.
Examples.
The size(1) command reports the sizes (in bytes) of the text, data, and bss segments. 
( for more details please refer man page of size(1) )
1. 
Check the following simple C program
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@CentOS]$ gcc memory-layout.c -o memory-layout
[narendra@CentOS]$ size memory-layout
text       data        bss        dec        hex    filename
960        248          8       1216        4c0    memory-layout</pre>
2. 
Let us add one global variable in program, now check the size of bss (highlighted in red color).
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">global; </code><code class="comments">/* Uninitialized variable stored in bss*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@CentOS]$ gcc memory-layout.c -o memory-layout
[narendra@CentOS]$ size memory-layout
text       data        bss        dec        hex    filename
 960        248         <strong><span style="color: red;">12</span></strong>       1220        4c4    memory-layout</pre>
3. 
Let us add one static variable which is also stored in bss.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">global; </code><code class="comments">/* Uninitialized variable stored in bss*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i; </code><code class="comments">/* Uninitialized static variable stored in bss */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@CentOS]$ gcc memory-layout.c -o memory-layout
[narendra@CentOS]$ size memory-layout
text       data        bss        dec        hex    filename
 960        248         <strong><span style="color: red;">16</span></strong>       1224        4c8    memory-layout</pre>
4. 
Let us initialize the static variable which will then be stored in Data Segment (DS)
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">global; </code><code class="comments">/* Uninitialized variable stored in bss*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = 100; </code><code class="comments">/* Initialized static variable stored in DS*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@CentOS]$ gcc memory-layout.c -o memory-layout
[narendra@CentOS]$ size memory-layout
text       data        bss        dec        hex    filename
960         <strong><span style="color: red;">252         12</span></strong>       1224        4c8    memory-layout</pre>
5. 
Let us initialize the global variable which will then be stored in Data Segment (DS)
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">global = 10; </code><code class="comments">/* initialized global variable stored in DS*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">i = 100; </code><code class="comments">/* Initialized static variable stored in DS*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
[narendra@CentOS]$ gcc memory-layout.c -o memory-layout
[narendra@CentOS]$ size memory-layout
text       data        bss        dec        hex    filename
960         <strong><span style="color: red;">256          8</span></strong>       1224        4c8    memory-layout</pre>
<h2>How to deallocate memory without using free() in C?</h2>
<strong>Question:</strong> How to deallocate dynamically allocate memory without using “free()” function. 
<!--more-->
<strong>Solution:</strong> Standard library function <a href="http://www.cplusplus.com/reference/clibrary/cstdlib/realloc/">realloc()</a> can be used to deallocate previously allocated memory. 
Below is function declaration of &#8220;realloc()&#8221; from &#8220;stdlib.h&#8221;
<code class="keyword bold">void</code> <code class="plain">*</code><code class="functions bold">realloc</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*ptr, </code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
If &#8220;size&#8221; is zero, then call to realloc is equivalent to &#8220;free(ptr)&#8221;. 
And if &#8220;ptr&#8221; is NULL and size is non-zero then call to realloc is equivalent to &#8220;malloc(size)&#8221;.
Let us check with simple example.
<code class="comments">/* code with memory leak */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Check the leak summary with valgrind tool. 
It shows memory leak of 10 bytes, which is highlighed in red colour.
<pre>
  [narendra@ubuntu]$ valgrind –leak-check=full ./free
  ==1238== LEAK SUMMARY:
  <font color="red">==1238==    definitely lost: 10 bytes in 1 blocks.</font>
  ==1238==      possibly lost: 0 bytes in 0 blocks.
  ==1238==    still reachable: 0 bytes in 0 blocks.
  ==1238==         suppressed: 0 bytes in 0 blocks.
[narendra@ubuntu]$
</pre>
Let us modify the above code.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code><code class="plain">*) </code><code class="functions bold">malloc</code><code class="plain">(10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* we are calling realloc with size = 0 */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">realloc</code><code class="plain">(ptr, 0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Check the valgrind’s output. 
It shows no memory leaks are possible, highlighted in red color.
<pre>
  [narendra@ubuntu]$ valgrind –leak-check=full ./a.out
  ==1435== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 11 from 1)
  ==1435== malloc/free: in use at exit: 0 bytes in 0 blocks.
  ==1435== malloc/free: 1 allocs, 1 frees, 10 bytes allocated.
  ==1435== For counts of detected errors, rerun with: -v
  <font color="red">==1435== All heap blocks were freed — no leaks are possible.</font>
  [narendra@ubuntu]$
</pre>
<h2>Difference Between malloc() and calloc() with Examples</h2>
<b>Pre-requisite:</b> <a href="https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/">Dynamic Memory Allocation in C using malloc(), calloc(), free() and realloc()</a>
The name <strong>malloc</strong> and <strong>calloc()</strong> are library functions that allocate memory dynamically. 
It means that memory is allocated during runtime(execution of the program) from the heap segment.
<ul>
<li><strong>Initialization:</strong> malloc() allocates memory block of given size (in bytes) and returns a pointer to the beginning of the block. 
malloc() doesn&#8217;t initialize the allocated memory. 
If we try to access the content of memory block(before initializing) then we&#8217;ll get segmentation fault error(or maybe garbage values).
<code class="keyword bold">void</code><code class="plain">* </code><code class="functions bold">malloc</code><code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
calloc() allocates the memory and also initializes the allocated memory block to zero. 
If we try to access the content of these blocks then we&#8217;ll get 0. 

<code class="keyword bold">void</code><code class="plain">* </code><code class="functions bold">calloc</code><code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">num, </code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
</li>
<li><strong>Number of arguments:</strong> Unlike malloc(), calloc() takes two arguments:<br />
1) Number of blocks to be allocated.<br />
2) Size of each block.</li>
<li>
    <strong>Return Value:</strong> After successful allocation in malloc() and calloc(), a pointer to the block of memory is returned otherwise <strong>NULL</strong> value is returned which indicates the failure of allocation.
</li>
For instance, If we want to allocate memory for array of 5 integers, see the following program:-
<code class="comments">// C program to demonstrate the use of calloc() </code>
<code class="comments">// and malloc() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code><code class="plain">* arr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// malloc() allocate the memory for 5 integers </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// containing garbage values </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(5 * </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code><code class="comments">// 5*4bytes = 20 bytes </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Deallocates memory previously allocated by malloc() function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(arr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calloc() allocate the memory for 5 integers and </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// set 0 to all of them </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr = (</code><code class="color1 bold">int</code><code class="plain">*)</code><code class="functions bold">calloc</code><code class="plain">(5, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Deallocates memory previously allocated by calloc() function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(arr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
<em>We can achieve same functionality as calloc() by using malloc() followed by memset(), </em>
<code class="plain">ptr = </code><code class="functions bold">malloc</code><code class="plain">(size); </code>
<code class="functions bold">memset</code><code class="plain">(ptr, 0, size); </code>
<blockquote>
<strong>Note: <em>It would be better to use malloc over calloc, unless we want the zero-initialization because malloc is faster than calloc. 
So if we just want to copy some stuff or do something that doesn&#8217;t require filling of the blocks with zeros, then malloc would be a better choice.</strong></em></blockquote>
</li>
<h2>How does free() know the size of memory to be deallocated?</h2>
Consider the following prototype of <em><a href="http://www.cplusplus.com/reference/clibrary/cstdlib/free/">free()</a></em> function which is used to free memory allocated using <em>malloc() </em>or <em>calloc()</em> or <em>realloc()</em>.<!--more-->
<code class="keyword bold">void</code> <code class="functions bold">free</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*ptr); </code>
Note that the free function does not accept size as a parameter. 
How does free() function know how much memory to free given just a pointer?
Following is the most common way to store size of memory so that free() knows the size of memory to be deallocated.<br />
<em>When memory allocation is done, the actual heap space allocated is one word larger than the requested memory. 
The extra word is used to store the size of the allocation and is later used by free( )</em>
Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.
<h2>Use of realloc()</h2>
Size of dynamically allocated memory can be changed by using realloc(). 
As per the C99 standard: <!--more-->
<code class="keyword bold">void</code> <code class="plain">*</code><code class="functions bold">realloc</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*ptr, </code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
<em>realloc deallocates the old object pointed to by ptr and returns a pointer to a new object that has the size specified by size. 
The contents of the new object is identical to that of the old object prior to deallocation, up to the lesser of the new and old sizes. 
Any bytes in the new object beyond the size of the old object have indeterminate values.<br />
</em>
The point to note is that <strong>realloc() should only be used for dynamically allocated memory</strong>. 
If the memory is not dynamically allocated, then behavior is undefined.<br />
For example, program 1 demonstrates incorrect use of realloc() and program 2 demonstrates correct use of realloc().
<strong>Program 1:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[2], i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr_new; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0] = 10;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[1] = 20;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// incorrect use of new_ptr: undefined behaviour </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr_new = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">realloc</code><code class="plain">(ptr, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)*3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*(ptr_new + 2) = 30; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, *(ptr_new + i)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
Undefined Behavior
<strong><br />
Program 2:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)*2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr_new; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*ptr = 10;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*(ptr + 1) = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr_new = (</code><code class="color1 bold">int</code> <code class="plain">*)</code><code class="functions bold">realloc</code><code class="plain">(ptr, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)*3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">*(ptr_new + 2) = 30; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, *(ptr_new + i)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
<em>10 20 30</em>
<h2>What is Memory Leak?  How can we avoid?</h2>
Memory leak occurs when programmers create a memory in heap and forget to delete it.<br />
Memory leaks are particularly serious issues for programs like daemons and servers which by definition never terminate.
<code class="comments">/* Function with memory leak */</code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">f() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code> <code class="plain">*) </code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Do some work */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code><code class="comments">/* Return without freeing ptr*/</code>
<code class="plain">} </code>
To avoid memory leaks, memory allocated on heap should always be freed when no longer needed.
<code class="comments">/* Function without memory leak */</code>
<code class="preprocessor">#include &lt;stdlib.h>; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">f() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*ptr = (</code><code class="color1 bold">int</code> <code class="plain">*) </code><code class="functions bold">malloc</code><code class="plain">(</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Do some work */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">free</code><code class="plain">(ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
<h2>fseek() vs rewind() in C</h2>
In C,  fseek() should be preferred over rewind().<!--more-->
Note the following text C99 standard:<br />
<em>The rewind function sets the file position indicator for the stream pointed to by stream to the beginning of the file. 
It is equivalent to </em> 
<code class="plain">(</code><code class="keyword bold">void</code><code class="plain">)</code><code class="functions bold">fseek</code><code class="plain">(stream, 0L, SEEK_SET)</code>
                <em>except that the error indicator for the stream is also cleared.</em>
This following code example sets the file position indicator of an input stream back to the beginning using rewind(). 
But there is no way to check whether the rewind() was successful.
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( fp == NULL ) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Handle open error */</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Do some processing with file*/</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">rewind</code><code class="plain">(fp);&nbsp; </code><code class="comments">/* no way to check if rewind is successful */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Do some more precessing with file */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>In the above code, fseek() can be used instead of rewind() to see if the operation succeeded. 
Following lines of code can be used in place of rewind(fp); </strong> 
<code class="keyword bold">if</code> <code class="plain">( </code><code class="functions bold">fseek</code><code class="plain">(fp, 0L, SEEK_SET) != 0 ) { </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">/* Handle repositioning error */</code>
<code class="plain">} </code>
<strong>Source:</strong><a href=" https://www.securecoding.cert.org/confluence/display/seccode/FIO07-C.+Prefer+fseek%28%29+to+rewind%28%29"><br />
https://www.securecoding.cert.org/confluence/display/seccode/FIO07-C.+Prefer+fseek%28%29+to+rewind%28%29</a>
<h2>EOF, getc() and feof() in C</h2>
In C/C++, <a href="http://www.cplusplus.com/reference/clibrary/cstdio/getc/">getc() </a>returns EOF when end of file is reached. 
getc() also returns EOF when it fails. 
So, only comparing the value returned by getc() with EOF is not sufficient to check for actual end of file. 
<!--more--> To solve this problem, C provides <a href="http://en.wikipedia.org/wiki/Feof">feof()</a> which returns non-zero value only if end of file has reached, otherwise it returns 0.<br />
For example, consider the following C program to print contents of file <em>test.txt</em> on screen. 
In the program, returned value of getc() is compared with EOF first, then there is another check using feof(). 
By putting this check, we make sure that the program prints <em>&#8220;End of file reached&#8221;</em> only if end of file is reached. 
And if getc() returns EOF due to any other reason, then the program prints <em>&#8220;Something went wrong&#8221;</em>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ch = </code><code class="functions bold">getc</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(ch != EOF)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* display contents of file on screen */</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(ch);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ch = </code><code class="functions bold">getc</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">feof</code><code class="plain">(fp)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n End of file reached."</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Something went wrong."</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>fopen() for an existing file in write mode</h2>
In C, <a href="http://www.cplusplus.com/reference/cstdio/fopen/">fopen()</a> is used to open a file in different modes. 
To open a file in write mode, &#8220;w&#8221; is specified. 
<!--more--> When mode &#8220;w&#8221; is specified, it creates an empty file for output operations. 
<strong>What if the file already exists?</strong><br />
If a file with the same name already exists, its contents are discarded and the file is treated as a new empty file. 
For example, in the following program, if &#8220;test.txt&#8221; already exists, its contents are removed and &#8220;GeeksforGeeks&#8221; is written to it.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Couldn't open file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"GeeksforGeeks"</code><code class="plain">, fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Done"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
The above behavior may lead to unexpected results. 
If programmer&#8217;s intention was to create a new file and a file with same name already exists, the existing file&#8217;s contents are overwritten.
The latest C standard <a href="http://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11 </a>provides a new mode &#8220;x&#8221; which is exclusive create-and-open mode. 
Mode &#8220;x&#8221; can be used with any &#8220;w&#8221; specifier, like &#8220;wx&#8221;, &#8220;wbx&#8221;. 
<strong>When x is used with w, fopen() returns NULL if file already exists or could not open.</strong>  Following is modified C11 program that doesn&#8217;t overwrite an existing file. 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">, </code><code class="string">"wx"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Couldn't open file or file already exists"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"GeeksforGeeks"</code><code class="plain">, fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Done"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<h2>Read/Write structure to a file in C</h2>
<!-- Problem Statement --><br />
Prerequisite: <a href="https://www.geeksforgeeks.org/structures-c/">Structure in C</a>
For writing in file, it is easy to write string or int to file using  <strong>fprintf</strong> and <strong>putc</strong>, but you might have faced difficulty when writing contents of struct. 
<strong>fwrite</strong> and <strong>fread</strong> make task easier when you want to write and read blocks of data.
<ol>
<li><strong>fwrite : </strong> Following is the declaration of fwrite function
<pre><strong>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</strong>
<strong>ptr</strong> - This is pointer to array of elements to be written
<strong>size</strong> -  This is the size in bytes of each element to be written
<strong>nmemb</strong> - This is the number of elements, each one with a size of size bytes
<strong>stream</strong> - This is the pointer to a FILE object that specifies an output stream
</pre>
<code class="comments">// C program for writing&nbsp; </code>
<code class="comments">// struct to file </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// a struct to read and write </code>
<code class="keyword bold">struct</code> <code class="plain">person&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">fname[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">lname[20]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*outfile; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// open file for writing </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">outfile = </code><code class="functions bold">fopen</code> <code class="plain">(</code><code class="string">"person.dat"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(outfile == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(stderr, </code><code class="string">"\nError opend file\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code> <code class="plain">(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">person input1 = {1, </code><code class="string">"rohan"</code><code class="plain">, </code><code class="string">"sharma"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">person input2 = {2, </code><code class="string">"mahendra"</code><code class="plain">, </code><code class="string">"dhoni"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// write struct to file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fwrite</code> <code class="plain">(&input1, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">person), 1, outfile); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fwrite</code> <code class="plain">(&input2, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">person), 1, outfile); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(</code><code class="functions bold">fwrite</code> <code class="plain">!= 0)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"contents to file written successfully !\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"error writing file !\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// close file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code> <code class="plain">(outfile); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>gcc demowrite.c
./a.out
contents to file written successfully!
</pre>
</li>
<li><strong>fread : </strong>Following is the declaration of fread function
<pre><strong>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</strong>
<strong>ptr</strong> - This is the pointer to a block of memory with a minimum size of size*nmemb bytes.
<strong>size</strong> - This is the size in bytes of each element to be read.
<strong>nmemb</strong> - This is the number of elements, each one with a size of size bytes.
<strong>stream</strong> - This is the pointer to a FILE object that specifies an input stream.</pre>
<code class="comments">// C program for reading&nbsp; </code>
<code class="comments">// struct from a file </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// struct person with 3 fields </code>
<code class="keyword bold">struct</code> <code class="plain">person&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">fname[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">lname[20]; </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*infile; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">struct</code> <code class="plain">person input; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open person.dat for reading </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">infile = </code><code class="functions bold">fopen</code> <code class="plain">(</code><code class="string">"person.dat"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(infile == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(stderr, </code><code class="string">"\nError opening file\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code> <code class="plain">(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// read file contents till end of file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">(</code><code class="functions bold">fread</code><code class="plain">(&input, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">struct</code> <code class="plain">person), 1, infile)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"id = %d name = %s %s\n"</code><code class="plain">, input.id, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">input.fname, input.lname); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// close file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code> <code class="plain">(infile); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>gcc demoread.c
./a.out
id = 1   name = rohan sharma
id = 2   name = mahendra dhoni
</pre></li></ol>
<h2>fgets() and gets() in C language</h2>
For reading a string value with spaces, we can use either gets() or fgets() in C programming language. 
Here, we will see what is the difference between gets() and fgets().
<p align="center"><strong>fgets()</strong>
It reads a line from the specified stream and stores it into the string pointed to by str. 
It stops when either (n-1) characters are read, the newline character is read, or the end-of-file is reached, whichever comes first.<br />
<strong>Syntax :</strong>
<pre><strong>char *fgets(char *str, int n, FILE *stream)</strong>
<strong>str :</strong> Pointer to an array of chars where the string read is copied.
<strong>n :</strong> Maximum number of characters to be copied into str 
(including the terminating null-character).
<strong>*stream :</strong> Pointer to a FILE object that identifies an input stream.
stdin can be used as argument to read from the standard input.
<strong>returns : </strong>the function returns str
</pre>
<ul>
<li>It follow some parameter such as Maximum length, buffer, input device reference.</li>
<li>It is <strong>safe </strong>to use because it checks the array bound.</li>
<li>It keep on reading until new line character encountered or maximum limit of character array.</li>
</ul>
Example : Let&#8217;s say the maximum number of characters are 15 and input length is greater than 15 but still fgets() will read only 15 character and print it.
<code class="comments">// C program to illustrate </code>
<code class="comments">// fgets() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define MAX 15 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">buf[MAX]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fgets</code><code class="plain">(buf, MAX, stdin); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"string is: %s\n"</code><code class="plain">, buf); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Since fgets() reads input from user, we need to provide input during runtime.
<pre>
Input:
Hello and welcome to GeeksforGeeks
Output:
Hello and welc
</pre>
<p align="center"><strong>gets()</strong>
Reads characters from the standard input (stdin) and stores them as a C string into str until a newline character or the end-of-file is reached.<br />
<strong>Syntax:</strong>
<pre><strong>char * gets ( char * str );</strong>
<strong>str :</strong>Pointer to a block of memory (array of char) 
where the string read is copied as a C string.
<strong>returns : </strong>the function returns str
 </pre>
<ul>
<li>It is not safe to use because it does not check the array bound. 
</li>
<li>It is used to read string from user until newline character not encountered.</li>
</ul>
Example : Suppose we have a character array of 15 characters and input is greater than 15 characters, gets() will read all these characters and store them into variable.Since, gets() do not check the maximum limit of input characters, so at any time compiler may return buffer overflow error.
<code class="comments">// C program to illustrate </code>
<code class="comments">// gets() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define MAX 15 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">buf[MAX]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a string: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">gets</code><code class="plain">(buf); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"string is: %s\n"</code><code class="plain">, buf); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Since gets() reads input from user, we need to provide input during runtime.
<pre>
Input:
Hello and welcome to GeeksforGeeks
Output:
Hello and welcome to GeeksforGeeks
</pre>
<h2>Basics of File Handling in C</h2>
So far the operations using C program are done on a prompt / terminal which is not stored anywhere. 
But in the software industry, most of the programs are written to store the information fetched from the program. 
One such way is to store the fetched information in a file. 
Different operations that can be performed on a file are:
<ol>
<li>Creation of a new file (<strong>fopen with attributes as “a” or “a+” or “w” or “w++”)</strong></li>
<li>Opening an existing file (<strong>fopen</strong>)</li>
<li>Reading from file (<strong>fscanf or fgetc</strong>)</li>
<li>Writing to a file (<strong>fprintf or fputs</strong>)</li>
<li>Moving to a specific location in a file (<strong>fseek, rewind</strong>)</li>
<li>Closing a file (<strong>fclose</strong>)</li>
</ol>
The text in the brackets denotes the functions used for performing those operations.
<b>Functions in File Operations:</b><br />
<img src="https://media.geeksforgeeks.org/wp-content/uploads/File-functions.jpg" alt="">
<strong>Opening or creating file</strong><br />
For opening a file, fopen function is used with the required access modes. 
Some of the commonly used file access modes are mentioned below.
<b>File opening modes in C:</b>
<ul>
<li><b>“r” &#8211;</b> Searches file. 
If the file is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the first character in it. 
If the file cannot be opened fopen( ) returns NULL.</li>
<li><b>“w” &#8211;</b> Searches file. 
If the file exists, its contents are overwritten. 
If the file doesn’t exist, a new file is created. 
Returns NULL, if unable to open file.</li>
<li><b>&#8220;a&#8221; &#8211;</b> Searches file. 
If the file is opened successfully fopen( ) loads it into memory and sets up a pointer that points to the last character in it. 
If the file doesn’t exist, a new file is created. 
Returns NULL, if unable to open file.</li>
<li><b>&#8220;r+&#8221; &#8211;</b> Searches file. 
If is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the first character in it. 
Returns NULL, if unable to open the file.</li>
<li><b>&#8220;w+&#8221; &#8211;</b> Searches file. 
If the file exists, its contents are overwritten. 
If the file doesn’t exist a new file is created. 
Returns NULL, if unable to open file.</li>
<li><b>&#8220;a+&#8221; &#8211;</b> Searches file. 
If the file is opened successfully fopen( ) loads it into memory and sets up a pointer which points to the last character in it. 
If the file doesn’t exist, a new file is created. 
Returns NULL, if unable to open file.</li>
</ul>
As given above, if you want to perform operations on a binary file, then you have to append &#8216;b&#8217; at the last. 
For example, instead of “w”, you have to use “wb”, instead of “a+” you have to use “a+b”. 
For performing the operations on the file, a special pointer called File pointer is used which is declared as
<pre class="prettyprint lang-c">FILE *filePointer; 
So, the file can be opened as 
filePointer = fopen(“fileName.txt”, “w”)
</pre>
The second parameter can be changed to contain all the attributes listed in the above table.
<ul>
<li><strong>Reading from a file &#8211;</strong><br />
The file read operations can be performed using functions fscanf or fgets. 
Both the functions performed the same operations as that of scanf and gets but with an additional parameter, the file pointer. 
So, it depends on you if you want to read the file line by line or character by character.
And the code snippet for reading a file is as:
<pre class="prettyprint lang-c">FILE * filePointer; 
filePointer = fopen(“fileName.txt”, “r”);
fscanf(filePointer, "%s %s %s %d", str1, str2, str3, &amp;year);
</pre>
</li>
<li><strong>Writing a file &#8211;</strong>:
The file write operations can be perfomed by the functions fprintf and fputs with similarities to read operations. 
The snippet for writing to a file is as :
<pre class="prettyprint lang-c">FILE *filePointer ; 
filePointer = fopen(“fileName.txt”, “w”);
fprintf(filePointer, "%s %s %s %d", "We", "are", "in", 2012);
</pre>
</li>
<li><strong>Closing a file &#8211;</strong>:<br />
After every successful fie operations, you must always close a file. 
For closing a file, you have to use fclose function. 
The snippet for closing a file is given as :
<pre class="prettyprint lang-c">FILE *filePointer ; 
filePointer= fopen(“fileName.txt”, “w”);
---------- Some file Operations -------
fclose(filePointer)</pre>
</li>
<b>Example 1:</b> Program to Open a File, Write in it, And Close the File
<code class="comments">// C program to Open a File, </code>
<code class="comments">// Write in it, And Close the File </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor"># include &lt;stdio.h> </code>
<code class="preprocessor"># include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main( ) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare the file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*filePointer ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get the data to be written in file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">dataToBeWritten[50]&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">= </code><code class="string">"GeeksforGeeks-A Computer Science Portal for Geeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open the existing file GfgTest.c using fopen() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// in write mode using "w" attribute </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">filePointer = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"GfgTest.c"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Check if this filePointer is null </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// which maybe if the file does not exist </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( filePointer == NULL ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"GfgTest.c file failed to open."</code> <code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The file is now opened.\n"</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Write the dataToBeWritten into the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( </code><code class="functions bold">strlen</code> <code class="plain">(&nbsp; dataToBeWritten&nbsp; ) > 0 ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// writing in the file using fputs() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(dataToBeWritten, filePointer) ;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">, filePointer) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Closing the file using fclose() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(filePointer) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Data successfully written in file GfgTest.c\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The file is now closed."</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
<b>Example 2:</b> Program to Open a File, Read from it, And Close the File
<code class="comments">// C program to Open a File, </code>
<code class="comments">// Read from it, And Close the File </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor"># include &lt;stdio.h> </code>
<code class="preprocessor"># include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main( ) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare the file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*filePointer ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declare the variable for the data to be read from file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">dataToBeRead[50]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open the existing file GfgTest.c using fopen() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// in read mode using "r" attribute </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">filePointer = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"GfgTest.c"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Check if this filePointer is null </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// which maybe if the file does not exist </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( filePointer == NULL ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"GfgTest.c file failed to open."</code> <code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The file is now opened.\n"</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Read the dataToBeRead from the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using fgets() method </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">( </code><code class="functions bold">fgets</code> <code class="plain">( dataToBeRead, 50, filePointer ) != NULL ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Print the dataToBeRead&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"%s"</code> <code class="plain">, dataToBeRead ) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Closing the file using fclose() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(filePointer) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Data successfully read from file GfgTest.c\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The file is now closed."</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
<h2>fsetpos() (Set File Position) in C</h2>
The <strong>fsetpos()</strong> function moves the file position indicator to the location specified by the object pointed to by position. 
When <strong>fsetpos()</strong> is executed ,the end-of-file indecator is reset.
<strong>Declaration</strong>
<pre>
<code>
int fsetpos(FILE *stream, const fpos_t *position)
</code></pre>
<strong>Parameters &#8211;</strong>
<ul>
<li><strong>stream &#8211;</strong> This is the pointer to a FILE object that identifies the stream.</li>
<li><strong>position &#8211;</strong> This is the pointer to a fpos_t object containing a position previously obtained with fgetpos.</li>
</ul>
<strong>Return &#8211;</strong> If it successful, it return <strong> zero</strong> otherwise returns nonzero value.
<code class="comments">// c code to demonstrate fsetpos() function. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main () { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">fpos_t</code> <code class="plain">position; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">/*write your own file name. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">My file name is "myfile.txt"*/</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"myfile.txt"</code><code class="plain">,</code><code class="string">"w+"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fgetpos</code><code class="plain">(fp, &position); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"HelloWorld!"</code><code class="plain">, fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fsetpos</code><code class="plain">(fp, &position); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// previous function is override </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"geeksforgeeks"</code><code class="plain">, fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
<b>Output &#8211;</b>
<pre>
geeksforgeeks
</pre>
<h2>rename function in C/C++</h2>
rename() function is used to change the name of the file or directory i.e. 
from <strong>old_name</strong> to <strong>new_name</strong> without changing the content present in the file. 
This function takes name of the file as its argument.<br />
If <strong>new_name</strong> is the name of an existing file in the same folder then the function may either fail or override the existing file, depending on the specific system and library implementation.<br />
<strong>Syntax:</strong>
<pre>
<strong>int rename (const char *old_name, const char *new_name);</strong>
<strong>Parameters:</strong>
<strong>old_name :</strong> Name of an existing file to be renamed.
<strong>new_name :</strong> String containing new name of the file.
</pre>
<strong>Return:</strong><br />
Return type of function is an integer. 
If the file is renamed successfully, zero is returned. 
On failure, a nonzero value is returned.
Assume that we have a text file having name <strong>geeks.txt</strong>, having some content. 
So, we are going to rename this file, using the below C program present in the same folder where this file is present.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/Before_running_code-1.png" alt="">
<code class="comments">// C program to demonstrate use of rename() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Old file name </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">old_name[] = </code><code class="string">"geeks.txt"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Any string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">new_name[] = </code><code class="string">"geeksforgeeks.txt"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">value; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// File name is changed here </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">value = </code><code class="functions bold">rename</code><code class="plain">(old_name, new_name); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Print the result </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(!value) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, </code><code class="string">"File name changed successfully"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">perror</code><code class="plain">(</code><code class="string">"Error"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
If file name changed
<strong>File name changed successfully</strong>
            OR
If file name not changed
<strong>Error: No such file or directory</strong>
</pre>
<img src="https://media.geeksforgeeks.org/wp-content/uploads/After_running_code-1.png" alt="">
<h2>tmpfile() function in C</h2>
In <a href="https://www.geeksforgeeks.org/c/">C Programming Language</a>, the tmpfile() function is used to produce/create a temporary file. 
<ul>
<li>tmpfile() function is defined in the &#8220;stdio.h&#8221; header file.</li>
<li>The created temporary file will automatically be deleted after the termination of program.</li>
<li>It opens file in binary update mode i.e., wb+ mode.</li>
<li>The syntax of tmpfile() function is:
<pre>FILE *tmpfile(void) </pre>
</li>
<li>  The tmpfile() function always returns a pointer after the creation of file to the temporary file. 
If by chance temporary file can not be created, then the tmpfile() function returns NULL pointer.</li>
</ul>
<code class="comments">// C program to demonstrate working of tmpfile() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[] = </code><code class="string">"Hello GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code><code class="plain">* tmp = </code><code class="functions bold">tmpfile</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(tmp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Unable to create temp file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Temporary file is created\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(str[i] != </code><code class="string">'&#092;&#048;'</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputc</code><code class="plain">(str[i], tmp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// rewind() function sets the file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// at the beginning of the stream. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">rewind</code><code class="plain">(tmp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(!</code><code class="functions bold">feof</code><code class="plain">(tmp)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(</code><code class="functions bold">fgetc</code><code class="plain">(tmp)); </code>
<code class="plain">} </code>
Output:
<pre>
Temporary file is created
Hello GeeksforGeeks
</pre>
<h2>fgetc() and fputc() in C</h2>
<p align="center"><strong>fgetc() </strong>
fgetc() is used to obtain input from a file single character at a time. 
This function returns the number of characters read by the function. 
It returns the character present at position indicated by file pointer. 
After reading the character, the file pointer is advanced to next character. 
If pointer is at end of file or if an error occurs EOF file is returned by this function.<br />
<strong>Syntax:<br />
</strong>
<pre>
<strong>int fgetc(FILE *pointer)
pointer:</strong> pointer to a FILE object that identifies 
the stream on which the operation is to be performed.
</pre>
<code class="comments">// C program to illustate fgetc() function </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// open the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">,</code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Return if could not open file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">do</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Taking input single character at a time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">c = </code><code class="functions bold">fgetc</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Checking for end of file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">feof</code><code class="plain">(fp)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code> <code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code><code class="keyword bold">while</code><code class="plain">(1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
The entire content of file is printed character by
character till end of file. 
It reads newline character
as well.
</pre>
<p align="center"><strong>Using fputc()</strong>
fputc() is used to write a single character at a time to a given file. 
It writes the given character at the position denoted by the file pointer and then advances the file pointer.<br />
This function returns the character that is written in case of successful write operation else in case of error EOF is returned.<br />
<strong>Syntax:<br />
</strong>
<pre>
<strong>int fputc(int char, FILE *pointer)
char: </strong> character to be written. 
This is passed as its int promotion.
<strong>pointer: </strong>pointer to a FILE object that identifies the 
stream where the character is to be written.
</pre>
<code class="comments">// C program to illustate fputc() function </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"output.txt"</code><code class="plain">,</code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Return if could not open file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">string[] = </code><code class="string">"good bye"</code><code class="plain">, received_string[20]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; string[i]!=</code><code class="string">'\0'</code><code class="plain">; i++) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Input string into the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// single character at a time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputc</code><code class="plain">(string[i], fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"output.txt"</code><code class="plain">,</code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Reading the string from file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fgets</code><code class="plain">(received_string,20,fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, received_string); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
<!-- Your Output -->good bye
</pre>
When fputc() is executed characters of string variable are written into the file one by one. 
When we read the line from the file we get the  same string that we entered.
<h2>fseek() in C/C++ with example</h2>
fseek() is used to move file pointer associated with a given file to a specific position.<br />
<strong>Syntax:</strong>
<pre>
<strong>int fseek(FILE *pointer, long int offset, int position)</strong>
<strong>pointer:</strong> pointer to a FILE object that identifies the stream.
<strong>offset: </strong>number of bytes to offset from position
<strong>position: </strong>position from where offset is added.
<strong>returns:</strong>
zero if successful, or else it returns a non-zero value 
</pre>
position defines the point with respect to which the file pointer needs to be moved. 
It has three values:<br />
SEEK_END : It denotes end of the file.<br />
SEEK_SET : It denotes starting of the file.<br />
SEEK_CUR : It denotes file pointer&#8217;s current position.
<code class="comments">// C Program to demonstrate the use of fseek() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Moving pointer to end </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fseek</code><code class="plain">(fp, 0, SEEK_END); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing position of pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%ld"</code><code class="plain">, </code><code class="functions bold">ftell</code><code class="plain">(fp)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
<!-- Your Output -->81
</pre>
<strong>Explanation</strong>
The file test.txt contains the following text:
<pre>"Someone over there is calling you.
we are going for work.
take care of yourself."</pre>
When we implement fseek() we move the pointer by 0 distance with respect to end of file i.e pointer now points to end of the file. 
Therefore the output is 81.
<strong>Related article:</strong> <a href="https://www.geeksforgeeks.org/g-fact-82/">fseek vs rewind in C</a>
<h2>ftell() in C with example</h2>
ftell() in C is used to find out the position of file pointer in the file with respect to starting of the file. 
Syntax of ftell() is: 
<pre>
long ftell(FILE *pointer)
</pre>
Consider below C program. 
The file taken in the example contains the following data :<br />
&#8220;Someone over there is calling you. 
We are going for work. 
Take care of yourself.&#8221; (without the quotes)<br />
When the fscanf statement is executed word &#8220;Someone&#8221; is stored in string and the pointer is moved beyond &#8220;Someone&#8221;. 
Therefore ftell(fp) returns 7 as length of &#8220;someone&#8221; is 6.
<code class="comments">// C program to demonstrate use of ftel()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Opening file in read mode */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"test.txt"</code><code class="plain">,</code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Reading first string */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">string[20];&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fscanf</code><code class="plain">(fp,</code><code class="string">"%s"</code><code class="plain">,string); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Printing position of file pointer */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%ld"</code><code class="plain">, </code><code class="functions bold">ftell</code><code class="plain">(fp)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : Assuming test.txt contains &#8220;Someone over there &#8230;.&#8221;.
<pre>
7
</pre>
<h2>lseek() in C/C++ to read the alternate nth byte and write it in another file</h2>
From a given file (e.g. 
input.txt) read the alternate nth byte and write it on another file with the help of “lseek”.<br />
<strong>lseek (C System Call)</strong>: lseek is a system call that is used to change the location of the read/write pointer of a file descriptor. 
The location can be set either in absolute or relative terms.<br />
<strong>Function Definition</strong>
<blockquote>off_t lseek(int fildes, off_t offset, int whence);
<strong>Field    Description</strong><br />
int fildes        :   The file descriptor of the pointer that is going to be moved<br />
off_t offset      :   The offset of the pointer (measured in bytes).<br />
int whence        :   The method in which the offset is to be interpreted<br />
(rela, absolute, etc.). 
Legal value r this variable are provided at the end.<br />
return value      :   Returns the offset of the pointer (in bytes) from the<br />
beginning of the file. 
If the return value is -1,<br />
then there was an error moving the pointer.<br/>
            </blockquote>
For example, say our Input file is as follows:<br />
<a href="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-03-29-22-24-46.png"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-03-29-22-24-46.png" alt="Screenshot from 2017-03-29 22-24-46"></a>
<code class="comments">// C program to read nth byte of a file and </code>
<code class="comments">// copy it to another file using lseek </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;fcntl.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">func(</code><code class="color1 bold">char</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open the file for READ only. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">f_write = open(</code><code class="string">"start.txt"</code><code class="plain">, O_RDONLY); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open the file for WRITE and READ only. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">f_read = open(</code><code class="string">"end.txt"</code><code class="plain">, O_WRONLY); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(read(f_write, arr, 1)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to write the 1st byte of the input file in </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the output file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(count &lt; n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// SEEK_CUR specifies that </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the offset provided is relative to the </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// current file position </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">lseek (f_write, n, SEEK_CUR); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">write (f_read, arr, 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count = n; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// After the nth byte (now taking the alternate </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// nth byte) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count = (2*n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">lseek(f_write, count, SEEK_CUR); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">write(f_read, arr, 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">close(f_write); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">close(f_read); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = 5; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calling for the function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">func(arr, n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output file (end.txt)</strong><br />
<a href="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-03-29-22-24-35.png"><img src="https://media.geeksforgeeks.org/wp-content/uploads/Screenshot-from-2017-03-29-22-24-35.png" alt="Screenshot from 2017-03-29 22-24-35"></a>
<h2>C program to delete a file</h2>
The <a href="http://www.cplusplus.com/reference/cstdio/remove/">remove </a>function in C/C++ can be used to delete a file. 
<!--more-->The function returns 0 if files is deleted successfully, other returns a non-zero value.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">remove</code><code class="plain">(</code><code class="string">"abc.txt"</code><code class="plain">) == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Deleted successfully"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Unable to delete the file"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
Using remove() function in C, we can write a program which can destroy itself after it is compiled and executed.
<b>Explanation:</b> This can be done using the <a href="https://www.geeksforgeeks.org/c-program-delete-file/">remove function</a> in C. 
Note that, this is done in Linux environment. 
So, the remove function is fed the first parameter in command line argument i.e. 
<b>a.out</b> file (executable file) created after compiling . 
Hence the program will be destroyed.<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">c, </code><code class="color1 bold">char</code> <code class="plain">*argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"By the time you will compile me I will be destroyed \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// array of pointers to command line arguments </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">remove</code><code class="plain">(argv[0]);&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">// Note: argv[0] will contain the executable file i.e. 
'a.out' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by&nbsp; MAZHAR IMAM KHAN. 
</code>
Output:
<pre>
By the time you will compile me I will be destroyed
</pre>
After the output shown above, the <b>a.out</b> file will be removed.<br />
</br><br />
<h2>C Program to merge contents of two files into a third file</h2>
Let the given two files be file1.txt and file2.txt. 
The following are steps to merge. 
<!--more--><br />
1) Open file1.txt and file2.txt in read mode.<br />
2) Open file3.txt in write mode.<br />
3) Run a loop to one by one copy characters of file1.txt to file3.txt.<br />
4) Run a loop to one by one copy characters of file2.txt to file3.txt.<br />
5) Close all files.
To successfully run the below program file1.txt and fil2.txt must exits in same folder.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open two files to be merged </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp1 = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"file1.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp2 = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"file2.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open file to store the result </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp3 = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"file3.txt"</code><code class="plain">, </code><code class="string">"w"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">c; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp1 == NULL || fp2 == NULL || fp3 == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Could not open files"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy contents of first file to file3.txt </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">((c = </code><code class="functions bold">fgetc</code><code class="plain">(fp1)) != EOF) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputc</code><code class="plain">(c, fp3); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy contents of second file to file3.txt </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">((c = </code><code class="functions bold">fgetc</code><code class="plain">(fp2)) != EOF) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputc</code><code class="plain">(c, fp3); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Merged file1.txt and file2.txt into file3.txt"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Merged file1.txt and file2.txt into file3.txt</pre>
<strong>Related Articles : </strong>
<ul>
<li><a href="https://www.geeksforgeeks.org/java-program-merge-two-files-alternatively-third-file/">Java program to merge two files alternatively into third file</a></li>
<li><a href="https://www.geeksforgeeks.org/java-program-merge-two-files-third-file/">Java program to merge two files into a third file</a></li>
</ul>
<h2>C Program to print contents of file</h2>
<a href="http://www.cplusplus.com/reference/cstdio/fopen/">fopen()</a> is used to open and <a href="http://www.cplusplus.com/reference/cstdio/fclose/">fclose()</a> is used to close a file in C 
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> // For exit() </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fptr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">filename[100], c; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter the filename to open \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, filename); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fptr = </code><code class="functions bold">fopen</code><code class="plain">(filename, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fptr == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Cannot open file \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Read contents from file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">c = </code><code class="functions bold">fgetc</code><code class="plain">(fptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(c != EOF) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%c"</code><code class="plain">, c); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">c = </code><code class="functions bold">fgetc</code><code class="plain">(fptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>Enter the filename to open
a.txt
/*Contents of a.txt*/</pre>
<h2>C Program to print numbers from 1 to N without using semicolon?</h2>
How to print numbers from 1 to N without using any semicolon in C.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define N 100 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Add your code here to print numbers from 1 </code>
<code class="comments">// to N without using any semicolon </code>
What code to add in above snippet such that it doesn&#8217;t contain semicolon and prints numbers from 1 to N?
<strong>We strongly recommend you to minimize your browser and try this yourself first</strong>
<strong>Method 1 (Recursive)</strong>
<code class="comments">// A recursive C program to print all numbers from 1 </code>
<code class="comments">// to N without semicolon </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define N 10 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">num) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num &lt;= N && </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, num) && main(num + 1)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 </pre>
See <a href="https://ide.geeksforgeeks.org/fXCLRM">this</a> for complete run. 
Thanks to Utkarsh Trivedi for suggesting this solution.
</br><br />
<strong>Method 2 (Iterative)</strong>
<code class="comments">// An iterative C program to print all numbers from 1 </code>
<code class="comments">// to N without semicoolon </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define N 10 </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">num, </code><code class="color1 bold">char</code> <code class="plain">*argv[]) </code>
<code class="plain">{ </code>
<code class="keyword bold">while</code> <code class="plain">(num &lt;= N && </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, num) && num++)&nbsp; </code>
<code class="plain">{ </code>
<code class="plain">}&nbsp; </code>
<code class="plain">} </code>
Output: 
<pre>1 2 3 4 5 6 7 8 9 10 </pre>
See <a href="https://ide.geeksforgeeks.org/1aB7Xo">this</a> for complete run. 
Thanks to Rahul Huria for suggesting this solution.
<strong>How do these solutions work?</strong><br />
main() function can receive arguments. 
The first argument is argument count whose value is 1 if no argument is passed to it. 
The first argument is always program name.
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">num, </code><code class="color1 bold">char</code> <code class="plain">*argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"num = %d\n"</code><code class="plain">, num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"argv[0] = %s "</code><code class="plain">, argv[0]); </code>
<code class="plain">} </code>
Output: 
<pre>num = 1 
argv[0] = &lt;file_name&gt;</pre>
<h2>How will you show memory representation of C variables?</h2>
Write a C program to show memory representation of C variables like int, float, pointer, etc. 
<strong>Algorithm:</strong><br />
Get the address and size of the variable. 
 Typecast the address to char pointer. 
Now loop for size of the variable and print the value at the typecasted pointer.
<!--more-->
<strong>Program:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="keyword bold">typedef</code> <code class="plain">unsigned </code><code class="color1 bold">char</code> <code class="plain">*byte_pointer; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/*show bytes takes byte pointer as an argument </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">and prints memory contents from byte_pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="comments">to byte_pointer + len */</code>
<code class="keyword bold">void</code> <code class="plain">show_bytes(byte_pointer start, </code><code class="color1 bold">int</code> <code class="plain">len)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; len; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %.2x"</code><code class="plain">, start[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">show_int(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_bytes((byte_pointer) &x, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">)); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">show_float(</code><code class="color1 bold">float</code> <code class="plain">x)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_bytes((byte_pointer) &x, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">)); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">show_pointer(</code><code class="keyword bold">void</code> <code class="plain">*x)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_bytes((byte_pointer) &x, </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="keyword bold">void</code> <code class="plain">*)); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Drover program to test above functions */</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">f = 1.0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*p = &i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_float(f); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_int(i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_pointer(p); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">show_int(i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h2>Condition To Print &#8220;HelloWord&#8221;</h2>
What should be the  &#8220;condition&#8221; so that the following code snippet prints both HelloWorld!
<!--more-->
<pre>
      if  "condition"
          printf ("Hello");
      else
          printf("World"); 
</pre>
<strong>Method 1:  </strong><br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(!</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello"</code><code class="plain">)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"World"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<strong>Explanation:</strong> Printf returns the number of character it has printed successfully. 
So, following solutions will also work
if (printf(&#8220;Hello&#8221;) < 0) or
if (printf("Hello") < 1) etc 
<strong>Method 2: Using <a href="https://www.geeksforgeeks.org/fork-system-call/">fork()</a>  </strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(fork()) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"World"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
This method is contributed by Aravind Alapati.
Please comment if you find more solutions of this.
<h2>Change/add only one character and print &#8216;*&#8217; exactly 20 times</h2>
In the below code, change/add only one character and print &#8216;*&#8217; exactly 20 times.<br />
<!--more-->
<pre>
int main()
{
    int i, n = 20;
    for (i = 0; i &lt; n; i--)
        printf(&quot;*&quot;);             
    getchar();
    return 0;
}
</pre>
<strong>Solutions:</strong>
<strong>1. 
Replace i by n in for loop&#8217;s third expression</strong><br />
<h3>C</h3>
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, n = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; n; n--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">();&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java code </code>
<code class="keyword">class</code> <code class="plain">GfG {&nbsp; </code>
<code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args)&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">i, n = </code><code class="value">20</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">for</code> <code class="plain">(i = </code><code class="value">0</code><code class="plain">; i &lt; n; n--)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.print(</code><code class="string">"*"</code><code class="plain">);&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="plain">}&nbsp; </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# code </code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="keyword">class</code> <code class="plain">GfG&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main()&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">i, n = 20;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">for</code> <code class="plain">(i = 0; i &lt; n; n--)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(</code><code class="string">"*"</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by SoumikMondal </code>
<strong>2. 
Put &#8216;-&#8216; before i in for loop&#8217;s second expression</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, n = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; -i &lt; n; i--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">();&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>3. 
Replace &lt; by + in for loop&#039;s second expression</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, n = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i + n; i--) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Let&#8217;s extend the problem little.</strong>
Change/add only one character and print &#8216;*&#8217; exactly 21 times.
Solution: Put negation operator before i in for loop&#8217;s second expression.
Explanation: Negation operator converts the number into its one&#8217;s complement. 
<pre>
       No. 
            One's complement
 0 (00000..00)            -1 (1111..11) 
-1 (11..1111)             0 (00..0000)
-2 (11..1110)             1 (00..0001)    
-3 (11..1101)             2 (00..0010)
...............................................
-20 (11..01100)           19 (00..10011)
</pre>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, n = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; ~i &lt; n; i--)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"*"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Please comment if you find more solutions of above problems.
<h2>Program for Sum of the digits of a given number</h2>
Given a number, find sum of its digits.
<strong>Examples : </strong>
<pre>
Input : n = 687
Output : 21
Input : n = 12
Output : 3
</pre>
<div id="practiceLinkDiv">
<h3>
            <a href="https://practice.geeksforgeeks.org/problems/sum-of-digit-is-pallindrome-or-not/0">Recommended: Please solve it on &#8220;<b><i><u>PRACTICE</u></i></b> &#8221; first, before moving on to the solution.</a><br />
        </h3>
<b>General Algorithm for sum of digits in a given number:</b>
<ol>
<li>Get the number</li>
<li>Declare a variable to store the sum and set it to 0</li>
<li>Repeat the next two steps till the number is not 0</li>
<li>Get the rightmost digit of the number with help of remainder &#8216;%&#8217; operator by dividing it with 10 and add it to sum.</li>
<li>Divide the number by 10 with help of &#8216;/&#8217; operator</li>
<li>Print or return the sum</li>
</ol>
Below are the solutions to get sum of the digits. 
<!--more--><br />
<strong>1. 
Iterative:</strong>
<h3>C++</h3>
<code class="comments">// C program to compute sum of digits in&nbsp; </code>
<code class="comments">// number. 
</code>
<code class="preprocessor"># include&lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="comments">/* Function to get sum of digits */</code>
<code class="keyword bold">class</code> <code class="plain">gfg </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">public</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">getSum(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sum = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(n != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sum = sum + n % 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = n/10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="comments">//driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">gfg g; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">cout&lt;&lt; g.getSum(n); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Soumik </code>
<h3>C</h3>
<code class="comments">// C program to compute sum of digits in&nbsp; </code>
<code class="comments">// number. 
</code>
<code class="preprocessor"># include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Function to get sum of digits */</code>
<code class="color1 bold">int</code> <code class="plain">getSum(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sum = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(n != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sum = sum + n % 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = n/10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">sum; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code><code class="plain">, getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to compute&nbsp; </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">import</code> <code class="plain">java.io.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Function to get sum of digits */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">getSum(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">sum = </code><code class="value">0</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code> <code class="plain">(n != </code><code class="value">0</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sum = sum + n % </code><code class="value">10</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = n/</code><code class="value">10</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver program </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">687</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println(getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Gitanjali </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python 3 program to </code>
<code class="comments"># compute sum of digits in&nbsp; </code>
<code class="comments"># number. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># Function to get sum of digits&nbsp; </code>
<code class="keyword">def</code> <code class="plain">getSum(n): </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">sum</code> <code class="keyword">=</code> <code class="value">0</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code> <code class="plain">(n !</code><code class="keyword">=</code> <code class="value">0</code><code class="plain">): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">sum</code> <code class="keyword">=</code> <code class="functions">sum</code> <code class="keyword">+</code> <code class="functions">int</code><code class="plain">(n </code><code class="keyword">%</code> <code class="value">10</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n </code><code class="keyword">=</code> <code class="functions">int</code><code class="plain">(n</code><code class="keyword">/</code><code class="value">10</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="functions">sum</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">n </code><code class="keyword">=</code> <code class="value">687</code>
<code class="functions">print</code><code class="plain">(getSum(n)) </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# program to compute&nbsp; </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Function to get sum of digits */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">getSum(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">sum = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code> <code class="plain">(n != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sum = sum + n % 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = n/10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver program </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Sam007 </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP Code to compute sum&nbsp; </code>
<code class="comments">// of digits in number. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to get&nbsp; </code>
<code class="comments">// $sum of digits&nbsp; </code>
<code class="keyword">function</code> <code class="plain">getsum(</code><code class="variable">$n</code><code class="plain">) </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$sum</code> <code class="plain">= 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code> <code class="plain">(</code><code class="variable">$n</code> <code class="plain">!= 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$sum</code> <code class="plain">= </code><code class="variable">$sum</code> <code class="plain">+ </code><code class="variable">$n</code> <code class="plain">% 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$n</code> <code class="plain">= </code><code class="variable">$n</code><code class="plain">/10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="variable">$sum</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="variable">$n</code> <code class="plain">= 687; </code>
<code class="variable">$res</code> <code class="plain">= getsum(</code><code class="variable">$n</code><code class="plain">); </code>
<code class="functions">echo</code><code class="plain">(</code><code class="string">"$res"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by&nbsp; </code>
<code class="comments">// Smitha Dinesh Semwal. 
</code>
<code class="plain">?> </code>
<br />
Output : 
<pre>21</pre>
<strong>How to compute in single line?</strong><br />
Below function has three lines instead of one line but it calculates sum in line. 
It can be made one line function if we pass pointer to sum.<br />
<h3>C++</h3>
<code class="preprocessor"># include&lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="comments">/* Function to get sum of digits */</code>
<code class="keyword bold">class</code> <code class="plain">gfg </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">public</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">getSum(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Single line that calculates sum */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(sum = 0; n > 0; sum += n % 10, n /= 10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">gfg g;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">cout&lt;&lt; g.getSum(n); </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="comments">//This code is contributed by Soumik </code>
<h3>C</h3>
<code class="preprocessor"># include&lt;stdio.h> </code>
<code class="comments">/* Function to get sum of digits */</code>
<code class="color1 bold">int</code> <code class="plain">getSum(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Single line that calculates sum */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(sum = 0; n > 0; sum += n % 10, n /= 10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">sum; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %d "</code><code class="plain">, getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to compute </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">import</code> <code class="plain">java.io.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Function to get sum of digits */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">getSum(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Single line that calculates sum */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">for</code> <code class="plain">(sum = </code><code class="value">0</code><code class="plain">; n > </code><code class="value">0</code><code class="plain">; sum += n % </code><code class="value">10</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n /= </code><code class="value">10</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">687</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println(getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Gitanjali </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Function to get sum of digits&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">def</code> <code class="plain">getSum(n): </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">sum</code> <code class="keyword">=</code> <code class="value">0</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments"># Single line that calculates sum&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">while</code><code class="plain">(n > </code><code class="value">0</code><code class="plain">): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">sum</code> <code class="keyword">+</code><code class="keyword">=</code> <code class="functions">int</code><code class="plain">(n</code><code class="keyword">%</code><code class="value">10</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n </code><code class="keyword">=</code> <code class="functions">int</code><code class="plain">(n</code><code class="keyword">/</code><code class="value">10</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="functions">sum</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># Driver code </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">n </code><code class="keyword">=</code> <code class="value">687</code>
<code class="functions">print</code><code class="plain">(getSum(n)) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed by </code>
<code class="comments"># Smitha Dinesh Semwal </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# program to compute&nbsp; </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">getSum(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Single line that calculates sum */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">for</code> <code class="plain">(sum = 0; n > 0; sum += n % 10, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n /= 10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">sum; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = 687; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(getSum(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Sam007 </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP Code for Sum the&nbsp; </code>
<code class="comments">// digits of a given number </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Function to get sum of digits&nbsp; </code>
<code class="keyword">function</code> <code class="plain">getsum(</code><code class="variable">$n</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Single line that calculates $sum </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">for</code> <code class="plain">(</code><code class="variable">$sum</code> <code class="plain">= 0; </code><code class="variable">$n</code> <code class="plain">> 0; </code><code class="variable">$sum</code> <code class="plain">+= </code><code class="variable">$n</code> <code class="plain">% 10,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="variable">$n</code> <code class="plain">/= 10); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="variable">$sum</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="variable">$n</code> <code class="plain">= 687; </code>
<code class="functions">echo</code><code class="plain">(getsum(</code><code class="variable">$n</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by&nbsp; </code>
<code class="comments">// Smitha Dinesh Semwal. 
</code>
<code class="plain">?> </code>
<br />
Output : 
<pre>21</pre>
<strong>2. 
Recursive</strong><br />
Thanks to ayesha for providing the below recursive solution.<br />
<h3>C++</h3>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="keyword bold">class</code> <code class="plain">gfg </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code><code class="keyword bold">public</code><code class="plain">: </code><code class="color1 bold">int</code> <code class="plain">sumDigits(</code><code class="color1 bold">int</code> <code class="plain">no) </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">no == 0 ? 0 : no%10 + sumDigits(no/10) ; </code>
<code class="undefined spaces">&nbsp;</code><code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//driver code </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">gfg g; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;g.sumDigits(687); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>C</h3>
<code class="color1 bold">int</code> <code class="plain">sumDigits(</code><code class="color1 bold">int</code> <code class="plain">no) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">no == 0 ? 0 : no%10 + sumDigits(no/10) ; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, sumDigits(687)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to compute </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">import</code> <code class="plain">java.io.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Function to get sum of digits */</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">sumDigits(</code><code class="keyword">int</code> <code class="plain">no) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">no == </code><code class="value">0</code> <code class="plain">? </code><code class="value">0</code> <code class="plain">: no%</code><code class="value">10</code> <code class="plain">+&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sumDigits(no/</code><code class="value">10</code><code class="plain">) ; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println(sumDigits(</code><code class="value">687</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Gitanjali </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python program to compute </code>
<code class="comments"># sum of digits in number. 
</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">def</code> <code class="plain">sumDigits(no): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="value">0</code> <code class="keyword">if</code> <code class="plain">no </code><code class="keyword">=</code><code class="keyword">=</code> <code class="value">0</code> <code class="keyword">else</code> <code class="functions">int</code><code class="plain">(no</code><code class="keyword">%</code><code class="value">10</code><code class="plain">) </code><code class="keyword">+</code> <code class="plain">sumDigits(</code><code class="functions">int</code><code class="plain">(no</code><code class="keyword">/</code><code class="value">10</code><code class="plain">))&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># Driver code </code>
<code class="functions">print</code><code class="plain">(sumDigits(</code><code class="value">687</code><code class="plain">)) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed by </code>
<code class="comments"># Smitha Dinesh Semwal </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# program to compute&nbsp; </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Function to get sum of digits */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">sumDigits(</code><code class="keyword">int</code> <code class="plain">no) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">no == 0 ? 0 : no % 10 +&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sumDigits(no / 10); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(sumDigits(687)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Sam007 </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP program to compute&nbsp; </code>
<code class="comments">// sum of digits in number. 
</code>
<code class="keyword">function</code> <code class="plain">sumDigits(</code><code class="variable">$no</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="keyword">return</code> <code class="variable">$no</code> <code class="plain">== 0 ? 0 : </code><code class="variable">$no</code> <code class="plain">% 10 +&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sumDigits(</code><code class="variable">$no</code> <code class="plain">/ 10) ; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="functions">echo</code> <code class="plain">sumDigits(687); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by aj_36 </code>
<code class="plain">?> </code>
<br />
<strong>Output :</strong> 
<pre>21</pre>
Please write comments if you find the above codes/algorithms incorrect, or find better ways to solve the same problem.
<h2>What is the best way in C to convert a number to a string?</h2>
<strong>Solution:</strong> Use sprintf() function.<br />
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">result[50]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">num = 23.34; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">sprintf</code><code class="plain">(result, </code><code class="string">"%f"</code><code class="plain">, num); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n The string for the num is %s"</code><code class="plain">, result); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="plain">} </code>
You can also write your own function using ASCII values of numbers.
<h2>Program to compute Log n</h2>
Write a one line C function that calculates and returns <img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-eeaee3f0c39dcc92a18a45e28b441f98_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#108;&#111;&#103;&#95;&#50;&#32;&#110;" title="Rendered by QuickLaTeX.com" height="25">. 
For example, if n = 64, then your function should return 6, and if n = 129, then your function should return 7. 
<!--more-->
<strong>
<p style="text-align:center">Using Recursion
</strong><br />
<h3>C</h3>
<code class="comments">// C program to find log(n) using Recursion </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">Log2n(unsigned </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(n > 1) ? 1 + Log2n(n / 2) : 0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">n = 32; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%u"</code><code class="plain">, Log2n(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to find log(n) </code>
<code class="comments">// using Recursion </code>
<code class="keyword">class</code> <code class="plain">Gfg1&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">Log2n(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">(n > </code><code class="value">1</code><code class="plain">) ? </code><code class="value">1</code> <code class="plain">+ Log2n(n / </code><code class="value">2</code><code class="plain">) : </code><code class="value">0</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver Code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String args[]) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">32</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println(Log2n(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Niraj_Pandey </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python 3 program to </code>
<code class="comments"># find log(n) using Recursion </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">def</code> <code class="plain">Log2n(n): </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="value">1</code> <code class="keyword">+</code> <code class="plain">Log2n(n </code><code class="keyword">/</code> <code class="value">2</code><code class="plain">) </code><code class="keyword">if</code> <code class="plain">(n > </code><code class="value">1</code><code class="plain">) </code><code class="keyword">else</code> <code class="value">0</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># Driver code </code>
<code class="plain">n </code><code class="keyword">=</code> <code class="value">32</code>
<code class="functions">print</code><code class="plain">(Log2n(n)) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed by </code>
<code class="comments"># Smitha Dinesh Semwal </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# program to find log(n) </code>
<code class="comments">// using Recursion </code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">Log2n(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">(n > 1) ? 1 +&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Log2n(n / 2) : 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver Code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = 32; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(Log2n(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by </code>
<code class="comments">// nitin mittal. 
</code>
<strong>Output :</strong>
<pre>
5
</pre>
<strong>Time complexity: </strong>O(log n)<br />
<strong>Auxiliary space: </strong>O(log n) if the stack size is considered during recursion otherwise O(1)<br />
<strong>
<p style="text-align:center">Using inbuilt log function
</strong><br />
We can use the inbuilt function of standard library which is available in  library.<br />
<h3>C</h3>
<code class="comments">// C program to find log(n) using Inbuilt </code>
<code class="comments">// function of &lt;math.h> library </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">n = 32; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, (</code><code class="color1 bold">int</code><code class="plain">)log2(n)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to find log(n) using Inbuilt </code>
<code class="comments">// function of java.util.Math library </code>
<code class="keyword">import</code> <code class="plain">java.util.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">Gfg2&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String args[]) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">32</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println((</code><code class="keyword">int</code><code class="plain">)(Math.log(n) / Math.log(</code><code class="value">2</code><code class="plain">))); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Niraj_Pandey </code>
<strong>Output :</strong>
<pre>
5
</pre>
<strong>Time complexity: </strong>O(1)<br />
<strong>Auxiliary space: </strong>O(1)
<h2>
<strong>
<p style="text-align:center">Let us try an extended version of the problem.
</strong></h2>
Write a one line function Logn(n, r) which returns <img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-70199e3aa8c9490d88b409dc6b4638f8_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#108;&#102;&#108;&#111;&#111;&#114;&#92;&#108;&#111;&#103;&#95;&#114;&#32;&#110;&#92;&#114;&#102;&#108;&#111;&#111;&#114;" title="Rendered by QuickLaTeX.com" height="27">.<br />
<strong>
          
<p style="text-align:center">Using Recursion
</strong><br />
<h3>C</h3>
<code class="comments">// C program to find log(n) on arbitrary base using Recursion </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">Logn(unsigned </code><code class="color1 bold">int</code> <code class="plain">n, unsigned </code><code class="color1 bold">int</code> <code class="plain">r) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(n > r - 1) ? 1 + Logn(n / r, r) : 0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">n = 256; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">r = 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%u"</code><code class="plain">, Logn(n, r)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to find log(n) on </code>
<code class="comments">// arbitrary base using Recursion </code>
<code class="keyword">class</code> <code class="plain">Gfg3&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">int</code> <code class="plain">Logn(</code><code class="keyword">int</code> <code class="plain">n, </code><code class="keyword">int</code> <code class="plain">r) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code> <code class="plain">(n > r - </code><code class="value">1</code><code class="plain">) ? </code><code class="value">1</code> <code class="plain">+ Logn(n / r, r) : </code><code class="value">0</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver Code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String args[]) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">256</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">r = </code><code class="value">3</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println(Logn(n, r)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Niraj_Pandey </code>
<strong>Output :</strong>
<pre>5
</pre>
<strong>Time complexity: </strong>O(log n)<br />
<strong>Auxiliary space: </strong>O(log n) if the stack size is considered during recursion otherwise O(1)
<strong>
<p style="text-align:center">Using inbuilt log function
</strong><br />
We only need to use logarithm property to find the value of log(n) on arbitrary base <strong>r</strong>. 
i.e., <img src="https://www.geeksforgeeks.org/wp-content/ql-cache/quicklatex.com-dd166df6f974a236f1590b7c3d0e8dc3_l3.png" class="ql-img-inline-formula quicklatex-auto-format" alt="&#92;&#108;&#111;&#103;&#95;&#114;&#32;&#110;&#32;&#61;&#32;&#92;&#100;&#102;&#114;&#97;&#99;&#123;&#108;&#111;&#103;&#95;&#107;&#32;&#40;&#110;&#41;&#125;&#123;&#92;&#108;&#111;&#103;&#95;&#107;&#32;&#40;&#114;&#41;&#125;" title="Rendered by QuickLaTeX.com" height="63"> where <strong>k</strong> can be any anything, which for standard log functions are either <strong>e</strong> or <strong>10</strong><br />
<h3>C</h3>
<code class="comments">// C program to find log(n) on arbitrary base </code>
<code class="comments">// using log() function of maths library </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">Logn(unsigned </code><code class="color1 bold">int</code> <code class="plain">n, unsigned </code><code class="color1 bold">int</code> <code class="plain">r) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="functions bold">log</code><code class="plain">(n) / </code><code class="functions bold">log</code><code class="plain">(r); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">n = 256; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">r = 3; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%u"</code><code class="plain">, Logn(n, r)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// Java program to find log(n) on arbitrary base </code>
<code class="comments">// using log() function of java.util.Math library </code>
<code class="keyword">import</code> <code class="plain">java.util.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">Gfg4 { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String args[]) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">n = </code><code class="value">256</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">int</code> <code class="plain">r = </code><code class="value">3</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.println((</code><code class="keyword">int</code><code class="plain">)(Math.log(n) / Math.log(r))); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Niraj_Pandey </code>
<strong>Output :</strong>
<pre>5
</pre>
<strong>Time complexity: </strong>O(1)<br />
<strong>Auxiliary space: </strong>O(1)<br />
<h2>Print &#8220;Even&#8221; or &#8220;Odd&#8221; without using conditional statement</h2>
Write a C/C++ program that accepts a number from the user and prints &#8220;Even&#8221; if the entered number is even and prints &#8220;Odd&#8221; if the number is odd. 
You are not allowed to use any comparison (==, &lt;,&gt;,&#8230;etc) or conditional (if, else, switch, ternary operator,..etc) statement.
<strong>Method 1</strong><br />
Below is a tricky code can be used to print &#8220;Even&#8221; or &#8220;Odd&#8221; accordingly.<br />
<h3>C++</h3>
<code class="preprocessor">#include&lt;iostream> </code>
<code class="preprocessor">#include&lt;conio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">arr[2][5] = {</code><code class="string">"Even"</code><code class="plain">, </code><code class="string">"Odd"</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">no; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Enter a number: "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cin >> no; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; arr[no%2]; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">getch(); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">arr </code><code class="keyword">=</code> <code class="plain">[</code><code class="string">"Even"</code><code class="plain">, </code><code class="string">"Odd"</code><code class="plain">] </code>
<code class="keyword">print</code> <code class="plain">(</code><code class="string">"Enter the number"</code><code class="plain">) </code>
<code class="plain">no </code><code class="keyword">=</code> <code class="functions">input</code><code class="plain">() </code>
<code class="keyword">print</code> <code class="plain">(arr[</code><code class="functions">int</code><code class="plain">(no) </code><code class="keyword">%</code> <code class="value">2</code><code class="plain">]) </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="variable">$arr</code> <code class="plain">= [</code><code class="string">"Even"</code><code class="plain">, </code><code class="string">"Odd"</code><code class="plain">];&nbsp; </code>
<code class="variable">$input</code> <code class="plain">= 5; </code>
<code class="functions">echo</code> <code class="plain">(</code><code class="variable">$arr</code><code class="plain">[</code><code class="variable">$input</code> <code class="plain">% 2]); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed </code>
<code class="comments">// by Aman ojha </code>
<code class="plain">?> </code>
<strong>Method 2</strong><br />
Below is another tricky code can be used to print &#8220;Even&#8221; or &#8220;Odd&#8221; accordingly. 
Thanks to <a href="https://www.geeksforgeeks.org/archives/8337/comment-page-1#comment-4987">student </a>for suggesting this method.<br/>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">no; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a no: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, &no); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">(no & 1 && </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"odd"</code><code class="plain">))|| </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"even"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Please write comments if you find the above code incorrect, or find better ways to solve the same problem
<h2>How will you print numbers from 1 to 100 without using loop?</h2>
If we take a look at this problem carefully, we can see that the idea of &#8220;loop&#8221; is to track some counter value e.g. 
&#8220;i=0&#8221; till &#8220;i &lt;= 100&quot;. 
So if we aren&#039;t allowed to use loop, how else can be track something in C language!<br />
<!--more-->
Well, one possibility is the use of &#8216;recursion&#8217; provided we use the terminating condition carefully. 
Here is a solution that prints numbers using recursion.<br />
<!--more--><br />
<h3>C++</h3>
<code class="comments">// C++ program to How will you print </code>
<code class="comments">//&nbsp; numbers from 1 to 100 without using loop? </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">class</code> <code class="plain">gfg </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="comments">// Prints numbers from 1 to n </code>
<code class="keyword bold">public</code><code class="plain">: </code>
<code class="keyword bold">void</code> <code class="plain">printNos(unsigned </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(n > 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(n - 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; n &lt;&lt; </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">gfg g; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">g.printNos(100); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by SoM15242 </code>
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Prints numbers from 1 to n </code>
<code class="keyword bold">void</code> <code class="plain">printNos(unsigned </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(n > 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(n - 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(100); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<h3>Java</h3>
<i id="run-and-edit-button" title="Edit Code" lang="java"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="java" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="java"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="java" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="keyword">import</code> <code class="plain">java.io.*; </code>
<code class="keyword">import</code> <code class="plain">java.util.*; </code>
<code class="keyword">import</code> <code class="plain">java.text.*; </code>
<code class="keyword">import</code> <code class="plain">java.math.*; </code>
<code class="keyword">import</code> <code class="plain">java.util.regex.*; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints numbers from 1 to n </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">printNos(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(n > </code><code class="value">0</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(n - </code><code class="value">1</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">System.out.print(n + </code><code class="string">" "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Driver Code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">main(String[] args)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(</code><code class="value">100</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Manish_100 </code>
<h3>Python3</h3>
<i id="run-and-edit-button" title="Edit Code" lang="python3"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="python3" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="python3"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="python3" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments"># Python3 program to Print </code>
<code class="comments"># numbers from 1 to n&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">def</code> <code class="plain">printNos(n): </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code> <code class="plain">n > </code><code class="value">0</code><code class="plain">: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(n </code><code class="keyword">-</code> <code class="value">1</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">print</code><code class="plain">(n, end </code><code class="keyword">=</code> <code class="string">' '</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># Driver code&nbsp; </code>
<code class="plain">printNos(</code><code class="value">100</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments"># This code is contributed by Smitha Dinesh Semwal </code>
<h3>C#</h3>
<i id="run-and-edit-button" title="Edit Code" lang="csharp"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="csharp" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="csharp"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="csharp" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="comments">// C# code for print numbers from&nbsp; </code>
<code class="comments">// 1 to 100 without using loop </code>
<code class="keyword">using</code> <code class="plain">System; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword">class</code> <code class="plain">GFG&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Prints numbers from 1 to n </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">printNos(</code><code class="keyword">int</code> <code class="plain">n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(n > 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(n - 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">Console.Write(n + </code><code class="string">" "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="keyword">public</code> <code class="keyword">static</code> <code class="keyword">void</code> <code class="plain">Main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(100); </code>
<code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by Ajit </code>
<h3>PHP</h3>
<i id="run-and-edit-button" title="Edit Code" lang="php"  class="material-icons code-sidebar-button">edit</i><br />
<i id="run-code-button" lang="php" title="Run Code and See Output" class="material-icons code-sidebar-button">play_arrow</i>
<i id="generate-url-and-run-button" title="Run Code and Generate IDE URL" lang="php"  class="material-icons code-sidebar-button generate-url-and-run-button">link</i><br />
<i id = "edit-on-ide-button" title="Edit on IDE"  lang="php" class="material-icons code-sidebar-button edit-on-ide-button">code</i>
<code class="plain">&lt;?php </code>
<code class="comments">// PHP program print numbers&nbsp; </code>
<code class="comments">// from 1 to 100 without&nbsp; </code>
<code class="comments">// using loop&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Prints numbers from 1 to n </code>
<code class="keyword">function</code> <code class="plain">printNos(</code><code class="variable">$n</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">if</code><code class="plain">(</code><code class="variable">$n</code> <code class="plain">> 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printNos(</code><code class="variable">$n</code> <code class="plain">- 1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions">echo</code> <code class="variable">$n</code><code class="plain">, </code><code class="string">" "</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword">return</code><code class="plain">; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="plain">printNos(100); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by vt_m </code>
<code class="plain">?> </code>
<br />
<strong>Output :</strong>
<pre>
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
16 17 18 19 20 21 22 23 24 25 26 27 
28 29 30 31 32 33 34 35 36 37 38 39
40 41 42 43 44 45 46 47 48 49 50 51
52 53 54 55 56 57 58 59 60 61 62 63
64 65 66 67 68 69 70 71 72 73 74 75
76 77 78 79 80 81 82 83 84 85 86 87
88 89 90 91 92 93 94 95 96 97 98 99 
100 
</pre>
<strong>Time Complexity :</strong> O(n)
Now try writing a program that does the same but without any &#8220;if&#8221; construct.<br />
Hint &#8212; use some operator which can be used instead of &#8220;if&#8221;. 
Please note that recursion technique is good but every call to the function creates one &#8220;stack-frame&#8221; in program stack. 
So if there&#8217;s constraint to the limited memory and we need to print large set of numbers, &#8220;recursion&#8221; might not be a good idea. 
So what could be the other alternative?
Another alternative is &#8220;goto&#8221; statement. 
Though use of &#8220;goto&#8221; is not suggestible as a general programming practice as &#8220;goto&#8221; statement changes the normal program execution sequence yet in some cases, use of &#8220;goto&#8221; is the best working solution. 
So please give a try printing numbers from 1 to 100 with &#8220;goto&#8221; statement. 
You can use <a href="https://ide.geeksforgeeks.org/">GfG IDE!</a> 
<a href="https://www.geeksforgeeks.org/output-of-c-program-set-18-3/">Print 1 to 100 in C++, without loop and recursion</a>
<h2>Write a C program to print &#8220;Geeks for Geeks&#8221; without using a semicolon</h2>
First of all we have to understand how printf() function works.<br />
Prototype of printf() function is:
<pre>
int printf( const char *format , ...)
</pre>
<strong>Parameter</strong>
<ul>
<li>
		<strong>format:</strong> This is a string that contains a text to be written to stdout.
	</li>
<li>
		<strong>Additional arguments:</strong> &#8230; (Three dots are called ellipses) which indicates the variable number of arguments depending upon the format string.
	</li>
</ul>
<strong>printf() returns the total number of characters written to stdout. 
Therefore it can be used as a condition check in an if condition, while condition, switch case and Macros.</strong>
Let&#8217;s see each of these conditions one by one.
<ol>
<li>
		<strong>Using if condition:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeks for Geeks"</code><code class="plain">) ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp;&nbsp; } </code>
<code class="plain">}&nbsp;&nbsp;&nbsp; </code>
</li>
<li>
	<strong>Using while condition:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(!</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Geeks for Geeks"</code> <code class="plain">)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp; } </code>
<code class="plain">} </code>
</li>
<li>
<strong>Using switch case:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code> <code class="plain">(</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeks for Geeks"</code> <code class="plain">)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp; } </code>
<code class="plain">}</code>
</li>
<li>
	<strong>Using Macros:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define PRINT printf("Geeks for Geeks") </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(PRINT) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp;&nbsp; } </code>
<code class="plain">} </code></li></ol>
<pre>
<strong>Output:</strong> Geeks for Geeks
</pre>
<strong>One trivial extension of the above problem:</strong> Write a C program to print &#8220;;&#8221; without using a semicolon
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// ASCII value of ; is 59 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%c"</code><code class="plain">, 59)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
</ol>
<pre>
<strong>Output:</strong> ;
</pre>
This blog is contributed by <a href="https://www.facebook.com/banalshubham"> Shubham Bansal</a>. 
If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. 
See your article appearing on the GeeksforGeeks main page and help other Geeks.
<h2>Write a one line C function to round floating point numbers</h2>
<strong>Algorithm: </strong>roundNo(num)<br />
  1. 
If num is positive then add 0.5.<br />
  2. 
Else subtract 0.5.<br />
  3. 
Type cast the result to int and return.<br />
<!--more-->
<strong>Example:</strong><br />
num = 1.67,   (int) num + 0.5 =  (int)2.17   =  2<br />
num = -1.67,  (int) num &#8211; 0.5  = -(int)2.17  = -2<br />
<strong><br />
Implementation:</strong>
<code class="comments">/* Program for rounding floating point numbers */</code>
<code class="preprocessor"># include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">roundNo(</code><code class="color1 bold">float</code> <code class="plain">num) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">num &lt; 0 ? num - 0.5 : num + 0.5; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, roundNo(-1.777)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:   -2
<strong>Time complexity: </strong>   O(1)<br />
<strong>Space complexity: </strong> O(1)
Now try rounding for a given precision. 
i.e., if given precision is 2 then function should return 1.63 for 1.63322 and -1.63 for 1.6332.
<h2>Implement Your Own sizeof</h2>
Here is an implementation. 
<!--more-->
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define my_sizeof(type) (char *)(&type+1)-(char*)(&type) </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%ld"</code><code class="plain">, my_sizeof(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Type is like a local variable to the macro. 
&amp;type gives the address of the variable (double x) declared in the program and incrementing it with 1 gives the address where the next variable of type x can be stored (here addr_of(x) + 8, for the size of a double is 8B).<br />
The difference gives the result that how many variables of type of x can be stored in that amount of memory which will obviously be 1 for the type x (for incrementing it with 1 and taking the difference is what we&#8217;ve done). 
Typecasting it into char* and taking the difference will tell us how many variables of type char can be stored in the given memory space (the difference). 
Since each char requires the only 1B of memory, therefore (amount of memory)/1 will give the number of bytes between two successive memory locations of the type of the variable passed on to the macro and hence the amount of memory that the variable of type x requires.<br />
But you won&#8217;t be able to pass any literal to this macro and know their size.
You can also implement using the function instead of a macro, but function implementation cannot be done in C as C doesn&#8217;t support function overloading and sizeof() is supposed to receive parameters of all data types. 
Note that the above implementation assumes that the size of character is one byte. 
<strong>Time Complexity: </strong>O(1)<br />
<strong>Space Complexity:</strong> O(1)
<h2>How to count set bits in a floating point number in C?</h2>
Given a <a href="http://en.wikipedia.org/wiki/Floating_point">floating point</a> number, write a function to count set bits in its binary representation. 
<!--more-->
For example, floating point representation of 0.15625 has 6 set bits (See <a href="http://en.wikipedia.org/wiki/Single_precision#IEEE_754_single-precision_binary_floating-point_format:_binary32">this</a>). 
A typical C compiler uses <a href="http://en.wikipedia.org/wiki/Single_precision">single precision floating point format</a>. 
We can use the idea discussed <a href="https://www.geeksforgeeks.org/how-will-you-show-memory-representation-of-c-variables/">here</a>. 
The idea is to take address of the given floating point number in a pointer variable, typecast the pointer to char * type and process individual bytes one by one. 
We can easily count set bits in a char using the techniques discussed <a href="https://www.geeksforgeeks.org/count-set-bits-in-an-integer/">here</a>. 

Following is C implementation of the above idea.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A utility function to count set bits in a char. 
</code>
<code class="comments">// Refer <a href="http://goo.gl/eHF6Y8">http://goo.gl/eHF6Y8</a> for details of this function. 
</code>
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">countSetBitsChar(</code><code class="color1 bold">char</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">count = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(n) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n &= (n-1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">count; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Returns set bits in binary representation of x </code>
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">countSetBitsFloat(</code><code class="color1 bold">float</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Count number of chars (or bytes) in binary representation of float </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">float</code><code class="plain">)/</code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">char</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// typcast address of x to a char pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr = (</code><code class="color1 bold">char</code> <code class="plain">*)&x;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">count = 0;&nbsp;&nbsp; </code><code class="comments">// To store the result </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">count += countSetBitsChar(*ptr); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">count; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">x = 0.15625; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Binary representation of %f has %u set bits "</code><code class="plain">, x, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">countSetBitsFloat(x)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Binary representation of 0.156250 has 6 set bits</pre>
<h2>How to change the output of printf() in main() ?</h2>
Consider the following program. 
Change the program so that the output of printf is always 10. 
It is not allowed to change main(). 
Only fun() can be changed.<!--more-->
<code class="keyword bold">void</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Add something here so that the printf in main prints 10 </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
We can use <a href="http://gcc.gnu.org/onlinedocs/cpp/Macro-Arguments.html#Macro-Arguments">Macro Arguments</a> to change the output of printf.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#define printf(x, y) printf(x, 10); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i = 20; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>10</pre>
<h2>How to find length of a string without string.h and loop in C?</h2>
Find the length of a string without using any loops and string.h in C. 
Your program is supposed to behave in following way: <!--more-->
<pre>Enter a string: GeeksforGeeks (<span style="color: #0000ff">Say user enters GeeksforGeeks</span>)
Entered string is: GeeksforGeeks
Length is: 13</pre>
You may assume that the length of entered string is always less than 100.
The following is solution.<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter a string: \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">gets</code><code class="plain">(str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Entered string is:%s\n"</code><code class="plain">, str); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"\rLength is: %d"</code><code class="plain">,</code><code class="functions bold">strlen</code><code class="plain">(str)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
Enter a string: GeeksforGeeks
Entered string is: GeeksforGeeks
Length is: 13</pre>
The idea is to use return values of printf() and gets().<br />
<a href="http://www.cplusplus.com/reference/cstdio/gets/">gets() returns the enereed string.</a><br />
<a href="https://www.geeksforgeeks.org/g-fact-10/">printf() returns the number of characters successfully written on output</a>.
In the above program, gets() returns the entered string. 
We print the length using the first printf. 
The second printf() calls gets() and prints the entered string using returned value of gets(), it also prints 20 extra characters for printing &#8220;Entered string is: &#8221; and &#8220;\n&#8221;. 
That is why we subtract 20 from the returned value of second printf and get the length. 
<h2>Implement your own itoa()</h2>
<a href="http://www.cplusplus.com/reference/cstdlib/itoa/">itoa </a>function converts integer into null-terminated string. 
It can convert negative numbers too. 
<!--more-->The standard definition of itoa function is give below:-
<code class="color1 bold">char</code><code class="plain">* itoa(</code><code class="color1 bold">int</code> <code class="plain">num, </code><code class="color1 bold">char</code><code class="plain">* buffer, </code><code class="color1 bold">int</code> <code class="plain">base)&nbsp; </code>
The third parameter base specify the conversion base. 
For example:- if base is 2, then it will convert the integer into its binary compatible string or if base is 16, then it will create hexadecimal converted string form of integer number. 
If base is 10 and value is negative, the resulting string is preceded with a minus sign (-). 
With any other base, value is always considered unsigned.
Reference: <a href="http://www.cplusplus.com/reference/cstdlib/itoa/"> http://www.cplusplus.com/reference/cstdlib/itoa/?kw=itoa</a>
<strong>Examples:</strong>
<pre>
  itoa(1567, str, 10) should return string "1567"
  itoa(-1567, str, 10) should return string "-1567"
  itoa(1567, str, 2) should return string "11000011111"
  itoa(1567, str, 16) should return string "61f"
</pre>
Individual digits of the given number must be processed and their corresponding characters must be put in the given string. 
Using repeated division by the given base, we get individual digits from least significant to most significant digit. 
But in the output, these digits are needed in reverse order. 
Therefore, we reverse the string obtained after repeated division and return it.
<code class="comments">/* A C++ program to implement itoa() */</code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* A utility function to reverse a string&nbsp; */</code>
<code class="keyword bold">void</code> <code class="plain">reverse(</code><code class="color1 bold">char</code> <code class="plain">str[], </code><code class="color1 bold">int</code> <code class="plain">length) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">start = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">end = length -1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(start &lt; end) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">swap(*(str+start), *(str+end)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">start++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">end--; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Implementation of itoa() </code>
<code class="color1 bold">char</code><code class="plain">* itoa(</code><code class="color1 bold">int</code> <code class="plain">num, </code><code class="color1 bold">char</code><code class="plain">* str, </code><code class="color1 bold">int</code> <code class="plain">base) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">bool</code> <code class="plain">isNegative = </code><code class="keyword bold">false</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Handle 0 explicitely, otherwise empty string is printed for 0 */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i++] = </code><code class="string">'0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i] = </code><code class="string">'\0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">str; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// In standard itoa(), negative numbers are handled only with&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// base 10. 
Otherwise numbers are considered unsigned. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num &lt; 0 && base == 10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">isNegative = </code><code class="keyword bold">true</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">num = -num; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Process individual digits </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(num != 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">rem = num % base; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i++] = (rem > 9)? (rem-10) + </code><code class="string">'a'</code> <code class="plain">: rem + </code><code class="string">'0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">num = num/base; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If number is negative, append '-' </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(isNegative) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i++] = </code><code class="string">'-'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i] = </code><code class="string">'\0'</code><code class="plain">; </code><code class="comments">// Append string terminator </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Reverse the string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">reverse(str, i); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">str; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test implementation of itoa() </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Base:10 "</code> <code class="plain">&lt;&lt; itoa(1567, str, 10) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Base:10 "</code> <code class="plain">&lt;&lt; itoa(-1567, str, 10) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Base:2 "</code> <code class="plain">&lt;&lt; itoa(1567, str, 2) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Base:8 "</code> <code class="plain">&lt;&lt; itoa(1567, str, 8) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"Base:16 "</code> <code class="plain">&lt;&lt; itoa(1567, str, 16) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
Base:10 1567
Base:10 -1567
Base:2 11000011111
Base:8 3037
Base:16 61f</pre>
<h2>Write a C program that does not terminate when Ctrl+C is pressed</h2>
Write a C program that doesn&#8217;t terminate when Ctrl+C is pressed. 
It prints a message &#8220;Cannot be terminated using Ctrl+c&#8221; and continues execution.<!--more-->
We can use <a href="http://en.wikipedia.org/wiki/C_signal_handling">signal handling in C</a> for this. 
When <a href="http://en.wikipedia.org/wiki/Control-C">Ctrl+C </a>is pressed, SIGINT signal is generated, we can catch this signal and run our defined signal handler. 
 C standard defines following 6 signals in signal.h header file.
SIGABRT &#8211; abnormal termination.<br />
SIGFPE &#8211; floating point exception.<br />
SIGILL &#8211; invalid instruction.<br />
SIGINT &#8211; interactive attention request sent to the program.<br />
SIGSEGV &#8211; invalid memory access.<br />
SIGTERM &#8211; termination request sent to the program.
Additional signals are specified Unix and Unix-like operating systems (such as Linux) defines more than 15 additional signals. 
See <a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals">http://en.wikipedia.org/wiki/<wbr>Unix_signal#POSIX_signals</wbr></a><br />
The standard C library function <a href="http://en.cppreference.com/w/c/program/signal">signal()</a> can be used to set up a handler for any of the above signals.
<code class="comments">/* A C program that does not terminate when Ctrl+C is pressed */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;signal.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* Signal Handler for SIGINT */</code>
<code class="keyword bold">void</code> <code class="plain">sigintHandler(</code><code class="color1 bold">int</code> <code class="plain">sig_num) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Reset handler to catch SIGINT next time. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">Refer <a href="http://en.cppreference.com/w/c/program/signal">http://en.cppreference.com/w/c/program/signal</a> */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">signal</code><code class="plain">(SIGINT, sigintHandler); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n Cannot be terminated using Ctrl+C \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fflush</code><code class="plain">(stdout); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Set the SIGINT (Ctrl-C) signal handler to sigintHandler&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">Refer <a href="http://en.cppreference.com/w/c/program/signal">http://en.cppreference.com/w/c/program/signal</a> */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">signal</code><code class="plain">(SIGINT, sigintHandler); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Infinite loop */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">(1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: When Ctrl+C was pressed two times
<pre> 
 Cannot be terminated using Ctrl+C
 
 Cannot be terminated using Ctrl+C</pre>
<h2>How to measure time taken by a function in C?</h2>
To calculate time taken by a process, we can use <a href="http://www.gnu.org/software/libc/manual/html_node/CPU-Time.html">clock()</a> function which is available <em>time.h</em>. 
We can call the clock function at the beginning and end of the code for which we measure time, subtract the values<!--more-->, and then divide by <a href="http://www.cplusplus.com/reference/ctime/CLOCKS_PER_SEC/">CLOCKS_PER_SEC </a>(the number of clock ticks per second) to get processor time, like following.
<pre>
     #include &lt;time.h&gt;
     
     clock_t start, end;
     double cpu_time_used;
     
     start = clock();
     ... 
/* Do the work.*/
     end = clock();
     cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;
</pre>
Following is a sample C program where we measure time taken by fun(). 
The function fun() waits for enter key press to terminate. 
<code class="comments">/* Program to demonstrate time taken by function fun() */</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;time.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function that terminates when enter key is pressed </code>
<code class="keyword bold">void</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"fun() starts \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Press enter to stop fun \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">(1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">getchar</code><code class="plain">()) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">break</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"fun() ends \n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// The main program calls fun() and measures time taken by fun() </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Calculate the time taken by fun() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">clock_t</code> <code class="plain">t; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t = </code><code class="functions bold">clock</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">t = </code><code class="functions bold">clock</code><code class="plain">() - t; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">time_taken = ((</code><code class="color1 bold">double</code><code class="plain">)t)/CLOCKS_PER_SEC; </code><code class="comments">// in seconds </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"fun() took %f seconds to execute \n"</code><code class="plain">, time_taken); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:  The following output is obtained after waiting for around 4 seconds and then hitting enter key.
<pre>
fun() starts
Press enter to stop fun
fun() ends
fun() took 4.017000 seconds to execute
</pre>
<a href="https://www.geeksforgeeks.org/how-to-find-time-taken-by-a-program-on-linux-shell/">How to find time taken by a command/program on Linux Shell?</a>
<h2>Print a long int in C using putchar() only</h2>
Write a C function <em>print(n)</em> that takes a long int number <em>n</em> as argument, and prints it on console. 
<!--more--> The only allowed library function is <em>putchar()</em>, no other function like <em>itoa()</em> or <em>printf() </em>is allowed. 
Use of loops is also not allowed.
<em><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></em>
This is a simple trick question. 
Since putchar() prints a character, we need to call putchar() for all digits. 
Recursion can always be used to replace iteration, so using recursion we can print all digits one by one. 
Now the question is <a href="http://www.cplusplus.com/reference/cstdio/putchar/">putchar()</a> prints a character, how to print digits using putchar(). 
We need to convert every digit to its corresponding ASCII value, this can be done by using ASCII value of &#8216;0&#8217;. 
 Following is complete C program.<br/>
<code class="comments">/* C program to print a long int number </code>
<code class="undefined spaces">&nbsp;</code><code class="comments">using putchar() only*/</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">print(</code><code class="color1 bold">long</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If number is smaller than 0, put a - sign </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// and change number to positive </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(n &lt; 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(</code><code class="string">'-'</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">n = -n; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Remove the last digit and recur </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(n/10) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print(n/10); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Print the last digit </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">putchar</code><code class="plain">(n%10 + </code><code class="string">'0'</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test abvoe function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">long</code> <code class="color1 bold">int</code> <code class="plain">n = 12045; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">print(n); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
Output: 
<pre>12045</pre>
One important thing to note is the sequence of putchar() and recursive call print(n/10). 
Since the digits should be printed left to right, the recursive call must appear before putchar() (The rightmost digit should be printed at the end, all other digits must be printed before it).
<h2>Convert a floating point number to string in C</h2>
Write a C function ftoa() that converts a given floating-point number or a double to a string. 
<!--more--> Use of standard library functions for direct conversion is not allowed. 
The following is prototype of ftoa(). 
The article provides insight of conversion of C double to string.
<pre>
ftoa(n, res, afterpoint)
n          --&gt; Input Number
res[]      --&gt; Array where output string to be stored
afterpoint --&gt; Number of digits to be considered after the point.
</pre>
<strong>Example:</strong>
<ul>
<li>ftoa(1.555, str, 2) should store &#8220;1.55&#8221; in res.</li>
<li>ftoa(1.555, str, 0) should store &#8220;1&#8221; in res.</li>
</ul>
<em><br />
<strong>We strongly recommend to minimize the browser and try this yourself first.</strong></em>
A simple way is to use <a href="https://www.geeksforgeeks.org/what-is-the-best-way-in-c-to-convert-a-number-to-a-string/">sprintf()</a>, but use of standard library functions for direct conversion is not allowed.
<strong>Approach:</strong> The idea is to separate integral and fractional parts and convert them to strings separately. 
Following are the detailed steps.
<ol>
<li>Extract integer part from floating-point or double number.</li>
<li>First, convert integer part to the string.</li>
<li>Extract fraction part by exacted integer part from n.</li>
<li>If d is non-zero, then do the following.
<ol style="list-style-type:lower-alpha">
<li>Convert fraction part to an integer by multiplying it with pow(10, d)</li>
<li>Convert the integer value to string and append to the result.</li>
</ol></li></ol>
Following is C implementation of the above approach.
<code class="comments">// C program for implementation of ftoa() </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Reverses a string 'str' of length 'len' </code>
<code class="keyword bold">void</code> <code class="plain">reverse(</code><code class="color1 bold">char</code><code class="plain">* str, </code><code class="color1 bold">int</code> <code class="plain">len) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0, j = len - 1, temp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(i &lt; j) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">temp = str[i]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i] = str[j]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[j] = temp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">i++; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">j--; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Converts a given integer x to string str[].&nbsp; </code>
<code class="comments">// d is the number of digits required in the output.&nbsp; </code>
<code class="comments">// If d is more than the number of digits in x,&nbsp; </code>
<code class="comments">// then 0s are added at the beginning. 
</code>
<code class="color1 bold">int</code> <code class="plain">intToStr(</code><code class="color1 bold">int</code> <code class="plain">x, </code><code class="color1 bold">char</code> <code class="plain">str[], </code><code class="color1 bold">int</code> <code class="plain">d) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(x) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i++] = (x % 10) + </code><code class="string">'0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = x / 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If number of digits required is more, then </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// add 0s at the beginning </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(i &lt; d) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i++] = </code><code class="string">'0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">reverse(str, i); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">str[i] = </code><code class="string">'\0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">i; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Converts a floating-point/double number to a string. 
</code>
<code class="keyword bold">void</code> <code class="plain">ftoa(</code><code class="color1 bold">float</code> <code class="plain">n, </code><code class="color1 bold">char</code><code class="plain">* res, </code><code class="color1 bold">int</code> <code class="plain">afterpoint) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Extract integer part </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ipart = (</code><code class="color1 bold">int</code><code class="plain">)n; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Extract floating part </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fpart = n - (</code><code class="color1 bold">float</code><code class="plain">)ipart; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// convert integer part to string </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = intToStr(ipart, res, 0); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// check for display option after point </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(afterpoint != 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">res[i] = </code><code class="string">'.'</code><code class="plain">; </code><code class="comments">// add dot </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get the value of fraction part upto given no. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// of points after dot. 
The third parameter&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// is needed to handle cases like 233.007 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fpart = fpart * </code><code class="functions bold">pow</code><code class="plain">(10, afterpoint); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">intToStr((</code><code class="color1 bold">int</code><code class="plain">)fpart, res + i + 1, afterpoint); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">res[20]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">n = 233.007; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ftoa(n, res, 4); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\"%s\"\n"</code><code class="plain">, res); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output:</b>
<pre>
"233.0070"
</pre>
<strong>Note:</strong> The program performs similar operation if instead of float, a double type is taken.
<h2>How to write a running C code without main()?</h2>
Write a C language code that prints <strong>GeeksforGeeks</strong> without any main function.
Logically it&#8217;s seems impossible to write a C program without using a main() function. 
Since every program must have a main() function because:-
<ul>
<li>
        It&#8217;s an entry point of every C/C++ program.
   </li>
<li>
        All Predefined and User-defined Functions are called directly or indirectly through the main.
   </li>
</ul>
Therefore we will use preprocessor(a program which processes the source code before compilation) directive #define with arguments to give an impression that the program runs without main. 
But in reality it runs with a hidden main function. 
Let&#8217;s see how the preprocessor doing their job:-
<a href="https://media.geeksforgeeks.org/wp-content/uploads/main-1.png"><img src="https://media.geeksforgeeks.org/wp-content/uploads/main-1.png" alt="up"></a>
Hence it can be solved in following ways:-
<ol>
<li><strong>Using a macro that defines main</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define fun main </code>
<code class="color1 bold">int</code> <code class="plain">fun(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre><strong>Output:</strong> Geeksforgeeks</pre>
</li>
<li><strong>Using Token-Pasting Operator</strong><br />
The above solution has word &#8216;main&#8217; in it. 
If we are not allowed to even write main, we can use token-pasting operator (see <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">this </a>for details)
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define fun m##a##i##n </code>
<code class="color1 bold">int</code> <code class="plain">fun() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<pre><strong>Output:</strong> Geeksforgeeks</pre>
</li>
<li>
<strong>Using Argumented Macro</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define begin(m,a,i,n) m##a##i##n </code>
<code class="preprocessor">#define start begin(m,a,i,n) </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">start() { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeksforgeeks"</code><code class="plain">); </code>
<code class="plain">} </code>
<pre><strong>Output:</strong> Geeksforgeeks</pre>
</li>
<li>
<strong>Modify the entry point during compilation</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// entry point function </code>
<code class="color1 bold">int</code> <code class="plain">nomain();&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">_start(){ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calling entry point </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nomain();&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">nomain() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">puts</code><code class="plain">(</code><code class="string">"Geeksforgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<strong>Output:</strong> 
Geeksforgeeks</pre>
<b>Compilation using command :</b><br />
gcc filename.c -nostartfiles<br />
(nostartfiles option tells the compiler to avoid standard linking)
<b>Explanation:</b><br />
Under normal compilation the body of _start() will contain a function call to main() [ this _start() will be appended to every code during normal compilation], so if that main() definition is not present it will result in error like &#8220;In function `_start&#8217;:<br />
(.text+0x20): undefined reference to `main&#8217;.<br />
In the above code what we have done is that we have defined our own _start() and defined our own entry point i.e nomain()
<ul>
<li><b>This method is contributed by Aravind Alapati</b></li>
</ul></li></ol>
Refer <a href="https://www.geeksforgeeks.org/executing-main-in-c-behind-the-scene/">Executing main() in C – behind the scene</a> for another solution.
<h2>Write your own memcpy() and memmove()</h2>
The <a href="http://geeksquiz.com/memcpy-in-cc/">memcpy </a>function is used to copy a block of data from a source address to a destination address. 
Below is its prototype.<!--more-->
<pre>void * memcpy(void * destination, const void * source, size_t num);</pre>
The idea is to simply typecast given addresses to char *(char takes 1 byte). 
Then one by one copy data from source to destination. 
Below is implementation of this idea.
<code class="comments">// A C implementation of memcpy() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">myMemCpy(</code><code class="keyword bold">void</code> <code class="plain">*dest, </code><code class="keyword bold">void</code> <code class="plain">*src, </code><code class="color1 bold">size_t</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Typecast src and dest addresses to (char *) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*csrc = (</code><code class="color1 bold">char</code> <code class="plain">*)src; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*cdest = (</code><code class="color1 bold">char</code> <code class="plain">*)dest; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy contents of src[] to dest[] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cdest[i] = csrc[i]; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">csrc[] = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">cdest[100]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">myMemCpy(cdest, csrc, </code><code class="functions bold">strlen</code><code class="plain">(csrc)+1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Copied string is %s"</code><code class="plain">, cdest); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">isrc[] = {10, 20, 30, 40, 50}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = </code><code class="keyword bold">sizeof</code><code class="plain">(isrc)/</code><code class="keyword bold">sizeof</code><code class="plain">(isrc[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">idest[n], i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">myMemCpy(idest, isrc,&nbsp; </code><code class="keyword bold">sizeof</code><code class="plain">(isrc)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nCopied array is "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, idest[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Copied string is GeeksforGeeks
Copied array is 10 20 30 40 50</pre>
<h3><strong>What is <a href="http://geeksquiz.com/memmove-in-cc/">memmove()</a>?</strong></h3>
memmove() is similar to memcpy() as it also copies data from a source to destination. 
memcpy() leads to problems when source and destination addresses overlap as memcpy() simply copies data one by one from one location to another. 
For example consider below program.
<code class="comments">// Sample program to show that memcpy() can loose data. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">csrc[100] = </code><code class="string">"Geeksfor"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">memcpy</code><code class="plain">(csrc+5, csrc, </code><code class="functions bold">strlen</code><code class="plain">(csrc)+1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, csrc); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>GeeksGeeksfor</pre>
Since the input addresses are overlapping, the above program overwrites the original string and causes data loss. 
<code class="comments">// Sample program to show that memmove() is better than memcpy() </code>
<code class="comments">// when addresses overlap. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">csrc[100] = </code><code class="string">"Geeksfor"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">memmove</code><code class="plain">(csrc+5, csrc, </code><code class="functions bold">strlen</code><code class="plain">(csrc)+1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, csrc); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>GeeksGeeksfor</pre>
<h3><strong>How to implement memmove()?</strong></h3>
The trick here is to use a temp array instead of directly copying from src to dest. 
The use of temp array is important to handle cases when source and destination addresses are overlapping.
<code class="comments">//C++ program to demonstrate implementation of memmove() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A function to copy block of 'n' bytes from source </code>
<code class="comments">// address 'src' to destination address 'dest'. 
</code>
<code class="keyword bold">void</code> <code class="plain">myMemMove(</code><code class="keyword bold">void</code> <code class="plain">*dest, </code><code class="keyword bold">void</code> <code class="plain">*src, </code><code class="color1 bold">size_t</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Typecast src and dest addresses to (char *) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*csrc = (</code><code class="color1 bold">char</code> <code class="plain">*)src; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*cdest = (</code><code class="color1 bold">char</code> <code class="plain">*)dest; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Create a temporary array to hold data of src </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*temp = </code><code class="keyword bold">new</code> <code class="color1 bold">char</code><code class="plain">[n]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy data from csrc[] to temp[] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">temp[i] = csrc[i]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">// Copy data from temp[] to cdest[] </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i=0; i&lt;n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cdest[i] = temp[i]; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">delete</code> <code class="plain">[] temp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">csrc[100] = </code><code class="string">"Geeksfor"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">myMemMove(csrc+5, csrc, </code><code class="functions bold">strlen</code><code class="plain">(csrc)+1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, csrc); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>GeeksGeeksfor</pre>
<strong>Optimizations:</strong><br />
The algorithm is inefficient (and honestly double the time if you use a temporary array). 
Double copies should be avoided unless if it is really impossible.
In this case though it is easily possible to avoid double copies by picking a direction of copy. 
In fact this is what the memmove() library function does.
By comparing the src and the dst addresses you should be able to find if they overlap.
&#8211; If they do not overlap, you can copy in any direction<br />
&#8211; If they do overlap, find which end of dest overlaps with the source and choose the direction of copy accordingly.<br />
&#8211; If the beginning of dest overlaps, copy from end to beginning<br />
&#8211; If the end of dest overlaps, copy from beginning to end<br />
&#8211; Another optimization would be to copy by word size. 
Just be careful to handle the boundary conditions.<br />
&#8211; A further optimization would be to use vector instructions for the copy since they&#8217;re contiguous.
<h2>C program to print characters without using format specifiers</h2>
As we know that there are various <a href="https://www.geeksforgeeks.org/data-types-in-c/"><strong>format specifiers</strong></a> in C like %d, %f, %c etc, to help us print characters or other data types. 
We normally use these specifiers along with the <strong>printf()</strong> function to print any variables. 
But there is also a way to print characters specifically without the use of %c format specifier. 
This can be obtained by using the below-shown method to get the character value of any ASCII codes of any particular character.<br />
Example:
<code class="comments">// Prints characters without format specifiers </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\x47 \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\x45 \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\x45 \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\x4b \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\x53"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
G 
E 
E 
K 
S
</pre>
<h2>C program to print a string without any quote (singe or double) in the program</h2>
Print a string without using quotes anywhere in the program using C or C++.<br />
Note : should not read input from the console.
<!-- To show strongly recommend and practice link    -->
<div id="practiceLinkDiv">
<h3><a href="https://ide.geeksforgeeks.org/">Recommended: Please try your approach on <b><i><u>{IDE}</u></i></b> first, before moving on to the solution.</a></h3>
The idea is to use <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">macro processor in C</a> (Refer point 6 of this article). 
A token passed to macro can be converted to a string literal by using # before it.<br/>
<code class="comments">// C program to print a string without&nbsp; </code>
<code class="comments">// quote in the program </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#define get(x) #x </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(get(vignesh)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
vignesh
</pre>
<h2>Execute both if and else statements in C/C++ simultaneously</h2>
Write a C/C++ program that execute both if-else block statements simultaneously.
<pre>
Syntax of if-else statement in C/C++ language is:
if (Boolean expression)
{
    // Statement will execute only 
    // if Boolean expression is true
}
else
{
    // Statement will execute only if 
    // the Boolean expression is false 
}
</pre>
Hence we can conclude that only one of the block of if-else statement will execute according to the condition of Boolean expression. 
But we can able to make our program so that both the statements inside if and else will execute simultaneously.
<div id="practiceLinkDiv">
<h3><a href="https://ide.geeksforgeeks.org/">Recommended: Please try your approach on <b><i><u>{IDE}</u></i></b> first, before moving on to the solution.</a></h3>
The trick is to use goto statement which provides an unconditional jump from the &#8216;goto&#8217; to a labelled statement in the same function.
Below is C/C++ program to execute both statements simultaneously:-
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(1) </code><code class="comments">//Replace 1 with 0 and see the magic </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">label_1: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Jump to the else statement after&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// executing the above statement </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label_2; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Jump to 'if block statement' if&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the Boolean condition becomes false </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">label_1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">label_2: </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
<b>Output:</b>
Hello Geeks
</pre>
Therefore both the statements of if and else block executed simultaneously. 
<em>Another interesting fact can be seen that Output will always remain same and will not depend upon the whether the Boolean condition is true or false.</em>
<strong>NOTE</strong> &#8211; Use of goto statement is highly discouraged in any programming language because it makes difficult to trace the control flow of a program, making the program hard to understand and hard to modify. 
As a programmer we should avoid the use of goto statement in C/C++.
This blog is contributed by <a href="https://www.facebook.com/banalshubham"> Shubham Bansal</a>. 
If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. 
See your article appearing on the GeeksforGeeks main page and help other Geeks.
<h2>Print &#8220;Hello World&#8221; in C/C++ without using any header file</h2>
Write a C/C++ program that prints <strong>Hello World</strong> without including any header file.
<em>Conceptually it&#8217;s seems impractical to write a C/C++ program that print <strong>Hello World</strong> without using a header file of &#8220;stdio.h&#8221;. 
Since the declaration of printf() function contains in the &#8220;stdio.h&#8221; header file.</em>
    But we can easily achieve this by taking the advantage of C pre-processor directives. 
The fact is at the time of compiling a program, the first phase of C preprocessing expands all header files into a single file and after that compiler itself compiles the expanded file. 
Therefore we just need to extract the declaration of printf() function from header file and use it in our main program like that:-
<ul>
<li><strong>C language:</strong> Just declare the printf() function taken from &#8220;stdio.h&#8221; header file.
<code class="comments">//Declare the printf() function </code>
<code class="color1 bold">int</code> <code class="functions bold">printf</code><code class="plain">(</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*format, ...); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Hello World"</code> <code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre><strong>Output:</strong> Hello World</pre>
<li><strong>C++ language:</strong> We can&#8217;t directly put the declaration of printf() function as in previous case due to the problem of <strong>Name mangling</strong> in C++. 
See <a href="https://www.geeksforgeeks.org/extern-c-in-c/">this</a> to know more about Name mangling. 
Therefore we just need to declare the printf() inside extern keyword like that:-
<code class="comments">//Declare the printf() function inside </code>
<code class="comments">//extern "C" for C++ compiler </code>
<code class="keyword bold">extern</code> <code class="string">"C"</code>
<code class="plain">{ </code>
<code class="color1 bold">int</code> <code class="functions bold">printf</code><code class="plain">(</code><code class="keyword bold">const</code> <code class="color1 bold">char</code> <code class="plain">*format, ...); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"Hello World"</code> <code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre><strong>Output:</strong> Hello World</pre>
</li>
</ul>
See <a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/">this</a> to know more about all phases of compilation of C program.
This blog is contributed by <a href="https://www.facebook.com/banalshubham"> Shubham Bansal</a>. 
If you like GeeksforGeeks and would like to contribute, you can also write an article using <a href="http://www.contribute.geeksforgeeks.org">contribute.geeksforgeeks.org</a> or mail your article to contribute@geeksforgeeks.org. 
See your article appearing on the GeeksforGeeks main page and help other Geeks.
<h2>Quine &#8211; A self-reproducing program</h2>
A quine is a program which prints a copy of its own as the only output. 
A quine takes no input. 
Quines are named after the American mathematician and logician Willard Van Orman Quine (1908–2000). 
The interesting thing is you are not allowed to use open and then print file of the program. 
<!--more-->
To the best of our knowledge, below is the shortest quine in C. 
<code class="plain">main() { </code><code class="color1 bold">char</code> <code class="plain">*s=</code><code class="string">"main() { char *s=%c%s%c; printf(s,34,s,34); }"</code><code class="plain">; </code><code class="functions bold">printf</code><code class="plain">(s,34,s,34); }&nbsp; </code>
This program uses the printf function without including its corresponding header (#include <stdio.h>), which can result in undefined behavior. 
Also, the return type declaration for main has been left off to reduce the length of the program. 
Two 34s are used to print double quotes around the string s.
Following is a shorter version of the above program suggested by <em>Narendra</em>.
<code class="plain">main(a){</code><code class="functions bold">printf</code><code class="plain">(a=</code><code class="string">"main(a){printf(a=%c%s%c,34,a,34);}"</code><code class="plain">,34,a,34);} </code>
If you find a shorter C quine or you want to share quine in other programming languages, then please do write in the comment section.
<a href="https://www.geeksforgeeks.org/quine-in-python/">Quine in Python</a>
Source:<br />
<a href="http://en.wikipedia.org/wiki/Quine_%28computing%29">http://en.wikipedia.org/wiki/Quine_%28computing%29</a>
<h2>Optimization Techniques | Set 2 (swapping)</h2>
How to swap two variables?
The question may look silly, neither geeky. 
See the following piece of code to swap two integers (<a href="http://en.wikipedia.org/wiki/XOR_swap_algorithm">XOR swapping</a>),<!--more-->
<pre>void myswap(int *x, int *y)
{
   if (x != y)
   {
      *x^=*y^=*x^=*y;
   }
}</pre>
At first glance, we may think nothing wrong with the code. 
However, when prompted for reason behind opting for XOR swap logic, the person was clue less. 
Perhaps any <em><strong>commutative</strong></em> operation can fulfill the need with some corner cases.
Avoid using fancy code snippets in production software. 
They create runtime surprises. 
We can observe the following notes on above code
<ol>
<li>The code behavior is undefined. 
The statement <span style="font-family: Consolas, Monaco, 'Courier New', Courier, monospace;line-height: 18px;font-size: 12px">*x^=*y^=*x^=*y; </span>modifying a variable more than once in without any <a href="http://en.wikipedia.org/wiki/Sequence_point">sequence point</a>.</li>
<li>It creates <a href="http://en.wikipedia.org/wiki/Instruction_pipeline">pipeline</a> stalls when executed on a processor with pipeline architecture.</li>
<li>The compiler can&#8217;t take advantage in optimizing the swapping operation. 
Some processors will provide single instruction to swap two variables. 
When we opted for standard library functions, there are more chances that the library would have been optimized. 
Even the compiler can recognize such standard function and generates optimum code.</li>
<li>Code readability is poor. 
It is very much important to write maintainable code.</li>
</ol>
<h2>ASCII NUL, ASCII 0 (&#8216;0&#8217;) and Numeric literal 0</h2>
The ASCII NUL and zero are represented as 0x00 and 0x30 respectively. 
An ASCII NUL character serves as sentinel characters of strings in C/C++. 
When the programmer uses &#8216;0&#8217; in his code, it will be represented as 0x30 in hex form. 
What will be filled in the binary representation of &#8216;integer&#8217; in the following program?
<code class="color1 bold">char</code> <code class="plain">charNUL = </code><code class="string">'\0'</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">integer = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">char</code> <code class="plain">charBinary = </code><code class="string">'0'</code><code class="plain">; </code>
The binary form of <em>charNUL</em> will have all its bits set to logic 0. 
The binary form of <em>integer</em> will have all its bits set to logic 0, which means each byte will be filled with NUL character (\ 0). 
The binary form of <em>charBinary</em> will be set to binary equivalent of hex 0x30.
<h2>Little and Big Endian Mystery</h2>
<strong>What are these?</strong><br />
Little and big endian are two ways of storing multibyte data-types ( int, float, etc). 
In little endian machines, last byte of binary representation of the multibyte data-type is stored first. 
On the other hand, in big endian machines, first byte of binary representation of the multibyte data-type is stored first.<br />
<!--more--><br />
Suppose integer is stored as 4 bytes (For those who are using DOS based compilers such as C++ 3.0 , integer is 2 bytes) then a variable x with value 0x01234567 will be stored as following.
<p style="font-family: georgia" align="center"><a href="http://4.bp.blogspot.com/_IEmaCFe3y9g/SO3GGEF4UkI/AAAAAAAAAAc/z7waF2Lwg0s/s1600-h/lb.GIF"><img id="BLOGGER_PHOTO_ID_5255074147691156034" style="margin: 0px auto 10px;text-align: center;cursor: pointer" src="http://4.bp.blogspot.com/_IEmaCFe3y9g/SO3GGEF4UkI/AAAAAAAAAAc/z7waF2Lwg0s/s400/lb.GIF" border="0" alt="" /></a>
<ul>
Memory representation of integer ox01234567 inside Big and little endian machines</ul>

<strong>How to see memory representation of multibyte data types on your machine?</strong><br />
Here is a sample C code that shows the byte representation of int, float and pointer. 
<br/>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* function to show bytes in memory, from location start to start+n*/</code>
<code class="keyword bold">void</code> <code class="plain">show_mem_rep(</code><code class="color1 bold">char</code> <code class="plain">*start, </code><code class="color1 bold">int</code> <code class="plain">n)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" %.2x"</code><code class="plain">, start[i]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/*Main function to call above function for 0x01234567*/</code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0x01234567; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">show_mem_rep((</code><code class="color1 bold">char</code> <code class="plain">*)&i, </code><code class="keyword bold">sizeof</code><code class="plain">(i)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
When above program is run on little endian machine, gives &#8220;67 45 23 01&#8221; as output , while if it is run on big endian machine, gives &#8220;01 23 45 67&#8221; as output.
<strong>Is there a quick way to determine endianness of your machine?</strong><br />
There are n no. 
of ways for determining endianness of your machine. 
Here is one quick way of doing the same.<br />
<h3>C++</h3>
<code class="preprocessor">#include &lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">i = 1;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*c = (</code><code class="color1 bold">char</code><code class="plain">*)&i;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(*c)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;</code><code class="string">"Little endian"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout&lt;&lt;</code><code class="string">"Big endian"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp; </code>
<code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This code is contributed by rathbhupendra </code>
<h3>C</h3>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">int</code> <code class="plain">i = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*c = (</code><code class="color1 bold">char</code><code class="plain">*)&i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(*c)&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Little endian"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Big endian"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<br />
<strong>Output:</strong>
<pre>
Little endian</pre>
In the above program, a character pointer c is pointing to an integer i. 
Since size of character is 1 byte when the character pointer is de-referenced it will contain only first byte of integer. 
If machine is little endian then *c will be 1 (because last byte is stored first) and if machine is big endian then *c will be 0.<br />
<strong><br />
Does endianness matter for programmers?</strong><br />
Most of the times compiler takes care of endianness, however, endianness becomes an issue in following cases.
It matters in network programming: Suppose you write integers to file on a little endian machine and you transfer this file to a big endian machine. 
Unless there is little endian to big endian transformation, big endian machine will read the file in reverse order. 
You can find such a practical example here.
Standard byte order for networks is big endian, also known as network byte order. 
Before transferring data on network, data is first converted to network byte order (big endian). 
Sometimes it matters when you are using type casting,  below program is an example.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">char</code> <code class="plain">arr[2] = {0x01, 0x00}; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">unsigned </code><code class="color1 bold">short</code> <code class="color1 bold">int</code> <code class="plain">x = *(unsigned </code><code class="color1 bold">short</code> <code class="color1 bold">int</code> <code class="plain">*) arr; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
In the above program, a char array is typecasted to an unsigned short integer type. 
When I run above program on little endian machine, I get 1 as output, while if I run it on a big endian machine I get 256. 
To make programs endianness independent, above programming style should be avoided.<br />
<strong><br />
What are bi-endians?</strong><br />
Bi-endian processors can run in both modes little and big endian.
<strong>What are the examples of little, big endian and bi-endian machines ?</strong><br />
Intel based processors are little endians. 
ARM processors were little endians. 
Current generation ARM processors are bi-endian.
Motorola 68K processors are big endians. 
PowerPC (by Motorola) and SPARK (by Sun) processors were big endian. 
Current version of these processors are bi-endians.<br />
<strong><br />
Does endianness affects file formats?</strong><br />
File formats which have 1 byte as a basic unit are independent of endianness e.g., ASCII files . 
Other file formats use some fixed endianness forrmat e.g, JPEG files are stored in big endian format. 
<strong><br />
Which one is better &#8212; little endian or big endian?</strong><br />
The term little and big endian came from Gulliver’s Travels by Jonathan Swift. 
Two groups could not agree by which end an egg should be opened -a- the little or the big. 
Just like the egg issue, there is no technological reason to choose one byte ordering convention over the other, hence the arguments degenerate into bickering about sociopolitical issues. 
As long as one of the conventions is selected and adhered to consistently, the choice is arbitrary.
<h2>Comparator function of qsort() in C</h2>
Standard C library provides <a href="http://www.cplusplus.com/reference/cstdlib/qsort/">qsort()</a> that can be used for sorting an array. 
As the name suggests, the function uses QuickSort algorithm to sort the given array. 
Following is prototype of qsort()<!--more-->
<code class="keyword bold">void</code> <code class="functions bold">qsort</code> <code class="plain">(</code><code class="keyword bold">void</code><code class="plain">* base, </code><code class="color1 bold">size_t</code> <code class="plain">num, </code><code class="color1 bold">size_t</code> <code class="plain">size,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">(*comparator)(</code><code class="keyword bold">const</code> <code class="keyword bold">void</code><code class="plain">*,</code><code class="keyword bold">const</code> <code class="keyword bold">void</code><code class="plain">*)); </code>
The key point about qsort() is comparator function <em>comparator</em>. 
The comparator function takes two arguments and contains logic to decide their relative order in sorted output. 
The idea is to provide flexibility so that qsort() can be used for any type (including user defined types) and can be used to obtain any desired order (increasing, decreasing or any other).
The comparator function takes two pointers as arguments (both type-casted to const void*) and defines the order of the elements by returning (in a stable and transitive manner
<pre>
int comparator(const void* p1, const void* p2);
Return value meaning
<0 The element pointed by p1 goes before the element pointed by p2
0  The element pointed by p1 is equivalent to the element pointed by p2
>0 The element pointed by p1 goes after the element pointed by p2
Source: <a href="http://www.cplusplus.com/reference/cstdlib/qsort/">http://www.cplusplus.com/reference/cstdlib/qsort/</a>
</pre>
For example, let there be an array of students where following is type of student. 
<code class="keyword bold">struct</code> <code class="plain">Student </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">age, marks; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">name[20]; </code>
<code class="plain">};</code>
Lets say we need to sort the students based on marks in ascending order. 
The comparator function will look like:
<code class="color1 bold">int</code> <code class="plain">comparator(</code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">*p, </code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">*q)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">l = ((</code><code class="keyword bold">struct</code> <code class="plain">Student *)p)->marks; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r = ((</code><code class="keyword bold">struct</code> <code class="plain">Student *)q)->marks;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(l - r); </code>
<code class="plain">} </code>
See following posts for more sample uses of qsort().<br />
<a href="https://www.geeksforgeeks.org/given-a-sequence-of-words-print-all-anagrams-together-set-2/">Given a sequence of words, print all anagrams together </a><br />
<a href="https://www.geeksforgeeks.org/dynamic-programming-set-21-box-stacking-problem/">Box Stacking Problem</a><br />
<a href="https://www.geeksforgeeks.org/closest-pair-of-points/">Closest Pair of Points</a>
Following is an interesting problem that can be easily solved with the help of <em>qsort()</em> and comparator function.<br />
<strong>Given an array of integers, sort it in such a way that the odd numbers appear first and the even numbers appear later. 
The odd numbers should be sorted in descending order and the even numbers should be sorted in ascending order.</strong>
The simple approach is to first modify the input array such that the even and odd numbers are segregated followed by applying some sorting algorithm on both parts(odd and even) separately. 
However, there exists an interesting approach with a little modification in comparator function of Quick Sort. 
The idea is to write a comparator function that takes two addresses p and q as arguments. 
Let l and r be the number pointed by p and q. 
The function uses following logic:<br />
1) If both (l and r) are odd, put the greater of two first.<br />
2) If both (l and r) are even, put the smaller of two first.<br />
3) If one of them is even and other is odd, put the odd number first.
Following is C implementation of the above approach.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// This function is used in qsort to decide the relative order </code>
<code class="comments">// of elements at addresses p and q. 
</code>
<code class="color1 bold">int</code> <code class="plain">comparator(</code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">*p, </code><code class="keyword bold">const</code> <code class="keyword bold">void</code> <code class="plain">*q) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Get the values at given addresses </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">l = *(</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*)p; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">r = *(</code><code class="keyword bold">const</code> <code class="color1 bold">int</code> <code class="plain">*)q; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// both odd, put the greater of two first. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">((l&1) && (r&1)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(r-l); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// both even, put the smaller of two first </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">( !(l&1) && !(r&1) ) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(l-r); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// l is even, put r first </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(!(l&1)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// l is odd, put l first </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">-1; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A utility function to print an array </code>
<code class="keyword bold">void</code> <code class="plain">printArr(</code><code class="color1 bold">int</code> <code class="plain">arr[], </code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; n; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d "</code><code class="plain">, arr[i]); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above function </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[] = {1, 6, 5, 2, 3, 9, 4, 7, 8}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">size = </code><code class="keyword bold">sizeof</code><code class="plain">(arr) / </code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">qsort</code><code class="plain">((</code><code class="keyword bold">void</code><code class="plain">*)arr, size, </code><code class="keyword bold">sizeof</code><code class="plain">(arr[0]), comparator); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Output array is\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">printArr(arr, size); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Output array is
9 7 5 3 1 2 4 6 8</pre>
<strong>Exercise:</strong><br />
Given an array of integers, sort it in alternate fashion. 
Alternate fashion means that the elements at even indices are sorted separately and elements at odd indices are sorted separately.
<h2>Program to validate an IP address</h2>
Write a program to Validate an IPv4 Address. 
According to Wikipedia, <a href="http://en.wikipedia.org/wiki/IP_address">IPv4 addresses </a>are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots, e.g., 172.16.254.1
<div id="practiceLinkDiv">
<h3><a href="https://practice.geeksforgeeks.org/problems/validate-an-ip-address/1">Recommended: Please solve it on &#8220;<b><i><u>PRACTICE</u></i></b>&#8221; first, before moving on to the solution.</a></h3>
Following are steps to check whether a given string is valid IPv4 address or not:
<strong>step 1)</strong> Parse string with &#8220;.&#8221; as delimiter using &#8220;<a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/strtok_r.html">strtok()</a>&#8221; function. 
<code class="plain">e.g. 
ptr = </code><code class="functions bold">strtok</code><code class="plain">(str, DELIM);</code>
<strong>step 2) </strong><br />
&#8230;&#8230;..a) If ptr contains any character which is not digit then return 0<br />
&#8230;&#8230;..b) Convert &#8220;ptr&#8221; to decimal number say &#8216;NUM&#8217;<br />
&#8230;&#8230;..c) If NUM is not in range of 0-255 return 0<br />
&#8230;&#8230;..d) If NUM is in range of 0-255 and ptr is non-NULL increment &#8220;dot_counter&#8221; by 1<br />
&#8230;&#8230;..e) if ptr is NULL goto step 3 else goto step 1
<strong>step 3)</strong> if dot_counter != 3 return 0 else return 1.
<code class="comments">// Program to check if a given string is valid IPv4 address or not </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#define DELIM "." </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* return 1 if string contain only digits, else return 0 */</code>
<code class="color1 bold">int</code> <code class="plain">valid_digit(</code><code class="color1 bold">char</code> <code class="plain">*ip_str) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(*ip_str) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(*ip_str >= </code><code class="string">'0'</code> <code class="plain">&& *ip_str &lt;= </code><code class="string">'9'</code><code class="plain">) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++ip_str; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">1; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">/* return 1 if IP string is valid, else return 0 */</code>
<code class="color1 bold">int</code> <code class="plain">is_valid_ip(</code><code class="color1 bold">char</code> <code class="plain">*ip_str) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i, num, dots = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">*ptr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ip_str == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// See following link for strtok() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// <a href="http://pubs.opengroup.org/onlinepubs/009695399/functions/strtok_r.html">http://pubs.opengroup.org/onlinepubs/009695399/functions/strtok_r.html</a> </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = </code><code class="functions bold">strtok</code><code class="plain">(ip_str, DELIM); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ptr == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(ptr) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* after parsing string, it must contain only digits */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(!valid_digit(ptr)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">num = </code><code class="functions bold">atoi</code><code class="plain">(ptr); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* check for valid IP */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(num >= 0 && num &lt;= 255) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* parse remaining string */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">ptr = </code><code class="functions bold">strtok</code><code class="plain">(NULL, DELIM); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(ptr != NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++dots; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* valid IP string must contain 3 dots */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(dots != 3) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">1; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver program to test above functions </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ip1[] = </code><code class="string">"128.0.0.1"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ip2[] = </code><code class="string">"125.16.100.1"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ip3[] = </code><code class="string">"125.512.100.1"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ip4[] = </code><code class="string">"125.512.100.abc"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">is_valid_ip(ip1)? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Valid\n"</code><code class="plain">): </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Not valid\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">is_valid_ip(ip2)? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Valid\n"</code><code class="plain">): </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Not valid\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">is_valid_ip(ip3)? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Valid\n"</code><code class="plain">): </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Not valid\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">is_valid_ip(ip4)? </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Valid\n"</code><code class="plain">): </code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Not valid\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Valid
Valid
Not valid
Not valid</pre>
<h2>Multithreading in C</h2>
<strong>What is a Thread? </strong><br />
A thread is a single sequence stream within in a process. 
Because threads have some of the properties of processes,<!--more--> they are sometimes called <i>lightweight processes</i>. 
<strong>What are the differences between process and thread?</strong><br />
Threads are not independent of one other like processes as a result threads shares with other threads their code section, data section and OS resources like open files and signals. 
But, like process, a thread has its own program counter (PC), a register set, and a stack space.
<strong>Why Multithreading?</strong><br />
Threads are popular way to improve application through parallelism. 
For example, in a browser, multiple tabs can be different threads. 
MS word uses multiple threads, one thread to format the text, other thread to process inputs, etc.<br />
Threads operate faster than processes due to following reasons:<br />
1) Thread creation is much faster.<br />
2) Context switching between threads is much faster.<br />
3) Threads can be terminated easily<br />
4) Communication between threads is faster.

See <a href="http://www.personal.kent.edu/%7Ermuhamma/OpSystems/Myos/threads.htm">http://www.personal.kent.edu/~rmuhamma/OpSystems/Myos/threads.htm</a> for more details.
<strong>Can we write multithreading programs in C?</strong><br />
Unlike Java, multithreading is not supported by the language standard. 
<a href="http://en.wikipedia.org/wiki/POSIX_Threads">POSIX Threads (or Pthreads)</a> is a POSIX standard for threads. 
Implementation of pthread is available with gcc compiler. 
<strong>A simple C program to demonstrate use of pthread basic functions</strong><br />
Please note that the below program may compile only with C compilers with pthread library.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;unistd.h>&nbsp; //Header file for sleep(). 
man 3 sleep for details. 
</code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A normal C function that is executed as a thread&nbsp; </code>
<code class="comments">// when its name is specified in pthread_create() </code>
<code class="keyword bold">void</code> <code class="plain">*myThreadFun(</code><code class="keyword bold">void</code> <code class="plain">*vargp) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sleep(1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Printing GeeksQuiz from Thread \n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t thread_id; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Before Thread\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_id, NULL, myThreadFun, NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_id, NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"After Thread\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="plain">}</code>
In main() we declare a variable called thread_id, which is of type pthread_t, which is an integer used to identify the thread in the system. 
After declaring thread_id, we call pthread_create() function to create a thread.<br />
pthread_create() takes 4 arguments.<br />
The first argument is a pointer to thread_id which is set by this function.<br />
The second argument specifies attributes. 
If the value is NULL, then default attributes shall be used.<br />
The third argument is name of function to be executed for the thread to be created.<br />
The fourth argument is used to pass arguments to the function, myThreadFun.<br />
The pthread_join() function for threads is the equivalent of wait() for processes. 
A call to pthread_join blocks the calling thread until the thread with identifier equal to the first argument terminates. 
<strong>How to compile above program?</strong><br />
To compile a multithreaded program using gcc, we need to link it with the pthreads library. 
Following is the command used to compile the program.
<pre>gfg@ubuntu:~/$ gcc multithread.c -lpthread
gfg@ubuntu:~/$ ./a.out
Before Thread
Printing GeeksQuiz from Thread 
After Thread
gfg@ubuntu:~/$ </pre>
<strong>A C program to show multiple threads with global and static variables</strong><br />
As mentioned above, all threads share data segment. 
Global and static variables are stored in data segment. 
Therefore, they are shared by all threads. 
The following example program demonstrates the same.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Let us create a global variable to change it in threads </code>
<code class="color1 bold">int</code> <code class="plain">g = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// The function to be executed by all threads </code>
<code class="keyword bold">void</code> <code class="plain">*myThreadFun(</code><code class="keyword bold">void</code> <code class="plain">*vargp) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Store the value argument passed to this thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">*myid = (</code><code class="color1 bold">int</code> <code class="plain">*)vargp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Let us create a static variable to observe its changes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">static</code> <code class="color1 bold">int</code> <code class="plain">s = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Change static and global variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">++s; ++g; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Print the argument, static and global variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Thread ID: %d, Static: %d, Global: %d\n"</code><code class="plain">, *myid, ++s, ++g); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t tid; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Let us create three threads </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; 3; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&tid, NULL, myThreadFun, (</code><code class="keyword bold">void</code> <code class="plain">*)&tid); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_exit(NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
gfg@ubuntu:~/$ gcc multithread.c -lpthread
gfg@ubuntu:~/$ ./a.out
Thread ID: 3, Static: 2, Global: 2
Thread ID: 3, Static: 4, Global: 4
Thread ID: 3, Static: 6, Global: 6
gfg@ubuntu:~/$ </pre>
Please note that above is simple example to show how threads work. 
Accessing a global variable in a thread is generally a bad idea. 
What if thread 2 has priority over thread 1 and thread 1 needs to change the variable. 
In practice, if it is required to access global variable by multiple threads, then they should be accessed using a mutex.
<h2>Assertions in C/C++</h2>
Assertions are statements used to test assumptions made by programmer. 
For example, we may use assertion to check if pointer returned by malloc() is NULL or not. 
<!--more-->
Following is syntax for assertion.
<pre>void assert( int expression ); </pre>
If expression evaluates to 0 (false), then the expression, sourcecode filename, and line number are sent to the standard error, and then abort() function is called. 

For example, consider the following program.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;assert.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 7; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/*&nbsp; Some big code in between and let's say x&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">is accidentally changed to 9&nbsp; */</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x = 9; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Programmer assumes x to be 7 in rest of the code </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">assert</code><code class="plain">(x==7); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">/* Rest of the code */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output 
<pre>
Assertion failed: x==7, file test.cpp, line 13 
This application has requested the Runtime to terminate it in an unusual 
way. 
Please contact the application's support team for more information.
</pre>
<strong>Assertion Vs Normal Error Handling</strong><br />
Assertions are mainly used to check logically impossible situations. 
For example, they can be used to check the state a code expects before it starts running or state after it finishes running. 
Unlike normal error handling, assertions are generally disabled at run-time. 
Therefore, it is not a good idea to write statements in asser() that can cause side effects. 
For example writing something like assert(x = 5) is not a good ideas as x is changed and this change won&#8217;t happen when assertions are disabled. 
See <a href="https://www.geeksforgeeks.org/understanding-exit-abort-and-assert/">this </a>for more details.
<strong>Ignoring Assertions</strong><br />
In C/C++, we can completely remove assertions at compile time using the preprocessor NODEBUG.
<code class="comments">// The below program runs fine because NDEBUG is defined </code>
<code class="preprocessor"># define NDEBUG </code>
<code class="preprocessor"># include &lt;assert.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 7; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">assert</code> <code class="plain">(x==5); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The above program compiles and runs fine. 
In Java, assertions are not enabled by default and we must pass an option to run-time engine to enable them.
<strong>Reference:</strong><br />
<a href="http://en.wikipedia.org/wiki/Assertion_%28software_development%29">http://en.wikipedia.org/wiki/Assertion_%28software_development%29</a>
<h2>fork() in C</h2>
Fork system call is used for creating a new process, which is called <strong><em>child process</em></strong>, which runs concurrently with the process that makes the fork() call (parent process). 
After a new child process is created, both processes will execute the next instruction following the fork() system call. 
A child process uses the same pc(program counter), same CPU registers, same open files which use in the parent process.
It takes no parameters and returns an integer value. 
Below are different values returned by fork().
<strong><em>Negative Value</em></strong>: creation of a child process was unsuccessful.<br />
<strong><em>Zero</em></strong>: Returned to the newly created child process.<br />
<strong><em>Positive value</em></strong>: Returned to parent or caller. 
The value contains process ID of newly created child process.
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Fork_in_C.jpg"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Fork_in_C.jpg" alt="creating a fork process"></a>
<strong><em>Please note that the above programs don’t compile in Windows environment.</em></strong>
<ol>
<li><strong>Predict the Output of the following program:</strong>.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// make two process which run same </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// program after this instruction </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello world!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
Hello world!
Hello world!
</pre>
</li>

<li><strong>Calculate number of times hello is printed:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"hello\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
hello
hello
hello
hello
hello
hello
hello
hello
</pre>
The number of times &#8216;hello&#8217; is printed is equal to number of process created. 
Total Number of Processes = 2<sup>n</sup>, where n is number of fork system calls. 
So here n = 3, 2<sup>3</sup> = 8
Let us put some label names for the three lines:
<pre>
fork ();   // Line 1
fork ();   // Line 2
fork ();   // Line 3
       L1       // There will be 1 child process 
    /     \     // created by line 1.
  L2      L2    // There will be 2 child processes
 /  \    /  \   //  created by line 2
L3  L3  L3  L3  // There will be 4 child processes 
                // created by line 3
</pre>
So there are total eight processes (new child processes and one original process).
If we want to represent the relationship between the processes as a tree hierarchy it would be the following:
The main process: P0<br />
Processes created by the 1st fork: P1<br />
Processes created by the 2nd fork: P2, P3<br />
Processes created by the 3rd fork: P4, P5, P6, P7
<pre>
             P0
         /   |   \
       P1    P4   P2
      /  \          \
    P3    P6         P5
   /
 P7
</pre>
</li>
<li> <strong>Predict the Output of the following program:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="keyword bold">void</code> <code class="plain">forkexample() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// child process because return value zero </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fork() == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello from Child!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// parent process because return value non-zero. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello from Parent!\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">forkexample(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
          
<pre>
1.
Hello from Child!
Hello from Parent!
     (or)
2.
Hello from Parent!
Hello from Child!
</pre>
In the above code, a child process is created. 
fork() returns 0 in the child process and positive integer in the parent process.<br />
Here, two outputs are possible because the parent process and child process are running concurrently. 
So we don’t know whether the OS will first give control to the parent process or the child process.
<strong>Important:</strong> Parent process and child process are running the same program, but it does not mean they are identical. 
OS allocate different data and states for these two processes, and the control flow of these processes can be different. 
See next example:</li>
<li><strong>Predict the Output of the following program:</strong>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">forkexample() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fork() == 0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Child has x = %d\n"</code><code class="plain">, ++x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Parent has x = %d\n"</code><code class="plain">, --x); </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">forkexample(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>
Parent has x = 0
Child has x = 2
     (or)
Child has x = 2
Parent has x = 0
</pre>
Here, global variable change in one process does not affected two other processes because data/state of two processes are different. 
And also parent and child run simultaneously so two outputs are possible.
   </li>
</ol>
<p align="center"><strong>fork() vs exec()</strong>
The fork system call creates a new process. 
The new process created by fork() is a copy of the current process except for the returned value. 
The exec() system call replaces the current process with a new program.
<strong>Exercise:</strong>
<ol>
<li>A process executes the following code:
<code class="keyword bold">for</code> <code class="plain">(i = 0; i &lt; n; i++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
The total number of child processes created is: (GATE-CS-2008)<br />
(A) n<br />
(B) 2^n – 1<br />
(C) 2^n<br />
(D) 2^(n+1) – 1;
See <a href="https://www.geeksforgeeks.org/gate-gate-cs-2008-question-66/">this</a> for solution.
</li>
<li>Consider the following code fragment:
<code class="keyword bold">if</code> <code class="plain">(fork() == 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = a + 5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d, %d\n"</code><code class="plain">, a, &a); </code>
<code class="plain">} </code>
<code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">a = a –5; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d, %d\n"</code><code class="plain">, a, &a); </code>
<code class="plain">} </code>
Let u, v be the values printed by the parent process, and x, y be the values printed by the child process. 
Which one of the following is TRUE? (GATE-CS-2005)<br />
(A) u = x + 10 and v = y<br />
(B) u = x + 10 and v != y<br />
(C) u + 10 = x and v = y<br />
(D) u + 10 = x and v != y<br />
See <a href="https://www.geeksforgeeks.org/gate-gate-cs-2005-question-72/">this</a> for solution.
</li>
<li>
Predict output of below program.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork() && fork() || fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fork(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"forked\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
See <a href="https://www.geeksforgeeks.org/fork-and-binary-tree/">this</a> for solution</li></ol>
<strong>Related Articles :</strong><br />
<a href="https://www.geeksforgeeks.org/c-program-demonstrate-fork-and-pipe/">C program to demonstrate fork() and pipe()</a><br />
<a href="https://www.geeksforgeeks.org/zombie-and-orphan-processes-in-c/">Zombie and Orphan Processes in C</a><br />
<a href="https://www.geeksforgeeks.org/fork-memory-shared-bw-processes-created-using/">fork() and memory shared b/w processes created using it.</a>
<h2>Interesting Facts in C Programming</h2>
Below are some interesting facts about C programming:
<strong>1)</strong> The case labels of a switch statement can occur inside if-else statements.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 2, b = 2; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">switch</code><code class="plain">(a) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">1: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(b==5) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">case</code> <code class="plain">2: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksforGeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">case</code> <code class="plain">3: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
Output : 
<pre>GeeksforGeeks</pre>
<strong>2)</strong> arr[index] is same as index[arr]<br />
The reason for this to work is, array elements are accessed using pointer arithmetic.
<code class="comments">// C program to demonstrate that arr[0] and </code>
<code class="comments">// 0[arr] </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main()&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr[0] = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, 0[arr] ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
Output : 
<pre>1</pre>
<strong>3)</strong> We can use &#8216;&lt;:, :&gt;&#8217; in place of &#8216;[,]&#8217; and &#8216;&lt;%, %&gt;&#8217; in place of &#8216;{,}&#8217;
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">&lt;% </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">arr &lt;:10:>; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">arr&lt;:0:> = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, arr&lt;:0:>); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">%> </code>
Output : 
<pre>1</pre>
<strong>4) </strong>Using #include in strange places.<br />
Let &#8220;a.txt&#8221; contains (&#8220;GeeksforGeeks&#8221;);
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="preprocessor">#include "a.txt" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">; </code>
<code class="plain">} </code>
Output : 
<pre>GeeksforGeeks</pre>
<strong>5)</strong> We can ignore input in scanf() by using an &#8216;*&#8217; after &#8216;%&#8217; in format specifiers
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Let we input 10 20, we get output as 20 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (First input is ignored) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If we remove * from below line, we get 10. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%*d%d"</code><code class="plain">, &a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">( </code><code class="string">"%d "</code><code class="plain">,&nbsp; a);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="plain">} </code>
<h2>Precision of floating point numbers in C++ (floor(), ceil(), trunc(), round() and setprecision())</h2>
Decimal equivalent of 1/3 is 0.33333333333333…. 
An infinite length number would require infinite memory to store, and we typically have 4 or 8 bytes. 
Therefore, Floating point numbers store only a certain number of significant digits, and the rest are lost. 
The <strong>precision</strong> of a floating point number defines how many significant digits it can represent without information loss. 
When outputting floating point numbers, cout has a default precision of 6 and it truncates anything after that.
Given below are few libraries and methods which are used to provide precision to floating point numbers in C++:
<center><strong>floor(): </strong> </center><br />
Floor rounds off the given value to the closest integer which is less than the given value.<br/>
<code class="comments">// C++ program to demonstrate working of floor() </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x =1.411, y =1.500, z =1.711; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(x) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(y) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(z) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">a =-1.411, b =-1.500, c =-1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(a) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(b) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">floor</code><code class="plain">(c) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>1
1
1
-2
-2
-2
</pre>
<center><strong>ceil(): </strong></center><br />
Ceil rounds off the given value to the closest integer which is more than the given value.
<code class="comments">// C++ program to demonstrate working of ceil() </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 1.411, y = 1.500, z = 1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(x) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(y) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(z) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">a = -1.411, b = -1.500, c = -1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(a) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(b) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="functions bold">ceil</code><code class="plain">(c) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>2
2
2
-1
-1
-1
</pre>
&nbsp;
<center><strong>trunc(): </strong></center><br />
Trunc rounds removes digits after decimal point.
<code class="comments">// C++ program to demonstrate working of trunc() </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 1.411, y = 1.500, z = 1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(x) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(y) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(z) &lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">a = -1.411, b = -1.500, c = -1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(a) &lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(b) &lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; trunc(c) &lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>1
1
1
-1
-1
-1
</pre>
<center><strong>round(): </strong></center><br />
Rounds given number to the closest integer.
<code class="comments">// C++ program to demonstrate working of round() </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">x = 1.411, y = 1.500, z = 1.611; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(x) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(y) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(z) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">a = -1.411, b = -1.500, c = -1.611; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(a) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(b) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; round(c) &lt;&lt; endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>1
2
2
-1
-2
-2
</pre>
&nbsp;
<center><strong>setprecision(): </strong></center><br />
Setprecision when used along with &#8216;fixed&#8217; provides precision to floating point numbers correct to decimal numbers mentioned in the brackets of the setprecison.
          
<code class="comments">// C++ program to demonstrate working of setprecision() </code>
<code class="comments">// in C/C++ </code>
<code class="preprocessor">#include&lt;bits/stdc++.h> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">double</code> <code class="plain">pi = 3.14159, npi = -3.14159; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(1) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; fixed &lt;&lt; setprecision(6) &lt;&lt; pi &lt;&lt;</code><code class="string">" "</code><code class="plain">&lt;&lt;npi&lt;&lt;endl; </code>
<code class="plain">} </code>
Output:
<pre>3 -3
3.1 -3.1
3.14 -3.14
3.142 -3.142
3.1416 -3.1416
3.14159 -3.14159
3.141590 -3.141590
</pre>
<strong>Note: </strong>When the value mentioned in the setprecision() exceeds the number of floating point digits in the original number then 0 is appended to floating point digit to match the precision mentioned by the user.
There exists other methods too to provide precision to floating point numbers. 
The above mentioned are few of the most commonly used methods to provide precision to floating point numbers during competitive coding.
<h2>Concept of setjump and longjump in C</h2>
“Setjump” and “Longjump” are defined in <a href="https://en.wikipedia.org/wiki/Setjmp.h">setjmp.h</a>, a header file in C standard library. 
<ul>
<li><strong>setjump(jmp_buf buf)</strong> : uses buf to remember current position and returns 0.</li>
<li><strong>longjump(jmp_buf buf, i)</strong> : Go back to place buf is pointing to and return i .</li>
</ul>
<code class="comments">// A simple C program to demonstrate working of setjmp() and longjmp() </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;setjmp.h> </code>
<code class="functions bold">jmp_buf</code> <code class="plain">buf; </code>
<code class="keyword bold">void</code> <code class="plain">func() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Welcome to GeeksforGeeks\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Jump to the point setup by setjmp </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">longjmp</code><code class="plain">(buf, 1); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geek2\n"</code><code class="plain">); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Setup jump position using buf and return 0 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">setjmp</code><code class="plain">(buf)) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geek3\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Geek4\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">func(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output : 
<pre>
Geek4
Welcome to GeeksforGeeks
Geek3</pre>
The main feature of these function is to provide a way that deviates from standard call and return sequence. 
This is mainly used to implement exception handling in C. 
<strong>setjmp</strong> can be used like <strong>try</strong> (in languages like C++ and Java). 
The call to <strong>longjmp</strong> can be used like <strong>throw</strong> (Note that longjmp() transfers control to the point set by setjmp()).
<h2>nextafter() and nexttoward() in C/C++</h2>
<strong>How would you solve below problems in C/C++?</strong>
<ul>
<li>What is the smallest representable positive floating point number in C/C++?</li>
<li>What is the largest representable negative floating point number in C/C++?</li>
<li>Given a positive floating point number x, find the largest representable floating point value smaller than x?</li>
</ul>
<strong>nextafter(x, y)  and nexttoward(x.y)</strong><br />
In C and C++, both nextafter(x, y)  and nexttoward(x.y)  are similar functions defined in math.h or cmath header files. 
They both return next representable value after x in the direction of y. 
<em>nexttoward() has more precise second parameter y.</em>
The following program demonstrates the concept :<br/>
<code class="comments">// C program to demonstrate use of nextafter() and nexttoward() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;math.h> </code>
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using nextafter </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Smallest positive floating point number : %e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nextafter(0.0, 1.0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Largest negative floating point number :%e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nextafter(0.0, -1.0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Largest positive floating point number smaller than 0.5 : %e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nextafter(0.5, 0.0)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using nexttoward </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Smallest positive floating point number : %e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nexttoward(0.0, 1.0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Largest negative floating point number : %e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nexttoward(0.0, -1.0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"Largest positive floating point number smaller than 0.5 : %e\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">nexttoward(0.5, 0.0)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
nextafter first value greater than zero: 4.940656e-324
nextafter first value less than zero: -4.940656e-324
nexttoward first value greater than zero: 4.940656e-324
nexttoward first valnextafter first value greater than zero: 4.940656e-324
nextafter first value less than zero: -4.940656e-324
nexttoward first value greater than zero: 4.940656e-324
nexttoward first value less than zero: -4.940656e-324 ue less than zero: -4.940656e-324 </pre>
<h2>pthread_cancel() in C with example</h2>
<b>prerequisite: <a href="https://www.geeksforgeeks.org/multithreading-c-2/">Multithreading</a>, <a href="https://www.geeksforgeeks.org/pthread_self-c-example/">pthread_self() in C with Example</a></b>
pthread_cancel() = This function cancel a particular thread using thread id. 
This function send a cancellation request to the thread.
<b>Syntax : &#8211; int pthread_cancel(pthread_t thread); </b>
<b>First Program : &#8211; </b> Cancel self thread
&nbsp;
<code class="comments">// C program to demonstrates cancellation of self thread&nbsp; </code>
<code class="comments">// using thread id </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code><code class="plain">* calls(</code><code class="keyword bold">void</code><code class="plain">* ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"GeeksForGeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// To exit the current thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pthread_self() return the particular thread id </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_cancel(pthread_self());&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// NULL when no attribute </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t </code><code class="keyword bold">thread</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calls is a function name </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&</code><code class="keyword bold">thread</code><code class="plain">, NULL, calls, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Waiting for when thread is completed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(</code><code class="keyword bold">thread</code><code class="plain">, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}</code>
<b>Output:</b>
<pre>GeeksForGeeks
</pre>
&nbsp;
If you use Linux then compile this program <b> gcc program_name.c -lpthread </b>
<b>Second Program : &#8211; </b> Cancel other thread
&nbsp;
<code class="comments">// C program to demonstrates cancellation of another thread&nbsp; </code>
<code class="comments">// using thread id </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// To Count </code>
<code class="color1 bold">int</code> <code class="plain">counter = 0;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// for temporary thread which will be&nbsp; </code>
<code class="comments">// store thread id of second thread </code>
<code class="plain">pthread_t tmp_thread;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// thread_one call func </code>
<code class="keyword bold">void</code><code class="plain">* func(</code><code class="keyword bold">void</code><code class="plain">* p)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"thread number one\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sleep(1);&nbsp;&nbsp; </code><code class="comments">// sleep 1 second </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">counter++;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for exiting if counter = = 5 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(counter = = 2) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for cancel thread_two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_cancel(tmp_thread);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for exit from thread_one&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_exit(NULL);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// thread_two call func2 </code>
<code class="keyword bold">void</code><code class="plain">* func2(</code><code class="keyword bold">void</code><code class="plain">* p)&nbsp; </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// store thread_two id to tmp_thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">tmp_thread = pthread_self();&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code> <code class="plain">(1) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"thread Number two"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sleep(1); </code><code class="comments">// sleep 1 second </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declare two thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t thread_one, thread_two;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create thread_one </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_one, NULL, func, NULL); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create thread_two&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_two, NULL, func2, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// waiting for when thread_one is completed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_one, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// waiting for when thread_two is completed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_two, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">}</code>
<b>Output:</b>
<pre>thread number one
thread number two
thread number one 
thread number two
</pre>
&nbsp;
If you use Linux then compile this program <b>gcc program_name.c -lpthread</b>
<h2>pthread_equal() in C with example</h2>
Prerequisite : <a href="https://www.geeksforgeeks.org/multithreading-c-2/">Multithreading</a>, <a href="https://www.geeksforgeeks.org/pthread_self-c-example/">pthread_self() in C with Example</a>
pthread_equal() = This compares two thread which is equal or not. 
This function compares two thread identifiers. 
It return &#8216;0&#8217; and non zero value. 
If it is equal then return non zero value else return 0.
<b>Syntax:- int pthread_equal (pthread_t t1, pthread_t t2); </b>
&nbsp;
<b>First Method</b> :- Compare with self thread
<code class="comments">// C program to demonstrate working of pthread_equal() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">pthread_t tmp_thread; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code><code class="plain">* func_one(</code><code class="keyword bold">void</code><code class="plain">* ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// in this field we can compare two thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pthread_self gives a current thread id </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(pthread_equal(tmp_thread, pthread_self())) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"equal\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"not equal\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// thread one </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t thread_one; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// assign the id of thread one in temporary </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// thread which is global declared&nbsp;&nbsp; r </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">tmp_thread = thread_one; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create a thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_one, NULL, func_one, NULL); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// wait for thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_one, NULL); </code>
<code class="plain">} </code>
Output:
<pre>equal
</pre>
&nbsp;
<b>Second Method</b> :- Compare with other thread
<code class="comments">// C program to demonstrate working of pthread_equal() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;unistd.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// global declared pthread_t variable </code>
<code class="plain">pthread_t tmp_thread; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code><code class="plain">* func_one(</code><code class="keyword bold">void</code><code class="plain">* ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">tmp_thread = pthread_self(); </code><code class="comments">// assign the id of thread one in </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// temporary thread which is global declared </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code><code class="plain">* func_two(</code><code class="keyword bold">void</code><code class="plain">* ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t thread_two = pthread_self(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// compare two thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(pthread_equal(tmp_thread, thread_two)) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"equal\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"not equal\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t thread_one, thread_two; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// creating thread one </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_one, NULL, func_one, NULL); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// creating thread two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&thread_two, NULL, func_two, NULL); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// wait for thread one </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_one, NULL); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// wait for thread two </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(thread_two, NULL); </code>
<code class="plain">} </code>
Output:
<pre>not equal
</pre>
<h2>pthread_self() in C with Example</h2>
Prerequisite : <a href="https://www.geeksforgeeks.org/multithreading-c-2/">Multithreading in C</a>
<b>Syntax :- pthread_t pthread_self(void);</b><br />
</br><br />
The pthread_self() function returns the ID of the thread in which it is invoked.<br />
</br>
<code class="comments">// C program to demonstrate working of pthread_self() </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="keyword bold">void</code><code class="plain">* calls(</code><code class="keyword bold">void</code><code class="plain">* ptr) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// using pthread_self() get current thread id </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In function \nthread id = %d\n"</code><code class="plain">, pthread_self()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_exit(NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_t </code><code class="keyword bold">thread</code><code class="plain">; </code><code class="comments">// declare thread </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_create(&</code><code class="keyword bold">thread</code><code class="plain">, NULL, calls, NULL); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"In main \nthread id = %d\n"</code><code class="plain">, </code><code class="keyword bold">thread</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_join(</code><code class="keyword bold">thread</code><code class="plain">, NULL);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
</br><br />
<b>Output:</b>
<pre>
In function
thread id = 1
In main
thread id = 1
</pre>
</br><br />
<h2>Local Labels in C</h2>
Everybody who has programmed in C programming language must be aware about &#8220;goto&#8221; and &#8220;labels&#8221; used in C to jump within a C function. 
GCC provides an extension to C called “local labels”. 
<!--more-->
<strong>Conventional Labels vs Local Labels</strong><br />
Conventional labels in C have function scope. 
Where as local label can be scoped to a inner nested block. 
Therefore, conventional Labels cannot be declared more than once in a function and that is where local labels are used. 
A label can appear more than once in function when the label is inside a macro and macro is expanded multiple times in a function. 
For example if a macro funcMacro()  has definition which involves jump instructions (goto statement) within the block and funcMacro is used by a function foo() several times.<br/>
<code class="preprocessor">#define funcMacro(params …) </code>
<code class="keyword bold">do</code> <code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(cond == </code><code class="keyword bold">true</code><code class="plain">)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;some code >&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">x:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;some code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="plain">} </code><code class="keyword bold">while</code><code class="plain">(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">Void foo() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;some code> </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">funcMacro(params …); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;some code > </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">funcMacro(params…); </code>
<code class="plain">} </code>
In such a function foo() , the function macro will be expanded two times.<br />
This will result in having more than one definition of label ‘x’ in a function, which leads to confusion to the compiler and results in compilation error. 
In such cases local labels are useful.<br />
 <br />
The above problem can be avoided by using local labels. 
A local label are declared as  below: 
<pre>
     __label__ label; </pre>
Local label declarations must come at the beginning of the block, before any ordinary declarations or statements.
Below is C example where a macro IS_STR_EMPTY() is expanded multiple times. 
Since local labels have block scope and every expansion of macro causes a new do while block, the program compiles and runs fine.
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">//Function macro using local labels </code>
<code class="preprocessor">#define IS_STR_EMPTY(str)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="keyword bold">do</code> <code class="plain">{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">__label__&nbsp; empty, not_empty, </code><code class="functions bold">exit</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(</code><code class="functions bold">strlen</code><code class="plain">(str))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">not_empty;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="plain">\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="plain">empty;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">\ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">not_empty:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"string&nbsp; = %s\n"</code><code class="plain">, str);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">goto</code> <code class="functions bold">exit</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">empty:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"string is empty\n"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">: ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="plain">} </code><code class="keyword bold">while</code><code class="plain">(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">string[20] = {</code><code class="string">'\0'</code><code class="plain">}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//Pass empty string to Macro function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">IS_STR_EMPTY(string); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//Pass non-empty string to Macro function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strcpy</code><code class="plain">(string, </code><code class="string">"geeksForgeeks"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">IS_STR_EMPTY(string); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
Output: 
<pre>string is empty
string  = geeksForgeeks</pre>
<h2>lvalue and rvalue in C language</h2>
<strong><u>L-value</u>:</strong> &#8220;l-value&#8221; refers to memory location which identifies an object. 
l-value may appear as either left hand or right hand side of an assignment operator(=). 
l-value often represents as identifier.
Expressions referring to modifiable locations are called &#8220;<strong>modifiable l-values</strong>&#8220;. 
A modifiable l-value cannot have an array type, an incomplete type, or a type with the <strong>const</strong> attribute. 
For structures and unions to be modifiable <strong>lvalues</strong>, they must not have any members with the <strong>const</strong> attribute. 
The name of the identifier denotes a storage location, while the value of the variable is the value stored at that location.
An identifier is a modifiable <strong>lvalue</strong> if it refers to a memory location and if its type is arithmetic, structure, union, or pointer. 
For example, if ptr is a pointer to a storage region, then <strong>*ptr</strong> is a modifiable l-value that designates the storage region to which <strong>ptr</strong> points.
In C, the concept was renamed as <strong>“locator value”</strong>, and referred to expressions that locate (designate) objects. 
The l-value is one of the following:
<ol>
<li>
        The name of the variable of any type i.e, an identifier of integral, floating, pointer, structure, or union type.
   </li>
<li>
        A subscript ([ ]) expression that does not evaluate to an array.
   </li>
<li>
        A unary-indirection (*) expression that does not refer to an array
   </li>
<li>
        An l-value expression in parentheses.
   </li>
<li>
        A <strong>const</strong> object (a nonmodifiable l-value).
   </li>
<li>
        The result of indirection through a pointer, provided that it isn&#8217;t a function pointer.
   </li>
<li>
        The result of member access through pointer(-&gt; or .)
   </li>
</ol>
<code class="comments">// declare a an object of type 'int' </code>
<code class="color1 bold">int</code> <code class="plain">a; </code>
&nbsp;
<code class="comments">// a is an expression referring to an </code>
<code class="comments">// 'int' object as l-value </code>
<code class="plain">a = 1; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">b = a; </code><code class="comments">// Ok, as l-value can appear on right </code>
&nbsp;
<code class="comments">// Switch the operand around '=' operator </code>
<code class="plain">9 = a; </code>
&nbsp;
<code class="comments">// Compilation error: </code>
<code class="comments">// as assignment is trying to change the </code>
<code class="comments">// value of assignment operator </code>
<strong><u>R-value</u></strong>: r-value&#8221; refers to data value that is stored at some address in memory. 
A r-value is an expression that can&#8217;t have a value assigned to it which means r-value can appear on right but not on left hand side of an assignment operator(=).
<code class="comments">// declare a, b an object of type 'int' </code>
<code class="color1 bold">int</code> <code class="plain">a = 1, b; </code>
&nbsp;
<code class="plain">a + 1 = b; </code><code class="comments">// Error, left expression is </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// is not variable(a + 1) </code>
&nbsp;
<code class="comments">// declare pointer variable 'p', and 'q' </code>
<code class="color1 bold">int</code> <code class="plain">*p, *q; </code><code class="comments">// *p, *q are lvalue </code>
&nbsp;
<code class="plain">*p = 1; </code><code class="comments">// valid l-value assignment </code>
&nbsp;
<code class="comments">// below is invalid - "p + 2" is not an l-value&nbsp; </code>
<code class="comments">// p + 2 = 18;&nbsp; </code>
&nbsp;
<code class="plain">q = p + 5; </code><code class="comments">// valid - "p + 5" is an r-value </code>
&nbsp;
<code class="comments">// Below is valid - dereferencing pointer </code>
<code class="comments">// expression gives an l-value </code>
<code class="plain">*(p + 2) = 18; </code>
&nbsp;
<code class="plain">p = &b;&nbsp; </code>
&nbsp;
<code class="color1 bold">int</code> <code class="plain">arr[20]; </code><code class="comments">// arr[12] is an lvalue; equivalent </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// to *(arr+12) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Note: arr itself is also an lvalue </code>
&nbsp;
<code class="keyword bold">struct</code> <code class="plain">S { </code><code class="color1 bold">int</code> <code class="plain">m; }; </code>
&nbsp;
<code class="keyword bold">struct</code> <code class="plain">S obj; </code><code class="comments">// obj and obj.m are lvalues </code>
&nbsp;
<code class="comments">// ptr-> is an lvalue; equivalent to (*ptr).m </code>
<code class="comments">// Note: ptr and *ptr are also lvalues </code>
<code class="keyword bold">struct</code> <code class="plain">S* ptr = &obj; </code>
<strong>Note</strong>: The unary &amp; (address-of) operator requires an lvalue as its operand. 
That is, &amp;n is a valid expression only if n is an lvalue. 
Thus, an expression such as &amp;12 is an error. 
Again, 12 does not refer to an object, so it&#8217;s not addressable. 
For instance,
<code class="comments">// declare a as int variable and </code>
<code class="comments">// 'p' as pointer variable </code>
<code class="color1 bold">int</code> <code class="plain">a, *p; </code>
&nbsp;
<code class="plain">p = &a; </code><code class="comments">// ok, assignment of address </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// at l-value </code>
&nbsp;
<code class="plain">&a = p;&nbsp;&nbsp;&nbsp; </code><code class="comments">// error: &a is an r-value </code>
&nbsp;
<code class="color1 bold">int</code> <code class="plain">x, y; </code>
&nbsp;
<code class="plain">(&nbsp; x &lt; y ? y : x) = 0; </code><code class="comments">// It's valid because the ternary </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// expression preserves the "lvalue-ness" </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// of both its possible return values </code>
<blockquote>Remembering the mnemonic, that <strong>lvalues</strong> can appear on the left of an assignment operator while <strong>rvalues</strong> can appear on the right</blockquote>
<strong>Reference:</strong><br />
<a href="https://msdn.microsoft.com/en-us/library/bkbs2cds.aspx">https://msdn.microsoft.com/en-us/library/bkbs2cds.aspx</a>
<h2>Get the stack size and set the stack size of thread attribute in C</h2>
Prerequisite : <a href="https://www.geeksforgeeks.org/multithreading-c-2/">Multithreading</a>
<b>Syntax :</b> 
<code class="comments">// to get size of stack </code>
<code class="color1 bold">int</code> <code class="plain">pthread_attr_getstacksize(</code><code class="keyword bold">const</code> <code class="plain">pthread_attr_t* restrict attr, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">size_t</code><code class="plain">* restrict stacksize); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// to set size of stack </code>
<code class="color1 bold">int</code> <code class="plain">pthread_attr_setstacksize(pthread_attr_t* attr, </code><code class="color1 bold">size_t</code> <code class="plain">stacksize); </code>
.<br />
<b>pthread_attr_getstacksize() :</b><br />
It is use for get threads stack size. 
The stacksize attribute gives the minimum stack size allocated to threads stack. 
When successfully run then it gives 0 otherwise gives any value.
<em>First argument &#8211;</em> It takes pthread attribute.<br />
<em>Second argument &#8211;</em> It takes a variable and give the size of the thread attribute.
<b>pthread_attr_setstacksize() :</b><br />
It is use for set new threads stack size. 
The stacksize attribute gives the minimum stack size allocated to threads stack. 
When successfully run then it gives 0 otherwise if error gives any value.
<em>First argument &#8211;</em> It takes pthread attribute.<br />
<em>Second argument &#8211;</em> It takes the size of new stack (In bytes)<br />
</br>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;pthread.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// for takes the size of threads stack </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">size_t</code> <code class="plain">stksize; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// attribute declaration </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_attr_t atr; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// it gets the threads stack size and give&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// value in stksize variable </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_attr_getstacksize(&atr, &stksize); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print the current threads stack size </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Current stack size - > %d\n"</code><code class="plain">, stksize); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// then set the new threads stack size </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_attr_setstacksize(&atr, 320000034); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pthread_attr_getstacksize(&atr, &stksize); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print the new stack size </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"New stack size-> %d\n"</code><code class="plain">, stksize); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<b>Output :</b>
<pre>
Current stack size - &gt; 4196464
New stack size-&gt; 320000034
 </pre>
<b>For compile use gcc program_name.c -lpthread </b><br />
</br><br />
<h2>Difference between fork() and exec()</h2>
Every application(program) comes into execution through means of process, <strong>process</strong> is a running instance of a program. 
Processes are created through different system calls, most popular are <strong>fork()</strong> and <strong>exec()</strong>
<p align="Center"><strong><a href="https://www.geeksforgeeks.org/fork-system-call/">fork()</a></strong>
<pre>
pid_t pid = fork();
</pre>
fork() creates a new process by duplicating the calling process, The new process, referred to as child, is an exact duplicate of the calling process, referred to as parent, except for the following :
<ol>
<li>The child has its own unique process ID, and this PID does not match the ID of any existing process group.</li>
<li>The child&#8217;s parent process ID is the same as the parent&#8217;s process ID.</li>
<li>The child does not inherit its parent&#8217;s memory locks and semaphore adjustments.</li>
<li>The  child does not inherit outstanding asynchronous I/O operations from its parent nor does it inherit any asynchronous I/O contexts from its parent.</li>
</ol>
<strong>Return value of fork()</strong><br />
 On success, the PID of the child process is returned in the parent, and 0 is returned in the child. 
On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately.<br />
<a href="https://www.geeksforgeeks.org/fork-system-call/">Detailed article on fork system call</a>
<p align="center"><strong>exec()</strong>
The  exec()  family  of functions <strong>replaces</strong> the current process image with a new process image. 
It loads the program into the current process space and runs it from the entry point.
The exec() family consists of following functions, I have implemented <strong>execv()</strong> in following C program, you can try rest as an exercise
<pre>
int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ..., 
       char * const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[], 
      char *const envp[]);
</pre>
<p align="center"><strong>fork vs exec</strong>
<ul>
<li>fork starts a new process which is a copy of the one that calls it, while exec replaces the current process image with another (different) one.</li>
<li>Both parent and child processes are executed simultaneously in case of fork() while Control never returns to the original program unless there is an exec() error.</li>
</ul>
<code class="comments">// C program to illustrate&nbsp; use of fork() & </code>
<code class="comments">// exec() system call for process creation </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;sys/types.h> </code>
<code class="preprocessor">#include &lt;unistd.h>&nbsp; </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;errno.h>&nbsp;&nbsp; </code>
<code class="preprocessor">#include &lt;sys/wait.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(){ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">pid_t&nbsp; pid; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">ret = 1; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">status; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">pid = fork(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(pid == -1){ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pid == -1 means error occured </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"can't fork, error occured\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(EXIT_FAILURE); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(pid == 0){ </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pid == 0 means child process created </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// getpid() returns process id of calling process </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"child process, pid = %u\n"</code><code class="plain">,getpid()); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the argv list first argument should point to&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// filename associated with file being executed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the array pointer must be terminated by NULL&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">* argv_list[] = {</code><code class="string">"ls"</code><code class="plain">,</code><code class="string">"-lart"</code><code class="plain">,</code><code class="string">"/home"</code><code class="plain">,NULL}; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the execv() only return if error occured. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// The return value is -1 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">execv(</code><code class="string">"ls"</code><code class="plain">,argv_list); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// a positive number is returned for the pid of </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// parent process </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// getppid() returns process id of parent of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calling process </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"parent process, pid = %u\n"</code><code class="plain">,getppid()); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// the parent process calls waitpid() on the child </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// waitpid() system call suspends execution of&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// calling process until a child specified by pid </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// argument has changed state </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// see wait() man page for all the flags or options </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// used here&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(waitpid(pid, &status, 0) > 0) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(WIFEXITED(status) && !WEXITSTATUS(status))&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"program execution successful\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="keyword bold">if</code> <code class="plain">(WIFEXITED(status) && WEXITSTATUS(status)) { </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(WEXITSTATUS(status) == 127) { </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// execv failed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"execv failed\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"program terminated normally,"</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">" but returned a non-zero status\n"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"program didn't terminate normally\n"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code> <code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// waitpid() failed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"waitpid() failed\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
parent process, pid = 11523
child process, pid = 14188
Program execution successful
</pre>
<h2>Errors in C/C++</h2>
Error is an illegal operation performed by the user which results in abnormal working of the program.<br />
Programming errors often remain undetected until the program is compiled or executed. 
Some of the errors inhibit the program from getting compiled or executed. 
Thus errors should be removed before compiling and executing.<br />
The most common errors can be broadly classified as follows.
<p align="center"><strong>Type of errors</strong>
<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Errors-In-C.png" alt="">
<ol>
<li><strong>Syntax errors:</strong> Errors that occur when you <strong>violate the rules</strong> of writing C/C++ syntax are known as syntax errors. 
This compiler error indicates something that must be fixed before the code can be compiled. 
All these errors are detected by compiler and thus are known as compile-time errors.<br />
Most frequent syntax errors are: 
<ul>
<li> Missing Parenthesis (<strong>}</strong>)</li>
<li> Printing the value of variable without declaring it</li>
<li>Missing semicolon like this:
<code class="comments">// C program to illustrate </code>
<code class="comments">// syntax error </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">y = 15;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, (x, y)) </code><code class="comments">// semicolon missed </code>
<code class="plain">} </code>
Error:
<pre>error: expected ';' before '}' token</pre>
</li>
<li> Syntax of a basic construct is written wrong. 
For example : while loop
<code class="comments">// C program to illustrate </code>
<code class="comments">// syntax error </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// while() cannot contain "." as an argument. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">while</code><code class="plain">(.)&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"hello"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Error:
<pre>error: expected expression before '.' token
     while(.) </pre>
In the given example, the syntax of while loop is incorrect. 
This causes a syntax error.</li>
</ul>
</li>
<li><strong>Run-time Errors :</strong> Errors which occur during program execution(run-time) after successful compilation are called run-time errors. 
One of the most common run-time error is division by zero also known as Division error. 
These types of error are hard to find as the compiler doesn&#8217;t point to the line at which the error occurs.<br />
For more understanding run the example given below.
<code class="comments">// C program to illustrate </code>
<code class="comments">// run-time error </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">n = 9, </code><code class="functions bold">div</code> <code class="plain">= 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// wrong logic </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// number is divided by 0, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// so this program abnormally terminates </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">div</code> <code class="plain">= n/0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"resut = %d"</code><code class="plain">, </code><code class="functions bold">div</code><code class="plain">); </code>
<code class="plain">} </code>
Error: 
<pre>warning: division by zero [-Wdiv-by-zero]
     div = n/0;</pre>
In the given example, there is Division by zero error. 
This is an example of run-time error i.e errors occurring while running the program.</li>
<li><strong>Linker Errors: </strong> These error occurs when after compilation we link the different object files with main&#8217;s object using <em>Ctrl+F9</em> key(RUN). 
These are errors generated when the executable of the program cannot be generated. 
This may be due to wrong function prototyping, incorrect header files. 
One of the most common linker error is writing <strong>Main()</strong> instead of <strong>main()</strong>.
<code class="comments">// C program to illustrate </code>
<code class="comments">// linker error </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">Main() </code><code class="comments">// Here Main() should be main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 10; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a);&nbsp; </code>
<code class="plain">} </code>
Error:
<pre>(.text+0x20): undefined reference to `main'
</pre>
</li>
<li><strong>Logical Errors : </strong> On compilation and execution of a program, desired output is not obtained when certain input values are given. 
These types of errors which provide incorrect output but appears to be error free are called logical errors. 
These are one of the most common errors done by beginners of programming.<br />
These errors solely depend on the logical thinking of the programmer and are easy to detect if we follow the line of execution and determine why the program takes that path of execution.
<code class="comments">// C program to illustrate </code>
<code class="comments">// logical error </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i = 0; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// logical error : a semicolon after loop </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(i = 0; i &lt; 3; i++); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"loop "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">continue</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">}&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
No output
</li>
<li><strong>Semantic errors :</strong> This error occurs when the statements written in the program are not meaningful to the compiler.
<code class="comments">// C program to illustrate </code>
<code class="comments">// semantic error </code>
<code class="keyword bold">void</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a, b, c; </code>
<code class="undefined spaces">&nbsp;&nbsp;</code><code class="plain">a + b = c; </code><code class="comments">//semantic error </code>
<code class="plain">} </code>
Error
<pre> error: lvalue required as left operand of assignment
 a + b = c; //semantic error</pre></li></ol>
<h2>Why is C considered faster than other languages ?</h2>
<!-- Problem Statement --><br />
You might have came across these statements, C is more optimised or performance of C is better than higher languages, so I&#8217;ll be discussing the reasons for this hypothesis.
First let&#8217;s list out functionalities which are provided by languages like Java and not C :
<ol>
<li>Array index bound checking</li>
<li> Uninitialized variable values checking</li>
<li>Check for memory leaks</li>
<li>Check for null pointer dereference</li>
<li>Automatic garbage collection</li>
<li> Run-time type checking</li>
<li> Exception handling</li>
</ol>
and there are more such features which are not present in C.
Extra features comes at cost and the cost includes decreased <strong>speed</strong> and increased <strong>size</strong>.
Let&#8217;s take an example for dynamic allocation in C and Java<br />
<strong>Java</strong>
<pre>
MyClass obj = new MyClass();
</pre>
Did you considered size of <strong>obj</strong>, the answer is <strong>No</strong>. 
The reason being it is automatically handled by language itself in background and you don&#8217;t have to write specific code for it.
But in case of <strong>C</strong>
<pre>
struct MyStruct *obj = malloc(sizeof(struct MyStruct));
</pre>
As you can see in above code the tasks of assigning reference to pointer, allocation of size is done explictly by programmer and at last free up allocated memory.
The array bound check is supported by </strong>Thumb Execution Environment (ThumbEE)</strong>, its other features includes automatic null pointer checks on every load and store instruction, an special instruction that call a handler.
Another reason is closeness of C to the Assembly language, in most of the cases its instructions directly map to assembly language, C is only one or level two levels of abstraction away from assembly language while Java is at minimum 3 levels abstraction away from assembler.
<h2>Incompatibilities between C and C++ codes</h2>
The C/C++ incompatibilities that cause most real problems are not subtle. 
Most are easily caught by compilers.<br />
This section gives examples of C code that is not C++ :
<strong>1)</strong> In C, functions can be defined using a syntax that optionally specifies argument types after the list of arguments:    
<code class="comments">// C code that uses argument types after </code>
<code class="comments">// the list of arguments. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="keyword bold">void</code> <code class="plain">fun(a, b)</code><code class="color1 bold">int</code> <code class="plain">a;</code><code class="color1 bold">int</code> <code class="plain">b;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="comments">// Invalid in C++ </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %d"</code><code class="plain">, a, b); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(8, 9); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Output:
8 9 
</pre>
<pre><strong>Error in C++ :- </strong> a and b was not declared in this scope </pre>
<strong>2)</strong> In C and in pre-standard versions of C++, the type specifier defaults to int.<br/>
<code class="comments">// C code to show implicit int declaration. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// implicit int in C, not allowed in C++ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">const</code> <code class="plain">a = 7;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre>
Output:
7
</pre>
<pre><strong>Error in C++ :- </strong> a does not name a type </pre>
<strong>3)</strong> In C, a global data object may be declared several times without using the <strong>extern </strong>specifier. 
As long as at most one such declaration provides an initializer, the object is considered defined only once.
<code class="comments">// C code to demonstrate multiple global </code>
<code class="comments">// declarations of same variable. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Declares single integer a, not allowed in C++ </code>
<code class="color1 bold">int</code> <code class="plain">a;&nbsp;&nbsp; </code><code class="color1 bold">int</code> <code class="plain">a;&nbsp;&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre><strong>Error in C++ :- </strong> Redefinition of int a</pre>
<strong>4)</strong> In C, a void* may be used as the right-hand operand of an assignment to or initialization of a variable of any pointer type.
<code class="comments">// C code to demonstrate implicit conversion </code>
<code class="comments">// of void* to int* </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;malloc.h> </code>
<code class="keyword bold">void</code> <code class="plain">f(</code><code class="color1 bold">int</code> <code class="plain">n) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Implicit conversion of void* to int* </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Not allowed in C++. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code><code class="plain">* p = </code><code class="functions bold">malloc</code><code class="plain">(n* </code><code class="keyword bold">sizeof</code><code class="plain">(</code><code class="color1 bold">int</code><code class="plain">));&nbsp;&nbsp; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">f(7); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre><strong>Error in C++ :- </strong> Invalid conversion of void* to int*</pre>
<strong>5)</strong> In C, an array can be initialized by an initializer that has more elements than the array requires.
<code class="comments">// C code to demonstrate that extra character </code>
<code class="comments">// check is not done in C. 
</code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Error in C++ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">array[5] = </code><code class="string">"Geeks"</code><code class="plain">;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, array); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output: 
<pre>Geeks
</pre>
<pre><strong>Error in C++ :- </strong> Initializer-string for array of chars is too long</pre>
<strong>6) </strong>In C, a function declared without specifying any argument types can take any number of arguments of any type at all. 
Click <a href="https://www.geeksforgeeks.org/difference-int-main-int-mainvoid/">here</a> to know more about this.
<code class="comments">// In C, empty brackets mean any number </code>
<code class="comments">// of arguments can be passed </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">fun() {&nbsp; }&nbsp; </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fun(10, </code><code class="string">"GfG"</code><code class="plain">, </code><code class="string">"GQ"</code><code class="plain">);&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<pre><strong>Error in C++ :- </strong> Too many arguments to function 'void fun()'</pre>
<strong>Related Articles:</strong>
<ul>
<li><a href="https://www.geeksforgeeks.org/fine-write-void-main-cc/">Is it fine to write “void main()” or “main()” in C/C++?</a></li>
<li><a href="https://www.geeksforgeeks.org/difference-int-main-int-mainvoid/">Difference between “int main()” and “int main(void)” in C/C++?</a></li>
<li><a href="https://www.geeksforgeeks.org/output-c-programs-set-24-c-vs-c/">Output of C++ programs | Set 24 (C++ vs C)</a></li>
</ul>
<h2>Convert C/C++ code to assembly language</h2>
We use g++ compiler to turn provided C code into assembly language. 
To see the assembly code generated by the C compiler, we can use the <strong>&#8220;-S&#8221;</strong> option on the command line:<br />
<strong>Syntax:</strong>
<pre>
$ gcc -S filename.c
</pre>
This will cause gcc to run the compiler, generating an assembly file. 
Suppose we write a C code and store it in a file name &#8220;geeks.c&#8221; .
<code class="comments">// C code stored in geeks.c file </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// global string </code>
<code class="color1 bold">char</code> <code class="plain">s[] = </code><code class="string">"GeeksforGeeks"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// Driver Code </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Declaring variables </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">a = 2000, b =17; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Printing statement </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s %d \n"</code><code class="plain">, s, a+b); </code>
<code class="plain">} </code>
<strong>Running the command:</strong>
<pre>
$ gcc -S geeks.c
</pre>
This will cause gcc to run the compiler, generating an assembly file <strong>geeks.s</strong>, and go no further. 
(Normally it would then invoke the assembler to generate an object- code file.)
The assembly-code file contains various declarations including the set of lines:
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.section&nbsp;&nbsp;&nbsp; __TEXT, __text, regular, pure_instructions </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.macosx_version_min 10, 12 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.globl&nbsp;&nbsp;&nbsp; _main </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.align&nbsp;&nbsp;&nbsp; 4, 0x90 </code>
<code class="plain">_main:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## @main </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.cfi_startproc </code>
<code class="preprocessor">## BB#0: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">pushq&nbsp;&nbsp;&nbsp; %rbp </code>
<code class="plain">Ltmp0: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.cfi_def_cfa_offset 16 </code>
<code class="plain">Ltmp1: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.cfi_offset %rbp, -16 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movq&nbsp;&nbsp;&nbsp; %rsp, %rbp </code>
<code class="plain">Ltmp2: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.cfi_def_cfa_register %rbp </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">subq&nbsp;&nbsp;&nbsp; $16, %rsp </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">leaq&nbsp;&nbsp;&nbsp; L_.str(%rip), %rdi </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">leaq&nbsp;&nbsp;&nbsp; _s(%rip), %rsi </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; $2000, -4(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## imm = 0x7D0 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; $17, -8(%rbp) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; -4(%rbp), %eax </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">addl&nbsp;&nbsp;&nbsp; -8(%rbp), %eax </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; %eax, %edx </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movb&nbsp;&nbsp;&nbsp; $0, %al </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">callq&nbsp;&nbsp;&nbsp; _printf </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">xorl&nbsp;&nbsp;&nbsp; %edx, %edx </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; %eax, -12(%rbp)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## 4-byte Spill </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">movl&nbsp;&nbsp;&nbsp; %edx, %eax </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">addq&nbsp;&nbsp;&nbsp; $16, %rsp </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">popq&nbsp;&nbsp;&nbsp; %rbp </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">retq </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.cfi_endproc </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.section&nbsp;&nbsp;&nbsp; __DATA, __data </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.globl&nbsp;&nbsp;&nbsp; _s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## @s </code>
<code class="plain">_s: </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.asciz&nbsp;&nbsp;&nbsp; </code><code class="string">"GeeksforGeeks"</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.section&nbsp;&nbsp;&nbsp; __TEXT, __cstring, cstring_literals </code>
<code class="plain">L_.str:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ## @.str </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">.asciz&nbsp;&nbsp;&nbsp; </code><code class="string">"%s %d \n"</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="plain">.subsections_via_symbols </code>
Each indented line in the above code corresponds to a single machine instruction. 
For example, the <strong>pushq</strong> instruction indicates that the contents of register<strong> %rbp</strong> should be pushed onto the program stack. 
All information about local variable names or data types has been stripped away. 
We still see a reference to the global<br />
variable <strong>s[]= &#8220;GeeksforGeeks&#8221;</strong>, since the compiler has not yet determined where in memory this variable will be stored.
<h2>Error Handling in C programs</h2>
Although C does not provide direct support to error handling (or exception handling), there are ways through which error handling can be done in C. 
A programmer has to prevent errors at the first place and test return values from the functions.<br />
A lot of C function calls return a -1 or NULL in case of an error, so quick test on these return values are easily done with for instance an ‘if statement’. For example, In <a href="https://www.geeksforgeeks.org/socket-programming-cc/">Socket Programming</a>, the returned value of the functions like socket(), listen() etc. 
are checked to see if there is an error or not.
<strong>Example: Error handling in Socket Programming</strong>
<pre>
if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0)
{
   perror("socket failed");
   exit(EXIT_FAILURE);
}
</pre>
<p align="center"><strong>Different methods of Error handling in C</strong>
<ol>
<li><strong>Global Variable errno:</strong> When a function is called in C, a variable named as errno is automatically assigned a code (value) which can be used to identify the type of error that has been encountered. 
Its a global variable indicating the error occurred during any function call and defined in the header file errno.h.<br />
Different codes (values) for errno mean different types of errors. 
Below is a list of few different errno values and its corresponding meaning:
<pre>
<b>errno value</b>       <b>Error</b>
1             /* Operation not permitted */
2             /* No such file or directory */
3             /* No such process */
4             /* Interrupted system call */
5             /* I/O error */
6             /* No such device or address */
7             /* Argument list too long */
8             /* Exec format error */
9             /* Bad file number */
10            /* No child processes */
11            /* Try again */
12            /* Out of memory */
13            /* Permission denied */
</pre>
<code class="comments">// C implementation to see how errno value is </code>
<code class="comments">// set in the case of any error in C </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;errno.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If a file is opened which does not exist, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// then it will be an error and corresponding </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// errno value will be set </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">* fp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// opening a file which does </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not exist. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">"GeeksForGeeks.txt"</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">" Value of errno: %d\n "</code><code class="plain">, </code><code class="functions bold">errno</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Value of errno: 2
</pre>
Note: Here the errno is set to 2 which means &#8211; No such file or directory. 
On online IDE it may give errorno 13, which says permission denied.</li>
<li><strong>perror() and strerror():</strong> The errno value got above indicate the types of error encountered.<br />
If it is required to show the error description, then there are two functions that can be used to display a text message that is associated with errorno. 
The functions are:
<ul>
<li><strong>perror:</strong> It displays the string you pass to it, followed by a colon, a space, and then the textual representation of the current errno value.<br />
<b>Syntax:</b>
<pre>void perror (const char *str)
<strong>str: </strong>is a string containing a custom message
to be printed before the error message itself.</pre>
</li>
<li><strong>strerror():</strong> returns a pointer to the textual representation of the current errno value.<br />
<b>Syntax:</b>
<pre>char *strerror (int errnum)
<strong>errnum:</strong> is the error number (errno).</pre>
</li>
</ul>
<code class="comments">// C implementation to see how perror() and strerror() </code>
<code class="comments">// functions are used to print the error messages. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;errno.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">*fp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// If a file is opened which does not exist, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// then it will be an error and corresponding </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// errno value will be set </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code><code class="plain">(</code><code class="string">" GeeksForGeeks.txt "</code><code class="plain">, </code><code class="string">"r"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// opening a file which does </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// not exist. 
</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of errno: %d\n "</code><code class="plain">, </code><code class="functions bold">errno</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"The error message is : %s\n"</code><code class="plain">,&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strerror</code><code class="plain">(</code><code class="functions bold">errno</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">perror</code><code class="plain">(</code><code class="string">"Message from perror"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:<br />
<strong>On Personal desktop:</strong>
<pre>Value of errno: 2
The error message is : No such file or directory
Message from perror: No such file or directory
</pre>
<strong>On online IDE:</strong>
<pre> Value of errno: 13
The error message is : Permission denied
</pre>
<strong>Note:</strong> The function perror() displays a string passed to it, followed by a colon and the textual message of the current errno value.</li>
<li><strong>Exit Status: </strong>The C standard specifies two constants: EXIT_SUCCESS and EXIT_FAILURE, that may be passed to exit() to indicate successful or unsuccessful termination, respectively. 
These are macros defined in stdlib.h.
<code class="comments">// C implementation which shows the </code>
<code class="comments">// use of EXIT_SUCCESS and EXIT_FAILURE. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;errno.h> </code>
<code class="preprocessor">#include &lt;string.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">* fp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code> <code class="plain">(</code><code class="string">"filedoesnotexist.txt"</code><code class="plain">, </code><code class="string">"rb"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(fp == NULL) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Value of errno: %d\n"</code><code class="plain">, </code><code class="functions bold">errno</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Error opening the file: %s\n"</code><code class="plain">, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">strerror</code><code class="plain">(</code><code class="functions bold">errno</code><code class="plain">)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">perror</code><code class="plain">(</code><code class="string">"Error printed by perror"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(EXIT_FAILURE); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I will not be printed\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code> <code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(EXIT_SUCCESS); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"I will not be printed\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>Value of errno: 2
Error opening the file: No such file or directory
Error printed by perror: No such file or directory
</pre>
</li>
<li><strong>Divide by Zero Errors:</strong> A common pitfall made by C programmers is not checking if a divisor is zero before a division command. 
Division by zero leads to undefined behavior, there is no C language construct that can do anything about it. 
Your best bet is to not divide by zero in the first place, by checking the denominator.
<code class="comments">// C program to check&nbsp; and rectify </code>
<code class="comments">// divide by zero condition </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">function(</code><code class="color1 bold">int</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 0; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">function(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">function(</code><code class="color1 bold">int</code> <code class="plain">x) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">float</code> <code class="plain">fx; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code> <code class="plain">(x==0) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Division by Zero is not allowed"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fprintf</code><code class="plain">(stderr, </code><code class="string">"Division by zero! Exiting...\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(EXIT_FAILURE); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">else</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fx = 10 / x; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"f(x) is: %.5f"</code><code class="plain">, fx); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="plain">} </code>
Output:
<pre>Division by Zero is not allowed</pre></li></ol>
<h2>Executing main() in C/C++ &#8211; behind the scene</h2>
How to write a C program to print &#8220;Hello world&#8221; without main() function?<br />
<em>At first, it seems impractical to execute a program without a <strong>main()</strong> function because the <strong>main()</strong> function is the entry point of any program.</em>
Let us first understand what happens under the hood while executing a C program in Linux system, how main() is called and how to execute a program without main(). 
Following setup is considered for the demonstration.
<ul>
<li>Ubuntu 16.4 LTS operating system</li>
<li>GCC 5.4.0 compiler</li>
<li>objdump utility</li>
</ul>
From C/C++ programming perspective, the program entry point is main() function. 
From the perspective of program execution, however, it is not. 
Prior to the point when the execution flow reaches to the main(), calls to few other functions are made, which setup arguments, prepare environment variables for program execution etc.
The executable file created after compiling a C source code is a <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format (ELF) file</a>.<br />
Every ELF file have a ELF header where there is a <strong>e_entry</strong> field which contains the program memory address from which the execution of executable will start. 
This memory address point to the <strong>_start()</strong> function.<br />
After loading the program, loader looks for the <strong>e_entry</strong> field from the ELF file header. 
<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format (ELF)</a> is a common standard file format used in UNIX system for executable files, object code, shared libraries, and core dumps. 
Let&#8217;s see this using an example. 
I&#8217;m creating a <strong>example.c</strong> file to demonstrate this. 
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Now compiling this using following commands
<pre>
gcc -o example example.c
</pre>
Now an <strong>example</strong> executable is created, let us examine this using objdump utility
<pre>
objdump -f example
</pre>
This outputs following critical information of executable on my machine. 
Have a look at start address below, this is the address pointing to _start() function.
<pre>
example:     file format elf64-x86-64
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000004003e0
</pre>
We can cross check this address by deassembling the executable, the output is long so I&#8217;m just pasting the output which shows where this address <strong>0x00000000004003e0</strong> is pointing
<pre>
objdump --disassemble  example
</pre>
Output :
<pre>
00000000004003e0 &lt;_start&gt;:
  4003e0:	31 ed                	xor    %ebp,%ebp
  4003e2:	49 89 d1             	mov    %rdx,%r9
  4003e5:	5e                   	pop    %rsi
  4003e6:	48 89 e2             	mov    %rsp,%rdx
  4003e9:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4003ed:	50                   	push   %rax
  4003ee:	54                   	push   %rsp
  4003ef:	49 c7 c0 60 05 40 00 	mov    $0x400560,%r8
  4003f6:	48 c7 c1 f0 04 40 00 	mov    $0x4004f0,%rcx
  4003fd:	48 c7 c7 d6 04 40 00 	mov    $0x4004d6,%rdi
  400404:	e8 b7 ff ff ff       	callq  4003c0 
  400409:	f4                   	hlt    
  40040a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
</pre>
As we can clearly see this is pointing to the _start() function.
<h4>The role of _start() function</h4>
The _start() function prepare the input arguments for another function <strong>_libc_start_main()</strong> which will be called next. 
This is prototype of <strong>_libc_start_main()</strong> function. 
Here we can see the arguments which were prepared by _start() function.
          
<code class="color1 bold">int</code> <code class="plain">__libc_start_main(</code><code class="color1 bold">int</code> <code class="plain">(*main) (</code><code class="color1 bold">int</code><code class="plain">, </code><code class="color1 bold">char</code> <code class="plain">* *, </code><code class="color1 bold">char</code> <code class="plain">* *), </code><code class="comments">/* address of main function*/</code>
<code class="color1 bold">int</code> <code class="plain">argc, </code><code class="comments">/* number of command line args*/</code>
<code class="color1 bold">char</code> <code class="plain">** ubp_av, </code><code class="comments">/* command line arg array*/</code>
<code class="keyword bold">void</code> <code class="plain">(*init) (</code><code class="keyword bold">void</code><code class="plain">), </code><code class="comments">/* address of init function*/</code>
<code class="keyword bold">void</code> <code class="plain">(*fini) (</code><code class="keyword bold">void</code><code class="plain">), </code><code class="comments">/* address of fini function*/</code>
<code class="keyword bold">void</code> <code class="plain">(*rtld_fini) (</code><code class="keyword bold">void</code><code class="plain">), </code><code class="comments">/* address of dynamic linker fini function */</code>
<code class="keyword bold">void</code> <code class="plain">(* stack_end) </code><code class="comments">/* end of the stack address*/</code>
<code class="plain">); </code>
<h4>The role of _libc_start_main() function </h4>
The role of _libs_start_main() function is following &#8211; 
<ul>
<li>Preparing environment variables for program execution</li>
<li>Calls <strong>_init()</strong> function which performs initialization before the main() function start.</li>
<li>Register <strong>_fini()</strong> and <strong>_rtld_fini()</strong> functions to perform cleanup after program terminates</li>
<ul>
After all the prerequisite actions has been completed, _libc_start_main() calls the main() function.
<h4>Writing program without main()</h4>
Now we know how the call to the main() is made.To make it clear, main() is nothing but a agreed term for startup code. 
We can have any name for startup code it doesn&#8217;t necessarily have to be &#8220;main&#8221;. 
As _start() function by default calls main(), we have to change it if we want to execute our custom startup code. 
We can override the _start() function to make it call our custom startup code not main(). 
Let&#8217;s have an example, save it as <strong>nomain.c</strong> &#8211; 
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;stdlib.h> </code>
<code class="keyword bold">void</code> <code class="plain">_start() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = my_fun(); </code><code class="comments">//calling custom main function </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">exit</code><code class="plain">(x); </code>
<code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">my_fun() </code><code class="comments">// our custom main function </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello world!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Now we have to force compiler to not use it&#8217;s own implementation of _start().In GCC we can do this using <strong>-nostartfiles</strong>
<pre>
gcc -nostartfiles -o nomain nomain.c
</pre>
Execute the executable nomain
<pre>
./nomain
</pre>
Output:
<pre>
Hello world!
</pre>
<h2>Hygienic Macros : An Introduction</h2>
We are all familiar with the working of <a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">macros</a> in languages like C. 
There are certain situations in which macro expansions can lead to undesirable results because of accidental capture of identifiers.<br />
For example:
<code class="comments">// C program to illustrate a situation known as&nbsp; </code>
<code class="comments">// accidental capture of identifiers - an </code>
<code class="comments">// undesirable result caused by unhygienic macros </code>
<code class="preprocessor">#define INCI(i) do { int x = 0; ++i; } while(0) </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 4, y = 8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// macro called first time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">INCI(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// macro called second time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">INCI(y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, b = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
The code is actually equivalent to:
<code class="comments">// C program to illustrate unhygenic macros </code>
<code class="comments">// with Macro definition substituted in source code. 
</code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 4, y = 8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//macro called first time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">do</code> <code class="plain">{ </code><code class="color1 bold">int</code> <code class="plain">x = 0; ++x; } </code><code class="keyword bold">while</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//macro called second time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">do</code> <code class="plain">{ </code><code class="color1 bold">int</code> <code class="plain">x = 0; ++y; } </code><code class="keyword bold">while</code><code class="plain">(0); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, b = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
x = 4, y = 9
</pre>
The variable a declared in the scope of the main function is overshadowed by the variable a in the macro definition so <strong>a = 4</strong> never gets updated (known as accidental capture).
<p align="center"><strong>Hygienic macros</strong>
Hygienic macros are macros whose expansion is guaranteed not to cause the accidental capture of identifiers. 
A hygienic macro doesn&#8217;t use variable names that can risk interfering with the code under expansion.<br />
The situation in the above code can be avoided simply by changing the name of the variable in the macro definition, which will produce a different output.
<code class="comments">// C program to illustrate&nbsp;&nbsp; </code>
<code class="comments">// Hygienic macros using&nbsp; </code>
<code class="comments">// identifier names such that&nbsp; </code>
<code class="comments">// they do not cause&nbsp; </code>
<code class="comments">// the accidental capture of identifiers </code>
<code class="preprocessor">#define INCI(i) do { int m = 0; ++i; } while(0) </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">x = 4, y = 8; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// macro called first time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">INCI(x); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// macro called second time </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">INCI(y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"x = %d, y = %d\n"</code><code class="plain">, x, y); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Output:
<pre>
x = 5, y = 9
</pre>
<h2>Command line arguments in C/C++</h2>
The most important function of C/C++ is main() function. 
It is mostly defined with a return type of int and without parameters : 
<pre>
int main() { /* ...*/ } 
</pre>
We can also give command-line arguments in C and C++. 
Command-line arguments are given after the name of the program in command-line shell of Operating Systems.<br />
To pass command line arguments, we typically define main() with two arguments : first argument is the number of command line arguments and second is list of command-line arguments.
<pre>
int main(int argc, char *argv[]) { /* ...*/ }
</pre>
or 
<pre>
int main(int argc, char **argv) { /* ...*/ }
</pre>
<ul>
<li><strong>argc (ARGument Count)</strong>  is int and stores number of command-line arguments passed by the user including the name of the program. 
So if we pass a value to a program, value of argc would be 2 (one for argument and one for program name)
  </li>
<li>The value of argc should be non negative.</li>
<li><strong>argv(ARGument Vector)</strong> is array of character pointers listing all the arguments.</li>
<li>If argc is greater than zero,the array elements from argv[0] to argv[argc-1] will contain pointers to strings.
  </li>
<li>Argv[0] is the name of the program , After that till argv[argc-1] every element is command -line arguments.
  </li>
</ul>

For better understanding run this code on your linux machine. 
<code class="comments">// Name of program mainreturn.cpp </code>
<code class="preprocessor">#include &lt;iostream> </code>
<code class="keyword bold">using</code> <code class="keyword bold">namespace</code> <code class="plain">std; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc, </code><code class="color1 bold">char</code><code class="plain">** argv) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; </code><code class="string">"You have entered "</code> <code class="plain">&lt;&lt; argc </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">&lt;&lt; </code><code class="string">" arguments:"</code> <code class="plain">&lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code> <code class="plain">(</code><code class="color1 bold">int</code> <code class="plain">i = 0; i &lt; argc; ++i) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cout &lt;&lt; argv[i] &lt;&lt; </code><code class="string">"\n"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
Input:
<pre>
$ g++ mainreturn.cpp -o main 
$ ./main geeks for geeks
</pre>
Output:
<pre>
You have entered 4 arguments:
./main
geeks
for
geeks
</pre>
<strong>Note :</strong> Other platform-dependent formats are also allowed by the C and C++ standards; for example, Unix (though not POSIX.1) and Microsoft Visual C++ have a third argument giving the program’s environment, otherwise accessible through getenv in stdlib.h:  Refer <a href="http://quiz.geeksforgeeks.org/c-program-print-environment-variables/">C program to print environment variables</a> for details.
<strong>Properties of Command Line Arguments:</strong>
<ol>
<li>They are passed to main() function.</li>
<li>They are parameters/arguments supplied to the program when it is invoked.</li>
<li>They are used to control program from outside instead of hard coding those values inside the code.</li>
<li>argv[argc] is a NULL pointer.</li>
<li>argv[0] holds the name of the program.</li>
<li>argv[1] points to the first command line argument and argv[n] points last argument.</li>
</ol>
<strong>Note :</strong> You pass all the command line arguments separated by a space, but if argument itself has a space then you can pass such arguments by putting them inside double quotes &#8220;&#8221; or single quotes &#8221;.
<code class="comments">// C program to illustrate </code>
<code class="comments">// command line arguments </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc,</code><code class="color1 bold">char</code><code class="plain">* argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">counter; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Program Name Is: %s"</code><code class="plain">,argv[0]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(argc==1) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nNo Extra Command Line Argument Passed Other Than Program Name"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">if</code><code class="plain">(argc>=2) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nNumber Of Arguments Passed: %d"</code><code class="plain">,argc); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n----Following Are The Command Line Arguments Passed----"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">for</code><code class="plain">(counter=0;counter&lt;argc;counter++) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\nargv[%d]: %s"</code><code class="plain">,counter,argv[counter]); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output in different scenarios:</strong>
<ol>
<li><strong>Without argument:</strong> When the above code is compiled and executed without passing any argument, it produces following output.
<pre>
$ ./a.out
Program Name Is: ./a.out
No Extra Command Line Argument Passed Other Than Program Name
</pre>
</li>
<li><strong>Three arguments :</strong> When the above code is compiled and executed with a three arguments, it produces the following output.
<pre>
$ ./a.out First Second Third
Program Name Is: ./a.out
Number Of Arguments Passed: 4
----Following Are The Command Line Arguments Passed----
argv[0]: ./a.out
argv[1]: First
argv[2]: Second
argv[3]: Third
</pre>
</li>
<li><strong>Single Argument :</strong> When the above code is compiled and executed with a single argument separated by space but inside double quotes, it produces the following output.
<pre>
$ ./a.out "First Second Third"
Program Name Is: ./a.out
Number Of Arguments Passed: 2
----Following Are The Command Line Arguments Passed----
argv[0]: ./a.out
argv[1]: First Second Third
</pre>
</li>
<li><strong>Single argument in quotes separated by space : </strong>When the above code is compiled and executed with a single argument separated by space but inside single quotes, it produces the following output.
<pre>
$ ./a.out 'First Second Third'
Program Name Is: ./a.out
Number Of Arguments Passed: 2
----Following Are The Command Line Arguments Passed----
argv[0]: ./a.out
argv[1]: First Second Third
</pre></li></ol>
<h2>Inbuilt library functions for user Input | scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s</h2>
<ol>
<li><strong>scanf() : </strong> The C library function int scanf (const char *format, &#8230;) reads formatted input from stdin.
<pre><strong>Syntax:</strong>
int scanf(const char *format, ...)
<strong>Return type:</strong> Integer
<strong>Parameters:</strong>
<strong>format:</strong> string that contains the type specifier(s) 
<strong>"..." (ellipsis):</strong> indicates that the function accepts
a variable number of arguments</pre>
Each argument must be a memory address where the converted result is written to. 
On success, the function returns the number of variables filled. 
In case of an input failure, before any data could be successfully read, EOF is returned.<br />
Type specifiers that can be used in scanf:
<pre><strong>%c</strong> — Character
<strong>%d</strong> — Signed integer
<strong>%f</strong> — Floating point
<strong>%s</strong> — String</pre>
<code class="comments">//C program t illustrate scanf statement </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a[10];&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Please enter your name : \n"</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">//scanf statement </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">scanf</code><code class="plain">(</code><code class="string">"%s"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"You entered: \n%s"</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Input:</strong>
<pre>Geek</pre>
<strong>Output:</strong>
<pre>Please enter your name : 
You entered: 
Geek</pre>
</li>
<li><strong>sscanf(): </strong>sscanf() is used to read formatted input from the string.
<pre><strong>Syntax:</strong>
int sscanf ( const char * s, const char * format, ...);
<strong>Return type:</strong> Integer
<strong>Parameters:</strong>
<strong>s:</strong> string used to retrieve data
<strong>format:</strong> string that contains the type specifier(s)
<strong>… :</strong> arguments contains pointers to allocate 
storage with appropriate type. 
There should be at least as many of these arguments as the 
number of values stored by the format specifiers.</pre>
On success, the function returns the number of variables filled. 
In the case of an input failure, before any data could be successfully read, EOF is returned.
<code class="comments">// C program to illustrate sscanf statement </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main () </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// declaring array s </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s [] = </code><code class="string">"3 red balls 2 blue balls"</code><code class="plain">;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str [10],str2 [10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// %*s is used to skip a word </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">sscanf</code> <code class="plain">(s,</code><code class="string">"%d %*s %*s %*s %s %s"</code><code class="plain">, &i, str, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code> <code class="plain">(</code><code class="string">"%d %s %s \n"</code><code class="plain">, i, str, str2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>3 blue balls</pre>
</li>
<li><strong>fscanf()</strong>: fscanf() reads formatted data from file and stores it into variables.
<pre><strong>Syntax:</strong>
int fscanf(FILE *stream, const char *format, ...)
<strong>Parameters:</strong>
<strong>Stream: </strong> pointer to the File object that identifies the stream.
<strong>format</strong> : is a string that contains the type specifier(s)
</pre>
On success, the function returns the number of variables filled. 
In the case of an input failure, before any data could be successfully read, EOF is returned.
<code class="comments">// C program to illustrate sscanf statement </code>
<code class="comments">// This program will run on system having the file file.txt </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s1[10], s2[10], s3[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">year; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">* fp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// opening/creation of file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fp = </code><code class="functions bold">fopen</code> <code class="plain">(</code><code class="string">"file.txt"</code><code class="plain">, </code><code class="string">"w+"</code><code class="plain">);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// storing string in the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"Hello World its 2017"</code><code class="plain">, fp);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// sets the file position to the beginning of the file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">rewind</code><code class="plain">(fp);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// taking input from file </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fscanf</code><code class="plain">(fp, </code><code class="string">"%s %s %s %d"</code><code class="plain">, s1, s2, s3, &year);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String1 |%s|\n"</code><code class="plain">, s1 ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String2 |%s|\n"</code><code class="plain">, s2 ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String3 |%s|\n"</code><code class="plain">, s3 ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integer |%d|\n"</code><code class="plain">, year ); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// close file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
Output:
<pre>
String1 |Hello|
String2 |World|
String3 |its|
Integer |2017|
</pre>
</li>
<li><strong>scanf_s() : </strong>This function is specific to Microsoft compilers. 
It is the same as scanf, except it does not cause buffer overload.
<pre><strong>Syntax:</strong>
int scanf_s(const char *format [argument]...);
<strong>argument(parameter): </strong>here you can specify the buffer size and actually control the limit
of the input so you don't crash the whole application.</pre>
On success, the function returns the number of variables filled. 
In the case of an input failure, before any data could be successfully read, EOF is returned.<br />
<strong>Why to use scanf_s()?</strong><br />
scanf just reads whatever input is provided from the console. 
C does not check whether the user input will fit in the variable that you’ve designated.<br />
If you have an array called color[3] and you use scanf for “Red”, it will work fine but if user enters more than 3 characters scanf starts writing into memory that doesn&#8217;t belong to colour. 
C won&#8217;t catch this or warn you and it might or might not crash the program, depending on if something tries to access and write on that memory slot that doesn’t belong to color. 
This is where scanf_s comes into play. 
scanf_s checks that the user input will fit in the given memory space.
<code class="comments">// C program to illustrate sscanf_s statement </code>
<code class="comments">// scanf_s() will only work in Microsoft Visual Studio. 
</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">a[5]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// sizeof(a) is buffer size </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">scanf_s(</code><code class="string">"%s"</code><code class="plain">, a, </code><code class="keyword bold">sizeof</code><code class="plain">(a));&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"\n%s "</code><code class="plain">, a); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Input:</strong>
<pre>Red</pre>
<strong>Output: </strong>
<pre>Red</pre>
<strong>Input:</strong>
<pre>Yellow</pre>
<strong>Output:</strong>
<pre>No Output</pre>
<strong>Illustrating the relation between buffer size and array size.</strong><br />
<h3>C</h3>
          
<code class="comments">// C program </code>
<code class="comments">// consumes the Enter key&nbsp; </code>
<code class="comments">// (newline character) pressed after input </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">char</code> <code class="plain">ch[100000]; </code>
<code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter characters: "</code><code class="plain">); </code>
<code class="plain">scanf_s(</code><code class="string">"%s"</code><code class="plain">, ch, 99999); </code>
<code class="functions bold">getchar</code><code class="plain">(); </code>
<h3>C++</h3>
<code class="comments">// C++ program </code>
<code class="comments">// consumes the Enter key&nbsp; </code>
<code class="comments">// (newline character) pressed after input </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include "stdafx.h" </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">_tmain(</code><code class="color1 bold">int</code> <code class="plain">argc, _TCHAR* argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// example </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">ch[100000]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Enter characters: "</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">scanf_s(</code><code class="string">"%s"</code><code class="plain">, ch, 99999); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">getchar</code><code class="plain">(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<ol>
<li>If the buffer size is equal to or smaller than the size of the array, then inputting bigger than or equal to the buffer size will do nothing.</li>
<li>If the buffer size is bigger than the size of an array, then
<ol style="list-style-type:lower-alpha">
<li>inputting smaller than buffer size will work out but will give an error
<p align="center" style="font-family:Consolas;color:red;font-size:medium">
&#8220;Run-Time Check Failure     #2 &#8211; Stack around the variable &#8216;variable_name&#8217; was corrupted.&#8221;</b>
</li>
<li>inputting bigger than buffer size will do nothing and give the same error.</li>
</ol></li></ol>
</li>
<li><strong>fscanf_s() : </strong>Difference between fscanf() and fscanf_s() is same as that of scanf() and scanf_s(). 
fscanf_s() is secure function and secure functions require the size of each c, C, s, S and [ type field to be passed as an argument immediately following the variable.
<pre><strong>Syntax:</strong>
int fscanf_s(   FILE *stream,  const char *format ,[argument ]... 
); 
fscanf_s has an extra argument(parameter) where you can 
specify the buffer size and actually control the limit of the input.
</pre>
On success, the function returns the number of variables filled. 
In the case of an input failure, before any data could be successfully read, EOF is returned.
<code class="comments">//C program to illustrate fscanf_s statement </code>
<code class="comments">//This program will run on MS Visual studio </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s1[10], s2[10], s3[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">year; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// file pointer </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">FILE</code> <code class="plain">* fp;&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Open file securely </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fopen_s(&fp,</code><code class="string">"file.txt"</code><code class="plain">, </code><code class="string">"w+"</code><code class="plain">);&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fputs</code><code class="plain">(</code><code class="string">"Hello World its 2017"</code><code class="plain">, fp);&nbsp; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">rewind</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Using fscanf_s </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fscanf_s(fp, </code><code class="string">"%s"</code><code class="plain">, s1, </code><code class="keyword bold">sizeof</code><code class="plain">(s1)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fscanf_s(fp, </code><code class="string">"%s"</code><code class="plain">, s2, </code><code class="keyword bold">sizeof</code><code class="plain">(s2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fscanf_s(fp, </code><code class="string">"%s"</code><code class="plain">, s3, </code><code class="keyword bold">sizeof</code><code class="plain">(s3)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">fscanf_s(fp, </code><code class="string">"%d"</code><code class="plain">, &year, </code><code class="keyword bold">sizeof</code><code class="plain">(year)); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String1 |%s|\n"</code><code class="plain">, s1); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String2 |%s|\n"</code><code class="plain">, s2); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"String3 |%s|\n"</code><code class="plain">, s3); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Integer |%d|\n"</code><code class="plain">, year); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">fclose</code><code class="plain">(fp); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code><code class="plain">(0); </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
String1 |Hello|
String2 |World|
String3 |its|
Integer |2017|
</pre>
</li>
<li><strong>sscanf_s() : </strong>sscanf_s() is secure function of sscanf() and secure functions require the size of each c, C, s, S and [ type field to be passed as an argument immediately following the variable.
<pre><strong>Syntax:</strong>
int sscanf_s(const char *restrict buffer, const char *restrict format, ...);
sscanf_s has an extra argument(parameter) where you can specify 
the buffer size and actually control the limit of the input.
</pre>
On success, the function returns the number of variables filled. 
In the case of an input failure, before any data could be successfully read, EOF is returned.
<code class="comments">//C program to illustrate sscanf_s statement </code>
<code class="comments">//This program will run on MS Visual studio </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">s[] = </code><code class="string">"3 red balls 2 blue balls"</code><code class="plain">; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">char</code> <code class="plain">str[10], str2[10]; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="color1 bold">int</code> <code class="plain">i; </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// %*s is used to skip a word </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sscanf_s(s, </code><code class="string">"%d"</code><code class="plain">, &i, </code><code class="keyword bold">sizeof</code><code class="plain">(i)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sscanf_s(s, </code><code class="string">"%*d %*s %*s %*s %s"</code><code class="plain">, str, </code><code class="keyword bold">sizeof</code><code class="plain">(str)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">sscanf_s(s, </code><code class="string">"%*d %*s %*s %*s %*s %s"</code><code class="plain">, str2, </code><code class="keyword bold">sizeof</code><code class="plain">(str2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d %s %s \n"</code><code class="plain">, i, str, str2); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>
3 blue balls 
</pre>
<strong>Note:</strong> sscanf_s() will only work in Microsoft Visual Studio.</li>
</ol>
<h2>Database Connectivity using C/C++</h2>
SQL (Structured Query Language) is a fourth-generation language (4GL) that is used to define, manipulate, and control an RDBMS (relational database management system).
<p style="text-align: justify;">Before starting the main article, let us get familiar with the used tools.
<ol>
<li>
<p style="text-align: justify;"><strong>Compiler:</strong> Code::Blocks IDE with MinGW compiler
<p style="text-align: justify;"><strong>Download Link:</strong> <a href="http://www.codeblocks.org/downloads/5">Binary Download</a><br />
Code::Blocks is a cross compiler (It can run on any platform like Windows, Linux and Mac) and it is free to download. 
This IDE is specially designed for C and C++ and easy to use.
</li>
<li>
<p style="text-align: justify;"><strong>API:</strong> We are going to use SQLAPI++ Library
<p style="text-align: justify;"><strong>Download Link:</strong> <a href="http://www.sqlapi.com/Download/index.html">SQLAPI Download</a>
<p style="text-align: justify;">SQLAPI++ is a C++ library (basically a set of header files) for accessing multiple SQL databases (Oracle, SQL Server, DB2, Sybase, Informix, InterBase, SQLBase, MySQL, PostgreSQL, SQLite, SQL Anywhere and ODBC). 
It is easy to implement and simple.
</li>
<li>
<p style="text-align: justify;"><strong>OCCI:</strong> Oracle C++ Call Interface
<p style="text-align: justify;"><strong>Download Link: </strong><a href="http://www.oracle.com/technetwork/database/features/oci/index-090820.html">OCCI C++ Download </a><br />
OCCI is an interface defined by the database company ORACLE that defines a comfortable interfacefor the C++ programmer to access the Oracle database with classes using parameters that are reminiscent of SQL statements. 
The interface exists for ORACLE 9i, ORACLE 10 and comes with the Oracle.</li></ol>
<p style="text-align: justify;">We must download and install the above three (if we don’t have them). 
Now we are almost ready to start.
&nbsp;
<strong><u>Some settings before starting:</u></strong>
-&gt; Open the code::blocks IDE and go to or click on <strong>settings</strong> -&gt; <strong>compiler and debugger settings</strong> (You will now see global compiler settings)
          
-&gt; Now click on “<strong>Linker settings</strong>” in the linker settings click on ADD button and add the following
For <strong>Windows OS</strong> :
<strong>Code:</strong>
C:\SQLAPI\lib\libsqlapiddll.a
C:\Program Files\CodeBlocks\MinGW\lib\libuser32.a
C:\Program Files\CodeBlocks\MinGW\lib\libversion.a
C:\Program Files\CodeBlocks\MinGW\lib\liboleaut32.a
C:\Program Files\CodeBlocks\MinGW\lib\libole32.a
These will be found in your SQLAPI++ (If you have not extracted in C: drive then select the appropriate location and add the mentioned files to linker settings).
The above code is used to add library files to connect C/C++ program with SQLAPI.
Basically, there are 2 steps:
<ol>
<ol>
<li><strong><u> Connecting to database (and error handling)</u></strong><br />
<strong>Code:</strong>
<code class="comments">// C++ pgroram for connecting to database (and error handling) </code>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include&lt;SQLAPI.h>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main SQLAPI++ header </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc, </code><code class="color1 bold">char</code><code class="plain">* argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create connection object to connect to database </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">SAConnection con; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">try</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// connect to database </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// in this example, it is Oracle, </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// but can also be Sybase, Informix, DB2 </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// SQLServer, InterBase, SQLBase and ODBC </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Connect (</code><code class="string">"test"</code><code class="plain">,&nbsp;&nbsp;&nbsp; </code><code class="comments">// database name </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"tester"</code><code class="plain">,&nbsp; </code><code class="comments">// user name </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="string">"tester"</code><code class="plain">,&nbsp; </code><code class="comments">// password </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">SA_Oracle_Client); </code><code class="comments">//Oracle Client </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"We are connected!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Disconnect is optional </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// autodisconnect will occur in destructor if needed </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Disconnect(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"We are disconnected!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">catch</code><code class="plain">(SAException &amp; x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// SAConnection::Rollback() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// can also throw an exception </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (if a network error for example), </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// we will be ready </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">try</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// on error rollback changes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Rollback (); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">catch</code><code class="plain">(SAException &amp;) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print error message </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, (</code><code class="keyword bold">const</code> <code class="color1 bold">char</code><code class="plain">*)x.ErrText()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre>We are Connected!
We are Disconnected!
</pre></li></ol>
</ol>
&nbsp;
<ol>
<li><strong><u> Executing a simple SQL Command</u></strong><br />
Now, we will look out to execute a simple SQL query.Firstly, creating a table for the database:
create table tb1(id number, name varchar(20);
<p style="text-align: justify;">Now, establish the connection to the database then, after your con.connect; method you should use cmd.setCommandText method to pass the query to the database, it is as shown below:
<pre>con.Connect("test", "tester", "tester", SA_Oracle_Client);
cmd.setCommandText("create table tb1(id number, name varchar(20));”);</pre>
and now, to execute the query we have to use the following command:
cmd.Execute();
<strong>Full Code:</strong>
          
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#include &lt;SQLAPI.h> // main SQLAPI++ header </code>
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="color1 bold">int</code> <code class="plain">argc, </code><code class="color1 bold">char</code><code class="plain">* argv[]) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">SAConnection con; </code><code class="comments">// connection object to connect to database </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">SACommandcmd;&nbsp;&nbsp;&nbsp; </code><code class="comments">// create command object </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">try</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// connect to database (Oracle in our example) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Connect(</code><code class="string">"test"</code><code class="plain">, </code><code class="string">"tester"</code><code class="plain">, </code><code class="string">"tester"</code><code class="plain">, SA_Oracle_Client); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// associate a command with connection </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// connection can also be specified in SACommand constructor </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.setConnection(&con); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// create table </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.setCommandText(</code><code class="string">"create table tbl(id number, name varchar(20));"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.Execute(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// insert value </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.setCommandText(</code><code class="string">"Insert into tbl(id, name) values (1,”Vinay”)"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.setCommandText(</code><code class="string">"Insert into tbl(id, name) values (2,”Kushal”)"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.setCommandText(</code><code class="string">"Insert into tbl(id, name) values (3,”Saransh”)"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">cmd.Execute(); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// commit changes on success </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Commit(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Table created, row inserted!\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">catch</code><code class="plain">(SAException &x) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// SAConnection::Rollback() </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// can also throw an exception </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// (if a network error for example), </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// we will be ready </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">try</code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// on error rollback changes </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">con.Rollback(); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">catch</code><code class="plain">(SAException &) </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// print error message </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%s\n"</code><code class="plain">, (</code><code class="keyword bold">const</code> <code class="color1 bold">char</code><code class="plain">*)x.ErrText()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="plain">} </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code></li></ol>
As we know, Oracle is not auto committed (committing is making permanent reflection of data in the database) so, we have to commit it.
<pre>con.Commit();</pre>
and similarly we can roll back the transactions when an exception occurs, so to do that we use:
<pre>con.Rollback();</pre>
For deleting a row, we use this command.
<pre>cmd.setCommandText("delete from tb1 where id= 2");</pre>
Thus, by the end of this article, we have learned how to connect your C/C++ program to database and perform manipulations.
<h2>Function Interposition in C with an example of user defined malloc()</h2>
<p style="text-align: justify;">Function interposition is the concept of replacing calls to functions in dynamic libraries with calls to user-defined wrappers.
<strong>What are applications?</strong> 
<ol>
<li> We can count number of calls to function.</li>
<li> Store caller&#8217;s information and arguments passed to function to track usage.</li>
<li> Detect memory leak, we can override malloc() and keep track of allocated spaces.</li>
<li> We can add our own security policies. 
For example, we can add a policy that fork cannot be called with more that specified recursion depth.</li>
</ol>
<strong>How to do function interposition?</strong><br />
The task is to write our own malloc() and make sure our own malloc() is called inplace of library malloc(). 
Below is a driver program to test different types of interpositions of malloc().<br/>
<code class="comments">// File Name : hello.c </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;stdlib.h> </code>
<code class="preprocessor">#include &lt;malloc.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="color1 bold">int</code> <code class="plain">main(</code><code class="keyword bold">void</code><code class="plain">) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="comments">// Call to user defined malloc </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">void</code> <code class="plain">*ptr = </code><code class="functions bold">malloc</code><code class="plain">(4); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"Hello World\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<ol>
<li><strong>Compile time : </strong>Replace library call with our own function when the source code is compiled.
<code class="comments">/* Compile-time interposition of malloc using C preprocessor.&nbsp; </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">A local malloc.h file defines malloc as wrapper */</code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// A file that contains our own malloc function </code>
<code class="comments">// File Name : mymalloc.c </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="preprocessor">#include &lt;malloc.h> </code>
<code class="keyword bold">void</code> <code class="plain">*mymalloc(</code><code class="color1 bold">size_t</code> <code class="plain">s) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"My malloc called"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
<code class="comments">// filename : malloc.h </code>
<code class="comments">// To replace all calls to malloc with mymalloc </code>
<code class="preprocessor">#define malloc(size) mymalloc(size) </code>
<code class="keyword bold">void</code> <code class="plain">*mymalloc(</code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
Steps to execute above on Linux: 
<pre>
// Compile the file containing user defined malloc()
:~$ <strong>gcc  -c mymalloc.c</strong>
// Compile hello.c with output file name as helloc. 
// -I. 
is used to include current folder (.) for header
// files to make sure our malloc.h is becomes available.
:~$ <strong>gcc  -I. 
-o helloc hello.c mymalloc.o</strong>
// Run the generated executable
:~$ <strong>./helloc</strong>
My malloc called
Hello World </pre>
</li>
.
<li><strong>Link time : </strong>When the relocatable object files are statically linked to form an executable object file.
<code class="comments">// filename : mymalloc.c </code>
<code class="comments">/* Link-time interposition of malloc using the </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">static linker’s (ld) "--wrap symbol" flag.*/</code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// __real_malloc() is used to called actual library </code>
<code class="comments">// malloc() </code>
<code class="keyword bold">void</code> <code class="plain">*__real_malloc(</code><code class="color1 bold">size_t</code> <code class="plain">size); </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="comments">// User defined wrapper for malloc() </code>
<code class="keyword bold">void</code> <code class="plain">*__wrap_malloc(</code><code class="color1 bold">size_t</code> <code class="plain">size) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"My malloc called"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
Steps to execute above on Linux: 
<pre>
// Compile the file containing user defined malloc()
:~$ <strong>gcc  -c mymalloc.c</strong>
// Compile hello.c with output name as hellol  
// "-Wl,--wrap=malloc" is used tell the linker to use
//  malloc() to call __wrap_malloc(). 
And to use 
// __real_malloc() to actual library malloc() 
:~$ <strong>gcc  -Wl,--wrap=malloc -o hellol hello.c mymalloc.o</strong>
// Run the generated executable
:~$ <strong>./hellol</strong>
My malloc called
Hello World </pre>
</li>
.
<li><strong>Load/run time :</strong> When an executable object file is loaded into memory,  dynamically linked, and then executed.
The environment variable <strong>LD_PRELOAD</strong> gives the loader a list of libraries to load be loaded before a  command or executable.<br />
We  make a dynamic library and make sure it is loaded before our executable for hello.c.
<code class="comments">/* Run-time interposition of malloc based on dynamic linker’s </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="comments">(ld-linux.so) LD_PRELOAD mechanism */</code>
<code class="preprocessor">#define _GNU_SOURCE </code>
<code class="preprocessor">#include &lt;stdio.h> </code>
<code class="undefined spaces">&nbsp;</code>&nbsp;
<code class="keyword bold">void</code> <code class="plain">*</code><code class="functions bold">malloc</code><code class="plain">(</code><code class="color1 bold">size_t</code> <code class="plain">s) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"My malloc called\n"</code><code class="plain">); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">NULL; </code>
<code class="plain">} </code>
Steps to execute above on Linux: 
<pre>
// Compile hello.c with output name as helloc
:~$ <strong>gcc -o hellor hello.c</strong>
// Generate a shared library myalloc.so. 
Refer
// <a href="https://www.geeksforgeeks.org/working-with-shared-libraries-set-2/">https://www.geeksforgeeks.org/working-with-shared-libraries-set-2/</a>
// for details.
:~$ <strong>gcc -shared -fPIC -o mymalloc.so mymalloc.c</strong>
// Make sure shared library is loaded and run before .
:~$ <strong>LD_PRELOAD=./mymalloc.so ./hellor</strong>
My malloc called
Hello World
</pre>
</li>
.
The code for user defined malloc is kept small for better readability. 
Ideally, it should allocate memory by making a call to library malloc().
<strong>Source:</strong><br />
<a href="https://www.utdallas.edu/~zxl111930/spring2012/public/lec18-handout.pdf">https://www.utdallas.edu/~zxl111930/spring2012/public/lec18-handout.pdf</a>
<h2>Macros vs Functions</h2>
<p style="text-align: justify;">Macros are <strong>pre-processed</strong> which means that all the macros would be processed before your program compiles. 
However, functions are <strong>not preprocessed but compiled</strong>.
<strong>See the following example of Macro:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define NUMBER 10 </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, NUMBER); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre class="gb wf">10</pre>
<strong>See the following example of Function:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">number() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">10; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, number()); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output:</strong>
<pre class="gb wf">10</pre>
Now compile them using the command:
<pre style="text-align: center;"><strong>gcc –E file_name.c</strong></pre>
This will give you the executable code as shown in the figure:
<a href="https://media.geeksforgeeks.org/wp-content/cdn-uploads/b12.png"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/b12.png" alt="b12"></a>
This shows that the macros are preprocessed while functions are not.
</br>
In macros, no type checking(incompatible operand, etc.) is done and thus use of micros can lead to errors/side-effects in some cases. 
However, this is not the case with functions. 
Also, macros do not check for compilation error (if any). 
Consider the following two codes:
<strong>Macros:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="preprocessor">#define CUBE(b) b*b*b </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, CUBE(1+2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output: Unexpected output</strong>
          
<pre>7</pre>
<strong>Functions:</strong>
<code class="preprocessor">#include&lt;stdio.h> </code>
<code class="color1 bold">int</code> <code class="plain">cube(</code><code class="color1 bold">int</code> <code class="plain">a) </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">a*a*a; </code>
<code class="plain">} </code>
<code class="color1 bold">int</code> <code class="plain">main() </code>
<code class="plain">{ </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="functions bold">printf</code><code class="plain">(</code><code class="string">"%d"</code><code class="plain">, cube(1+2)); </code>
<code class="undefined spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="keyword bold">return</code> <code class="plain">0; </code>
<code class="plain">} </code>
<strong>Output: As expected</strong>
<pre>27</pre>
<ul>
<li>Macros are usually one liner. 
However, they can consist of more than one line, Click <a href="https://www.geeksforgeeks.org/multiline-macros-in-c/">here</a> to see the usage. 
There are no such constraints in functions.</li>
<li>The speed at which macros and functions differs. 
Macros are typically faster than functions as they don&#8217;t involve actual function call overhead.</li>
</ul>
<strong>Conclusion:</strong><br />
Macros are no longer recommended as they cause following issues. 
There is a better way in modern compilers that is inline functions and const variable. 
Below are disadvantages of macros:
a)  There is no type checking
b)  Difficult to debug as they cause simple replacement.
c)  Macro don&#8217;t have namespace, so a macro in one section of code can affect other section.
d) Macros can cause side effects as shown in above CUBE() example.
<table width="100%" style="table-layout:fixed;">
<thead>
<th>Macro</th>
<th>Function</th>
</thead>
<tbody>
<tr>
<td>Macro is Preprocessed</td>
<td>Function is Compiled</td>
</tr>
<tr>
<td>No Type Checking is done in Macro</td>
<td>Type Checking is Done in Function</td>
</tr>
<tr>
<td>Using Macro increases the code length</td>
<td>Using Function keeps the code length unaffected</td>
</tr>
<tr>
<td>Use of macro can lead to side effect at later stages</td>
<td>Functions do not lead to any side effect in any case</td>
</tr>
<tr>
<td>Speed of Execution using Macro is Faster</td>
<td>Speed of Execution using Function is Slower</td>
</tr>
<tr>
<td>Before Compilation, macro name is replaced by macro value</td>
<td>During function call, transfer of control takes place</td>
</tr>
<tr>
<td>Macros are useful when small code is repeated many times</td>
<td>Functions are useful when large code is to be written</td>
</tr>
<tr>
<td>Macro does not check any Compile-Time Errors</td>
<td>Function checks Compile-Time Errors</td>
</tr>
</tbody>
</table>
See following for more details on macros:<br />
<a href="https://www.geeksforgeeks.org/interesting-facts-preprocessors-c/">Interesting facts about Macros and Preprocessors</a>
<br>
<br>
<br>
<script>
	var toc = $('#toc');
	$('h2').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append(topicNumber + ' <a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>
