<base target="_blank"><html><head><title>SVG Tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
var showTopicNumber = false;
var topicEnd = "<br>";
var bookid = "SVG Tutorial"
var markerName = "h2, h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
#toc{color:cyan; font-size:20px;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>SVG Tutorial</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://fsymbols.com/" class="whitebut ">Symbols Emoji</a>
<a href="https://www.svgviewer.dev/" class="whitebut ">SVGviewer</a>
<a href="https://www.rapidtables.com/web/tools/svg-viewer-editor.html" class="whitebut ">SVG Viewer</a>

</div>
<pre>
<br>
<br>
<h2><span class="orange">Introduction</span></h2>
SVG is an XML language, similar to XHTML, which can be used to draw vector graphics, such as the ones shown to the right. 
It can be used to create an image either by specifying all the lines and shapes necessary, by modifying already existing raster images, or by a combination of both. 
The image and its components can also be transformed, composited together, or filtered to change their appearance completely.

SVG came about in 1999 after several competing formats had been submitted to the <a href="https://www.w3.org">W3C</a> and failed to be fully ratified. 
SVG is supported by all major <a href="https://caniuse.com/#search=svg">browsers</a>. 
A downside is loading SVG can be slow. 
SVG does offer benefits, some of which include having a DOM interface available for it, and not requiring third-party extensions. 
Whether or not to use it often depends on your specific use case.
<h3>&emsp;Basic ingredients</h3>
HTML provides elements for defining headers, paragraphs, tables, and so on. 
In much the same way SVG provides elements for circles, rectangles, and simple and complex curves. 
A simple SVG document consists of nothing more than the <code>&lt;svg></code> root element and several basic shapes that build a graphic together. 
In addition there is the <code>&lt;g></code> element, which is used to group several basic shapes together.

Starting from there, the SVG image can become arbitrarily complex. 
SVG supports gradients, rotations, filter effects, animations, interactivity with JavaScript, and so on. 
But all these extra features of the language rely on this relatively small set of elements to define the graphics area.
<h3>&emsp;Before you start</h3>
There are a number of drawing applications available such as <a href="https://www.inkscape.org/">Inkscape</a> which are free and use SVG as their native file format. 
However, this tutorial will rely on the trusty XML or text editor (your choice). 
The idea is to teach the internals of SVG to those who want to understand it, and that is best done by dirtying your hands with a bit of markup. 
You should note your final goal though. 
Not all SVG viewers are equal and so there is a good chance that something written for one app will not display exactly the same in another, because they support different levels of the SVG specification or another specification that you are using along with SVG (that is, JavaScript or CSS).

SVG is supported in all modern browsers and even a couple versions back in some cases. 
A fairly complete browser support table can be found on <a href="https://caniuse.com/svg">Can I use</a>. 
Firefox has supported some SVG content since version 1.5, and that support level has been growing with each release since. 
Hopefully, along with the tutorial here, MDN can help developers keep up with the differences between Gecko and some of the other major implementations.

Before starting you should have a basic understanding of XML or another markup language such as HTML. 
If you are not too familiar with XML, here are some guidelines to keep in mind:

SVG elements and attributes should all be entered in the case shown here since XML is case-sensitive (unlike HTML).

Attribute values in SVG must be placed inside quotes, even if they are numbers.
SVG is a huge specification. 
This tutorial attempts to cover the basics. 
Once you are familiar you should be able to use the Element Reference and the Interface Reference to find out anything else you need to know.
<h3>&emsp;Flavors of SVG</h3>
Since becoming a recommendation in 2003, the most recent "full" SVG version is 1.1. 
It builds on top of SVG 1.0, but adds more modularization to ease implementation. 
<a href="https://www.w3.org/TR/SVG/">The second edition of SVG 1.1</a> became a Recommendation in 2011. 
"Full" SVG 1.2 was meant to be the next major release of SVG. 
It was dropped for the upcoming <a href="https://www.w3.org/TR/SVG2/">SVG 2.0</a>, which is under heavy development right now and follows a similar approach to CSS 3 in that it splits components into several loosely coupled specifications.

Apart from the full SVG recommendations, the working group at the W3C introduced SVG Tiny and SVG Basic in 2003. 
These two profiles are aimed mainly at mobile devices. 
The first, SVG Tiny, should yield graphics primitives for small devices with low capabilities. 
SVG Basic offers many features of full SVG, but doesn't include the ones which are hard to implement or heavy to render (like animations). 
In 2008, SVG Tiny 1.2 became a W3C Recommendation.

There were plans for an SVG Print specification, which would add support for multiple pages and enhanced color management. 
This work was discontinued.
<h2><br><span class="orange">Getting started</span></h2>
<h3>&emsp;A simple example</h3>
Let us dive straight in with a simple example. 
Take a look at the following code.

<code>&lt;svg version="1.1"
width="300" height="200"
xmlns="http://www.w3.org/2000/svg">

&lt;rect width="100%" height="100%" fill="red" />

&lt;circle cx="150" cy="100" r="80" fill="green" />

&lt;text x="150" y="125" font-size="60" text-anchor="middle" fill="white">SVG&lt;/text>

&lt;/svg>
</code>

Copy the code and paste it in a file demo1.svg. 
Then open the file in Firefox. 
It will render as shown in the following screenshot. 
(Firefox users: click <a href="https://media.prod.mdn.mozit.cloud/attachments/2012/07/09/3075/89b1e0a26e8421e19f907e0522b188bd/svgdemo1.xml">here</a>)
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Getting_Started/svgdemo1.png" alt="" width="300" height="200" class="lazy">

The rendering process involves the following:
We start with the <code>&lt;svg></code> root element:
a doctype declaration as known from (X)HTML should be left off because DTD based SVG validation leads to more problems than it solves

before SVG 2, to identify the version of the SVG for other types of validation the <code>version</code> and <code>baseProfile</code> attributes should always be used instead. 
Both <code>version</code> and <code>baseProfile</code> attributes are deprecated in SVG 2.

as an XML dialect, SVG must always bind the namespaces correctly (in the xmlns attribute). 
See the Namespaces Crash Course page for more info.
The background is set to red by drawing a rectangle <code>&lt;rect></code> that covers the complete image area.

A green circle <code>&lt;circle></code> with a radius of 80px is drawn atop the center of the red rectangle (center of circle offset 150px to the right, and 100px downward from the top left corner).

The text "SVG" is drawn. 
The interior of each letter is filled in with white. 
The text is positioned by setting an anchor where we want the midpoint to be: in this case, the midpoint should correspond to the center of the green circle. 
Fine adjustments can be made to the font size and vertical position to ensure the final result is aesthetically pleasing.
<h3>&emsp;Basic properties of SVG files</h3>
The first important thing to notice is the order of rendering elements. 
The globally valid rule for SVG files is, that <em>later</em> elements are rendered <em>atop previous</em> elements. 
The further down an element is the more it will be visible.

SVG files on the web can be displayed directly in the browser or embedded in HTML files via several methods:
If the HTML is XHTML and is delivered as type <code>application/xhtml+xml</code>, the SVG can be directly embedded in the XML source.

If the HTML is HTML5, and the browser is a conforming HTML5 browser, the SVG can also be directly embedded. 
However, there may be syntax changes necessary to conform to the HTML5 specification.

The SVG file can be referenced with an <code>object</code> element:
&lt;object data="image.svg" type="image/svg+xml" />
Likewise an <code>iframe</code> element can be used:
&lt;iframe src="image.svg">&lt;/iframe>
An <code>img</code> element can theoretically be used too. 
However, this technique doesn't work in Firefox before 4.0.

Finally, SVG can be created dynamically with JavaScript and injected into the HTML DOM. 
With this method, replacement technologies can be implemented for browsers which normally can't process SVG.

See this dedicated article which deals with the topic in-depth.
How SVG handles sizes and units will be explained on the next page.
<h3>&emsp;SVG file types</h3>
SVG files come in two flavors. 
Normal SVG files are simple text files containing SVG markup. 
The recommended filename extension for these files is ".svg" (all lowercase).

Due to the potentially massive size SVG files can reach when used for some applications (e.g., geographical applications), the SVG specification also allows for gzip-compressed SVG files. 
The recommended filename extension for these files is ".svgz" (all lowercase). 
Unfortunately, it is very problematic to get gzip-compressed SVG files to work reliably across all SVG capable user agents when served from a Microsoft IIS server, and Firefox cannot load gzip-compressed SVG from the local computer. 
Avoid gzip-compressed SVG except when you are publishing to a webserver that you know will serve it correctly (see below).
<h3>&emsp;A word on Webservers</h3>
Now that you have an idea of how to create basic SVG files, the next stage is to upload them to a Webserver. 
There are some gotchas at this stage though. 
For normal SVG files, servers should send the HTTP headers:

Content-Type: image/svg+xml
Vary: Accept-Encoding
For gzip-compressed SVG files, servers should send the HTTP headers:

Content-Type: image/svg+xml
Content-Encoding: gzip
Vary: Accept-Encoding
You can check that your server is sending the correct HTTP headers with your SVG files by using the Network Monitor panel or a site such as <a href="https://websniffer.cc/">websniffer.cc</a>. 
Submit the URL of one of your SVG files and look at the HTTP response headers. 
If you find that your server is not sending the headers with the values given above, then you should contact your Web host. 
If you have problems convincing them to correctly configure their servers for SVG, there may be ways to do it yourself. 
See the <a href="https://www.w3.org/services/svg-server/">server configuration page</a> on the w3.org for a range of simple solutions.

Server misconfiguration is a very common reason for SVG failing to load, so make sure you check yours. 
If your server is not configured to send the correct headers with the SVG files it serves, then Firefox will most likely show the markup of the files as text or encoded garbage, or even ask the viewer to choose an application to open them.
<h2><br><span class="orange">Positions</span></h2>
In this article, we examine how Scalable Vector Graphics (SVG) represents the positions and sizes of objects within a drawing context, including coordinate system and what a "pixel" measurement means in a scalable context.
<h2>The grid</h2>
For all elements, SVG uses a coordinate system or <strong>grid</strong> system similar to the one used by canvas (and by a whole lot of other computer drawing routines). 
That is, the top left corner of the document is considered to be the point (0,0), or point of origin. 
Positions are then measured in pixels from the top left corner, with the positive x direction being to the right, and the positive y direction being to the bottom.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Positions/canvas_default_grid.png" alt="" width="220" height="220" class="lazy">

Note that this is slightly different than the way you're taught to graph as a kid (y axis is flipped). 
However, this is the same way elements in HTML are positioned (By default, LTR documents are considered not the RTL documents which position X from right-to-left).

<h4>Example:</h4>
The element

&lt;rect x="0" y="0" width="100" height="100" />
defines a rectangle from the upper left corner, that spans from there 100px to the right and to the bottom.
<h3>&emsp;<a href="#what_are_pixels" title='Permalink to What are "pixels"?'>What are "pixels"?</a></h3>
In the most basic case one pixel in an SVG document maps to one pixel on the output device (a.k.a. 
the screen). 
But SVG wouldn't have the "Scalable" in its name, if there weren't several possibilities to change this behavior. 
Much like absolute and relative font sizes in CSS, SVG defines absolute units (ones with a dimensional identifier like "pt" or "cm") and so-called user units, that lack that identifier and are plain numbers.

Without further specification, one user unit equals one screen unit. 
To explicitly change this behavior, there are several possibilities in SVG. 
We start with the <code>svg</code> root element:

&lt;svg width="100" height="100">
The above element defines a simple SVG canvas with 100x100px. 
One user unit equals one screen unit.

&lt;svg width="200" height="200" viewBox="0 0 100 100">
The whole SVG canvas here is 200px by 200px in size. 
However, the <code>viewBox</code> attribute defines the portion of that canvas to display. 
These 200x200 pixels display an area that starts at user unit (0,0) and spans 100x100 user units to the right and to the bottom. 
This effectively zooms in on the 100x100 unit area and enlarges the image to double size.

The current mapping (for a single element or the whole image) of user units to screen units is called <strong>user coordinate system</strong>. 
Apart from scaling the coordinate system can also be rotated, skewed and flipped. 
The default user coordinate system maps one user pixel to one device pixel. 
(However, the device may decide, what it understands as one pixel.) Lengths in the SVG file with specific dimensions, like "in" or "cm", are then calculated in a way that makes them appear 1:1 in the resulting image.

A quote from the SVG 1.1 specification illustrates this:

<blockquote>
[...] suppose that the user agent can determine from its environment that "1px" corresponds to "0.2822222mm" (i.e., 90dpi). 
Then, for all processing of SVG content: [...] "1cm" equals "35.43307px" (and therefore 35.43307 user units)

</blockquote>
<h2><br><span class="orange">Basic shapes</span></h2>
There are several basic shapes used for most SVG drawing. 
The purpose of these shapes is fairly obvious from their names. 
Some of the parameters that determine their position and size are given, but an element reference would probably contain more accurate and complete descriptions along with other properties that won't be covered in here. 
However, since they're used in most SVG documents, it's necessary to give them some sort of introduction.

To insert a shape, you create an element in the document. 
Different elements correspond to different shapes and take different parameters to describe the size and position of those shapes. 
Some are slightly redundant in that they can be created by other shapes, but they're all there for your convenience and to keep your SVG documents as short and as readable as possible. 
All the basic shapes are shown in the following image.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes/shapes.png" alt="" width="110" height="260" class="lazy">

The code to generate that image looks something like this:

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="200" height="250" version="1.1" xmlns="http://www.w3.org/2000/svg">

&lt;rect x="10" y="10" width="30" height="30" stroke="black" fill="transparent" stroke-width="5"/>
&lt;rect x="60" y="10" rx="10" ry="10" width="30" height="30" stroke="black" fill="transparent" stroke-width="5"/>

&lt;circle cx="25" cy="75" r="20" stroke="red" fill="transparent" stroke-width="5"/>
&lt;ellipse cx="75" cy="75" rx="20" ry="5" stroke="red" fill="transparent" stroke-width="5"/>

&lt;line x1="10" x2="50" y1="110" y2="150" stroke="orange" stroke-width="5"/>
&lt;polyline points="60 110 65 120 70 115 75 130 80 125 85 140 90 135 95 150 100 145"
stroke="orange" fill="transparent" stroke-width="5"/>

&lt;polygon points="50 160 55 180 70 180 60 190 65 205 50 195 35 205 40 190 30 180 45 180"
stroke="green" fill="transparent" stroke-width="5"/>

&lt;path d="M20,230 Q40,205 50,230 T90,230" fill="none" stroke="blue" stroke-width="5"/>
&lt;/svg>
</code>
<strong>Note:</strong> The <code>stroke</code>, <code>stroke-width</code>, and <code>fill</code> attributes are explained later in the tutorial.
<h2>Rectangle</h2>
The <code>&lt;rect></code> element draws a rectangle on the screen. 
There are 6 basic attributes that control the position and shape of the rectangles on screen. 
The one on the right has its <code>rx</code> and <code>ry</code> parameters set, giving it rounded corners. 
If they're not set, they default to <code>0</code>.

<code>&lt;rect x="10" y="10" width="30" height="30"/>
&lt;rect x="60" y="10" rx="10" ry="10" width="30" height="30"/>
</code>

<code>x</code>
The x position of the top left corner of the rectangle.

<code>y</code>
The y position of the top left corner of the rectangle.

<code>width</code>
The width of the rectangle

<code>height</code>
The height of the rectangle

<code>rx</code>
The x radius of the corners of the rectangle

<code>ry</code>
The y radius of the corners of the rectangle
<h2>Circle</h2>
The <code>&lt;circle></code> element draws a circle on the screen. 
It takes 3 basic parameters to determine the shape and size of the element.

<code>&lt;circle cx="25" cy="75" r="20"/></code>

<code>r</code>
The radius of the circle.

<code>cx</code>
The x position of the center of the circle.

<code>cy</code>
The y position of the center of the circle.
<h2>Ellipse</h2>
An <code>&lt;ellipse></code> is a more general form of the <code>&lt;circle></code> element, where you can scale the x and y radius (commonly referred to as the <em>semimajor</em> and <em>semiminor</em> axes in maths) of the circle separately.

<code>&lt;ellipse cx="75" cy="75" rx="20" ry="5"/></code>

<code>rx</code>
The x radius of the ellipse.

<code>ry</code>
The y radius of the ellipse.

<code>cx</code>
The x position of the center of the ellipse.

<code>cy</code>
The y position of the center of the ellipse.
<h2>Line</h2>
The <code>&lt;line></code> element takes the positions of two points as parameters and draws a straight line between them.

<code>&lt;line x1="10" x2="50" y1="110" y2="150" stroke="black" stroke-width="5"/></code>

<code>x1</code>
The x position of point 1.

<code>y1</code>
The y position of point 1.

<code>x2</code>

The x position of point 2.
<code>y2</code>
The y position of point 2.
<h2>Polyline</h2>
A <code>&lt;polyline></code> is a group of connected straight lines. 
Since the list of points can get quite long, all the points are included in one attribute:

<code>&lt;polyline points="60, 110 65, 120 70, 115 75, 130 80, 125 85, 140 90, 135 95, 150 100, 145"/></code>

<code>points</code>
A list of points. 
Each number must be separated by a space, comma, EOL, or a line feed character. 
Each point must contain two numbers: an x coordinate and a y coordinate. 
So, the list <code>(0,0)</code>, <code>(1,1)</code>, and <code>(2,2)</code> would be written as <code>0, 0 1, 1 2, 2</code>.
<h2>Polygon</h2>
A <code>&lt;polygon></code> is similar to a <code>&lt;polyline></code>, in that it is composed of straight line segments connecting a list of points. 
For polygons though, the path automatically connects the last point with the first, creating a closed shape.
<strong>Note:</strong> A rectangle is a type of polygon, so a polygon can be used to create a <code>&lt;rect/></code> element in cases where you need a little more flexibility.
<code>&lt;polygon points="50, 160 55, 180 70, 180 60, 190 65, 205 50, 195 35, 205 40, 190 30, 180 45, 180"/></code>

<code>points</code>
A list of points, each number separated by a space, comma, EOL, or a line feed character. 
Each point must contain two numbers: an x coordinate and a y coordinate. 
So, the list <code>(0,0)</code>, <code>(1,1)</code>, and <code>(2,2)</code> would be written as <code>0, 0 1, 1 2, 2</code>. 
The drawing then closes the path, so a final straight line would be drawn from <code>(2,2)</code> to <code>(0,0)</code>.
<h2>Path</h2>
A <code>&lt;path></code> is the most general shape that can be used in SVG. 
Using a <code>path</code> element, you can draw rectangles (with or without rounded corners), circles, ellipses, polylines, and polygons. 
Basically any of the other types of shapes, bezier curves, quadratic curves, and many more.

For this reason, the next section in this tutorial will be focused on paths. 
But for now, note that there is a single parameter used to control its shape.

<code>&lt;path d="M20,230 Q40,205 50,230 T90,230" fill="none" stroke="blue" stroke-width="5"/></code>
<code>d</code>
A list of points and other information about how to draw the path. 
See the Paths section for more information.

<h2><br><span class="orange">Paths</span></h2>
The <code>&lt;path></code> element is the most powerful element in the SVG library of basic shapes. 
It can be used to create lines, curves, arcs, and more.

Paths create complex shapes by combining multiple straight lines or curved lines. 
Complex shapes composed only of straight lines can be created as <code>&lt;polyline></code>s. 
While <code>&lt;polyline></code>s and <code>&lt;path></code>s can create similar-looking shapes, <code>&lt;polyline></code>s require a lot of small straight lines to simulate curves, and don't scale well to larger sizes.

A good understanding of paths is important when drawing SVGs. 
While creating complex paths using an XML editor or text editor is not recommended, understanding how they work will allow to identify and repair display issues in SVGs.

The shape of a <code>&lt;path></code> element is defined by one parameter: <code>d</code>. 
(See more in basic shapes.) The <code>d</code> attribute contains a series of commands and parameters used by those commands.

Each of the commands is instantiated (for example, creating a class, naming and locating it) by a specific letter. 
For instance, let's move to the x and y coordinates (<code>10</code>, <code>10</code>). 
The "Move to" command is called with the letter <code>M</code>. 
When the parser runs into this letter, it knows it needs to move to a point. 
So, to move to (<code>10</code>,<code>10</code>) the command to use would be <code>M 10 10</code>. 
After that, the parser begins reading for the next command.

All of the commands also come in two variants. 
An <strong>uppercase letter</strong> specifies absolute coordinates on the page, and a <strong>lowercase letter</strong> specifies relative coordinates (e.g., <em>move 10px up and 7px to the left from the last point</em>).

Coordinates in the <code>d</code> parameter are <strong>always unitless</strong> and hence in the user coordinate system. 
Later, we will learn how paths can be transformed to suit other needs.
<h2>Line commands</h2>
There are five line commands for <code>&lt;path></code> nodes. 
The first command is the "Move To" or <code>M</code>, which was described above. 
It takes two parameters, a coordinate (<code>x</code>) and coordinate (<code>y</code>) to move to. 
If the cursor was already somewhere on the page, no line is drawn to connect the two positions. 
The "Move To" command appears at the beginning of paths to specify where the drawing should start. 
For example:
<code>M x y
(or)
m dx dy</code>

In the following example there's only a point at (<code>10</code>,<code>10</code>). 
Note, though, that it wouldn't show up if a path was just drawn normally. 
For example:
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/blank_path_area.png" alt="" width="100" height="100" class="lazy">

<code>&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">

&lt;path d="M10 10"/>

&lt;!-- Points -->
&lt;circle cx="10" cy="10" r="2" fill="red"/>

&lt;/svg>
</code>

There are three commands that draw lines. 
The most generic is the "Line To" command, called with <code>L</code>. 
<code>L</code> takes two parameters—x and y coordinates—and draws a line from the current position to a new position.

<code> L x y
(or)
l dx dy</code>

There are two abbreviated forms for drawing horizontal and vertical lines. 
<code>H</code> draws a horizontal line, and <code>V</code> draws a vertical line. 
Both commands only take one parameter since they only move in one direction.

<code> H x
(or)
h dx

V y
(or)
v dy
</code>

An easy place to start is by drawing a shape. 
We will start with a rectangle (the same type that could be more easily made with a <code>&lt;rect></code> element). 
It's composed of horizontal and vertical lines only.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/path_line_commands.png" alt="" width="100" height="100" class="lazy">

<code>&lt;svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">

&lt;path d="M 10 10 H 90 V 90 H 10 L 10 10"/>

&lt;!-- Points -->
&lt;circle cx="10" cy="10" r="2" fill="red"/>
&lt;circle cx="90" cy="90" r="2" fill="red"/>
&lt;circle cx="90" cy="10" r="2" fill="red"/>
&lt;circle cx="10" cy="90" r="2" fill="red"/>

&lt;/svg>
</code>

We can shorten the above path declaration a little bit by using the "Close Path" command, called with <code>Z</code>. 
This command draws a straight line from the current position back to the first point of the path. 
It is often placed at the end of a path node, although not always. 
There is no difference between the uppercase and lowercase command.

<code> Z
(or)
z
</code>

So our path above could be shortened to:

<code> &lt;path d="M 10 10 H 90 V 90 H 10 Z" fill="transparent" stroke="black"/>
</code>

The relative forms of these commands can also be used to draw the same picture. 
Relative commands are called by using lowercase letters, and rather than moving the cursor to an exact coordinate, they move it relative to its last position. 
For instance, since our box is 80×80, the <code>&lt;path></code> element could have been written as:

<code> &lt;path d="M 10 10 h 80 v 80 h -80 Z" fill="transparent" stroke="black"/>
</code>

The path will move to point (<code>10</code>,<code>10</code>) and then move horizontally 80 points to the right, then 80 points down, then 80 points to the left, and then back to the start.

In these examples, it would probably be simpler to use the <code>&lt;polygon></code> or <code>&lt;polyline></code> elements. 
However, paths are used so often in drawing SVG that developers may be more comfortable using them instead. 
There is no real performance penalty or bonus for using one or the other.
<h2>Curve commands</h2>
There are three different commands that can be used to create smooth curves. 
Two of those curves are Bézier curves, and the third is an "arc" or part of a circle. 
You might have already gained practical experience with Bézier curves using path tools in Inkscape, Illustrator or Photoshop. 
For a complete description of the math behind Bézier curves, go to a reference like the one on <a href="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Wikipedia</a>. 
There are an infinite number of Bézier curves, but only two simple ones are available in <code>&lt;path></code> elements: a cubic one, called with <code>C</code>, and a quadratic one, called with <code>Q</code>.

<h3>&emsp;Bézier Curves</h3>
The cubic curve, <code>C</code>, is the slightly more complex curve. 
Cubic Béziers take in two control points for each point. 
Therefore, to create a cubic Bézier, three sets of coordinates need to be specified.

<code> C x1 y1, x2 y2, x y
(or)
c dx1 dy1, dx2 dy2, dx dy
</code>

The last set of coordinates here (<code>x</code>,<code>y</code>) specify where the line should end. 
The other two are control points. 
(<code>x1</code>,<code>y1</code>) is the control point for the start of the curve, and (<code>x2</code>,<code>y2</code>) is the control point for the end. 
The control points essentially describe the slope of the line starting at each point. 
The Bézier function then creates a smooth curve that transfers from the slope established at the beginning of the line, to the slope at the other end.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/cubic_b%C3%A9zier_curves_with_grid.png" alt="Cubic Bézier Curves with grid" width="190" height="160" class="lazy">

<code>&lt;svg width="190" height="160" xmlns="http://www.w3.org/2000/svg">

&lt;path d="M 10 10 C 20 20, 40 20, 50 10" stroke="black" fill="transparent"/>
&lt;path d="M 70 10 C 70 20, 110 20, 110 10" stroke="black" fill="transparent"/>
&lt;path d="M 130 10 C 120 20, 180 20, 170 10" stroke="black" fill="transparent"/>
&lt;path d="M 10 60 C 20 80, 40 80, 50 60" stroke="black" fill="transparent"/>
&lt;path d="M 70 60 C 70 80, 110 80, 110 60" stroke="black" fill="transparent"/>
&lt;path d="M 130 60 C 120 80, 180 80, 170 60" stroke="black" fill="transparent"/>
&lt;path d="M 10 110 C 20 140, 40 140, 50 110" stroke="black" fill="transparent"/>
&lt;path d="M 70 110 C 70 140, 110 140, 110 110" stroke="black" fill="transparent"/>
&lt;path d="M 130 110 C 120 140, 180 140, 170 110" stroke="black" fill="transparent"/>

&lt;/svg>
</code>

The example above creates nine cubic Bézier curves. 
As the curves move toward the right, the control points become spread out horizontally. 
As the curves move downward, they become further separated from the end points. 
The thing to note here is that the curve starts in the direction of the first control point, and then bends so that it arrives along the direction of the second control point.

Several Bézier curves can be stringed together to create extended, smooth shapes. 
Often, the control point on one side of a point will be a reflection of the control point used on the other side to keep the slope constant. 
In this case, a shortcut version of the cubic Bézier can be used, designated by the command <code>S</code> (or <code>s</code>).

<code> S x2 y2, x y
(or)
s dx2 dy2, dx dy
</code>

<code>S</code> produces the same type of curve as earlier—but if it follows another <code>S</code> command or a <code>C</code> command, the first control point is assumed to be a reflection of the one used previously. 
If the <code>S</code> command doesn't follow another <code>S</code> or <code>C</code> command, then the current position of the cursor is used as the first control point. 
In this case the result is the same as what the <code>Q</code> command would have produced with the same parameters.

An example of this syntax is shown below, and in the figure to the left the specified control points are shown in red, and the inferred control point in blue.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/shortcut_cubic_b%C3%A9zier_with_grid.png" alt="" width="190" height="160" class="lazy">

<code>&lt;svg width="190" height="160" xmlns="http://www.w3.org/2000/svg">
&lt;path d="M 10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80" stroke="black" fill="transparent"/>
&lt;/svg>
</code>

The other type of Bézier curve, the quadratic curve called with <code>Q</code>, is actually a simpler curve than the cubic one. 
It requires one control point which determines the slope of the curve at both the start point and the end point. 
It takes two parameters: the control point and the end point of the curve.
<strong>Note:</strong> The co-ordinate deltas for <code>q</code> are both relative to the previous point (that is, <code>dx</code> and <code>dy</code> are not relative to <code>dx1</code> and <code>dy1</code>).
<code> Q x1 y1, x y
(or)
q dx1 dy1, dx dy
</code>
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/quadratic_b%C3%A9zier_with_grid.png" alt="Quadratic Bézier with grid" width="190" height="160" class="lazy">

<code>&lt;svg width="190" height="160" xmlns="http://www.w3.org/2000/svg">
&lt;path d="M 10 80 Q 95 10 180 80" stroke="black" fill="transparent"/>
&lt;/svg>
</code>

As with the cubic Bézier curve, there is a shortcut for stringing together multiple quadratic Béziers, called with <code>T</code>.

<code> T x y
(or)
t dx dy
</code>

This shortcut looks at the previous control point used and infers a new one from it. 
This means that after the first control point, fairly complex shapes can be made by specifying only end points.

This only works if the previous command was a <code>Q</code> or a <code>T</code> command. 
If not, then the control point is assumed to be the same as the previous point, and only lines will be drawn.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/shortcut_quadratic_b%C3%A9zier_with_grid.png" alt="" width="188" height="158" class="lazy">

<code>&lt;svg width="190" height="160" xmlns="http://www.w3.org/2000/svg">
&lt;path d="M 10 80 Q 52.5 10, 95 80 T 180 80" stroke="black" fill="transparent"/>
&lt;/svg>
</code>

Both curves produce similar results, although the cubic one allows greater freedom in exactly what the curve looks like. 
Deciding which curve to use is situational and depends on the amount of symmetry the line has.
<h3>&emsp;Arcs</h3>
The other type of curved line that can be created using SVG is the arc, called with the <code>A</code> command. 
Arcs are sections of circles or ellipses.

For a given x-radius and y-radius, there are two ellipses that can connect any two points (as long as they're within the radius of the circle). 
Along either of those circles, there are two possible paths that can be taken to connect the points—so in any situation, there are four possible arcs available.

Because of that, arcs require quite a few parameters:

<code> A rx ry x-axis-rotation large-arc-flag sweep-flag x y
a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy
</code>

At its start, the arc element takes in two parameters for the x-radius and y-radius. 
If needed, see <code>&lt;ellipse></code>s and how they behave. 
The final two parameters designate the x and y coordinates to end the stroke. 
Together, these four values define the basic structure of the arc.

The third parameter describes the rotation of the arc. 
This is best explained with an example:
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/svgarcs_xaxisrotation_with_grid.png" alt="SVGArcs_XAxisRotation_with_grid" width="200" height="201" class="lazy">

<code>&lt;svg width="320" height="320" xmlns="http://www.w3.org/2000/svg">
&lt;path d="M 10 315
L 110 215
A 30 50 0 0 1 162.55 162.45
L 172.55 152.45
A 30 50 -45 0 1 215.1 109.9
L 315 10" stroke="black" fill="green" stroke-width="2" fill-opacity="0.5"/>
&lt;/svg>
</code>

The example shows a <code>&lt;path></code> element that goes diagonally across the page. 
At its center, two elliptical arcs have been cut out (x radius = <code>30</code>, y radius = <code>50</code>). 
In the first one, the x-axis-rotation has been left at <code>0</code>, so the ellipse that the arc travels around (shown in gray) is oriented straight up and down. 
For the second arc, though, the x-axis-rotation is set to <code>-45</code> degrees. 
This rotates the ellipse so that it is aligned with its minor axis along the path direction, as shown by the second ellipse in the example image.

For the unrotated ellipse in the image above, there are only two different arcs and not four to choose from because the line drawn from the start and end of the arc goes through the center of the ellipse. 
In a slightly modified example the two ellipses that form the four different arcs can be seen:
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/svgarcs_xaxisrotation_with_grid_ellipses.png" alt="Show the 4 arcs on the Ellipse example" width="320" height="320" class="lazy">

<code>&lt;svg xmlns="http://www.w3.org/2000/svg" width="320" height="320">
&lt;path d="M 10 315
L 110 215
A 36 60 0 0 1 150.71 170.29
L 172.55 152.45
A 30 50 -45 0 1 215.1 109.9
L 315 10" stroke="black" fill="green" stroke-width="2" fill-opacity="0.5"/>
&lt;circle cx="150.71" cy="170.29" r="2" fill="red"/>
&lt;circle cx="110" cy="215" r="2" fill="red"/>
&lt;ellipse cx="144.931" cy="229.512" rx="36" ry="60" fill="transparent" stroke="blue"/>
&lt;ellipse cx="115.779" cy="155.778" rx="36" ry="60" fill="transparent" stroke="blue"/>
&lt;/svg>
</code>

Notice that each of the blue ellipses are formed by two arcs, depending on traveling clockwise or counter-clockwise. 
Each ellipse has one short arc and one long arc. 
The two ellipses are just mirror images of each other. 
They are flipped along the line formed from the start→end points.

If the start→end points are farther than the ellipse's <code>x</code> and <code>y</code> radius can reach, the ellipse's radii will be minimally expanded so it could reach the start→end points. 
The interactive codepen at the bottom of this page demonstrates this well. 
To determine if an ellipse's radii are large enough to require expanding, a system of equations would need to be solved, such as <a href="https://www.wolframalpha.com/input/?i=solve+((110+-+x)%5E2%2F36%5E2)+%2B+((215+-+y)%5E2%2F60%5E2)+%3D+1,+((150.71+-+x)%5E2%2F36%5E2)+%2B+((170.29+-+y)%5E2%2F60%5E2)+%3D+1">this on wolfram alpha</a>. 
This computation is for the non-rotated ellipse with start→end (<code>110</code>, <code>215</code>)→(<code>150.71</code>, <code>170.29</code>). 
The solution, (<code>x</code>, <code>y</code>), is the center of the ellipse(s). 
The solution will be <a href="https://www.wolframalpha.com/input/?i=solve+((110+-+x)%5E2%2F30%5E2)+%2B+((215+-+y)%5E2%2F50%5E2)+%3D+1,+((162.55+-+x)%5E2%2F30%5E2)+%2B+((162.45+-+y)%5E2%2F50%5E2)+%3D+1">imaginary</a> if the ellipse's radii are too small. 
This second computation is for the non-rotated ellipse with start→end (<code>110</code>, <code>215</code>)→(<code>162.55</code>, <code>162.45</code>). 
The solution has a small imaginary component because the ellipse was just barely expanded.

The four different paths mentioned above are determined by the next two parameter flags. 
As mentioned earlier, there are still two possible ellipses for the path to travel around and two different possible paths on both ellipses, giving four possible paths. 
The first parameter is the <code>large-arc-flag</code>. 
It determines if the arc should be greater than or less than 180 degrees; in the end, this flag determines which direction the arc will travel around a given circle. 
The second parameter is the <code>sweep-flag</code>. 
It determines if the arc should begin moving at positive angles or negative ones, which essentially picks which of the two circles will be traveled around. 
The example below shows all four possible combinations, along with the two circles for each case.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths/svgarcs_flags.png" alt="" width="325" height="325" class="lazy">

<code>&lt;svg width="325" height="325" xmlns="http://www.w3.org/2000/svg">
&lt;path d="M 80 80
A 45 45, 0, 0, 0, 125 125
L 125 80 Z" fill="green"/>
&lt;path d="M 230 80
A 45 45, 0, 1, 0, 275 125
L 275 80 Z" fill="red"/>
&lt;path d="M 80 230
A 45 45, 0, 0, 1, 125 275
L 125 230 Z" fill="purple"/>
&lt;path d="M 230 230
A 45 45, 0, 1, 1, 275 275
L 275 230 Z" fill="blue"/>
&lt;/svg>
</code>

Arcs are an easy way to create pieces of circles or ellipses in drawings. 
For instance, a pie chart would require a different arc for each piece.

If transitioning to SVG from <code>&lt;canvas></code>, arcs can be the hardest thing to learn, but are also much more powerful. 
Complete circles and ellipses are the only shapes that SVG arcs have trouble drawing. 
Because the start and end points for any path going around a circle are the same point, there are an infinite number of circles that could be chosen, and the actual path is undefined. 
It's possible to approximate them by making the start and end points of the path slightly askew, and then connecting them with another path segment. 
For example, it's possible to make a circle with an arc for each semi-circle. 
At that point, it's often easier to use a real <code>&lt;circle></code> or <code>&lt;ellipse></code> node instead. 
This interactive demo might help understand the concepts behind SVG arcs: <a href="https://codepen.io/lingtalfi/pen/yaLWJG">http://codepen.io/lingtalfi/pen/yaLWJG</a> (tested in chrome and firefox only, might not work in your browser)
<h2><br><span class="orange">Fills and Strokes</span></h2>
There are several ways to color shapes (including specifying attributes on the object) using inline CSS, an embedded CSS section, or an external CSS file. 
Most SVG you'll find around the web use inline CSS, but there are advantages and disadvantages associated with each type.
<h2>Fill and Stroke Attributes</h2>
<h3>&emsp;Painting</h3>
Basic coloring can be done by setting two attributes on the node: <code>fill</code> and <code>stroke</code>. 
Using <code>fill</code> sets the color inside the object and <code>stroke</code> sets the color of the line drawn around the object. 
You can use the same css color naming schemes that you use in HTML, whether that's color names (that is <code>red</code>), rgb values (that is <code>rgb(255,0,0)</code>), hex values, rgba values, etc.

<code> &lt;rect x="10" y="10" width="100" height="100" stroke="blue" fill="purple"
fill-opacity="0.5" stroke-opacity="0.8"/>
</code>

In addition, you can specify the opacity of either the <code>fill</code> or <code>stroke</code> separately in SVG. 
These are controlled by the <code>fill-opacity</code> and <code>stroke-opacity</code> attributes.
<strong>Note:</strong> In Firefox, <code>rgba</code> values are also allowed, and will give the same effect. 
But for compatibility with other viewers, it's often best to specify the <code>fill</code>/<code>stroke</code> opacity separately. 
If you specify both an <code>rgba</code> value and a <code>fill</code>/<code>stroke</code> opacity value, both will be applied.
<h3>&emsp;Stroke</h3>
In addition to its color properties, there are a few other attributes available to control the way a stroke is drawn on a line.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes/svg_stroke_linecap_example.png" alt="" width="160" height="140" class="lazy">

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="160" height="140" xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;line x1="40" x2="120" y1="20" y2="20" stroke="black" stroke-width="20" stroke-linecap="butt"/>
&lt;line x1="40" x2="120" y1="60" y2="60" stroke="black" stroke-width="20" stroke-linecap="square"/>
&lt;line x1="40" x2="120" y1="100" y2="100" stroke="black" stroke-width="20" stroke-linecap="round"/>
&lt;/svg>
</code>

The <code>stroke-width</code> property defines the width of this stroke. 
Strokes are drawn centered around the path. 
In the example above, the path is shown in pink, and the stroke in black.

The second attribute affecting strokes is the <code>stroke-linecap</code> property, demonstrated above. 
This controls the shape of the ends of lines.

There are three possible values for <code>stroke-linecap</code>:
<code>butt</code> closes the line off with a straight edge that's normal (at 90 degrees) to the direction of the stroke and crosses its end.
<code>square</code> has essentially the same appearance, but stretches the stroke slightly beyond the actual path. 
The distance that the stroke goes beyond the path is half the <code>stroke-width</code>.
<code>round</code> produces a rounded effect on the end of the stroke. 
The radius of this curve is also controlled by the <code>stroke-width</code>.
Use <code>stroke-linejoin</code> to control how the joint between two line segments is drawn.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes/svg_stroke_linejoin_example.png" alt="" width="160" height="280" class="lazy">

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="160" height="280" xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;polyline points="40 60 80 20 120 60" stroke="black" stroke-width="20"
stroke-linecap="butt" fill="none" stroke-linejoin="miter"/>

&lt;polyline points="40 140 80 100 120 140" stroke="black" stroke-width="20"
stroke-linecap="round" fill="none" stroke-linejoin="round"/>

&lt;polyline points="40 220 80 180 120 220" stroke="black" stroke-width="20"
stroke-linecap="square" fill="none" stroke-linejoin="bevel"/>
&lt;/svg>
</code>

Each of these polylines has two segments. 
The joint where the two meet is controlled by the <code>stroke-linejoin</code> attribute. 
There are three possible values for this attribute. 
<code>miter</code> extends the line slightly beyond its normal width to create a square corner where only one angle is used. 
<code>round</code> creates a rounded line segment. 
<code>bevel</code> creates a new angle to aid in the transition between the two segments.

Finally, you can also use dashed line types on a stroke by specifying the <code>stroke-dasharray</code> attribute.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes/svg_stroke_dasharray_example.png" alt="" width="200" height="150" class="lazy">

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="200" height="150" xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;path d="M 10 75 Q 50 10 100 75 T 190 75" stroke="black"
stroke-linecap="round" stroke-dasharray="5,10,5" fill="none"/>
&lt;path d="M 10 75 L 190 75" stroke="red"
stroke-linecap="round" stroke-width="1" stroke-dasharray="5,5" fill="none"/>
&lt;/svg>
</code>

The <code>stroke-dasharray</code> attribute takes a series of comma-separated numbers as its argument.
<strong>Note:</strong> Unlike <code>&lt;path></code> elements, these numbers <em><strong>must</strong></em> be comma-separated (whitespace is ignored).
The first number specifies a distance for the filled area, and the second a distance for the unfilled area. 
So in the above example, the second path fills 5 pixel units, with 5 blank units until the next dash of 5 units. 
You can specify more numbers if you would like a more complicated dash pattern. 
The first example specifies three numbers, in which case the renderer loops the numbers twice to create an even pattern. 
So the first path renders 5 filled, 10 empty, 5 filled, and then loops back to create 5 empty, 10 filled, 5 empty. 
The pattern then repeats.

There are additional <code>stroke</code> and <code>fill</code> properties available, including <code>fill-rule,</code> which specifies how to color in shapes that overlap themselves; <code>stroke-miterlimit</code>, which determines if a stroke should draw miters; and stroke-dashoffset, which specifies where to start a dasharray on a line.
<h2>Using CSS</h2>
In addition to setting attributes on objects, you can also use CSS to style fills and strokes. 
Not all attributes can be set via CSS. 
Attributes that deal with painting and filling are usually available, so <code>fill</code>, <code>stroke</code>, <code>stroke-dasharray</code>, etc... 
can all be set this way, in addition to the gradient and pattern versions of those shown below. 
Attributes like <code>width</code>, <code>height</code>, or <code>&lt;path></code> commands cannot be set through CSS. 
It's easiest just to test and find out what is available and what isn't.
<strong>Note:</strong> The <a href="https://www.w3.org/TR/SVG/propidx.html">SVG specification</a> decides strictly between attributes that are <em>properties</em> and other attributes. 
The former can be modified with CSS, the latter not.
CSS can be inserted inline with the element via the <code>style</code> attribute:

<code> &lt;rect x="10" height="180" y="10" width="180" style="stroke: black; fill: red;"/>
</code>

Or it can be moved to a special style section that you include. 
Instead of shoving such a section into a <code>&lt;head></code> section like you do in HTML, though, it's included in an area called <code>&lt;defs></code>.

<code>&lt;defs></code> stands for definitions, and it is here that you can create elements that don't appear in the SVG directly, but are used by other elements.

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;defs>
&lt;style type="text/css">&lt;![CDATA[
#MyRect {
stroke: black;
fill: red;
}
]]>&lt;/style>
&lt;/defs>
&lt;rect x="10" height="180" y="10" width="180" id="MyRect"/>
&lt;/svg>
</code>

Moving styles to an area like this can make it easier to adjust properties on large groups of elements. 
You can also use things like the <strong><code>:hover</code> pseudo class</strong> to create rollover effects:

<code> #MyRect:hover {
stroke: black;
fill: blue;
}
</code>

You can also specify an external stylesheet for your CSS rules through <a href="https://www.w3.org/TR/xml-stylesheet/">normal XML-stylesheet syntax</a>:

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;?xml-stylesheet type="text/css" href="style.css"?>

&lt;svg width="200" height="150" xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;rect height="10" width="10" id="MyRect"/>
&lt;/svg>
</code>

Where <code>style.css</code> looks something like:

<code>#MyRect {
fill: red;
stroke: black;
}
</code>
<h2><br><span class="orange">Gradients in SVG</span></h2>
Perhaps more exciting than just fills and strokes is the fact that you can also create and apply gradients as either fills or strokes.

There are two types of gradients: linear and radial. 
You <strong>must</strong> give the gradient an <code>id</code> attribute; otherwise it can't be referenced by other elements inside the file. 
Gradients are defined in a defs section as opposed to on a shape itself to promote reusability.
<h2>Linear Gradient</h2>
Linear gradients change along a straight line. 
To insert one, you create a <code>&lt;linearGradient></code> node inside the definitions section of your SVG file.

<h3>&emsp;Basic example</h3>
<code>&lt;svg width="120" height="240" version="1.1" xmlns="http://www.w3.org/2000/svg">
&lt;defs>
&lt;linearGradient id="Gradient1">
&lt;stop class="stop1" offset="0%"/>
&lt;stop class="stop2" offset="50%"/>
&lt;stop class="stop3" offset="100%"/>
&lt;/linearGradient>
&lt;linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="50%" stop-color="black" stop-opacity="0"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/linearGradient>
&lt;style type="text/css">&lt;![CDATA[
#rect1 { fill: url(#Gradient1); }
.stop1 { stop-color: red; }
.stop2 { stop-color: black; stop-opacity: 0; }
.stop3 { stop-color: blue; }
]]>&lt;/style>
&lt;/defs>

&lt;rect id="rect1" x="10" y="10" rx="15" ry="15" width="100" height="100"/>
&lt;rect x="10" y="120" rx="15" ry="15" width="100" height="100" fill="url(#Gradient2)"/>

&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Linear Gradient sample" width="120" height="280" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Gradients/_sample_.Linear_Gradient.html" class="lazy"></iframe>
Above is an example of a linear gradient being applied to a <code>&lt;rect></code> element. 
Inside the linear gradient are several <code>&lt;stop></code> nodes. 
These nodes tell the gradient what color it should be at certain positions by specifying an <code>offset</code> attribute for the position, and a <code>stop-color</code> attribute. 
This can be assigned directly or through CSS. 
The two methods have been intermixed for the purposes of this example. 
For instance, this one tells the gradient to start at the color red, change to transparent-black in the middle, and end at the color blue. 
You can insert as many stop colors as you like to create a blend that's as beautiful or hideous as you need, but the offsets should always increase from 0% (or 0 if you want to drop the % sign) to 100% (or 1). 
Duplicate values will use the stop that is assigned furthest down the XML tree. 
Also, like with fill and stroke, you can specify a <code>stop-opacity</code> attribute to set the opacity at that position (again, in FF3 you can also use rgba values to do this).

&lt;stop offset="100%" stop-color="yellow" stop-opacity="0.5"/>
To use a gradient, we have to reference it from an object's <code>fill</code> or <code>stroke</code> attributes. 
This is done the same way you reference elements in CSS, using a <code>url</code>. 
In this case, the url is just a reference to our gradient, which I've given the creative ID, "Gradient". 
To attach it, set the <code>fill</code> to <code>url(#Gradient)</code>, and voila! Our object is now multicolored. 
You can do the same with <code>stroke</code>.

The <code>&lt;linearGradient></code> element also takes several other attributes, which specify the size and appearance of the gradient. 
The orientation of the gradient is controlled by two points, designated by the attributes <code>x1</code>, <code>x2</code>, <code>y1</code>, and <code>y2</code>. 
These attributes define a line along which the gradient travels. 
The gradient defaults to a horizontal orientation, but it can be rotated by changing these. 
Gradient2 in the above example is designed to create a vertical gradient.

&lt;linearGradient x1="0" x2="0" y1="0" y2="1">
<strong>Note:</strong> You can also use the <code>xlink:href</code> attribute on gradients too. 
When it is used, attributes and stops from one gradient can be included on another. 
In the above example, you wouldn't have to recreate all the stops in Gradient2.

&lt;linearGradient>
&lt;stop offset="0%"/>
&lt;stop offset="50%"/>
&lt;stop offset="100%"/>
&lt;/linearGradient>
&lt;linearGradient x1="0" x2="0" y1="0" y2="1"
xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#Gradient1"/>
I've included the xlink namespace here directly on the node, although usually you would define it at the top of your document. 
More on that when we talk about images.
<h2>Radial Gradient</h2>
Radial gradients are similar to linear ones but draw a gradient that radiates out from a point. 
To create one you add a <code>&lt;radialGradient></code> element to the definitions section of your document.

<h3>&emsp;Basic example</h3>
<code>&lt;?xml version="1.0" standalone="no"?>
&lt;svg width="120" height="240" version="1.1" xmlns="http://www.w3.org/2000/svg">
&lt;defs>
&lt;radialGradient id="RadialGradient1">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;radialGradient id="RadialGradient2" cx="0.25" cy="0.25" r="0.25">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;/defs>

&lt;rect x="10" y="10" rx="15" ry="15" width="100" height="100" fill="url(#RadialGradient1)"/>
&lt;rect x="10" y="120" rx="15" ry="15" width="100" height="100" fill="url(#RadialGradient2)"/>

&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Basic example 2 sample" width="120" height="280" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Gradients/_sample_.Basic_example_2.html" class="lazy"></iframe>
The stops used here are the same as before, but now the object will be red in the center, and in all directions gradually change to blue at the edge. 
Like linear gradients, the <code>&lt;radialGradient></code> node can take several attributes to describe its position and orientation. 
However, unlike linear gradients, it's a bit more complex. 
The radial gradient is again defined by two points, which determine where its edges are. 
The first of these defines a circle around which the gradient ends. 
It requires a center point, designated by the <code>cx</code> and <code>cy</code> attributes, and a radius, <code>r</code>. 
Setting these three attributes will allow you to move the gradient around and change its size, as shown in the second <code>rect</code> above.

The second point is called the focal point and is defined by the <code>fx</code> and <code>fy</code> attributes. 
While the first point described where the edges of the gradient were, the focal point describes where its middle is. 
This is easier to see with an example.
<h3>&emsp;Center and focal point</h3>
<code>&lt;?xml version="1.0" standalone="no"?>

&lt;svg width="120" height="120" version="1.1"
xmlns="http://www.w3.org/2000/svg">
&lt;defs>
&lt;radialGradient id="Gradient"
cx="0.5" cy="0.5" r="0.5" fx="0.25" fy="0.25">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;/defs>

&lt;rect x="10" y="10" rx="15" ry="15" width="100" height="100"
fill="url(#Gradient)" stroke="black" stroke-width="2"/>

&lt;circle cx="60" cy="60" r="50" fill="transparent" stroke="white" stroke-width="2"/>
&lt;circle cx="35" cy="35" r="2" fill="white" stroke="white"/>
&lt;circle cx="60" cy="60" r="2" fill="white" stroke="white"/>
&lt;text x="38" y="40" fill="white" font-family="sans-serif" font-size="10pt">(fx,fy)&lt;/text>
&lt;text x="63" y="63" fill="white" font-family="sans-serif" font-size="10pt">(cx,cy)&lt;/text>

&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Center and focal point sample" width="120" height="160" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Gradients/_sample_.Center_and_focal_point.html" class="lazy"></iframe>
If the focal point is moved outside the circle described earlier, it's impossible for the gradient to be rendered correctly, so the spot will be assumed to be within the edge of the circle. 
If the focal point isn't given at all, it's assumed to be at the same place as the center point.

Both linear and radial gradients also take a few other attributes to describe transformations they may undergo. 
The only other one I want to mention here is the <code>spreadMethod</code> attribute. 
This attribute controls what happens when the gradient reaches its end, but the object isn't filled yet. 
It can take on one of three values, "pad", "reflect", or "repeat". 
"Pad" is what you have seen so far. 
When the gradient reaches its end, the final offset color is used to fill the rest of the object. 
"reflect" causes the gradient to continue on, but reflected in reverse, starting with the color offset at 100% and moving back to the offset at 0%, and then back up again. 
"Repeat" also lets the gradient continue, but instead of going backwards, it just jumps back to the beginning and runs again.
<h3>&emsp;spreadMethod</h3>
<code>&lt;?xml version="1.0" standalone="no"?>

&lt;svg width="220" height="220" version="1.1" xmlns="http://www.w3.org/2000/svg">
&lt;defs>
&lt;radialGradient id="GradientPad"
cx="0.5" cy="0.5" r="0.4" fx="0.75" fy="0.75"
spreadMethod="pad">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;radialGradient id="GradientRepeat"
cx="0.5" cy="0.5" r="0.4" fx="0.75" fy="0.75"
spreadMethod="repeat">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;radialGradient id="GradientReflect"
cx="0.5" cy="0.5" r="0.4" fx="0.75" fy="0.75"
spreadMethod="reflect">
&lt;stop offset="0%" stop-color="red"/>
&lt;stop offset="100%" stop-color="blue"/>
&lt;/radialGradient>
&lt;/defs>

&lt;rect x="10" y="10" rx="15" ry="15" width="100" height="100" fill="url(#GradientPad)"/>
&lt;rect x="10" y="120" rx="15" ry="15" width="100" height="100" fill="url(#GradientRepeat)"/>
&lt;rect x="120" y="120" rx="15" ry="15" width="100" height="100" fill="url(#GradientReflect)"/>

&lt;text x="15" y="30" fill="white" font-family="sans-serif" font-size="12pt">Pad&lt;/text>
&lt;text x="15" y="140" fill="white" font-family="sans-serif" font-size="12pt">Repeat&lt;/text>
&lt;text x="125" y="140" fill="white" font-family="sans-serif" font-size="12pt">Reflect&lt;/text>

&lt;/svg>
</code>

<iframe class="sample-code-frame" title="spreadMethod sample" width="220" height="260" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Gradients/_sample_.spreadMethod.html" class="lazy"></iframe>
Both gradients also have an attribute named <code>gradientUnits</code>, which describes the unit system you're going to use when you describe the size or orientation of the gradient. 
There are two possible values to use here: <code>userSpaceOnUse</code> or <code>objectBoundingBox</code>. 
<code>objectBoundingBox</code> is the default, so that's what has been shown so far. 
It essentially scales the gradient to the size of your object, so you only have to specify coordinates in values from zero to one, and they're scaled to the size of your object automatically for you. 
<code>userSpaceOnUse</code> essentially takes in absolute units. 
So you have to know where your object is, and place the gradient at the same place. 
The radialGradient above would be rewritten:

&lt;radialGradient cx="60" cy="60" r="50" fx="35" fy="35" gradientUnits="userSpaceOnUse">
You can also then apply another transformation to the gradient by using the <code>gradientTransform</code> attribute, but since we haven't introduced transforms yet, I'll leave that for later.

There are some other caveats for dealing with <code>gradientUnits="objectBoundingBox"</code> when the object bounding box isn't square, but they're fairly complex and will have to wait for someone more in-the-know to explain them.
<h2><br><span class="orange">Patterns</span></h2>
<h2>Patterns</h2>
Patterns are arguably one of the more confusing fill types to use in SVG. 
They're also very powerful, so they're worth talking about and getting at least a fundamental grasp on. 
Like gradients, the <code>&lt;pattern></code> element should be put in the <code>&lt;defs></code> section of your SVG file.

<code>&lt;svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
&lt;defs>
&lt;linearGradient id="Gradient1">
&lt;stop offset="5%" stop-color="white"/>
&lt;stop offset="95%" stop-color="blue"/>
&lt;/linearGradient>
&lt;linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1">
&lt;stop offset="5%" stop-color="red"/>
&lt;stop offset="95%" stop-color="orange"/>
&lt;/linearGradient>

&lt;pattern id="Pattern" x="0" y="0" width=".25" height=".25">
&lt;rect x="0" y="0" width="50" height="50" fill="skyblue"/>
&lt;rect x="0" y="0" width="25" height="25" fill="url(#Gradient2)"/>
&lt;circle cx="25" cy="25" r="20" fill="url(#Gradient1)" fill-opacity="0.5"/>
&lt;/pattern>
&lt;/defs>

&lt;rect fill="url(#Pattern)" stroke="black" width="200" height="200"/>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Patterns sample" width="220" height="240" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Patterns/_sample_.Patterns.html" class="lazy"></iframe>
Inside the <code>&lt;pattern></code> element, you can include any of the other basic shapes you've included before, and each of them can be styled using any of the styles you've learned before, including gradients and opacity. 
Here, we've just drawn two rectangle elements inside the pattern (which overlap, and one of which is twice the size of the other and is used to fill in the entire pattern), and one circle.

The confusing thing about patterns is defining a unit system and their size. 
In the example above, we've defined a <code>width</code> and <code>height</code> attribute on the pattern element to describe how far the pattern should go before it begins repeating itself again. 
There are also <code>x</code> and <code>y</code> attributes available if you want to offset the start point of this rectangle somewhere within your drawing. 
The reason they've been used here is described below.

As with the <code>gradientUnits</code> attribute used above, patterns also have an attribute, <code>patternUnits</code>, which specifies the units that these attributes will take. 
It defaults to <code>"objectBoundingBox"</code> as it did above, so a value of <code>1</code> is scaled to the <code>width</code>/<code>height</code> of the object you're applying the pattern to. 
Since, in this case, we wanted the pattern to repeat 4 times horizontally and vertically, the <code>height</code> and <code>width</code> are set to <code>0.25</code>. 
This means the pattern's <code>width</code>/<code>height</code> is only <code>0.25</code> of the total box size.

Unlike gradients, patterns have a second attribute, <code>patternContentUnits</code>, which describes the units system used inside the pattern element, on the basic shapes themselves. 
This attribute defaults to <code>"userSpaceOnUse"</code>, the opposite of the <code>patternUnits</code> attribute. 
What this means is that unless you specify one or both of these attributes (<code>patternContentUnits</code> and <code>patternUnits</code>), the shapes you draw inside your pattern are being drawn in a different coordinate system than the pattern element is using, which can make things a bit confusing when you're writing this by hand.

To make this work in the example above, we had to consider the size of our box (200 pixels) and the fact that we wanted the pattern to repeat itself 4 times horizontally and vertically. 
This means that each pattern unit was a 50×50 square. 
The two rects and the circle inside the pattern were then sized to fit in a 50×50 box. 
Anything we had drawn outside that box wouldn't have been shown. 
The pattern also had to be offset by 10 pixels so that it would start in the upper-left corner of our box, so the <code>x</code> and <code>y</code> attributes of the <code>pattern</code> had to be adjusted to 10÷200 = 0.05.

The caveat here is that if the object changes size, the pattern itself will scale to fit it, but the objects inside will not. 
So while we would still have 4 repeating units inside the pattern, the objects composing that pattern would remain the same size, and you end up with large areas of nothing in between them. 
By changing the <code>patternContentUnits</code> attribute, we can put all the elements into the same unit system:

<code> &lt;pattern id="Pattern" width=".25" height=".25" patternContentUnits="objectBoundingBox">
&lt;rect x="0" y="0" width=".25" height=".25" fill="skyblue"/>
&lt;rect x="0" y="0" width=".125" height=".125" fill="url(#Gradient2)"/>
&lt;circle cx=".125" cy=".125" r=".1" fill="url(#Gradient1)" fill-opacity="0.5"/>
&lt;/pattern>
</code>

Now, because the pattern content is in the same unit system as the pattern, we don't have to offset the box so that the pattern starts in the correct place, and if the object size was changed to a larger one, the pattern would automatically scale so that it had the same number of objects and repeats inside it. 
This contrasts with the <code>"userSpaceOnUse"</code> system, where if the object changes the size, the pattern would stay the same and just repeat itself more times to fill the box.

As a slight aside, in Gecko circles seem to have trouble drawing if their radius is set to something less than <code>0.075</code> (it is currently unknown whether this is a bug in the pattern element or not). 
To work around that it is probably best to avoid drawing in <code>"objectBoundingBox"</code> units unless you have to.

Neither of these uses is what one would normally think of when you think of a pattern. 
Patterns usually have a set size and repeat themselves independently of what an object's shape is. 
To create something like this, both the pattern and its contents must be drawn in the current userSpace, so they don't change shape if the object does:

<code> &lt;pattern id="Pattern" x="10" y="10" width="50" height="50" patternUnits="userSpaceOnUse">
&lt;rect x="0" y="0" width="50" height="50" fill="skyblue"/>
&lt;rect x="0" y="0" width="25" height="25" fill="url(#Gradient2)"/>
&lt;circle cx="25" cy="25" r="20" fill="url(#Gradient1)" fill-opacity="0.5"/>
&lt;/pattern>
</code>

Of course, this means the pattern won't scale if you change your object size later. 
All three of the preceding examples are shown below on a rectangle that has been slightly elongated to a <code>height</code> of <code>300px</code>, but I should note that it's not an exhaustive picture, and there are other options available depending on your application.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Patterns/svg_pattern_comparison_of_units.png" alt="" width="640" height="320" class="lazy">
<h2><br><span class="orange">Texts</span></h2>
When talking about text in SVG we have to differentiate two almost completely separate topics. 
The one is the inclusion and display of text in an image, and the other are SVG fonts. 
The latter may be described in a later section of the tutorial, while we will focus completely on the first part: Bringing text into an SVG image.
<h2>Basics</h2>
We have seen in the introducing example, that the <code>text</code> element can be used to put arbitrary text in SVG documents:

<code>&lt;text x="10" y="10">Hello World!&lt;/text>
</code>

The <code>x</code> and <code>y</code> attributes determine, where in the viewport the text will appear. 
The attribute <code>text-anchor</code>, which can have the values "start", "middle", "end" or "inherit", decides in which direction the text flows from this point. 
The attribute <code>dominant-baseline</code> decides the vertical alignment.

Like with the shape elements text can be colorized with the <code>fill</code> attribute and given a stroke with the <code>stroke</code> attribute. 
Both may also refer to gradients or patterns, which makes simple coloring text in SVG very powerful compared to CSS 2.1.
<h2>Setting font properties</h2>
An essential part of a text is the font in which it is displayed. 
SVG offers a set of attributes, many similar to their CSS counterparts, to enable font selection. 
Each of the following properties can be set as an attribute or via a CSS declaration: <code>font-family</code>, <code>font-style</code>, <code>font-weight</code>, <code>font-variant</code>, <code>font-stretch</code>, <code>font-size</code>, <code>font-size-adjust</code>, <code>kerning</code>, <code>letter-spacing</code>, <code>word-spacing</code> and <code>text-decoration</code>.

<h2>Other text-related elements</h2>
<h3>&emsp;tspan</h3>
This element is used to mark up sub-portions of a larger text. 
It must be a child of a <code>text</code> element or another <code>tspan</code> element. 
A typical use case is to paint one word of a sentence bold red.

<code>&lt;svg width="350" height="60" xmlns="http://www.w3.org/2000/svg">
&lt;text>
This is &lt;tspan font-weight="bold" fill="red">bold and red&lt;/tspan>
&lt;/text>

&lt;style>&lt;![CDATA[
text{
dominant-baseline: hanging;
font: 28px Verdana, Helvetica, Arial, sans-serif;
}
]]>&lt;/style>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="tspan sample" width="100%" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Texts/_sample_.tspan.html" class="lazy"></iframe>
The <code>tspan</code> element has the following custom attributes:
<strong><code>x</code></strong>

Set a new absolute <code>x</code> coordinate for the containing text. 
This overwrites the default current text position. 
The attribute may also contain a list of numbers, that are one by one applied to the single characters of the <code>tspan</code> element.
<strong><code>dx</code></strong>

Start drawing the text with a horizontal offset <code>dx</code> from the default current position. 
Here, too, you may provide a list of values that are applied to consecutive characters, hence piling up the offset over time.

Likewise, there are <strong><code>y</code></strong> and <strong><code>dy</code></strong> for vertical displacement.
<strong><code>rotate</code></strong>

Rotate all characters by this degree. 
A list of numbers makes each character rotate to its respective value, with remaining characters rotating according to the last value.
<strong><code>textLength</code></strong>

This is a more obscure attribute giving the calculated length of the string. 
It is meant to allow the rendering engine to fine-tune the positions of the glyphs when its own measured text length doesn't meet the one provided here.
<h3>&emsp;textPath</h3>
This element fetches via its <code>xlink:href</code> attribute an arbitrary path and aligns the characters, that it encircles, along this path:

<code>&lt;svg width="200" height="100" xmlns="http://www.w3.org/2000/svg">
&lt;path id="my_path" d="M 20,20 C 80,60 100,40 120,20" fill="transparent" />
&lt;text>
&lt;textPath xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#my_path">
A curve.
&lt;/textPath>
&lt;/text>

&lt;style>&lt;![CDATA[
text{
dominant-baseline: hanging;
font: 28px Verdana, Helvetica, Arial, sans-serif;
}
]]>&lt;/style>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="textPath sample" width="100%" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Texts/_sample_.textPath.html" class="lazy"></iframe>
<h2><br><span class="orange">Basic Transformations</span></h2>
Now we're ready to start distorting our beautiful images. 
But first, let's formally introduce the <code>&lt;g></code> element. 
With this helper, you can assign properties to a complete set of elements. 
Actually, that's its only purpose.
<h2>Example</h2>
<code>&lt;svg width="30" height="10">
&lt;g fill="red">
&lt;rect x="0" y="0" width="10" height="10" />
&lt;rect x="20" y="0" width="10" height="10" />
&lt;/g>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Example sample" width="30" height="60" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Basic_Transformations/_sample_.Example.html" class="lazy"></iframe>
All following transformations are summed up in an element's <code>transform</code> attribute. 
Transformations can be chained by concatenating them, separated by whitespace.
<h2>Translation</h2>
It may be necessary to move an element around, even though you can position it with the according attributes. 
For this purpose, the <code>translate()</code> transformation stands ready.

<code>&lt;svg width="40" height="50" style="background-color:#bff;">
&lt;rect x="0" y="0" width="10" height="10" transform="translate(30,40)" />
&lt;/svg>
</code>

The example will render a rectangle, translated to the point (30,40) instead of (0,0).

<iframe class="sample-code-frame" title="Translation sample" width="40" height="60" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Basic_Transformations/_sample_.Translation.html" class="lazy"></iframe>
If the second value is not given, it is assumed to be <em>0</em>.
<h2>Rotation</h2>
Rotating an element is quite a common task. 
Use the <code>rotate()</code> transformation for this:

<code>&lt;svg width="31" height="31">
&lt;rect x="12" y="-10" width="20" height="20" transform="rotate(45)" />
&lt;/svg>
</code>

This example shows a square that is rotated by 45 degrees. 
The value for <code>rotate()</code> is given in degrees.

<iframe class="sample-code-frame" title="Rotation sample" width="31" height="60" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Basic_Transformations/_sample_.Rotation.html" class="lazy"></iframe>

<h2>Multiple transformations</h2>
Transformations can be concatenated easily just by separating them with spaces. 
For example, <code>translate()</code> and <code>rotate()</code> are common used transformations.

<code>&lt;svg width="40" height="50" style="background-color:#bff;">
&lt;rect x="0" y="0" width="10" height="10" transform="translate(30,40) rotate(45)" />
&lt;/svg>
</code>

This example shows again the small square shown above that this time is also rotated by 45 degrees.
<h2>Skewing</h2>
To make a rhombus out of our rectangle, the <code>skewX()</code> and <code>skewY()</code> transformations are available. 
Each one takes an angle that determines how far the element will be skewed.

<h2>Scaling</h2>
<code>scale()</code> changes the size of an element. 
It takes two numbers, the first being the <em>x</em> scale factor and the second being the <em>y</em> scale factor. 
The factors are taken as the ratio of the transformed dimension to the original. 
For example, <em>0.5 shrinks by 50%. 
If the second number is omitted, it is assumed to be equal to the first.</em>

<h2>Complex transformations with <code>matrix()</code></h2>
All the above transformations can be expressed by a 2x3 transformation matrix. 
To combine several transformations, one can set the resulting matrix directly with the <code>matrix(a, b, c, d, e, f)</code> transformation which maps coordinates from a previous coordinate system into a new coordinate system by
<math display="block"><semantics><mrow><mo>{</mo><mtable rowspacing="0.5ex"><mtr><mtd><msub><mi>x</mi><mstyle mathvariant="normal"><mrow><mi>newCoordSys</mi></mrow></mstyle></msub><mo>=</mo><mi>a</mi><msub><mi>x</mi><mstyle mathvariant="normal"><mrow><mi>prevCoordSys</mi></mrow></mstyle></msub><mo>+</mo><mi>c</mi><msub><mi>y</mi><mstyle mathvariant="normal"><mrow><mi>prevCoordSys</mi></mrow></mstyle></msub><mo>+</mo><mi>e</mi></mtd></mtr><mtr><mtd><msub><mi>y</mi><mstyle mathvariant="normal"><mrow><mi>newCoordSys</mi></mrow></mstyle></msub><mo>=</mo><mi>b</mi><msub><mi>x</mi><mstyle mathvariant="normal"><mrow><mi>prevCoordSys</mi></mrow></mstyle></msub><mo>+</mo><mi>d</mi><msub><mi>y</mi><mstyle mathvariant="normal"><mrow><mi>prevCoordSys</mi></mrow></mstyle></msub><mo>+</mo><mi>f</mi></mtd></mtr></mtable></mrow><annotation encoding="TeX">\left{ \begin{matrix} x_{\mathrm{prevCoordSys}} = a x_{\mathrm{newCoordSys}} + c y_{\mathrm{newCoordSys}} + e \ y_{\mathrm{prevCoordSys}} = b x_{\mathrm{newCoordSys}} + d y_{\mathrm{newCoordSys}} + f \end{matrix} \right.</annotation></semantics></math>

See a concrete example on the SVG transform documentation. 
Detailed information about this property can be found in the <a href="https://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined">SVG Recommendation</a>.
<h2>Effects on Coordinate Systems</h2>
When using transformations you establish a new coordinate system inside the element the transformations apply to. 
That means, the units you specify for the element and its children might not follow the 1:1 pixel mapping, but are also distorted, skewed, translated and scaled according to the transformation.

<code>&lt;svg width="100" height="100">
&lt;g transform="scale(2)">
&lt;rect width="50" height="50" />
&lt;/g>
&lt;/svg>
</code>

The resulting rectangular in the above example will be 100x100px. 
The more intriguing effects arise, when you rely on attributes like <code>userSpaceOnUse</code> and the such.

<iframe class="sample-code-frame" title="Effects on Coordinate Systems sample" width="100" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Basic_Transformations/_sample_.Effects_on_Coordinate_Systems.html" class="lazy"></iframe>

<h2>Embedding SVG in SVG</h2>
In contrast to HTML, SVG allows you to embed other <code>svg</code> elements seamlessly. 
This way you can also create new coordinate systems by utilizing the <code>viewBox</code>, <code>width</code> and <code>height</code> of the inner <code>svg</code> element.

<code>&lt;svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100" height="100">
&lt;svg width="100" height="100" viewBox="0 0 50 50">
&lt;rect width="50" height="50" />
&lt;/svg>
&lt;/svg>
</code>

The example above has basically the same effect as the one above, namely that the rect will be twice as large as specified.

<iframe class="sample-code-frame" title="Embedding SVG in SVG sample" width="100" height="100" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Basic_Transformations/_sample_.Embedding_SVG_in_SVG.html" class="lazy"></iframe>
<h2><br><span class="orange">Clipping and masking</span></h2>
Erasing part of what one has created might at first sight look contradictory. 
But when you try to create a semicircle in SVG, you will find out the use of the following properties quickly.

<strong>Clipping</strong> refers to removing parts of elements defined by other parts. 
In this case, any half-transparent effects are not possible, it's an all-or-nothing approach.

<strong>Masking</strong> on the other hand allows soft edges by taking transparency and grey values of the mask into account.
<h3>&emsp;Creating clips</h3>
We create the above mentioned semicircle based on a <code>circle</code> element:

<code>&lt;svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
&lt;defs>
&lt;clipPath id="cut-off-bottom">
&lt;rect x="0" y="0" width="200" height="100" />
&lt;/clipPath>
&lt;/defs>

&lt;circle cx="100" cy="100" r="100" clip-path="url(#cut-off-bottom)" />
&lt;/svg>
</code>

Centered at (100,100) a circle with radius 100 is painted. 
The attribute <code>clip-path</code> references a <code><code>&lt;clipPath></code></code> element with a single <code>rect</code> element. 
This rectangular on its own would paint the upper half of the canvas black. 
Note, that the <code>clipPath</code> element is usually placed in a <code>defs</code> section.

The <code>rect</code> will not be painted, however. 
Instead its pixel data will be used to determine, which pixels of the circle "make it" to the final rendering. 
Since the rectangle covers only the upper half of the circle, the lower half of the circle will vanish:

<iframe class="sample-code-frame" title="Creating clips sample" width="240" height="240" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Clipping_and_masking/_sample_.Creating_clips.html" class="lazy"></iframe>
We now have a semicircle without having to deal with arcs in path elements. 
For the clipping, every path inside the <code>clipPath</code> is inspected and evaluated together with its stroke properties and transformation. 
Then every part of the target lying in a transparent area of the resulting <code>clipPath</code>'s content will not be rendered. 
Color, opacity and such have no effect as long as they don't let parts vanish completely.
<h3>&emsp;Masking</h3>
The effect of masking is most impressively presented with a gradient. 
If you want an element to fade out, you can achieve this effect quite quickly with masks.

<code>&lt;svg width="200" height="200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
&lt;defs>
&lt;linearGradient id="Gradient">
&lt;stop offset="0" stop-color="black" />
&lt;stop offset="1" stop-color="white" />
&lt;/linearGradient>
&lt;mask id="Mask">
&lt;rect x="0" y="0" width="200" height="200" fill="url(#Gradient)"  />
&lt;/mask>
&lt;/defs>

&lt;rect x="0" y="0" width="200" height="200" fill="green" />
&lt;rect x="0" y="0" width="200" height="200" fill="red" mask="url(#Mask)" />
&lt;/svg>
</code>

You see a green-filled <code>rect</code> at the lowest layer and on top a red-filled <code>rect</code>. 
The latter has the <code>mask</code> attribute pointing to the <code>mask</code> element. 
The content of the mask is a single <code>rect</code> element, that is filled with a black-to-white gradient. 
As a result the pixels of the red rectangle use the luminance value of the mask content as the alpha value (the transparency), and we see a green-to-red gradient as a result:

<iframe class="sample-code-frame" title="Masking sample" width="240" height="240" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Clipping_and_masking/_sample_.Masking.html" class="lazy"></iframe>

<h3>&emsp;Transparency with <code>opacity</code></h3>
There is a simple possibility to set the transparency for a whole element. 
It's the <code>opacity</code> attribute:

<code>&lt;rect x="0" y="0" width="100" height="100" opacity=".5" />
</code>

The above rectangle will be painted half-transparent. 
For the fill and stroke there are two separate attributes, <code>fill-opacity</code> and <code>stroke-opacity</code>, that control each of those property opacities separately. 
Note, that the stroke will be painted on top of the filling. 
Hence, if you set a stroke opacity on an element, that also has a fill, the fill will shine through on half of the stroke, while on the other half the background will appear:

<code>&lt;svg width="200" height="200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
&lt;rect x="0" y="0" width="200" height="200" fill="blue" />
&lt;circle cx="100" cy="100" r="50" stroke="yellow" stroke-width="40" stroke-opacity=".5" fill="red" />
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Transparency with opacity sample" width="240" height="240" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Clipping_and_masking/_sample_.Transparency_with_opacity.html" class="lazy"></iframe>
You see in this example the red circle on blue background. 
The yellow stroke is set to 50% opacity, which leads effectively to a double-color stroke.
<h2>Using well-known CSS techniques</h2>
One of the most powerful tools in a web developer's toolbox is <code>display: none</code>. 
It is therefore not a surprise that it was decided to take this CSS property into SVG as well, together with <code>visibility</code> and <code>clip</code> as defined by CSS 2. 
For reverting a previously set <code>display: none</code> it is important to know, that the initial value for all SVG elements is <code>inline</code>.
<h2><br><span class="orange">Other content in SVG</span></h2>
Apart from graphic primitives like rectangles and circles, SVG offers a set of elements to embed other types of content in images as well.
<h3>&emsp;Embedding raster images</h3>
Much like the img element in HTML SVG has an <code>image</code> element to serve the same purpose. 
You can use it to embed arbitrary raster (and vector) images. 
The specification requests applications to support at least PNG, JPEG and SVG format files.

The embedded picture becomes a normal SVG element. 
This means, that you can use clips, masks, filters, rotations and all other tools of SVG on the content:

<code>&lt;svg version="1.1"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
width="200" height="200">
&lt;image x="90" y="-65" width="128" height="146" transform="rotate(45)"
xlink:href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/image/mdn_logo_only_color.png"/>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Embedding raster images sample" width="220" height="240" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Other_content_in_SVG/_sample_.Embedding_raster_images.html" class="lazy"></iframe>

<h3>&emsp;Embedding arbitrary XML</h3>
Since SVG is an XML application, you can of course <em>always</em> embed arbitrary XML anywhere in an SVG document. 
But then you have no means to define how the surrounding SVG should react on the content. 
Actually, in a conforming viewer it will react in no way at all, the data will be omitted. 
Therefore the specification adds the <code><code>&lt;foreignObject></code></code> element to SVG. 
Its sole purpose is to be a container for other markup and a carrier for SVG styling attributes (most prominently <code>width</code> and <code>height</code> to define the space the object will take).

The <code>foreignObject</code> element is a good way to embed XHTML in SVG. 
If you have longer texts, the HTML layout is more suitable and comfortable than the SVG <code>text</code> element. 
Another often cited use case is the embedding of formulas with MathML. 
For scientific applications of SVG this is a very good way to join both worlds.
<strong>Note:</strong> Please keep in mind, that the content of the <code>foreignObject</code> must be processable by the viewer. 
A standalone SVG viewer is unlikely to be able to render HTML or MathML.
Since the <code>foreignObject</code> is an SVG element, you can, like in the case of <code>image</code>, use any SVG goodness with it, which then will be applied to its content.
<h2><br><span class="orange">Filter effects</span></h2>
There are situations, where basic shapes do not provide the flexibility you need to achieve a certain effect. 
Drop shadows, to provide a popular example, cannot be created reasonably with a combination of gradients. 
Filters are SVG's mechanism to create sophisticated effects.

A basic example is to add a blur effect to SVG content. 
While basic blurs can be achieved with the help of gradients, the blur filter is needed to do anything beyond.
<h2>Example</h2>
Filters are defined by <code>&lt;filter></code> element, which should be put in the <code>&lt;defs></code> section of your SVG file. 
Between the filter tags, goes a list of <em>primitives</em>, basic operations that build on top of the previous operations (like blurring, adding a lighting effect, etc). 
To apply your created filter on a graphic element, you set the <code>filter</code> attribute.

<code>&lt;svg width="250" viewBox="0 0 200 85"
xmlns="http://www.w3.org/2000/svg" version="1.1">
&lt;defs>
&lt;!-- Filter declaration -->
&lt;filter id="MyFilter" filterUnits="userSpaceOnUse"
x="0" y="0"
width="200" height="120">

&lt;!-- offsetBlur -->
&lt;feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>
&lt;feOffset in="blur" dx="4" dy="4" result="offsetBlur"/>

&lt;!-- litPaint -->
&lt;feSpecularLighting in="blur" surfaceScale="5" specularConstant=".75"
specularExponent="20" lighting-color="#bbbbbb"
result="specOut">
&lt;fePointLight x="-5000" y="-10000" z="20000"/>
&lt;/feSpecularLighting>
&lt;feComposite in="specOut" in2="SourceAlpha" operator="in" result="specOut"/>
&lt;feComposite in="SourceGraphic" in2="specOut" operator="arithmetic"
k1="0" k2="1" k3="1" k4="0" result="litPaint"/>

&lt;!-- merge offsetBlur + litPaint -->
&lt;feMerge>
&lt;feMergeNode in="offsetBlur"/>
&lt;feMergeNode in="litPaint"/>
&lt;/feMerge>
&lt;/filter>
&lt;/defs>

&lt;!-- Graphic elements -->
&lt;g filter="url(#MyFilter)">
&lt;path fill="none" stroke="#D90000" stroke-width="10"
d="M50,66 c-50,0 -50,-60 0,-60 h100 c50,0 50,60 0,60z" />
&lt;path fill="#D90000"
d="M60,56 c-30,0 -30,-40 0,-40 h80 c30,0 30,40 0,40z" />
&lt;g fill="#FFFFFF" stroke="black" font-size="45" font-family="Verdana" >
&lt;text x="52" y="52">SVG&lt;/text>
&lt;/g>
&lt;/g>
&lt;/svg>
</code>

<iframe class="sample-code-frame" title="Example sample" width="100%" height="120" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/Filter_effects/_sample_.Example.html" class="lazy"></iframe>

<h3>&emsp;Step 1</h3>
<code>&lt;feGaussianBlur in="SourceAlpha"
stdDeviation="4"
result="blur"/>
</code>

<code>&lt;feGaussianBlur></code> takes <code>in</code> "SourceAlpha", which is the alpha channel of the source graphic, applies a blur of 4, and stores the <code>result</code> in a temporary buffer named "blur".
<h3>&emsp;Step 2</h3>
<code>&lt;feOffset in="blur"
dx="4" dy="4"
result="offsetBlur"/>
</code>

<code>&lt;feOffset></code> takes <code>in</code> "blur", which we previously created, shifts the result 4 to the right and 4 to the bottom, and stores the <code>result</code> in the buffer "offsetBlur". 
The two first primitives just created a drop shadow.
<h3>&emsp;Step 3</h3>
<code>&lt;feSpecularLighting in="offsetBlur"
surfaceScale="5" specularConstant=".75"
specularExponent="20" lighting-color="#bbbbbb"
result="specOut">
&lt;fePointLight x="-5000" y="-10000" z="20000"/>
&lt;/feSpecularLighting>
</code>

<code>&lt;feSpecularLighting></code> takes <code>in</code> "offsetBlur", generates a lighting effect, and stores the <code>result</code> in the buffer "specOut".
<h3>&emsp;Step 4</h3>
<code>&lt;feComposite in="specOut" in2="SourceAlpha"
operator="in"
result="specOut"/>
</code>

The first <code>&lt;feComposite></code> takes <code>in</code> "specOut" and "SourceAlpha", masks out the result of "specOut" so that the result is not bigger than "SourceAlpha" (the original source graphic), and overrides the <code>result</code> "specOut".
<h3>&emsp;Step 5</h3>
<code>&lt;feComposite in="SourceGraphic" in2="specOut"
operator="arithmetic"
k1="0" k2="1" k3="1" k4="0"
result="litPaint"/>
</code>

The second <code>&lt;feComposite></code> takes <code>in</code> "SourceGraphic" and "specOut", adds the result of "specOut" on top of "SourceGraphic", and stores the <code>result</code> in "litPaint".
<h3>&emsp;Step 6</h3>
<code>&lt;feMerge>
&lt;feMergeNode in="offsetBlur"/>
&lt;feMergeNode in="litPaint"/>
&lt;/feMerge>
</code>

Finally, <code>&lt;feMerge></code> merges together "offsetBlur", which is the drop shadow, and "litPaint", which is the original source graphic with a lighting effect.
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-0.png" alt="Source graphic" width="115" height="70" class="lazy">

Source graphic
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-1.png" alt="Primitive 1" width="115" height="70" class="lazy">

Primitive 1
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-2.png" alt="Primitive 2" width="115" height="70" class="lazy">

Primitive 2
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-3.png" alt="Primitive 3" width="115" height="70" class="lazy">

Primitive 3
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-4.png" alt="Primitive 4" width="115" height="70" class="lazy">

Primitive 4
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-5.png" alt="Primitive 5" width="115" height="70" class="lazy">

Primitive 5
<img src="https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Filter_effects/filters01-6.png" alt="Primitive 6" width="115" height="70" class="lazy">

Primitive 6
<h2><br><span class="orange">SVG fonts</span></h2>
When SVG was specified, support for web fonts was not widespread in browsers. 
Since accessing the correct font file is however crucial for rendering text correctly, a font description technology was added to SVG to provide this ability. 
It was not meant for compatibility with other formats like PostScript or OTF, but rather as a simple means of embedding glyph information into SVG when rendered.
<strong>Note:</strong> SVG Fonts are currently supported only in Safari and Android Browser.

Internet Explorer <a href="https://blogs.msdn.com/b/ie/archive/2010/08/04/html5-modernized-fourth-ie9-platform-preview-available-for-developers.aspx">hasn't considered implementing this</a>, the functionality has been <a href="https://www.chromestatus.com/feature/5930075908210688">removed from Chrome 38</a> (and Opera 25) and Firefox has <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=119490">postponed its implementation indefinitely</a> to concentrate on WOFF. 
Other tools however like the <a href="https://www.adobe.com/svg/viewer/install/">Adobe SVG Viewer</a> plugin, Batik and parts of Inkscape support SVG font embedding.
The base for defining an SVG font is the <code>&lt;font></code> element.
<h2>Defining a font</h2>
There are some ingredients required for embedding a font in SVG. 
Let's show an example declaration (the one <a href="https://www.w3.org/TR/SVG/fonts.html#FontElement">from the specification</a>), and explain the details.

&lt;font horiz-adv-x="1000">
&lt;font-face font-family="Super Sans" font-weight="bold" font-style="normal"
units-per-em="1000" cap-height="600" x-height="400"
ascent="700" descent="300"
alphabetic="0" mathematical="350" ideographic="400" hanging="500">
&lt;font-face-src>
&lt;font-face-name name="Super Sans Bold"/>
&lt;/font-face-src>
&lt;/font-face>
&lt;missing-glyph>&lt;path d="M0,0h200v200h-200z"/>&lt;/missing-glyph>
&lt;glyph unicode="!" horiz-adv-x="300">&lt;!-- Outline of exclam. 
pt. 
glyph -->&lt;/glyph>
&lt;glyph unicode="@">&lt;!-- Outline of @ glyph -->&lt;/glyph>
&lt;!-- more glyphs -->
&lt;/font>
We start with the <code>&lt;font></code> element. 
This bears an id attribute, to enable it to be referenced via a URI (see below). 
The <code>horiz-adv-x</code> attribute determines how wide a character is on average compared to the path definitions of the single glyphs. 
The value <code>1000</code> sets a reasonable value to work with. 
There are several accompanying attributes that help further define the basic glyph-box layout.

The <code>&lt;font-face></code> element is the SVG equivalent of the CSS <code>@font-face</code> declaration. 
It defines basic properties of the final font such as weight, style, etc. 
In the example above the first and most important to be defined is <code>font-family</code>, the value of which can then be referenced in CSS and SVG <code>font-family</code> properties. 
The <code>font-weight</code> and <code>font-style</code> attributes have the same purpose as the equivalent descriptors in CSS. 
All following attributes are rendering instructions for the font layout engine, for example, how much of the glyphs' overall heights are <a href="https://en.wikipedia.org/wiki/Ascender_%28typography%29">ascenders</a>.

Its child, the <code>&lt;font-face-src></code> element, corresponds to CSS' <code>src</code> descriptor in <code>@font-face</code> declarations. 
You can point to external sources for font declarations by means of its children <code>&lt;font-face-name></code> and <code>&lt;font-face-uri></code>. 
The above example states that if the renderer has a local font available named "Super Sans Bold", it should use this instead.

Following <code>&lt;font-face-src></code> is a <code>&lt;missing-glyph></code> element. 
This defines what should be displayed if a certain glyph is not found in the font and if there are no fallback mechanisms. 
It also shows how glyphs are created: By adding any graphical SVG content inside. 
You can use literally any other SVG elements in here, even <code>&lt;filter></code>, <code>&lt;a></code> or <code>&lt;script></code>. 
For simple glyphs, however, you can add a <code>d</code> attribute — this defines a shape for the glyph exactly like how standard SVG paths work.

The actual glyphs are then defined by <code>&lt;glyph></code> elements. 
The most important attribute is <code>unicode</code>. 
It defines the unicode codepoint represented by this glyph. 
If you also specify the <code>lang</code> attribute on a glyph, you can further restrict it to certain languages (represented by <code>xml:lang</code> on the target) exclusively. 
Again, you can use arbitrary SVG to define the glyph, which allows for great effects in supporting user agents.

There are two further elements that can be defined inside <code>font</code>: <code>&lt;hkern></code> and <code>&lt;vkern></code>. 
Each carries references to at least two characters (attributes <code>u1</code> and <code>u2</code>) and an attribute <code>k</code> that determines how much the distance between those characters should be decreased. 
The below example instructs user agents to place the "A" and "V" characters closer together the standard distance between characters.

&lt;hkern u1="A" u2="V" k="20" />
<h2>Referencing a font</h2>
When you have put together your font declaration as described above, you can just use a simple <code>font-family</code> attribute to actually apply the font to some SVG text:

&lt;font>
&lt;font-face font-family="Super Sans" />
&lt;!-- and so on -->
&lt;/font>

&lt;text font-family="Super Sans">My text uses Super Sans&lt;/text>
However, you are free to combine several methods for great freedom of how and where to define the font.
<h3>&emsp;Option: Use CSS @font-face</h3>
You can use <code>@font-face</code> to reference remote (and not so remote) fonts:

&lt;font>
&lt;!-- and so on -->
&lt;/font>

&lt;style type="text/css">
@font-face {
font-family: "Super Sans";
src: url(#Super_Sans);
}
&lt;/style>

&lt;text font-family="Super Sans">My text uses Super Sans&lt;/text>
<h3>&emsp;Option: reference a remote font</h3>
The above mentioned <code>font-face-uri</code> element allows you to reference an external font, hence allowing greater re-usability:

&lt;font>
&lt;font-face font-family="Super Sans">
&lt;font-face-src>
&lt;font-face-uri xlink:href="fonts.svg#Super_Sans" />
&lt;/font-face-src>
&lt;/font-face>
&lt;/font>
<h2><br><span class="orange">SVG image element</span></h2>
The SVG <code>&lt;image></code> element allows for raster images to be rendered within an SVG object.

In this basic example, a .jpg image referenced by an <code>href</code> attribute will be rendered inside an SVG object:

<code>&lt;?xml version="1.0" standalone="no"?>
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
&lt;svg width="5cm" height="4cm" version="1.1"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
	&lt;image href="firefox.jpg" x="0" y="0" height="50px" width="50px"/>
&lt;/svg>
</code>

There are some important things to take note of (referenced from the <a href="https://www.w3.org/TR/SVG/struct.html#ImageElement">W3 specs</a>):

If you do not set the <code>x</code> or <code>y</code> attributes, they will be set to <code>0</code>.

If you do not set the <code>height</code> or <code>width</code> attributes, they will be set to <code>0</code>.

Having a <code>height</code> or <code>width</code> attribute of <code>0</code> will disable rendering of the image.
<h2><br><span class="orange">Tools for SVG</span></h2>
Now that we covered the basics of the SVG internals, we will take a look at some tools to work with SVG files.
<h3>&emsp;Browser support</h3>
As of Internet Explorer 9, all major browsers support SVG: IE 9, Mozilla Firefox, Safari, Google Chrome and Opera. 
Mobile devices with Webkit-based browsers also support SVG. 
On older or smaller devices, chances are that SVG Tiny is supported.

<h2>Inkscape</h2>
URL: <a href="https://www.inkscape.org">www.inkscape.org</a>

One of the most important tools for a graphics format is a decent drawing program. 
Inkscape offers state-of-the-art vector drawing, and it's open source.

Moreover, it uses SVG as its native file format. 
To store Inkscape specific data, it extends the SVG file with elements and attributes in a custom namespace, but you can also choose to export as plain SVG.
<h2>Adobe Illustrator</h2>
URL: <a href="https://www.adobe.com/products/illustrator/">www.adobe.com/products/illustrator/</a>

Before Adobe acquired Macromedia, it was the most prominent promoter of SVG. 
From this time stems the good support of SVG in Illustrator. 
However, the resulting SVG often shows some quirks, that make it necessary to post-process it for general applicability.
<h2>Apache Batik</h2>
URL: <a href="https://xmlgraphics.apache.org/batik/">xmlgraphics.apache.org/batik/</a>

Batik is a set of open source tools under the roof of the Apache Software Foundation. 
The toolkit is written in Java and offers almost complete SVG 1.1 support, as well as some features that were originally planned for SVG 1.2.

Batik offers a viewer (Squiggle), a rasterizer for PNG output, an SVG pretty printer to format SVG files, and a TrueType-to-SVG-Font converter.

Together with <a href="https://xmlgraphics.apache.org/fop/">Apache FOP</a> Batik can transform SVG to PDF.
<h3>&emsp;Other renderers</h3>
Several projects exist that can create a raster image from an SVG source. 
<a href="http://ImageMagick.org">ImageMagick</a> is one of the most famous command-line image processing tools. 
The Gnome library <a href="https://library.gnome.org/devel/rsvg/">rsvg</a> is used by the Wikipedia to raster their SVG graphics. 
Usage of headless browsers such as SlimerJS and PhantomJS are also popular for this purpose, as the image produced is closer to what the SVG will look like in the browser.

<h2>Raphael JS</h2>
URL: <a href="https://raphaeljs.com/">raphaeljs.com</a>

This is a JavaScript library, that acts as an abstraction layer between browser implementations. 
Notably older versions of Internet Explorer are supported by generating VML, a vector markup language, that is one of two ancestors of SVG and exists since IE 5.5.
<h2>Snap.svg</h2>
URL: <a href="http://snapsvg.io/">snapsvg.io</a>

A newer JavaScript abstraction layer from the same author of Raphael JS. 
Snap.svg is designed for modern browsers and therefore supports the newest SVG features like masking, clipping, patterns, full gradients, groups. 
It does not support the older browsers that Raphael does.
<h2>Google Docs</h2>
URL: <a href="https://www.google.com/google-d-s/drawings/">www.google.com/google-d-s/drawings/</a>

Drawings from Google Docs can be exported as SVG.
<h2>Science</h2>
The well-known plotting tools xfig and gnuplot both support exporting as SVG. 
To render graphs on the web <a href="https://jsxgraph.uni-bayreuth.de/wp/">JSXGraph</a> supports VML, SVG and canvas, automatically deciding which technology to use based on browser capabilities.

In GIS (Geographic Information System) applications SVG is often used as both storage and rendering format. 
See <a href="https://carto.net">carto.net</a> for details.
<h2>More tools!</h2>
The W3C offers a <a href="https://www.w3.org/Graphics/SVG/WG/wiki/Implementations">list of programs</a> that support SVG.
<h2><br><span class="orange">SVG and CSS</span></h2>
This page illustrates the application of CSS to the specialized language for creating graphics: SVG.

Below you'll create a simple demonstration that runs in your SVG-enabled browser.
<strong>Note:</strong> Elements referenced by <code>&lt;use></code> elements inherit the styles from that element. 
So to apply different styles to them you should use CSS custom properties.
<h2>Example</h2>
Make a new SVG document as a plain text file, <code>doc8.svg</code>. 
Copy and paste the content from here, making sure that you scroll to get all of it:

<code>&lt;svg width="600px" height="600px" viewBox="-300 -300 600 600"
xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">

&lt;title>SVG demonstration&lt;/title>
&lt;desc>Mozilla CSS Getting Started - SVG demonstration&lt;/desc>

&lt;defs>
&lt;radialGradient id="fade" cx="0" cy="0" r="200"
gradientUnits="userSpaceOnUse">
&lt;stop id="fade-stop-1" offset="33%"/>
&lt;stop id="fade-stop-2" offset="95%"/>
&lt;/radialGradient>
&lt;/defs>

&lt;text id="heading" x="-280" y="-270">SVG demonstration&lt;/text>
&lt;text  id="caption" x="-280" y="-250">Move your mouse pointer over the flower.&lt;/text>

&lt;g id="flower">
&lt;circle id="overlay" cx="0" cy="0" r="200" stroke="none" fill="url(#fade)"/>

&lt;g id="outer-petals">
&lt;g class="quadrant">
&lt;g class="segment">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(18)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(36)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(54)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(72)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(90)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(108)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(126)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(144)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(162)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(180)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(198)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(216)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(234)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(252)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(270)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(288)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(306)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(324)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(342)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>
&lt;/g>

&lt;g id="inner-petals" transform="rotate(9) scale(0.33)">
&lt;g class="quadrant">
&lt;g class="segment">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(18)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(36)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(54)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(72)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(90)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(108)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(126)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(144)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(162)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(180)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(198)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(216)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(234)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(252)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>

&lt;g class="quadrant">
&lt;g class="segment" transform="rotate(270)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(288)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(306)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(324)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g class="segment" transform="rotate(342)">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;/g>
&lt;/g>
&lt;/g>
&lt;/svg>
</code>

Make a new CSS file, <code>style8.css</code>. 
Copy and paste the content from here, making sure that you scroll to get all of it:

<code>/*** SVG demonstration ***/

/* page */
svg {
background-color: beige;
}

#heading {
font-size: 24px;
font-weight: bold;
}

#caption {
font-size: 12px;
}

/* flower */
#flower:hover {
cursor: crosshair;
}

/* gradient */
#fade-stop-1 {
stop-color: blue;
}

#fade-stop-2 {
stop-color: white;
}

/* petals */
.segment-fill {
fill: var(--segment-fill-fill);
stroke: var(--segment-fill-stroke);
stroke-width: var(--segment-fill-stroke-width);
}

.segment-fill:hover {
fill: var(--segment-fill-fill-hover);
stroke: var(--segment-fill-stroke-hover);
}

.segment-edge {
fill: var(--segment-edge-fill);
stroke: var(--segment-edge-stroke);
stroke-width: var(--segment-edge-stroke-width);
}

.segment-edge:hover {
	stroke: var(--segment-edge-stroke-hover);
}

/* outer petals */
#outer-petals {
opacity: .75;
--segment-fill-fill: azure;
--segment-fill-stroke: lightsteelblue;
--segment-fill-stroke-width: 1;
--segment-edge-fill: none;
--segment-edge-stroke: deepskyblue;
--segment-edge-stroke-width: 3;
--segment-fill-fill-hover: plum;
--segment-fill-stroke-hover: none;
--segment-edge-stroke-hover: slateblue;
}

/*
Non-standard way of styling elements referenced via &lt;use> elements,
supported by some older browsers
*/
#outer-petals .segment-fill {
fill: azure;
stroke: lightsteelblue;
stroke-width: 1;
}

#outer-petals .segment-edge {
fill: none;
stroke: deepskyblue;
stroke-width: 3;
}

#outer-petals .segment:hover > .segment-fill {
fill: plum;
stroke: none;
}

#outer-petals .segment:hover > .segment-edge {
stroke: slateblue;
}

/* inner petals */
#inner-petals {
--segment-fill-fill: yellow;
--segment-fill-stroke: yellow;
--segment-fill-stroke-width: 1;
--segment-edge-fill: none;
--segment-edge-stroke: yellowgreen;
--segment-edge-stroke-width: 9;
--segment-fill-fill-hover: darkseagreen;
--segment-fill-stroke-hover: none;
--segment-edge-stroke-hover: green;
}

/*
Non-standard way of styling elements referenced via &lt;use> elements,
supported by some older browsers
*/
#inner-petals .segment-fill {
fill: yellow;
stroke: yellow;
stroke-width: 1;
}

#inner-petals .segment-edge {
fill: none;
stroke: yellowgreen;
stroke-width: 9;
}

#inner-petals .segment:hover > .segment-fill {
fill: darkseagreen;
stroke: none;
}

#inner-petals .segment:hover > .segment-edge {
stroke: green;
}
</code>

Open the document in your SVG-enabled browser. 
Move your mouse pointer over the graphic to see what happens.
<h3>&emsp;Result</h3>
<iframe class="sample-code-frame" title="Example sample" width="660" height="660" src="https://yari-demos.prod.mdn.mozit.cloud/en-US/docs/Web/SVG/Tutorial/SVG_and_CSS/_sample_.Example.html" class="lazy"></iframe>
Notes about this demonstration:

The SVG document links the stylesheet in the usual way.

SVG has its own CSS properties and values. 
Some of them are similar to CSS properties for HTML.
<h3>&emsp;Challenge</h3>
Change the stylesheet so that the inner petals all turn pink when the mouse pointer is over any one of them, without changing the way the outer petals work.

See a solution to this challenge.
<h2>Simplified structure</h2>
The SVG structure shown above could be written much more concise by referencing the individual parts of the flower via <code>&lt;use></code> elements. 
This <a href="https://www.w3.org/TR/SVG2/struct.html#UseStyleInheritance">behavior is standardized</a>, though only a few browsers support the <code>:hover</code> pseudo-class and other more complex CSS selectors on elements referenced via <code>&lt;use></code> elements, at the moment. 
There is <a href="https://github.com/w3c/svgwg/issues/504">some discussion about what rules apply to such referenced elements</a>.

See below how the structure then looks like.

<code>&lt;svg width="600px" height="600px" viewBox="-300 -300 600 600"
xmlns="http://www.w3.org/2000/svg">

&lt;title>SVG demonstration&lt;/title>
&lt;desc>Mozilla CSS Getting Started - SVG demonstration&lt;/desc>

&lt;defs>
&lt;g id="segment" class="segment">
&lt;path class="segment-fill" d="M0,0 v-200 a40,40 0 0,0 -62,10 z"/>
&lt;path class="segment-edge" d="M0,-200 a40,40 0 0,0 -62,10"/>
&lt;/g>
&lt;g id="quadrant">
&lt;use xlink:href="#segment"/>
&lt;use xlink:href="#segment" transform="rotate(18)"/>
&lt;use xlink:href="#segment" transform="rotate(36)"/>
&lt;use xlink:href="#segment" transform="rotate(54)"/>
&lt;use xlink:href="#segment" transform="rotate(72)"/>
&lt;/g>
&lt;g id="petals">
&lt;use xlink:href="#quadrant"/>
&lt;use xlink:href="#quadrant" transform="rotate(90)"/>
&lt;use xlink:href="#quadrant" transform="rotate(180)"/>
&lt;use xlink:href="#quadrant" transform="rotate(270)"/>
&lt;/g>
&lt;radialGradient id="fade" cx="0" cy="0" r="200"
gradientUnits="userSpaceOnUse">
&lt;stop id="fade-stop-1" offset="33%"/>
&lt;stop id="fade-stop-2" offset="95%"/>
&lt;/radialGradient>
&lt;/defs>

&lt;text id="heading" x="-280" y="-270">SVG demonstration&lt;/text>
&lt;text  id="caption" x="-280" y="-250">Move your mouse pointer over the flower.&lt;/text>

&lt;g id="flower">
&lt;circle id="overlay" cx="0" cy="0" r="200" stroke="none" fill="url(#fade)"/>
&lt;use id="outer-petals" xlink:href="#petals"/>
&lt;use id="inner-petals" xlink:href="#petals"
transform="rotate(9) scale(0.33)"/>
&lt;/g>

&lt;/svg>
</code>
<h2>What next?</h2>
In this demonstration, your SVG-enabled browser already knows how to display SVG elements. 
The stylesheet only modifies the display in certain ways. 
This is also true for HTML and XUL documents. 
But you can use CSS for general-purpose XML documents, where there is no predefined way to display the elements. 
The next page demonstrates this: XML data
<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
elements_selector: ".lazy"
// ... more custom settings?
});
</script>
</pre></body></html>
