<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{font-size: x-large;width:80%;margin-left: 10%}
h1, h2 {color: gold;}
</style>
</head><body>
<center><h3>MicroPython Examples</h3>
<div id="toc"></div></center>
<br>
<br>
<br>

<h1>LED</h1>

<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/leds.jpg"></p>
<p>A light-emitting diode (LED) is a semiconductor device that emits visible light when an electric current passes through it. The light is not particularly bright, but in most LEDs it is monochromatic, occurring at a single wavelength. The output from an LED can range from red (at a wavelength of approximately 700 nanometers) to blue-violet (about 400 nanometers). Some LEDs emit infrared (IR) energy (830 nanometers or longer); such a device is known as an infrared-emitting diode (IRED).</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/led/led.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<pre><code>from machine import Pin
from time import sleep

# GPIO16 (D0) is the internal LED for NodeMCU
led = Pin(16, Pin.OUT)

# The internal LED turn on when the pin is LOW
while True:
    led.high()
    sleep(1)
    led.low()
    sleep(1)
</code></pre>
<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/nodemcu_led.gif"></p>
<p><a href="https://github.com/nodemcu/nodemcu-devkit-v1.0/issues/16#issuecomment-244625860">Here</a> is the reason why the built in led turn on when Pin 16 is Low :)</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<pre><code>def led_toggle():
    led.value(not led.value())
</code></pre>
<p>Now we can use this function to blink the LED</p>
<pre><code>while True:
    led_toggle()
    sleep(1)
</code></pre>


<h1>Button</h1>

<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/switches.png"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/button/button.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<pre><code>from machine import Pin
from time import sleep

led = Pin(16, Pin.OUT)
button = Pin(14, Pin.IN, Pin.PULL_UP)

while True:

    # The value function returns the current level of the pin,
    # either 1 for a high logic level or 0 for a low logic level.
    # Notice how the button is at a high level (value returns 1) when
    # it's not pressed. This is because the pull-up resistor keeps the pin at
    # a high level when it's not connected to ground through the button.
    # When the button is pressed then the input pin connects to ground
    # and reads a low level (value returns 0).
    if not button.value():
        # Remember that the internal led turn on
        # when the pin is LOW
        led.low()
    else:
        led.high()

    sleep(.1)
</code></pre>
<h3>
<a id="user-content-pull-up-resistor" class="anchor" href="#pull-up-resistor" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pull Up resistor</h3>
<p>With a pull-up resistor, the input pin will read a high state when the button is not pressed. In other words, a small amount of current is flowing between VCC and the input pin (not to ground), thus the input pin reads close to VCC. When the button is pressed, it connects the input pin directly to ground. The current flows through the resistor to ground, thus the input pin reads a low state.</p>
<img src="https://camo.githubusercontent.com/8632f3d794c5cf455d6466057da10d31084c15c7/68747470733a2f2f63646e2e737061726b66756e2e636f6d2f6173736574732f362f662f622f632f372f3531313536386236636533393566316234303030303030302e6a7067" width="300" data-canonical-src="https://cdn.sparkfun.com/assets/6/f/b/c/7/511568b6ce395f1b40000000.jpg">
<p><a href="https://learn.sparkfun.com/tutorials/pull-up-resistors" rel="nofollow">Here</a> is a good explanation about this circuit.</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<pre><code>def led_toggle():
    led.value(not led.value())

while True:
    if not button.value():
        led_toggle()
        time.sleep(.5)
</code></pre>


<h1>NeoPixels</h1>

<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/neopixel.jpg"></p>
<p>NeoPixels, also known as <a href="https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf" rel="nofollow">WS2812b</a> LEDs, are full-colour LEDs that are connected in serial, are individually addressable, and can have their red, green and blue components set between 0 and 255. They require precise timing to control them and there is a special neopixel module to do just this.</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/neopixels/neopixels.png"></p>
<h3>
<a id="user-content-neopixel-basics" class="anchor" href="#neopixel-basics" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NeoPixel basics</h3>
<p>To create a NeoPixel object do the following:</p>
<pre><code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from neopixel import NeoPixel
&gt;&gt;&gt; np = NeoPixel(Pin(14), 8)
</code></pre>
<p>This configures a NeoPixel strip on <code>GPIO14</code> with 8 pixels. You can adjust the “14” (pin number) and the “8” (number of pixels) to suit your set up.</p>
<pre><code>&gt;&gt;&gt; for i, pixel in enumerate(np):
...     print(i, pixel)
...     
...     
... 
0 (0, 0, 0)
1 (0, 0, 0)
2 (0, 0, 0)
3 (0, 0, 0)
4 (0, 0, 0)
5 (0, 0, 0)
6 (0, 0, 0)
7 (0, 0, 0)
</code></pre>
<p>To set the colour of pixels use:</p>
<pre><code>&gt;&gt;&gt; np[0] = (255, 0, 0) # set to red, full brightness
&gt;&gt;&gt; np[1] = (0, 128, 0) # set to green, half brightness
&gt;&gt;&gt; np[2] = (0, 0, 64)  # set to blue, quarter brightness
</code></pre>
<p>Then use the <code>write()</code> method to output the colours to the LEDs:</p>
<pre><code>&gt;&gt;&gt; np.write()
</code></pre>
<p>To set a random color you can use the <code>getrandbits()</code> function</p>
<pre><code>&gt;&gt;&gt; from urandom import getrandbits
&gt;&gt;&gt; for i in range(np.n):
...     np[i] = (getrandbits(8), getrandbits(8), getrandbits(8))
...     
...     
... 
&gt;&gt;&gt; np.write()
</code></pre>
<h3>
<a id="user-content-demo" class="anchor" href="#demo" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/neopixels/src/python/">examples/neopixels/src/python</a> folder and upload the <code>main.py</code> with ampy:</p>
<pre><code>$ bin/ampy --port /dev/ttyUSB0 put main.py
</code></pre>
<p>Then go to the python shell, reboot MicroPython with <code>Ctrl-D</code> (to load the <code>main.py</code> file) and run the function <code>demo(pin, n)</code>, where <code>pin</code> is the GPIO number and <code>n</code> is the length of pixels in the neopixels array.</p>
<pre><code>$ bin/shell
[Ctrl-D]

PYB: soft reboot
#21 ets_task(40100164, 3, 3fff8398, 4)
could not open file 'boot.py' for reading
MicroPython v1.8.7-7-gb5a1a20a3 on 2017-01-09; ESP module with ESP8266
Type "help()" for more information.
&gt;&gt;&gt; demo(pin=14, n=8)
</code></pre>
<h3>
<a id="user-content-resources" class="anchor" href="#resources" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resources</h3>
<ul>
<li><a href="https://youtu.be/_voIwFB4mu0" rel="nofollow">Video showing NeoPixels with MicroPython</a></li>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/overview" rel="nofollow">Adafruit - The magic of NeoPixels</a></li>
</ul>


<h1>DHT11</h1>

<p>The <a href="https://cdn-learn.adafruit.com/downloads/pdf/dht.pdf" rel="nofollow">DHT11</a> is a temperature and humidity sensor.</p>
<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/dht11.jpg"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/dht11/dht11.png"></p>
<h3>
<a id="user-content-the-basic-code-is" class="anchor" href="#the-basic-code-is" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The basic code is</h3>
<pre><code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from dht import DHT11
&gt;&gt;&gt; d = DHT11(Pin(14))
&gt;&gt;&gt; d.measure()
&gt;&gt;&gt; d.temperature()
28
&gt;&gt;&gt; d.humidity()
16
</code></pre>
<h3>
<a id="user-content-logging-the-data-with-phant" class="anchor" href="#logging-the-data-with-phant" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging the data with <a class="internal present" href="/lvidarte/esp8266/wiki/Phant">Phant</a>
</h3>
<p>Download the server</p>
<pre><code>$ sudo npm install -g phant
</code></pre>
<p>Start the server</p>
<pre><code>$ phant
phant http server running on port 8080
phant telnet server running on port 8081
</code></pre>
<p>Go to the browser and open the <a href="http://localhost:8080" rel="nofollow">http://localhost:8080</a>, then click on Create a data stream. Complete the Title with "ESP8266 Weather" and the Description with "ESP8266 Weather Station" for the new data stream and put the following fields: <code>temperature</code> and <code>humidity</code>. Then save and copy the public and private key (or download the keys as a JSON file).</p>
<h3>
<a id="user-content-making-http-requests-with-urequests" class="anchor" href="#making-http-requests-with-urequests" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making http requests with urequests</h3>
<p>MicroPython has <a href="https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py">urequest</a> which is very small port from the Python <a href="http://docs.python-requests.org/en/master/" rel="nofollow">Requests</a> lib.</p>
<p>According the <a href="http://phant.io/docs/input/http/" rel="nofollow">Phant documentation</a> the curl to send data is:</p>
<pre><code>$ curl -X POST 'http://PHANT_HOST/input/PUBLIC_KEY' \
       -H 'Phant-Private-Key: PRIVATE_KEY' \
       -d 'temperature=24.1&amp;humidity=40.2'
</code></pre>
<p>So to get this with urequest you have to do the following</p>
<pre><code>import urequests

url = 'http://%s/input/%s?temperature=24.1&amp;humidity=40.2' % (PHANT_HOST, PUBLIC_KEY)
headers = {'Phant-Private-Key': PRIVATE_KEY}
response = urequests.post(url, headers=headers)
</code></pre>
<p>You can check the response code and reason as following</p>
<pre><code>print(response.status_code, response.reason)
</code></pre>
<p>See the full code <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python/main.py">here</a></p>
<h3>
<a id="user-content-install-the-code" class="anchor" href="#install-the-code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Install the code</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python">examples/dht11/src/python</a> folder and update the <code>boot.py</code> file with your WiFi essid and password, and the <code>main.py</code> file with the Phant host and keys. Then upload the files with the <a href="https://github.com/adafruit/ampy">ampy</a> tool, using the script:</p>
<pre><code>$ bin/put.sh
</code></pre>
<p>Then open the Python shell, reboot MicroPython (to load the files) and run the following</p>
<pre><code>$ bin/shell
[Ctrl-D]

...

&gt;&gt;&gt; data = read_sensor()
&gt;&gt;&gt; phant_log(data)
</code></pre>
<p>There is a function <code>run()</code> to do this endless</p>
<pre><code>while True:
    data = read_sensor()
    print("Sending data", data)
    phant_log(data)
    time.sleep(60)
</code></pre>
<h3>
<a id="user-content-phant-interface" class="anchor" href="#phant-interface" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Phant interface</h3>
<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/phant.png"></p>
<h3>
<a id="user-content-visualize-the-data" class="anchor" href="#visualize-the-data" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Visualize the data</h3>
<p>You can <a href="http://phant.io/graphing/google/2014/07/07/graphing-data/" rel="nofollow">make graphs with Google Charts</a>, just open the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/html/weather.html">html/weather.html</a> example file changing the <code>phant_host</code> and <code>public_key</code> variables according to your settings.</p>
<p><img src="https://github.com//lvidarte/esp8266/wiki/imgs/weather-graph.png"></p>


<h1>SDD1306</h1>

<p>The SDD1306 is a driver for Oled Displays.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdd1306/sdd1306.png"></p>
<p>Get the library and upload</p>
<pre><code>$ wget https://raw.githubusercontent.com/adafruit/micropython-adafruit-ssd1306/master/ssd1306.py
$ ampy -p /dev/ttyUSB0 put ssd1306.py
</code></pre>
<p>Then check the files on the esp</p>
<pre><code>$ ampy -p /dev/ttyUSB0 ls
boot.py
ssd1306.py
</code></pre>
<p>Now, lets play</p>
<pre><code>&gt;&gt;&gt; from machine import Pin, I2C
&gt;&gt;&gt; i2c = I2C(scl=Pin(5), sda=Pin(4))

&gt;&gt;&gt; from ssd1306 import SSD1306_I2C
&gt;&gt;&gt; oled = SSD1306_I2C(128, 64, i2c)

&gt;&gt;&gt; oled.fill(1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.fill(0)
&gt;&gt;&gt; oled.show()


&gt;&gt;&gt; oled.pixel(0, 0, 1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.pixel(127, 63, 1)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.text('Hello', 0, 0)
&gt;&gt;&gt; oled.text(‘World’, 0, 10)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.invert(True)
&gt;&gt;&gt; oled.invert(False)
</code></pre>


<h1>SDCard</h1>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdcard/sdcard.png"></p>
<p>Ref: <a href="https://learn.adafruit.com/micropython-hardware-sd-cards/esp8266" rel="nofollow">Adafruit - MicroPython Hardware: SD Cards</a></p>
<p>Download the <a href="https://github.com/micropython/micropython/blob/master/drivers/sdcard/sdcard.py">sdcard.py</a> module. Next use a tool like <a href="https://github.com/adafruit/ampy">ampy</a> to copy the <code>sdcard.py</code> file to the root of the board's filesystem:</p>
<pre><code>$ ampy --port /dev/ttyUSB0 put sdcard.py
</code></pre>
<p>Mount SD Card:</p>
<pre><code>&gt;&gt;&gt; import machine, sdcard, os
&gt;&gt;&gt; sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15))
&gt;&gt;&gt; os.umount()
&gt;&gt;&gt; os.VfsFat(sd, "")
&gt;&gt;&gt; os.listdir()
['somefile']
</code></pre>
<p>Then write a file</p>
<pre><code>&gt;&gt;&gt; f = open('test', 'w')
&gt;&gt;&gt; f.write('hello world')
11
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; os.listdir()
['somefile', 'test']
</code></pre>
<p>Then read a file</p>
<pre><code>&gt;&gt;&gt; f = open('test', 'r')
&gt;&gt;&gt; f.read()
'hello world'
&gt;&gt;&gt; f.close()
</code></pre>


<h1>OTA</h1>

<p>Over-The-Air (OTA) update is the wireless delivery of new firmware.</p>
<p>There is still not OTA for MicroPython, but will be under development soon. Check this <a href="https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979" rel="nofollow">https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979</a></p>
<p>But you can do OTA with C++ as described in the <a class="internal present" href="/lvidarte/esp8266/wiki/CPP%3A-OTA">C++ OTA</a> section of this wiki.</p>


<h1>AP</h1>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/ap/ap.png"></p>
<p>You can put the esp8266 as an Access Point mode with the following lines</p>
<pre><code>import network

ap = network.WLAN(network.AP_IF)
ap.config(essid="ESP-AP", password="12345678")
ap.active(True)
</code></pre>


<h1>RGB Lamp</h1>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/rgb-lamp.png"></p>
<h3>
<a id="user-content-pwm-pulse-with-modulation" class="anchor" href="#pwm-pulse-with-modulation" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PWM (Pulse With Modulation)</h3>
<p>Pulse width modulation (PWM) is a way to get an artificial analog output on a digital pin. It achieves this by rapidly toggling the pin from low to high. There are two parameters associated with this: the frequency of the toggling, and the duty cycle.</p>
<p>See the micropython doc <a href="https://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/pwm.html" rel="nofollow">here</a>.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/pwm.gif"></p>
<pre><code>import socket
import machine
import template

ADDR = ('0.0.0.0', 80)

PIN_R = 12
PIN_G = 13
PIN_B = 14


class RGBLed:
    def __init__(self, pin_r, pin_g, pin_b):
        self.pin_r = machine.PWM(machine.Pin(pin_r))
        self.pin_g = machine.PWM(machine.Pin(pin_g))
        self.pin_b = machine.PWM(machine.Pin(pin_b))
        self.set(0, 0, 0)

    def set(self, r, g, b):
        self.r = int(r)
        self.g = int(g)
        self.b = int(b)
        self.duty()

    def duty(self):
        self.pin_r.duty(self.duty_translate(self.r))
        self.pin_g.duty(self.duty_translate(self.g))
        self.pin_b.duty(self.duty_translate(self.b))

    def duty_translate(self, n):
        """translate values from 0-255 to 0-1023"""
        return int((float(n) / 255) * 1023)


def get_url(conn):
    conn_file = conn.makefile('rb', 0)
    method, url = None, None
    while True:
        line = conn_file.readline().decode()
        if not line or line == '\r\n':
            break
        if line.startswith('GET'):
            method, url, _ = line.split()
    return method, url

def parse_url(url):
    try:
        path, query = url.split('?', 2)
    except:
        return url, {}
    return path, {_.split('=')[0]: _.split('=')[1] for _ in query.split('&amp;')}

def conn_send(conn, response):
    total_sent = 0
    while total_sent &lt; len(response):
        sent = conn.send(response[total_sent:])
        if sent == 0:
            raise RuntimeError('Socket connection broken')
        total_sent = total_sent + sent

led = RGBLed(PIN_R, PIN_G, PIN_B)

s = socket.socket()
s.bind(ADDR)
s.listen(1)

print('RGBLamp daemon started on %s:%s' % ADDR)

while True:
    conn, addr = s.accept()
    method, url = get_url(conn)
    path, query = parse_url(url)
    print(addr[0], '-', method, url)
    if path == '/':
        if [_ for _ in list('rbg') if _ in query.keys()]:
            led.set(query.get('r', 0), query.get('g', 0), query.get('b', 0))
        response = template.html % (led.r, led.g, led.b)
        conn_send(conn, response)
    conn.close()
</code></pre>


<h1>Servo sg90</h1>

<p>The sg90 servo has three wires: brown (gnd), red (vcc), and yellow (signal). The vcc is the power source for the servo, and it has to be connected to the vin pin of our board – this way it is connected directly to the USB port, and not powered through the board.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sg90/sg90.png"></p>
<p>The signal wire tells the servo what position it should move to, using a 50Hz PWM signal. The center is at around 77, and the exact range varies with the servo model, but should be somewhere between 30 and 122, which corresponds to about 180° of movement. Note that if you send the servo a signal that is outside of the range, it will still obediently try to move there – hitting a mechanical stop and buzzing loudly. If you leave it like this for longer, you can damage your servo, your board or your battery, so please be careful.</p>
<p>So now we are ready to try and move it to the center position:</p>
<pre><code>from machine import Pin, PWM
servo = PWM(Pin(14), freq=50, duty=77)
</code></pre>
<p>Then we can see where the limits of its movement are:</p>
<pre><code>servo.duty(30)
servo.duty(122)
</code></pre>
<p>Ref: <a href="http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms" rel="nofollow">http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms</a></p>

<br>
<br>
<br>
<br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h1, h2').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
