<base target="_blank"><html><head><title>MicroPython Examples</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "MicroPython"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>MicroPython Examples</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="http://wiki.micropython.org/Home" class="whitebut ">MicroPython Wiki</a>
<a href="https://docs.micropython.org/en/latest/esp8266/tutorial/index.html" class="whitebut ">MicroPython tutorial for ESP8266</a>
<a href="https://github.com/mithru/MicroPython-Examples" class="whitebut ">MicroPython-Examples</a>
<a href="https://github.com/peterhinch/micropython-samples" class="whitebut ">micropython-samples</a>
<a href="https://microbit-micropython.readthedocs.io/en/v1.0.1/" class="whitebut ">BBC micro</a>
<a href="https://micropython.org/" class="whitebut ">MicroPython</a>
<a href="https://realpython.com/micropython/" class="whitebut ">Programming Hardware in Python</a></div>
<pre>
<br>

<h2>LED</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/leds.jpg"></p>
<p>A light-emitting diode (LED) is a semiconductor device that emits visible light when an electric current passes through it. The light is not particularly bright, but in most LEDs it is monochromatic, occurring at a single wavelength. The output from an LED can range from red (at a wavelength of approximately 700 nanometers) to blue-violet (about 400 nanometers). Some LEDs emit infrared (IR) energy (830 nanometers or longer); such a device is known as an infrared-emitting diode (IRED).</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/led/led.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<pre><code>from machine import Pin
from time import sleep

# GPIO16 (D0) is the internal LED for NodeMCU
led = Pin(16, Pin.OUT)

# The internal LED turn on when the pin is LOW
while True:
    led.high()
    sleep(1)
    led.low()
    sleep(1)
</code></pre>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/nodemcu_led.gif"></p>
<p><a href="https://github.com/nodemcu/nodemcu-devkit-v1.0/issues/16#issuecomment-244625860">Here</a> is the reason why the built in led turn on when Pin 16 is Low :)</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<pre><code>def led_toggle():
    led.value(not led.value())
</code></pre>
<p>Now we can use this function to blink the LED</p>
<pre><code>while True:
    led_toggle()
    sleep(1)
</code></pre>


<h2>Button</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/switches.png"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/button/button.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<pre><code>from machine import Pin
from time import sleep

led = Pin(16, Pin.OUT)
button = Pin(14, Pin.IN, Pin.PULL_UP)

while True:

    # The value function returns the current level of the pin,
    # either 1 for a high logic level or 0 for a low logic level.
    # Notice how the button is at a high level (value returns 1) when
    # it's not pressed. This is because the pull-up resistor keeps the pin at
    # a high level when it's not connected to ground through the button.
    # When the button is pressed then the input pin connects to ground
    # and reads a low level (value returns 0).
    if not button.value():
        # Remember that the internal led turn on
        # when the pin is LOW
        led.low()
    else:
        led.high()

    sleep(.1)
</code></pre>
<h3>
<a id="user-content-pull-up-resistor" class="anchor" href="#pull-up-resistor" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pull Up resistor</h3>
<p>With a pull-up resistor, the input pin will read a high state when the button is not pressed. In other words, a small amount of current is flowing between VCC and the input pin (not to ground), thus the input pin reads close to VCC. When the button is pressed, it connects the input pin directly to ground. The current flows through the resistor to ground, thus the input pin reads a low state.</p>
<img src="https://camo.githubusercontent.com/8632f3d794c5cf455d6466057da10d31084c15c7/68747470733a2f2f63646e2e737061726b66756e2e636f6d2f6173736574732f362f662f622f632f372f3531313536386236636533393566316234303030303030302e6a7067" width="300" data-canonical-src="https://cdn.sparkfun.com/assets/6/f/b/c/7/511568b6ce395f1b40000000.jpg">
<p><a href="https://learn.sparkfun.com/tutorials/pull-up-resistors" rel="nofollow">Here</a> is a good explanation about this circuit.</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<pre><code>def led_toggle():
    led.value(not led.value())

while True:
    if not button.value():
        led_toggle()
        time.sleep(.5)
</code></pre>


<h2>NeoPixels</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/neopixel.jpg"></p>
<p>NeoPixels, also known as <a href="https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf" rel="nofollow">WS2812b</a> LEDs, are full-colour LEDs that are connected in serial, are individually addressable, and can have their red, green and blue components set between 0 and 255. They require precise timing to control them and there is a special neopixel module to do just this.</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/neopixels/neopixels.png"></p>
<h3>
<a id="user-content-neopixel-basics" class="anchor" href="#neopixel-basics" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NeoPixel basics</h3>
<p>To create a NeoPixel object do the following:</p>
<pre><code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from neopixel import NeoPixel
&gt;&gt;&gt; np = NeoPixel(Pin(14), 8)
</code></pre>
<p>This configures a NeoPixel strip on <code>GPIO14</code> with 8 pixels. You can adjust the “14” (pin number) and the “8” (number of pixels) to suit your set up.</p>
<pre><code>&gt;&gt;&gt; for i, pixel in enumerate(np):
...     print(i, pixel)
...     
...     
... 
0 (0, 0, 0)
1 (0, 0, 0)
2 (0, 0, 0)
3 (0, 0, 0)
4 (0, 0, 0)
5 (0, 0, 0)
6 (0, 0, 0)
7 (0, 0, 0)
</code></pre>
<p>To set the colour of pixels use:</p>
<pre><code>&gt;&gt;&gt; np[0] = (255, 0, 0) # set to red, full brightness
&gt;&gt;&gt; np[1] = (0, 128, 0) # set to green, half brightness
&gt;&gt;&gt; np[2] = (0, 0, 64)  # set to blue, quarter brightness
</code></pre>
<p>Then use the <code>write()</code> method to output the colours to the LEDs:</p>
<pre><code>&gt;&gt;&gt; np.write()
</code></pre>
<p>To set a random color you can use the <code>getrandbits()</code> function</p>
<pre><code>&gt;&gt;&gt; from urandom import getrandbits
&gt;&gt;&gt; for i in range(np.n):
...     np[i] = (getrandbits(8), getrandbits(8), getrandbits(8))
...     
...     
... 
&gt;&gt;&gt; np.write()
</code></pre>
<h3>
<a id="user-content-demo" class="anchor" href="#demo" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/neopixels/src/python/">examples/neopixels/src/python</a> folder and upload the <code>main.py</code> with ampy:</p>
<pre><code>$ bin/ampy --port /dev/ttyUSB0 put main.py
</code></pre>
<p>Then go to the python shell, reboot MicroPython with <code>Ctrl-D</code> (to load the <code>main.py</code> file) and run the function <code>demo(pin, n)</code>, where <code>pin</code> is the GPIO number and <code>n</code> is the length of pixels in the neopixels array.</p>
<pre><code>$ bin/shell
[Ctrl-D]

PYB: soft reboot
#21 ets_task(40100164, 3, 3fff8398, 4)
could not open file 'boot.py' for reading
MicroPython v1.8.7-7-gb5a1a20a3 on 2017-01-09; ESP module with ESP8266
Type "help()" for more information.
&gt;&gt;&gt; demo(pin=14, n=8)
</code></pre>
<h3>
<a id="user-content-resources" class="anchor" href="#resources" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resources</h3>
<ul>
<li><a href="https://youtu.be/_voIwFB4mu0" rel="nofollow">Video showing NeoPixels with MicroPython</a></li>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/overview" rel="nofollow">Adafruit - The magic of NeoPixels</a></li>
</ul>


<h2>DHT11</h2>

<p>The <a href="https://cdn-learn.adafruit.com/downloads/pdf/dht.pdf" rel="nofollow">DHT11</a> is a temperature and humidity sensor.</p>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/dht11.jpg"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/dht11/dht11.png"></p>
<h3>
<a id="user-content-the-basic-code-is" class="anchor" href="#the-basic-code-is" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The basic code is</h3>
<pre><code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from dht import DHT11
&gt;&gt;&gt; d = DHT11(Pin(14))
&gt;&gt;&gt; d.measure()
&gt;&gt;&gt; d.temperature()
28
&gt;&gt;&gt; d.humidity()
16
</code></pre>
<h3>
<a id="user-content-logging-the-data-with-phant" class="anchor" href="#logging-the-data-with-phant" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging the data with <a class="internal present" href="/lvidarte/esp8266/wiki/Phant">Phant</a>
</h3>
<p>Download the server</p>
<pre><code>$ sudo npm install -g phant
</code></pre>
<p>Start the server</p>
<pre><code>$ phant
phant http server running on port 8080
phant telnet server running on port 8081
</code></pre>
<p>Go to the browser and open the <a href="http://localhost:8080" rel="nofollow">http://localhost:8080</a>, then click on Create a data stream. Complete the Title with "ESP8266 Weather" and the Description with "ESP8266 Weather Station" for the new data stream and put the following fields: <code>temperature</code> and <code>humidity</code>. Then save and copy the public and private key (or download the keys as a JSON file).</p>
<h3>
<a id="user-content-making-http-requests-with-urequests" class="anchor" href="#making-http-requests-with-urequests" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making http requests with urequests</h3>
<p>MicroPython has <a href="https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py">urequest</a> which is very small port from the Python <a href="http://docs.python-requests.org/en/master/" rel="nofollow">Requests</a> lib.</p>
<p>According the <a href="http://phant.io/docs/input/http/" rel="nofollow">Phant documentation</a> the curl to send data is:</p>
<pre><code>$ curl -X POST 'http://PHANT_HOST/input/PUBLIC_KEY' \
       -H 'Phant-Private-Key: PRIVATE_KEY' \
       -d 'temperature=24.1&amp;humidity=40.2'
</code></pre>
<p>So to get this with urequest you have to do the following</p>
<pre><code>import urequests

url = 'http://%s/input/%s?temperature=24.1&amp;humidity=40.2' % (PHANT_HOST, PUBLIC_KEY)
headers = {'Phant-Private-Key': PRIVATE_KEY}
response = urequests.post(url, headers=headers)
</code></pre>
<p>You can check the response code and reason as following</p>
<pre><code>print(response.status_code, response.reason)
</code></pre>
<p>See the full code <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python/main.py">here</a></p>
<h3>
<a id="user-content-install-the-code" class="anchor" href="#install-the-code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Install the code</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python">examples/dht11/src/python</a> folder and update the <code>boot.py</code> file with your WiFi essid and password, and the <code>main.py</code> file with the Phant host and keys. Then upload the files with the <a href="https://github.com/adafruit/ampy">ampy</a> tool, using the script:</p>
<pre><code>$ bin/put.sh
</code></pre>
<p>Then open the Python shell, reboot MicroPython (to load the files) and run the following</p>
<pre><code>$ bin/shell
[Ctrl-D]

...

&gt;&gt;&gt; data = read_sensor()
&gt;&gt;&gt; phant_log(data)
</code></pre>
<p>There is a function <code>run()</code> to do this endless</p>
<pre><code>while True:
    data = read_sensor()
    print("Sending data", data)
    phant_log(data)
    time.sleep(60)
</code></pre>
<h3>
<a id="user-content-phant-interface" class="anchor" href="#phant-interface" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Phant interface</h3>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/phant.png"></p>
<h3>
<a id="user-content-visualize-the-data" class="anchor" href="#visualize-the-data" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Visualize the data</h3>
<p>You can <a href="http://phant.io/graphing/google/2014/07/07/graphing-data/" rel="nofollow">make graphs with Google Charts</a>, just open the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/html/weather.html">html/weather.html</a> example file changing the <code>phant_host</code> and <code>public_key</code> variables according to your settings.</p>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/weather-graph.png"></p>


<h2>SDD1306</h2>

<p>The SDD1306 is a driver for Oled Displays.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdd1306/sdd1306.png"></p>
<p>Get the library and upload</p>
<pre><code>$ wget https://raw.githubusercontent.com/adafruit/micropython-adafruit-ssd1306/master/ssd1306.py
$ ampy -p /dev/ttyUSB0 put ssd1306.py
</code></pre>
<p>Then check the files on the esp</p>
<pre><code>$ ampy -p /dev/ttyUSB0 ls
boot.py
ssd1306.py
</code></pre>
<p>Now, lets play</p>
<pre><code>&gt;&gt;&gt; from machine import Pin, I2C
&gt;&gt;&gt; i2c = I2C(scl=Pin(5), sda=Pin(4))

&gt;&gt;&gt; from ssd1306 import SSD1306_I2C
&gt;&gt;&gt; oled = SSD1306_I2C(128, 64, i2c)

&gt;&gt;&gt; oled.fill(1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.fill(0)
&gt;&gt;&gt; oled.show()


&gt;&gt;&gt; oled.pixel(0, 0, 1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.pixel(127, 63, 1)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.text('Hello', 0, 0)
&gt;&gt;&gt; oled.text(‘World’, 0, 10)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.invert(True)
&gt;&gt;&gt; oled.invert(False)
</code></pre>


<h2>SDCard</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdcard/sdcard.png"></p>
<p>Ref: <a href="https://learn.adafruit.com/micropython-hardware-sd-cards/esp8266" rel="nofollow">Adafruit - MicroPython Hardware: SD Cards</a></p>
<p>Download the <a href="https://github.com/micropython/micropython/blob/master/drivers/sdcard/sdcard.py">sdcard.py</a> module. Next use a tool like <a href="https://github.com/adafruit/ampy">ampy</a> to copy the <code>sdcard.py</code> file to the root of the board's filesystem:</p>
<pre><code>$ ampy --port /dev/ttyUSB0 put sdcard.py
</code></pre>
<p>Mount SD Card:</p>
<pre><code>&gt;&gt;&gt; import machine, sdcard, os
&gt;&gt;&gt; sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15))
&gt;&gt;&gt; os.umount()
&gt;&gt;&gt; os.VfsFat(sd, "")
&gt;&gt;&gt; os.listdir()
['somefile']
</code></pre>
<p>Then write a file</p>
<pre><code>&gt;&gt;&gt; f = open('test', 'w')
&gt;&gt;&gt; f.write('hello world')
11
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; os.listdir()
['somefile', 'test']
</code></pre>
<p>Then read a file</p>
<pre><code>&gt;&gt;&gt; f = open('test', 'r')
&gt;&gt;&gt; f.read()
'hello world'
&gt;&gt;&gt; f.close()
</code></pre>


<h2>OTA</h2>

<p>Over-The-Air (OTA) update is the wireless delivery of new firmware.</p>
<p>There is still not OTA for MicroPython, but will be under development soon. Check this <a href="https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979" rel="nofollow">https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979</a></p>
<p>But you can do OTA with C++ as described in the <a class="internal present" href="/lvidarte/esp8266/wiki/CPP%3A-OTA">C++ OTA</a> section of this wiki.</p>


<h2>AP</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/ap/ap.png"></p>
<p>You can put the esp8266 as an Access Point mode with the following lines</p>
<pre><code>import network

ap = network.WLAN(network.AP_IF)
ap.config(essid="ESP-AP", password="12345678")
ap.active(True)
</code></pre>


<h2>RGB Lamp</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/rgb-lamp.png"></p>
<h3>
<a id="user-content-pwm-pulse-with-modulation" class="anchor" href="#pwm-pulse-with-modulation" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PWM (Pulse With Modulation)</h3>
<p>Pulse width modulation (PWM) is a way to get an artificial analog output on a digital pin. It achieves this by rapidly toggling the pin from low to high. There are two parameters associated with this: the frequency of the toggling, and the duty cycle.</p>
<p>See the micropython doc <a href="https://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/pwm.html" rel="nofollow">here</a>.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/pwm.gif"></p>
<pre><code>import socket
import machine
import template

ADDR = ('0.0.0.0', 80)

PIN_R = 12
PIN_G = 13
PIN_B = 14


class RGBLed:
    def __init__(self, pin_r, pin_g, pin_b):
        self.pin_r = machine.PWM(machine.Pin(pin_r))
        self.pin_g = machine.PWM(machine.Pin(pin_g))
        self.pin_b = machine.PWM(machine.Pin(pin_b))
        self.set(0, 0, 0)

    def set(self, r, g, b):
        self.r = int(r)
        self.g = int(g)
        self.b = int(b)
        self.duty()

    def duty(self):
        self.pin_r.duty(self.duty_translate(self.r))
        self.pin_g.duty(self.duty_translate(self.g))
        self.pin_b.duty(self.duty_translate(self.b))

    def duty_translate(self, n):
        """translate values from 0-255 to 0-1023"""
        return int((float(n) / 255) * 1023)


def get_url(conn):
    conn_file = conn.makefile('rb', 0)
    method, url = None, None
    while True:
        line = conn_file.readline().decode()
        if not line or line == '\r\n':
            break
        if line.startswith('GET'):
            method, url, _ = line.split()
    return method, url

def parse_url(url):
    try:
        path, query = url.split('?', 2)
    except:
        return url, {}
    return path, {_.split('=')[0]: _.split('=')[1] for _ in query.split('&amp;')}

def conn_send(conn, response):
    total_sent = 0
    while total_sent &lt; len(response):
        sent = conn.send(response[total_sent:])
        if sent == 0:
            raise RuntimeError('Socket connection broken')
        total_sent = total_sent + sent

led = RGBLed(PIN_R, PIN_G, PIN_B)

s = socket.socket()
s.bind(ADDR)
s.listen(1)

print('RGBLamp daemon started on %s:%s' % ADDR)

while True:
    conn, addr = s.accept()
    method, url = get_url(conn)
    path, query = parse_url(url)
    print(addr[0], '-', method, url)
    if path == '/':
        if [_ for _ in list('rbg') if _ in query.keys()]:
            led.set(query.get('r', 0), query.get('g', 0), query.get('b', 0))
        response = template.html % (led.r, led.g, led.b)
        conn_send(conn, response)
    conn.close()
</code></pre>


<h2>Servo sg90</h2>

<p>The sg90 servo has three wires: brown (gnd), red (vcc), and yellow (signal). The vcc is the power source for the servo, and it has to be connected to the vin pin of our board – this way it is connected directly to the USB port, and not powered through the board.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sg90/sg90.png"></p>
<p>The signal wire tells the servo what position it should move to, using a 50Hz PWM signal. The center is at around 77, and the exact range varies with the servo model, but should be somewhere between 30 and 122, which corresponds to about 180° of movement. Note that if you send the servo a signal that is outside of the range, it will still obediently try to move there – hitting a mechanical stop and buzzing loudly. If you leave it like this for longer, you can damage your servo, your board or your battery, so please be careful.</p>
<p>So now we are ready to try and move it to the center position:</p>
<pre><code>from machine import Pin, PWM
servo = PWM(Pin(14), freq=50, duty=77)
</code></pre>
<p>Then we can see where the limits of its movement are:</p>
<pre><code>servo.duty(30)
servo.duty(122)
</code></pre>
<p>Ref: <a href="http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms" rel="nofollow">http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms</a></p>


<h2>使用MicroPython从ESP板发送数据到Google表格</h2>
<pre>
<a href="https://blog.gypsyengineer.com/en/diy-electronics/micropython-on-esp32-sending-data-to-google-sheets.html">esp32 sending data to google sheets</a>

Google表格提供了很棒的HTTP API，为什么我们不能只发送一个POST请求来将数据插入到工作表中？

原因是Google表格API关注安全性并需要身份验证。

特别是，Google Sheet API支持两种身份验证方法：API密钥和OAuth2令牌。

使用API密钥听起来很简单：
我们可以在Google IAM控制台中创建一个API密钥，在我们的ESP板上编码，忘记旋转密钥和安全性，并永远使用密钥。

不幸的是（或者说幸运的是）它不会起作用。
Google Sheet API仅允许API键进行读取操作。

如果要写入工作表，则必须使用OAuth2。这里出现了问题。
首先，您需要在Google IAM控制台中创建一个服务帐户，然后为该服务帐户创建一个私有RSA密钥。

好的，那并不难。
然后，您的ESP板必须构建一个JWT请求，将当前时间戳放入其中，并使用RSA-SHA256签名算法使用密钥对请求进行签名。
接下来，板子必须将签名的JWT请求发送到Google OAuth2服务，该服务最终返回OAuth2令牌。
最后使用令牌来调用Google表格API。
让我快速总结一下ESP板能够在Google表格中插入一行需要的内容：
HTTP客户端、JSON解析器、具有正确时间的实时时钟或NTP客户端，以及RSA-SHA256签名的实现算法。

幸运的是，MicroPython提供了除RSA-SHA256签名之外的大部分内容。
确切地说，MicroPython可以计算SHA256哈希，但不能使用RSA算法对数据进行签名。

此外，RSA签名是一项昂贵的操作，可能需要相当多的时间和内存，但ESP板并不像PC那么强大，也没有太多的内存。

我猜想Google身份验证带来的复杂性以及缺少MicroPython的RSA，让人们使用了一个公开的表单或一个可以实现认证过程的中间件服务。

当然，作为一名安全工程师，我无法接受一个包含公共可用表格的解决方案，其中包含我房间内温度和湿度等敏感数据。

因为我是一名安全工程师，所以我不喜欢中间件。

最后，唯一的选择是以某种方式在ESP板上实现上述认证过程。

正如我之前提到的，MicroPython已经提供了大部分必需的东西：
ujson允许解析JSON
ntptime.py提供NTP客户端
uhashlib可以计算SHA256哈希值
http.client提供了一个HTTP客户端

唯一缺少的部分是RSA签名。

密码学的一个主要规则是：不要自己实现任何加密算法，而是使用现有的算法。

我知道这个规则，并发现python-rsa包在纯Python中实现了RSA算法。

除了使用RSA进行签名之外，该库还支持其他操作，例如验证签名，加密和解密，加载和存储密钥等。

这个库对于一个小型的ESP板来说负担太重了，我决定只保留RSA签名的实现并删除剩下的代码。
我甚至删除了以PKCS1格式加载RSA密钥的代码，因为它需要移植一个不小的pyasn1包。
我还必须基于从右到左的二进制方法和其他一些操作来实现模块化求幂，因为事实证明它们不是由MicroPython提供的。
它产生了一个新的micropython-rsa签名库。

我使用ESP8266和MicroPython以前的一个项目作为起点。

在实施身份验证过程并在我的笔记本电脑上进行测试后，我终于成功用ESP8266主板运行了代码。

不幸的是我发现代码运行得很慢，主要问题是ESP8266主板没有足够的内存来完成RSA签名。
我尝试了一些优化，甚至尝试将应用程序代码嵌入到MicroPython固件中，但没有任何帮助。

最后的希望是在ESP32上运行代码。
我之前没有用过ESP32，于是订购了我的第一个ESP32开发板。
幸运的是，它成功了！

应用程序不再抱怨内存不足，事实上它运行得更快了。

该代码可在GitHub上获得。
README简要描述了如何构建项目。
我还在Hackaday.io上创建了一个项目。
我希望我能找到一些时间在后续帖子中提供更多细节。
https://github.com/artem-smotrakov/esp32-weather-google-sheets

<h2>timers_and_interrupts_timer</h2>

from machine import Pin, Timer

led = Pin(5, Pin.OUT)
led.value(0)

timer = Timer(-1)
timer.init(period=1000, mode=Timer.PERIODIC, callback=lambda t:led.value(not led.value()))


<h2>timers_and_interrupts_interrupt</h2>

from machine import Pin

led = Pin(5, Pin.OUT)

button = Pin(4, Pin.IN, Pin.PULL_UP)
button.irq(trigger=Pin.IRQ_FALLING, handler=lambda t:led.value(not led.value()))

<h2>timers_and_interrupts_debounce</h2>

from machine import Pin

led = Pin(5, Pin.OUT)
button = Pin(4, Pin.IN, Pin.PULL_UP)

def debounce(pin):
    prev = None
    for _ in range(32):
        current_value = pin.value()
        if prev != None and prev != current_value:
            return None
        prev = current_value
    return prev


def button_callback(pin):
    d = debounce(pin)

    if d == None:
        return
    elif not d:
        led.value(not led.value())
        
button.irq(trigger=Pin.IRQ_FALLING, handler=button_callback)


<h2>Pwm and Adc with a Nodemcu and Micropython</h2>
https://micronote.tech/2020/02/PWM-and-ADC-with-a-NodeMCU-and-MicroPython/

from machine import Pin, PWM, ADC, Timer

POT_LOWER_EXTREME = 18
POT_UPPER_EXTREME = 1024

pwm_led = PWM(Pin(5), freq=1000)
pot = ADC(0)

def pot_percent(val, lower_limit, upper_limit):
    if val > upper_limit:
        val = upper_limit
    elif val < lower_limit:
        val = lower_limit
        
    total_range = upper_limit - lower_limit
    
    return (val-lower_limit)/total_range

def set_dimmer(pin):
    pwm_led.duty(int(pot_percent(pot.read(), POT_LOWER_EXTREME, POT_UPPER_EXTREME) * 1023))

timer = Timer(-1)
timer.init(period=100, mode=Timer.PERIODIC, callback=set_dimmer)


<br>
<br>
<br>
<br>

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</body>
</html>
