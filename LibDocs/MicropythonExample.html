<base target="_blank"><html><head><title>MicroPython Examples</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "MicroPython"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>MicroPython Examples</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://pypi.org/project/micropython-mpu6886/" class="whitebut ">6-axis motion tracking device</a>

<a href="http://wiki.micropython.org/Home" class="whitebut ">MicroPython Wiki</a>
<a href="https://docs.micropython.org/en/latest/esp8266/tutorial/index.html" class="whitebut ">MicroPython tutorial for ESP8266</a>
<a href="https://github.com/mithru/MicroPython-Examples" class="whitebut ">MicroPython-Examples</a>
<a href="https://github.com/peterhinch/micropython-samples" class="whitebut ">micropython-samples</a>
<a href="https://microbit-micropython.readthedocs.io/en/v1.0.1/" class="whitebut ">BBC micro</a>
<a href="https://micropython.org/" class="whitebut ">MicroPython</a>
<a href="https://realpython.com/micropython/" class="whitebut ">Programming Hardware in Python</a></div>

<pre>
<br>

<h2>LED</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/leds.jpg"></p>
<p>A light-emitting diode (LED) is a semiconductor device that emits visible light when an electric current passes through it. The light is not particularly bright, but in most LEDs it is monochromatic, occurring at a single wavelength. The output from an LED can range from red (at a wavelength of approximately 700 nanometers) to blue-violet (about 400 nanometers). Some LEDs emit infrared (IR) energy (830 nanometers or longer); such a device is known as an infrared-emitting diode (IRED).</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/led/led.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<code>from machine import Pin
from time import sleep

# GPIO16 (D0) is the internal LED for NodeMCU
led = Pin(16, Pin.OUT)

# The internal LED turn on when the pin is LOW
while True:
    led.high()
    sleep(1)
    led.low()
    sleep(1)
</code>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/nodemcu_led.gif"></p>
<p><a href="https://github.com/nodemcu/nodemcu-devkit-v1.0/issues/16#issuecomment-244625860">Here</a> is the reason why the built in led turn on when Pin 16 is Low :)</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<code>def led_toggle():
    led.value(not led.value())
</code>
<p>Now we can use this function to blink the LED</p>
<code>while True:
    led_toggle()
    sleep(1)
</code>


<h2>Button</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/switches.png"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/button/button.png"></p>
<h3>
<a id="user-content-code" class="anchor" href="#code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Code</h3>
<code>from machine import Pin
from time import sleep

led = Pin(16, Pin.OUT)
button = Pin(14, Pin.IN, Pin.PULL_UP)

while True:

    # The value function returns the current level of the pin,
    # either 1 for a high logic level or 0 for a low logic level.
    # Notice how the button is at a high level (value returns 1) when
    # it's not pressed. This is because the pull-up resistor keeps the pin at
    # a high level when it's not connected to ground through the button.
    # When the button is pressed then the input pin connects to ground
    # and reads a low level (value returns 0).
    if not button.value():
        # Remember that the internal led turn on
        # when the pin is LOW
        led.low()
    else:
        led.high()

    sleep(.1)
</code>
<h3>
<a id="user-content-pull-up-resistor" class="anchor" href="#pull-up-resistor" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Pull Up resistor</h3>
<p>With a pull-up resistor, the input pin will read a high state when the button is not pressed. In other words, a small amount of current is flowing between VCC and the input pin (not to ground), thus the input pin reads close to VCC. When the button is pressed, it connects the input pin directly to ground. The current flows through the resistor to ground, thus the input pin reads a low state.</p>
<img src="https://camo.githubusercontent.com/8632f3d794c5cf455d6466057da10d31084c15c7/68747470733a2f2f63646e2e737061726b66756e2e636f6d2f6173736574732f362f662f622f632f372f3531313536386236636533393566316234303030303030302e6a7067" width="300" data-canonical-src="https://cdn.sparkfun.com/assets/6/f/b/c/7/511568b6ce395f1b40000000.jpg">
<p><a href="https://learn.sparkfun.com/tutorials/pull-up-resistors" rel="nofollow">Here</a> is a good explanation about this circuit.</p>
<h3>
<a id="user-content-toggle-a-led" class="anchor" href="#toggle-a-led" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toggle a LED</h3>
<code>def led_toggle():
    led.value(not led.value())

while True:
    if not button.value():
        led_toggle()
        time.sleep(.5)
</code>


<h2>NeoPixels</h2>

<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/neopixel.jpg"></p>
<p>NeoPixels, also known as <a href="https://cdn-shop.adafruit.com/datasheets/WS2812B.pdf" rel="nofollow">WS2812b</a> LEDs, are full-colour LEDs that are connected in serial, are individually addressable, and can have their red, green and blue components set between 0 and 255. They require precise timing to control them and there is a special neopixel module to do just this.</p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/neopixels/neopixels.png"></p>
<h3>
<a id="user-content-neopixel-basics" class="anchor" href="#neopixel-basics" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NeoPixel basics</h3>
<p>To create a NeoPixel object do the following:</p>
<code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from neopixel import NeoPixel
&gt;&gt;&gt; np = NeoPixel(Pin(14), 8)
</code>
<p>This configures a NeoPixel strip on <code>GPIO14</code> with 8 pixels. You can adjust the “14” (pin number) and the “8” (number of pixels) to suit your set up.</p>
<code>&gt;&gt;&gt; for i, pixel in enumerate(np):
...     print(i, pixel)
...     
...     
... 
0 (0, 0, 0)
1 (0, 0, 0)
2 (0, 0, 0)
3 (0, 0, 0)
4 (0, 0, 0)
5 (0, 0, 0)
6 (0, 0, 0)
7 (0, 0, 0)
</code>
<p>To set the colour of pixels use:</p>
<code>&gt;&gt;&gt; np[0] = (255, 0, 0) # set to red, full brightness
&gt;&gt;&gt; np[1] = (0, 128, 0) # set to green, half brightness
&gt;&gt;&gt; np[2] = (0, 0, 64)  # set to blue, quarter brightness
</code>
<p>Then use the <code>write()</code> method to output the colours to the LEDs:</p>
<code>&gt;&gt;&gt; np.write()
</code>
<p>To set a random color you can use the <code>getrandbits()</code> function</p>
<code>&gt;&gt;&gt; from urandom import getrandbits
&gt;&gt;&gt; for i in range(np.n):
...     np[i] = (getrandbits(8), getrandbits(8), getrandbits(8))
...     
...     
... 
&gt;&gt;&gt; np.write()
</code>
<h3>
<a id="user-content-demo" class="anchor" href="#demo" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Demo</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/neopixels/src/python/">examples/neopixels/src/python</a> folder and upload the <code>main.py</code> with ampy:</p>
<code>$ bin/ampy --port /dev/ttyUSB0 put main.py
</code>
<p>Then go to the python shell, reboot MicroPython with <code>Ctrl-D</code> (to load the <code>main.py</code> file) and run the function <code>demo(pin, n)</code>, where <code>pin</code> is the GPIO number and <code>n</code> is the length of pixels in the neopixels array.</p>
<code>$ bin/shell
[Ctrl-D]

PYB: soft reboot
#21 ets_task(40100164, 3, 3fff8398, 4)
could not open file 'boot.py' for reading
MicroPython v1.8.7-7-gb5a1a20a3 on 2017-01-09; ESP module with ESP8266
Type "help()" for more information.
&gt;&gt;&gt; demo(pin=14, n=8)
</code>
<h3>
<a id="user-content-resources" class="anchor" href="#resources" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resources</h3>
<ul>
<li><a href="https://youtu.be/_voIwFB4mu0" rel="nofollow">Video showing NeoPixels with MicroPython</a></li>
<li><a href="https://learn.adafruit.com/adafruit-neopixel-uberguide/overview" rel="nofollow">Adafruit - The magic of NeoPixels</a></li>
</ul>


<h2>DHT11</h2>

<p>The <a href="https://cdn-learn.adafruit.com/downloads/pdf/dht.pdf" rel="nofollow">DHT11</a> is a temperature and humidity sensor.</p>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/dht11.jpg"></p>
<h3>
<a id="user-content-schematic" class="anchor" href="#schematic" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schematic</h3>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/dht11/dht11.png"></p>
<h3>
<a id="user-content-the-basic-code-is" class="anchor" href="#the-basic-code-is" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The basic code is</h3>
<code>&gt;&gt;&gt; from machine import Pin
&gt;&gt;&gt; from dht import DHT11
&gt;&gt;&gt; d = DHT11(Pin(14))
&gt;&gt;&gt; d.measure()
&gt;&gt;&gt; d.temperature()
28
&gt;&gt;&gt; d.humidity()
16
</code>
<h3>
<a id="user-content-logging-the-data-with-phant" class="anchor" href="#logging-the-data-with-phant" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Logging the data with <a class="internal present" href="/lvidarte/esp8266/wiki/Phant">Phant</a>
</h3>
<p>Download the server</p>
<code>$ sudo npm install -g phant
</code>
<p>Start the server</p>
<code>$ phant
phant http server running on port 8080
phant telnet server running on port 8081
</code>
<p>Go to the browser and open the <a href="http://localhost:8080" rel="nofollow">http://localhost:8080</a>, then click on Create a data stream. Complete the Title with "ESP8266 Weather" and the Description with "ESP8266 Weather Station" for the new data stream and put the following fields: <code>temperature</code> and <code>humidity</code>. Then save and copy the public and private key (or download the keys as a JSON file).</p>
<h3>
<a id="user-content-making-http-requests-with-urequests" class="anchor" href="#making-http-requests-with-urequests" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Making http requests with urequests</h3>
<p>MicroPython has <a href="https://github.com/micropython/micropython-lib/blob/master/urequests/urequests.py">urequest</a> which is very small port from the Python <a href="http://docs.python-requests.org/en/master/" rel="nofollow">Requests</a> lib.</p>
<p>According the <a href="http://phant.io/docs/input/http/" rel="nofollow">Phant documentation</a> the curl to send data is:</p>
<code>$ curl -X POST 'http://PHANT_HOST/input/PUBLIC_KEY' \
       -H 'Phant-Private-Key: PRIVATE_KEY' \
       -d 'temperature=24.1&amp;humidity=40.2'
</code>
<p>So to get this with urequest you have to do the following</p>
<code>import urequests

url = 'http://%s/input/%s?temperature=24.1&amp;humidity=40.2' % (PHANT_HOST, PUBLIC_KEY)
headers = {'Phant-Private-Key': PRIVATE_KEY}
response = urequests.post(url, headers=headers)
</code>
<p>You can check the response code and reason as following</p>
<code>print(response.status_code, response.reason)
</code>
<p>See the full code <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python/main.py">here</a></p>
<h3>
<a id="user-content-install-the-code" class="anchor" href="#install-the-code" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Install the code</h3>
<p>Go to the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/python">examples/dht11/src/python</a> folder and update the <code>boot.py</code> file with your WiFi essid and password, and the <code>main.py</code> file with the Phant host and keys. Then upload the files with the <a href="https://github.com/adafruit/ampy">ampy</a> tool, using the script:</p>
<code>$ bin/put.sh
</code>
<p>Then open the Python shell, reboot MicroPython (to load the files) and run the following</p>
<code>$ bin/shell
[Ctrl-D]

...

&gt;&gt;&gt; data = read_sensor()
&gt;&gt;&gt; phant_log(data)
</code>
<p>There is a function <code>run()</code> to do this endless</p>
<code>while True:
    data = read_sensor()
    print("Sending data", data)
    phant_log(data)
    time.sleep(60)
</code>
<h3>
<a id="user-content-phant-interface" class="anchor" href="#phant-interface" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Phant interface</h3>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/phant.png"></p>
<h3>
<a id="user-content-visualize-the-data" class="anchor" href="#visualize-the-data" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Visualize the data</h3>
<p>You can <a href="http://phant.io/graphing/google/2014/07/07/graphing-data/" rel="nofollow">make graphs with Google Charts</a>, just open the <a href="https://github.com/lvidarte/esp8266/blob/master/examples/dht11/src/html/weather.html">html/weather.html</a> example file changing the <code>phant_host</code> and <code>public_key</code> variables according to your settings.</p>
<p><img src="https://github.com/lvidarte/esp8266/wiki/imgs/weather-graph.png"></p>


<h2>SDD1306</h2>

<p>The SDD1306 is a driver for Oled Displays.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdd1306/sdd1306.png"></p>
<p>Get the library and upload</p>
<code>$ wget https://raw.githubusercontent.com/adafruit/micropython-adafruit-ssd1306/master/ssd1306.py
$ ampy -p /dev/ttyUSB0 put ssd1306.py
</code>
<p>Then check the files on the esp</p>
<code>$ ampy -p /dev/ttyUSB0 ls
boot.py
ssd1306.py
</code>
<p>Now, lets play</p>
<code>&gt;&gt;&gt; from machine import Pin, I2C
&gt;&gt;&gt; i2c = I2C(scl=Pin(5), sda=Pin(4))

&gt;&gt;&gt; from ssd1306 import SSD1306_I2C
&gt;&gt;&gt; oled = SSD1306_I2C(128, 64, i2c)

&gt;&gt;&gt; oled.fill(1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.fill(0)
&gt;&gt;&gt; oled.show()


&gt;&gt;&gt; oled.pixel(0, 0, 1)
&gt;&gt;&gt; oled.show()
&gt;&gt;&gt; oled.pixel(127, 63, 1)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.text('Hello', 0, 0)
&gt;&gt;&gt; oled.text(‘World’, 0, 10)
&gt;&gt;&gt; oled.show()

&gt;&gt;&gt; oled.invert(True)
&gt;&gt;&gt; oled.invert(False)
</code>


<h2>SDCard</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sdcard/sdcard.png"></p>
<p>Ref: <a href="https://learn.adafruit.com/micropython-hardware-sd-cards/esp8266" rel="nofollow">Adafruit - MicroPython Hardware: SD Cards</a></p>
<p>Download the <a href="https://github.com/micropython/micropython/blob/master/drivers/sdcard/sdcard.py">sdcard.py</a> module. Next use a tool like <a href="https://github.com/adafruit/ampy">ampy</a> to copy the <code>sdcard.py</code> file to the root of the board's filesystem:</p>
<code>$ ampy --port /dev/ttyUSB0 put sdcard.py
</code>
<p>Mount SD Card:</p>
<code>&gt;&gt;&gt; import machine, sdcard, os
&gt;&gt;&gt; sd = sdcard.SDCard(machine.SPI(1), machine.Pin(15))
&gt;&gt;&gt; os.umount()
&gt;&gt;&gt; os.VfsFat(sd, "")
&gt;&gt;&gt; os.listdir()
['somefile']
</code>
<p>Then write a file</p>
<code>&gt;&gt;&gt; f = open('test', 'w')
&gt;&gt;&gt; f.write('hello world')
11
&gt;&gt;&gt; f.close()
&gt;&gt;&gt; os.listdir()
['somefile', 'test']
</code>
<p>Then read a file</p>
<code>&gt;&gt;&gt; f = open('test', 'r')
&gt;&gt;&gt; f.read()
'hello world'
&gt;&gt;&gt; f.close()
</code>


<h2>OTA</h2>

<p>Over-The-Air (OTA) update is the wireless delivery of new firmware.</p>
<p>There is still not OTA for MicroPython, but will be under development soon. Check this <a href="https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979" rel="nofollow">https://www.kickstarter.com/projects/214379695/micropython-on-the-esp8266-beautifully-easy-iot/posts/1540979</a></p>
<p>But you can do OTA with C++ as described in the <a class="internal present" href="/lvidarte/esp8266/wiki/CPP%3A-OTA">C++ OTA</a> section of this wiki.</p>


<h2>AP</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/ap/ap.png"></p>
<p>You can put the esp8266 as an Access Point mode with the following lines</p>
<code>import network

ap = network.WLAN(network.AP_IF)
ap.config(essid="ESP-AP", password="12345678")
ap.active(True)
</code>


<h2>RGB Lamp</h2>

<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/rgb-lamp.png"></p>
<h3>
<a id="user-content-pwm-pulse-with-modulation" class="anchor" href="#pwm-pulse-with-modulation" aria-hidden="true"><svg class="octicon octicon-link" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PWM (Pulse With Modulation)</h3>
<p>Pulse width modulation (PWM) is a way to get an artificial analog output on a digital pin. It achieves this by rapidly toggling the pin from low to high. There are two parameters associated with this: the frequency of the toggling, and the duty cycle.</p>
<p>See the micropython doc <a href="https://docs.micropython.org/en/latest/esp8266/esp8266/tutorial/pwm.html" rel="nofollow">here</a>.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/rgb-lamp/pwm.gif"></p>
<code>import socket
import machine
import template

ADDR = ('0.0.0.0', 80)

PIN_R = 12
PIN_G = 13
PIN_B = 14


class RGBLed:
    def __init__(self, pin_r, pin_g, pin_b):
        self.pin_r = machine.PWM(machine.Pin(pin_r))
        self.pin_g = machine.PWM(machine.Pin(pin_g))
        self.pin_b = machine.PWM(machine.Pin(pin_b))
        self.set(0, 0, 0)

    def set(self, r, g, b):
        self.r = int(r)
        self.g = int(g)
        self.b = int(b)
        self.duty()

    def duty(self):
        self.pin_r.duty(self.duty_translate(self.r))
        self.pin_g.duty(self.duty_translate(self.g))
        self.pin_b.duty(self.duty_translate(self.b))

    def duty_translate(self, n):
        """translate values from 0-255 to 0-1023"""
        return int((float(n) / 255) * 1023)


def get_url(conn):
    conn_file = conn.makefile('rb', 0)
    method, url = None, None
    while True:
        line = conn_file.readline().decode()
        if not line or line == '\r\n':
            break
        if line.startswith('GET'):
            method, url, _ = line.split()
    return method, url

def parse_url(url):
    try:
        path, query = url.split('?', 2)
    except:
        return url, {}
    return path, {_.split('=')[0]: _.split('=')[1] for _ in query.split('&amp;')}

def conn_send(conn, response):
    total_sent = 0
    while total_sent &lt; len(response):
        sent = conn.send(response[total_sent:])
        if sent == 0:
            raise RuntimeError('Socket connection broken')
        total_sent = total_sent + sent

led = RGBLed(PIN_R, PIN_G, PIN_B)

s = socket.socket()
s.bind(ADDR)
s.listen(1)

print('RGBLamp daemon started on %s:%s' % ADDR)

while True:
    conn, addr = s.accept()
    method, url = get_url(conn)
    path, query = parse_url(url)
    print(addr[0], '-', method, url)
    if path == '/':
        if [_ for _ in list('rbg') if _ in query.keys()]:
            led.set(query.get('r', 0), query.get('g', 0), query.get('b', 0))
        response = template.html % (led.r, led.g, led.b)
        conn_send(conn, response)
    conn.close()
</code>


<h2>Servo sg90</h2>

<p>The sg90 servo has three wires: brown (gnd), red (vcc), and yellow (signal). The vcc is the power source for the servo, and it has to be connected to the vin pin of our board – this way it is connected directly to the USB port, and not powered through the board.</p>
<p><img src="https://raw.githubusercontent.com/lvidarte/esp8266/master/examples/sg90/sg90.png"></p>
<p>The signal wire tells the servo what position it should move to, using a 50Hz PWM signal. The center is at around 77, and the exact range varies with the servo model, but should be somewhere between 30 and 122, which corresponds to about 180° of movement. Note that if you send the servo a signal that is outside of the range, it will still obediently try to move there – hitting a mechanical stop and buzzing loudly. If you leave it like this for longer, you can damage your servo, your board or your battery, so please be careful.</p>
<p>So now we are ready to try and move it to the center position:</p>
<code>from machine import Pin, PWM
servo = PWM(Pin(14), freq=50, duty=77)
</code>
<p>Then we can see where the limits of its movement are:</p>
<code>servo.duty(30)
servo.duty(122)
</code>
<p>Ref: <a href="http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms" rel="nofollow">http://micropython-on-esp8266-workshop.readthedocs.io/en/latest/basics.html#servomechanisms</a></p>


<h2>使用MicroPython从ESP板发送数据到Google表格</h2>

<a href="https://blog.gypsyengineer.com/en/diy-electronics/micropython-on-esp32-sending-data-to-google-sheets.html">esp32 sending data to google sheets</a>

Google表格提供了很棒的HTTP API，为什么我们不能只发送一个POST请求来将数据插入到工作表中？

原因是Google表格API关注安全性并需要身份验证。

特别是，Google Sheet API支持两种身份验证方法：API密钥和OAuth2令牌。

使用API密钥听起来很简单：
我们可以在Google IAM控制台中创建一个API密钥，在我们的ESP板上编码，忘记旋转密钥和安全性，并永远使用密钥。

不幸的是（或者说幸运的是）它不会起作用。
Google Sheet API仅允许API键进行读取操作。

如果要写入工作表，则必须使用OAuth2。这里出现了问题。
首先，您需要在Google IAM控制台中创建一个服务帐户，然后为该服务帐户创建一个私有RSA密钥。

好的，那并不难。
然后，您的ESP板必须构建一个JWT请求，将当前时间戳放入其中，并使用RSA-SHA256签名算法使用密钥对请求进行签名。
接下来，板子必须将签名的JWT请求发送到Google OAuth2服务，该服务最终返回OAuth2令牌。
最后使用令牌来调用Google表格API。
让我快速总结一下ESP板能够在Google表格中插入一行需要的内容：
HTTP客户端、JSON解析器、具有正确时间的实时时钟或NTP客户端，以及RSA-SHA256签名的实现算法。

幸运的是，MicroPython提供了除RSA-SHA256签名之外的大部分内容。
确切地说，MicroPython可以计算SHA256哈希，但不能使用RSA算法对数据进行签名。

此外，RSA签名是一项昂贵的操作，可能需要相当多的时间和内存，但ESP板并不像PC那么强大，也没有太多的内存。

我猜想Google身份验证带来的复杂性以及缺少MicroPython的RSA，让人们使用了一个公开的表单或一个可以实现认证过程的中间件服务。

当然，作为一名安全工程师，我无法接受一个包含公共可用表格的解决方案，其中包含我房间内温度和湿度等敏感数据。

因为我是一名安全工程师，所以我不喜欢中间件。

最后，唯一的选择是以某种方式在ESP板上实现上述认证过程。

正如我之前提到的，MicroPython已经提供了大部分必需的东西：
ujson允许解析JSON
ntptime.py提供NTP客户端
uhashlib可以计算SHA256哈希值
http.client提供了一个HTTP客户端

唯一缺少的部分是RSA签名。

密码学的一个主要规则是：不要自己实现任何加密算法，而是使用现有的算法。

我知道这个规则，并发现python-rsa包在纯Python中实现了RSA算法。

除了使用RSA进行签名之外，该库还支持其他操作，例如验证签名，加密和解密，加载和存储密钥等。

这个库对于一个小型的ESP板来说负担太重了，我决定只保留RSA签名的实现并删除剩下的代码。
我甚至删除了以PKCS1格式加载RSA密钥的代码，因为它需要移植一个不小的pyasn1包。
我还必须基于从右到左的二进制方法和其他一些操作来实现模块化求幂，因为事实证明它们不是由MicroPython提供的。
它产生了一个新的micropython-rsa签名库。

我使用ESP8266和MicroPython以前的一个项目作为起点。

在实施身份验证过程并在我的笔记本电脑上进行测试后，我终于成功用ESP8266主板运行了代码。

不幸的是我发现代码运行得很慢，主要问题是ESP8266主板没有足够的内存来完成RSA签名。
我尝试了一些优化，甚至尝试将应用程序代码嵌入到MicroPython固件中，但没有任何帮助。

最后的希望是在ESP32上运行代码。
我之前没有用过ESP32，于是订购了我的第一个ESP32开发板。
幸运的是，它成功了！

应用程序不再抱怨内存不足，事实上它运行得更快了。

该代码可在GitHub上获得。
README简要描述了如何构建项目。
我还在Hackaday.io上创建了一个项目。
我希望我能找到一些时间在后续帖子中提供更多细节。
https://github.com/artem-smotrakov/esp32-weather-google-sheets

<h2>timers_and_interrupts_timer</h2>

from machine import Pin, Timer

led = Pin(5, Pin.OUT)
led.value(0)

timer = Timer(-1)
timer.init(period=1000, mode=Timer.PERIODIC, callback=lambda t:led.value(not led.value()))


<h2>timers_and_interrupts_interrupt</h2>

from machine import Pin

led = Pin(5, Pin.OUT)

button = Pin(4, Pin.IN, Pin.PULL_UP)
button.irq(trigger=Pin.IRQ_FALLING, handler=lambda t:led.value(not led.value()))

<h2>timers_and_interrupts_debounce</h2>

from machine import Pin

led = Pin(5, Pin.OUT)
button = Pin(4, Pin.IN, Pin.PULL_UP)

def debounce(pin):
    prev = None
    for _ in range(32):
        current_value = pin.value()
        if prev != None and prev != current_value:
            return None
        prev = current_value
    return prev


def button_callback(pin):
    d = debounce(pin)

    if d == None:
        return
    elif not d:
        led.value(not led.value())
        
button.irq(trigger=Pin.IRQ_FALLING, handler=button_callback)


<h2>Pwm and Adc with a Nodemcu and Micropython</h2>
https://micronote.tech/2020/02/PWM-and-ADC-with-a-NodeMCU-and-MicroPython/

from machine import Pin, PWM, ADC, Timer

POT_LOWER_EXTREME = 18
POT_UPPER_EXTREME = 1024

pwm_led = PWM(Pin(5), freq=1000)
pot = ADC(0)

def pot_percent(val, lower_limit, upper_limit):
    if val > upper_limit:
        val = upper_limit
    elif val < lower_limit:
        val = lower_limit
        
    total_range = upper_limit - lower_limit
    
    return (val-lower_limit)/total_range

def set_dimmer(pin):
    pwm_led.duty(int(pot_percent(pot.read(), POT_LOWER_EXTREME, POT_UPPER_EXTREME) * 1023))

timer = Timer(-1)
timer.init(period=100, mode=Timer.PERIODIC, callback=set_dimmer)

<h2>6 axis</h2>
<a href="http://smoothieware.org/6axis" class="whitebut ">6axis</a>
<a href="https://github.com/custom-build-robots/6-Axis-Desktop-Robotic-Arm-Raspberry-Pi" class="whitebut ">Robotic-Arm-Raspberry</a>
<a href="https://github.com/mechiris/RobotControl" class="whitebut ">RobotControl</a>

Smoothieboard can be made to work for more than 3 axes.

We are not talking about extruders here ( these are supported separately, see <a href="https://smoothieware.org/extruder" class="wikilink1" title="extruder" data-wiki-id="extruder">Extruder</a> ), but rotational axes, like those for example used for 4 or 5 axis machining.

This feature is one of the rare ones that requires compiling Smoothie. 
Because it increases the size of the movement planning queue significantly, we were unfortunately not able to fit it in the “normal” firmware.

There are two resources that were written about this feature when it was released that you might want to read :

<a href="https://github.com/Smoothieware/Smoothieware/pull/1055" class="urlextern" title="https://github.com/Smoothieware/Smoothieware/pull/1055" rel="ugc nofollow">ABC pull request</a> on github.

<a href="https://github.com/Smoothieware/Smoothieware/blob/edge/upgrade-notes.md" class="urlextern" title="https://github.com/Smoothieware/Smoothieware/blob/edge/upgrade-notes.md" rel="ugc nofollow">Smoothie&#039;s upgrade notes</a>

<h4>Workpiece Coordinate System</h4><strong>NOTE</strong> that currently WCS is not supported for ABC axis (G10 L2…). 
G92 A0 resets the A axis and does not set the WCS for it (same for B and C).

<h4>Extruders</h4><strong>NOTE</strong> You cannot define extruders AND ABC axis they are mutually exclusive and smoothie will not run if they are both defined.

<h3 class="sectionedit2" id="compiling-6-axis">Compiling 6 axis.</h3>

Before attempting this, please read <a href="https://smoothieware.org/compiling-smoothie" class="wikilink1" title="compiling-smoothie" data-wiki-id="compiling-smoothie">compiling smoothie</a>, and compile Smoothie “normally” for practice.

Once that is done ( and only once that is done ), you need to do the same process, but instead of doing 

make

You now do : 

make clean
make AXIS=6 CNC=1

You can change this number to 5 or 4 if you do not need all 6 axes. 
It saves memory and allows you to use more of it for other things.

By default, Smoothie calculates distances only on the first three ( XYZ ) axes. 
You can change this behavior by setting the <kbd class="__keyboard">PAXIS</kbd> compilation parameter, for example:

make AXIS=5 PAXIS=4 CNC=1

Means Smoothie is compiled with XYZAB axes, and distances are calculated in the XYZA space.

<h4>Primary Axes</h4><strong>NOTE</strong> that in most cases you <strong>DO NOT</strong> need to set PAXIS. 
Only do this if you fully understand the difference between a Cartesian (primary) axis and say a rotary axis.

Once your firmware is compiled, you can now flash it to the board and start using it.

<h3 class="sectionedit3" id="using-additional-axes">Using additional axes</h3>

<h4>XYZ first</h4><strong>NOTE</strong> You MUST fully define the alpha, beta and gamma (XYZ) axis before the other axis. 
They MUST have valid pin definitions for the step and dir pins (enable is optional) If you do not define valid pins for these first three axis smoothie will not boot.

You can now add the following to your configuration file :

# A axis
delta_steps_per_mm                    100     # may be steps per degree for example
delta_step_pin                               xx              # Pin for delta stepper step signal
delta_dir_pin                                xx             # Pin for delta stepper direction
delta_en_pin                                 xx             # Pin for delta enable
delta_current                                1.5              # Z stepper motor current
delta_max_rate                               300.0            # mm/min
delta_acceleration                          500.0            # mm/sec²

# B axis
epsilon_steps_per_mm                    100     # may be steps per degree for example
epsilon_step_pin                              xx              # Pin for delta stepper step signal
epsilon_dir_pin                                xx             # Pin for delta stepper direction
epsilon_en_pin                                xx             # Pin for delta enable
epsilon_current                                1.5              # Z stepper motor current
epsilon_max_rate                               300.0            # mm/min
epsilon_acceleration                          500.0            # mm/sec²

# C axis
zeta_steps_per_mm                    100     # may be steps per degree for example
zeta_step_pin                               xx              # Pin for delta stepper step signal
zeta_dir_pin                                xx             # Pin for delta stepper direction
zeta_en_pin                                 xx             # Pin for delta enable
zeta_current                                1.5              # Z stepper motor current
zeta_max_rate                               300.0            # mm/min
zeta_acceleration                          500.0            # mm/sec²

This configuration is very similar to that of your XYZ axes, and you need to change the values to fit your setup.

Optionally if you are using endstops on the A, B or C axis, you need to <strong>replace</strong> your endstops section with the following ( it is also found in the <a href="https://github.com/Smoothieware/Smoothieware/blob/edge/ConfigSamples/Snippets/abc-endstop.config" class="urlextern" title="https://github.com/Smoothieware/Smoothieware/blob/edge/ConfigSamples/Snippets/abc-endstop.config" rel="ugc nofollow">snippets example</a> ) :

<h4>Only for more than 3 axes</h4><strong>NOTE</strong> DO NOT use the following syntax if you only have XYZ axis! use the regular endstop config syntax.

<h4>Hand in hand</h4><strong>NOTE</strong> If you define a homing axis then there MUST be a defined axis with the same designation (eg B endstop MUST have B axis defined)

<strong>NOTE</strong> The ABC axis will always home after the XYZ axis home and will home individually, unless homing_order is defined in which case all axis will home individually in the order specified.

## Endstops new syntax (the name is not significant)
# NOTE only a min or a max homing endstop maybe defined
endstop.minx.enable                          true             # enable an endstop
endstop.minx.pin                             1.24             # pin
endstop.minx.homing_direction                home_to_min      # direction it moves to the endstop
endstop.minx.homing_position                 0                # the cartesian coordinate this is set to when it homes
endstop.minx.axis                            X                # the axis designator
endstop.minx.max_travel                      500              # the maximum travel in mm before it times out
endstop.minx.fast_rate                       50               # fast homing rate in mm/sec
endstop.minx.slow_rate                       25               # slow homing rate in mm/sec
endstop.minx.retract                         5                # bounce off endstop in mm

# uncomment for homing to max and comment the minx above
#endstop.maxx.enable                          true             # enable an endstop
#endstop.maxx.pin                             1.25             # pin
#endstop.maxx.homing_direction                home_to_max      # direction it moves to the endstop
#endstop.maxx.homing_position                 200              # the cartesian coordinate this is set to when it homes
#endstop.maxx.axis                            X                # the axis designator
#endstop.maxx.max_travel                      500              # the maximum travel in mm before it times out
#endstop.maxx.fast_rate                       50               # fast homing rate in mm/sec
#endstop.maxx.slow_rate                       25               # slow homing rate in mm/sec
#endstop.maxx.retract                         5                # bounce off endstop in mm

endstop.miny.enable                          true             # enable an endstop
endstop.miny.pin                             1.26             # pin
endstop.miny.homing_direction                home_to_min      # direction it moves to the endstop
endstop.miny.homing_position                 0                # the cartesian coordinate this is set to when it homes
endstop.miny.axis                            Y                # the axis designator
endstop.miny.max_travel                      500              # the maximum travel in mm before it times out
endstop.miny.fast_rate                       50               # fast homing rate in mm/sec
endstop.miny.slow_rate                       25               # slow homing rate in mm/sec
endstop.miny.retract                         5                # bounce off endstop in mm

# uncomment for homing to max and comment the min above
#endstop.maxy.enable                          true             # enable an endstop
#endstop.maxy.pin                             1.27             # pin
#endstop.maxy.homing_direction                home_to_max      # direction it moves to the endstop
#endstop.maxy.homing_position                 200              # the cartesian coordinate this is set to when it homes
#endstop.maxy.axis                            Y                # the axis designator
#endstop.maxy.max_travel                      500              # the maximum travel in mm before it times out
#endstop.maxy.fast_rate                       50               # fast homing rate in mm/sec
#endstop.maxy.slow_rate                       25               # slow homing rate in mm/sec
#endstop.maxy.retract                         5                # bounce off endstop in mm

endstop.minz.enable                          true             # enable an endstop
endstop.minz.pin                             1.28             # pin
endstop.minz.homing_direction                home_to_min      # direction it moves to the endstop
endstop.minz.homing_position                 0                # the cartesian coordinate this is set to when it homes
endstop.minz.axis                            Z                # the axis designator
endstop.minz.max_travel                      100              # the maximum travel in mm before it times out
endstop.minz.fast_rate                       10               # fast homing rate in mm/sec
endstop.minz.slow_rate                       2                # slow homing rate in mm/sec
endstop.minz.retract                         5                # bounce off endstop in mm

# uncomment for homing to max and comment the min above
#endstop.maxz.enable                          true             # enable an endstop
#endstop.maxz.pin                             1.29             # pin
#endstop.maxz.homing_direction                home_to_max      # direction it moves to the endstop
#endstop.maxz.homing_position                 200              # the cartesian coordinate this is set to when it homes
#endstop.maxz.axis                            Z                # the axis designator
#endstop.maxz.max_travel                      100              # the maximum travel in mm before it times out
#endstop.maxz.fast_rate                       10               # fast homing rate in mm/sec
#endstop.maxz.slow_rate                       2                # slow homing rate in mm/sec
#endstop.maxz.retract                         5                # bounce off endstop in mm

# optional enable limit switches, actions will stop if any enabled limit switch is triggered
#endstop.minx.limit_enable                   false            # set to true to enable the limit on this endstop
#endstop.miny.limit_enable                   false            # set to true to enable the limit on this endstop
#endstop.minz.limit_enable                   false            # set to true to enable the limit on this endstop

# also define the pin needed and the Axis designator if limit on a max pin not defined above
#endstop.maxx.enable                          true             # enable an endstop
#endstop.maxx.pin                             1.25             # pin
#endstop.maxx.limit_enable                    true             # set to true to enable the limit on this endstop
#endstop.maxx.axis                            X                # the axis designator

# OPTIONAL uncomment for homing the A axis to min
#endstop.mina.enable                          true             # enable an endstop
#endstop.mina.pin                             1.29             # pin
#endstop.mina.homing_direction                home_to_min      # direction it moves to the endstop
#endstop.mina.homing_position                 200              # the cartesian coordinate this is set to when it homes
#endstop.mina.axis                            A                # the axis designator
#endstop.mina.max_travel                      100              # the maximum travel in mm before it times out
#endstop.mina.fast_rate                       10               # fast homing rate in mm/sec
#endstop.mina.slow_rate                       2                # slow homing rate in mm/sec
#endstop.mina.retract                         5                # bounce off endstop in mm

# type of machine
#corexy_homing                               false            # set to true if homing on a hbot or corexy

# optional order in which axis will home, default is they all home at the same time,
# if this is set it will force each axis to home one at a time in the specified order
#homing_order                                 XYZ              # x axis followed by y then z last
#move_to_origin_after_home                    false            # move XY to 0,0 after homing
#endstop_debounce_count                       100              # uncomment if you get noise on your endstops, default is 100
#endstop_debounce_ms                          1                # uncomment if you get noise on your endstops, default is 1 millisecond debounce
#home_z_first true # uncomment and set to true to home the Z first, otherwise Z homes after XY

<a href="http://mpy-tut.zoic.org/tut/motors.html" class="whitebut ">motors</a>
<a href="https://forum.micropython.org/viewtopic.php?t=6477" class="whitebut ">Pyboard 6V DC motors</a>
<a href="http://techawarey.com/programming/micropython/servo-motor-control-using-micropython/" class="whitebut ">Servo Motor control using MicroPython</a>

<br>
<br>
<br>
<br>

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre>
</body>
</html>
