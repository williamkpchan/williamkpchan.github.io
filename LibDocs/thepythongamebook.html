<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>

<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, strong,  div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {display: inline-block; margin-top: 2%;margin-bottom: 1%;}
</style>
</head>
<body onkeypress="chkKey()">
<center><h1>Pygame tutorial</h1>
<div id="toc"></div></center>
<br>
<br>
<br>
<pre>

<h1 class="title">Step 000 - Installation, Documentation and Examples</h1>

<h2>- Installation</h2>

<h3>install python</h3>

Pygame is not shipped together with <a href="http://www.pygame.org/download.shtml">Python</a>, it is a 3rd-party-package. 
To install it on your computer you need a version of <a href="http://www.python.org">Python</a> installed correctly on your computer that works good together with Pygame:
Python2.x (recommended)  
or Python 3.x (experimental) 

&lt;note warning&gt;from <a href="http://www.pygame.org/wiki/FrequentlyAskedQuestions">Pygame FAQ</a>:  <strong>Does Pygame work with Python 3?</strong> <br/>
Mostly yes. 
Only the scrap, _movie, surfarray for Numeric, and threads modules have not been ported. 
The Pygame alternative, pgreloaded (Pygame Reloaded), also supports Python 3.
&lt;/note&gt;

<h3>Install Pygame</h3>
	
Linux  Users of <a href="http://www.ubuntulinux.org/">Ubuntu Linux</a> can type: <code>sudo apt-get install python-pygame</code> or install pygame using synaptic or the ubuntu software center. 

Windows  Install pygame from <a href="http://www.pygame.org/download.shtml">http://www.pygame.org/download.shtml</a> 
Mac  Install pygame from <a href="http://www.pygame.org/download.shtml">http://www.pygame.org/download.shtml</a> 
source  installing from source : <a href="http://www.pygame.org/download.shtml">http://www.pygame.org/download.shtml</a> 

<h2>- documentation</h2>
<a href="/_detail/en:part2:pygame:pygame-docs-offline.jpg?id=en%3Apygame%3Astep000"><img src="http://thepythongamebook.com/_media/en:part2:pygame:pygame-docs-offline.jpg?w=350&amp;tok=d24ce1"></a>
You can view the pygame documentation online at:
<a href="http://www.pygame.org/docs/">http://www.pygame.org/docs/</a>

If you have no internet access, you can still read pygame&#039;s documentation offline in your browser. 
Just open the file <code>index.html</code> in pygame&#039;s <code>docs</code> folder. 
 The File should be located inside your python installation: <code>/dist-packages/pygame/docs/index.html</code>
Linux  <code>/usr/lib/python2.6/dist-packages/pygame/docs/index.html</code> 
Windows  ? 
Mac  ? 

<h2>- Examples</h2>
pygame will install a bunch of highly useful examples inside the folder <code>/dist-packages/pygame/examples</code>. 
It is a good idea to copy the whole <code>example</code> folder (including his sub-folders <code>data</code> and <code>macosx</code>) to another location like to your desktop. 
In that way, you can modify all pygame examples without destroying the originals.

A short description of each pygame example can be found at pygames documentation homepage:

<a href="http://www.pygame.org/docs/ref/examples.html">http://www.pygame.org/docs/ref/examples.html</a>

<h4 id="enjoy">Enjoy</h4>
<a href="/_detail/en:part2:pygame:aliens.jpg?id=en%3Apygame%3Astep000"><img src="http://thepythongamebook.com/_media/en:part2:pygame:aliens.jpg?w=350&amp;tok=212c4b"></a>
Now it is time to enjoy your successfull installation of python and pygame. 
How about a round of mindless alien shooting ?

Open a terminal and type: 
python -m pygame.examples.aliens

<h2>- The Editor and Other Tools</h2>

<h4 id="text_editor">Text Editor</h4>
To modify the python source code files (<strong>.py</strong>) in your favourite text editor, make sure that you are able to load, modify and start python files using your editor. 
Try to open and start the aliens example from within your text editor. 
Every <abbr title="Operating System">OS</abbr> is shipped with at least one very simple text editor, and python usually installs the IDLE text editor on your system. 
For a list of text editors and IDE and their features see <a href="http://wiki.python.org/moin/PythonEditors">http://wiki.python.org/moin/PythonEditors</a>

<h4 id="graphic_editor">Graphic Editor</h4>
For the next chapters, it is helpful if you know how to paint and modify images, especially in the <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">.png</a> format. 
Most image editors / viewers can display those graphics (even your webbrowser) but not every image editor can handle transparency (transparent backgrounds). 


You can download and install the free and open source image editor <a href="https://en.wikipedia.org/wiki/GIMP">GIMP</a> for every operation system, althoug you will only need very few of it&#039;s functions for the next chapters. 
A simple image viewer with rudimentary editing functions such as <a href="https://en.wikipedia.org/wiki/IrfanView">IrfanView</a> for Windows or <a href="https://en.wikipedia.org/wiki/gthumb">gthumb</a> for Linux may be sufficient.

<h4 id="sound">Sound</h4>
For the next chapters, it is helpful if you can generate and manipulate (and record!) sound effects on your computer. 
You need functions to cut parts of recorded sound effects and ideally a noise reduction. 
Both functions are provided by the free and open source program <a href="https://en.wikipedia.org/wiki/audacity">audacity</a>, wich can also generate sounds.

For an specific sound effect generator, you may try out <a href="http://www.drpetter.se/project_sfxr.html">http://www.drpetter.se/project_sfxr.html</a>

<h2>- Download from Github</h2>
Source code examples and other necessary files like graphics and sounds will be hosted not on this wiki, but instead on <a href="https://en.wikipedia.org/wiki/github">github</a>. 
While it is not necessary to create an account at github.com to download all code examples for this book, it may be useful if you want to publish your edits / comments back into this wiki.

What you should know however is how to download code and files directly from github:

Open this <abbr title="Uniform Resource Locator">URL</abbr> in your browser: <a href="https://github.com/horstjens/ThePythonGameBook">https://github.com/horstjens/ThePythonGameBook</a>
and click on the big <strong>Downloads</strong> icon.
choose <strong>Download .tar.gz</strong> for Linux, or <strong>Download .zip</strong> for Windows
extract the archive file on your Desktop. 
All neccessary files for the next chapters are inside the <code>pygame</code> folder 

<a href="/_detail/en:part2:pygame:github1_bunt.jpg?id=en%3Apygame%3Astep000"><img src="http://thepythongamebook.com/_media/en:part2:pygame:github1_bunt.jpg?w=800&amp;tok=3c1e60"></a>  
<a href="/_detail/en:part2:pygame:github2mini.jpg?id=en%3Apygame%3Astep000">
<img src="http://thepythongamebook.com/_media/en:part2:pygame:github2mini.jpg"></a>  

Now you are ready, start with <a href="/en:pygame:step001">step001</a> and write your first pygame program ! 
<h1 class="title">Step 001 - Pygame Basics</h1>
<a href="https://en.wikipedia.org/wiki/flip_book"><img src="http://thepythongamebook.com/_media/en:part2:flip-book.jpg"></a>
The next few code examples demonstrate how to set up a working pygame program and move <strong>surfaces</strong> or <strong>sprites</strong> (2-dimensional shapes) around.

The important thing to understand is that (in those pygame examples) there is no real movement. 
In fact, what you see as movement is an illusion only happening in your brain. 
What you do see is a fast sequence of images, beamed at you from your computer monitor. 


The same happens if you watch TV, cinema or even a <a href="https://en.wikipedia.org/wiki/flip_book">flip book</a> - or any computer game. 
You see lots of similar pictures at a high frequency or <a href="https://en.wikipedia.org/wiki/frame_rate">frame rate</a> (like 60 pictures per second). 
If you see, let&#039;s say, a picture of a blue ball in the upper left corner in the first picture (or frame) and thus at each following picture (frame) the ball is a bit more right than in the previous picture, you think that the ball is moving from left to right.

<h4 id="code_discussion_and_source_code">Code Discussion and Source Code</h4>
In the next chapters (steps) you can always expect a short code discussion where the new concepts and matching code lines are explained followed by the complete source code example at the end of the page. 
The discussion of the code is written <em>before</em> the complete source code because the source code examples tend to be rather long.

For best results do not copy &amp; paste the source code examples but instead click on the name of the source code example (on top of the source code) to download and save it. 
If your browser or operating system allows you to open the source code example directly with a Python editor like geany or IDLE you can run the code examples directly from your editor.
<h1 class="title">Step 002 - Window and Framerate</h1>

This first pygame example is very simple: It opens a window and displays the <a href="https://en.wikipedia.org/wiki/frame_rate">frame rate</a>. 
You can close
the program by pressing the ESCAPE key (on the top left of most keyboards) or by clicking on the close button in the window menubar.

<br/>

<a href="/_detail/en:part2:pygame:002horst.jpg?id=en%3Apygame%3Astep002"><img src="http://thepythongamebook.com/_media/en:part2:pygame:002horst.jpg?w=300&amp;tok=2450bb"></a>    <a href="/_detail/en:part2:pygame:002yip.jpg?id=en%3Apygame%3Astep002"><img src="http://thepythongamebook.com/_media/en:part2:pygame:002yip.jpg?w=300&amp;tok=c6c0de"></a>  
Screenshot of 002_display_fps.py    Screenshot of the improved variant 002_display_fps_pretty.py  

<h4 id="where_is_the_source_code">Where Is the Source Code ?</h4>
The source code example to this “step” is always at the end of the page, at <a href="http://thepythongamebook.com/en:part2:pygame:step002?&amp;#source_code_on_github">source code on github</a>. 
The reason is that source code examples can be several 100 lines long and (like in this case) come in several variants or include several files. 
In ThePythonGameBook the full source code is always the last heading on a page.


<h3>Code Discussion</h3>
<h4 id="allow_special_chars">Allow Special Chars</h4>
The first line is a very special kind of comment. 
If written in the first or second line, 
it allows the use of (national) special characters<sup><a href="#fn__1" id="fnt__1">1)</a></sup> inside strings and comments in python2.x 
This special comment structure is no longer necessary in python3.x 
<span># -*- coding: utf-8 -*-</span>

<h4 id="multi-line_docstring">Multi-Line Docstring</h4>
A docstring in triple quotes allows you to span a comment over several lines. 
Use comments to describe what the program should do. 
This cannot be overstated, use comments to describe what the code is supposed to do. 
You can also provide an email address, a project webpage  or information about the author.
<span>&quot;&quot;&quot;The following program simplifies
gimmicks and enhances unicorns.&quot;&quot;&quot;</span>

The docstring with triple quotes explains what the program does.

<h4 id="import_and_start_pygame">Import and Start Pygame</h4>
Because pygame is not yet included into python it must be <a href="http://www.pygame.org">correctly installed</a> and imported. 
During this wiki book I will always write <code>import pygame</code> and never <code>import pygame as pg</code> or <code>from pygame import *</code>. 

<span>import</span> pygame
pygame.<span>init</span><span>&#40;</span><span>&#41;</span>

<h4 id="screen_and_background">Screen and Background</h4>
The visible pygame window is called <strong>screen</strong> (in nearly all pygame code examples) and it describes what you see.
Pygame has lot of commands to create and handle rectangular graphical areas, called pygame surfaces. 
Imagine a sheet of paper or a napkin, where you can draw or write. 
If you glue (blit) those papers on a single page of a <a href="https://en.wikipedia.org/wiki/flip_book">flip_book</a> (the <strong>screen</strong>) you would make them visible.

In this code example, the background surface is filled with white colour - pygame colours are always tuples of (red, green, blue) values where each value can be an integer from 0 to 255. 
The tuple (255,0,0) describes the red color (full red and nothing else), while all colours together (255,255,255) describe white. 
Black is (0,0,0). 


After painting and writing on a surface but before blitting the surface it is a good idea to <code>.convert()</code> the surface. 
This helps pygame to store the surface in memory optimized for fast blitting. 
Note that surfaces with transparency need <code>.convert_alpha()</code> instead.
screen <span>=</span> pygame.<span>display</span>.<span>set_mode</span><span>&#40;</span><span>&#40;</span><span>640</span><span>,</span><span>480</span><span>&#41;</span><span>&#41;</span> <span># Set screen size of pygame window</span>
background <span>=</span> pygame.<span>Surface</span><span>&#40;</span>screen.<span>get_size</span><span>&#40;</span><span>&#41;</span><span>&#41;</span>  <span># Create empty pygame surface</span>
background.<span>fill</span><span>&#40;</span><span>&#40;</span><span>255</span><span>,</span><span>255</span><span>,</span><span>255</span><span>&#41;</span><span>&#41;</span>     <span># Fill the background white color (red,green,blue)</span>
background <span>=</span> background.<span>convert</span><span>&#40;</span><span>&#41;</span>  <span># Convert Surface to make blitting faster</span>

<h4 id="blitting_the_background">Blitting the Background</h4>
After creating the background surface (and filling it with white color) this surface is not visible by itself. 
Only after blitting (~painting) it to the visible <strong>screen</strong> surface you actually see the white background. 
If you comment out this line you will see a black window only - freshly created surfaces like the screen are black by default.
screen.<span>blit</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span> <span>0</span><span>&#41;</span><span>&#41;</span>

Here, the destination surface is &#039;screen&#039; on which you blit the surface &#039;background&#039; to position (0, 0)
so that the upper left corner of &#039;background&#039; is on position (0, 0) on the &#039;screen&#039; surface. 


<h4 id="event_handler">Event Handler</h4>
Pygame creates a lot of events all the time (the mouse is moved, a key is pressed etc). 
You can react on those events with an event handler like the following example.
If a key is pressed, the Pygame event queue registers a KEYDOWN event. 
There exists another method to ask what keys are pressed at the moment, see the next examples. 
The Pygame documentation at <a href="http://www.pygame.org/docs/ref/key.html">http://www.pygame.org/docs/ref/key.html</a> lists all valid keyboard constants.
<span>for</span> event <span>in</span> pygame.<span>event</span>.<span>get</span><span>&#40;</span><span>&#41;</span>:
   <span>if</span> event.<span>type</span> <span>==</span> pygame.<span>QUIT</span>: 
       mainloop <span>=</span> <span>False</span> <span># pygame window closed by user</span>
   <span>elif</span> event.<span>type</span> <span>==</span> pygame.<span>KEYDOWN</span>:
       <span>if</span> event.<span>key</span> <span>==</span> pygame.<span>K_ESCAPE</span>:
           mainloop <span>=</span> <span>False</span> <span># user pressed ESC</span>

<h4 id="understanding_time">Understanding Time</h4>
The object <code>pygame.time.Clock()</code> (which will be stored in the variable <code>clock</code>) has a method <code>tick()</code> which returns the amount of milliseconds passed since the last frame.
Inside the mainloop, the code:
milliseconds <span>=</span> clock.<span>tick</span><span>&#40;</span>FPS<span>&#41;</span> <span># do not go faster than this framerate</span>

stores the number of milliseconds into the variable <code>milliseconds</code>.
The next code line
playtime +<span>=</span> milliseconds / <span>1000.0</span> <span># add seconds to playtime</span>

calculates the number of seconds passed (by dividing by 1000.0) and increases the value of the variable <code>playtime</code>.

<h3>Ideas</h3>

Change the screen resolution.
Try blitting the background in the middle of the screen, not in the topleft corner.
See <a href="/en:resources:glossary:p:pygame:keycodes">keycodes</a> and let the program print something as soon as you press the &lt;key&gt;space&lt;/key&gt; key.

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/event.html#pygame.event.get">http://www.pygame.org/docs/ref/event.html#pygame.event.get</a>
<a href="http://www.pygame.org/docs/ref/time.html">http://www.pygame.org/docs/ref/time.html</a>
<a href="http://www.pygame.org/docs/ref/key.html">http://www.pygame.org/docs/ref/key.html</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.fill">http://www.pygame.org/docs/ref/surface.html#Surface.fill</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.blit">http://www.pygame.org/docs/ref/surface.html#Surface.blit</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.convert">http://www.pygame.org/docs/ref/surface.html#Surface.convert</a>

<h3>Source Code on Github</h3>
To run both variants of this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th><th>  comment  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/002_display_fps.py">002_display_fps.py</a>    pygame    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>    simple version  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/002_display_fps_pretty.py">002_display_fps_pretty.py</a>    pygame    OOP version  

There exist 2 code examples, a simple example from <a href="/en:resources:people:jens_horst:start">Horst</a> and an object oriented variant of <a href="/en:resources:people:yipyip:start">yipyip</a>. 
Both versions have a similar functionality but implement this in a different manner. 
If you are new to python/pygame programming and have not yet worked with the <strong>class</strong> command you may want to try out the simple variant and come back if you are more familiar with>
<h3>Simple Version</h3>

This is the most basic meaningful pygame program. 
No fancy stuff.

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/002_display_fps.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/002_display_fps.py</a>
<h3>OOP Version</h3>

An object orientated version, which uses the pygame.font module for displaying
frame rate and game duration as text. 

(See also <a href="/en:pygame:step012">→pygame text</a>)
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/002_display_fps_pretty.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/002_display_fps_pretty.py</a>
<em>Click reload in your browser if you see no code.</em>

<br/>
	


<h1 class="title">Step 003 - Surfaces and Drawing</h1>

<a href="/_detail/en:part2:step003.jpg?id=en%3Apygame%3Astep003"><img src="http://thepythongamebook.com/_media/en:part2:step003.jpg?w=300&amp;tok=b66adf"></a>   <a href="/_detail/en:part2:pygame:003pretty.jpg?id=en%3Apygame%3Astep003"><img src="http://thepythongamebook.com/_media/en:part2:pygame:003pretty.jpg?w=300&amp;tok=fd9fb8"></a>  
Screenshot of 003_static_blit.py    Screenshot of the improved variant 003_static_blit_pretty.py  

This program is blitting two different pygame surfaces into the pygame window (called <strong>screen</strong>):
The (white) background surface and
the (blue-black) ball surface

Unlike the usual <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">Cartesian_coordinate_system</a>, Pygame use an x,y coordinates system where the position (0,0) is defined as the top left corner of the screen. 
Moving down means having a higher y value, moving to the right means having a higher x value.
<a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system"><img src="http://thepythongamebook.com/_media/en:part2:cartesian-coordinates2.png"></a>     vs. 
   <a href="/_detail/en:part2:pygame-coordinates2.png?id=en%3Apygame%3Astep003"><img src="http://thepythongamebook.com/_media/en:part2:pygame-coordinates2.png"></a>  
<a href="https://en.wikipedia.org/wiki/René_Descartes">Cartesian</a> <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system">coordinate system</a>. 
The point (0,0) is in the middle    <a href="https://en.wikipedia.org/wiki/Pygame">Pygame</a> coordinate system. 
The point (0,0) is in the top left corner  


<h3>Code Discussion</h3>
<h4 id="surfaces">Surfaces</h4>
Please note that despite the name the <strong>ball</strong> surface is a rectangular surface. 
Onto this surface the program draws a blue circle.
Because the ball surface was not filled like the background surface, it remains black (<strong>R</strong>ed <strong>G</strong>reen <strong>B</strong>lue value: (0,0,0)).
Also note that in this program nothing is blitted inside the mainloop, all painting and blitting occurs before the mainloop. 
The ball is visible on the screen because the background was blitted first and then the background the ball surface was blitted (quasi-on-top). 
Reverse the order of blitting and you should see only the white background. 
Blitting the background on the screen is a good method to clean all graphic artefacts from a screen.

<h4 id="drawing">Drawing</h4>
Pygame knows a lot of <a href="http://www.pygame.org/docs/ref/draw.html">drawing functions</a>. 
In this code example, the <code>pygame.draw.circle</code> function is used. 
All of Pygame&#039;s drawing function need a <strong>pygame surface</strong> to draw on. 
Think of those surfaces like papers or beer mats. 
The top left corner of the Pygame surface has the coordinate (0,0). 

Let&#039;s take a look at the <code>pygame.draw_circle</code> documentation and the code lines in the source code example:
<span># create a rectangular surface for the ball</span>
ballsurface <span>=</span> pygame.<span>Surface</span><span>&#40;</span><span>&#40;</span><span>50</span><span>,</span><span>50</span><span>&#41;</span><span>&#41;</span>   
<span># draw blue filled circle on ball surface </span>
pygame.<span>draw</span>.<span>circle</span><span>&#40;</span>ballsurface<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>255</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>25</span><span>,</span><span>25</span><span>&#41;</span><span>,</span><span>25</span><span>&#41;</span> 

In the first code line, a pygame <strong>surface</strong> is created with the dimensions 50 pixel width (x-axis) and 50 pixel height (y-axis). 
This little pygame surface is named <strong>ball</strong>. 

The second code line draws a <strong>circle</strong> on the surface <strong>ball</strong> with the colours
0 (no portion of red), 0 (no portion of green), 255 (full portion of blue) at the position (25,25) counted from the top left corner of the <strong>ball</strong> surface. 
(25,25) is exactly the middle of (50,50). 
This circle has a radius of 25 pixels, and because there is no line width argument, pygame falls back to the default width of 0 which results in a blue filled circle.

<h4 id="some_drawing_functions">Some Drawing Functions</h4>
In the official pygame documentation, the chapter <strong>draw</strong> lists 9 drawing functions. 
4 of them are used in this code example to draw green figures on the background surface. 
Try to change the values and see what happens:
<span>#------- try out some pygame draw functions --------</span>
<span># pygame.draw.rect(Surface, color, Rect, width=0): return Rect</span>
pygame.<span>draw</span>.<span>rect</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>255</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>50</span><span>,</span><span>50</span><span>,</span><span>100</span><span>,</span><span>25</span><span>&#41;</span><span>&#41;</span> <span># rect: (x1, y1, width, height)</span>
<span># pygame.draw.circle(Surface, color, pos, radius, width=0): return Rect</span>
pygame.<span>draw</span>.<span>circle</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>200</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>200</span><span>,</span><span>50</span><span>&#41;</span><span>,</span> <span>35</span><span>&#41;</span>
<span># pygame.draw.polygon(Surface, color, pointlist, width=0): return Rect</span>
pygame.<span>draw</span>.<span>polygon</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>180</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>&#40;</span><span>250</span><span>,</span><span>100</span><span>&#41;</span><span>,</span><span>&#40;</span><span>300</span><span>,</span><span>0</span><span>&#41;</span><span>,</span><span>&#40;</span><span>350</span><span>,</span><span>50</span><span>&#41;</span><span>&#41;</span><span>&#41;</span>
<span># pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1): return Rect</span>
pygame.<span>draw</span>.<span>arc</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>150</span><span>,</span><span>0</span><span>&#41;</span><span>,</span><span>&#40;</span><span>400</span><span>,</span><span>10</span><span>,</span><span>150</span><span>,</span><span>100</span><span>&#41;</span><span>,</span> <span>0</span><span>,</span> <span>3.14</span><span>&#41;</span> <span># radiant instead of grad</span>


<h3>Ideas</h3>

Paint a giant pink circle on the middle of the screen
Find out wich line you must out-comment (using #) to remove the blue ball <strong>and</strong> the black square
Can you use the <strong>pygame.draw.polygon</strong> function to draw a pentagram: <br/>
<a href="/_detail/en:part2:pygame:pentagram.png?id=en%3Apygame%3Astep003"><img src="http://thepythongamebook.com/_media/en:part2:pygame:pentagram.png"></a>
Can you make an arc from the topright to the lower-left corner<sup><a href="#fn__1" id="fnt__1">1)</a></sup>?
Use python&#039;s <strong>range</strong> function to draw a pretty pattern across the screen. 
Start with this code and expand to all 4 corners:
<span>for</span> point <span>in</span> <span>range</span><span>&#40;</span><span>0</span><span>,</span><span>641</span><span>,</span><span>64</span><span>&#41;</span>: <span># range(start, stop, step)</span>
  pygame.<span>draw</span>.<span>line</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>255</span><span>,</span><span>0</span><span>,</span><span>255</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>480</span><span>,</span> point<span>&#41;</span><span>,</span> <span>1</span><span>&#41;</span>
Can you use the point variable also inside the color tuple to make each line with a different color?


<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/draw.html">http://www.pygame.org/docs/ref/draw.html</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.blit">http://www.pygame.org/docs/ref/surface.html#Surface.blit</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.convert">http://www.pygame.org/docs/ref/surface.html#Surface.convert</a>
<a href="http://www.pygame.org/docs/ref/surface.html#Surface.convert_alpha">http://www.pygame.org/docs/ref/surface.html#Surface.convert_alpha</a>


<h3>Source Code on Github</h3>
	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th><th>  comment  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/003_static_blit.py">003_static_blit.py</a>    pygame    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>    simple version  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/003_static_blit.py">003_static_blit_pretty.py</a>    pygame    pretty version  

<h3>Simple Version</h3>

This version draws some lines and blits a surface. 
no fancy stuff.

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/003_static_blit.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/003_static_blit.py</a>

<h3>OOP Version</h3>

Improvements:
using 2 different <strong>class</strong> objects, one for the game, one for the ball. 
See <a href="/en:pygame:step014">→sprites</a>
better text display, see <a href="/en:pygame:step012">→text</a>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/003_static_blit_pretty.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/003_static_blit_pretty.py</a>


<h1 class="title">Step 004 - Colorkey and Alpha Values</h1>
004_colorkey.py
004_alphademo.py
004_alphademo_pretty.py
004_per-pixel-alphademo.py

In this page you will find 4 code examples: <strong>004_colorkey.py</strong> , <strong>004_alphademo.py</strong> , <strong>004_alphademo_pretty.py</strong> and <strong>004_per-pixel-alphademo.py</strong>. 
All examples demonstrate how to work with transparency and pygame surfaces. 


<strong>004_colorkey.py</strong> is simple to understand. 
Compare it with <strong>003_static_blit.py</strong> on the <a href="/en:pygame:step003">previous page</a> and look at the blue circle. 
Do you notice a difference ? Right, the ugly black corners around the blue circle are gone. 
This is thanks to pygame&#039;s <strong>set_colorkey</strong> command. 
By defining a specific color on a pygame surface as colorkey, you make this color (in our example, the black color) transparent.

There are 2 kind of image files: Those with in-build transparency , and those without. 

Only graphic files of the file type <strong>.png</strong> and <strong>.gif</strong> can have transparency<sup><a href="#fn__1" id="fnt__1">1)</a></sup>. 
Other file tpyes like the popular <strong>.jpg</strong> format can not have transparency. 
If you want transparency for such images you must add them manually with pygame. 
<strong>004_alphademo.py</strong> shows you how to do that. 
Look at the slowly blinking colormonster (3rd from the left the second row). 
You can see the amount of alpha-value (the white text below the picture) necessary to make a picture fully visible or fully transparent.

You can also press the keys &lt;key&gt;Ins&lt;/key&gt;, &lt;key&gt;Dec&lt;/key&gt;, &lt;key&gt;Home&lt;/key&gt;, &lt;key&gt;End&lt;/key&gt;,&lt;key&gt;PageUp&lt;/key&gt;, &lt;key&gt;PageDown&lt;/key&gt;, &lt;key&gt;Num+&lt;/key&gt;, &lt;key&gt;Num–&lt;/key&gt; to manually change the <strong>rgb</strong> and <strong>alpha</strong> values in the topright images. 
Press the keys to see what happens.

For even more effects, you can change the Blit mode by pressing &lt;key&gt;ENTER&lt;/key&gt;.
This affects the mixing of <strong>rgb</strong> values from the image and those specified by the keys.

<strong>004_per-pixel-alphademo.py</strong> shows you an interesting effect by changing the alpha-value of individual pixels. 
Move the mouse around and use the scroll wheel.

<h2>- Code Discussion 004_colorkey.py</h2>

<h3>Colorkey</h3>

There is only one important line in this example. 
To get rid of the ugly black corners of the blue <strong>ball</strong> surface we declare the color black (0.0.0) as transparent.
<span>#make black the transparent color (red,green,blue)</span>
ball.<span>set_colorkey</span><span>&#40;</span><span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span>        

To make the blitting of a pygame surface faster, it is a good idea to use .convert() on the surface once all drawing on the surface is done. 
Note that if the surface contains transparent colors, you need to use convert.alpha() instead of .convert().

<h3>Blitting on the Screen</h3>

The same ballsurface is blitted on the screen (not on the background!) twice in this example:
once (the left ball) before the mainloop start and once inside the mainloop. 

Inside the mainloop a pattern of colourful lines is drawn each frame. 
The lines will draw on top of the left surface,
but the right surface is drawn on top of the lines. 


Note that the “corners” of the ball surfaces are not simply white but transparent. 
The colourful lines are good visible
“below” the corners of the right ball surface.

Note that in this code example, inside the mainloop all commands draw directly on the screen surface.

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/surface.html#Surface.set_colorkey">http://www.pygame.org/docs/ref/surface.html#Surface.set_colorkey</a>

<h2>- Code Discussion 004_alphademo.py</h2>
<strong>004_alphademo.py</strong> shall show you the possibilities of alpha-values (transparency) and image files. 


Don&#039;t worry if you do not understand all of <strong>004_alphademo.py</strong> yet - i don&#039;t understand all of it, neither. 
The important thing is to know how to use it. 
Some techniques like <a href="/en:pygame:step007">loading surfaces</a> from files and <a href="/en:pygame:step012">using text</a> will be explained in other pages. 
Also note that there are 2 ways of handling keyboard input in 004_alphademo.py.
pressed_keys : to indicate of a specific key is pressed at this moment.
key_pressed : to check if a specific key was (once) pressed and released.

Both methods will be discussed in more detail in <a href="/en:pygame:step011">→step011</a>.

<h3>Blend Modes</h3>

From the different blit-modes, BLEND_RGBA_MULT (mode number 8) seems to be the most meaningful one. 
Using this blit mode, you can make an image all blue, red or green by setting the per-pixel-alpha values for the corresponding colour. 
At the same time, you can set an alpha value for the whole image. 
This works both for images without transparency such as <strong>.jpg</strong> images but also for images with in-build transparency such as <strong>.gif</strong> or <strong>.png</strong> images.
<span>def</span> get_alpha_surface<span>&#40;</span> surf<span>,</span> alpha<span>=</span><span>128</span><span>,</span> red<span>=</span><span>128</span><span>,</span> green<span>=</span><span>128</span><span>,</span> blue<span>=</span><span>128</span><span>,</span> mode<span>=</span>pygame.<span>BLEND_RGBA_MULT</span><span>&#41;</span>:
   <span>&quot;&quot;&quot;    
   Allocate a new surface with user-defined values (0-255)
   for red, green, blue and alpha.
&nbsp;
   Thanks to Claudio Canepa &lt;ccanepacc@gmail.com&gt;.
   &quot;&quot;&quot;</span>
&nbsp;
   tmp <span>=</span> pygame.<span>Surface</span><span>&#40;</span> surf.<span>get_size</span><span>&#40;</span><span>&#41;</span><span>,</span> pygame.<span>SRCALPHA</span><span>,</span> <span>32</span><span>&#41;</span>
   tmp.<span>fill</span><span>&#40;</span> <span>&#40;</span>red<span>,</span>green<span>,</span>blue<span>,</span>alpha<span>&#41;</span> <span>&#41;</span>
   tmp.<span>blit</span><span>&#40;</span>surf<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> surf.<span>get_rect</span><span>&#40;</span><span>&#41;</span><span>,</span> mode<span>&#41;</span>
   <span>return</span> tmp

For an example of how to use this function, see this code snippet:
tmp <span>=</span> get_alpha_surface<span>&#40;</span>pngMonster3<span>,</span> a<span>,</span> r<span>,</span> g<span>,</span> b<span>,</span> mode<span>&#41;</span> 
screen.<span>blit</span><span>&#40;</span>tmp<span>,</span> <span>&#40;</span><span>600</span><span>,</span><span>10</span><span>&#41;</span><span>&#41;</span>

The different <strong>modes</strong> are integer values and can be found in the <a href="http://www.pygame.org/docs/ref/locals.html">pygame documentation</a> or by using python&#039;s 
<a href="/en:resources:glossary:direct_mode"> interactive interpreter</a>:
<span>&gt;&gt;&gt;</span><span>import</span> pygame
<span>&gt;&gt;&gt;</span><span>help</span><span>&#40;</span>pygame.<span>constants</span><span>&#41;</span>

<h3>Alpha Value for the Whole Surface</h3>

If you have a pygame surface without in-build transparency (let&#039;s say loaded from an <strong>.jpg</strong> image) you can set an alpha-value (transparency) for the whole surface with a simple <strong>set_alpha()</strong> command as shown in this code snippet from 004_alphademo.py:
jpgMonster2.<span>set_alpha</span><span>&#40;</span>alpha<span>&#41;</span> <span># alpha (0-255) for whole surface</span>
screen.<span>blit</span><span>&#40;</span>jpgMonster2<span>,</span> <span>&#40;</span><span>400</span><span>,</span><span>300</span><span>&#41;</span><span>&#41;</span>  <span># blit on screen</span>

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/surface.html#Surface.blit">http://www.pygame.org/docs/ref/surface.html#Surface.blit</a>
more about blend modes:
<a href="http://stackoverflow.com/questions/601776/what-do-the-blend-modes-in-pygame-mean">http://stackoverflow.com/questions/601776/what-do-the-blend-modes-in-pygame-mean</a>
<a href="http://illusions.hu/effectwiki/doku.php?id=list_of_blendings">http://illusions.hu/effectwiki/doku.php?id=list_of_blendings</a>

<h2>- Ideas</h2>
&lt;note tip&gt;replace <code>colormonster.jpg</code> with a picture of your own head. 
rename the picture or the relevant code line inside <code>005_alphademo.py</code>. 
Can you make your face all blue or all purple just by pressing keys ?&lt;/note&gt;

&lt;note tip&gt;set_aplpha() allows you to create fading effects for game intros, in-game cinematic or game-over screens. 
Use a paint programm like Gimp, create a stunning game title (or game over message) and save it in the .jpg format. 
Now try to let pygame fade in or fade out of this picture (ideally while playing music, see <a href="/en:pygame:step010">→step010</a>)&lt;/note&gt;

<h3>Source Code on Github</h3>
	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th><th>  comment  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/004_colorkey.py">004_colorkey.py</a>    pygame    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>    This program runs stand-alone and does not need other files  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/004_alphademo.py">004_alphademo.py</a>    pygame    this program needs other files (see below) to run  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/004_alphademo_pretty.py">004_alphademo_pretty.py</a>    pygame    yipyip&#039;s version of alphademo. 
This program needs other files (see below) to run  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/800px-La_naissance_de_Venus.jpg">800px-La_naissance_de_Venus.jpg</a> <br/>
<a href="/_detail/en:part2:pygame:orzvenus150.jpg?id=en%3Apygame%3Astep004"><img src="http://thepythongamebook.com/_media/en:part2:pygame:orzvenus150.jpg"></a>    pygame/data    source: <a href="https://en.wikipedia.org/wiki/The_Birth_of_Venus_(Botticelli)">wikipedia</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/colormonster.jpg">colormonster.jpg</a> <br/>
<a href="/_detail/en:part2:pygame:colormonster.jpg?id=en%3Apygame%3Astep004"><img src="http://thepythongamebook.com/_media/en:part2:pygame:colormonster.jpg?w=150&amp;tok=f10e11"></a>    pygame/data    a <strong>.jpg</strong> graphic an not have in-build transparency. 
(notice the white background) 
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/colormonster.png">colormonster.png</a> <br/>
<a href="/_detail/en:part2:pygame:colormonster.png?id=en%3Apygame%3Astep004"><img src="http://thepythongamebook.com/_media/en:part2:pygame:colormonster.png?w=150&amp;tok=f852ed"></a>    pygame/data    a <strong>.png</strong> (as well as <strong>.gif</strong>) graphic can have in-build transparency. 
Notice the transparent background  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/ente.jpg">ente.jpg</a> <br/>
<a href="/_detail/en:part2:pygame:ente.jpg?id=en%3Apygame%3Astep004"><img src="http://thepythongamebook.com/_media/en:part2:pygame:ente.jpg?w=150&amp;tok=ff2e24"></a>    pygame/data    a picture of a duck<sup><a href="#fn__2" id="fnt__2">2)</a></sup>

<em>If you see no colourful source code below, click on  “reload” on your browser. 
Or follow the links to github.</em>

<h3>004_colorkey.py</h3>

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_colorkey.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_colorkey.py</a>
<h3>004_alphademo.py</h3>

This program need other graphic files to be located in a subfolder called <code>data</code>. 
See the file table above for details. 
To get the program working correctly, you best download and unpack the whole file archive (link in the file table above).

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo.py</a>
<h3>004_alphademo_pretty.py</h3>

This program need other graphic files to be located in a subfolder called <code>data</code>. 
See the file table above for details. 
To get the program working correctly, you best download and unpack the whole file archive (link in the file table above).

&lt;note tip&gt;This version is for python 2.x only ! For python 3.x, see the next code example below&lt;/note&gt;

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo_pretty.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo_pretty.py</a>
<h3>004_alphademo_pretty_python3x.py</h3>

This program need other graphic files to be located in a subfolder called <code>data</code>. 
See the file table above for details. 
To get the program working correctly, you best download and unpack the whole file archive (link in the file table above).

&lt;note tip&gt;This verison works with python3.x only. 
For python 2x version, see the oode example above&lt;/note&gt;

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo_pretty_python3x.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_alphademo_pretty_python3x.py</a>
<h3>004_per-pixel-alphademo.py</h3>

This program needs one other graphic file -ente.jpg-  to be located in a subfolder called <code>data</code>. 
See the file table above for details. 
To get the program working correctly, you best download and unpack the whole file archive (link in the file table above).

Note: For Python 3.x, change the two instances of the xrange() function (which was deprecated in Python 3) to range().
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_per-pixel-alphademo.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/004_per-pixel-alphademo.py</a>


<h1 class="title">Step 006 - Time-based Movement</h1>

<h3>Code Discussion</h3>

<a href="/_detail/en:part2:step006.jpg?id=en%3Apygame%3Astep006"><img src="http://thepythongamebook.com/_media/en:part2:step006.jpg?w=300&amp;tok=69ab8f"></a>
To avoid the hardware-dependence of <a href="/en:part2:pygame:step005">frame-based movement</a> you can force pygame to calculate time-based movement. 
Please note that we still speak of the illusion of movement, because all what pygame does is blitting blobs (surfaces) to different positions - but in a more reliable way <img src="http://thepythongamebook.com/lib/images/smileys/icon_smile.gif"> !

Time-based movement does <strong>not</strong> mean that your pygame program will run on crappy computers as smooth as on fast machines - pygame can not (yet) do that! Time-based movement just means that independent of the speed of the computer, in the source code example below the ball will always take the same amount of time to cross the screen. 
On fast machines, the movement will appear very smooth, while on slow machines the movement will appear bumpy.

<h4 id="calculating_the_passed_time">Calculating the passed Time</h4>
The secret to time-based movement is to let pygame calculate how much time was passed since the last cycle of the mainloop (to be exact: since the last call of the clock.tick command). 
Pygame provide this information in milliseconds. 
In the source code example below I convert this value into seconds <sup><a href="#fn__1" id="fnt__1">1)</a></sup>. 
This time value is <strong>multiplied</strong> to the speed vector:
    <span>#calculate new center of ball (time-based)</span>
   ballx +<span>=</span> dx * seconds <span># float, since seconds passed since last frame is a decimal value</span>
   bally +<span>=</span> dy * seconds 

Note that the value of seconds will be something like 0.05 seconds per frame <sup><a href="#fn__2" id="fnt__2">2)</a></sup> so you need rather high dx and dy values to see any movement at all. 
In this example dx and dy speed values are set at 60 pixel per second.

<h4 id="blitting_on_a_clean_screen">Blitting on a clean Screen</h4>
In this pygame example, the whole background is blitted onto the screen each cycle (frame) of the mainloop. 
This will overwrite all old images of the ball surface. 
On top of the fresh background, the ball is blitted each frame. 
While this method of cleaning the whole screen allow you care-free programming, very big pygame windows (screen resolution) or slow computers will show a drop in the frame-rate. 
The next chapters will show you more time- and memory-efficient methods of cleaning only those parts of the screen that need cleaning. 
This is called dirty rects cleaning.

<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/006_time_based_movement.py">006_time_based_movement.py</a>    pygame    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/006_time_based_movement.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/006_time_based_movement.py</a>
	


<h1 class="title">Step 008 - Animation</h1>
Remember the Subsurfaces from the last step? And remember that the snake had always the same grinning facial expression? Now, let&#039;s make some animated <strong>sprites</strong><sup><a href="#fn__1" id="fnt__1">1)</a></sup> - not pygame sprites, but surfaces that show different images of an animation cycle, like a bird flapping its wings.

<a href="/_detail/en:part2:spritesheet008.jpg?id=en%3Apygame%3Astep008"><img src="http://thepythongamebook.com/_media/en:part2:spritesheet008.jpg?w=300&amp;tok=631675"></a>
Instead of painting all the single pictures of an animation cycle myself, I prefer to use ready-made sprite sheets.

In the data folder, you will find a spritesheet<sup><a href="#fn__2" id="fnt__2">2)</a></sup> from Ari Feldmann&#039;s Spritelib ( <a href="http://www.widgetworx.com/spritelib/">http://www.widgetworx.com/spritelib/</a> ) showing several pictures of an animal. 
If you use Ari&#039;s sprite&#039;s, make sure to include his <a href="/en:glossary:s:spritelib_license">license information</a> in your program.

With the help of pygame&#039;s subsurface command, I will show you how to extract single images from the sprite sheet and use them.

<h3>Code Discussion</h3>
<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/008_animation.py">008_animation.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/char9.bmp">char9.bmp</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/char9.bmp"><img src="http://thepythongamebook.com/_media/en:part2:pygame:char9_150.jpg"></a>    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/008_animation.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/008_animation.py</a>
	
<h1 class="title">Step 009 - Tile-based Graphics</h1>
Escape the maze!

In this code example, you can control a little red ball using the cursor keys &lt;key&gt;←&lt;/key&gt; &lt;key&gt;→&lt;/key&gt; &lt;key&gt;↑&lt;/key&gt; &lt;key&gt;↓&lt;/key&gt; and you must seek to escape a walled maze by finding the way to the orange goal.

<a href="/_detail/en:part2:step009.jpg?id=en%3Apygame%3Astep009"><img src="http://thepythongamebook.com/_media/en:part2:step009.jpg?w=300&amp;tok=481287"></a>

<h3>Code Discussion</h3>
<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/009_01_tile_based_graphic_(ugly).py">009_01_tile_based_graphic_(ugly).py</a> <br/>
simple but ugly verions    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/009_02_tile_based_graphic_(improved).py">009_02_tile_based_graphic_(improved).py.py</a> <br/>
improved version    <code>pygame</code>  

<h4 id="ugly_version">Ugly Version</h4>
View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/009_01_tile_based_graphic_">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/009_01_tile_based_graphic_</a>(ugly).py
</script>

<h4 id="improved_version">Improved Version</h4>
View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/009_02_tile_based_graphic_">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/009_02_tile_based_graphic_</a>(improved).py
</script>
<h1 class="title">Step 010 - Using Sound and Music</h1>
<h3>Code Discussion</h3>

Pygame has several commands to play sound. 
Pygame offers a set of <a href="http://www.pygame.org/docs/ref/mixer.html">Sound</a> commands to load and play short sound files - usually <code>.wav</code> or <code>.ogg</code> files. 
For longer files, pygame offers <a href="http://www.pygame.org/docs/ref/music.html">pygame.music</a> commands to stream longer music / sound / voice files directly from the harddisk.

In the source code example below, loading sounds and music is done from a subfolder called <code>data</code>, like the graphic files in the previous source code example.

<h4 id="initializing_the_mixer">Initializing the Mixer</h4>
To get rid of a nasty delay between giving the play command for a sound and hearing it you need to initialize the pygame mixer. 
This is done before writing the pygame.init() command. 
Under Linux, I got best results with this line:
pygame.<span>mixer</span>.<span>pre_init</span><span>&#40;</span><span>44100</span><span>,</span> -<span>16</span><span>,</span> <span>2</span><span>,</span> <span>2048</span><span>&#41;</span> <span># setup mixer to avoid sound lag</span>
pygame.<span>init</span><span>&#40;</span><span>&#41;</span>                      <span>#initialize pygame</span>

<h4 id="loading_music_and_sound_files">loading music and sound files</h4>
Note that loading the sound and music files from harddisk must be done after setting up the mixer. 
In the code-example below, <strong>an-turr.ogg</strong> is a longer music file while <strong>jump.wav</strong> and <strong>fail.wav</strong> are short sound effects:
<span>try</span>:
   pygame.<span>mixer</span>.<span>music</span>.<span>load</span><span>&#40;</span><span>os</span>.<span>path</span>.<span>join</span><span>&#40;</span><span>'data'</span><span>,</span> <span>'an-turr.ogg'</span><span>&#41;</span><span>&#41;</span><span>#load music</span>
   jump <span>=</span> pygame.<span>mixer</span>.<span>Sound</span><span>&#40;</span><span>os</span>.<span>path</span>.<span>join</span><span>&#40;</span><span>'data'</span><span>,</span><span>'jump.wav'</span><span>&#41;</span><span>&#41;</span>  <span>#load sound</span>
   fail <span>=</span> pygame.<span>mixer</span>.<span>Sound</span><span>&#40;</span><span>os</span>.<span>path</span>.<span>join</span><span>&#40;</span><span>'data'</span><span>,</span><span>'fail.wav'</span><span>&#41;</span><span>&#41;</span>  <span>#load sound</span>
<span>except</span>:
   <span>raise</span> <span>UserWarning</span><span>,</span> <span>&quot;could not load or play soundfiles in 'data' folder :-(&quot;</span>

<h4 id="playing_music_and_sound_from_files">Playing Music and Sound from Files</h4>
After loading the sound effects or the music and thus creating pygame objects, you can simply call the <code>.play()</code> method of those objects. 
Inside the brackets you write -1 for endless play or the number of times or the time length to play the sound.
<span>#for sound effects: </span>
<span>#Sound.play(loops=0, maxtime=0, fade_ms=0): return Channel</span>
jump.<span>play</span><span>&#40;</span><span>&#41;</span> <span># play the jump sound effect once</span>

The music is usually played endlessly:
<span>#music is already the name of the music object</span>
<span>#pygame.mixer.music.play(loops=0, start=0.0): return None</span>
music.<span>play</span><span>&#40;</span>-<span>1</span><span>&#41;</span> <span># play endless</span>

&lt;note tip&gt;you hear just a short crack noise instead of a sound? Some sounds simply do not work with pygame. 
Try to open (and edit) the sound with a sound editor like <a href="http://audacity.sourceforge.net/">Audacity</a> and save it again, preferable in the free <a href="https://en.wikipedia.org/wiki/Vorbis">.ogg (vorbis) format</a>.&lt;/note&gt;

<h4 id="versions_with_and_without_graphic">versions with and without graphic</h4>
Note that you do not need pygame&#039;s graphic at all to play music files. 
One of the code examples below use graphical output, the other example use only text output. 
In text output, you still need to initialize pygame and set up the mixer.

<h2>- Generate Sound Effects</h2>
Unlike music, sound effects are easy enough  to generate and not worth the hassle of copyright fights. 
 You may find good sound effects here:
overview of resources at the pygame homepage: <a href="http://pygame.org/wiki/resources">http://pygame.org/wiki/resources</a> 
wikimedia commons: <a href="http://commons.wikimedia.org/wiki/Category:Sound">http://commons.wikimedia.org/wiki/Category:Sound</a>

To generate sound effects, you can either:
plug a microphon<sup><a href="#fn__1" id="fnt__1">1)</a></sup> in your computer and start the recording software of your <abbr title="Operating System">OS</abbr>. 
every <abbr title="Operating System">OS</abbr> is shipped with a primitive voice recording software.
use a program that can generate sound effects, like:
<a href="http://audacity.sourceforge.net/">http://audacity.sourceforge.net/</a>
<a href="http://www.drpetter.se/project_sfxr.html">http://www.drpetter.se/project_sfxr.html</a>
<a href="http://www.bfxr.net/">http://www.bfxr.net/</a> (online)

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.pre_init">http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.pre_init</a>
<a href="http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.Sound">http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.Sound</a>
<a href="http://www.pygame.org/docs/ref/music.html#pygame.mixer.music.load">http://www.pygame.org/docs/ref/music.html#pygame.mixer.music.load</a>
<a href="http://www.pygame.org/docs/ref/music.html#pygame.mixer.music.play">http://www.pygame.org/docs/ref/music.html#pygame.mixer.music.play</a>

<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/010_sound_and_music.py">010_sound_and_music.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/010_sound_only_no_graphic.py">010_sound_only_no_graphic.py</a>    <code>pygame</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/an-turr.ogg">an-turr.ogg</a> <br/>
from <a href="http://modarchive.org/index.php?request=view_by_moduleid&amp;query=33502">modarchive.org</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/fail.wav">fail.wav</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/jump.wav">jum.wav</a>    <code>pygame/data</code>  

<h4 id="without_graphic">without graphic</h4>
View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/010_sound_only_no_graphic.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/010_sound_only_no_graphic.py</a>
<h4 id="with_graphic">with graphic</h4>
View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/010_sound_and_music.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/010_sound_and_music.py</a>
	
<h1 class="title">Step 011 - Keys, Rotating and Zoom</h1>
<h3>Code Discussion</h3>
<h4 id="pressed_keys">Pressed Keys</h4>
<a href="/_detail/en:part2:part2step011.jpg?id=en%3Apygame%3Astep011"><img src="http://thepythongamebook.com/_media/en:part2:part2step011.jpg?w=195&amp;tok=b1bbe4"></a>
Surfaces can not only moved around, but also rotated and -unlike beer mats- zoomed. 
The next source code examples introduce a new method of keyboard control.
Instead of checking a queued event with <strong>pygame.event.get()</strong> the function <strong>pygame.key.get_pressed()</strong> delivers the actual state of the complete keyboard. 
This state is represented by a tuple of 0/1 values for each key. 

A value of 0 signals an <em>unpressed</em>, a value of 1 signals a <em>pressed</em> State of a key. 
You can access the value for a specific key with the K_&lt;A_SPECIFIC_KEY&gt; values defined in <strong>pygame.constants</strong>.
For example
pressedkeys <span>=</span> pygame.<span>key</span>.<span>get_pressed</span><span>&#40;</span><span>&#41;</span>
<span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_x</span><span>&#93;</span>:
   do_something<span>&#40;</span><span>&#41;</span>

checks if the key “<strong>x</strong>” is pressed.
This method is ideal for constant movement, where a sprite moves or rotate as long as a specific key is pressed.

In the source code example bleow, the cursor keys &lt;key&gt;←&lt;/key&gt; &lt;key&gt;↑&lt;/key&gt; &lt;key&gt;→&lt;/key&gt; &lt;key&gt;↓&lt;/key&gt; are used to move the snake surface, while the keys &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;s&lt;/key&gt; zoom/shrink the snake and the keys &lt;key&gt;a&lt;/key&gt; and &lt;key&gt;d&lt;/key&gt; rotate the snake.

It is possible to press several keys together, like left and right cursor, and the program will move the correctly (not at all in this case):
    dx<span>,</span> dy  <span>=</span> <span>0</span><span>,</span> <span>0</span>   <span># no cursor key, no movement</span>
   <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_LEFT</span><span>&#93;</span>:
       dx -<span>=</span> speed
   <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_RIGHT</span><span>&#93;</span>:
       dx +<span>=</span> speed

Note that this method of keyboard control is less precise than the <code>if pygame.event.type…</code> - method because there is no guarantee that a fast key-pressing will be noticed by pygame. 
Depending on how fast the computer can calculate each cycle of the main-loop, there could be a chance that you press and release a key just between 2 main loop cycles and pygame would not notice. 
However, if your program runs around 30 frames per second, you would need lightning fast fingers to become <em>not</em> noticed by pygame.

Also note that this keyboard control method is not ideal for pre-defined movement like stones on a board game. 
While you can control with the time-based movement the speed of a surface, it lay in the skill of the user and his dexterity in pressing and releasing a key to control how long a surface moves (and where its movements end exactly). 


<h4 id="troublesome_subsurface">troublesome subsurface</h4>
Also note that the cleaning of the old surface (using the <code>subsurface</code> method) is done inside a try…except block. 
If the subsurface is no longer inside the surface, pygame would raise an error. 
This can happen when you zoom or rotate the snake outside the screen.
   <span># only blit the part of the background where the snake was (cleanrect)</span>
   <span>try</span>:
       <span>#if the subsurface is outside the screen pygame would raise an error</span>
       <span>#this can happen when using rotozoom, therfore check inside try..except</span>
       <span>#Surface.subsurface(Rect): return Surface</span>
       dirtyrect <span>=</span> background.<span>subsurface</span><span>&#40;</span><span>&#40;</span><span>round</span><span>&#40;</span>snakex<span>,</span><span>0</span><span>&#41;</span><span>,</span> 
               <span>round</span><span>&#40;</span>snakey<span>,</span><span>0</span><span>&#41;</span><span>,</span> snake.<span>get_width</span><span>&#40;</span><span>&#41;</span><span>,</span> snake.<span>get_height</span><span>&#40;</span><span>&#41;</span><span>&#41;</span><span>&#41;</span>
&nbsp;
       screen.<span>blit</span><span>&#40;</span>dirtyrect<span>,</span> <span>&#40;</span><span>round</span><span>&#40;</span>snakex<span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>round</span><span>&#40;</span>snakey<span>,</span><span>0</span><span>&#41;</span><span>&#41;</span><span>&#41;</span> 
   <span>except</span>:
       screen.<span>blit</span><span>&#40;</span>background<span>,</span><span>&#40;</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span> <span># blit the whole background (slow but secure)</span>

<h4 id="do_not_get_lost_in_space">do not get lost in space !</h4>
Also note that in this code example there is no checking if the snake is inside the screen whatsoever. 
You can try to move the snake outside of the right , move it down, left and up and reappear from the left. 


<h4 id="zooming_around_the_center">Zooming around the Center</h4>
the <strong>pygame.transform.rotozoom</strong> command would rotate around the position (0,0) of a Surface - the topleft corner. 


To create a more pleasing rotation aroundthe center effect, we need some tricks:
First, the original snake surface is copied into snake_original right after creation, to have always a not-manipulated image:
snake_original <span>=</span> snake.<span>copy</span><span>&#40;</span><span>&#41;</span>      <span># store a unmodified copy of the snake surface</span>

&lt;note tip&gt;
snake_original <span>=</span> snake

would not work because both snake and snake_original would be just pointers to the same python object (the manipulated snake). 
If you need a copy of an object, use the .copy() method&lt;/note&gt;

Always the original_snake surface is zoomed and rotated with the current <strong>zoom</strong> and <strong>angle</strong> values by the pygame.transform.rotozoom command.

But how to avoid a rotation around the topleft corner?

For that, before <code>pygame.transform.rotozoom</code> does its work, the current <strong>rectangle</strong> of the snake surface is stored into the variable <strong>oldrect</strong> by the <code>surface.get_rect()</code> command. 
Pygame rects have several useful properties, like pre-defined constants for center, centerx, centery, width, height etc.

After rotating and now having a usually resized snake surface (pygame always calculate a rectangle around the visible surface, thus a rotated snake fits in a bigger rectangle than a non-rotated snake) the rectangle of the new surface is stored into the variable <strong>newrect</strong>. 
This is also done with the <code>surface.get_rect()</code> command.
Now the code example simply blits the new surface so that its new center lays on the same spot as the center of the old rectangle - rotated around the center.
    <span>if</span> turnfactor <span>!=</span> <span>0</span> <span>or</span> zoomfactor <span>!=</span><span>1.0</span>:
       angle +<span>=</span> turnfactor * turnspeed * seconds <span># time-based turning</span>
       zoom *<span>=</span> zoomfactor 
       <span># the surface shrinks and zooms and moves by rotating</span>
       oldrect <span>=</span> snake.<span>get_rect</span><span>&#40;</span><span>&#41;</span> <span># store current surface rect</span>
       snake <span>=</span> pygame.<span>transform</span>.<span>rotozoom</span><span>&#40;</span>snake_original<span>,</span> angle<span>,</span> zoom<span>&#41;</span>
       newrect <span>=</span> snake.<span>get_rect</span><span>&#40;</span><span>&#41;</span> <span># store new surface rect</span>
       <span># put new surface rect center on same spot as old surface rect center</span>
       snakex +<span>=</span> oldrect.<span>centerx</span> - newrect.<span>width</span> / <span>2</span>
       snakey +<span>=</span> oldrect.<span>centery</span> - newrect.<span>height</span> / <span>2</span>

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/rect.html">http://www.pygame.org/docs/ref/rect.html</a>
<a href="http://www.pygame.org/docs/ref/transform.html#pygame.transform.rotozoom">http://www.pygame.org/docs/ref/transform.html#pygame.transform.rotozoom</a>
<a href="http://www.pygame.org/docs/ref/key.html#pygame.key.get_pressed">http://www.pygame.org/docs/ref/key.html#pygame.key.get_pressed</a>

<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/011_rotozoom.py">011_rotozoom.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/background640x480_a.jpg">background640x480_a.jpg</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/background640x480_a.jpg"><img src="http://thepythongamebook.com/_media/en:part2:pygame:background150.jpg"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/snake.gif">snake.gif</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/snake.gif"><img src="http://thepythongamebook.com/_media/en:part2:pygame:pysnake150.png"></a>    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/011_rotozoom.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/011_rotozoom.py</a>
	
<h1 class="title">Step 012 - Text</h1>
<h3>Code Discussion</h3>

<a href="/_detail/en:part2:part2step012.jpg?id=en%3Apygame%3Astep012"><img src="http://thepythongamebook.com/_media/en:part2:part2step012.jpg?w=250&amp;tok=9ef06d"></a>
There are more ways to display text than the <code>pygame.display.set_caption(“msg”)</code> command. 
You can render any text directly on a pygame surface. 
This code example uses two defined functions to better seperate the text writing from the surface display commands. 
Note that inside the second function is a call to the first function, generating a random colour tuple of <code>(red, green, blue)</code> values.

All the text rendering happens inside the <code>write</code> function:
<span>def</span> write<span>&#40;</span>msg<span>=</span><span>&quot;pygame is cool&quot;</span><span>&#41;</span>:
   myfont <span>=</span> pygame.<span>font</span>.<span>SysFont</span><span>&#40;</span><span>&quot;None&quot;</span><span>,</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>34</span><span>,</span><span>128</span><span>&#41;</span><span>&#41;</span>
   mytext <span>=</span> myfont.<span>render</span><span>&#40;</span>msg<span>,</span> <span>True</span><span>,</span> newcolour<span>&#40;</span><span>&#41;</span><span>&#41;</span>
   mytext <span>=</span> mytext.<span>convert_alpha</span><span>&#40;</span><span>&#41;</span>
   <span>return</span> mytext

Inside this <code>write</code>-function, text is written to a surface (pygame uses the system font if no specific font-file is loaded) using a randomized font size and randomized colour. 
The text surface has already a transparent color and is returned to the function call inside the main loop:
   <span># inside mainloop</span>
  textsurface <span>=</span> write<span>&#40;</span><span>&quot;hello world&quot;</span><span>&#41;</span>

Code Challenges:
prompt user for text to randomize
read in a text file of words to display, change the word on collision with wall

For fun, no cleanrect method is used here and the background is only blitted to the screen when the text surface touches the left screen border.

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/font.html#pygame.font.SysFont">http://www.pygame.org/docs/ref/font.html#pygame.font.SysFont</a>
<a href="http://www.pygame.org/docs/ref/freetype.html#Font.render">http://www.pygame.org/docs/ref/freetype.html#Font.render</a>

<h3>The Flytext Function</h3>

This exmple is written as a big function, <strong>flytext()</strong>. 
The function <strong>flytext</strong> accept the two arguments <strong>msg</strong> (the text message to display) and <strong>duration</strong>. 


Example:
To call the function and let it write “Python is cool” for seven seconds, use:
flytext<span>&#40;</span><span>&quot;Python is cool&quot;</span><span>,</span> <span>7</span><span>&#41;</span>

Note that if you start flytext without arguments, the last two codelines will run the function with default arguments, writing “hello World” for five seconds. 
You can change the default values in the line where the flytext function is defined:
<span>def</span> flytext<span>&#40;</span>msg<span>=</span><span>&quot;hello world&quot;</span><span>,</span> duration<span>=</span><span>5</span><span>&#41;</span>:

<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/012_text.py">012_text.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/012_text.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/012_text.py</a>
	
<h1 class="title">Step 013 - Catch the Thief Game</h1>
<h3>How to Play</h3>

<a href="/_detail/en:part2:part2step013.jpg?id=en%3Apygame%3Astep013"><img src="http://thepythongamebook.com/_media/en:part2:part2step013.jpg?w=400&amp;tok=ea0ba3"></a>
This code example should teach nearly nothing new but instead put all the wisdom from the previous steps together to create a little game. 
In this <strong>catch-the-thief</strong>-game up to 2 players control sprites<sup><a href="#fn__1" id="fnt__1">1)</a></sup> (the Pygame snake and the babytux bird) and are tasked to help the police (blue circle with white “P”) to catch a thief (red triangle with transparent “T”). 
To make the game interesting (and difficult), the police moves toward the middle position between the both players (this position is marked with a black cross). 
The thief moves randomly.

All sprites are controlled indirectly, like ships in water (or spaceships in space): The player point the mouse or press the cursor - keys &lt;key&gt;←&lt;/key&gt; &lt;key&gt;→&lt;/key&gt; &lt;key&gt;↑&lt;/key&gt; &lt;key&gt;↓&lt;/key&gt; in the direction the sprite should move. 
The sprite will eventually move into this direction but will continue to do so even if it gets a new order. 
Bouncing off the screen edge will change the direction. 
If no orders are given, all sprites except the thief will eventually come to an halt because of friction. 
The player can use an emergency break and force his sprite to halt by pressing &lt;key&gt;ENTER&lt;/key&gt; or pressing the left mouse button. 
Instead of the cursor keys, the player can also use &lt;key&gt;w&lt;/key&gt;, &lt;key&gt;a&lt;/key&gt;, &lt;key&gt;s&lt;/key&gt;, &lt;key&gt;s&lt;/key&gt;, &lt;key&gt;CTRL&lt;/key&gt;.

If no second player is present, one skilled player can try to control both sprites with mouse &amp; keyboard. 


<h3>Code Discussion</h3>

In the code, those pygame surfaces are called sprites. 
Please note that pygame has it&#039;s own, very sophisticated <strong>pygame.Sprite</strong>>def</strong>. 
Most important are the last two lines, basically the only lines outside a function:
<span>if</span> __name__ <span>==</span> <span>&quot;__main__&quot;</span>:
   play_the_game<span>&#40;</span><span>&#41;</span>

Those lines control if the game is started directly or imported from another program (like a program that manages a highscore list). 
If the programm is started directly, the internal variable __name__ has the value &quot;__main__&quot;. 
In this case, the game start itself by calling the <strong>play_the_game()</strong> function.

Because the loaded background image is larger than the pygame display screen resolution, the background image is resized using this command:
    background <span>=</span> pygame.<span>transform</span>.<span>scale</span><span>&#40;</span>background<span>,</span> <span>&#40;</span>screen.<span>get_width</span><span>&#40;</span><span>&#41;</span><span>,</span> screen.<span>get_height</span><span>&#40;</span><span>&#41;</span><span>&#41;</span><span>&#41;</span>

After <strong>def</strong>ining some useful functions for later use the game creates several pygame surfaces: <strong>screen</strong> and <strong>background</strong> and several sprites: <strong>bird</strong>, <strong>snake</strong>, <strong>police</strong>, <strong>cross</strong>, <strong>thief</strong> where each sprite get the variables <strong>x</strong>, <strong>y</strong>, <strong>dx</strong>, <strong>dy</strong> with the spritename as prefix. 
X and Y control the position while dx and dy control the movement speed.

Inside the mainloop, all sprites are <strong>cleaned</strong>, <strong>updated</strong> (player commands are computed here) and finally <strong>blitted</strong>n on the screen again.
The mainloop switch into a special GameOver - mode after the playtime runs out. 
While in the GameOver mode, no sprites are displayed and only the score is rendered for the players information.

The <strong>cleanblit</strong> function calls and a lot of headache could all be ignored and instead a simple line of
            <span>#screen.blit(background, (0,0))  # not GameOver</span>

would do the job. 
However, framerate would drop when using large screen resolutions.

Before blitting (drawing) the sprites, a check is made if the police sprite is near enough at the thief sprite to credit the players with a score point. 
There are some code lines to see if the pygame sound mixer is currently busy and if he is silent the <strong>spring.wav</strong> sound is played. 
Also because at each <em>catching</em> of the thief the screen is filled with a random colour, the code line checks if this frame (mainloop cycle) is the first of “normal” activity (no thief is catched) right after an “catch” frame. 
If yes, the old original background is blitted on the screen.
            catch_in_last_frame <span>=</span> catch_in_this_frame <span># save old catch info</span>
           catch_in_this_frame <span>=</span> <span>False</span>
           <span>if</span> <span>&#40;</span>distx <span>&lt;</span> police.<span>get_width</span><span>&#40;</span><span>&#41;</span> /<span>2</span><span>&#41;</span> <span>and</span> <span>&#40;</span>disty <span>&lt;</span> police.<span>get_height</span><span>&#40;</span><span>&#41;</span>/<span>2</span><span>&#41;</span>:
               catch_in_this_frame <span>=</span> <span>True</span>
               points +<span>=</span> seconds
               screen.<span>fill</span><span>&#40;</span>randomcolour<span>&#40;</span><span>&#41;</span><span>&#41;</span> 
               <span>if</span> <span>not</span> pygame.<span>mixer</span>.<span>get_busy</span><span>&#40;</span><span>&#41;</span>:
                   spring.<span>play</span><span>&#40;</span><span>&#41;</span> <span># only play this sound if mixer is silent at the moment</span>
           <span>else</span>:
               <span># no catch this time</span>
               <span>if</span> catch_in_last_frame:
                   screen.<span>blit</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span> <span># restore backgrounnd</span>

<h3>Ideas</h3>

&lt;note tip&gt;ideas:
head over to <a href="http://www.openstreetmap.org/">http://www.openstreetmap.org/</a> , find a map from your city, and use it ! (right-click on the map, select “save image as…”)
Improve one-player modus by adding &lt;key&gt;w&lt;/key&gt; &lt;key&gt;a&lt;/key&gt; &lt;key&gt;s&lt;/key&gt; &lt;key&gt;d&lt;/key&gt; as control keys
enable direct control for mouse or keyboard (like manipulating snakex, snakey instead of snakedx, snakedy)
create additional sprites
play a music file
use proportional force (like a rubber band): the further away the police surface is from the cross, the faster it travels toward the cross
split the code into  a config file (with all the constants and variables) and into a game file
dynamic score points: calculate the current distance between police and thief. 
Give points all the time, based on this distance (0 distance - max points)
draw a line between police and thief. 
The line should become thicker if the distance police-thief becomes shorter

&lt;/note&gt;

<h3>Trivia</h3>

&lt;note&gt;trivia: This games is inspired by the Austrian tv cult series <a href="https://de.wikipedia.org/wiki/Kottan">Kottan</a>. 
As the content and visuals of this series are -sadly- neither public domain nor creative-commons licensed i use free graphics. 
But on your own computer, you can replace the sprite graphics with some characters of your favorite TV show.&lt;/note&gt;

<h3>Documentation</h3>

<a href="http://www.pygame.org/docs/ref/transform.html#pygame.transform.scale">http://www.pygame.org/docs/ref/transform.html#pygame.transform.scale</a>
<a href="http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.get_busy">http://www.pygame.org/docs/ref/mixer.html#pygame.mixer.get_busy</a>

<h3>Source Code on Github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/013_catch_the_thief.py">013_catch_the_thief.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/wien.jpg">wien.jpg</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/wien.jpg"><img src="http://thepythongamebook.com/_media/en:part2:part2step013.jpg?w=150&amp;tok=3c28fc"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/snake.gif">snake.gif</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/snake.gif"><img src="http://thepythongamebook.com/_media/en:part2:pygame:pysnake150.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a> <br/>
from <a href="http://commons.wikimedia.org/wiki/File:Mini-babytux.gif">wikimedia commons</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/spring.wav">spring.wav</a> <br/>
from Battle of Wesnoth    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/time_is_up_game_over.ogg">time_is_up_game_over.ogg</a> <br/>
from Neverball    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/013_catch_the_thief.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/013_catch_the_thief.py</a>
	
<h1 class="title">Step 014 - Pygame sprites</h1>
<h3>code discussion</h3>

<a href="/_detail/en:part2:part2step014.jpg?id=en%3Apygame%3Astep014"><img src="http://thepythongamebook.com/_media/en:part2:part2step014.jpg?w=350&amp;tok=9f397f"></a>
If you analyze the previous <a href="/en:pygame:step013">catch-the-thief game</a> you will notice that most of the code in the main loop takes care of cleaning, calculating and blitting the pygame surfaces (the <em>sprites</em>). 
Pygame provides a very powerful pygame.sprite <strong>class</strong> for more elegant and object-oriented sprite programming. 


The advantages of using a sprite>self</strong>) but you can also use>pygame.sprite.Group</strong>s for mass processing 
pygame provides easy-to-use collision detection between sprites

<h4 id="what_is_a_class">what is a>
Please refer to the python documentation or other tutorials for a better introduction into object-oriented programming. 
For quick and dirty coding, it is enough if you compare using a sprite>Cookie_cutter</a> you can construct many <a href="https://en.wikipedia.org/wiki/Cookies">cookies</a>. 
Think of the cookie cutter as the <strong>class</strong> and of the cookies as the (constructed) <strong>instances of this>. 
The>code example of a sprite>

<a href="https://de.wikipedia.org/wiki/Teig"><img src="http://thepythongamebook.com/_media/en:part2:793px-pizza_1_bg.jpg?w=150&amp;tok=a04619"></a>   +   <a href="https://en.wikipedia.org/wiki/Cookie_cutter"><img src="http://thepythongamebook.com/_media/en:part2:cookiecuttersal.jpg?w=150&amp;tok=64ec2c"></a>   =  <a href="https://en.wikipedia.org/wiki/Cookies"><img src="http://thepythongamebook.com/_media/en:part2:800px-christmas_cookies_plateful.jpg?w=150&amp;tok=45ec4a"></a>  
dough    a cookie cutter    many cookies  
some coding   ><span>class</span> Snake<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   <span>&quot;&quot;&quot;the pygame Snake&quot;&quot;&quot;</span>
   image <span>=</span> pygame.<span>image</span>.<span>load</span><span>&#40;</span><span>&quot;Snake.gif&quot;</span><span>&#41;</span>
   image <span>=</span> image.<span>convert_alpha</span><span>&#40;</span><span>&#41;</span>
   <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> startpos<span>&#41;</span>:
      pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span>
                             <span>self</span>.<span>groups</span><span>&#41;</span> 
      <span>self</span>.<span>pos</span> <span>=</span> startpos
      <span>self</span>.<span>image</span> <span>=</span> Snake.<span>image</span> 
      <span>self</span>.<span>rect</span> <span>=</span> <span>self</span>.<span>image</span>.<span>get_rect</span><span>&#40;</span><span>&#41;</span>
   <span>def</span> update<span>&#40;</span><span>self</span><span>&#41;</span>:
      <span>self</span>.<span>rect</span>.<span>center</span> <span>=</span> <span>self</span>.<span>pos</span>
<a href="/_detail/en:part2:snakes.png?id=en%3Apygame%3Astep014"><img src="http://thepythongamebook.com/_media/en:part2:snakes.png?w=200&amp;tok=5c0480"></a> 

<h4 id="discussion_of_sprite_classes">discussion of sprite>
In the code example above (below the cookies) you can how a sprite>class</strong>) with a beginning capital Letter, in this case <strong>S</strong>nake instead of <strong>snake</strong>. 
Also note that this>derives from</em> (is a child of) pygame&#039;s Sprite><span>class</span> Snake<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:

Directly after the>    image <span>=</span> pygame.<span>image</span>.<span>load</span><span>&#40;</span><span>&quot;Snake.gif&quot;</span><span>&#41;</span>
   image <span>=</span> image.<span>convert_alpha</span><span>&#40;</span><span>&#41;</span>

describe>class prefix self</h4>
Now comes the part describing each>self</strong> is used. 
You could use another prefix but most python coders write <strong>self</strong>. 
Each function need at least the argument <strong>self</strong>, even if no other parameter is passed to the function. 
The first function that every pygame sprite><span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>&#41;</span>:

A part from the usual <strong>self</strong>, you can give the new born Snake as many arguments as you need, like initial position, behaviour, color etc. 
In the next example, only a startpos is given, defaulting to (50,50) if the sprite is created without a startpos.

<strong>The sprite will not work until you tell pygame to do all the stuff that it needs doing to create a new sprite. 
This is done by calling the __init__ function of the>, also a good way to handle pygame&#039;s sprite groups.

<h4 id="storing_class_parameters">storing>
If you want to store any parameters for the sprite itself (so that other functions like an update or kill function can access them, you need to save the parameter into a><span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> startpos<span>=</span><span>&#40;</span><span>50</span><span>,</span><span>50</span><span>&#41;</span><span>&#41;</span>:
      pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span><span>self</span>.<span>groups</span><span>&#41;</span> <span># never forget this line !</span>
      <span>self</span>.<span>pos</span> <span>=</span> startpos                        <span># store startpos into a>

<h4 id="call_the_property_of_the_class">call the property of the>
Now you are free to code all the property&#039;s of the>self</strong> to indicate that a property (like the position) is valid or this individual snake (class instance) only. 
Here, the starpos argument is stored into the variable self.pos:
<span>self</span>.<span>pos</span> <span>=</span> startpos

To access><span>self</span>.<span>image</span> <span>=</span> Snake.<span>image</span>

<h4 id="useful_stuff_for_each_class">useful stuff for each>

self.image …how the sprite look. 
It&#039;s a pygame surface, loaded or created, and you can use the pygame.draw commands on it.
self.rect  …very useful, get it with the command <code>self.rect = self.image.get_rect()</code> after you are done with creating self.image
self.radius … useful for circular collision detection
self.rect.center … if you have self.rect, use this to control the postion of a sprite on the screen.
update(self, time): … a function (best with the passed seconds since last frame as argument) where you can calculate what the sprite should do, like moving, bouncing of walls etc
kill(self) … very useful to destroy a sprite. 
the call inside the>a complete sprite>
This is the complete code for the Birdcatcher>source code</a>. 
This>self.image</strong>.
<span>class</span> BirdCatcher<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   <span>#>
   image <span>=</span> pygame.<span>Surface</span><span>&#40;</span><span>&#40;</span><span>100</span><span>,</span><span>100</span><span>&#41;</span><span>&#41;</span> <span># created on the fly</span>
   image.<span>set_colorkey</span><span>&#40;</span><span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span> <span># black transparent</span>
   pygame.<span>draw</span>.<span>circle</span><span>&#40;</span><span>self</span>.<span>image</span><span>,</span> <span>&#40;</span><span>255</span><span>,</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>,</span> <span>&#40;</span><span>50</span><span>,</span><span>50</span><span>&#41;</span><span>,</span> <span>50</span><span>,</span> <span>2</span><span>&#41;</span> <span># red circle</span>
   image <span>=</span> <span>self</span>.<span>image</span>.<span>convert_alpha</span><span>&#40;</span><span>&#41;</span>
   <span># code for each individual>
   <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>&#41;</span>:
       pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span> <span>self</span>.<span>groups</span><span>&#41;</span> <span># THE most important line !</span>
       <span>self</span>.<span>image</span> <span>=</span> BirdCatcher.<span>image</span> <span># make>
       <span>self</span>.<span>rect</span> <span>=</span> <span>self</span>.<span>image</span>.<span>get_rect</span><span>&#40;</span><span>&#41;</span>
       <span>self</span>.<span>radius</span> <span>=</span> <span>50</span> <span># for collide check</span>
   <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> seconds<span>&#41;</span>:
       <span># no need for seconds but the other sprites need it</span>
       <span>self</span>.<span>rect</span>.<span>center</span> <span>=</span> pygame.<span>mouse</span>.<span>get_pos</span><span>&#40;</span><span>&#41;</span>
&nbsp;

<h4 id="before_the_main_loop">before the main loop</h4>
Before the main loop starts, you define some pygame.sprite.Groups to contain all the sprites:
If you have a Sprite <strong>Snake</strong> and the two groups <strong>allgroup</strong> and <strong>snakegroup</strong> you can assign that all Snake sprites should be members of both groups:
allgroup <span>=</span> pygame.<span>sprite</span>.<span>Group</span><span>&#40;</span><span>&#41;</span>
snakegroup <span>=</span> pygame.<span>sprite</span>.<span>Group</span><span>&#40;</span><span>&#41;</span>
<span># each Snake sprite is automatically member of both groups:</span>
Snake.<span>groups</span> <span>=</span> allgroup<span>,</span> snakegroup
<span># create a single Snake named &quot;mypython&quot;</span>
mypython <span>=</span> Snake<span>&#40;</span><span>&#41;</span> 

<h4 id="what_to_do_in_the_mainloop">what to do in the mainloop</h4>
You must make sure that your sprites belong to a sprite group (like allsprites). 
In the mainloop, you simply call those commands each frame:
allsprites.<span>clear</span><span>&#40;</span>screen<span>,</span> background<span>&#41;</span>
allsprites.<span>update</span><span>&#40;</span>seconds<span>&#41;</span>
allsprites.<span>draw</span><span>&#40;</span>screen<span>&#41;</span>
pygame.<span>display</span>.<span>flip</span><span>&#40;</span><span>&#41;</span>

<h3>documentation</h3>

<a href="http://www.pygame.org/docs/ref/sprite.html">http://www.pygame.org/docs/ref/sprite.html</a>
<a href="http://www.pygame.org/docs/ref/examples.html">http://www.pygame.org/docs/ref/examples.html</a> (pygame version 1.9) 
the aliens example: <a href="http://www.pygame.org">www.pygame.org</a>

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/014_sprites.py">014_sprites.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png">babytux_neg.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux_neg.png"></a>    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/014_sprites.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/014_sprites.py</a>
	
<h1 class="title">Step 015 - Explosions, healthbars and gravity</h1>

<h3>code discussion</h3>

<a href="/_detail/en:part2:part2step015.jpg?id=en%3Apygame%3Astep015"><img src="http://thepythongamebook.com/_media/en:part2:part2step015.jpg?w=400&amp;tok=0eb55a"></a>

In the code example below (see <a href="#source_code" title="en:pygame:step015 ↵">source code</a>) you can create and kill sprites by mouse click. 
For each kill there is an explosion effect: a sound plays and a random amount of fragments is flying around. 
The fragments are subject to a gravity force.

Also note:
Each Bird sprite has it&#039;s own livebar sprite (a green bar to display the remaining hitpoints). 
Each bird create it&#039;s own hitbar inside the init method !
<span>class</span> Bird<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
  <span># ..</span>
  <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> pos<span>&#41;</span>:
     <span>#..</span>
     Livebar<span>&#40;</span><span>self</span><span>&#41;</span> <span>#create a Livebar for this Bird. 
self is the Bird sprite as parameter</span>

Each Livebar get his “boss” as parameter when created:
<span>class</span> Livebar<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
       <span>#..</span>
       <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> boss<span>&#41;</span>:
           <span>#.. 
</span>
           <span>self</span>.<span>boss</span> <span>=</span> boss <span># the boss is the bird sprite</span>

The main purpose of the code example is to demonstrate the difference between a bad and a good sprite collision detection. 
As each <strong>Bird</strong><sup><a href="#fn__1" id="fnt__1">1)</a></sup> sprite moves around the screen, it is checked (in the mainloop) for collision with another <strong>Bird</strong> sprite. 
(A even more clever way will be demonstrated in the next steps).

<h4 id="good">good</h4>
The efficient way to do so was friendly showed me by <a href="/en:resources:people:gummbum:start">Gummbum</a> from the <a href="http://groups.google.com/group/pygame-mirror-on-google-groups/">pygame mailing list</a>
<span>#...before mainloop...</span>
othergroup <span>=</span>  <span>&#91;</span><span>&#93;</span>  <span>#create empty list</span>
&nbsp;
<span>#...inside mainloop...</span>
<span>while</span> mainloop:
   <span># ... 
the usual mainloop code</span>
&nbsp;
   <span># test if a bird collides with another bird</span>
   <span>for</span> bird <span>in</span> birdgroup:
       othergroup<span>&#91;</span>:<span>&#93;</span> <span>=</span> birdgroup.<span>sprites</span><span>&#40;</span><span>&#41;</span> <span># This is the correct code, no garbage collection</span>
       othergroup.<span>remove</span><span>&#40;</span>bird<span>&#41;</span> <span># remove the actual bird, only all other birds remain</span>
       <span>if</span> pygame.<span>sprite</span>.<span>spritecollideany</span><span>&#40;</span>bird<span>,</span> othergroup<span>&#41;</span>: 
           bird.<span>crashing</span> <span>=</span> <span>True</span>
           crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> othergroup<span>,</span> <span>False</span> <span>&#41;</span>
           <span>for</span> crashbird <span>in</span> crashgroup:
               bird.<span>dx</span> -<span>=</span> crashbird.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> - bird.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span>
               bird.<span>dy</span> -<span>=</span> crashbird.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> - bird.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span>

<h4 id="wrong">wrong</h4>
If you write instead of the <code>othergroup[:] = ….</code> line this code:
othergroup <span>=</span> birdgroup.<span>copy</span><span>&#40;</span><span>&#41;</span> <span># WRONG ! THIS CODE MAKES UGLY TIME-CONSUMING GARBAGE COLLECTION !</span>

you will notice longer delays between 2 frames as soon as many objects are on the screen.

The .copy() command, excecuted each frame, each up huge blocks of memory. 
This block of memory has to be cleaned again from time to time and while pygame 
does so, you can notice a huge pause…the game “hangs”. 
This effect will only become visible if you have many sprites moving around. 
Watch the <code>max(ms)</code> display in the pygame title or the length of the green <strong>Timebar</strong> bars.

In the source code example at the end of this page you can toggle efficient and inefficient coding by pressing &lt;key&gt;b&lt;/key&gt;. 


<h4 id="clever">clever</h4>
Instead of creating another group for all Birds without the actual Bird you can also compare with the whole birdgroup and check the Bird&#039;s number attribute to make sure there is a collision between two different sprites:
<span># very clever coding</span>
crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> birdgroup<span>,</span> <span>False</span><span>&#41;</span> <span># the actual Bird is also in birdgroup</span>
<span>for</span> crashbird <span>in</span> crashgroup: 
   <span>if</span> crashbird.<span>number</span> <span>!=</span> bird.<span>number</span>: <span>#avoid collision with itself</span>

In the source code example at the end of this page you can toggle clever coding by pressing &lt;key&gt;c&lt;/key&gt;

<h3>overwriting a>

Take a look at the code of the <strong>def kill(self)</strong> method of the (huge) <strong>Bird</strong> sprite>Timebar</strong> sprite>self.kill()</code> command, but you will find no <code>def kill(self):</code> function in the <strong>Timebar</strong> sprite>pygame.sprite.Sprite</strong>>def kill(self)</code> method. 
As the name suggest, <code>self.kill()</code> removes the actual sprite from the screen and from all groups.
<span>class</span> Timebar<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
  <span>#..</span>
  <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> <span>time</span><span>&#41;</span>:
       <span>self</span>.<span>rect</span>.<span>centery</span> <span>=</span> <span>self</span>.<span>rect</span>.<span>centery</span> - <span>7</span> <span># each timebar kill itself when it leaves the screen</span>
       <span>if</span> <span>self</span>.<span>rect</span>.<span>centery</span> <span>&lt;</span> <span>0</span>:
           <span>self</span>.<span>kill</span><span>&#40;</span><span>&#41;</span> <span># remove the sprite from screen and from all groups</span>

<h3>over writing kill</h3>

However, the more complicated <strong>Bird</strong> sprite>def kill(self):</code> function. 
That is because I want to do some extra stuff before killing the sprite, like playing a sound effect and shattering fragments around the screen. 
Also in this case I want to remove the <strong>Bird</strong> sprite from a special dictionary where I store each <strong>Bird</strong> sprite and its individual number. 
Therefore, I overwrite the <code>def kill(self):</code> function, do my special things and finally call pygame&#039;s kill method directly: <code>pygame.sprite.Sprite.kill(self)</code>

Big Badda Boom!
<span>class</span> Bird<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
  <span>#..</span>
  <span>def</span> kill<span>&#40;</span><span>self</span><span>&#41;</span>:
       <span>&quot;&quot;&quot;because i want to do some special effects (sound, dictionary etc.)
       before killing the Bird sprite i have to write my own kill(self)
       function and finally call pygame.sprite.Sprite.kill(self) 
       to do the 'real' killing&quot;&quot;&quot;</span>
       cry.<span>play</span><span>&#40;</span><span>&#41;</span>   <span>#play sound effect</span>
       <span>for</span> _ <span>in</span> <span>range</span><span>&#40;</span><span>random</span>.<span>randint</span><span>&#40;</span><span>3</span><span>,</span><span>15</span><span>&#41;</span><span>&#41;</span>:
           Fragment<span>&#40;</span><span>self</span>.<span>pos</span><span>&#41;</span> <span># create Fragment sprites</span>
       Bird.<span>birds</span><span>&#91;</span><span>self</span>.<span>number</span><span>&#93;</span> <span>=</span> <span>None</span> <span># kill Bird in sprite dictionary</span>
       pygame.<span>sprite</span>.<span>Sprite</span>.<span>kill</span><span>&#40;</span><span>self</span><span>&#41;</span> <span># kill the actual Bird </span>

<h3>Exploding fragments</h3>

The Fragment><a href="#fn__2" id="fnt__2">2)</a></sup>. 
Note that you can toggle gravity by pressing &lt;key&gt;g&lt;/key&gt; during the game. 
The effect of the gravity is handled in the update method of the Fragment><span>class</span> Fragment<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   <span>&quot;&quot;&quot;a fragment of an exploding Bird&quot;&quot;&quot;</span>
   gravity <span>=</span> <span>True</span> <span># fragments fall down ?</span>
   <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> pos<span>&#41;</span>:
           pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span> <span>self</span>.<span>groups</span><span>&#41;</span>
           <span>self</span>.<span>pos</span> <span>=</span> <span>&#91;</span><span>0.0</span><span>,</span><span>0.0</span><span>&#93;</span>
           <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> <span>=</span> pos<span>&#91;</span><span>0</span><span>&#93;</span>
           <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> <span>=</span> pos<span>&#91;</span><span>1</span><span>&#93;</span>
           <span>#...</span>
           <span>self</span>.<span>dx</span> <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span>-<span>self</span>.<span>fragmentmaxspeed</span><span>,</span><span>self</span>.<span>fragmentmaxspeed</span><span>&#41;</span>
           <span>self</span>.<span>dy</span> <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span>-<span>self</span>.<span>fragmentmaxspeed</span><span>,</span><span>self</span>.<span>fragmentmaxspeed</span><span>&#41;</span>
&nbsp;
   <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> seconds<span>&#41;</span>:
           <span>#...</span>
           <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dx</span> * seconds
           <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dy</span> * seconds
           <span>if</span> Fragment.<span>gravity</span>:
               <span>self</span>.<span>dy</span> +<span>=</span> FORCE_OF_GRAVITY <span># gravity suck fragments down</span>
           <span>self</span>.<span>rect</span>.<span>centerx</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>
           <span>self</span>.<span>rect</span>.<span>centery</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>

<h4 id="layers">Layers</h4>
By default, pygame will blit the sprites in the order the sprites are added. 
IF you prefer precise order of drawing the sprites (like the mouse pointer always before all other sprites) you can do two things:
use several <code>clear</code>, <code>update</code> and <code>draw</code> commands, one for each sprite group:
use the <code>pygame.sprite-LayeredUpdates</code> group instead of a sprite group and set a default layer for each group, like in the code example below:
    <span># LayeredUpdates instead of group to draw in correct order</span>
   allgroup <span>=</span> pygame.<span>sprite</span>.<span>LayeredUpdates</span><span>&#40;</span><span>&#41;</span> <span># important</span>
   <span>#assign default groups to each sprite>
   Livebar.<span>groups</span> <span>=</span>  bargroup<span>,</span> allgroup 
   Timebar.<span>groups</span> <span>=</span> bargroup<span>,</span> allgroup
   Bird.<span>groups</span> <span>=</span>  birdgroup<span>,</span> allgroup
   Fragment.<span>groups</span> <span>=</span> fragmentgroup<span>,</span> allgroup
   BirdCatcher.<span>groups</span> <span>=</span> stuffgroup<span>,</span> allgroup
   <span>#assign default layer for each sprite (lower numer is background)</span>
   BirdCatcher._layer <span>=</span> <span>5</span> <span># top foreground</span>
   Fragment._layer <span>=</span> <span>4</span>
   Timebar._layer <span>=</span> <span>3</span>
   Bird._layer <span>=</span> <span>2</span>
   Livebar._layer <span>=</span> <span>1</span> <span>#background</span>

More about layers in the next step.

<h3>putting the whole game inside a function</h3>

You may have noticed that the whole game sits inside a function called <code>def game():</code>. 
This is useful when we later make a game menu that starts the game. 
Because it will be sensible to split the game code into a menu.py and a startgame.py file. 
The menu.py file will <strong>import</strong> the startgame and call it when the user chooses the menu option. 
To be more precise, the menu.py file will start a single <strong>function</strong> inside the startgame.py file. 
(If there is no meaningful function defined inside startgame.py  the menu file would start startgame.py right after importing it, before displaying a menu and waiting for the user&#039;s choice).

<h3>python modules</h3>

We have no menu.py (yet) but we can prepare for it by stuffing all interesting parts (shooting up penguins etc) inside a function - let&#039;s call the function <strong>game()</strong> (see below). 
But how do we start the game directly? For that, we check the internal python variable __name__. 
In this variable, python stores the name of the python module that <strong>import</strong>ed the actual python program. 
If we started the actual python program directly (from the terminal or from the python editor), then this variable gets the value __main__ from python.
Therefore you will find in many python <strong>modules</strong><sup><a href="#fn__3" id="fnt__3">3)</a></sup> those lines:
<span>def</span> game<span>&#40;</span><span>&#41;</span>:
 <span>#.. 
all the interesting stuff</span>
<span>if</span> __name__ <span>==</span> <span>&quot;__main__&quot;</span>:
   <span>print</span> <span>&quot;i was started directly and will start game()&quot;</span>
   game<span>&#40;</span><span>&#41;</span>  <span># start the interesting stuff </span>
<span>else</span>:
   <span>print</span> <span>&quot;i am imported by&quot;</span><span>,</span>__name__<span>,</span> <span>&quot;and will do nothing at the moment&quot;</span>

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/015_more_sprites.py">015_more_sprites.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png">babytux_neg.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux_neg.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/claws.ogg">claws.ogg</a>  <br/>
from Battle of Wesnoth    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/015_more_sprites.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/015_more_sprites.py</a>

click reload in your browser if you see no code here:
	
<h1 class="title">Step 016 - LayeredUpdates and Parallax scrolling</h1>
<h1 class="title">gameplay</h1>
<a href="/_detail/en:part2:part2step016.jpg?id=en%3Apygame%3Astep016"><img src="http://thepythongamebook.com/_media/en:part2:part2step016.jpg?w=400&amp;tok=459c71"></a>

The source code example below is not much of a game, but it demonstrates the uses of layers for sprites and <a href="https://en.wikipedia.org/wiki/Parallax_scrolling">Parallax_scrolling</a> (the mountains). 
Also, you can hide penguins behind blocks and mountains.
Additionally, you can aim with the mouse pointer and press &lt;key&gt;p&lt;/key&gt; to print out information about the layers (at the text console).

<strong>Trivia:</strong>

<a href="http://www.arcade-museum.com/game_detail.php?game_id=8747"><img src="http://thepythongamebook.com/_media/en:part2:moon-patrol.png"></a>

According to wikipedia, Parallax scrolling was first introduced to computer games by the arcade game <a href="https://en.wikipedia.org/wiki/Moon_Patrol">Moon_Patrol</a> 1982. 
The mountains (and in higher levels, futuristic buildings) moved at different speed to create the illusion of a <a href="https://en.wikipedia.org/wiki/Side-scroller">side-scrolling computer game</a>.

<strong>proposals to tinker:</strong>
Change the layer of the three types of>pevious step</a>, let the Birds change <code>_layer</code> by random and explode them by mouseclick !

<h1 class="title">code discussion</h1>
<h2>- layers</h2>
Do you remember the sprite groups from the last step ? Sprite groups are basically containers where the sprites “live” in. 
As soon as a sprite is killed (by it&#039;s <code>kill()</code> functoin) the sprite is not also removed from the screen but also from all containers holding it. 
In the last two steps, i had two uses for sprite groups:

The <code>allgroup</code> (every sprite was member of this group), to clear, draw, and update all sprites from within the main loop
other groups like <code>birdgroup</code>, used to check each sprite in this group for collision detection (crashgroup)


You will note that there exist different variants of sprite groups:
the old <strong>spritegroup</strong>
the newer <strong>LayeredUpdate</strong> group

When using <code>pygame.sprite.Layeredupdate()</code> instead of <code>pygame.sprite.Group()</code> you can give each sprite a variable <code>_layer</code> as well as a variable <code>groups</code> to influence the drawing order of the sprite. 
In the <a href="/en:part2:pygame:step015">previous step</a> those variables were defined outside the sprite>__init__(self)</strong> method of each sprite>
The sprite groups must exist (be defined in the mainloop) before you can assign sprites to the groups. 
That means, inside the mainloop, before you create a Bird sprite or assign images to the Bird>before</strong> you call <strong>pygame.sprite.Sprite.__init__(self, *groups):</strong>


&lt;note&gt;<strong>#…</strong> means that i let away some not so important code lines&lt;/note&gt;
<span>class</span> Bird<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
       <span>#...</span>
       <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> startpos<span>=</span>screen.<span>get_rect</span><span>&#40;</span><span>&#41;</span>.<span>center</span><span>&#41;</span>:
           <span>self</span>.<span>groups</span> <span>=</span> birdgroup<span>,</span> allgroup <span># assign groups BEFORE calling pygame.sprite.Sprite.__init__</span>
           <span>self</span>._layer <span>=</span> <span>7</span>                   <span># assign _layer BEFORE calling pygame.sprite.Sprite.__init__ </span>
           pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span>  <span>self</span>.<span>groups</span> <span>&#41;</span> <span>#call parent>
           <span>self</span>.<span>pos</span> <span>=</span> starpos
           <span># ...</span>
<span># define sprite groups </span>
birdgroup <span>=</span> bargroup <span>=</span> pygame.<span>sprite</span>.<span>Group</span><span>&#40;</span><span>&#41;</span> <span># simple group for collision detection</span>
allgroup  <span>=</span> pygame.<span>sprite</span>.<span>LayeredUpdates</span><span>&#40;</span><span>&#41;</span> <span># more sophisticated and modern group</span>
&nbsp;
<span># assign images to the Bird>
Bird<span>&#40;</span><span>&#41;</span>
<hr />

<h3>pygame.sprite.LayeredUpdates</h3>

please see the official pygame doumentation at: <a href="http://www.pygame.org/docs/ref/sprite.html#pygame.sprite.LayeredUpdates">http://www.pygame.org/docs/ref/sprite.html#pygame.sprite.LayeredUpdates</a>
<hr />

<h3>changing layers</h3>

The cool things about layers is: you can change them even at runtime, to place sprites more in the foreground or more in the background (see code example below). 
The <strong>change_layer</strong> method does exaclty that. 
Important: you need only to change the layer of the LayeredUpdates-group that actually draws the sprites on the screen. 
In the code example below, this is the <strong>allgroup</strong>. 
(Special thanks to <a href="/en:resources:people:gummbum:start">Gummbum</a> for helping me out here). 
Because i want only to change the layer of the <strong>Bird</strong> sprites and their <strong>Lifebar</strong> sprites i loop over all sprites in the groups <strong>birdgroup</strong> and <strong>bargroup</strong>. 
Each Bird sprite is a member of the allgroup as well as of the birdgroup. 
Each Lifebar sprite is a member of the allgroup as well as of the bargroup.
<span>if</span> pygame.<span>mouse</span>.<span>get_pressed</span><span>&#40;</span><span>&#41;</span><span>&#91;</span><span>0</span><span>&#93;</span>:
 <span>if</span> birdlayer <span>&lt;</span> <span>10</span>:
    birdlayer +<span>=</span> <span>1</span>
    cooldowntime <span>=</span> <span>.5</span> <span># seconds</span>
    cry.<span>play</span><span>&#40;</span><span>&#41;</span>
    <span>for</span> bird <span>in</span> birdgroup:
        allgroup.<span>change_layer</span><span>&#40;</span>bird<span>,</span> birdlayer<span>&#41;</span> <span># allgroup draws the sprite </span>
    <span>for</span> bar <span>in</span> bargroup:
        allgroup.<span>change_layer</span><span>&#40;</span>bar<span>,</span> birdlayer<span>&#41;</span> <span># allgroup draws the sprite </span>

<h2>- Textsprite</h2>
Up to now, i blitted all text to the screen or to the background with the write function. 
In this example, you will see a new>Text</strong>, also printing a msg to the screen. 
The Text sprite has no advantages over blitting directly to the background yet, but you can use it later to change the _layer of the Text sprite or if you want the Text sprite to move around. 
Note that 
the>newmsg</strong> to update the displaying text string.
<span>def</span> newmsg<span>&#40;</span><span>self</span><span>,</span> birdlayer<span>&#41;</span>:
   <span>self</span>.<span>image</span> <span>=</span>  write<span>&#40;</span><span>&quot;current Bird _layer = %i&quot;</span> % birdlayer<span>&#41;</span>
   <span>self</span>.<span>rect</span> <span>=</span> <span>self</span>.<span>image</span>.<span>get_rect</span><span>&#40;</span><span>&#41;</span>
   <span>self</span>.<span>rect</span>.<span>center</span> <span>=</span> <span>&#40;</span>screen.<span>get_width</span><span>&#40;</span><span>&#41;</span>/<span>2</span><span>,</span><span>10</span><span>&#41;</span>

<h2>- waiting Birds</h2>
Take a look at the Bird>Bird.waittime</strong> indicating how long a Bird should stay “invisible”. 
Instead of messing around with drawing and not drawing, during his “invisible” <strong>waittime</strong>, each bird is simply teleported to the position (-100,-100), that is outside your screen. 
If the waittime is over, the Bird sprite is teleported to his Bird.pos position and act like a normal Bird sprite - speeding around, crashing into walls and other birds, exploding.
Class Bird<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   waittime <span>=</span> <span>1.0</span> <span>#seconds</span>
   <span>#...</span>
   <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> seconds<span>&#41;</span>:
       <span>#---make Bird only visible after waiting time</span>
       <span>self</span>.<span>lifetime</span> +<span>=</span> seconds
       <span>if</span> <span>self</span>.<span>lifetime</span> <span>&gt;</span> <span>&#40;</span><span>self</span>.<span>waittime</span><span>&#41;</span> <span>and</span> <span>self</span>.<span>waiting</span>:
          <span>self</span>.<span>newspeed</span><span>&#40;</span><span>&#41;</span>
          <span>self</span>.<span>waiting</span> <span>=</span> <span>False</span>
          <span>self</span>.<span>rect</span>.<span>centerx</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>
          <span>self</span>.<span>rect</span>.<span>centery</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>
       <span>if</span> <span>self</span>.<span>waiting</span>:
          <span>self</span>.<span>rect</span>.<span>center</span> <span>=</span> <span>&#40;</span>-<span>100</span><span>,</span>-<span>100</span><span>&#41;</span>
       <span>else</span>:
          <span># speedcheck</span>
          <span>#.. 
all the other things</span>

But why the waittime ? The answer is a modification to the <strong>Fragment</strong>><span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> layer<span>=</span><span>4</span><span>&#41;</span>:
  <span>#...</span>
  Lifebar<span>&#40;</span><span>self</span>.<span>number</span><span>&#41;</span> <span>#create a Lifebar for this Bird. 
</span>
  <span># starting implosion of blue fragments</span>
  <span>for</span> _ <span>in</span> <span>range</span><span>&#40;</span><span>8</span><span>&#41;</span>:
        Fragment<span>&#40;</span><span>self</span>.<span>pos</span><span>,</span> <span>True</span><span>&#41;</span>

See the <strong>for</strong> loop ? I simply wanted 8 (blue) Fragments, so i do not use an variable like <strong>a</strong> or <strong>b</strong> or <strong>x</strong> inside the <strong>for</strong> loop but simply an underscore. 
The <strong>True</strong> parameter in the Fragment>dual-use Fragments</h2>
The fragment>if</strong>-<strong>else</strong> construct. 
The new part is only valid for “bluefrag” Fragments. 
After choosing per random from where (screen edge) the Fragment start, self.dx and self.dy are calculated… The Fragment should fly from the screen edge toward the position of the Bird sprite (self.target). 
But how fast does the fragment fly ? Because in the update method of the fragment>unit</em> of a sprite is measured in <strong>pixel per second</strong>. 
Meaning each blue sprite will need exactly one second to travel from it&#039;s origin to the Bird sprite position. 


But what if the waittime for each Birdsprite is 2 seconds ? or just a half second ? For this reason, dx and dy are multiplied by the factor ( 1.0 / Bird.waittime). 
So if the Bird waits 2 seconds before appearing, the blue Fragments have more time and should travel slower: 1.0 / 2.0 = 0.5, the speed is reduced. 
On the other hand, if the waittime is shorter (say 0.5 seconds) the Fragments should fly faster: ( 1.0 / 0.5 = 2); dx and dy is doubled.

For aesthetic reasons, i allow the blue Fragments to live up to a half second after reaching their target by adding to self.lifetime a value between 0 and 0.5: <code>random.random() * 0.5</code>. 
Random.random() creates a float value between 0 and 1.
<span>class</span> Fragment<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   <span>#... 
    </span>
   <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> pos<span>,</span> bluefrag <span>=</span> <span>False</span><span>&#41;</span>:
      <span>#...</span>
      <span>self</span>.<span>bluefrag</span> <span>=</span> bluefrag
      <span>self</span>.<span>pos</span><span>=</span><span>&#91;</span><span>0.0</span><span>,</span><span>0.0</span><span>&#93;</span>
      <span>self</span>.<span>target</span> <span>=</span> pos
      <span>if</span> <span>self</span>.<span>bluefrag</span>:      <span># blue frament implodes from screen edge toward Bird</span>
         <span>self</span>.<span>color</span> <span>=</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>random</span>.<span>randint</span><span>&#40;</span><span>25</span><span>,</span><span>255</span><span>&#41;</span><span>&#41;</span> <span># blue</span>
         <span>self</span>.<span>side</span> <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>1</span><span>,</span><span>4</span><span>&#41;</span>
         <span>if</span> <span>self</span>.<span>side</span> <span>==</span> <span>1</span>:  <span># left side</span>
              <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> <span>=</span> <span>0</span>   
              <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span>screen.<span>get_height</span><span>&#40;</span><span>&#41;</span><span>&#41;</span>
         <span>elif</span> <span>self</span>.<span>side</span> <span>==</span> <span>2</span>: <span># top</span>
              <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span>screen.<span>get_width</span><span>&#40;</span><span>&#41;</span><span>&#41;</span> 
              <span>#...</span>
         <span># calculating flytime for one second.. 
Bird.waittime should be 1.0</span>
         <span>self</span>.<span>dx</span> <span>=</span> <span>&#40;</span><span>self</span>.<span>target</span><span>&#91;</span><span>0</span><span>&#93;</span> - <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span><span>&#41;</span> * <span>1.0</span> / Bird.<span>waittime</span>
         <span>self</span>.<span>dy</span> <span>=</span> <span>&#40;</span><span>self</span>.<span>target</span><span>&#91;</span><span>1</span><span>&#93;</span> - <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span><span>&#41;</span> * <span>1.0</span> / Bird.<span>waittime</span>
         <span>self</span>.<span>lifetime</span> <span>=</span> Bird.<span>waittime</span> + <span>random</span>.<span>random</span><span>&#40;</span><span>&#41;</span> * <span>.5</span> <span># a bit more livetime after the Bird appears</span>
      <span>else</span>: <span># red fragment explodes from the bird toward screen edge</span>
         <span>#... 
 all the stuff for red Fragments</span>
&nbsp;
   <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> seconds<span>&#41;</span>:
      <span># ...</span>
      <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dx</span> * seconds
      <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dy</span> * seconds
      <span># ...</span>
      <span>self</span>.<span>rect</span>.<span>centerx</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>
      <span>self</span>.<span>rect</span>.<span>centery</span> <span>=</span> <span>round</span><span>&#40;</span><span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span><span>,</span><span>0</span><span>&#41;</span>

<h2>- scrolling mountains</h2>
You will notice that at the start of the game, the moutains “walk” in from right to left. 
All moutnains are instances of the same mountain>type</code> parameter (making blue, red or pink mountains).

Most of the work in this>__ini__</code>-method:
<span>class</span> Mountain<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
       <span>#...</span>
       <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> <span>type</span><span>&#41;</span>:
           <span>self</span>.<span>type</span> <span>=</span> <span>type</span>
           <span>if</span> <span>self</span>.<span>type</span> <span>==</span> <span>1</span>:
               <span>self</span>._layer <span>=</span> -<span>1</span>
               <span>self</span>.<span>dx</span> <span>=</span> -<span>100</span>
               <span>self</span>.<span>color</span> <span>=</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>255</span><span>&#41;</span> <span># blue mountains, close</span>
           <span>elif</span> <span>self</span>.<span>type</span> <span>==</span> <span>2</span>:
               <span>self</span>._layer <span>=</span> -<span>2</span>
               <span>self</span>.<span>color</span> <span>=</span> <span>&#40;</span><span>200</span><span>,</span><span>0</span><span>,</span><span>255</span><span>&#41;</span> <span># pink mountains, middle</span>
               <span>self</span>.<span>dx</span> <span>=</span> -<span>75</span>
           <span>else</span>:
               <span>self</span>._layer <span>=</span> -<span>3</span>
               <span>self</span>.<span>dx</span> <span>=</span> -<span>35</span>
               <span>self</span>.<span>color</span> <span>=</span> <span>&#40;</span><span>255</span><span>,</span><span>0</span><span>,</span><span>0</span><span>&#41;</span> <span># red mountains, far away</span>
           <span>self</span>.<span>groups</span> <span>=</span> allgroup<span>,</span> mountaingroup
           pygame.<span>sprite</span>.<span>Sprite</span>.<span>__init__</span><span>&#40;</span><span>self</span><span>,</span> <span>self</span>.<span>groups</span><span>&#41;</span> <span># THE Line</span>
           <span>#...</span>

Maybe the most interesting part here is the creation of the actual mountain. 
This is done with the help of the random.random() function (creates an decimal number between 0.0 and 1.0) and the <code>pygame.draw.polygon</code>-method. 
On each mountain surface, a filled triangle (polygon) is created from the lower left corner to a corner in the middle (x/2) and at a random height (the moutain peak) and back to the lower right corner. 
The syntax for pygame.draw.poligon is: <code>pygame.draw.polygon(surface, color, pointlist, width=0)</code>
<span>class</span> Mountain<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
  <span>#...</span>
  <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>,</span> <span>type</span><span>&#41;</span>:
           <span>#...</span>
           <span>self</span>.<span>dy</span> <span>=</span> <span>0</span>
           x <span>=</span> <span>100</span> * <span>self</span>.<span>type</span> * <span>1.5</span>
           y <span>=</span> screen.<span>get_height</span><span>&#40;</span><span>&#41;</span> / <span>2</span> + <span>50</span> * <span>&#40;</span><span>self</span>.<span>type</span> -<span>1</span><span>&#41;</span>
           <span>self</span>.<span>image</span> <span>=</span> pygame.<span>Surface</span><span>&#40;</span><span>&#40;</span>x<span>,</span>y<span>&#41;</span><span>&#41;</span>
           <span>self</span>.<span>image</span>.<span>set_colorkey</span><span>&#40;</span><span>&#40;</span><span>0</span><span>,</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span> <span># black is transparent</span>
           pygame.<span>draw</span>.<span>polygon</span><span>&#40;</span><span>self</span>.<span>image</span><span>,</span> <span>self</span>.<span>color</span><span>,</span>
              <span>&#40;</span><span>&#40;</span><span>0</span><span>,</span>y<span>&#41;</span><span>,</span>
               <span>&#40;</span><span>0</span><span>,</span>y-<span>10</span>*<span>self</span>.<span>type</span><span>&#41;</span><span>,</span> 
               <span>&#40;</span>x/<span>2</span><span>,</span> <span>int</span><span>&#40;</span><span>random</span>.<span>random</span><span>&#40;</span><span>&#41;</span>*y/<span>2</span><span>&#41;</span><span>&#41;</span><span>,</span>
               <span>&#40;</span>x<span>,</span>y-<span>10</span>*<span>self</span>.<span>type</span><span>&#41;</span><span>,</span>
               <span>&#40;</span>x<span>,</span>y<span>&#41;</span><span>,</span>
               <span>&#40;</span><span>9</span><span>,</span>y<span>&#41;</span><span>&#41;</span><span>,</span><span>0</span><span>&#41;</span> <span># width=0 fills the polygon</span>
           <span>self</span>.<span>image</span>.<span>convert_alpha</span><span>&#40;</span><span>&#41;</span>
           <span>self</span>.<span>rect</span> <span>=</span> <span>self</span>.<span>image</span>.<span>get_rect</span><span>&#40;</span><span>&#41;</span>

Each mountain has a <code>.parent</code> attribute, set to <strong>False</strong> in the <code>__ini__</code>-method. 
In the <code>update</code>-method of the moutain>type</code> is created and placed directly to it&#039;s right side (yet invisible because outside the screen border). 
If a mountain travels too far to the left side, it is killed.
<span>class</span> Mountain<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
 <span>#...</span>
 <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> <span>time</span><span>&#41;</span>:
    <span>if</span> <span>self</span>.<span>rect</span>.<span>centerx</span> + <span>self</span>.<span>rect</span>.<span>width</span>/<span>2</span>+<span>10</span> <span>&lt;</span> <span>0</span>:
       <span>self</span>.<span>kill</span><span>&#40;</span><span>&#41;</span>
       <span># create new mountains if necessary</span>
    <span>if</span> <span>not</span> <span>self</span>.<span>parent</span>:
       <span>if</span> <span>self</span>.<span>rect</span>.<span>centerx</span>  <span>&lt;</span> screen.<span>get_width</span><span>&#40;</span><span>&#41;</span>:
          <span>self</span>.<span>parent</span> <span>=</span> <span>True</span>
          Mountain<span>&#40;</span><span>self</span>.<span>type</span><span>&#41;</span> <span># new Mountain coming from the right side</span>
&nbsp;

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/016_layers.py">016_layers.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png">babytux_neg.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux_neg.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/claws.ogg">claws.ogg</a>  <br/>
from Battle of Wesnoth    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/016_layers.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/016_layers.py</a>
	
<h1 class="title">Step 017 - Rotating, shooting, inheritance, physics</h1>

Time to play! The source code example below is an actual playable game, demonstrating several different concepts:

<a href="https://en.wikipedia.org/wiki/Trigonometric_functions">Trigonometric_functions</a> to rotate objects
<a href="https://en.wikipedia.org/wiki/Inheritance_(computer_science)">Inheritance</a> to build>Elastic collision</a> between to physical objects (birds, but reduced to physical <strong>disc&#039;s).
</strong>&lt;note important&gt;Horst: what are physical discs?&lt;/note&gt;


<h1 class="title">gameplay</h1>
<a href="/_detail/en:part2:part2step017.png?id=en%3Apygame%3Astep017"><img src="http://thepythongamebook.com/_media/en:part2:part2step017.png?w=400&amp;tok=42ca30"></a>
With the source code example below you can shoot down little penguins (again). 
This time, you steer a fat penguin and can rotate and move him with the &lt;key&gt;w&lt;/key&gt;,&lt;key&gt;a&lt;/key&gt;,&lt;key&gt;s&lt;/key&gt;,&lt;key&gt;d&lt;/key&gt; keys. 
The movement is <em>relative</em> to the facing of the fat penguin; by pressing &lt;key&gt;w&lt;/key&gt; he will not move upwards, but instead <em>forward</em> depending on his actual rotation. 
You can still move <em>sidewards</em> by pressing &lt;key&gt;q&lt;/key&gt; and &lt;key&gt;r&lt;/key&gt;. 


To calculate the <em>forward</em> movement of a rotated object in a cartesian (x,y) coordinate system some <a href="https://en.wikipedia.org/wiki/Trigonometric_functions">Trigonometric_functions</a> are used. 
To make the game more interesting, some small penguins are also in the game. 
The player can shoot at them (using the &lt;key&gt;SPACE&lt;/key&gt; key) and collide with them but should avoid the fragments when a small penguin explodes. 


If a small penguin reaches the ground, he get some random “fuel”<sup><a href="#fn__1" id="fnt__1">1)</a></sup> and moves upward (negative dy) until the “fuel” runs out. 
<em>Gravity</em>, that the player can turn on and off with the &lt;key&gt;g&lt;/key&gt;, will suck penguins, shots and fragments down.

The small objects (penguins, shots) are pushed around by forces (boost, gravity, impact of shots and fragments or other penguins), leading to diagonal movement (dx and dy). 
While the rotation of the fat penguin dedicate it&#039;s movement, the movement of the small objects dedicate their rotation. 


The goal of the game is too shoot down as many small penguins while trying to reach a 100% hit ratio. 
Each time one small penguin is killed a new one is created. 
The ratio of hits / misses will be calculated by the computer. 
The game ends if the <code>gametime</code> runs out or the player was hit by too much red fragments.

<h4 id="to_tinker">to tinker</h4>

change the constants (all in CAPITAL LETTER) like GRAVITY, FRICTION etc.
uncomment out-commented lines in <code>Bird.areacheck</code> to let birds bounce off walls
uncomment out-commented lines in <code>Bird.speedcheck</code> to introduce a general speed limit
give the small birds more “fuel” to fly higher: change <code>self.boostmax</code> in <code>Bird.__init__</code>

<h1 class="title">code discussion</h1>
<h2>- some trigonometry for pygame</h2>

<a href="http://de.wikipedia.org/w/index.php?title=Datei:Winkelfunktionen_Einheitskreis.svg&amp;filetimestamp=20061216174113"><img src="http://thepythongamebook.com/_media/en:part2:627px-winkelfunktionen_einheitskreis.svg-viertel.png?w=300&amp;tok=617db7"></a>    <a href="http://en.wikipedia.org/wiki/File:Unit_circle_angles.svg"><img src="http://thepythongamebook.com/_media/en:part2:600px-unit_circle_angles.svg-kleiner.png"></a>  
How to calculate <strong>sine</strong> and <strong>cosine</strong> for angle x    Radiand vs. 
Grad: 360° = 2 * π <br/>
π (<a href="https://en.wikipedia.org/wiki/pi">Pi</a>) = 3.1418…. 
 

While python will take care of most mathematics involved in rotating sprites for you, it may be a good to refresh some school wisdom. 
In this example games, those trigometric functions are used:
The sine: takes an angle (in radiant) as argument, returns the y coordinate 
The cosine: takes an angle (in radiant) as argument, returns the x coordinate
The arctangent: takes a fraction as argument, returns an angle (in radiant)

As you can see in the drawing at the right side, <strong>sine</strong> is the vertical coordinate of a given point ( D in the diagram) on a unit circle<sup><a href="#fn__2" id="fnt__2">2)</a></sup> while the <strong>cosine</strong> is the horizontal coordinate of the same point. 

The relation between those coordinates (vertical / horizontal) equals the <strong>tangent</strong> of the angle. 
The arctangent function is the inverse function of the tangent: arctangent takes the relation (y/x) as argument and returns the angle.

<h3>grad and radiant</h3>

There are several methods to measure the angle:
divide a full circle into 360 degrees (grad) or
divide a full circle into 2 times <strong>Pi</strong> <sup><a href="#fn__3" id="fnt__3">3)</a></sup>

While python&#039;s pygame module can handle basic rotation of sprites and surfaces using the 360 degree method, for calculating sine, cosine and arctangent, you need python&#039;s <strong>math</strong> module. 
Math functions use radians. 


Two small functions help here:
<span>import</span> <span>math</span>
<span>def</span> radians_to_degrees<span>&#40;</span>radians<span>&#41;</span>:
   <span>return</span> <span>&#40;</span>radians / <span>math</span>.<span>pi</span><span>&#41;</span> * <span>180.0</span>
<span>def</span> degrees_to_radians<span>&#40;</span>degrees<span>&#41;</span>:
   <span>return</span> degrees * <span>&#40;</span><span>math</span>.<span>pi</span> / <span>180.0</span><span>&#41;</span>

<h2>- calculating direction for a given rotation</h2>
The player&#039;s>BigBird</strong> knows the rotation of the sprite and need the movement vectors <code>dx</code> and <code>dy</code> to calculate. 
Here is the code, not-so important bits are omitted:
<span>import</span> <span>math</span>
GRAD <span>=</span> <span>math</span>.<span>pi</span> / <span>180</span>
<span>class</span> BigBird<span>&#40;</span>pygame.<span>sprites</span>.<span>Sprites</span><span>&#41;</span>:
   <span>#...</span>
   <span>def</span> <span>__init__</span><span>&#40;</span><span>self</span><span>&#41;</span>:
       pressedkeys <span>=</span> pygame.<span>key</span>.<span>get_pressed</span><span>&#40;</span><span>&#41;</span>
       <span>self</span>.<span>ddx</span> <span>=</span> <span>0.0</span>
       <span>self</span>.<span>ddy</span> <span>=</span> <span>0.0</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_w</span><span>&#93;</span>: <span># forward</span>
                        <span>self</span>.<span>ddx</span> <span>=</span> -<span>math</span>.<span>sin</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
                        <span>self</span>.<span>ddy</span> <span>=</span> -<span>math</span>.<span>cos</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_s</span><span>&#93;</span>: <span># backward</span>
                        <span>self</span>.<span>ddx</span> <span>=</span> +<span>math</span>.<span>sin</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
                        <span>self</span>.<span>ddy</span> <span>=</span> +<span>math</span>.<span>cos</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_e</span><span>&#93;</span>: <span># right side</span>
                        <span>self</span>.<span>ddx</span> <span>=</span> +<span>math</span>.<span>cos</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span>
                        <span>self</span>.<span>ddy</span> <span>=</span> -<span>math</span>.<span>sin</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_q</span><span>&#93;</span>: <span># left side</span>
                        <span>self</span>.<span>ddx</span> <span>=</span> -<span>math</span>.<span>cos</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
                        <span>self</span>.<span>ddy</span> <span>=</span> +<span>math</span>.<span>sin</span><span>&#40;</span><span>self</span>.<span>angle</span>*GRAD<span>&#41;</span> 
       <span>#...</span>
       <span>self</span>.<span>dx</span> +<span>=</span> <span>self</span>.<span>ddx</span> * <span>self</span>.<span>speed</span>
       <span>self</span>.<span>dy</span> +<span>=</span> <span>self</span>.<span>ddy</span> * <span>self</span>.<span>speed</span>
       <span>#...</span>
       <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dx</span> * seconds
       <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span> <span>self</span>.<span>dy</span> * seconds
       <span>#...</span>

<h2>- calculating rotation for a given direction</h2>
On the other hand, if you know dx and dy and need the fitting angle, you can use this code:
<span>class</span> Bullet<span>&#40;</span>pygame.<span>sprite</span>.<span>Sprite</span><span>&#41;</span>:
   <span>#...</span>
   <span>def</span> update<span>&#40;</span><span>self</span><span>,</span> <span>time</span><span>&#41;</span>:
       <span>#...</span>
       <span>#--------- rotate into direction of movement ------------</span>
       <span>#--- calculate with math.atan ---</span>
       <span>#if self.dx != 0 and self.dy!=0:</span>
       <span>#        ratio = self.dy / self.dx</span>
       <span>#        if self.dx &gt; 0:</span>
       <span>#            self.angle = -90-math.atan(ratio)/math.pi*180.0 # in grad</span>
       <span>#        else:</span>
       <span>#            self.angle = 90-math.atan(ratio)/math.pi*180.0 # in grad</span>
       <span>#--- or calculate with math.atan2 ---</span>
       <span>self</span>.<span>angle</span> <span>=</span> <span>math</span>.<span>atan2</span><span>&#40;</span>-<span>self</span>.<span>dx</span><span>,</span> -<span>self</span>.<span>dy</span><span>&#41;</span>/<span>math</span>.<span>pi</span>*<span>180.0</span> 
       <span>self</span>.<span>image</span> <span>=</span> pygame.<span>transform</span>.<span>rotozoom</span><span>&#40;</span><span>self</span>.<span>image0</span><span>,</span><span>self</span>.<span>angle</span><span>,</span><span>1.0</span><span>&#41;</span>

Using math.atan2 function instead of math.atan save some code lines. 

You can view the documentation for the math module online at <a href="http://docs.python.org/library/math.html">http://docs.python.org/library/math.html</a> :
&lt;note&gt;
math.atan(x) 
  Return the arc tangent of x, in radians.

math.atan2(y, x) 
  Return atan(y / x), in radians. 
The result is between -pi and pi. 
 
 The vector in the plane from the origin to point (x, y) makes
 this angle with the positive X axis. 

 
 The point of atan2() is that the signs of both inputs are known 
 to it, so it can compute the correct quadrant for the angle. 
For
 example, atan(1) and atan2(1, 1) are both pi/4, 
 but atan2(-1, -1) is -3*pi/4.

&lt;/note&gt;

<h2>- using>
<a href="/_detail/en:part2:classchart17.png?id=en%3Apygame%3Astep017"><img src="http://thepythongamebook.com/_media/en:part2:classchart17.png?w=600&amp;tok=101a20"></a>
In this code example exist 2 kinds of birds: The big (fat) BigBird and many smalle SmallBird&#039;s. 
Both have a common parent>elastic collision</h2>
Inside the game&#039;s mainloop is a tiny “physic engine” in use:
It checks with a crashgroup if one bird is actually crashing into another bird.
If so, both birds move away from each other. 


This could be done with less sophisticated code like in the previous examples, like by simply giving the crashbird&#039;s new random values for dx and dy. 
However <a href="/en:resources:people:michlmayr_leonard:start">Lenoard Michlmayr</a> was so nice to help me out here with some code for an <a href="https://en.wikipedia.org/wiki/Elastic_collision">elastic collision</a>:

<a href="/_detail/en:part2:elastischer_stoss.gif?id=en%3Apygame%3Astep017"><img src="http://thepythongamebook.com/_media/en:part2:elastischer_stoss.gif"></a>

<em>Note that to simplify the calculation, each bird is calculated as a disc. 
Also in the very special case that there is no speed (like if one bird is “beamed” into another bird) some random values for dx and dy are created.</em>
<span># ...</span>
   <span>def</span> elastic_collision<span>&#40;</span>sprite1<span>,</span> sprite2<span>&#41;</span>:
       <span>&quot;&quot;&quot;elasitc collision between 2 sprites (calculated as disc's).
          The function alters the dx and dy movement vectors of both sprites.
          The sprites need the property .mass, .radius, .pos[0], .pos[1], .dx, dy
          pos[0] is the x postion, pos[1] the y position&quot;&quot;&quot;</span>
       <span># here we do some physics: the elastic</span>
       <span># collision</span>
       <span>#</span>
       <span># first we get the direction of the push.</span>
       <span># Let's assume that the sprites are disk</span>
       <span># shaped, so the direction of the force is</span>
       <span># the direction of the distance.</span>
       dirx <span>=</span> sprite1.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> - sprite2.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span>
       diry <span>=</span> sprite1.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> - sprite2.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span>
       <span>#</span>
       <span># the velocity of the centre of mass</span>
       sumofmasses <span>=</span> sprite1.<span>mass</span> + sprite2.<span>mass</span>
       sx <span>=</span> <span>&#40;</span>sprite1.<span>dx</span> * sprite1.<span>mass</span> + sprite2.<span>dx</span> * sprite2.<span>mass</span><span>&#41;</span> / sumofmasses
       sy <span>=</span> <span>&#40;</span>sprite1.<span>dy</span> * sprite1.<span>mass</span> + sprite2.<span>dy</span> * sprite2.<span>mass</span><span>&#41;</span> / sumofmasses
       <span># if we sutract the velocity of the centre</span>
       <span># of mass from the velocity of the sprite,</span>
       <span># we get it's velocity relative to the</span>
       <span># centre of mass. 
And relative to the</span>
       <span># centre of mass, it looks just like the</span>
       <span># sprite is hitting a mirror.</span>
       <span>#</span>
       bdxs <span>=</span> sprite2.<span>dx</span> - sx
       bdys <span>=</span> sprite2.<span>dy</span> - sy
       cbdxs <span>=</span> sprite1.<span>dx</span> - sx
       cbdys <span>=</span> sprite1.<span>dy</span> - sy
       <span># (dirx,diry) is perpendicular to the mirror</span>
       <span># surface. 
We use the dot product to</span>
       <span># project to that direction.</span>
       distancesquare <span>=</span> dirx * dirx + diry * diry
       <span>if</span> distancesquare <span>==</span> <span>0</span>:
           <span># no distance? this should not happen,</span>
           <span># but just in case, we choose a random</span>
           <span># direction</span>
           dirx <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>11</span><span>&#41;</span> - <span>5.5</span>
           diry <span>=</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>11</span><span>&#41;</span> - <span>5.5</span>
           distancesquare <span>=</span> dirx * dirx + diry * diry
       dp <span>=</span> <span>&#40;</span>bdxs * dirx + bdys * diry<span>&#41;</span> <span># scalar product</span>
       dp /<span>=</span> distancesquare <span># divide by distance * distance.</span>
       cdp <span>=</span> <span>&#40;</span>cbdxs * dirx + cbdys * diry<span>&#41;</span>
       cdp /<span>=</span> distancesquare
       <span># We are done. 
(dirx * dp, diry * dp) is</span>
       <span># the projection of the velocity</span>
       <span># perpendicular to the virtual mirror</span>
       <span># surface. 
Subtract it twice to get the</span>
       <span># new direction.</span>
       <span>#</span>
       <span># Only collide if the sprites are moving</span>
       <span># towards each other: dp &gt; 0</span>
       <span>if</span> dp <span>&gt;</span> <span>0</span>:
           sprite2.<span>dx</span> -<span>=</span> <span>2</span> * dirx * dp 
           sprite2.<span>dy</span> -<span>=</span> <span>2</span> * diry * dp
           sprite1.<span>dx</span> -<span>=</span> <span>2</span> * dirx * cdp 
           sprite1.<span>dy</span> -<span>=</span> <span>2</span> * diry * cdp

The function is called with 2 sprites as arguments during the mainloop. 
Note that the elastic_collision function has no return values but
instead manipulates the .dx and .dy properties (the movement vectors) of both sprites.
<span># ... 
inside mainloop</span>
       <span># ------ collision detection</span>
       <span>for</span> bird <span>in</span> birdgroup:  <span># test if a bird collides with another bird</span>
           bird.<span>crashing</span> <span>=</span> <span>False</span> <span># make bird NOT blue</span>
           <span># check the Bird.number to make sure the bird is not crashing with himself</span>
           <span>if</span> <span>not</span> bird.<span>waiting</span>: <span># do not check birds outside the screen</span>
               crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> birdgroup<span>,</span> <span>False</span> <span>&#41;</span>
               <span>for</span> crashbird <span>in</span> crashgroup:  <span># test bird with other bird collision</span>
                   <span>if</span> crashbird.<span>number</span> <span>&gt;</span> bird.<span>number</span>: <span>#avoid checking twice</span>
                       bird.<span>crashing</span> <span>=</span> <span>True</span> <span># make bird blue</span>
                       crashbird.<span>crashing</span> <span>=</span> <span>True</span> <span># make other bird blue</span>
                       <span>if</span> <span>not</span> <span>&#40;</span>bird.<span>waiting</span> <span>or</span> crashbird.<span>waiting</span><span>&#41;</span>:
                           elastic_collision<span>&#40;</span>crashbird<span>,</span> bird<span>&#41;</span> <span># change dx and dy of both birds</span>

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/017_turning_and_physic.py">017_turning_and_physic.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png">babytux_neg.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux_neg.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux_neg.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/claws.ogg">claws.ogg</a>  <br/>
from Battle of Wesnoth    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/wormhole.ogg">wormhole.ogg</a>     <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/bomb.ogg">bomb.ogg</a>     <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/shoot.ogg">shoot.ogg</a>     <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/beep.ogg">beep.ogg</a>     <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/017_turning_and_physic.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/017_turning_and_physic.py</a>
	
<h1 class="title">Step 018 - Mask and pixel perfect collision detection</h1>

<h2>- gameplay</h2>
<a href="/_detail/en:part2:step018_collidecircle.jpg?id=en%3Apygame%3Astep018"><img src="http://thepythongamebook.com/_media/en:part2:step018_collidecircle.jpg?w=300&amp;tok=a6d5f8"></a>
In this variation of the previous game, you can toggle with the &lt;key&gt;c&lt;/key&gt; key between the three different methods for collision detection:

collide_rect - the default method, and the fastest of all. 
sprites need a self.rect attribute
collide_circle - slower but better looking. 
sprites need a self.radius attribute
collide_mask - the slowest but most precise method. 
sprites need a self.mask attribute, taken from the sprites image.


Fly the smaller penguin around (with &lt;key&gt;w&lt;/key&gt; &lt;key&gt;a&lt;/key&gt; &lt;key&gt;s&lt;/key&gt; &lt;key&gt;d&lt;/key&gt; &lt;key&gt;q&lt;/key&gt; &lt;key&gt;e&lt;/key&gt;, shoot at the big penguin with &lt;key&gt;space&lt;/key&gt; and check the pattern of the yellow impact “wounds” depending of the different collide methods.

A bitmask is like an image with only two colours: collision-relevant and non-relevant. 
Like an black / white photograph. 
You can create your own bitmask but pygame has a <a href="http://www.pygame.org/docs/ref/mask.html#pygame.mask.from_surface">command to create a bitmaks from an image</a>:
pygame.<span>mask</span>.<span>from_surface</span><span>&#40;</span>Surface<span>,</span> threshold <span>=</span> <span>127</span><span>&#41;</span> -<span>&gt;</span> Mask

Note that if you rotate a sprite and rotate the sprite&#039;s image, you must create a new mask from the rotated image.

<h2>- collision dedection</h2>

       <span>#.. 
inside mainloop</span>
               <span>elif</span> event.<span>key</span> <span>==</span> pygame.<span>K_c</span>:
                   <span>if</span> collision <span>==</span> <span>&quot;rect&quot;</span>:
                       collision <span>=</span> <span>&quot;circle&quot;</span>
                   <span>elif</span> collision <span>==</span> <span>&quot;circle&quot;</span>:
                       collision <span>=</span> <span>&quot;mask&quot;</span>
                   <span>elif</span> collision <span>==</span> <span>&quot;mask&quot;</span>:
                       collision <span>=</span> <span>&quot;rect&quot;</span>
                   screentext2.<span>newmsg</span><span>&#40;</span><span>&quot;collsion detection: %s&quot;</span> % collision<span>&#41;</span>
       <span># ...</span>
       <span># ------ collision detection</span>
       <span>for</span> bird <span>in</span> birdgroup:
           <span>#...</span>
           <span>if</span> collision <span>==</span> <span>&quot;rect&quot;</span>:
               crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> bulletgroup<span>,</span> <span>False</span><span>,</span> pygame.<span>sprite</span>.<span>collide_rect</span><span>&#41;</span>
           <span>elif</span> collision <span>==</span> <span>&quot;circle&quot;</span>:
               crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> bulletgroup<span>,</span> <span>False</span><span>,</span> pygame.<span>sprite</span>.<span>collide_circle</span><span>&#41;</span>
           <span>elif</span> collision <span>==</span> <span>&quot;mask&quot;</span>:
               crashgroup <span>=</span> pygame.<span>sprite</span>.<span>spritecollide</span><span>&#40;</span>bird<span>,</span> bulletgroup<span>,</span> <span>False</span><span>,</span> pygame.<span>sprite</span>.<span>collide_mask</span><span>&#41;</span>
           <span>for</span> ball <span>in</span> crashgroup:  <span># test for collision with bullet</span>
              <span># ...</span>

<h2>- problem: sprites overshooting each other</h2>
There is a common problem if you test very small, very fast sprites for collisions with small objects: the fast sprite is “teleporting” or overshooting over the obstacle, not triggering a collision detection.
Some quick solutions are:
use slower, bigger sprites and bigger obstacles
use a higher framerate
use a self.radius value of a sprite that is far bigger than the actual sprite. 
Use this self.radius together with <strong>pygame.sprite.collide_circle</strong> for collision detection
experts: calculate if 2 vectors, originating from <strong>self.pos</strong> with <strong>self.dx</strong>,<strong>self.dy</strong> cross each others.

<h2>- what&#039;s new</h2>
<a href="/_detail/en:part2:classchart18.png?id=en%3Apygame%3Astep018"><img src="http://thepythongamebook.com/_media/en:part2:classchart18.png?w=600&amp;tok=84fc68"></a>
The code is nearly the same code as in the previous example. 

The Fragment>source code on github</h2>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/018_perfect_collision_detection.py">018_perfect_collision_detection.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png">babytux.png</a> <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/babytux.png"><img src="http://thepythongamebook.com/_media/en:part2:babytux.png"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/crossmonster.png">crossmonster.png</a> <br/>
<a href="/_detail/en:part2:crossmonster.png?id=en%3Apygame%3Astep018"><img src="http://thepythongamebook.com/_media/en:part2:crossmonster.png?w=100&amp;tok=91ee18"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/xmonster.png">xmonster.png</a>  <br/>
<a href="/_detail/en:part2:xmonster.png?id=en%3Apygame%3Astep018"><img src="http://thepythongamebook.com/_media/en:part2:xmonster.png?w=100&amp;tok=5dff2b"></a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/claws.ogg">claws.ogg</a>  <br/>
from Battle of Wesnoth    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/bomb.ogg">bomb.ogg</a>     <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/shoot.ogg">shoot.ogg</a>     <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/beep.ogg">beep.ogg</a>     <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/018_perfect_collision_detection.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/018_perfect_collision_detection.py</a>
	
<h1 class="title">Step 019 - Homing missiles</h1>

<a href="/_detail/en:part2:screenshot019.jpg?id=en%3Apygame%3Astep019"><img src="http://thepythongamebook.com/_media/en:part2:screenshot019.jpg?w=300&amp;tok=b0e67d"></a>
In this example game, two players can fire bullets and rockets at each other or at big nasty monsters. 


Bullets have a short range, but steal hitpoints if hitting a player or a monster.

There are 2 different kind of rockets:
a “light”,  weak damage, fast flying variant. 
Short lifetime. 
Can be shot down.
a “heavy”, heavy damage, slow flying “sliding” variant. 
Longer lifetime. 
Can not be shot down, but it&#039;s flightpath can be disturbed if hit.

Both types of rockets aim automatically toward the target. 
While the “light” rockets move in the direction of their heading (boring), the “heavy” rockets “slide” like in open space, making  more interesting flight patterns.

A player can store a maximum ammo of 32 rockets (see <strong>class Player, self.rocketsmax</strong>). 
The first 16 rockets are light rockets, the others are heavy rockets.

Not shooting increase the stock of missiles of each player (see the blue rocketbar above each player)

If no more monsters are present, the players can fight each other (duel mode). 
New monsters can be created my pressing &lt;key&gt;m&lt;/key&gt;.

If both players are shot down by monsters, the monsters start fighting themselves (Overtime). 
You can press &lt;key&gt;o&lt;/key&gt; to get more overtime and watch the monsters fighting each other.

<h3>Monster states</h3>

Each 15 seconds, (see <strong>class Monster, self.hunttime</strong>) the monster has a chance to select a new target.

Each monster has a primitive <a href="https://en.wikipedia.org/wiki/State_machine">State_machine</a>, cycling between the three states “do nothing”, “shoot bullets at target” and “shoot rockets at target”. 
Each “state” is exactly 3 seconds long. 

This is the code line to see in what “state” or “phase” a monster currently is (inside <strong>class Monster, def update</strong>): 
self.phase = self.phases[int(self.alivetime) % 3 ]

Self.alivetime is a variable counting the time (in seconds) of existence of a monster. 
The %-sign is the <a href="https://en.wikipedia.org/wiki/Modulo_operation">modulo operator</a>. 
It doesn&#039;t return the result of a division, but instead the <a href="https://en.wikipedia.org/wiki/Remainder">remainder</a>.

As you can see in this example, the remainder cycles between 0 , 1 and 2 if the divisor is 3:
<span>for</span> x <span>in</span> <span>range</span><span>&#40;</span><span>31</span><span>&#41;</span>: <span># python2.x</span>
  <span>print</span> x<span>,</span> <span>&quot;divided by 3 =&quot;</span><span>,</span> x/<span>3</span><span>,</span> <span>&quot;remainder:&quot;</span><span>,</span> x%<span>3</span><span>,</span><span>&quot;float result:&quot;</span><span>,</span> x/<span>3.0</span>

output:
0 divided by 3 = 0 remainder: 0 float result: 0.0 
1 divided by 3 = 0 remainder: 1 float result: 0.333333333333 
2 divided by 3 = 0 remainder: 2 float result: 0.666666666667 
3 divided by 3 = 1 remainder: 0 float result: 1.0 
4 divided by 3 = 1 remainder: 1 float result: 1.33333333333 
5 divided by 3 = 1 remainder: 2 float result: 1.66666666667 
...

<h3>classes</h3>

All><img src="http://thepythongamebook.com/_media/en:part2:classchart19.png?w=600&amp;tok=3d0e6e"></a>

<h3>additional resources</h3>

<a href="/_media/en:part2:data019.tar.gz">data019.tar.gz</a>

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/019_homing_missiles.py">019_homing_missiles.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/player_red2.png">player_red2.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/player_blue2.png">player_blue2.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/xmonster_s.png">xmonster_s.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/xmonster_fire_s.png">xmonster_fire_s.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/xmonster_left_s.png">xmonster_left_s.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/xmonster_right_s.png">xmonster_right_s.png</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/claws.ogg">claws.ogg</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/wormhole.ogg">wormhole.ogg</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/bomb.ogg">bomb.ogg</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/shoot.ogg">shoot.ogg</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/beep.ogg">beep.ogg</a>    <code>pygame/data</code>  
<a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/data/explode.ogg">explode.ogg</a>    <code>pygame/data</code>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/019_homing_missiles.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/019_homing_missiles.py</a>
	
<h1 class="title">Step 020 - Shooting bullets from the end of a cannon barrel</h1>

<h3>video</h3>

<iframe src="//www.youtube-nocookie.com/embed/SDsomsEWl7E" height="293" width="520"></iframe>
Video link: <a href="http://www.youtube.com/watch?v=SDsomsEWl7E">http://www.youtube.com/watch?v=SDsomsEWl7E</a>
<span>
	<a href="/tag:video?do=showtag&amp;tag=video">video</a>
</span>

<h3>description</h3>

<a href="/_detail/en:part2:pygame:tankdemo04.jpg?id=en%3Apygame%3Astep020"><img src="http://thepythongamebook.com/_media/en:part2:pygame:tankdemo04.jpg?w=300&amp;tok=0aca6b"></a>
In this example, two tanks can be controlled by the players (using both hands), moving forward and backward and rotating. 
Additionally, the turrets can rotate also. 
The turrets can shoot bullets out of the tanks&#039;s main cannon (please admire the recoil effect) and the tanks can fire tracer rounds from machine guns. 
Each gun has a machine gun at the turret and at its bow (see graphic at the right). 
<br/>
This source code examples teaches nothing new but demonstrate how to solve a specific problem: Creating bullet-sprites not at the center of it&#039;s launcher, but at the end (and some space away) from it. 
The most obvious solution for such a problem would be to create the bullet at the center of it&#039;s launcher (the Tank) and use the <strong>Layer</strong> system to make sure the Tank is drawn on top of the bullet. 

But if you have a fine eye you will notice some ugly effects: if you rotate a cannon fast enough, it will look like the bullet exits at the side of the cannon instead of at it&#039;s end. 
Also creating one Sprite at the exact position of another sprite will trigger a collision detection, needing more code to make sure that a tank cannot shoot itself.

<h3>source code discussion</h3>

To deal with the problem of creating a bullet sprite at the exact end of a rotated cannon sprite, see the source code below. 
All you need is a little knowledge of the <strong>math.sin</strong> and <strong>math.cos</strong> function (remember to transform grad into radiant), like explained in <a href="/en:pygame:step017">step017 - rotating, shooting, inheritance</a>.

If you like complicated explanations: What you do here is creating a vector and rotating it to find the coordinate of a point (the musszle).
This is done in the methods <strong>calculate_origin</strong> of the <strong>Bullet</strong> and the <strong>Tracer</strong>>Bullet</h4>
For the Bullet, shooting out of the muzzle of the tanks main gun the problem is this: It&#039;s boss sprite, the Tank turret, is rotated by <strong>turretAngle</strong>. 
Also the cannon is very long, nearly as long as the side of the Tank.
   <span>def</span> calculate_origin<span>&#40;</span><span>self</span><span>&#41;</span>:
       <span># - spawn bullet at end of turret barrel instead tank center -</span>
       <span># cannon is around Tank.side long, calculatet from Tank center</span>
       <span># later subtracted 20 pixel from this distance</span>
       <span># so that bullet spawns closer to tank muzzle</span>
       <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span>  <span>math</span>.<span>cos</span><span>&#40;</span>degrees_to_radians<span>&#40;</span><span>self</span>.<span>boss</span>.<span>turretAngle</span><span>&#41;</span><span>&#41;</span> * <span>&#40;</span>Tank.<span>side</span>-<span>20</span><span>&#41;</span>
       <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span>  <span>math</span>.<span>sin</span><span>&#40;</span>degrees_to_radians<span>&#40;</span>-<span>self</span>.<span>boss</span>.<span>turretAngle</span><span>&#41;</span><span>&#41;</span> * <span>&#40;</span>Tank.<span>side</span>-<span>20</span><span>&#41;</span>
&nbsp;

<h4 id="tracer">Tracer</h4>
For the Tracer (shooting out of the red bow rectangle of the tank) the point of launching is the little red rectangle in the front of the Tank. 
Because the Tank can rotate it&#039;s turret independent of the tank&#039;s own rotation, the important variable here is tankangle. 
The bow machine gun rectangle is not so much distanced from the Tank&#039;s center (side/2), but it is a bit on the left side. 
De facto i created here an 2D-Vector, 30° from the Tank&#039;s center and with the lenght of Tank.side/2. 
This vector is rotated with the <strong>tankAngle</strong> to find the coordinates of the point of origin for the Tracer round.
    <span>def</span> calculate_origin<span>&#40;</span><span>self</span><span>&#41;</span>:
       <span>&quot;&quot;&quot;overwriting because another point of origin is needed&quot;&quot;&quot;</span>
       <span># - spawn bullet at end of bow rect (and some extra distance)</span>
       <span># the bow rect is in the middle -left from the tank center</span>
       <span># calculatet by going -30° from the Tank center for the half tank side</span>
       <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span>  <span>math</span>.<span>cos</span><span>&#40;</span>degrees_to_radians<span>&#40;</span><span>30</span>+<span>self</span>.<span>boss</span>.<span>tankAngle</span><span>&#41;</span><span>&#41;</span> * <span>&#40;</span>Tank.<span>side</span>/<span>2</span><span>&#41;</span>
       <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span>  <span>math</span>.<span>sin</span><span>&#40;</span>degrees_to_radians<span>&#40;</span>-<span>30</span>-<span>self</span>.<span>boss</span>.<span>tankAngle</span><span>&#41;</span><span>&#41;</span> * <span>&#40;</span>Tank.<span>side</span>/<span>2</span><span>&#41;</span>

<h3>keyboard overflow problem</h3>

While playing you will notice that sometimes some keyboard command seem to be ignored when you press several keys at once. 
It also can happen that if you press some combinations of more than 2 keys at the same time, it seems like a different key was pressed (ghost) 
To test it out:
run example tankdemo03.py from below.
press &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;s&lt;/key&gt; to move the tank forward and back (works)
press &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;s&lt;/key&gt; at the same time, to stop the tank movement (works also)
if you press &lt;key&gt;d&lt;/key&gt; and &lt;key&gt;a&lt;/key&gt; at the same time, the tank does not rotate (correctly)
while pressing &lt;key&gt;d&lt;/key&gt; and &lt;key&gt;a&lt;/key&gt;, also press &lt;key&gt;w&lt;/key&gt; or &lt;key&gt;s&lt;/key&gt;. 
This time, it works (the tank does not rotate, but moves forward &amp; back). 
In this case, 3 keys are pressed simultaneously and interpreted correctly.
the combinations  &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;a&lt;/key&gt; , &lt;key&gt;s&lt;/key&gt; and &lt;key&gt;a&lt;/key&gt;, &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;d&lt;/key&gt;, &lt;key&gt;s&lt;/key&gt; and &lt;key&gt;d&lt;/key&gt; all work, letting the tank rotate and move at the same time
while pressing &lt;key&gt;w&lt;/key&gt; and &lt;key&gt;s&lt;/key&gt; at the same time (no movement), also press &lt;key&gt;d&lt;/key&gt; to rotate the tank. 
This does not work ! Worse, the bow mg start firing, but you have not pressed &lt;key&gt;LCTRL&lt;/key&gt; ! (ghost key effect)

This phenomenon is well known among game designer. 
Ultimately it is caused by the way how keyboards are constructed. 


A possible solution is to design games with fewer keys to be pressed and use keys like SHIFT, ALT and CTRL because those keys are better recognized by design of the hardware. 
Also think about accepting input from Mouse and Joysticks (see pygame documentation) or writing network-games where each player has his own keyboard.

See the glossary entry <a href="/en:resources:glossary:k:keyboard">keyboard</a> for more information. 
You will find there a very cool program<sup><a href="#fn__1" id="fnt__1">1)</a></sup> to test out how many keys you can press at the same time without confusing your keyboard.
<span>
	<a href="/tag:keyboard?do=showtag&amp;tag=keyboard">keyboard</a>
</span>

<h3>additional resources</h3>

no additional resources necessary.

<h3>classchart</h3>

<a href="/_detail/en:part2:classchart_020.jpg?id=en%3Apygame%3Astep020"><img src="http://thepythongamebook.com/_media/en:part2:classchart_020.jpg"></a>

<h3>ideas</h3>

&lt;note tip&gt;Can you add sound effects to the Tankdemo ? See <a href="/en:pygame:step010">step010 - using sound and music</a>&lt;/note&gt;
&lt;note tip&gt;Can you create moving or stationary practice targets for the Tankdemo ? See <a href="/en:pygame:step017">step017 - rotating, shooting...</a>&lt;/note&gt;

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/020_shooting_from_tank.py">020_shooting_from_tank.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/020_shooting_from_tank.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/020_shooting_from_tank.py</a>

<h1 class="title">Step 021 - Rotating toward a target</h1>

<h3>video</h3>

<iframe src="//www.youtube-nocookie.com/embed/nfaOmkhK-V0" height="293" width="520"></iframe>
Video link: <a href="http://www.youtube.com/watch?v=nfaOmkhK-V0">http://www.youtube.com/watch?v=nfaOmkhK-V0</a>
<em>Bug: tank angle and turret angle is swapped in the video. 
The source code below is correct.</em>
<span>
	<a href="/tag:video?do=showtag&amp;tag=video">video</a>
</span>

<h3>description</h3>

<a href="/_detail/en:part2:pygame:targetingdemo.jpg?id=en%3Apygame%3Astep021"><img src="http://thepythongamebook.com/_media/en:part2:pygame:targetingdemo.jpg?w=350&amp;tok=e27283"></a>
In the code example below, you can move both tanks (as in <a href="/en:pygame:step020">step020</a>) or you can “teleport” the yellow tank toward the mouse pointer by clicking the left mouse button. 
The blue tank will rotate it&#039;s turrent toward the position of the yellow tank. 
The problem is to decide in wich direction the turret should move. 


<h3>source code discussion</h3>

In the code example below this is solved by the Tank>aim_at_player</strong>. 
Note that the angle <strong>diff</strong> can result in values &gt; than 360, so the result is divided by 360 and its modulo<sup><a href="#fn__1" id="fnt__1">1)</a></sup>, is saved. 
 You will also note that very few lines are altered since <a href="/en:pygame:step020">step020</a>, mostly the tank>    <span>def</span> aim_at_player<span>&#40;</span><span>self</span><span>,</span> targetnumber<span>=</span><span>0</span><span>&#41;</span>:
       <span>#print &quot;my  pos: x:%.1f y:%.1f &quot; % ( self.pos[0], self.pos[1])</span>
       <span>#print &quot;his pos: x:%.1f y:%.1f &quot; % ( Tank.book[0].pos[0], Tank.book[0].pos[1])  </span>
       deltax <span>=</span> Tank.<span>book</span><span>&#91;</span>targetnumber<span>&#93;</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span> - <span>self</span>.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span>
       deltay <span>=</span> Tank.<span>book</span><span>&#91;</span>targetnumber<span>&#93;</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span> - <span>self</span>.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span>
       angle <span>=</span>   <span>math</span>.<span>atan2</span><span>&#40;</span>-deltax<span>,</span> -deltay<span>&#41;</span>/<span>math</span>.<span>pi</span>*<span>180.0</span>    
&nbsp;
       diff <span>=</span> <span>&#40;</span>angle - <span>self</span>.<span>turretAngle</span> - <span>90</span><span>&#41;</span> %<span>360</span> <span>#reset at 360</span>
       <span>if</span> diff <span>==</span> <span>0</span>:
           <span>self</span>.<span>turndirection</span> <span>=</span> <span>0</span>
       <span>elif</span> diff <span>&gt;</span> <span>180</span>:
           <span>self</span>.<span>turndirection</span> <span>=</span> <span>1</span>
       <span>else</span>:
           <span>self</span>.<span>turndirection</span> <span>=</span> -<span>1</span>
       <span>return</span> diff

And also the mainloop&#039;s event handler is expanded. 
He now checks the MOUSEBUTTON event to teleport player1 tank around:
            <span># teleport player1 tank if left mousebutton is pressed</span>
           <span>elif</span> event.<span>type</span> <span>==</span> pygame.<span>MOUSEBUTTONDOWN</span>:
               <span>if</span> pygame.<span>mouse</span>.<span>get_pressed</span><span>&#40;</span><span>&#41;</span><span>&#91;</span><span>0</span><span>&#93;</span>:
                   <span>#left mousebutton was pressed</span>
                   player1.<span>pos</span><span>&#91;</span><span>0</span><span>&#93;</span><span>=</span>pygame.<span>mouse</span>.<span>get_pos</span><span>&#40;</span><span>&#41;</span><span>&#91;</span><span>0</span><span>&#93;</span>
                   player1.<span>pos</span><span>&#91;</span><span>1</span><span>&#93;</span><span>=</span>pygame.<span>mouse</span>.<span>get_pos</span><span>&#40;</span><span>&#41;</span><span>&#91;</span><span>1</span><span>&#93;</span>

&lt;note&gt;<a href="/en:resources:people:start"><img src="http://thepythongamebook.com/_media/en:resources:people:yipyip:yip0.png?w=50&amp;tok=eb8747"></a>User <a href="/en:resources:people:start">yipyip</a> has donated a very interesting solution to this problem, using <a href="https://en.wikipedia.org/wiki/Complex_number">Complex numbers</a>. 
See his source code here: <a href="/en:resources:people:yipyip:drehung">yipyip&#039;s solution</a>
&lt;/note&gt;

<h3>ideas</h3>

&lt;note tip&gt;Do you remember the keyboard-rollover problem from <a href="/en:pygame:step020">step020</a> ? Now you could use less keyboard commands by letting both players turrets automatically  rotate toward each other&lt;/note&gt;
&lt;note tip&gt;Can you code an <a href="https://en.wikipedia.org/wiki/Artificial_intelligence">Artificial_intelligence</a> for the bow machine gun ? Let it firing as soon as it&#039;s <a href="https://en.wikipedia.org/wiki/Deflection_(military)">Deflection angle</a> is low enough: 
<span>if</span> -<span>5</span> <span>&lt;</span> tankDiffAngle <span>&lt;</span> <span>5</span>:
 Tracer<span>&#40;</span><span>self</span><span>&#41;</span>

&lt;/note&gt;

<h3>additional resources</h3>

no additional resources needed

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/021_targeting.py">021_targeting.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/021_targeting.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/021_targeting.py</a>

<h1 class="title">Step 022 - Scrolling and mini-map</h1>

<h3>video</h3>

<iframe src="//www.youtube-nocookie.com/embed/DusPphBj98A" height="293" width="520"></iframe>
Video link: <a href="http://www.youtube.com/watch?v=DusPphBj98A">http://www.youtube.com/watch?v=DusPphBj98A</a>
<span>
	<a href="/tag:video?do=showtag&amp;tag=video">video</a>
</span>

<h3>description</h3>

<a href="/_detail/en:part2:pygame:step022.jpg?id=en%3Apygame%3Astep022"><img src="http://thepythongamebook.com/_media/en:part2:pygame:step022.jpg?w=300&amp;tok=5bb2c6"></a>
In this example you can control the 2 famous tanks from the previous step. 
But some features were added:  
The map or “playground” is larger than the screen resolution. 
. 
The player sprite(s) can be steered around the whole map (but not over the map edge). 
The position of all <strong>Tank</strong>, <strong>Bullet</strong> and <strong>Tracer</strong> sprites and the current visible area of the map can be seen in the minimap or radar-map. 
The minimap is always visible on the top right corner of the screen. 
The minimap itself is also a Sprite, called <strong>Radarmap</strong>. 
The dimensions of screen, the big map and the radarmap are all visible inside the <strong>Config</strong>>real-time-strategy games (rts-games)</a>.

<h3>code discussion</h3>

In the Code examples of this part of the book, all sprites have a <strong>self.pos</strong> attribute, a list of two coordinates [x,y]. 
This <strong>self.pos</strong> variable is used for all calculations (angle, movement etc.). 
Until now, the <strong>self.pos</strong> variable was identical with the <strong>self.rect</strong> position (<strong>self.rect.centerx, self.rect.centery</strong>), the only difference being that <strong>self.rect</strong> demands integer values while the <strong>self.pos</strong> variables could handle decimal points.

But now with the <strong>bigmap</strong> being by far larger as the visible <strong>screen</strong> area, the math gets more complex. 
While the <strong>self.pos</strong> variables stay more or less untouched, the position of the visible screen area in realation to the big map is to be calculated when blitting the sprites at the  <strong>self.rect.center</strong> position.

<h4 id="configcornerpoint_shows_the_way">Config.cornerpoint shows the way</h4>
In this example, the offset of the visible <strong>screen</strong> to the <strong>bigmap</strong> is calculated with the aid of the variable <strong>Config.cornerpoint</strong>. 
It&#039;s a list of 2 coordinates [x,y] and stored inside the <strong>Config</strong>-class so that other>screen</strong> area. 
At the beginning, those are set to [0,0] and there is no difference between the <strong>self.rect</strong> coordinates and the <strong>self.pos</strong> coordinates.

As soon as the player moves the visible area with the Cursor - Keys, the value of <strong>Config.cornerpoint</strong> is changed (this is done inside the mainloop):
  <span>#...</span>
       <span># -------- scroll the big map ----------</span>
       scrollx <span>=</span> <span>0</span>
       scrolly <span>=</span> <span>0</span>
       pressedkeys <span>=</span> pygame.<span>key</span>.<span>get_pressed</span><span>&#40;</span><span>&#41;</span>
       <span># --- handle Cursor keys to scroll map ----</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_LEFT</span><span>&#93;</span>:
            scrollx -<span>=</span> Config.<span>scrollstepx</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_RIGHT</span><span>&#93;</span>:
            scrollx +<span>=</span> Config.<span>scrollstepx</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_UP</span><span>&#93;</span>:
            scrolly -<span>=</span> Config.<span>scrollstepy</span>
       <span>if</span> pressedkeys<span>&#91;</span>pygame.<span>K_DOWN</span><span>&#93;</span>:
            scrolly +<span>=</span> Config.<span>scrollstepy</span>
       <span># -------- scroll the visible part of the map ------</span>
       Config.<span>cornerpoint</span><span>&#91;</span><span>0</span><span>&#93;</span> +<span>=</span> scrollx
       Config.<span>cornerpoint</span><span>&#91;</span><span>1</span><span>&#93;</span> +<span>=</span> scrolly  
 <span>#...</span>

<strong>Config.scrollstepx</strong> and <strong>Config.scrollstepy</strong> are variables to control how many pixels the visible area should scroll each frame. 
Do not make those values too big, or the scrolling look jumpy.

<h4 id="spritely_tank_class">Spritely Tank>
Now, let&#039;s take a look inside a typical Sprite>Tank</strong>>update(self)</strong>-function, there is the blitting of the <strong>self.rect.center</strong> variables. 
Here the values of <strong>Config.cornerpoint</strong> are subtracted. 
Change the - into a + for a funny effect:
  #... 

       self.rect.centerx = round(self.pos[0] - Config.cornerpoint[0], 0) #x
       self.rect.centery = round(self.pos[1] - Config.cornerpoint[1], 0) #y    
 #...

<h4 id="bulleting_sprites">Bulleting Sprites</h4>
Also note that in contrast to the previous step, in this code example the <strong>Bullet</strong> sprite>Bullet</strong> (and <strong>Tracer</strong>) sprites. 
This is necessary so that the <strong>Radarmap</strong> sprite can iterate throug all <strong>Tank</strong> sprites (in the Tank book) and all Bullets (in the Bullet book) to draw little dots. 
Inside the <strong>Radarmap</strong>>self.factorx</strong> and <strong>self.factory</strong> are variables indication the relation between bigmap to radarmap.
<span>#... 
inside Radarmap>
       <span>for</span> tanknumber <span>in</span> Tank.<span>book</span>: <span># tank are circles with radius 4</span>
           pos <span>=</span> Tank.<span>book</span><span>&#91;</span>tanknumber<span>&#93;</span>.<span>pos</span>
           color <span>=</span> Tank.<span>book</span><span>&#91;</span>tanknumber<span>&#93;</span>.<span>color</span>
           pygame.<span>draw</span>.<span>circle</span><span>&#40;</span><span>self</span>.<span>image</span><span>,</span>color<span>,</span> <span>&#40;</span><span>round</span><span>&#40;</span>pos<span>&#91;</span><span>0</span><span>&#93;</span> * <span>self</span>.<span>factorx</span><span>,</span><span>0</span><span>&#41;</span><span>,</span>
                                                 <span>round</span><span>&#40;</span>pos<span>&#91;</span><span>1</span><span>&#93;</span> * <span>self</span>.<span>factory</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span><span>,</span> <span>4</span> <span>&#41;</span>
       <span>for</span> bulletnumber <span>in</span> Bullet.<span>book</span>:
           <span>if</span> Bullet.<span>book</span><span>&#91;</span>bulletnumber<span>&#93;</span>.<span>tracer</span>:
               dotlength <span>=</span> <span>2</span> <span># bullets are rectangles with sidelength 4 (bullets) or 2 (tracer)</span>
           <span>else</span>:
               dotlength <span>=</span> <span>4</span> <span># rect with length 1 is not visible</span>
           pos <span>=</span> Bullet.<span>book</span><span>&#91;</span>bulletnumber<span>&#93;</span>.<span>pos</span>
           color <span>=</span> Bullet.<span>book</span><span>&#91;</span>bulletnumber<span>&#93;</span>.<span>color</span>
           pygame.<span>draw</span>.<span>rect</span><span>&#40;</span><span>self</span>.<span>image</span><span>,</span> color<span>,</span><span>&#40;</span><span>round</span><span>&#40;</span>pos<span>&#91;</span><span>0</span><span>&#93;</span> * <span>self</span>.<span>factorx</span><span>,</span><span>0</span><span>&#41;</span><span>,</span>
                                               <span>round</span><span>&#40;</span>pos<span>&#91;</span><span>1</span><span>&#93;</span> * <span>self</span>.<span>factory</span><span>,</span><span>0</span><span>&#41;</span><span>,</span>
                                               dotlength<span>,</span> dotlength<span>&#41;</span><span>&#41;</span>
<span>#...</span>

<h3>ideas</h3>

&lt;note tip&gt;How powerful is your computer ? Change all those variables in the <strong>Config</strong>>loading images (step007)</a> ? try to load an existing image to use as <strong>bigmap</strong>&lt;/note&gt; 
&lt;note tip&gt;What of building obstacles for the tanks to navigate around?&lt;/note&gt;
&lt;note tip&gt;What about lobbing projectiles over obstacles by calculating kinetic energy required to move an object that weighs X amount Y distance?&lt;/note&gt;

<h3>additional resources</h3>

no additional resources necessary

<h3>source code on github</h3>
To run this example you need:

	<thead>
	
		<th>  file  </th><th>  in folder  </th><th>  download  </th>
	
	</thead>

<a href="https://github.com/horstjens/ThePythonGameBook/raw/master/pygame/022_minimap.py">022_minimap.py</a>    <code>pygame</code>    Download the whole Archive with all files from Github:  <br/>
<a href="https://github.com/horstjens/ThePythonGameBook/archives/master">https://github.com/horstjens/ThePythonGameBook/archives/master</a>  

View/Edit/Download the file directly in Github: <a href="https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/022_minimap.py">https://github.com/horstjens/ThePythonGameBook/blob/master/pygame/022_minimap.py</a>

<h1 class="title">Step 023 - LayeredDirty Sprites</h1>
	

&lt;note warning&gt;This page is under construction!&lt;/note&gt;

According to the pygame documentation at
<a href="http://www.pygame.org/docs/ref/sprite.html#pygame.sprite.LayeredDirty">http://www.pygame.org/docs/ref/sprite.html#pygame.sprite.LayeredDirty</a>

pygame provides a <strong>LayeredDirty</strong> group for sprites. 
This is handy for sprites that do not move around a lot and don&#039;t need to be redrawn every frame.

Sadly i am not able to understand how to change the layer of a LayeredDirty sprite after it&#039;s creation…

The only way to assign o layer to a sprite DirtyLayered sprite group is to watch the order of creating those sprites.

LayerdDirty works best with DirtySprites, a subclass of Sprites:

pygame.sprite.DirtySprite
a more featureful subclass of Sprite with more attributes
pygame.sprite.DirtySprite(*groups): return DirtySprite
None	
Extra DirtySprite attributes with their default values:

dirty = 1

   if set to 1, it is repainted and then set to 0 again
   if set to 2 then it is always dirty ( repainted each frame,
   flag is not reset)
   0 means that it is not dirty and therefor not repainted again
blendmode = 0

   its the special_flags argument of blit, blendmodes
source_rect = None

   source rect to use, remember that it is relative to
   topleft (0,0) of self.image
visible = 1

   normally 1, if set to 0 it will not be repainted
   (you must set it dirty too to be erased from screen)
layer = 0

   (READONLY value, it is read when adding it to the
   LayeredRenderGroup, for details see doc of LayeredRenderGroup)

Also see <a href="/en:resources:games:schwarzweiss">schwarzweiss game</a> for an example of how to use LayeredDirty sprite group.

<h4 id="source_code_on_github">source code on github</h4>
	
<h2>- Step 024 - Game menu</h2>

&lt;note warning&gt;This page is under construction!&lt;/note&gt;

<h3>description</h3>

<a href="/_detail/en:part2:pygame:easyguimenu.png?id=en%3Apygame%3Astep024"><img src="http://thepythongamebook.com/_media/en:part2:pygame:easyguimenu.png"></a>
<span>
	<a href="/tag:easygui?do=showtag&amp;tag=easygui">easygui</a>,
	<a href="/tag:menu?do=showtag&amp;tag=menu">menu</a>,
	<a href="/tag:pygame?do=showtag&amp;tag=pygame">pygame</a>
</span>

Most games do not throw the player directly into the game (like in all previous steps) but instead offer some kind of game menu. 
Inside a game menu, the player can usually access options (like changinging the <a href="/en:resoureces:glossary:s:screen_resolution">screen resolution</a> or toggling <a href="/en:resources:glossary:f:full-screen">full-screen mode</a>) ), he can view the highscore list, starting or leaving the game and sometimes watch an introduction or help screen.

Tasks like this are ideally done using a <a href="/en:resources:glossary:g:gui">GUI (graphical User Interface</a> but sadly, pygame is not shipped with any <abbr title="Graphical User Interface">GUI</abbr>. 
Instead, you can use an existing gui like <a href="/en:resources:glossary:t:tkinter">Tkinter</a>, <a href="/en:resources:glossary:e:easygui">EasyGui</a>, <a href="/en:resources:glossary:w:wxpython">wxpython</a> to write your game menu and launch the whole pygame “game” from within. 
This can be done by programming the whole pygame game as a function, passing arguments to it and returning the score value.
<span>#... 
inside gui...</span>
<span>import</span> pygamegame
<span>#... 
some gui code letting the player choose the screen resolution</span>
score <span>=</span> pygamegame<span>&#40;</span>screen_resolution<span>&#41;</span> <span># start the pygame game and return the score to the menu</span>
<span>#... 
some gui code to add the score to the highscore</span>

Alternatively you can write your own menu system using pygame. 
The source code example below includes several files:

<h3>additional resources</h3>

Normally you do not want to have more than one executable program in the project folder, to avoid confusing the user. 
Instead, you want another folder (<strong>data</strong>) inside the project folder, and only a single executable program in the project folder calling all other necessary programs.
For this example, it is necessary that the folder where <strong>easyguimenu.py</strong> is located has an subfolder called <strong>data</strong>. 
Inside this <strong>data</strong> folder must be the programs <strong>screensaver.py</strong>, <strong>easygui.py</strong> and one empty file named <strong>__init__.py</strong>.

To make this code example working, you need 4 files, 3 of them located inside a subfolder named <strong>data</strong>:
easyguimenu.py (the game menu, see source code below)
inside the subfolder <strong>data</strong>:
<em>init.py</em> (an empty file, just the filename is important)
easygui.py (see <a href="/en:resources:glossary:e:easygui">EasyGUI</a>)
screensaver.py (the game itself, see source code below)

You best download and extract this archive, it contains all necessary files and folders:
<a href="/_media/en:part2:pygame:step023_menu.tar.gz">all files and folders in one archive</a>

<a href="/_detail/en:part2:pygame:folders23.jpg?id=en%3Apygame%3Astep024"><img src="http://thepythongamebook.com/_media/en:part2:pygame:folders23.jpg"></a>

<h3>ideas</h3>

&lt;note tip&gt;Replace the command <strong>easygui.buttonboxe</strong> with <strong>easygui.choicebox</strong>. 
Try out other <a href="/en:resources:glossary:e:easygui">EasyGUI</a> commands.&lt;/note&gt;
&lt;note tip&gt;Easygui can display <strong>gif-graphics</strong> and if you install python-imaging-tk correctly it can display also <strong>jpg</strong> and <strong>png</strong> graphics. 
Make your game menu even more pretty by displaying a nice graphic.&lt;/note&gt;

<h3>source code</h3>
<h4 id="pygame_screensaver">pygame screensaver</h4>
This is not even a game, just some sort of screensaver drawing random colored circles. 
Written as a function in pygame, it accepts a screenresolution tuple (x,y) as argument and returns the time in seconds the screensaver was watched.
<dl>
<dt><a href="/_export/code/en:pygame:step024?codeblock=1" title="Download Snippet">screensaver.py</a></dt>
<dd><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>
<span>#</span>
<span>#       screensaver.py</span>
<span>import</span> pygame
<span>import</span> <span>random</span>
&nbsp;
<span>def</span> screensaver<span>&#40;</span>screenresolution <span>=</span> <span>&#40;</span><span>640</span><span>,</span><span>480</span><span>&#41;</span><span>&#41;</span>:
   <span># -*- coding: utf-8 -*-</span>
   <span>&quot;&quot;&quot;very simple test &quot;game&quot; or screensaver.
      all the user have to do is press ESC or SPACE.
      the &quot;game&quot; paint random circles.
      the &quot;game&quot; accept a screen resolution tuple as argument.
      the &quot;game&quot; returns the time passed until the user pressed space&quot;&quot;&quot;</span>
   pygame.<span>init</span><span>&#40;</span><span>&#41;</span>                      <span>#initialize pygame</span>
   screen<span>=</span>pygame.<span>display</span>.<span>set_mode</span><span>&#40;</span><span>&#40;</span>screenresolution<span>&#91;</span><span>0</span><span>&#93;</span><span>,</span>screenresolution<span>&#91;</span><span>1</span><span>&#93;</span><span>&#41;</span><span>&#41;</span> <span># set screensize of pygame window</span>
   background <span>=</span> pygame.<span>Surface</span><span>&#40;</span>screen.<span>get_size</span><span>&#40;</span><span>&#41;</span><span>&#41;</span>  <span>#create empty pygame surface</span>
   background.<span>fill</span><span>&#40;</span><span>&#40;</span><span>255</span><span>,</span><span>255</span><span>,</span><span>255</span><span>&#41;</span><span>&#41;</span>     <span>#fill the background white color (red,green,blue)</span>
   background <span>=</span> background.<span>convert</span><span>&#40;</span><span>&#41;</span>  <span>#convert Surface object to make blitting faster</span>
   screen.<span>blit</span><span>&#40;</span>background<span>,</span> <span>&#40;</span><span>0</span><span>,</span><span>0</span><span>&#41;</span><span>&#41;</span>     <span>#draw the background on screen</span>
   clock <span>=</span> pygame.<span>time</span>.<span>Clock</span><span>&#40;</span><span>&#41;</span>        <span>#create a pygame clock object</span>
   mainloop <span>=</span> <span>True</span>                    
   FPS <span>=</span> <span>30</span> <span># desired framerate in frames per second. 
try out other values !</span>
   playtime <span>=</span> <span>0.0</span> <span># how many seconds the &quot;game&quot; is played</span>
   <span>while</span> mainloop:
       milliseconds <span>=</span> clock.<span>tick</span><span>&#40;</span>FPS<span>&#41;</span> <span># do not go faster than this framerate</span>
       playtime +<span>=</span> milliseconds / <span>1000.0</span> <span># add seconds to playtime</span>
       <span># paint random circles</span>
       color <span>=</span> <span>&#40;</span><span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>255</span><span>&#41;</span><span>,</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>255</span><span>&#41;</span><span>,</span> <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>255</span><span>&#41;</span><span>&#41;</span>
       pygame.<span>draw</span>.<span>circle</span><span>&#40;</span>screen<span>,</span> color<span>,</span> <span>&#40;</span><span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span>screenresolution<span>&#91;</span><span>0</span><span>&#93;</span><span>&#41;</span><span>,</span>
                                          <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span>screenresolution<span>&#91;</span><span>1</span><span>&#93;</span><span>&#41;</span><span>&#41;</span><span>,</span>
                                          <span>random</span>.<span>randint</span><span>&#40;</span><span>1</span><span>,</span> <span>min</span><span>&#40;</span>screenresolution<span>&#91;</span><span>0</span><span>&#93;</span><span>,</span> screenresolution<span>&#91;</span><span>1</span><span>&#93;</span><span>&#41;</span><span>&#41;</span><span>,</span>
                                          <span>random</span>.<span>randint</span><span>&#40;</span><span>0</span><span>,</span><span>1</span><span>&#41;</span><span>&#41;</span>        
       <span>for</span> event <span>in</span> pygame.<span>event</span>.<span>get</span><span>&#40;</span><span>&#41;</span>:
           <span>if</span> event.<span>type</span> <span>==</span> pygame.<span>QUIT</span>:
               mainloop <span>=</span> <span>False</span> <span># pygame window closed by user</span>
           <span>elif</span> event.<span>type</span> <span>==</span> pygame.<span>KEYDOWN</span>:
               <span>if</span> event.<span>key</span> <span>==</span> pygame.<span>K_ESCAPE</span>:
                   mainloop <span>=</span> <span>False</span> <span># user pressed ESC</span>
               <span>if</span> event.<span>key</span> <span>==</span> pygame.<span>K_SPACE</span>:
                   mainloop <span>=</span> <span>False</span> <span># user pressed ESC</span>
       pygame.<span>display</span>.<span>set_caption</span><span>&#40;</span><span>&quot;press ESC to quit. 
frame rate: %.2f fps, time: %.2f seonds&quot;</span> % <span>&#40;</span>clock.<span>get_fps</span><span>&#40;</span><span>&#41;</span><span>,</span> playtime<span>&#41;</span><span>&#41;</span>
       pygame.<span>display</span>.<span>flip</span><span>&#40;</span><span>&#41;</span>          <span># flip the screen like in a flip book</span>
   <span>print</span> <span>&quot;This 'game' was played for %.2f seconds&quot;</span> % playtime
   pygame.<span>quit</span><span>&#40;</span><span>&#41;</span> <span># this line is important so that the pygame window does not remain open.</span>
   <span>return</span> playtime <span># in seconds</span>
&nbsp;
<span>if</span> __name__ <span>==</span> <span>'__main__'</span>:
   screensaver<span>&#40;</span><span>&#41;</span>
</dd></dl>

<h4 id="easygui_menu">easygui menu</h4>
Here is the code of a very simple menu system written in <a href="/en:resources:glossary:e:easygui">Easygui</a>. 
It allows to change the screen resolution, to start the screensaver, and to quit. 
The number of seconds the screensaver was watched is returned from the screensaver.py program to this program and displayed.
<dl>
<dt><a href="/_export/code/en:pygame:step024?codeblock=2" title="Download Snippet">easyguimenu.py</a></dt>
<dd><span>#!/usr/bin/env python</span>
<span># -*- coding: utf-8 -*-</span>
<span>#</span>
<span>#       easyguimenu.py</span>
<span>#       </span>
<span>#       Copyright 2011 Horst JENS &lt;horst.jens@spielend-programmieren.at&gt;</span>
<span>#       license: gpl</span>
<span>#       part of http://ThePythonGameBook.com</span>
<span>#       needs easygui from http://easygui.sourceforge.net/ to work</span>
&nbsp;
<span># both easygui.py and screensaber.py must be located in a </span>
<span># subdirectory 'data'. 
In this subdirectory there have to exist an</span>
<span># empty file with the name '__init__.py'</span>
&nbsp;
<span>from</span> data <span>import</span> easygui 
<span>from</span> data <span>import</span> screensaver 
&nbsp;
<span>def</span> gamemenu<span>&#40;</span><span>&#41;</span>:
   resolution <span>=</span> <span>&#91;</span><span>640</span><span>,</span><span>480</span><span>&#93;</span>
   watched <span>=</span> <span>0</span>
   msg <span>=</span> <span>&quot;Welcome at screensaver game menu. 
please choose wisely:&quot;</span>
   buttons <span>=</span> <span>&#91;</span><span>&quot;watch screensaver&quot;</span><span>,</span> <span>&quot;change resolution&quot;</span><span>,</span> <span>&quot;quit&quot;</span><span>&#93;</span>
   picture <span>=</span> <span>None</span> <span># gif file</span>
   <span>while</span> <span>True</span>: <span>#endless loop</span>
       title <span>=</span> <span>&quot;screensave will run with %ix%i resolution&quot;</span> % <span>&#40;</span>resolution<span>&#91;</span><span>0</span><span>&#93;</span><span>,</span> resolution<span>&#91;</span><span>1</span><span>&#93;</span><span>&#41;</span>
       selection <span>=</span> easygui.<span>buttonbox</span><span>&#40;</span>msg<span>,</span> title<span>,</span> buttons<span>,</span> picture<span>&#41;</span>
       <span>if</span> selection <span>==</span> <span>&quot;quit&quot;</span>:
           easygui.<span>msgbox</span><span>&#40;</span><span>&quot;bye-bye&quot;</span><span>&#41;</span>
           <span>break</span> <span># leave loop</span>
       <span>elif</span> selection <span>==</span> <span>&quot;watch screensaver&quot;</span>:
           watched +<span>=</span> <span>1</span>
           playtime <span>=</span> screensaver.<span>screensaver</span><span>&#40;</span>resolution<span>&#41;</span>
           msg +<span>=</span> <span>&quot;<span>\n</span> you watched the screensaver for %i seconds&quot;</span> % playtime
       <span>elif</span> selection <span>==</span> <span>&quot;change resolution&quot;</span>:
           resolution<span>&#91;</span><span>0</span><span>&#93;</span> <span>=</span> easygui.<span>integerbox</span><span>&#40;</span><span>&quot;Please enter the new value for the x resolution:&quot;</span><span>,</span> 
                                              title<span>,</span> resolution<span>&#91;</span><span>0</span><span>&#93;</span><span>,</span> <span>0</span><span>,</span> <span>4000</span><span>&#41;</span>
           resolution<span>&#91;</span><span>1</span><span>&#93;</span> <span>=</span> easygui.<span>integerbox</span><span>&#40;</span><span>&quot;Please enter the new value for the y resolution:&quot;</span><span>,</span> 
                                              title<span>,</span> resolution<span>&#91;</span><span>1</span><span>&#93;</span><span>,</span> <span>0</span><span>,</span> <span>2000</span><span>&#41;</span>
   <span>return</span> watched <span># returns how many times the screensaver was watched (if anybody ask)</span>
&nbsp;
<span>if</span> __name__ <span>==</span> <span>'__main__'</span>:
   gamemenu<span>&#40;</span><span>&#41;</span>
</dd></dl>
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
<h2>- 002_display_fps.py</h2>

Open a Pygame window and display framerate.
Program terminates by pressing the ESCAPE-Key.

works with python2.7 and python3.4 

URL    : http://thepythongamebook.com/en:part2:pygame:step002
Author : horst.jens@spielend-programmieren.at
License: GPL, see http://www.gnu.org/licenses/gpl.html
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division
import pygame

# Initialize Pygame.
pygame.init()
# Set size of pygame window.
screen=pygame.display.set_mode((640,480))
# Create empty pygame surface.
background = pygame.Surface(screen.get_size())
# Fill the background white color.
background.fill((255, 255, 255))
# Convert Surface object to make blitting faster.
background = background.convert()
# Copy background to screen (position (0, 0) is upper left corner).
screen.blit(background, (0,0))
# Create Pygame clock object. 
 
clock = pygame.time.Clock()

mainloop = True
# Desired framerate in frames per second. 
Try out other values. 
             
FPS = 30
# How many seconds the "game" is played.
playtime = 0.0

while mainloop:
   # Do not go faster than this framerate.
   milliseconds = clock.tick(FPS) 
   playtime += milliseconds / 1000.0 
   
   for event in pygame.event.get():
       # User presses QUIT-button.
       if event.type == pygame.QUIT:
           mainloop = False 
       elif event.type == pygame.KEYDOWN:
           # User presses ESCAPE-Key
           if event.key == pygame.K_ESCAPE:
               mainloop = False
               
   # Print framerate and playtime in titlebar.
   text = "FPS: {0:.2f}   Playtime: {1:.2f}".format(clock.get_fps(), playtime)
   pygame.display.set_caption(text)

   #Update Pygame display.
   pygame.display.flip()

# Finish Pygame. 
 
pygame.quit()

# At the very last:
print("This game was played for {0:.2f} seconds".format(playtime))
This Gist brought to you by gist-it.view rawpygame/002_display_fps.py

<h2></h2>
#!/usr/bin/env python

"""
<h2>002_display_fps_pretty.py</h2>

Display framerate and playtime.
Works with Python 2.7 and 3.3+.

URL:     http://thepythongamebook.com/en:part2:pygame:step002
Author:  yipyip
License: Do What The Fuck You Want To Public License (WTFPL)
        See http://sam.zoy.org/wtfpl/
"""

####

import pygame
####

class PygView(object):
   def __init__(self, width=640, height=400, fps=30):
       """Initialize pygame, window, background, font,...
       """
       pygame.init()
       pygame.display.set_caption("Press ESC to quit")
       self.width = width
       self.height = height
       #self.height = width // 4
       self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
       self.background = pygame.Surface(self.screen.get_size()).convert()
       self.clock = pygame.time.Clock()
       self.fps = fps
       self.playtime = 0.0
       self.font = pygame.font.SysFont('mono', 20, bold=True)
   def run(self):
       """The mainloop
       """
       running = True
       while running:
           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   running = False
               elif event.type == pygame.KEYDOWN:
                   if event.key == pygame.K_ESCAPE:
                       running = False

           milliseconds = self.clock.tick(self.fps)
           self.playtime += milliseconds / 1000.0
           self.draw_text("FPS: {:6.3}{}PLAYTIME: {:6.3} SECONDS".format(
                          self.clock.get_fps(), " "*5, self.playtime))

           pygame.display.flip()
           self.screen.blit(self.background, (0, 0))

       pygame.quit()
   def draw_text(self, text):
       """Center text in window
       """
       fw, fh = self.font.size(text) # fw: font width,  fh: font height
       surface = self.font.render(text, True, (0, 255, 0))
       # // makes integer division in python3
       self.screen.blit(surface, ((self.width - fw) // 2, (self.height - fh) // 2))

####

if __name__ == '__main__':

   # call with width of window and fps
   PygView(640, 400).run()
This Gist brought to you by gist-it.view rawpygame/002_display_fps_pretty.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>003_static_blit.py</h2>
static blitting and drawing
url: http://thepythongamebook.com/en:part2:pygame:step003
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

work with python3.4 and python2.7

Blitting a surface on a static position
Drawing a filled circle into ballsurface.
Blitting this surface once.
introducing pygame draw methods
The ball's rectangular surface is black because the background
color of the ball's surface was never defined nor filled."""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
pygame.init()
screen=pygame.display.set_mode((640,480))
background = pygame.Surface(screen.get_size())
background.fill((255,255,255))     # fill the background white 
background = background.convert()  # prepare for faster blitting
ballsurface = pygame.Surface((50,50))     # create a rectangular surface for the ball
#pygame.draw.circle(Surface, color, pos, radius, width=0) 
# draw blue filled circle on ball surface
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) 
ballsurface = ballsurface.convert() 
ballx = 320
bally = 240

#------- try out some pygame draw functions --------
# see the original documentation at http://www.pygame.org/docs/ref/draw.html

# pygame.draw.rect(Surface, color, Rect, width=0): return Rect
# rect: (x-position of topleft corner, y-position of topleft corner, width, height)
pygame.draw.rect(background, (0,255,0), (50,50,100,25))
# pygame.draw.circle(Surface, color, pos, radius, width=0): return Rect
pygame.draw.circle(background, (0,200,0), (200,50), 35)
# pygame.draw.polygon(Surface, color, pointlist, width=0): return Rect
pygame.draw.polygon(background, (0,180,0), ((250,100),(300,0),(350,50)))
# pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1): return Rect
# radiant instead of grad
pygame.draw.arc(background, (0,150,0),(400,10,150,100), 0, 3.14) 

#------- blit the surfaces on the screen to make them visible
screen.blit(background, (0,0))     # blit the background on the screen (overwriting all)
screen.blit(ballsurface, (ballx, bally))  # blit the topleft corner of ball surface at pos (ballx, bally)
clock = pygame.time.Clock()
mainloop = True
FPS = 30 # desired framerate in frames per second. 
try out other values !
playtime = 0.0

while mainloop:
   milliseconds = clock.tick(FPS) # do not go faster than this frame rate
   playtime += milliseconds / 1000.0
   # ----- event handler -----
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC
   pygame.display.set_caption("Frame rate: {:0.2f} frames per second." 
                              " Playtime: {:.2} seconds".format(
                              clock.get_fps(),playtime))
   pygame.display.flip()      # flip the screen like in a flipbook
print("this 'game' was played for %.2f seconds" % playtime)
This Gist brought to you by gist-it.view rawpygame/003_static_blit.py
# -*- coding: utf-8 -*-
"""
<h2>003_static_blit_pretty.py</h2>
static blitting and drawing (pretty version)
url: http://thepythongamebook.com/en:part2:pygame:step003
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

works with pyhton3.4 and python2.7

Blitting a surface on a static position
Drawing a filled circle into ballsurface.
Blitting this surface once.
introducing pygame draw methods
The ball's rectangular surface is black because the background
color of the ball's surface was never defined nor filled."""
import pygame 

class PygView(object):

 
   def __init__(self, width=640, height=400, fps=30):
       """Initialize pygame, window, background, font,...
          default arguments 
       """
       pygame.init()
       pygame.display.set_caption("Press ESC to quit")
       self.width = width
       self.height = height
       self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
       self.background = pygame.Surface(self.screen.get_size()).convert()  
       self.background.fill((255,255,255)) # fill background white
       self.clock = pygame.time.Clock()
       self.fps = fps
       self.playtime = 0.0
       self.font = pygame.font.SysFont('mono', 24, bold=True)

   def paint(self):
       """painting on the surface"""
       #------- try out some pygame draw functions --------
       # pygame.draw.line(Surface, color, start, end, width) 
       pygame.draw.line(self.background, (0,255,0), (10,10), (50,100))
       # pygame.draw.rect(Surface, color, Rect, width=0): return Rect
       pygame.draw.rect(self.background, (0,255,0), (50,50,100,25)) # rect: (x1, y1, width, height)
       # pygame.draw.circle(Surface, color, pos, radius, width=0): return Rect
       pygame.draw.circle(self.background, (0,200,0), (200,50), 35)
       # pygame.draw.polygon(Surface, color, pointlist, width=0): return Rect
       pygame.draw.polygon(self.background, (0,180,0), ((250,100),(300,0),(350,50)))
       # pygame.draw.arc(Surface, color, Rect, start_angle, stop_angle, width=1): return Rect
       pygame.draw.arc(self.background, (0,150,0),(400,10,150,100), 0, 3.14) # radiant instead of grad
       # ------------------- blitting a Ball --------------
       myball = Ball() # creating the Ball object
       myball.blit(self.background) # blitting it

   def run(self):
       """The mainloop
       """
       self.paint() 
       running = True
       while running:
           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   running = False 
               elif event.type == pygame.KEYDOWN:
                   if event.key == pygame.K_ESCAPE:
                       running = False

           milliseconds = self.clock.tick(self.fps)
           self.playtime += milliseconds / 1000.0
           self.draw_text("FPS: {:6.3}{}PLAYTIME: {:6.3} SECONDS".format(
                          self.clock.get_fps(), " "*5, self.playtime))

           pygame.display.flip()
           self.screen.blit(self.background, (0, 0))
           
       pygame.quit()
   def draw_text(self, text):
       """Center text in window
       """
       fw, fh = self.font.size(text)
       surface = self.font.render(text, True, (0, 0, 0))
       self.screen.blit(surface, (50,150))

class Ball(object):
   """this is not a native pygame sprite but instead a pygame surface"""
   def __init__(self, radius = 50, color=(0,0,255), x=320, y=240):
       """create a (black) surface and paint a blue ball on it"""
       self.radius = radius
       self.color = color
       self.x = x
       self.y = y
       # create a rectangular surface for the ball 50x50
       self.surface = pygame.Surface((2*self.radius,2*self.radius))    
       # pygame.draw.circle(Surface, color, pos, radius, width=0) # from pygame documentation
       pygame.draw.circle(self.surface, color, (radius, radius), radius) # draw blue filled circle on ball surface
       self.surface = self.surface.convert() # for faster blitting. 

       # to avoid the black background, make black the transparent color:
       # self.surface.set_colorkey((0,0,0))
       # self.surface = self.surface.convert_alpha() # faster blitting with transparent color
       
   def blit(self, background):
       """blit the Ball on the background"""
       background.blit(self.surface, ( self.x, self.y))
   
####

if __name__ == '__main__':

   # call with width of window and fps
   PygView().run()
This Gist brought to you by gist-it.view rawpygame/003_static_blit_pretty.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>004_colorkey.py</h2>
dynamic blitting and colorkey
url: http://thepythongamebook.com/en:part2:pygame:step004
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Blitting one surface on 2 static positions, once before the
mainloop and once inside the mainloop.
using colorkey to make a part of the surfaces tranparent
blitting lines on the screen to create a colourful pattern
like in a screensaver
"""

import pygame
import random
pygame.init()
screen=pygame.display.set_mode((640,480))
background = pygame.Surface(screen.get_size())
background.fill((255,255,255))     # fill the background white (red,green,blue)
background = background.convert()  # faster blitting
ballsurface = pygame.Surface((50,50))     # create a new surface (black by default)
ballsurface.set_colorkey((0,0,0))         # make black the transparent color (red,green,blue)
#pygame.draw.circle(Surface, color, pos, radius, width=0)
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) # paint blue circle
ballsurface = ballsurface.convert_alpha()        # faster blitting, convert_alpha() because transparency
screen.blit(background, (0,0))     #draw background on screen (overwriting all)
ballx = 20   # left ball position
bally = 240
screen.blit(ballsurface, (ballx, bally))  #draw the ball surface (lines will draw over this ball)
ballx2 = 400  # right ball position
bally2 = 380
clock = pygame.time.Clock()
mainloop = True
FPS = 30 # desired framerate in frames per second. 
try out other values !
playtime = 0.0
t = 0 # variable used to draw a pattern
color1 = 0
color2 = 0
while mainloop:
   milliseconds = clock.tick(FPS) # do not go faster than this framerate
   playtime += milliseconds / 1000.0
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC
   # ------- draw cute pattern ------------------
   pygame.draw.line(screen, (color1,255-color1,color2), (32*t,0), (0,480-24*t))
   pygame.draw.line(screen, (255-color2,color2,color1), (32*t,480), (640,480-24*t))
   screen.blit(ballsurface, (ballx2, bally2))  #draw the ball over the lines 
   t += 1   # increase t
   if t > 20:
       t = 0 # reset t
       color1 = random.randint(0,255) # new color
       color2 = random.randint(0,255)
   # --------- end of cute pattern drawing code ----------
   pygame.display.set_caption("Frame rate %.2f frames per second. 
Playtime: %.2f seconds" % (clock.get_fps(),playtime))  
   pygame.display.flip()          # flip the screen 30 times a second
print "This 'game' was played for %.2f seconds." % playtime
This Gist brought to you by gist-it.view rawpygame/004_colorkey.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" 004_alphademo.py
   colorkey and alpha-value
   url: http://thepythongamebook.com/en:part2:pygame:step004
   author: horst.jens@spielend-programmieren.at
   per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
   licence: gpl, see http://www.gnu.org/licenses/gpl.html
   
   works with pyhton3.4 and python2.7
"""
import pygame
import os


def get_alpha_surface( surf, alpha=128, red=128, green=128, blue=128, mode=pygame.BLEND_RGBA_MULT):
   """returns a copy of a surface object with user-defined 
      values for red, green, blue and alpha. 

      Values from 0-255. 

      thanks to Claudio Canepa <ccanepacc@gmail.com>
      for this function."""
 
   tmp = pygame.Surface( surf.get_size(), pygame.SRCALPHA, 32)
   tmp.fill( (red,green,blue,alpha) )
   tmp.blit(surf, (0,0), surf.get_rect(), mode)
   return tmp

def bounce(value, direction, bouncing=True, valuemin=0, valuemax=255):
   """bouncing a value (like alpha or color) between 
      baluemin and valuemax. 

      When bouncing is True,
      direction (usually -1 or 1)  is inverted when reaching valuemin or valuemax"""
      
   value += direction # increase or decrase value by direction
   if value <= valuemin:
       value = valuemin
       if bouncing:
           direction *= -1
   elif value >= valuemax:
       value = valuemax
       if bouncing: 
           direction *= -1
   return value, direction  
   
def write(msg="pygame is cool", size=24, color=(255,255,255)):
   myfont = pygame.font.SysFont("None", size)
   mytext = myfont.render(msg, True, color)
   mytext = mytext.convert_alpha()
   return mytext

def alphademo(width=800, height=600):
   pygame.init()
   screen=pygame.display.set_mode((width, height))
   background = pygame.Surface(screen.get_size()).convert()
   #background.fill((255, 255, 255))     #fill the background white
   venus = pygame.image.load(os.path.join("data","800px-La_naissance_de_Venus.jpg")).convert()
   # transform venus and blit on background in one go
   pygame.transform.scale(venus, (width, height), background) 
   # --------- png image with convert.alpha() ------------------
   # .png and .gif graphics can have transparency. 
use convert_alpha()
   pngMonster = pygame.image.load(os.path.join("data", "colormonster.png")).convert_alpha()
   pngMonster0 = pngMonster.copy() # a copy 
   pngMonster3 = pngMonster.copy() # copy for per-pixel alpha
   
   # ---------- jpg image  ------------
   # using .convert() at an .png image is the same as using a .jpg  
   # => no transparency !
   jpgMonster = pygame.image.load(os.path.join("data","colormonster.jpg")).convert()
   jpgMonster0 = jpgMonster.copy() # copy of jpgMonster 
   jpgMonster1 = jpgMonster.copy() # another copy to demonstrate colorkey
   jpgMonster1.set_colorkey((255,255,255)) # make white color transparent
   jpgMonster1.convert_alpha() 
   jpgMonster2 = jpgMonster.copy() # another copy for surface alpha
   jpgMonster3 = jpgMonster.copy() # anoter copy for per-pixel alpha
   # ------- text surfaces ----------
   png0text = write("png (has alpha)")
   png3text = write("png with pixel-alpha")
   jpg0text = write("jpg (no alpha)")
   jpg1text = write("jpg with colorkey")
   jpg2text = write("jpg with surface alpha")
   jpg3text = write("jpg with pixel-alpha")
   # ------- for bitmap-alpha --------
   alpha = 128   # between 0 and 255. 

   direction = 1 # change of alpha
   # ------- for per-pixel-alpha -----
   r = 255 # red
   g = 255 # green
   b = 255 # blue
   a = 255 # pixel-alpha
   modeNr = 7 
   # index 7, int-value 8, name="BLEND_RGB_MULT" ,usage = pygame.BLEND_RGB_MULT
   paper = pygame.Surface((400,100)) # background for instructions
   #paper.fill((0,0,0))              # is already black, no fill necessary
   paper.set_alpha(128)              # half-transparent
   
   
   modelist = [ "BLEND_ADD",
                "BLEND_SUB",
                "BLEND_MULT",
                "BLEND_MIN",
                "BLEND_MAX",
                "BLEND_RGBA_ADD",
                "BLEND_RGBA_SUB",
                "BLEND_RGBA_MULT",
                "BLEND_RGBA_MIN",
                "BLEND_RGBA_MAX" ]
   
   
   # -------  mainloop ----------
   clock = pygame.time.Clock()
   mainloop = True
   effects = False
   while mainloop:
       clock.tick(30)
       screen.blit(background, (0,0)) # draw background every frame
       pygame.display.set_caption("insert/del=red:%i, home/end=green:%i, pgup/pgdwn=blue:%i, +/-=pixalpha:%i press ESC" % ( r, g, b, a))
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               mainloop = False
           elif event.type == pygame.KEYDOWN: # press and release key
               if event.key == pygame.K_ESCAPE:
                   mainloop = False
               if event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                   #modeNr += 1
                   #if modeNr > 9: 
                   #    modeNr = 0 # cycle throug number 0 to 9
                   modeNr = (modeNr + 1) % len(modelist) # by yipyip
       mode = pygame.constants.__dict__[modelist[modeNr]]
       # ------ keyb is pressed ? -------
       dr, dg, db, da = 0,0,0,0 # set changing to 0 for red, green, blue, pixel-alpha
       pressed_keys = pygame.key.get_pressed()
       if pressed_keys[pygame.K_PAGEUP]: 
           db = 1 # blue up
       if pressed_keys[pygame.K_PAGEDOWN]: 
           db = -1 # blue down
       if pressed_keys[pygame.K_HOME]:
           dg = 1 # green up
       if pressed_keys[pygame.K_END]:
           dg = -1 # green down
       if pressed_keys[pygame.K_INSERT]:
           dr = 1 # red up
       if pressed_keys[pygame.K_DELETE]:
           dr = -1 # red down
       if pressed_keys[pygame.K_KP_PLUS]:
           da = 1 # alpha up
       if pressed_keys[pygame.K_KP_MINUS]:
           da = -1 # alpha down
       # ------- change color and alpha values -------- 
       alpha, direction = bounce(alpha, direction) # change alpha
       r, dr = bounce(r,dr, False)  # red for per-pixel
       g, dg = bounce(g,dg, False)  # green for per-pixel
       b, db = bounce(b, db, False) # blue for per-pixel
       a, da = bounce(a, da, False) # alpha for per-pixel
       
       # ----- blit jpgMonster0 as ist is, no alpha at all ------
       screen.blit(jpgMonster0, (0, 300))
       screen.blit(jpg0text,(0,550))
       # ------blit jpgMonster1 with the colorkey set to white ------
       screen.blit(jpgMonster1, (200,300))
       screen.blit(jpg1text, (200,550))
       # ----- blit jpgmonster2 with alpha for whole  surface  --------
       jpgMonster2.set_alpha(alpha) # alpha for whole surface
       screen.blit(jpgMonster2, (400,300))  # blit on screen
       screen.blit(jpg2text,(400,550))
       screen.blit(write("surface-alpha: %i" % alpha),(400,570))
       # ----- blit jpgmonster3 with per-pixel alpha-------
       tmp = get_alpha_surface(jpgMonster3, a, r, g, b, mode) # get current alpha
       screen.blit(tmp, (600,300))
       screen.blit(jpg3text, (600, 550))
       # ----- blit pngMonster0 as it is, with transparency from image ---
       screen.blit(pngMonster0, (0, 10))
       screen.blit(png0text, (0, 200))
       # ----- blit pngMonster1 with colorkey set to black ----
       #  ***  png already has alpha, does not need colorkey **
       # ----- blit pngMonster2 with alpha for whole surface -----
       #  *** surface-alpha does not work if surface (png) already has alpha ***
       # ----- blit pngmonster3 with per-pixel alpha-------
       tmp = get_alpha_surface(pngMonster3, a, r, g, b, mode) # get current alpha
       screen.blit(tmp, (600,10))
       screen.blit(png3text, (600,200))
       # ---- instructions ----
       screen.blit(paper, (188,150)) #  semi-transparent background for instructions
       screen.blit(write("press [INS] / [DEL] to change red value: %i" % r,24, (255,255,255)),(190,150))
       screen.blit(write("press [HOME] / [END] to change green value: %i" % g),(190,170))
       screen.blit(write("press [PgUp] / [PgDwn] to chgange blue value: %i"% b), (190, 190))
       screen.blit(write("press [Enter] for mode: %i (%s)" % (mode, modelist[modeNr])), (190,230))
       screen.blit(write("press [+] / [-] (Keypad) to chgange alpha value: %i"% a), (190, 210))
       # ------ next frame --------
       pygame.display.flip()       # flip the screen 30 times a second
       
if __name__ == "__main__":
   alphademo()
This Gist brought to you by gist-it.view rawpygame/004_alphademo.py
#!/usr/bin/env python

"""
<h2>004_alphademo_pretty.py</h2>
Experiments with colorkey and alpha-value
URL: http://thepythongamebook.com/en:part2:pygame:step004
Author: horst.jens@spielend-programmieren.at, prettifying by yipyip
per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
Licence: gpl, see http://www.gnu.org/licenses/gpl.html

works with pyhton2.7
"""

####

import pygame
import os
import itertools

####

BLENDMODES = ((pygame.BLEND_ADD, "ADD"),
             (pygame.BLEND_SUB, "SUB"),
             (pygame.BLEND_MULT, "MULT"),
             (pygame.BLEND_MIN, "MIN"),
             (pygame.BLEND_MAX, "MAX"),
             (pygame.BLEND_RGBA_ADD, "RGBA ADD"),
             (pygame.BLEND_RGBA_SUB, "RGBA SUB"),
             (pygame.BLEND_RGBA_MULT, "RGBA MULT"),
             (pygame.BLEND_RGBA_MIN, "RGBA MIN"),
             (pygame.BLEND_RGBA_MAX, "RGBA MAX"))

####

def load_pic(name, path="data"):

   return pygame.image.load(os.path.join(path, name))

####

def check(x, minval=0, maxval=255):

   return min(maxval, max(minval, x))
   
####

def get_alpha_surface(surface, rgba=(128, 128, 128, 128), mode=pygame.BLEND_RGBA_ADD):
   """
   Return a copy of a surface object with user-defined 
   values for red, green, blue and alpha. 
Values from 0-255. 

   (Thanks to Claudio Canepa <ccanepacc@gmail.com>)
   """  
   new_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA|pygame.HWSURFACE)
   new_surface.fill(rgba)
   new_surface.blit(surface, (0, 0), surface.get_rect(), mode)
   
   return new_surface

####

class AlphaDemo(object):
   def __init__(self, width=900, height=600, fontsize=14):

       pygame.init()
       self.screen = pygame.display.set_mode((width, height), pygame.DOUBLEBUF)
       self.background = pygame.Surface(self.screen.get_size()).convert()
       self.font = pygame.font.SysFont('mono', fontsize, bold=True)
       self.clock = pygame.time.Clock()
       
       #self.background.fill((255, 255, 255))
       venus = load_pic("800px-La_naissance_de_Venus.jpg").convert()
       # transform venus and blit 
       pygame.transform.scale(venus, (width, height), self.background)
       
       # .png and .gif graphics can have transparency, use convert_alpha()
       self.png_monster = load_pic("colormonster.png").convert_alpha()
       
       # jpg image, no transparency!
       self.jpg_monster = load_pic("colormonster.jpg").convert()

       # per pixel rgba
       self.pp_rgba = [255, 255, 255, 128]
       alpha_up = range(0, 256, 4)
       alpha_down = alpha_up[-1::-1]
       self.glob_alphas = itertools.cycle(alpha_up + alpha_down)
       self.step = 4
       self.mode_nr = 5
   def run(self):
       """
       Mainloop
       """
       mainloop = True
       while mainloop:
           self.clock.tick(20)
           # draw background every frame
           self.screen.blit(self.background, (0, 0))
           
           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   mainloop = False
               elif event.type == pygame.KEYDOWN:
                   if event.key == pygame.K_ESCAPE:
                       mainloop = False

           self.action(pygame.key.get_pressed())
           pygame.display.flip()
          

   def action(self, pressed_keys):

       red, green, blue, alpha = self.pp_rgba
       if pressed_keys[pygame.K_PAGEUP]: 
           blue = blue + self.step
       if pressed_keys[pygame.K_PAGEDOWN]: 
           blue = blue - self.step    
       if pressed_keys[pygame.K_HOME]:
           green = green + self.step    
       if pressed_keys[pygame.K_END]:
           green = green - self.step
       if pressed_keys[pygame.K_INSERT]:
           red = red + self.step    
       if pressed_keys[pygame.K_DELETE]:
           red = red - self.step   
       if pressed_keys[pygame.K_KP_PLUS]:
           alpha = alpha + self.step  
       if pressed_keys[pygame.K_KP_MINUS]:
           alpha = alpha - self.step
       if pressed_keys[pygame.K_RETURN]:
           self.mode_nr = (self.mode_nr + 1) % len(BLENDMODES)    
       
       mode, mode_text = BLENDMODES[self.mode_nr]
       self.pp_rgba = map(check, (red, green, blue, alpha))       
       glob_alpha = self.glob_alphas.next()
       self.show_surfaces(self.png_monster, 'png', 0, 0, 200, 180,
                          glob_alpha, self.pp_rgba, mode)
       self.show_surfaces(self.jpg_monster, 'jpg', 0, 300, 200, 180,
                          glob_alpha, self.pp_rgba, mode)

       text = "ins/del=red>%d  home/end=green>%d  pgup/pgdwn=blue>%d  "\
              "+/-=ppalpha>%d  " % tuple(self.pp_rgba)
       pygame.display.set_caption("%s  Mode>%s" % (text, mode_text))
     
 
   def show_surfaces(self, surf, pictype, x, y, x_delta, height,
                     glob_alpha, pp_rgba, mode):

       yh = y + height
       #pure surface
       self.screen.blit(surf, (x, y))
       self.write(x, y + height, "%s pure" % pictype)
       # with with colorkey
       ck_surf = surf.copy()
       ck_surf.set_colorkey((255,255,255))
       x = x + x_delta
       self.screen.blit(ck_surf, (x, y))
       self.write(x, yh, "%s colorkey" % pictype)
       # with alpha for whole surface 
       alpha_surf = surf.copy()
       alpha_surf.set_alpha(glob_alpha)
       x = x + x_delta
       self.screen.blit(alpha_surf, (x, y))
       self.write(x, yh, "%s alpha> %d" % (pictype, glob_alpha))
       # with per-pixel alpha
       ppa_surf = surf.copy()
       ppa_surf = get_alpha_surface(ppa_surf, pp_rgba, mode)
       x = x + x_delta
       self.screen.blit(ppa_surf, (x, y))
       self.write(x, yh, "%s, per-pixel-alpha" % pictype)
   def write(self, x, y, msg, color=(255,255,0)):

       self.screen.blit(self.font.render(msg, True, color), (x, y))
           
####
       
if __name__ == "__main__":
   
   AlphaDemo().run()
This Gist brought to you by gist-it.view rawpygame/004_alphademo_pretty.py
#!/usr/bin/env python

"""
<h2>004_alphademo_pretty.py</h2>
Experiments with colorkey and alpha-value
URL: http://thepythongamebook.com/en:part2:pygame:step004
Original Author: horst.jens@spielend-programmieren.at, prettifying by yipyip
per-pixel-alpha code by Claudio Canepa <ccanepacc@gmail.com>
updating to python3.6 by tatatingting
Licence: gpl, see http://www.gnu.org/licenses/gpl.html

works with pyhton3.6
"""

####

import pygame
import os
import itertools

####

BLENDMODES = ((pygame.BLEND_ADD, "ADD"),
             (pygame.BLEND_SUB, "SUB"),
             (pygame.BLEND_MULT, "MULT"),
             (pygame.BLEND_MIN, "MIN"),
             (pygame.BLEND_MAX, "MAX"),
             (pygame.BLEND_RGBA_ADD, "RGBA ADD"),
             (pygame.BLEND_RGBA_SUB, "RGBA SUB"),
             (pygame.BLEND_RGBA_MULT, "RGBA MULT"),
             (pygame.BLEND_RGBA_MIN, "RGBA MIN"),
             (pygame.BLEND_RGBA_MAX, "RGBA MAX"))
####

def load_pic(name, path="data"):
   return pygame.image.load(os.path.join(path, name))
####

def check(x, minval=0, maxval=255):
   return min(maxval, max(minval, x))
####

def get_alpha_surface(surface, rgba=(128, 128, 128, 128), mode=pygame.BLEND_RGBA_ADD):
   """
   Return a copy of a surface object with user-defined
   values for red, green, blue and alpha. 
Values from 0-255.
   (Thanks to Claudio Canepa <ccanepacc@gmail.com>)
   """
   new_surface = pygame.Surface(surface.get_size(), pygame.SRCALPHA | pygame.HWSURFACE)
   new_surface.fill(rgba)
   new_surface.blit(surface, (0, 0), surface.get_rect(), mode)

   return new_surface
####

class AlphaDemo(object):

   def __init__(self, width=900, height=600, fontsize=14):

       pygame.init()
       self.screen = pygame.display.set_mode((width, height), pygame.DOUBLEBUF)
       self.background = pygame.Surface(self.screen.get_size()).convert()
       self.font = pygame.font.SysFont('mono', fontsize, bold=True)
       self.clock = pygame.time.Clock()

       # self.background.fill((255, 255, 255))
       venus = load_pic("800px-La_naissance_de_Venus.jpg").convert()
       # transform venus and blit
       pygame.transform.scale(venus, (width, height), self.background)

       # .png and .gif graphics can have transparency, use convert_alpha()
       self.png_monster = load_pic("colormonster.png").convert_alpha()

       # jpg image, no transparency!
       self.jpg_monster = load_pic("colormonster.jpg").convert()

       # per pixel rgba
       self.pp_rgba = [255, 255, 255, 128]
       alpha_up = range(0, 256, 4)
       alpha_down = alpha_up[-1::-1]
       self.glob_alphas = itertools.cycle(list(alpha_up) + list(alpha_down))
       self.step = 4
       self.mode_nr = 5

   def run(self):
       """
       Mainloop
       """
       mainloop = True
       while mainloop:
           self.clock.tick(20)
           # draw background every frame
           self.screen.blit(self.background, (0, 0))

           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   mainloop = False
               elif event.type == pygame.KEYDOWN:
                   if event.key == pygame.K_ESCAPE:
                       mainloop = False

           self.action(pygame.key.get_pressed())
           pygame.display.flip()

   def action(self, pressed_keys):

       red, green, blue, alpha = self.pp_rgba
       if pressed_keys[pygame.K_PAGEUP]:
           blue = blue + self.step
       if pressed_keys[pygame.K_PAGEDOWN]:
           blue = blue - self.step
       if pressed_keys[pygame.K_HOME]:
           green = green + self.step
       if pressed_keys[pygame.K_END]:
           green = green - self.step
       if pressed_keys[pygame.K_INSERT]:
           red = red + self.step
       if pressed_keys[pygame.K_DELETE]:
           red = red - self.step
       if pressed_keys[pygame.K_KP_PLUS]:
           alpha = alpha + self.step
       if pressed_keys[pygame.K_KP_MINUS]:
           alpha = alpha - self.step
       if pressed_keys[pygame.K_RETURN]:
           self.mode_nr = (self.mode_nr + 1) % len(BLENDMODES)

       mode, mode_text = BLENDMODES[self.mode_nr]
       self.pp_rgba = list(map(check, (red, green, blue, alpha)))
       glob_alpha = self.glob_alphas.__next__()
       self.show_surfaces(self.png_monster, 'png', 0, 0, 200, 180,
                          glob_alpha, self.pp_rgba, mode)
       self.show_surfaces(self.jpg_monster, 'jpg', 0, 300, 200, 180,
                          glob_alpha, self.pp_rgba, mode)

       text = "ins/del=red>%d  home/end=green>%d  pgup/pgdwn=blue>%d  " \
              "+/-=ppalpha>%d  " % tuple(self.pp_rgba)
       pygame.display.set_caption("%s  Mode>%s" % (text, mode_text))

   def show_surfaces(self, surf, pictype, x, y, x_delta, height,
                     glob_alpha, pp_rgba, mode):

       yh = y + height
       # pure surface
       self.screen.blit(surf, (x, y))
       self.write(x, y + height, "%s pure" % pictype)
       # with with colorkey
       ck_surf = surf.copy()
       ck_surf.set_colorkey((255, 255, 255))
       x = x + x_delta
       self.screen.blit(ck_surf, (x, y))
       self.write(x, yh, "%s colorkey" % pictype)
       # with alpha for whole surface
       alpha_surf = surf.copy()
       alpha_surf.set_alpha(glob_alpha)
       x = x + x_delta
       self.screen.blit(alpha_surf, (x, y))
       self.write(x, yh, "%s alpha> %d" % (pictype, glob_alpha))
       # with per-pixel alpha
       ppa_surf = surf.copy()
       ppa_surf = get_alpha_surface(ppa_surf, pp_rgba, mode)
       x = x + x_delta
       self.screen.blit(ppa_surf, (x, y))
       self.write(x, yh, "%s, per-pixel-alpha" % pictype)

   def write(self, x, y, msg, color=(255, 255, 0)):

       self.screen.blit(self.font.render(msg, True, color), (x, y))
####

if __name__ == "__main__":
   AlphaDemo().run()
This Gist brought to you by gist-it.view rawpygame/004_alphademo_pretty_python3x.py
#!/usr/bin/env python

"""
<h2>004_per-pixel-alphademo.py</h2>

Experiments with alpha values.
Use mouse and scrollwheel.

URL:     http://thepythongamebook.com/en:part2:pygame:step004
Author:  Dirk Ketturkat
License: Do What The Fuck You Want To Public License (WTFPL)
        See http://sam.zoy.org/wtfpl/
"""

import pygame
import os
def load_pic(name, path="data"):

   pic = pygame.image.load(os.path.join(path, name))
   if pic.get_alpha():
       return pic.convert_alpha()
   else:
       return pic.convert()
def check(x, minval=0, maxval=255):

   return min(maxval, max(minval, x))
def offset(len1, len2):
   """ For picture centering
   """
   return max(0, (len1 - len2) // 2)
class PeepDemo(object):
   def __init__(self, **args):
       pygame.init()
       self.width = args['width']
       self.height = args['height']
       self.fps = args['fps']
       self.screen = pygame.display.set_mode((self.width, self.height), pygame.DOUBLEBUF)
       self.clock = pygame.time.Clock()
       pygame.display.set_caption("Move Mouse and Scroll Mouse Wheel")

       self.pic = load_pic(args['pic'])
       self.background = pygame.Surface(self.screen.get_size()).convert()
       self.background.fill(args['backcol'])

       self.ppa_surface = pygame.Surface(self.screen.get_size(), flags=pygame.SRCALPHA)
       self.pic_offset = offset(self.width, self.pic.get_width()), offset(self.height, self.pic.get_height())

       # init stuff for circles with alpha value
       self.center = self.width // 2, self.height // 2
       self.max_radius = min(self.width, self.height)
       self.hole_count = args['holes']
       self.calc_centers(self.center, self.center, self.hole_count)
       self.calc_rad_alphas(self.max_radius, self.hole_count)

       self.rad_alphas = []
       self.centers = []

   def calc_rad_alphas(self, radius, n):
       """
       Calculate linear radius and alpha values
       """
       assert 0 < n < 256, "Invalid number of holes!"

       rad_step = radius // n
       alpha_step = 256 // n
       self.rad_alphas = [(radius - i * rad_step, 255 - i*alpha_step) for i in range(n)]

   def calc_centers(self, center, pos, holes):
       """
       Calculate center points from center (of window) to mouse position
       """

       cx, cy = center
       mx, my = pos
       vx, vy = mx - cx, my - cy

       xs = vx // holes
       ys = vy // holes
       self.centers = [(cx + xs*i, cy + ys*i) for i in range(holes)]

   def run(self):
       """
       Mainloop
       """
       mainloop = True
       while mainloop:
           self.flip()
           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   mainloop = False
               elif event.type == pygame.KEYDOWN:
                   if event.key == pygame.K_ESCAPE:
                       mainloop = False
               elif event.type == pygame.MOUSEMOTION:
                   self.calc_centers(self.center, pygame.mouse.get_pos(),
                                     self.hole_count)
               elif event.type == pygame.MOUSEBUTTONDOWN:
                   # check mouse wheel
                   if event.button in (4, 5):
                       self.hole_count = check(self.hole_count + [-1, 1][event.button-4], 2, 64)
                       self.calc_rad_alphas(self.max_radius, self.hole_count)
                       self.calc_centers(self.center, pygame.mouse.get_pos(), self.hole_count)
           self.show()
       pygame.quit()

   def show(self):
       """
       Draw all
       """

       # picture on screen
       self.screen.blit(self.pic, self.pic_offset)
       # circles on alpha surface
       for (r, a), c in zip(self.rad_alphas, self.centers):
           pygame.draw.circle(self.ppa_surface, (0, 0, 0, a), c, r)

       # alpha surface on screen
       self.screen.blit(self.ppa_surface, (0, 0))
       # erase alpha surface for new circles
       self.ppa_surface.fill((0, 0, 0))

   def flip(self):
       """
       Show drawing and erase
       """
       pygame.display.flip()
       self.screen.blit(self.background, (0, 0))
       self.clock.tick(self.fps)
opts = {'width': 800,
       'height': 600,
       'backcol': (255, 0, 0),
       'fps': 100,
       'fontsize': 18,
       'pic': 'ente.jpg',
       'holes': 7}

if __name__ == "__main__":
   PeepDemo(**opts).run()
This Gist brought to you by gist-it.view rawpygame/004_per-pixel-alphademo.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>006_time_baed_movement.py</h2>
url: http://thepythongamebook.com/en:part2:pygame:step006
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

works with python3.4 and pyhton2.7

bouncing ball. 
Movement is now time based.
Because at coding, you never know exactly how many milliseconds
will have been passed between two frames, this example use pygame's
clock function to calculate the passed time and move the ballsurface at
constantly the same speed. 

If you toggle the wild circle painting by pressing SPACE, the computer
has more to paint, framerate will drop, more time will pass between 
2 frames and movement of the ball surface will be choppy (less smooth).
However, the movent speed remain unchanged because of the time-based movement.
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division
import pygame
import random
def wildPainting():
   """draw random circles to give the cpu some work to do"""
   pygame.draw.circle(background, (random.randint(0,255),
                      random.randint(0,255), random.randint(0,255)),
                      (random.randint(0,screenrect.width),
                      random.randint(0,screenrect.height)),
                      random.randint(50,500))

#pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()
screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
screenrect = screen.get_rect()
background = pygame.Surface(screen.get_size()) #create surface for background
background.fill((255,255,255))     #fill the background white (red,green,blue)
background = background.convert()  #convert surface for faster blitting
background2 = background.copy()    # clean background to restore for later 
ballsurface = pygame.Surface((50,50))     #create a new surface (black by default)
ballsurface.set_colorkey((0,0,0))         #make black the transparent color (red,green,blue)
#pygame.draw.circle(Surface, color, pos, radius, width=0)
pygame.draw.circle(ballsurface, (0,0,255), (25,25),25) # paint blue circle
ballsurface = ballsurface.convert_alpha()        # for faster blitting. 
because transparency, use convert_alpha()
ballrect = ballsurface.get_rect()
ballx, bally = 550,240             # start position for the ball surface (topleft corner)
dx,dy  = 60, 50                    # speed of ball surface in pixel per second !
                 
screen.blit(background, (0,0))     #blit the background on screen (overwriting all)
screen.blit(ballsurface, (ballx, bally))  #blit the ball surface on the screen (on top of background)


clock = pygame.time.Clock()        #create pygame clock object
mainloop = True
FPS = 60                           # desired max. 
framerate in frames per second. 

playtime = 0
paint_big_circles = False
cleanup = True

while mainloop:
   milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
   seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
   playtime += seconds
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC

           elif event.key == pygame.K_1: 
               FPS = 5
           elif event.key == pygame.K_2:
               FPS = 20
           elif event.key == pygame.K_3:
               FPS = 30
           elif event.key == pygame.K_4:
               FPS = 40
           elif event.key == pygame.K_5:
               FPS = 50
           elif event.key == pygame.K_6:
               FPS = 60
           elif event.key == pygame.K_7:
               FPS = 70
           elif event.key == pygame.K_8:
               FPS = 80
           elif event.key == pygame.K_9:
               FPS = 90
           elif event.key == pygame.K_0:
               FPS = 1000 # absurd high value
           elif event.key == pygame.K_x:
               paint_big_circles =  not paint_big_circles # toggle
           elif event.key == pygame.K_y:
               cleanup = not cleanup # toggle boolean value
           elif event.key == pygame.K_w: # restore old background
               background.blit(background2, (0,0)) # clean the screen

               
              
           
   pygame.display.set_caption("x: paint ({}) y: cleanup ({}) ,"
                              " w: white, 0-9: limit FPS to {}"
                              " (now: {:.2f})".format(
                   paint_big_circles, cleanup, FPS,clock.get_fps()))
   if cleanup:
       screen.blit(background, (0,0))     #draw background on screen (overwriting all)
   if paint_big_circles:
      wildPainting()
   #calculate new center of ball (time-based)
   ballx += dx * seconds # float, since seconds passed since last frame is a decimal value
   bally += dy * seconds 
   # bounce ball if out of screen
   if ballx < 0:
       ballx = 0
       dx *= -1 
   elif ballx + ballrect.width > screenrect.width:
       ballx = screenrect.width - ballrect.width
       dx *= -1
   if bally < 0:
       bally = 0
       dy *= -1
   elif bally + ballrect.height > screenrect.height:
       bally = screenrect.height - ballrect.height
       dy *= -1
   # paint the ball    
   screen.blit(ballsurface, (round(ballx,0), round(bally,0 )))
   pygame.display.flip()          # flip the screen 30 times a second
print("This 'game' was played for {:.2f} seconds".format(playtime))
This Gist brought to you by gist-it.view rawpygame/006_time_based_movement.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>008_animation.py</h2>
animation & spritesheet
url: http://thepythongamebook.com/en:part2:pygame:step008
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html
spritesheet from
http://www.flyingyogi.com

using subsurface, this program gets "sprites" from a sprite sheet 
and display them, creating an animation.

works with python3.4 and pyhton2.7
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division
import pygame
import random
import os
pygame.init()
folder = "data" # replace with "." if pictures lay in the same folder as program
try: 
   spritesheet = pygame.image.load(os.path.join(folder, "char9.bmp"))
except: 
   raise(UserWarning, "i'm unable to load 'cahr9.bmp' form the folder 'data'") # error msg and exit

screen=pygame.display.set_mode((800,480)) # try out larger values and see what happens !
spritesheet.convert() # convert only works afteer display_setmode is set.
screenrect = screen.get_rect()
background = pygame.Surface((screen.get_size()))
backgroundrect = background.get_rect()
background.fill((255,0,255)) # fill white
background = background.convert()
screen.blit(background,(0,0))

lions = [] # a list for the lion images
# the spritesheet has lions, 128 x 64 pixels
sz = 128
w, h = 128, 64
# for nbr in range(1,5,1): # first line contains 4 pictures of lions
#    lions.append(spritesheet.subsurface((sz*(nbr-1),64,sz,sz)))
# for nbr in range(5,7,1): # second line contains 2 pictures of lions
#    lions.append(spritesheet.subsurface((sz*(nbr-5),262-64,sz,sz)))
for nbr in range(4): # first line contains 4 pictures of lions
  lions.append(spritesheet.subsurface((sz*nbr,64,w,h)))
for nbr in range(2): # second line contains 2 pictures of lions
  lions.append(spritesheet.subsurface((sz*nbr,198,w,h)))

print("len:",len(lions), lions[0].get_size())

for nbr in range(len(lions)):
  lions[nbr].set_colorkey((0,0,0)) # black transparent
  lions[nbr] = lions[nbr].convert_alpha()
  print("converted nbr", nbr)

for nbr in range(len(lions)):
   screen.blit(lions[nbr], (nbr*(sz+1), 0))  #blit the ball surface on the screen (on top of background)
   print("blitted nbr", nbr)

# 
clock = pygame.time.Clock()        #create pygame clock object
mainloop = True
FPS = 60                           # desired max. 
framerate in frames per second. 

playtime = 0
cycletime = 0 
#newnr = 0 # index of the first lionimage to display
#oldnr = 0 # needed to compare if image has changed
interval = .15 # how long one single images should be displayed in seconds 
picnr = 0
while mainloop:
   milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
   seconds = milliseconds / 1000.0 # seconds passed since last frame (float)
   playtime += seconds
   cycletime += seconds
   if cycletime > interval: # Note that milliseconds is a lot smaller than interval
       mypicture = lions[picnr] ## 
       #screen.blit(background.subsurface((300,300,128,66)),(300,300)) ##
       screen.blit(mypicture, (300,300)) 
       picnr += 1
       if picnr > 5:
           picnr = 0
       cycletime = 0  # reset cycletime.

   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC

   pygame.display.set_caption("[FPS]: %.2f picture: %i" % (clock.get_fps(), picnr))
   #this would repaint the whole screen (secure, but slow)
   #screen.blit(background, (0,0))     #draw background on screen (overwriting all)

   pygame.display.flip()          # flip the screen 30 times a second
print("This 'game' was played for {:.2f} seconds".format(playtime))
This Gist brought to you by gist-it.view rawpygame/008_animation.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Name:    010_sound_only_no_graphic.py
Purpose: demonstrate use of pygame for playing sound & music
URL:     http://ThePythonGameBook.com 
Author:  Horst.Jens@spielend-programmieren.at
Licence: gpl, see http://www.gnu.org/licenses/gpl.html

works with pyhton3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
import os
import sys

# if using python2, the get_input command needs to act like raw_input:
if sys.version_info[:2] <= (2, 7):
   get_input = raw_input
else:
   get_input = input # python3
       

pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()                              #initialize pygame

# look for sound & music files in subfolder 'data'
pygame.mixer.music.load(os.path.join('data', 'an-turr.ogg'))#load music
jump = pygame.mixer.Sound(os.path.join('data','jump.wav'))  #load sound
fail = pygame.mixer.Sound(os.path.join('data','fail.wav'))  #load sound

# play music non-stop
pygame.mixer.music.play(-1)                           

# game loop
gameloop = True

while gameloop:
   # indicate if music is playing
   if pygame.mixer.music.get_busy():
       print(" ... 
music is playing")
   else: 
       print(" ... 
music is not playing")
   # print menu 
   print("please press key:")
   print("[a] to play 'jump.wav' sound")
   print("[b] to play 'fail.wav' sound")
   print("[m] to toggle music on/off")
   print("[q] to quit")
   answer = get_input("press key [a] or [b] or [m] or [q], followed by [ENTER]")
   answer = answer.lower() # force lower case
   if "a" in answer:
       jump.play()
       print("playing jump.wav once")
   elif "b" in answer:
       fail.play()
       print("playing fail.wav once")
   elif "m" in answer:
       if pygame.mixer.music.get_busy():
           pygame.mixer.music.stop()
       else:
           pygame.mixer.music.play()
   elif "q" in answer:
       #break from gameloop
       gameloop = False
   else:
       print("please press either [a], [b], [m] or [q] and [ENTER]")
print("bye-bye")
pygame.quit() # clean exit 
This Gist brought to you by gist-it.view rawpygame/010_sound_only_no_graphic.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>010_sound_and_music.py</h2>
plays music and sound effects
url: http://thepythongamebook.com/en:part2:pygame:step010
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

This program plays music and 
plays a sound effect whenever the a of b  key is pressed and released
All files must be in a 'data' subfolder.
The 'data' subfolder must be in the same folder as the program.

works with python3.4 and python2.7
"""
import pygame
import os
pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()                      #initialize pygame

try:
   pygame.mixer.music.load(os.path.join('data', 'an-turr.ogg'))#load music
   jump = pygame.mixer.Sound(os.path.join('data','jump.wav'))  #load sound
   fail = pygame.mixer.Sound(os.path.join('data','fail.wav'))  #load sound
except:
   raise(UserWarning, "could not load or play soundfiles in 'data' folder :-(")

pygame.mixer.music.play(-1)                           # play music non-stop

screen=pygame.display.set_mode((640,480)) # set screensize of pygame window
background = pygame.Surface(screen.get_size())  #create empty pygame surface
background.fill((255,255,255))     #fill the background white color (red,green,blue)
background = background.convert()  #convert Surface object to make blitting faster
screen.blit(background, (0,0))     #draw the background on screen
clock = pygame.time.Clock()        #create a pygame clock object
mainloop = True                    
FPS = 30 # desired framerate in frames per second. 
try out other values !
while mainloop:
   milliseconds = clock.tick(FPS) # do not go faster than this framerate
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC
           if event.key == pygame.K_a:
               fail.play()                  # play sound effect
           if event.key == pygame.K_b:
               jump.play()                  # play sound effect
       elif event.type == pygame.MOUSEBUTTONDOWN:
           bstate = pygame.mouse.get_pressed()
           print ('bstate: ', bstate)
           if bstate[0]:
               fail.play()
               print (pygame.mouse.get_pos())
               pygame.draw.circle(screen, (255,255,0), pygame.mouse.get_pos(), 30)
   # print the framerate into the pygame window title
   pygame.display.set_caption("FPS: {:.2f} Press [a] or [b] to play sound effects".format(clock.get_fps()))
   pygame.display.flip()          # flip the screen
This Gist brought to you by gist-it.view rawpygame/010_sound_and_music.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>011-rotozoom.py</h2>
moving, rotating and zooming a pygame surface
url: http://thepythongamebook.com/en:part2:pygame:step011
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

loading the background image and snake.gif from a subfolder called 'data'
The subfolder must be inside the same folder as the program itself. 

The snake surface can be moved with the cursor keys, 
rotated with a and d key and and zoomed with w and s key

works with pyhton3.4 and python2.7
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
import os

try:
   # load from subfolder 'data'
   background = pygame.image.load(os.path.join("data","background640x480_a.jpg"))
   snake = pygame.image.load(os.path.join("data","snake.gif"))
except:
   raise(UserWarning, "Unable to find the images in the folder 'data' :-( ")
#finally:
pygame.init()
screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
background = background.convert()  # jpg can not have transparency
snake = snake.convert_alpha()      # png image has transparent color 
snake_original = snake.copy()      # store a unmodified copy of the snake surface
snakex, snakey = 250, 240            # start position of snake surface
dx, dy  = 0, 0                   # snake speed in pixel per second !
speed = 60                       # in pixel / second
angle = 0                        # current orientation of snake
zoom = 1.0                       # current zoom factor
zoomspeed = 0.01                   
turnspeed = 180                  # in Grad (360) per second
screen.blit(background, (0,0))     # blit background on screen (overwriting all)
screen.blit(snake, (snakex, snakey))  # blit the snake shape 
clock = pygame.time.Clock()        # create pygame clock object 
mainloop = True
FPS = 60                           # desired max. 
framerate in frames per second. 

while mainloop:
   milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
   seconds = milliseconds / 1000.0 # seconds passed since last frame
   for event in pygame.event.get():
       if event.type == pygame.QUIT:
           mainloop = False # pygame window closed by user
       elif event.type == pygame.KEYDOWN:
           if event.key == pygame.K_ESCAPE:
               mainloop = False # user pressed ESC
   pygame.display.set_caption("press cursor keys and w a s d - fps:"
       "%.2f zoom: %.2f angle %.2f" % (clock.get_fps(), zoom, angle))
   # only blit the part of the background where the snake was (cleanrect)
   #try:
       #if the subsurface is outside the screen pygame would raise an error
       #this can happen when using rotozoom, therfore check inside try..except
   #    dirtyrect = background.subsurface((round(snakex,0), 
   #            round(snakey,0), snake.get_width(), snake.get_height()))
   
   #    screen.blit(dirtyrect, (round(snakex,0), round(snakey,0))) 
   #except:
   #print "autch!"
   snakerect = pygame.Rect(round(snakex,0), 
               round(snakey,0), snake.get_width(), snake.get_height())
   dirty = background.subsurface(snakerect.clip(screen.get_rect()))
   dirtyrect = dirty.get_rect()
   screen.blit(dirty, (round(snakex), round(snakey)))
       
       #screen.blit(background,(0,0)) # blit the whole background (slow but secure)
       #raise UserWarning, "subsurface out of screen?"
   # move snake with cursor keys
   pressedkeys = pygame.key.get_pressed()
   dx, dy  = 0, 0   # no cursor key, no movement
   if pressedkeys[pygame.K_LEFT]:
       dx -= speed
   if pressedkeys[pygame.K_RIGHT]:
       dx += speed
   if pressedkeys[pygame.K_UP]:
       dy -= speed
   if pressedkeys[pygame.K_DOWN]:
       dy += speed
   #calculate new center of snake 
   snakex += dx * seconds # time based movement
   snakey += dy * seconds
   # rotate snake with a and d key
   turnfactor = 0  # neither a nor d, no turning
   if pressedkeys[pygame.K_a]:
       turnfactor += 1 # counter-clockwise
   if pressedkeys[pygame.K_d]:
       turnfactor -= 1 #clock-wise
   # zoom snake with w and s key
   zoomfactor = 1.0 # neither w nor s, no zooming
   if pressedkeys[pygame.K_w]:
       zoomfactor += zoomspeed
   if pressedkeys[pygame.K_s]:
       zoomfactor -= zoomspeed
   if turnfactor != 0 or zoomfactor !=1.0:
       angle += turnfactor * turnspeed * seconds # time-based turning
       zoom *= zoomfactor 
       # the surface shrinks and zooms and moves by rotating
       oldrect = snake.get_rect() # store current surface rect
       snake = pygame.transform.rotozoom(snake_original, angle, zoom)
       newrect = snake.get_rect() # store new surface rect
       # put new surface rect center on same spot as old surface rect center
       snakex += oldrect.centerx - newrect.centerx
       snakey += oldrect.centery - newrect.centery
   # paint the snake    
   screen.blit(snake, (round(snakex,0), round(snakey,0)))    
   pygame.display.flip()          # flip the screen 30 times a second                # flip the screen 30 (or FPS) times a second
This Gist brought to you by gist-it.view rawpygame/011_rotozoom.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>012_text.py</h2>
displaying and moving text
url: http://thepythongamebook.com/en:part2:pygame:step012
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

This program demonstrate how to render and blit text into a surface

works with pyhton3.4 and python2.7
"""

import pygame
import random

def flytext(msg="hello world", duration=5):
   """blinking text bouncing around the screen"""

   def newcolour():
       # any colour but black or white 
       return (random.randint(10,250), random.randint(10,250), random.randint(10,250))

   def write(msg="pygame is cool"):
       myfont = pygame.font.SysFont("None", random.randint(34,128))
       mytext = myfont.render(msg, True, newcolour())
       mytext = mytext.convert_alpha()
       return mytext
       
   pygame.init()
   x = 60
   y = 60
   dx = 5
   dy = 5

   screen = pygame.display.set_mode((640,400))
   background = pygame.Surface((screen.get_width(), screen.get_height()))
   background.fill((255,255,255)) # white
   background = background.convert()
   screen.blit(background, (0,0)) # clean whole screen
   clock = pygame.time.Clock()
   mainloop = True
   FPS = 60 # desired framerate in frames per second.
   while mainloop:
       milliseconds = clock.tick(FPS)  # milliseconds passed since last frame
       seconds = milliseconds / 1000.0 # seconds passed since last frame
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               mainloop = False # pygame window closed by user
           elif event.type == pygame.KEYDOWN:
               if event.key == pygame.K_ESCAPE:
                   mainloop = False # user pressed ESC
       textsurface = write("hello world")
       #screen.blit(background, (0,0)) # clean whole screen
       x += dx
       y += dy
       if x < 0:
          x = 0
          dx *= -1
          screen.blit(background, (0,0)) # clean whole screen
       elif x + textsurface.get_width() > screen.get_width():
           x = screen.get_width() - textsurface.get_width()
           dx *= -1
       if y < 0:
           y = 0
           dy *= -1
       elif y + textsurface.get_height() > screen.get_height():
           y = screen.get_height() - textsurface.get_height()
           dy *= -1
           
       screen.blit(textsurface, (x,y))
       pygame.display.flip()
   pygame.quit()

if __name__=="__main__":
   flytext() 
This Gist brought to you by gist-it.view rawpygame/012_text.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>013_catch_the_thief.py</h2>
a game without pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step013
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

The player(s) can control the Pygame snake (with cursor keys) and the
Tux bird (with the mouse). 
A blue police icon moves toward the middle
distance between snake and bird (indicated by a cross).
Your task is to catch the thief (red triangle) with the blue police circle.
The thief moves by random. 
You have only a short period of time. 
For each 
millisecond where the police circle touches the thief triangle, you get points.

Loading  images and sounds from a subfolder called 'data'
The subfolder must be inside the same folder as the program itself. 


works with pyhton3.4 and python2.7
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
import os
import random

# ------ a> Config.screenwidth:
       x = Config.screenwidth - sprite.get_width()/2
       dx *= -1
   if y - sprite.get_height()/2 < 0:
       y = sprite.get_height()/2
       dy *= -1
   elif y + sprite.get_height()/2 > Config.screenheight:
       y = Config.screenheight - sprite.get_height()/2
       dy *= -1
   return x,y,dx,dy
   
def randomcolour():
   """returns a random colour tuple (red,green,blue)"""
   return (random.randint(0,255), random.randint(0,255), random.randint(0,255))

def arrow(sprite, dx, dy):
   midx = sprite.get_width() /2
   midy = sprite.get_height() /2
   
   return sprite
def play_the_game():
   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   try:
       # load graphic files from subfolder 'data'
       background = pygame.image.load(os.path.join("data","wien.jpg"))
       snake = pygame.image.load(os.path.join("data","snake.gif"))
       bird = pygame.image.load(os.path.join("data","babytux.png"))
       # load sound files 
       over = pygame.mixer.Sound(os.path.join('data','time_is_up_game_over.ogg'))
       spring = pygame.mixer.Sound(os.path.join('data', 'spring.wav'))

   except:
       raise(UserWarning, "Unable to find or play the files in the folder 'data' :-( ")
   # ----------- start ---------

   screen=pygame.display.set_mode((1024,600)) # try out larger values and see what happens !
   Config.screen = screen # copy screen into the Config> Config.birdx:
               Config.birddx += 1
           if mousey < Config.birdy:
               Config.birddy -= 1
           elif mousey > Config.birdy:
               Config.birddy += 1
           if pygame.mouse.get_pressed()[0] == True:
               Config.birddx = 0 # stop movement by mouseclick (left button)
               Config.birddy = 0
           # ---- keyboard ------
           # cursor keys or wasd
           pressedkeys = pygame.key.get_pressed() # all keys that are pressed now
           if pressedkeys[pygame.K_LEFT] or pressedkeys[pygame.K_a]:
               Config.snakedx -= 1
           if pressedkeys[pygame.K_RIGHT] or pressedkeys[pygame.K_d]:
               Config.snakedx += 1
           if pressedkeys[pygame.K_UP] or pressedkeys[pygame.K_w]:
               Config.snakedy -= 1
           if pressedkeys[pygame.K_DOWN] or pressedkeys[pygame.K_s]:
               Config.snakedy += 1
           if pressedkeys[pygame.K_RETURN] or pressedkeys[pygame.K_LCTRL]:
               Config.snakedx = 0 # stop movement by pressing the 's' key
               Config.snakedy = 0
           # ------------ compute movement ----------------
           Config.crossx = min(Config.birdx,Config.snakex) + ( max(Config.birdx, Config.snakex) -  # cross is in the middle of bird and snake 
                    min(Config.birdx,Config.snakex)) / 2.0 -cross.get_width()/2
           Config.crossy = min(Config.birdy,Config.snakey) + ( max(Config.birdy, Config.snakey) - 
                    min(Config.birdy,Config.snakey)) / 2.0 - cross.get_height()/2
           if Config.crossx < Config.policex:
               Config.policedx -= 1        # police moves toward cross
           elif Config.crossx > Config.policex:
               Config.policedx += 1
           if Config.crossy > Config.policey:
               Config.policedy += 1
           elif Config.crossy < Config.policey:
               Config.policedy -= 1
           Config.thiefdx += random.randint( -Config.erratic,Config.erratic )  # thief is erratic
           Config.thiefdy += random.randint( -Config.erratic,Config.erratic )
           Config.thiefdx = max(Config.thiefdx, -Config.thiefmaxspeed)         # limit speed of thief
           Config.thiefdx = min(Config.thiefdx, Config.thiefmaxspeed)
           Config.thiefdy = max(Config.thiefdy, -Config.thiefmaxspeed)
           Config.thiefdy = min(Config.thiefdy, Config.thiefmaxspeed)
           # ---- friction... 
sprites get slower ----
           Config.policedx *= 0.995
           Config.policedy *= 0.995
           Config.snakedx *= 0.995
           Config.snakedy *= 0.995
           Config.birddx *= 0.995
           Config.birddy *= 0.995
           # --------- new position -----------
           Config.policex += Config.policedx * seconds 
           Config.policey += Config.policedy * seconds
           Config.birdx += Config.birddx * seconds
           Config.birdy += Config.birddy * seconds
           Config.snakex += Config.snakedx * seconds
           Config.snakey += Config.snakedy * seconds
           Config.thiefx += Config.thiefdx * seconds
           Config.thiefy += Config.thiefdy * seconds
           # ----------- bounce ----------
           Config.policex, Config.policey, Config.policedx, Config.policedy = bounce(police, Config.policex, Config.policey, Config.policedx, Config.policedy)
           Config.birdx, Config.birdy, Config.birddx, Config.birddy = bounce(bird, Config.birdx, Config.birdy, Config.birddx, Config.birddy)
           Config.snakex, Config.snakey, Config.snakedx, Config.snakedy = bounce(snake, Config.snakex, Config.snakey, Config.snakedx, Config.snakedy)
           Config.thiefx, Config.thiefy, Config.thiefdx, Config.thiefdy = bounce(thief, Config.thiefx, Config.thiefy, Config.thiefdx, Config.thiefdy)
           # --- police got thief ? collision detection -----
           distx =  max(Config.policex + police.get_width()/2 , Config.thiefx + 
                    thief.get_width()/2) - min(Config.policex + 
                    police.get_width()/2, Config.thiefx + thief.get_width()/2)
           disty =  max(Config.policey + police.get_height()/2 , Config.thiefy + 
                    thief.get_height()/2) - min(Config.policey + police.get_width()/2,
                    Config.thiefy + thief.get_width()/2)
           catch_in_last_frame = catch_in_this_frame # save old catch info
           catch_in_this_frame = False
           if (distx < police.get_width() /2) and (disty < police.get_height()/2):
               catch_in_this_frame = True
               points += seconds
               screen.fill(randomcolour()) 
               if not pygame.mixer.get_busy():
                   spring.play() # only play this sound if mixer is silent at the moment
           else:   # no catch this time
               if catch_in_last_frame:
                   screen.blit(background, (0,0)) # restore background
           # ---------- blit ----------------
           draw(bird, Config.birdx, Config.birdy)
           draw(snake, Config.snakex, Config.snakey)
           pygame.draw.line(screen, randomcolour(), (Config.snakex,Config.snakey), (Config.birdx, Config.birdy), 1)
           pygame.draw.line(screen, randomcolour(), (Config.crossx,Config.crossy), (Config.policex, Config.policey) ,1)
           draw(police, Config.policex, Config.policey)
           draw(cross, Config.crossx, Config.crossy)
           draw(thief, Config.thiefx, Config.thiefy)
       pygame.display.flip()          # flip the screen FPS times a second    
   pygame.quit()
# check if the program is imported. 
if not, start it directly
if __name__ == "__main__":
   play_the_game()
This Gist brought to you by gist-it.view rawpygame/013_catch_the_thief.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>014-sprites.py</h2>
real pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step014
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

Real pygame Sprites moving around. 
Create more sprites with mouse click.
Shows collision detection
loading images from a subfolder called 'data'
all images files must be in the subfolder 'data'. 
The subfolder must be inside the
same folder as the program itself. 


works with pyhton3.4 and python2.7
"""
import pygame
import os
import random
import math

pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
pygame.init()
#screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
screen=pygame.display.set_mode((1920,1080), pygame.FULLSCREEN)
winstyle = 0  # |FULLSCREEN # Set the display mode
BIRDSPEED = 50.0

def write(msg="pygame is cool"):
   myfont = pygame.font.SysFont("None", 32)
   mytext = myfont.render(msg, True, (0,0,0))
   mytext = mytext.convert_alpha()
   return mytext

class BirdCatcher(pygame.sprite.Sprite):
   def __init__(self):
       pygame.sprite.Sprite.__init__(self, self.groups)
       self.image = pygame.Surface((100,100)) # created on the fly
       self.image.set_colorkey((0,0,0)) # black transparent
       pygame.draw.circle(self.image, (255,0,0), (50,50), 50, 2) # red circle
       self.image = self.image.convert_alpha()
       self.rect = self.image.get_rect()
       self.radius = 50 # for collide check
   def update(self, seconds):
       # no need for seconds but the other sprites need it
       self.rect.center = pygame.mouse.get_pos()
class Bird(pygame.sprite.Sprite):
   image=[]  # list of all images
   # not necessary:
   birds = {} # a dictionary of all Birds, each Bird has its own number
   number = 0  
   def __init__(self, startpos=(50,50), area=screen.get_rect(), speed=None):
       pygame.sprite.Sprite.__init__(self, self.groups)
       self.pos = [0.0,0.0]
       self.pos[0] = startpos[0]*1.0 # float
       self.pos[1] = startpos[1]*1.0 # float
       self.image = Bird.image[0]
       self.rect = self.image.get_rect()
       self.area = area # where the sprite is allowed to move
       self.newspeed(speed)
       self.catched = False
       #--- not necessary:
       self.number = Bird.number # get my personal Birdnumber
       Bird.number+= 1           # increase the number for next Bird
       Bird.birds[self.number] = self # store myself into the Bird dictionary
       #print "my number %i Bird number %i " % (self.number, Bird.number)
   def newspeed(self, speed=None):
       # new birdspeed, but not 0
       if speed == None:
           speedrandom = random.choice([-1,1]) # flip a coin
           self.dx = random.random() * BIRDSPEED * speedrandom + speedrandom 
           self.dy = random.random() * BIRDSPEED * speedrandom + speedrandom 
       else:
           self.dx, self.dy = speed

   def update(self, seconds):
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       # -- check if out of screen
       if not self.area.contains(self.rect):
           self.image = Bird.image[1] # crash into wall
           # --- compare self.rect and area.rect
           if self.pos[0] + self.rect.width/2 > self.area.right:
               self.pos[0] = self.area.right - self.rect.width/2
           if self.pos[0] - self.rect.width/2 < self.area.left:
               self.pos[0] = self.area.left + self.rect.width/2
           if self.pos[1] + self.rect.height/2 > self.area.bottom:
               self.pos[1] = self.area.bottom - self.rect.height/2
           if self.pos[1] - self.rect.height/2 < self.area.top:
               self.pos[1] = self.area.top + self.rect.height/2
           self.newspeed() # calculate a new direction
       else:
           if self.catched:
               self.image = Bird.image[2] # blue rectangle
           else:
               self.image = Bird.image[0] # normal bird image
       #--- calculate new position on screen -----
           
       self.rect.centerx = round(self.pos[0],0)
       self.rect.centery = round(self.pos[1],0)
   
background = pygame.Surface((screen.get_width(), screen.get_height()))
background.fill((255,255,255))     # fill white
background.blit(write("Press left mouse button for more sprites. 
Press ESC to quit"),(5,10))
background = background.convert()  # jpg can not have transparency
screen.blit(background, (0,0))     # blit background on screen (overwriting all)
clock = pygame.time.Clock()        # create pygame clock object 
mainloop = True
FPS = 60                           # desired max. 
framerate in frames per second. 


# load images into>015_more_sprites.py</h2>
pygame sprites with hitbars and exploding fragments
url: http://thepythongamebook.com/en:part2:pygame:step015
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

pygame sprites moving araound and exploding into little fragments 
(on mouseclick). 
Effect of gravity on the fragments can be toggled.
Differnt coding style and its outcome on performance (framerate)
can be toggled and is displayed by green bars. 
a long bar indicates
a slow performance.

works with pyhton3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

def game():
       
   import pygame
   import os
   import random
   import math

   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   screen=pygame.display.set_mode((1920, 1080), pygame.FULLSCREEN) # try out larger values and see what happens !
   #winstyle = 0  # |FULLSCREEN # Set the display mode
   BIRDSPEEDMAX = 200
   BIRDSPEEDMIN = 10
   FRICTION =.999
   HITPOINTS = 100.0 
   FORCE_OF_GRAVITY = 9.81 # in pixel per second² .See http://en.wikipedia.org/wiki/Gravitational_acceleration
   print(pygame.ver)
   def write(msg="pygame is cool"):
       """write text into pygame surfaces"""
       myfont = pygame.font.SysFont("None", 32)
       mytext = myfont.render(msg, True, (0,0,0))
       mytext = mytext.convert_alpha()
       return mytext
   
   #define sprite groups
   birdgroup = pygame.sprite.LayeredUpdates()   
   bargroup = pygame.sprite.Group()
   stuffgroup = pygame.sprite.Group()
   fragmentgroup = pygame.sprite.Group()
   # LayeredUpdates instead of group to draw in correct order
   allgroup = pygame.sprite.LayeredUpdates() # more sophisticated than simple group

  > self.lifetime:
               self.kill() 
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           if Fragment.gravity:
               self.dy += FORCE_OF_GRAVITY # gravity suck fragments down
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
           
  > BIRDSPEEDMIN and abs(self.dy) > BIRDSPEEDMIN:
               self.dx *= FRICTION
               self.dy *= FRICTION
           # spped limit
           if abs(self.dx) > BIRDSPEEDMAX:
               self.dx = BIRDSPEEDMAX * self.dx / self.dx
           if abs(self.dy) > BIRDSPEEDMAX:
               self.dy = BIRDSPEEDMAX * self.dy / self.dy
           # new position
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           # -- check if Bird out of screen
           if not self.area.contains(self.rect):
               self.crashing = True # change colour later
               # --- compare self.rect and area.rect
               if self.pos[0] + self.rect.width/2 > self.area.right:
                   self.pos[0] = self.area.right - self.rect.width/2
               if self.pos[0] - self.rect.width/2 < self.area.left:
                   self.pos[0] = self.area.left + self.rect.width/2
               if self.pos[1] + self.rect.height/2 > self.area.bottom:
                   self.pos[1] = self.area.bottom - self.rect.height/2
               if self.pos[1] - self.rect.height/2 < self.area.top:
                   self.pos[1] = self.area.top + self.rect.height/2
               self.newspeed() # calculate a new direction
           #--- calculate actual image: crasing, catched, both, nothing ?
           self.image = Bird.image[self.crashing + self.catched*2]
           #--- calculate new position on screen -----
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
           #--- loose hitpoins
           if self.crashing:
               self.hitpoints -=1
           #--- check if still alive
           if self.hitpoints <= 0:
               self.kill()
   
   #---------------  no> millimax:
           millimax = milliseconds
       seconds = milliseconds / 1000.0 # seconds passed since last frame
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               mainloop = False # pygame window closed by user

           elif event.type == pygame.MOUSEBUTTONUP:
               x, y = pygame.mouse.get_pos()
               angle = random.random()*2*3.1415
               Bird( pygame.mouse.get_pos(), speed=(500*math.cos(angle),500*math.sin(angle)) )
           elif event.type == pygame.MOUSEBUTTONDOWN:
               x, y = pygame.mouse.get_pos()
               angle = random.random()*2*3.1415
               Bird( pygame.mouse.get_pos(), speed=(500*math.cos(angle),500*math.sin(angle)) )

           elif event.type == pygame.KEYDOWN:
               if event.key == pygame.K_ESCAPE:
                   mainloop = False # user pressed ESC
               elif event.key == pygame.K_g:
                   Fragment.gravity = not Fragment.gravity # toggle gravity>016_layers.py</h2>
pygame sprites with different layers and parallax scrolling
url: http://thepythongamebook.com/en:part2:pygame:step016
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html
change the sprite layer by clicking with left or right mouse button
the birdsprites will appear before or behind the blocks

point on a sprite and pres "p" to print out more information about that sprite
part of www.pythongamebook.com by Horst JENS
works with python3.4 and python2.7
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

def game():
       
   import pygame
   import os
   import random
   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
   #winstyle = 0  # |FULLSCREEN # Set the display mode
   print("pygame version", pygame.ver)

   BIRDSPEEDMAX = 200
   BIRDSPEEDMIN = 10
   FRICTION =.999
   FORCE_OF_GRAVITY = 9.81
   
   
   def write(msg="pygame is cool"):
       """write text into pygame surfaces"""
       myfont = pygame.font.SysFont("None", 32)
       mytext = myfont.render(msg, True, (0,0,0))
       mytext = mytext.convert_alpha()
       return mytext
   
  > self.area.bottom:
                   self.pos[1] = self.area.bottom
                   self.newspeed() # calculate a new direction
           self.pos[0] += self.dx * time
           self.pos[1] += self.dy * time
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
           
  > (self.waittime) and self.waiting:
               self.newspeed()
               self.waiting = False
               self.rect.centerx = round(self.pos[0],0)
               self.rect.centery = round(self.pos[1],0)
           if self.waiting:
               self.rect.center = (-100,-100)
           else:
               # speedcheck
               # friction make birds slower
               if abs(self.dx) > BIRDSPEEDMIN and abs(self.dy) > BIRDSPEEDMIN:
                   self.dx *= FRICTION
                   self.dy *= FRICTION
               # spped limit
               if abs(self.dx) > BIRDSPEEDMAX:
                   self.dx = BIRDSPEEDMAX * self.dx / self.dx
               if abs(self.dy) > BIRDSPEEDMAX:
                   self.dy = BIRDSPEEDMAX * self.dy / self.dy
               # movement
               self.pos[0] += self.dx * seconds
               self.pos[1] += self.dy * seconds
               # -- check if Bird out of screen
               if not self.area.contains(self.rect):
                   self.crashing = True # change colour later
                   # --- compare self.rect and area.rect
                   if self.pos[0] + self.rect.width/2 > self.area.right:
                       self.pos[0] = self.area.right - self.rect.width/2
                   if self.pos[0] - self.rect.width/2 < self.area.left:
                       self.pos[0] = self.area.left + self.rect.width/2
                   if self.pos[1] + self.rect.height/2 > self.area.bottom:
                       self.pos[1] = self.area.bottom - self.rect.height/2
                   if self.pos[1] - self.rect.height/2 < self.area.top:
                       self.pos[1] = self.area.top + self.rect.height/2
                   self.newspeed() # calculate a new direction
               #--- calculate actual image: crasing, catched, both, nothing ?
               self.image = Bird.image[self.crashing + self.catched*2]
               #--- calculate new position on screen -----
               self.rect.centerx = round(self.pos[0],0)
               self.rect.centery = round(self.pos[1],0)
               #--- loose hitpoins
               if self.crashing:
                   self.hitpoints -=1
               #--- check if still alive
               if self.hitpoints <= 0:
                   self.kill()
           
  > self.lifetime:
               self.kill() 
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           if Fragment.gravity and not self.bluefrag:
               self.dy += FORCE_OF_GRAVITY # gravity suck fragments down
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   
       
   background = pygame.Surface((screen.get_width(), screen.get_height()))
   background.fill((255,255,255))     # fill white
   background.blit(write("press left mouse button to increase Bird's layer"),(50,40))
   background.blit(write("press right mouse button to decrease Bird's layer."),(50,65))
   background.blit(write("layer of mountains are: -1 (blue), -2 (pink), -3 (red)"),(50,90))
   background.blit(write("Press ESC to quit, p to print info at mousepos"), (50,115))
   # secret keys: g (gravity), p (print layers)
   
   background = background.convert()  # jpg can not have transparency
   screen.blit(background, (0,0))     # blit background on screen (overwriting all)

   #define sprite groups. 
Do this before creating sprites 
   blockgroup = pygame.sprite.LayeredUpdates()
   birdgroup = pygame.sprite.Group() 
   textgroup = pygame.sprite.Group()
   bargroup = pygame.sprite.Group()
   stuffgroup = pygame.sprite.Group()
   mountaingroup = pygame.sprite.Group()
   # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
   allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 

   
   try: # load images into> -4:
                   birdlayer -= 1
                   cooldowntime = .5
                   cry.play()
                   for bird in birdgroup:
                       allgroup.change_layer(bird, birdlayer) # allgroup draws the sprite !
                   for bar in bargroup:
                       allgroup.change_layer(bar, birdlayer) # allgroup draws the sprite 
       else:
           cooldowntime -= seconds # to avoid speedclicking

       pygame.display.set_caption("fps: %.2f birds: %i grav: %s" % (clock.get_fps(), len(birdgroup), Fragment.gravity))
       

       birdtext.newmsg("current Bird _layer = %i" % birdlayer) # update text for birdlayer
   
       # ------ collision detection
       for bird in birdgroup:
           bird.cleanstatus() 
           
       #pygame.sprite.spritecollide(sprite, group, dokill, collided = None): return Sprite_list
       crashgroup = pygame.sprite.spritecollide(hunter, birdgroup, False, pygame.sprite.collide_circle)
       # pygame.sprite.collide_circle works only if one sprite has self.radius
       # you can do without that argument collided and only the self.rects will be checked
       for crashbird in crashgroup:
           crashbird.catched = True # will get a blue border from Bird.update()
       
       for bird in birdgroup:  # test if a bird collides with another bird
           # check the Bird.number to make sure the bird is not crashing with himself
           crashgroup = pygame.sprite.spritecollide(bird, birdgroup, False )
           for crashbird in crashgroup:
               if crashbird.number != bird.number: #different number means different birds
                   bird.crashing = True
                   if not bird.waiting:
                       bird.dx -= crashbird.pos[0] - bird.pos[0]
                       bird.dy -= crashbird.pos[1] - bird.pos[1]
       
       # create 10 new Birds if fewer than 11 birds alive
       if len(birdgroup) < 10:
           for _ in range(random.randint(1,5)):
               Bird(birdlayer)
                   
       # ----------- clear, draw , update, flip -----------------  
       allgroup.clear(screen, background)
       allgroup.update(seconds)
       allgroup.draw(screen)           
       pygame.display.flip()         

if __name__ == "__main__":
   game()
else:
   print("i was imported by", __name__)
This Gist brought to you by gist-it.view rawpygame/016_layers.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>017_turning_and_physic.py</h2>
pygame sprites primitive physic (elastic collision)
url: http://thepythongamebook.com/en:part2:pygame:step017
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html

move the big bird around with the keys w,a,s,d  and q and e
fire with space, toggle gravity with g

works with pyhton3.4 and python2.7
"""
#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

def game(folder = "data"):
   import pygame
   import os
   import random
   import math 
   #------ starting pygame -------------
   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
   #winstyle = 0  # |FULLSCREEN # Set the display mode
   print("pygame version", pygame.ver)
   # ------- game constants ----------------------
   BIRDSPEEDMAX = 200
   FRAGMENTMAXSPEED = 200
   FRICTION =.991  # between 1 and 0. 
1 means no friction at all (deep space)
   FORCE_OF_GRAVITY = 2.81 # pixel per second square earth: 9.81 m/s²
   GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
   # ----------- functions -----------
   def write(msg="pygame is cool", color=(0,0,0)):
       """write text into pygame surfaces"""
       myfont = pygame.font.SysFont("None", 32)
       mytext = myfont.render(msg, True, color)
       mytext = mytext.convert_alpha()
       return mytext
   def getclassname(class_instance):
       """this function extract the>"
       parts = text.split(".") # like ["<class '__main__","XWing'>"]
       return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
   
   def elastic_collision(sprite1, sprite2):
       """elasitc collision between 2 sprites (calculated as disc's).
          The function alters the dx and dy movement vectors of both sprites.
          The sprites need the property .mass, .radius, .pos[0], .pos[1], .dx, dy
          pos[0] is the x postion, pos[1] the y position"""
       # here we do some physics: the elastic
       # collision
       #
       # first we get the direction of the push.
       # Let's assume that the sprites are disk
       # shaped, so the direction of the force is
       # the direction of the distance.
       dirx = sprite1.pos[0] - sprite2.pos[0]
       diry = sprite1.pos[1] - sprite2.pos[1]
       #
       # the velocity of the centre of mass
       sumofmasses = sprite1.mass + sprite2.mass
       sx = (sprite1.dx * sprite1.mass + sprite2.dx * sprite2.mass) / sumofmasses
       sy = (sprite1.dy * sprite1.mass + sprite2.dy * sprite2.mass) / sumofmasses
       # if we sutract the velocity of the centre
       # of mass from the velocity of the sprite,
       # we get it's velocity relative to the
       # centre of mass. 
And relative to the
       # centre of mass, it looks just like the
       # sprite is hitting a mirror.
       #
       bdxs = sprite2.dx - sx
       bdys = sprite2.dy - sy
       cbdxs = sprite1.dx - sx
       cbdys = sprite1.dy - sy
       # (dirx,diry) is perpendicular to the mirror
       # surface. 
We use the dot product to
       # project to that direction.
       distancesquare = dirx * dirx + diry * diry
       if distancesquare == 0:
           # no distance? this should not happen,
           # but just in case, we choose a random
           # direction
           dirx = random.randint(0,11) - 5.5
           diry = random.randint(0,11) - 5.5
           distancesquare = dirx * dirx + diry * diry
       dp = (bdxs * dirx + bdys * diry) # scalar product
       dp /= distancesquare # divide by distance * distance.
       cdp = (cbdxs * dirx + cbdys * diry)
       cdp /= distancesquare
       # We are done. 
(dirx * dp, diry * dp) is
       # the projection of the velocity
       # perpendicular to the virtual mirror
       # surface. 
Subtract it twice to get the
       # new direction.
       #
       # Only collide if the sprites are moving
       # towards each other: dp > 0
       if dp > 0:
           sprite2.dx -= 2 * dirx * dp 
           sprite2.dy -= 2 * diry * dp
           sprite1.dx -= 2 * dirx * cdp 
           sprite1.dy -= 2 * diry * cdp
   # -----------> BIRDSPEEDMAX:
           #   self.dx = BIRDSPEEDMAX * (self.dx/abs(self.dx)) # dx/abs(dx) is 1 or -1
           #if abs(self.dy) > BIRDSPEEDMAX:
           #   self.dy = BIRDSPEEDMAX * (self.dy/abs(self.dy))
           if abs(self.dx) > 0 : 
               self.dx *= FRICTION  # make the Sprite slower over time
           if abs(self.dy) > 0 :
               self.dy *= FRICTION

       def areacheck(self):
           if not self.area.contains(self.rect):
               self.crashing = True # change colour later
               # --- compare self.rect and area.rect
               if self.pos[0] + self.rect.width/2 > self.area.right:
                   self.pos[0] = self.area.right - self.rect.width/2
                   self.dx *= -0.5 # bouncing off but loosing speed
               if self.pos[0] - self.rect.width/2 < self.area.left:
                   self.pos[0] = self.area.left + self.rect.width/2
                   self.dx *= -0.5 # bouncing off the side but loosing speed
               if self.pos[1] + self.rect.height/2 > self.area.bottom:
                   self.pos[1] = self.area.bottom - self.rect.height/2
                   #self.dy *= -1 # bouncing off the ground
                   #if reaching the bottom, the birds get a boost and fly upward to the sky
                   #at the bottom the bird "refuel" a random amount of "fuel" (the boostime)
                   self.dy = 0 # break at the bottom
                   self.dx *= 0.3 # x speed is reduced at the ground
                   self.boosttime = self.boostmin + random.random()* (self.boostmax - self.boostmin)
               if self.pos[1] - self.rect.height/2 < self.area.top:
                   self.pos[1] = self.area.top + self.rect.height/2
                   self.dy = 0 # stop when reaching the sky
                   #self.dy *= -1 
                   self.hitpoints -= 1 # reaching the sky cost 1 hitpoint
       def update(self, seconds):
           #---make Bird only visible after waiting time
           self.lifetime += seconds
           if self.lifetime > (self.waittime):
               self.waiting = False
           if self.waiting:
               self.rect.center = (-100,-100)
           else: # the waiting time (Blue Fragments) is over
               if self.boosttime > 0:   # boost flying upwards ?
                   self.boosttime -= seconds
                   self.dy -= self.boostspeed # upward is negative y !
                   self.ddx = -math.sin(self.angle*GRAD) 
                   self.ddy = -math.cos(self.angle*GRAD) 
                   Smoke(self.rect.center, -self.ddx , -self.ddy )
               self.speedcheck()    # ------------- movement
               self.pos[0] += self.dx * seconds
               self.pos[1] += self.dy * seconds
               self.areacheck() # ------- check if Bird out of screen
               #--- calculate actual image: crasing, bigbird, both, nothing ?
               self.image = Bird.image[self.crashing+self.big] # 0 for not crashing, 1 for crashing
               self.image0 = Bird.image[self.crashing+self.big] # 0 for not crashing, 1 for crashing
               #--------- rotate into direction of movement ------------
               self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
               self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
               #--- calculate new position on screen -----
               self.rect.centerx = round(self.pos[0],0)
               self.rect.centery = round(self.pos[1],0)
               if self.hitpoints <= 0:
                   self.kill()
   
  > important for Bird.image
           Bird.__init__(self) # create a "little" Bird but do more than that
           self.hitpoints = float(100)
           self.hitpointsfull = float(100)
           self.image = Bird.image[2] # big bird image
           self.pos = [screen.get_width()/2, screen.get_height()/2]
           self.rect = self.image.get_rect()
           self.angle = 0
           self.speed = 20.0 # base movement speed factor
           self.rotatespeed = 1.0 # rotating speed
           self.frags = 100
           Lifebar(self)
           self.cooldowntime = 0.08 #seconds
           self.cooldown = 0.0
           self.damage = 5 # how many damage one bullet inflict
           self.shots = 0
           self.radius = self.image.get_width() / 2.0
           self.mass = 400.0
       
       def kill(self):
           bombsound.play()
           Bird.kill(self)
           
       def update(self, time):
           """BigBird has its own update method, overwriting the 
              update method from the Bird> (self.waittime):
               self.waiting = False
           if self.waiting:
               self.rect.center = (-100,-100)
           else:
               #--- calculate actual image: crasing, bigbird, both, nothing ?
               self.image = Bird.image[self.crashing+self.big] # 0 for not crashing, 2 for big
               pressedkeys = pygame.key.get_pressed()
               self.ddx = 0.0
               self.ddy = 0.0
               if pressedkeys[pygame.K_w]: # forward
                        self.ddx = -math.sin(self.angle*GRAD) 
                        self.ddy = -math.cos(self.angle*GRAD) 
                        Smoke(self.rect.center, -self.ddx , -self.ddy )
               if pressedkeys[pygame.K_s]: # backward
                        self.ddx = +math.sin(self.angle*GRAD) 
                        self.ddy = +math.cos(self.angle*GRAD) 
                        Smoke(self.rect.center, -self.ddx, -self.ddy )
               if pressedkeys[pygame.K_e]: # right side
                        self.ddx = +math.cos(self.angle*GRAD)
                        self.ddy = -math.sin(self.angle*GRAD)
                        Smoke(self.rect.center, -self.ddx , -self.ddy )
               if pressedkeys[pygame.K_q]: # left side
                        self.ddx = -math.cos(self.angle*GRAD) 
                        self.ddy = +math.sin(self.angle*GRAD) 
                        Smoke(self.rect.center, -self.ddx , -self.ddy )
               # ------------shoot-----------------
               if self.cooldown > 0:
                   self.cooldown -= time 
               else:
                   if pressedkeys[pygame.K_SPACE]: # shoot forward
                       self.ddx = +math.sin(self.angle*GRAD)#recoil
                       self.ddy = +math.cos(self.angle*GRAD)
                       lasersound.play() # play sound
                       self.shots += 1
                       Bullet(self, -math.sin(self.angle*GRAD) ,
                              -math.cos(self.angle*GRAD) )
                   self.cooldown = self.cooldowntime
               # ------------move------------------
               if not self.waiting:
                   self.dx += self.ddx * self.speed
                   self.dy += self.ddy * self.speed
               #self.speedcheck()   # friction, maxspeed             
               self.pos[0] += self.dx * seconds
               self.pos[1] += self.dy * seconds
               # -- check if Bird out of screen
               self.areacheck()
               # ------------- rotate ------------------
               if pressedkeys[pygame.K_a]: # left turn , counterclockwise
                   self.angle += self.rotatespeed
               if pressedkeys[pygame.K_d]: # right turn, clockwise
                   self.angle -= self.rotatespeed
               self.oldcenter = self.rect.center
               self.image = pygame.transform.rotate(self.image, self.angle)
               self.rect = self.image.get_rect()
               self.rect.center = self.oldcenter
               #--- calculate new position on screen -----
               self.rect.centerx = round(self.pos[0],0)
               self.rect.centery = round(self.pos[1],0)
               if self.hitpoints <= 0: # ----- alive---- 
                   self.kill()
           
  > self.lifetime:
               self.kill() 
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   
  > 0:
           quota = (float(hits)/player.shots )* 100
       pygame.display.set_caption("fps: %.2f gravity: %s hits:%i shots:%i quota:%.2f%%"  % (clock.get_fps(), 
                                    gravity, hits, player.shots, quota))
       # ------ collision detection
       for bird in birdgroup:  # test if a bird collides with another bird
           bird.crashing = False # make bird NOT blue
           # check the Bird.number to make sure the bird is not crashing with himself
           if not bird.waiting: # do not check birds outside the screen
               crashgroup = pygame.sprite.spritecollide(bird, birdgroup, False )
               for crashbird in crashgroup:  # test bird with other bird collision
                   if crashbird.number > bird.number: #avoid checking twice
                       bird.crashing = True # make bird blue
                       crashbird.crashing = True # make other bird blue
                       if not (bird.waiting or crashbird.waiting):
                           elastic_collision(crashbird, bird) # change dx and dy of both birds
                                           
               crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False)
               for ball in crashgroup:  # test for collision with bullet
                   if ball.boss.number != bird.number:
                       hitsound.play()
                       hits +=1
                       bird.hitpoints -= ball.boss.damage
                       factor =  (ball.mass / bird.mass)
                       bird.dx += ball.dx * factor
                       bird.dy += ball.dy * factor
                       ball.kill()
                       
               crashgroup = pygame.sprite.spritecollide(bird, fragmentgroup, False)
               for frag in crashgroup: # test for red fragments
                   bird.hitpoints -=1
                   factor =  frag.mass / bird.mass
                   bird.dx += frag.dx * factor
                   bird.dy += frag.dy * factor
                   frag.kill()
                   
       if gravity: # ---- gravity check ---
           for thing in gravitygroup:
               thing.dy += FORCE_OF_GRAVITY # gravity suck down all kind of things
                   
       if len(birdgroup) < amount: # create enough SmallBirds
           for _ in range(random.randint(1,3)):
               SmallBird()
       
       # ------game Over ? -------------
       if (player.hitpoints < 1 or playtime > gametime) and not gameOver:
           gameOver = True # do those things once when the game ends
           screentext.newmsg("Game Over. 
hits/shots: %i/%i quota: %.2f%%" % (hits, player.shots, quota), (255,0,0))
           player.hitpoints = 0 # kill the player into a big explosion
       if gameOver: # overtime to watch score, explosion etc
           overtime -= seconds
           if overtime < 0:
               mainloop = False
       else: # not yet gameOver
           screentext.newmsg("Time left: %.2f" % (gametime - playtime))
       
       # ----------- clear, draw , update, flip -----------------  
       allgroup.clear(screen, background)
       allgroup.update(seconds)
       allgroup.draw(screen)           
       pygame.display.flip()         

if __name__ == "__main__":
   game()
This Gist brought to you by gist-it.view rawpygame/017_turning_and_physic.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>018_pefect_collision_detection.py</h2>
pixel perfect collision detection for pygame sprites
url: http://thepythongamebook.com/en:part2:pygame:step018
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html

this code demonstrate the difference between
colliderect, collidecircle and collidemask

move the small babytux around with the keys w,a,s,d  and q and e
fire with space, toggle gravity with g
toggle collision detection with c
Shoot on the giant monsters and watch the yellow impact "wounds"

works with python3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

def game(folder = "data"):
   import pygame
   import os
   import random
   import math 
   #------ starting pygame -------------
   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   screen=pygame.display.set_mode((640,480)) # try out larger values and see what happens !
   #winstyle = 0  # |FULLSCREEN # Set the display mode
   print("pygame version", pygame.ver )
   # ------- game constants ----------------------
   #BIRDSPEEDMIN = 10
   FRAGMENTMAXSPEED = 200
   FRICTION =.991  # between 1 and 0. 
1 means no friction at all (deep space)
   FORCE_OF_GRAVITY = 2.81 # pixel per second square. 
Earth: 9.81 m/s²
   GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
   # ----------- functions -----------
   def write(msg="pygame is cool", color=(0,0,0)):
       """write text into pygame surfaces"""
       myfont = pygame.font.SysFont("None", 32)
       mytext = myfont.render(msg, True, color)
       mytext = mytext.convert_alpha()
       return mytext
   def getclassname(class_instance):
       """this function extract the>"
       parts = text.split(".") # like ["<class '__main__","XWing'>"]
       return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
   # -----------> BIRDSPEEDMAX:
           #   self.dx = BIRDSPEEDMAX * (self.dx/abs(self.dx)) # dx/abs(dx) is 1 or -1
           #if abs(self.dy) > BIRDSPEEDMAX:
           #   self.dy = BIRDSPEEDMAX * (self.dy/abs(self.dy))
           if abs(self.dx) > 0 : 
               self.dx *= FRICTION  # make the Sprite slower over time
           if abs(self.dy) > 0 :
               self.dy *= FRICTION

       def areacheck(self):
           if not self.area.contains(self.rect):
               #self.crashing = True # change colour later
               # --- compare self.rect and area.rect
               if self.pos[0] + self.rect.width/2 > self.area.right:
                   self.pos[0] = self.area.right - self.rect.width/2
                   self.dx *= -0.5 # bouncing off but loosing speed
               if self.pos[0] - self.rect.width/2 < self.area.left:
                   self.pos[0] = self.area.left + self.rect.width/2
                   self.dx *= -0.5 # bouncing off the side but loosing speed
               if self.pos[1] + self.rect.height/2 > self.area.bottom:
                   self.pos[1] = self.area.bottom - self.rect.height/2
                   self.dy *= -0.5
               if self.pos[1] - self.rect.height/2 < self.area.top:
                   self.pos[1] = self.area.top + self.rect.height/2
                   self.dy *= -0.5 # stop when reaching the sky
                   
       def update(self, seconds):
           self.speedcheck()    
           # ------------- movement
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           # -------------- check if Bird out of screen
           self.areacheck()
           # ------ rotating
           if self.dx != 0 and self.dy!=0:
               ratio = self.dy / self.dx
               if self.dx > 0:
                   self.angle = -90-math.atan(ratio)/math.pi*180.0 # in grad
               else:
                   self.angle = 90-math.atan(ratio)/math.pi*180.0 # in grad
           #self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
           #--- calculate new position on screen -----
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
           if self.hitpoints <= 0:
               self.kill()
   
  > important for Bird.image
           Bird.__init__(self,5) # create a "little" Bird but do more than that
           self.hitpoints = float(100)
           self.hitpointsfull = float(100)
           self.pos = [screen.get_width()/2, screen.get_height()/2]
           #print "my BigBirdNumber is", self.number # i have a number in the Bird> 0:
               self.cooldown -= time 
           else:
               if pressedkeys[pygame.K_SPACE]: # shoot forward
                   lasersound.play() # play sound
                   self.shots += 1
                   Bullet(self, -math.sin(self.angle*GRAD) ,
                          -math.cos(self.angle*GRAD) )
               self.cooldown = self.cooldowntime
           # ------------move------------------
           self.dx += self.ddx * self.speed
           self.dy += self.ddy * self.speed
           #self.speedcheck()   # friction, maxspeed             
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           # -- check if Bird out of screen
           self.areacheck()
           # ------------- rotate ------------------
           if pressedkeys[pygame.K_a]: # left turn , counterclockwise
               self.angle += self.rotatespeed
           if pressedkeys[pygame.K_d]: # right turn, clockwise
               self.angle -= self.rotatespeed
           self.oldcenter = self.rect.center
           self.image = pygame.transform.rotate(self.image0, self.angle)
           self.rect = self.image.get_rect()
           self.rect.center = self.oldcenter
           #--- calculate new position on screen -----
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
           if self.hitpoints <= 0: # ----- alive---- 
               self.kill()
           
  > self.lifetime:
               self.kill() 
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   
  > 0:
                   self.angle = -90-math.atan(ratio)/math.pi*180.0 # in grad
               else:
                   self.angle = 90-math.atan(ratio)/math.pi*180.0 # in grad
           self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0)
           
   # ----------------- end of definitions ------------  
   # ----------------- background artwork -------------  
   background = pygame.Surface((screen.get_width(), screen.get_height()))
   background.fill((255,255,255))     # fill white
   background.blit(write("navigate with w,a,s,d and q and e "),(50,40))
   background.blit(write("press SPACE to fire bullets"),(50,70))
   background.blit(write("press g to toggle gravity"), (50, 100))
   background.blit(write("press c to toggle collision detection."),(50,130))
   background.blit(write("Press ESC to quit "), (50,160))
   background = background.convert()  # jpg can not have transparency
   screen.blit(background, (0,0))     # blit background on screen (overwriting all)
   #-----------------define sprite groups------------------------
   birdgroup = pygame.sprite.Group() 
   textgroup = pygame.sprite.Group()
   bargroup = pygame.sprite.Group()
   stuffgroup = pygame.sprite.Group()
   bulletgroup = pygame.sprite.Group()
   fragmentgroup = pygame.sprite.Group()
   gravitygroup = pygame.sprite.Group()
   # only the allgroup draws the sprite, so i use LayeredUpdates() instead Group()
   allgroup = pygame.sprite.LayeredUpdates() # more sophisticated, can draw sprites in layers 

   #-------------loading files from data subdirectory -------------------------------
   try: # load images into> 0:
           quota = (float(hits)/player.shots )* 100
       pygame.display.set_caption("fps: %.2f gravity: %s hits:%i shots:%i quota:%.2f%%"  % (clock.get_fps(), 
                                    gravity, hits, player.shots, quota))
       # ------ collision detection
       for bird in birdgroup:

           if collision == "rect":
               crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_rect)
           elif collision == "circle":
               crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_circle)
           elif collision == "mask":
               crashgroup = pygame.sprite.spritecollide(bird, bulletgroup, False, pygame.sprite.collide_mask)
           else:
               raise( SystemExit, "wrong/missing collisoin method")
           for ball in crashgroup:  # test for collision with bullet
               if ball.boss.number != bird.number:
                   hitsound.play()
                   hits +=1
                   bird.hitpoints -= ball.boss.damage
                   #factor =  (ball.mass / bird.mass)
                   #bird.dx += ball.dx * factor
                   #bird.dy += ball.dy * factor
                   Wound(ball.rect.center, bird)
                   ball.kill()
                   
           crashgroup = pygame.sprite.spritecollide(bird, fragmentgroup, False)
           for frag in crashgroup: # test for red fragments
               bird.hitpoints -=1
               factor =  frag.mass / bird.mass
               bird.dx += frag.dx * factor
               bird.dy += frag.dy * factor
               frag.kill()
                   
       if gravity: # ---- gravity check ---
           for thing in gravitygroup:
               thing.dy += FORCE_OF_GRAVITY # gravity suck down all kind of things
                   
       #if len(birdgroup) < amount: # create enough SmallBirds
       #    for _ in range(random.randint(1,3)):
       #        SmallBird()
       
       # ------game Over ? -------------
       if (player.hitpoints < 1 or playtime > gametime) and not gameOver:
           gameOver = True # do those things once when the game ends
           screentext2.newmsg("")
           screentext.newmsg("Game Over. 
hits/shots: %i/%i quota: %.2f%%" % (hits, player.shots, quota), (255,0,0))
           player.hitpoints = 0 # kill the player into a big explosion
       if gameOver: # overtime to watch score, explosion etc
           overtime -= seconds
           if overtime < 0:
               mainloop = False
       else: # not yet gameOver
           screentext.newmsg("Time left: %.2f" % (gametime - playtime))
       
       # ----------- clear, draw , update, flip -----------------  
       allgroup.clear(screen, background)
       allgroup.update(seconds)
       allgroup.draw(screen)           
       pygame.display.flip()         

if __name__ == "__main__":
   game()
This Gist brought to you by gist-it.view rawpygame/018_perfect_collision_detection.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>019_homing_missiles.py</h2>
2-player game with homing missiles
url: http://thepythongamebook.com/en:part2:pygame:step019
author: horst.jens@spielend-programmieren.at
physic by Leonard Michlmayr
licence: gpl, see http://www.gnu.org/licenses/gpl.html

2 player can shoot at each other and/or at monster(s).
2 types of homing missiles (can also be shot down)
create new monsters with key m

works with python3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

def game(folder = "data"):
   import pygame
   import os
   import random
   import math 
   #------ starting pygame -------------
   pygame.mixer.pre_init(44100, -16, 2, 2048) # setup mixer to avoid sound lag
   pygame.init()
   screen=pygame.display.set_mode((1800,1000)) # try out larger values and see what happens !
   screenrect = screen.get_rect()
   #winstyle = 0  # |FULLSCREEN # Set the display mode
   #print "pygame version", pygame.ver 
   # ------- game constants ----------------------
   GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad
   # ----------- functions -----------
   def write(msg="pygame is cool", color=(0,0,0)):
       """write text into pygame surfaces"""
       myfont = pygame.font.SysFont("None", 32)
       mytext = myfont.render(msg, True, color)
       mytext = mytext.convert_alpha()
       return mytext
   def getclassname(class_instance):
       """this function extract the>"
       parts = text.split(".") # like ["<class '__main__","XWing'>"]
       return parts[-1][0:-2] # from the last (-1) part, take all but the last 2 chars
   
   def radians_to_degrees(radians):
       return (radians / math.pi) * 180.0
   
   def degrees_to_radians(degrees):
       return degrees * (math.pi / 180.0)
   
   def elastic_collision(sprite1, sprite2):
       """elasitc collision between 2 sprites (calculated as disc's).
          The function alters the dx and dy movement vectors of both sprites.
          The sprites need the property .mass, .radius, .pos[0], .pos[1], .dx, dy
          pos[0] is the x postion, pos[1] the y position"""
       # here we do some physics: the elastic
       # collision
       # first we get the direction of the push.
       # Let's assume that the sprites are disk
       # shaped, so the direction of the force is
       # the direction of the distance.
       dirx = sprite1.pos[0] - sprite2.pos[0]
       diry = sprite1.pos[1] - sprite2.pos[1]
       # the velocity of the centre of mass
       sumofmasses = sprite1.mass + sprite2.mass
       sx = (sprite1.dx * sprite1.mass + sprite2.dx * sprite2.mass) / sumofmasses
       sy = (sprite1.dy * sprite1.mass + sprite2.dy * sprite2.mass) / sumofmasses
       # if we sutract the velocity of the centre
       # of mass from the velocity of the sprite,
       # we get it's velocity relative to the
       # centre of mass. 
And relative to the
       # centre of mass, it looks just like the
       # sprite is hitting a mirror.
       bdxs = sprite2.dx - sx
       bdys = sprite2.dy - sy
       cbdxs = sprite1.dx - sx
       cbdys = sprite1.dy - sy
       # (dirx,diry) is perpendicular to the mirror
       # surface. 
We use the dot product to
       # project to that direction.
       distancesquare = dirx * dirx + diry * diry
       if distancesquare == 0:
           # no distance? this should not happen,
           # but just in case, we choose a random
           # direction
           dirx = random.randint(0,11) - 5.5
           diry = random.randint(0,11) - 5.5
           distancesquare = dirx * dirx + diry * diry
       dp = (bdxs * dirx + bdys * diry) # scalar product
       dp /= distancesquare # divide by distance * distance.
       cdp = (cbdxs * dirx + cbdys * diry)
       cdp /= distancesquare
       # We are done. 
(dirx * dp, diry * dp) is
       # the projection of the velocity
       # perpendicular to the virtual mirror
       # surface. 
Subtract it twice to get the
       # new direction.
       # Only collide if the sprites are moving
       # towards each other: dp > 0
       if dp > 0:
           sprite2.dx -= 2 * dirx * dp 
           sprite2.dy -= 2 * diry * dp
           sprite1.dx -= 2 * dirx * cdp 
           sprite1.dy -= 2 * diry * cdp
   
   # -----------> self.boss.rocketsmax / 2:
               self.color = (0,0,255)
           else:
               self.color = (0,0,128)
           self.percent = self.boss.rockets / self.boss.rocketsmax * 1.0
       
  > self.speedmax:
               factor = self.speedmax / speed * 1.0
               self.dx *= factor
               self.dy *= factor
           else:
               self.color = (0,0,128)
           self.percent = self.boss.rockets / self.boss.rocketsmax * 1.0
       
  > self.speedmax:
               factor = self.speedmax / speed * 1.0
               self.dx *= factor
               self.dy *= factor
           #----------- friction -------------            
           if abs(self.dx) > 0 : 
               self.dx *= self.friction  # make the Sprite slower over time
           if abs(self.dy) > 0 :
               self.dy *= self.friction

       def areacheck(self):
           """if GameObject leave self.arena, it is bounced (self.areabounce) or stopped (self.areastop)"""
           if (self.areastop or self.areabounce) and not self.area.contains(self.rect):
               # --- compare self.rect and area.rect
               if self.pos[0] + self.rect.width/2 > self.area.right:
                   self.pos[0] = self.area.right - self.rect.width/2
                   if self.areabounce:
                       self.dx *= self.bouncefriction # bouncing off but loosing speed
                   else:
                       self.dx = 0
               if self.pos[0] - self.rect.width/2 < self.area.left:
                   self.pos[0] = self.area.left + self.rect.width/2
                   if self.areabounce:
                       self.dx *= self.bouncefriction # bouncing off but loosing speed
                   else:
                       self.dx = 0
               if self.pos[1] + self.rect.height/2 > self.area.bottom:
                   self.pos[1] = self.area.bottom - self.rect.height/2
                   if self.areabounce:
                       self.dy *= self.bouncefriction # bouncing off but loosing speed
                   else:
                       self.dy = 0
               if self.pos[1] - self.rect.height/2 < self.area.top:
                   self.pos[1] = self.area.top + self.rect.height/2
                   if self.areabounce:
                       self.dy *= self.bouncefriction # bouncing off but loosing speed
                   else:
                       self.dy = 0
                       
       def rotate_toward_moving(self, dx= None, dy=None):
           if dx is None and dy is None:
               dx = self.dx
               dy = self.dy
           return  math.atan2(-dx, -dy)/math.pi*180.0 
       
       def kill(self):
           GameObject.gameobjects[self.number] =   None # delete sprite from dictionary
           pygame.sprite.Sprite.kill(self) # kill the sprite              
       
       def update(self, seconds):
           self.alivetime += seconds
           # ------- killing --------------
           if self.hitpoints <= 1:
               self.kill()
           if self.lifetime != -1:
               if self.alivetime > self.lifetime:
                   self.kill() # end of natural lifetime
           # --------- rotated ? -------------------
           if self.angle != self.oldangle:            
               self.oldcenter = self.rect.center
               self.image = pygame.transform.rotate(self.image0, self.angle)
               self.rect = self.image.get_rect()
               self.rect.center = self.oldcenter
               self.oldangle = self.angle

           #----------moving ----------------
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           self.speedcheck()    # ------------- movement
           self.areacheck() # ------- check if Bird out of screen
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   
  > 0:
                   return random.choice(Monster.monsters)
           else:
               pass # ------
               
       
       def update(self, seconds):
             pressedkeys = pygame.key.get_pressed()
             self.ddx = 0.0
             self.ddy = 0.0
             self.targetnumber = self.get_target_nr()
             if self.playernumber == 0:
                   if pressedkeys[pygame.K_w]: # forward
                            self.ddx = -math.sin(self.angle*GRAD) 
                            self.ddy = -math.cos(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx , -self.ddy )
                   if pressedkeys[pygame.K_s]: # backward
                            self.ddx = +math.sin(self.angle*GRAD) 
                            self.ddy = +math.cos(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx, -self.ddy )
                   if pressedkeys[pygame.K_e]: # right side
                            self.ddx = +math.cos(self.angle*GRAD)
                            self.ddy = -math.sin(self.angle*GRAD)
                            Smoke(self.rect.center, -self.ddx , -self.ddy )
                   if pressedkeys[pygame.K_q]: # left side
                            self.ddx = -math.cos(self.angle*GRAD) 
                            self.ddy = +math.sin(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx , -self.ddy )
             elif self.playernumber == 1:
                   if pressedkeys[pygame.K_KP8]: # forward
                            self.ddx = -math.sin(self.angle*GRAD) 
                            self.ddy = -math.cos(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx , -self.ddy )
                   if pressedkeys[pygame.K_KP5] or pressedkeys[pygame.K_KP2]: # backward
                            self.ddx = +math.sin(self.angle*GRAD) 
                            self.ddy = +math.cos(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx, -self.ddy )
                   if pressedkeys[pygame.K_KP9]: # right side
                            self.ddx = +math.cos(self.angle*GRAD)
                            self.ddy = -math.sin(self.angle*GRAD)
                            Smoke(self.rect.center, -self.ddx , -self.ddy )
                   if pressedkeys[pygame.K_KP7]: # left side
                            self.ddx = -math.cos(self.angle*GRAD) 
                            self.ddy = +math.sin(self.angle*GRAD) 
                            Smoke(self.rect.center, -self.ddx , -self.ddy )                        
             # ------------shoot-----------------
             self.peacetime += seconds # increase peacetime if no shot was fired
             if self.cooldown > 0: # ------ can not shoot
                   self.cooldown -= seconds # pause between bullets
             else: # --------can shoot
                   if ((self.playernumber == 1 and pressedkeys[pygame.K_KP0]) or 
                       (self.playernumber == 0 and pressedkeys[pygame.K_SPACE])): # shoot forward
                           self.ddx = +math.sin(self.angle*GRAD)#recoil
                           self.ddy = +math.cos(self.angle*GRAD)
                           lasersound.play() # play sound
                           Bullet(self, None, self.max_abberation )
                           self.peacetime = 0 # reset peacetime
                           self.cooldown = self.cooldowntime 
                           self.bullets_fired += 1
                           if self.rocketcooldown > 0:
                               self.rocketcooldown -= seconds
                           else:
                               if self.rockets > self.rocketsmax / 2: # heavy sliding rocket
                                   if self.targetnumber is not None:
                                       crysound.play()
                                       Rocket(self,self.targetnumber,1,-30) #boss, target, type, launchangle
                                       Rocket(self,self.targetnumber,1, 30) #boss, target, type, launchangle
                                       self.rockets_fired +=2
                                       self.rockets -= 2
                                       self.rocketcooldown = self.rocketcooldowntime
                               elif self.rockets > 2: # weak seeking rocket
                                   if self.targetnumber is not None:
                                       crysound.play()
                                       Rocket(self,self.targetnumber, 2, -80 )#boss, target, type
                                       Rocket(self,self.targetnumber, 2, 80 )#boss, target, type
                                       self.rockets_fired += 2
                                       self.rockets -= 2
                                       self.rocketcooldown = self.rocketcooldowntime
             #----- add more rockets --------
             if self.peacetime > self.rocketreloadtime:
                 self.rockets += 2
                 self.peacetime = 0
             #-------------rotate----------------
             if self.playernumber == 0:
                   if pressedkeys[pygame.K_a]: # left turn , counterclockwise
                       self.angle += self.rotatespeed
                   if pressedkeys[pygame.K_d]: # right turn, clockwise
                       self.angle -= self.rotatespeed
             elif self.playernumber == 1:
                   if pressedkeys[pygame.K_KP4]: # left turn , counterclockwise
                       self.angle += self.rotatespeed
                   if pressedkeys[pygame.K_KP6]: # right turn, clockwise
                       self.angle -= self.rotatespeed
             # ------------move------------------
             self.dx += self.ddx * self.speed 
             self.dy += self.ddy * self.speed
             # ----- move, rotate etc. 
------------  
             GameObject.update(self, seconds)# ------- calll parent function 
           
  > 0: # 1+ Monsters are alive
               mynumber = self.number
               while mynumber == self.number:
                  mynumber = random.choice(Monster.monsters)
               return mynumber
           else:
               return None
               
           
       def update(self, seconds):
           # each second, decide if to hunt player 0 or player 1
           self.hunttime += seconds
           if self.hunttime > 15:
               self.hunttime = 0
               self.targetnumber = self.choose_target_nr()
               self.target = GameObject.gameobjects[self.targetnumber]
           # hunting
           self.image = Monster.image[0] # "normal" xmonster
           if GameObject.gameobjects[self.targetnumber] is not None:
               self.targetdistancex = self.target.pos[0] - self.pos[0]
               self.targetdistancey = self.target.pos[1] - self.pos[1]
               if self.targetdistancex > 0:
                   self.dx += 1
                   if self.targetdistancex > 100:
                       self.image = Monster.image[3] # look right
                       #self.image0 = Monster.image[3] # look right
               elif self.targetdistancex <0:
                   self.dx -= 1
                   if self.targetdistancex < -100:
                       self.image = Monster.image[2] # look left
                       #self.image0 = Monster.image[2] # look left
               if self.targetdistancey > 0:
                   self.dy += 1
               elif self.targetdistancey < 0:
                   self.dy -= 1
               # ----- shoot rockets --------
               # ---- 4 different phases: bullets, heavy rockets, light rockets, pausing
               # ---- chance to change into another phase each full second
               self.phase = self.phases[int(self.alivetime) % 4 ] # fully cycle throug all phases each 3 seconds
               if self.phase == "nothing":
                   pass # do not shoot
               elif self.phase == "bullets":
                   if random.randint(1,2) == 1:
                       Bullet(self, GameObject.rotate_toward_moving(self, self.targetdistancex, self.targetdistancey), self.max_abberation)
                       self.bullets_fired += 1
                       self.firetime = 0.1
               elif self.phase == "heavy rockets":
                   #self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
                   if random.randint(1,50) == 1:
                       Rocket(self, self.targetnumber, 1) # shoot a slow, heavy rocket
                       self.rockets_fired += 1
                       self.firetime = 0.25 # show fire image for this time
               elif self.phase == "small rockets":
                   if random.randint(1,25) == 1:
                       Rocket(self, self.targetnumber, 2) # shoot a small fast rocket
                       self.rockets_fired += 1
                       self.firetime = 0.25 # show fire image for this time
                   
               if self.firetime > 0:
                   self.image = Monster.image[1] # show fire image for monster
                   self.firetime -= seconds    
               else:
                   self.firetime = 0
           GameObject.update(self, seconds)
           
           
  > self.lifetime:
               self.kill() 
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   
  > self.lifetime:
               self.kill() 
           if self.hitpoints < 1:
               self.kill()
           if GameObject.gameobjects[self.targetnr] is None:
               self.kill()
           if self.alivetime < self.starttime:
               #--------- rotate into direction of movement ------------
               self.angle = math.atan2(-self.dx, -self.dy)/math.pi*180.0 
           else:
               #-------- rotate toward target
               if self.target is not None:
                   ix = self.target.pos[0] - self.pos[0]
                   iy = self.target.pos[1] - self.pos[1]
                   self.angle = radians_to_degrees(math.atan2(iy,- ix))+90
               self.ddx = -math.sin(self.angle*GRAD)  
               self.ddy = -math.cos(self.angle*GRAD) 
           if self.type == 1: # sliding
               self.dx += self.ddx  #* self.speed
               self.dy += self.ddy  #* self.speed
               if random.randint(1,self.smokechance) ==1:
                   Smoke(self.pos, -self.ddx * 2, -self.ddy * 2)
           elif self.type == 2: #seeking
               self.dx = self.ddx * self.speed
               self.dy = self.ddy * self.speed
               if random.randint(1, self.smokechance) ==1:
                   Smoke(self.pos, -self.ddx, -self.ddy, 25, 75)
           #----------- both ------------
           GameObject.speedcheck(self)
           oldrect = self.rect.center
           self.image = pygame.transform.rotozoom(self.image0,self.angle,1.0) 
           self.rect = self.image.get_rect()   
           self.rect.center = oldrect
           self.pos[0] += self.dx * seconds
           self.pos[1] += self.dy * seconds
           self.rect.centerx = round(self.pos[0],0)
           self.rect.centery = round(self.pos[1],0)
   #------------- end of> crashplayer.number:
                   elastic_collision(crashplayer, player) # impact on player
                   # player.hitpoints -= crashplayer.damage
               # no damage ?
       
           # test if player crash into enemy rocket
           crashgroup = pygame.sprite.spritecollide(player, rocketgroup, False, pygame.sprite.collide_mask)
           for rocket in crashgroup:
               #if projectile.physicnumber > crashbody.physicnumber: #avoid checking twice
               if rocket.boss.playernumber != player.playernumber: # avoid friendly fire
                  impactsound.play()
                  player.hitpoints -= rocket.damage
                  rocket.boss.rockets_hit += 1
                  Wound(rocket.pos[:])
                  elastic_collision(rocket, player)
                  rocket.kill()
       
       for projectile in projectilegroup:
           # rocket vs rocket vs bullet vs bullet
           crashgroup = pygame.sprite.spritecollide(projectile, projectilegroup, False )
           for crashthing in crashgroup:
               if projectile.number > crashthing.number:
                   if crashthing.boss.playernumber != projectile.boss.playernumber:
                       projectile.hitpoints -= crashthing.damage
                       crashthing.hitpoints -= projectile.damage
                       elastic_collision(projectile, crashthing)
           
       if gravity: # ---- gravity check ---
           for thing in gravitygroup:  # gravity suck down bullets, players, monsters
               thing.dy += 2.81 # pixel per second square earth: 9.81 m/s
       # ------game Over ? -------------
       #if  (playtime > gametime) and not gameOver:
       #    gameOver = True # do those things once when the game ends
       if GameObject.gameobjects[0] is None and GameObject.gameobjects[1] is None:
           gameOver = True # both players death
           screentext1.newmsg("Game Over. 
Time played: %.2f seconds" % playtime)
           screentext2.newmsg("both players killed")
       elif GameObject.gameobjects[0] is None or GameObject.gameobjects[1] is None:
           if player1.hitpoints > 0:
               textname = "Red Player"
               textcolor = (255,0,0)
           else:
               textname = "Blue Player"
               textcolor = (0,0,255)
           if len(monstergroup) == 0: 
               gameOver = True # one player dead, all monsters dead
               screentext2.newmsg("%s, you win!" % textname, textcolor)
           elif len(monstergroup) == 1:
               screentext2.newmsg("%s, fight the monster !" % textname, textcolor)
           else:
               screentext2.newmsg("%s, fight the monsters !" % textname, textcolor)
       elif len(monstergroup) == 0:
           Player.duel = True # both players alive, no monsters alive
           screentext2.newmsg("Duel mode. 
Both Players, fight each other!", (255,0,255))
       elif len(monstergroup) == 1:
           Player.duel = False
           screentext2.newmsg("Both players, fight the monster", (255,0,255))
       elif len(monstergroup) > 1:
           Player.duel = False
           screentext2.newmsg("Both players, fight the monsters", (255,0,255))
       if gameOver: # overtime to watch score, explosion etc
           overtime -= seconds
           screentext1.newmsg("Game over. 
Overtime: %.2f" % overtime)
           if overtime < 0:
               mainloop = False
       else: # not yet gameOver
           screentext1.newmsg("Time left: %.2f" % (gametime - playtime),(255,0,255))
           #if player1.bullets_fired > 0:
           screentext3.newmsg("Red player: bullets: %i hit: %i quota: %.2f%% rockets: %i hits: %i quota: %.2f%%"
                              % (player1.bullets_fired, player1.bullets_hit, player1.bullets_hit *100.0 / max(1, player1.bullets_fired),
                              player1.rockets_fired, player1.rockets_hit, player1.rockets_hit * 100.0 / max(1,player1.rockets_fired))
                              ,(255,0,0))
           screentext4.newmsg("Blue player: bullets: %i hit: %i quota: %.2f%% rockets: %i hits: %i quota: %.2f%%"
                              % (player2.bullets_fired, player2.bullets_hit, player2.bullets_hit *100.0 / max(1, player2.bullets_fired),
                              player2.rockets_fired, player2.rockets_hit, player2.rockets_hit * 100.0 / max(1,player2.rockets_fired))
                              ,(0,0,255))
       # ----------- clear, draw , update, flip -----------------  
       allgroup.clear(screen, background)
       allgroup.update(seconds)
       allgroup.draw(screen)           
       pygame.display.flip()         

if __name__ == "__main__":
   game()
This Gist brought to you by gist-it.view rawpygame/019_homing_missiles.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
<h2>020_shooting_from_tank.py</h2>
demo of tank game with rotating turrets
url: http://thepythongamebook.com/en:part2:pygame:step020
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

demo of 2 tanks shooting bullets at the end of it's cannon
and shooting tracers at the end of it's bow Machine Gun
and from the turret-machine gun (co-axial with main gun)

works with pyhton3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad

class Config(object):
   """ a> Bullet.maxlifetime:
           self.kill()
       # ------ calculate movement --------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       # ----- kill if out of screen
       if self.pos[0] < 0:
           self.kill()
       elif self.pos[0] > Config.width:
           self.kill()
       if self.pos[1] < 0:
           self.kill()
       elif self.pos[1] > Config.height:
           self.kill()
       #------- move -------
       self.rect.centerx = round(self.pos[0],0)
       self.rect.centery = round(self.pos[1],0)

class Tracer(Bullet):
   """Tracer is nearly the same as Bullet, but smaller
      and with another origin (bow MG rect instead cannon.
      Tracer inherits all methods of Bullet, but i overwrite
      calculate_heading and calculate_origin"""
   side = 15 # long side of bullet rectangle
   vel = 200 # velocity
   mass = 10
   color = (200,0,100)
   maxlifetime = 10.0 # seconds
   def __init__(self, boss, turret=False):
       self.turret = turret
       Bullet.__init__(self,boss ) # this line is important 

   def calculate_heading(self):
       """overwriting the method because there are some differences 
          between a tracer and a main gun bullet"""
       self.radius = Tracer.side # for collision detection
       self.angle = 0
       self.angle += self.boss.tankAngle
       if self.turret:
           self.angle = self.boss.turretAngle
       self.mass = Tracer.mass
       self.vel = Tracer.vel
       image = pygame.Surface((Tracer.side, Tracer.side / 4)) # a line 
       image.fill(self.boss.color) # fill yellow ? 
       pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side / 4)) # red dot at front
       image.set_colorkey((128,128,128)) # grey transparent
       self.image0 = image.convert_alpha()
       self.image = pygame.transform.rotate(self.image0, self.angle)
       self.rect = self.image.get_rect()
       if self.turret:
           # turret mg
           self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
       else:
           # bow mg
           self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel

   def calculate_origin(self):
       """overwriting because another point of origin is needed"""
       # - spawn bullet at end of machine gun muzzle (bow or turret)
       if self.turret:
           self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
           self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
       else:
           self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
           self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)

class Tank(pygame.sprite.Sprite):
   """ A Tank, controlled by the Player with Keyboard commands.
   This Tank draw it's own Turret (including the main gun) 
   and it's bow rectangle (slit for Tracer Machine Gun"""
   side = 100 # side of the quadratic tank sprite
   recoiltime = 0.75 # how many seconds  the cannon is busy after firing one time
   mgrecoiltime = 0.2 # how many seconds the bow mg (machine gun) is idle
   turretTurnSpeed = 25 # turret
   tankTurnSpeed = 8 # tank
   movespeed = 25
   maxrotate = 360 # maximum amount of degree the turret is allowed to rotate
   book = {} # a book of tanks to store all tanks
   number = 0 # each tank gets his own number
   # keys for tank control, expand if you need more tanks
   #          player1,        player2    etc
   firekey = (pygame.K_k, pygame.K_DOWN)
   mgfirekey = (pygame.K_LCTRL, pygame.K_KP_ENTER)
   mg2firekey = (pygame.K_i, pygame.K_UP)
   turretLeftkey = (pygame.K_j, pygame.K_LEFT)
   turretRightkey = (pygame.K_l, pygame.K_RIGHT)
   forwardkey = (pygame.K_w, pygame.K_KP8)
   backwardkey = (pygame.K_s, pygame.K_KP5)
   tankLeftkey = (pygame.K_a, pygame.K_KP4)
   tankRightkey = (pygame.K_d, pygame.K_KP6)
   color = ((200,200,0), (0,0,200))
   msg = ["wasd LCTRL, ijkl", "Keypad: 4852, ENTER, cursor"]

   def __init__(self, startpos = (150,150), angle=0):
       self.number = Tank.number # now i have a unique tank number
       Tank.number += 1 # prepare number for next tank
       Tank.book[self.number] = self # store myself into the tank book
       pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
       self.pos = [startpos[0], startpos[1]] # x,y
       self.dx = 0
       self.dy = 0
       self.ammo = 30 # main gun
       self.mgammo = 500 # machinge gun
       self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
       Text((Config.width/2, 30+20*self.number), self.msg) # create status line text sprite
       self.color = Tank.color[self.number]
       self.turretAngle = angle #turret facing
       self.tankAngle = angle # tank facing
       self.firekey = Tank.firekey[self.number] # main gun
       self.mgfirekey = Tank.mgfirekey[self.number] # bow mg
       self.mg2firekey = Tank.mg2firekey[self.number] # turret mg
       self.turretLeftkey = Tank.turretLeftkey[self.number] # turret
       self.turretRightkey = Tank.turretRightkey[self.number] # turret
       self.forwardkey = Tank.forwardkey[self.number] # move tank
       self.backwardkey = Tank.backwardkey[self.number] # reverse tank
       self.tankLeftkey = Tank.tankLeftkey[self.number] # rotate tank
       self.tankRightkey = Tank.tankRightkey[self.number] # rotat tank
       # painting facing north, have to rotate 90° later
       image = pygame.Surface((Tank.side,Tank.side)) # created on the fly
       image.fill((128,128,128)) # fill grey
       if self.side > 10:
            pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
            pygame.draw.rect(image, (90,90,90), (0,0,self.side//6, self.side)) # track left
            pygame.draw.rect(image, (90,90,90), (self.side-self.side//6, 0, self.side,self.side)) # right track
            pygame.draw.rect(image, (255,0,0), (self.side//6+5 , 10, 10, 5)) # red bow rect left
            #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
       pygame.draw.circle(image, (255,0,0), (self.side//2,self.side//2), self.side//3 , 2) # red circle for turret
       image = pygame.transform.rotate(image,-90) # rotate so to look east
       self.image0 = image.convert_alpha()
       self.image = image.convert_alpha()
       self.rect = self.image0.get_rect()
       #---------- turret ------------------
       self.firestatus = 0.0 # time left until cannon can fire again
       self.mgfirestatus = 0.0 # time until mg can fire again
       self.mg2firestatus = 0.0 # time until turret mg can fire again
       self.turndirection = 0    # for turret
       self.tankturndirection = 0
       self.movespeed = Tank.movespeed
       self.turretTurnSpeed = Tank.turretTurnSpeed
       self.tankTurnSpeed = Tank.tankTurnSpeed
       Turret(self) # create a Turret for this tank

   def update(self, seconds):
       # no need for seconds but the other sprites need it
       #-------- reloading, firestatus----------
       if self.firestatus > 0:
           self.firestatus -= seconds # cannon will soon be ready again
           if self.firestatus <0:
               self.firestatus = 0 #avoid negative numbers
       if self.mgfirestatus > 0:
           self.mgfirestatus -= seconds # bow mg will soon be ready again
           if self.mgfirestatus <0:
               self.mgfirestatus = 0 #avoid negative numbers
       if self.mg2firestatus > 0:
           self.mg2firestatus -= seconds # turret mg will soon be ready again
           if self.mg2firestatus <0:
               self.mg2firestatus = 0 #avoid negative numbers

       # ------------ keyboard --------------
       pressedkeys = pygame.key.get_pressed()
       # -------- turret manual rotate ----------
       self.turndirection = 0    #  left / right turret rotation
       if pressedkeys[self.turretLeftkey]:
           self.turndirection += 1
       if pressedkeys[self.turretRightkey]:
           self.turndirection -= 1

       #---------- tank rotation ---------
       self.tankturndirection = 0 # reset left/right rotation
       if pressedkeys[self.tankLeftkey]:
           self.tankturndirection += 1
       if pressedkeys[self.tankRightkey]:
           self.tankturndirection -= 1

       # ---------------- rotate tank ---------------
       self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
       # angle etc from Tank (boss)
       oldcenter = self.rect.center
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
       self.rect = self.image.get_rect()
       self.rect.center = oldcenter 
       # if tank is rotating, turret is also rotating with tank !
       # -------- turret autorotate ----------
       self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
       # ---------- fire cannon -----------
       if (self.firestatus ==0) and (self.ammo > 0):
           if pressedkeys[self.firekey]:
               self.firestatus = Tank.recoiltime # seconds until tank can fire again
               Bullet(self)    
               self.ammo -= 1
               self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               Text.book[self.number].changemsg(self.msg)
       # -------- fire bow mg ---------------
       if (self.mgfirestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mgfirekey]:
               self.mgfirestatus = Tank.mgrecoiltime
               Tracer(self, False) # turret mg = False
               self.mgammo -= 1
               self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               Text.book[self.number].changemsg(self.msg)
       # -------- fire turret mg ---------------
       if (self.mg2firestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mg2firekey]:
               self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
               Tracer(self, True) # turret mg = True
               self.mgammo -= 1
               self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               Text.book[self.number].changemsg(self.msg)
       # ---------- movement ------------
       self.dx = 0
       self.dy = 0
       self.forward = 0 # movement calculator
       if pressedkeys[self.forwardkey]:
           self.forward += 1
       if pressedkeys[self.backwardkey]:
           self.forward -= 1
       # if both are pressed togehter, self.forward becomes 0
       if self.forward == 1:
           self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       if self.forward == -1:
           self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       # ------------- check border collision ---------------------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       if self.pos[1] + self.side//2 >= Config.height:
           self.pos[1] = Config.height - self.side//2
           self.dy = 0 # crash into border
       elif self.pos[1] -self.side/2 <= 0:
           self.pos[1] = 0 + self.side//2
           self.dy = 0
       # ---------- paint sprite at correct position ---------
       self.rect.centerx = round(self.pos[0], 0) #x
       self.rect.centery = round(self.pos[1], 0) #y    

class Turret(pygame.sprite.Sprite):
   """turret on top of tank"""
   def __init__(self, boss):
       pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
       self.boss = boss
       self.side = self.boss.side        
       self.images = {} # how much recoil after shooting, reverse order of apperance
       self.images[0] = self.draw_cannon(0)  # idle position
       self.images[1] = self.draw_cannon(1)
       self.images[2] = self.draw_cannon(2)
       self.images[3] = self.draw_cannon(3)
       self.images[4] = self.draw_cannon(4)
       self.images[5] = self.draw_cannon(5)
       self.images[6] = self.draw_cannon(6)
       self.images[7] = self.draw_cannon(7)
       self.images[8] = self.draw_cannon(8)  # position of max recoil
       self.images[9] = self.draw_cannon(4)
       self.images[10] = self.draw_cannon(0) # idle position

   def update(self, seconds):        
       # painting the correct image of cannon
       if self.boss.firestatus > 0:
           self.image = self.images[int(self.boss.firestatus // (Tank.recoiltime / 10.0))]
       else:
           self.image = self.images[0]
       # --------- rotating -------------
       # angle etc from Tank (boss)
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
       self.rect = self.image.get_rect()
       # ---------- move with boss ---------
       self.rect = self.image.get_rect()
       self.rect.center = self.boss.rect.center

   def draw_cannon(self, offset):
        # painting facing right, offset is the recoil
        image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
        image.fill((128,128,128)) # fill grey
        pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
        pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
        pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
        pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
        pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
        image.set_colorkey((128,128,128))
        return image
# ---------------- End of>021_targeting.py</h2>
demo of tank game with rotating turrets
url: http://thepythongamebook.com/en:part2:pygame:step021
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

the player2 tank rotate it's turrent always to player1 tank
you can "teleport" player1 tank by mouse click

special thanks to Jonathan Persson for motivation to write this
"""
import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad

class Config(object):
   """ a> Bullet.maxlifetime:
           self.kill()
       # ------ calculate movement --------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       # ----- kill if out of screen
       if self.pos[0] < 0:
           self.kill()
       elif self.pos[0] > Config.width:
           self.kill()
       if self.pos[1] < 0:
           self.kill()
       elif self.pos[1] > Config.height:
           self.kill()
       #------- move -------
       self.rect.centerx = round(self.pos[0],0)
       self.rect.centery = round(self.pos[1],0)
       
class Tracer(Bullet):
   """Tracer is nearly the same as Bullet, but smaller
      and with another origin (bow MG rect instead cannon.
      Tracer inherits all methods of Bullet, but i overwrite
      calculate_heading and calculate_origin"""
   side = 15 # long side of bullet rectangle
   vel = 200 # velocity
   mass = 10
   color = (200,0,100)
   maxlifetime = 10.0 # seconds
   def __init__(self, boss, turret=False):
       self.turret = turret
       Bullet.__init__(self,boss ) # this line is important 
       
   def calculate_heading(self):
       """overwriting the method because there are some differences 
          between a tracer and a main gun bullet"""
       self.radius = Tracer.side # for collision detection
       self.angle = 0
       self.angle += self.boss.tankAngle
       if self.turret:
           self.angle = self.boss.turretAngle
       self.mass = Tracer.mass
       self.vel = Tracer.vel
       image = pygame.Surface((Tracer.side, Tracer.side / 4)) # a line 
       image.fill(self.boss.color) # fill yellow ? 
       pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side / 4)) # red dot at front
       image.set_colorkey((128,128,128)) # grey transparent
       self.image0 = image.convert_alpha()
       self.image = pygame.transform.rotate(self.image0, self.angle)
       self.rect = self.image.get_rect()
       if self.turret:
           # turret mg
           self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
       else:
           # bow mg
           self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel

   def calculate_origin(self):
       """overwriting because another point of origin is needed"""
       # - spawn bullet at end of machine gun muzzle (bow or turret)
       if self.turret:
           self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
           self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
       else:
           self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
           self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)
       
   
class Tank(pygame.sprite.Sprite):
   """ A Tank, controlled by the Player with Keyboard commands.
   This Tank draw it's own Turret (including the main gun) 
   and it's bow rectangle (slit for Tracer Machine Gun"""
   side = 100 # side of the quadratic tank sprite
   recoiltime = 0.75 # how many seconds  the cannon is busy after firing one time
   mgrecoiltime = 0.2 # how many seconds the bow mg (machine gun) is idle
   turretTurnSpeed = 50 # turret
   tankTurnSpeed = 80 # tank
   movespeed = 80
   #maxrotate = 360 # maximum amount of degree the turret is allowed to rotate
   book = {} # a book of tanks to store all tanks
   number = 0 # each tank gets his own number
   # keys for tank control, expand if you need more tanks
   #          player1,        player2    etc
   firekey = (pygame.K_k, pygame.K_DOWN)
   mgfirekey = (pygame.K_LCTRL, pygame.K_KP_ENTER)
   mg2firekey = (pygame.K_i, pygame.K_UP)
   turretLeftkey = (pygame.K_j, pygame.K_LEFT)
   turretRightkey = (pygame.K_l, pygame.K_RIGHT)
   forwardkey = (pygame.K_w, pygame.K_KP8)
   backwardkey = (pygame.K_s, pygame.K_KP5)
   tankLeftkey = (pygame.K_a, pygame.K_KP4)
   tankRightkey = (pygame.K_d, pygame.K_KP6)
   color = ((200,200,0), (0,0,200))
   #msg = ["wasd LCTRL, ijkl", "Keypad: 4852, ENTER, cursor"]
         
   def __init__(self, startpos = (150,150), angle=0):
       self.number = Tank.number # now i have a unique tank number
       Tank.number += 1 # prepare number for next tank
       Tank.book[self.number] = self # store myself into the tank book
       pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
       self.pos = [startpos[0], startpos[1]] # x,y
       self.dx = 0
       self.dy = 0
       self.ammo = 30 # main gun
       self.mgammo = 500 # machinge gun
       self.color = Tank.color[self.number]
       self.turretAngle = angle #turret facing
       self.tankAngle = angle # tank facing
       self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
       Text((Config.width/2, 30+20*self.number), self.msg) # create status line text sprite
       self.firekey = Tank.firekey[self.number] # main gun
       self.mgfirekey = Tank.mgfirekey[self.number] # bow mg
       self.mg2firekey = Tank.mg2firekey[self.number] # turret mg
       self.turretLeftkey = Tank.turretLeftkey[self.number] # turret
       self.turretRightkey = Tank.turretRightkey[self.number] # turret
       self.forwardkey = Tank.forwardkey[self.number] # move tank
       self.backwardkey = Tank.backwardkey[self.number] # reverse tank
       self.tankLeftkey = Tank.tankLeftkey[self.number] # rotate tank
       self.tankRightkey = Tank.tankRightkey[self.number] # rotat tank
       # painting facing north, have to rotate 90° later
       image = pygame.Surface((Tank.side,Tank.side)) # created on the fly
       image.fill((128,128,128)) # fill grey
       if self.side > 10:
            pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
            pygame.draw.rect(image, (90,90,90), (0,0,self.side/6, self.side)) # track left
            pygame.draw.rect(image, (90,90,90), (self.side-self.side/6, 0, self.side,self.side)) # right track
            pygame.draw.rect(image, (255,0,0), (self.side/6+5 , 10, 10, 5)) # red bow rect left
            #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
       pygame.draw.circle(image, (255, 0, 0), (int(self.side/2), int(self.side/2)), int(self.side/3), 2) # red circle for turret
       image = pygame.transform.rotate(image,-90) # rotate so to look east
       self.image0 = image.convert_alpha()
       self.image = image.convert_alpha()
       self.rect = self.image0.get_rect()
       #---------- turret ------------------
       self.firestatus = 0.0 # time left until cannon can fire again
       self.mgfirestatus = 0.0 # time until mg can fire again
       self.mg2firestatus = 0.0 # time until turret mg can fire again
       self.turndirection = 0    # for turret
       self.tankturndirection = 0
       self.movespeed = Tank.movespeed
       self.turretTurnSpeed = Tank.turretTurnSpeed
       self.tankTurnSpeed = Tank.tankTurnSpeed
       Turret(self) # create a Turret for this tank
       
   def update(self, seconds):
       # no need for seconds but the other sprites need it
       #-------- reloading, firestatus----------
       if self.firestatus > 0:
           self.firestatus -= seconds # cannon will soon be ready again
           if self.firestatus <0:
               self.firestatus = 0 #avoid negative numbers
       if self.mgfirestatus > 0:
           self.mgfirestatus -= seconds # bow mg will soon be ready again
           if self.mgfirestatus <0:
               self.mgfirestatus = 0 #avoid negative numbers
       if self.mg2firestatus > 0:
           self.mg2firestatus -= seconds # turret mg will soon be ready again
           if self.mg2firestatus <0:
               self.mg2firestatus = 0 #avoid negative numbers
       
       # ------------ keyboard --------------
       pressedkeys = pygame.key.get_pressed()
       # -------- turret manual rotate ----------
       self.turndirection = 0    #  left / right turret rotation
       if self.number == 1:   # only for tank2
           self.aim_at_player()       # default aim at player0
       else:
           if pressedkeys[self.turretLeftkey]:
               self.turndirection += 1
           if pressedkeys[self.turretRightkey]:
               self.turndirection -= 1
          
       #---------- tank rotation ---------
       self.tankturndirection = 0 # reset left/right rotation
       if pressedkeys[self.tankLeftkey]:
           self.tankturndirection += 1
       if pressedkeys[self.tankRightkey]:
           self.tankturndirection -= 1
       
       # ---------------- rotate tank ---------------
       self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
       # angle etc from Tank (boss)
       oldcenter = self.rect.center
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
       self.rect = self.image.get_rect()
       self.rect.center = oldcenter 
       # if tank is rotating, turret is also rotating with tank !
       # -------- turret autorotate ----------
       self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
       # ---------- fire cannon -----------
       if (self.firestatus ==0) and (self.ammo > 0):
           if pressedkeys[self.firekey]:
               self.firestatus = Tank.recoiltime # seconds until tank can fire again
               Bullet(self)    
               self.ammo -= 1
               #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # -------- fire bow mg ---------------
       if (self.mgfirestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mgfirekey]:
               self.mgfirestatus = Tank.mgrecoiltime
               Tracer(self, False) # turret mg = False
               self.mgammo -= 1
               #self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # -------- fire turret mg ---------------
       if (self.mg2firestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mg2firekey]:
               self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
               Tracer(self, True) # turret mg = True
               self.mgammo -= 1
               #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # ---------- movement ------------
       self.dx = 0
       self.dy = 0
       self.forward = 0 # movement calculator
       if pressedkeys[self.forwardkey]:
           self.forward += 1
       if pressedkeys[self.backwardkey]:
           self.forward -= 1
       # if both are pressed togehter, self.forward becomes 0
       if self.forward == 1:
           self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       if self.forward == -1:
           self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       # ------------- check border collision ---------------------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       if self.pos[1] + self.side/2 >= Config.height:
           self.pos[1] = Config.height - self.side/2
           self.dy = 0 # crash into border
       elif self.pos[1] -self.side/2 <= 0:
           self.pos[1] = 0 + self.side/2
           self.dy = 0
       
       self.rect.centerx = round(self.pos[0], 0) #x
       self.rect.centery = round(self.pos[1], 0) #y    
       self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
       Text.book[self.number].changemsg(self.msg)
                   
   def aim_at_player(self, targetnumber=0):
       #print "my  pos: x:%.1f y:%.1f " % ( self.pos[0], self.pos[1])
       #print "his pos: x:%.1f y:%.1f " % ( Tank.book[0].pos[0], Tank.book[0].pos[1])  
       deltax = Tank.book[targetnumber].pos[0] - self.pos[0]
       deltay = Tank.book[targetnumber].pos[1] - self.pos[1]
       angle =   math.atan2(-deltax, -deltay)/math.pi*180.0    
       
       diff = (angle - self.turretAngle - 90) %360 #reset at 360
       if diff == 0:
           self.turndirection = 0
       elif diff > 180:
           self.turndirection = 1
       else:
           self.turndirection = -1
       return diff

class Turret(pygame.sprite.Sprite):
   """turret on top of tank"""
   def __init__(self, boss):
       pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
       self.boss = boss
       self.side = self.boss.side
       
       self.images = {} # how much recoil after shooting, reverse order of apperance
       self.images[0] = self.draw_cannon(0)  # idle position
       self.images[1] = self.draw_cannon(1)
       self.images[2] = self.draw_cannon(2)
       self.images[3] = self.draw_cannon(3)
       self.images[4] = self.draw_cannon(4)
       self.images[5] = self.draw_cannon(5)
       self.images[6] = self.draw_cannon(6)
       self.images[7] = self.draw_cannon(7)
       self.images[8] = self.draw_cannon(8)  # position of max recoil
       self.images[9] = self.draw_cannon(4)
       self.images[10] = self.draw_cannon(0) # idle position
        
   def update(self, seconds):        
       # painting the correct image of cannon
       if self.boss.firestatus > 0:
           self.image = self.images[int(self.boss.firestatus / (Tank.recoiltime / 10.0))]
       else:
           self.image = self.images[0]
       # --------- rotating -------------
       # angle etc from Tank (boss)
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
       self.rect = self.image.get_rect()
       # ---------- move with boss ---------
       self.rect = self.image.get_rect()
       self.rect.center = self.boss.rect.center

   
   def draw_cannon(self, offset):
        # painting facing right, offset is the recoil
        image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
        image.fill((128,128,128)) # fill grey
        pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
        pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
        pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
        pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
        pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
        image.set_colorkey((128,128,128))
        return image

# ---------------- End of>022_minimap.py</h2>
demo of tank game with rotating turrets and minimap
url: http://thepythongamebook.com/en:part2:pygame:step022
author: horst.jens@spielend-programmieren.at
licence: gpl, see http://www.gnu.org/licenses/gpl.html

the minimap displays tanks, traces and bullets even for elements
currently not visible on the playfield.

works with python3.4 and python2.7
"""

#the next line is only needed for python2.x and not necessary for python3.x
from __future__ import print_function, division

import pygame
import random
import math
GRAD = math.pi / 180 # 2 * pi / 360   # math module needs Radiant instead of Grad

class Config(object):
   """ a> Bullet.maxlifetime:
           self.kill()
       # ------ calculate movement --------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       # ----- kill if out of screen
       if self.pos[0] < 0:
           self.kill()
       elif self.pos[0] > Config.bigmapwidth:
           self.kill()
       if self.pos[1] < 0:
           self.kill()
       elif self.pos[1] > Config.bigmapheight:
           self.kill()
       #------- move -------
       self.rect.centerx = round(self.pos[0] - Config.cornerpoint[0],0)
       self.rect.centery = round(self.pos[1] - Config.cornerpoint[1],0)
       
class Tracer(Bullet):
   """Tracer is nearly the same as Bullet, but smaller
      and with another origin (bow MG rect instead cannon.
      Tracer inherits all methods of Bullet, but i overwrite
      calculate_heading and calculate_origin"""
   side = 15 # long side of bullet rectangle
   vel = 200 # velocity
   mass = 10
   color = (200,0,100)
   maxlifetime = 10.0 # seconds
   def __init__(self, boss, turret=False):
       self.turret = turret
       Bullet.__init__(self,boss ) # this line is important 
       self.tracer = True
       
   def calculate_heading(self):
       """overwriting the method because there are some differences 
          between a tracer and a main gun bullet"""
       self.radius = Tracer.side # for collision detection
       self.angle = 0
       self.angle += self.boss.tankAngle
       if self.turret:
           self.angle = self.boss.turretAngle
       self.mass = Tracer.mass
       self.vel = Tracer.vel
       image = pygame.Surface((Tracer.side, Tracer.side // 4)) # a line 
       image.fill(self.boss.color) # fill yellow ? 
       pygame.draw.rect(image, (0,0,0), (Tracer.side * .75, 0, Tracer.side, Tracer.side // 4)) # red dot at front
       image.set_colorkey((128,128,128)) # grey transparent
       self.image0 = image.convert_alpha()
       self.image = pygame.transform.rotate(self.image0, self.angle)
       self.rect = self.image.get_rect()
       if self.turret:
           # turret mg
           self.dx = math.cos(degrees_to_radians(self.boss.turretAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.turretAngle)) * self.vel
       else:
           # bow mg
           self.dx = math.cos(degrees_to_radians(self.boss.tankAngle)) * self.vel
           self.dy = math.sin(degrees_to_radians(-self.boss.tankAngle)) * self.vel

   def calculate_origin(self):
       """overwriting because another point of origin is needed"""
       # - spawn bullet at end of machine gun muzzle (bow or turret)
       if self.turret:
           self.pos[0] +=  math.cos(degrees_to_radians(-90+self.boss.turretAngle)) * 15
           self.pos[1] +=  math.sin(degrees_to_radians(90-self.boss.turretAngle)) * 15
       else:
           self.pos[0] +=  math.cos(degrees_to_radians(30+self.boss.tankAngle)) * (Tank.side/2)
           self.pos[1] +=  math.sin(degrees_to_radians(-30-self.boss.tankAngle)) * (Tank.side/2)
       
class Radarmap(pygame.sprite.Sprite):
   """a> 10:
            pygame.draw.rect(image, self.color, (5,5,self.side-10, self.side-10)) #tank body, margin 5
            pygame.draw.rect(image, (90,90,90), (0,0,self.side//6, self.side)) # track left
            pygame.draw.rect(image, (90,90,90), (self.side-self.side//6, 0, self.side,self.side)) # right track
            pygame.draw.rect(image, (255,0,0), (self.side//6+5 , 10, 10, 5)) # red bow rect left
            #pygame.draw.rect(image, (255,0,0), (self.side/2 - 5, 10, 10, 5)) # red bow rect middle
       pygame.draw.circle(image, (255,0,0), (self.side//2,self.side//2), self.side//3 , 2) # red circle for turret
       image = pygame.transform.rotate(image,-90) # rotate so to look east
       self.image0 = image.convert_alpha()
       self.image = image.convert_alpha()
       self.rect = self.image0.get_rect()
       #---------- turret ------------------
       self.firestatus = 0.0 # time left until cannon can fire again
       self.mgfirestatus = 0.0 # time until mg can fire again
       self.mg2firestatus = 0.0 # time until turret mg can fire again
       self.turndirection = 0    # for turret
       self.tankturndirection = 0
       self.movespeed = Tank.movespeed
       self.turretTurnSpeed = Tank.turretTurnSpeed
       self.tankTurnSpeed = Tank.tankTurnSpeed
       Turret(self) # create a Turret for this tank
       
   def update(self, seconds):  # no need for seconds but the other sprites need it
       #-------- reloading, firestatus----------
       if self.firestatus > 0:
           self.firestatus -= seconds # cannon will soon be ready again
           if self.firestatus <0:
               self.firestatus = 0 #avoid negative numbers
       if self.mgfirestatus > 0:
           self.mgfirestatus -= seconds # bow mg will soon be ready again
           if self.mgfirestatus <0:
               self.mgfirestatus = 0 #avoid negative numbers
       if self.mg2firestatus > 0:
           self.mg2firestatus -= seconds # turret mg will soon be ready again
           if self.mg2firestatus <0:
               self.mg2firestatus = 0 #avoid negative numbers
       
       # ------------ keyboard --------------
       pressedkeys = pygame.key.get_pressed()
       # -------- turret manual rotate ----------
       self.turndirection = 0    #  left / right turret rotation
       if self.number == 1:   # only for tank2
           self.aim_at_player()       # default aim at player0
       else:
           if pressedkeys[self.turretLeftkey]:
               self.turndirection += 1
           if pressedkeys[self.turretRightkey]:
               self.turndirection -= 1
          
       #---------- tank rotation ---------
       self.tankturndirection = 0 # reset left/right rotation
       if pressedkeys[self.tankLeftkey]:
           self.tankturndirection += 1
       if pressedkeys[self.tankRightkey]:
           self.tankturndirection -= 1
       
       # ---------------- rotate tank ---------------
       self.tankAngle += self.tankturndirection * self.tankTurnSpeed * seconds # time-based turning of tank
       # angle etc from Tank (boss)
       oldcenter = self.rect.center
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image0, self.tankAngle) 
       self.rect = self.image.get_rect()
       self.rect.center = oldcenter 
       # if tank is rotating, turret is also rotating with tank !
       # -------- turret autorotate ----------
       self.turretAngle += self.tankturndirection * self.tankTurnSpeed * seconds  + self.turndirection * self.turretTurnSpeed * seconds # time-based turning
       # ---------- fire cannon -----------
       if (self.firestatus ==0) and (self.ammo > 0):
           if pressedkeys[self.firekey]:
               self.firestatus = Tank.recoiltime # seconds until tank can fire again
               Bullet(self)    
               self.ammo -= 1
               #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # -------- fire bow mg ---------------
       if (self.mgfirestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mgfirekey]:
               self.mgfirestatus = Tank.mgrecoiltime
               Tracer(self, False) # turret mg = False
               self.mgammo -= 1
               #self.msg = "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # -------- fire turret mg ---------------
       if (self.mg2firestatus ==0) and (self.mgammo >0):
           if pressedkeys[self.mg2firekey]:
               self.mg2firestatus = Tank.mgrecoiltime # same recoiltime for both mg's
               Tracer(self, True) # turret mg = True
               self.mgammo -= 1
               #self.msg =  "player%i: ammo: %i/%i keys: %s" % (self.number+1, self.ammo, self.mgammo, Tank.msg[self.number])
               #Text.book[self.number].changemsg(self.msg)
       # ---------- movement ------------
       self.dx = 0
       self.dy = 0
       self.forward = 0 # movement calculator
       if pressedkeys[self.forwardkey]:
           self.forward += 1
       if pressedkeys[self.backwardkey]:
           self.forward -= 1
       # if both are pressed togehter, self.forward becomes 0
       if self.forward == 1:
           self.dx =  math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  -math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       if self.forward == -1:
           self.dx =  -math.cos(degrees_to_radians(self.tankAngle)) * self.movespeed
           self.dy =  math.sin(degrees_to_radians(self.tankAngle)) * self.movespeed
       # ------------- check border collision ---------------------
       self.pos[0] += self.dx * seconds
       self.pos[1] += self.dy * seconds
       if self.pos[0] + self.side/2 >= Config.bigmapwidth:
           self.pos[0] = Config.bigmawidth - self.side/2
           self.dx = 0 # crash into border
       elif self.pos[0] -self.side/2 <= 0:
           self.pos[0] = 0 + self.side/2
           self.dx = 0
       if self.pos[1] + self.side/2 >= Config.bigmapheight:
           self.pos[1] = Config.bigmapheight - self.side/2
           self.dy = 0 # crash into border
       elif self.pos[1] -self.side/2 <= 0:
           self.pos[1] = 0 + self.side/2
           self.dy = 0    
       
       self.rect.centerx = round(self.pos[0] - Config.cornerpoint[0], 0) #x
       self.rect.centery = round(self.pos[1] - Config.cornerpoint[1], 0) #y    
       #self.msg =  "tank%i: x:%i y:%i facing: turret:%i tank:%i"  % (self.number, self.pos[0], self.pos[1], self.turretAngle, self.tankAngle )
                   
   def aim_at_player(self, targetnumber=0):
       deltax = Tank.book[targetnumber].pos[0] - self.pos[0]
       deltay = Tank.book[targetnumber].pos[1] - self.pos[1]
       angle =   math.atan2(-deltax, -deltay)/math.pi*180.0    
       
       diff = (angle - self.turretAngle - 90) %360 #reset at 360
       diff -= 180
       # to avoid a jittering canon introduce a tolerance range of 4 degrees
       if abs(diff) < 2:
           self.turndirection = 0
       elif diff > 0:
           self.turndirection = 1
       else:
           self.turndirection = -1
       # return diff
    
    
class Turret(pygame.sprite.Sprite):
   """turret on top of tank"""
   def __init__(self, boss):
       pygame.sprite.Sprite.__init__(self, self.groups) # THE most important line !
       self.boss = boss
       self.side = self.boss.side
       self.images = {} # how much recoil after shooting, reverse order of apperance
       self.images[0] = self.draw_cannon(0)  # idle position
       self.images[1] = self.draw_cannon(1)
       self.images[2] = self.draw_cannon(2)
       self.images[3] = self.draw_cannon(3)
       self.images[4] = self.draw_cannon(4)
       self.images[5] = self.draw_cannon(5)
       self.images[6] = self.draw_cannon(6)
       self.images[7] = self.draw_cannon(7)
       self.images[8] = self.draw_cannon(8)  # position of max recoil
       self.images[9] = self.draw_cannon(4)
       self.images[10] = self.draw_cannon(0) # idle position
        
   def update(self, seconds):        
       # painting the correct image of cannon
       if self.boss.firestatus > 0:
           self.image = self.images[int(self.boss.firestatus // (Tank.recoiltime / 10.0))]
       else:
           self.image = self.images[0]
       # --------- rotating -------------
       # angle etc from Tank (boss)
       oldrect = self.image.get_rect() # store current surface rect
       self.image  = pygame.transform.rotate(self.image, self.boss.turretAngle) 
       self.rect = self.image.get_rect()
       # ---------- move with boss ---------
       self.rect = self.image.get_rect()
       self.rect.center = self.boss.rect.center
   
   def draw_cannon(self, offset):
        # painting facing right, offset is the recoil
        image = pygame.Surface((self.boss.side * 2,self.boss.side * 2)) # created on the fly
        image.fill((128,128,128)) # fill grey
        pygame.draw.circle(image, (255,0,0), (self.side,self.side), 22, 0) # red circle
        pygame.draw.circle(image, (0,255,0), (self.side,self.side), 18, 0) # green circle
        pygame.draw.rect(image, (255,0,0), (self.side-10, self.side + 10, 15,2)) # turret mg rectangle
        pygame.draw.rect(image, (0,255,0), (self.side-20 - offset,self.side - 5, self.side - offset,10)) # green cannon
        pygame.draw.rect(image, (255,0,0), (self.side-20 - offset,self.side - 5, self.side - offset,10),1) # red rect 
        image.set_colorkey((128,128,128))
        return image
# ---------------- End of> Config.bigmapwidth - Config.width:
           Config.cornerpoint[0] = Config.bigmapwidth - Config.width
           scrollx = 0
       if Config.cornerpoint[1] < 0:
           Config.cornerpoint[1] = 0
           scrolly = 0
       elif Config.cornerpoint[1] > Config.bigmapheight - Config.height:
           Config.cornerpoint[1] = Config.bigmapheight - Config.height
           scrolly = 0
       
       pygame.display.set_caption("%s FPS: %.2f playtime: %.1f " % ( Config.title,clock.get_fps(), playtime))
       #screen.blit(background, (0,0)) # delete all
       if scrollx == 0 and scrolly == 0:    # only necessery if there was no scrolling
           allgroup.clear(screen, background) # funny effect if you outcomment this line
       else:
           background = bigmap.subsurface((Config.cornerpoint[0],
                                           Config.cornerpoint[1],
                                           Config.width,
                                           Config.height)) # take snapshot of bigmap
           screen.blit(background, (0,0))
       allgroup.update(seconds) 
       allgroup.draw(screen)
       pygame.display.flip() # flip the screen 30 times a second
   return 0

if __name__ == '__main__':
   main()
This Gist brought to you by gist-it.view rawpygame/022_minimap.py
<br>
<br>
<br>
<br>

<script>
	var toc = $('#toc');
	$('.title,h2').each(function(i) {
		var topic = $(this), topicNumber = i + 1;
		toc.append('<a href="#topic-'+topicNumber+'" target="_self">'+topic.text()+'</a><br>');
		topic.attr('id', 'topic-' + topicNumber);
	});
</script>

