
<!DOCTYPE html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Windows Random cards</title>
<link href="https://williamkpchan.github.io/maincss.css" rel="stylesheet" type="text/css">
<script src="https://code.jquery.com/jquery-3.7.1.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

<script src="https://williamkpchan.github.io/mainscript.js"></script>
<script src="randoptionsArray.js"></script>

<style>
body { 
  width:80%;
  margin-left:10%;
  background-color: black;
  color: gray;
  justify-content: center;
  align-content: center;
  font-size: xx-large;
}
iframe {width:100%;}
dt, dd { display: inline-block; float: left; }
dt { clear: left; }
p { padding-left: 1.5em; text-indent:-1em;}
td {color:gray;}
#question { font-size: 24px; color: gray;}
.normalsize {font-size: 24px}
.mainFrame {width:100%; background-color: black}
#mychoice {font-size: 20px}
select option { font-size: 18px, line-height: 60%;}
button {color:white;}
a, select {font-size: 24px}
pre img {
  max-width:100%;
  display: block;
  margin: auto;
  text-align: center
}
#schRst, #markLst {font-size: 20px}
#jumpButton {font-size: 18px; color: orange;}
video { width: 100%;}
  sf {font-size: 70%}

@media only screen and (max-width: 1080px) {
  
  .mainFrame {width:100%; font-size: 24px; margin-left:0%;}
  pre {width:100%; font-size: 20px}
  img {width:100%}
  button {margin-top: 5px;}
  #schRst, #markLst {font-size: 20px}
  select option { font-size: 18px, line-height: 60%;}
  sf {font-size: 70%}
}
#question {
  user-select: none;
  cursor: pointer;
}

</style>
</head>

<body onkeypress="chkKey()">
<center>
<h5 id="totalLen">Info cards</h5>
<div class="mainFrame">
<button onclick=jpback()>next</button>
<button onclick=randQues()><o>rand</o></button>
<button onclick="window.location='#jumpButton'""><r>end</r></button>
<button onclick=randommyChoice()><pk>randL</pk></button>
<button onclick=stopjp()><o>stopjp</o></button>
<span id="automode"></span>
</div>
</center>

<pre id="question"> </pre><br>

<center>
<button id="jumpButton" onclick=jpButClick()><span id="questionsLeft"></span></button>
<button onclick=gotoQues()>goto</button>
<button onclick=ignoreIt()>ignoreIt</button>
<button onclick=markIt()>markIt</button>
<button onclick=recordIt() class="red">Rec</button>
<button onclick=clearIt() class="gold">Clr</button>
<button onclick=summaryIt() class="white">Show</button>

<button onclick=autojp()><lg>autoF</lg></button>
<button onclick=findkeyword() class="redbut"><r>findkey</r></button>
<button onclick=joinMultiTips(fixedSelections);><y>joinMultiTips</y></button>
<button onclick=createSearchSelectionButton();><pk>SearchKey</pk></button>
</div><br>
<span class="normalsize">select card box:</span>
<select id="myChoice" onchange="useChosen()"></select>

</select>
<br>
<button onclick=gototop();><r>top</r></button>
<button onclick=window.scrollTo(0, Number(document.body.scrollHeight/4))>quad</button>
<button onclick=window.scrollTo(0, Number(document.body.scrollHeight/2))>half</button>
<button onclick=window.scrollTo(0, Number(document.body.scrollHeight*3/4))>3 quad</button>
<button onclick="shuffleSW = !shuffleSW";><pk>shufSW</pk></button>
<button onclick=seekListName();><r>seekListName</r></button>

<br>
<div id="markLst"></div>
<div id="schRst"></div>
<br>

<a href="https://chat.deepseek.com/a/chat/" class="whitebut " target="_blank">deepseek</a>
</center>
<div id="localStorageList"></div>

<br><br><br><br>
<script>
tipsListName = ""
suffleTable = []
ignoreList = [];
ignoreListname = ""
markList = [];
markListname = ""
topicNo = ""
topic = ""
actualID = ""
questionList = []
shuffleSW = false
let intervalId;
fixedSelections = {}

const selectElement = document.getElementById('myChoice');
optionsArray.forEach(optionText => {
 const option = document.createElement('option');
 option.value = optionText; // Set the value attribute
 option.textContent = optionText; // Set the display text
 selectElement.appendChild(option); // Append the option to the select
});

function init(topicPtr) {
    listItem = ""
     for (variableName in window) { // list all window objects
        if (window[variableName] instanceof Array) { 
          listItem = listItem + ", " + variableName; 
        }
     }

  $("#totalLen").html(tipsListName+": "+questionList.length);

     if (!Number.isInteger(Number(topicPtr))) {
       topicNo = questionList.length;
     } else {
       topicNo = topicPtr;
     }

  //shuffle(questionList)

  showTopic()
}

function shuffle(array) {
 suffleTable = Array.from(Array(questionList.length).keys()) // cannot use eq sign

 //if(shuffleSW){
 //  currentIndex = array.length;
 //  while (currentIndex != 0) {
 //    randomIndex = Math.floor(Math.random() * currentIndex);
 //    currentIndex--;
 //    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
 //    [suffleTable[currentIndex], suffleTable[randomIndex]] = [suffleTable[randomIndex], suffleTable[currentIndex]];
 //  }
 //}else{
 //  topicNo = Math.floor(Math.random()  * questionList.length)
 //}
}

function randPtr(arrayName) {
  if (arrayName.length === 0) {
    throw new Error("Cannot select random index from an empty array");
  }
  return Math.floor(Math.random() * arrayName.length);
}

function randMultiPtr(arrayName, count, addEmptyElements = 0) {
  if (arrayName.length === 0 && addEmptyElements === 0) {
    throw new Error("Cannot select random elements from an empty array");
  }
  
  // Create an array with the original elements plus empty elements
  const arrayWithEmpties = arrayName.slice();
  for (let i = 0; i < addEmptyElements; i++) {
    arrayWithEmpties.push(''); // Add empty string elements
  }
  
  // If more elements are requested than available, adjust count.
  count = Math.min(count, arrayWithEmpties.length);

  // Fisher-Yates Shuffle Algorithm
  const shuffledArray = arrayWithEmpties.slice();
  for (let i = shuffledArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
  }

  return shuffledArray.slice(0, count);
}

// Function to search items by keyword and display results
function searchAndSelectItems() {
  const categories = {
    è‰²è°ƒ: t2i[0].è‰²è°ƒ,
    æ„å›¾: t2i[0].æ„å›¾,
    ç´‹ç†: t2i[0].ç´‹ç†,
    é£æ ¼: t2i[0].é£æ ¼,
    ç®—æ³•: t2i[0].ç®—æ³•,
    ç‰©ä»¶: t2i[0].ç‰©ä»¶,
    å½¢å®¹è¯: t2i[0].å½¢å®¹è¯,
    åœºæ™¯: t2i[0].åœºæ™¯
  };
  
  // Create search UI
  let html = `
    <div id="searchSelectionUI">
      <y>æœç´¢å¹¶é€‰æ‹©å›ºå®šé¡¹ç›®</y>
        <input type="text" id="searchKeyword" placeholder="è¾“å…¥å…³é”®è¯"> <button onclick="performSearch()" style="cursor: pointer;">æœç´¢</button> <button onclick="clearSearch()" style="cursor: pointer;">æ¸…ç©º</button>
      <y id="searchResults">è¾“å…¥å…³é”®è¯å¹¶ç‚¹å‡»æœç´¢</y>
      <pk id="selectedItemsPreview" style="display: none;">å·²é€‰æ‹©çš„é¡¹ç›®:</pk> <r id="selectedItemsList"></r></pk> <button onclick="confirmSearchSelections()">ç¡®è®¤å¹¶ç”Ÿæˆ</button> <button onclick="cancelSearchSelections()">å–æ¶ˆ</button> <button onclick="viewAllIndices()">æŸ¥çœ‹æ‰€æœ‰ç´¢å¼•</button>
    </div>
  `;
  
  // Display the UI in #question area
  const questionDiv = document.querySelector('#question');
  if (questionDiv) {
    questionDiv.innerHTML = html;
  }
  
  // Store selected items globally
  window.selectedSearchItems = [];
  
  // Perform search function
  window.performSearch = function() {
    const keyword = document.querySelector('#searchKeyword').value.trim();
    const resultsDiv = document.querySelector('#searchResults');
    
    if (!keyword) {
      resultsDiv.innerHTML = '<p>è¯·è¾“å…¥æœç´¢å…³é”®è¯</p>';
      return;
    }
    
    const searchResults = [];
    
    // Search through all categories
    for (const [category, items] of Object.entries(categories)) {
      items.forEach((item, index) => {
        if (item.toLowerCase().includes(keyword.toLowerCase())) {
          searchResults.push({
            category: category,
            index: index,
            text: item
          });
        }
      });
    }
    
    // Display results
    if (searchResults.length === 0) {
      resultsDiv.innerHTML = `<p>æœªæ‰¾åˆ°åŒ…å«"${keyword}"çš„é¡¹ç›®</p>`;
    } else {
      let resultsHtml = ''
      searchResults.forEach((result, i) => {
        const isSelected = window.selectedSearchItems.some(sel => 
          sel.category === result.category && sel.index === result.index
        );

        resultsHtml += `<label> <input type="checkbox" id="searchResult_${i}" data-category="${result.category}" 
            data-index="${result.index}" data-text="${result.text.replace(/"/g, '&quot;')}" ${isSelected ? 'checked' : ''}
            onchange="toggleSearchItem(${i})"> <strong>${result.category}[${result.index}]</strong> ${result.text} </label> `;
      });
      
      resultsDiv.innerHTML = resultsHtml;
    }
  };
  
  // Toggle item selection
  window.toggleSearchItem = function(resultIndex) {
    const checkbox = document.querySelector(`#searchResult_${resultIndex}`);
    if (!checkbox) return;
    
    const category = checkbox.getAttribute('data-category');
    const index = parseInt(checkbox.getAttribute('data-index'));
    const text = checkbox.getAttribute('data-text');
    
    const item = { category: category, index: index, text: text };
    
    if (checkbox.checked) {
      // Add if not already selected
      const exists = window.selectedSearchItems.some(sel => 
        sel.category === category && sel.index === index
      );
      if (!exists) {
        window.selectedSearchItems.push(item);
      }
    } else {
      // Remove if selected
      window.selectedSearchItems = window.selectedSearchItems.filter(sel => 
        !(sel.category === category && sel.index === index)
      );
    }
    
    // Update preview
    updateSelectedPreview();
  };
  
  // Update selected items preview
  function updateSelectedPreview() {
    const previewDiv = document.querySelector('#selectedItemsPreview');
    const listDiv = document.querySelector('#selectedItemsList');
    
    if (window.selectedSearchItems.length === 0) {
      previewDiv.style.display = 'none';
    } else {
      previewDiv.style.display = 'block';
      
      // Group by category
      const grouped = {};
      window.selectedSearchItems.forEach(item => {
        if (!grouped[item.category]) {
          grouped[item.category] = [];
        }
        grouped[item.category].push(item);
      });
      
      let listHtml = '';
      for (const [category, items] of Object.entries(grouped)) {
        listHtml += `<div>`;
        listHtml += `<strong>${category}:</strong> `;
        listHtml += items.map(item => 
          `[${item.index}] ${item.text.substring(0, 40)}${item.text.length > 40 ? '...' : ''}`
        ).join(', ');
        listHtml += `</div>`;
      }
      
      listDiv.innerHTML = listHtml;
    }
  }
  
  // Clear search
  window.clearSearch = function() {
    document.querySelector('#searchKeyword').value = '';
    document.querySelector('#searchResults').innerHTML = 
      '<p>è¾“å…¥å…³é”®è¯å¹¶ç‚¹å‡»æœç´¢</p>';
  };
  
  // View all indices
  window.viewAllIndices = function() {
    const resultsDiv = document.querySelector('#searchResults');
    let allItems = [];
    
    for (const [category, items] of Object.entries(categories)) {
      items.forEach((item, index) => {
        allItems.push({
          category: category,
          index: index,
          text: item
        });
      });
    }
    
    let resultsHtml = `<p>æ‰€æœ‰é¡¹ç›® (${allItems.length} ä¸ª):</p>`;
    
    // Sort by category and index
    allItems.sort((a, b) => {
      if (a.category === b.category) {
        return a.index - b.index;
      }
      return a.category.localeCompare(b.category);
    });
    
    allItems.forEach((result, i) => {
      const isSelected = window.selectedSearchItems.some(sel => 
        sel.category === result.category && sel.index === result.index
      );
      
      resultsHtml += `
        <div>
          <label>
            <input type="checkbox" 
                   id="allItem_${i}" 
                   data-category="${result.category}" 
                   data-index="${result.index}"
                   data-text="${result.text.replace(/"/g, '&quot;')}"
                   ${isSelected ? 'checked' : ''}
                   onchange="toggleAllItem(${i})">
            <div>
              <span style="color: #2196F3; font-weight: bold;">${result.category}[${result.index}]:</span>
              <span style="color: #333; margin-left: 5px;">${result.text.substring(0, 60)}${result.text.length > 60 ? '...' : ''}</span>
            </div>
          </label>
        </div>
      `;
    });
    
    resultsDiv.innerHTML = resultsHtml;
    
    // Update toggle function for all items
    window.toggleAllItem = function(itemIndex) {
      const checkbox = document.querySelector(`#allItem_${itemIndex}`);
      if (!checkbox) return;
      
      const category = checkbox.getAttribute('data-category');
      const index = parseInt(checkbox.getAttribute('data-index'));
      const text = checkbox.getAttribute('data-text');
      
      const item = { category: category, index: index, text: text };
      
      if (checkbox.checked) {
        const exists = window.selectedSearchItems.some(sel => 
          sel.category === category && sel.index === index
        );
        if (!exists) {
          window.selectedSearchItems.push(item);
        }
      } else {
        window.selectedSearchItems = window.selectedSearchItems.filter(sel => 
          !(sel.category === category && sel.index === index)
        );
      }
      
      updateSelectedPreview();
    };
  };
  
// Confirm selections and generate
window.confirmSearchSelections = function() {
  // Store selected items in local variable before cleanup
  const selectedItemsCopy = [...window.selectedSearchItems]; // Changed from window.selectedItems to window.selectedSearchItems
  
  // Convert selected items to fixedSelections format
  let formattedSelections = {
    theme: []
  };
  
  selectedItemsCopy.forEach(item => {
    // Only add the index if it's not already in the array
    if (!formattedSelections.theme.includes(item.index)) {
      formattedSelections.theme.push(item.index);
    }
  });
  
  // Store in the global fixedSelections variable (assuming it exists globally)
  if (typeof fixedSelections !== 'undefined') {
    fixedSelections = formattedSelections;
  }
  
  setTimeout(() => {
      // Alternative: call combineWithRandom with first selected item
      // Use the local copy instead of window.selectedItems
      if (selectedItemsCopy.length > 0) {
        joinMultiTips(formattedSelections);
      }
  }, 100); // Small delay to ensure UI updates first
  
  // Clean up global variables
  delete window.selectedSearchItems; // Changed from window.selectedItems to window.selectedSearchItems
  delete window.performSearch;
  delete window.toggleSearchItem;
  delete window.clearSearch;
  delete window.viewAllIndices;
  delete window.confirmSearchSelections;
  delete window.cancelSearchSelections;
  
  // Remove the search UI
  const searchUI = document.querySelector('#searchSelectionUI');
  if (searchUI) {
    searchUI.remove();
  }
};

  // Cancel and use random selections
  window.cancelSearchSelections = function() {
    joinMultiTips(); // Call with no fixed selections
    
    // Clean up global variables
    delete window.selectedSearchItems;
    delete window.performSearch;
    delete window.toggleSearchItem;
    delete window.clearSearch;
    delete window.viewAllIndices;
    delete window.confirmSearchSelections;
    delete window.cancelSearchSelections;
  };
}

// Update joinMultiTips function to show selection summary
function joinMultiTips(fixedSelections = {}) {
  let finalArray = [];
  
  // Show selection summary
  // showFixedSelectionsSummary(fixedSelections);
  
  // Original joinMultiTips logic (simplified for example)
  function addSelections(category, categoryKey, randomCnt, percent) {
    let selections = [];
    let fixedIndices = [];
    
    if (fixedSelections[categoryKey] && fixedSelections[categoryKey].length > 0) {
      fixedIndices = fixedSelections[categoryKey]
        .filter(idx => idx >= 0 && idx < category.length);
      
      fixedIndices.forEach(idx => {
        selections.push(category[idx]);
      });
    }
    
    const randomNeeded = Math.max(0, randomCnt - fixedIndices.length);
    
    if (randomNeeded > 0) {
      const availableIndices = Array.from({length: category.length}, (_, i) => i)
        .filter(i => !fixedIndices.includes(i));
      
      const randomSelections = getRandomItems(category, availableIndices, randomNeeded);
      selections = selections.concat(randomSelections);
    }
    
    if (selections.length > randomCnt) {
      selections = selections.slice(0, randomCnt);
    }
    
    return selections;
  }
  
  function getRandomItems(arr, availableIndices, count) {
    if (availableIndices.length === 0 || count <= 0) return [];
    const shuffled = [...availableIndices].sort(() => Math.random() - 0.5);
    const selectedIndices = shuffled.slice(0, Math.min(count, shuffled.length));
    return selectedIndices.map(idx => arr[idx]);
  }

  // Apply selections
  finalArray = finalArray.concat(addSelections(è‰²è°ƒ, 'è‰²è°ƒ', è‰²è°ƒcnt, 10));
  finalArray = finalArray.concat(addSelections(æ„å›¾, 'æ„å›¾', æ„å›¾cnt, 50));
  finalArray = finalArray.concat(addSelections(ç´‹ç†, 'ç´‹ç†', ç´‹ç†cnt, 30));
  finalArray = finalArray.concat(addSelections(é£æ ¼, 'é£æ ¼', é£æ ¼cnt, 60));
  finalArray = finalArray.concat(addSelections(ç®—æ³•, 'ç®—æ³•', ç®—æ³•cnt, 30));
  finalArray = finalArray.concat(addSelections(å½¢å®¹è¯, 'å½¢å®¹è¯', å½¢å®¹è¯cnt, 50));
  finalArray = finalArray.concat(addSelections(ç‰©ä»¶, 'ç‰©ä»¶', ç‰©ä»¶cnt, 10));
  finalArray = finalArray.concat(addSelections(åœºæ™¯, 'åœºæ™¯', åœºæ™¯cnt, 15));

  let finalString = finalArray.join(', ').replace(/,(\s*,)+/g, ', ');
  document.querySelector('#question').innerHTML = `${finalString}`;
  return finalArray;
}


// Function to show fixed selections summary
function showFixedSelectionsSummary(fixedSelections) {
  const categories = {
    è‰²è°ƒ: t2i[0].è‰²è°ƒ,
    æ„å›¾: t2i[0].æ„å›¾,
    ç´‹ç†: t2i[0].ç´‹ç†,
    é£æ ¼: t2i[0].é£æ ¼,
    ç®—æ³•: t2i[0].ç®—æ³•,
    ç‰©ä»¶: t2i[0].ç‰©ä»¶,
    å½¢å®¹è¯: t2i[0].å½¢å®¹è¯,
    åœºæ™¯: t2i[0].åœºæ™¯
  };
  
  let summaryHtml = ''
  let hasSelections = false;
  
  for (const [category, indices] of Object.entries(fixedSelections)) {
    if (indices && indices.length > 0 && categories[category]) {
      hasSelections = true;
      summaryHtml += `<div style="margin-top: 8px;">`;
      summaryHtml += `<strong>${category}:</strong> `;
      
      const items = indices.map(idx => {
        if (idx >= 0 && idx < categories[category].length) {
          const text = categories[category][idx];
          return `[${idx}] ${text.substring(0, 40)}${text.length > 40 ? '...' : ''}`;
        }
        return `[${idx}] (æ— æ•ˆç´¢å¼•)`;
      }).join(', ');
      
      summaryHtml += items;
      summaryHtml += `</div>`;
    }
  }

  // Insert the summary before #question if it exists
  const questionDiv = document.querySelector('#question');
  if (questionDiv && questionDiv.parentNode) {
    const existingSummary = document.querySelector('#fixedSelectionsSummary');
    if (existingSummary) {
      existingSummary.remove();
    }
    
    // Insert the new summary
    questionDiv.insertAdjacentHTML('beforebegin', summaryHtml);
  }
}

// Create a button to trigger the search interface
function createSearchSelectionButton() {
  const button = document.createElement('button');
  button.textContent = 'ğŸ” æœç´¢';
  button.onclick = searchAndSelectItems;
  
  // Insert the button before the #question element
  const questionDiv = document.querySelector('#question');
  if (questionDiv && questionDiv.parentNode) {
    const existingButton = document.querySelector('#searchSelectionBtn');
    if (!existingButton) {
      button.id = 'searchSelectionBtn';
      questionDiv.parentNode.insertBefore(button, questionDiv);
    }
  }  
  return button;
}


function randomSelectAndJoin(arr, itemNum, separator = " ") {
    // Validate input: ensure the array has enough elements
    if (!Array.isArray(arr) || arr.length < itemNum) {
        throw new Error(`Array must have at least ${itemNum} elements`);
    }

    // If requesting more items than array length, return all items
    if (itemNum >= arr.length) {
        return arr.join(separator);
    }

    // Create an array to store selected indices
    const selectedIndices = [];
    
    // Randomly select unique indices
    while (selectedIndices.length < itemNum) {
        const randomIndex = Math.floor(Math.random() * arr.length);
        
        // Only add if not already selected
        if (!selectedIndices.includes(randomIndex)) {
            selectedIndices.push(randomIndex);
        }
    }

    // Map indices to elements and join them
    const selectedElements = selectedIndices.map(index => arr[index]);

    selectionInfo = ""
    selectedElements.forEach((element, i) => {
        const index = selectedIndices[i];
        const length = element.length;
        const first15Chars = element.substring(0, 15);
        selectionInfo += `<br>Index ${index}: Length=${length}, LeadingChars="${first15Chars}"\n`;
    });

    document.querySelector('#schRst').innerHTML = selectionInfo;
    return selectedElements.join(separator);
}

  


function joinMultiTipsOrig(fixedSelections = {}) {
  let finalArray = []; // use 'let' because we reassign

  // Helper function to add fixed selections first, then random ones
  function addSelections(category, categoryKey, randomCnt, percent) {
    let selections = [];
    
    // Add fixed selections if provided for this category
    if (fixedSelections[categoryKey] && fixedSelections[categoryKey].length > 0) {
      // Ensure fixed selections are valid indices
      const fixedIndices = fixedSelections[categoryKey].filter(idx => 
        idx >= 0 && idx < category.length
      );
      
      // Add the fixed items
      fixedIndices.forEach(idx => {
        selections.push(category[idx]);
      });
      
      // Remove fixed items from consideration for random selection
      const availableIndices = Array.from({length: category.length}, (_, i) => i)
        .filter(i => !fixedIndices.includes(i));
      
      // If we need more random selections beyond fixed ones
      if (randomCnt > fixedIndices.length) {
        const randomNeeded = randomCnt - fixedIndices.length;
        const randomSelections = randMultiPtrFromIndices(category, availableIndices, randomNeeded, percent);
        selections = selections.concat(randomSelections);
      }
    } else {
      // No fixed selections, use original random logic
      selections = randMultiPtr(category, randomCnt, Number.parseInt(category.length * percent / 100));
    }
    
    return selections;
  }

  // Modified version of randMultiPtr that works with specific indices
  function randMultiPtrFromIndices(arr, indices, count, percent) {
    // This is a simplified version - you'll need to adapt your actual randMultiPtr logic
    // For now, just select random items from the available indices
    const shuffled = [...indices].sort(() => 0.5 - Math.random());
    const selectedIndices = shuffled.slice(0, Math.min(count, indices.length));
    return selectedIndices.map(idx => arr[idx]);
  }

  // Apply selections for each category
  finalArray = finalArray.concat(addSelections(è‰²è°ƒ, 'è‰²è°ƒ', è‰²è°ƒcnt, 30));
  finalArray = finalArray.concat(addSelections(æ„å›¾, 'æ„å›¾', æ„å›¾cnt, 50));
  finalArray = finalArray.concat(addSelections(ç´‹ç†, 'ç´‹ç†', ç´‹ç†cnt, 10));
  finalArray = finalArray.concat(addSelections(é£æ ¼, 'é£æ ¼', é£æ ¼cnt, 50));
  finalArray = finalArray.concat(addSelections(ç®—æ³•, 'ç®—æ³•', ç®—æ³•cnt, 30));
  finalArray = finalArray.concat(addSelections(å½¢å®¹è¯, 'å½¢å®¹è¯', å½¢å®¹è¯cnt, 50));
  finalArray = finalArray.concat(addSelections(ç‰©ä»¶, 'ç‰©ä»¶', ç‰©ä»¶cnt, 30));
  finalArray = finalArray.concat(addSelections(åœºæ™¯, 'åœºæ™¯', åœºæ™¯cnt, 15));

  // Clean up the final string
  finalString = finalArray.join(', ').replace(/,(\s*,)+/g, ', ');
  document.querySelector('#question').innerHTML = finalString;
  return finalArray;
}

// Example of how to use with fixed selections:
// const fixedSelections = {
//   è‰²è°ƒ: [0, 1], // Must include items at index 0 and 1 from è‰²è°ƒ array
//   æ„å›¾: [2],    // Must include item at index 2 from æ„å›¾ array
//   é£æ ¼: [0]     // Must include item at index 0 from é£æ ¼ array
// };
// joinMultiTips(fixedSelections);

// Original function call without fixed selections still works:
// joinMultiTips();


function copyTipContent() {
  const questionEl = document.querySelector('#question');
  if (!questionEl) {
    console.error('#question element not found');
    return;
  }

  // Get text content (ignores HTML tags)
  const textToCopy = questionEl.textContent || questionEl.innerText || '';

  if (!textToCopy.trim()) {
    console.warn('No text to copy in #question');
    return;
  }

  // Modern clipboard API (secure, works in most browsers)
  if (navigator.clipboard) {
    navigator.clipboard.writeText(textToCopy).then(() => {
      console.log('âœ… Text copied to clipboard:', textToCopy);
      // Optional: show visual feedback
      // e.g., flash a message or change background briefly
    }).catch(err => {
      console.error('Failed to copy using Clipboard API:', err);
      fallbackCopyTextToClipboard(textToCopy); // Fallback for older browsers
    });
  } else {
    // Fallback for very old browsers (e.g., Safari < 13.1, old iOS)
    fallbackCopyTextToClipboard(textToCopy);
  }
}

// Fallback using temporary textarea
function fallbackCopyTextToClipboard(text) {
  const textarea = document.createElement('textarea');
  textarea.value = text;
  textarea.style.position = 'fixed';  // Avoid scrolling to bottom
  textarea.style.opacity = '0';
  document.body.appendChild(textarea);
  textarea.select();
  try {
    const success = document.execCommand('copy');
    if (success) {
      console.log('âœ… Text copied via fallback method');
    } else {
      console.error('âŒ execCommand("copy") failed');
    }
  } catch (err) {
    console.error('Fallback copy failed:', err);
  }
  document.body.removeChild(textarea);
}


// Triple-click functionality

function setupTripleClick() {
    let clickCount = 0;
    let clickTimer;

    document.addEventListener('click', function(e) {
        const jsTipElement = document.querySelector('#question');
        console.log('#question:', jsTipElement);
        
        if (jsTipElement && e.target.closest('#question')) {
            clickCount++;
            console.log("âœ… Click INSIDE #question! Count:", clickCount);
            
            clearTimeout(clickTimer);
            clickTimer = setTimeout(() => {
                clickCount = 0;
            }, 500);
            
            if (clickCount === 3) {
                console.log('ğŸ¯ TRIPLE CLICK DETECTED!');
                copyTipContent();
                clickCount = 0;
                clearTimeout(clickTimer);
            }
        } else {
            clickCount = 0;
        }
    });
}



function showCopyFeedback() {
  const tipElement = document.querySelector('#question');
  const originalBackground = tipElement.style.backgroundColor;
  
  // Flash effect
  tipElement.style.backgroundColor = '#4CAF50';
  tipElement.style.transition = 'background-color 0.3s';
  
  setTimeout(() => {
    tipElement.style.backgroundColor = originalBackground;
  }, 300);
  
  // Optional: Show a temporary message
  const feedback = document.createElement('div');
  feedback.textContent = 'âœ“ Copied to clipboard!';
  feedback.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    background: #4CAF50;
    color: white;
    padding: 10px 15px;
    border-radius: 5px;
    z-index: 1000;
    font-family: Arial, sans-serif;
  `;
  document.body.appendChild(feedback);
  
  setTimeout(() => {
    document.body.removeChild(feedback);
  }, 1000);
}

// Fallback for older browsers
function fallbackCopyText(text) {
  const textArea = document.createElement('textarea');
  textArea.value = text;
  textArea.style.cssText = 'position: fixed; left: -9999px; opacity: 0;';
  document.body.appendChild(textArea);
  textArea.select();
  textArea.setSelectionRange(0, 99999); // For mobile devices
  
  try {
    const successful = document.execCommand('copy');
    if (successful) {
      showCopyFeedback();
      console.log('âœ… Content copied to clipboard (fallback)!');
    } else {
      alert('âŒ Failed to copy content. Please copy manually.');
    }
  } catch (err) {
    alert('âŒ Copy failed. Please copy manually: ' + text);
  }
  
  document.body.removeChild(textArea);
}

function showTopic() {
  topicNo = topicNo - 1;
  if (topicNo < 0) { topicNo = questionList.length-1}
  actualID = suffleTable[topicNo]

  while(ignoreList.includes(actualID)){
    topicNo = topicNo - 1
    if (topicNo < 0) { topicNo = questionList.length-1}
    actualID = suffleTable[topicNo]
  }

  var pointer = topicNo;
  topic = questionList[pointer];
  recordLast(pointer);

  tipsNamesubstr = tipsListName.substring(0, 7)
  if (tipsNamesubstr === "archive") {
    topic = lineHeader + topic + lineTail
  }

    document.querySelector('#question').innerHTML = topic;
    document.querySelector('#questionsLeft').innerHTML = topicNo+1;
    $("#automode").html(topicNo+1)

  // Wait for DOM to be fully loaded before setting up event listeners
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, setting up triple click...');
    setupTripleClick();
  });



  document.querySelector('body').focus();
  gototop()
}

function gotoQues() {
  pointer = questionList.length+1
  while(pointer > questionList.length){
    pointer = Number(prompt("goto item number", topicNo))
  }
  showPointerQue(pointer)
}

function randQues() {
  randomPtr = Math.floor(Math.random() * questionList.length);
  showPointerQue(randomPtr)
}

function stopjp() {
    clearInterval(intervalId);
    $("#automode").html("")
}
function autojp() {
  var timeStep = Number(prompt("Please enter period in seconds: ", "7")) * 1000; // Convert to milliseconds
  var cycleNum = Number(prompt("Please enter cycle number: ", "50"));
  if (timeStep > 0 && cycleNum > 0) {
    let rptcount = 0; // Initialize counter
    //$("#automode").html("<r>Auto:On</r>")
      intervalId = setInterval(() => {
      jpback();
      rptcount++;
      $("#automode").html(rptcount)
      if (rptcount >= cycleNum) {
        clearInterval(intervalId); // Stop the interval
      }
    }, timeStep);
  }
}

function showPointerQue(pointer) {
  topicNo = pointer;
  showTopic()
  //var topic = questionList[pointer];
  //document.querySelector('#question').innerHTML = topic;
  //document.querySelector('#questionsLeft').innerHTML = topicNo;
  //document.querySelector('body').focus();
  recordLast(pointer);
  gototop();
}

function gototop() {
  window.location = '#totalLen'
}

function ignoreIt() {
  actualID = suffleTable[topicNo]
  ignoreList.push(actualID);
  ignoreListStr = ignoreList.join(" ");
  localStorage.setItem(ignoreListname, ignoreListStr)
  document.querySelector('#schRst').innerHTML = "<br><y>topic ignored:</y> <r>" + topicNo + "</r>"
}

function markIt() {
  actualID = suffleTable[topicNo]
  markList.push(actualID);
  markList = [...new Set(markList)];
  markListStr = markList.join(" ");
  localStorage.setItem(markListname, markListStr)
  showmarkList(markList)
}
function recordIt() {
  let tipsListNamedata = JSON.parse(localStorage.getItem(tipsListName)) || []
  tipsListNamedata.push(topic)
  localStorage.setItem(tipsListName, JSON.stringify(tipsListNamedata))

console.log("recordIt: ",tipsListName, topic)
  //localStorage.setItem(keyname, value)
}
function clearIt() {
  window.localStorage.removeItem(tipsListName);
console.log("clearIt: ",tipsListName, topic)
}

function summaryIt() {
  const value = localStorage.getItem(tipsListName);
  const itemdiv = document.createElement('div');
  itemdiv.textContent = `tipsListName: ${tipsListName}, Value: ${value}`;

  const storageList = document.getElementById('localStorageList');
  storageList.innerHTML = ''; // Clear previous content
  storageList.appendChild(itemdiv);
}

function findkeyword() {
  keyword = ""
  while(keyword == ""){
    keyword = prompt("enter keyword to search: ", keyword)
  }

  keyword = keyword.toLowerCase();
  targetNum = [];

  for ( i = 0; i < questionList.length; i++) {
    searchString = questionList[i].toLowerCase();

    if(typeof(searchString)=="string"){
      searchResult = searchString.indexOf(keyword);
      if(searchResult >= 0){
        targetNum.push(i);
      }
    }
  }

  if(targetNum.length >0){
    targetNumStr = ""
    for ( i = 0; i < targetNum.length; i++) {
      targetNumStr = targetNumStr + "<span class='redbut' onclick=showPointerQue("
      + (targetNum[i]+1)
      + ")>"
      + (targetNum[i]+1)
      + "</span> "
    }
    document.querySelector('#schRst').innerHTML = "<br><y>search result:</y> <r>" + keyword+ "</r><br>" + targetNumStr;
  }else{
    document.querySelector('#schRst').innerHTML = "<br><y>search result: <r>None!</r></y><br>";
  }
  window.location = '#schRst';
}

$(".answer").click(function () {
   $(this).toggleClass("appear");
});

function jpButClick() {
  var jpBut = document.querySelector('#jumpButton');
  if (topicNo >= 0) {
    showTopic();
  }else if(topicNo === 0) {
      jpBut.classList.disabled = true;
  }else{
      jpBut.classList.disabled = false;
  }
}

function jpback() {
  topicNo = topicNo + 2;
  actualID = suffleTable[topicNo]
  while(ignoreList.includes(actualID)){
    topicNo = topicNo + 2
    console.log("\ninside topicNo ",topicNo, "actualID ",actualID)
    actualID = suffleTable[topicNo]
  }
  if (topicNo <= questionList.length){
      showTopic()
  }
}

function chkKey() {
  var testkey = getChar(event);
  if(testkey == 'f'){jpback();}
  else if(testkey == 'a'){autojp();}
  else if(testkey == 'b'){jpButClick();}
  else if(testkey == 'F'){findkeyword();}
  else if(testkey == 'i'){ignoreIt();}
  else if(testkey == 'm'){markIt();}
  else if(testkey == 'g'){gotoQues();}
  else if(testkey == 'r'){randommyChoice();}
  else if(testkey == 's'){speak();}
  else if(testkey == 't'){gototop();}
  else if(testkey == 'e'){window.location = '#myChoice'; window.scrollBy({ top: -100, behavior: 'smooth'});}

  else{chkOtherKeys(testkey)} 
}
function getChar(event) {
  if (event.which!=0 && event.charCode!=0) {
    return String.fromCharCode(event.which)   // the rest
  } else {
    return null // special key
  }
}

function useChosen() {
  var myChoice = document.getElementById("myChoice");
  var choiceIndex = myChoice.selectedIndex;
  tipsListName = myChoice.options[choiceIndex].text // first to know the question name
  addButton();
  loadArray(tipsListName, 2)
}

function randommyChoice() {
  ArrayPtr = Math.floor(Math.random() * optionsArray.length);
  tipsListName = myChoice.options[ArrayPtr].text // first to know the question name
  loadArray(tipsListName, 2)
}

function loadArray(filename, topicPtr) {
  tipsListName = filename // update tipsListName to avoid entry from seel list name
  if(filename == "JavaScriptTips"){
    url = "JavaScriptTipsTab-starter/js/main.js"
  }else if(filename == "proverbList"){
    url = "https://williamkpchanhp.github.io/LibDocs/literature/proverbs.js"
  }else if(filename == "phpQuiz"){
    url = "RNotes.js"
  }else if(filename == "improveEnglish"){
    url = "personalQuality.js"
  }else{
    url = filename + ".js"
  }

    script = document.createElement('script');
    script.src = url
    script.type = 'text/javascript';

    script.onload = function () { // remember to put all waiting jobs inside here 
       questionList = eval(filename);

       var myChoice = document.getElementById("myChoice");
       myChoice.value = filename

       ignoreListname = "ignore" + filename
       markListname = "mark" + filename
       if (localStorage.getItem(ignoreListname) === null) {
         ignoreList = [];
       } else{
         ignoreList = localStorage.getItem(ignoreListname).split(' ').map(Number);
       }

       if (localStorage.getItem(markListname) === null) {
         markList = [];
       } else{
         markList = localStorage.getItem(markListname).split(' ').map(Number);
       }

       // startup topicPtr
       if (!Number.isInteger(Number(topicPtr))) {
         topicNo = questionList.length;
       } else {
         topicNo = topicPtr;
       }

       init(Number(topicNo)+1)  // showTopic
       showmarkList(markList)
    };

    document.head.appendChild(script);
    gototop();
}

function seekListName() {
  findListkeyword = ""
  while(findListkeyword == ""){
    findListkeyword = prompt("enter list name to search for: ", findListkeyword)
  }

  findListkeyword = findListkeyword.toLowerCase();
  targetListNum = [];

  for ( i = 0; i < optionsArray.length; i++) {
    searchString = optionsArray[i].toLowerCase();

    if(typeof(searchString)=="string"){
      searchResult = searchString.indexOf(findListkeyword);
      if(searchResult >= 0){
        targetListNum.push(i);
      }
    }
  }

  if(targetListNum.length >0){
    targetListNumStr = ""
    for ( i = 0; i < targetListNum.length; i++) {
      targetListNumStr = targetListNumStr + "<span class='redbut' onclick=loadArray('"+optionsArray[targetListNum[i]]
      + "')>"
      + optionsArray[targetListNum[i]]
      + "</span> "
    }
    document.querySelector('#schRst').innerHTML = "<br><y>search result:</y> <r>" + findListkeyword+ "</r><br>" + targetListNumStr;
  }else{
    document.querySelector('#schRst').innerHTML = "<br><y>search result: <r>None!</r></y><br>";
  }
  window.location = '#schRst';
}


function showmarkList(markList) {
  if(markList.length >0){
    markListStr = ""
    markList = [...new Set(markList)];
    for ( i = 0; i < markList.length; i++) {
      markListStr = markListStr + "<span class='redbut' onclick=showPointerQue("
      + markList[i]
      + ")>"
      + markList[i]
      + "</span> "
    }
    document.querySelector('#markLst').innerHTML = "<br><y>marked Topics:</y> " + markListStr+ "<br>"
  }else{
    document.querySelector('#markLst').innerHTML = "<br><y>marked Topics: <r>None!</r></y><br>";
  }
}

$("body").on( "swipeleft", function( event ) {jpback();} );
$("body").on( "swiperight", function( event ) {jpButClick();});
$("img").click( "jpButClick()");



// record lastRecStr for next start up
function recordLast(value) {
console.log("value ",value)
  lastRecStr = tipsListName+" "+ value
  console.log("\n\nrecordLast lastRecStr ", lastRecStr)
  localStorage.setItem("lastRec", lastRecStr)
}


// startup the process
if (localStorage.getItem("lastRec") === null) {
  console.log("lastRec i null")
  randommyChoice();
} else{
  lastRec = localStorage.getItem("lastRec")
console.log(lastRec)
  tipsListName = lastRec.split(' ')[0];
  actualID = lastRec.split(' ')[1];
console.log("tipsListName ",tipsListName, " number ", actualID)
  if(!Number.isInteger(Number(actualID))){
    actualID = 20
  }

  loadArray(tipsListName, actualID)

  mainFrameDiv = document.querySelector('.mainFrame');
  mixButton = `<button onclick="searchKeywords();"><r>searchKey</r></button><button onclick="mixItems(2);">Mix2Items</button><button onclick="mixItems(3);">Mix3Items</button>\n`;
  addButton();
  init(Number(actualID))
}


// addButton
function addButton() {
  if(tipsListName == "theme"){
    console.log("mainFrameDiv.innerHTML bf",mainFrameDiv.innerHTML)
    mainFrameDiv.innerHTML += mixButton
  }else{
    console.log("mainFrameDiv.innerHTML aft",mainFrameDiv.innerHTML)
    mainFrameDiv.innerHTML = mainFrameDiv.innerHTML.replace(mixButton, '' );
  }
}

// Search for keywords in the theme array
function searchKeywords() {
  // Create search UI
  let html = `
    <div id="searchSelectionUI">
      <y>æœç´¢å¹¶é€‰æ‹©å›ºå®šé¡¹ç›®</y>
        <input type="text" id="searchKeyword" placeholder="è¾“å…¥å…³é”®è¯"> <button onclick="performSearch()" style="cursor: pointer;">æœç´¢</button> <button onclick="clearSearch()" style="cursor: pointer;">æ¸…ç©º</button>
      <y id="searchResults">è¾“å…¥å…³é”®è¯å¹¶ç‚¹å‡»æœç´¢</y>
      <pk id="selectedItemsPreview" style="display: none;">å·²é€‰æ‹©çš„é¡¹ç›®:</pk> <r id="selectedItemsList"></r> <button onclick="confirmSearchSelections()">ç¡®è®¤å¹¶ç”Ÿæˆ</button> <button onclick="cancelSearchSelections()">å–æ¶ˆ</button> <button onclick="viewAllIndices()">æŸ¥çœ‹æ‰€æœ‰ç´¢å¼•</button>
    </div>
  `;
  
  // Display the UI in #question area
  const questionDiv = document.querySelector('#question');
  if (questionDiv) {
    questionDiv.innerHTML = html;
  }
  questionDiv.focus()
  // Store selected items globally
  window.selectedItems = [];
  
  // Perform search function
  window.performSearch = function() {
    const keyword = document.querySelector('#searchKeyword').value.trim();
    const resultsDiv = document.querySelector('#searchResults');
    
    if (!keyword) {
      resultsDiv.innerHTML = '<p>è¯·è¾“å…¥æœç´¢å…³é”®è¯</p>';
      return;
    }
    
    const searchTerm = keyword.toLowerCase();
    const searchResults = theme.filter(item => 
        item.toLowerCase().includes(searchTerm)
    );

    // Display results
    if (searchResults.length === 0) {
      resultsDiv.innerHTML = `<p>æœªæ‰¾åˆ°åŒ…å«"${keyword}"çš„é¡¹ç›®</p>`;
    } else {
      let resultsHtml = `<p>æ‰¾åˆ° ${searchResults.length} ä¸ªç»“æœ:</p>`;
      searchResults.forEach((result, i) => {
        const actualIndex = theme.findIndex(item => item === result);
        const isSelected = window.selectedItems.some(sel => 
          sel.index === actualIndex
        );

        resultsHtml += `<label> <input type="checkbox" id="searchResult_${i}" data-index="${actualIndex}" data-text="${result.replace(/"/g, '&quot;')}" ${isSelected ? 'checked' : ''}
            onchange="toggleSearchItem(${i}, ${actualIndex})"> <strong>ç´¢å¼•[${actualIndex}]</strong> ${result} </label><br>`;
      });
      
      resultsDiv.innerHTML = resultsHtml;
    }
  };
  
  // Toggle item selection
  window.toggleSearchItem = function(resultIndex, actualIndex) {
    const checkbox = document.querySelector(`#searchResult_${resultIndex}`);
    if (!checkbox) return;
    
    const index = parseInt(actualIndex);
    const text = checkbox.getAttribute('data-text');
    
    const item = { index: index, text: text };
    
    if (checkbox.checked) {
      // Add if not already selected
      const exists = window.selectedItems.some(sel => 
        sel.index === index
      );
      if (!exists) {
        window.selectedItems.push(item);
      }
    } else {
      // Remove if selected
      window.selectedItems = window.selectedItems.filter(sel => 
        !(sel.index === index)
      );
    }
    
    // Update preview
    updateSelectedPreview();
  };
  
  // Update selected items preview
  function updateSelectedPreview() {
    const previewDiv = document.querySelector('#selectedItemsPreview');
    const listDiv = document.querySelector('#selectedItemsList');
    
    if (window.selectedItems.length === 0) {
      previewDiv.style.display = 'none';
      listDiv.innerHTML = '';
    } else {
      previewDiv.style.display = 'block';
      
      let listHtml = '';
      window.selectedItems.forEach(item => {
        listHtml += `<div>`;
        listHtml += `[${item.index}] ${item.text.substring(0, 40)}${item.text.length > 40 ? '...' : ''}`;
        listHtml += `</div>`;
      });
      
      listDiv.innerHTML = listHtml;
    }
  }
  
  // Clear search
  window.clearSearch = function() {
    document.querySelector('#searchKeyword').value = '';
    document.querySelector('#searchResults').innerHTML = 
      '<p>è¾“å…¥å…³é”®è¯å¹¶ç‚¹å‡»æœç´¢</p>';
  };
  
  // View all indices
  window.viewAllIndices = function() {
    const resultsDiv = document.querySelector('#searchResults');
    let allItems = [];
    
    theme.forEach((item, index) => {
      allItems.push({
        index: index,
        text: item
      });
    });
    
    let resultsHtml = `<p>æ‰€æœ‰é¡¹ç›® (${allItems.length} ä¸ª):</p>`;

    allItems.forEach((result, i) => {
      const isSelected = window.selectedItems.some(sel => 
        sel.index === result.index
      );
      
      resultsHtml += `
        <div>
          <label>
            <input type="checkbox" 
                   id="allItem_${i}" 
                   data-index="${result.index}"
                   data-text="${result.text.replace(/"/g, '&quot;')}"
                   ${isSelected ? 'checked' : ''}
                   onchange="toggleAllItem(${i}, ${result.index})">
            <div>
              <span style="color: #2196F3; font-weight: bold;">[${result.index}]:</span>
              <span style="color: #333; margin-left: 5px;">${result.text.substring(0, 60)}${result.text.length > 60 ? '...' : ''}</span>
            </div>
          </label>
        </div>
      `;
    });
    
    resultsDiv.innerHTML = resultsHtml;
    
    // Update toggle function for all items
    window.toggleAllItem = function(itemIndex, actualIndex) {
      const checkbox = document.querySelector(`#allItem_${itemIndex}`);
      if (!checkbox) return;
      
      const index = parseInt(actualIndex);
      const text = checkbox.getAttribute('data-text');
      
      const item = { index: index, text: text };
      
      if (checkbox.checked) {
        const exists = window.selectedItems.some(sel => 
          sel.index === index
        );
        if (!exists) {
          window.selectedItems.push(item);
        }
      } else {
        window.selectedItems = window.selectedItems.filter(sel => 
          !(sel.index === index)
        );
      }
      
      updateSelectedPreview();
    };
  };
  
  // Confirm selections and combine with random
  window.confirmSearchSelections = function() {
    // Store selected items in local variable
    const selectedItemsCopy = [...window.selectedItems];
    
    if (selectedItemsCopy.length === 0) {
      alert('è¯·å…ˆé€‰æ‹©è‡³å°‘ä¸€ä¸ªé¡¹ç›®');
      return;
    }
    
    // Clean up first
    cleanupSearchFunctions();
    
    // Combine each selected item with a random other item
    selectedItemsCopy.forEach((item, index) => {
      setTimeout(() => {
        const result = combineWithRandom(item.text);
        // Display the result
        if (result) {
          const resultDiv = document.createElement('div');
          resultDiv.innerHTML = `${result}`;
          document.querySelector('#question').appendChild(resultDiv);
        }
      }, index * 100); // Stagger the results for better display
    });
  };

  // Cancel and use random selections
  window.cancelSearchSelections = function() {
    // Clean up first
    cleanupSearchFunctions();
    
    // Just combine two random items from the theme
    if (theme.length >= 2) {
      const randomIndex1 = Math.floor(Math.random() * theme.length);
      let randomIndex2;
      do {
        randomIndex2 = Math.floor(Math.random() * theme.length);
      } while (randomIndex2 === randomIndex1 && theme.length > 1);
      
      const result = combineWithRandom(theme[randomIndex1]);
      if (result) {
        const resultDiv = document.createElement('div');
        resultDiv.innerHTML = `<p>éšæœºç»„åˆç»“æœ: ${result}</p>`;
        document.querySelector('#question').appendChild(resultDiv);
      }
    } else {
      alert('ä¸»é¢˜æ•°ç»„ä¸­è‡³å°‘éœ€è¦2ä¸ªé¡¹ç›®æ‰èƒ½è¿›è¡Œç»„åˆ');
    }
  };
}

// Helper function to clean up
function cleanupSearchFunctions() {
  // Clean up global variables
  delete window.selectedItems;
  delete window.performSearch;
  delete window.toggleSearchItem;
  delete window.clearSearch;
  delete window.viewAllIndices;
  delete window.confirmSearchSelections;
  delete window.cancelSearchSelections;
  delete window.toggleAllItem;
  
  // Remove the search UI
  const searchUI = document.querySelector('#searchSelectionUI');
  if (searchUI) {
    searchUI.remove();
  }
}

// The original combineWithRandom function
function combineWithRandom(selectedString) {
    if (!selectedString || typeof selectedString !== 'string') {
        console.log('Please provide a valid selected string');
        return null;
    }
    
    // Check if the selected string exists in the theme array
    if (!theme.includes(selectedString)) {
        console.log('Selected string not found in theme array');
        return null;
    }
    
    // Filter out the selected string from possible random choices
    const otherOptions = theme.filter(item => item !== selectedString);
    
    if (otherOptions.length === 0) {
        console.log('No other options available to combine with');
        return selectedString;
    }
    
    // Randomly select another string
    const randomIndex = Math.floor(Math.random() * otherOptions.length);
    const randomString = otherOptions[randomIndex];
    
    // Join the two strings
    const combined = `${selectedString} ${randomString}`;
    
    console.log('Combined result:', combined);
    return combined;
}


  // åˆå§‹åŒ– Mermaidï¼Œè®¾ç½®é…ç½®
  mermaid.initialize({
    startOnLoad: true,  // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ¸²æŸ“å›¾è¡¨
    theme: 'default',   // ä¸»é¢˜ï¼ˆå¯é€‰ï¼šdefaultã€darkã€forestã€neutralï¼‰
    logLevel: 3         // æ—¥å¿—çº§åˆ«ï¼ˆ3=ä»…é”™è¯¯ï¼‰
  });
</script>

</body>
</html>
