// javascript Quiz Data
window.quizData = [
"<h3>find strings without tab character</h3>	noTabStrings = strings.filter(str => !str.includes('\t'));<br>console.log(noTabStrings)",
'<h2>JavaScript 间接使用 DeepSeek </h2>	<center><div id="间接使用DeepSeektoc" class="toc"><a href="#间接使用DeepSeektopic-0" target="_self">1. 使用 TensorFlow.js</a><br><a href="#间接使用DeepSeektopic-1" target="_self">2. 通过 API 调用 DeepSeek 服务</a><br><a href="#间接使用DeepSeektopic-2" target="_self">3. 在 Node.js 中调用 Python 脚本</a><br><a href="#间接使用DeepSeektopic-3" target="_self">4. 使用 WebAssembly (WASM)</a><br><a href="#间接使用DeepSeektopic-4" target="_self">5. 使用第三方 JavaScript 深度学习库</a><br><a href="#间接使用DeepSeektopic-5" target="_self">总结</a><br></div></center><br><br>\n\nJavaScript 本身并不直接支持深度学习框架（如 TensorFlow 或 PyTorch），但可以通过以下方式间接使用 DeepSeek 或类似的深度学习功能：\n\n<o id="间接使用DeepSeektopic-0">1. 使用 TensorFlow.js</o>\nTensorFlow.js 是一个 JavaScript 库，支持在浏览器和 Node.js 中运行深度学习模型。你可以使用 TensorFlow.js 加载和运行预训练的 DeepSeek 模型，或者在 JavaScript 中训练简单的模型。\n\n<lg>安装 TensorFlow.js</lg>\nnpm install @tensorflow/tfjs\n\n<lg>示例：加载预训练模型</lg>\nimport * as tf from \"@tensorflow/tfjs\";\n\n// 加载模型\nasync function loadModel() {\n const model = await tf.loadLayersModel(\"path/to/your/model.json\");\n return model;\n}\n\n// 使用模型进行预测\nasync function predict() {\n const model = await loadModel();\n const input = tf.tensor2d([[1, 2, 3, 4]]); // 输入数据\n const output = model.predict(input);\n output.print();\n}\n\npredict();\n\n<lg>训练简单模型</lg>\nconst model = tf.sequential();\nmodel.add(tf.layers.dense({ units: 10, inputShape: [5], activation: \"relu\" }));\nmodel.add(tf.layers.dense({ units: 1, activation: \"sigmoid\" }));\n\nmodel.compile({ optimizer: \"adam\", loss: \"binaryCrossentropy\", metrics: [\"accuracy\"] });\n\nconst x = tf.randomNormal([100, 5]);\nconst y = tf.randomUniform([100, 1]);\n\nmodel.fit(x, y, {\n epochs: 10,\n batchSize: 32,\n callbacks: {\n  onEpochEnd: (epoch, logs) =&gt; {\n   console.log(`Epoch ${epoch}: loss = ${logs.loss}`);\n  }\n }\n});\n\n<o id="间接使用DeepSeektopic-1">2. 通过 API 调用 DeepSeek 服务</o>\n如果 DeepSeek 提供了 RESTful API 或 GraphQL 接口，你可以使用 JavaScript 的 `fetch` 或 `axios` 调用这些服务。\n\n<lg>示例：调用 API</lg>\nasync function queryDeepSeek(input) {\n const response = await fetch(\"https://api.deepseek.com/predict\", {\n  method: \"POST\",\n  headers: {\n   \"Content-Type\": \"application/json\",\n   \"Authorization\": \"Bearer YOUR_API_KEY\"\n  },\n  body: JSON.stringify({ input: input })\n });\n const result = await response.json();\n return result;\n}\n\n// 使用\nqueryDeepSeek("Hello, DeepSeek!").then(response =&gt; {\n console.log(response);\n});\n\n<o id="间接使用DeepSeektopic-2">3. 在 Node.js 中调用 Python 脚本</o>\n如果 DeepSeek 的模型是用 Python 训练的，你可以通过 Node.js 调用 Python 脚本来运行模型。\n\n<lg>示例：使用 `child_process` 调用 Python</lg>\nconst { spawn } = require(\"child_process\");\n\nfunction runPythonScript(input) {\n const pythonProcess = spawn(\"python\", [\"path/to/your/script.py\", input]);\n\n pythonProcess.stdout.on(\"data\", (data) =&gt; {\n  console.log(`Python script output: ${data}`);\n });\n\n pythonProcess.stderr.on(\"data\", (data) =&gt; {\n  console.error(`Error: ${data}`);\n });\n}\n\n// 使用\nrunPythonScript("Hello, DeepSeek!");\n\n<lg>Python 脚本示例（`script.py`）</lg>\nimport sys\n\ninput_data = sys.argv[1]\n# 调用 DeepSeek 模型\nprint(f"Processed input: {input_data}")\n\n<o id="间接使用DeepSeektopic-3">4. 使用 WebAssembly (WASM)</o>\n如果你的 DeepSeek 模型可以编译为 WebAssembly，可以在 JavaScript 中加载并运行 WASM 模块。\n\n<lg>示例：加载 WASM 模块</lg>\nasync function loadWasm() {\n const response = await fetch(\"path/to/your/model.wasm\");\n const buffer = await response.arrayBuffer();\n const module = await WebAssembly.compile(buffer);\n const instance = await WebAssembly.instantiate(module);\n return instance;\n}\n\nloadWasm().then(instance =&gt; {\n const result = instance.exports.predict(42); // 调用 WASM 函数\n console.log(result);\n});\n\n<o id="间接使用DeepSeektopic-4">5. 使用第三方 JavaScript 深度学习库</o>\n除了 TensorFlow.js，还有一些其他 JavaScript 深度学习库可以使用：\n- Brain.js：简单的神经网络库。\n- Synaptic：灵活的神经网络库。\n- ML5.js：基于 TensorFlow.js 的高级库，适合初学者。\n\n<lg>示例：使用 Brain.js</lg>\nconst brain = require(\"brain.js\");\n\nconst net = new brain.NeuralNetwork();\nnet.train([\n { input: [0, 0], output: [0] },\n { input: [0, 1], output: [1] },\n { input: [1, 0], output: [1] },\n { input: [1, 1], output: [0] }\n]);\n\nconst output = net.run([1, 0]);\nconsole.log(output); // 输出预测结果\n\n<h3 id="间接使用DeepSeektopic-5">总结</h3>JavaScript 可以通过以下方式使用 DeepSeek 或类似功能：\n1. TensorFlow.js：在浏览器或 Node.js 中运行深度学习模型。\n2. API 调用：通过 RESTful API 或 GraphQL 调用 DeepSeek 服务。\n3. Node.js 调用 Python：通过 `child_process` 调用 Python 脚本。\n4. WebAssembly：加载和运行编译为 WASM 的模型。\n5. 第三方库：使用 Brain.js、Synaptic 或 ML5.js 等库。\n',
'<h2>使用以下javascript语句时，第一次点击目标能正常运作，再次点击失效</h2>	问题可能是由于事件绑定重复或元素状态变化导致的。\n以下是一些可能的解决方案：\n\n### 1. 使用 `on` 方法代替 `bind`\n`bind` 方法在 jQuery 1.7 之后已经被弃用，推荐使用 `on` 方法来绑定事件。\n`on` 方法更灵活，并且可以更好地处理动态添加的元素。\n\n$(\"#answer li\").on(\"click\", function (){\n selectedIs = $(this).index().toString();\n checkAnswer(selectedIs);\n});\n\n### 2. 确保事件只绑定一次\n如果你在代码中多次绑定了点击事件，可能会导致事件处理函数被多次调用。\n你可以使用 `off` 方法在绑定之前先解绑事件，确保事件只绑定一次。\n\n$(\"#answer li\").off(\"click\").on(\"click\", function (){\n selectedIs = $(this).index().toString();\n checkAnswer(selectedIs);\n});\n\n### 3. 检查元素状态\n如果点击后元素的属性或状态发生了变化（例如被禁用或移除），可能会导致事件无法再次触发。确保在点击后元素的状态没有发生意外的变化。\n\n### 4. 使用事件委托\n如果你在点击后动态添加或删除了 `#answer li` 元素，可以考虑使用事件委托来确保事件能够正确绑定到新添加的元素上。\n\n$(\"#answer\").on(\"click\", \"li\", function (){\n selectedIs = $(this).index().toString();\n checkAnswer(selectedIs);\n});\n\n### 5. 调试 `checkAnswer` 函数\n确保 `checkAnswer` 函数在每次点击时都能正确执行，并且没有抛出异常或导致其他问题。\n\n### 6. 检查其他代码\n确保没有其他代码干扰了点击事件的处理，例如阻止事件冒泡或默认行为。\n\n### 示例代码\n结合以上建议，你可以尝试以下代码：\n\n$(\"#answer\").on(\"click\", \"li\", function (){\n selectedIs = $(this).index().toString();\n checkAnswer(selectedIs);\n});\n\n这样可以确保事件绑定是稳定的，并且能够处理动态添加的元素。如果问题仍然存在，建议进一步检查 `checkAnswer` 函数和其他相关代码。\n\n出现 `Uncaught TypeError: $(...).on is not a function` 错误，通常是因为以下原因之一：\n\n### 1. **jQuery 库未正确加载**\n- `$` 是 jQuery 的别名，如果 `$` 未定义或 `on` 方法不存在，可能是因为 jQuery 库没有正确加载。\n- 确保你在使用 jQuery 代码之前已经正确引入了 jQuery 库。\n\n **解决方法：**\n 在 `&lt;head>` 或 `&lt;body>` 的顶部引入 jQuery 库。例如：\n\n &lt;head>\n  &lt;script src="https://code.jquery.com/jquery-3.7.1.min.js">&lt;/script>\n &lt;/head>\n\n 或者使用本地文件：\n\n &lt;head>\n  &lt;script src="path/to/your/jquery.min.js">&lt;/script>\n &lt;/head>\n\n **验证 jQuery 是否加载成功：**\n 在浏览器控制台中输入 `$` 或 `jQuery`，如果返回一个函数，说明 jQuery 已加载成功。\n\n### 2. **jQuery 版本过低**\n- `on` 方法是在 jQuery 1.7 版本中引入的。如果你使用的是较旧的 jQuery 版本（低于 1.7），`on` 方法将不可用。\n- 检查你的 jQuery 版本：\n\n console.log(jQuery.fn.jquery); // 输出当前 jQuery 版本\n\n **解决方法：**\n 升级到较新的 jQuery 版本（推荐 3.x 或更高版本）。可以通过以下方式引入最新版本：\n\n &lt;script src="https://code.jquery.com/jquery-3.7.1.min.js">&lt;/script>\n\n### 3. **与其他库冲突**\n- 如果你的页面中同时引入了其他 JavaScript 库（如 Prototype、MooTools 等），它们可能会占用 `$` 符号，导致 jQuery 无法正常工作。\n- 检查是否有其他库与 jQuery 冲突。\n\n **解决方法：**\n 使用 `jQuery` 代替 `$`，或者通过 `noConflict` 方法解决冲突：\n\n var $j = jQuery.noConflict(); // 释放 $ 符号\n $j(\"#answer li\").on(\"click\", function (){\n  selectedIs = $j(this).index().toString();\n  checkAnswer(selectedIs);\n });\n\n### 4. **代码执行顺序问题**\n- 如果你的 jQuery 代码在 DOM 元素加载之前执行，可能会导致 `$(\"#answer li\")` 找不到目标元素，从而引发错误。\n- 确保你的代码在 DOM 加载完成后执行。\n\n **解决方法：**\n 将代码放在 `$(document).ready()` 中：\n\n $(document).ready(function() {\n  $(\"#answer li\").on(\"click\", function (){\n   selectedIs = $(this).index().toString();\n   checkAnswer(selectedIs);\n  });\n });\n\n 或者使用简写：\n\n $(function() {\n  $(\"#answer li\").on(\"click\", function (){\n   selectedIs = $(this).index().toString();\n   checkAnswer(selectedIs);\n  });\n });\n\n### 5. **检查是否正确引入了 jQuery**\n- 如果你使用的是模块化开发（如 Webpack、ES Modules），可能需要通过 `import` 引入 jQuery。\n\n **解决方法：**\n 在模块化环境中，确保正确引入 jQuery：\n\n import $ from \"jquery\";\n\n $(document).ready(function() {\n  $(\"#answer li\").on(\"click\", function (){\n   selectedIs = $(this).index().toString();\n   checkAnswer(selectedIs);\n  });\n });\n\n### 6. **检查是否有拼写错误**\n- 确保代码中没有拼写错误，例如 `$` 被写成了其他字符，或者 `on` 被写成了其他方法。\n\n### 总结\n按照以下步骤排查问题：\n1. 确保 jQuery 库已正确加载。\n2. 确保 jQuery 版本 >= 1.7。\n3. 确保代码在 DOM 加载完成后执行（使用 `$(document).ready()`）。\n4. 检查是否有其他库与 jQuery 冲突。\n5. 如果问题仍未解决，提供更多上下文代码，我可以进一步帮助你排查问题。',
'<h2>自动下单</h2>	<div id="自动下单toc" class="toc"><a href="#自动下单topic-0" target="_self">1. 选择交易平台和API</a><br><a href="#自动下单topic-1" target="_self">2. 项目结构</a><br><a href="#自动下单topic-2" target="_self">3. 安装依赖</a><br><a href="#自动下单topic-3" target="_self">4. 配置文件 (config.js)</a><br><a href="#自动下单topic-4" target="_self">5. 主程序 (index.js)</a><br><a href="#自动下单topic-5" target="_self">6. 环境变量 (.env)</a><br><a href="#自动下单topic-6" target="_self">7. 运行程序</a><br><a href="#自动下单topic-7" target="_self">8. 进一步扩展</a><br><a href="#自动下单topic-8" target="_self">注意事项</a><br></div></center><br><br>\n\n自动下单是量化交易的核心功能之一，但实现自动下单需要与交易平台的API进行集成，并且需要处理许多安全和合规性问题。\n以下是一个基本的框架，展示如何使用JavaScript（结合Node.js）实现自动下单功能。\n<o id="自动下单topic-0">1. 选择交易平台和API</o>\n首先，选择一个支持API的交易平台（如Alpaca、Interactive Brokers、Binance等），并注册获取API密钥。\n<o id="自动下单topic-1">2. 项目结构</o>\n创建一个Node.js项目，结构如下：\nquant-trading/\n│\n├── index.js\n├── config.js\n├── package.json\n└── README.md\n<o id="自动下单topic-2">3. 安装依赖</o>\n在项目目录下运行以下命令来初始化项目并安装所需的依赖：\nnpm init -y\nnpm install axios dotenv\n<o id="自动下单topic-3">4. 配置文件 (config.js)</o>\n创建一个配置文件来存储API密钥和其他配置信息。\nrequire("dotenv").config();\nmodule.exports = {\n apiKey: process.env.API_KEY,\n apiSecret: process.env.API_SECRET,\n baseUrl: process.env.BASE_URL || "https://paper-api.alpaca.markets", // 使用Alpaca的模拟交易环境\n};\n<o id="自动下单topic-4">5. 主程序 (index.js)</o>\n编写主程序来处理自动下单逻辑。\nconst axios = require("axios");\nconst config = require("./config");\n\nconst BASE_URL = config.baseUrl;\nconst API_KEY = config.apiKey;\nconst API_SECRET = config.apiSecret;\n\nconst headers = {\n "APCA-API-KEY-ID": API_KEY,\n "APCA-API-SECRET-KEY": API_SECRET,\n};\n\nasync function placeOrder(symbol, qty, side, type = "market", time_in_force = "day") {\n const orderData = {\n  symbol: symbol,\n  qty: qty,\n  side: side,\n  type: type,\n  time_in_force: time_in_force,\n };\n\n try {\n  const response = await axios.post(`${BASE_URL}/v2/orders`, orderData, { headers });\n  console.log("Order placed successfully:", response.data);\n } catch (error) {\n  console.error("Error placing order:", error.response ? error.response.data : error.message);\n }\n}\n\n// 示例：买入10股AAPL\nplaceOrder("AAPL", 10, "buy");\n<o id="自动下单topic-5">6. 环境变量 (.env)</o>\n创建一个 `.env` 文件来存储敏感信息。\n\nAPI_KEY=your_api_key_here\nAPI_SECRET=your_api_secret_here\n<o id="自动下单topic-6">7. 运行程序</o>\n在项目目录下运行以下命令来启动程序：\nnode index.js\n<o id="自动下单topic-7">8. 进一步扩展</o>\n- **策略实现**：在自动下单之前，实现量化交易策略（如移动平均线交叉、动量策略等）。\n- **错误处理**：增加错误处理逻辑，确保程序在出现异常时能够正确处理。\n- **日志记录**：添加日志记录功能，方便调试和监控。\n- **安全性**：确保API密钥等敏感信息不会暴露在代码中，使用环境变量或密钥管理服务。\n<o id="自动下单topic-8">注意事项</o>\n- **模拟交易**：在实盘交易之前，建议先在模拟环境中测试你的策略和代码。\n- **合规性**：确保你的交易策略和自动下单程序符合相关法律法规和交易平台的使用条款。\n',
'<h2>如何自动才能下单</h2>	自动下单是量化交易的核心功能之一，但实现自动下单需要与交易平台的API进行集成，并且需要处理许多安全和合规性问题。\n\n以下是一个基本的框架，展示如何使用JavaScript（结合Node.js）实现自动下单功能。\n\n<h3>1. 选择交易平台和API</h3>首先，选择一个支持API的交易平台（如Alpaca、Interactive Brokers、Binance等），并注册获取API密钥。\n\n<h3>2. 项目结构</h3>创建一个Node.js项目，结构如下：\nquant-trading/\n│\n├── index.js\n├── config.js\n├── package.json\n└── README.md\n<h3>3. 安装依赖</h3>在项目目录下运行以下命令来初始化项目并安装所需的依赖：\nbash\nnpm init -y\nnpm install axios dotenv\n<h3>4. 配置文件 (config.js)</h3>创建一个配置文件来存储API密钥和其他配置信息。\n\njavascript\nrequire("dotenv").config();\nmodule.exports = {\n  apiKey: process.env.API_KEY,\n  apiSecret: process.env.API_SECRET,\n  baseUrl: process.env.BASE_URL || "https://paper-api.alpaca.markets", // 使用Alpaca的模拟交易环境\n};\n<h3>5. 主程序 (index.js)</h3>编写主程序来处理自动下单逻辑。\n\njavascript\nconst axios = require("axios");\nconst config = require("./config");\nconst BASE_URL = config.baseUrl;\nconst API_KEY = config.apiKey;\nconst API_SECRET = config.apiSecret;\nconst headers = {\n  "APCA-API-KEY-ID": API_KEY,\n  "APCA-API-SECRET-KEY": API_SECRET,\n};\nasync function placeOrder(symbol, qty, side, type = "market", time_in_force = "day") {\n  const orderData = {\n    symbol: symbol,\n    qty: qty,\n    side: side,\n    type: type,\n    time_in_force: time_in_force,\n  };\n  try {\n    const response = await axios.post(`${BASE_URL}/v2/orders`, orderData, { headers });\n    console.log("Order placed successfully:", response.data);\n  } catch (error) {\n    console.error("Error placing order:", error.response ? error.response.data : error.message);\n  }\n}\n// 示例：买入10股AAPL\nplaceOrder("AAPL", 10, "buy");\n<h3>6. 环境变量 (.env)</h3>创建一个 .env 文件来存储敏感信息。\n\nAPI_KEY=your_api_key_here\nAPI_SECRET=your_api_secret_here\n<h3>7. 运行程序</h3>在项目目录下运行以下命令来启动程序：\nbash\nnode index.js\n<h3>8. 进一步扩展</h3><pk>策略实现</pk>：在自动下单之前，实现量化交易策略（如移动平均线交叉、动量策略等）。\n\n<pk>错误处理</pk>：增加错误处理逻辑，确保程序在出现异常时能够正确处理。\n\n<pk>日志记录</pk>：添加日志记录功能，方便调试和监控。\n\n<pk>安全性</pk>：确保API密钥等敏感信息不会暴露在代码中，使用环境变量或密钥管理服务。\n\n<h3>注意事项</h3><pk>模拟交易</pk>：在实盘交易之前，建议先在模拟环境中测试你的策略和代码。\n\n<pk>合规性</pk>：确保你的交易策略和自动下单程序符合相关法律法规和交易平台的使用条款。\n\n通过以上步骤，你可以实现一个基本的自动下单功能，并根据需求进一步扩展和优化。\n\n',
'<h2>javascript OCR</h2>	在JavaScript中进行PDF文件的中文文字识别（OCR），可以通过以下步骤实现。\n\nJavaScript本身没有内置的OCR功能，但可以借助一些库和工具来实现，例如：\n<pk>Tesseract.js</pk>：一个基于Tesseract OCR的JavaScript库。\n\n<pk>PDF.js</pk>：用于将PDF文件渲染为图像。\n\n<pk>在线OCR API</pk>：如百度OCR、腾讯OCR等。\n\n以下是使用Tesseract.js和PDF.js实现PDF中文OCR的详细步骤。\n\n<h3>1. 使用Tesseract.js进行OCR</h3>Tesseract.js是一个基于WebAssembly的OCR库，支持在浏览器中直接运行。\n\n<h4>安装Tesseract.js</h4>在项目中安装Tesseract.js：\nbash\n\nnpm install tesseract.js\n\n或者直接在HTML中引入：\n\n&lt;script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js">&lt;/script>\n\nRun HTML\n\n<h3>2. 使用PDF.js将PDF渲染为图像</h3>PDF.js是Mozilla开发的一个PDF渲染库，可以将PDF页面渲染为Canvas图像。\n\n<h4>安装PDF.js</h4>在项目中安装PDF.js：\nbash\n\nnpm install pdfjs-dist\n\n或者直接在HTML中引入：\n\n&lt;script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js">&lt;/script>\n\nRun HTML\n\n<h3>3. 实现PDF中文OCR</h3>以下是一个完整的示例代码，展示如何将PDF文件渲染为图像并使用Tesseract.js进行OCR。\n\n<h4>HTML部分</h4>html\n\n&lt;!DOCTYPE html>\n&lt;html lang="en">\n&lt;head>\n &lt;meta charset="UTF-8">\n &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">\n &lt;title>PDF中文OCR&lt;/title>\n &lt;script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js">&lt;/script>\n &lt;script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js">&lt;/script>\n&lt;/head>\n&lt;body>\n &lt;h1>PDF中文OCR示例&lt;/h1>\n &lt;input type="file" accept="application/pdf" />\n &lt;button onclick="processPDF()">开始识别&lt;/button>\n &lt;pre>&lt;/pre>\n &lt;script>\n  async function processPDF() {\n   const file = document.getElementById("pdfInput").files[0];\n   if (!file) {\n    alert("请选择一个PDF文件");\n    return;\n   }\n   const fileReader = new FileReader();\n   fileReader.onload = async function (event) {\n    const pdfData = new Uint8Array(event.target.result);\n    // 加载PDF文件\n    const loadingTask = pdfjsLib.getDocument({ data: pdfData });\n    const pdf = await loadingTask.promise;\n    // 初始化Tesseract\n    const worker = await Tesseract.createWorker({\n     logger: (m) => console.log(m),\n    });\n    await worker.loadLanguage("chi_sim");\n    await worker.initialize("chi_sim");\n    let fullText = ";\n    // 遍历每一页\n    for (let pageNum = 1; pageNum &lt;= pdf.numPages; pageNum++) {\n     const page = await pdf.getPage(pageNum);\n     const viewport = page.getViewport({ scale: 2.0 });\n     const canvas = document.createElement("canvas");\n     const context = canvas.getContext("2d");\n     canvas.height = viewport.height;\n     canvas.width = viewport.width;\n     // 渲染PDF页面为图像\n     await page.render({ canvasContext: context, viewport }).promise;\n     // 使用Tesseract进行OCR\n     const { data: { text } } = await worker.recognize(canvas);\n     fullText += text + "\n";\n    }\n    // 显示识别结果\n    document.getElementById("output").textContent = fullText;\n    // 关闭Tesseract Worker\n    await worker.terminate();\n   };\n   fileReader.readAsArrayBuffer(file);\n  }\n &lt;/script>\n&lt;/body>\n&lt;/html>\n\nRun HTML\n\n<h3>4. 代码说明</h3><pk>PDF文件选择</pk>：通过&lt;input type="file">选择PDF文件。\n\n<pk>PDF渲染</pk>：使用PDF.js将PDF页面渲染为Canvas图像。\n\n<pk>OCR识别</pk>：使用Tesseract.js对Canvas图像进行OCR识别。\n\n<pk>结果显示</pk>：将识别结果输出到页面上。\n\n<h3>5. 注意事项</h3><pk>性能问题</pk>：对于较大的PDF文件，OCR处理可能会较慢，建议分页处理。\n\n<pk>语言支持</pk>：确保Tesseract.js加载了中文语言包（chi_sim或chi_tra）。\n\n<pk>浏览器兼容性</pk>：Tesseract.js和PDF.js依赖于WebAssembly，确保使用现代浏览器（如Chrome、Firefox、Edge）。\n\n<h3>6. 使用在线OCR API（可选）</h3>如果需要更高的识别精度或处理大量文件，可以使用在线OCR API（如百度OCR或腾讯OCR）。\n\n以下是调用百度OCR API的示例：\n<h4>安装Axios（用于HTTP请求）</h4>bash\n\nnpm install axios\n\n<h4>调用百度OCR API</h4>javascript\n\nconst axios = require("axios");\nconst fs = require("fs");\nasync function baiduOCR(imagePath) {\n const accessToken = "你的百度API Access Token";\n const url = `https://aip.baidubce.com/rest/2.0/ocr/v1/general_basic?access_token=${accessToken}`;\n const image = fs.readFileSync(imagePath, { encoding: "base64" });\n const response = await axios.post(url, { image }, {\n  headers: { "Content-Type": "application/x-www-form-urlencoded" },\n });\n return response.data.words_result.map((item) => item.words).join("\n");\n}\n// 示例调用\nbaiduOCR("example.png").then((text) => console.log(text));\n\n通过以上方法，你可以在JavaScript中实现PDF文件的中文文字识别。\n\n根据需求选择适合的工具和方案。',
'<h2>JavaScript密码认证</h2>	以下是一個簡單的 JavaScript 程式，用來驗證用戶密碼。\n這個範例假設你已經有一個存儲在資料庫或某處的哈希密碼，並且使用 bcrypt 來進行密碼的哈希比對。\n\n<h3>1. 安裝 bcrypt</h3>首先，你需要安裝 bcrypt 套件。\n你可以使用 npm 來安裝：\n\nnpm install bcrypt\n\n<h3>2. JavaScript 程式碼範例</h3>javascript\nconst bcrypt = require("bcrypt");\n// 假設這是從資料庫中獲取的哈希密碼\nconst storedHash = "$2b$10$examplehashfromdatabase";\n// 用戶輸入的密碼\nconst userInputPassword = "userPassword123";\n// 驗證密碼\nbcrypt.compare(userInputPassword, storedHash, function(err, result) {\n  if (err) {\n    console.error("驗證過程中發生錯誤:", err);\n    return;\n  }\n  if (result) {\n    console.log("密碼正確，認證成功！");\n  } else {\n    console.log("密碼錯誤，認證失敗！");\n  }\n});\n\n<h3>3. 程式碼解釋</h3>bcrypt.compare: 這個函數用於比對用戶輸入的密碼和存儲的哈希密碼。\n它會返回一個布林值 (true 或 false)，表示密碼是否匹配。\n\nstoredHash: 這是從資料庫中獲取的哈希密碼。\n通常，這個哈希密碼是在用戶註冊時使用 bcrypt.hash 生成的。\n\nuserInputPassword: 這是用戶在登錄時輸入的密碼。\n\n<h3>4. 注意事項</h3>安全性: 永遠不要在資料庫中存儲明文密碼。\n使用 bcrypt 或其他安全的哈希算法來存儲密碼。\n\n錯誤處理: 在實際應用中，請確保處理所有可能的錯誤情況，例如資料庫連接失敗、哈希比對失敗等。\n\n<h3>5. 進一步改進</h3>Salt Rounds: 在生成哈希密碼時，可以指定 saltRounds 來增加安全性。\n例如：\n\nconst saltRounds = 10;\nbcrypt.hash(userInputPassword, saltRounds, function(err, hash) {\n  // 存儲 hash 到資料庫\n});\n這個範例應該能幫助你開始實現用戶密碼認證功能。\n如果你有更多需求或問題，請隨時告訴我！\n\n',
'<h2>get array loaded from url script.onload</h2>	在 JavaScript 中，你可以使用 XMLHttpRequest 或 fetch API 來從 URL 加載數據，並在加載完成後將其存儲到一個數組中。\n以下是一個使用 fetch API 的範例，展示如何在 script.onload 的類似情境下加載數據並將其存儲到數組中。\n\n<h3>使用 fetch API 加載數據並存儲到數組</h3>javascript\n<dg>// 定義一個數組來存儲加載的數據</dg>\nlet loadedDataArray = [];\n<dg>// URL 從中加載數據</dg>\nconst dataUrl = "https://example.com/api/data";\n<dg>// 使用 fetch API 加載數據</dg>\nfetch(dataUrl)\n .then(response => {\n  if (!response.ok) {\n   throw new Error("網絡響應不正常");\n  }\n  return response.json(); <dg>// 假設數據是 JSON 格式</dg>\n })\n .then(data => {\n  <dg>// 將加載的數據存儲到數組中</dg>\n  loadedDataArray = data;\n  console.log("數據加載完成:", loadedDataArray);\n })\n .catch(error => {\n  console.error("加載數據時發生錯誤:", error);\n });\n\n<h3>使用 XMLHttpRequest 加載數據並存儲到數組</h3>如果你更喜歡使用 XMLHttpRequest，以下是一個範例：\n<dg>// 定義一個數組來存儲加載的數據</dg>\nlet loadedDataArray = [];\n<dg>// URL 從中加載數據</dg>\nconst dataUrl = "https://example.com/api/data";\n<dg>// 創建一個新的 XMLHttpRequest 對象</dg>\nconst xhr = new XMLHttpRequest();\n<dg>// 設置請求和響應類型</dg>\nxhr.open("GET", dataUrl, true);\nxhr.responseType = "json";\n<dg>// 定義加載完成後的回調函數</dg>\nxhr.onload = function() {\n if (xhr.status === 200) {\n  <dg>// 將加載的數據存儲到數組中</dg>\n  loadedDataArray = xhr.response;\n  console.log("數據加載完成:", loadedDataArray);\n } else {\n  console.error("加載數據時發生錯誤:", xhr.statusText);\n }\n};\n<dg>// 定義錯誤處理</dg>\nxhr.onerror = function() {\n console.error("請求失敗");\n};\n<dg>// 發送請求</dg>\nxhr.send();\n\n<h3>解釋</h3>fetch API: 這是一個現代化的方法來進行網絡請求，並且返回一個 Promise，使得代碼更加簡潔和易讀。\n\nXMLHttpRequest: 這是一個較舊的方法，但仍然廣泛使用，特別是在需要更多控制請求的情況下。\n\nresponse.json(): 這個方法用於將響應解析為 JSON 格式。\n\nxhr.responseType = "json": 這個屬性設置響應類型為 JSON，這樣 xhr.response 將自動解析為 JavaScript 對象。\n\n<h3>注意事項</h3>跨域請求: 如果數據來源於不同的域名，請確保服務器支持 CORS（跨域資源共享）。\n\n錯誤處理: 在實際應用中，請確保處理所有可能的錯誤情況，例如網絡錯誤、解析錯誤等。\n\n這個範例應該能幫助你從 URL 加載數據並將其存儲到數組中。\n如果你有更多需求或問題，請隨時告訴我！\n\n',
'<h2>get array in browser</h2>	在瀏覽器中使用 JavaScript 從 URL 加載數據並存儲到數組中，可以直接使用 fetch 或 XMLHttpRequest，因為這些都是瀏覽器內置的 API。\n以下是一個完整的範例，展示如何在瀏覽器中實現這一功能。\n<h3>使用 fetch API 在瀏覽器中加載數據</h3>html\n &lt;button>加載數據&lt;/button>\n &lt;pre>&lt;/pre>\n  // 定義一個數組來存儲加載的數據\n  let loadedDataArray = [];\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", async () => {\n   try {\n// 使用 fetch API 加載數據\nconst response = await fetch(dataUrl);\nif (!response.ok) {\nthrow new Error("網絡響應不正常");\n}\n// 解析 JSON 數據\nconst data = await response.json();\n// 將加載的數據存儲到數組中\nloadedDataArray = data;\n// 顯示數據\noutputElement.textContent = JSON.stringify(loadedDataArray, null, 2);\nconsole.log("數據加載完成:", loadedDataArray);\n   } catch (error) {\nconsole.error("加載數據時發生錯誤:", error);\noutputElement.textContent = "加載數據時發生錯誤: " + error.message;\n   }\n  });\n<h3>使用 XMLHttpRequest 在瀏覽器中加載數據</h3>如果你更喜歡使用 XMLHttpRequest，以下是範例：\n &lt;button>加載數據&lt;/button>\n &lt;pre>&lt;/pre>\n  // 定義一個數組來存儲加載的數據\n  let loadedDataArray = [];\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", () => {\n   // 創建一個新的 XMLHttpRequest 對象\n   const xhr = new XMLHttpRequest();\n   // 設置請求和響應類型\n   xhr.open("GET", dataUrl, true);\n   xhr.responseType = "json";\n   // 定義加載完成後的回調函數\n   xhr.onload = function () {\nif (xhr.status === 200) {\n// 將加載的數據存儲到數組中\nloadedDataArray = xhr.response;\n// 顯示數據\noutputElement.textContent = JSON.stringify(loadedDataArray, null, 2);\nconsole.log("數據加載完成:", loadedDataArray);\n} else {\nconsole.error("加載數據時發生錯誤:", xhr.statusText);\noutputElement.textContent = "加載數據時發生錯誤: " + xhr.statusText;\n}\n   };\n   // 定義錯誤處理\n   xhr.onerror = function () {\nconsole.error("請求失敗");\noutputElement.textContent = "請求失敗";\n   };\n   // 發送請求\n   xhr.send();\n  });\n<h3>範例說明</h3>fetch API:\n使用 fetch 加載數據，並使用 await 等待響應。\n\n解析 JSON 數據並存儲到數組中。\n\n將數據顯示在頁面上。\n\nXMLHttpRequest:\n使用 XMLHttpRequest 加載數據。\n\n設置 responseType 為 json，以便自動解析 JSON 數據。\n\n將數據存儲到數組中並顯示在頁面上。\n\n按鈕觸發:\n點擊按鈕時觸發數據加載。\n\n加載的數據會顯示在 &lt;pre> 標籤中。\n\n範例 API:\n使用 <a href="https://jsonplaceholder.typicode.com/posts" target="_blank" rel="noreferrer">JSONPlaceholder</a> 作為範例 API，它返回一個包含多個對象的數組。\n\n<h3>運行方式</h3>將上述代碼保存為一個 HTML 文件（例如 index.html）。\n\n在瀏覽器中打開該文件。\n\n點擊「加載數據」按鈕，數據將從 URL 加載並顯示在頁面上。\n\n<h3>注意事項</h3>跨域問題:\n如果數據來源於不同的域名，請確保服務器支持 CORS（跨域資源共享）。\n\n如果無法控制服務器，可以考慮使用代理服務器或 JSONP（僅限 XMLHttpRequest）。\n\n錯誤處理:\n在實際應用中，請確保處理所有可能的錯誤情況，例如網絡錯誤、解析錯誤等。\n',
'<h2>assign array to an array loaded from url with array name</h2>	如果你想將從 URL 加載的數據存儲到一個具有特定名稱的數組中，並且在加載之前將該數組初始化為空數組，可以按照以下步驟實現。\n\n以下是完整的範例，展示如何在瀏覽器中加載數據並將其存儲到一個特定名稱的數組中：\n<h3>範例：加載數據並存儲到特定名稱的數組</h3> &lt;button>加載數據&lt;/button>\n &lt;pre>&lt;/pre>\n &lt;script>\n  // 定義一個特定名稱的數組，並初始化為空數組\n  let myDataArray = [];\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", async () => {\n   try {\n// 初始化數組為空數組\nmyDataArray = [];\n// 使用 fetch API 加載數據\nconst response = await fetch(dataUrl);\nif (!response.ok) {\nthrow new Error("網絡響應不正常");\n}\n// 解析 JSON 數據\nconst data = await response.json();\n// 將加載的數據存儲到特定名稱的數組中\nmyDataArray = data;\n// 顯示數據\noutputElement.textContent = JSON.stringify(myDataArray, null, 2);\nconsole.log("數據加載完成:", myDataArray);\n   } catch (error) {\nconsole.error("加載數據時發生錯誤:", error);\noutputElement.textContent = "加載數據時發生錯誤: " + error.message;\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>初始化數組:\n在腳本開始時，定義一個名為 myDataArray 的數組，並將其初始化為空數組：\nlet myDataArray = [];\n\n加載數據前重置數組:\n在點擊按鈕時，先將 myDataArray 重置為空數組：\nmyDataArray = [];\n\n加載數據並存儲到數組:\n使用 fetch API 從 URL 加載數據，並將數據存儲到 myDataArray 中：\nmyDataArray = data;\n\n顯示數據:\n將加載的數據顯示在頁面上，並輸出到控制台以便調試。\n\n<h3>運行方式</h3>將上述代碼保存為一個 HTML 文件（例如 index.html）。\n\n在瀏覽器中打開該文件。\n\n點擊「加載數據」按鈕，數據將從 URL 加載並存儲到 myDataArray 中，同時顯示在頁面上。\n\n<h3>進階：動態指定數組名稱</h3>如果你希望動態指定數組名稱（例如根據用戶輸入或其他條件），可以使用 JavaScript 的物件來實現。\n例如：\nconst dataContainer = {}; // 用於存儲多個數組\nconst arrayName = "myDataArray"; // 動態數組名稱\n// 初始化數組\ndataContainer[arrayName] = [];\n// 加載數據並存儲到動態名稱的數組中\ndataContainer[arrayName] = data;\n這樣，你可以根據需要動態創建和管理多個數組。\n',
'<h2>get the array name loaded from url with complete array included</h2>	在 JavaScript 中，數組本身並沒有「名稱」的概念。\n數組只是一個值，而名稱是變數或物件屬性的標識符。\n如果你想從 URL 加載數據並將其存儲到一個特定名稱的數組中，同時還想獲取該數組的名稱，可以通過以下方式實現：\n\n<h3>方法 1：使用物件來存儲數組並保留名稱</h3>你可以使用一個物件來存儲數組，並將數組名稱作為物件的鍵。\n這樣，你既可以保留數組的名稱，也可以輕鬆訪問數組的內容。\n\n<h4>範例程式碼</h4> &lt;button>加載數據&lt;/button>\n &lt;pre>&lt;/pre>\n  // 使用物件來存儲數組\n  const dataContainer = {};\n  // 定義數組名稱\n  const arrayName = "myDataArray";\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", async () => {\n   try {\n// 初始化數組為空數組\ndataContainer[arrayName] = [];\n// 使用 fetch API 加載數據\nconst response = await fetch(dataUrl);\nif (!response.ok) {\nthrow new Error("網絡響應不正常");\n}\n// 解析 JSON 數據\nconst data = await response.json();\n// 將加載的數據存儲到特定名稱的數組中\ndataContainer[arrayName] = data;\n// 顯示數組名稱和數據\noutputElement.textContent = `數組名稱: ${arrayName}\n數據內容: ${JSON.stringify(dataContainer[arrayName], null, 2)}`;\nconsole.log("數組名稱:", arrayName);\nconsole.log("數據加載完成:", dataContainer[arrayName]);\n   } catch (error) {\nconsole.error("加載數據時發生錯誤:", error);\noutputElement.textContent = "加載數據時發生錯誤: " + error.message;\n   }\n  });\n<h3>程式碼說明</h3>使用物件存儲數組:\n創建一個物件 dataContainer，用於存儲數組。\n\n將數組名稱作為物件的鍵，例如 dataContainer["myDataArray"]。\n\n動態初始化數組:\n在加載數據之前，將數組初始化為空數組：\ndataContainer[arrayName] = [];\n\n加載數據並存儲到數組:\n使用 fetch API 加載數據，並將其存儲到 dataContainer[arrayName] 中。\n\n顯示數組名稱和數據:\n將數組名稱和數據內容顯示在頁面上。\n\n<h3>方法 2：直接使用變數名稱</h3>如果你希望直接使用變數名稱來存儲數組，可以通過以下方式實現：\n<h4>範例程式碼</h4>// 定義數組名稱\nconst arrayName = "myDataArray";\n// 創建一個全域變數來存儲數組\nwindow[arrayName] = [];\n// 加載數據並存儲到數組中\nfetch("https://jsonplaceholder.typicode.com/posts")\n .then(response => response.json())\n .then(data => {\n  window[arrayName] = data;\n  console.log("數組名稱:", arrayName);\n  console.log("數據內容:", window[arrayName]);\n })\n .catch(error => {\n  console.error("加載數據時發生錯誤:", error);\n });\n\n<h3>程式碼說明</h3>使用 window 物件:\n在瀏覽器中，window 是全域物件，可以通過 window[arrayName] 動態創建全域變數。\n\n動態存儲數組:\n將加載的數據存儲到 window[arrayName] 中。\n\n訪問數組:\n你可以通過 window[arrayName] 或直接使用 myDataArray 來訪問數組。\n\n<h3>總結</h3>如果你需要保留數組名稱並動態管理多個數組，建議使用 物件 來存儲數組。\n\n如果你只需要一個全域變數來存儲數組，可以使用 window 物件 動態創建變數。\n\n希望這些方法能幫助你實現需求！如果有其他問題，請隨時告訴我。',
'<h2>how to list all array names in webpage</h2>	在 JavaScript 中，數組本身並沒有「名稱」的概念，因為數組只是值，而名稱是變數或物件屬性的標識符。\n如果你想在網頁上列出所有數組的名稱，你需要將這些數組存儲在一個結構中（例如物件），然後從該結構中提取名稱。\n以下是實現方法：\n<h3>方法 1：使用物件存儲數組並列出名稱</h3>將所有數組存儲在一個物件中，然後遍歷物件的鍵（即數組名稱）並顯示在網頁上。\n<h4>範例程式碼</h4> &lt;button>加載數據&lt;/button>\n &lt;h2>數組名稱列表：&lt;/h2>\n &lt;ul>&lt;/ul>\n &lt;pre>&lt;/pre>\n &lt;script>\n  // 使用物件來存儲數組\n  const dataContainer = {\n   myDataArray1: [],\n   myDataArray2: [],\n   myDataArray3: []\n  };\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const arrayNamesList = document.getElementById("arrayNamesList");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", async () => {\n   try {\n// 使用 fetch API 加載數據\nconst response = await fetch(dataUrl);\nif (!response.ok) {\nthrow new Error("網絡響應不正常");\n}\n// 解析 JSON 數據\nconst data = await response.json();\n// 將加載的數據存儲到第一個數組中\ndataContainer.myDataArray1 = data;\n// 列出所有數組名稱\narrayNamesList.innerHTML = "; // 清空列表\nfor (const arrayName in dataContainer) {\nconst listItem = document.createElement("li");\nlistItem.textContent = arrayName;\narrayNamesList.appendChild(listItem);\n}\n// 顯示數據\noutputElement.textContent = JSON.stringify(dataContainer, null, 2);\nconsole.log("數據加載完成:", dataContainer);\n   } catch (error) {\nconsole.error("加載數據時發生錯誤:", error);\noutputElement.textContent = "加載數據時發生錯誤: " + error.message;\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>使用物件存儲數組: 創建一個物件 dataContainer，並將數組存儲為物件的屬性。\n例如：\nconst dataContainer = {\n myDataArray1: [],\n myDataArray2: [],\n myDataArray3: []\n};\n\n列出數組名稱: 使用 for...in 迴圈遍歷物件的鍵（即數組名稱）。\n\n將每個名稱添加到網頁上的列表中。\n\n加載數據: 使用 fetch API 加載數據，並將其存儲到其中一個數組中。\n\n顯示數據: 將整個物件的內容顯示在網頁上。\n\n<h3>方法 2：使用全域變數並列出名稱</h3>如果你將數組存儲為全域變數，可以使用 window 物件來列出所有數組名稱。\n\n<h4>範例程式碼</h4> &lt;button>加載數據&lt;/button>\n &lt;h2>數組名稱列表：&lt;/h2>\n &lt;ul>&lt;/ul>\n &lt;pre>&lt;/pre>\n &lt;script>\n  // 定義全域變數來存儲數組\n  const myDataArray1 = [];\n  const myDataArray2 = [];\n  const myDataArray3 = [];\n  // URL 從中加載數據\n  const dataUrl = "https://jsonplaceholder.typicode.com/posts"; // 範例 API\n  // 獲取按鈕和輸出元素\n  const loadDataButton = document.getElementById("loadDataButton");\n  const arrayNamesList = document.getElementById("arrayNamesList");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載數據\n  loadDataButton.addEventListener("click", async () => {\n   try {\n// 使用 fetch API 加載數據\nconst response = await fetch(dataUrl);\nif (!response.ok) {\nthrow new Error("網絡響應不正常");\n}\n// 解析 JSON 數據\nconst data = await response.json();\n// 將加載的數據存儲到第一個數組中\nmyDataArray1.push(...data);\n// 列出所有數組名稱\narrayNamesList.innerHTML = "; // 清空列表\nfor (const variableName in window) {\nif (window[variableName] instanceof Array) {\nconst listItem = document.createElement("li");\nlistItem.textContent = variableName;\narrayNamesList.appendChild(listItem);\n}\n}\n// 顯示數據\noutputElement.textContent = JSON.stringify({ myDataArray1, myDataArray2, myDataArray3 }, null, 2);\nconsole.log("數據加載完成:", { myDataArray1, myDataArray2, myDataArray3 });\n   } catch (error) {\nconsole.error("加載數據時發生錯誤:", error);\noutputElement.textContent = "加載數據時發生錯誤: " + error.message;\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>使用全域變數: 將數組存儲為全域變數（例如 myDataArray1、myDataArray2 等）。\n\n列出數組名稱: 使用 for...in 迴圈遍歷 window 物件，檢查每個屬性是否為數組。\n\n如果是數組，則將其名稱添加到網頁上的列表中。\n\n加載數據: 使用 fetch API 加載數據，並將其存儲到其中一個數組中。\n\n顯示數據: 將所有數組的內容顯示在網頁上。\n<h3>總結</h3>如果你需要動態管理數組並列出名稱，建議使用 物件 來存儲數組。\n如果你使用全域變數，可以通過遍歷 window 物件來列出數組名稱。\n',
'<h2>to wait script.onload finish and then action</h2>	在 JavaScript 中，如果你想等待一個動態加載的腳本（例如通過 script.onload）完成加載後再執行某些操作，可以使用 script.onload 事件來確保腳本已經加載完成。\n以下是一個完整的範例，展示如何等待腳本加載完成後再執行後續操作。\n<h3>範例：等待腳本加載完成後執行操作</h3> &lt;button>加載腳本&lt;/button>\n &lt;div>&lt;/div>\n &lt;script>\n  // 獲取按鈕和輸出元素\n  const loadScriptButton = document.getElementById("loadScriptButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載腳本\n  loadScriptButton.addEventListener("click", () => {\n   // 創建一個新的 script 元素\n   const script = document.createElement("script");\n   script.src = "https://example.com/your-script.js"; // 替換為你的腳本 URL\n   script.type = "text/javascript";\n   // 定義 onload 事件處理程序\n   script.onload = function () {\noutputElement.textContent = "腳本加載完成，執行後續操作！";\nconsole.log("腳本加載完成，執行後續操作！");\n// 在這裡執行你的後續操作\nyourFunctionFromScript(); // 假設腳本中有這個函數\n   };\n   // 定義 onerror 事件處理程序\n   script.onerror = function () {\noutputElement.textContent = "腳本加載失敗！";\nconsole.error("腳本加載失敗！");\n   };\n   // 將 script 元素添加到文檔中\n   document.head.appendChild(script);\n  });\n &lt;/script>\n<h3>程式碼說明</h3>動態加載腳本:\n使用 document.createElement("script") 創建一個新的 &lt;script> 元素。\n\n設置 script.src 為要加載的腳本 URL。\n\n設置 script.type 為 text/javascript（可選，默認為此類型）。\n\n等待腳本加載完成:\n使用 script.onload 事件來監聽腳本加載完成的事件。\n\n在 onload 事件處理程序中，執行後續操作。\n\n處理加載錯誤:\n使用 script.onerror 事件來監聽腳本加載失敗的情況。\n\n將腳本添加到文檔中:\n使用 document.head.appendChild(script) 將腳本添加到文檔的 &lt;head> 中，觸發加載。\n\n<h3>進階：使用 Promise 封裝腳本加載</h3>如果你希望更優雅地處理腳本加載，可以使用 Promise 來封裝腳本加載邏輯。\n\n<h4>範例程式碼</h4> &lt;button>加載腳本&lt;/button>\n &lt;div>&lt;/div>\n &lt;script>\n  // 獲取按鈕和輸出元素\n  const loadScriptButton = document.getElementById("loadScriptButton");\n  const outputElement = document.getElementById("output");\n  // 封裝腳本加載邏輯為 Promise\n  function loadScript(src) {\n   return new Promise((resolve, reject) => {\nconst script = document.createElement("script");\nscript.src = src;\nscript.type = "text/javascript";\nscript.onload = () => resolve(script);\nscript.onerror = () => reject(new Error(`腳本加載失敗: ${src}`));\ndocument.head.appendChild(script);\n   });\n  }\n  // 點擊按鈕時加載腳本\n  loadScriptButton.addEventListener("click", async () => {\n   try {\n// 加載腳本\nawait loadScript("https://example.com/your-script.js"); // 替換為你的腳本 URL\noutputElement.textContent = "腳本加載完成，執行後續操作！";\nconsole.log("腳本加載完成，執行後續操作！");\n// 在這裡執行你的後續操作\nyourFunctionFromScript(); // 假設腳本中有這個函數\n   } catch (error) {\noutputElement.textContent = error.message;\nconsole.error(error);\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>封裝為 Promise:\n將腳本加載邏輯封裝為一個 loadScript 函數，返回一個 Promise。\n\n如果腳本加載成功，調用 resolve；\n如果加載失敗，調用 reject。\n\n使用 async/await:\n在按鈕點擊事件處理程序中使用 async/await 來等待腳本加載完成。\n\n如果加載成功，執行後續操作；\n如果加載失敗，捕獲錯誤並顯示錯誤信息。\n\n<h3>總結</h3>使用 script.onload 可以確保腳本加載完成後再執行後續操作。\n使用 Promise 封裝腳本加載邏輯，可以使代碼更簡潔和易於維護。\n',
'<h2>how to 使用 Promise 封裝腳本加載</h2>	使用 Promise 封裝腳本加載是一種非常優雅的方式，可以讓你的代碼更具可讀性和可維護性。\n通過 Promise，你可以輕鬆地處理腳本加載的成功和失敗情況，並使用 async/await 來簡化異步操作。\n\n以下是完整的範例，展示如何使用 Promise 封裝腳本加載：\n\n<h3>範例：使用 Promise 封裝腳本加載</h3> &lt;button>加載腳本&lt;/button>\n &lt;div>&lt;/div>\n &lt;script>\n  // 獲取按鈕和輸出元素\n  const loadScriptButton = document.getElementById("loadScriptButton");\n  const outputElement = document.getElementById("output");\n  // 封裝腳本加載邏輯為 Promise\n  function loadScript(src) {\n   return new Promise((resolve, reject) => {\n// 創建一個新的 script 元素\nconst script = document.createElement("script");\nscript.src = src;\nscript.type = "text/javascript";\n// 定義 onload 事件處理程序\nscript.onload = () => {\nconsole.log(`腳本加載成功: ${src}`);\nresolve(script); // 腳本加載成功，調用 resolve\n};\n// 定義 onerror 事件處理程序\nscript.onerror = () => {\nconsole.error(`腳本加載失敗: ${src}`);\nreject(new Error(`腳本加載失敗: ${src}`)); // 腳本加載失敗，調用 reject\n};\n// 將 script 元素添加到文檔中\ndocument.head.appendChild(script);\n   });\n  }\n  // 點擊按鈕時加載腳本\n  loadScriptButton.addEventListener("click", async () => {\n   try {\n// 加載腳本\nconst script = await loadScript("https://example.com/your-script.js"); // 替換為你的腳本 URL\noutputElement.textContent = "腳本加載完成，執行後續操作！";\nconsole.log("腳本加載完成，執行後續操作！");\n// 在這裡執行你的後續操作\nyourFunctionFromScript(); // 假設腳本中有這個函數\n   } catch (error) {\noutputElement.textContent = error.message;\nconsole.error(error);\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>封裝為 Promise:\n創建一個 loadScript 函數，接受腳本的 URL 作為參數。\n\n在函數內部，返回一個 Promise，並在 script.onload 和 script.onerror 中分別調用 resolve 和 reject。\n\n使用 async/await:\n在按鈕點擊事件處理程序中使用 async/await 來等待腳本加載完成。\n\n如果腳本加載成功，執行後續操作；\n如果加載失敗，捕獲錯誤並顯示錯誤信息。\n\n動態加載腳本:\n使用 document.createElement("script") 創建一個新的 &lt;script> 元素。\n\n設置 script.src 為要加載的腳本 URL。\n\n將 &lt;script> 元素添加到文檔的 &lt;head> 中，觸發加載。\n\n處理加載成功和失敗:\n如果腳本加載成功，Promise 會 resolve，並返回加載的腳本元素。\n\n如果腳本加載失敗，Promise 會 reject，並拋出一個錯誤。\n\n<h3>進階：加載多個腳本</h3>如果你需要加載多個腳本，並在所有腳本加載完成後執行操作，可以使用 Promise.all。\n\n<h4>範例程式碼</h4>javascript\n// 加載多個腳本\nasync function loadMultipleScripts() {\n try {\n  const scripts = await Promise.all([\n   loadScript("https://example.com/script1.js"),\n   loadScript("https://example.com/script2.js"),\n   loadScript("https://example.com/script3.js")\n  ]);\n  console.log("所有腳本加載完成！");\n  // 在這裡執行你的後續操作\n } catch (error) {\n  console.error("加載腳本時發生錯誤:", error);\n }\n}\n// 調用函數\nloadMultipleScripts();\n\n<h3>總結</h3>使用 Promise 封裝腳本加載邏輯，可以使代碼更簡潔和易於維護。\n\n通過 async/await，可以輕鬆地處理異步操作，並在腳本加載完成後執行後續操作。\n\n如果需要加載多個腳本，可以使用 Promise.all 來等待所有腳本加載完成。\n',
'<h2>$ajax to collect text file and assign value to javascript array</h2>	如果你想使用 $.ajax（jQuery 的 AJAX 方法）來加載一個文本文件，並將其內容分配給 JavaScript 數組，可以按照以下步驟實現。\n以下是完整的範例程式碼：\n<h3>範例：使用 $.ajax 加載文本文件並分配給數組</h3>html\n&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js">&lt;/script>\n &lt;button>加載文本文件&lt;/button>\n &lt;div>&lt;/div>\n  // 定義一個數組來存儲文本文件的內容\n  let textDataArray = [];\n  // 獲取按鈕和輸出元素\n  const loadTextFileButton = $("#loadTextFileButton");\n  const outputElement = $("#output");\n  // 點擊按鈕時加載文本文件\n  loadTextFileButton.on("click", function () {\n   // 使用 $.ajax 加載文本文件\n   $.ajax({\nurl: "example.txt", // 替換為你的文本文件路徑\nmethod: "GET",\ndataType: "text",\nsuccess: function (data) {\n// 將文本文件的內容按行拆分並存儲到數組中\ntextDataArray = data.split("\n");\n// 顯示數組內容\noutputElement.text("文本文件內容已加載到數組中：\n" + textDataArray.join("\n"));\nconsole.log("文本文件內容已加載到數組中：", textDataArray);\n},\nerror: function (jqXHR, textStatus, errorThrown) {\noutputElement.text("加載文本文件時發生錯誤：" + textStatus);\nconsole.error("加載文本文件時發生錯誤：", textStatus, errorThrown);\n}\n   });\n  });\n<h3>程式碼說明</h3>引入 jQuery:\n在 &lt;head> 中引入 jQuery，因為我們使用 $.ajax 方法。\n\n定義數組:\n定義一個數組 textDataArray，用於存儲文本文件的內容。\n\n使用 $.ajax 加載文本文件:\n設置 url 為文本文件的路徑（例如 example.txt）。\n\n設置 method 為 GET，因為我們是從服務器獲取數據。\n\n設置 dataType 為 text，因為我們加載的是文本文件。\n\n處理加載成功:\n在 success 回調函數中，將文本文件的內容按行拆分（使用 split("\n")），並存儲到 textDataArray 中。\n\n將數組內容顯示在網頁上。\n\n處理加載失敗:\n在 error 回調函數中，顯示錯誤信息。\n\n<h3>文本文件範例 (example.txt)</h3>假設你的文本文件 example.txt 內容如下：\n\nApple\nBanana\nCherry\nDate\nElderberry\n加載後，textDataArray 將會是：\n["Apple", "Banana", "Cherry", "Date", "Elderberry"]\n\n<h3>進階：處理不同格式的文本文件</h3>如果你的文本文件內容是逗號分隔的（CSV 格式），你可以使用 split(",") 來拆分數據。\n\n<h4>範例程式碼</h4>javascript\nsuccess: function (data) {\n // 將文本文件的內容按逗號拆分並存儲到數組中\n textDataArray = data.split(",");\n // 顯示數組內容\n outputElement.text("文本文件內容已加載到數組中：\n" + textDataArray.join("\n"));\n console.log("文本文件內容已加載到數組中：", textDataArray);\n}\n\n<h3>總結</h3>使用 $.ajax 可以輕鬆加載文本文件並將其內容分配給 JavaScript 數組。\n\n通過 split() 方法，可以根據需要拆分文本文件的內容（例如按行或按逗號）。\n\n如果需要加載其他類型的文件（如 JSON 或 CSV），可以調整 dataType 和數據處理邏輯。',
'<h2>load js file on demand</h2>	在 JavaScript 中，你可以動態加載一個 JavaScript 文件（即「按需加載」），並在加載完成後執行特定的操作。\n這可以通過創建一個 &lt;script> 元素並將其添加到文檔中來實現。\n以下是完整的範例，展示如何按需加載 JavaScript 文件並在加載完成後執行操作。\n\n<h3>範例：按需加載 JavaScript 文件</h3> &lt;button>加載腳本&lt;/button>\n &lt;div>&lt;/div>\n &lt;script>\n  // 獲取按鈕和輸出元素\n  const loadScriptButton = document.getElementById("loadScriptButton");\n  const outputElement = document.getElementById("output");\n  // 點擊按鈕時加載腳本\n  loadScriptButton.addEventListener("click", function () {\n   // 創建一個新的 script 元素\n   const script = document.createElement("script");\n   script.src = "https://example.com/your-script.js"; // 替換為你的腳本 URL\n   script.type = "text/javascript";\n   // 定義 onload 事件處理程序\n   script.onload = function () {\noutputElement.textContent = "腳本加載完成，執行後續操作！";\nconsole.log("腳本加載完成，執行後續操作！");\n// 在這裡執行你的後續操作\nyourFunctionFromScript(); // 假設腳本中有這個函數\n   };\n   // 定義 onerror 事件處理程序\n   script.onerror = function () {\noutputElement.textContent = "腳本加載失敗！";\nconsole.error("腳本加載失敗！");\n   };\n   // 將 script 元素添加到文檔中\n   document.head.appendChild(script);\n  });\n &lt;/script>\n<h3>程式碼說明</h3>動態創建 &lt;script> 元素:\n使用 document.createElement("script") 創建一個新的 &lt;script> 元素。\n\n設置 script.src 為要加載的 JavaScript 文件的 URL。\n\n設置 script.type 為 text/javascript（可選，默認為此類型）。\n\n處理加載完成:\n使用 script.onload 事件來監聽腳本加載完成的事件。\n\n在 onload 事件處理程序中，執行後續操作（例如調用腳本中的函數）。\n\n處理加載失敗:\n使用 script.onerror 事件來監聽腳本加載失敗的情況。\n\n將腳本添加到文檔中:\n使用 document.head.appendChild(script) 將腳本添加到文檔的 &lt;head> 中，觸發加載。\n\n<h3>進階：使用 Promise 封裝腳本加載</h3>如果你希望更優雅地處理腳本加載，可以使用 Promise 來封裝腳本加載邏輯。\n\n<h4>範例程式碼</h4> &lt;button>加載腳本&lt;/button>\n &lt;div>&lt;/div>\n &lt;script>\n  // 獲取按鈕和輸出元素\n  const loadScriptButton = document.getElementById("loadScriptButton");\n  const outputElement = document.getElementById("output");\n  // 封裝腳本加載邏輯為 Promise\n  function loadScript(src) {\n   return new Promise((resolve, reject) => {\n// 創建一個新的 script 元素\nconst script = document.createElement("script");\nscript.src = src;\nscript.type = "text/javascript";\n// 定義 onload 事件處理程序\nscript.onload = () => {\nconsole.log(`腳本加載成功: ${src}`);\nresolve(script); // 腳本加載成功，調用 resolve\n};\n// 定義 onerror 事件處理程序\nscript.onerror = () => {\nconsole.error(`腳本加載失敗: ${src}`);\nreject(new Error(`腳本加載失敗: ${src}`)); // 腳本加載失敗，調用 reject\n};\n// 將 script 元素添加到文檔中\ndocument.head.appendChild(script);\n   });\n  }\n  // 點擊按鈕時加載腳本\n  loadScriptButton.addEventListener("click", async () => {\n   try {\n// 加載腳本\nconst script = await loadScript("https://example.com/your-script.js"); // 替換為你的腳本 URL\noutputElement.textContent = "腳本加載完成，執行後續操作！";\nconsole.log("腳本加載完成，執行後續操作！");\n// 在這裡執行你的後續操作\nyourFunctionFromScript(); // 假設腳本中有這個函數\n   } catch (error) {\noutputElement.textContent = error.message;\nconsole.error(error);\n   }\n  });\n &lt;/script>\n<h3>程式碼說明</h3>封裝為 Promise:\n創建一個 loadScript 函數，接受腳本的 URL 作為參數。\n\n在函數內部，返回一個 Promise，並在 script.onload 和 script.onerror 中分別調用 resolve 和 reject。\n\n使用 async/await:\n在按鈕點擊事件處理程序中使用 async/await 來等待腳本加載完成。\n\n如果腳本加載成功，執行後續操作；\n如果加載失敗，捕獲錯誤並顯示錯誤信息。\n\n<h3>總結</h3>動態加載 JavaScript 文件可以通過創建 &lt;script> 元素並將其添加到文檔中來實現。\n\n使用 Promise 封裝腳本加載邏輯，可以使代碼更簡潔和易於維護。\n\n通過 async/await，可以輕鬆地處理異步操作，並在腳本加載完成後執行後續操作。\n',
'<h2>build a Local Proxy Server</h2>	<center><div id="buildLocalProxytoc" class="toc"><a href="#buildLocalProxytopic-0" target="_self"><lg>Option 1: Using Node.js</lg></a><br><a href="#buildLocalProxytopic-1" target="_self">Steps:</a><br><a href="#buildLocalProxytopic-2" target="_self"><lg>Option 2: Using Python</lg></a><br><a href="#buildLocalProxytopic-3" target="_self">Steps:</a><br><a href="#buildLocalProxytopic-4" target="_self"><lg>Testing the Proxy Server</lg></a><br><a href="#buildLocalProxytopic-5" target="_self"><lg>Customizing the Proxy Server</lg></a><br><a href="#buildLocalProxytopic-6" target="_self"><lg>Why Use a Proxy Server?</lg></a><br></div></center><br><br>\n\nBuilding a local proxy server is a great way to serve external resources (like images) as if they are hosted locally. Below is a step-by-step guide to creating a simple local proxy server using <o>Node.js</o> or <o>Python</o>.\n<h3 id="buildLocalProxytopic-0"><lg>Option 1: Using Node.js</lg></h3>Node.js is a popular runtime for building lightweight servers.\n\nHere\'s how to set up a local proxy server:\n<h4 id="buildLocalProxytopic-1">Steps:</h4><o>Install Node.js：</o>\nDownload and install Node.js from <a href="https://nodejs.org/" target="_blank" rel="noreferrer">nodejs.org</a>.\n<o>Create a Project Folder：</o>\nCreate a new folder for your project, e.g., <pk>local-proxy-server</pk>.\n<o>Initialize a Node.js Project：</o>\nOpen a terminal in the project folder and run:\nnpm init -y\n<o>Install Required Packages：</o>\nInstall the <pk>http-proxy</pk> package to handle proxy functionality:\nnpm install http-proxy\n<o>Create the Proxy Server Script：</o>\nCreate a file named <pk>server.js</pk> and add the following code:\nconst http = require(\'http\');\nconst httpProxy = require(\'http-proxy\');\n\n// Create a proxy server\nconst proxy = httpProxy.createProxyServer({});\n\n// Create the main server\nconst server = http.createServer((req, res) =&gt; {\n // Proxy all requests to an external URL\n proxy.web(req, res, { target: \'https://example.com\' });\n});\n\n// Start the server\nconst PORT = 8000;\nserver.listen(PORT, () =&gt; {\n console.log(`Proxy server running on http://localhost:${PO}`);\n});\n\n<o>Run the Server：</o>\nStart the server by running:\nnode server.js\nThe server will now proxy requests to <pk>https://example.com</pk>. For example, if you visit <pk>http://localhost:8000/images/your-image.jpg</pk>, it will fetch the image from <pk>https://example.com/images/your-image.jpg</pk>.\n<h3 id="buildLocalProxytopic-2"><lg>Option 2: Using Python</lg></h3>Python also makes it easy to create a simple proxy server.\n<h4 id="buildLocalProxytopic-3">Steps:</h4><o>Install Python：</o>\nEnsure Python is installed on your system. You can download it from <a href="https://www.python.org/" target="_blank" rel="noreferrer">python.org</a>.\n\n<o>Create a Proxy Server Script：</o>\nCreate a file named <pk>proxy_server.py</pk> and add the following code\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nimport requests\n\nclass ProxyHandler(BaseHTTPRequestHandler):\n def do_GET(self):\n  # Fetch the external resource\n  external_url = f"https://example.com{self.path}"\n  response = requests.get(external_url)\n\n  # Send the response back to the client\n  self.send_response(response.status_code)\n  for key, value in response.headers.items():\n   self.send_header(key, value)\n  self.end_headers()\n  self.wfile.write(response.content)\n\n# Start the server\nif __name__ == "__main__":\n PORT = 8000\n server = HTTPServer(("localhost", PORT), ProxyHandler)\n print(f"Proxy server running on http://localhost:{PORT}")\n server.serve_forer()\n\n<o>Run the Server：</o>\nStart the server by running:\npython proxy_server.py\n\nThe server will now proxy requests to <pk>https://example.com</pk>. For example, if you visit <pk>http://localhost:8000/images/your-image.jpg</pk>, it will tch the image from <pk>https://example.com/images/your-image.jpg</pk>.\n<h3 id="buildLocalProxytopic-4"><lg>Testing the Proxy Server</lg></h3>Open your browser and navigate to <pk>http://localhost:8000</pk>.\n\nAppend the path to the external resource you want to fetch. For example:\n<pk>http://localhost:8000/images/your-image.jpg</pk>ill fetch <pk>https://example.com/images/your-image.jpg</pk>.\n<h3 id="buildLocalProxytopic-5"><lg>Customizing the Proxy Server</lg></h3>Change the Target URL： Replace <pk>https://example.com</pk> with the external URL you want to proxy.\nAdd Caching： To improve performance, you can cache responses locally on your hard disk.\nHandle Errors： Add error handling to manage cases where the external resource is unavailable.\n\n<h3 id="buildLocalProxytopic-6"><lg>Why Use a Proxy Server?</lg></h3>Local Testing： Simulate external resources as if they are hosted locally.\nSecurity： Avoid exposing direct external URLs in your code.\nControl： Modify or filter requests/responses as needed.\n',
'<h2>use javascript create a program as a writing pad</h2>	you can use JavaScript to create a program that uses an Android phone as a writing pad. JavaScript is a versatile language that can be used for both the <o>front-end (Android app)</o> and <o>back-end (server)</o> components of this project. Here"s how you can do it:\n<h3><o>1. Tools and Technologies</o></h3><o>Front-End (Android App)</o>:\nUse a <o>Progressive Web App (PWA)</o> or a framework like <o>React Native</o> to create a mobile app that runs in a browser or as a standalone app.\nUse the HTML5 <pk>&lt;canvas></pk> element to capture touch input.\n<o>Back-End (Server)</o>:\nUse <o>Node.js</o> to create a server that receives data from the Android app.\n\n<o>Communication</o>:\nUse <o>WebSockets</o> or <o>HTTP</o> for real-time communication between the Android app and the server.\n<o>Computer Display</o>:\nUse a web-based front-end (HTML5 <pk>&lt;canvas></pk>) to display the drawing on the computer.\n<h3><o>2. Steps to Build the Program</o></h3><h4><o>Step 1: Create the Android App (Front-End)</o></h4><o>Set Up a Web App</o>:\nCreate an HTML file with a <pk>&lt;canvas></pk> element to capture touch input.\n &lt;style>\n  canvas {\n   border: 1px solid black;\n   background-color: white;\n  }\n &lt;canvas id="drawingCanvas" width="500" height="500">&lt;/canvas>\n &lt;script src="app.js">&lt;/script>\n<o>Capture Touch Input</o>:\nUse JavaScript to handle touch events and draw on the canvas.\nExample JavaScript (<pk>app.js</pk>):\nconst canvas = document.getElementById("drawingCanvas");\nconst ctx = canvas.getContext("2d");\nlet drawing = false;\ncanvas.addEventListener("touchstart", (e) => {\n drawing = true;\n const touch = e.touches[0];\n ctx.beginPath();\n ctx.moveTo(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);\n});\n\ncanvas.addEventListener("touchmove", (e) => {\n if (drawing) {\n  const touch = e.touches[0];\n  ctx.lineTo(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);\n  ctx.stroke();\n\n  // Send coordinates to the server\n  sendData(touch.clientX - canvas.offsetLeft, touch.clientY - canvas.offsetTop);\n }\n});\n\ncanvas.addEventListener("touchend", () => {\n drawing = false;\n ctx.closePath();\n});\n\nfunction sendData(x, y) {\n const data = { x, y };\n fetch("http://COMPUTER_IP_ADDRESS:3000/draw", {\n  method: "POST",\n  headers: { "Content-Type": "application/json" },\n  body: JSON.stringify(data),\n });\n}\n<o>Host the Web App</o>:\nHost the app on a local server or deploy it to a cloud service.\nUse a tool like <pk>http-server</pk> to serve the files locally:\nnpx http-server\n<h4><o>Step 2: Create the Server (Back-End)</o></h4><o>Set Up a Node.js Server</o>:\nInstall Node.js and create a new project.\nInstall <pk>express</pk> for handling HTTP requests:\nnpm install express\n<o>Create the Server</o>:\nExample <pk>server.js</pk>:\nconst express = require("express");\nconst app = express();\nconst port = 3000;\napp.use(express.json());\nlet drawingData = [];\n\napp.post("/draw", (req, res) => {\n const { x, y } = req.body;\n drawingData.push({ x, y });\n console.log(`Received: x=${x}, y=${y}`);\n res.sendStatus(200);\n});\n\napp.get("/data", (req, res) => {\n res.json(drawingData);\n});\n\napp.listen(port, () => {\n console.log(`Server running at http://localhost:${port}`);\n});\n<o>Run the Server</o>:\n<o>Start the server:</o>\nnode server.js\n<h4><o>Step 3: Create the Computer Display (Front-End)</o></h4><o>Set Up a Web Page</o>:\nCreate an HTML file to display the drawing.\n &lt;style>\n  canvas {\n   border: 1px solid black;\n   background-color: white;\n  }\n &lt;canvas id="displayCanvas" width="500" height="500">&lt;/canvas>\n &lt;script src="display.js">&lt;/script>\n<o>Fetch and Display Data</o>:\nUse JavaScript to fetch data from the server and draw it on the canvas.\nExample JavaScript (<pk>display.js</pk>):\nconst canvas = document.getElementById("displayCanvas");\nconst ctx = canvas.getContext("2d");\nfunction fetchData() {\n fetch("http://localhost:3000/data")\n  .then((response) => response.json())\n  .then((data) => {\n   ctx.clearRect(0, 0, canvas.width, canvas.height);\n   data.forEach((point, index) => {\n    if (index === 0) {\n     ctx.beginPath();\n     ctx.moveTo(point.x, point.y);\n    } else {\n     ctx.lineTo(point.x, point.y);\n     ctx.stroke();\n    }\n   });\n  });\n}\nsetInterval(fetchData, 100); // Fetch data every 100ms\n<o>Host the Display Page</o>:\nServe the display page using the same or another local server.\n<h3><o>3. Test the Program</o></h3>Open the Android app in a mobile browser.\nStart drawing on the canvas.\nOpen the display page on the computer to see the drawing in real-time.\n<h3><o>4. Optional Enhancements</o></h3><o>WebSocket Communication</o>: Replace HTTP with WebSockets for faster, real-time updates.\n<o>Stylus Support</o>: Add pressure sensitivity for stylus input.\n<o>Multi-User Support</o>: Allow multiple users to draw simultaneously.\nThis approach uses JavaScript for both the Android app and the server, making it a lightweight and cross-platform solution.',
'<h2>use bluetooth</h2>	it is possible to use <o>Bluetooth</o> as the medium for communication between the Android phone (writing pad) and the computer. Bluetooth is a great choice for short-range wireless communication, and it can be used to send touch data from the Android device to the computer in real-time.\n<o>Here’s how you can implement this:</o>\n<h3><o>1. Tools and Technologies</o></h3><o>Android App</o>:\nUse the <o>Web Bluetooth API</o> (for web apps) or <o>Android Bluetooth APIs</o> (for native apps) to handle Bluetooth communication.\n<o>Computer Program</o>:\nUse a Bluetooth library like <o>Node.js <pk>bluetooth-serial-port</pk></o> or <o>Python <pk>pybluez</pk></o> to receive data on the computer.\n<o>Communication Protocol</o>:\nDefine a simple protocol to send touch coordinates (e.g., <pk>x,y</pk>).\n<h3><o>2. Steps to Build the Program</o></h3><h4><o>Step 1: Create the Android App</o></h4><o>Set Up Bluetooth Permissions</o>:\nAdd the following permissions to your <pk>AndroidManifest.xml</pk>:\nxml\n&lt;uses-permission android:name="android.permission.BLUETOOTH" />\n&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />\n&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />\n\nRun HTML\n<o>Enable Bluetooth</o>:\nCheck if Bluetooth is enabled and request permission to enable it if necessary.\nExample Kotlin code:\nkotlin\nval bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()\nif (bluetoothAdapter == null) {\n // Device doesn"t support Bluetooth\n} else {\n if (!bluetoothAdapter.isEnabled) {\n  val enableBtIntent = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)\n  startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT)\n }\n}\n<o>Discover and Connect to the Computer</o>:\nPair the Android device with the computer.\nDiscover the computer"s Bluetooth device and connect to it.\nExample Kotlin code:\nkotlin\nval pairedDevices: Set&lt;BluetoothDevice>? = bluetoothAdapter?.bondedDevices\npairedDevices?.forEach { device ->\n if (device.name == "COMPUTER_NAME") {\n  val socket = device.createRfcommSocketToServiceRecord(UUID.randomUUID())\n  socket.connect()\n  // Use the socket to send data\n }\n}\n<o>Send Touch Data</o>:\nCapture touch input (as shown in the previous examples) and send the coordinates via Bluetooth.\nExample Kotlin code:\nkotlin\nfun sendData(x: Float, y: Float) {\n val data = "$x,$y\n".toByteArray()\n socket.outputStream.write(data)\n}\n<h4><o>Step 2: Create the Computer Program</o></h4><o>Set Up Bluetooth on the Computer</o>:\nEnsure Bluetooth is enabled on the computer.\nPair the computer with the Android device.\n<o>Use a Bluetooth Library</o>:\nFor <o>Node.js</o>, use the <pk>bluetooth-serial-port</pk> library:\nnpm install bluetooth-serial-port\nFor <o>Python</o>, use the <pk>pybluez</pk> library:\npip install pybluez\n<o>Receive Data on the Computer</o>:\nExample using Node.js:\nconst BluetoothSerialPort = require("bluetooth-serial-port");\nconst btSerial = new BluetoothSerialPort.BluetoothSerialPort();\n\nbtSerial.on("found", (address, name) => {\n if (name === "ANDROID_DEVICE_NAME") {\n  btSerial.findSerialPortChannel(address, (channel) => {\n   btSerial.connect(address, channel, () => {\n    console.log("Connected to Android device");\n\n    btSerial.on("data", (buffer) => {\n     const data = buffer.toString("utf-8").trim();\n     const [x, y] = data.split(",").map(parseFloat);\n     console.log(`Received: x=${x}, y=${y}`);\n     // Draw the coordinates on a canvas or GUI\n    });\n   });\n  });\n }\n});\n\nbtSerial.inquire();\nExample using Python:\nimport bluetooth\nserver_socket = bluetooth.BluetoothSocket(bluetooth.RFCOMM)\nserver_socket.bind(("", bluetooth.PORT_ANY))\nserver_socket.listen(1)\n\nport = server_socket.getsockname()[1]\nprint(f"Waiting for connection on RFCOMM channel {port}...")\n\nclient_socket, address = server_socket.accept()\nprint(f"Connected to {address}")\n\nwhile True:\n data = client_socket.recv(1024).decode().strip()\n if not data:\n  break\n x, y = map(float, data.split(","))\n print(f"Received: x={x}, y={y}")\n # Draw the coordinates on a canvas or GUI\n\nclient_socket.close()\nserver_socket.close()\n<h4><o>Step 3: Display the Drawing on the Computer</o></h4>Use a GUI library like <pk>tkinter</pk> (Python) or <pk>electron</pk> (Node.js) to display the received data.\nExample Python <pk>tkinter</pk> code:\nimport tkinter as tk\ndef draw_point(x, y):\n canvas.create_oval(x-2, y-2, x+2, y+2, fill="black")\n\nroot = tk.Tk()\ncanvas = tk.Canvas(root, width=500, height=500, bg="white")\ncanvas.pack()\n\n# Call draw_point(x, y) when data is received\nroot.mainloop()\n<h3><o>3. Test the Program</o></h3>Pair the Android device with the computer.\n\nRun the Android app and start drawing.\nRun the computer program to receive and display the drawing.\n<h3><o>4. Optional Enhancements</o></h3><o>Error Handling</o>: Add robust error handling for Bluetooth connection issues.\n<o>Multi-Device Support</o>: Allow multiple Android devices to connect to the same computer.\n<o>Stylus Support</o>: Add pressure sensitivity for stylus input.\nUsing Bluetooth as the medium is a great choice for short-range, low-latency communication.\n',
'<h2>Handling CORS issues</h2>	<center><div id="HandlingCORStoc" class="toc"><a href="#HandlingCORStopic-0" target="_self">1. <pk>Use a Proxy Server</pk></a><br><a href="#HandlingCORStopic-1" target="_self">2. <pk>JSONP (JSON with Padding)</pk></a><br><a href="#HandlingCORStopic-2" target="_self">3. <pk>Disable CORS in the Browser (Development Only)</pk></a><br><a href="#HandlingCORStopic-3" target="_self">4. <pk>Browser Extensions</pk></a><br><a href="#HandlingCORStopic-4" target="_self">5. <pk>Use a Backend-to-Backend Communication</pk></a><br><a href="#HandlingCORStopic-5" target="_self">6. <pk>Debugging Tips</pk></a><br><a href="#HandlingCORStopic-6" target="_self">7. <pk>Best Practices</pk></a><br></div></center><br><br>\n\nHandling CORS issues on the <pk>browser side</pk> is limited because CORS is a security feature enforced by browsers to protect users.\nHowever, there are a few workarounds you can use during development or in specific scenarios.\nBelow are some approaches:\n\n<h3 id="HandlingCORStopic-0">1. <pk>Use a Proxy Server</pk></h3>Since browsers enforce CORS, you can bypass it by routing your requests through a proxy server.\nThe proxy server acts as an intermediary, making the request on your behalf and returning the response to your browser.\n\n<y> a. <pk>Local Proxy Setup</pk></y>\nYou can set up a simple proxy server using Node.js, Nginx, or any backend framework.\n\n<pk>Example using Node.js (Express):</pk>\nconst express = require(\'express\');\nconst request = require(\'request\');\nconst app = express();\n\napp.use(\'/proxy\', (req, res) =&gt; {\n  const url = \'https://target-server.com\' + req.url;\n  req.pipe(request(url)).pipe(res);\n});\n\napp.listen(3000, () =&gt; console.log(\'Proxy server running on port 3000\'));\n\n<pk>Usage in the Browser:</pk>\nInstead of calling `https://target-server.com/api`, call your proxy server: `http://localhost:3000/proxy/api`.\n\n<y> b. <pk>Public Proxy Services</pk></y>\nYou can use public proxy services like:\n- [CORS Anywhere](https://cors-anywhere.herokuapp.com/)\n- [All Origins](https://allorigins.win/)\n\n<pk>Example:</pk>\nfetch(\'https://cors-anywhere.herokuapp.com/https://target-server.com/api\')\n  .then(response =&gt; response.json())\n  .then(data =&gt; console.log(data))\n  .catch(error =&gt; console.error(error));\n\n<h3 id="HandlingCORStopic-1">2. <pk>JSONP (JSON with Padding)</pk></h3>JSONP is an older technique to bypass CORS for `GET` requests.\nIt works by loading a script tag with a callback function.\n\n<pk>Example:</pk>\nfunction handleResponse(data) {\n  console.log(data);\n}\n\nconst script = document.createElement(\'script\');\nscript.src = \'https://target-server.com/api?callback=handleResponse\';\ndocument.body.appendChild(script);\n\n<pk>Limitations:</pk>\n- Only works for `GET` requests.\n- Requires server support for JSONP.\n- Less secure than CORS.\n\n<h3 id="HandlingCORStopic-2">3. <pk>Disable CORS in the Browser (Development Only)</pk></h3>For local development, you can disable CORS in your browser.\n<pk>This is not recommended for production or regular browsing.</pk>\n\n<y> a. <pk>Chrome</pk></y>\n1. Close all instances of Chrome.\n2. Open a terminal and run:\n   chrome.exe --disable-web-security --user-data-dir="C:/ChromeDevSession"\n   (Replace `chrome.exe` with the path to your Chrome executable.)\n\n<y> b. <pk>Firefox</pk></y>\n1. Type `about:config` in the address bar.\n2. Search for `security.fileuri.strict_origin_policy`.\n3. Set it to `false`.\n\n<h3 id="HandlingCORStopic-3">4. <pk>Browser Extensions</pk></h3>You can use browser extensions to bypass CORS during development.\nThese extensions modify response headers to allow cross-origin requests.\n\n- <pk>Chrome</pk>: [CORS Unblock](https://chrome.google.com/webstore/detail/cors-unblock/lfhmikememgdcahcdlaciloancbhjino)\n- <pk>Firefox</pk>: [CORS Everywhere](https://addons.mozilla.org/en-US/firefox/addon/cors-everywhere/)\n\n<h3 id="HandlingCORStopic-4">5. <pk>Use a Backend-to-Backend Communication</pk></h3>If you control both the frontend and backend, you can avoid CORS by making the request from your backend server instead of the browser.\nThe backend server can then forward the response to the frontend.\n\n<h3 id="HandlingCORStopic-5">6. <pk>Debugging Tips</pk></h3>- Use browser developer tools (F12) to inspect the network requests and CORS headers.\n- Check the console for CORS-related errors.\n- Test the API using tools like Postman or cURL to ensure it works without CORS issues.\n\n<h3 id="HandlingCORStopic-6">7. <pk>Best Practices</pk></h3>- <pk>Avoid Workarounds in Production</pk>: Workarounds like disabling CORS or using JSONP are not secure for production.\n- <pk>Use a Proxy in Production</pk>: Set up a secure proxy server to handle cross-origin requests.\n- <pk>Communicate with the Server Team</pk>: If you don’t control the server, ask the server team to enable CORS with proper headers.\n\nBy using these techniques, you can handle CORS issues on the browser side during development or in specific scenarios.\nHowever, the best long-term solution is to configure the server to support CORS properly.\n',
'<h2>addEventListener("click", async () => {}</h2>	<center><div id="clickasynctoc" class="toc"><a href="#clickasynctopic-0" target="_self">代碼的運行過程如下</a><br><a href="#clickasynctopic-1" target="_self">1. 選擇按鈕元素</a><br><a href="#clickasynctopic-2" target="_self">2. 添加事件監聽器</a><br><a href="#clickasynctopic-3" target="_self">3. 異步回調函數</a><br><a href="#clickasynctopic-4" target="_self">4. 事件觸發</a><br><a href="#clickasynctopic-5" target="_self">5. 執行回調函數</a><br><a href="#clickasynctopic-6" target="_self">示例代碼</a><br><a href="#clickasynctopic-7" target="_self">運行過程</a><br><a href="#clickasynctopic-8" target="_self">總結</a><br></div></center><br><br>\n\n<o id="clickasynctopic-0">代碼的運行過程如下</o>：\n<y id="clickasynctopic-1">1. 選擇按鈕元素</y>：\n- loadDataButton 是一個 DOM 元素，通常通過 document.getElementById 或 document.querySelector 等方法獲取。\n\n<y id="clickasynctopic-2">2. 添加事件監聽器</y>：\n- 使用 addEventListener 方法為 loadDataButton 添加一個 click 事件監聽器。\n- 當按鈕被點擊時，監聽器會觸發。\n\n<y id="clickasynctopic-3">3. 異步回調函數</y>：\n- 回調函數是 async () => {}，這意味著它是一個異步函數，允許在函數內使用 await 來處理異步操作（如 API 請求）。\n\n<y id="clickasynctopic-4">4. 事件觸發</y>：\n- 當按鈕被點擊時，瀏覽器會執行這個異步回調函數。\n\n<y id="clickasynctopic-5">5. 執行回調函數</y>：\n- 回調函數內的代碼會按順序執行，遇到 await 時會暫停，直到異步操作完成後繼續。\n<o id="clickasynctopic-6">示例代碼</o>\nloadDataButton.addEventListener("click", async () => {\n  try {\n    const response = await fetch(\'https://api.example.com/data\');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error(\'Error:\', error);\n  }\n});\n\n<o id="clickasynctopic-7">運行過程</o>\n1. 點擊按鈕：用戶點擊 loadDataButton。\n2. 觸發回調：異步回調函數開始執行。\n3. 發送請求：fetch 發送請求並等待回應。\n4. 解析數據：回應到達後，解析為 JSON。\n5. 處理數據：數據被打印到控制台。\n6. 錯誤處理：如果出現錯誤，會被 catch 捕獲並打印。\n<o id="clickasynctopic-8">總結</o>\n這句代碼為按鈕添加了一個點擊事件監聽器，點擊後會執行異步操作，適合處理需要等待的任務，如網絡請求。\n',
'<h2>promise 和 async 異同</h2>	<center><div id="promise和asynctoc" class="toc"><a href="#promise和asynctopic-0" target="_self"><o>相同點</o></a><br><a href="#promise和asynctopic-1" target="_self"> 1. 處理異步操作</a><br><a href="#promise和asynctopic-2" target="_self"> 2. 基於 Promise</a><br><a href="#promise和asynctopic-3" target="_self"> 3. 錯誤處理</a><br><a href="#promise和asynctopic-4" target="_self"><o>不同點</o></a><br><a href="#promise和asynctopic-5" target="_self"> 語法</a><br><a href="#promise和asynctopic-6" target="_self"> 可讀性</a><br><a href="#promise和asynctopic-7" target="_self"> 錯誤處理</a><br><a href="#promise和asynctopic-8" target="_self"> 返回值</a><br><a href="#promise和asynctopic-9" target="_self"> 適用場景</a><br><a href="#promise和asynctopic-10" target="_self"><o>代碼示例比較</o></a><br><a href="#promise和asynctopic-11" target="_self"> 使用 Promise</a><br><a href="#promise和asynctopic-12" target="_self"> 使用 async/await</a><br><a href="#promise和asynctopic-13" target="_self"><o>詳細區別</o></a><br><a href="#promise和asynctopic-14" target="_self"> 1. 語法簡潔性</a><br><a href="#promise和asynctopic-15" target="_self"> 2. 錯誤處理</a><br><a href="#promise和asynctopic-16" target="_self"> 3. 控制流程</a><br><a href="#promise和asynctopic-17" target="_self"> 4. 返回值</a><br><a href="#promise和asynctopic-18" target="_self"><o>選擇使用場景</o></a><br><a href="#promise和asynctopic-19" target="_self"> - 使用 Promise</a><br><a href="#promise和asynctopic-20" target="_self"> - 使用 async/await</a><br><a href="#promise和asynctopic-21" target="_self"><o>總結</o></a><br></div></center><br><br>\n\nPromise 和 async/await 都是用於處理 JavaScript 中異步操作的工具，但它們在語法和使用方式上有明顯的區別。\n以下是它們的異同點：\n\n<h3 id="promise和asynctopic-0"><o>相同點</o></h3><y id="promise和asynctopic-1"> 1. 處理異步操作</y>：\n- 兩者都用於處理異步操作，例如網絡請求、定時器、文件讀寫等。\n- 目標都是避免回調地獄（Callback Hell），讓代碼更易讀和維護。\n\n<y id="promise和asynctopic-2"> 2. 基於 Promise</y>：\n- async/await 實際上是基於 Promise 的語法糖。\n- async 函數總是返回一個 Promise，而 await 用於等待一個 Promise 的結果。\n\n<y id="promise和asynctopic-3"> 3. 錯誤處理</y>：\n- 兩者都可以通過 try/catch 或 .catch() 來捕獲錯誤。\n\n<h3 id="promise和asynctopic-4"><o>不同點</o></h3><lg id="promise和asynctopic-5"> 語法</lg>\n- Promise 使用 .then() 和 .catch() 鏈式調用\n- async/await 使用 async 和 await 關鍵字    \n<lg id="promise和asynctopic-6"> 可讀性</lg>\n- Promise 鏈式調用較長時，可讀性較差     \n- async/await 更像同步代碼，可讀性更高       \n<lg id="promise和asynctopic-7"> 錯誤處理</lg>\n- Promise 使用 .catch() 或鏈式調用中的第二個參數\n- async/await 使用 try/catch，類似同步代碼    \n<lg id="promise和asynctopic-8"> 返回值</lg>\n- Promise 返回一個 - Promise 對象\n- async/await async 函數返回一個 - Promise\n<lg id="promise和asynctopic-9"> 適用場景</lg>\n- Promise 簡單的異步操作或需要手動控制 - Promise\n- async/await 複雜的異步邏輯，需要更清晰的代碼結構\n\n<h3 id="promise和asynctopic-10"><o>代碼示例比較</o></h3><pk id="promise和asynctopic-11"> 使用 Promise</pk>\njavascript\nfunction fetchData() {\n  return fetch(\'https://api.example.com/data\')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n      console.log(data);\n    })\n    .catch(error =&gt; {\n      console.error(\'Error:\', error);\n    });\n}\n<pk id="promise和asynctopic-12"> 使用 async/await</pk>\nasync function fetchData() {\n  try {\n    const response = await fetch(\'https://api.example.com/data\');\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error(\'Error:\', error);\n  }\n}\n<h3 id="promise和asynctopic-13"><o>詳細區別</o></h3><y id="promise和asynctopic-14"> 1. 語法簡潔性</y>：\n- Promise 需要通過 .then() 和 .catch() 來處理異步操作，當鏈式調用較多時，代碼會變得冗長。\n- async/await 讓異步代碼看起來更像同步代碼，結構更清晰。\n\n<y id="promise和asynctopic-15"> 2. 錯誤處理</y>：\n- Promise 的錯誤處理依賴於 .catch() 或 .then() 的第二個參數。\n- async/await 可以使用 try/catch，這與同步代碼的錯誤處理方式一致，更直觀。\n\n<y id="promise和asynctopic-16"> 3. 控制流程</y>：\n- Promise 適合簡單的異步操作，或者需要手動控制 Promise 的場景（例如 Promise.all、Promise.race）。\n- async/await 更適合複雜的異步邏輯，尤其是需要按順序執行多個異步操作時。\n\n<y id="promise和asynctopic-17"> 4. 返回值</y>：\n- Promise 直接返回一個 Promise 對象。\n- async 函數總是返回一個 Promise，即使函數內沒有顯式返回 Promise。\n\n<h3 id="promise和asynctopic-18"><o>選擇使用場景</o></h3><pk id="promise和asynctopic-19"> - 使用 Promise</pk>：\n- 當你需要手動控制多個 Promise 的並行執行（例如 Promise.all）。\n- 當異步邏輯較簡單，不需要複雜的流程控制。\n\n<pk id="promise和asynctopic-20"> - 使用 async/await</pk>：\n- 當異步邏輯較複雜，需要按順序執行多個異步操作。\n- 當你需要更高的代碼可讀性和維護性。\n\n<h3 id="promise和asynctopic-21"><o>總結</o></h3>- Promise 是 JavaScript 中處理異步操作的基礎。\n- async/await 是基於 Promise 的語法糖，讓異步代碼更簡潔、易讀。\n- 兩者可以結合使用，根據具體場景選擇最合適的方式。\n',
'<h2>use JavaScript to split an array in chunks</h2>	const originalArray = Array.from({ length: 100 }, (_, i) => i + 1); // Example array [1, 2, ..., 100]\nconst chunkSize = 30;\nconst chunks = [];\nfor (let i = 0; i < originalArray.length; i += chunkSize) {\n    chunks.push(originalArray.slice(i, i + chunkSize));\n}\n\nconsole.log(chunks);\n\n<o>Explanation</o>:\n1. <lg>Array.from</lg>: Creates an array of length 100 with values from 1 to 100.\n2. <lg>chunkSize</lg>: Defines the size of each subarray (30 in this case).\n3. <lg>for loop</lg>: Iterates over the original array in steps of chunkSize.\n4. <lg>slice</lg>: Extracts a portion of the array from index i to i + chunkSize.\n5. <lg>chunks.push</lg>: Adds each subarray to the chunks array.\n\n<o>Output</o>:\nThe chunks array will contain:\n[\n  [1, 2, 3, ..., 30],       // Subarray 1 (length 30)\n  [31, 32, 33, ..., 60],    // Subarray 2 (length 30)\n  [61, 62, 63, ..., 90],    // Subarray 3 (length 30)\n  [91, 92, 93, ..., 100]    // Subarray 4 (length 10)\n]\n',
'<h2>debug javascript in android</h2>	<center><div id="debuginandroidtoc" class="toc"><a href="#debuginandroidtopic-0" target="_self"><y>1. Using Chrome DevTools with WebView</y></a><br><a href="#debuginandroidtopic-1" target="_self"> Steps</a><br><a href="#debuginandroidtopic-2" target="_self"> 1. Enable WebView Debugging:</a><br><a href="#debuginandroidtopic-3" target="_self"> 2. Connect to Chrome DevTools:</a><br><a href="#debuginandroidtopic-4" target="_self"><y>2. Using Chrome DevTools with Android Browser</y></a><br><a href="#debuginandroidtopic-5" target="_self"> Steps</a><br><a href="#debuginandroidtopic-6" target="_self"> 1. Connect Your Android Device:</a><br><a href="#debuginandroidtopic-7" target="_self"> 2. Open Chrome on Your Android Device:</a><br><a href="#debuginandroidtopic-8" target="_self"> 3. Open Chrome DevTools on Your Computer:</a><br><a href="#debuginandroidtopic-9" target="_self"><y>3. Using `console.log()`</y></a><br><a href="#debuginandroidtopic-10" target="_self"> Steps</a><br><a href="#debuginandroidtopic-11" target="_self"> 1. Add `console.log()` Statements:</a><br><a href="#debuginandroidtopic-12" target="_self"> 2. View Logs:</a><br><a href="#debuginandroidtopic-13" target="_self"><y>4. Using Android Studio Logcat</y></a><br><a href="#debuginandroidtopic-14" target="_self"> Steps</a><br><a href="#debuginandroidtopic-15" target="_self"> 1. Open Logcat:</a><br><a href="#debuginandroidtopic-16" target="_self"> 2. Filter Logs:</a><br><a href="#debuginandroidtopic-17" target="_self"><y>5. Using Remote Debugging with Firefox</y></a><br><a href="#debuginandroidtopic-18" target="_self"> Steps</a><br><a href="#debuginandroidtopic-19" target="_self"> 1. Enable Remote Debugging on Android:</a><br><a href="#debuginandroidtopic-20" target="_self"> 2. Connect to Firefox DevTools:</a><br><a href="#debuginandroidtopic-21" target="_self"><y>6. Using Third-Party Tools</y></a><br><a href="#debuginandroidtopic-22" target="_self"> There are also third-party tools like Weinre**</a><br><a href="#debuginandroidtopic-23" target="_self"> Steps</a><br><a href="#debuginandroidtopic-24" target="_self"> 1. Install Weinre:</a><br><a href="#debuginandroidtopic-25" target="_self"> 2. Run Weinre:</a><br><a href="#debuginandroidtopic-26" target="_self"> 3. Connect Your Android Device:</a><br><a href="#debuginandroidtopic-27" target="_self"><y>Conclusion</y></a><br></div></center><br><br>\n\nDebugging JavaScript in an Android app, especially in a WebView or a browser, can be a bit tricky but is definitely doable. Here are some methods to debug JavaScript in Android:\n\n<h3 id="debuginandroidtopic-0"><y>1. Using Chrome DevTools with WebView</y></h3>If you\'re using a WebView in your Android app, you can debug the JavaScript running inside it using Chrome DevTools.\n\n<pk id="debuginandroidtopic-1"> Steps</pk>:\n<o id="debuginandroidtopic-2"> 1. Enable WebView Debugging:</o>\n- In your Android app, enable WebView debugging by adding the following line of code in your `WebView` setup:\njava\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n\n- This should be done before any WebView is instantiated in your app.\n\n<o id="debuginandroidtopic-3"> 2. Connect to Chrome DevTools:</o>\n- Open Chrome on your desktop and navigate to `chrome://inspect`.\n- You should see your Android device listed with the WebView instances that are debuggable.\n- Click on the "Inspect" link next to the WebView you want to debug. This will open Chrome DevTools, where you can debug JavaScript, inspect the DOM, and monitor network activity.\n\n<h3 id="debuginandroidtopic-4"><y>2. Using Chrome DevTools with Android Browser</y></h3>If you\'re debugging JavaScript in a website loaded in the Android browser, you can use Chrome DevTools as well.\n\n<pk id="debuginandroidtopic-5"> Steps</pk>:\n<o id="debuginandroidtopic-6"> 1. Connect Your Android Device:</o>\n- Connect your Android device to your computer via USB.\n- Enable USB debugging on your Android device (go to `Settings &gt; Developer options &gt; USB debugging`).\n\n<o id="debuginandroidtopic-7"> 2. Open Chrome on Your Android Device:</o>\n- Open Chrome on your Android device and navigate to the website you want to debug.\n\n<o id="debuginandroidtopic-8"> 3. Open Chrome DevTools on Your Computer:</o>\n- Open Chrome on your desktop and navigate to `chrome://inspect`.\n- You should see your Android device listed with the tabs open in Chrome on your device.\n- Click on the "Inspect" link next to the tab you want to debug. This will open Chrome DevTools, where you can debug JavaScript, inspect the DOM, and monitor network activity.\n\n<h3 id="debuginandroidtopic-9"><y>3. Using `console.log()`</y></h3>For simpler debugging, you can use `console.log()` statements in your JavaScript code to print messages to the console.\n\n<pk id="debuginandroidtopic-10"> Steps</pk>:\n<o id="debuginandroidtopic-11"> 1. Add `console.log()` Statements:</o>\n- Add `console.log()` statements in your JavaScript code to output variables, objects, or messages.\n- Example:\njavascript\nconsole.log("This is a debug message");\nconsole.log(variableName);\n<o id="debuginandroidtopic-12"> 2. View Logs:</o>\n- If you\'re using a WebView, you can view the logs in Android Studio\'s Logcat.\n- If you\'re using Chrome, you can view the logs in the Chrome DevTools console.\n\n<h3 id="debuginandroidtopic-13"><y>4. Using Android Studio Logcat</y></h3>If you\'re running JavaScript in a WebView, you can also use Android Studio\'s Logcat to view logs.\n\n<pk id="debuginandroidtopic-14"> Steps</pk>:\n<o id="debuginandroidtopic-15"> 1. Open Logcat:</o>\n- Open Android Studio and connect your Android device.\n- Open the Logcat window (`View &gt; Tool Windows &gt; Logcat`).\n\n<o id="debuginandroidtopic-16"> 2. Filter Logs:</o>\n- Filter the logs by the tag `Web Console` to see the output of `console.log()` statements from your JavaScript code.\n\n<h3 id="debuginandroidtopic-17"><y>5. Using Remote Debugging with Firefox</y></h3>If you prefer using Firefox, you can also debug JavaScript on Android using Firefox\'s remote debugging tools.\n\n<pk id="debuginandroidtopic-18"> Steps</pk>:\n<o id="debuginandroidtopic-19"> 1. Enable Remote Debugging on Android:</o>\n- Open Firefox on your Android device.\n- Go to `Settings &gt; Advanced &gt; Remote Debugging` and enable it.\n\n<o id="debuginandroidtopic-20"> 2. Connect to Firefox DevTools:</o>\n- Open Firefox on your desktop.\n- Go to `Tools &gt; Web Developer &gt; Remote Debugging`.\n- You should see your Android device listed. Click on it to start debugging.\n\n<h3 id="debuginandroidtopic-21"><y>6. Using Third-Party Tools</y></h3><o id="debuginandroidtopic-22"> There are also third-party tools like Weinre**</o>Web Inspector Remote) that allow you to debug JavaScript on mobile devices.\n\n<pk id="debuginandroidtopic-23"> Steps</pk>:\n<o id="debuginandroidtopic-24"> 1. Install Weinre:</o>\n- Install Weinre using npm:\nbash\nnpm install -g weinre\n<o id="debuginandroidtopic-25"> 2. Run Weinre:</o>\n- Start the Weinre server:\nbash\nweinre --boundHost -all-\n<o id="debuginandroidtopic-26"> 3. Connect Your Android Device:</o>\n- Open the Weinre interface in your desktop browser and follow the instructions to connect your Android device.\n\n<h3 id="debuginandroidtopic-27"><y>Conclusion</y></h3>Debugging JavaScript in Android can be done using various methods, depending on your setup. Chrome DevTools is the most common and powerful tool for this purpose, but other methods like `console.log()`, Android Studio Logcat, and third-party tools like Weinre can also be useful. Choose the method that best fits your needs and workflow.\n',
'<h2>use web worker to collect data</h2>	<center><div id="usewebworkertoc" class="toc"><a href="#usewebworkertopic-0" target="_self"><o>Why Use Web Workers?</o></a><br><a href="#usewebworkertopic-1" target="_self">1. Non-blocking Main Thread</a><br><a href="#usewebworkertopic-2" target="_self">2. Parallel Processing</a><br><a href="#usewebworkertopic-3" target="_self">3. Improved Performance</a><br><a href="#usewebworkertopic-4" target="_self"><o>How to Implement Web Workers for Data Collection</o></a><br><a href="#usewebworkertopic-5" target="_self">1. Create a Web Worker Script</a><br><a href="#usewebworkertopic-6" target="_self">2. Main Thread: Use the Web Worker</a><br><a href="#usewebworkertopic-7" target="_self">3. Fetch Data Chunks in the Main Thread</a><br><a href="#usewebworkertopic-8" target="_self">4. Update HTML</a><br><a href="#usewebworkertopic-9" target="_self"><o>Benefits of Using Web Workers:</o></a><br><a href="#usewebworkertopic-10" target="_self">1. Responsive UI</a><br><a href="#usewebworkertopic-11" target="_self">2. Scalability</a><br><a href="#usewebworkertopic-12" target="_self">3. Modularity</a><br><a href="#usewebworkertopic-13" target="_self"><o>When to Avoid Web Workers:</o></a><br></div></center><br><br>\n\nusing <r>Web Workers</r> can be a great idea if the `codetable` is a long list of elements. Web Workers allow you to offload heavy computations or data-fetching tasks to a separate thread, preventing the main thread (UI thread) from being blocked. This ensures that your web application remains responsive and provides a better user experience.\n\n<h3 id="usewebworkertopic-0"><o>Why Use Web Workers?</o></h3><lg id="usewebworkertopic-1">1. Non-blocking Main Thread</lg>:\n- Fetching data for a long list of stock codes can take significant time, especially if the API calls are slow or the list is large. Using Web Workers prevents the UI from freezing during this process.\n\n<lg id="usewebworkertopic-2">2. Parallel Processing</lg>:\n- Web Workers can handle multiple tasks in parallel, making it faster to process a large `codetable`.\n\n<lg id="usewebworkertopic-3">3. Improved Performance</lg>:\n- By distributing the workload, you can improve the overall performance of your application.\n\n<h3 id="usewebworkertopic-4"><o>How to Implement Web Workers for Data Collection</o></h3>Here’s how you can refactor your code to use Web Workers for data collection:\n<lg id="usewebworkertopic-5">1. Create a Web Worker Script</lg>\nCreate a separate JavaScript file (e.g., `worker.js`) that will handle the data collection logic.\n\n// worker.js\nself.addEventListener(\'message\', async (event) =&gt; {\n const { codetable, url } = event.data;\n const results = [];\n for (const stknum of codetable) {\n  const stkcode = "hk" + stknum;\n  const apiUrl = url + stkcode + ",day,,,10,qfq";\n\n  try {\n   const response = await fetch(apiUrl);\n   const responseText = await response.text();\n   const jsonString = responseText.split("=")[1];\n   const jsonData = JSON.parse(jsonString);\n   const stockName = jsonData.data[stkcode].qt[stkcode][1];\n\n   const stockData = jsonData.data[stkcode].qfqday || jsonData.data[stkcode].day;\n\n   if (!stockData || !Array.isArray(stockData)) {\n    throw new Error(`Invalid/missing stock data for ${stkcode}`);\n   }\n\n   const amtArray = stockData.map(row =&gt; Number(row[8]));\n   const highArray = stockData.map(row =&gt; Number(row[3]));\n   const lowArray = stockData.map(row =&gt; Number(row[4]));\n\n   const avgAmt = averageOfLastTen(amtArray);\n   const maxH = Math.max(...highArray);\n   const minL = Math.min(...lowArray);\n\n   results.push({ stknum, stockName, avgAmt, maxH, minL });\n  } catch (error) {\n   console.error(`Error fetching data for ${stknum}:`, error);\n  }\n }\n\n // Send the results back to the main thread\n self.postMessage(results);\n});\n\nfunction averageOfLastTen(arr) {\n if (arr.length &lt; 10) {\n  throw new Error("Array must have at least 10 elements");\n }\n const lastTen = arr.slice(-10);\n const sum = lastTen.reduce((acc, val) =&gt; acc + val, 0);\n return sum / 10;\n}\n\n<lg id="usewebworkertopic-6">2. Main Thread: Use the Web Worker</lg>\nIn your main script, create a Web Worker and delegate the data collection task to it.\n\n// Main script\nconst codetable = [\'02800\', \'00700\', \'09988\', /* ... long list of stock codes ... */];\nconst BaseObj = {};\n\n// Create a Web Worker\nconst worker = new Worker(\'worker.js\');\n\n// Send the codetable and API URL to the worker\nworker.postMessage({\n codetable,\n url: "https://web.ifzq.gtimg.cn/appstock/app/hkfqkline/get?_var=kline_dayqfq&amp;param="\n});\n\n// Listen for messages from the worker\nworker.addEventListener(\'message\', (event) =&gt; {\n const results = event.data;\n\n // Populate BaseObj with the results\n results.forEach(result =&gt; {\n  BaseObj[result.stknum] = {\n   stockName: result.stockName,\n   avgAmt: result.avgAmt,\n   maxH: result.maxH,\n   minL: result.minL\n  };\n });\n\n console.log("All data collected:", BaseObj);\n\n // Now you can proceed with fetchDataChunks or other logic\n fetchDataChunks();\n});\n\n// Handle errors from the worker\nworker.addEventListener(\'error\', (error) =&gt; {\n console.error("Web Worker error:", error);\n});\n\n<lg id="usewebworkertopic-7">3. Fetch Data Chunks in the Main Thread</lg>\nAfter the Web Worker has collected the data and populated `BaseObj`, you can proceed with `fetchDataChunks` in the main thread.\n\nasync function fetchDataChunks() {\n const baseurl = "http://qt.gtimg.cn/?q=";\n const chunkSize = 64;\n const chunks = [];\n const urlReqStr = [];\n\n for (let i = 0; i &lt; codetable.length; i += chunkSize) {\n  chunks.push(codetable.slice(i, i + chunkSize));\n }\n\n for (let i = 0; i &lt; chunks.length; i++) {\n  urlReqStr.push(baseurl + chunks[i].map(element =&gt; "s_hk" + element).join(","));\n }\n\n for (let i = 0; i &lt; urlReqStr.length; i++) {\n  await fetchDataChunk(urlReqStr[i]);\n }\n\n updateHTML();\n}\n\nasync function fetchDataChunk(url) {\n try {\n  const response = await fetch(url);\n  const data = await response.text();\n  const rows = data.split(";");\n\n  rows.forEach(row =&gt; {\n   const columns = row.split("~");\n   if (columns.length &gt; 1) {\n    const stockCode = columns[2];\n    const stknum = stockCode.replace("s_hk", "");\n\n    if (BaseObj[stknum] &amp;&amp; BaseObj[stknum].avgAmt) {\n     const currentAmt = parseFloat(columns[7]);\n     const avgAmt = BaseObj[stknum].avgAmt;\n     const amtPercentage = (currentAmt / avgAmt) * 100;\n\n     allResults[stknum] = {\n      price: columns[3],\n      diff: columns[4],\n      pct: columns[5],\n      amt: amtPercentage.toFixed(2),\n     };\n    }\n   }\n  });\n } catch (error) {\n  console.error("Error fetching data:", error);\n }\n}\n\n<lg id="usewebworkertopic-8">4. Update HTML</lg>\nFinally, update the HTML with the sorted results as before.\n\nfunction updateHTML() {\n const sortedResults = Object.keys(allResults).sort((a, b) =&gt; {\n  return allResults[b].pct - allResults[a].pct;\n });\n\n const tableBody = document.getElementById(\'stockTable\').getElementsByTagName(\'tbody\')[0];\n tableBody.innerHTML = \'\';\n\n sortedResults.forEach(stockCode =&gt; {\n  const row = tableBody.insertRow();\n  const cell1 = row.insertCell(0);\n  const cell2 = row.insertCell(1);\n  const cell3 = row.insertCell(2);\n  const cell4 = row.insertCell(3);\n\n  cell1.textContent = stockCode;\n  cell2.textContent = allResults[stockCode].price;\n  cell3.textContent = allResults[stockCode].diff;\n  cell4.textContent = allResults[stockCode].pct;\n });\n}\n\n<h3 id="usewebworkertopic-9"><o>Benefits of Using Web Workers:</o></h3><lg id="usewebworkertopic-10">1. Responsive UI</lg>:\n- The main thread is free to handle user interactions while the Web Worker processes the data.\n\n<lg id="usewebworkertopic-11">2. Scalability</lg>:\n- You can handle a large `codetable` without degrading the performance of the main thread.\n\n<lg id="usewebworkertopic-12">3. Modularity</lg>:\n- The data collection logic is separated into a Web Worker, making the main script cleaner and easier to maintain.\n\n<h3 id="usewebworkertopic-13"><o>When to Avoid Web Workers:</o></h3>- If the `codetable` is small or the data collection process is quick, using Web Workers might introduce unnecessary complexity.\n- Web Workers cannot directly manipulate the DOM, so you need to post messages back to the main thread for UI updates.\n\nBy using Web Workers, you can efficiently handle large datasets and ensure a smooth user experience.\n',
'<h2>what is object literal</h2>	<center><div id="objectliteraltoc" class="toc"><a href="#objectliteraltopic-0" target="_self">Syntax:</a><br><a href="#objectliteraltopic-1" target="_self">Example:</a><br><a href="#objectliteraltopic-2" target="_self">Key Features of Object Literals:</a><br><a href="#objectliteraltopic-3" target="_self">When to Use Object Literals:</a><br><a href="#objectliteraltopic-4" target="_self">Example with Nested Objects:</a><br></div></center><br><br>\n\n创建对象的方法\nIn JavaScript, an <r>object literal</r> is a way to define and create objects using a concise and readable syntax.\nIt is one of the most common ways to create objects in JavaScript.\nAn object literal is a comma-separated list of key-value pairs enclosed in curly braces {}.\n<y id="objectliteraltopic-0">Syntax:</y>\nlet obj = { key1: value1, key2: value2, ...};\n- <r>Keys</r>: Also called property names, they are strings or symbols.\n- <r>Values</r>: Can be any valid JavaScript value, such as numbers, strings, functions, arrays, or even other objects.\n<y id="objectliteraltopic-1">Example:</y>\nlet person = {\n  name: "Alice",\n  age: 25,\n  isStudent: false,\n  greet: function() {\n    console.log("Hello, my name is " + this.name);\n  }\n};\n\nIn this example:\n- name, age, and isStudent are <r>properties</r> of the person object.\n- greet is a <r>method</r> (a function) of the person object.\n<y id="objectliteraltopic-2">Key Features of Object Literals:</y>\n1. <r>Concise Syntax</r>: Easy to write and read.\n2. <r>Dynamic Properties</r>: You can use variables or expressions as property names using computed property names (enclosed in square brackets []).\n  let key = "status";\n  let obj = {\n    [key]: "active" // Computed property name\n  };\n   console.log(obj); // Output: {status: "active"}\n   \n3. <r>Shorthand Syntax</r>: If the property name and the variable name are the same, you can use shorthand notation.\n  let name = "Bob";\n  let age = 30;\n  let person = { name, age }; // Shorthand for {name: name, age: age}\n  console.log(person); // Output: {name: "Bob", age: 30}\n4. <r>Methods</r>: Functions can be directly defined as properties (methods) within the object.\n   let car = {\n     brand: "Toyota",\n     start() { console.log("Engine started!"); }\n   };\n   car.start(); // Output: "Engine started!"\n   \n<y id="objectliteraltopic-3">When to Use Object Literals:</y>\n- When you need to create a simple object with a fixed set of properties.\n- For configuration objects, data structures, or passing multiple related values as a single entity.\n<y id="objectliteraltopic-4">Example with Nested Objects:</y>\nlet user = {\n  id: 1,\n  name: "John",\n  address: {\n    city: "New York",\n    zip: "10001"\n  }\n};\nconsole.log(user.address.city); // Output: "New York"\nObject literals are a fundamental part of JavaScript and are widely used in modern JavaScript development.\n',
'<h2>{x:i} meaning</h2>	In JavaScript, {x: i} is an object literal that creates an object with a single property.\nHere\'s a breakdown:\n\n- x is the <r>property name</r> (or key).\n- i is the <r>value</r> assigned to the property x.\n<y>Example:</y>\nlet i = 10;\nlet obj = {x: i};\nconsole.log(obj); // Output: {x: 10}\nIn this example:\n- The object obj is created with a property x.\n- The value of x is the value of the variable i, which is 10.\n<y>Key Points:</y>\n1. <r>Property Name</r>: x is the key in the object.\n2. <r>Value</r>: i is the value assigned to the key x.\n3. <r>Dynamic Value</r>: If i is a variable, the value of x will be whatever i holds at the time the object is created.\n<y>Use Cases:</y>\n- Creating objects with dynamic values.\n- Passing configuration options or key-value pairs.\n',
'<h2>web worker example</h2>	<center><div id="webworkerexampletoc" class="toc"><a href="#webworkerexampletopic-0" target="_self">Example: Heavy Load with Web Worker</a><br><a href="#webworkerexampletopic-1" target="_self"> 1. Main Script (main.js)</a><br><a href="#webworkerexampletopic-2" target="_self"> 2. Worker Script (worker.js)</a><br><a href="#webworkerexampletopic-3" target="_self">How It Works:</a><br><a href="#webworkerexampletopic-4" target="_self">Key Benefits:</a><br><a href="#webworkerexampletopic-5" target="_self"> - Non-blocking</a><br><a href="#webworkerexampletopic-6" target="_self"> - Parallel Processing</a><br><a href="#webworkerexampletopic-7" target="_self"> - Heavy Load Handling</a><br><a href="#webworkerexampletopic-8" target="_self">Output:</a><br><a href="#webworkerexampletopic-9" target="_self">Notes:</a><br></div></center><br><br>\n\nWeb Workers are a powerful feature in JavaScript that allow you to run computationally intensive tasks in the background without blocking the main thread (UI thread). This is particularly useful for handling <o>heavy loads</o>, such as complex calculations, large data processing, or tasks that would otherwise cause the browser to become unresponsive.\n\nBelow is an example of how to use a <o>Web Worker</o> to handle a heavy computational load, such as calculating Fibonacci numbers (a common example of a computationally expensive task).\n<y id="webworkerexampletopic-0">Example: Heavy Load with Web Worker</y>\n<r id="webworkerexampletopic-1"> 1. Main Script (main.js)</r>\nThis script creates a Web Worker and communicates with it to perform a heavy computation.\n\n// Create a new Web Worker\nconst worker = new Worker(\'worker.js\');\n\n// Listen for messages from the worker\nworker.addEventListener(\'message\', (event) =&gt; {\n  console.log(`Result from worker: ${event.data}`);\n});\n\n// Send a message to the worker to start the computation\nconst number = 40; // Fibonacci number to calculate (large number for heavy load)\nworker.postMessage(number);\nconsole.log(\'Main thread is free to do other work...\');\n\n<r id="webworkerexampletopic-2"> 2. Worker Script (worker.js)</r>\nThis script runs in the background and performs the heavy computation.\n\n// Listen for messages from the main thread\nself.addEventListener(\'message\', (event) =&gt; {\n  const number = event.data;\n\n  // Perform the heavy computation (Fibonacci)\n  const result = fibonacci(number);\n\n  // Send the result back to the main thread\n  self.postMessage(result);\n});\n\n// Fibonacci function (computationally expensive)\nfunction fibonacci(n) {\n  if (n &lt;= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n<y id="webworkerexampletopic-3">How It Works:</y>\n1. The <o>main script</o> creates a Web Worker and sends it a number (e.g., `40`) to calculate the Fibonacci sequence.\n2. The <o>worker script</o> performs the heavy computation in the background without blocking the main thread.\n3. Once the computation is complete, the worker sends the result back to the main thread using `postMessage`.\n4. The main thread listens for the result and logs it to the console.\n<y id="webworkerexampletopic-4">Key Benefits:</y>\n<r id="webworkerexampletopic-5"> - Non-blocking</r>: The main thread remains responsive, allowing the UI to update and handle user interactions.\n<r id="webworkerexampletopic-6"> - Parallel Processing</r>: The Web Worker runs in a separate thread, enabling true parallelism.\n<r id="webworkerexampletopic-7"> - Heavy Load Handling</r>: Ideal for tasks like data processing, image manipulation, or complex algorithms.\n<y id="webworkerexampletopic-8">Output:</y>\nWhen you run the above code, you\'ll see something like this in the console:\nMain thread is free to do other work...\nResult from worker: 102334155\n\nThe main thread remains free to handle other tasks while the Web Worker computes the Fibonacci number in the background.\n<y id="webworkerexampletopic-9">Notes:</y>\n- Web Workers do not have access to the DOM or `window` object. They are designed for pure computation and data processing.\n- Use `postMessage` to communicate between the main thread and the worker.\n- Terminate the worker when it\'s no longer needed to free up resources:\n\n  worker.terminate();\n\n',
'<h2>Uncaught SecurityError</h2>	<center><div id="SecurityErrortoc" class="toc"><a href="#SecurityErrortopic-0" target="_self">Why Does This Happen?</a><br><a href="#SecurityErrortopic-1" target="_self"> 1. Same-Origin Policy</a><br><a href="#SecurityErrortopic-2" target="_self"> 2. `file://` Protocol</a><br><a href="#SecurityErrortopic-3" target="_self">How to Fix It</a><br><a href="#SecurityErrortopic-4" target="_self"> 1. Use a Local Web Server</a><br><a href="#SecurityErrortopic-5" target="_self">  Options for a Local Web Server</a><br><a href="#SecurityErrortopic-6" target="_self"> 2. Use a Bundler or Development Tool</a><br><a href="#SecurityErrortopic-7" target="_self"> 3. Browser-Specific Workarounds</a><br><a href="#SecurityErrortopic-8" target="_self">Example with a Local Web Server</a><br><a href="#SecurityErrortopic-9" target="_self"> 1. Folder Structure</a><br><a href="#SecurityErrortopic-10" target="_self"> 2. Serve the Files</a><br><a href="#SecurityErrortopic-11" target="_self"> 3. Access the Files</a><br><a href="#SecurityErrortopic-12" target="_self"> 4. Code</a><br><a href="#SecurityErrortopic-13" target="_self">Why This Works</a><br></div></center><br><br>\n\nThe error `Uncaught SecurityError: Failed to construct \'Worker\': Script at \'file:///C:/Users/User/Desktop/worker.js\' cannot be accessed from origin \'null\'.` occurs because of how browsers handle Web Workers and cross-origin requests when running JavaScript locally (e.g., from a `file://` URL).\n<y id="SecurityErrortopic-0">Why Does This Happen?</y>\n<o id="SecurityErrortopic-1"> 1. Same-Origin Policy</o>:\n- Browsers enforce a same-origin policy for security reasons. This means that scripts (including Web Workers) must be loaded from the same origin (protocol, domain, and port) as the main page.\n- When you open a local HTML file (e.g., `file:///C:/Users/User/Desktop/index.html`), the origin is considered `null`, and the browser blocks access to other local files (like `worker.js`) due to security restrictions.\n\n<o id="SecurityErrortopic-2"> 2. `file://` Protocol</o>:\n- The `file://` protocol is treated differently by browsers. It does not allow loading external resources (like Web Workers) from the local file system unless specific security settings are configured.\n<y id="SecurityErrortopic-3">How to Fix It</y>\nTo resolve this issue, you need to serve your files using a local web server instead of opening them directly from the file system. Here are some solutions:\n<o id="SecurityErrortopic-4"> 1. Use a Local Web Server</o>\n- Run a local web server to serve your files over `http://` or `https://` instead of `file://`.\n- This ensures that the browser treats your files as coming from the same origin.\n\n<o id="SecurityErrortopic-5">  Options for a Local Web Server</o>:\n- VS Code Live Server Extension: If you\'re using Visual Studio Code, install the [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) extension and use it to serve your files.\n- Python Simple HTTP Server:\n     ```bash\n     python -m http.server 8000\n     Navigate to `http://localhost:8000` in your browser.\n- Node.js HTTP Server:\n     Install a simple HTTP server using Node.js:\n     ```bash\n     npx http-server\n     Navigate to `http://localhost:8080` in your browser.\n<o id="SecurityErrortopic-6"> 2. Use a Bundler or Development Tool</o>\n- If you\'re working on a larger project, use a bundler like Webpack, Parcel, or Vite. These tools come with built-in development servers that handle local file serving.\n<o id="SecurityErrortopic-7"> 3. Browser-Specific Workarounds</o>\n- Some browsers allow you to disable security restrictions for local files, but this is not recommended for security reasons.\n- For example, in Chrome, you can launch the browser with the `--allow-file-access-from-files` flag:\n     ```bash\n     chrome.exe --allow-file-access-from-files\n     Warning: This exposes your system to potential security risks.\n<y id="SecurityErrortopic-8">Example with a Local Web Server</y>\n\n<o id="SecurityErrortopic-9"> 1. Folder Structure</o>:\n   project/\n   ├── index.html\n   ├── main.js\n   └── worker.js\n\n<o id="SecurityErrortopic-10"> 2. Serve the Files</o>:\n   Use a local web server (e.g., Python HTTP server):\n   ```bash\n   cd project\n   python -m http.server 8000\n\n<o id="SecurityErrortopic-11"> 3. Access the Files</o>:\n   Open your browser and navigate to:\n   http://localhost:8000\n\n<o id="SecurityErrortopic-12"> 4. Code</o>:\n     &lt;body&gt;\n       &lt;script src="main.js"&gt;&lt;/script&gt;\n     &lt;/body&gt;\n\n- `main.js`:\n     const worker = new Worker(\'worker.js\');\n     worker.postMessage(40);\n     worker.addEventListener(\'message\', (event) =&gt; {\n       console.log(`Result from worker: ${event.data}`);\n     });\n- `worker.js`:\n     self.addEventListener(\'message\', (event) =&gt; {\n       const result = fibonacci(event.data);\n       self.postMessage(result);\n     });\n\n     function fibonacci(n) {\n       if (n &lt;= 1) return n;\n       return fibonacci(n - 1) + fibonacci(n - 2);\n     }\n<y id="SecurityErrortopic-13">Why This Works</y>\nBy serving your files over `http://localhost`, the browser treats them as coming from the same origin, and the Web Worker can be loaded without security restrictions.\n',
'<h2>Object literals examples</h2>	<center><div id="literalsexamplestoc" class="toc"><a href="#literalsexamplestopic-0" target="_self">1. Configuration Objects</a><br><a href="#literalsexamplestopic-1" target="_self">2. Data Structures</a><br><a href="#literalsexamplestopic-2" target="_self">3. API Responses</a><br><a href="#literalsexamplestopic-3" target="_self">4. Function Return Values</a><br><a href="#literalsexamplestopic-4" target="_self">5. Dynamic Property Names</a><br><a href="#literalsexamplestopic-5" target="_self">6. Methods in Objects</a><br><a href="#literalsexamplestopic-6" target="_self">7. Grouping Related Data</a><br><a href="#literalsexamplestopic-7" target="_self">8. Shorthand Syntax</a><br><a href="#literalsexamplestopic-8" target="_self">9. Default Function Parameters</a><br><a href="#literalsexamplestopic-9" target="_self">10. Simulating Namespaces</a><br><a href="#literalsexamplestopic-10" target="_self">Summary</a><br></div></center><br><br>\n\nObject literals are incredibly versatile in JavaScript and are used in a wide variety of applications.\nBelow are some "practical examples" of how object literals can be used in real-world scenarios:\n\n<y id="literalsexamplestopic-0">1. Configuration Objects</y>\nObject literals are often used to pass configuration options to functions or libraries.\n// Configuration for a chart library\nconst chartConfig = {\n  type: \'bar\',\n  data: {\n    labels: [\'January\', \'February\', \'March\'],\n    datasets: [{\n      label: \'Sales\',\n      data: [65, 59, 80]\n    }]\n  },\n  options: {\n    responsive: true,\n    title: {\n      display: true,\n      text: \'Monthly Sales Data\'\n    }\n  }\n};\n\n// Function to initialize a chart\nfunction initializeChart(config) {\n  console.log(\'Initializing chart with config:\', config);\n}\n\ninitializeChart(chartConfig);\n\n<y id="literalsexamplestopic-1">2. Data Structures</y>\nObject literals can represent complex data structures, such as nested objects or collections.\n// Representing a user profile\nconst userProfile = {\n  id: 1,\n  name: \'John Doe\',\n  email: \'john.doe@example.com\',\n  address: {\n    street: \'123 Main St\',\n    city: \'New York\',\n    zip: \'10001\'\n  },\n  hobbies: [\'reading\', \'traveling\', \'coding\']\n};\n\nconsole.log(userProfile.address.city); // Output: "New York"\nconsole.log(userProfile.hobbies[2]); // Output: "coding"\n\n<y id="literalsexamplestopic-2">3. API Responses</y>\nObject literals are commonly used to structure data returned from APIs.\n// Simulated API response\nconst apiResponse = {\n  status: \'success\',\n  data: {\n    users: [\n      { id: 1, name: \'Alice\' },\n      { id: 2, name: \'Bob\' }\n    ]\n  },\n  timestamp: \'2023-10-01T12:00:00Z\'\n};\n\nconsole.log(apiResponse.data.users[0].name); // Output: "Alice"\n\n<y id="literalsexamplestopic-3">4. Function Return Values</y>\nFunctions can return object literals to provide structured data.\n// Function to create a user object\nfunction createUser(name, email) {\n  return {\n    name: name,\n    email: email,\n    createdAt: new Date().toISOString()\n  };\n}\n\nconst newUser = createUser(\'Jane Doe\', \'jane.doe@example.com\');\nconsole.log(newUser);\n// Output: { name: "Jane Doe", email: "jane.doe@example.com", createdAt: "2023-10-01T12:00:00Z" }\n\n<y id="literalsexamplestopic-4">5. Dynamic Property Names</y>\nObject literals support computed property names, allowing you to dynamically define keys.\nconst dynamicKey = \'status\';\nconst user = {\n  id: 1,\n  name: \'John\',\n  [dynamicKey]: \'active\' // Computed property name\n};\n\nconsole.log(user.status); // Output: "active"\n\n<y id="literalsexamplestopic-5">6. Methods in Objects</y>\nObject literals can include functions (methods) to encapsulate behavior.\nconst calculator = {\n  add(a, b) {\n    return a + b;\n  },\n  subtract(a, b) {\n    return a - b;\n  }\n};\n\nconsole.log(calculator.add(5, 3)); // Output: 8\nconsole.log(calculator.subtract(5, 3)); // Output: 2\n\n<y id="literalsexamplestopic-6">7. Grouping Related Data</y>\nObject literals are great for grouping related data and functionality.\nconst car = {\n  make: \'Toyota\',\n  model: \'Camry\',\n  year: 2020,\n  drive() {\n    console.log(`Driving the ${this.make} ${this.model}`);\n  }\n};\n\ncar.drive(); // Output: "Driving the Toyota Camry"\n\n<y id="literalsexamplestopic-7">8. Shorthand Syntax</y>\nWhen property names and variable names are the same, you can use shorthand syntax.\nconst name = \'Alice\';\nconst age = 30;\n\nconst person = { name, age }; // Shorthand for { name: name, age: age }\nconsole.log(person); // Output: { name: "Alice", age: 30 }\n\n<y id="literalsexamplestopic-8">9. Default Function Parameters</y>\nObject literals can be used to provide default parameters in functions.\nfunction createPost(title, content, options = {}) {\n  const defaults = {\n    author: \'Anonymous\',\n    date: new Date().toISOString(),\n    isPublished: false\n  };\n\n  return {\n    title,\n    content,\n    ...defaults,\n    ...options // Override defaults with provided options\n  };\n}\n\nconst post = createPost(\'My First Post\', \'Hello, world!\', { isPublished: true });\nconsole.log(post);\n// Output: { title: "My First Post", content: "Hello, world!", author: "Anonymous", date: "2023-10-01T12:00:00Z", isPublished: true }\n\n<y id="literalsexamplestopic-9">10. Simulating Namespaces</y>\nObject literals can be used to create namespaces and avoid polluting the global scope.\nconst MyApp = {\n  utils: {\n    formatDate(date) {\n      return date.toISOString();\n    }\n  },\n  services: {\n    fetchData() {\n      return \'Data from server\';\n    }\n  }\n};\n\nconsole.log(MyApp.utils.formatDate(new Date())); // Output: "2023-10-01T12:00:00.000Z"\nconsole.log(MyApp.services.fetchData()); // Output: "Data from server"\n\n<y id="literalsexamplestopic-10">Summary</y>\nObject literals are a fundamental part of JavaScript and are used in many scenarios, including:\n- Configuration objects\n- Data structures\n- API responses\n- Function return values\n- Grouping related data and functionality\n- Simulating namespaces\n\nThey provide a clean and concise way to organize and work with data in JavaScript. Let me know if you\'d like more examples or further clarification!\n',
'<h2>async request in burst mode may block the progress</h2>	When you have a lot of asynchronous requests happening in burst mode in JavaScript, it can lead to performance issues, such as blocking the main thread, overwhelming the network, or exhausting system resources. Here are some strategies to mitigate these issues:\n<h3><y>1. Throttle or Debounce Requests</y></h3>- Use throttling or debouncing to limit the number of requests sent in a given time frame.\n- Throttling: Ensures that a function is called at most once in a specified period.\n- Debouncing: Ensures that a function is called only after a certain amount of time has passed since the last call.\n  Example:\n  function throttle(func, limit) {\n    let inThrottle;\n    return function() {\n      const args = arguments;\n      const context = this;\n      if (!inThrottle) {\n        func.apply(context, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n  const throttledRequest = throttle(async () => {\n    await fetch(\'https://example.com/api\');\n  }, 1000); // Limit to 1 request per second\n<h3><y>2. Batch Requests</y></h3>- Combine multiple requests into a single request if the API supports batching.\n- This reduces the number of network calls and improves efficiency.\n  Example:\n  async function batchRequests(urls) {\n    const responses = await Promise.all(urls.map(url => fetch(url)));\n    return Promise.all(responses.map(res => res.json()));\n  }\n  const urls = [\'https://example.com/api/1\', \'https://example.com/api/2\'];\n  batchRequests(urls).then(data => console.log(data));\n<h3><y>3. Use a Queue for Request Management</y></h3>- Implement a queue system to process requests sequentially or in controlled batches.\n- Libraries like `p-queue` can help manage concurrency.\n\n  Example with `p-queue`:\n  import PQueue from \'p-queue\';\n  const queue = new PQueue({ concurrency: 5 }); // Limit to 5 concurrent requests\n  async function makeRequest(url) {\n    const response = await fetch(url);\n    return response.json();\n  }\n\n  const urls = [\'https://example.com/api/1\', \'https://example.com/api/2\', ...];\n  urls.forEach(url => {\n    queue.add(() => makeRequest(url));\n  });\n<h3><y>4. Prioritize Requests</y></h3>- Prioritize critical requests and delay or drop less important ones.\n- Use a priority queue to manage the order of requests.\n  Example:\n  const highPriorityQueue = new PQueue({ concurrency: 1 });\n  const lowPriorityQueue = new PQueue({ concurrency: 1 });\n\n  highPriorityQueue.add(() => fetch(\'/critical-api\'));\n  lowPriorityQueue.add(() => fetch(\'/non-critical-api\'));\n<h3><y>5. Use Web Workers</y></h3>- Offload heavy processing or network requests to Web Workers to avoid blocking the main thread.\n- Web Workers run in a separate thread, so they won\'t interfere with the UI.\n  Example:\n  // main.js\n  const worker = new Worker(\'worker.js\');\n  worker.postMessage({ urls: [\'https://example.com/api/1\', \'https://example.com/api/2\'] });\n\n  worker.onmessage = (event) => {\n    console.log(\'Received data:\', event.data);\n  };\n  // worker.js\n  self.onmessage = async (event) => {\n    const urls = event.data.urls;\n    const responses = await Promise.all(urls.map(url => fetch(url)));\n    const data = await Promise.all(responses.map(res => res.json()));\n    self.postMessage(data);\n  };\n<h3><y>6. Optimize Network Usage</y></h3>- Use HTTP/2 or HTTP/3 to take advantage of multiplexing and reduce latency.\n- Enable compression (e.g., gzip) to reduce the size of the data being transferred.\n<h3><y>7. Limit Concurrent Requests</y></h3>- Use libraries like `axios` with concurrency control or manually limit the number of concurrent requests.\n  Example with `axios`:\n  const axios = require(\'axios\');\n  const { default: PQueue } = require(\'p-queue\');\n  const queue = new PQueue({ concurrency: 5 });\n  const urls = [\'https://example.com/api/1\', \'https://example.com/api/2\', ...];\n  const requests = urls.map(url => queue.add(() => axios.get(url)));\n  Promise.all(requests).then(responses => {\n    console.log(\'All requests completed:\', responses);\n  });\n<h3><y>8. Use Caching</y></h3>- Cache responses to avoid redundant requests.\n- Use browser caching, service workers, or an in-memory cache like `lru-cache`.\n  Example:\n  const cache = new Map();\n  async function fetchWithCache(url) {\n    if (cache.has(url)) {\n      return cache.get(url);\n    }\n    const response = await fetch(url);\n    const data = await response.json();\n    cache.set(url, data);\n    return data;\n  }\n<h3><y>9. Monitor and Adjust</y></h3>- Use performance monitoring tools (e.g., Chrome DevTools, Lighthouse) to identify bottlenecks.\n- Adjust concurrency limits, batch sizes, or other parameters based on real-world performance.\nBy combining these strategies, you can effectively manage burst-mode async requests and prevent them from blocking the main thread or overwhelming the system.\n',
'<h2>run web worker in browser</h2>	<center><div id="runwebworkertoc" class="toc"><a href="#runwebworkertopic-0" target="_self"><pk>Introduction</pk></a><br><a href="#runwebworkertopic-1" target="_self"><pk>How to Use Web Workers</pk></a><br><a href="#runwebworkertopic-2" target="_self"> 1. Create a Web Worker Script</a><br><a href="#runwebworkertopic-3" target="_self"> 2. Use the Web Worker in Your Main Script</a><br><a href="#runwebworkertopic-4" target="_self"> 3. Run It in the Browser</a><br><a href="#runwebworkertopic-5" target="_self"><pk>Key Points to Remember</pk></a><br><a href="#runwebworkertopic-6" target="_self"> 1. Same-Origin Policy</a><br><a href="#runwebworkertopic-7" target="_self"> 2. No DOM Access</a><br><a href="#runwebworkertopic-8" target="_self"> 3. Browser Support</a><br><a href="#runwebworkertopic-9" target="_self"> 4. Inline Workers (Alternative)</a><br><a href="#runwebworkertopic-10" target="_self"><pk>When to Use Web Workers Without a Server</pk></a><br><a href="#runwebworkertopic-11" target="_self"> - Heavy Computations</a><br><a href="#runwebworkertopic-12" target="_self"> - Background Tasks</a><br><a href="#runwebworkertopic-13" target="_self"> - Parallel Processing</a><br><a href="#runwebworkertopic-14" target="_self"><pk>Debugging Web Workers</pk></a><br></div></center><br><br>\n\n<h3 id="runwebworkertopic-0"><pk>Introduction</pk></h3>use Web Workers in a browser without needing a server in the background.\nWeb Workers run in a separate thread from the main browser thread, allowing you to perform tasks like heavy computations, data processing, or asynchronous operations without blocking the UI.\nThey work entirely on the client side, so no server is required.\nBut when run in local machine mode, the browser will block connection by CORS, so run it in local server: localhost.\n<h3 id="runwebworkertopic-1"><pk>How to Use Web Workers</pk></h3><o id="runwebworkertopic-2"> 1. Create a Web Worker Script</o>:\n  Write a separate JavaScript file that contains the logic for the worker.\n  Example: `worker.js`\n  // worker.js\n  self.onmessage = function(event) {\n    const data = event.data;\n    console.log(\'Message received in worker:\', data);\n\n    // Perform some computation or task\n    const result = data * 2;\n\n    // Send the result back to the main thread\n    self.postMessage(result);\n  };\n\n\n<o id="runwebworkertopic-3"> 2. Use the Web Worker in Your Main Script</o>:\n  In your main JavaScript file, create a `Worker` object and communicate with it.\n  Example: `main.js`\n  // main.js\n  const worker = new Worker(\'worker.js\');\n\n  // Send a message to the worker\n  worker.postMessage(10);\n\n  // Listen for messages from the worker\n  worker.onmessage = function(event) {\n    console.log(\'Result from worker:\', event.data);\n  };\n\n<o id="runwebworkertopic-4"> 3. Run It in the Browser</o>:\n  Open your HTML file in a browser. The Web Worker will run in the background, and you can see the communication between the main thread and the worker in the browser\'s console.\n  Example: `index.html`\n    &lt;script src="main.js"&gt;&lt;/script&gt;\n<h3 id="runwebworkertopic-5"><pk>Key Points to Remember</pk></h3><o id="runwebworkertopic-6"> 1. Same-Origin Policy</o>:\n  - The Web Worker script must be served from the same origin as the main script (unless you use `importScripts` with CORS-enabled resources).\n  - If you\'re running the HTML file locally (e.g., `file://` protocol), some browsers may block Web Workers due to security restrictions. To avoid this, use a local development server (e.g., `http-server`, `live-server`, or VS Code\'s Live Server extension).\n\n<o id="runwebworkertopic-7"> 2. No DOM Access</o>:\n  - Web Workers cannot access the DOM or `window` object directly. They are designed to offload tasks that don\'t require UI updates.\n\n<o id="runwebworkertopic-8"> 3. Browser Support</o>:\n  - Web Workers are supported in all modern browsers. However, if you\'re using advanced features like `SharedArrayBuffer` or `Module Workers`, check for compatibility.\n\n<o id="runwebworkertopic-9"> 4. Inline Workers (Alternative)</o>:\n  - If you don\'t want to use a separate file for the worker, you can create an **inline worker** using a `Blob` or `URL.createObjectURL`.\n  Example of an Inline Worker:\n  const workerCode = `\n    self.onmessage = function(event) {\n      const result = event.data * 2;\n      self.postMessage(result);\n    };\n  `;\n\n  const blob = new Blob([workerCode], { type: \'application/javascript\' });\n  const worker = new Worker(URL.createObjectURL(blob));\n\n  worker.postMessage(10);\n  worker.onmessage = function(event) {\n    console.log(\'Result from inline worker:\', event.data);\n  };\n\n<h3 id="runwebworkertopic-10"><pk>When to Use Web Workers Without a Server</pk></h3><r id="runwebworkertopic-11"> - Heavy Computations</r>: Offload tasks like image processing, data analysis, or complex calculations.\n<r id="runwebworkertopic-12"> - Background Tasks</r>: Perform tasks that don\'t need to block the main thread, such as polling or logging.\n<r id="runwebworkertopic-13"> - Parallel Processing</r>: Use multiple workers to divide and conquer tasks.\n<h3 id="runwebworkertopic-14"><pk>Debugging Web Workers</pk></h3>- Use the browser\'s developer tools (e.g., Chrome DevTools) to debug Web Workers. You can inspect messages, set breakpoints, and monitor performance.\nBy using Web Workers, you can significantly improve the performance and responsiveness of your web application, even without a server in the background.\n',
'<h2>burst-mode Web Workers </h2>	<center><div id="burst-modeWebWorkerstoc" class="toc"><a href="#burst-modeWebWorkerstopic-0" target="_self"><y>Why Does `net::ERR_INSUFFICIENT_RESOURCES` Happen?</y></a><br><a href="#burst-modeWebWorkerstopic-1" target="_self">1. Browser Limits</a><br><a href="#burst-modeWebWorkerstopic-2" target="_self">2. Resource Exhaustion</a><br><a href="#burst-modeWebWorkerstopic-3" target="_self">3. Operating System Limits</a><br><a href="#burst-modeWebWorkerstopic-4" target="_self"><y>How to Avoid `net::ERR_INSUFFICIENT_RESOURCES` in Web Workers</y></a><br><a href="#burst-modeWebWorkerstopic-5" target="_self">1. Limit Concurrent Requests</a><br><a href="#burst-modeWebWorkerstopic-6" target="_self">2. Reuse Workers</a><br><a href="#burst-modeWebWorkerstopic-7" target="_self">3. Batch Requests</a><br><a href="#burst-modeWebWorkerstopic-8" target="_self">4. Throttle or Debounce Requests</a><br><a href="#burst-modeWebWorkerstopic-9" target="_self">5. Monitor Resource Usage</a><br><a href="#burst-modeWebWorkerstopic-10" target="_self">6. Graceful Error Handling</a><br><a href="#burst-modeWebWorkerstopic-11" target="_self">7. Use Service Workers for Caching</a><br><a href="#burst-modeWebWorkerstopic-12" target="_self"><y>Example: Web Worker with Controlled Concurrency</y></a><br><a href="#burst-modeWebWorkerstopic-13" target="_self"><y>Key Takeaways</y></a><br></div></center><br><br>\n\nWhen using **Web Workers** to handle **burst-mode async requests**, it is possible to encounter the `net::ERR_INSUFFICIENT_RESOURCES` error in the browser. This error occurs when the browser exhausts its available resources (e.g., network sockets, memory, or file descriptors) due to an excessive number of concurrent requests or tasks.\n<h3 id="burst-modeWebWorkerstopic-0"><y>Why Does `net::ERR_INSUFFICIENT_RESOURCES` Happen?</y></h3><r id="burst-modeWebWorkerstopic-1">1. Browser Limits</r>:\n- Browsers impose limits on the number of concurrent network requests (e.g., 6-8 per domain in Chrome). If you exceed these limits, the browser may throw this error.\n- Web Workers can exacerbate this issue because each worker can independently make network requests, potentially overwhelming the browser\'s network stack.\n<r id="burst-modeWebWorkerstopic-2">2. Resource Exhaustion</r>:\n- Each Web Worker consumes memory and other system resources. If you create too many workers or make too many requests from them, the browser may run out of resources.\n<r id="burst-modeWebWorkerstopic-3">3. Operating System Limits</r>:\n- The operating system may also impose limits on the number of open sockets or file descriptors, which can contribute to this error.\n<h3 id="burst-modeWebWorkerstopic-4"><y>How to Avoid `net::ERR_INSUFFICIENT_RESOURCES` in Web Workers</y></h3><r id="burst-modeWebWorkerstopic-5">1. Limit Concurrent Requests</r>:\n- Use a queue or a library like `p-queue` to limit the number of concurrent requests made by Web Workers.\n- Example:\nconst PQueue = require(\'p-queue\');\nconst queue = new PQueue({ concurrency: 5 }); // Limit to 5 concurrent requests\nasync function fetchData(url) {\n  const response = await fetch(url);\n  return response.json();\n}\n\nconst urls = [\'https://example.com/api/1\', \'https://example.com/api/2\', ...];\nurls.forEach(url =&gt; {\n  queue.add(() =&gt; fetchData(url));\n});\n<r id="burst-modeWebWorkerstopic-6">2. Reuse Workers</r>:\n- Instead of creating a new worker for each request, reuse a pool of workers. This reduces the overhead of creating and destroying workers.\n- Example:\nconst workerPool = [];\nconst workerCount = 4; // Number of workers in the pool\nfor (let i = 0; i &lt; workerCount; i++) {\n const worker = new Worker(\'worker.js\');\n workerPool.push(worker);\n}\nfunction assignTaskToWorker(data) {\n const worker = workerPool.pop();\n worker.postMessage(data);\n worker.onmessage = (event) =&gt; {\n  console.log(\'Result:\', event.data);\n  workerPool.push(worker); // Return worker to the pool\n };\n}\n<r id="burst-modeWebWorkerstopic-7">3. Batch Requests</r>:\n- Combine multiple requests into a single request if the API supports batching. This reduces the number of network calls.\n<r id="burst-modeWebWorkerstopic-8">4. Throttle or Debounce Requests</r>:\n- Use throttling or debouncing to limit the rate at which requests are made.\n<r id="burst-modeWebWorkerstopic-9">5. Monitor Resource Usage</r>:\n- Use browser developer tools to monitor memory and network usage. If you notice resource exhaustion, reduce the number of concurrent workers or requests.\n<r id="burst-modeWebWorkerstopic-10">6. Graceful Error Handling</r>:\n- Implement retry logic with exponential backoff to handle transient errors like `net::ERR_INSUFFICIENT_RESOURCES`.\n- Example:\nasync function fetchWithRetry(url, retries = 3) {\n try {\n   const response = await fetch(url);\n   return response.json();\n } catch (error) {\n   if (retries &gt; 0) {\n     console.log(`Retrying... (${retries} attempts left)`);\n     await new Promise(resolve =&gt; setTimeout(resolve, 1000)); // Wait 1 second\n     return fetchWithRetry(url, retries - 1);\n   } else {\n     throw error;\n   }\n }\n}\n<r id="burst-modeWebWorkerstopic-11">7. Use Service Workers for Caching</r>:\n- Cache responses using a Service Worker to reduce the number of network requests.\n<h3 id="burst-modeWebWorkerstopic-12"><y>Example: Web Worker with Controlled Concurrency</y></h3>Here’s an example of using Web Workers with controlled concurrency to avoid `net::ERR_INSUFFICIENT_RESOURCES`:\n\n// worker.js\nself.onmessage = async function(event) {\n const url = event.data;\n try {\n  const response = await fetch(url);\n  const data = await response.json();\n  self.postMessage({ success: true, data });\n } catch (error) {\n  self.postMessage({ success: false, error: error.message });\n }\n};\n\n// main.js\nconst workerPool = [];\nconst workerCount = 4; // Number of workers in the pool\nconst urls = [\'https://example.com/api/1\', \'https://example.com/api/2\', ...];\n\nfor (let i = 0; i &lt; workerCount; i++) {\n  const worker = new Worker(\'worker.js\');\n  workerPool.push(worker);\n}\n\nasync function processUrls(urls) {\n  for (const url of urls) {\n    const worker = workerPool.pop();\n    worker.postMessage(url);\n    worker.onmessage = (event) =&gt; {\n      if (event.data.success) {\n        console.log(\'Data:\', event.data.data);\n      } else {\n        console.error(\'Error:\', event.data.error);\n      }\n      workerPool.push(worker); // Return worker to the pool\n    };\n    await new Promise(resolve =&gt; setTimeout(resolve, 100)); // Add a small delay\n  }\n}\n\nprocessUrls(urls);\n<h3 id="burst-modeWebWorkerstopic-13"><y>Key Takeaways</y></h3>- Web Workers can help offload tasks, but they don\'t bypass browser or OS resource limits.\n- Use **concurrency control**, **batching**, and **caching** to avoid overwhelming the browser.\n- Monitor resource usage and implement retry logic to handle transient errors gracefully.\n',
'<h2>p-queue library</h2>	<center><div id="p-queuetoc" class="toc"><a href="#p-queuetopic-0" target="_self">1. Install `p-queue`</a><br><a href="#p-queuetopic-1" target="_self">2. Use a CDN (No Build Tool Required)</a><br><a href="#p-queuetopic-2" target="_self">3. Example: Using `p-queue` for Controlled API Requests</a><br><a href="#p-queuetopic-3" target="_self">4. Key Features of `p-queue`</a><br><a href="#p-queuetopic-4" target="_self">- Concurrency Control</a><br><a href="#p-queuetopic-5" target="_self">- Queue Management</a><br><a href="#p-queuetopic-6" target="_self">- Event Hooks</a><br><a href="#p-queuetopic-7" target="_self">- Priority Support</a><br><a href="#p-queuetopic-8" target="_self">5. Debugging and Monitoring</a><br><a href="#p-queuetopic-9" target="_self">6. Browser Compatibility</a><br></div></center><br><br>\n\nTo use the `p-queue` library in a browser environment, you need to include it in your project and ensure it works in the browser context. `p-queue` is a promise-based queue that helps manage concurrency, making it ideal for controlling the number of concurrent async tasks like API requests.\n\nHere’s how you can use `p-queue` in the browser:\n<h3 id="p-queuetopic-0">1. Install `p-queue`</h3>If you\'re using a build tool like Webpack, Parcel, or Vite, you can install `p-queue` via npm:\n\nnpm install p-queue\n\nThen, import it into your JavaScript file:\nimport PQueue from \'p-queue\';\n\nconst queue = new PQueue({ concurrency: 5 }); // Limit to 5 concurrent tasks\n<h3 id="p-queuetopic-1">2. Use a CDN (No Build Tool Required)</h3>If you\'re not using a build tool, you can include `p-queue` directly in your HTML file using a CDN like esm.sh or unpkg.\n\nExample using esm.sh:\n&lt;script type="module"&gt;\n import PQueue from \'https://esm.sh/p-queue\';\n\n const queue = new PQueue({ concurrency: 2 }); // Limit to 2 concurrent tasks\n\n async function fetchData(url) {\n  const response = await fetch(url);\n  const data = await response.json();\n  console.log(\'Fetched data:\', data);\n  return data;\n }\n\n const urls = [\n  \'https://jsonplaceholder.typicode.com/posts/1\',\n  //....\n  \'https://jsonplaceholder.typicode.com/posts/4\',\n ];\n\n urls.forEach(url =&gt; {\n  queue.add(() =&gt; fetchData(url));\n });\n&lt;/script&gt;\n<h3 id="p-queuetopic-2">3. Example: Using `p-queue` for Controlled API Requests</h3>Here’s a complete example of using `p-queue` to control the number of concurrent API requests in the browser:\n&lt;script type="module"&gt;\n import PQueue from \'https://esm.sh/p-queue\';\n\n // Create a queue with a concurrency limit of 3\n const queue = new PQueue({ concurrency: 3 });\n\n // Function to fetch data from an API\n async function fetchData(url) {\n  try {\n   const response = await fetch(url);\n   if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n   }\n   const data = await response.json();\n   console.log(\'Fetched data:\', data);\n   return data;\n  } catch (error) {\n   console.error(\'Error fetching data:\', error);\n   throw error;\n  }\n }\n\n // Array of URLs to fetch\n const urls = [\n  \'https://jsonplaceholder.typicode.com/posts/1\',\n  //....\n  \'https://jsonplaceholder.typicode.com/posts/6\',\n ];\n\n // Add each URL to the queue\n urls.forEach(url =&gt; {\n  queue.add(() =&gt; fetchData(url))\n   .then(data =&gt; {\n    console.log(\'Processed data:\', data);\n   })\n   .catch(error =&gt; {\n    console.error(\'Task failed:\', error);\n   });\n });\n\n // Log when the queue is empty\n queue.onEmpty(() =&gt; {\n  console.log(\'Queue is empty! All tasks are done.\');\n });\n\n // Log when all tasks are completed\n queue.onIdle(() =&gt; {\n  console.log(\'Queue is idle! All tasks are completed.\');\n });\n<h3 id="p-queuetopic-3">4. Key Features of `p-queue`</h3><r id="p-queuetopic-4">- Concurrency Control</r>: Limit the number of tasks running concurrently.\n<r id="p-queuetopic-5">- Queue Management</r>: Add tasks to the queue and handle them in a controlled manner.\n<r id="p-queuetopic-6">- Event Hooks</r>: Use `onEmpty`, `onIdle`, and other event hooks to monitor the queue\'s state.\n<r id="p-queuetopic-7">- Priority Support</r>: Assign priorities to tasks to control their execution order.\n<h3 id="p-queuetopic-8">5. Debugging and Monitoring</h3>- Use `console.log` to debug tasks added to the queue.\n- Monitor the queue\'s state using `queue.size` (number of pending tasks) and `queue.pending` (number of tasks currently running).\n\nExample:\nconsole.log(\'Pending tasks:\', queue.size);\nconsole.log(\'Tasks running:\', queue.pending);\n<h3 id="p-queuetopic-9">6. Browser Compatibility</h3>- `p-queue` relies on Promises, which are supported in all modern browsers.\n- If you need to support older browsers, use a polyfill for `Promise`.\n',
'<h2>`&lt;script&gt;` and `&lt;script type="module"&gt;`</h2>	<center><div id="scripttypetoc" class="toc"><a href="#scripttypetopic-0" target="_self">1. Module Scope vs Global Scope</a><br><a href="#scripttypetopic-1" target="_self">2. Strict Mode</a><br><a href="#scripttypetopic-2" target="_self">3. Deferred Execution</a><br><a href="#scripttypetopic-3" target="_self">4. Cross-Origin Restrictions</a><br><a href="#scripttypetopic-4" target="_self">5. Import/Export Syntax</a><br><a href="#scripttypetopic-5" target="_self">6. Top-Level `await`</a><br><a href="#scripttypetopic-6" target="_self">7. File Extension and MIME Type</a><br><a href="#scripttypetopic-7" target="_self">8. Browser Support</a><br><a href="#scripttypetopic-8" target="_self">Example Usage</a><br><a href="#scripttypetopic-9" target="_self">Summary</a><br></div></center><br><br>\n\nThe `&lt;script&gt;` and `&lt;script type="module"&gt;` tags in HTML are used to include JavaScript in a web page, but they behave differently in terms of how the JavaScript code is executed and what features are available. Here\'s a breakdown of the differences:\n<h3 id="scripttypetopic-0">1. Module Scope vs Global Scope</h3>- `&lt;script&gt;`: JavaScript code included via a standard `&lt;script&gt;` tag is executed in the global scope. This means variables, functions, and other declarations are added to the global `window` object, which can lead to potential conflicts or pollution of the global namespace.\n- `&lt;script type="module"&gt;`: JavaScript code included as a module (`type="module"`) is executed in its own module scope. Variables and functions declared in the module are not added to the global scope, avoiding conflicts with other scripts.\n<h3 id="scripttypetopic-1">2. Strict Mode</h3>- `&lt;script&gt;`: By default, strict mode is not enforced in standard `&lt;script&gt;` tags. You can enable it manually by adding `"use strict";` at the beginning of the script.\n- `&lt;script type="module"&gt;`: Modules are automatically executed in strict mode. This means you cannot use undeclared variables, and other strict mode rules are enforced by default.\n<h3 id="scripttypetopic-2">3. Deferred Execution</h3>- `&lt;script&gt;`: Without the `defer` or `async` attributes, standard `&lt;script&gt;` tags block HTML parsing and rendering until the script is downloaded and executed.\n- `&lt;script type="module"&gt;`: Modules are deferred by default. This means the browser will download the module script in parallel with HTML parsing but will only execute it after the HTML is fully parsed. This behavior is similar to using the `defer` attribute in a standard `&lt;script&gt;` tag.\n<h3 id="scripttypetopic-3">4. Cross-Origin Restrictions</h3>- `&lt;script&gt;`: Standard scripts can be loaded from any origin without restrictions (unless CORS policies are enforced).\n- `&lt;script type="module"&gt;`: Modules are subject to CORS (Cross-Origin Resource Sharing) restrictions. If the module is loaded from a different origin, the server must provide the appropriate CORS headers.\n<h3 id="scripttypetopic-4">5. Import/Export Syntax</h3>- `&lt;script&gt;`: Standard scripts cannot use the `import` and `export` syntax for modular code. All code is executed in a single global context.\n- `&lt;script type="module"&gt;`: Modules support the `import` and `export` syntax, allowing you to split your code into multiple files and share functionality between them.\n<h3 id="scripttypetopic-5">6. Top-Level `await`</h3>- `&lt;script&gt;`: Standard scripts cannot use `await` at the top level of the script. It can only be used inside `async` functions.\n- `&lt;script type="module"&gt;`: Modules support top-level `await`, meaning you can use `await` outside of an `async` function.\n<h3 id="scripttypetopic-6">7. File Extension and MIME Type</h3>- `&lt;script&gt;`: Standard scripts can be loaded from files with any extension, and the MIME type is not strictly enforced.\n- `&lt;script type="module"&gt;`: Modules must be served with the correct MIME type (`text/javascript` or `application/javascript`). Additionally, the file extension is often `.js`, but the browser relies on the MIME type.\n<h3 id="scripttypetopic-7">8. Browser Support</h3>- `&lt;script&gt;`: Supported by all browsers, including very old ones.\n- `&lt;script type="module"&gt;`: Supported in modern browsers (e.g., Chrome, Firefox, Edge, Safari). Older browsers (e.g., Internet Explorer) do not support modules.\n<h3 id="scripttypetopic-8">Example Usage</h3>&lt;!-- Standard script --&gt;\n&lt;script&gt;\n  console.log("This is a standard script.");\n&lt;/script&gt;\n\n&lt;!-- Module script --&gt;\n&lt;script type="module"&gt;\n  import { myFunction } from \'./myModule.js\';\n  console.log("This is a module script.");\n  myFunction();\n&lt;/script&gt;\n<h3 id="scripttypetopic-9">Summary</h3>- Use `&lt;script&gt;` for traditional, globally scoped JavaScript.\n- Use `&lt;script type="module"&gt;` for modern, modular JavaScript with features like `import`/`export`, strict mode, and deferred execution.\n\nModules are the recommended way to write modern JavaScript applications, as they promote better code organization and avoid global scope pollution.\n',
'<h2>JavaScript cloning an object</h2>	<center><div id="cloninganobjecttoc" class="toc"><a href="#cloninganobjecttopic-0" target="_self"><pk>1. Shallow Clone</pk></a><br><a href="#cloninganobjecttopic-1" target="_self"> Using the Spread Operator (`...`)</a><br><a href="#cloninganobjecttopic-2" target="_self"> Using `Object.assign()`</a><br><a href="#cloninganobjecttopic-3" target="_self"> Note</a><br><a href="#cloninganobjecttopic-4" target="_self"><pk>2. Deep Clone</pk></a><br><a href="#cloninganobjecttopic-5" target="_self"> Using `JSON.parse(JSON.stringify())`</a><br><a href="#cloninganobjecttopic-6" target="_self"> Limitations</a><br><a href="#cloninganobjecttopic-7" target="_self"> Using a Library (e.g., Lodash)</a><br><a href="#cloninganobjecttopic-8" target="_self"> Using a Custom Recursive Function</a><br><a href="#cloninganobjecttopic-9" target="_self"><pk>3. Structured Clone Algorithm</pk></a><br><a href="#cloninganobjecttopic-10" target="_self"> Advantages</a><br><a href="#cloninganobjecttopic-11" target="_self"> Limitations</a><br><a href="#cloninganobjecttopic-12" target="_self"><pk>Summary</pk></a><br></div></center><br><br>\n\nIn JavaScript, cloning an object can be done in several ways, depending on the depth of the clone (shallow or deep) and the specific requirements of your use case. Here are the most common methods:\n<h3 id="cloninganobjecttopic-0"><pk>1. Shallow Clone</pk></h3>A shallow clone copies the top-level properties of an object, but nested objects are still referenced (not cloned).\n<y id="cloninganobjecttopic-1"> Using the Spread Operator (`...`)</y>\nconst original = { a: 1, b: { c: 2 } };\nconst clone = { ...original };\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<y id="cloninganobjecttopic-2"> Using `Object.assign()`</y>\nconst original = { a: 1, b: { c: 2 } };\nconst clone = Object.assign({}, original);\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<o id="cloninganobjecttopic-3"> Note</o>: Both methods create a shallow copy. If `original.b` is modified, `clone.b` will also reflect the changes.\n<h3 id="cloninganobjecttopic-4"><pk>2. Deep Clone</pk></h3>A deep clone creates a new object with all nested objects copied recursively, so no references to the original nested objects remain.\n<y id="cloninganobjecttopic-5"> Using `JSON.parse(JSON.stringify())`</y>\nThis method works well for objects without functions, `undefined`, or special objects like `Date`, `RegExp`, etc.\nconst original = { a: 1, b: { c: 2 } };\nconst clone = JSON.parse(JSON.stringify(original));\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<o id="cloninganobjecttopic-6"> Limitations</o>:\n- Does not copy functions or `undefined` values.\n- Loses special object types like `Date`, `RegExp`, etc.\n<y id="cloninganobjecttopic-7"> Using a Library (e.g., Lodash)</y>\nLibraries like Lodash provide a robust `_.cloneDeep()` method for deep cloning.\nconst _ = require(\'lodash\');\nconst original = { a: 1, b: { c: 2 } };\nconst clone = _.cloneDeep(original);\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<y id="cloninganobjecttopic-8"> Using a Custom Recursive Function</y>\nIf you prefer not to use a library, you can write a recursive function to deep clone an object:\nfunction deepClone(obj) {\n if (obj === null || typeof obj !== \'object\') {\n  return obj;\n }\n\n if (obj instanceof Date) {\n  return new Date(obj);\n }\n if (Array.isArray(obj)) {\n  const arrCopy = [];\n  for (let i = 0; i &lt; obj.length; i++) {\n   arrCopy[i] = deepClone(obj[i]);\n  }\n  return arrCopy;\n }\n const objCopy = {};\n for (const key in obj) {\n  if (obj.hasOwnProperty(key)) {\n   objCopy[key] = deepClone(obj[key]);\n  }\n }\n return objCopy;\n}\nconst original = { a: 1, b: { c: 2 } };\nconst clone = deepClone(original);\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<h3 id="cloninganobjecttopic-9"><pk>3. Structured Clone Algorithm</pk></h3>Modern browsers support the `structuredClone()` method, which performs a deep clone and handles more cases than `JSON.parse(JSON.stringify())`.\nconst original = { a: 1, b: { c: 2 } };\nconst clone = structuredClone(original);\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<o id="cloninganobjecttopic-10"> Advantages</o>:\n- Handles more types (e.g., `Date`, `RegExp`, `Map`, `Set`, etc.).\n- Does not require a library.\n<o id="cloninganobjecttopic-11"> Limitations</o>:\n- Not supported in very old browsers.\n<h3 id="cloninganobjecttopic-12"><pk>Summary</pk></h3>- Use spread operator or `Object.assign()` for shallow clones.\n- Use `JSON.parse(JSON.stringify())` for simple deep clones (no functions or special objects).\n- Use `structuredClone()` for robust deep cloning in modern environments.\n- Use Lodash\'s `_.cloneDeep()` or a custom recursive function for full control over deep cloning.\n',
'<h2>JavaScript check if an object is empty</h2>	<center><div id="objectisemptytoc" class="toc"><a href="#objectisemptytopic-0" target="_self">1. Using <o>Object.keys()</o></a><br><a href="#objectisemptytopic-1" target="_self">2. Using <o>Object.entries()</o></a><br><a href="#objectisemptytopic-2" target="_self">3. Using a <o>for...in</o> Loop</a><br><a href="#objectisemptytopic-3" target="_self">4. Using <o>JSON.stringify()</o></a><br><a href="#objectisemptytopic-4" target="_self">5. Using <o>Object.getOwnPropertyNames()</o></a><br><a href="#objectisemptytopic-5" target="_self">6. Using a Library (e.g., Lodash)</a><br><a href="#objectisemptytopic-6" target="_self">Summary</a><br></div></center><br><br>\n\nIn JavaScript, you can check if an object is empty (i.e., it has no own enumerable properties) using several methods. Here are the most common and reliable approaches:\n<h3 id="objectisemptytopic-0">1. Using <o>Object.keys()</o></h3>The <o>Object.keys()</o> method returns an array of the object\'s own enumerable property names. If the array is empty, the object is empty.\nconst obj = {};\nif (Object.keys(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Explanation</y>:\n- <o>Object.keys(obj)</o> returns an array of keys.\n- If the array\'s length is <o>0</o>, the object has no properties.\n<h3 id="objectisemptytopic-1">2. Using <o>Object.entries()</o></h3>The <o>Object.entries()</o> method returns an array of the object\'s own enumerable key-value pairs. If the array is empty, the object is empty.\nconst obj = {};\nif (Object.entries(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Explanation</y>:\n- <o>Object.entries(obj)</o> returns an array of key-value pairs.\n- If the array\'s length is <o>0</o>, the object has no properties.\n<h3 id="objectisemptytopic-2">3. Using a <o>for...in</o> Loop</h3>You can use a <o>for...in</o> loop to check if the object has any enumerable properties.\nconst obj = {};\nlet isEmpty = true;\nfor (let key in obj) {\n if (obj.hasOwnProperty(key)) {\n  isEmpty = false;\n  break;\n }\n}\nif (isEmpty) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Explanation</y>:\n- The <o>for...in</o> loop iterates over the object\'s enumerable properties.\n- If the loop never runs (i.e., no properties exist), the object is empty.\n<h3 id="objectisemptytopic-3">4. Using <o>JSON.stringify()</o></h3>If the object is empty, <o>JSON.stringify()</o> will return <o>"{}"</o>.\nconst obj = {};\nif (JSON.stringify(obj) === \'{}\') {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Explanation</y>:\n- <o>JSON.stringify(obj)</o> converts the object to a JSON string.\n- If the object is empty, the result is <o>"{}"</o>.\n<y>Limitation</y>:\n- This method may not work as expected if the object contains non-enumerable properties or symbols.\n<h3 id="objectisemptytopic-4">5. Using <o>Object.getOwnPropertyNames()</o></h3>This method returns an array of all properties (including non-enumerable ones, except for symbols) of the object.\nconst obj = {};\nif (Object.getOwnPropertyNames(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Explanation</y>:\n- <o>Object.getOwnPropertyNames(obj)</o> returns an array of all property names.\n- If the array\'s length is <o>0</o>, the object has no properties.\n<h3 id="objectisemptytopic-5">6. Using a Library (e.g., Lodash)</h3>Libraries like Lodash provide utility functions to check if an object is empty.\nconst _ = require(\'lodash\');\nconst obj = {};\nif (_.isEmpty(obj)) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n<y>Advantages</y>:\n- Handles edge cases (e.g., non-enumerable properties, symbols, etc.).\n- Works for arrays, maps, sets, and other data structures.\n<h3 id="objectisemptytopic-6">Summary</h3>- Use <o>Object.keys(obj).length === 0</o> for a simple and modern approach.\n- Use <o>for...in</o> if you need to check for enumerable properties explicitly.\n- Use <o>JSON.stringify(obj) === \'{}\'</o> for a quick check (but be aware of limitations).\n- Use Lodash\'s <o>_.isEmpty()</o> for a robust and versatile solution.\nFor most cases, <o>Object.keys(obj).length === 0</o> is the recommended approach.\n',
'<h2>CORS issue</h2>	<center><div id="CORSissuetoc" class="toc"><a href="#CORSissuetopic-0" target="_self">1. Use a public Proxy Server</a><br><a href="#CORSissuetopic-1" target="_self"> Example: Using a CORS Proxy</a><br><a href="#CORSissuetopic-2" target="_self">2. Use a local Backend Server</a><br><a href="#CORSissuetopic-3" target="_self"> Example: Using Node.js as a Backend Proxy</a><br><a href="#CORSissuetopic-4" target="_self">3. Use JSONP (if supported by the API)</a><br><a href="#CORSissuetopic-5" target="_self"> Example:</a><br><a href="#CORSissuetopic-6" target="_self">4. Disable CORS in the Browser (for Development Only)</a><br><a href="#CORSissuetopic-7" target="_self"> For Chrome:</a><br><a href="#CORSissuetopic-8" target="_self"> For Firefox:</a><br><a href="#CORSissuetopic-9" target="_self">5. Contact the API Provider</a><br><a href="#CORSissuetopic-10" target="_self">Summary</a><br></div></center><br><br>\n\nThe CORS (Cross-Origin Resource Sharing) issue occurs when a web application running at one origin (domain) tries to make a request to a resource at a different origin, and the server at the other origin does not include the necessary `Access-Control-Allow-Origin` header in its response. This is a security feature implemented by browsers to prevent cross-origin requests that could potentially be malicious.\n\nTo work around this issue, you have a few options:\n<h3 id="CORSissuetopic-0">1. Use a public Proxy Server</h3>You can use a proxy server to fetch the data. The proxy server will act as an intermediary between your frontend and the target server, adding the necessary CORS headers to the response.\n<y id="CORSissuetopic-1"> Example: Using a CORS Proxy</y>\nYou can use a public CORS proxy like [cors-anywhere](https://cors-anywhere.herokuapp.com/) or [allorigins](https://api.allorigins.win/). Here\'s how you can modify your `fetch` request:\n\nconst proxyUrl = \'https://cors-anywhere.herokuapp.com/\';\nconst targetUrl = \'http://web.ifzq.gtimg.cn/appstock/app/day/query?code=hk00981\';\n\nfetch(proxyUrl + targetUrl)\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    console.log(data);\n    // Process and display the data as before\n  })\n  .catch(error =&gt; {\n    console.error(\'Error fetching data:\', error);\n  });\n\n<h3 id="CORSissuetopic-2">2. Use a local Backend Server</h3>If you have control over a backend server (e.g., using Node.js, Python, etc.), you can make the request from the backend. Since CORS is a browser-specific restriction, servers are not affected by it.\n<y id="CORSissuetopic-3"> Example: Using Node.js as a Backend Proxy</y>\n1. Create a simple Node.js server using Express:\n  npm init -y\n  npm install express node-fetch cors\n2. Create a `server.js` file:\n  const express = require(\'express\');\n  const fetch = require(\'node-fetch\');\n  const cors = require(\'cors\');\n  const app = express();\n  app.use(cors());\n  app.get(\'/api/data\', async (req, res) =&gt; {\n    const targetUrl = \'http://web.ifzq.gtimg.cn/appstock/app/day/query?code=hk00981\';\n    try {\n      const response = await fetch(targetUrl);\n      const data = await response.json();\n      res.json(data);\n    } catch (error) {\n      res.status(500).json({ error: \'Failed to fetch data\' });\n    }\n  });\n  const PORT = 3000;\n  app.listen(PORT, () =&gt; {\n    console.log(`Server running on http://localhost:${PORT}`);\n  });\n3. Start the server: node server.js\n4. Update your frontend to fetch data from your backend:\n  fetch(\'http://localhost:3000/api/data\')\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n      console.log(data);\n      // Process and display the data as before\n    })\n    .catch(error =&gt; {\n      console.error(\'Error fetching data:\', error);\n    });\n<h3 id="CORSissuetopic-4">3. Use JSONP (if supported by the API)</h3>If the API supports <k>JSONP (JSON with Padding)</k>, you can use it to bypass CORS. JSONP works by loading a `&lt;script&gt;` tag with a callback function, which the server wraps the JSON response in.\n<y id="CORSissuetopic-5"> Example:</y>\nfunction handleJSONP(data) {\n  console.log(data);\n  // Process and display the data as before\n}\n\nconst script = document.createElement(\'script\');\nscript.src = \'http://web.ifzq.gtimg.cn/appstock/app/day/query?code=hk00981&amp;callback=handleJSONP\';\ndocument.body.appendChild(script);\n\nHowever, JSONP is outdated and not supported by all APIs. It also has security risks, so use it cautiously.\n\n<h3 id="CORSissuetopic-6">4. Disable CORS in the Browser (for Development Only)</h3>For local development, you can disable CORS in your browser. This is <k>not recommended for production</k> but can be useful for testing.\n<y id="CORSissuetopic-7"> For Chrome:</y>\n1. Close all instances of Chrome.\n2. Open a terminal and run:\n  google-chrome --disable-web-security --user-data-dir=/tmp/chrome\n  \n<y id="CORSissuetopic-8"> For Firefox:</y>\n1. Type `about:config` in the address bar.\n2. Search for `security.fileuri.strict_origin_policy` and set it to `false`.\n\n<h3 id="CORSissuetopic-9">5. Contact the API Provider</h3>If you have access to the API provider, you can request them to add the `Access-Control-Allow-Origin` header to their server responses. For example:\n\nAccess-Control-Allow-Origin: *\n<h3 id="CORSissuetopic-10">Summary</h3>The best approach depends on your use case:\n- For quick testing, use a <k>CORS proxy</k>.\n- For production, set up a <k>backend server</k> to handle the requests.\n- If the API supports JSONP, you can use that as a workaround.\n',
'<h2>calculate moving average</h2>	amtArray = [1,3,5,7,9, 11,13,10,25]\n// Function to calculate moving average of five days\nfunction calculateMA(arr, days) {\n  startDay = days-1\n  let movingAverages = [];\n  stuffArrayWithNull(movingAverages, startDay);\n  for (let i = startDay; i < arr.length; i++) {\n    let sum = 0;\n    for (let j = i - startDay; j <= i; j++) {\n      sum += arr[j];\n    }\n    let average = sum / days;\n    movingAverages.push(average);\nconsole.log(movingAverages)\n  }\n  return movingAverages;\n}\n// Function to stuff an array with null values\nfunction stuffArrayWithNull(array, times) {\n  for (let i = 0; i < times; i++) {\n    array.push(null);\n  }\n}\n// Calculate moving averages for the given array\nconst movingAverages = calculateMA(amtArray, 5);\nconsole.log("Moving Averages of Five Days:", movingAverages);\n\nlet amtIdx;\n// Check for null values before performing the calculation\nif (amtMA2 !== null && amtMA5 !== null && amtMA5 !== 0) {\n    amtIdx = Math.round(amtMA2 / amtMA5 * 100);\n} else {\n    // Handle the case where any of the values is null or amtMA5 is 0\n    amtIdx = null;\n}\n',
'<h2>wait for an asynchronous function</h2>	To wait for an asynchronous function to finish and then continue with the next part of your code, you can use async/await or .then() syntax in JavaScript.\nHere\'s an example using async/await:\n\n// Example asynchronous function\nfunction asyncFunction() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            console.log("Async function finished.");\n            resolve();\n        }, 2000);\n    });\n}\n\nasync function executeAsyncFunction() {\n    console.log("Starting async function execution");\n    // Wait for the asynchronous function to finish\n    await asyncFunction();\n    console.log("Async function completed. Continue with the next part.");\n}\nexecuteAsyncFunction();\n\nIn this code:\nThe asyncFunction is an example of an asynchronous function that returns a Promise and simulates some asynchronous operation (in this case, a timeout of 2 seconds).\nexecuteAsyncFunction is an async function that calls asyncFunction using await, which pauses the execution of the executeAsyncFunction until the Promise returned by asyncFunction is resolved.\nWhen asyncFunction completes, the program will log "Async function finished." and then continue with the next part of the code inside executeAsyncFunction.\nBy using await with the asynchronous function, you can ensure that the code execution waits for the asynchronous operation to complete before moving on to the next part of the code.\n',
'<h2>JavaScript Map 比对象</h2>	传统上，存储键值对的数据结构时，对象 (Object) 一直是我们的首选。\n然而，ES6 引入了 Map 对象，它提供了一种更强大、更灵活的方式来处理键值对。\n以前也懒得用，直到最近用了下，我发现 Map 比对象更香。\n\n<h3>1. 键的类型不再局限：</h3>这是 Map 最显著的优势之一。\n对象只能使用字符串或 Symbol 作为键，这限制了其适用性。\nMap 则不同，可以使用任何数据类型作为键，包括对象、函数、数字，甚至 NaN。\n想象一下，你想要使用 DOM 元素作为键来存储与其相关的数据，Map 可以轻松实现：\n<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/btsCOHx9LAMCib91gAIvha0peiaztgtyPIjmRtiavwHUzBk0B1icDlCVYFmEsyQ9PqZG3BtZh57T8d7k3JTxNd5kcA/640">\n\n对象则无法实现这种灵活的键类型。\n\n<h3>2. 键的顺序得到保留：</h3>对象的属性在添加时，其顺序是不确定的，尤其是在较旧的 JavaScript 引擎中。\n虽然现代 JavaScript 引擎尝试保留属性的插入顺序，但这种行为并非总是可靠的。\nMap 则不同，Map 对象会按照键值对插入的顺序进行存储和迭代。\n这在需要维护特定顺序的场景下非常有用：\n<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/btsCOHx9LAMCib91gAIvha0peiaztgtyPI3KdgPF9LXofszytoyxd0XQslfOmR2AicOBTCDeLTLnO8pKgK1GWZV1A/640">\n\n<h3>3. 轻松获取大小：</h3>要获取对象中属性的数量，你需要手动遍历或者使用 Object.keys(obj).length，这既不优雅，也可能效率不高。\nMap 对象提供了一个简单的 size 属性，可以直接获取键值对的数量：\n<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/btsCOHx9LAMCib91gAIvha0peiaztgtyPIcowOaDgJFiarnRbgDnjibWWiaTYvQQpiaj3mSWpqDNHojhqmLSCZyt6OMw/640">\n\n<h3>4. 避免原型链污染：</h3>JavaScript 对象会继承原型链上的属性。\n这意味着，如果不小心，你可能会意外访问到原型链上的属性，或者更糟糕的是，修改原型链上的属性，导致全局污染。\nMap 对象不会继承任何属性，它完全隔离于原型链，更加安全可靠。\n\n<h3>5. 更优的性能：</h3>在某些场景下，特别是需要频繁添加、删除键值对的情况下，Map 对象通常比对象具有更好的性能。\nJavaScript 引擎对 Map 对象进行了专门的优化，使其更适合处理动态数据。\n\n<h3>6. 内置的迭代方法：</h3>Map 对象提供了内置的迭代方法，例如 forEach、keys、values 和 entries，使得迭代键值对变得非常方便：\nconst myMap = new Map();\nmyMap.set(\'a\', 1);\nmyMap.set(\'b\', 2);\n\nmyMap.forEach((value, key) => {\n  console.log(key, value); // 输出: a 1, b 2\n});\n\nfor (const key of myMap.keys()) {\n  console.log(key); // 输出: a, b\n}\n\nfor (const value of myMap.values()) {\n  console.log(value); // 输出: 1, 2\n}\n\nfor (const [key, value] of myMap.entries()) {\n  console.log(key, value); // 输出: a 1, b 2\n}\n\n何时仍然使用对象？\n虽然 Map 在很多方面都优于对象，但对象仍然有其用武之地。\n\nJSON： JSON 数据格式本质上是对象。\n简单的配置对象： 对于简单的、静态的配置对象，对象仍然是一个不错的选择。\n需要直接访问属性的情况： 如果需要使用 obj.propertyName 语法直接访问属性，对象仍然是必要的。\n但是，请注意，这可以通过将 Map 转换为对象来实现，但需要权衡性能。\n',
'<h2>javascript concatenate array elements to one string</h2>	In JavaScript, you can concatenate the elements of an array into a single string using several methods. Here are the most common approaches:\n<o>1. Using `.join()`</o>\nThe `join()` method concatenates all elements of an array into a string, with an optional separator between elements.\n<lg>Example:</lg>\nconst array = ["Hello", "world", "!"];\nconst result = array.join(" "); // Join with a space as the separator\nconsole.log(result); // Output: "Hello world !"\n<o>2. Using `.reduce()`</o>\nThe `reduce()` method can be used to concatenate array elements into a single string by iterating over the array.\nExample:\nconst array = ["Hello", "world", "!"];\nconst result = array.reduce((acc, curr) => acc + " " + curr, "").trim();\nconsole.log(result); // Output: "Hello world !"\n<o>3. Using a `for` Loop</o>\nYou can manually concatenate array elements using a loop.\n<lg>Example:</lg>\nconst array = ["Hello", "world", "!"];\nlet result = "";\nfor (let i = 0; i < array.length; i++) {\n result += array[i] + " ";\n}\nresult = result.trim(); // Remove the trailing space\nconsole.log(result); // Output: "Hello world !"\n<o>4. Using `.toString()`</o>\nThe `toString()` method converts an array into a string, with elements separated by commas.\n<lg>Example:</lg>\nconst array = ["Hello", "world", "!"];\nconst result = array.toString(); // Output: "Hello,world,!"\nconsole.log(result);\nIf you want to replace the commas with a different separator, you can chain `.replace()` or `.split().join()`:\nconst result = array.toString().replace(/,/g, " "); // Output: "Hello world !"\n<o>5. Using Template Literals (for small arrays)</o>\nIf the array is small, you can use template literals to concatenate the elements.\n<lg>Example:</lg>\nconst array = ["Hello", "world", "!"];\nconst result = `${array[0]} ${array[1]} ${array[2]}`;\nconsole.log(result); // Output: "Hello world !"\n<o>6. Using `Array.prototype.flat()` (for nested arrays)</o>\nIf you have a nested array and want to flatten it before concatenation, you can use `flat()`.\n<lg>Example:</lg>\nconst array = ["Hello", ["world", "!"]];\nconst flattened = array.flat(); // Flatten the array\nconst result = flattened.join(" "); // Join with a space\nconsole.log(result); // Output: "Hello world !"\n<o>Summary</o>\n- Use `join()` for simple concatenation with a separator.\n- Use `reduce()` for more complex concatenation logic.\n- Use a `for` loop for manual control over the process.\n- Use `toString()` for quick comma-separated strings.\n- Use template literals for small, fixed arrays.\nFor most cases, `join()` is the simplest and most efficient method.\n',
'<h2>to clone an object in javascript</h2>	In JavaScript, cloning an object can be done in several ways, depending on the depth of the clone (shallow or deep) and the specific requirements of your use case. Here are the most common methods:\n<h3>1. Shallow Clone</h3>A shallow clone copies the top-level properties of an object, but nested objects are still referenced (not cloned).\n<o>Using the Spread Operator (`...`)</o>\nconst original = { a: 1, b: { c: 2 } };\nconst clone = { ...original };\n\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<o>Using `Object.assign()`</o>\nconst original = { a: 1, b: { c: 2 } };\nconst clone = Object.assign({}, original);\n\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<lg>Note</lg>: Both methods create a shallow copy. If `original.b` is modified, `clone.b` will also reflect the changes.\n<h3>2. Deep Clone</h3>A deep clone creates a new object with all nested objects copied recursively, so no references to the original nested objects remain.\n<o>Using `JSON.parse(JSON.stringify())`</o>\nThis method works well for objects without functions, `undefined`, or special objects like `Date`, `RegExp`, etc.\nconst original = { a: 1, b: { c: 2 } };\nconst clone = JSON.parse(JSON.stringify(original));\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n\n<lg>Limitations</lg>:\n- Does not copy functions or `undefined` values.\n- Loses special object types like `Date`, `RegExp`, etc.\n<o>Using a Library (e.g., Lodash)</o>\nLibraries like Lodash provide a robust `_.cloneDeep()` method for deep cloning.\nconst _ = require(\'lodash\');\nconst original = { a: 1, b: { c: 2 } };\nconst clone = _.cloneDeep(original);\n\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<o>Using a Custom Recursive Function</o>\nIf you prefer not to use a library, you can write a recursive function to deep clone an object:\nfunction deepClone(obj) {\n if (obj === null || typeof obj !== \'object\') {\n  return obj;\n }\n\n if (obj instanceof Date) {\n  return new Date(obj);\n }\n\n if (Array.isArray(obj)) {\n  const arrCopy = [];\n  for (let i = 0; i < obj.length; i++) {\n   arrCopy[i] = deepClone(obj[i]);\n  }\n  return arrCopy;\n }\n\n const objCopy = {};\n for (const key in obj) {\n  if (obj.hasOwnProperty(key)) {\n   objCopy[key] = deepClone(obj[key]);\n  }\n }\n return objCopy;\n}\n\nconst original = { a: 1, b: { c: 2 } };\nconst clone = deepClone(original);\n\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n<h3>3. Structured Clone Algorithm</h3>Modern browsers support the `structuredClone()` method, which performs a deep clone and handles more cases than `JSON.parse(JSON.stringify())`.\n\nconst original = { a: 1, b: { c: 2 } };\nconst clone = structuredClone(original);\nconsole.log(clone); // { a: 1, b: { c: 2 } }\n\n<lg>Advantages</lg>:\n- Handles more types (e.g., `Date`, `RegExp`, `Map`, `Set`, etc.).\n- Does not require a library.\n\n<lg>Limitations</lg>:\n- Not supported in very old browsers.\n<h3>Summary\n- Use <lg>spread operator</lg> or <lg>`Object.assign()`</lg> for shallow clones.\n- Use <lg>`JSON.parse(JSON.stringify())`</lg> for simple deep clones (no functions or special objects).\n- Use <lg>`structuredClone()`</lg> for robust deep cloning in modern environments.\n- Use <lg>Lodash\'s `_.cloneDeep()`</lg> or a custom recursive function for full control over deep cloning.\n\nChoose the method that best fits your needs!\n\n',
'<h2>to check if an object is empty</h2>	In JavaScript, you can check if an object is empty (i.e., it has no own enumerable properties) using several methods. Here are the most common and reliable approaches:\n<h3>1. Using `Object.keys()`</h3>The `Object.keys()` method returns an array of the object\'s own enumerable property names. If the array is empty, the object is empty.\nconst obj = {};\nif (Object.keys(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Explanation</lg>:\n- `Object.keys(obj)` returns an array of keys.\n- If the array\'s length is `0`, the object has no properties.\n<h3>2. Using `Object.entries()`</h3>The `Object.entries()` method returns an array of the object\'s own enumerable key-value pairs. If the array is empty, the object is empty.\nconst obj = {};\n\nif (Object.entries(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Explanation</lg>:\n- `Object.entries(obj)` returns an array of key-value pairs.\n- If the array\'s length is `0`, the object has no properties.\n<h3>3. Using a `for...in` Loop</h3>You can use a `for...in` loop to check if the object has any enumerable properties.\nconst obj = {};\n\nlet isEmpty = true;\nfor (let key in obj) {\n if (obj.hasOwnProperty(key)) {\n  isEmpty = false;\n  break;\n }\n}\n\nif (isEmpty) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Explanation</lg>:\n- The `for...in` loop iterates over the object\'s enumerable properties.\n- If the loop never runs (i.e., no properties exist), the object is empty.\n<h3>4. Using `JSON.stringify()`</h3>If the object is empty, `JSON.stringify()` will return `"{}"`.\nconst obj = {};\n\nif (JSON.stringify(obj) === \'{}\') {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Explanation</lg>:\n- `JSON.stringify(obj)` converts the object to a JSON string.\n- If the object is empty, the result is `"{}"`.\n\n<lg>Limitation</lg>:\n- This method may not work as expected if the object contains non-enumerable properties or symbols.\n<h3>5. Using `Object.getOwnPropertyNames()`</h3>This method returns an array of all properties (including non-enumerable ones, except for symbols) of the object.\nconst obj = {};\n\nif (Object.getOwnPropertyNames(obj).length === 0) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Explanation</lg>:\n- `Object.getOwnPropertyNames(obj)` returns an array of all property names.\n- If the array\'s length is `0`, the object has no properties.\n<h3>6. Using a Library (e.g., Lodash)</h3>Libraries like Lodash provide utility functions to check if an object is empty.\n\nconst _ = require(\'lodash\');\nconst obj = {};\n\nif (_.isEmpty(obj)) {\n console.log(\'Object is empty\');\n} else {\n console.log(\'Object is not empty\');\n}\n\n<lg>Advantages</lg>:\n- Handles edge cases (e.g., non-enumerable properties, symbols, etc.).\n- Works for arrays, maps, sets, and other data structures.\n<h3>Summary\n- Use <lg>`Object.keys(obj).length === 0`</lg> for a simple and modern approach.\n- Use <lg>`for...in`</lg> if you need to check for enumerable properties explicitly.\n- Use <lg>`JSON.stringify(obj) === \'{}\'`</lg> for a quick check (but be aware of limitations).\n- Use <lg>Lodash\'s `_.isEmpty()`</lg> for a robust and versatile solution.\n\nFor most cases, <lg>`Object.keys(obj).length === 0`</lg> is the recommended approach.\n',
'<h2>How to access url with origin \'null\'</h2>	<o>1. Running in a Browser (for local testing)</o>\nIf you are testing a web page that accesses other resources (e.g., making an AJAX call to another URL) and getting the `null` origin issue, one common cause is that you are opening the HTML file directly from the local file system (using `file://` protocol). In this case, the browser treats it as having an origin of `null`.\nTo solve this, you can set up a simple local web server. For example:\n<lg>Using Python\'s built-in server</lg>:\nIf you have Python installed, you can navigate to the directory containing your HTML and related files in the terminal and run the following command depending on your Python version:\n- For Python 2: `python -m SimpleHTTPServer 8000`\n- For Python 3: `python -m http.server 8000`\nThen you can access your page in the browser at `http://localhost:8000/` instead of using the `file://` path. This way, the page will have a proper origin (e.g., `http://localhost:8000`).\n<lg>Using Node.js and `http-server`</lg>:\nFirst, install `http-server` globally if you haven\'t already: `npm install -g http-server`.\nThen, navigate to your project directory in the terminal and run `http-server`. By default, it will start serving your files on `http://localhost:8080`.\n\n<o>2. In JavaScript Code</o>\nIf you are dealing with URLs in JavaScript and want to work around the `null` origin issue for things like cross-origin requests:\n<lg>For Fetch API</lg>:\nIf you are making a request to another domain and getting issues related to the `null` origin, you need to make sure that the target server has appropriate CORS (Cross-Origin Resource Sharing) headers set. If you have control over the server, you can add headers like `Access-Control-Allow-Origin` to allow requests from your origin. For example, if your page is served from `http://localhost:8000` (after setting up a proper server as described above), you can set `Access-Control-Allow-Origin: http://localhost:8000` on the server side.\n\nHere\'s a simple example of using the Fetch API to make a request:\nfetch(\'https://example.com/api/data\', {\n method: \'GET\',\n headers: {\n  \'Content-Type\': \'application/json\'\n }\n})\n.then(response => response.json())\n.then(data => console.log(data))\n.catch(error => console.error(\'Error:\', error));\n<lg>For XMLHttpRequest</lg>:\nSimilar to the Fetch API, you need to handle CORS properly. Here\'s a basic example of an `XMLHttpRequest`:\nconst xhr = new XMLHttpRequest();\nxhr.open(\'GET\', \'https://example.com/api/data\', true);\nxhr.onreadystatechange = function () {\n if (xhr.readyState === 4 && xhr.status === 200) {\n  const data = JSON.parse(xhr.responseText);\n  console.log(data);\n }\n};\nxhr.send();\n\nIn summary, dealing with the `null` origin when accessing URLs mainly involves setting up a proper web server for local testing and handling CORS correctly when making requests to other domains. \n',
'<h2>from the client side to make server receive origin \'null\'</h2>	<o>1. When Does the Origin Become `\'null\'`?</o>\n- The origin is `\'null\'` in the following scenarios:\n1. The web page is opened from a local file (e.g., `file://` protocol).\n2. The web page is embedded in an iframe with the `sandbox` attribute (and no `allow-same-origin` directive).\n3. The request is made from a browser extension or a non-web context.\n\n<o>2. Force the Origin to Be `\'null\'`</o>\nTo ensure the origin is `\'null\'`, you can:\n- Open the web page from a local file (e.g., `file:///path/to/your/file.html`).\n- Use an iframe with the `sandbox` attribute:\n  <iframe src="https://example.com" sandbox></iframe>\n  This will make the iframe\'s origin `\'null\'`.\n<o>3. Send a Request with `\'null\'` Origin</o>\n Once the origin is `\'null\'`, you can send a request to the server using `fetch` or `XMLHttpRequest`. The browser will automatically set the `Origin` header to `\'null\'`.\n<lg>Example with `fetch`:</lg>\n fetch(\'https://yourserver.com/api\', {\n  method: \'POST\',\n  headers: {\n  \'Content-Type\': \'application/json\',\n  },\n  body: JSON.stringify({ message: \'Hello from client!\' }),\n })\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error(\'Error:\', error));\n<lg>Example with `XMLHttpRequest`:</lg>\n const xhr = new XMLHttpRequest();\n xhr.open(\'POST\', \'https://yourserver.com/api\', true);\n xhr.setRequestHeader(\'Content-Type\', \'application/json\');\n xhr.onreadystatechange = function () {\n  if (xhr.readyState === 4 && xhr.status === 200) {\n  console.log(JSON.parse(xhr.responseText));\n  }\n };\n xhr.send(JSON.stringify({ message: \'Hello from client!\' }));\n\n<o>4. Server-Side Handling of `\'null\'` Origin</o>\n On the server side, you can check the `Origin` header to verify that the request is coming from a `\'null\'` origin. Here’s how you can handle it:\n<lg>Example in Node.js (Express):</lg>\n const express = require(\'express\');\n const app = express();\n app.use(express.json());\n app.post(\'/api\', (req, res) => {\n  const origin = req.get(\'Origin\');\n  console.log(\'Origin:\', origin); // Should log \'null\'\n\n  if (origin === \'null\') {\n  res.json({ message: \'Request received from null origin!\' });\n  } else {\n  res.status(403).json({ error: \'Invalid origin\' });\n  }\n });\n\n app.listen(3000, () => {\n  console.log(\'Server running on http://localhost:3000\');\n });\n<lg>Example in Python (Flask):</lg>\n from flask import Flask, request, jsonify\n app = Flask(__name__)\n\n @app.route(\'/api\', methods=[\'POST\'])\n def api():\n  origin = request.headers.get(\'Origin\')\n  print(\'Origin:\', origin) # Should log \'null\'\n\n  if origin == \'null\':\n   return jsonify(message=\'Request received from null origin!\')\n  else:\n   return jsonify(error=\'Invalid origin\'), 403\n\n if __name__ == \'__main__\':\n  app.run(port=3000)\n\n<o>5. Testing</o>\n- Save your HTML file locally (e.g., `file:///path/to/your/file.html`).\n- Open the file in a browser and make the request.\n- The server should log the origin as `\'null\'` and respond accordingly.\n\n<o>6. Important Notes</o>\n- Browsers enforce strict security policies for `\'null\'` origins, so you may need to configure CORS headers on the server to allow such requests.\n- If the server is configured to allow `\'null\'` origins, the request will succeed. Otherwise, the browser will block it due to the Same-Origin Policy.\n\n Example CORS headers to allow `\'null\'` origin:\n Access-Control-Allow-Origin: null\n Access-Control-Allow-Methods: POST, GET, OPTIONS\n Access-Control-Allow-Headers: Content-Type\nBy following these steps, you can ensure that the client sends a request with a `\'null\'` origin and that the server handles it correctly. Let me know if you need further clarification!\n',
'<h2>统计每分钟成交量和价格</h2>	通过统计每分钟成交量和价格升去测量庄家的行为是不错的办法，但是如何才能得到相关数据，并且用javascript表现出来\n\n要通过统计每分钟成交量和价格变化来分析庄家行为，首先需要获取实时或历史的股票交易数据。\n以下是实现这一目标的步骤，并用JavaScript进行数据展示的基本思路：\n<o>1. 获取股票交易数据</o>\n-<lg>数据来源</lg>：\n -<lg>免费数据源</lg>：一些金融平台（如新浪财经、腾讯财经、Yahoo Finance、Alpha Vantage等）提供免费的股票历史数据和实时数据。\n -<lg>付费数据源</lg>：如Wind、东方财富、Tushare（针对中国市场的金融数据接口）等，提供更详细的数据。\n -<lg>券商API</lg>：一些券商提供API接口，可以获取实时交易数据。\n-<lg>数据格式</lg>：通常为JSON或CSV格式，包含时间戳、开盘价、收盘价、最高价、最低价、成交量等信息。\n<o>2. 处理和分析数据</o>\n- 使用JavaScript（如Node.js或浏览器环境）获取数据后，可以对数据进行分析。\n- 例如：\n     - 计算每分钟的成交量变化。\n     - 判断是否有大单成交（如单笔成交量超过某个阈值）。\n     - 结合价格变化，判断庄家可能的操作行为。\n<o>3. 用JavaScript实现</o>\n以下是一个简单的示例，展示如何用JavaScript获取数据并分析每分钟的成交量和价格变化。\n<lg>示例代码</lg>：\n// 假设有一个包含每分钟交易数据的数组\nconst stockData = [\n { time: "09:30", price: 10.0, volume: 1000 },\n { time: "09:31", price: 10.1, volume: 1500 },\n { time: "09:32", price: 10.2, volume: 2000 },\n { time: "09:33", price: 10.1, volume: 1800 },\n { time: "09:34", price: 10.3, volume: 2500 },\n // 更多数据...\n];\n\n// 定义一个大单的阈值（例如单笔成交量超过1000手）\nconst LARGE_ORDER_THRESHOLD = 1000;\n\n// 分析每分钟数据\nstockData.forEach((minuteData, index) => {\n const { time, price, volume } = minuteData;\n\n // 判断是否为大单\n if (volume > LARGE_ORDER_THRESHOLD) {\n  console.log(`时间：${time}，价格：${price}，成交量：${volume} —— 可能有大单交易`);\n }\n\n // 判断价格变化趋势\n if (index > 0) {\n  const prevPrice = stockData[index - 1].price;\n  const priceChange = price - prevPrice;\n  if (priceChange > 0) {\n   console.log(`时间：${time}，价格上涨：+${priceChange.toFixed(2)}`);\n  } else if (priceChange < 0) {\n   console.log(`时间：${time}，价格下跌：${priceChange.toFixed(2)}`);\n  }\n }\n});\n<o>4. 可视化数据</o>\n- 使用JavaScript图表库（如<lg>Chart.js</lg>、**D3.js** 或<lg>ECharts</lg>）将数据可视化。\n- 例如，绘制每分钟的成交量和价格变化曲线。\n\n<lg>示例代码（使用Chart.js）</lg>：\n&lt;canvas id="stockChart" width="400" height="200">&lt;/canvas>\n&lt;script src="https://cdn.jsdelivr.net/npm/chart.js">&lt;/script>\n&lt;script>\n const ctx = document.getElementById(\'stockChart\').getContext(\'2d\');\n const stockChart = new Chart(ctx, {\n  type: \'line\',\n  data: {\n   labels: stockData.map(data => data.time), // 时间轴\n   datasets: [\n    {\n     label: \'价格\',\n     data: stockData.map(data => data.price),\n     borderColor: \'blue\',\n     yAxisID: \'price\',\n    },\n    {\n     label: \'成交量\',\n     data: stockData.map(data => data.volume),\n     borderColor: \'red\',\n     yAxisID: \'volume\',\n    }\n   ]\n  },\n  options: {\n   scales: {\n    price: {\n     type: \'linear\',\n     position: \'left\',\n    },\n    volume: {\n     type: \'linear\',\n     position: \'right\',\n    }\n   }\n  }\n });\n&lt;/script>\n<o>5. 获取实时数据</o>\n如果需要实时数据，可以使用以下方法：\n-<lg>WebSocket</lg>：通过券商的WebSocket API获取实时数据。\n-<lg>定时请求</lg>：使用 `setInterval` 定期从API获取最新数据。\n-<lg>示例代码</lg>：\n setInterval(async () => {\n const response = await fetch(\'https://api.example.com/stock-data\');\n const data = await response.json();\n console.log(\'最新数据：\', data);\n }, 60000); // 每分钟更新一次\n<o>6. 注意事项</o>\n-<lg>数据准确性</lg>：确保数据来源可靠。\n-<lg>频率限制</lg>：免费API通常有请求频率限制，注意不要超过限制。\n-<lg>隐私和安全</lg>：如果使用付费API，注意保护API密钥。\n通过以上方法，你可以用JavaScript获取、分析和展示股票交易数据，进而尝试判断庄家的行为。如果需要更复杂的分析，可以结合机器学习或量化交易策略。\n',
'<h2>limit concurrent request</h2>	// Define BaseObj in the global scope\nconst BaseObj = {};\nconst codetable = [\'02800\',\'00700\',\'09988\',\'03690\',\'00883\'];\n\n// Function to fetch data for a single code\nasync function fetchData(code) {\n const stkcode = "hk" + code;\n const url = "https://web.ifzq.gtimg.cn/appstock/app/hkfqkline/get?_var=kline_dayqfq&param=" + stkcode + ",day,,,10,qfq";\n const response = await fetch(url);\n const dataStr = await response.text();\n const jsonString = dataStr.split("=")[1];\n const jsonData = JSON.parse(jsonString);\n const stockName = jsonData.data[stkcode].qt[stkcode][1];\n return { code, stockName, data: jsonData };\n}\n\n// Concurrent request limit\nconst MAX_CONCURRENT_REQUESTS = 5; // Set the maximum number of concurrent requests\n\n// Queue to manage concurrent requests\nconst requestQueue = [];\nlet activeRequests = 0;\n\n// Function to process the next request in the queue\nasync function processQueue() {\n if (activeRequests < MAX_CONCURRENT_REQUESTS && requestQueue.length > 0) {\n  activeRequests++;\n  const request = requestQueue.shift();\n  await request();\n  activeRequests--;\n  processQueue();\n }\n}\n\n// Add requests to the queue\ncodetable.forEach(code => {\n requestQueue.push(async () => {\n  const result = await fetchData(code);\n  BaseObj[result.code] = result; // Store the result in BaseObj\n });\n});\n\n// Start processing the queue\nprocessQueue();\n\n // access data\n const data = BaseObj[\'02800\'];\n const stockName = data.stockName;\n const stockData = data.data;\n console.log(\'Stock Name:\', stockName);\n console.log(\'Stock Data:\', stockData);\n',
'<h2>webscrape news details from browser</h2>	<center><div id="webscrapenewstoc" class="toc"><a href="#webscrapenewstopic-0" target="_self"> 1. Check the Website\'s <lg>robots.txt</lg></a><br><a href="#webscrapenewstopic-1" target="_self"> 2. Inspect the Web Page</a><br><a href="#webscrapenewstopic-2" target="_self"> 3. Use a Web Scraping Tool or Library</a><br><a href="#webscrapenewstopic-3" target="_self"> 4. Example Code (Python with BeautifulSoup and Requests)</a><br><a href="#webscrapenewstopic-4" target="_self"> 5. Handling Dynamic Content</a><br><a href="#webscrapenewstopic-5" target="_self"><y>using JavaScript</y></a><br><a href="#webscrapenewstopic-6" target="_self"> 1. Set Up Node.js</a><br><a href="#webscrapenewstopic-7" target="_self"> 2. Install Required Libraries</a><br><a href="#webscrapenewstopic-8" target="_self"> 3. Write the Scraping Script</a><br><a href="#webscrapenewstopic-9" target="_self"> 4. Run the Script</a><br><a href="#webscrapenewstopic-10" target="_self"> 5. Handling Dynamic Content</a><br><a href="#webscrapenewstopic-11" target="_self"> Install Puppeteer</a><br><a href="#webscrapenewstopic-12" target="_self"> Puppeteer Script</a><br><a href="#webscrapenewstopic-13" target="_self"> 6. Run the Puppeteer Script</a><br><a href="#webscrapenewstopic-14" target="_self"> Notes:</a><br><a href="#webscrapenewstopic-15" target="_self"><y>example of Puppeteer to scrape the news</y></a><br></div></center><br><br>\n\nIt is possible to scrape news details from the provided URL using web scraping techniques.\nHowever, before proceeding, you should ensure that you comply with the website\'s <lg>terms of service</lg> and <lg>robots.txt</lg> file to avoid any legal or ethical issues.\nHere’s a general approach to scrape news details from the URL:\n<o id="webscrapenewstopic-0"> 1. Check the Website\'s <lg>robots.txt</lg></o>\n- Visit <lg>https://www.sinchew.com.my/robots.txt</lg> to see if the website allows scraping for the specific URL or directory.\n- If scraping is disallowed, you should not proceed without permission.\n<o id="webscrapenewstopic-1"> 2. Inspect the Web Page</o>\n- Open the URL in your browser and use the browser\'s developer tools (right-click → Inspect or <lg>Ctrl+Shift+I</lg>) to analyze the HTML structure.\n- Identify the HTML elements containing the news title, date, author, and content.\n<o id="webscrapenewstopic-2"> 3. Use a Web Scraping Tool or Library</o>\n- You can use Python libraries like <lg>BeautifulSoup</lg> (for parsing HTML) and <lg>requests</lg> (for fetching the page content).\n- Alternatively, you can use <lg>Selenium</lg> if the content is dynamically loaded via JavaScript.\n<o id="webscrapenewstopic-3"> 4. Example Code (Python with BeautifulSoup and Requests)</o>\npython\nimport requests\nfrom bs4 import BeautifulSoup\n\n# URL of the news article\nurl = "https://www.sinchew.com.my/news/20250304/international/6346262"\n\n# Send a GET request to fetch the page content\nresponse = requests.get(url)\n\n# Check if the request was successful\nif response.status_code == 200:\n # Parse the HTML content using BeautifulSoup\n soup = BeautifulSoup(response.content, \'html.parser\')\n\n # Extract the news title (example, adjust selector based on actual HTML)\n title = soup.find(\'h1\').text.strip()\n\n # Extract the publication date (example, adjust selector based on actual HTML)\n date = soup.find(\'span\', class_=\'date\').text.strip()\n\n # Extract the news content (example, adjust selector based on actual HTML)\n content = soup.find(\'div\', class_=\'article-content\').text.strip()\n\n # Print the extracted details\n print("Title:", title)\n print("Date:", date)\n print("Content:", content)\nelse:\n print("Failed to retrieve the page. Status code:", response.status_code)\n<o id="webscrapenewstopic-4"> 5. Handling Dynamic Content</o>\n- If the content is loaded dynamically via JavaScript, you may need to use <lg>Selenium</lg> to render the page fully before scraping.\n<h3 id="webscrapenewstopic-5"><y>using JavaScript</y></h3>you can use <lg>Node.js</lg> with libraries like <lg>Axios</lg> (for HTTP requests) and <lg>Cheerio</lg> (for parsing HTML). Here\'s how you can do it:\n<o id="webscrapenewstopic-6"> 1. Set Up Node.js</o>\n- Make sure you have Node.js installed on your system. You can download it from [nodejs.org](https://nodejs.org/).\n- Create a new project folder and initialize it with `npm`:\n  mkdir webscraper\n  cd webscraper\n  npm init -y\n<o id="webscrapenewstopic-7"> 2. Install Required Libraries</o>\n- Install <lg>Axios</lg> and <lg>Cheerio</lg>:\n  npm install axios cheerio\n<o id="webscrapenewstopic-8"> 3. Write the Scraping Script</o>\n- Create a file named `scrape.js` and add the following code:\nconst axios = require(\'axios\');\nconst cheerio = require(\'cheerio\');\n\n// URL of the news article\nconst url = \'https://www.sinchew.com.my/news/20250304/international/6346262\';\n\n// Fetch the page content\naxios.get(url)\n  .then(response =&gt; {\n // Load the HTML content into Cheerio\n const $ = cheerio.load(response.data);\n\n // Extract the news title (adjust selector based on actual HTML)\n const title = $(\'h1\').text().trim();\n\n // Extract the publication date (adjust selector based on actual HTML)\n const date = $(\'span.date\').text().trim();\n\n // Extract the news content (adjust selector based on actual HTML)\n const content = $(\'div.article-content\').text().trim();\n\n // Print the extracted details\n console.log(\'Title:\', title);\n console.log(\'Date:\', date);\n console.log(\'Content:\', content);\n  })\n  .catch(error =&gt; {\n console.error(\'Failed to retrieve the page:\', error.message);\n  });\n<o id="webscrapenewstopic-9"> 4. Run the Script</o>\n- Run the script using Node.js:\n  node scrape.js\n<o id="webscrapenewstopic-10"> 5. Handling Dynamic Content</o>\n- If the content is loaded dynamically via JavaScript, you can use <lg>Puppeteer</lg> (a headless browser library) instead of Axios and Cheerio. Here\'s an example:\n<o id="webscrapenewstopic-11"> Install Puppeteer</o>:\nnpm install puppeteer\n<o id="webscrapenewstopic-12"> Puppeteer Script</o>:\nconst puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n  // Launch a headless browser\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n\n  // URL of the news article\n  const url = \'https://www.sinchew.com.my/news/20250304/international/6346262\';\n\n  // Navigate to the page\n  await page.goto(url, { waitUntil: \'networkidle2\' });\n\n  // Extract the news title (adjust selector based on actual HTML)\n  const title = await page.$eval(\'h1\', el =&gt; el.textContent.trim());\n\n  // Extract the publication date (adjust selector based on actual HTML)\n  const date = await page.$eval(\'span.date\', el =&gt; el.textContent.trim());\n\n  // Extract the news content (adjust selector based on actual HTML)\n  const content = await page.$eval(\'div.article-content\', el =&gt; el.textContent.trim());\n\n  // Print the extracted details\n  console.log(\'Title:\', title);\n  console.log(\'Date:\', date);\n  console.log(\'Content:\', content);\n\n  // Close the browser\n  await browser.close();\n})();\n<o id="webscrapenewstopic-13"> 6. Run the Puppeteer Script</o>\n- Run the script using Node.js:\n  node scrape.js\n<o id="webscrapenewstopic-14"> Notes:</o>\n1. <lg>Selectors</lg>: The selectors (`h1`, `span.date`, `div.article-content`) used in the examples are placeholders. You need to inspect the actual HTML structure of the page and adjust them accordingly.\n<h3 id="webscrapenewstopic-15"><y>example of Puppeteer to scrape the news</y></h3>First, you need to install Puppeteer using npm:\nnpm install puppeteer\nThen, you can create a script to scrape the news details:\n\nconst puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n const url = \'https://www.sinchew.com.my/news/20250304/international/6346262\';\n\n await page.goto(url, { waitUntil: \'domcontentloaded\' });\n\n const newsDetails = await page.evaluate(() =&gt; {\n  const title = document.querySelector(\'h1.title\').innerText;\n  const content = document.querySelector(\'div.article-content\').innerText;\n\n  return { title, content };\n });\n\n console.log(newsDetails);\n\n await browser.close();\n})();\nIn this script:\nIt launches a headless browser using Puppeteer and opens a new page.\nIt navigates to the provided URL.\nUsing page.evaluate(), it extracts the title and content of the news article by selecting the relevant elements on the page.\nFinally, it logs the news details to the console and closes the browser.\nPlease make sure to handle any asynchronous operations properly and adjust the script to fit the structure of the website you are scraping.\n',
'<h2>add element to object and later increment the value</h2>	// Initialize an object\nlet data = {};\n// Function to add a new key-value pair or increment the existing value\nfunction addToObject(obj, key, value) {\n if (obj[key] === undefined) {\n  // If the key is not present\n  obj[key] = value;\n } else {\n  // If the key is already present\n  obj[key] += value;\n }\n}\n// Add or increment values in the object\naddToObject(data, \'key1\', 5); // Adding a new key-value pair\naddToObject(data, \'key2\', 10); // Adding a new key-value pair\naddToObject(data, \'key1\', 3); // Incrementing the value\nconsole.log(data); // Output the updated object',
'<h2>to access to Object.keys of the variable name object</h2>	An object name that is constructed by joining a string `"fdays_data_"` and a variable name, and to access the `Object.keys` of the resultant object:\n<o>Example:</o>\nconst variableName = "example"; // This is the variable part of the object name\nconst objectName = "fdays_data_" + variableName; // Construct the object name\n// Assume you have an object like this:\nconst fdays_data_example = {\n    key1: "value1",\n    key2: "value2",\n    key3: "value3"\n};\n\n// Access the object dynamically using bracket notation\nconst resultantObject = window[objectName]; // Use `window` if it\'s in the global scope, or use the appropriate context\n\n// Get the keys of the resultant object\nconst keys = Object.keys(resultantObject);\n\nconsole.log(keys); // Output: ["key1", "key2", "key3"]\n\n<o>Explanation:</o>\n1. <y>Construct the object name</y>: Use string concatenation to create the object name dynamically.\n2. <y>Access the object dynamically</y>: Use bracket notation (`window[objectName]` or `this[objectName]` depending on the context) to access the object.\n3. <y>Get the keys</y>: Use `Object.keys()` to retrieve the keys of the object.\n<o>Notes:</o>\n- If the object is not in the global scope (e.g., inside a function or module), replace `window` with the appropriate context or object that contains the variable.\n- Ensure the object exists before accessing it to avoid errors.\n',
'<h2>using Web Worker in concurrent requests</h2>	<center><div id="concurrentWebWorkertoc" class="toc"><a href="#concurrentWebWorkertopic-0" target="_self">Steps to Limit Concurrent Requests in Web Workers</a><br><a href="#concurrentWebWorkertopic-1" target="_self">Implementation</a><br><a href="#concurrentWebWorkertopic-2" target="_self">Web Worker Script (`worker.js`)</a><br><a href="#concurrentWebWorkertopic-3" target="_self">How It Works</a><br><a href="#concurrentWebWorkertopic-4" target="_self">Key Features</a><br><a href="#concurrentWebWorkertopic-5" target="_self">Example Workflow</a><br><a href="#concurrentWebWorkertopic-6" target="_self">Improvements</a><br></div></center><br><br>\n\nTo limit concurrent requests when using a <y>Web Worker</y>, you need to coordinate the tasks sent to the worker pool. Web Workers run in separate threads, so you need to manage the number of tasks being processed concurrently by the workers.\nHere\'s how you can achieve this:\n<o id="concurrentWebWorkertopic-0">Steps to Limit Concurrent Requests in Web Workers</o>\n1. <y>Create a Pool of Web Workers</y>:\n- Initialize a pool of workers (e.g., 5 workers) to handle tasks concurrently.\n2. <y>Queue Tasks</y>:\n- Maintain a queue of tasks that need to be processed.\n3. <y>Assign Tasks to Workers</y>:\n- Assign tasks to workers as they become available, ensuring that no more than the specified number of tasks are processed concurrently.\n4. <y>Track Worker Availability</y>:\n- Use a mechanism to track which workers are busy and which are free to take on new tasks.\n<o id="concurrentWebWorkertopic-1">Implementation</o>\nHere’s an example implementation:\n// Constants\nconst MAX_CONCURRENT_REQUESTS = 5; // Maximum number of concurrent requests\nconst workerPool = []; // Pool of Web Workers\nconst taskQueue = []; // Queue of tasks\n// Initialize Web Worker pool\nfor (let i = 0; i &lt; MAX_CONCURRENT_REQUESTS; i++) {\n const worker = new Worker(\'worker.js\'); // Path to your worker script\n workerPool.push({ worker, busy: false });\n}\n// Function to process the next task in the queue\nfunction processNextTask() {\n // Find an available worker\n const availableWorker = workerPool.find(w =&gt; !w.busy);\n if (availableWorker &amp;&amp; taskQueue.length &gt; 0) {\n  const task = taskQueue.shift(); // Get the next task from the queue\n  availableWorker.busy = true; // Mark the worker as busy\n  // Send the task to the worker\n  availableWorker.worker.postMessage(task);\n  // Listen for the worker\'s response\n  availableWorker.worker.onmessage = (event) =&gt; {\n   console.log(\'Task completed:\', event.data);\n   // Mark the worker as available\n   availableWorker.busy = false;\n   // Process the next task\n   processNextTask();\n  };\n  // Handle errors\n  availableWorker.worker.onerror = (error) =&gt; {\n   console.error(\'Worker error:\', error);\n   availableWorker.busy = false; // Mark the worker as available\n   processNextTask(); // Process the next task\n  };\n }\n}\n// Function to add a task to the queue\nfunction addTask(task) {\n taskQueue.push(task); // Add the task to the queue\n processNextTask(); // Try to process the task immediately\n}\n// Example usage\nconst tasks = [\n { url: \'https://example.com/api/1\' },\n { url: \'https://example.com/api/2\' },\n  。。。\n { url: \'https://example.com/api/9\' },\n { url: \'https://example.com/api/10\' },\n];\n// Add tasks to the queue\ntasks.forEach(task =&gt; addTask(task));\n<o id="concurrentWebWorkertopic-2">Web Worker Script (`worker.js`)</o>\nThe Web Worker script handles the actual task processing. Here\'s an example:\n// worker.js\nself.onmessage = async (event) =&gt; {\n const { url } = event.data;\n // Simulate fetching data from the URL\n try {\n  const response = await fetch(url);\n  const data = await response.json();\n  self.postMessage({ url, data }); // Send the result back to the main thread\n } catch (error) {\n  self.postMessage({ url, error: error.message }); // Send the error back to the main thread\n }\n};\n<o id="concurrentWebWorkertopic-3">How It Works</o>\n1. <y>Worker Pool</y>:\n- A pool of 5 Web Workers is created. Each worker can handle one task at a time.\n2. <y>Task Queue</y>:\n- Tasks are added to a queue. The `addTask` function adds tasks to the queue and tries to process them immediately.\n3. <y>Task Processing</y>:\n- The `processNextTask` function checks for an available worker and assigns the next task from the queue to it.\n- Once a worker completes a task, it marks itself as available and processes the next task in the queue.\n4. <y>Concurrency Control</y>:\n- The `MAX_CONCURRENT_REQUESTS` constant ensures that no more than 5 tasks are processed concurrently.\n<o id="concurrentWebWorkertopic-4">Key Features</o>\n- <y>Concurrency Limit</y>: The number of concurrent tasks is limited to the size of the worker pool.\n- <y>Task Queue</y>: Tasks are queued and processed as workers become available.\n- <y>Error Handling</y>: Errors in the worker are caught and reported back to the main thread.\n- <y>Scalability</y>: You can easily adjust the concurrency limit by changing the size of the worker pool.\n<o id="concurrentWebWorkertopic-5">Example Workflow</o>\nSuppose you have 10 tasks:\n1. The first 5 tasks are assigned to the 5 workers.\n2. As each worker completes a task, it picks up the next task from the queue.\n3. This continues until all 10 tasks are processed, with no more than 5 tasks active at any time.\n<o id="concurrentWebWorkertopic-6">Improvements</o>\n1. <y>Dynamic Worker Pool</y>:\n- You can dynamically create or terminate workers based on the workload.\n2. <y>Task Prioritization</y>:\n- Implement a priority queue to process high-priority tasks first.\n3. <y>Retry Mechanism</y>:\n- Add a retry mechanism for failed tasks.\n4. <y>Progress Tracking</y>:\n- Track the progress of tasks and notify the main thread when all tasks are complete.\n',
'<h2>show frequency distribution by javascript</h2>	<center><div id="frequencydisttoc" class="toc"><a href="#frequencydisttopic-0" target="_self">1. Using a Plain JavaScript Object</a><br><a href="#frequencydisttopic-1" target="_self">2. Using `reduce()` for Frequency Distribution</a><br><a href="#frequencydisttopic-2" target="_self">3. Using `Map` for Frequency Distribution</a><br><a href="#frequencydisttopic-3" target="_self">4. Visualizing Frequency Distribution with a Bar Chart</a><br><a href="#frequencydisttopic-4" target="_self">5. Frequency Distribution for <y>Numeric Data</y> (Binning)</a><br><a href="#frequencydisttopic-5" target="_self">Summary</a><br></div></center><br><br>\n\nsome common methods:\n<o id="frequencydisttopic-0">1. Using a Plain JavaScript Object</o>\nYou can use a plain JavaScript object to count the frequency of each value in an array.\n\n// Example data\nconst data = ["A", "B", "A", "C", "B", "A", "A", "C", "B", "A"];\n\n// Create a frequency distribution\nconst frequencyDistribution = {};\n\ndata.forEach(item =&gt; {\n frequencyDistribution[item] = (frequencyDistribution[item] || 0) + 1;\n});\n\nconsole.log(frequencyDistribution);\nOutput:\n{ A: 5, B: 3, C: 2 }\n<o id="frequencydisttopic-1">2. Using `reduce()` for Frequency Distribution</o>\nThe `reduce()` method is a powerful way to calculate the frequency distribution.\n\n// Example data\nconst data = ["A", "B", "A", "C", "B", "A", "A", "C", "B", "A"];\n\n// Calculate frequency distribution\nconst frequencyDistribution = data.reduce((acc, item) =&gt; {\n acc[item] = (acc[item] || 0) + 1;\n return acc;\n}, {});\n\nconsole.log(frequencyDistribution);\nOutput:\n{ A: 5, B: 3, C: 2 }\n<o id="frequencydisttopic-2">3. Using `Map` for Frequency Distribution</o>\nA `Map` can also be used to store the frequency distribution, especially if the keys are not strings.\n\n// Example data\nconst data = ["A", "B", "A", "C", "B", "A", "A", "C", "B", "A"];\n\n// Create a frequency distribution using Map\nconst frequencyDistribution = new Map();\n\ndata.forEach(item =&gt; {\n frequencyDistribution.set(item, (frequencyDistribution.get(item) || 0) + 1);\n});\n\nconsole.log(Object.fromEntries(frequencyDistribution));\nOutput:\n{ A: 5, B: 3, C: 2 }\n<o id="frequencydisttopic-3">4. Visualizing Frequency Distribution with a Bar Chart</o>\nYou can use a library like **Chart.js** or **D3.js** to visualize the frequency distribution as a bar chart.\n<y>Example using Chart.js</y>:\n&lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;\n&lt;canvas id="myChart" width="400" height="200"&gt;&lt;/canvas&gt;\n&lt;script&gt;\n // Example data\n const data = ["A", "B", "A", "C", "B", "A", "A", "C", "B", "A"];\n\n // Calculate frequency distribution\n const frequencyDistribution = data.reduce((acc, item) =&gt; {\n  acc[item] = (acc[item] || 0) + 1;\n  return acc;\n }, {});\n\n // Extract labels and frequencies\n const labels = Object.keys(frequencyDistribution);\n const frequencies = Object.values(frequencyDistribution);\n\n // Create a bar chart\n const ctx = document.getElementById(\'myChart\').getContext(\'2d\');\n const myChart = new Chart(ctx, {\n  type: \'bar\',\n  data: {\n  labels: labels,\n  datasets: [{\n   label: \'Frequency\',\n   data: frequencies,\n   backgroundColor: \'rgba(75, 192, 192, 0.2)\',\n   borderColor: \'rgba(75, 192, 192, 1)\',\n   borderWidth: 1\n  }]\n  },\n  options: {\n  scales: {\n   y: {\n   beginAtZero: true\n   }\n  }\n  }\n });\n&lt;/script&gt;\n\nThis will render a bar chart showing the frequency distribution of the data.\n<o id="frequencydisttopic-4">5. Frequency Distribution for <y>Numeric Data</y> (Binning)</o>\nFor numeric data, you can bin the data into ranges and calculate the frequency distribution.\n\n// Example numeric data\nconst data = [12, 15, 22, 25, 30, 35, 40, 45, 50, 55, 60];\n\n// Define bins\nconst bins = [10, 20, 30, 40, 50, 60];\n\n// Calculate frequency distribution\nconst frequencyDistribution = Array(bins.length).fill(0);\n\ndata.forEach(value =&gt; {\n for (let i = 0; i &lt; bins.length; i++) {\n if (value &lt;= bins[i]) {\n  frequencyDistribution[i]++;\n  break;\n }\n }\n});\n\nconsole.log(frequencyDistribution);\nOutput:\n[2, 3, 2, 2, 2]\n<o id="frequencydisttopic-5">Summary</o>\n- Use plain objects, `reduce()`, or `Map` to calculate frequency distributions.\n- Use libraries like **Chart.js** or **D3.js** to visualize the distribution.\n- For numeric data, bin the data into ranges before calculating frequencies.\n',
'<h2>WebSockets</h2>	Using WebSockets in JavaScript can significantly speed up communication between a client (e.g., a web browser) and a server compared to traditional HTTP requests. WebSockets provide a full-duplex, persistent connection that allows real-time, low-latency communication. Here\'s how you can use WebSockets in JavaScript to speed up communication:\n<o>1. Why WebSockets are Faster</o>\n- <y>Persistent Connection</y>: WebSockets maintain a single, long-lived connection between the client and server, eliminating the overhead of repeatedly establishing new connections (as in HTTP).\n- <y>Low Latency</y>: Data can be sent and received instantly without waiting for request/response cycles.\n- <y>Efficient Data Transfer</y>: WebSockets use a lightweight protocol with minimal overhead, making it ideal for real-time applications like chat, gaming, or live updates.\n<o>2. Setting Up a WebSocket Connection</o>\nTo use WebSockets in JavaScript, you need to:\n- Create a WebSocket connection on the client side.\n- Set up a WebSocket server to handle incoming connections and messages.\n\n<y>Client-Side (JavaScript in the Browser)</y>\n// Create a WebSocket connection to the server\nconst socket = new WebSocket(\'ws://your-server-address\');\n\n// Event listener for when the connection is established\nsocket.addEventListener(\'open\', (event) => {\n console.log(\'WebSocket connection opened\');\n // Send a message to the server\n socket.send(\'Hello Server!\');\n});\n\n// Event listener for receiving messages from the server\nsocket.addEventListener(\'message\', (event) => {\n console.log(\'Message from server:\', event.data);\n});\n\n// Event listener for handling errors\nsocket.addEventListener(\'error\', (error) => {\n console.error(\'WebSocket error:\', error);\n});\n\n// Event listener for when the connection is closed\nsocket.addEventListener(\'close\', (event) => {\n console.log(\'WebSocket connection closed\');\n});\n<y>Server-Side (Node.js Example)</y>\nYou can use the `ws` library in Node.js to create a WebSocket server:\n```bash\nnpm install ws\nconst WebSocket = require(\'ws\');\n\n// Create a WebSocket server\nconst wss = new WebSocket.Server({ port: 8080 });\n\n// Event listener for when a client connects\nwss.on(\'connection\', (ws) => {\n console.log(\'Client connected\');\n\n // Event listener for receiving messages from the client\n ws.on(\'message\', (message) => {\n  console.log(\'Received:\', message.toString());\n\n  // Send a response back to the client\n  ws.send(`Server received: ${message}`);\n });\n\n // Event listener for when the client disconnects\n ws.on(\'close\', () => {\n  console.log(\'Client disconnected\');\n });\n});\n<o>3. Advantages for Speeding Up Communication</o>\n- <y>Real-Time Updates</y>: WebSockets allow the server to push updates to the client instantly without the client needing to poll the server repeatedly.\n- <y>Reduced Overhead</y>: Unlike HTTP, which requires headers and handshakes for every request, WebSockets have minimal overhead after the initial connection.\n- <y>Bidirectional Communication</y>: Both the client and server can send messages at any time, enabling faster and more interactive communication.\n<o>4. Use Cases for WebSockets</o>\n- <y>Real-Time Applications</y>: Chat applications, live notifications, and collaborative tools.\n- <y>Gaming</y>: Multiplayer games requiring low-latency communication.\n- <y>Financial Applications</y>: Real-time stock price updates.\n- <y>IoT</y>: Real-time monitoring and control of devices.\n<o>5. Best Practices</o>\n- <y>Reconnect Logic</y>: Implement logic to reconnect if the WebSocket connection is lost.\n- <y>Error Handling</y>: Handle errors gracefully to ensure robustness.\n- <y>Message Format</y>: Use a structured format like JSON for sending and receiving messages.\n- <y>Security</y>: Use `wss://` (WebSocket Secure) for encrypted communication.\n<o>Example: Sending JSON Data</o>\n<y>Client-Side</y>\nconst socket = new WebSocket(\'ws://your-server-address\');\n\nsocket.addEventListener(\'open\', () => {\n const data = { type: \'message\', content: \'Hello Server!\' };\n socket.send(JSON.stringify(data));\n});\n\nsocket.addEventListener(\'message\', (event) => {\n const data = JSON.parse(event.data);\n console.log(\'Received from server:\', data);\n});\n<y>Server-Side</y>\nws.on(\'message\', (message) => {\n const data = JSON.parse(message);\n console.log(\'Received:\', data);\n\n const response = { type: \'response\', content: \'Hello Client!\' };\n ws.send(JSON.stringify(response));\n});\n\nThe term `ws:\\` seems to be a typo or misunderstanding. The correct protocol for WebSocket connections is `ws://` for unencrypted connections and `wss://` for encrypted (secure) connections, similar to `http://` and `https://` for HTTP.\n<o>Setting Up `wss://`</o>\n<y>Server-Side Code (Node.js with `wss://`)</y>\nconst https = require(\'https\');\nconst fs = require(\'fs\');\nconst WebSocket = require(\'ws\');\n\n// Load SSL certificate and key\nconst server = https.createServer({\n cert: fs.readFileSync(\'path/to/certificate.pem\'),\n key: fs.readFileSync(\'path/to/private-key.pem\'),\n});\n\n// Create a WebSocket server\nconst wss = new WebSocket.Server({ server });\n\nwss.on(\'connection\', (ws) => {\n console.log(\'Client connected\');\n ws.on(\'message\', (message) => {\n  console.log(\'Received:\', message.toString());\n  ws.send(`Server received: ${message}`);\n });\n});\n\n// Start the server\nserver.listen(8080, () => {\n console.log(\'WebSocket server is running on wss://localhost:8080\');\n});\n',
'<h2>Disabling the Ctrl + W</h2>	<center><div id="DisableCtrl+Wtoc" class="toc"><a href="#DisableCtrl+Wtopic-0" target="_self"> 1. Use a Chrome Extension</a><br><a href="#DisableCtrl+Wtopic-1" target="_self"> 2. Use AutoHotkey (Windows Only)</a><br><a href="#DisableCtrl+Wtopic-2" target="_self"> 3. Use macOS Keyboard Shortcut Remapping</a><br><a href="#DisableCtrl+Wtopic-3" target="_self"> 4. Use a Custom JavaScript Solution (Advanced)</a><br><a href="#DisableCtrl+Wtopic-4" target="_self"> 5. Use a Different Browser</a><br><a href="#DisableCtrl+Wtopic-5" target="_self"> Important Notes:</a><br></div></center><br><br>\n\nDisabling the `Ctrl + W` shortcut in Google Chrome, which closes the current tab, isn\'t straightforward because Chrome doesn\'t provide a built-in way to modify or disable keyboard shortcuts.\nHowever, there are a few workarounds you can try:\n<o id="DisableCtrl+Wtopic-0"> 1. Use a Chrome Extension</o>\nYou can use extensions like <y>Shortkeys</y> or <y>Disable Keyboard Shortcuts</y> to remap or disable specific keyboard shortcuts.\n<y>Steps:</y>\n1. Open the Chrome Web Store.\n2. Search for an extension like <y>Shortkeys</y> or <y>Disable Keyboard Shortcuts</y>.\n3. Install the extension.\n4. Configure the extension to disable or remap the `Ctrl + W` shortcut.\n<o id="DisableCtrl+Wtopic-1"> 2. Use AutoHotkey (Windows Only)</o>\nAutoHotkey is a scripting tool that allows you to remap or disable keyboard shortcuts system-wide.\n<y>Steps:</y>\n1. Download and install [AutoHotkey](https://www.autohotkey.com/).\n2. Create a new script file (e.g., `disable_ctrl_w.ahk`).\n3. Add the following code to the script:\n`ahk\n ^w::return\n- `^w` represents `Ctrl + W`.\n- `return` tells AutoHotkey to do nothing when the shortcut is pressed.\n4. Save the script and double-click it to run it.\n<o id="DisableCtrl+Wtopic-2"> 3. Use macOS Keyboard Shortcut Remapping</o>\nIf you\'re on macOS, you can use the <y>System Preferences</y> to remap or disable keyboard shortcuts.\n<y>Steps:</y>\n1. Go to <y>System Preferences &gt; Keyboard &gt; Shortcuts</y>.\n2. Select <y>App Shortcuts</y> from the sidebar.\n3. Click the <y>+</y> button to add a new shortcut.\n4. Choose <y>Google Chrome</y> as the application.\n5. Enter a menu command like `Close Tab` (exact wording matters).\n6. Assign a different shortcut or leave it blank to disable it.\n<o id="DisableCtrl+Wtopic-3"> 4. Use a Custom JavaScript Solution (Advanced)</o>\nIf you\'re a developer or comfortable with JavaScript, you can inject a script into Chrome to intercept the `Ctrl + W` shortcut.\n<y>Steps:</y>\n1. Open the Chrome Developer Tools (`Ctrl + Shift + I` or `Cmd + Option + I` on macOS).\n2. Go to the <y>Console</y> tab.\n3. Paste the following code:\n document.addEventListener(\'keydown\', function(event) {\n   if (event.ctrlKey &amp;&amp; event.key === \'w\') {\n     event.preventDefault();\n     console.log(\'Ctrl + W disabled\');\n   }\n });\n This will prevent the `Ctrl + W` shortcut from closing the tab while the Developer Tools are open. However, this is not a permanent solution.\n<o id="DisableCtrl+Wtopic-4"> 5. Use a Different Browser</o>\nSome browsers, like Firefox, allow you to customize keyboard shortcuts more easily through extensions or settings.\n<o id="DisableCtrl+Wtopic-5"> Important Notes:</o>\n- Disabling `Ctrl + W` can be inconvenient if you frequently close tabs.\n- Be cautious when using third-party extensions or scripts, as they may have access to your browsing data.\n',
'<h2>javascript map function</h2>	<center><div id="javascriptmaptoc" class="toc"><a href="#javascriptmaptopic-0" target="_self">語法</a><br><a href="#javascriptmaptopic-1" target="_self">參數</a><br><a href="#javascriptmaptopic-2" target="_self">返回值</a><br><a href="#javascriptmaptopic-3" target="_self">範例</a><br><a href="#javascriptmaptopic-4" target="_self">使用箭頭函數簡化</a><br><a href="#javascriptmaptopic-5" target="_self">注意事項</a><br></div></center><br><br>\n\n在 JavaScript 中，map 是一個陣列方法，用於對陣列中的每個元素執行指定的函數，並返回一個新的陣列，新陣列中的元素是原陣列元素經過函數處理後的結果。\n\n<o id="javascriptmaptopic-0">語法</o>\nconst newArray = array.map(callback(currentValue, index, array), thisArg);\n\n<o id="javascriptmaptopic-1">參數</o>\n1. <y>callback</y>: 對每個元素執行的函數，該函數接收三個參數：\n- <y>currentValue</y>: 當前處理的元素。\n- <y>index</y> (可選): 當前處理元素的索引。\n- <y>array</y> (可選): 調用 map 的陣列本身。\n2. <y>thisArg</y> (可選): 執行 callback 時使用的 this 值。\n\n<o id="javascriptmaptopic-2">返回值</o>\n- 返回一個新陣列，每個元素都是原陣列元素經過 callback 處理後的結果。\n\n<o id="javascriptmaptopic-3">範例</o>\nconst numbers = [1, 2, 3, 4];\n\n// 將每個元素乘以 2\nconst doubled = numbers.map(function(num) {\n return num * 2;\n});\n\nconsole.log(doubled); // 輸出: [2, 4, 6, 8]\n\n<o id="javascriptmaptopic-4">使用箭頭函數簡化</o>\nconst numbers = [1, 2, 3, 4];\nconst doubled = numbers.map(num =&gt; num * 2);\n\nconsole.log(doubled); // 輸出: [2, 4, 6, 8]\n\n<o id="javascriptmaptopic-5">注意事項</o>\n- map 不會改變原陣列，而是返回一個新陣列。\n- 如果陣列中有空元素（例如 [1, , 3]），map 會跳過這些空元素，不會對它們執行 callback。\n',
'<h2>object 和 map 結構異同</h2>	<center><div id="結構異同toc" class="toc"><a href="#結構異同topic-0" target="_self"><pk>相同點</pk></a><br><a href="#結構異同topic-1" target="_self"> 鍵值對結構</a><br><a href="#結構異同topic-2" target="_self"> 動態增刪</a><br><a href="#結構異同topic-3" target="_self"><pk>不同點</pk></a><br><a href="#結構異同topic-4" target="_self"> 鍵的類型</a><br><a href="#結構異同topic-5" target="_self"> 鍵的順序</a><br><a href="#結構異同topic-6" target="_self"> 大小（Size）</a><br><a href="#結構異同topic-7" target="_self"> 迭代</a><br><a href="#結構異同topic-8" target="_self"> 效能</a><br><a href="#結構異同topic-9" target="_self"> 預設鍵</a><br><a href="#結構異同topic-10" target="_self"> 序列化</a><br><a href="#結構異同topic-11" target="_self"> 使用場景</a><br><a href="#結構異同topic-12" target="_self"><pk>範例比較</pk></a><br><a href="#結構異同topic-13" target="_self"> 1. 鍵的類型</a><br><a href="#結構異同topic-14" target="_self"> 2. 順序</a><br><a href="#結構異同topic-15" target="_self"> 3. 大小</a><br><a href="#結構異同topic-16" target="_self"> 4. 迭代</a><br><a href="#結構異同topic-17" target="_self"><pk>使用場景</pk></a><br><a href="#結構異同topic-18" target="_self"> Object</a><br><a href="#結構異同topic-19" target="_self"> Map</a><br><a href="#結構異同topic-20" target="_self"><pk>總結</pk></a><br><a href="#結構異同topic-21" target="_self"> Object</a><br><a href="#結構異同topic-22" target="_self"> Map</a><br></div></center><br><br>\n\n在 JavaScript 中，Object 和 Map 都是用於儲存鍵值對的資料結構，但它們在設計和用途上有顯著的差異。\n以下是它們的主要異同點：\n\n<o id="結構異同topic-0"><pk>相同點</pk></o>\n1. <y id="結構異同topic-1"> 鍵值對結構</y>：\n- 兩者都使用鍵值對（key-value pairs）來儲存資料。\n- 可以通過鍵（key）來存取對應的值（value）。\n\n2. <y id="結構異同topic-2"> 動態增刪</y>：\n- 都可以動態地新增、刪除或修改鍵值對。\n\n<o id="結構異同topic-3"><pk>不同點</pk></o>\n特性\n<y id="結構異同topic-4"> 鍵的類型</y> Object 鍵只能是字串（String）或 Symbol。\n Map 鍵可以是任意類型（包括物件、函數、原始值等）。\n<y id="結構異同topic-5"> 鍵的順序</y> Object 在 ES6 之前，鍵的順序不一定保證；ES6 後，字串鍵按插入順序排列，但 Symbol 鍵不保證。\n Map 鍵值對的順序嚴格按照插入順序排列。\n<y id="結構異同topic-6"> 大小（Size）</y> Object 需要手動計算（例如 Object.keys(obj).length）。\n Map 可以直接通過 map.size 取得。\n<y id="結構異同topic-7"> 迭代</y> Object 需要手動使用 for...in 或 Object.keys() 等方法。\n Map 內建迭代器，可以直接使用 for...of 或 map.forEach()。\n<y id="結構異同topic-8"> 效能</y> Object 在頻繁增刪鍵值對的情況下效能較差。\n Map 在頻繁增刪鍵值對的情況下效能較好。\n<y id="結構異同topic-9"> 預設鍵</y> Object 有原型鏈（prototype），可能會有預設的鍵（如 toString）。\n Map 沒有原型鏈，不會有預設鍵。\n<y id="結構異同topic-10"> 序列化</y> Object 可以使用 JSON.stringify() 序列化。\n Map 無法直接序列化，需要手動轉換。\n<y id="結構異同topic-11"> 使用場景</y> Object 適合靜態的、鍵為字串的資料結構。\n Map 適合動態的、鍵為任意類型的資料結構。\n\n<o id="結構異同topic-12"><pk>範例比較</pk></o>\n<y id="結構異同topic-13"> 1. 鍵的類型</y>\n// Object\nconst obj = {};\nobj[1] = "one"; // 鍵會被自動轉為字串 "1"\nobj["1"] = "one again"; // 會覆蓋上面的值\nconsole.log(obj); // { "1": "one again" }\n\n// Map\nconst map = new Map();\nmap.set(1, "one"); // 鍵是數字 1\nmap.set("1", "one again"); // 鍵是字串 "1"\nconsole.log(map.get(1)); // "one"\nconsole.log(map.get("1")); // "one again"\n\n<y id="結構異同topic-14"> 2. 順序</y>\n// Object\nconst obj = { b: 2, a: 1 };\nconsole.log(Object.keys(obj)); // ["b", "a"]（順序不一定）\n\n// Map\nconst map = new Map();\nmap.set("b", 2);\nmap.set("a", 1);\nconsole.log([...map.keys()]); // ["b", "a"]（嚴格按插入順序）\n\n<y id="結構異同topic-15"> 3. 大小</y>\n// Object\nconst obj = { a: 1, b: 2 };\nconsole.log(Object.keys(obj).length); // 2\n\n// Map\nconst map = new Map();\nmap.set("a", 1);\nmap.set("b", 2);\nconsole.log(map.size); // 2\n\n<y id="結構異同topic-16"> 4. 迭代</y>\n// Object\nconst obj = { a: 1, b: 2 };\nfor (let key in obj) {\n console.log(key, obj[key]); // "a 1", "b 2"\n}\n\n// Map\nconst map = new Map();\nmap.set("a", 1);\nmap.set("b", 2);\nfor (let [key, value] of map) {\n console.log(key, value); // "a 1", "b 2"\n}\n\n<o id="結構異同topic-17"><pk>使用場景</pk></o>\n- <y id="結構異同topic-18"> Object</y>：\n- 適合靜態的、鍵為字串的資料結構。\n- 例如：配置物件、資料傳輸物件（DTO）、JSON 資料等。\n\n- <y id="結構異同topic-19"> Map</y>：\n- 適合動態的、鍵為任意類型的資料結構。\n- 例如：需要頻繁增刪鍵值對的場景、需要保留插入順序的場景、鍵可能是物件的情況。\n\n<o id="結構異同topic-20"><pk>總結</pk></o>\n- 如果需要簡單的鍵值對儲存，且鍵是字串，可以使用 <y id="結構異同topic-21"> Object</y>。\n- 如果需要更靈活的鍵類型、嚴格的順序保證或高效能的增刪操作，則使用 <y id="結構異同topic-22"> Map</y>。\n',
'<h2>map結構使用範例</h2>	<center><div id="map結構toc" class="toc"><a href="#map結構topic-0" target="_self">1. 創建與初始化 Map</a><br><a href="#map結構topic-1" target="_self">2. 新增鍵值對</a><br><a href="#map結構topic-2" target="_self">3. 取得值</a><br><a href="#map結構topic-3" target="_self">4. 檢查鍵是否存在</a><br><a href="#map結構topic-4" target="_self">5. 刪除鍵值對</a><br><a href="#map結構topic-5" target="_self">6. 清空 Map</a><br><a href="#map結構topic-6" target="_self">7. 取得 Map 的大小</a><br><a href="#map結構topic-7" target="_self">8. 迭代 Map</a><br><a href="#map結構topic-8" target="_self">8.1 使用 for...of</a><br><a href="#map結構topic-9" target="_self">8.2 使用 forEach</a><br><a href="#map結構topic-10" target="_self">8.3 取得所有鍵或值</a><br><a href="#map結構topic-11" target="_self">9. 使用物件作為鍵</a><br><a href="#map結構topic-12" target="_self">10. 將 Map 轉為陣列</a><br><a href="#map結構topic-13" target="_self">11. 將 Map 轉為 Object</a><br><a href="#map結構topic-14" target="_self">12. 實際應用範例</a><br></div></center><br><br>\n\nMap 是 JavaScript 中一種強大的鍵值對資料結構，適合需要動態操作、鍵為任意類型或需要保留插入順序的場景。以下是一些常見的使用範例，展示如何操作 Map。\n\n<o id="map結構topic-0">1. 創建與初始化 Map</o>\n// 創建一個空的 Map\nconst map = new Map();\n\n// 創建時初始化資料\nconst mapWithData = new Map([\n ["name", "Alice"],\n ["age", 25],\n [1, "one"],\n [{ key: "objKey" }, "This is an object key"]\n]);\n\nconsole.log(mapWithData);\n<o id="map結構topic-1">2. 新增鍵值對</o>\n使用 set(key, value) 方法新增鍵值對。\nconst map = new Map();\n\nmap.set("name", "Alice");\nmap.set("age", 25);\nmap.set(1, "one");\nmap.set({ key: "objKey" }, "This is an object key");\n\nconsole.log(map);\n\n<o id="map結構topic-2">3. 取得值</o>\n使用 get(key) 方法根據鍵取得對應的值。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconsole.log(map.get("name")); // "Alice"\nconsole.log(map.get("age")); // 25\nconsole.log(map.get("unknown")); // undefined（鍵不存在時返回 undefined）\n\n<o id="map結構topic-3">4. 檢查鍵是否存在</o>\n使用 has(key) 方法檢查某個鍵是否存在。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconsole.log(map.has("name")); // true\nconsole.log(map.has("gender")); // false\n\n<o id="map結構topic-4">5. 刪除鍵值對</o>\n使用 delete(key) 方法刪除指定的鍵值對。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nmap.delete("name");\nconsole.log(map.has("name")); // false\nconsole.log(map); // Map { "age" => 25 }\n\n<o id="map結構topic-5">6. 清空 Map</o>\n使用 clear() 方法清空所有鍵值對。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nmap.clear();\nconsole.log(map.size); // 0\n\n<o id="map結構topic-6">7. 取得 Map 的大小</o>\n使用 size 屬性取得 Map 中鍵值對的數量。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconsole.log(map.size); // 2\n\n<o id="map結構topic-7">8. 迭代 Map</o>\nMap 內建迭代器，可以使用以下方法進行迭代：\n\n<y id="map結構topic-8">8.1 使用 for...of</y>\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nfor (let [key, value] of map) {\n console.log(key, value);\n}\n// 輸出:\n// name Alice\n// age 25\n\n<y id="map結構topic-9">8.2 使用 forEach</y>\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nmap.forEach((value, key) => {\n console.log(key, value);\n});\n// 輸出:\n// name Alice\n// age 25\n\n<y id="map結構topic-10">8.3 取得所有鍵或值</y>\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconsole.log([...map.keys()]);  // ["name", "age"]\nconsole.log([...map.values()]); // ["Alice", 25]\nconsole.log([...map.entries()]); // [["name", "Alice"], ["age", 25]]\n\n<o id="map結構topic-11">9. 使用物件作為鍵</o>\nMap 允許使用物件作為鍵，這是 Object 無法做到的。\nconst objKey1 = { id: 1 };\nconst objKey2 = { id: 2 };\n\nconst map = new Map();\nmap.set(objKey1, "Value for objKey1");\nmap.set(objKey2, "Value for objKey2");\n\nconsole.log(map.get(objKey1)); // "Value for objKey1"\nconsole.log(map.get(objKey2)); // "Value for objKey2"\n\n<o id="map結構topic-12">10. 將 Map 轉為陣列</o>\n可以使用 Array.from 或展開運算符將 Map 轉為陣列。\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconst arrayFromMap = Array.from(map);\nconsole.log(arrayFromMap); // [["name", "Alice"], ["age", 25]]\n\nconst spreadArray = [...map];\nconsole.log(spreadArray); // [["name", "Alice"], ["age", 25]]\n\n<o id="map結構topic-13">11. 將 Map 轉為 Object</o>\n如果需要將 Map 轉為 Object，可以使用以下方法：\nconst map = new Map([\n ["name", "Alice"],\n ["age", 25]\n]);\n\nconst obj = Object.fromEntries(map);\nconsole.log(obj); // { name: "Alice", age: 25 }\n\n<o id="map結構topic-14">12. 實際應用範例</o>\n假設我們需要統計一段文字中每個單詞出現的次數：\nconst text = "apple banana apple orange banana apple";\nconst words = text.split(" ");\n\nconst wordCountMap = new Map();\n\nfor (let word of words) {\n if (wordCountMap.has(word)) {\n  wordCountMap.set(word, wordCountMap.get(word) + 1);\n } else {\n  wordCountMap.set(word, 1);\n }\n}\n\nconsole.log(wordCountMap);\n// 輸出:\n// Map {\n//  "apple" => 3,\n//  "banana" => 2,\n//  "orange" => 1\n// }\n',
'<h2>javascript 數據結構种类</h2>	<center><div id="數據結構种类toc" class="toc"><a href="#數據結構种类topic-0" target="_self">1. 原始資料類型（Primitive Types）</a><br><a href="#數據結構种类topic-1" target="_self">2. 物件（Object）</a><br><a href="#數據結構种类topic-2" target="_self">3. 陣列（Array）</a><br><a href="#數據結構种类topic-3" target="_self">4. 集合（Set）</a><br><a href="#數據結構种类topic-4" target="_self">5. 映射（Map）</a><br><a href="#數據結構种类topic-5" target="_self">6. 弱集合（WeakSet）</a><br><a href="#數據結構种类topic-6" target="_self">7. 弱映射（WeakMap）</a><br><a href="#數據結構种类topic-7" target="_self">8. 類型化陣列（Typed Arrays）</a><br><a href="#數據結構种类topic-8" target="_self">9. 資料視圖（DataView）</a><br><a href="#數據結構种类topic-9" target="_self">10. 其他內建物件</a><br><a href="#數據結構种类topic-10" target="_self">11. 自定義資料結構</a><br><a href="#數據結構种类topic-11" target="_self">總結</a><br></div></center><br><br>\n\nJavaScript 提供了多種內建的資料結構，每種結構都有其特定的用途和優勢。以下是 JavaScript 中常見的資料結構：\n<o id="數據結構种类topic-0">1. 原始資料類型（Primitive Types）</o>\n這些是最基本的資料類型，不是物件，也沒有方法。\n- <y>Number</y>: 數字（整數或浮點數）。\n- <y>String</y>: 字串。\n- <y>Boolean</y>: 布林值（true 或 false）。\n- <y>undefined</y>: 未定義的值。\n- <y>null</y>: 空值。\n- <y>BigInt</y>: 用於表示大整數。\n- <y>Symbol</y>: 唯一且不可變的值，通常用於物件屬性的鍵。\n<o id="數據結構种类topic-1">2. 物件（Object）</o>\n物件是 JavaScript 中最基本的複合資料結構，用於儲存鍵值對（key-value pairs）。\n- <y>鍵（Key）</y>: 必須是字串或 Symbol。\n- <y>值（Value）</y>: 可以是任何類型，包括其他物件或函數。\n- <y>範例</y>:\nconst person = {\n name: "Alice",\n age: 25,\n greet: function() {\n  console.log("Hello!");\n }\n };\n<o id="數據結構种类topic-2">3. 陣列（Array）</o>\n陣列是一種有序的列表，可以儲存多個值，並通過索引存取。\n- <y>特性</y>:\n- 索引從 0 開始。\n- 可以動態調整大小。\n- 可以儲存不同類型的值。\n- <y>範例</y>:\nconst fruits = ["apple", "banana", "orange"];\nconsole.log(fruits[1]); // "banana"\n<o id="數據結構种类topic-3">4. 集合（Set）</o>\nSet 是一種儲存唯一值的集合，不允許重複的值。\n- <y>特性</y>:\n- 值可以是任意類型。\n- 沒有索引，無法通過索引存取。\n- <y>範例</y>:\nconst uniqueNumbers = new Set([1, 2, 3, 3, 4]);\nconsole.log(uniqueNumbers); // Set { 1, 2, 3, 4 }\n<o id="數據結構种类topic-4">5. 映射（Map）</o>\nMap 是一種鍵值對的集合，鍵可以是任意類型。\n- <y>特性</y>:\n- 鍵值對的順序嚴格按照插入順序排列。\n- 適合需要頻繁增刪鍵值對的場景。\n- <y>範例</y>:\nconst map = new Map();\n map.set("name", "Alice");\n map.set(1, "one");\n console.log(map.get("name")); // "Alice"\n<o id="數據結構种类topic-5">6. 弱集合（WeakSet）</o>\nWeakSet 是一種特殊的集合，只能儲存物件，並且不會阻止垃圾回收。\n- <y>特性</y>:\n- 無法迭代或取得大小。\n- 適合用於臨時儲存物件。\n- <y>範例</y>:\nconst weakSet = new WeakSet();\n const obj = {};\n weakSet.add(obj);\n console.log(weakSet.has(obj)); // true\n<o id="數據結構种类topic-6">7. 弱映射（WeakMap）</o>\nWeakMap 是一種特殊的映射，鍵只能是物件，並且不會阻止垃圾回收。\n- <y>特性</y>:\n- 無法迭代或取得大小。\n- 適合用於與物件相關的私有資料儲存。\n- <y>範例</y>:\nconst weakMap = new WeakMap();\n const obj = {};\n weakMap.set(obj, "private data");\n console.log(weakMap.get(obj)); // "private data"\n<o id="數據結構种类topic-7">8. 類型化陣列（Typed Arrays）</o>\n類型化陣列是一種用於處理二進制資料的陣列，例如音訊、影像等。\n- <y>常見類型</y>:\n- Int8Array, Uint8Array, Int16Array, Float32Array 等。\n- <y>範例</y>:\nconst buffer = new ArrayBuffer(16); // 建立一個 16 位元組的緩衝區\n const int32Array = new Int32Array(buffer); // 將緩衝區視為 32 位整數陣列\n<o id="數據結構种类topic-8">9. 資料視圖（DataView）</o>\nDataView 是一種用於讀寫類型化陣列的二進制資料的視圖。\n- <y>範例</y>:\nconst buffer = new ArrayBuffer(16);\n const view = new DataView(buffer);\n view.setInt32(0, 1234); // 在位置 0 寫入一個 32 位整數\n console.log(view.getInt32(0)); // 1234\n<o id="數據結構种类topic-9">10. 其他內建物件</o>\nJavaScript 還提供了許多內建物件，這些物件可以視為特殊的資料結構：\n- <y>Date</y>: 用於處理日期和時間。\n- <y>RegExp</y>: 用於處理正則表達式。\n- <y>Error</y>: 用於處理錯誤。\n- <y>Promise</y>: 用於處理非同步操作。\n- <y>Function</y>: 函數本身也是一種物件。\n<o id="數據結構种类topic-10">11. 自定義資料結構</o>\n除了內建的資料結構，JavaScript 也允許開發者根據需求實現自定義的資料結構，例如：\n- <y>堆疊（Stack）</y>\n- <y>佇列（Queue）</y>\n- <y>鏈結串列（Linked List）</y>\n- <y>樹（Tree）</y>\n- <y>圖（Graph）</y>\n- <y>雜湊表（Hash Table）</y>\n<o id="數據結構种类topic-11">總結</o>\nJavaScript 提供了豐富的內建資料結構，涵蓋了從簡單的原始類型到複雜的物件和集合。根據具體需求選擇合適的資料結構，可以讓程式碼更高效且易於維護。以下是常見的選擇建議：\n- 簡單的鍵值對：使用 <y>Object</y>。\n- 需要唯一值：使用 <y>Set</y>。\n- 需要鍵為任意類型：使用 <y>Map</y>。\n- 需要有序列表：使用 <y>Array</y>。\n- 需要處理二進制資料：使用 <y>類型化陣列</y> 或 <y>DataView</y>。\n',
'<h2>Convert Array Codes</h2>	function convertCodes(codes) {\n return codes.map(code => {\n  if (code.startsWith(\'6\')) {\n   return \'sh\' + code;\n  } else {\n   return \'sz\' + code;\n  }\n });\n}\n\n// Example usage:\nconst codes = [\'600001\', \'300002\', \'000003\', \'600004\'];\nconst convertedCodes = convertCodes(codes);\nconsole.log(convertedCodes); // Output: [\'sh600001\', \'sz300002\', \'sz000003\', \'sh600004\']',
'<h2>Common Object Methods Sample Application in JavaScript</h2>	class Person {\n constructor(name, age) {\n  this.name = name;\n  this.age = age;\n }\n\n // toString() equivalent\n toString() {\n  return `Person(name=${this.name}, age=${this.age})`;\n }\n\n // equals() equivalent\n equals(other) {\n  return other instanceof Person && this.name === other.name && this.age === other.age;\n }\n}\n\n// Create objects\nconst person1 = new Person("Alice", 30);\nconst person2 = new Person("Bob", 25);\nconst person3 = new Person("Alice", 30);\n\n// Demonstrate methods\nconsole.log(person1.toString());  // toString() equivalent\nconsole.log(person1.equals(person3));  // equals() equivalent\n<o>Key Takeaways</o>\n- These methods are fundamental to working with objects in most programming languages.\n- The exact implementation may vary depending on the language (e.g., `__str__` in Python vs. `toString()` in JavaScript).\n',
'<h2>common JavaScript object methods</h2>	<center><div id="commonJavaScriptobjecttoc" class="toc"><a href="#commonJavaScriptobjecttopic-0" target="_self" onclick="jumpto(0)">1. Object.keys()</a><br><a href="#commonJavaScriptobjecttopic-1" target="_self" onclick="jumpto(1)">2. Object.values()</a><br><a href="#commonJavaScriptobjecttopic-2" target="_self" onclick="jumpto(2)">3. Object.entries()</a><br><a href="#commonJavaScriptobjecttopic-3" target="_self" onclick="jumpto(3)">4. Object.assign()</a><br><a href="#commonJavaScriptobjecttopic-4" target="_self" onclick="jumpto(4)">5. Object.freeze()</a><br><a href="#commonJavaScriptobjecttopic-5" target="_self" onclick="jumpto(5)">6. Object.seal()</a><br><a href="#commonJavaScriptobjecttopic-6" target="_self" onclick="jumpto(6)">7. Object.hasOwnProperty()</a><br><a href="#commonJavaScriptobjecttopic-7" target="_self" onclick="jumpto(7)">8. Object.create()</a><br><a href="#commonJavaScriptobjecttopic-8" target="_self" onclick="jumpto(8)">9. Object.defineProperty()</a><br><a href="#commonJavaScriptobjecttopic-9" target="_self" onclick="jumpto(9)">10. Object.getPrototypeOf()</a><br><a href="#commonJavaScriptobjecttopic-10" target="_self" onclick="jumpto(10)">11. Object.setPrototypeOf()</a><br><a href="#commonJavaScriptobjecttopic-11" target="_self" onclick="jumpto(11)">12. Object.is()</a><br><a href="#commonJavaScriptobjecttopic-12" target="_self" onclick="jumpto(12)">Example Application: Managing a User Object</a><br><a href="#commonJavaScriptobjecttopic-13" target="_self" onclick="jumpto(13)">Key Takeaways</a><br></div></center><br><br>\n\n<o id="commonJavaScriptobjecttopic-0">1. Object.keys()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Returns an array of an object\'s own enumerable property names.\n const person = { name: "Alice", age: 30 };\n console.log(Object.keys(person)); // Output: ["name", "age"]\n<o id="commonJavaScriptobjecttopic-1">2. Object.values()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Returns an array of an object\'s own enumerable property values.\n const person = { name: "Alice", age: 30 };\n console.log(Object.values(person)); // Output: ["Alice", 30]\n<o id="commonJavaScriptobjecttopic-2">3. Object.entries()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Returns an array of an object\'s own enumerable property key-value pairs.\n const person = { name: "Alice", age: 30 };\n console.log(Object.entries(person)); // Output: [["name", "Alice"], ["age", 30]]\n<o id="commonJavaScriptobjecttopic-3">4. Object.assign()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Copies the values of all enumerable properties from one or more source objects to a target object.\n const target = { a: 1 };\n const source = { b: 2, c: 3 };\n const result = Object.assign(target, source);\n console.log(result); // Output: { a: 1, b: 2, c: 3 }\n<o id="commonJavaScriptobjecttopic-4">5. Object.freeze()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Freezes an object, preventing new properties from being added and existing properties from being modified or deleted.\n const person = { name: "Alice" };\n Object.freeze(person);\n person.name = "Bob"; // This will not change the value\n console.log(person); // Output: { name: "Alice" }\n<o id="commonJavaScriptobjecttopic-5">6. Object.seal()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Seals an object, preventing new properties from being added and marking all existing properties as non-configurable.\n const person = { name: "Alice" };\n Object.seal(person);\n person.age = 30; // This will not add the property\n console.log(person); // Output: { name: "Alice" }\n<o id="commonJavaScriptobjecttopic-6">7. Object.hasOwnProperty()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Checks if an object has a specific property as its own property (not inherited).\n const person = { name: "Alice" };\n console.log(person.hasOwnProperty("name")); // Output: true\n console.log(person.hasOwnProperty("age")); // Output: false\n<o id="commonJavaScriptobjecttopic-7">8. Object.create()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Creates a new object with the specified prototype object and properties.\n const personProto = { greet: function() { console.log("Hello!"); } };\n const person = Object.create(personProto);\n person.greet(); // Output: "Hello!"\n<o id="commonJavaScriptobjecttopic-8">9. Object.defineProperty()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n- Defines a new property directly on an object or modifies an existing property.\n const person = {};\n Object.defineProperty(person, "name", { value: "Alice", writable: false });\n console.log(person.name); // Output: "Alice"\n person.name = "Bob"; // This will not change the value\n console.log(person.name); // Output: "Alice"\n<o id="commonJavaScriptobjecttopic-9">10. Object.getPrototypeOf()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n - Returns the prototype of the specified object.\n  const person = { name: "Alice" };\n console.log(Object.getPrototypeOf(person)); // Output: {}\n <o id="commonJavaScriptobjecttopic-10">11. Object.setPrototypeOf()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n - Sets the prototype of an object.\n  const person = { name: "Alice" };\n const personProto = { greet: function() { console.log("Hello!"); } };\n Object.setPrototypeOf(person, personProto);\n person.greet(); // Output: "Hello!"\n <o id="commonJavaScriptobjecttopic-11">12. Object.is()</o> <a href="#top" target="_self"><b>⇧</b></a><br>\n - Compares two values for equality (similar to ===, but handles NaN and -0 correctly).\n  console.log(Object.is(NaN, NaN)); // Output: true\n console.log(Object.is(0, -0)); // Output: false\n<h3 id="commonJavaScriptobjecttopic-12">Example Application: Managing a User Object</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\nHere’s a practical example of using these methods to manage a user object:\nconst user = {\n name: "Alice",\n age: 30,\n email: "alice@example.com"\n};\n\n// Add a new property\nuser.country = "USA";\n\n// Check if a property exists\nconsole.log(user.hasOwnProperty("email")); // Output: true\n\n// Get all keys, values, and entries\nconsole.log(Object.keys(user)); // Output: ["name", "age", "email", "country"]\nconsole.log(Object.values(user)); // Output: ["Alice", 30, "alice@example.com", "USA"]\nconsole.log(Object.entries(user)); // Output: [["name", "Alice"], ["age", 30], ["email", "alice@example.com"], ["country", "USA"]]\n\n// Freeze the object\nObject.freeze(user);\nuser.age = 31; // This will not change the value\nconsole.log(user.age); // Output: 30\n\n// Create a new object with a prototype\nconst userProto = { isAdmin: false };\nconst newUser = Object.create(userProto, {\n name: { value: "Bob", writable: true },\n age: { value: 25, writable: true }\n});\nconsole.log(newUser.isAdmin); // Output: false\nconsole.log(newUser.name); // Output: "Bob"\n<h3 id="commonJavaScriptobjecttopic-13">Key Takeaways</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n- JavaScript provides a rich set of methods to handle and manipulate objects.\n- These methods are essential for tasks like iterating over properties, copying objects, and controlling object mutability.\n- Understanding these methods helps you write more efficient and maintainable code.\n\nLet me know if you\'d like further clarification or additional examples!\n',
'<h2>javascript 監聽滑動手勢</h2>	<center><div id="監聽滑動手勢toc" class="toc"><a href="#監聽滑動手勢topic-0" target="_self" onclick="jumpto(0)">touchstart、touchmove 和 touchend</a><br><a href="#監聽滑動手勢topic-1" target="_self" onclick="jumpto(1)">其他監聽方式</a><br><a href="#監聽滑動手勢topic-2" target="_self" onclick="jumpto(2)">使用 CSS 自定义属性结合 scroll 事件（针对页面滚动模拟滑动）：</a><br><a href="#監聽滑動手勢topic-3" target="_self" onclick="jumpto(3)">使用第三方库：</a><br></div></center><br><br>\n\n<h3 id="監聽滑動手勢topic-0">touchstart、touchmove 和 touchend</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n在 JavaScript 中监听滑动手势，一般可以通过 touchstart、touchmove 和 touchend 这几个触摸事件来实现，以下是一个简单的示例代码：\n &lt;script&gt;\n  let startX, startY;\n  document.addEventListener(\'touchstart\', function (e) {\n   const touch = e.changedTouches[0];\n   startX = touch.pageX;\n   startY = touch.pageY;\n  });\n\n  document.addEventListener(\'touchmove\', function (e) {\n   e.preventDefault(); // 防止页面默认滚动行为\n   const touch = e.changedTouches[0];\n   const moveX = touch.pageX;\n   const moveY = touch.pageY;\n   const diffX = moveX - startX;\n   const diffY = moveY - startY;\n  });\n\n  document.addEventListener(\'touchend\', function (e) {\n   const touch = e.changedTouches[0];\n   const endX = touch.pageX;\n   const endY = touch.pageY;\n   const diffX = endX - startX;\n   const diffY = endY - startY;\n\n   if (Math.abs(diffX) &gt; Math.abs(diffY)) {\n    if (diffX &gt; 0) {\n     console.log(\'向右滑动\');\n    } else {\n     console.log(\'向左滑动\');\n    }\n   }\n  });\n &lt;/script&gt;\n在上述代码中：\ntouchstart 事件记录下触摸开始时手指的坐标。\ntouchmove 事件中阻止了页面的默认滚动行为，并可以获取触摸移动时的坐标变化，但在这个示例中主要逻辑在 touchend 处理。\ntouchend 事件发生时，计算触摸结束和开始时的坐标差值，根据差值判断是向左滑动还是向右滑动（这里只简单处理了水平方向的滑动判断）。\n如果你是在桌面端模拟滑动手势监听，也可以使用鼠标的 mousedown、mousemove 和 mouseup 事件来类似实现。\n\n<h3 id="監聽滑動手勢topic-1">其他監聽方式</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n在桌面端使用鼠标事件模拟滑动：\n可以通过 mousedown、mousemove、mouseup 事件来模拟滑动操作，代码示例如下：\n &lt;script&gt;\n  let startX, startY;\n  let isDragging = false;\n\n  document.addEventListener(\'mousedown\', function (e) {\n   startX = e.pageX;\n   startY = e.pageY;\n   isDragging = true;\n  });\n\n  document.addEventListener(\'mousemove\', function (e) {\n   if (isDragging) {\n    const moveX = e.pageX;\n    const moveY = e.pageY;\n    const diffX = moveX - startX;\n    const diffY = moveY - startY;\n   }\n  });\n\n  document.addEventListener(\'mouseup\', function (e) {\n   isDragging = false;\n   const endX = e.pageX;\n   const endY = e.pageY;\n   const diffX = endX - startX;\n   const diffY = endY - startY;\n\n   if (Math.abs(diffX) &gt; Math.abs(diffY)) {\n    if (diffX &gt; 0) {\n     console.log(\'向右滑动（模拟）\');\n    } else {\n     console.log(\'向左滑动（模拟）\');\n    }\n   }\n  });\n &lt;/script&gt;\n<h3 id="監聽滑動手勢topic-2">使用 CSS 自定义属性结合 scroll 事件（针对页面滚动模拟滑动）：</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n如果要监听页面滚动来模拟滑动效果，可以利用 scroll 事件，并结合 CSS 自定义属性来记录滚动状态，示例如下：\n &lt;script&gt;\n  let prevScrollTop = 0;\n  document.addEventListener(\'scroll\', function () {\n   const currentScrollTop = window.pageYOffset;\n   const scrollDiff = currentScrollTop - prevScrollTop;\n   if (scrollDiff &gt; 0) {\n    console.log(\'向下滑动（通过滚动模拟）\');\n   } else if (scrollDiff &lt; 0) {\n    console.log(\'向上滑动（通过滚动模拟）\');\n   }\n   prevScrollTop = currentScrollTop;\n  });\n &lt;/script&gt;\n<h3 id="監聽滑動手勢topic-3">使用第三方库：</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"&gt;&lt;/script&gt;\n &lt;script&gt;\n  const hammertime = new Hammer(document.body);\n  hammertime.on(\'swipeleft swiperight\', function (ev) {\n   if (ev.type ===\'swipeleft\') {\n    console.log(\'向左滑动（Hammer.js）\');\n   } else {\n    console.log(\'向右滑动（Hammer.js）\');\n   }\n  });\n &lt;/script&gt;\n',
'<h2>Copying Image Address and Pasting into Editor</h2>	<center><div id="CopyingImagetoc" class="toc"><a href="#CopyingImagetopic-0" target="_self">Frontend Implementation (Client-side)</a><br><a href="#CopyingImagetopic-1" target="_self">Node.js Backend (if needed)</a><br><a href="#CopyingImagetopic-2" target="_self">Enhanced Frontend with Node.js Backend</a><br><a href="#CopyingImagetopic-3" target="_self">Alternative Approach for Clipboard Access Issues</a><br><a href="#CopyingImagetopic-4" target="_self">Important Notes</a><br></div></center><br><br>\n\nA combination of frontend JavaScript and potentially a Node.js backend.\n<y id="CopyingImagetopic-0">Frontend Implementation (Client-side)</y>\n&lt;div class="image-container"&gt;\n &lt;img src="example.jpg" alt="Example" class="clickable-image"&gt;\n&lt;/div&gt;\n&lt;div class="editor" contenteditable="true"&gt;&lt;/div&gt;\n&lt;script&gt;\ndocument.addEventListener(\'DOMContentLoaded\', () =&gt; {\n const images = document.querySelectorAll(\'.clickable-image\');\n const editor = document.querySelector(\'.editor\');\n \n images.forEach(img =&gt; {\n  img.addEventListener(\'click\', async (e) =&gt; {\n  const imageUrl = e.target.src;\n  \n  try {\n   // Copy to clipboard\n   await navigator.clipboard.writeText(imageUrl);\n   \n   // Focus on editor and paste\n   editor.focus();\n   document.execCommand(\'insertText\', false, imageUrl);\n   \n   // Alternatively for modern browsers:\n   // const selection = window.getSelection();\n   // const range = document.createRange();\n   // range.selectNodeContents(editor);\n   // range.collapse(false);\n   // selection.removeAllRanges();\n   // selection.addRange(range);\n   // document.execCommand(\'insertText\', false, imageUrl);\n   \n   console.log(\'Image URL copied and pasted to editor\');\n  } catch (err) {\n   console.error(\'Failed to copy: \', err);\n  }\n  });\n });\n});\n&lt;/script&gt;\n<y id="CopyingImagetopic-1">Node.js Backend (if needed)</y>\nIf you need to process the image URL on the server side first:\n// server.js\nconst express = require(\'express\');\nconst app = express();\nconst port = 3000;\napp.use(express.static(\'public\'));\napp.use(express.json());\napp.post(\'/process-image\', (req, res) =&gt; {\n const imageUrl = req.body.imageUrl;\n \n // Process the URL if needed (e.g., create a shortened URL, store in DB, etc.)\n const processedUrl = processImageUrl(imageUrl);\n \n res.json({ processedUrl });\n});\nfunction processImageUrl(url) {\n // Your processing logic here\n return url; // Return as-is for this example\n}\napp.listen(port, () =&gt; {\n console.log(`Server running at http://localhost:${port}`);\n});\n<y id="CopyingImagetopic-2">Enhanced Frontend with Node.js Backend</y>\n// Modified frontend to work with Node.js backend\ndocument.addEventListener(\'DOMContentLoaded\', () =&gt; {\n const images = document.querySelectorAll(\'.clickable-image\');\n const editor = document.querySelector(\'.editor\');\n \n images.forEach(img =&gt; {\n  img.addEventListener(\'click\', async (e) =&gt; {\n   const imageUrl = e.target.src;\n   \n   try {\n    // Optional: Send to Node.js backend for processing\n    const response = await fetch(\'/process-image\', {\n     method: \'POST\',\n     headers: {\n      \'Content-Type\': \'application/json\',\n     },\n     body: JSON.stringify({ imageUrl }),\n    });\n    \n    const { processedUrl } = await response.json();\n    \n    // Copy to clipboard\n    await navigator.clipboard.writeText(processedUrl);\n    \n    // Focus on editor and paste\n    editor.focus();\n    document.execCommand(\'insertText\', false, processedUrl);\n    \n    console.log(\'Image URL processed, copied and pasted to editor\');\n   } catch (err) {\n    console.error(\'Error:\', err);\n   }\n  });\n });\n});\n<y id="CopyingImagetopic-3">Alternative Approach for Clipboard Access Issues</y>\nIf you\'re having issues with clipboard permissions, you can create a hidden input element:\nfunction copyToClipboard(text) {\n const input = document.createElement(\'input\');\n input.value = text;\n document.body.appendChild(input);\n input.select();\n document.execCommand(\'copy\');\n document.body.removeChild(input);\n}\n<y id="CopyingImagetopic-4">Important Notes</y>\n1. <pk>Clipboard Permissions</pk>: Modern browsers require secure contexts (HTTPS) for clipboard access, or the page must be served from localhost.\n2. <pk>Content Security</pk>: Be cautious about directly pasting URLs into an editor if they come from untrusted sources.\n3. <pk>Error Handling</pk>: Always include error handling for clipboard operations as they can fail due to permissions or other issues.\n4. <pk>Node.js Role</pk>: The Node.js backend is only necessary if you need to process the image URL on the server. For simple copy-paste, pure frontend JavaScript is sufficient.\n',
'<h2>Capture console.log output to display on page</h2>	const output = document.getElementById(\'output\');\nconst originalLog = console.log;\nconsole.log = function(message) {\n originalLog.apply(console, arguments);\n output.innerHTML += JSON.stringify(message, null, 2) + \'<br><br>\';\n};',
'<h2>to parse json content</h2>	.then(text => {\n const jsonStr = text.replace(\'kline_dayqfq=\', \'\');\n stkdata = JSON.parse(jsonStr);\n // theCode is the variable to get url\n console.log(Object.keys(stkdata.data[`hk${theCode}`]))\n const qtValue = stkdata.data[`hk${theCode}`].qt[`hk${theCode}`][44]\n console.log(qtValue);\n',
'<h2>web scraping using JavaScript on the browser side</h2>	<center><div id="browsersidetoc" class="toc"><a href="#browsersidetopic-0" target="_self">Methods for Browser-Side Web Scraping</a><br><a href="#browsersidetopic-1" target="_self">Limitations of Browser-Side Scraping</a><br><a href="#browsersidetopic-2" target="_self">Better Alternatives for Heavy Scraping</a><br><a href="#browsersidetopic-3" target="_self">Conclusion</a><br></div></center><br><br>\n\nwith some limitations.\nHere’s how it works and what you need to consider:\n<o id="browsersidetopic-0">Methods for Browser-Side Web Scraping</o>\n1. <lg>Using `fetch()` + DOM Parsing (for Same-Origin or CORS-Enabled Sites)</lg>\n- Fetch HTML content and parse it using the DOM.\n- Example:\n  fetch(\'https://example.com\')\n   .then(response =&gt; response.text())\n   .then(html =&gt; {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, \'text/html\');\n    const titles = doc.querySelectorAll(\'h1\');\n    titles.forEach(title =&gt; console.log(title.textContent));\n   })\n   .catch(error =&gt; console.error(\'Error:\', error));\n- <lg>Limitation:</lg> Works only if the target site allows <lg>CORS</lg> (Cross-Origin Resource Sharing), which most external sites block.\n\n2. <lg>Using Browser Extensions (Chrome/Firefox)</lg>\n- Extensions can bypass CORS restrictions (with proper permissions).\n- Example (Chrome extension using `chrome.scripting` or `content scripts`).\n\n3. <lg>Injecting Scripts via DevTools (Manual Scraping)</lg>\n- Open DevTools (`F12`), go to the <lg>Console</lg>, and run JavaScript to extract data:\n  const data = Array.from(document.querySelectorAll(\'.post\')).map(el =&gt; ({\n   title: el.querySelector(\'h2\').innerText,\n   url: el.querySelector(\'a\').href\n  }));\n  console.log(data);\n- You can then copy the output manually.\n\n4. <lg>Bookmarklet (Mini JavaScript Snippet)</lg>\n- Save a JavaScript snippet as a bookmark to scrape the current page:\n  javascript:(function() {\n   const text = document.body.innerText;\n   prompt("Page Text:", text);\n  })();\n\n5. <lg>Proxy Server (to Avoid CORS)</lg>\n- If you control a backend, you can fetch data via your server (which bypasses CORS) and then retrieve it in the browser.\n<o id="browsersidetopic-1">Limitations of Browser-Side Scraping</o>\n- <lg>CORS Restrictions:</lg> Most websites block cross-origin requests.\n- <lg>Dynamic Content:</lg> Some sites load data via JavaScript (SPAs like React/Angular), requiring tools like <lg>Puppeteer</lg> (which runs in Node.js, not the browser).\n- <lg>Legal &amp; Ethical Issues:</lg> Many sites prohibit scraping in their <lg>Terms of Service</lg>.\n- <lg>Rate Limiting/IP Blocking:</lg> Excessive requests may get you blocked.\n<o id="browsersidetopic-2">Better Alternatives for Heavy Scraping</o>\n1. <lg>Backend Scraping (Node.js + Puppeteer/Cheerio)</lg>\n   const puppeteer = require(\'puppeteer\');\n   (async () =&gt; {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto(\'https://example.com\');\n  const data = await page.evaluate(() =&gt; document.body.innerText);\n  console.log(data);\n  await browser.close();\n   })();\n 2. <lg>API-Based Scraping Services</lg> (e.g., ScrapingBee, Apify)\n<o id="browsersidetopic-3">Conclusion</o>\n- <lg>For simple scraping on the same domain or CORS-allowed sites</lg>, browser-side JS works.\n- <lg>For external sites</lg>, use a backend (Node.js + Puppeteer) or a browser extension.\n- <lg>For large-scale scraping</lg>, consider a dedicated scraping tool/service.\n',
'<h2>DOMParser</h2>	fetch(\'https://www.xinouzhou.com/\')\n .then(response => response.text())\n .then(html => {\n  className = \'a\'\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(html, \'text/html\');\n  const titles = doc.querySelectorAll(className);\n  titles.forEach(title => console.log(title.textContent));\n })\n .catch(error => console.error(\'Error:\', error));\n',
'<h2>Running Node.js Script and Displaying Results on a Web Page</h2>	<center><div id="Node.jsScripttoc" class="toc"><a href="#Node.jsScripttopic-0" target="_self"><pk>Option 1: Using Express.js (Recommended for web applications)</pk></a><br><a href="#Node.jsScripttopic-1" target="_self">Install Express</a><br><a href="#Node.jsScripttopic-2" target="_self">Create a server file (server.js)</a><br><a href="#Node.jsScripttopic-3" target="_self">Run the server</a><br><a href="#Node.jsScripttopic-4" target="_self">Visit the page</a><br><a href="#Node.jsScripttopic-5" target="_self"><pk>Option 2: Using File System and Browser</pk></a><br><a href="#Node.jsScripttopic-6" target="_self">Create a script file (script.js)</a><br><a href="#Node.jsScripttopic-7" target="_self">Run the script</a><br><a href="#Node.jsScripttopic-8" target="_self">Open the HTML file</a><br><a href="#Node.jsScripttopic-9" target="_self"><pk>Option 3: Real-time Updates with WebSockets (Advanced)</pk></a><br><a href="#Node.jsScripttopic-10" target="_self">Install dependencies</a><br><a href="#Node.jsScripttopic-11" target="_self">Create server (server.js)</a><br><a href="#Node.jsScripttopic-12" target="_self">Create public/index.html</a><br><a href="#Node.jsScripttopic-13" target="_self">Run the server</a><br><a href="#Node.jsScripttopic-14" target="_self">Visit the page</a><br></div></center><br><br>\n\nHere\'s a step-by-step guide to running a Node.js script and displaying its results on a web page:\n<h3 id="Node.jsScripttopic-0"><pk>Option 1: Using Express.js (Recommended for web applications)</pk></h3>\n1.<o id="Node.jsScripttopic-1">Install Express</o> (if you haven\'t already):\nnpm install express\n\n2.<o id="Node.jsScripttopic-2">Create a server file (server.js)</o>:\nconst express = require(\'express\');\nconst app = express();\nconst port = 3000;\n\n// Your script logic\nfunction runScript() {\n // Replace this with your actual script\n const result = {\n  message: "Hello from Node.js!",\n  data: [1, 2, 3, 4, 5],\n  timestamp: new Date()\n };\n return result;\n}\n\n// Route to serve HTML page\napp.get(\'/\', (req, res) =&gt; {\n const scriptResults = runScript();\n \n // Send HTML with embedded results\n res.send(`\n  &lt;!DOCTYPE html&gt;\n  &lt;html&gt;\n  &lt;head&gt;\n   &lt;title&gt;Node.js Script Results&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n   &lt;h1&gt;Script Results&lt;/h1&gt;\n   &lt;pre&gt;${JSON.stringify(scriptResults, null, 2)}&lt;/pre&gt;\n  &lt;/body&gt;\n  &lt;/html&gt;\n `);\n});\n\napp.listen(port, () =&gt; {\n console.log(`Server runnin http://localhost:${port}`);\n});\n\n3.<o id="Node.jsScripttopic-3">Run the server</o>:\nnode server.js\n\n4.<o id="Node.jsScripttopic-4">Visit the page</o>:\nOpen your browser and go to `http://localhost:3000`\n<h3 id="Node.jsScripttopic-5"><pk>Option 2: Using File System and Browser</pk></h3>\nIf you just want to quickly output results to a page:\n\n1.<o id="Node.jsScripttopic-6">Create a script file (script.js)</o>:\nconst fs = require(\'fs\');\n\n// Your script logic\nconst results = {\n message: "Hello from Node.js!",\n data: [1, 2, 3, 4, 5],\n timestamp: new Date()\n};\n\n// Create HTML file with results\nconst html = `\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;Node.js Script Results&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;h1&gt;Script Results&lt;/h1&gt;\n &lt;pre&gt;${JSON.stringify(results, null, 2)}&lt;/pre&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n`;\n\nfs.writeFileSync(\'results.html\', html);\nconsole.l saved to results.html\');\n\n2.<o id="Node.jsScripttopic-7">Run the script</o>:\nnode script.js\n\n3.<o id="Node.jsScripttopic-8">Open the HTML file</o>:\nDouble-click the generated `results.html` file in your file explorer or open it in a browser.\n<h3 id="Node.jsScripttopic-9"><pk>Option 3: Real-time Updates with WebSockets (Advanced)</pk></h3>\nFor real-time updates, you can use Socket.io:\n\n1.<o id="Node.jsScripttopic-10">Install dependencies</o>:\nnpm install express socket.io\n\n2.<o id="Node.jsScripttopic-11">Create server (server.js)</o>:\nconst express = require(\'express\');\nconst socketio = require(\'socket.io\');\nconst app = express();\nconst port = 3000;\n\napp.use(express.static(\'public\'));\n\nconst server = app.listen(port, () =&gt; {\n console.log(`Server running at http://localhost:${port}`);\n});\n\nconst io = socketio(server);\n\nio.on(\'connection\', (socket) =&gt; {\n console.log(\'New client connected\');\n \n // Run your script and send results\n setInterval(() =&gt; {\n  const results = {\n   message: "Real-time data",\n   value: Math.random(),\n   timestamp: new Date()\n  };\n  socket.emit(\'update\', results);\n }, 1000);\n});\n\n3.<o id="Node.jsScripttopic-12">Create public/index.html</o>:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;Real-time Results&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;h1&gt;Real-time Script Results&lt;/h1&gt;\n &lt;pre id="results"&gt;&lt;/pre&gt;\n \n &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;\n &lt;script&gt;\n  const socket = io();\n  const resultsElement = document.getElementById(\'results\');\n  \n  socket.on(\'update\', (data) =&gt; {\n   resultsElement.textContent = JSON.stringify(data, null, 2);\n  });\n &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n4.<o id="Node.jsScripttopic-13">Run the server</o>:\nnode server.js\n\n5.<o id="Node.jsScripttopic-14">Visit the page</o>:\nOpen your browser and go to `http://localhost:3000`\n',
'<h2>Cloudflare Workers 和 Web Scraping</h2>	<center><div id="CloudflareWorkerstoc" class="toc"><a href="#CloudflareWorkerstopic-0" target="_self">可行性</a><br><a href="#CloudflareWorkerstopic-1" target="_self">优势</a><br><a href="#CloudflareWorkerstopic-2" target="_self">限制和挑战</a><br><a href="#CloudflareWorkerstopic-3" target="_self">示例代码</a><br><a href="#CloudflareWorkerstopic-4" target="_self">替代方案</a><br><a href="#CloudflareWorkerstopic-5" target="_self"><pk>on browser side to run web workers on Cloudflare Workers</pk></a><br><a href="#CloudflareWorkerstopic-6" target="_self">1. Browser Web Workers (Client-Side)</a><br><a href="#CloudflareWorkerstopic-7" target="_self">2. Cloudflare Workers (Server-Side)</a><br><a href="#CloudflareWorkerstopic-8" target="_self">3. Connecting Browser Web Workers to Cloudflare Workers</a><br><a href="#CloudflareWorkerstopic-9" target="_self">Key Benefits</a><br><a href="#CloudflareWorkerstopic-10" target="_self">Limitations</a><br><a href="#CloudflareWorkerstopic-11" target="_self"><pk>use worker pool to further reduce load</pk></a><br><a href="#CloudflareWorkerstopic-12" target="_self">Concept: Worker Pools for Distributed Processing</a><br><a href="#CloudflareWorkerstopic-13" target="_self">Implementation Approaches</a><br><a href="#CloudflareWorkerstopic-14" target="_self">Optimization Techniques</a><br><a href="#CloudflareWorkerstopic-15" target="_self">Performance Considerations</a><br><a href="#CloudflareWorkerstopic-16" target="_self">Best Practices</a><br></div></center><br><br>\n\nCloudflare Workers 可以用于网页抓取(web scraping)，但有一些重要的限制和注意事项需要考虑：\n<o id="CloudflareWorkerstopic-0">可行性</o>\n\n1. <y>技术上是可行的</y>：Workers 可以发送 HTTP 请求并处理响应，这是网页抓取的基础\n2. <y>基于 JavaScript</y>：使用 Fetch API 或第三方库如 cheerio 解析 HTML\n<o id="CloudflareWorkerstopic-1">优势</o>\n\n- <y>全球分布式</y>：在 Cloudflare 的边缘节点运行，靠近目标网站\n- <y>快速执行</y>：低延迟响应\n- <y>无需管理服务器</y>：无服务器架构\n<o id="CloudflareWorkerstopic-2">限制和挑战</o>\n\n1. <y>执行时间限制</y>：\n - 免费版：10ms CPU 时间/请求\n - 付费版：50ms CPU 时间/请求\n - 对于复杂页面解析可能不够\n\n2. <y>内存限制</y>：约 128MB 内存\n\n3. <y>反爬虫措施</y>：\n - 许多网站有 Cloudflare 防护，可能阻止 Workers IP\n - 缺乏成熟的代理支持\n\n4. <y>法律和合规性</y>：\n - 确保遵守目标网站的 robots.txt 和服务条款\n - Cloudflare 服务条款可能限制某些抓取行为\n<o id="CloudflareWorkerstopic-3">示例代码</o>\n\naddEventListener(\'fetch\', event =&gt; {\n event.respondWith(handleRequest(event.request))\n})\n\nasync function handleRequest(request) {\n const response = await fetch(\'https://example.com\');\n const html = await response.text();\n \n // 使用cheerio等库解析HTML\n // 提取所需数据\n \n return new Response(JSON.stringify(extractedData), {\n  headers: { \'content-type\': \'application/json\' }\n });\n}\n<o id="CloudflareWorkerstopic-4">替代方案</o>\n\n如果 Workers 的限制影响您的需求，可以考虑：\n- 使用 Cloudflare Workers 结合其他服务\n- 专用爬虫服务器\n- 无头浏览器服务如 Puppeteer 或 Playwright\n\n总之，Cloudflare Workers 适合轻量级、简单的网页抓取任务，但对于复杂或大规模的抓取可能不是最佳选择。\n\n<h3 id="CloudflareWorkerstopic-5"><pk>on browser side to run web workers on Cloudflare Workers</pk></h3>Running <y>Web Workers</y> (browser-side) in conjunction with <y>Cloudflare Workers</y> (server-side) is a bit different since they operate in different environments. However, you can use <y>Cloudflare Workers</y> to enhance your <y>browser-based Web Workers</y> by offloading heavy tasks to the edge. Here\'s how they can work together:\n\n<o id="CloudflareWorkerstopic-6">1. Browser Web Workers (Client-Side)</o>\nWeb Workers run in the browser and allow JavaScript to execute in the background without blocking the UI. \nExample of a simple <y>browser Web Worker</y>:\n<y>📌 main.js (Browser)</y>\n// Create a Web Worker\nconst worker = new Worker(\'worker.js\');\n\n// Send data to the worker\nworker.postMessage({ url: \'https://example.com/api/data\' });\n\n// Receive data from the worker\nworker.onmessage = (event) =&gt; {\n console.log(\'Data from worker:\', event.data);\n};\n<y>📌 worker.js (Browser)</y>\n// Listen for messages from the main thread\nself.onmessage = async (event) =&gt; {\n const { url } = event.data;\n \n // Fetch data (could be from a Cloudflare Worker)\n const response = await fetch(url);\n const data = await response.json();\n \n // Send back to the main thread\n self.postMessage(data);\n};\n\n<o id="CloudflareWorkerstopic-7">2. Cloudflare Workers (Server-Side)</o>\nCloudflare Workers act as a <y>serverless proxy</y> that can:\n- Handle API requests\n- Scrape websites (if allowed)\n- Process data before sending it back to the browser\n<y>📌 cloudflare-worker.js</y>\naddEventListener(\'fetch\', (event) =&gt; {\n event.respondWith(handleRequest(event.request));\n});\n\nasync function handleRequest(request) {\n // Fetch data from an external API or website\n const response = await fetch(\'https://api.example.com/data\');\n const data = await response.json();\n\n // Modify data if needed\n const processedData = { ...data, processed: true };\n\n // Return as JSON\n return new Response(JSON.stringify(processedData), {\n  headers: { \'Content-Type\': \'application/json\' },\n });\n}\n<y>Deploying the Cloudflare Worker</y>\n1. Go to [Cloudflare Workers](https://workers.cloudflare.com/)\n2. Create a new Worker and paste the code.\n3. Deploy it (e.g., at `https://my-worker.my-subdomain.workers.dev`).\n\n<o id="CloudflareWorkerstopic-8">3. Connecting Browser Web Workers to Cloudflare Workers</o>\nNow, modify the <y>browser Web Worker</y> (`worker.js`) to fetch data from <y>Cloudflare Workers</y> instead of directly calling APIs:\n<y>📌 Updated worker.js (Browser)</y>\nself.onmessage = async (event) =&gt; {\n const { url } = event.data;\n \n // Fetch from Cloudflare Worker instead of direct API\n const cfWorkerUrl = \'https://my-worker.my-subdomain.workers.dev\';\n const response = await fetch(cfWorkerUrl);\n const data = await response.json();\n \n self.postMessage(data);\n};\n\n<o id="CloudflareWorkerstopic-9">Key Benefits</o>\n <y>Offload heavy processing</y> (e.g., web scraping) to Cloudflare Workers \n <y>Reduce client-side JavaScript workload</y> \n <y>Improve performance</y> (Cloudflare Workers run on the edge) \n <y>Avoid CORS issues</y> (Cloudflare Workers can proxy requests) \n\n<o id="CloudflareWorkerstopic-10">Limitations</o>\n <y>Cloudflare Workers have CPU time limits</y> (free tier: 10ms, paid: 50ms) \n <y>Some websites block Cloudflare IPs</y> (use proxies if needed) \n <y>Browser Web Workers still run on the client</y> (but can delegate tasks to CF Workers) \n\n<y>Final Flow</y>\n1. <y>Browser</y> → Spawns a <y>Web Worker</y> \n2. <y>Web Worker</y> → Fetches data from <y>Cloudflare Worker</y> \n3. <y>Cloudflare Worker</y> → Does heavy lifting (API calls, scraping, etc.) \n4. <y>Cloudflare Worker</y> → Returns processed data to <y>Web Worker</y> \n5. <y>Web Worker</y> → Sends data back to the <y>main browser thread</y> \n\nThis setup keeps your browser responsive while leveraging Cloudflare’s edge network for fast, scalable processing. 🚀\n\n<h3 id="CloudflareWorkerstopic-11"><pk>use worker pool to further reduce load</pk></h3># Using Worker Pools to Reduce Load in Cloudflare Workers\n\nWorker pools can help distribute computational workloads more efficiently when using Cloudflare Workers. Here\'s how to implement this strategy to further reduce load and improve performance:\n<o id="CloudflareWorkerstopic-12">Concept: Worker Pools for Distributed Processing</o>\n\nInstead of handling all processing in a single Cloudflare Worker, you can:\n1. Create multiple specialized Workers (a "pool")\n2. Distribute tasks among them\n3. Aggregate results\n<o id="CloudflareWorkerstopic-13">Implementation Approaches</o>\n<y>1. Multiple Cloudflare Workers with Dedicated Roles</y>\n\n// main-worker.js (router)\naddEventListener(\'fetch\', event =&gt; {\n event.respondWith(handleRequest(event.request))\n})\n\nasync function handleRequest(request) {\n // Distribute tasks to specialized workers\n const [data1, data2] = await Promise.all([\n  fetch(\'https://worker-1.your-domain.workers.dev\'),\n  fetch(\'https://worker-2.your-domain.workers.dev\')\n ]);\n \n // Aggregate results\n return new Response(JSON.stringify({\n  result1: await data1.json(),\n  result2: await data2.json()\n }));\n}\n<y>2. Durable Objects for Stateful Workloads</y>\n\n// durable-object.js\nexport class TaskProcessor {\n async fetch(request) {\n  // Process task here\n  return new Response(JSON.stringify({result: "processed"}));\n }\n}\n\n// worker.js\nexport default {\n async fetch(request, env) {\n  const id = env.TASK_PROCESSOR.idFromName("task1");\n  const stub = env.TASK_PROCESSOR.get(id);\n  return stub.fetch(request);\n }\n}\n<y>3. Queue-Based Processing with Workers KV</y>\n\n// producer-worker.js\naddEventListener(\'fetch\', event =&gt; {\n event.respondWith(handleRequest(event.request))\n})\n\nasync function handleRequest(request) {\n // Add task to queue\n await env.TASK_QUEUE.put(`task_${Date.now()}`, taskData);\n return new Response("Task queued");\n}\n\n// consumer-worker.js (runs on cron trigger)\nexport default {\n async scheduled(event, env, ctx) {\n  // Process queued tasks\n  const tasks = await env.TASK_QUEUE.list();\n  // Distribute to worker pool\n }\n}\n<o id="CloudflareWorkerstopic-14">Optimization Techniques</o>\n\n1. <y>Request Batching</y>:\n   async function batchProcess(urls) {\n   const batchSize = 5;\n   const results = [];\n   \n   for (let i = 0; i &lt; urls.length; i += batchSize) {\n    const batch = urls.slice(i, i + batchSize);\n    results.push(...await Promise.all(batch.map(url =&gt; fetch(url))));\n   }\n   \n   return results;\n  }\n  \n2. <y>Work Stealing</y>:\n   // Worker checks for pending tasks in shared KV\n  async function getNextTask() {\n   const tasks = await env.PENDING_TASKS.list();\n   if (tasks.keys.length) {\n    const task = tasks.keys[0];\n    await env.PENDING_TASKS.delete(task.name);\n    return task;\n   }\n   return null;\n  }\n  \n3. <y>Result Caching</y>:\n   async function getWithCache(url) {\n   const cacheKey = `cache_${hash(url)}`;\n   const cached = await env.RESULT_CACHE.get(cacheKey);\n   if (cached) return cached;\n   \n   const fresh = await fetch(url);\n   await env.RESULT_CACHE.put(cacheKey, fresh, {expirationTtl: 3600});\n   return fresh;\n  }\n  <o id="CloudflareWorkerstopic-15">Performance Considerations</o>\n\n- <y>Worker-to-Worker Communication</y>: Each `fetch()` call between Workers adds latency\n- <y>Cold Starts</y>: Pooled Workers may experience cold starts\n- <y>KV Latency</y>: Workers KV has ~1ms read latency (eventual consistency)\n- <y>Cost</y>: More Workers = higher potential costs\n<o id="CloudflareWorkerstopic-16">Best Practices</o>\n\n1. Keep individual Worker execution under 50ms (paid plan limit)\n2. Use ETags for caching between Workers\n3. Implement exponential backoff for retries\n4. Monitor Worker CPU time usage\n5. Consider warming strategies for critical Workers\n\nThis approach allows you to horizontally scale processing across multiple Workers while staying within Cloudflare\'s execution limits.\n',
'<h2>web scraping using JavaScript on the browser side</h2>	<center><div id="browserscrapingtoc" class="toc"><a href="#browserscrapingtopic-0" target="_self">Methods for Browser-Side Web Scraping</a><br><a href="#browserscrapingtopic-1" target="_self"><gr>1. Using `fetch()` + DOM Parsing (for Same-Origin or CORS-Enabled Sites)</gr></a><br><a href="#browserscrapingtopic-2" target="_self"><gr>2. Using Browser Extensions (Chrome/Firefox)</gr></a><br><a href="#browserscrapingtopic-3" target="_self"><gr>3. Injecting Scripts via DevTools (Manual Scraping)</gr></a><br><a href="#browserscrapingtopic-4" target="_self"><gr>4. Bookmarklet (Mini JavaScript Snippet)</gr></a><br><a href="#browserscrapingtopic-5" target="_self"><gr>5. Proxy Server (to Avoid CORS)</gr></a><br><a href="#browserscrapingtopic-6" target="_self">Limitations of Browser-Side Scraping</a><br><a href="#browserscrapingtopic-7" target="_self">Better Alternatives for Heavy Scraping</a><br><a href="#browserscrapingtopic-8" target="_self"><gr>1. Backend Scraping (Node.js + Puppeteer/Cheerio)</gr></a><br><a href="#browserscrapingtopic-9" target="_self"><gr>2. API-Based Scraping Services</gr></a><br><a href="#browserscrapingtopic-10" target="_self">Conclusion</a><br></div></center><br><br>\n\nbut with some limitations. Here’s how it works and what you need to consider:\n<h3 id="browserscrapingtopic-0">Methods for Browser-Side Web Scraping</h3><o id="browserscrapingtopic-1"><gr>1. Using `fetch()` + DOM Parsing (for Same-Origin or CORS-Enabled Sites)</gr></o>\n- Fetch HTML content and parse it using the DOM.\n- Example:\n fetch(\'https://example.com\')\n  .then(response =&gt; response.text())\n  .then(html =&gt; {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, \'text/html\');\n    const titles = doc.querySelectorAll(\'h1\');\n    titles.forEach(title =&gt; console.log(title.textContent));\n  })\n  .catch(error =&gt; console.error(\'Error:\', error));\n- <y>Limitation:</y> Works only if the target site allows <y>CORS</y> (Cross-Origin Resource Sharing), which most external sites block.\n\n<o id="browserscrapingtopic-2"><gr>2. Using Browser Extensions (Chrome/Firefox)</gr></o>\n- Extensions can bypass CORS restrictions (with proper permissions).\n- Example (Chrome extension using `chrome.scripting` or `content scripts`).\n\n<o id="browserscrapingtopic-3"><gr>3. Injecting Scripts via DevTools (Manual Scraping)</gr></o>\n- Open DevTools (`F12`), go to the <y>Console</y>, and run JavaScript to extract data:\n const data = Array.from(document.querySelectorAll(\'.post\')).map(el =&gt; ({\n  title: el.querySelector(\'h2\').innerText,\n  url: el.querySelector(\'a\').href\n }));\n console.log(data);\n- You can then copy the output manually.\n\n<o id="browserscrapingtopic-4"><gr>4. Bookmarklet (Mini JavaScript Snippet)</gr></o>\n- Save a JavaScript snippet as a bookmark to scrape the current page:\n javascript:(function() {\n  const text = document.body.innerText;\n  prompt("Page Text:", text);\n })();\n\n<o id="browserscrapingtopic-5"><gr>5. Proxy Server (to Avoid CORS)</gr></o>\n- If you control a backend, you can fetch data via your server (which bypasses CORS) and then retrieve it in the browser.\n<h3 id="browserscrapingtopic-6">Limitations of Browser-Side Scraping</h3>- <y>CORS Restrictions:</y> Most websites block cross-origin requests.\n- <y>Dynamic Content:</y> Some sites load data via JavaScript (SPAs like React/Angular), requiring tools like <y>Puppeteer</y> (which runs in Node.js, not the browser).\n- <y>Legal &amp; Ethical Issues:</y> Many sites prohibit scraping in their <y>Terms of Service</y>.\n- <y>Rate Limiting/IP Blocking:</y> Excessive requests may get you blocked.\n<h3 id="browserscrapingtopic-7">Better Alternatives for Heavy Scraping</h3><o id="browserscrapingtopic-8"><gr>1. Backend Scraping (Node.js + Puppeteer/Cheerio)</gr></o>\n  const puppeteer = require(\'puppeteer\');\n  (async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n const data = await page.evaluate(() =&gt; document.body.innerText);\n console.log(data);\n await browser.close();\n  })();\n<o id="browserscrapingtopic-9"><gr>2. API-Based Scraping Services</gr></o> (e.g., ScrapingBee, Apifo)\n<h3 id="browserscrapingtopic-10">Conclusion</h3>- <y>For simple scraping on the same domain or CORS-allowed sites</y>, browser-side JS works.\n- <y>For external sites</y>, use a backend (Node.js + Puppeteer) or a browser extension.\n- <y>For large-scale scraping</y>, consider a dedicated scraping tool/service.\n',
'<h2>Spread Operator Samples</h2>	<center><div id="SpreadOperatortoc" class="toc"><a href="#SpreadOperatortopic-0" target="_self"><pk>Array Examples</pk></a><br><a href="#SpreadOperatortopic-1" target="_self">1.Combining arrays</a><br><a href="#SpreadOperatortopic-2" target="_self">2.Copying an array</a><br><a href="#SpreadOperatortopic-3" target="_self">3.Adding elements to an array</a><br><a href="#SpreadOperatortopic-4" target="_self">4.Converting string to array</a><br><a href="#SpreadOperatortopic-5" target="_self">5.Passing array elements as function arguments</a><br><a href="#SpreadOperatortopic-6" target="_self"><pk>Object Examples</pk></a><br><a href="#SpreadOperatortopic-7" target="_self">1.Combining objects</a><br><a href="#SpreadOperatortopic-8" target="_self">2.Copying an object (shallow copy)</a><br><a href="#SpreadOperatortopic-9" target="_self">3.Overriding properties</a><br><a href="#SpreadOperatortopic-10" target="_self">4.Adding new properties</a><br><a href="#SpreadOperatortopic-11" target="_self"><pk>Other Use Cases</pk></a><br><a href="#SpreadOperatortopic-12" target="_self">1.Rest parameters in functions</a><br><a href="#SpreadOperatortopic-13" target="_self">2.Converting NodeList to array</a><br><a href="#SpreadOperatortopic-14" target="_self">3.Math operations</a><br></div></center><br><br>\n\nThe spread operator (`...`) is a useful syntax in JavaScript for expanding iterables like arrays or objects.\nHere are some common use cases:\n<h3 id="SpreadOperatortopic-0"><pk>Array Examples</pk></h3><o id="SpreadOperatortopic-1">1.Combining arrays</o>\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5, 6]\n<o id="SpreadOperatortopic-2">2.Copying an array</o>\nconst original = [1, 2, 3];\nconst copy = [...original]; // [1, 2, 3]\n<o id="SpreadOperatortopic-3">3.Adding elements to an array</o>\nconst numbers = [1, 2, 3];\nconst moreNumbers = [0, ...numbers, 4]; // [0, 1, 2, 3, 4]\n<o id="SpreadOperatortopic-4">4.Converting string to array</o>\nconst str = "hello";\nconst chars = [...str]; // [\'h\', \'e\', \'l\', \'l\', \'o\']\n<o id="SpreadOperatortopic-5">5.Passing array elements as function arguments</o>\nfunction sum(a, b, c) {\n  return a + b + c;\n}\nconst nums = [1, 2, 3];\nconsole.log(sum(...nums)); // 6\n<h3 id="SpreadOperatortopic-6"><pk>Object Examples</pk></h3><o id="SpreadOperatortopic-7">1.Combining objects</o>\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { c: 3, d: 4 };\nconst combinedObj = { ...obj1, ...obj2 }; // { a: 1, b: 2, c: 3, d: 4 }\n<o id="SpreadOperatortopic-8">2.Copying an object (shallow copy)</o>\nconst originalObj = { x: 1, y: 2 };\nconst copyObj = { ...originalObj }; // { x: 1, y: 2 }\n<o id="SpreadOperatortopic-9">3.Overriding properties</o>\nconst defaults = { theme: \'light\', fontSize: 12 };\nconst userSettings = { fontSize: 14 };\nconst finalSettings = { ...defaults, ...userSettings }; // { theme: \'light\', fontSize: 14 }\n<o id="SpreadOperatortopic-10">4.Adding new properties</o>\nconst person = { name: \'John\', age: 30 };\nconst updatedPerson = { ...person, city: \'New York\' }; // { name: \'John\', age: 30, city: \'New York\' }\n<h3 id="SpreadOperatortopic-11"><pk>Other Use Cases</pk></h3><o id="SpreadOperatortopic-12">1.Rest parameters in functions</o>\nfunction logArguments(...args) {\n  console.log(args); // args is an array of all passed arguments\n}\nlogArguments(1, 2, 3); // [1, 2, 3]\n<o id="SpreadOperatortopic-13">2.Converting NodeList to array</o>\nconst nodeList = document.querySelectorAll(\'div\');\nconst nodeArray = [...nodeList];\n<o id="SpreadOperatortopic-14">3.Math operations</o>\nconst numbers = [5, 2, 9, 1];\nconsole.log(Math.max(...numbers)); // 9\n',
'<h2>Template Literals Examples</h2>	<center><div id="TemplateLiteralstoc" class="toc"><a href="#TemplateLiteralstopic-0" target="_self">Basic Syntax</a><br><a href="#TemplateLiteralstopic-1" target="_self">Multi-line Strings</a><br><a href="#TemplateLiteralstopic-2" target="_self">Expression Interpolation</a><br><a href="#TemplateLiteralstopic-3" target="_self">Function Calls in Templates</a><br><a href="#TemplateLiteralstopic-4" target="_self">Nested Templates</a><br><a href="#TemplateLiteralstopic-5" target="_self">Tagged Templates</a><br><a href="#TemplateLiteralstopic-6" target="_self">Raw Strings</a><br><a href="#TemplateLiteralstopic-7" target="_self">Object Property Access</a><br></div></center><br><br>\n\nTemplate literals (previously called "template strings") are string literals that allow embedded expressions and multi-line strings.\nHere are several examples:\n<o id="TemplateLiteralstopic-0">Basic Syntax</o>\nconst name = \'Alice\';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // "Hello, Alice!"\n<o id="TemplateLiteralstopic-1">Multi-line Strings</o>\nconst message = `\n  This is a\n  multi-line\n  string.\n`;\nconsole.log(message);\n<o id="TemplateLiteralstopic-2">Expression Interpolation</o>\nconst a = 5;\nconst b = 10;\nconsole.log(`The sum of ${a} and ${b} is ${a + b}.`);\n// "The sum of 5 and 10 is 15."\n<o id="TemplateLiteralstopic-3">Function Calls in Templates</o>\nfunction capitalize(str) {\n  return str[0].toUpperCase() + str.slice(1);\n}\n\nconst word = \'template\';\nconsole.log(`Capitalized: ${capitalize(word)}`);\n// "Capitalized: Template"\n<o id="TemplateLiteralstopic-4">Nested Templates</o>\nconst isLoggedIn = true;\nconst username = \'Bob\';\nconsole.log(`User: ${isLoggedIn ? username : \'Guest\'}`);\n// "User: Bob"\n<o id="TemplateLiteralstopic-5">Tagged Templates</o>\nfunction highlight(strings, ...values) {\n  let result = \'\';\n  strings.forEach((string, i) =&gt; {\n    result += string;\n    if (i &lt; values.length) {\n      result += `<mark>${values[i]}</mark>`;\n    }\n  });\n  return result;\n}\n\nconst price = 19.99;\nconst quantity = 3;\nconst total = highlight`The price is ${price} for ${quantity} items. Total: ${price * quantity}`;\nconsole.log(total);\n// "The price is <mark>19.99</mark> for <mark>3</mark> items. Total: <mark>59.97</mark>"\n<o id="TemplateLiteralstopic-6">Raw Strings</o>\nconst path = String.raw`C:\Development\profile\about.html`;\nconsole.log(path); // "C:\Development\profile\about.html"\n<o id="TemplateLiteralstopic-7">Object Property Access</o>\nconst user = { firstName: \'John\', lastName: \'Doe\' };\nconsole.log(`Welcome, ${user.firstName} ${user.lastName}!`);\n// "Welcome, John Doe!"\n',
'<h2>Running Node.js Script Continuously and Displaying Output in Chrome</h2>	<center><div id="RunningNode.jstoc" class="toc"><a href="#RunningNode.jstopic-0" target="_self">Option 1: Web Server with Auto-Refresh</a><br><a href="#RunningNode.jstopic-1" target="_self">Option 2: WebSocket for Real-Time Updates</a><br><a href="#RunningNode.jstopic-2" target="_self">Option 3: Server-Sent Events (SSE)</a><br><a href="#RunningNode.jstopic-3" target="_self">Keeping the Script Running</a><br></div></center><br><br>\n\nSeveral options:\n<h3 id="RunningNode.jstopic-0">Option 1: Web Server with Auto-Refresh</h3>1. <lg>Create a simple HTTP server</lg> in your Node.js script:\nconst http = require(\'http\');\nconst fs = require(\'fs\');\n\nlet status = "Initializing...";\n\n// Your continuous process\nsetInterval(() =&gt; {\n  status = `Last updated: ${new Date().toISOString()}`;\n  // Your actual status update logic here\n}, 1000);\n\n// Create server\nconst server = http.createServer((req, res) =&gt; {\n  if (req.url === \'/\') {\n    res.writeHead(200, {\'Content-Type\': \'text/html\'});\n    res.end(`\n      &lt;!DOCTYPE html&gt;\n      &lt;html&gt;\n      &lt;head&gt;\n        &lt;title&gt;Status Page&lt;/title&gt;\n        &lt;meta http-equiv="refresh" content="1"&gt;\n      &lt;/head&gt;\n      &lt;body&gt;\n        &lt;h1&gt;Current Status:&lt;/h1&gt;\n        &lt;pre&gt;${status}&lt;/pre&gt;\n      &lt;/body&gt;\n      &lt;/html&gt;\n    `);\n  }\n});\n\nserver.listen(3000, () =&gt; {\n  console.log(\'Server running at http://localhost:3000/\');\n});\n\n2. <lg>Run the script continuously</lg> using PM2 (recommended for production):\nnpm install -g pm2\npm2 start yourscript.js\npm2 save\npm2 startup\n\n3. <lg>Open Chrome</lg> and navigate to `http://localhost:3000`\n<h3 id="RunningNode.jstopic-1">Option 2: WebSocket for Real-Time Updates</h3>\nFor more real-time updates without page refresh:\n\n1. Install required packages:\nnpm install ws express\n\n2. Create a WebSocket server:\nconst express = require(\'express\');\nconst WebSocket = require(\'ws\');\nconst app = express();\nconst port = 3000;\n\n// Serve static HTML\napp.get(\'/\', (req, res) =&gt; {\n  res.send(`\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;Real-Time Status&lt;/title&gt;\n      &lt;style&gt;#status { white-space: pre; font-family: monospace; }&lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;h1&gt;Current Status:&lt;/h1&gt;\n      &lt;div id="status"&gt;&lt;/div&gt;\n      &lt;script&gt;\n        const ws = new WebSocket(\'ws://\' + window.location.host);\n        ws.onmessage = (event) =&gt; {\n          document.getElementById(\'status\').textContent = event.data;\n        };\n      &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n  `);\n});\n\nconst server = app.listen(port, () =&gt; {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n\n// WebSocket server\nconst wss = new WebSocket.Server({ server });\n\n// Your continuous process\nlet status = "Initializing...";\nsetInterval(() =&gt; {\n  status = `Last updated: ${new Date().toISOString()}\n`;\n  // Your actual status update logic here\n  \n  // Broadcast to all connected clients\n  wss.clients.forEach(client =&gt; {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(status);\n    }\n  });\n}, 1000);\n\n3. Run with PM2 as shown in Option 1.\n<h3 id="RunningNode.jstopic-2">Option 3: Server-Sent Events (SSE)</h3>\nAnother modern approach:\n\nconst express = require(\'express\');\nconst app = express();\nconst port = 3000;\n\napp.get(\'/\', (req, res) =&gt; {\n  res.send(`\n    &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n      &lt;title&gt;SSE Status&lt;/title&gt;\n      &lt;style&gt;#status { white-space: pre; font-family: monospace; }&lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n      &lt;h1&gt;Current Status:&lt;/h1&gt;\n      &lt;div id="status"&gt;&lt;/div&gt;\n      &lt;script&gt;\n        const eventSource = new EventSource(\'/updates\');\n        eventSource.onmessage = (event) =&gt; {\n          document.getElementById(\'status\').textContent = event.data;\n        };\n      &lt;/script&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n  `);\n});\n\napp.get(\'/updates\', (req, res) =&gt; {\n  res.setHeader(\'Content-Type\', \'text/event-stream\');\n  res.setHeader(\'Cache-Control\', \'no-cache\');\n  res.setHeader(\'Connection\', \'keep-alive\');\n  \n  // Send updates every second\n  const interval = setInterval(() =&gt; {\n    const status = `Last updated: ${new Date().toISOString()}\n`;\n    res.write(`data: ${status}\n\n`);\n  }, 1000);\n  \n  req.on(\'close\', () =&gt; {\n    clearInterval(interval);\n  });\n});\n\napp.listen(port, () =&gt; {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n<h3 id="RunningNode.jstopic-3">Keeping the Script Running</h3>\nFor production environments, consider:\n1. <lg>PM2</lg> (as shown above)\n2. <lg>Docker</lg> with proper restart policies\n3. <lg>Systemd</lg> service on Linux\n4. <lg>Forever</lg> (alternative to PM2): `npm install -g forever &amp;&amp; forever start yourscript.js`\n',
'<h2>Find the Minimum Value Across Two Arrays</h2>	<center><div id="FindtheMinimumtoc" class="toc"><a href="#FindtheMinimumtopic-0" target="_self">Method 1: Using `Math.min()` with Spread Operator (ES6)</a><br><a href="#FindtheMinimumtopic-1" target="_self">Method 2: Using `Array.concat()` (ES5 compatible)</a><br><a href="#FindtheMinimumtopic-2" target="_self">Method 3: Manual Comparison (Good for very large arrays)</a><br><a href="#FindtheMinimumtopic-3" target="_self">Method 4: Using `reduce()` (Functional approach)</a><br><a href="#FindtheMinimumtopic-4" target="_self">Important Notes:</a><br></div></center><br><br>\n\nTo find the minimum value when comparing two arrays (or more), you have several options in JavaScript. Here are the most efficient approaches:\n<h3 id="FindtheMinimumtopic-0">Method 1: Using `Math.min()` with Spread Operator (ES6)</h3>const array1 = [5, 8, 2, 10];\nconst array2 = [3, 6, 1, 9];\n\n// Combine arrays and find minimum\nconst combinedArray = [...array1, ...array2];\nconst minValue = Math.min(...combinedArray);\n\nconsole.log(minValue); // Output: 1\n<h3 id="FindtheMinimumtopic-1">Method 2: Using `Array.concat()` (ES5 compatible)</h3>const array1 = [5, 8, 2, 10];\nconst array2 = [3, 6, 1, 9];\n\nconst minValue = Math.min.apply(null, array1.concat(array2));\nconsole.log(minValue); // Output: 1\n<h3 id="FindtheMinimumtopic-2">Method 3: Manual Comparison (Good for very large arrays)</h3>function findMinAcrossArrays(...arrays) {\n let globalMin = Infinity;\n \n for (const arr of arrays) {\n  const currentMin = Math.min(...arr);\n  if (currentMin &lt; globalMin) {\n   globalMin = currentMin;\n  }\n }\n \n return globalMin;\n}\n\nconst minValue = findMinAcrossArrays(array1, array2);\nconsole.log(minValue); // Output: 1\n<h3 id="FindtheMinimumtopic-3">Method 4: Using `reduce()` (Functional approach)</h3>const minValue = [array1, array2]\n .flat()\n .reduce((min, num) =&gt; Math.min(min, num), Infinity);\n<h3 id="FindtheMinimumtopic-4">Important Notes:</h3>1. <lg>Empty arrays</lg>: These methods will return `Infinity` if all arrays are empty\n2. <lg>Performance</lg>: For very large arrays (&gt;100,000 elements), Method 3 is most memory-efficient\n3. <lg>Negative numbers</lg>: All methods work correctly with negative values\n4. <lg>Non-numbers</lg>: Will return `NaN` if arrays contain non-numeric values\n\nWould you like me to adapt any of these methods for a specific use case with your chart implementation?\n',
'<h2>Replace 5-Digit Numbers with HTML</h2>	function replaceBracketedFiveDigitNumbers(text) {\n // Regular expression to match 5 digits within parentheses\n const regex = /\((\d{5})\)/g;\n \n // Replacement with the desired HTML format\n return text.replace(regex, (match, digits) => \n  `<o onclick="xunbao(\'${digits}\')">${digits}</o>`\n );\n}\n\n// Example usage:\nconst originalText = "The codes are (12345) and (67890), but (1234) is too short.";\nconst replacedText = replaceBracketedFiveDigitNumbers(originalText);\nconsole.log(replacedText);',
'<h2>Cross-Page Communication</h2>	<center><div id="Cross-Pagetoc" class="toc"><a href="#Cross-Pagetopic-0" target="_self"><r>Using sessionStorage to Transfer Data Between Pages</r></a><br><a href="#Cross-Pagetopic-1" target="_self">Basic Usage</a><br><a href="#Cross-Pagetopic-2" target="_self">Transferring Data Between Pages</a><br><a href="#Cross-Pagetopic-3" target="_self"> Page 1 (Sender)</a><br><a href="#Cross-Pagetopic-4" target="_self"> Page 2 (Receiver)</a><br><a href="#Cross-Pagetopic-5" target="_self">Important Notes</a><br><a href="#Cross-Pagetopic-6" target="_self">Alternative Approach for Tab Communication</a><br><a href="#Cross-Pagetopic-7" target="_self"><r>BroadcastChannel API</r></a><br><a href="#Cross-Pagetopic-8" target="_self">Basic Usage:</a><br><a href="#Cross-Pagetopic-9" target="_self">Complete Example:</a><br><a href="#Cross-Pagetopic-10" target="_self"> Page 1 (Sender):</a><br><a href="#Cross-Pagetopic-11" target="_self"> Page 2 (Receiver):</a><br><a href="#Cross-Pagetopic-12" target="_self"><r>Window.postMessage()</r></a><br><a href="#Cross-Pagetopic-13" target="_self">Basic Syntax:</a><br><a href="#Cross-Pagetopic-14" target="_self">Complete Example:</a><br><a href="#Cross-Pagetopic-15" target="_self"> Parent Window:</a><br><a href="#Cross-Pagetopic-16" target="_self"> Child Window (iframe):</a><br><a href="#Cross-Pagetopic-17" target="_self"> Key Differences:</a><br></div></center><br><br>\n\n<pk>sessionStorage, BroadcastChannel API and postMessage()</pk>\n<h3 id="Cross-Pagetopic-0"><r>Using sessionStorage to Transfer Data Between Pages</r></h3><h4 id="Cross-Pagetopic-1">Basic Usage</h4>// Storing data in sessionStorage\nsessionStorage.setItem(\'key\', \'value\');\n\n// Retrieving data\nconst data = sessionStorage.getItem(\'key\');\n\n// Removing data\nsessionStorage.removeItem(\'key\');\n\n// Clearing all sessionStorage\nsessionStorage.clear();\n<h4 id="Cross-Pagetopic-2">Transferring Data Between Pages</h4><o id="Cross-Pagetopic-3"> Page 1 (Sender)</o>\n// Store data before navigating\nsessionStorage.setItem(\'userData\', JSON.stringify({\n  name: \'John Doe\',\n  id: 123,\n  preferences: { theme: \'dark\' }\n}));\n\n// Then navigate to another page\nwindow.location.href = \'page2.html\';\n\n<o id="Cross-Pagetopic-4"> Page 2 (Receiver)</o>\n// Retrieve data when the page loads\ndocument.addEventListener(\'DOMContentLoaded\', function() {\n  const userData = JSON.parse(sessionStorage.getItem(\'userData\'));\n  \n  if (userData) {\n    console.log(\'Received data:\', userData);\n    // Use the data in your page\n    document.getElementById(\'username\').textContent = userData.name;\n    \n    // Optionally clear the data after use\n    sessionStorage.removeItem(\'userData\');\n  }\n});\n<h4 id="Cross-Pagetopic-5">Important Notes</h4>1. <lg>Same-Origin Policy</lg>: sessionStorage is only accessible from pages with the same origin (protocol, domain, and port).\n2. <lg>Tab/Window Scope</lg>: Data is only available within the same browser tab/window where it was set. Opening a new tab/window creates a new session.\n3. <lg>Session Lifetime</lg>: Data persists until the tab/window is closed.\n4. <lg>Storage Limit</lg>: Typically around 5MB per origin.\n5. <lg>Data Types</lg>: Only strings can be stored. Use `JSON.stringify()` for objects and `JSON.parse()` to retrieve them.\n6. <lg>Security</lg>: Don\'t store sensitive information as it\'s accessible via JavaScript in the same tab.\n<h4 id="Cross-Pagetopic-6">Alternative Approach for Tab Communication</h4>If you need to communicate between tabs, consider:\n1. <lg>BroadcastChannel API</lg>\n2. <lg>LocalStorage with storage events</lg>\n3. <lg>Window.postMessage()</lg> for cross-origin communication\n\n<h3 id="Cross-Pagetopic-7"><r>BroadcastChannel API</r></h3>The BroadcastChannel API allows communication between different browsing contexts (windows, tabs, iframes) from the same origin.\n<h4 id="Cross-Pagetopic-8">Basic Usage:</h4>// Create or connect to a channel (all pages use the same channel name)\nconst channel = new BroadcastChannel(\'my_app_channel\');\n\n// Sending a message\nchannel.postMessage({\n  type: \'data_transfer\',\n  payload: { username: \'John\', score: 100 }\n});\n\n// Receiving messages\nchannel.onmessage = function(event) {\n  console.log(\'Received:\', event.data);\n  \n  if (event.data.type === \'data_transfer\') {\n    // Handle the received data\n    document.getElementById(\'result\').textContent = \n      `User: ${event.data.payload.username}, Score: ${event.data.payload.score}`;\n  }\n};\n\n// Close the channel when done\n// channel.close();\n\n<h4 id="Cross-Pagetopic-9">Complete Example:</h4><o id="Cross-Pagetopic-10"> Page 1 (Sender):</o>\ndocument.getElementById(\'send-btn\').addEventListener(\'click\', () =&gt; {\n  const data = {\n    type: \'user_update\',\n    payload: {\n      userId: \'123\',\n      action: \'profile_update\',\n      newName: document.getElementById(\'name-input\').value\n    }\n  };\n  \n  const channel = new BroadcastChannel(\'app_updates\');\n  channel.postMessage(data);\n  channel.close();\n});\n<o id="Cross-Pagetopic-11"> Page 2 (Receiver):</o>\n\nconst channel = new BroadcastChannel(\'app_updates\');\n\nchannel.onmessage = (event) =&gt; {\n  if (event.data.type === \'user_update\') {\n    console.log(\'Update received:\', event.data.payload);\n    // Update UI accordingly\n  }\n};\n\n// Remember to close when the page unloads\nwindow.addEventListener(\'beforeunload\', () =&gt; {\n  channel.close();\n});\n\n<h3 id="Cross-Pagetopic-12"><r>Window.postMessage()</r></h3>This method enables cross-origin communication between Window objects.\n<h4 id="Cross-Pagetopic-13">Basic Syntax:</h4>// In the sender window:\notherWindow.postMessage(message, targetOrigin, [transfer]);\n\n// In the receiver window:\nwindow.addEventListener(\'message\', (event) =&gt; {\n  // Verify origin for security!\n  if (event.origin !== \'https://trusted-site.com\') return;\n  \n  // Handle message\n});\n\n<h4 id="Cross-Pagetopic-14">Complete Example:</h4><o id="Cross-Pagetopic-15"> Parent Window:</o>\n&lt;iframe id="childFrame" src="https://child.example.com"&gt;⁢/iframe&gt;\n&lt;script&gt;\n  const iframe = document.getElementById(\'childFrame\');\n  \n  // Wait for iframe to load\n  iframe.onload = function() {\n    // Send message to iframe\n    iframe.contentWindow.postMessage({\n      type: \'config\',\n      theme: \'dark\',\n      language: \'en\'\n    }, \'https://child.example.com\');\n  };\n  \n  // Listen for responses\n  window.addEventListener(\'message\', (event) =&gt; {\n    // Always verify the origin!\n    if (event.origin !== \'https://child.example.com\') return;\n    \n    if (event.data.type === \'response\') {\n      console.log(\'Received response:\', event.data);\n    }\n  });\n&lt;/script&gt;\n<o id="Cross-Pagetopic-16"> Child Window (iframe):</o>\n// Listen for messages from parent\nwindow.addEventListener(\'message\', (event) =&gt; {\n  // Verify origin\n  if (event.origin !== \'https://parent.example.com\') return;\n  \n  if (event.data.type === \'config\') {\n    console.log(\'Received config:\', event.data);\n    // Apply configuration\n    \n    // Send response back\n    window.parent.postMessage({\n      type: \'response\',\n      status: \'config_applied\'\n    }, \'https://parent.example.com\');\n  }\n});\n<o id="Cross-Pagetopic-17"> Key Differences:</o>\nFeature : Scope \nBroadcastChannel.API : Same origin only \nwindow.postMessage.. : Cross-origin possible \n\nFeature : Target \nBroadcastChannel.API : All listening contexts \nwindow.postMessage.. : Specific window/frame \n\nFeature : Channel Management \nBroadcastChannel.API : Explicit channels \nwindow.postMessage.. : Direct window reference \n\nFeature : Security \nBroadcastChannel.API : Origin-restricted \nwindow.postMessage.. : Requires manual origin checks \n\nFeature : Use Case \nBroadcastChannel.API : Internal app communication \nwindow.postMessage.. : Cross-window/iframe messaging \n\nBroadcastChannel is simpler for same-origin tab communication, while postMessage() is essential for cross-origin scenarios like iframe communication.\n',
'<h2>Real-Time Data Communication Between Server and Client</h2>	<center><div id="DataCommunicationtoc" class="toc"><a href="#DataCommunicationtopic-0" target="_self">Server-side (Node.js)</a><br><a href="#DataCommunicationtopic-1" target="_self">Client-side (HTML/JavaScript for Chrome)</a><br><a href="#DataCommunicationtopic-2" target="_self">How to Run the Application</a><br><a href="#DataCommunicationtopic-3" target="_self">How It Works</a><br></div></center><br><br>\n\nHere\'s a complete implementation of a system where:\n1. Node.js server waits for user input\n2. Sends data to client (Chrome)\n3. Client receives data, stores it in an array\n4. Plots the data in a real-time chart\n5. Process continues until user stops it\n<h3 id="DataCommunicationtopic-0">Server-side (Node.js)</h3>// server.js\nconst express = require(\'express\');\nconst WebSocket = require(\'ws\');\nconst readline = require(\'readline\');\n\nconst app = express();\nconst port = 3000;\n\n// Create HTTP server\nconst server = app.listen(port, () =&gt; {\n console.log(`Server running at http://localhost:${port}`);\n});\n\n// Create WebSocket server\nconst wss = new WebSocket.Server({ server });\n\n// Serve static files\napp.use(express.static(\'public\'));\n\n// Set up command line interface\nconst rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout\n});\n\nconst clients = new Set();\n\nwss.on(\'connection\', (ws) =&gt; {\n clients.add(ws);\n console.log(\'New client connected\');\n\n ws.on(\'close\', () =&gt; {\n  clients.delete(ws);\n  console.log(\'Client disconnected\');\n });\n});\n\nfunction sendDataToClients(data) {\n clients.forEach(client =&gt; {\n  if (client.readyState === WebSocket.OPEN) {\n   client.send(JSON.stringify(data));\n  }\n });\n}\n\nfunction promptForData() {\n rl.question(\'Enter a number (or "stop" to end): \', (input) =&gt; {\n  if (input.toLowerCase() === \'stop\') {\n   console.log(\'Ending data collection\');\n   sendDataToClients({ command: \'stop\' });\n   rl.close();\n   process.exit(0);\n  } else {\n   const num = parseFloat(input);\n   if (!isNaN(num)) {\n    const timestamp = new Date().toISOString();\n    const dataPoint = { value: num, timestamp };\n    console.log(`Sending data: ${JSON.stringify(dataPoint)}`);\n    sendDataToClients(dataPoint);\n    promptForData(); // Continue prompting\n   } else {\n    console.log(\'Invalid input. Please enter a number.\');\n    promptForData();\n   }\n  }\n });\n}\n\n// Start the data collection process\nconsole.log(\'Waiting for clients to connect...\');\nwss.on(\'listening\', () =&gt; {\n    // Wait a bit for clients to connect before starting\n    setTimeout(promptForData, 1000);\n});\n<h3 id="DataCommunicationtopic-1">Client-side (HTML/JavaScript for Chrome)</h3>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;Real-Time Data Chart&lt;/title&gt;\n &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;\n &lt;style&gt;\n  body { font-family: Arial, sans-serif; margin: 20px; }\n  #chart-container { width: 80%; margin: 0 auto; }\n  #status { margin-top: 20px; padding: 10px; background: #f0f0f0; }\n &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;h1&gt;Real-Time Data Visualization&lt;/h1&gt;\n &lt;div id="chart-container"&gt;\n  &lt;canvas id="dataChart"&gt;&lt;/canvas&gt;\n &lt;/div&gt;\n &lt;div id="status"&gt;Waiting for data from server...&lt;/div&gt;\n\n &lt;script&gt;\n  // Initialize data array\n  const dataPoints = [];\n  \n  // Initialize Chart\n  const ctx = document.getElementById(\'dataChart\').getContext(\'2d\');\n  const chart = new Chart(ctx, {\n   type: \'line\',\n   data: {\n    labels: [],\n    datasets: [{\n     label: \'Real-Time Data\',\n     data: [],\n     borderColor: \'rgb(75, 192, 192)\',\n     tension: 0.1,\n     fill: false\n    }]\n   },\n   options: {\n    responsive: true,\n    scales: {\n     y: {\n      beginAtZero: false\n     }\n    }\n   }\n  });\n\n  // Connect to WebSocket server\n  const ws = new WebSocket(`ws://${window.location.hostname}:3000`);\n  \n  ws.onopen = () =&gt; {\n   document.getElementById(\'status\').textContent = \'Connected to server. Waiting for data...\';\n  };\n\n  ws.onmessage = (event) =&gt; {\n   const receivedData = JSON.parse(event.data);\n   \n   if (receivedData.command === \'stop\') {\n    document.getElementById(\'status\').textContent = \'Data collection stopped by server.\';\n    ws.close();\n    return;\n   }\n   \n   // Add new data point\n   dataPoints.push(receivedData);\n   document.getElementById(\'status\').textContent = `Received data: ${receivedData.value} at ${receivedData.timestamp}`;\n   \n   // Update chart\n   chart.data.labels.push(receivedData.timestamp);\n   chart.data.datasets[0].data.push(receivedData.value);\n   \n   // Keep only the last 20 points for better visibility\n   const maxPoints = 20;\n   if (chart.data.labels.length &gt; maxPoints) {\n    chart.data.labels.shift();\n    chart.data.datasets[0].data.shift();\n   }\n   \n   chart.update();\n  };\n  ws.onclose = () =&gt; {\n   document.getElementById(\'status\').textContent += \' Connection closed.\';\n  };\n\n  ws.onerror = (error) =&gt; {\n   document.getElementById(\'status\').textContent = \'WebSocket error: \' + error.message;\n  };\n &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<h3 id="DataCommunicationtopic-2">How to Run the Application</h3>1. First, install the required dependencies:\nnpm install express ws\n2. Create a project structure:\nyour-project-folder/\n├── server.js\n└── public/\n    └── index.html\n3. Start the server:\nnode server.js\n4. Open Chrome and navigate to `http://localhost:3000`\n5. In the terminal where the server is running, enter numbers when prompted. Each number will be sent to the client and plotted on the chart.\n6. Enter "stop" to end the process.\n<h3 id="DataCommunicationtopic-3">How It Works</h3>1. **Server-side**:\n- Creates both HTTP and WebSocket servers\n- Waits for user input in the terminal\n- Validates the input (must be a number)\n- Sends each valid number to all connected clients via WebSocket\n- Stops when user enters "stop"\n\n2. **Client-side**:\n- Connects to the WebSocket server\n- Maintains an array of received data points\n- Uses Chart.js to display the data in real-time\n- Updates the chart with each new data point\n- Shows connection status and received data\n\nThe system will continuously update the chart in the browser as new data is entered in the server terminal.\n',
'<h2>使用 Node.js 处理表格数据</h2>	const fs = require(\'fs\');\nconst readline = require(\'readline\');\nconst cheerio = require(\'cheerio\');\n\n// Create readline interface for user input\nconst rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout\n});\n\n// Prompt user for input file path\nrl.question(\'Enter HTML file path (default: input.html): \', (filePath) => {\n filePath = filePath.trim() || \'input.html\';\n\n // Prompt for minimum strike price\n rl.question(\'Enter minimum strike price (default: 0): \', (minStrikeStr) => {\n  const minStrike = parseFloat(minStrikeStr) || 0;\n  rl.close();\n\n  // Read and process file\n  fs.readFile(filePath, \'utf8\', (err, html) => {\n   if (err) {\n    console.error(`Error reading file: ${err.message}`);\n    return;\n   }\n\n   const $ = cheerio.load(html);\n   const tableData = [];\n\n   // Parse table rows WITH efgear (amplifier)\n   $(\'tr.table-row\').each((index, element) => {\n    const $row = $(element);\n    const $symElement = $row.find(\'td[data-field-key="sym"]\');\n\n    // Extract new field: efgear (amplifier)\n    const efgear = $row.find(\'td[data-field-key="efgear"]\').text().trim();\n\n    const stkName = $symElement.find(\'div[data-export-split="1"]\').text().trim();\n    const stkCode = $symElement.find(\'a.bmpLnk.cls\').text().replace(\'.HK\', \'\').trim();\n    const strikePrice = parseFloat($row.find(\'td[data-field-key="strike"]\').text().trim());\n    const ldate = $row.find(\'td[data-field-key="ldate"]\').text().trim();\n\n    // Filter step: Only include rows with strikePrice >= minStrike\n    if (strikePrice >= minStrike) {\n     tableData.push({ \n      stkCode, \n      stkName, \n      strikePrice, \n      ldate, \n      amplifier: efgear // Renamed to "amplifier"\n     });\n    }\n   });\n\n   // Sort by strikePrice\n   tableData.sort((a, b) => a.strikePrice - b.strikePrice);\n\n   // Generate HTML table body WITH amplifier column\n   const htmlTableBody = tableData.map(row => `\n    &lt;tr>\n     &lt;td>${row.stkCode}&lt;/td>\n     &lt;td>${row.stkName}&lt;/td>\n     &lt;td>${row.strikePrice.toFixed(3)}&lt;/td>\n     &lt;td>${row.ldate}&lt;/td>\n     &lt;td>${row.amplifier}&lt;/td> &lt;!-- New column -->\n    &lt;/tr>\n   `).join(\'\');\n\n   // Read warrantheader.html\n   fs.readFile(\'warrantheader.html\', \'utf8\', (err, headerHtml) => {\n    if (err) {\n     console.error(`Error reading header file: ${err.message}`);\n     return;\n    }\n\n    // Concatenate header and table body (WITH new column in header)\n    const combinedHtml = headerHtml + `\n     &lt;div class="filtered-count">Showing ${tableData.length} records with strike price ≥ ${minStrike}&lt;/div>\n     &lt;table>\n      &lt;tr>\n       &lt;th>Stock Code&lt;/th>\n       &lt;th>Stock Name&lt;/th>\n       &lt;th>Strike Price&lt;/th>\n       &lt;th>Expiry Date&lt;/th>\n       &lt;th>Amplifier&lt;/th> &lt;!-- New header -->\n      &lt;/tr>\n      ${htmlTableBody}\n     &lt;/table>\n    `;\n\n    // Save to output.html\n    fs.writeFile(\'output.html\', combinedHtml, \'utf8\', (err) => {\n     if (err) {\n      console.error(`Error writing file: ${err.message}`);\n     } else {\n      console.log(`Filtered results saved to output.html (${tableData.length} records)`);\n     }\n    });\n   });\n  });\n });\n});\n',
'<h2>一、Node.js 文件监控工具（监听文件变化并自动执行命令）</h2>	const fs = require(\'fs\');\nconst path = require(\'path\');\nconst { watch } = require(\'chokidar\');\n\nconst targetPath = path.resolve(__dirname, \'src\'); // 监控目录\nconst execCmd = \'npm run build\'; // 变化时执行的命令\n\nwatch(targetPath, { persistent: true }).on(\'all\', (event, filePath) => {\n console.log(`文件 ${filePath} 发生 ${event} 事件`);\n if (event === \'change\') {\n  require(\'child_process\').exec(execCmd, (err) => {\n   if (err) throw err;\n   console.log(\'执行完成:\', execCmd);\n  });\n }\n});\n\nconsole.log(\'监控启动，等待文件变化...\');\n \n \n',
'<h2>二、Node.js 简易 HTTP 服务器（带路由和静态资源处理）</h2>	const http = require(\'http\');\nconst fs = require(\'fs\');\nconst path = require(\'path\');\n\nconst server = http.createServer((req, res) => {\n // 路由处理\n if (req.url === \'/\') {\n  fs.readFile(path.join(__dirname, \'index.html\'), (err, data) => {\n   res.writeHead(200, { \'Content-Type\': \'text/html\' });\n   res.end(data);\n  });\n } else if (req.url.startsWith(\'/static/\')) { // 静态资源\n  const filePath = path.join(__dirname, req.url);\n  fs.createReadStream(filePath).pipe(res);\n } else {\n  res.writeHead(404);\n  res.end(\'Not Found\');\n }\n});\n\nserver.listen(3000, () => {\n console.log(\'服务器运行在 http://localhost:3000\');\n});\n \n \n',
'<h2>三、Node.js 实时聊天应用（WebSocket 实现）</h2>	const http = require(\'http\');\nconst WebSocket = require(\'ws\');\n\nconst server = http.createServer();\nconst wss = new WebSocket.Server({ server });\n\nwss.on(\'connection\', (ws) => {\n ws.on(\'message\', (data) => {\n  // 广播消息给所有客户端\n  wss.clients.forEach(client => {\n   if (client.readyState === WebSocket.OPEN) {\n    client.send(`用户说：${data.toString()}`);\n   }\n  });\n });\n});\n\nserver.listen(8080, () => {\n console.log(\'WebSocket 服务器启动，端口 8080\');\n});\n \n \n',
'<h2>四、Node.js 命令行工具（生成随机密码）</h2>	const crypto = require(\'crypto\');\nconst yargs = require(\'yargs\'); // 需先安装：npm install yargs\n\nconst argv = yargs.argv;\nconst length = argv.length || 16; // 默认长度 16\n\nfunction generatePassword(length) {\n return crypto.randomBytes(Math.ceil(length/2))\n  .toString(\'hex\') // 转十六进制\n  .slice(0, length); // 截取指定长度\n}\n\nconsole.log(\'生成的随机密码:\', generatePassword(length));\n \n \n',
'<h2>五、Node.js 定时任务（每天执行指定操作）</h2>	const schedule = require(\'node-schedule\'); // 需安装：npm install node-schedule\n\n// 每天 9 点执行任务\nconst job = schedule.scheduleJob(\'0 0 9 * * *\', () => {\n console.log(\'定时任务执行:\', new Date().toLocaleString());\n // 这里添加具体任务逻辑（如发送邮件、数据备份等）\n});\n\nconsole.log(\'定时任务已启动\');\n\n',
'<h2>1. API 接口开发</h2>	Node.js 凭借其单线程、非阻塞 I/O 的特性，非常适合构建高性能的网络应用。\n在实际开发过程中，你可以根据具体需求选择合适的框架和工具：\n- 开发 API 时，可选择 Express、NestJS 等框架。\n- 进行爬虫开发，有 Puppeteer、Playwright 等工具可供选择。\n- 开发 CLI 工具，Commander.js 和 Oclif 是不错的选择。\n- 实现实时应用，Socket.IO 和 WebSocket 是常用的技术。\n\nNode.js 开发 API 接口十分便捷，借助 Express 框架能快速达成。下面为你展示一个基础的 RESTful API 示例：\n\nconst express = require(\'express\');\nconst app = express();\nconst port = 3000;\n\n// 解析 JSON 请求体\napp.use(express.json());\n\n// 模拟数据\nconst users = [\n { id: 1, name: \'张三\' },\n { id: 2, name: \'李四\' }\n];\n\n// 获取所有用户\napp.get(\'/api/users\', (req, res) => {\n res.json(users);\n});\n\n// 获取单个用户\napp.get(\'/api/users/:id\', (req, res) => {\n const user = users.find(u => u.id === parseInt(req.params.id));\n if (!user) return res.status(404).send(\'未找到该用户\');\n res.json(user);\n});\n\n// 创建用户\napp.post(\'/api/users\', (req, res) => {\n const user = {\n  id: users.length + 1,\n  name: req.body.name\n };\n users.push(user);\n res.status(201).json(user);\n});\n\napp.listen(port, () => {\n console.log(`服务器运行在端口 ${port}`);\n});\n\n**关键技术要点**：\n- 可选用 Express、Koa、Fastify 等框架。\n- 利用中间件进行请求解析、身份验证等操作。\n- 采用 REST 架构风格，合理设置 HTTP 状态码。\n- 借助 Jest 或 Supertest 开展测试工作。\n',
'<h2>2. 爬虫开发</h2>	\n使用 Cheerio 和 Puppeteer 可以实现网页数据的爬取。下面是一个简单的示例：\n\nconst axios = require(\'axios\');\nconst cheerio = require(\'cheerio\');\n\nasync function crawlWebsite(url) {\n try {\n  // 发送 HTTP 请求\n  const response = await axios.get(url);\n  const html = response.data;\n  \n  // 加载 HTML 内容\n  const $ = cheerio.load(html);\n  \n  // 提取数据\n  const titles = [];\n  $(\'h2\').each((index, element) => {\n   titles.push($(element).text());\n  });\n  \n  return titles;\n } catch (error) {\n  console.error(\'爬取失败:\', error);\n  throw error;\n }\n}\n\ncrawlWebsite(\'https://example.com\')\n .then(titles => console.log(titles))\n .catch(err => console.error(err));\n\n**关键技术要点**：\n- 运用 axios 或 got 发起 HTTP 请求。\n- 借助 Cheerio 解析静态 HTML 内容。\n- 利用 Puppeteer 处理动态渲染的页面。\n- 遵守网站的 robots.txt 规则，合理控制爬取频率。\n',
'<h2>3. CLI 工具开发</h2>	\n开发 CLI 工具可以使用 Commander.js 或 Oclif 框架。下面是一个简单的示例：\n\n#!/usr/bin/env node\nconst { Command } = require(\'commander\');\nconst program = new Command();\n\nprogram\n .name(\'my-cli\')\n .description(\'简单的 CLI 工具\')\n .version(\'1.0.0\');\n\nprogram\n .command(\'greet <name>\')\n .description(\'打招呼\')\n .option(\'-u, --uppercase\', \'转为大写\')\n .action((name, options) => {\n  let message = `你好，${name}!`;\n  if (options.uppercase) {\n   message = message.toUpperCase();\n  }\n  console.log(message);\n });\n\nprogram.parse(process.argv);\n\n**关键技术要点**：\n- 利用 Commander 或 yargs 处理命令行参数。\n- 使用 Inquirer.js 实现交互式问答功能。\n- 借助 Chalk 美化终端输出效果。\n- 通过 npm link 进行本地测试。\n',
'<h2>4. 实时数据处理</h2>	\n使用 Socket.IO 或 WebSocket 可以实现实时数据处理。下面是一个简单的聊天应用示例：\n\nconst express = require(\'express\');\nconst http = require(\'http\');\nconst { Server } = require(\'socket.io\');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = new Server(server);\n\n// 静态文件服务\napp.use(express.static(\'public\'));\n\n// 监听连接事件\nio.on(\'connection\', (socket) => {\n console.log(\'有用户连接\');\n \n // 监听消息事件\n socket.on(\'chat message\', (msg) => {\n  // 广播消息给所有客户端\n  io.emit(\'chat message\', msg);\n });\n \n // 监听断开连接事件\n socket.on(\'disconnect\', () => {\n  console.log(\'用户断开连接\');\n });\n});\n\nserver.listen(3000, () => {\n console.log(\'服务器运行在端口 3000\');\n});\n\n**关键技术要点**：\n- 采用 Socket.IO 实现实时通信，它支持自动重连功能。\n- 利用 WebSocket 构建低延迟的双向通信。\n- 借助 Redis 实现分布式系统中的消息广播。\n- 考虑使用集群模式提升应用的扩展性。\n\n',
'<h2>Node.js 命令行调整字体</h2>	<center><div id="调整字体toc" class="toc"><a href="#调整字体topic-0" target="_self">1. 使用 ASCII 艺术字体（视觉上放大）</a><br><a href="#调整字体topic-1" target="_self">2. 通过 ANSI 转义序列（部分终端支持）</a><br><a href="#调整字体topic-2" target="_self">3. 提示用户手动调整终端字体</a><br><a href="#调整字体topic-3" target="_self">4. 使用图形界面替代纯终端</a><br></div></center><br><br>\n\n在 Node.js 命令行工具中，直接调整字体大小比较受限，因为终端字体大小通常由用户的终端设置（如 Windows Terminal、iTerm2 或终端模拟器的偏好设置）控制，而非应用程序本身。\n不过，你可以通过以下几种方式间接实现类似效果：\n<h3 id="调整字体topic-0">1. 使用 ASCII 艺术字体（视觉上放大）</h3>通过生成更大的字符艺术来替代普通文本，视觉上达到“放大”的效果。\n可以使用 `figlet` 或 `chalk-animation` 等库：\nnpm install figlet\n\nconst figlet = require(\'figlet\');\nconst chalk = require(\'chalk\');\n\nfiglet(\'HELLO WORLD!\', (err, data) =&gt; {\n if (err) {\n  console.log(\'出错了...\');\n  console.dir(err);\n  return;\n }\n console.log(chalk.yellow(data)); // 黄色大字体\n});\n\n<h3 id="调整字体topic-1">2. 通过 ANSI 转义序列（部分终端支持）</h3>某些终端支持使用特定的 ANSI 转义序列调整字体，但兼容性较差：\n// 注意：仅部分终端支持，且可能需要用户手动启用\nconst LARGE_FONT = \'\x1b[29t\'; // 增大字体（不一定有效）\nconst RESET = \'\x1b[0m\';\n\nconsole.log(`${LARGE_FONT}这可能是大号字体${RESET}`);\n\n<h3 id="调整字体topic-2">3. 提示用户手动调整终端字体</h3>最可靠的方式是通过文本提示用户调整终端设置：\nconst chalk = require(\'chalk\');\n\nconsole.log(chalk.yellow(\'提示：您可以按 Ctrl++ 或 Command++ 放大终端字体\'));\n\n<h3 id="调整字体topic-3">4. 使用图形界面替代纯终端</h3>如果需要精确控制字体大小，可以考虑创建 Electron 应用（本质是浏览器），它支持完整的 CSS 字体控制：\n// Electron 示例（需要单独安装 electron 包）\nconst { app, BrowserWindow } = require(\'electron\');\n\nfunction createWindow() {\n const win = new BrowserWindow({\n  width: 800,\n  height: 600,\n  webPreferences: {\n   nodeIntegration: true,\n   contextIsolation: false,\n  },\n });\n\n win.loadFile(\'index.html\'); // HTML 中可自由设置字体大小\n}\n\napp.whenReady().then(createWindow);\n- <lg>推荐方案</lg>：使用 `figlet` 生成艺术字体，或通过 `chalk` 增强颜色和样式（视觉上突出）。\n\n- <lg>终端兼容性</lg>：直接调整字体大小的 ANSI 序列兼容性差，不建议依赖。\n\n- <lg>终极方案</lg>：若必须精确控制字体，使用 Electron 构建桌面应用。\n\n以下是一个结合 `figlet` 和 `chalk` 的完整示例：\nconst figlet = require(\'figlet\');\nconst chalk = require(\'chalk\');\n\n// 生成大字体标题\nfiglet(\'CLI TOOL\', (err, data) =&gt; {\n if (err) return console.error(err);\n console.log(chalk.yellow(data));\n});\n\n// 提示用户输入\nconsole.log(chalk.cyan(\'\n请输入您的命令：\'));\n\n效果示例：\n _   _ _   _ _ _ _   _   _ \n| |  (_) |  | | (_) |  (_)  | |\n| |__ _| |__ | | |_| |__ _ ___| |\n| \'_ \| | \'_ \| | | | \'_ \| / __| |\n| | | | | |_) | | | | |_) | \__ \_|\n|_| |_|_|_.__/|_|_|_|_.__/|_|___(_)\n\n请输入您的命令：\n',
'<h2>Node.js命令行工具中设置颜色</h2>	在Node.js的Web应用中\n和HTML页面类似，通常也是通过CSS来设置`input`的文字颜色。\n如果是使用Express等框架构建的Web应用，在相应的HTML模板文件中，按照HTML页面中设置颜色的方法进行设置即可。\n例如，在模板文件中添加`&lt;input type="text" style="color: yellow;">`或者定义一个CSS类来设置颜色。\n\n如果是在命令行工具中使用`input`，使用库来实现颜色设置，比如在Node.js中可以使用`chalk`库来给命令行中的文本添加颜色。\n示例代码如下：\n\nconst chalk = require(\'chalk\');\nconst readline = require(\'readline\');\n\nconst rl = readline.createInterface({\n input: process.stdin,\n output: process.stdout\n});\n\nrl.question(chalk.yellow(\'请输入您的姓名：\'), (answer) => {\n console.log(`您输入的姓名是：${answer}`);\n rl.close();\n});',
'<h2>To run another Node.js script from a main Node.js script</h2>	and capture its output until the child script finishes, you can use the `child_process` module to spawn a new process.\nHere\'s an example of how you can achieve this:\n\n1. <lg>Main Node.js Script (`mainScript.js`)</lg>:\n const { spawn } = require(\'child_process\');\n // Run the child script\n const childProcess = spawn(\'node\', [\'childScript.js\']);\n\n // Listen for the \'data\' event to capture the output of the child script\n childProcess.stdout.on(\'data\', (data) => {\n   console.log(data.toString());\n });\n\n // Listen for the \'close\' event to know when the child process has finished\n childProcess.on(\'close\', (code) => {\n   console.log(`Child process finished with code ${code}`);\n   // Code to execute after the child process has completed\n });\n\n2. <lg>Child Node.js Script (`childScript.js`)</lg>:\n This is the script that you want to run and capture the output from.\n\n // Code in childScript.js\n console.log(\'Child script is running...\');\n // Any other code you want to execute in the child script\n\n3. <lg>How It Works</lg>:\n - The main script uses `child_process.spawn()` to run the child script (`childScript.js`) as a separate Node.js process.\n - The output of the child script is captured by listening to the `data` event on the `stdout` stream of the child process.\n - The `close` event is used to know when the child process has finished running.\n\nWhen you run the main script (`mainScript.js`) using `node mainScript.js`, it will execute the child script (`childScript.js`) and display the output of the child script until it finishes.\nThe main script will continue running after the child process has completed.\nIf the child script running as a separate process requires user input, you can still interact with it from the main Node.js script using `child.stdin.write()` to provide input to the child script.\nHere\'s an example illustrating how you can achieve this:\n\n1. <lg>Main Node.js Script (`mainScript.js`)</lg>:\n const { spawn } = require(\'child_process\');\n \n // Run the child script\n const childProcess = spawn(\'node\', [\'childScript.js\'], { stdio: [\'pipe\', \'pipe\', \'pipe\'] });\n\n // Listen for data from the child script\n childProcess.stdout.on(\'data\', (data) => {\n   console.log(data.toString());\n });\n\n // Provide input to the child script\n childProcess.stdin.write(\'User input from main script\n\');\n\n // Handle user input to provide to the child script\n process.stdin.on(\'data\', (data) => {\n   childProcess.stdin.write(data);\n });\n\n // Listen for the \'close\' event\n childProcess.on(\'close\', (code) => {\n   console.log(`Child process finished with code ${code}`);\n });\n\n2. <lg>Child Node.js Script (`childScript.js`)</lg>:\n\n This is the script that requires user input.\n process.stdin.on(\'data\', (data) => {\n   console.log(`Received input in child script: ${data.toString()}`);\n });\n\n console.log(\'Child script is running...\');\n\n3. <lg>How It Works</lg>:\n - The main script spawns the child script as a separate process with communication pipes enabled for `stdin`, `stdout`, and `stderr`.\n - User input can be provided to the child script from the main script using `childProcess.stdin.write()`.\n - The child script listens for user input using `process.stdin.on(\'data\', ...)`.\n - When the child script requests input, the main script can provide it through `childProcess.stdin.write()`.\n\nWhen you run the main script (`mainScript.js`), it will communicate with the child script (`childScript.js`) and allow for interaction by providing input from the main script to the child script.\n\nIt is possible to run multiple child scripts from a main Node.js script and interact with each child script independently by managing their input and output streams individually.\nHere\'s an example demonstrating how you can run multiple child scripts and interact with each of them:\n\n1. <lg>Main Node.js Script (`mainScript.js`)</lg>:\n const { spawn } = require(\'child_process\');\n\n // Function to start a child process\n function startChildScript(scriptName) {\n   const childProcess = spawn(\'node\', [scriptName], { stdio: [\'pipe\', \'pipe\', \'pipe\'] });\n\n   // Listen for data from the child script\n   childProcess.stdout.on(\'data\', (data) => {\n     console.log(`${scriptName}: ${data.toString()}`);\n   });\n\n   // Provide input to the child script\n   childProcess.stdin.write(\'User input from main script\n\');\n\n   // Handle user input to provide to the child script\n   process.stdin.on(\'data\', (data) => {\n     childProcess.stdin.write(data);\n   });\n\n   // Listen for the \'close\' event\n   childProcess.on(\'close\', (code) => {\n     console.log(`${scriptName}: Child process finished with code ${code}`);\n   });\n }\n\n // Start multiple child scripts\n startChildScript(\'childScript1.js\');\n startChildScript(\'childScript2.js\');\n\n2. <lg>Child Node.js Scripts (`childScript1.js`, `childScript2.js`, etc.)</lg>:\n\n These are the scripts that you want to run as child processes. You can have multiple child scripts.\n\n3. <lg>How It Works</lg>:\n - The `startChildScript()` function is used to spawn a child process for each child script.\n - Each child process has its own input and output streams, allowing interaction with each child script independently.\n - User input can be provided to each child script from the main script.\n - The child scripts can communicate with the main script through their standard input and output streams.\n\nWhen you run the main script (`mainScript.js`), it will start multiple child scripts and manage interactions with each of them independently, providing input and handling output for each child script separately.',
'<h2>const wss = new WebSocket.Server({ server })</h2>	<center><div id="toc" class="WebSocket.Servertoc"><a href="#WebSocket.Servertopic-0" target="_self">核心功能</a><br><a href="#WebSocket.Servertopic-1" target="_self">代码构成解析</a><br><a href="#WebSocket.Servertopic-2" target="_self">为何要传入HTTP服务器？</a><br><a href="#WebSocket.Servertopic-3" target="_self">示例说明</a><br><a href="#WebSocket.Servertopic-4" target="_self">工作机制总结</a><br></div></center><br><br>\n\n这段代码的作用是创建一个WebSocket服务器实例`wss`，该实例是基于已有的HTTP服务器`server`建立的。\n下面来详细剖析：\n<h3 id="WebSocket.Servertopic-0">核心功能</h3>借助WebSocket协议，服务器和客户端之间能够实现实时通信，而此代码就是创建这样的WebSocket服务器。\n和传统的HTTP请求-响应模式不同，WebSocket建立连接后，双方可以随时主动向对方发送数据。\n\n<h3 id="WebSocket.Servertopic-1">代码构成解析</h3>const wss = new WebSocket.Server({ server });\n1. <lg>WebSocket.Server</lg>：它是Node.js里`ws`库提供的一个类，专门用于创建WebSocket服务器。\n2. <lg>{ server }</lg>：这是传递给构造函数的配置对象，其中的`server`是一个已存在的HTTP服务器实例。\n\n<h3 id="WebSocket.Servertopic-2">为何要传入HTTP服务器？</h3>把已有的HTTP服务器`server`传递给WebSocket服务器，主要有以下两方面原因：\n- <lg>端口复用</lg>：WebSocket服务器可以和HTTP服务器共用同一个端口。\n比如，HTTP服务器使用的是80端口，那么WebSocket服务器也能通过这个端口进行通信。\n- <lg>路径区分</lg>：可以对不同的路径进行配置，让某些路径由HTTP服务器处理，而另外一些路径由WebSocket服务器处理。\n\n<h3 id="WebSocket.Servertopic-3">示例说明</h3>下面是一个完整的示例，展示了如何创建HTTP服务器并在其基础上创建WebSocket服务器：\nconst http = require(\'http\');\nconst WebSocket = require(\'ws\');\n// 先创建一个HTTP服务器\nconst server = http.createServer((req, res) =&gt; {\n res.writeHead(200, { \'Content-Type\': \'text/plain\' });\n res.end(\'这是一个普通的HTTP服务器\n\');\n});\n// 再基于这个HTTP服务器创建WebSocket服务器\nconst wss = new WebSocket.Server({ server });\n// 处理WebSocket连接事件\nwss.on(\'connection\', (ws) =&gt; {\n console.log(\'有新的客户端连接上了WebSocket服务器\');\n \n // 接收客户端发送的消息\n ws.on(\'message\', (message) =&gt; {\n  console.log(\'收到消息:\', message);\n  // 向客户端发送消息\n  ws.send(\'服务器已收到你的消息: \' + message);\n });\n \n // 处理连接关闭事件\n ws.on(\'close\', () =&gt; {\n  console.log(\'客户端断开了WebSocket连接\');\n });\n});\n// 启动服务器，监听3000端口\nserver.listen(3000, () =&gt; {\n console.log(\'服务器正在监听3000端口\');\n});\n<h3 id="WebSocket.Servertopic-4">工作机制总结</h3>- 客户端可以通过`ws://localhost:3000`连接到WebSocket服务器。\n- 当有新的WebSocket连接建立时，会触发`connection`事件。\n- 通过`ws.send()`方法，服务器可以向客户端发送消息；客户端发送的消息则通过`message`事件来接收。\n\n通过这种方式，你可以在同一个端口上同时提供HTTP服务和WebSocket实时通信服务。\n',
'<h2>difference between http and express in nodejs</h2>	<center><div id="httpNexpresstoc" class="toc"><a href="#httpNexpresstopic-0" target="_self">核心差异</a><br><a href="#httpNexpresstopic-1" target="_self">示例对比</a><br><a href="#httpNexpresstopic-2" target="_self">主要区别详解</a><br><a href="#httpNexpresstopic-3" target="_self">适用场景</a><br><a href="#httpNexpresstopic-4" target="_self">总结</a><br></div></center><br><br>\n在Node.js里，HTTP和Express都是用于构建Web服务器的工具，但它们处于不同的抽象层次，在功能和使用方式上有明显差异。下面为你详细介绍：\n<h3 id="httpNexpresstopic-0">核心差异</h3>对比项 : 抽象层次 \nHTTP.Node.js原生模块. : 底层API，需手动处理大量细节 \nExpress.第三方框架. : 高层抽象，封装了常见功能，简化开发 \n\n对比项 : 路由系统 \nHTTP.Node.js原生模块. : 需手动解析URL和HTTP方法 \nExpress.第三方框架. : 内置强大的路由系统，支持参数和中间件 \n\n对比项 : 中间件支持 \nHTTP.Node.js原生模块. : 无原生支持，需自行实现 \nExpress.第三方框架. : 核心特性，支持请求预处理、错误处理等 \n\n对比项 : 模板引擎 \nHTTP.Node.js原生模块. : 需手动集成 \nExpress.第三方框架. : 内置支持，方便渲染动态HTML \n\n对比项 : 静态文件服务 \nHTTP.Node.js原生模块. : 需手动处理 \nExpress.第三方框架. : 内置`express.static`中间件 \n\n对比项 : 社区生态 \nHTTP.Node.js原生模块. : 基础组件，需依赖第三方库 \nExpress.第三方框架. : 生态丰富，有大量插件和集成方案 \n\n对比项 : 学习曲线 \nHTTP.Node.js原生模块. : 陡峭，适合深入理解HTTP原理 \nExpress.第三方框架. : 平缓，适合快速开发 \n<h3 id="httpNexpresstopic-1">示例对比</h3><o>使用HTTP模块</o>\nconst http = require(\'http\');\nconst server = http.createServer((req, res) =&gt; {\n // 手动解析URL和方法\n if (req.url === \'/\' &amp;&amp; req.method === \'GET\') {\n  res.writeHead(200, { \'Content-Type\': \'text/plain\' });\n  res.end(\'Hello World\n\');\n } else if (req.url === \'/api/data\' &amp;&amp; req.method === \'GET\') {\n  res.writeHead(200, { \'Content-Type\': \'application/json\' });\n  res.end(JSON.stringify({ message: \'Data from API\' }));\n } else {\n  res.writeHead(404, { \'Content-Type\': \'text/plain\' });\n  res.end(\'Not Found\n\');\n }\n});\n\nserver.listen(3000, () =&gt; {\n console.log(\'Server running on port 3000\');\n});\n\n<o>使用Express框架</o>\nconst express = require(\'express\');\nconst app = express();\n\n// 处理GET请求\napp.get(\'/\', (req, res) =&gt; {\n res.send(\'Hello World!\');\n});\n\n// 处理API请求\napp.get(\'/api/data\', (req, res) =&gt; {\n res.json({ message: \'Data from API\' });\n});\n\n// 处理404错误\napp.use((req, res) =&gt; {\n res.status(404).send(\'Not Found\');\n});\n\napp.listen(3000, () =&gt; {\n console.log(\'Server running on port 3000\');\n});\n<h3 id="httpNexpresstopic-2">主要区别详解</h3>1. <lg>路由系统</lg>\n- <lg>HTTP</lg>：要手动解析`req.url`和`req.method`，来判断请求的路径和方法。\n- <lg>Express</lg>：提供了`app.METHOD(path, handler)`这样的便捷方法，还支持路由参数，例如`/users/:id`。\n\n2. <lg>中间件机制</lg>\n- <lg>HTTP</lg>：没有原生的中间件概念，所有请求处理逻辑都得在回调函数里手动实现。\n- <lg>Express</lg>：中间件是其核心特性，能够对请求进行预处理，比如解析请求体、验证身份、记录日志等。\n // 中间件示例：记录请求时间\n  app.use((req, res, next) =&gt; {\n console.log(`Request received at: ${new Date()}`);\n next(); // 把控制权交给下一个中间件\n  });\n  \n3. <lg>请求体解析</lg>\n- <lg>HTTP</lg>：要手动处理数据流，解析JSON或表单数据。\n- <lg>Express</lg>：通过`express.json()`和`express.urlencoded()`中间件，能自动解析请求体。\n\n4. <lg>错误处理</lg>\n- <lg>HTTP</lg>：需要在每个请求处理逻辑中手动处理错误。\n- <lg>Express</lg>：有专门的错误处理中间件，简化了全局错误处理。\n app.use((err, req, res, next) =&gt; {\n console.error(err);\n res.status(500).send(\'Internal Server Error\');\n  });\n  \n5. <lg>静态文件服务</lg>\n- <lg>HTTP</lg>：要手动读取文件并设置响应头。\n- <lg>Express</lg>：使用`express.static`中间件就能轻松实现。\n app.use(express.static(\'public\')); // 直接访问public目录下的文件\n<h3 id="httpNexpresstopic-3">适用场景</h3>- <lg>HTTP模块</lg>：\n - 开发底层网络服务，如自定义协议。\n - 想要精确控制请求处理流程。\n - 对性能有极高要求的场景。\n- <lg>Express框架</lg>：\n - 快速开发Web应用和API。\n - 开发中小型项目，追求开发效率。\n - 集成第三方插件，如身份验证、模板引擎等。\n<h3 id="httpNexpresstopic-4">总结</h3>HTTP模块是Node.js的基础组件，适合用于深入理解HTTP协议和开发底层服务。而Express是基于HTTP模块构建的成熟框架，提供了丰富的功能和便捷的API，能极大地提高开发效率，是Web开发的主流选择。在实际开发中，你可以根据项目需求来选择合适的工具。\n',
'<h2>JavaScript Puppeteer Samples</h2>	<center><div id="PuppeteerSamplestoc" class="toc"><a href="#PuppeteerSamplestopic-0" target="_self">Basic Setup</a><br><a href="#PuppeteerSamplestopic-1" target="_self">Taking a Screenshot</a><br><a href="#PuppeteerSamplestopic-2" target="_self">Generating PDF</a><br><a href="#PuppeteerSamplestopic-3" target="_self">Form Submission</a><br><a href="#PuppeteerSamplestopic-4" target="_self">Scraping Data</a><br><a href="#PuppeteerSamplestopic-5" target="_self">Handling Dynamic Content</a><br><a href="#PuppeteerSamplestopic-6" target="_self">Emulating Devices</a><br><a href="#PuppeteerSamplestopic-7" target="_self">Intercepting Network Requests</a><br></div></center><br><br>\n\nPuppeteer is a Node.js library that provides a high-level API to control Chrome/Chromium browsers.\n<h3 id="PuppeteerSamplestopic-0">Basic Setup</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n // Launch browser\n const browser = await puppeteer.launch({ headless: false });\n const page = await browser.newPage();\n \n // Navigate to a page\n await page.goto(\'https://example.com\');\n \n // Do something...\n \n // Close browser\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-1">Taking a Screenshot</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n await page.screenshot({ path: \'example.png\' });\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-2">Generating PDF</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\', { waitUntil: \'networkidle0\' });\n await page.pdf({ path: \'example.pdf\', format: \'A4\' });\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-3">Form Submission</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch({ headless: false });\n const page = await browser.newPage();\n await page.goto(\'https://example.com/login\');\n \n // Type into form fields\n await page.type(\'#username\', \'myusername\');\n await page.type(\'#password\', \'mypassword\');\n \n // Click submit button\n await page.click(\'#submit\');\n \n // Wait for navigation\n await page.waitForNavigation();\n \n console.log(\'Logged in successfully!\');\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-4">Scraping Data</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com/products\');\n \n const products = await page.evaluate(() =&gt; {\n  return Array.from(document.querySelectorAll(\'.product\')).map(product =&gt; {\n   return {\n    name: product.querySelector(\'.name\').innerText,\n    price: product.querySelector(\'.price\').innerText\n   };\n  });\n });\n \n console.log(products);\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-5">Handling Dynamic Content</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com/dynamic-content\');\n \n // Wait for specific element to load\n await page.waitForSelector(\'.dynamic-element\');\n \n // Or wait for a specific timeout\n await page.waitForTimeout(2000);\n \n const content = await page.$eval(\'.dynamic-element\', el =&gt; el.textContent);\n console.log(content);\n \n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-6">Emulating Devices</h3>const puppeteer = require(\'puppeteer\');\nconst devices = require(\'puppeteer/DeviceDescriptors\');\nconst iPhone = devices[\'iPhone 11\'];\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n // Emulate iPhone 11\n await page.emulate(iPhone);\n await page.goto(\'https://example.com\');\n \n await page.screenshot({ path: \'mobile-view.png\' });\n await browser.close();\n})();\n\n<h3 id="PuppeteerSamplestopic-7">Intercepting Network Requests</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n // Enable request interception\n await page.setRequestInterception(true);\n \n page.on(\'request\', interceptedRequest =&gt; {\n  if (interceptedRequest.url().endsWith(\'.png\') || \n    interceptedRequest.url().endsWith(\'.jpg\')) {\n   interceptedRequest.abort(); // Block images\n  } else {\n   interceptedRequest.continue();\n  }\n });\n \n await page.goto(\'https://example.com\');\n await browser.close();\n})();\n\nThese samples cover common Puppeteer use cases.\nRemember to install Puppeteer first with `npm install puppeteer`.\n',
'<h2>POE JavaScript Puppeteer samples</h2>	<center><div id="Puppeteer_samplestoc" class="toc"><a href="#Puppeteer_samplestopic-0" target="_self">1. Basic Usage: Launching a Browser and Navigating to a Page</a><br><a href="#Puppeteer_samplestopic-1" target="_self">2. Filling Out a Form and Submitting</a><br><a href="#Puppeteer_samplestopic-2" target="_self">3. Scraping Data from a Page</a><br><a href="#Puppeteer_samplestopic-3" target="_self">4. Taking a Screenshot of a Specific Element</a><br><a href="#Puppeteer_samplestopic-4" target="_self">5. Headless Mode vs. Headful Mode</a><br><a href="#Puppeteer_samplestopic-5" target="_self"><pk>dynamic content</pk></a><br><a href="#Puppeteer_samplestopic-6" target="_self">1. Using `waitForSelector()`</a><br><a href="#Puppeteer_samplestopic-7" target="_self">2. Waiting for Network Idle</a><br><a href="#Puppeteer_samplestopic-8" target="_self">3. Using `waitForTimeout()`</a><br><a href="#Puppeteer_samplestopic-9" target="_self">4. Combining Multiple Waits</a><br><a href="#Puppeteer_samplestopic-10" target="_self">5. Observing Changes with Mutation Observers</a><br><a href="#Puppeteer_samplestopic-11" target="_self">Summary</a><br></div></center><br><br>\n\n<h3 id="Puppeteer_samplestopic-0">1. Basic Usage: Launching a Browser and Navigating to a Page</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n await page.screenshot({ path: \'example.png\' });\n await browser.close();\n})();\n\n<h3 id="Puppeteer_samplestopic-1">2. Filling Out a Form and Submitting</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com/login\');\n\n await page.type(\'#username\', \'myUsername\');\n await page.type(\'#password\', \'myPassword\');\n await page.click(\'#submit\');\n \n await page.waitForNavigation();\n await browser.close();\n})();\n\n<h3 id="Puppeteer_samplestopic-2">3. Scraping Data from a Page</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n\n const data = await page.evaluate(() =&gt; {\n  const items = Array.from(document.querySelectorAll(\'h1\'));\n  return items.map(item =&gt; item.textContent);\n });\n\n console.log(data);\n await browser.close();\n})();\n\n<h3 id="Puppeteer_samplestopic-3">4. Taking a Screenshot of a Specific Element</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n\n const element = await page.$(\'h1\');\n await element.screenshot({ path: \'element.png\' });\n await browser.close();\n})();\n\n<h3 id="Puppeteer_samplestopic-4">5. Headless Mode vs. Headful Mode</h3>const puppeteer = require(\'puppeteer\');\n(async () =&gt; {\n const browser = await puppeteer.launch({ headless: false }); // Change to true for headless mode\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n await browser.close();\n})();\n\n<h3 id="Puppeteer_samplestopic-5"><pk>dynamic content</pk></h3>Handling dynamic content with Puppeteer often involves waiting for elements to load or become visible. Here are some strategies you can use:\n\n<h3 id="Puppeteer_samplestopic-6">1. Using `waitForSelector()`</h3>This method waits for a specific element to appear in the DOM.\nawait page.goto(\'https://example.com\');\nawait page.waitForSelector(\'#dynamic-element\'); // Wait until the element is present\nconst content = await page.evaluate(() =&gt; document.querySelector(\'#dynamic-element\').textContent);\nconsole.log(content);\n\n<h3 id="Puppeteer_samplestopic-7">2. Waiting for Network Idle</h3>If the page loads content dynamically via network requests, you can wait for network activity to settle.\nawait page.goto(\'https://example.com\', { waitUntil: \'networkidle2\' }); // Wait until no network connections for at least 500 ms\n\n<h3 id="Puppeteer_samplestopic-8">3. Using `waitForTimeout()`</h3>If you know a specific delay before content loads, you can use `waitForTimeout()`, though this is less reliable.\nawait page.goto(\'https://example.com\');\nawait page.waitForTimeout(2000); // Wait for 2 seconds\n\n<h3 id="Puppeteer_samplestopic-9">4. Combining Multiple Waits</h3>You can combine waits to ensure that both the content is loaded and the network is idle.\nawait page.goto(\'https://example.com\', { waitUntil: \'networkidle2\' });\nawait page.waitForSelector(\'#dynamic-element\');\n\n<h3 id="Puppeteer_samplestopic-10">5. Observing Changes with Mutation Observers</h3>If you need to react to changes dynamically, you can set up a MutationObserver in your page context.\nawait page.evaluate(() =&gt; {\n const targetNode = document.getElementById(\'dynamic-container\');\n const config = { childList: true, subtree: true };\n\n const callback = (mutationsList) =&gt; {\n  for (let mutation of mutationsList) {\n   if (mutation.type === \'childList\') {\n    console.log(\'A child node has been added or removed.\');\n   }\n  }\n };\n\n const observer = new MutationObserver(callback);\n observer.observe(targetNode, config);\n});\n\n<h3 id="Puppeteer_samplestopic-11">Summary</h3>- Use `waitForSelector()` for specific elements.\n- Use `networkidle2` to ensure the page has finished loading.\n- Combine multiple wait strategies for robustness.\n- Consider using Mutation Observers for real-time changes.\n',
'<h2>What is Axios in JavaScript?</h2>	<center><div id="Axiostoc" class="toc"><a href="#Axiostopic-0" target="_self" onclick="jumpto(0)">Example Usage</a><br><a href="#Axiostopic-1" target="_self" onclick="jumpto(1)">Why Use Axios Over Fetch API?</a><br></div></center><br><br>\n\n<lg>Axios</lg> is a popular <lg>promise-based HTTP client</lg> for JavaScript, used to make <lg>HTTP requests</lg> from:\n- <lg>Browsers</lg> (using `XMLHttpRequest`)\n- <lg>Node.js</lg> (using `http` module)\n\nIt simplifies sending <lg>AJAX requests</lg> and handling responses, supporting modern features like:\n✅ <lg>Promise-based</lg> (async/await compatible)\n✅ <lg>Request &amp; response interception</lg>\n✅ <lg>Automatic JSON data transformation</lg>\n✅ <lg>CSRF/XSRF protection</lg>\n✅ <lg>Cancellation support</lg>\n\n<h3 id="Axiostopic-0">Example Usage</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n<lg>1. Installation</lg>\nnpm install axios # For Node.js\n\nor include it via CDN:\n&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"&gt;&lt;/script&gt;\n\n<lg>2. Making a GET Request</lg>\naxios.get(\'https://api.example.com/data\')\n .then(response =&gt; console.log(response.data))\n .catch(error =&gt; console.error(\'Error:\', error));\n\n<lg>3. Making a POST Request</lg>\naxios.post(\'https://api.example.com/post\', { name: \'John\' })\n .then(response =&gt; console.log(response.data))\n .catch(error =&gt; console.error(\'Error:\', error));\n\n<lg>4. Using Async/Await</lg>\nasync function fetchData() {\n try {\n  const response = await axios.get(\'https://api.example.com/data\');\n  console.log(response.data);\n } catch (error) {\n  console.error(\'Error:\', error);\n }\n}\nfetchData();\n\n<h3 id="Axiostopic-1">Why Use Axios Over Fetch API?</h3> <a href="#top" target="_self"><b>⇧</b></a><br>\n- <lg>Simpler syntax</lg> (no need to manually parse JSON).\n- <lg>Better error handling</lg> (Axios rejects on HTTP errors like 404/500).\n- <lg>Request cancellation</lg> (using `CancelToken` or `AbortController`).\n- <lg>Wider browser support</lg> (works in older browsers).\n',
'<h2>Real-Time Communication Between Server and Browser Clients</h2>	<center><div id="Real-TimeCommunicationtoc" class="toc"><a href="#Real-TimeCommunicationtopic-0" target="_self">Server-side (Node.js with Express and Socket.io)</a><br><a href="#Real-TimeCommunicationtopic-1" target="_self">Client-side (HTML, CSS, JavaScript)</a><br><a href="#Real-TimeCommunicationtopic-2" target="_self">How to Use</a><br><a href="#Real-TimeCommunicationtopic-3" target="_self">Features</a><br><a href="#Real-TimeCommunicationtopic-4" target="_self">Security Considerations</a><br></div></center><br><br>\n\nHere\'s a complete implementation for real-time messaging between a Node.js server and multiple browser clients, including the ability to send messages between specific users.\n<h3 id="Real-TimeCommunicationtopic-0">Server-side (Node.js with Express and Socket.io)</h3>\n// server.js\nconst express = require(\'express\');\nconst http = require(\'http\');\nconst socketIo = require(\'socket.io\');\nconst path = require(\'path\');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server);\n\n// Store connected users\nconst users = {};\n\n// Serve static files from the public directory\napp.use(express.static(path.join(__dirname, \'public\')));\n\n// Handle socket connections\nio.on(\'connection\', (socket) => {\n console.log(\'New client connected:\', socket.id);\n\n // Handle new user joining\n socket.on(\'join\', (username) => {\n  users[socket.id] = username;\n  console.log(`${username} joined with ID: ${socket.id}`);\n  \n  // Broadcast to all clients that a new user has joined\n  io.emit(\'userList\', Object.values(users));\n  io.emit(\'message\', {\n   sender: \'System\',\n   text: `${username} has joined the chat`,\n   timestamp: new Date().toISOString()\n  });\n });\n\n // Handle incoming messages\n socket.on(\'sendMessage\', (data) => {\n  const { recipientId, text } = data;\n  const sender = users[socket.id] || \'Anonymous\';\n  const timestamp = new Date().toISOString();\n\n  if (recipientId === \'all\') {\n   // Broadcast to all clients\n   io.emit(\'message\', {\n    sender,\n    text,\n    timestamp\n   });\n  } else {\n   // Send to specific recipient\n   io.to(recipientId).emit(\'message\', {\n    sender,\n    text,\n    timestamp,\n    private: true\n   });\n   // Also send to sender so they see their own messages\n   socket.emit(\'message\', {\n    sender: `You (to ${users[recipientId] || recipientId})`,\n    text,\n    timestamp,\n    private: true\n   });\n  }\n });\n\n // Handle disconnection\n socket.on(\'disconnect\', () => {\n  const username = users[socket.id];\n  if (username) {\n   console.log(`${username} disconnected`);\n   delete users[socket.id];\n\n   // Update user list for all clients\n   io.emit(\'userList\', Object.values(users));\n   io.emit(\'message\', {\n    sender: \'System\',\n    text: `${username} has left the chat`,\n    timestamp: new Date().toISOString()\n   });\n  }\n });\n});\n\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n console.log(`Server running on port ${PORT}`);\n});\n<h3 id="Real-TimeCommunicationtopic-1">Client-side (HTML, CSS, JavaScript)</h3>\nCreate a `public` directory and place these files there:\n\nindex.html\n&lt;!DOCTYPE html>\n&lt;html lang="en">\n&lt;head>\n &lt;meta charset="UTF-8">\n &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">\n &lt;title>Real-Time Chat&lt;/title>\n &lt;link rel="stylesheet" href="styles.css">\n&lt;/head>\n&lt;body>\n &lt;div class="chat-container">\n  &lt;div class="chat-header">\n   &lt;h1>Real-Time Chat&lt;/h1>\n   &lt;div class="user-controls">\n    &lt;input type="text" id="usernameInput" placeholder="Enter your username">\n    &lt;button id="joinButton">Join Chat&lt;/button>\n   &lt;/div>\n  &lt;/div>\n  \n  &lt;div class="chat-main">\n   &lt;div class="message-container" id="messageContainer">&lt;/div>\n\n   &lt;div class="user-list-container">\n    &lt;h3>Online Users&lt;/h3>\n    &lt;ul id="userList">&lt;/ul>\n   &lt;/div>\n  &lt;/div>\n  \n  &lt;div class="message-input">\n   &lt;select id="recipientSelect">\n    &lt;option value="all">Everyone&lt;/option>\n   &lt;/select>\n   &lt;input type="text" id="messageInput" placeholder="Type your message..." disabled>\n   &lt;button id="sendButton" disabled>Send&lt;/button>\n  &lt;/div>\n &lt;/div>\n \n &lt;script src="/socket.io/socket.io.js">&lt;/script>\n &lt;script src="client.js">&lt;/script>\n&lt;/body>\n&lt;/html>\n\nstyles.css\nbody {\n font-family: Arial, sans-serif;\n margin: 0;\n padding: 0;\n background-color: #f5f5f5;\n}\n\n.chat-container {\n max-width: 1000px;\n margin: 20px auto;\n background: white;\n border-radius: 8px;\n box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\n overflow: hidden;\n}\n\n.chat-header {\n padding: 15px;\n background: #4CAF50;\n color: white;\n text-align: center;\n}\n\n.user-controls {\n margin-top: 10px;\n display: flex;\n gap: 10px;\n}\n\n.user-controls input, .user-controls button {\n padding: 8px;\n border: none;\n border-radius: 4px;\n}\n\n.user-controls button {\n background: #333;\n color: white;\n cursor: pointer;\n}\n\n.user-controls button:hover {\n background: #555;\n}\n\n.chat-main {\n display: flex;\n height: 500px;\n}\n\n.message-container {\n flex: 3;\n padding: 15px;\n overflow-y: auto;\n border-right: 1px solid #eee;\n}\n\n.user-list-container {\n flex: 1;\n padding: 15px;\n overflow-y: auto;\n}\n\n.user-list-container h3 {\n margin-top: 0;\n border-bottom: 1px solid #eee;\n padding-bottom: 10px;\n}\n\n.user-list {\n list-style: none;\n padding: 0;\n}\n\n.user-list li {\n padding: 8px;\n border-bottom: 1px solid #eee;\n cursor: pointer;\n}\n\n.user-list li:hover {\n background-color: #f0f0f0;\n}\n\n.message-input {\n display: flex;\n padding: 15px;\n background: #f9f9f9;\n border-top: 1px solid #eee;\n}\n\n.message-input select {\n padding: 8px;\n margin-right: 10px;\n border: 1px solid #ddd;\n border-radius: 4px;\n}\n\n.message-input input {\n flex: 1;\n padding: 8px;\n border: 1px solid #ddd;\n border-radius: 4px;\n}\n\n.message-input button {\n padding: 8px 15px;\n margin-left: 10px;\n background: #4CAF50;\n color: white;\n border: none;\n border-radius: 4px;\n cursor: pointer;\n}\n\n.message-input button:hover {\n background: #45a049;\n}\n\n.message {\n margin-bottom: 15px;\n padding: 10px;\n border-radius: 4px;\n background: #f0f0f0;\n}\n\n.message .sender {\n font-weight: bold;\n margin-bottom: 5px;\n}\n\n.message .timestamp {\n font-size: 0.8em;\n color: #666;\n margin-bottom: 5px;\n}\n\n.message .text {\n margin-top: 5px;\n}\n\n.message.private {\n background: #e3f2fd;\n border-left: 3px solid #2196F3;\n}\n\nclient.js\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n const socket = io();\n let currentUsername = \'\';\n \n // DOM elements\n const usernameInput = document.getElementById(\'usernameInput\');\n const joinButton = document.getElementById(\'joinButton\');\n const messageInput = document.getElementById(\'messageInput\');\n const sendButton = document.getElementById(\'sendButton\');\n const messageContainer = document.getElementById(\'messageContainer\');\n const userList = document.getElementById(\'userList\');\n const recipientSelect = document.getElementById(\'recipientSelect\');\n \n // Join chat\n joinButton.addEventListener(\'click\', () => {\n  const username = usernameInput.value.trim();\n  if (username) {\n   currentUsername = username;\n   socket.emit(\'join\', username);\n\n   // Disable join controls\n   usernameInput.disabled = true;\n   joinButton.disabled = true;\n\n   // Enable message controls\n   messageInput.disabled = false;\n   sendButton.disabled = false;\n  }\n });\n \n // Send message\n sendButton.addEventListener(\'click\', sendMessage);\n messageInput.addEventListener(\'keypress\', (e) => {\n  if (e.key === \'Enter\') {\n   sendMessage();\n  }\n });\n \n function sendMessage() {\n  const text = messageInput.value.trim();\n  if (text) {\n   const recipientId = recipientSelect.value;\n   socket.emit(\'sendMessage\', {\n    recipientId,\n    text\n   });\n   messageInput.value = \'\';\n  }\n }\n \n // Receive messages\n socket.on(\'message\', (data) => {\n  const messageElement = document.createElement(\'div\');\n  messageElement.className = \'message\' + (data.private ? \' private\' : \'\');\n  \n  messageElement.innerHTML = `\n   &lt;div class="sender">${data.sender}&lt;/div>\n   &lt;div class="timestamp">${new Date(data.timestamp).toLocaleTimeString()}&lt;/div>\n   &lt;div class="text">${data.text}&lt;/div>\n  `;\n  \n  messageContainer.appendChild(messageElement);\n  messageContainer.scrollTop = messageContainer.scrollHeight;\n });\n \n // Update user list\n socket.on(\'userList\', (users) => {\n  // Clear current list\n  userList.innerHTML = \'\';\n  recipientSelect.innerHTML = \'&lt;option value="all">Everyone&lt;/option>\';\n  \n  // Get socket IDs of all users (for private messaging)\n  socket.emit(\'getSocketIds\', (socketIds) => {\n   users.forEach((username, index) => {\n    // Add to user list display\n    const userElement = document.createElement(\'li\');\n    userElement.textContent = username;\n    userElement.dataset.socketId = socketIds[index];\n    userList.appendChild(userElement);\n \n    // Add to recipient select (except current user)\n    if (username !== currentUsername) {\n     const option = document.createElement(\'option\');\n     option.value = socketIds[index];\n     option.textContent = username;\n     recipientSelect.appendChild(option);\n    }\n   });\n  });\n });\n \n // Click on user to send private message\n userList.addEventListener(\'click\', (e) => {\n  if (e.target.tagName === \'LI\') {\n   recipientSelect.value = e.target.dataset.socketId;\n   messageInput.focus();\n  }\n });\n \n // Request socket IDs from server\n socket.emit(\'getSocketIds\', (socketIds) => {\n  // This is just to trigger the server to send the socket IDs\n });\n});\n<h3 id="Real-TimeCommunicationtopic-2">How to Use</h3>\n1. Install the required dependencies:\nnpm install express socket.io\n\n2. Start the server:\nnode server.js\n\n3. Open multiple browser tabs/windows and navigate to `http://localhost:3000`\n\n4. Enter a username in each tab and click "Join Chat"\n\n5. Send messages to everyone or select a specific user from the dropdown to send private messages\n<h3 id="Real-TimeCommunicationtopic-3">Features</h3>\n1. Real-time messaging between all connected clients\n2. Private messaging between specific users\n3. Online user list that updates in real-time\n4. Message timestamps\n5. Visual distinction between public and private messages\n6. Responsive design that works on different screen sizes\n<h3 id="Real-TimeCommunicationtopic-4">Security Considerations</h3>\nFor a production environment, you would want to add:\n- User authentication\n- Message validation/sanitization\n- Rate limiting\n- HTTPS for secure connections\n- More robust error handling\n┌───────────────────────┐\n│      Client Side      │\n├───────────────────────┤\n│ 1. User enters name   │\n│ 2. Joins chat         │\n│ 3. Sees user list     │\n│ 4. Composes message   │\n│ 5. Selects recipient  │\n│ 6. Sends message      │\n│ 7. Receives messages  │\n└──────────┬────────────┘\n           │\n           ▼\n┌───────────────────────┐\n│    Socket.io Tunnel   │\n└──────────┬────────────┘\n           │\n           ▼\n┌───────────────────────┐\n│      Server Side      │\n├───────────────────────┤\n│ 1. Manages connections│\n│ 2. Tracks users       │\n│ 3. Routes messages    │\n│ 4. Broadcasts updates │\n│ 5. Handles disconnects│\n└───────────────────────┘',
'<h2>headless browser and available innodejs package</h2>	A headless browser is a web browser without a graphical user interface (GUI).\nIt can programmatically control web pages, execute JavaScript, and perform all the functions of a normal browser, but runs in the background without displaying anything on the screen.\n<h3>Why Use Headless Browsers?</h3>Headless browsers are commonly used for:\n- Web scraping and data extraction\n- Automated testing of web applications\n- Generating screenshots or PDFs of web pages\n- Performance monitoring and analysis\n- Automating repetitive web tasks\n<h3>Popular Headless Browser Packages for Node.js</h3>Here are the most commonly used headless browser packages in Node.js:\n<h3>1. Puppeteer</h3>- Developed by Google\'s Chrome team\n- Controls Chromium or Chrome browser\n- Simple API and excellent documentation\n- Installation: `npm install puppeteer`\n\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  await page.goto(\'https://example.com\');\n  await page.screenshot({ path: \'example.png\' });\n  await browser.close();\n})();\n<h3>2. Playwright</h3>- Developed by Microsoft\n- Supports Chromium, WebKit, and Firefox\n- Cross-browser testing capabilities\n- Installation: `npm install playwright`\n\nconst { chromium } = require(\'playwright\');\n(async () => {\n  const browser = await chromium.launch();\n  const page = await browser.newPage();\n  await page.goto(\'https://example.com\');\n  console.log(await page.title());\n  await browser.close();\n})();\n<h3>3. Selenium WebDriver</h3>- More established but more complex\n- Supports multiple programming languages\n- Works with many browsers (including non-headless)\n- Installation: `npm install selenium-webdriver`\n\nconst { Builder } = require(\'selenium-webdriver\');\nconst chrome = require(\'selenium-webdriver/chrome\');\n\n(async function example() {\n  let driver = await new Builder()\n    .forBrowser(\'chrome\')\n    .setChromeOptions(new chrome.Options().headless())\n    .build();\n  \n  await driver.get(\'https://example.com\');\n  console.log(await driver.getTitle());\n  await driver.quit();\n})();\n<h3>4. Nightmare</h3>- Simpler alternative to Puppeteer (older)\n- Electron-based\n- Installation: `npm install nightmare`\n\nconst Nightmare = require(\'nightmare\');\nconst nightmare = Nightmare({ show: false });\n\nnightmare\n  .goto(\'https://example.com\')\n  .evaluate(() => document.title)\n  .end()\n  .then(console.log);\n<h3>Comparison</h3>Feature : Maintainer \nPuppeteer : Google \nPlaywright : Microsoft \nSelenium : Community \nNightmare : Community \n\nFeature : Browser Support \nPuppeteer : Chromium \nPlaywright : Chromium, WebKit, Firefox \nSelenium : Multiple \nNightmare : Electron \n\nFeature : Performance \nPuppeteer : Fast \nPlaywright : Fast \nSelenium : Moderate \nNightmare : Moderate \n\nFeature : API Simplicity \nPuppeteer : High \nPlaywright : High \nSelenium : Moderate \nNightmare : High \n\nFeature : Cross-browser \nPuppeteer : No \nPlaywright : Yes \nSelenium : Yes \nNightmare : No \n\nFor most modern Node.js projects, Puppeteer or Playwright are the recommended choices due to their active development, excellent documentation, and strong performance.\n',
'<h2>application samples of Puppeteer in Node.js</h2>	<center><div id="PuppeteerSamplestoc" class="toc"><a href="#PuppeteerSamplestopic-0" target="_self">1. Basic Page Screenshot</a><br><a href="#PuppeteerSamplestopic-1" target="_self">2. Generate PDF from a Web Page</a><br><a href="#PuppeteerSamplestopic-2" target="_self">3. Web Scraping (Extract Data)</a><br><a href="#PuppeteerSamplestopic-3" target="_self">4. Automated Form Submission</a><br><a href="#PuppeteerSamplestopic-4" target="_self">5. Performance Monitoring</a><br><a href="#PuppeteerSamplestopic-5" target="_self">6. Automated Testing (Check for 404 Links)</a><br><a href="#PuppeteerSamplestopic-6" target="_self">7. Single-Page Application (SPA) Interaction</a><br><a href="#PuppeteerSamplestopic-7" target="_self">8. Handle Authentication (Save/Load Cookies)</a><br><a href="#PuppeteerSamplestopic-8" target="_self">9. Mobile Emulation</a><br><a href="#PuppeteerSamplestopic-9" target="_self">10. Capture Console Logs and Errors</a><br><a href="#PuppeteerSamplestopic-10" target="_self">Key Notes:</a><br></div></center><br><br>\n\n<h3 id="PuppeteerSamplestopic-0">1. Basic Page Screenshot</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://example.com\');\n await page.screenshot({ path: \'example.png\' }); // Full-page screenshot\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-1">2. Generate PDF from a Web Page</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://example.com\', { waitUntil: \'networkidle0\' });\n await page.pdf({ \n  path: \'example.pdf\', \n  format: \'A4\',\n  printBackground: true \n });\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-2">3. Web Scraping (Extract Data)</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://quotes.toscrape.com\');\n \n const quotes = await page.evaluate(() => {\n  return Array.from(document.querySelectorAll(\'.quote\')).map(quote => ({\n   text: quote.querySelector(\'.text\').innerText,\n   author: quote.querySelector(\'.author\').innerText\n  }));\n });\n \n console.log(quotes);\n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-3">4. Automated Form Submission</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch({ headless: false }); // Show browser for demo\n const page = await browser.newPage();\n \n await page.goto(\'https://example.com/login\');\n \n // Fill and submit form\n await page.type(\'#username\', \'testuser\');\n await page.type(\'#password\', \'password123\');\n await page.click(\'#submit\');\n \n await page.waitForNavigation();\n console.log(\'Form submitted!\');\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-4">5. Performance Monitoring</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://example.com\', { waitUntil: \'networkidle0\' });\n \n // Get performance metrics\n const metrics = await page.metrics();\n console.log(\'Metrics:\', metrics);\n \n // Get page load time\n const loadTime = await page.evaluate(() => window.performance.timing.loadEventEnd - window.performance.timing.navigationStart);\n console.log(`Page load time: ${loadTime}ms`);\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-5">6. Automated Testing (Check for 404 Links)</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://example.com\');\n \n // Get all links on the page\n const links = await page.evaluate(() => \n  Array.from(document.querySelectorAll(\'a[href]\'), a => a.href)\n );\n \n // Check each link\n for (const link of links) {\n  const response = await page.goto(link, { waitUntil: \'domcontentloaded\' }).catch(e => e);\n  if (response &amp;&amp; response.status() === 404) {\n   console.log(`Broken link found: ${link}`);\n  }\n }\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-6">7. Single-Page Application (SPA) Interaction</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n await page.goto(\'https://example-spa.com\');\n \n // Wait for dynamic content to load\n await page.waitForSelector(\'.dynamic-content\');\n \n // Click a button that loads content via AJAX\n await page.click(\'#load-more\');\n await page.waitForResponse(response => response.url().includes(\'/api/data\'));\n \n // Extract dynamically loaded content\n const dynamicContent = await page.$eval(\'.dynamic-content\', el => el.innerText);\n console.log(dynamicContent);\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-7">8. Handle Authentication (Save/Load Cookies)</h3>const puppeteer = require(\'puppeteer\');\nconst fs = require(\'fs\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n // Login and save cookies\n await page.goto(\'https://example.com/login\');\n await page.type(\'#username\', \'user\');\n await page.type(\'#password\', \'pass\');\n await page.click(\'#submit\');\n await page.waitForNavigation();\n \n const cookies = await page.cookies();\n fs.writeFileSync(\'cookies.json\', JSON.stringify(cookies));\n \n // Later sessions can load cookies\n const newPage = await browser.newPage();\n const savedCookies = JSON.parse(fs.readFileSync(\'cookies.json\'));\n await newPage.setCookie(...savedCookies);\n await newPage.goto(\'https://example.com/dashboard\');\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-8">9. Mobile Emulation</h3>const puppeteer = require(\'puppeteer\');\nconst devices = require(\'puppeteer/DeviceDescriptors\');\nconst iPhone = devices[\'iPhone 11\'];\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n // Emulate iPhone\n await page.emulate(iPhone);\n await page.goto(\'https://example.com\');\n await page.screenshot({ path: \'mobile-view.png\' });\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-9">10. Capture Console Logs and Errors</h3>const puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n \n // Listen for console events\n page.on(\'console\', msg => console.log(\'PAGE LOG:\', msg.text()));\n page.on(\'pageerror\', error => console.log(\'Page error:\', error.message));\n \n await page.goto(\'https://example.com\');\n \n // Trigger some console logs\n await page.evaluate(() => {\n  console.log(\'Hello from the page!\');\n  throw new Error(\'Test error\');\n });\n \n await browser.close();\n})();\n<h3 id="PuppeteerSamplestopic-10">Key Notes:</h3>1. All examples use `async/await` for better readability\n2. Add error handling with `try/catch` in production code\n3. Use `{ headless: false }` during development to see what\'s happening\n4. Remember to close the browser with `await browser.close()`\n5. For complex scraping, consider adding delays with `page.waitForTimeout(1000)`\n\nThese examples demonstrate Puppeteer\'s versatility for automation, testing, scraping, and monitoring tasks.\n',
'<h2>Puppeteer application samples</h2>	<h3>1. Basic Web Page Screenshot</h3>Capture a full - page screenshot of a website.\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com\');\n await page.screenshot({ path: \'example.png\', fullPage: true });\n await browser.close();\n})();\n<h3>2. Web Scraping</h3>Extract product information from an e - commerce website.\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://shop.example.com/products\');\n const products = await page.evaluate(() => {\n  return Array.from(document.querySelectorAll(\'.product-card\')).map(card => {\n   return {\n    title: card.querySelector(\'h3\').innerText,\n    price: card.querySelector(\'.price\').innerText,\n    link: card.querySelector(\'a\').href\n   };\n  });\n });\n console.log(products);\n await browser.close();\n})();\n<h3>3. Form Submission</h3>Automatically fill out and submit a form.\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch({ headless: false });\n const page = await browser.newPage();\n await page.goto(\'https://example.com/contact\');\n await page.type(\'#name\', \'John Doe\');\n await page.type(\'#email\', \'john@example.com\');\n await page.type(\'#message\', \'Hello, this is a test message.\');\n await Promise.all([\n  page.click(\'#submit\'),\n  page.waitForNavigation()\n ]);\n console.log(\'Form submitted successfully!\');\n await browser.close();\n})();\n<h3>4. Login Automation</h3>Automatically log in to a website.\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch({ headless: false });\n const page = await browser.newPage();\n await page.goto(\'https://example.com/login\');\n await page.type(\'#username\', \'your_username\');\n await page.type(\'#password\', \'your_password\');\n await Promise.all([\n  page.click(\'#login-button\'),\n  page.waitForNavigation()\n ]);\n console.log(\'Logged in successfully!\');\n await browser.close();\n})();\n<h3>5. PDF Generation</h3>Generate a PDF from a web page.\nconst puppeteer = require(\'puppeteer\');\n(async () => {\n const browser = await puppeteer.launch();\n const page = await browser.newPage();\n await page.goto(\'https://example.com/report\', { waitUntil: \'networkidle2\' });\n await page.pdf({ path: \'report.pdf\', format: \'A4\' });\n await browser.close();\n})();\n',
'<h2>Puppeteer 实现自动滚动页面以加载更多动态内容</h2>	<center><div id="Puppeteer自动滚动页面toc" class="toc"><a href="#Puppeteer自动滚动页面topic-0" target="_self">自动滚动的实现原理</a><br><a href="#Puppeteer自动滚动页面topic-1" target="_self">实现自动滚动的代码示例</a><br><a href="#Puppeteer自动滚动页面topic-2" target="_self">使用示例</a><br><a href="#Puppeteer自动滚动页面topic-3" target="_self">优化建议</a><br></div></center><br><br>\n\n在 Puppeteer 中实现自动滚动页面以加载更多动态内容是爬取动态网站的常见需求。\n以下是实现这一功能的详细方法和示例代码：\n<h3 id="Puppeteer自动滚动页面topic-0">自动滚动的实现原理</h3>\n动态加载内容的网站通常使用无限滚动（Infinite Scroll）技术，需要通过模拟用户滚动行为来触发更多内容的加载。\n主要步骤包括：\n1. 滚动页面到底部\n2. 等待新内容加载完成\n3. 检查是否还有更多内容可加载\n4. 重复上述步骤直到满足条件\n<h3 id="Puppeteer自动滚动页面topic-1">实现自动滚动的代码示例</h3>\n下面是一个完整的自动滚动函数，可用于收集更多动态加载的图片：\nasync function autoScrollAndCollectImages(page, scrollTimes = 5, waitTime = 1000) {\n // 初始提取图片\n let allImages = await extractImages(page);\n let previousHeight = 0;\n \n for (let i = 0; i &lt; scrollTimes; i++) {\n  // 记录当前页面高度\n  previousHeight = await page.evaluate(\'document.body.scrollHeight\');\n  \n  // 滚动到页面底部\n  await page.evaluate(\'window.scrollTo(0, document.body.scrollHeight)\');\n  \n  // 等待页面加载新内容\n  await page.waitForTimeout(waitTime);\n  \n  // 等待页面高度变化，表示有新内容加载\n  const newHeight = await page.evaluate(\'document.body.scrollHeight\');\n  if (newHeight === previousHeight) {\n   console.log(\'页面高度未变化，可能已到达底部或加载完成\');\n   break;\n  }\n  \n  // 提取新加载的图片\n  const newImages = await extractImages(page);\n  \n  // 计算新增图片\n  const uniqueNewImages = newImages.filter(img =&gt; !allImages.includes(img));\n  if (uniqueNewImages.length &gt; 0) {\n   console.log(`第 ${i+1} 次滚动后新增 ${uniqueNewImages.length} 张图片`);\n   allImages = [...allImages, ...uniqueNewImages];\n  } else {\n   console.log(`第 ${i+1} 次滚动后未发现新图片`);\n  }\n }\n \n return allImages;\n}\n\n// 提取页面图片的辅助函数\nasync function extractImages(page) {\n return await page.evaluate(() =&gt; {\n  const images = document.querySelectorAll(\'img\');\n  return Array.from(images)\n   .map(img =&gt; img.src)\n   .filter(src =&gt; src &amp;&amp; src.trim() !== \'\');\n });\n}\n<h3 id="Puppeteer自动滚动页面topic-2">使用示例</h3>\n以下是如何在完整的 Puppeteer 脚本中使用上述函数：\n\nconst puppeteer = require(\'puppeteer\');\n\n(async () =&gt; {\n const browser = await puppeteer.launch({ headless: false });\n const page = await browser.newPage();\n \n try {\n  // 设置视口以加载更多内容\n  await page.setViewport({ width: 1200, height: 800 });\n  \n  // 导航到目标页面\n  await page.goto(\'https://example.com\', { waitUntil: \'networkidle2\' });\n  \n  // 执行自动滚动并收集图片\n  const images = await autoScrollAndCollectImages(page, 10, 1500);\n  \n  console.log(`共收集到 ${images.length} 张图片`);\n  \n  // 处理图片数据（保存到文件、下载等）\n  // ...\n  \n } catch (error) {\n  console.error(\'发生错误:\', error);\n } finally {\n  await browser.close();\n }\n})();\n<h3 id="Puppeteer自动滚动页面topic-3">优化建议</h3>\n1. **智能滚动判断**：\n- 除了检查页面高度变化，还可以监听网络请求或特定元素的出现\n- 检查页面是否显示"没有更多内容"的提示\n\n2. **性能优化**：\n- 调整滚动间隔时间和滚动次数\n- 使用 `page.waitForSelector` 等待特定元素出现\n- 限制每次提取的图片数量\n\n3. **处理反爬机制**：\n- 添加随机延迟避免被识别为机器人\n- 设置合理的 User-Agent\n- 使用代理IP（如果需要）\n\n通过这种方法，你可以有效地收集通过无限滚动动态加载的图片和其他内容。\n根据具体网站的特点，可能需要调整滚动策略和等待条件。\n',
'<h2>open HTML page using Node.js</h2>	Use the `open` package in Node.js to accomplish this.\n\n1. <lg>Install the `open` package</lg>:\nInstall the `open` package from npm.\nYou can do this by running the following command in your terminal:\n npm install open\n2. <lg>Node.js Script (`openHtmlPage.js`)</lg>:\n Here\'s an example script that opens a specific HTML page in the default web browser:\n\n const open = require(\'open\');\n\n // Specify the path to the HTML file you want to open\n const htmlFilePath = \'path/to/your/htmlfile.html\';\n\n // Open the HTML file in the default web browser\n open(htmlFilePath)\n   .then(() => {\n     console.log(`Opened HTML file in the default web browser: ${htmlFilePath}`);\n   })\n   .catch(err => {\n     console.error(err);\n   });\n\n Replace `\'path/to/your/htmlfile.html\'` with the actual path to the HTML file you want to open.\n\n3. <lg>Run the Script</lg>:\n Run the script using the following command in your terminal:\n\n node openHtmlPage.js\n\n4. <lg>Explanation</lg>:\n - The `open` package in Node.js is used to open files, URLs, and executables in the default application.\n - In the script above, the `open()` function is used to open the specified HTML file in the default web browser.\n - The script logs a message if the HTML file was successfully opened or logs an error if there was a problem opening the file.\n\nWhen you run the script (`openHtmlPage.js`), it should open the specified HTML file in the default web browser on your system.\n',
'<h2>Node.js child_process</h2>	Execute system commands using the `child_process` module. There are several functions in the `child_process` module that you can use to run system commands, such as `exec()`, `execFile()`, `spawn()`, and `fork()`. Here\'s an example using the `exec()` function to run a system command:\n1. <lg>Node.js Script (`runCommand.js`)</lg>:\n Here\'s an example script that executes a system command using `exec()`:\n const { exec } = require(\'child_process\');\n // Specify the system command you want to execute\n const command = \'ls -l\';\n // Execute the system command\n exec(command, (error, stdout, stderr) => {\n   if (error) {\n     console.error(`Error executing command: ${error.message}`);\n     return;\n   }\n   if (stderr) {\n     console.error(`Error executing command: ${stderr}`);\n     return;\n   }\n   console.log(`Command output: ${stdout}`);\n });\n\n Replace `\'ls -l\'` with the system command you want to execute.\n2. <lg>Run the Script</lg>:\n Run the script using the following command in your terminal:\n ```bash\n node runCommand.js\n\n3. <lg>Explanation</lg>:\n - In the script above, the `exec()` function from the `child_process` module is used to execute the specified system command.\n - The `exec()` function takes the command as the first parameter and a callback function as the second parameter to handle the output and errors.\n - The callback function receives three arguments: `error`, `stdout`, and `stderr`. `stdout` contains the output of the command, while `stderr` contains any error output.\nWhen you run the script (`runCommand.js`), it will execute the system command specified and output the result in the console. You can replace `\'ls -l\'` with any system command you want to execute.\n',
'<h2>R websocket and applications</h2>	<center><div id="Rwebsockettoc" class="toc"><a href="#Rwebsockettopic-0" target="_self">R WebSocket Libraries:</a><br><a href="#Rwebsockettopic-1" target="_self">Comparison with Node.js WebSocket Libraries:</a><br><a href="#Rwebsockettopic-2" target="_self">Alternatives:</a><br><a href="#Rwebsockettopic-3" target="_self"><pk>R to talk to client on chrome</pk></a><br><a href="#Rwebsockettopic-4" target="_self">1. Set Up a WebSocket Server in R</a><br><a href="#Rwebsockettopic-5" target="_self">2. Create a WebSocket Client in Chrome (JavaScript)</a><br><a href="#Rwebsockettopic-6" target="_self">3. Test the Communication</a><br><a href="#Rwebsockettopic-7" target="_self">Troubleshooting</a><br><a href="#Rwebsockettopic-8" target="_self">Alternative: Use `websocket` Package (Client-Side in R)</a><br><a href="#Rwebsockettopic-9" target="_self">Final Notes</a><br><a href="#Rwebsockettopic-10" target="_self"><pk>R to wait for user input and send the message to browser</pk></a><br><a href="#Rwebsockettopic-11" target="_self">Step 1: R WebSocket Server (`server.R`)</a><br><a href="#Rwebsockettopic-12" target="_self">Step 2: Chrome Client (`client.html`)</a><br><a href="#Rwebsockettopic-13" target="_self">How to Run</a><br><a href="#Rwebsockettopic-14" target="_self">Key Features</a><br><a href="#Rwebsockettopic-15" target="_self">Troubleshooting</a><br><a href="#Rwebsockettopic-16" target="_self">Extending the Example</a><br><a href="#Rwebsockettopic-17" target="_self"><pk>an application for real-time data streaming</pk></a><br><a href="#Rwebsockettopic-18" target="_self">1. R WebSocket Server (`server.R`)</a><br><a href="#Rwebsockettopic-19" target="_self">2. Chrome Client (`client.html`)</a><br><a href="#Rwebsockettopic-20" target="_self">How to Run</a><br><a href="#Rwebsockettopic-21" target="_self">Key Features</a><br><a href="#Rwebsockettopic-22" target="_self">Customize the Data Source</a><br><a href="#Rwebsockettopic-23" target="_self">Troubleshooting</a><br><a href="#Rwebsockettopic-24" target="_self">Next Steps</a><br></div></center><br><br>\n\nIn R, you can use the <lg>websocket</lg> package, which provides WebSocket client functionality similar to the `websocket` library in Node.js.  \n<h3 id="Rwebsockettopic-0">R WebSocket Libraries:</h3>1. <lg>websocket</lg> (Recommended)  \n- A pure R implementation of WebSocket (RFC 6455).  \n- Works well for both client and server-side WebSocket interactions.  \n- Available on CRAN: [https://cran.r-project.org/package=websocket](https://cran.r-project.org/package=websocket)  \n\n<lg>Installation:</lg>\n install.packages("websocket")\n\n<lg>Example (Client):</lg>\n library(websocket)\n\n # Create a WebSocket client\n ws = WebSocket$new("wss://echo.websocket.org")\n\n # Define event handlers\n ws$onMessage(function(event) {\n   cat("Message received:", event$data, "\n")\n })\n\n ws$onOpen(function(event) {\n   cat("Connection opened\n")\n   ws$send("Hello from R!")\n })\n\n ws$onClose(function(event) {\n   cat("Connection closed\n")\n })\n\n ws$onError(function(event) {\n   cat("Error encountered:", event$message, "\n")\n })\n\n2. <lg>httpuv</lg> (For WebSocket Server)  \n- Part of the Shiny framework but can be used independently.  \n- Supports both HTTP and WebSocket servers.  \n- Useful if you need to create a WebSocket server in R.  \n\n<lg>Example (Server):</lg>\n library(httpuv)\n\n app = list(\n   onWSOpen = function(ws) {\n   ws$onMessage(function(binary, message) {\n   cat("Received:", message, "\n")\n   ws$send(paste("Echo:", message))\n   })\n   }\n )\n\n runServer("0.0.0.0", 8080, app)\n<h3 id="Rwebsockettopic-1">Comparison with Node.js WebSocket Libraries:</h3>Feature : Client Support \nNode.js ws : Yes \nR websocket : Yes \n\nFeature : Server Support \nNode.js ws : Yes \nR websocket : Limited (`httpuv` needed) \n\nFeature : Event Handling \nNode.js ws : Yes \nR websocket : Yes \n\nFeature : TLS/SSL \nNode.js ws : Yes \nR websocket : Yes \n<h3 id="Rwebsockettopic-2">Alternatives:</h3>- If you need <lg>real-time bidirectional communication</lg>, consider <lg>shiny` + `httpuv</lg> for server-side WebSockets.  \n- For <lg>connecting to external WebSocket APIs</lg>, `websocket` (client) is the best choice.  \n\n<h3 id="Rwebsockettopic-3"><pk>R to talk to client on chrome</pk></h3>Use the <lg>httpuv</lg> package (for the server) and <lg>JavaScript in Chrome</lg> (for the client).\nHere\'s a step-by-step guide:\n<h3 id="Rwebsockettopic-4">1. Set Up a WebSocket Server in R</h3>We\'ll use `httpuv` (part of Shiny) to create a WebSocket server.\n<lg>Install `httpuv` (if not installed)</lg>\ninstall.packages("httpuv")\n<lg>R WebSocket Server Code</lg>\nlibrary(httpuv)\n\n# Define WebSocket behavior\napp &lt;- list(\n call = function(req) {\n  list(\n   status = 200L,\n   headers = list("Content-Type" = "text/html"),\n   body = "WebSocket Server Running"\n  )\n },\n onWSOpen = function(ws) {\n  cat("Client connected\n")\n  \n  # Send a welcome message to the client\n  ws$send("Hello from R Server!")\n  \n  # Handle incoming messages from the client\n  ws$onMessage(function(binary, msg) {\n   cat("Received from client:", msg, "\n")\n   ws$send(paste("R says: You sent -", msg))\n  })\n  \n  # Handle client disconnection\n  ws$onClose(function() {\n   cat("Client disconnected\n")\n  })\n }\n)\n\n# Start the server on port 8080\nrunServer("0.0.0.0", 8080, app)\n- This server:\n- Responds to WebSocket connections (`onWSOpen`).\n- Sends a welcome message when a client connects.\n- Echoes back messages received from the client.\n<h3 id="Rwebsockettopic-5">2. Create a WebSocket Client in Chrome (JavaScript)</h3>You can run this in the <lg>Chrome DevTools Console</lg> or an HTML file.\n<lg>Option A: Run in Chrome DevTools Console</lg>\n1. Open Chrome, go to any webpage (e.g., `https://example.com`).\n2. Press `F12` (or `Ctrl+Shift+I`) to open <lg>DevTools</lg>.\n3. Go to the <lg>Console</lg> tab and run:\n\n// Connect to the R WebSocket server\nconst ws = new WebSocket("ws://localhost:8080");\n\n// Handle incoming messages from R\nws.onmessage = function(event) {\n console.log("R says:", event.data);\n};\n\n// Send a message to R\nws.send("Hello from Chrome!");\n- You should see responses from the R server in the console.\n<lg>Option B: Create an HTML File</lg>\nSave this as `client.html` and open it in Chrome:\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;WebSocket Client&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;script&gt;\n  const ws = new WebSocket("ws://localhost:8080");\n\n  ws.onopen = function() {\n   console.log("Connected to R server");\n   ws.send("Hello from Chrome!");\n  };\n\n  ws.onmessage = function(event) {\n   console.log("R says:", event.data);\n  };\n\n  ws.onclose = function() {\n   console.log("Disconnected from R server");\n  };\n &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n- Open this file in Chrome (`Ctrl+O`), and check the <lg>Console</lg> (`F12`) for messages.\n<h3 id="Rwebsockettopic-6">3. Test the Communication</h3>1. <lg>Run the R WebSocket server</lg> (the `httpuv` code above).\n2. <lg>Open Chrome</lg> and either:\n- Run the JavaScript snippet in the <lg>Console</lg>, or\n- Open the `client.html` file.\n3. <lg>Messages will flow both ways</lg>:\n- Chrome → R (handled in `onMessage` in R).\n- R → Chrome (handled in `ws.onmessage` in JS).\n<h3 id="Rwebsockettopic-7">Troubleshooting</h3>- <lg>"WebSocket connection failed"</lg> \n- Ensure the R server is running (`runServer` is active). \n- Check for firewall/port issues (try `telnet localhost 8080`). \n- If using <lg>HTTPS</lg>, Chrome requires `wss://` (secure WebSocket). \n\n- <lg>R not receiving messages</lg> \n- Make sure `ws.onMessage` is correctly set up in R. \n- Check Chrome\'s <lg>Network → WS</lg> tab in DevTools for errors. \n<h3 id="Rwebsockettopic-8">Alternative: Use `websocket` Package (Client-Side in R)</h3>If you want <lg>R to act as a WebSocket client</lg> (connecting to a JavaScript server), use:\nlibrary(websocket)\nws &lt;- WebSocket$new("ws://your-js-websocket-server")\n\nws$onMessage(function(event) {\n cat("JS says:", event$data, "\n")\n})\n\nws$send("Hello from R!")\n<h3 id="Rwebsockettopic-9">Final Notes</h3>- <lg>httpuv</lg> is best for <lg>R as a WebSocket server</lg>. \n- <lg>websocket</lg> is best for <lg>R as a WebSocket client</lg>. \n- Chrome (JavaScript) can connect to either. \n\nWould you like help extending this for a specific use case (e.g., real-time data streaming)? 🚀\n\n<h3 id="Rwebsockettopic-10"><pk>R to wait for user input and send the message to browser</pk></h3>Here’s a complete <lg>R WebSocket server application</lg> that: \n1. <lg>Waits for user input</lg> in the R console. \n2. <lg>Sends messages to a Chrome browser</lg> (or any WebSocket client). \n3. <lg>Receives messages from Chrome</lg> and prints them in R. \n\nWe\'ll use <lg>`httpuv`</lg> (for the WebSocket server) and a simple <lg>HTML/JS client</lg> for Chrome.\n<h3 id="Rwebsockettopic-11">Step 1: R WebSocket Server (`server.R`)</h3>This script runs a WebSocket server and waits for user input to send messages to connected clients.\n\nlibrary(httpuv)\n\n# Global variable to store active WebSocket connections\nclients &lt;- list()\n\n# WebSocket server setup\napp &lt;- list(\n call = function(req) {\n  # Handle HTTP requests (optional)\n  list(\n   status = 200L,\n   headers = list("Content-Type" = "text/html"),\n   body = "WebSocket Server Running (R -&gt; Chrome)"\n  )\n },\n onWSOpen = function(ws) {\n  # Assign a random ID to the client (for tracking)\n  client_id &lt;- paste0("client_", length(clients) + 1)\n  clients[[client_id]] &lt;&lt;- ws\n  cat("Client connected:", client_id, "\n")\n\n  # Send welcome message\n  ws$send(paste0("Welcome, ", client_id, "!"))\n\n  # Handle incoming messages from Chrome\n  ws$onMessage(function(binary, msg) {\n   cat("Received from Chrome:", msg, "\n")\n  })\n\n  # Handle client disconnection\n  ws$onClose(function() {\n   cat("Client disconnected:", client_id, "\n")\n   clients[[client_id]] &lt;&lt;- NULL\n  })\n }\n)\n\n# Start the server\nserver &lt;- startServer("0.0.0.0", 8080, app)\ncat("WebSocket server running on ws://localhost:8080\n")\n\n# Function to send messages to all connected clients\nsend_to_all &lt;- function(msg) {\n for (client in clients) {\n  client$send(msg)\n }\n}\n\n# Wait for user input and send messages\ncat("Type a message to send to Chrome (or \'quit\' to exit):\n")\nwhile (TRUE) {\n user_input &lt;- readline(prompt = "R&gt; ")\n if (tolower(user_input) == "quit") break\n send_to_all(user_input)\n}\n\n# Cleanup\nstopServer(server)\ncat("Server stopped.\n")\n<h3 id="Rwebsockettopic-12">Step 2: Chrome Client (`client.html`)</h3>Save this as an HTML file and open it in Chrome.\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;Chrome WebSocket Client&lt;/title&gt;\n &lt;style&gt;\n  body { font-family: Arial; margin: 20px; }\n  #messages { border: 1px solid #ccc; padding: 10px; height: 200px; overflow-y: scroll; }\n &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;h1&gt;Chrome WebSocket Client&lt;/h1&gt;\n &lt;div id="messages"&gt;&lt;/div&gt;\n &lt;input type="text" id="message" placeholder="Type a message to R..."&gt;\n &lt;button onclick="sendMessage()"&gt;Send&lt;/button&gt;\n\n &lt;script&gt;\n  const ws = new WebSocket("ws://localhost:8080");\n  const messagesDiv = document.getElementById("messages");\n\n  ws.onopen = function() {\n   logMessage("Connected to R WebSocket server!");\n  };\n\n  ws.onmessage = function(event) {\n   logMessage("R says: " + event.data);\n  };\n\n  ws.onclose = function() {\n   logMessage("Disconnected from server.");\n  };\n\n  function sendMessage() {\n   const msg = document.getElementById("message").value;\n   ws.send(msg);\n   logMessage("You sent: " + msg);\n   document.getElementById("message").value = "";\n  }\n\n  function logMessage(msg) {\n   messagesDiv.innerHTML += "&lt;p&gt;" + msg + "&lt;/p&gt;";\n   messagesDiv.scrollTop = messagesDiv.scrollHeight;\n  }\n &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<h3 id="Rwebsockettopic-13">How to Run</h3>1. <lg>Run the R server</lg>:\n- Open R/RStudio and run `server.R`.\n- You’ll see: `WebSocket server running on ws://localhost:8080`.\n\n2. <lg>Open the Chrome client</lg>:\n- Open `client.html` in Chrome (drag the file into the browser).\n- It will connect to the R server automatically.\n\n3. <lg>Send messages</lg>:\n- <lg>From R to Chrome</lg>: Type a message in the R console and press Enter. It will appear in the Chrome client.\n- <lg>From Chrome to R</lg>: Type in the input box and click "Send". The message will print in the R console.\n\n4. <lg>Quit</lg>:\n- Type `quit` in the R console to stop the server.\n<h3 id="Rwebsockettopic-14">Key Features</h3>- <lg>Bi-directional communication</lg>: R ↔ Chrome.\n- <lg>Multiple clients</lg>: The server can handle multiple Chrome tabs.\n- <lg>User-friendly</lg>: Chrome client has a simple UI.\n<h3 id="Rwebsockettopic-15">Troubleshooting</h3>- <lg>"Connection failed"</lg> in Chrome: \n - Ensure the R server is running (`startServer` is active). \n - Check if the port (`8080`) is blocked (try `telnet localhost 8080`). \n\n- <lg>R not receiving messages</lg>: \n - Verify `ws.onMessage` is set up correctly in the R script. \n - Check Chrome’s <lg>DevTools Console</lg> (`F12`) for errors. \n<h3 id="Rwebsockettopic-16">Extending the Example</h3>- <lg>Send data frames/JSON</lg>: Use `jsonlite::toJSON()` in R and `JSON.parse()` in JS. \n- <lg>Real-time plots</lg>: Use `shiny` + `httpuv` to update graphs in Chrome dynamically. \n\nWould you like to add any specific features (e.g., authentication, binary data)? \n<h3 id="Rwebsockettopic-17"><pk>an application for real-time data streaming</pk></h3>Here’s a <lg>real-time data streaming application</lg> where:\n- <lg>R generates live data</lg> (e.g., sine waves, stock prices, sensor data).\n- <lg>A Chrome browser visualizes it dynamically</lg> using WebSockets (`httpuv` + `Plotly`/`Chart.js`).\n<h3 id="Rwebsockettopic-18">1. R WebSocket Server (`server.R`)</h3>Streams data to all connected clients every second.\n\nlibrary(httpuv)\nlibrary(jsonlite)\n\n# Global variables\nclients &lt;- list()\ndata_counter &lt;- 0\n\n# WebSocket server setup\napp &lt;- list(\n call = function(req) {\n  list(\n   status = 200L,\n   headers = list("Content-Type" = "text/html"),\n   body = "Real-time Data Streaming Server (R -&gt; Chrome)"\n  )\n },\n onWSOpen = function(ws) {\n  client_id &lt;- paste0("client_", length(clients) + 1)\n  clients[[client_id]] &lt;&lt;- ws\n  cat("Client connected:", client_id, "\n")\n \n  ws$onClose(function() {\n   cat("Client disconnected:", client_id, "\n")\n   clients[[client_id]] &lt;&lt;- NULL\n  })\n }\n)\n\n# Start server\nserver &lt;- startServer("0.0.0.0", 8080, app)\ncat("Server running at ws://localhost:8080\n")\n\n# Function to broadcast data to all clients\nbroadcast_data &lt;- function() {\n data_counter &lt;&lt;- data_counter + 1\n\n # Generate fake streaming data (e.g., sine wave)\n time &lt;- Sys.time()\n value &lt;- sin(data_counter * 0.1) + rnorm(1, sd = 0.1) # Add noise\n\n data &lt;- list(\n  time = format(time, "%H:%M:%OS2"),\n  value = round(value, 3),\n  counter = data_counter\n )\n\n json_data &lt;- toJSON(data, auto_unbox = TRUE)\n\n # Send to all connected clients\n for (client in clients) {\n  client$send(json_data)\n }\n}\n\n# Broadcast data every 1 second\ntimer &lt;- later::later(\n function() {\n  broadcast_data()\n  timer &lt;&lt;- later::later(broadcast_data, 1)\n },\n 1\n)\n\n# Stop server on R interrupt\nonStop(function() {\n stopServer(server)\n cat("Server stopped.\n")\n})\n<h3 id="Rwebsockettopic-19">2. Chrome Client (`client.html`)</h3>Visualizes streaming data with <lg>Chart.js</lg>.\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n &lt;title&gt;Real-time Data Stream&lt;/title&gt;\n &lt;script src="https://cdn.jsdelivr.net/npm/chart.js"&gt;&lt;/script&gt;\n &lt;style&gt;\n  body { font-family: Arial; margin: 20px; }\n  #chart-container { width: 800px; height: 400px; }\n &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n &lt;h1&gt;Real-time Data Stream from R&lt;/h1&gt;\n &lt;div id="chart-container"&gt;\n  &lt;canvas id="dataChart"&gt;&lt;/canvas&gt;\n &lt;/div&gt;\n &lt;div id="latest-data"&gt;&lt;/div&gt;\n\n &lt;script&gt;\n  const ws = new WebSocket("ws://localhost:8080");\n  const ctx = document.getElementById("dataChart").getContext("2d");\n  const maxDataPoints = 50; // Show last 50 points\n  let timeData = [];\n  let valueData = [];\n\n  // Initialize Chart.js\n  const chart = new Chart(ctx, {\n   type: "line",\n   data: {\n    labels: timeData,\n    datasets: [{\n     label: "Live Data from R",\n     data: valueData,\n     borderColor: "rgb(75, 192, 192)",\n     tension: 0.1\n    }]\n   },\n   options: {\n    scales: {\n     x: { title: { display: true, text: "Time" } },\n     y: { title: { display: true, text: "Value" } }\n    }\n   }\n  });\n\n  // Handle WebSocket messages\n  ws.onmessage = function(event) {\n   const data = JSON.parse(event.data);\n   document.getElementById("latest-data").innerHTML = `\n    &lt;p&gt;&lt;strong&gt;Latest:&lt;/strong&gt; ${data.time} | Value: ${data.value} | Count: ${data.counter}&lt;/p&gt;\n   `;\n\n   // Update chart data\n   timeData.push(data.time);\n   valueData.push(data.value);\n\n   // Trim old data\n   if (timeData.length &gt; maxDataPoints) {\n    timeData.shift();\n    valueData.shift();\n   }\n\n   // Update chart\n   chart.data.labels = timeData;\n   chart.data.datasets[0].data = valueData;\n   chart.update();\n  };\n &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n<h3 id="Rwebsockettopic-20">How to Run</h3>1. <lg>Start the R server</lg>:\n source("server.R")\n- The server will broadcast data every second.\n\n2. <lg>Open `client.html` in Chrome</lg>:\n- Drag the file into Chrome or host it locally (e.g., with Python: `python -m http.server 8000`).\n- You’ll see a live-updating chart:\n\n  ![Example output](https://i.imgur.com/JQ8zZlL.gif)\n<h3 id="Rwebsockettopic-21">Key Features</h3>- <lg>Real-time updates</lg>: Data streams from R to Chrome without page reloads.\n- <lg>Dynamic visualization</lg>: Chart.js animates incoming data.\n- <lg>Scalable</lg>: Supports multiple clients (try opening `client.html` in multiple tabs).\n<h3 id="Rwebsockettopic-22">Customize the Data Source</h3>Replace `broadcast_data()` in `server.R` with your own data:\n- <lg>Stock prices</lg>: Use `quantmod::getSymbols()`.\n- <lg>Sensor data</lg>: Read from a serial port with `serial` package.\n- <lg>Database queries</lg>: Poll a database (e.g., `DBI` + `RPostgres`).\n\n# Example: Streaming live stock prices\nbroadcast_data &lt;- function() {\n stock_price &lt;- quantmod::getSymbols("AAPL", auto.assign = FALSE)\n latest_price &lt;- tail(stock_price$AAPL.Close, 1)\n\n data &lt;- list(\n  time = format(Sys.time(), "%H:%M:%OS2"),\n  value = as.numeric(latest_price)\n )\n\n for (client in clients) {\n  client$send(toJSON(data, auto_unbox = TRUE))\n }\n}\n<h3 id="Rwebsockettopic-23">Troubleshooting</h3>- <lg>No data in Chrome?</lg>\n - Check the <lg>WebSocket connection</lg> in Chrome DevTools (`F12 → Network → WS`).\n - Ensure the R server is running (`ws://localhost:8080`).\n\n- <lg>Chart not updating?</lg>\n - Verify `chart.update()` is called in `ws.onmessage`.\n<h3 id="Rwebsockettopic-24">Next Steps</h3>- Add <lg>controls</lg> (e.g., pause/resume stream) with buttons in `client.html`.\n- Use <lg>`shiny`</lg> for a full dashboard (combine `httpuv` + `shiny`).\n\nWant to adapt this for a specific data source (IoT, finance, etc.)?\n',
'<h2>using javascript regex</h2>	how to filter pattern: "target="_blank">..&lt;/a>"\n// Array of strings\nconst stringArray = [\n \'Some text target="_blank">..&lt;/a> more text\',\n \'Another text\',\n \'target="_blank">..&lt;/a> Text to remove\',\n \'No match here\'\n];\n\n// Regular expression pattern to match \'target="_blank">..&lt;/a>\'\nconst pattern = /target="_blank">..<\/a>/;\n\n// Filter the array to remove elements matching the pattern\nconst filteredArray = stringArray.filter(str => !pattern.test(str));\nconsole.log(filteredArray);',
'<h2>regular expression `/&lt;a[^>]*></h2>	In the regular expression `/&lt;a[^>]*>链接&lt;\/a>/g`, the part `a[^>]*` has a specific meaning:\n<h3>Breakdown:</h3>1. <lg>`a`</lg>\n- Matches the literal character `\'a\'`.\n- Since it follows `&lt;`, it helps match the opening `&lt;a` tag.\n\n2. <lg>`[^>]`</lg>\n- `[^...]` is a <lg>negated character class</lg>, meaning it matches any character <lg>except</lg> those inside the brackets.\n- Here, `[^>]` means "match any character that is <lg>not</lg> `>`".\n\n3. <lg>`*`</lg>\n- A quantifier meaning "zero or more" of the preceding element.\n- So `[^>]*` means "match zero or more characters that are <lg>not</lg> `>`".\n<h3>Combined Meaning:</h3>- `a[^>]*` → After matching `&lt;a`, it matches any sequence of characters until a `>` is encountered.\n  - This effectively captures everything inside the `&lt;a ...>` tag (attributes like `href`, `target`, etc.) without including the closing `>`.\n<h3>Example:</h3>For the string:\n`&lt;a href="https://example.com" target="_blank">链接&lt;/a>`\n\n- `a[^>]*` matches:\n  `a href="https://example.com" target="_blank"`\n  (i.e., everything from `a` up to, but not including, the `>`).\n<h3>Why `[^>]*` is Used:</h3>- It ensures we match <lg>all attributes inside the `&lt;a>` tag</lg> without accidentally including other parts of the HTML.\n- If we used `.*` (greedy match), it might incorrectly match too much (e.g., across multiple tags).\n- `[^>]*` is safer because it stops at the first `>`.\n<h3>Full Regex Explanation:</h3>`/&lt;a[^>]*>链接&lt;\/a>/g` →\n"Match `&lt;a`, followed by any characters except `>`, then `>链接&lt;/a>`, globally."\n<h3>JavaScript Example:</h3>const str = \'&lt;a href="https://example.com">链接&lt;/a>&lt;a>其他内容&lt;/a>\';\nconst result = str.replace(/&lt;a[^>]*>链接&lt;\/a>/g, \'\');\nconsole.log(result); // Output: "&lt;a>其他内容&lt;/a>"\nHere, only the `&lt;a ...>链接&lt;/a>` is removed, while `&lt;a>其他内容&lt;/a>` remains.\n',
'<h2>Using the `fs` Package to Control Output</h2>	The Node.js `fs` (File System) module provides several ways to write files.\nHere\'s how to properly use `fs.writeFile()` and its variations to control output files:\n<h3>Basic File Writing</h3>const fs = require(\'fs\');\nconst filename = \'output.html\';\nconst htmlContent = \'&lt;html>&lt;body>&lt;h1>Hello World&lt;/h1>&lt;/body>&lt;/html>\';\n\n// Asynchronous file writing (recommended)\nfs.writeFile(filename, htmlContent, (err) => {\n if (err) {\n  console.error(\'Error writing file:\', err);\n  return;\n }\n console.log(\'File written successfully\');\n});\n<h3>Synchronous Alternative</h3>try {\n fs.writeFileSync(filename, htmlContent);\n console.log(\'File written successfully\');\n} catch (err) {\n console.error(\'Error writing file:\', err);\n}\n<h3>Advanced Options</h3>You can control the file output more precisely with additional options:\nfs.writeFile(\n filename,\n htmlContent,\n {\n  encoding: \'utf8\', // specify encoding\n  flag: \'w\'     // \'w\' for write (default), \'a\' for append\n },\n (err) => {\n  if (err) throw err;\n  console.log(\'Saved!\');\n }\n);\n<h3>Promises-based API (Node.js 10+)</h3>const fs = require(\'fs\').promises;\nasync function writeFile() {\n try {\n  await fs.writeFile(filename, htmlContent);\n  console.log(\'File written successfully\');\n } catch (err) {\n  console.error(\'Error writing file:\', err);\n }\n}\n\nwriteFile();\n<h3>Creating Directories First</h3>If you need to ensure the directory exists first:\nconst path = require(\'path\');\nconst dirname = path.dirname(filename);\n\n// Create directory if it doesn\'t exist\nif (!fs.existsSync(dirname)) {\n fs.mkdirSync(dirname, { recursive: true });\n}\n\n// Then write the file\nfs.writeFile(filename, htmlContent, (err) => {\n // handle result\n});\n\nRemember that `fs.writeFile()` will:\n1. Create the file if it doesn\'t exist\n2. Overwrite the file if it does exist\n3. Require proper error handling for file system operations\n\nFor more control over writing (like appending or streaming), consider `fs.createWriteStream()` or `fs.appendFile()`.\n',
'<h2>JavaScript set object elements unique</h2>	In JavaScript, if you want to make the elements within an object unique, the specific approach depends on whether the object is an array or an ordinary object.\nHere are detailed explanations and examples for both scenarios:\n<h3>1. Making Array Elements Unique</h3>For arrays, you can use methods like `Set` or `filter` to achieve the goal of uniqueness.\n<lg>Example 1: Using `Set` (suitable for primitive data types)</lg>\nconst array = [1, 2, 2, 3, 4, 4, 5];\nconst uniqueArray = [...new Set(array)];\nconsole.log(uniqueArray); // Output: [1, 2, 3, 4, 5]\n<lg>Example 2: Using `filter` (suitable for complex data types like objects)</lg>\nconst array = [\n  { id: 1, name: \'Alice\' },\n  { id: 2, name: \'Bob\' },\n  { id: 1, name: \'Alice\' }\n];\n\nconst uniqueArray = array.filter((value, index, self) => \n  index === self.findIndex(item => item.id === value.id)\n);\n\nconsole.log(uniqueArray);\n// Output: [\n//   { id: 1, name: \'Alice\' },\n//   { id: 2, name: \'Bob\' }\n// ]\n<h3>2. Ensuring Object Property Names Are Unique</h3>In JavaScript, object property names are inherently unique. If you assign a new value to an existing property name, the old value will be overwritten.\n<lg>Example</lg>\nconst obj = {\n  name: \'Alice\',\n  age: 30,\n  name: \'Bob\' // This will overwrite the previous \'name\' property\n};\n\nconsole.log(obj); // Output: { name: \'Bob\', age: 30 }\n<h3>3. Making Values in an Object\'s Properties Unique</h3>If you want the values of properties in an object (for example, array - type values) to be unique, you can process each property individually.\n<lg>Example</lg>\nconst obj = {\n  numbers: [1, 2, 2, 3],\n  letters: [\'a\', \'b\', \'b\', \'c\']\n};\n\n// Process each property to make the array values unique\nObject.keys(obj).forEach(key => {\n  if (Array.isArray(obj[key])) {\n    obj[key] = [...new Set(obj[key])];\n  }\n});\n\nconsole.log(obj);\n// Output: {\n//   numbers: [1, 2, 3],\n//   letters: [\'a\', \'b\', \'c\']\n// }\n<h3>Summary</h3>- When dealing with arrays, `Set` is very effective for removing duplicate primitive values.\n- For arrays containing objects, use the `filter` method in combination with `findIndex` to determine uniqueness based on specific properties.\n- Object property names are always unique; assigning a value to an existing property will overwrite the old value.\n- For object properties with array - type values, you can process each array to make its elements unique.\n',
'<h2>Convert a dataframe in R into a JavaScript object</h2>	1. <o>Convert Dataframe to JSON</o>:\n Use the `jsonlite` package in R to convert the dataframe to JSON format.\n\n2. <o>Write JSON Data to a File</o>:\n Write the JSON data to a JavaScript file that can be included in your HTML file.\n\n<lg>Example</lg>:\n1. <o>Install and Load the `jsonlite` Package</o>:\n If you haven\'t installed the `jsonlite` package yet, you can do so using the following command:\n\n install.packages("jsonlite")\n library(jsonlite)\n2. <o>Create a Sample Data Frame</o>:\n # Sample data frame\n df <- data.frame(\n   Name = c("Alice", "Bob", "Charlie"),\n   Age = c(25, 30, 35),\n   Score = c(80, 85, 90)\n )\n3. <o>Convert Dataframe to JSON</o>:\n Convert the dataframe to JSON format using the `toJSON()` function from the `jsonlite` package:\n\n # Convert dataframe to JSON\n json_data <- toJSON(df, pretty = TRUE)\n4. <o>Write JSON Data to a JavaScript File</o>:\n # Write JSON data to a JavaScript file\n writeLines(paste("var data =", json_data, ";"), "data.js")\n\n This code will write the JSON data to a file named `data.js` with the JavaScript variable `data` containing the JSON object.\n\n5. <o>Create an HTML File</o>:\n &lt;html>\n &lt;head>\n   &lt;script src="data.js">&lt;/script>\n &lt;/head>\n &lt;body>\n   &lt;script>\n   console.log(data); // Access the JSON data in the data variable\n   &lt;/script>\n &lt;/body>\n &lt;/html>\n',
'<h2>WebSocket Communication between R Server and Chrome Client</h2>	Complete example showing how to:\n1. Set up a WebSocket server in R\n2. Continuously collect data from a URL\n3. Process the data and store results in a dataframe\n4. Send the data to a Chrome client\n5. Display the data as a chart in the browser\n\n<h3>R Server Side Code</h3>library(websocket)\nlibrary(httr)\nlibrary(jsonlite)\n\n# Create a dataframe to store results\nresults_df <- data.frame(\n  timestamp = character(),\n  value = numeric(),\n  stringsAsFactors = FALSE\n)\n\n# Function to fetch and process data from URL\nfetch_data <- function() {\n  # Example: Fetch random data from an API\n  # Replace with your actual data source\n  response <- GET("https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd")\n  data <- content(response, "parsed")\n  \n  # Process the data\n  current_time <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")\n  value <- data$bitcoin$usd\n  \n  # Add to dataframe\n  new_row <- data.frame(timestamp = current_time, value = value)\n  results_df <<- rbind(results_df, new_row)\n  \n  # Keep only last 100 entries\n  if (nrow(results_df) > 100) {\n    results_df <<- tail(results_df, 100)\n  }\n  \n  # Return latest data point\n  list(timestamp = current_time, value = value, all_data = results_df)\n}\n\n# WebSocket server\nstart_websocket_server <- function() {\n  ws_server <- WebSocket$new("127.0.0.1", 8080)\n  \n  ws_server$onConnection(function(ws) {\n    cat("Client connected\n")\n    \n    # Send initial data\n    data <- fetch_data()\n    ws$send(toJSON(data))\n    \n    # Set up a timer to send updates every 2 seconds\n    timer <- later::later(\n      function() {\n        if (ws$readyState() == 1) {  # 1 = OPEN\n          data <- fetch_data()\n          ws$send(toJSON(data))\n          timer <<- later::later(repeatable, 2)\n        }\n      },\n      2\n    )\n    \n    repeatable <- function() {\n      if (ws$readyState() == 1) {\n        data <- fetch_data()\n        ws$send(toJSON(data))\n        timer <<- later::later(repeatable, 2)\n      }\n    }\n    \n    ws$onClose(function() {\n      cat("Client disconnected\n")\n      if (!is.null(timer)) later::destroy(timer)\n    })\n  })\n  \n  cat("WebSocket server running on ws://127.0.0.1:8080\n")\n  later::run_now()\n}\n\n# Start the server\nstart_websocket_server()\n<h3>Chrome Client Side Code (HTML/JavaScript)&lt;/h3>\n\nSave this as `client.html` and open it in Chrome:\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n &lt;title>Real-time Data Visualization&lt;/title>\n &lt;script src="https://cdn.jsdelivr.net/npm/chart.js">&lt;/script>\n &lt;style>\n  body { font-family: Arial, sans-serif; margin: 20px; }\n  #chart-container { width: 800px; height: 400px; margin: 20px auto; }\n &lt;/style>\n&lt;/head>\n&lt;body>\n &lt;h1>Real-time Data from R Server&lt;/h1>\n &lt;div id="chart-container">\n  &lt;canvas id="dataChart">&lt;/canvas>\n &lt;/div>\n &lt;div id="latest-value">&lt;/div>\n \n &lt;script>\n  // Connect to WebSocket server\n  const ws = new WebSocket("ws://127.0.0.1:8080");\n  \n  // Chart setup\n  const ctx = document.getElementById(\'dataChart\').getContext(\'2d\');\n  const chart = new Chart(ctx, {\n   type: \'line\',\n   data: {\n    labels: [],\n    datasets: [{\n     label: \'Value from R Server\',\n     data: [],\n     borderColor: \'rgb(75, 192, 192)\',\n     tension: 0.1,\n     fill: false\n    }]\n   },\n   options: {\n    responsive: true,\n    scales: {\n     x: {\n      title: {\n       display: true,\n       text: \'Time\'\n      }\n     },\n     y: {\n      title: {\n       display: true,\n       text: \'Value\'\n      }\n     }\n    }\n   }\n  });\n  \n  // Handle incoming messages\n  ws.onmessage = function(event) {\n   const data = JSON.parse(event.data);\n   \n   // Update latest value display\n   document.getElementById(\'latest-value\').innerHTML = \n    `&lt;p>Latest update at ${data.timestamp}: ${data.value}&lt;/p>`;\n   \n   // Update chart with all historical data\n   const allData = data.all_data;\n   chart.data.labels = allData.map(item => item.timestamp);\n   chart.data.datasets[0].data = allData.map(item => item.value);\n   chart.update();\n  };\n  \n  ws.onerror = function(error) {\n   console.error("WebSocket error:", error);\n  };\n  \n  ws.onclose = function() {\n   console.log("WebSocket connection closed");\n  };\n &lt;/script>\n&lt;/body>\n&lt;/html>\n\n<h3>How to Run This Example</h3>1. Save the R code to a file (e.g., `websocket_server.R`)\n2. Run the R script: `Rscript websocket_server.R`\n3. Save the HTML code to `client.html`\n4. Open `client.html` in Chrome\n5. You should see a real-time chart updating every 2 seconds with data from the R server\n\n<h3>Key Features</h3>\n1. <lg>R Server Side</lg>:\n- Uses `websocket` package to create a WebSocket server\n- Fetches data from a URL (Bitcoin price API in this example)\n- Stores historical data in a dataframe\n- Sends both latest data point and all historical data to client\n\n2. <lg>Chrome Client Side</lg>:\n- Connects to the R server via WebSocket\n- Uses Chart.js to visualize the data\n- Updates the chart in real-time as new data arrives\n\nYou can modify the `fetch_data()` function to collect data from any URL or API you need. The example shows Bitcoin prices, but you can replace it with any data source.\n',
'<h2>Executing a Function on Double-Clicking an Image with jQuery</h2>	$(document).ready(function() {\n  // Attach double-click handler to all images\n  $(\'img\').dblclick(function() {\n    // Get the src attribute of the clicked image\n    var imgSrc = $(this).attr(\'src\');\n    \n    // Execute your function with the image source\n    handleImageDoubleClick(imgSrc);\n  });\n});\n\nfunction handleImageDoubleClick(src) {\n  // Your custom function to handle the double-click\n  console.log(\'Image double-clicked. Source:\', src);\n  \n  // You can do more with the src here, like:\n  // - Store it in a variable\n  // - Send it to a server\n  // - Display it somewhere on the page\n}\n\n## Alternative Version (for dynamically loaded images)\n\nIf your images are loaded dynamically after the page loads, use event delegation:\n\n$(document).ready(function() {\n  $(document).on(\'dblclick\', \'img\', function() {\n    var imgSrc = $(this).attr(\'src\');\n    handleImageDoubleClick(imgSrc);\n  });\n});\n\n## Example with Additional Features\n\nHere\'s a more complete example that also shows the src on the page:\n\n$(document).ready(function() {\n  $(\'img\').dblclick(function() {\n    var imgSrc = $(this).attr(\'src\');\n    \n    // Display the src below the image\n    $(this).after(\'&lt;div class="src-display">Double-clicked: \' + imgSrc + \'&lt;/div>\');\n    \n    // Remove previous displays\n    $(\'.src-display\').not(\':last\').remove();\n    \n    // Or store in an array if you need to track multiple clicks\n    if (typeof window.clickedImages === \'undefined\') {\n      window.clickedImages = [];\n    }\n    window.clickedImages.push(imgSrc);\n  });\n});\n\nRemember to include the jQuery library in your HTML before using these scripts:\n&lt;script src="https://code.jquery.com/jquery-3.6.0.min.js">&lt;/script>\n\n\n',
'<h2>JavaScript Detecting Double Clicks</h2>	Use the `dblclick` event or implement your own double-click detection logic using `click` events with a timing threshold.\n<h3>Method 1: Using the `dblclick` Event</h3>element.addEventListener(\'dblclick\', function(event) {\n  console.log(\'Double click detected!\');\n  // Your double click handling code here\n});\n<h3>Method 2: Manual Detection with Timing</h3>\nThis gives you more control over the timing threshold between clicks:\nlet lastClickTime = 0;\nconst doubleClickThreshold = 300; // milliseconds\n\nelement.addEventListener(\'click\', function(event) {\n  const currentTime = new Date().getTime();\n  \n  if (currentTime - lastClickTime < doubleClickThreshold) {\n    console.log(\'Double click detected!\');\n    // Your double click handling code here\n    lastClickTime = 0; // Reset\n  } else {\n    lastClickTime = currentTime;\n    \n    // Optional: Set timeout to clear if no second click comes\n    setTimeout(() => {\n      if (lastClickTime !== 0 && (new Date().getTime() - lastClickTime) >= doubleClickThreshold) {\n        console.log(\'Single click detected\');\n        // Your single click handling code here\n        lastClickTime = 0;\n      }\n    }, doubleClickThreshold);\n  }\n});\n<h3>Method 3: Combining Both Approaches</h3>let clickCount = 0;\n\nelement.addEventListener(\'click\', function() {\n  clickCount++;\n  \n  if (clickCount === 1) {\n    setTimeout(function() {\n      if (clickCount === 1) {\n        console.log(\'Single click\');\n      } else {\n        console.log(\'Double click\');\n      }\n      clickCount = 0;\n    }, 300); // Adjust timing as needed\n  }\n});\n\nelement.addEventListener(\'dblclick\', function() {\n  clickCount = 0;\n  console.log(\'Double click via dblclick event\');\n});\n<h3>Notes:</h3>1. The default double-click speed is system-dependent but typically around 500ms.\n2. For most cases, using the native `dblclick` event is simplest and recommended.\n3. The manual approach gives you more control over timing and can help distinguish between single and double clicks more precisely.\n4. Remember to prevent unwanted behavior by calling `event.preventDefault()` if needed.\n\n\n\n',
'<h2>JavaScript Loading and Saving Objects in localStorage</h2>	<h3>Saving an Object to localStorage</h3>const saveObjectToLocalStorage = (key, obj) => {\n  try {\n    const serializedObj = JSON.stringify(obj);\n    localStorage.setItem(key, serializedObj);\n    console.log(`Object saved to localStorage with key: ${key}`);\n  } catch (error) {\n    console.error(\'Error saving object to localStorage:\', error);\n  }\n};\n\n// Example usage:\nconst user = {\n  id: 1,\n  name: \'John Doe\',\n  preferences: {\n    theme: \'dark\',\n    notifications: true\n  }\n};\n\nsaveObjectToLocalStorage(\'userData\', user);\n<h3>Loading an Object from localStorage</h3>const loadObjectFromLocalStorage = (key) => {\n  try {\n    const serializedObj = localStorage.getItem(key);\n    if (serializedObj === null) {\n      console.log(`No object found in localStorage with key: ${key}`);\n      return null;\n    }\n    return JSON.parse(serializedObj);\n  } catch (error) {\n    console.error(\'Error loading object from localStorage:\', error);\n    return null;\n  }\n};\n\n// Example usage:\nconst loadedUser = loadObjectFromLocalStorage(\'userData\');\nconsole.log(loadedUser);\n<h3>Complete Example with Helper Class</h3>class LocalStorageManager {\n  static save(key, value) {\n    try {\n      const serialized = JSON.stringify(value);\n      localStorage.setItem(key, serialized);\n    } catch (error) {\n      console.error(\'LocalStorage save error:\', error);\n    }\n  }\n\n  static load(key) {\n    try {\n      const serialized = localStorage.getItem(key);\n      return serialized ? JSON.parse(serialized) : null;\n    } catch (error) {\n      console.error(\'LocalStorage load error:\', error);\n      return null;\n    }\n  }\n\n  static remove(key) {\n    localStorage.removeItem(key);\n  }\n\n  static clear() {\n    localStorage.clear();\n  }\n}\n\n// Usage:\nconst gameState = {\n  level: 5,\n  score: 1200,\n  inventory: [\'sword\', \'shield\', \'potion\']\n};\n\n// Save\nLocalStorageManager.save(\'gameState\', gameState);\n\n// Load\nconst savedGame = LocalStorageManager.load(\'gameState\');\nconsole.log(savedGame);\n\n// Remove\n// LocalStorageManager.remove(\'gameState\');\n\n// Clear all\n// LocalStorageManager.clear();\n<h3>Important Notes</h3>\n1. **Storage Limit**: localStorage is typically limited to about 5MB per origin.\n\n2. **Data Persistence**: Data persists even after the browser is closed.\n\n3. **Synchronous**: localStorage operations are synchronous and can block the main thread with large data.\n\n4. **Security**: Don\'t store sensitive information as it\'s accessible via JavaScript.\n\n5. **Complex Objects**: Functions and Symbols in your objects will be lost during JSON serialization.\n\nFor more complex needs, consider IndexedDB which can handle larger amounts of structured data.\n\n\n\n\n',
'<h2>JavaScript Adding Strings to Dynamic Properties with String Arrays</h2>	1. Add strings to an object with dynamic property names\n2. Handle cases where the properties don\'t exist yet\n3. Store multiple strings in an array for each property\n<h3>Method 1: Initialize Array if Property Doesn\'t Exist (Basic)</h3>const obj = {\n  existingProp: [\'value1\'],\n};\n\nconst dynamicKey = \'newStrings\';\n\n// Add string to dynamic property (initialize array if needed)\nif (!obj[dynamicKey]) {\n  obj[dynamicKey] = []; // Initialize as empty array if doesn\'t exist\n}\nobj[dynamicKey].push(\'Hello\');\nobj[dynamicKey].push(\'World\');\n\nconsole.log(obj);\n// {\n//   existingProp: [\'value1\'],\n//   newStrings: [\'Hello\', \'World\']\n// }\n<h3>Method 2: Using Nullish Coalescing Assignment (ES2020+)</h3>const obj = {\n  existingProp: [\'existing string\'],\n};\n\nconst dynamicKey = \'dynamicProp\';\n\n// Initialize if doesn\'t exist, then add strings\nobj[dynamicKey] ??= []; // Create array if property doesn\'t exist\nobj[dynamicKey].push(\'First string\');\nobj[dynamicKey].push(\'Second string\');\n\nconsole.log(obj);\n// {\n//   existingProp: [\'existing string\'],\n//   dynamicProp: [\'First string\', \'Second string\']\n// }\n<h3>Method 3: Function to Handle Multiple Adds</h3>function addToStringVector(obj, propName, ...strings) {\n  obj[propName] ??= []; // Initialize if doesn\'t exist\n  obj[propName].push(...strings); // Add all strings at once\n  return obj;\n}\n\n// Usage:\nconst myObj = { existing: [\'old value\'] };\naddToStringVector(myObj, \'newProp\', \'first\', \'second\', \'third\');\naddToStringVector(myObj, \'existing\', \'additional value\');\n\nconsole.log(myObj);\n// {\n//   existing: [\'old value\', \'additional value\'],\n//   newProp: [\'first\', \'second\', \'third\']\n// }\n<h3>Method 4: Handling Nested Objects with Dynamic Paths</h3>function addToNestedStringVector(obj, path, ...strings) {\n  const keys = Array.isArray(path) ? path : path.split(\'.\');\n  let current = obj;\n  \n  // Traverse or create the path\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    current[key] ??= {};\n    current = current[key];\n  }\n  \n  const lastKey = keys[keys.length - 1];\n  current[lastKey] ??= [];\n  current[lastKey].push(...strings);\n  \n  return obj;\n}\n\n// Usage:\nconst nestedObj = { level1: { existing: [\'value\'] } };\naddToNestedStringVector(nestedObj, \'level1.newArray\', \'a\', \'b\');\naddToNestedStringVector(nestedObj, [\'level2\', \'dynamicProp\'], \'x\', \'y\');\n\nconsole.log(nestedObj);\n// {\n//   level1: {\n//     existing: [\'value\'],\n//     newArray: [\'a\', \'b\']\n//   },\n//   level2: {\n//     dynamicProp: [\'x\', \'y\']\n//   }\n// }\n<h3>Method 5: Using Proxy for Automatic Initialization</h3>For advanced use cases where you want automatic array creation:\n\nfunction createAutoVectorObject() {\n  return new Proxy({}, {\n    get(target, prop) {\n      if (!(prop in target)) {\n        target[prop] = []; // Auto-initialize with empty array\n      }\n      return target[prop];\n    }\n  });\n}\n\n// Usage:\nconst autoObj = createAutoVectorObject();\nautoObj.existing.push(\'first\'); // No need to initialize\nautoObj[\'dynamic-prop\'].push(\'value1\', \'value2\');\n\nconsole.log(autoObj);\n// {\n//   existing: [\'first\'],\n//   \'dynamic-prop\': [\'value1\', \'value2\']\n// }\n<h3>Important Considerations:</h3>1. **Duplicate Handling**: The above methods allow duplicates. If you need unique values, add a check:\n      if (!obj[propName].includes(newString)) {\n     obj[propName].push(newString);\n   }\n\n2. **Type Safety**: Ensure the property remains an array:\n      if (obj[propName] && !Array.isArray(obj[propName])) {\n     throw new Error(`Property ${propName} is not an array`);\n   }\n\n3. **Performance**: For frequent operations on large arrays, consider using a Set instead and convert to array when needed.\n\nChoose the method that best fits your specific requirements and JavaScript version support.\n\n\n\n\n\n\n',
'<h2>Adding a String to a Nested Object with Dynamic Property Names in JavaScript</h2>	\nto add a string to a nested object where:\n1. The property names are dynamic (not known in advance)\n2. The nested structure might not exist yet\n3. You need to handle multiple levels of nesting\n\n<h3>Method 1: Using Optional Chaining and Nullish Coalescing</h3>const obj = {\n  existingProp: \'value\',\n  // Note: nestedObj doesn\'t exist initially\n};\n\nconst dynamicParentKey = \'nestedObj\';\nconst dynamicChildKey = \'newString\';\nconst valueToAdd = \'Hello World\';\n\n// Safely add the property\nobj[dynamicParentKey] ??= {}; // Create parent if doesn\'t exist\nobj[dynamicParentKey][dynamicChildKey] = valueToAdd;\n\nconsole.log(obj);\n// {\n//   existingProp: \'value\',\n//   nestedObj: { newString: \'Hello World\' }\n// }\n\n<h3>Method 2: Recursive Approach for Deep Nesting</h3>function setNestedValue(obj, keys, value) {\n  let current = obj;\n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    current[key] = current[key] || {};\n    current = current[key];\n  }\n  current[keys[keys.length - 1]] = value;\n  return obj;\n}\n\n// Usage:\nconst myObject = { existing: \'value\' };\nconst path = [\'level1\', \'level2\', \'dynamicProp\'];\nconst stringValue = \'Nested Hello World\';\n\nsetNestedValue(myObject, path, stringValue);\n\nconsole.log(myObject);\n// {\n//   existing: \'value\',\n//   level1: { level2: { dynamicProp: \'Nested Hello World\' } }\n// }\n\n<h3>Method 4: Handling Arrays in the Path</h3>function deepSet(obj, path, value) {\n  const keys = Array.isArray(path) ? path : path.split(\'.\');\n  let current = obj;\n  \n  for (let i = 0; i < keys.length - 1; i++) {\n    const key = keys[i];\n    if (!current[key] || typeof current[key] !== \'object\') {\n      current[key] = {};\n    }\n    current = current[key];\n  }\n  \n  current[keys[keys.length - 1]] = value;\n  return obj;\n}\n\n// Usage:\nconst target = {};\ndeepSet(target, \'a.b.c\', \'Deep value\');\ndeepSet(target, [\'x\', \'y\', \'z\'], \'Array path value\');\n\nconsole.log(target);\n// {\n//   a: { b: { c: \'Deep value\' } },\n//   x: { y: { z: \'Array path value\' } }\n// }\n\n\n',
'<h2>Extracting Images and Videos from Tumblr</h2>	getting 0 media items when scraping the Tumblr archive page,\nit\'s likely because:\n1. The content is loaded dynamically after the initial page load (common with Tumblr\'s infinite scroll)\n2. The selectors aren\'t matching the actual elements\n3. There might be anti-scraping measures in place\n\n<h3>improved version</h3>const puppeteer = require(\'puppeteer\');\nconst fs = require(\'fs\');\n\nasync function scrapeTumblr(url) {\n  const browser = await puppeteer.launch({\n    headless: false, // Set to true after testing\n    args: [\'--no-sandbox\', \'--disable-setuid-sandbox\']\n  });\n  \n  try {\n    const page = await browser.newPage();\n    await page.setUserAgent(\'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\');\n    \n    console.log(`Navigating to ${url}...`);\n    await page.goto(url, {\n      waitUntil: \'networkidle2\',\n      timeout: 60000\n    });\n\n    // Wait longer and use more specific selectors\n    await page.waitForTimeout(3000); // Initial wait\n    \n    // Scroll multiple times to load all content\n    console.log(\'Scrolling to load content...\');\n    for (let i = 0; i < 10; i++) {\n      await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));\n      await page.waitForTimeout(2000);\n    }\n\n    // Use more specific selectors for Tumblr\n    const media = await page.evaluate(() => {\n      const items = [];\n      \n      // Get images - Tumblr often uses specific classes\n      document.querySelectorAll(\'img[src*="media.tumblr.com"], img[src*="assets.tumblr.com"]\').forEach(img => {\n        if (img.src && !img.src.startsWith(\'data:\')) {\n          items.push({\n            type: \'image\',\n            url: img.src,\n            alt: img.alt || \'\'\n          });\n        }\n      });\n      \n      // Get videos - Tumblr video elements\n      document.querySelectorAll(\'video source\').forEach(source => {\n        if (source.src) {\n          const video = source.closest(\'video\');\n          items.push({\n            type: \'video\',\n            url: source.src,\n            poster: video?.poster || \'\'\n          });\n        }\n      });\n\n      // Also check for iframes (embedded content)\n      document.querySelectorAll(\'iframe\').forEach(iframe => {\n        const src = iframe.src;\n        if (src && (src.includes(\'youtube.com\') || src.includes(\'vimeo.com\'))) {\n          items.push({\n            type: \'embedded\',\n            url: src\n          });\n        }\n      });\n      \n      return items;\n    });\n\n    // Filter duplicates and clean URLs\n    const uniqueMedia = [...new Map(media.map(item => [item.url, item])).values()]\n      .map(item => {\n        // Get higher resolution images when possible\n        if (item.type === \'image\' && item.url.includes(\'media.tumblr.com\')) {\n          item.originalUrl = item.url\n            .replace(/_\d+\.(jpg|png|gif)$/, \'_1280.$1\')\n            .replace(/\/s\d+x\d+\//, \'/\');\n        }\n        return item;\n      });\n\n    console.log(`Found ${uniqueMedia.length} media items:`);\n    console.log(uniqueMedia);\n    \n    // Save results\n    const timestamp = new Date().toISOString().replace(/[:.]/g, \'-\');\n    const filename = `tumblr-media-${timestamp}.json`;\n    fs.writeFileSync(filename, JSON.stringify(uniqueMedia, null, 2));\n    console.log(`Results saved to ${filename}`);\n    \n    return uniqueMedia;\n  } catch (error) {\n    console.error(\'Error during scraping:\', error);\n  } finally {\n    await browser.close();\n  }\n}\n\n// Run the scraper\nconst tumblrUrl = \'https://sassydw.tumblr.com/archive\';\nscrapeTumblr(tumblrUrl).then(media => {\n  console.log(\'Scraping completed!\');\n}).catch(err => {\n  console.error(\'Scraping failed:\', err);\n});\n<h3>Key Improvements:</h3>1. <lg>Changed to non-headless mode initially</lg> (`headless: false`) so you can see what\'s happening\n2. <lg>Added longer waits and more scrolls</lg> to ensure all content loads\n3. <lg>More specific selectors</lg> targeting Tumblr\'s image and video elements\n4. <lg>Added iframe detection</lg> for embedded content\n5. <lg>Better URL cleaning</lg> to get higher resolution images\n6. <lg>Improved duplicate removal</lg> using a Map\n\n### Additional Troubleshooting Tips:\n\n1. <lg>Check the visible browser</lg>: With `headless: false`, you can see if content is actually loading\n2. <lg>Add console logs</lg>: Add `console.log`s in the evaluate function to debug what\'s being found\n3. <lg>Try different wait strategies</lg>: Sometimes `networkidle0` works better than `networkidle2`\n4. <lg>Check for errors</lg>: Tumblr might show a "Consent" banner that blocks content\n5. <lg>Try mobile user agent</lg>: Sometimes sites serve simpler content to mobile\n\nIf you\'re still getting zero items, you might need to:\n- Handle cookie consent banners\n- Wait for specific elements to appear\n- Use different selectors based on the blog\'s specific theme\n',
'<h2>scrollToBottom</h2>	window.addEventListener(\'load\', function() {\n // Function to scroll to bottom\n const scrollToBottom = () => {\n  const height = Math.max(\n   document.body.scrollHeight,\n   document.documentElement.scrollHeight\n  );\n  window.scrollTo(0, height);\n };\n \n // Scroll immediately\n scrollToBottom();\n \n // Scroll again after short delays to catch any dynamic content\n setTimeout(scrollToBottom, 100);\n setTimeout(scrollToBottom, 500);\n setTimeout(scrollToBottom, 1000);\n \n console.log(\'Auto-scroll to bottom activated\');\n});\n',
'<h2>to fix the issue: Uncaught ReferenceError: inclTxt is not defined</h2>	if(inclTxt != ""){\n  markerName = markerName + ":contains(\'" + inclTxt + "\')"\n  console.log("markerName: ", markerName)\n}\n\nCheck if variable exists first:\nif(typeof inclTxt !== \'undefined\' && inclTxt != ""){\n  markerName = markerName + ":contains(\'" + inclTxt + "\')"\n  console.log("markerName: ", markerName)\n}\n',
'<h2>JavaScript 数组存储任意类型的元素</h2>	JavaScript 数组可以存储任意类型的元素，包括字符串、对象、甚至其他数组。你也可以在一个对象中存储数组作为其属性值。以下是如何正确地构造这样的数据结构，并访问其中的不同元素。\n例子：\n\nvar t2i = [\n  // 字符串元素\n  \'色彩斑斓, 深邃色彩, 以浓郁鲜艳的色调为主, 晶瑩剔透, 增強對比度,銳度, 多层次, 颜色层次丰富\',\n  \'逆光, 昏暗光线, 营造庄严神秘氛围\',\n  \n  // 对象元素\n  {\n    // 在对象里存储一个字符串数组\n    lightConditions: [\'逆光\', \'昏暗光线\'],\n    effect: \'营造庄严神秘氛围\'\n  }\n];\n\n// 访问数组中的字符串元素\nconsole.log(t2i[0]); // 第一个字符串\nconsole.log(t2i[1]); // 第二个字符串\n\n// 访问数组中的对象及其内部元素\nconsole.log(t2i[2].lightConditions); // 输出 ["逆光", "昏暗光线"]\nconsole.log(t2i[2].lightConditions[0]); // 输出 "逆光"\nconsole.log(t2i[2].effect); // 输出 "营造庄严神秘氛围"\n',
'<h2>using javascript and sessionStorage to pass data to another webpage</h2>	\nfunction setData() {\n  // Store data in sessionStorage\n  sessionStorage.setItem(\'myData\', \'Hello from Page 1!\');\n  // Redirect to the next page\n  window.location.href = \'receiver.html\';\n}\n\nreceiver.html\n// Get data from sessionStorage\nconst receivedData = sessionStorage.getItem(\'myData\');\n\nif (receivedData) {\n  document.getElementById(\'display\').textContent = receivedData;\n  console.log(\'Received data:\', receivedData);\n  \n  // Optional: Clear the data after use\n  // sessionStorage.removeItem(\'myData\');\n} else {\n  document.getElementById(\'display\').textContent = \'No data received\';\n}\n',
'<h2>bluetooth protocols</h2>	<div id="bluetoothprotocolstoc" class="toc"><a href="#bluetoothprotocolstopic-0" target="_self">Web Bluetooth API Basics</a><br><a href="#bluetoothprotocolstopic-1" target="_self"> 1. Check Bluetooth Availability</a><br><a href="#bluetoothprotocolstopic-2" target="_self"> 2. Request Device and Discover Services (Protocols)</a><br><a href="#bluetoothprotocolstopic-3" target="_self"> 3. Common Bluetooth Protocols/Profiles and Their Service UUIDs</a><br><a href="#bluetoothprotocolstopic-4" target="_self"> 4. Browser Support and Limitations</a><br><a href="#bluetoothprotocolstopic-5" target="_self"> 5. Complete Example with UI</a><br><a href="#bluetoothprotocolstopic-6" target="_self">Alternative Approaches</a><br><a href="#bluetoothprotocolstopic-7" target="_self">Summary</a><br></div></center><br><br>\n<pre>Bluetooth devices support various protocols (profiles), but in JavaScript/Web Bluetooth API, you can\'t directly enumerate all available protocols on the current device. Instead, you can discover devices and see what services (which correspond to specific protocols/profiles) they offer.\n\n<h3 id="bluetoothprotocolstopic-0">Web Bluetooth API Basics</h3>\n\nThe Web Bluetooth API allows you to connect to Bluetooth Low Energy (BLE) devices and discover their services/characteristics.\n<o id="bluetoothprotocolstopic-1"> 1. Check Bluetooth Availability</o>\n\n// Check if Web Bluetooth is supported\nif (!navigator.bluetooth) {\n  console.log(\'Web Bluetooth API is not supported in this browser.\');\n  console.log(\'Use Chrome, Edge, Opera, or Android WebView.\');\n} else {\n  console.log(\'Web Bluetooth is supported!\');\n}\n<o id="bluetoothprotocolstopic-2"> 2. Request Device and Discover Services (Protocols)</o>\n\nasync function discoverBluetoothServices() {\n  try {\n    // Request a Bluetooth device with some common services\n    const device = await navigator.bluetooth.requestDevice({\n      acceptAllDevices: true,\n      optionalServices: [\n        \'battery_service\',\n        \'device_information\',\n        \'heart_rate\',\n        \'cycling_speed_and_cadence\',\n        // Add more service UUIDs as needed\n      ]\n    });\n\n    console.log(\'Device Name:\', device.name);\n    console.log(\'Device ID:\', device.id);\n\n    // Connect to the GATT server\n    const server = await device.gatt.connect();\n    \n    // Get all primary services\n    const services = await server.getPrimaryServices();\n    \n    console.log(\'\nAvailable Services (Protocols):\');\n    for (const service of services) {\n      console.log(`- ${service.uuid}: ${service.uuid.startsWith(\'0x\') ? \n        getServiceName(service.uuid) : \'Unknown Service\'}`);\n      \n      // Get characteristics for each service\n      const characteristics = await service.getCharacteristics();\n      characteristics.forEach(char =&gt; {\n        console.log(`  └─ Characteristic: ${char.uuid}`);\n      });\n    }\n    \n    // Don\'t forget to disconnect when done\n    // server.disconnect();\n    \n  } catch (error) {\n    console.error(\'Error:\', error);\n  }\n}\n\n// Helper function to map UUIDs to service names\nfunction getServiceName(uuid) {\n  const serviceMap = {\n    \'0x1800\': \'Generic Access\',\n    \'0x1801\': \'Generic Attribute\',\n    \'0x1802\': \'Immediate Alert\',\n    \'0x1803\': \'Link Loss\',\n    \'0x1804\': \'Tx Power\',\n    \'0x1805\': \'Current Time Service\',\n    \'0x1806\': \'Reference Time Update Service\',\n    \'0x1807\': \'Next DST Change Service\',\n    \'0x1808\': \'Glucose\',\n    \'0x1809\': \'Health Thermometer\',\n    \'0x180a\': \'Device Information\',\n    \'0x180d\': \'Heart Rate\',\n    \'0x180f\': \'Battery Service\',\n    \'0x1810\': \'Blood Pressure\',\n    \'0x1811\': \'Alert Notification Service\',\n    \'0x1812\': \'Human Interface Device\',\n    \'0x1813\': \'Scan Parameters\',\n    \'0x1814\': \'Running Speed and Cadence\',\n    \'0x1815\': \'Automation IO\',\n    \'0x1816\': \'Cycling Speed and Cadence\',\n    \'0x1818\': \'Cycling Power\',\n    \'0x1819\': \'Location and Navigation\',\n    \'0x181a\': \'Environmental Sensing\',\n    \'0x181b\': \'Body Composition\',\n    \'0x181c\': \'User Data\',\n    \'0x181d\': \'Weight Scale\',\n    \'0x181e\': \'Bond Management Service\',\n    \'0x181f\': \'Continuous Glucose Monitoring\',\n    \'0x1820\': \'Internet Protocol Support Service\',\n    \'0x1821\': \'Indoor Positioning\',\n    \'0x1822\': \'Pulse Oximeter Service\',\n    \'0x1823\': \'HTTP Proxy\',\n    \'0x1824\': \'Transport Discovery\',\n    \'0x1825\': \'Object Transfer Service\',\n    \'0x1826\': \'Fitness Machine\',\n    \'0x1827\': \'Mesh Provisioning Service\',\n    \'0x1828\': \'Mesh Proxy Service\',\n    \'0x1829\': \'Reconnection Configuration\',\n    \'0x183a\': \'Insulin Delivery\',\n    \'0x183b\': \'Binary Sensor\',\n    \'0x183c\': \'Emergency Configuration\',\n    \'0x183d\': \'Authorization Control\',\n    \'0x183e\': \'Physical Activity Monitor\',\n    \'0x183f\': \'Elapsed Time Service\',\n    \'0x1840\': \'Generic Health Sensor\',\n    \'0x1841\': \'Audio Input Control\',\n    \'0x1842\': \'Volume Control\',\n    \'0x1843\': \'Volume Offset Control\',\n    \'0x1844\': \'Coordinated Set Identification Service\',\n    \'0x1845\': \'Device Time\',\n    \'0x1846\': \'Media Control Service\',\n    \'0x1847\': \'Generic Media Control Service\',\n    \'0x1848\': \'Constant Tone Extension\',\n    \'0x1849\': \'Telephone Bearer Service\',\n    \'0x184a\': \'Generic Telephone Bearer Service\',\n    \'0x184b\': \'Microphone Control\',\n    \'0x184c\': \'Audio Stream Control Service\',\n    \'0x184d\': \'Broadcast Audio Scan Service\',\n    \'0x184e\': \'Published Audio Capabilities Service\',\n    \'0x184f\': \'Basic Audio Announcement Service\',\n    \'0x1850\': \'Broadcast Audio Announcement Service\',\n    \'0x1851\': \'Common Audio Service\',\n    \'0x1852\': \'Hearing Access Service\',\n    \'0x1853\': \'Telephony and Media Audio Service\',\n    \'0x1854\': \'Public Broadcast Announcement Service\',\n  };\n  \n  return serviceMap[uuid.toLowerCase()] || \'Unknown Service\';\n}\n<o id="bluetoothprotocolstopic-3"> 3. Common Bluetooth Protocols/Profiles and Their Service UUIDs</o>\n\nHere are some common Bluetooth profiles and their corresponding service UUIDs:\n\nconst bluetoothProfiles = {\n  // GATT Services (BLE)\n  \'Generic Access\': \'00001800-0000-1000-8000-00805f9b34fb\',\n  \'Generic Attribute\': \'00001801-0000-1000-8000-00805f9b34fb\',\n  \'Heart Rate\': \'0000180d-0000-1000-8000-00805f9b34fb\',\n  \'Battery Service\': \'0000180f-0000-1000-8000-00805f9b34fb\',\n  \'Device Information\': \'0000180a-0000-1000-8000-00805f9b34fb\',\n  \'Human Interface Device (HID)\': \'00001812-0000-1000-8000-00805f9b34fb\',\n  \'Running Speed and Cadence\': \'00001814-0000-1000-8000-00805f9b34fb\',\n  \'Cycling Speed and Cadence\': \'00001816-0000-1000-8000-00805f9b34fb\',\n  \'Cycling Power\': \'00001818-0000-1000-8000-00805f9b34fb\',\n  \n  // Classic Bluetooth profiles (not directly accessible via Web Bluetooth)\n  // These typically require different APIs or platform-specific access\n  \'A2DP\': \'Audio Distribution Profile\',  // For audio streaming\n  \'AVRCP\': \'Audio/Video Remote Control Profile\',\n  \'HFP\': \'Hands-Free Profile\',\n  \'HSP\': \'Headset Profile\',\n  \'PBAP\': \'Phone Book Access Profile\',\n  \'MAP\': \'Message Access Profile\',\n  \'SPP\': \'Serial Port Profile\',\n  \'HID\': \'Human Interface Device Profile\',\n  \'PAN\': \'Personal Area Networking\',\n  \'FTP\': \'File Transfer Profile\',\n  \'OPP\': \'Object Push Profile\',\n};\n\n// Function to scan for devices with specific profiles\nasync function scanForProfiles() {\n  const profileServices = {\n    \'Heart Rate Monitor\': [\'heart_rate\'],\n    \'Fitness Device\': [\'heart_rate\', \'cycling_speed_and_cadence\', \'cycling_power\'],\n    \'Smart Watch\': [\'battery_service\', \'device_information\', \'heart_rate\'],\n    \'Bluetooth HID\': [\'human_interface_device\'],\n  };\n  \n  for (const [deviceType, services] of Object.entries(profileServices)) {\n    console.log(`\nLooking for ${deviceType}...`);\n    \n    try {\n      const device = await navigator.bluetooth.requestDevice({\n        filters: [{ services }],\n        optionalServices: services\n      });\n      \n      console.log(`Found ${deviceType}: ${device.name}`);\n      \n      // Connect and verify services\n      const server = await device.gatt.connect();\n      const deviceServices = await server.getPrimaryServices();\n      \n      console.log(`Available services on ${device.name}:`);\n      deviceServices.forEach(service =&gt; {\n        console.log(`- ${service.uuid}`);\n      });\n      \n      server.disconnect();\n      \n    } catch (error) {\n      if (error.name !== \'NotFoundError\') {\n        console.error(`Error scanning for ${deviceType}:`, error);\n      }\n    }\n  }\n}\n<o id="bluetoothprotocolstopic-4"> 4. Browser Support and Limitations</o>\n\n**Important Limitations:**\n1. **Web Bluetooth only works with BLE (Bluetooth Low Energy) devices**\n2. **Cannot access Classic Bluetooth profiles** (A2DP, HFP, SPP, etc.)\n3. **Requires HTTPS** (except localhost for development)\n4. **User interaction required** - must be triggered by a user gesture (click)\n5. **Browser support** - primarily Chrome/Edge/Opera\n<o id="bluetoothprotocolstopic-5"> 5. Complete Example with UI</o>\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;Bluetooth Protocol Scanner&lt;/title&gt;\n  &lt;style&gt;\n    body { font-family: Arial, sans-serif; margin: 20px; }\n    button { padding: 10px 15px; margin: 5px; }\n    #results { margin-top: 20px; }\n    .device { border: 1px solid #ccc; padding: 10px; margin: 10px 0; }\n    .service { margin-left: 20px; color: #666; }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Bluetooth Protocol Scanner&lt;/h1&gt;\n  \n  &lt;button onclick="scanBluetooth()"&gt;Scan Bluetooth Devices&lt;/button&gt;\n  &lt;button onclick="scanForProfiles()"&gt;Scan by Profile Type&lt;/button&gt;\n  \n  &lt;div id="results"&gt;&lt;/div&gt;\n  \n  &lt;script&gt;\n    async function scanBluetooth() {\n      const results = document.getElementById(\'results\');\n      results.innerHTML = \'&lt;p&gt;Scanning for Bluetooth devices...&lt;/p&gt;\';\n      \n      try {\n        const device = await navigator.bluetooth.requestDevice({\n          acceptAllDevices: true,\n          optionalServices: [\'battery_service\', \'device_information\']\n        });\n        \n        results.innerHTML = `\n          &lt;div class="device"&gt;\n            &lt;h3&gt;Device Found: ${device.name || \'Unnamed Device\'}&lt;/h3&gt;\n            &lt;p&gt;ID: ${device.id}&lt;/p&gt;\n            &lt;p&gt;Connected via GATT: ${device.gatt.connected}&lt;/p&gt;\n          &lt;/div&gt;\n        `;\n        \n        // Connect and get services\n        const server = await device.gatt.connect();\n        const services = await server.getPrimaryServices();\n        \n        let servicesHTML = \'&lt;h4&gt;Available Services:&lt;/h4&gt;\';\n        for (const service of services) {\n          servicesHTML += `\n            &lt;div class="service"&gt;\n              &lt;strong&gt;${service.uuid}&lt;/strong&gt;\n              ${getServiceName(service.uuid) ? \n                ` - ${getServiceName(service.uuid)}` : \'\'}\n            &lt;/div&gt;\n          `;\n        }\n        \n        results.innerHTML += servicesHTML;\n        \n      } catch (error) {\n        results.innerHTML = `&lt;p&gt;Error: ${error.message}&lt;/p&gt;`;\n      }\n    }\n    \n    // Include getServiceName() function from above\n    function getServiceName(uuid) {\n      // ... (use the function from above)\n    }\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n<h3 id="bluetoothprotocolstopic-6">Alternative Approaches</h3>\n\nFor **Classic Bluetooth profiles**, you might need:\n\n1. **Platform-specific APIs** (Cordova, React Native plugins)\n2. **Native desktop applications** using platform APIs\n3. **Chrome Extensions** with `chrome.bluetooth` API\n4. **Node.js** with libraries like `noble` or `bluetooth-hci-socket`\n\n**Chrome Extension Example** (has more access):\n// In a Chrome Extension with bluetooth permission\nchrome.bluetooth.getAdapterState(function(adapter) {\n  console.log(\'Adapter address:\', adapter.address);\n  console.log(\'Adapter name:\', adapter.name);\n  console.log(\'Adapter discoverable:\', adapter.discoverable);\n});\n\nchrome.bluetooth.getDevices(function(devices) {\n  devices.forEach(device =&gt; {\n    console.log(\'Device:\', device.name, device.type);\n  });\n});\n\n<h3 id="bluetoothprotocolstopic-7">Summary</h3>\n\n1. **Web Bluetooth API** only exposes BLE services, not all Bluetooth protocols\n2. You can discover **GATT services** which correspond to specific BLE profiles\n3. **Classic Bluetooth profiles** (A2DP, HFP, SPP) are not accessible via Web Bluetooth\n4. Always handle permissions and user interactions properly\n5. Check browser compatibility before implementing\n\nThe key is to understand that in the Web Bluetooth context, "protocols" are represented as **services** that you can discover once connected to a device.\n',
'<h2>LocalStorage Array Manager</h2>	Load an array from localStorage on initialization, and to save array content back to localStorage.\n\nSix functions created:\n- show status messages\n- display the array\n- load array from localStorage\n- save array to localStorage\n- add a random item to the array\n- clear the array\n\n// Initialize array with default value or from localStorage\nlet historyArray = [];\nconst STORAGE_KEY = \'historyArrayData\';\n\n// Function to show status messages\nfunction showStatus(message, type = \'info\') {\n  statusMessage.textContent = message;\n  statusMessage.className = `status ${type}`;\n  statusMessage.style.display = \'block\';\n  \n  // Auto-hide after 3 seconds\n  setTimeout(() => {\n    statusMessage.style.display = \'none\';\n  }, 3000);\n}\n\n// Function to display the array\nfunction displayArray() {\n  if (historyArray.length === 0) {\n    arrayDisplay.innerHTML = \'<span class="empty-array">Array is empty. Add some items using the "Add Random Item" button.</span>\';\n  } else {\n    arrayDisplay.textContent = JSON.stringify(historyArray, null, 2);\n  }\n}\n\n// Function to load array from localStorage\nfunction loadArrayFromLocalStorage() {\n  try {\n    const storedData = localStorage.getItem(STORAGE_KEY);\n    \n    if (storedData) {\n        historyArray = JSON.parse(storedData);\n        showStatus(`Array loaded from localStorage with ${historyArray.length} items`, \'success\');\n    } else {\n        // Initialize with default data if nothing is stored\n        historyArray = [\n          "First item loaded from default",\n          "Second item",\n          "Third item"\n        ];\n        showStatus(\'No data found in localStorage. Using default array.\', \'info\');\n    }\n  } catch (error) {\n    console.error(\'Error loading from localStorage:\', error);\n    historyArray = ["Error loading data"];\n    showStatus(\'Error loading data from localStorage. Using empty array.\', \'error\');\n  }\n  \n  displayArray();\n}\n\n// Function to save array to localStorage\nfunction saveArrayToLocalStorage() {\n  try {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(historyArray));\n    showStatus(`Array saved to localStorage with ${historyArray.length} items`, \'success\');\n  } catch (error) {\n    console.error(\'Error saving to localStorage:\', error);\n    showStatus(\'Error saving data to localStorage\', \'error\');\n  }\n}\n\n// Function to add a random item to the array\nfunction addRandomItem() {\n  const items = [\n    "Random Item " + Math.floor(Math.random() * 1000),\n    "New Entry " + Date.now().toString().slice(-4),\n    "Sample Data " + Math.floor(Math.random() * 100),\n    "Test Item " + String.fromCharCode(65 + Math.floor(Math.random() * 26)),\n    "Generated at " + new Date().toLocaleTimeString()\n  ];\n  \n  const randomItem = items[Math.floor(Math.random() * items.length)];\n  historyArray.push(randomItem);\n  displayArray();\n  showStatus(`Added: "${randomItem}" to the array`, \'info\');\n}\n\n// Function to clear the array\nfunction clearArray() {\n  if (historyArray.length > 0) {\n    historyArray = [];\n    displayArray();\n    showStatus(\'Array cleared\', \'info\');\n  } else {\n    showStatus(\'Array is already empty\', \'info\');\n  }\n}\n\n// Event listeners\nsaveButton.addEventListener(\'click\', saveArrayToLocalStorage);\naddButton.addEventListener(\'click\', addRandomItem);\nclearButton.addEventListener(\'click\', clearArray);\n\n// Initialize on page load\ndocument.addEventListener(\'DOMContentLoaded\', loadArrayFromLocalStorage);\n\n// Also show localStorage info on page load\ndocument.addEventListener(\'DOMContentLoaded\', () => {\n  console.log(\'LocalStorage Array Manager initialized\');\n  console.log(\'LocalStorage key:\', STORAGE_KEY);\n  console.log(\'Current array:\', historyArray);\n});\n',
'<h2>randomSelectAndJoin</h2>	function randomSelectAndJoin(arr, selectNum, separator = " ") {\n    // Validate input: ensure the array has enough elements\n    if (!Array.isArray(arr) || arr.length < selectNum) {\n        throw new Error(`Array must have at least ${selectNum} elements`);\n    }\n\n    // If requesting more items than array length, return all items\n    if (selectNum >= arr.length) {\n        return arr.join(separator);\n    }\n\n    // Create an array to store selected indices\n    const selectedIndices = [];\n    \n    // Randomly select unique indices\n    while (selectedIndices.length < selectNum) {\n        const randomIndex = Math.floor(Math.random() * arr.length);\n        // Only add if not already selected\n        if (!selectedIndices.includes(randomIndex)) {\n            selectedIndices.push(randomIndex);\n        }\n    }\n\n    // Map indices to elements and join them\n    const selectedElements = selectedIndices.map(index => arr[index]);\n    return selectedElements.join(separator);\n}\n\n// Alternative: More efficient version for large arrays\nfunction randomSelectAndJoinEfficient(arr, selectNum, separator = " ") {\n    if (!Array.isArray(arr) || arr.length < selectNum) {\n        throw new Error(`Array must have at least ${selectNum} elements`);\n    }\n\n    if (selectNum >= arr.length) { return arr.join(separator); }\n\n    // Create a copy of the array\n    const arrCopy = [...arr];\n    const selectedElements = [];\n    \n    // Randomly select and remove elements\n    for (let i = 0; i < selectNum; i++) {\n        const randomIndex = Math.floor(Math.random() * arrCopy.length);\n        selectedElements.push(arrCopy[randomIndex]);\n        // Remove selected element to avoid duplicates\n        arrCopy.splice(randomIndex, 1);\n    }\n\n    return selectedElements.join(separator);\n}\n\n// Example usage:\nconst fruits = ["apple", "banana", "cherry", "date", "elderberry"];\nconsole.log(randomSelectAndJoin(fruits, 3)); // e.g., "banana cherry apple"\nconsole.log(randomSelectAndJoin(fruits, 2, ", ")); // e.g., "date, cherry"\nconsole.log(randomSelectAndJoin(fruits, 4, " and ")); // e.g., "elderberry and apple and banana and cherry"\n',
]
