<base target="_blank"><html><head><title>Essential Batch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "Essential Batch"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Essential Batch</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<pre><br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>

<br>
<br>
<h2>Introduction</h2>
This book describes Windows scripting as implemented by <code>cmd.exe</code> command interpreter.
This book first describes using the Windows NT command interpreter, how it receives, parses, and processes commands from users. 

Then it describes various commands available.
To obtain an extensive list of Windows commands and their short summaries, open the command prompt on any Windows computer, and type help. 
To find out about a particular command, type the name of the command followed by <code>/?</code>.
The subject of this book is also known as "batch programming", even though "batch" refers not only to batch files for MS DOS and Windows command interpreter. 

Other subject terms include "batch file programming", "batch file scripting", "Windows batch command", "Windows batch file", "Windows command line", "Windows command prompt", and "Windows shell scripting".

<h2>How a command line is interpreted</h2>

The parsing of a command line into a sequence of commands is complex, and varies subtly from command interpreter to command interpreter. 
There are, however, four main components:
<strong>Variable substitution</strong>
A command line is scanned for variable specifications, and any found are replaced with the contents of those variables.
<strong>Quoting</strong>
`Special characters can be quoted, to remove their special meanings.
<strong>Syntax</strong>
Command lines are developed into a sequence of commands according to a syntax.
<strong>Redirection</strong>
Redirection specifications are applied, and removed from the command line, before an individual command in a sequence is executed.
<h2>Variable substitution</h2>
Command lines can contain variable specifications. 
These comprise a <code>%</code> character followed by a name, followed by a second <code>%</code> character unless the name is a digit in 0 ... 
9 or an asterisk *.
Variable specifications are replaced with values as follows:

<code>%%</code>, such as <code>%PATH%</code> or <code>%USERNAME%</code>, is replaced with the value of the named environment variable. 
For example, <code>%PATH%</code> is replaced by the value of the PATH environment variable.varname

<code>%</code> for 0 &lt;= n &lt;= 9, such as <code>%0</code> or <code>%9</code>, is replaced with the value of the n-th parameter passed to the batch file when it was invoked, subject to any subsequent modifications by the SHIFT command. 
For example: <code>%2</code> is replaced by the value of the second batch file parameter.n

%* is replaced with the values of all the command-line parameters except for %0, even those beyond index 9. SHIFT command has no impact on the result of %*. 
See also command-line arguments.

<h2>Special names</h2>
Some variable names are not visible using SET command. 
Rather, they are made available for reading using the <code>%</code> notation. 
To find out about them, type <code>help set</code>.
Special variable names and what they expand to:

<h4></h4>
<table>
<thead><tr>
<th width="209">Name</th>
<th width="496">Replacement Value Used</th>
</tr></thead>
<tbody>
<tr>
<td>%CD%</td>
<td>The current directory, not ending in a slash character if it is not the root directory of the current drive</td>
</tr>
<tr>
<td>%TIME%</td>
<td>The system time in HH:MM:SS.mm format.</td>
</tr>
<tr>
<td>%DATE%</td>
<td>The system date in a format specific to localization.</td>
</tr>
<tr>
<td>%RANDOM%</td>
<td>A generated pseudo-random number between 0 and 32767.</td>
</tr>
<tr>
<td>%ERRORLEVEL%</td>
<td>The error level returned by the last executed command, or by the last called batch script.</td>
</tr>
<tr>
<td>%CMDEXTVERSION%</td>
<td>The version number of the Command Processor Extensions currently used by cmd.exe.</td>
</tr>
<tr>
<td>%CMDCMDLINE%</td>
<td>The content of the command line used when the current cmd.exe was started.</td>
</tr>
</tbody>
</table>

<h2>Quoting and escaping</h2>
You can prevent the special characters that control command syntax from having their special meanings as follows, except for the percent sign (<code>%</code>):

You can surround a string containing a special character by quotation marks.
You can place caret (<code>^</code>), an escape character, immediately before the special characters. 
In a command located after a pipe (<code>|</code>), you need to use three carets (<code>^^^</code>) for this to work.

The special characters that need quoting or escaping are usually <code>&lt;</code>, <code>&gt;</code>, <code>|</code>, <code>&amp;</code>, and <code>^</code>. 
In some circumstances, <code>!</code> and <code>\</code> may need to be escaped. 
A newline can be escaped using caret as well.
When you surround the string using quotation marks, they become part of the argument passed to the command invoked. 
By contrast, when you use caret as an escape character, the caret does not become part of the argument passed.
The percent sign (<code>%</code>) is a special case. 
On the command line, it does not need quoting or escaping unless two of them are used to indicate a variable, such as <code>%OS%</code>. 
But in a batch file, you have to use a double percent sign (<code>%%</code>) to yield a single percent sign (<code>%</code>). 
Enclosing the percent sign in quotation marks or preceding it with caret does not work.
Examples

<code>echo "Johnson &amp; son"</code>Echoes the complete string rather than splitting the command line at the &amp; character. 
Quotes are echoed as well

<code>echo Johnson ^&amp; son</code>As above, but using caret before the special character ampersand. 
No quotes are echoed.

<code>echo Johnson &amp; son</code>Does not use an escape character and therefore, "son" is interpreted as a separate command, usually leading to an error message that command son is not found.

<code>echo A ^^ B</code>Echoes <code>A ^ B</code>. 
Caret needs escaping as well or else it is interpreted as escaping a space.

<code>echo &gt; NUL | echo A ^^^^ B</code>Echoes <code>A ^ B</code>. 
When after a pipe, a caret used for escaping needs to be tripled to work; the fourth caret is the one being escaped.

<code>if 1 equ 1 ^echo Equal &amp;^echo Indeed, equal</code>Echoes the two strings. 
The caret at the end of the line escapes the newlines, leading to the three lines being treated as if they were a single line. 
The space before the first caret is necessary or else 1 gets joined with the following echo to yield <code>1echo</code>.

<code>attrib File^ 1.txt</code>Does not show attributes of file named File <code>1.txt</code> since escaping of space does not work. 
Using quotes, as in <code>attrib "File 1.txt"</code>, works.

<code>echo The ratio was 47%.</code>If run from a batch, the percent sign is ignored.

<code>echo The ratio was 47%%.</code>If run from a batch, the percent sign is output once.

<code>set /a modulo=14%%3</code>If run from a batch, sets modulo variable to 2, the remainder of dividing 14 by 3. 
Does not work with single <code>%</code>.

<code>for %%i in (1,2,3) do echo %%i</code>If run from a batch, outputs 1, 2 and 3.

<code>echo %temp%</code>Outputs the content of temp variable even if run from a batch file. 
Use of the percent sign in a batch to access environment variables and passed arguments needs no escaping.

<code>echo ^%temp^%</code>Outputs literally %temp% when run from the command line.

<code>echo %%temp%%</code>Outputs literally <code>%temp%</code> when run from a batch.

<code>echo //comment line | findstr \//</code>Command FINDSTR uses backslash (<code>\</code>) for escaping. 
Unlike caret, this is internal to the command and unknown to the command shell.

<h2>Syntax</h2>
Command lines are developed into a sequence of commands according to a syntax. 
In that syntax, simple commandsmay be combined to form pipelines, which may in turn be combined to form compound commands, which finally may be turned into parenthesized commands.
A simple command is just a command name, a command tail, and some redirection specifications. 
An example of a simple command is <code>dir *.txt &gt; somefile</code>.
A pipeline is several simple commands joined together with the "pipe" metacharacter ¡ª <code>|</code>, also known as the "vertical bar". 
The standard output of the simple command preceding each vertical bar is connected to the standard input of the simple command following it, via a pipe. 
The command interpreter runs all of the simple commands in the pipeline in parallel. 
An example of a pipeline (comprising two simple commands) is <code>dir *.txt | more</code>.
A compound command is a set of pipelines separated by conjunctions. 
The pipelines are executed sequentially, one after the other, and the conjunction controls whether the command interpreter executes the next pipeline or not. 
An example of a compound command (comprising two pipelines, which themselves are just simple commands) is move <code>file.txt file.bak &amp;&amp; dir &gt; file.txt</code>.
The conjunctions:

<code><strong>&amp;</strong></code> - An unconditional conjunction. 
The next pipeline is always executed after the current one has completed executing.

<code><strong>&amp;&amp;</strong></code> - A positive conditional conjunction. 
The next pipeline is executed if the current one completes executing with a zero exit status.

<code><strong>||</strong></code> - A negative conditional conjunction. 
The next pipeline is executed if the current one completes executing with a non-zero exit status.

A parenthesized command is a compound command enclosed in parentheses (i.e. ( and )). 
From the point of view of syntax, this turns a compound command into a simple command, whose overall output can be redirected.
For example: The command line <code>( pushd temp &amp; dir &amp; popd ) &gt; somefile.txt</code> causes the standard output of the entire compound command <code>( pushd temp &amp; dir &amp; popd )</code> to be redirected to <code>somefile.txt</code>.

<h2>Redirection</h2>
Redirection specifications are applied, and removed from the command line, before an individual command in a sequence is executed. 
Redirection specifications control where the standard input, standard output, and standard error file handles for a simple command point. 
They override any effects to those file handles that may have resulted from pipelining. 
(See the preceding section on command syntax.) Redirection signs <code>&gt;</code> and <code>&gt;&gt;</code> can be prefixed with 1 for the standard output (same as no prefix) or 2 for the standard error.
The redirection specifications are:
<strong>&lt; filename </strong>Redirect standard input to read from the named file.
<strong>&gt; filename </strong>Redirect standard output to write to the named file, overwriting its previous contents.
<strong>&gt;&gt; filename </strong>Redirect standard output to write to the named file, appending to the end of its previous contents.
<strong>&gt;&amp;h </strong>Redirect to handle h, where handle is any of 0¡ªstandard input, 1¡ªstandard output, 2¡ªstandard error, and more.
<strong>&lt;&amp;h </strong>Redirect from handle h.
Examples:

<code>dir *.txt &gt;listing.log</code>Redirects the output of the <code>dir</code> command to listing.log file.

<code>dir *.txt &gt; listing.log</code>As above; the space before the file name makes no difference. 
However, if you type this into the command window, auto-completion with tab after typing <code>&gt; l</code> actually works, while it does not work with <code>&gt;listing.log</code>.

<code>dir *.txt 2&gt;NUL</code>Redirects errors of the <code>dir</code> command to nowhere.

<code>dir *.txt &gt;&gt;listing.log</code>Redirects the output of the <code>dir</code> command to listing.log file, appending to the file. 
Thereby, the content of the file before the redirected command was executed does not get lost.

<code>dir *.txt &gt;listing.log 2&gt;&amp;1</code>Redirects the output of the <code>dir</code> command to listing.log file, along with the error messages.

<code>dir *.txt &gt;listing.log 2&gt;listing-errors.log</code>Redirects the output of the <code>dir</code> command to listing.log file, and the error messages to listing-errors.log file.

<code>&gt;myfile.txt echo Hello</code>The redirection can precede the command.

<code>echo Hello &amp; echo World &gt;myfile.txt</code>Only the 2nd <code>echo</code> gets redirected.

<code>(echo Hello &amp; echo World) &gt;myfile.txt</code>Output of both echos gets redirected.

<code>type con &gt;myfile.txt</code>Redirects console input (con) to the file. 
Thus, allows multi-line user input terminated by user pressing Control + Z. 
See also user input.

<code>(for %i in (1,2,3) do @echo %i) &gt; myfile.txt</code>Redirects the entire output of the loop to the file.

<code>for %i in (1,2,3) do @echo %i &gt; myfile.txt</code>Starts redirection anew each time the body of the loop is entered, losing the output of all but the latest loop iteration.

<h2>Batch reloading</h2>

The command interpreter reloads the content of a batch after each execution of a line or a bracketed group.
If you start the following batch and change <code>echo A</code> to <code>echo B</code> in the batch shortly after starting it, the output will be <code>B</code>.

@echo off
ping -n 6 127.0.0.1 &gt;nul &amp; REM wait
echo A

What is on a single line does matter; changing <code>echo A</code> in the following batch after running it has no impact:

@echo off
ping -n 6 127.0.0.1 &gt;nul &amp; echo A

Nor have after-start changes have any impact on commands bracketed with ( and ). 
Thus, changing <code>echo A</code> after starting the following batch has no impact:

@echo off
for /L %%i in (1,1,10) do (
ping -n 2 127.0.0.1 &gt;nul &amp; REM wait
echo A
)

Same happens for any other enclosing, including:

@echo off
(
ping -n 6 127.0.0.1 &gt;nul &amp; REM wait
echo A
)

<h2>Environment variables</h2>

The environment variables of the command interpreter process are inherited by the processes of any (external) commands that it executes. 
A few environment variables are used by the command interpreter itself. 
Changing them changes its operation.
Environment variables are affected by the SET, PATH, and PROMPT commands.
To unset a variable, set it to empty string, such as <code>set myvar=</code>.
The command interpreter inherits its initial set of environment variables from the process that created it. 
In the case of command interpreters invoked from desktop shortcuts this will be Windows Explorer, for example.
Command interpreters generally have textual user interfaces, not graphical ones, and so do not recognize the Windows message that informs applications that the environment variable template in the Registry has been changed. 
Changing the environment variables in Control Panel will cause Windows Explorer to update its own environment variables from the template in the Registry, and thus change the environment variables that any subsequently invoked command interpreters will inherit. 
However, it will not cause command interpreters that are already running to update their environment variables from the template in the Registry.
<h2>COMSPEC</h2>
The <code>COMSPEC </code>environment variable contains the full path name of the command interpreter program file. 
This is just inherited from the parent process, and is thus indirectly derived from the setting of <code>COMSPEC</code> in the environment variable template in the Registry.
<h2>PATH</h2>
The value of the <code>PATH</code> environment variable comprises a list of directory names, separated by semi-colon characters. 
This is the list of directories that are searched, in order, when locating the program file of an external command to execute.
<h2>PATHEXT</h2>
The value of the <code>PATHEXT </code>environment variable comprises a list of filename extensions, separated by semi-colon characters. 
This is the list of filename extensions that are applied, in order, when locating the program file of an external command to execute.
An example content of <code>PATHEXT </code>printed by <code>echo %PATHEXT%</code>:
<code>.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC</code>
By adding ".PL" to the variable, you can ensure Perl programs get run from the command line even when typed without the ".pl" extension. 
Thus, instead of typing "mydiff.pl a.txt b.txt", you can type "mydiff a.txt b.txt".
Adding ".PL" to the variable in Windows Vista and later:

<code>setx PATHEXT %PATHEXT%;.PL</code>If you use "set" available in Windows XP, the effect will be temporary and impacting only the current console or process.

Links:

<h2>PROMPT</h2>
The <code>PROMPT</code> environment variable controls the text emitted when the command interpreter displays the prompt. 
The command interpreter displays the prompt when prompting for a new command line in interactive mode, or when echoing a batch file line in batch file mode.
Various special character sequences in the value of the <code>PROMPT</code> environment variable cause various special effects when the prompt is displayed, as in the following table:

<h4></h4>
<table>
<thead><tr>
<th width="153">Characters</th>
<th width="423">Expansion Result</th>
</tr></thead>
<tbody>
<tr>
<td>$$</td>
<td>$ character itself</td>
</tr>
<tr>
<td>$A</td>
<td>&amp; symbol AKA ampersand. 
A convenience, since it is difficult to place a literal &amp; in the value of the PROMPT environment variable using the SET command.</td>
</tr>
<tr>
<td>$B</td>
<td>Vertical bar '|' (pipe symbol)</td>
</tr>
<tr>
<td>$C</td>
<td>Left parenthesis '('</td>
</tr>
<tr>
<td>$D</td>
<td>Current date</td>
</tr>
<tr>
<td>$E</td>
<td>ESC (ASCII code 27)</td>
</tr>
<tr>
<td>$F</td>
<td>Right parenthesis ')'</td>
</tr>
<tr>
<td>$G</td>
<td>Greater-than symbol '&gt;'</td>
</tr>
<tr>
<td>$H</td>
<td>Backspace (deletes previous character)</td>
</tr>
<tr>
<td>$L</td>
<td>Less-than symbol '&lt;'</td>
</tr>
<tr>
<td>$M</td>
<td>Remote name linked to the current drive if it is a network drive; empty string otherwise.</td>
</tr>
<tr>
<td>$N</td>
<td>Current drive letter</td>
</tr>
<tr>
<td>$P</td>
<td>Current drive letter and full path</td>
</tr>
<tr>
<td>$Q</td>
<td>'=' (equals sign)</td>
</tr>
<tr>
<td>$S</td>
<td>' ' (space character)</td>
</tr>
<tr>
<td>$T</td>
<td>Current system time</td>
</tr>
<tr>
<td>$V</td>
<td>Windows version number</td>
</tr>
<tr>
<td>$_</td>
<td>&lt;CR&gt; (carriage return character, aka "enter")</td>
</tr>
<tr>
<td>$+</td>
<td>As many plus signs (+) as there are items on the pushd directory stack</td>
</tr>
</tbody>
</table>

<h2>Switches</h2>

Most Windows commands provide switches AKA options to direct their behavior.
Observations:

Switches most often consist of a single-letter; some switches consist of a sequence of multiple letters.
Switches are preceded with a slash (<code>/</code>) rather than, as in some other operating systems, with a minus sign (<code>-</code>).
Switches are case-insensitive rather than, as in some other operating systems, case-sensitive.
If a command from another operating system is ported to Windows (such as <code>grep</code>), it usually retains the option conventions from the original operating system, including the use of minus sign and case-sensitivity.

Examples:

<code>dir /?</code>Displays the help. 
This option is provided by many commands.

<code>dir /b /s</code>Lists all files and folders in the current folder recursively. 
Two switches are used: <code>/b</code> and <code>/s</code>.

<code>dir /bs</code>Does not work; switches cannot be accumulated behind a single slash.

<code>findstr /ric:"id: *[0-9]*" File.txt</code>Unlike many other commands, <code>findstr</code> allows the accumulation of switches behind a single slash. 
Indeed, r, i and c are single-letter switches.

<code>dir/b/s</code>Works. 
In <code>dir</code>, removing whitespace between the command and the first switch or between the switches does not make a difference; thus, does the same as <code>dir /b /s</code>.

<code>tree/f/a</code>Does not work, unlike <code>tree /f /a</code>. 
In tree, separation by whitespace is mandatory. 
Nor does find/i/v work.

<code>dir /od</code>The switch letter o is further modified by a single letter specifying that ordering should be by date. 
The letter d is not a switch by itself. 
Similar cases include <code>dir /ad</code> and more <code>/t4</code>.

<code>dir /B /S</code>The switches are case-insensitive, unlike in some other operating systems.

<code>sort /r file.txt</code>Sorts the file in a reverse order.

<code>sort /reverse file.txt</code>Sort allows the switch string to be longer than a single-letter.

<code>sort /reve file.txt</code>Sort allows the specified switch string to be a sub-string of the complete long name of the switch. 
Thus, does the same as the above.

<code>sort /reva file.txt</code>Does not work, since <code>reva</code> is not a sub-string of <code>reverse</code>.

<code>taskkill /im AcroRd32.exe</code><code>Taskkill</code> requires a multi-letter switch name for <code>/im</code>; shortening to <code>/i</code> does not work.

<code>java -version</code>Java, which originated in the environment of another operating system family, uses the minus convention for its switches AKA options.

<code>grep --help</code>If GNU grep is installed, it requires multi-letter switches to be preceded by two dashes.

<h2>Error level</h2>

Commands usually set error level at the end of their execution. 
In Windows NT and later, it is a 32-bit signed integer; in MS DOS, it used to be an integer from 0 to 255. 
Keywords: return code, exit code, exit status.
The conventional meaning of the error level:

0 - success
not 0 - failure
The error levels being set are usually positive.
If the command does not distinguish various kinds of failure, the error level on failure is usually 1.

Uses of the error level:

It can be tested using <code>&amp;&amp;</code> and <code>||</code>; see also syntax.
It can be tested using IF.
The value can be accessed from <code>ERRORLEVEL </code>variable.

Examples:

<code>dir &gt;NUL &amp;&amp; echo Success</code>The part after &amp;&amp; is executed only if the error level is zero.

<code>color 00 || echo Failure</code>The part after || is executed only if the error level is non-zero, whether positive or negative.

<code>color 00 || ( echo Failure)</code>Multi-line bracketing works as well.

<code>echo %ERRORLEVEL%</code>Displays the error level without changing it.

<code>if %errorlevel% equ 0 echo The error level is zero, meaning success.</code>
<code>if %errorlevel% neq 0 echo The error level is non-zero, meaning failure.</code>

<code>if errorlevel 1 echo The error level is &gt;= 1, meaning failure via positive error level.</code>Does not cover failure via negative error level. 
Note the <code>&gt;=</code> part: this is not the same as <code>if %errorlevel% equ 1</code>.

<code>exit /b 1</code>Returns a batch file, setting the error level to 1.

<code>cmd /c "exit /b 10"</code>In the middle of a batch file or on the command line, sets the error level to 10.

<code>(cmd /c "exit /b 0" &amp;&amp; Echo Success) &amp; (cmd /c "exit /b -1" || Echo Failure)</code>As above, showing the error level is indeed affected.

<code>(cmd /c "exit /b 0" &amp; cmd /c "exit /b 1") || Echo Failure</code>The error level of a chain created by <code>&amp;</code> is the error level of the last command of the chain.

<code>cmd /c "exit /b -1" &amp; if not errorlevel 1 echo Would-be success</code>The <code>if not errorlevel 1</code> test, which might appear to test for success, passes on negative numbers: it tests on "not error level &gt;= 1", which is "error level &lt;= 0".

<code>set myerrorlevel=%errorlevel%</code>Remembers the error level for later.

<code>set errorlevel=0</code>To be avoided: overshadows the built-in <code>errorlevel</code> variable. 
Ensures that subsequent accesses via <code>%ERRORLEVEL%</code> return 0 rather than the actual error level.

<code>cmd /c "exit /b 0"if 1 equ 1 ( cmd /c "exit /b 1" &amp; echo %errorlevel% )</code>Displays 0, since <code>%errorlevel%</code> gets expanded before <code>cmd /c "exit /b 1"</code> gets executed.

<h2>String processing</h2>

Getting a substring of a variable:

set a=abcdefgh
echo %a:~0,1%   &amp; rem from index 0, length 1; result: a
echo %a:~1,1%   &amp; rem from index 1, length 1; result: b
echo %a:~0,2%   &amp; rem from index 0, length 2; result: ab
echo %a:~1,2%   &amp; rem from index 1, length 2; result: bc
echo %a:~1%     &amp; rem from index 1 to the end; result: bcdefgh
echo %a:~-1%    &amp; rem from index -1 (last char) to the end; result: h
echo %a:~-2%    &amp; rem from index -2 (next-to-last) to the end; result: gh
echo %a:~0,-2%  &amp; rem from index 0 to index -2, excl.; result: abcdef
echo %a:~0,-1%  &amp; rem from index 0 to index -1, excl.; result: abcdefg
echo %a:~1,-1%  &amp; rem from index 1 to index -1, excl.; result: bcdefg

Testing substring containment:

<code>if not "%a:bc=%"=="%a%" echo yes</code>
If variable a contains "bc" as a substring, echo "yes".
This test is a trick that uses string replacement, discussed below.
This test does not work if the variable contains a quotation mark.

Testing for "starts with":

if %a:~0,1%==a echo yes   &amp; rem If variable a starts with "a", echo "yes".
if %a:~0,2%==ab echo yes  &amp; rem If variable a starts with "ab", echo "yes".

String replacement:

set a=abcd &amp; echo %a:c=%   &amp; rem replace c with nothing; result: abd
set a=abcd &amp; echo %a:c=e%  &amp; rem replace c with e; result: abed; 
set a=abcd &amp; echo %a:*c=%  &amp; rem replace all up to c with nothing; result: d
rem Above, the asterisk (*) only works at the beginning of the sought pattern.

See also the help for SET command: set /?.
Splitting a string by any of " ", ",", and ";": ["space", "comma" and "semicolon":]

set myvar=a b,c;d
for %%a in (%myvar%) do echo %%a

Splitting a string by semicolon, assuming the string contains no quotation marks:

@echo off
set myvar=a b;c;d
set strippedvar=%myvar%
:repeat
for /f "delims=;" %%a in ("%strippedvar%") do echo %%a
set prestrippedvar=%strippedvar%
set strippedvar=%strippedvar:*;=%
if not "%prestrippedvar:;=%"=="%prestrippedvar%" goto :repeat

Limitations:
The above string processing does not work with parameter variables (<code>%1</code>, <code>%2</code>, ...).

<h2>Command-line arguments</h2>

The command-line arguments AKA command-line parameters passed to a batch script are accessible as <code>%1</code>, <code>%2</code>, ..., <code>%9</code>. 
There can be more than nine arguments; to access them, see how to loop over all of them below.
The syntax <code>%0</code> does not refer to a command-line argument but rather to the name of the batch file.
Testing for whether the first command-line argument has been provided:

if not -%1-==-- echo Argument one provided
if -%1-==-- echo Argument one not provided &amp; exit /b

A robust looping over all command-line arguments using <code>SHIFT</code> (for each command-line argument, ...):

:argactionstart
if -%1-==-- goto argactionend
echo %1 &amp; REM Or do any other thing with the argument
shift
goto argactionstart
:argactionend

A robust looping over all command-line arguments using <code>SHIFT</code> without modifying <code>%1</code>, <code>%2</code>, etc.:

call :argactionstart %*
echo Arg one: %1 &amp; REM %1, %2, etc. 
are unmodified in this location
exit /b

:argactionstart
if -%1-==-- goto argactionend
echo %1 &amp; REM Or do any other thing with the argument
shift
goto argactionstart
:argactionend
exit /b

Transferring command-line arguments to environment variables:

setlocal EnableDelayedExpansion
REM Prevent affecting possible callers of the batch
REM Without delayed expansion, !arg%argno%! used below won't work.
set argcount=0
:argactionstart
if -%1-==-- goto argactionend
set /a argcount+=1
set arg%argcount%=%1
shift
goto argactionstart
:argactionend

set argno=0
:loopstart
set /a argno+=1
if %argno% gtr %argcount% goto loopend
echo !arg%argno%! &amp; REM Or do any other thing with the argument
goto loopstart
:loopend

Looping over all command-line arguments, albeit not a robust one:

for %%i in (%*) do (
echo %%i
)

This looks elegant but is non-robust, maltreating arguments containing wildcards (<code>*</code>, <code>?</code>). 
In particular, the above for command replaces arguments that contain wildcards (<code>*</code>, <code>?</code>) with file names that match them, or drops them if no files match. 
Nonetheless, the above loop works as expected as long as the passed arguments do not contain wildcards.
Finding the number of command-line arguments, in a non-robust way:

set argcount=0
for %%i in (%*) do set /a argcount+=1

Again, this does not work with arguments containing wildcards.
The maximum possible number of arguments is greater than 4000, as empirically determined on a Windows Vista machine. 
The number can differ on Windows XP and Windows 7.
In passing arguments to a batch script, characters used for argument separation are the following ones:

space
comma
semicolon
equal sign
tab character

Thus, the following lines pass the same four arguments:

<code>test.bat a b c d</code>
<code>test.bat a,b,c,d</code>
<code>test.bat a, b, c, d</code>
<code>test.bat a;b;c;d</code>
<code>test.bat a=b=c=d</code>
<code>test.bat a b,c;,;=d</code>

Yes, even the line with <code>a b,c;,;=d</code> passes four arguments, since a sequence of separating characters is considered a single separator.
To have a space, comma or semicolon in the argument value, you can pass the value enclosed in quotation marks. 
However, the quotation marks become part of the argument value. 
To get rid of the enclosing quotation marks when referring to the argument in the script, you can use <code>%~&lt;number&gt;</code> described in percent tilde.
When passing arguments to an invoked command rather than a batch script, you usually need to separate the command from the first argument using a space. 
However, for internal commands, that separation is not necessary if the first character after the command name is one of a couple of symbols, including <code>.\/</code>, and more:

<code>echo.</code>Outputs a newline.

<code>tree.</code>Fails: "tree." not found. 
tree is an external command.

<code>dir..</code>Lists the content of the parent directory.

<code>cd..</code>Changes the current directory to the parent one.

<code>cd\</code>Changes the current directory to the root one.

<code>start.</code>Opens Windows Explorer from the current directory.

<code>dir/b/s</code>Lists directory content recursively, showing full paths.

<h2>Wildcards</h2>

Many commands accept file name wildcards--characters that do not stand for themselves and enable matching of a group of filenames.
Wildcards:

<code>*</code> : any sequence of characters

<code>?</code> : a single character other than a period (<code>.</code>) or, if part of a sequence of question marks at the end of a maximum period-free part of a file name, possibly zero number of characters; see examples for clarification

Examples:

<code>dir *.txt</code>Matches <code>Myfile.txt</code>, <code>Plan.txt</code> and any other file with the <code>.txt</code> extension.

<code>dir *txt</code>The period does not need to be included. 
However, this will also match files named without the period convention, such as <code>myfiletxt</code>.

<code>ren *.cxx *.cpp</code>Renames all files with .<code>cxx</code> extension to have <code>.cpp</code> extension.

<code>dir a?b.txt</code>
Matches files <code>aab.txt</code>, <code>abb.txt</code>, <code>a0b.txt</code>, etc.
Does not match <code>ab.txt</code>, since a question mark followed by a character other than a question mark or period cannot match zero characters.
Does not match <code>a.b.txt</code>, since a question mark cannot match a period.

<code>dir ???.txt</code>Matches <code>.txt</code>, <code>a.txt</code>, <code>aa.txt</code>, and <code>aaa.txt</code>, among others, since each question mark in the sequence followed by a period can match zero number of characters.

<code>dir a???.b???.txt???</code>Matches <code>a.b.txt</code>, among others. 
While the last question mark sequence is not followed by a period, it is still a sequence at the end of a maximum period-free part of a file name.

<code>dir ????????.txt &amp; @REM eight question marks</code>Matches the same files as <code>*.txt</code>, since each file also has a short file name that has no more than 8 characters before <code>.txt</code>.
Quirk with short file names: the wildcard matching is performed both on long file names and the usually hidden short 8 chars + period + 3 chars file names. 
This can lead to bad surprises.
Unlike shells of some other operating systems, the <code>cmd.exe</code> shell does not perform wildcard expansion (replacement of the pattern containing wildcards with the list of file names matching the pattern) on its own. 
It is the responsibility of each program to treat wildcards as such. 

This enables such things as <code>ren *.txt *.bat</code>, since the <code>ren</code> command actually sees the <code>*</code> wildcard rather than a list of files matching the wildcard. 

Thus, <code>echo *.txt</code> does not display files in the current folder matching the pattern but rather literally displays <code>*.txt</code>.
Another consequence is that you can write <code>findstr a.*txt</code> without fearing that the <code>a.*txt</code> part gets replaced with the names of some files in the current folder. 

Furthermore, recursive <code>findstr /s pattern *.txt</code> is possible, while in some other operating systems, the <code>*.txt</code> part would get replaced with the file names found in the current folder, disregarding nested folders.
Commands accepting wildcards include ATTRIB, COPY, DIR, FINDSTR, FOR, REN, etc.

<h2>User input</h2>

You can get input from the user using the following methods:

<code>SET</code><code> /P</code> command

CHOICE command
Using <code>type con &gt;myfile.txt</code>, for which the multi-line user input is terminated by user pressing Control + Z.

<h2>%~ (percent tilde)</h2>

When a command-line argument contains a file name, special syntax can be used to get various information about the file.
The following expand to various information about the file passed as <code>%1</code>:

<h4></h4>
<table>
<thead><tr>
<th width="121">Syntax</th>
<th width="371">Expansion Result</th>
<th width="200">Example</th>
</tr></thead>
<tbody>
<tr>
<td>%~1</td>
<td>%1 with no enclosing quotation marks</td>
<td>Not provided</td>
</tr>
<tr>
<td>%~f1</td>
<td>Full path with a drive letter</td>
<td>C:\Windows\System32\notepad.exe</td>
</tr>
<tr>
<td>%~d1</td>
<td>Drive letter</td>
<td>C:</td>
</tr>
<tr>
<td>%~p1</td>
<td>Drive-less path with the trailing backslash</td>
<td>\Windows\System32\</td>
</tr>
<tr>
<td>%~n1</td>
<td>For a file, the file name without path and extensionFor a folder, the folder name</td>
<td>notepad</td>
</tr>
<tr>
<td>%~x1</td>
<td>File name extension including the period</td>
<td>.exe</td>
</tr>
<tr>
<td>%~s1</td>
<td>Modify of f, n and x to use short name</td>
<td>Not provided</td>
</tr>
<tr>
<td>%~a1</td>
<td>File attributes</td>
<td>--a------</td>
</tr>
<tr>
<td>%~t1</td>
<td>Date and time of last modification of the file</td>
<td>02.11.2006 11:45</td>
</tr>
<tr>
<td>%~z1</td>
<td>File size</td>
<td>151040</td>
</tr>
<tr>
<td>%~pn1</td>
<td>A combination of p and n</td>
<td>\Windows\System32\notepad</td>
</tr>
<tr>
<td>%~dpnx1</td>
<td>A combination of several letters</td>
<td>C:\Windows\System32\notepad.exe</td>
</tr>
<tr>
<td>%~$PATH:1</td>
<td>The full path of the first match found in the folders present in the PATH variable, or an empty string in no match.</td>
<td> </td>
</tr>
<tr>
<td>%~n0</td>
<td>%~n applied to %0:The extensionless name of the batch</td>
<td>tildetest</td>
</tr>
<tr>
<td>%~nx0</td>
<td>%~nx applied to %0:The name of the batch</td>
<td>tildetest.bat</td>
</tr>
<tr>
<td>%~d0</td>
<td>%~f applied to %0:The drive letter of the batch</td>
<td>C:</td>
</tr>
<tr>
<td>%~dp0</td>
<td>%~dp applied to %0:The folder of the batch with trailing backslash</td>
<td>C:\Users\Joe Hoe\</td>
</tr>
</tbody>
</table>

The same syntax applies to single-letter variables created by FOR command, such as <code>%%i</code>.

<h2>Functions</h2>

Functions AKA subprograms can be emulated using CALL, labels, SETLOCAL and ENDLOCAL.
An example of a function that determines arithmetic power:

@echo off
call :power 2 4
echo %result%
rem Prints 16, determined as 2 * 2 * 2 * 2
goto :eof

rem __Function power______________________
rem Arguments: %1 and %2
:power
setlocal
set counter=%2
set interim_product=%1
:power_loop
if %counter% gtr 1 (
set /a interim_product=interim_product * %1
set /a counter=counter - 1
goto :power_loop
)
endlocal &amp; set result=%interim_product%
goto :eof

While the goto :eof at the end of the function is not really needed, it has to be there in the general case in which there is more than one function.
The variable into which the result should be stored can be specified on the calling line as follows:

@echo off
call :sayhello result=world
echo %result%
exit /b

:sayhello
set %1=Hello %2
REM Set %1 to set the returning value
exit /b

In the example above, <code>exit /b</code> is used instead of <code>goto :eof</code> to the same effect.
Also, remember that the equal sign is a way to separate parameters. 
Thus, the following items achieve the same:

<code>call :sayhello result=world</code>
<code>call :sayhello result world</code>
<code>call :sayhello result,world</code>
<code>call :sayhello result;world</code>

(See command-line arguments as a reminder)

<h2>Calculation</h2>

Batch scripts can do simple 32-bit integer arithmetic and bitwise manipulation using SET /a command. 
The largest supported integer is 2147483647 = 2 ^ 31 - 1. 
The smallest supported integer is -2147483648 = - (2 ^ 31), assignable with the trick of <code>set /a num=-2147483647-1</code>. 
The syntax is reminiscent of the C language.
Arithmetic operators include *, /, % (modulo), +, -. 
In a batch, modulo has to be entered as "%%".
Bitwise operators interpret the number as a sequence of 32 binary digits. 
These are ~ (complement), &amp; (and), | (or), ^ (xor), &lt;&lt; (left shift), &gt;&gt; (right shift).
A logical operator of negation is !: it turns zero into one and non-zero into zero.
A combination operator is ,: it allows more calculations in one set command.
Combined assignment operators are modeled on "+=", which, in "a+=b", means "a=a+b". 
Thus, "a-=b" means "a=a-b". 
Similarly for *=, /=, %=, &amp;=, ^=, |=, &lt;&lt;=, and &gt;&gt;=.
The precedence order of supported operators, is as follows:
<ol start="1">
<code>( )</code>
<code>* / % + -</code>
<code>&lt;&lt; &gt;&gt;</code>
<code>&amp;</code>
<code>^</code>
<code>|</code>
<code>= *= /= %= += -= &amp;= ^= |= &lt;&lt;= &gt;&gt;=</code>
<code>,</code>
</ol>
Literals can be entered as decimal (1234), hexadecimal (0xffff, leading 0x), and octal (0777, leading 0).
The internal bit representation of negative numbers is two's complement. 
This provides a connection between arithmetic operations and bit operations. 
For instance, -2147483648 is represented as 0x80000000, and therefore set /a num=~(-2147483647-1) yields 2147483647, which equals 0x7FFFFFFF (type set /a num=0x7FFFFFFF to check).
As some of the operators have special meaning for the command interpreter, an expression using them needs to be enclosed in quotation marks, such as this:

<code>set /a num="255^127"</code>

<code>set /a "num=255^127"</code>Alternative placement of quotation marks.

<code>set /a num=255^^127</code>Escape ^ using ^ instead of quotation marks.

Examples:

<code>set n1=40 &amp; set n2=25</code><code>set /a n3=%n1%+%n2%</code>
Uses the standard percent notation for variable expansion.

<code>set n1=40 &amp; set n2=25</code><code>set /a n3=n1+n2</code>
Avoids the percent notation around variable names as unneeded for /a.

<code>set /a num="255^127"</code>Encloses "^" in quotation marks to prevent its special meaning for the command interpreter.

<code>set /a n1 = (10 + 5)/5</code>The spaces around = do not matter with /a. 
However, getting used to it lends itself to writing "set var = value" without /a, which sets the value of "var " rather than "var".

<code>if 1==1 (set /a n1=(2+4)*5)</code>Does not work: the arithmetic brackets within grouping brackets cause trouble.

<code>if 1==1 (set /a n1=^(2+4^)*5)</code>Escaping the arithmetic brackets with caret (^) works, as does enclosing "n1=2+(4*5)" in quotation marks.

<code>set /a n1=2+3,n2=4*7</code>Performs two calculations.

<code>set /a n1=n2=2</code>Has the same effect as n1=2,n2=2.

<code>set n1=40 &amp; set n2=25 &amp; set /a n3=n1+n2</code>Works as expected.

<code>set /a n1=2,n2=3,n3=n1+n2</code>Works as expected.

<code>set n1=40 &amp; set n2=25 &amp; set /a n3=%n1%+%n2%</code>Does not work unless n1 and n2 were set previously. 
The variable specifications %n1%" and "%n2"% get expanded  the first set command is executed. 
Dropping percent notation makes it work.before

<code>set /a n1=2,n2=3,n3=%n1%+%n2%</code>Does not work unless n1 and n2 were set previously, for the reason stated in the previous example.

<code>set /a n1=0xffff</code>Sets n1 using hexadecimal notation.

<code>set /a n1=0777</code>Sets n1 using octal notation.

<code>set /a n1=%random%</code>A pseudo-random number from 0 to 32767 = 2^15-1.

<code>set /a n1="%random%&gt;&gt;10"</code>A pseudo-random number from 0 to 31 = 2^5-1. 
The shift right operator drops 10 out of 15 bits, keeping 5 bits.

<code>set /a n1=%random%%50</code>A pseudo-random number from 0 to 49. 
Uses the % modulo operator. 
In a batch, %% is needed for modulo: <code>set /a n1=%random%%%50</code>. 
Because of this particular use of the modulo, the result is not perfectly uniform; it is uniform if the 2nd modulo operand--above 50--equals to a power of 2, e.g. 
256 = 2^8.

<code>set /a n1="(%random%&lt;&lt;15)+%random%"</code>A pseudo-random number from 0 to 1073741823 = 2^30 - 1. 
Combines the two 15-bit random numbers produced by %random% alone to produce a single 30-bit random number..

<code>set /a n1="((%random%&lt;&lt;15)+%random%)%1000000"</code>As above, but again using modulo, this time to achieve the range 0 to 999999.

An example calculation that prints prime numbers:

@echo off
setlocal
set n=1
:print_primes_loop
set /a n=n+1
set cand_divisor=1
:print_primes_loop2
set /a cand_divisor=cand_divisor+1
set /a cand_divisor_squared=cand_divisor*cand_divisor
if %cand_divisor_squared% gtr %n% echo Prime %n% &amp; goto :print_primes_loop
set /a modulo=n%%cand_divisor
if %modulo% equ 0 goto :print_primes_loop &amp; REM Not a prime
goto :print_primes_loop2

<h2>Finding files</h2>

Files can be found using DIR, FOR, FINDSTR, FORFILES, and WHERE.
Examples:

<code>dir /b /s *base*.doc*</code>Outputs all files in the current folder and its sub-folders such that the file name before the extension contains the word <code>base</code> and whose extension starts with <code>doc</code>, which includes <code>doc</code> and <code>docx</code>. 
The files are output with full paths, one file per line.

<code>dir /b /s *.txt | findstr /i pers.*doc</code>Combines the result of outputting files including their complete paths with the <code>findstr</code> filtering command supporting limited regular expressions, yielding a versatile and powerful combination for finding files by names and the names of their directories.

<code>for /r %i in (*) do @if %~zi geq 1000000 echo %~zi %i</code>For each file in the current folder and its sub-folders that has the size greater than or equal to 1,000,000 bytes, outputs the file size in bytes and the full path of the file. 
For the syntax in <code>%~zi</code>, see percent tilde.

<code>forfiles /s /d 06/10/2015 /c "cmd /c echo @fdate @path"</code>For each file in the current folder and its sub-folders modified on 10 June 2015 or later, outputs the file modification date and full file path. 
The date format after <code>/d</code> is locale specific. 
Thus, allows to find most recently modified files.

<code>(for /r %i in (*) do @echo %~ti :: %i) | findstr 2015.*::</code>Searching the current folder recursively, outputs files whose last modification date is in year 2015. 
Places the modification date and time, followed by a double colon, before the file name. 
Works as long as the used version of Windows and locale displays dates in a format that contains four-digit years. 
The double colon is used to make sure the <code>findstr</code> command is matching the date and not the file name.

<code>for /r %i in (*) do @echo %~ti | findstr 2015 &gt;NUL &amp;&amp; echo %i</code>As above, outputs files changed in 2015. 
Unlike the above, only outputs the files, not the modification dates.

<code>findstr /i /s /m cat.*mat *.txt</code>Finds files by their content. 
Performs a full text search for regular expression cat.*mat in files with names ending in <code>.txt</code>, and outputs the files names. 
The <code>/m</code> switch ensures only the file names are output.

<code>where *.bat</code>Outputs all .bat files in the current directory and in the directories that are in <code>PATH</code>.

<h2>Keyboard shortcuts</h2>

When using Windows command line from the standard console that appears after typing <code>cmd.exe</code> after pressing <code>Windows + R</code>, you can use multiple keyboard shortcuts, including function keys:

<code>Tab</code>: Completes the relevant part of the typed string from file names or folder names in the current folder. 
The relevant part is usually the last space-free part, but use of quotation marks changes that. 
Generally considers both files and folders for completion, but <code>cd</code> command only considers folders.
Up and down arrow keys: Enters commands from the command history, one at a time.

<code>Escape</code>: Erases the current command line being typed.

<code>F1</code>: Types the characters from the single previously entered command from the command history, one character at a time. 
Each subsequent press of <code>F1</code> enters one more character.

<code>F2</code>: Asks you to type a character, and enters the shortest prefix of the previous command from the command history that does not include the typed character. 
Thus, if the previous command was echo Hello world and you typed o, enters ech.

<code>F3</code>: Enters the single previous command from the command history. 
Repeated pressing has no further effect.

<code>F4</code>: Asks you to type a character, and erases the part of the currently typed string that starts at the current cursor location, continues to the right, and ends with the character you entered excluding that character. 
Thus, if you type echo Hello world, place the cursor at H using left arrow key, press F4 and then w, you get echo world.

<code>F5</code>: Enters previous commands from the command history, one at a time.

<code>F6</code>: Enters Control+Z character.

<code>F7</code>: Opens a character-based popup window with the command history, and lets you use arrow key and enter to select a command. 
After you press enter in the popup, the command is immediately executed.

<code>F8</code>: Given an already typed string, shows items from the command history that have that string as a prefix, one at a time.

<code>F9</code>: Lets you enter the number of the command from the command history, and then executes the command.

<code>Alt + F7</code>: Erases the command history.

The above are also known as command prompt keyboard shortcuts.
The availability of the above shortcuts does not seem to depend on running DOSKEY.

<h2>Paths</h2>

File and directory paths follow certain conventions. 
These include the possible use of a drive letter followed by a colon (<code>:</code>), the use of backslash (<code>\</code>) as the path separator, and the distinction between relative and absolute paths.
Forward slash (<code>/</code>) often works when used instead of (<code>\</code>) but not always; it is normally used to mark switches (options). 
Using forward slash can lead to various obscure behaviors, and is best avoided.
Special device names include <code>NUL</code>, <code>CON</code>, <code>PRN</code>, <code>AUX</code>, <code>COM1</code>, ...,<code> COM9</code>, <code>LPT1</code>, ..., <code>LPT9</code>; these can be redirected to.
Examples:

<code>attrib C:\Windows\System32\notepad.exe</code>Succeeds if the file exists, as it should. 
This is an <em>absolute </em>path with a drive letter. 
It is also known as a  <em>fully qualified</em> path.

<code>attrib \Windows\System32\notepad.exe</code>Succeeds if the current drive is <code>C:</code>, and if the file exists, as it should. 
This is an absolute path without a drive letter.

<code>cd /d C:\Windows &amp; attrib System32\notepad.exe</code>Succeeds if the file exists. 
The path given to <code>attrib</code> is a  relative path.

<code>cd /d C:\Windows\System32 &amp; attrib C:notepad.exe</code>Succeeds if the file exists. 
The path given to <code>attrib</code> is a  one despite containing a drive letter: there would have to be <code>C:\notepad.exe</code> with a backslash for that to be an absolute path.relative

<code>cd /d C:\Windows &amp; attrib .\System32\notepad.exe</code>Succeeds if the file exists. 
A single period denotes the current folder.

<code>attrib .</code>A single period denotes the current folder.

<code>cd /d C:\Windows &amp; attrib .\System32\\\notepad.exe</code>Succeeds if the file exists. 
Piling of backslashes has no impact beyond the first backslash.

<code>cd /d C:\Windows &amp; attrib .\System32</code>Succeeds if the folder exists.

<code>cd /d C:\Windows &amp; attrib .\System32\</code>Fails. 
Folders are usually denoted without the final backslash.

<code>cd C:\Windows\System32\</code>Succeeds.

<code>cd ..</code>A double period denotes the parent folder.

<code>attrib C:\Windows\System32\..\..\Windows\System32</code>A double period can be used in the middle of the path to navigate to the parent folder, even multiple times.

<code>attrib \\myserver\myvolume</code>A network UNC path starts with double backslash and no drive letter.

<code>cd \\myserver\myvolume</code>Does not work; changing to a server folder in this direct manner does not work.

<code>pushd \\myserver\folder</code>Automatically creates a drive for the folder and changes to it. 
After you use POPD, the drive gets unassigned again.

<code>attrib C:/Windows/System32/notepad.exe</code>Succeeds on multiple versions of <code>cmd.exe</code>. 
Uses forward slashes.

<h2>Arrays</h2>

Arrays can be emulated in the delayed expansion mode using the combination of <code>%</code> and <code>!</code> to indicate variables. 
There, <code>%i%</code> is the value of variable <code>i</code> with the immediate expansion while <code>!i!</code> is the value of variable <code>i</code> in the delayed expansion.

@echo off
setlocal EnableDelayedExpansion
for /l %%i in (1, 1, 10) do (
set array_%%i=!random!
)

for /l %%i in (1, 1, 10) do (
echo !array_%%i!
)

:: For each item in the array, not knowing the length
set i=1
:startloop
if not defined array_%i% goto endloop
set array_%i%=!array_%i%!_dummy_suffix
echo A%i%: !array_%i%!
set /a i+=1
goto startloop
:endloop

<h2>Perl one-liners</h2>

Some tasks can be conveniently achieved with Perl one-liners. 
Perl is a scripting language originating in the environment of another operating system. 
Since many Windows computing environments have Perl installed, Perl one-liners are a natural and compact extension of Windows batch scripting.
Examples:

<code>echo "abcbbc"| perl -pe "s/a.*?c/ac/"</code>Lets Perl act as sed, the utility that supports textual replacements specified using regular expressions.

<code>echo a b| perl -lane "print $F[1]"</code>Lets Perl act as cut command, displaying the 2nd field or column of the line, in this case b. 
Use <code>$F[2]</code> to display 3rd field; indexing starts at zero. 
Native solution: <code>FOR</code><code> /f</code>.

<code>perl -ne "print if /\x22hello\x22/" file.txt</code>Acts as grep or FINDSTR, outputting the lines in <code>file.txt</code> that match the regular expression after if. 
Uses the powerful Perl regular expressions, more powerful than those of FINDSTR.

<code>perl -ne "$. 
&lt;= 10 and print" MyFile.txt</code>Lets Perl act as head -10 command, outputting the first 10 lines of the file.

<code>perl -e "sleep 5"</code>Waits for 5 seconds.

<code>for /f %i in ('perl -MPOSIX -le "print strftime '%Y-%m-%d', localtime"') do @set isodate=%i</code>Gets current date in the ISO format into <code>isodate</code> variable.

<code>perl -MWin32::Clipboard -e "print Win32::Clipboard-&gt;Get()"</code>Outputs the text content of the clipboard. 
When stored to getclip.bat, yields a handy getclip command to complement CLIP command.

<code>perl -MText::Diff -e "print diff 'File1.txt', 'File2.txt'"</code>Outputs differences between two files in a format similar to diff command known from other operating systems, including context lines, lines starting with + and lines starting with -.

On the web, Perl one-liners are often posted in the command-line conventions of another operating system, including the use of apostrophe (<code>'</code>) to surround the arguments instead of Windows quotation marks. 
These need to be tweaked for Windows.

<h2>Limitations</h2>

There is no touch command familiar from other operating systems. 
The touch command would modify the last-modification timestamp of a file without changing its content.
One workaround, with unclear reliability and applicability across various Windows versions, is this:
<code>copy /b file.txt+,,</code>

<h2>Built-in commands</h2>

These commands are all built in to the command interpreter itself, and cannot be changed. 
Sometimes this is because they require access to internal command interpreter data structures, or modify properties of the command interpreter process itself.

<h4></h4>
<table>
<thead><tr>
<th width="168">Command</th>
<th width="526">Description</th>
</tr></thead>
<tbody>
<tr>
<td>ASSOC</td>
<td>Associates an extension with a file type (FTYPE).</td>
</tr>
<tr>
<td>BREAK</td>
<td>Sets or clears extended CTRL+C checking.</td>
</tr>
<tr>
<td>CALL</td>
<td>Calls one batch program from another.</td>
</tr>
<tr>
<td>CD, CHDIR</td>
<td>Displays or sets the current directory.</td>
</tr>
<tr>
<td>CHCP</td>
<td>Displays or sets the active code page number.</td>
</tr>
<tr>
<td>CLS</td>
<td>Clears the screen.</td>
</tr>
<tr>
<td>COLOR</td>
<td>Sets the console foreground and background colors.</td>
</tr>
<tr>
<td>COPY</td>
<td>Copies files.</td>
</tr>
<tr>
<td>DATE</td>
<td>Displays and sets the system date.</td>
</tr>
<tr>
<td>DEL, ERASE</td>
<td>Deletes one or more files.</td>
</tr>
<tr>
<td>DIR</td>
<td>Displays a list of files and subdirectories in a directory.</td>
</tr>
<tr>
<td>ECHO</td>
<td>Displays messages, or turns command echoing on or off.</td>
</tr>
<tr>
<td>ELSE</td>
<td>Performs conditional processing in batch programs when "IF" is not true.</td>
</tr>
<tr>
<td>ENDLOCAL</td>
<td>Ends localization of environment changes in a batch file.</td>
</tr>
<tr>
<td>EXIT</td>
<td>Quits the CMD.EXE program (command interpreter).</td>
</tr>
<tr>
<td>FOR</td>
<td>Runs a specified command for each file in a set of files.</td>
</tr>
<tr>
<td>FTYPE</td>
<td>Sets the file type command.</td>
</tr>
<tr>
<td>IF</td>
<td>Performs conditional processing in batch programs.</td>
</tr>
<tr>
<td>MD, MKDIR</td>
<td>Creates a directory.</td>
</tr>
<tr>
<td>MOVE</td>
<td>Moves a file to a new location</td>
</tr>
<tr>
<td>PATH</td>
<td>Sets or modifies the PATH environment</td>
</tr>
<tr>
<td>PAUSE</td>
<td>Causes the command session to pause for user input.</td>
</tr>
<tr>
<td>POPD</td>
<td>Changes to the drive and directory popped from the directory stack</td>
</tr>
<tr>
<td>PROMPT</td>
<td>Sets or modifies the string displayed when waiting for input.</td>
</tr>
<tr>
<td>PUSHD</td>
<td>Pushes the current directory onto the stack, and changes to the new directory.</td>
</tr>
<tr>
<td>RD / RMDIR</td>
<td>Removes the directory.</td>
</tr>
<tr>
<td>REM</td>
<td>A comment command. 
Unlike double-colon (::), the command can be executed.</td>
</tr>
<tr>
<td>REN / RENAME</td>
<td>Renames a file or directory</td>
</tr>
<tr>
<td>SET</td>
<td>Sets or displays shell environment variables</td>
</tr>
<tr>
<td>SETLOCAL</td>
<td>Creates a child-environment for the batch file.</td>
</tr>
<tr>
<td>SHIFT</td>
<td>Moves the batch parameters forward.</td>
</tr>
<tr>
<td>START</td>
<td>Starts a program with various options.</td>
</tr>
<tr>
<td>TIME</td>
<td>Displays or sets the system clock</td>
</tr>
<tr>
<td>TITLE</td>
<td>Changes the window title</td>
</tr>
<tr>
<td>TYPE</td>
<td>Prints the content of a file to the console.</td>
</tr>
<tr>
<td>VER</td>
<td>Shows the command processor, operating system versions.</td>
</tr>
<tr>
<td>VERIFY</td>
<td>Verifies that file copy has been done correctly.</td>
</tr>
<tr>
<td>VOL</td>
<td>Shows the label of the current volume.</td>
</tr>
</tbody>
</table>

<h2>External commands</h2>

External commands available to Windows command interpreter are separate executable program files, supplied with the operating system by Microsoft, or bundled as standard with the third-party command interpreters. 
By replacing the program files, the meanings and functions of these commands can be changed.
Many, but not all, external commands support the <code>/?</code> convention, causing them to write on-line usage information to their standard output and then to exit with a status code of 0.

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>