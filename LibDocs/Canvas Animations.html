<base target="_blank"><html><head><title>Canvas Animations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script type='text/javascript' src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
  var showTopicNumber = true;
  var bookid = "Canvas Animations"
  var markerName = "h3"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
pre{width:100%;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Canvas Animations</h1>

<br><br>
<div id="toc"></div></center>
<br><br>
https://codemyui.com/tag/canvas/
<pre>
<br>
<br>
You can create animations with HTML5 by combining HTML, CSS, and JavaScript (JS), with which you can build shapes. 
Also, you can control animations and <a href="https://cloudinary.com/blog/image_editing_basics_and_a_tutorial_for_automation_with_ai" data-popup="true">edit images</a>, video, and audio by means of JS or CSS elements, all of which you then add to a drawing board, which you set up with the <code>&lt;canvas&gt;</code> element.
This article shows you how to create simple animations in three examples. 

Also described are the HTML5 best practices for canvas optimization, including the procedures for prerendering to an off-screen canvas, batching together <code>canvas</code> calls, layering <code>canvas</code> for complex scenes, and implementing the <code>requestAnimationFrame()</code> method.
<h3>Definition of HTML5 Animation</h3> 
You create HTML5 animations with HTML’s <code>canvas</code> element, which acts as a drawing board for images on which are displayed multiple frames for animation. 
As mentioned earlier, to build HTML5 animations, you use HTML, CSS, and JS. 

Additional tools are available with which you can quickly create complex animations. 
Examples are <a href="https://cloudinary.com/dam-guide/dam-systems" data-popup="true">media management systems</a> and HTML5-animation software, which offer the drag-and-drop capability for placement of shapes and enable interactivity. 
HTML5 animation tools typically generate code, which you can then modify or embed in your sites or apps. 

<h3>Creation of Simple HTML5 Animations</h3>
To create animations with HTML5, you need shapes and a method for controlling the live actions. 
Recall that you can create shapes, which are JS elements, and control animations with CSS or through JS. 

You can also incorporate images, video, or audio by importing the appropriate elements. 

Follow these steps:
Set up a canvas by adding a <code>&lt;canvas&gt;</code> element to your HTML document, for example: 

<code>&lt;canvas id=&quot;myCanvas&quot; width=&quot;300&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</code>
Locate the element in your JS and create a drawing object with this code: 
let canvas = document.getElementById(&quot;myCanvas&quot;);
let ctx = canvas.getContext(&quot;2d&quot;);

Draw your shapes with a method, such as one of the following: 
<code>fillStyle(color|pattern|gradient)</code>: for setting the fill style of your shape.
<code>fillRect(x,y,w,h)</code>: for drawing a rectangle according to the specified coordinates and fill style.
<code>strokeStyle(color|pattern|gradient)</code>: for specifying a stroke style for your shape.

<code>strokeRect(x,y,w,h)</code>: for drawing a rectangle with borders that match the specified sizes, coordinates, and style. 

For all the drawing options, see the W3Schools’ <a href="https://www.w3schools.com/tags/ref_canvas.asp" data-popup="true"><em>HTML Canvas Reference</em></a>.
While drawing shapes, you can save your canvas state to create frames for rendering according to the parameters you set with the following JS methods:

<code>window.setInterval()</code>
<code>window.setTimeout()</code>
<code>window.requestAnimationFrame()</code>
<h3>HTML5 Animations with Code Examples</h3>

Below are three beautiful examples of HTML5 animations that showcase their types. 
To see the HTML, CSS, and JS code within each frame, click the buttons across the top left. 

<strong>Lightning, created by Jack Rugile</strong>

See the Pen <a href="https://codepen.io/jackrugile/pen/fxqKJ">
Canvas Lightning WIP</a> by Jack Rugile (<a href="https://codepen.io/jackrugile">@jackrugile</a>)
on <a href="https://codepen.io">CodePen</a>.
<strong>Tearable Mesh, created by dissimulate</strong>

See the Pen <a href="https://codepen.io/dissimulate/pen/KrAwx">
Tearable Cloth</a> by dissimulate (<a href="https://codepen.io/dissimulate">@dissimulate</a>)
on <a href="https://codepen.io">CodePen</a>.
<strong>Earth and Sun, created by MDN</strong>

See the Pen <a href="https://codepen.io/unicodeveloper/pen/LzNQYG">
An animated solar system</a> by Prosper Otemuyiwa (<a href="https://codepen.io/unicodeveloper">@unicodeveloper</a>)
on <a href="https://codepen.io">CodePen</a>.
<h3>HTML5 Best Practices for Canvas Optimization</h3>

For a smooth performance of animations, adopt the best practices below.
<h3>Prerender to an Off-Screen Canvas</h3>A majority of the scenes in many animations, such as games, contain repeated images or similar ones. 
Rather than reloading those images in your primary canvas each time, prerender the scenes in an off-screen canvas, after which you can move that canvas back in line with your primary one.
Such a practice not only boosts the performance of your animations, but also smooths out their appearance.

<h3>Batch Together Canvas Calls</h3>Drawing elements while scripting animations takes resources and time. 
For efficiency, consider loading multiple, shorter commands at once to the video buffer, which then processes each of the operations. 

For example:
context.beginPath();
for (let i = 0; i &lt; points.length - 1; i++) {
  let p1 = points[i];
  let p2 = points[i+1];
  context.moveTo(p1.x, p1.y);
  context.lineTo(p2.x, p2.y);
}

context.stroke(); **//Placing this method inside the for loop would result in poorer performance.**
<h3>Layer Canvases for Complex Scenes</h3>Layering canvases separates the rendering of larger elements. 
Do so by applying transparency to your top-layer <code>canvas</code> elements and a <code>background</code> canvas to those elements that you want to render. 
Assuming that your canvases are aligned, viewers will see a composite image of all the canvases on a rendering of your scene.

With layered canvases, you can keep the static elements of your animation as <a href="https://cloudinary.com/blog/how_to_automatically_and_professionally_remove_photo_backgrounds" data-popup="true">background</a> and create the moving elements in the other layers, saving you the trouble of having to refresh or rerender a majority of your scene.
<h3>Implementation of <code>requestAnimationFrame()</code></h3>The <code>requestAnimationFrame</code> method enables you to rely on your viewer’s browser to apply your set-rendering routine at the right time. 
That means that no rendering occurs if your page is not being viewed—as opposed to having the browser render scenes at a fixed rate regardless of whether the viewer is on your page.
Having the browser determine when to render animations eliminates waste of processing power when they are out of view. 

However, when applying <code>requestAnimationFrame()</code>, be sure to verify that the browser is rendering the animation smoothly. 
As a rule, with <code>requestAnimationFrame()</code> in place, browsers render animations at 60 FPS, but that’s not guaranteed. 
  
The following code adds a check for smoothness:
let x = 50;
let y = 50;
let lastRender = Date.now();
function render() {
  let delta = Date.now() - lastRender;
  x += delta;
  y += delta;
  context.fillRect(x, y, W, H);
  requestAnimationFrame(render);
}
render();
<h3>Generation of GIF-Based Animations With Cloudinary</h3>
Generating animated GIFs on Cloudinary is a simple, intuitive process: 
Create your images with Cloudinary <a href="https://cloudinary.com/blog/how_to_overlay_text_on_image_easily_pixel_perfect_and_with_no_css_html" data-popup="true">overlays</a> and chained transformations. 

Properly position the images that are in or outside the canvas with custom overlay coordinates.

Add a simple script that programmatically generates transformation URLs and pass them to Cloudinary’s upload API call as the criteria for generating new images.
In Cloudinary, you can create a “sprite”—a single, cloud-based GIF—by merging together images that share the same tag. 
For a step-by-step tutorial, see our post <a href="https://dam-files.cloudinary.com/blog/cloud_based_animated_gif_generation" data-popup="true"><em>Create Cloud-Based Animation Sequence GIFs</em></a>.
<h3>Display of Video Content With Cloudinary</h3>

Beyond animations, most websites need a convenient way to process and display video. 
Cloudinary is the answer: it’s a cloud-based platform on which you can dynamically transcode and manipulate videos, optimizing file formats and sizes to any device, browser, or media channel. 
Additionally, you can easily perform these tasks on that platform:
Embed videos in webpages and apps with Cloudinary’s dynamic URLs.
Integrate your videos with URL-based APIs and SDKs.
Deliver smooth video-streaming through multiple CDNs and live-stream from any device, including sharing on social media. 

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
