<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{width: 80%;margin-left: 10%}
li{text-align: left; margin-left: 20%;}
h1, h2 {color: gold;}
pre{width: 100%; margin-left: 0px;}
</style>

</head><body>
<center><h1>Regular Expression Notes</h1>
<div id="toc"></div></center>

<pre>
<h2>Capturing group</h2>
(abc){3} matches abcabcabc.
(向現){2} matches 向現向現.

<h2>Non-Captured Group</h2>
example
Regex Code :- (?:animal)(?:=)(\w+)(,)\1\2

Search String :-
Line 1 - animal=cat,dog,cat,tiger,dog
Line 2 - animal=cat,cat,dog,dog,tiger
Line 3 - animal=dog,dog,cat,cat,tiger

(?:animal)	Non-Captured Group 1
(?:=)		Non-Captured Group 2
(\w+)		Captured Group 1
(,)		Captured Group 2
\1		result of captured group 1 i.e In Line 1 is cat,In Line 2 is cat,In Line 3 is dog.
\2		result of captured group 2 i.e comma(,)

<h2>not include &lt;/a&gt;</h2>
not include 向現
^((?!向現).)*$
向現
test
one two
a向現s
three

not include &lt;/a&gt;
^((?!&lt;/a&gt;).)*$

Finding tags Not Containing img
<[^img].+?>

to find all instances of "foo" not either preceded by a "." or succeeded by a "/".

(?=subexp)         look-ahead
(?!subexp)         negative look-ahead
(?<=subexp)        look-behind
(?&lt;!subexp)        negative look-behind

(?&lt;!\.)foo(?!/)

The ^ inside square brackets negates the expression. So to find a "foo" not preceded by a "." would be:

[^.]foo
<[^img]
[^0-9\r\n] matches any character that is not a digit or a line break.
q[^u] means: "a q followed by a character that is not a u"

<a href="https://www.regular-expressions.info/charclass.html">Negated Character Classes</a>
<a href="https://www.ocpsoft.org/tutorials/regular-expressions/and-in-regex/">“And” in regular expressions `&&`</a>


<h2>Grouping</h2>
(x)	
Matches x and remembers the match. 
These are called capturing groups.

For example, /(foo)/ matches and remembers "foo" in "foo bar". 

The capturing groups are numbered according to the order of left parentheses of capturing groups, starting from 1. 
The matched substring can be recalled from the resulting array's elements [1], ..., [n] or from the predefined RegExp object's properties $1, ..., $9.

(?:x)
Matches x but does not remember the match. 
These are called non-capturing groups. 
The matched substring cannot be recalled from the resulting array's elements [1], ..., [n] or from the predefined RegExp object's properties $1, ..., $9.

<a href="https://www.regextester.com/15">Regular Expression examples</a>
<a href="https://www.javamex.com/tutorials/regular_expressions/non_capturing_groups.shtml">Non-capturing groups</a>

<a href="https://www.regular-expressions.info/refcapture.html">Capturing Groups and Backreferences</a>
<br>


<h2>Regular Expression Recipes</h2>
<a href="Regular Expression Recipes.html">Regular Expression Recipes</a>
strip all HTML tags
<(.|\n)+?>

strip digits
\d{1,3}.?
strip digits with decimals
(\d*\.)?\d+

<table>
<tr><td><A HREF="brackets.html" TARGET="_top">Capturing group</A></td>
    <td><TT>(regex)</TT></td>
    <td>Parentheses group the regex between them.  They capture the text matched by the regex inside them into a numbered group that can be reused with a numbered backreference.  They allow you to apply regex operators to the entire grouped regex.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">{3}</SPAN></TT> matches <TT CLASS=match>abcabcabc</TT>.  First group matches <TT CLASS=match>abc</TT>.</td>
</tr>

<tr><td><A HREF="brackets.html" TARGET="_top">Capturing group</A></td>
    <td><TT>\(regex\)</TT></td>
    <td>Escaped parentheses group the regex between them.  They capture the text matched by the regex inside them into a numbered group that can be reused with a numbered backreference.  They allow you to apply regex operators to the entire grouped regex.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">\(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">\)</SPAN><SPAN CLASS="regexplain">{3}</SPAN></TT> matches <TT CLASS=match>abcabcabc</TT>.  First group matches <TT CLASS=match>abc</TT>.</td>
</tr>

<tr><td><A HREF="brackets.html" TARGET="_top">Non-capturing group</A></td>
    <td><TT>(?:regex)</TT></td>
    <td>Non-capturing parentheses group the regex so you can apply regex operators, but do not capture anything.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(?:</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">{3}</SPAN></TT> matches <TT CLASS=match>abcabcabc</TT>.  No groups.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\1</TT> through <TT>\9</TT></td>
    <td>Substituted with the text matched between the 1st through 9th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\1</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\10</TT> through <TT>\99</TT></td>
    <td>Substituted with the text matched between the 10th through 99th numbered capturing group.</td>
    <td></td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\k&lt;1&gt;</TT> through <TT>\k&lt;99&gt;</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\k&lt;1&gt;</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\k'1'</TT> through <TT>\k'99'</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\k'1'</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\g1</TT> through <TT>\g99</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\g1</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\g{1}</TT> through <TT>\g{99}</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\g{1}</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\g&lt;1></TT> through <TT>\g&lt;99></TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\g&lt;1&gt;</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>\g'1'</TT> through <TT>\g'99'</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">\g'1'</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backref.html" TARGET="_top">Backreference</A></td>
    <td><TT>(?P=1)</TT> through <TT>(?P=99)</TT></td>
    <td>Substituted with the text matched between the 1st through 99th numbered capturing group.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">abc</SPAN><SPAN CLASS="regexnest1">|</SPAN><SPAN CLASS="regexplain">def</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexplain">=</SPAN><SPAN CLASS="regexspecial">(?P=1)</SPAN></TT> matches <TT CLASS=match>abc=abc</TT> or <TT CLASS=match>def=def</TT>, but not <TT CLASS=string>abc=def</TT> or <TT CLASS=string>def=abc</TT>.</td>
</tr>

<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\k&lt;-1&gt;</TT>, <TT>\k&lt;-2&gt;</TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\k&lt;-3&gt;</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>

<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\k'-1'</TT>, <TT>\k'-2'</TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\k'-3'</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>
<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\g-1</TT>, <TT>\g-2</TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\g-3</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>

<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\g{-1}</TT>, <TT>\g{-2}</TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\g{-3}</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>

<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\g&lt;-1></TT>, <TT>\g&lt;-2></TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\g&lt;-3&gt;</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>

<tr><td><A HREF="backrefrel.html" TARGET="_top">Relative Backreference</A></td>
    <td><TT>\g'-1'</TT>, <TT>\g'-2'</TT>, etc.</td>
    <td>Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">b</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">c</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">d</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">\g'-3'</SPAN></TT> matches <TT CLASS=match>abcdb</TT>.</td>
</tr>

<tr><td><A HREF="backref2.html" TARGET="_top">Failed backreference</A></td>
    <td>Any numbered backreference</td>
    <td>Backreferences to groups that did not participate in the match attempt fail to match.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">?</SPAN><SPAN CLASS="regexspecial">\1</SPAN></TT> matches <TT CLASS=match>aa</TT> but fails to match <tt class=string>b</tt>.</td>
</tr>

<tr><td><a href="backref2.html#invalid">Invalid backreference</a></td>
    <td>Any numbered backreference</td>
    <td>Backreferences to groups that do not exist at all are valid but fail to match anything.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">?</SPAN><SPAN CLASS="regexspecial">\2</SPAN><SPAN CLASS="regexspecial">|</SPAN><SPAN CLASS="regexplain">b</SPAN></TT> matches <TT CLASS=match>b</TT> in <tt class=string>aab</tt>.</td>
</tr>

<tr><td><a href="backref2.html#nested">Nested backreference</a></td>
    <td>Any numbered backreference</td>
    <td>Backreferences can be used inside the group they reference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexspecial">\1</SPAN><SPAN CLASS="regexspecial">?</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">{3}</SPAN></TT> matches <TT CLASS=match>aaaaaa</TT>.</td>
</tr>

<tr><td><a href="backref2.html#forward">Forward reference</a></td>
    <td>Any numbered backreference</td>
    <td>Backreferences can be used before the group they reference.</td>
    <td><TT CLASS=code><SPAN CLASS="regexnest1">(</SPAN><SPAN CLASS="regexspecial">\2</SPAN><SPAN CLASS="regexspecial">?</SPAN><SPAN CLASS="regexnest2">(</SPAN><SPAN CLASS="regexplain">a</SPAN><SPAN CLASS="regexnest2">)</SPAN><SPAN CLASS="regexnest1">)</SPAN><SPAN CLASS="regexspecial">{3}</SPAN></TT> matches <TT CLASS=match>aaaaaa</TT>.</td>
</tr>

<tr><th>Feature</th><th>Syntax</th><th>Description</th><th>Example</th>
</tr>

</table>

<h2>RegReplace User Guide</h2>
<a href="RegReplace User Guide.html">sublime RegReplace User Guide</a>

<h2>create a regex macro example</h2>
<a href="https://www.tomordonez.com/create-a-regex-macro-in-sublime.html">create a regex macro example in sublime</a>
<br>


<br><br><br><br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
