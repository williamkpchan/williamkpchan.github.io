<base target="_blank"><html><head><title>d3 tutorials</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var bookid = "d3 tutorials"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color: #020; border:1px solid green;}
</style></head><body onkeypress="chkKey()"><center>
<h1></h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
</div>
<pre>
<br>
<br>
<a href="https://alignedleft.com/tutorials/d3" class="whitebut ">d3 tutorials</a>

These tutorials address an older version of D3 (3.x) and will no longer be updated. 
See my book <a href="https://alignedleft.com/work/d3-book-2e"><em>Interactive Data Visualization for the Web, 2nd Ed.</em></a> to learn all about the current version of D3 (4.x).

<h2>Structure</h2>
Each tutorial includes

Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

Working with D3 requires an appreciation of the following concepts.

<h2>HTML</h2>
Hypertext Markup Language is used to structure content for web browsers. 
The simplest HTML page looks like this:

<code>&lt;html>
    &lt;head>
        &lt;title>Page Title&lt;/title>
    &lt;/head>
    &lt;body>
        &lt;h1>Page Title&lt;/h1>
        &lt;p>This is a really interesting paragraph.&lt;/p>
    &lt;/body>
&lt;/html></code>

<h2>DOM</h2>
The Document Object Model refers to the hierarchical structure of HTML. 
Each bracketed tag is an <em>element</em>, and we refer to elements’ relative relationships to each other in human terms: parent, child, sibling, ancestor, and descendant. 
In the HTML above, <code>body</code> is the parent element to both of its children, <code>h1</code> and <code>p</code> (which are siblings to each other). 
All elements on the page are descendants of <code>html</code>.

Web browsers parse the DOM in order to make sense of a page’s content.

<h2>CSS</h2>
Cascading Style Sheets are used to style the visual presentation of HTML pages. 
 A simple CSS stylesheet looks like this:

<code>body {
    background-color: white;
    color: black;
}</code>

CSS styles consist of <em>selectors</em> and <em>rules</em>. 
Selectors identify specific elements to which styles will be applied:

<code>h1          /* Selects level 1 headings              */
p           /* Selects paragraphs                    */
.caption    /* Selects elements with class "caption" */
#subnav     /* Selects element with ID "subnav"      */</code>

Rules are properties that, cumulatively, form the styles:

<code>color: pink;
background-color: yellow;
margin: 10px;
padding: 25px;</code>

We connect selectors and rules using curly brackets:

<code>p {
    font-size: 12px;
    line-height: 14px;
    color: black;
}</code>

D3 uses CSS-style selectors to identify elements on which to operate, so it’s important to understand how to use them.

CSS rules can be included directly within the <code>head</code> of a document, like so

<code>&lt;head>
    &lt;style type="text/css">
        p {
            font-family: sans-serif;
            color: lime;
        }
    &lt;/style>
&lt;/head></code>

or saved in an external file with a <code>.css</code> suffix, and then referenced in the document’s <code>head</code>:

<code>&lt;head>
    &lt;link rel="stylesheet" href="style.css">
&lt;/head></code>

<h2>JavaScript</h2>
JavaScript is a dynamic scripting language that can instruct the browser to make changes to a page after it has already loaded.

Scripts can be included directly in HTML, between two <code>script</code> tags

<code>&lt;body>
    &lt;script type="text/javascript">
        alert("Hello, world!");
    &lt;/script>
&lt;/body></code>

or stored in a separate file, and then referenced somewhere the HTML (commonly in the <code>head</code>):

<code>&lt;head>
    &lt;title>Page Title&lt;/title>
    &lt;script type="text/javascript" src="https://alignedleft.com/tutorials/d3/myscript.js">&lt;/script>
&lt;/head></code>

<h2>Developer Tools</h2>
Be familiar with your browser’s developer tools. 
In a WebKit browser (like Safari or Chrome), you can open the web inspector, which looks something like this:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/20-fundamentals/web_inspector.png">
While “View Source” shows you the original HTML source of the page, the web inspector shows you the <em>current state of the DOM</em>. 
This is useful because your code will modify DOM elements dynamically. 
In the web inspector, you can watch elements as they change. 
You’ll also use the JavaScript console for debugging. 
See more on <a href="https://developer.chrome.com/devtools">debugging HTML, CSS, and JavaScript with the web inspector and console</a>.

<h2>SVG</h2>
D3 is at its best when rendering visuals as Scalable Vector Graphics. 
SVG is a text-based image format. 
Meaning, you can specify what an SVG image should look like by writing simple markup code, sort of like HTML tags. 
In fact, SVG code can be included directly within any HTML document. 
Web browsers have supported the SVG format for years (<a href="http://caniuse.com/#feat=svg">except for Internet Explorer</a>), but it never quite caught on, until now.

Here’s a little circle that I just coded into this page:

<svg width="50" height="50"><circle cx="25" cy="25" r="22" fill="blue" stroke="gray" stroke-width="2"></circle></svg>
<code>&lt;svg width="50" height="50">
    &lt;circle cx="25" cy="25" r="22"
     fill="blue" stroke="gray" stroke-width="2"/>
&lt;/svg></code>

Go ahead — right-click on it: it’s not an image! Zoom your browser and you’ll see it scales up and down smoothly, as a vector graphic should.

You’re not required to use SVG with D3, but you’ll soon find that SVG provides a range of visual opportunities that aren’t possible with regular HTML elements.

<h2>Downloading D3</h2>
Start by creating a new folder for your project. 
 Within that folder, I recommend creating a sub-folder called <code>d3</code>. 
 Then <a href="http://d3js.org/d3.v3.js">download the latest version of d3.v3.js</a> into that sub-folder. 
 As of this writing, the current version of D3 is 3.4.2.

D3 is also provided in a “minified” version, <a href="http://d3js.org/d3.v3.min.js">d3.v3.min.js</a>, from which whitespace has been removed for smaller file sizes and faster load times. 
 The functionality is the same, but typically you’d use the regular version while working on a project (for friendlier debugging), and then switch to the minified version once you’ve launched the project publicly (for optimized load times). 
 The choice is up to you, but in these tutorials we’ll be using the standard version.

A third option is to download the entire D3 repository, which gives you not just the JavaScript files, but also all of the component source code. 
You can <a href="https://github.com/mbostock/d3/releases">download the whole thing as a compressed ZIP file</a>.

<h2>Referencing D3</h2>
Create a simple HTML page within your project folder named <code>index.html</code>. 
Your folder structure should now look something like this:

<code>project-folder/
    d3/
        d3.v3.js
        d3.v3.min.js (optional)
    index.html</code>

Now paste the following into your HTML file, so it references D3 in the <code>head</code> and provides room for your JavaScript code:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
    &lt;head>
        &lt;meta charset="utf-8">
        &lt;title>D3 Test&lt;/title>
        &lt;script type="text/javascript" src="https://alignedleft.com/tutorials/d3/d3/d3.v3.js">&lt;/script>
    &lt;/head>
    &lt;body>
        &lt;script type="text/javascript">
            // Your beautiful D3 code will go here
        &lt;/script>
    &lt;/body>
&lt;/html>     </code>

<h2>Viewing Your Page</h2>
In some cases, you can just open your HTML file in a web browser to view it. 
 However, when loading external data sources, it is more reliable to run a local web server and view your page from <code>http://localhost:8888/</code>. 
You could use a server like <a href="http://mamp.info/en/">MAMP</a> or see <a href="https://github.com/mbostock/d3/wiki">the notes on the wiki</a> on activating a quick, temporary server.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

One of your first steps will be to use D3 to create a new DOM element. 
Typically, this will be an SVG object for rendering a data visualization, but we’ll start simple, and just create a <code>p</code> paragraph element.

Begin with this simple HTML template:

<code>&lt;!DOCTYPE html>
&lt;html lang="en">
    &lt;head>
        &lt;meta charset="utf-8">
        &lt;title>D3 Test&lt;/title>
        &lt;script type="text/javascript" src="https://alignedleft.com/tutorials/d3/d3/d3.v3.js">&lt;/script>
    &lt;/head>
    &lt;body>
        &lt;script type="text/javascript">
            // Your beautiful D3 code will go here
        &lt;/script>
    &lt;/body>
&lt;/html></code>

<a href="https://alignedleft.com/tutorials/d3/adding-elements/./1.html">Here’s a demo page with that code.</a> Yes, it doesn’t look like much, but open up your web inspector, and you should see something like:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/40-adding-elements/1.png">
Back in your HTML, replace the comment between the <code>script</code> tags with:

<code>d3.select("body").append("p").text("New paragraph!");</code>

Save and refresh (or <a href="https://alignedleft.com/tutorials/d3/adding-elements/./2.html">view the corresponding demo page</a>), and voilà! There is text in the formerly empty browser window, and the following in the web inspector:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/40-adding-elements/2.png">
See the difference? Now in the DOM, there is a new paragraph element that was generated on-the-fly! This may not be exciting yet, but you will soon use a similar technique to dynamically generate tens or hundreds of elements, each one corresponding to a piece of your data set.

Let’s walk through what just happened. 
 In sequence, we:

<ol>
<li>Invoked D3's <code>select</code> method, which selects a single element from the DOM using CSS selector syntax. 
(We selected the <code>body</code>.)</li>
<li>Created a new <code>p</code> element and appended that to the end of our selection, meaning just <em>before</em> the closing <code>&lt;/body></code> tag in this case.</li>
<li>Set the text content of that new, empty paragraph to “New paragraph!”</li>
</ol>
All of those crazy dots are just part of D3’s <em>chain syntax</em>.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

D3 smartly employs a technique called <em>chain syntax</em>, which you may recognize from jQuery. 
By “chaining” methods together with periods, you can perform several actions in a single line of code. 
It can be fast and easy, but it’s important to understand how it works, to save yourself hours of debugging headaches later.

By the way, <em>functions</em> and <em>methods</em> are just two different words for the same concept: a chunk of code that accepts an argument as input, performs some action, and returns some data as output.

Let’s revisit our first line of D3 code (<a href="https://alignedleft.com/tutorials/d3/chaining-methods/./index.html">demo page here</a>).

<code>d3.select("body").append("p").text("New paragraph!");</code>

This may look like a big mess, especially if you’re new to programming. 
So the first thing to know is that JavaScript, like HTML, doesn’t care about whitespace and line breaks, so you can put each method on its own line for legibility:

<code>d3.select("body")
    .append("p")
    .text("New paragraph!");</code>

Everyone has their own coding style. 
Use whatever indents, line breaks, and whitespace (tabs or spaces) works for you.

<h2>One Link at a Time</h2>
Let’s deconstruct each piece of this code.

<code>d3</code> — References the D3 object, so we can access its methods.

<code>.select("body")</code> — Give <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select"><code>select()</code></a> a CSS selector as input, and it will return a reference to the first element in the DOM that matches. 
(Use <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll"><code>selectAll()</code></a> when you need more than one element.) In this case, we just want the <code>body</code>, so a reference to <code>body</code> is handed off to the next method in our chain.

<code>.append("p")</code> — <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-append"><code>append()</code></a> creates whatever new DOM element you specify and appends it to the end (but <em>just inside</em>) of whatever selection it’s acting on. 
In our case, we want to create a new <code>p</code> within the <code>body</code>. 
We specified <code>"p"</code> as the input argument, but this method also sees the reference to <code>body</code> that was passed down the chain from the <code>select()</code> method. 
Finally, <code>append()</code>, in turn, hands down a reference to the new element it just created.

<code>.text("New paragraph!")</code> — <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-text"><code>text()</code></a> takes a string and inserts it between the opening and closing tags of the current selection. 
Since the previous method passed down a reference to our new <code>p</code>, this code just inserts the new text between <code>&lt;p></code> and <code>&lt;/p></code>. 
(In cases where there is existing content, it will be overwritten.)

<code>;</code> — The all-important semicolon indicates the end of this line of code.

<h2>The Hand-off</h2>
Many, but not all, D3 methods return a selection (or, really, reference to a selection), which enables this handy technique of method chaining. 
Typically, a method returns a reference to the element that it just acted upon, but not always.

So remember: When chaining methods, order matters. 
The output type of one method has to match the input type expected by the next method in the chain. 
If adjacent inputs and outputs are mismatched, the hand-off will function more like a dropped baton in a middle-school relay race.

When sussing out what each function expects and returns, <a href="https://github.com/mbostock/d3/wiki/API-Reference">the API reference</a> is your friend. 
It contains detailed information on each method, including whether or not it returns a selection.

<h2>Going Chainless</h2>
Our sample code could be rewritten without chain syntax as:

<code>var body = d3.select("body");
var p = body.append("p");
p.text("New paragraph!");</code>

Ugh! What a mess. 
Yet there will be times you need to break the chain, such as when you are calling so many functions that it doesn't make sense to string them all together. 
Or just because you want to organize your code in a way that makes more sense to you.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

What is binding, and why would I want to do it to my data?

Data visualization is a process of <em>mapping</em> data to visuals. 
Data in, visual properties out. 
Maybe bigger numbers make taller bars, or special categories trigger brighter colors. 
The mapping rules are up to you.

With D3, we <em>bind</em> our data input values to elements in the DOM. 
Binding is like “attaching” or associating data to specific elements, so that later you can reference those values to apply mapping rules. 
Without the binding step, we have a bunch of data-less, un-mappable DOM elements. 
No one wants that.

<h2>In a Bind</h2>
We use D3’s <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data"><code>selection.data()</code></a> method to bind data to DOM elements. 
But there are two things we need in place first, before we can bind data:

<ol>
<li>The data</li>
<li>A selection of DOM elements</li>
</ol>
Let’s tackle these one at a time.

<h2>Data</h2>
D3 is smart about handling different kinds of data, so it will accept practically any array of numbers, strings, or objects (themselves containing other arrays or key/value pairs). 
 It can handle JSON (and GeoJSON) gracefully, and even has a built-in method to help you load in CSV files.

But to keep things simple, for now we will start with a boring array of numbers. 
 Here is our sample data set:

<code>var dataset = [ 5, 10, 15, 20, 25 ];</code>

<h2>Please Make Your Selection</h2>
First, you need to decide what to select. 
That is, what elements will your data be associated with? Again, let’s keep it super simple and say that we want to make a new paragraph for each value in the data set. 
So you might imagine something like this would be helpful

<code>d3.select("body").selectAll("p")</code>

and you’d be right, but there’s a catch: The paragraphs we want to select <em>don’t exist yet</em>. 
And this gets at one of the most common points of confusion with D3: How can we select elements that don’t yet exist? Bear with me, as the answer may require bending your mind a bit.

The answer lies with <code>enter()</code>, a truly magical method. 
Here’s our final code for this example, which I’ll explain:

<code>d3.select("body").selectAll("p")
    .data(dataset)
    .enter()
    .append("p")
    .text("New paragraph!");</code>

<a href="https://alignedleft.com/tutorials/d3/binding-data/./index.html">Now look at what that code does on this demo page.</a> You see five new paragraphs, each with the same content. 
Here’s what’s happening.

<code>d3.select("body")</code> — Finds the <code>body</code> in the DOM and hands a reference off to the next step in the chain.

<code>.selectAll("p")</code> — Selects all paragraphs in the DOM. 
Since none exist yet, this returns an empty selection. 
Think of this empty selection as representing the paragraphs that <em>will soon exist</em>.

<code>.data(dataset)</code> — Counts and parses our data values. 
There are five values in our data set, so everything past this point is executed five times, once for each value.

<code>.enter()</code> — To create new, data-bound elements, you must use <code>enter()</code>. 
This method looks at the DOM, and then at the data being handed to it. 
If there are more data values than corresponding DOM elements, then <code>enter()</code> <em>creates a new placeholder element</em> on which you may work your magic. 
It then hands off a reference to this new placeholder to the next step in the chain.

<code>.append("p")</code> — Takes the placeholder selection created by <code>enter()</code> and inserts a <code>p</code> element into the DOM. 
Hooray! Then it hands off a reference to the element it just created to the next step in the chain.

<code>.text("New paragraph!")</code> — Takes the reference to the newly created <code>p</code> and inserts a text value.

<h2>Bound and Determined</h2>
All right! Our data has been read, parsed, and bound to new <code>p</code> elements that we created in the DOM. 
Don’t believe me? Head back to <a href="https://alignedleft.com/tutorials/d3/binding-data/./index.html">the demo page</a> and whip out your web inspector.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/60-binding-data/1.png">
Okay, I see five paragraphs, but where’s the data? Click on <em>Console</em>, type in the following JavaScript/D3 code, and hit enter:

<code>console.log(d3.selectAll("p"))</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/60-binding-data/2.png">
An array! Click the small, gray disclosure triangle to reveal more:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/60-binding-data/3.png">
You’ll notice the five <code>HTMLParagraphElement</code>s, numbered 0 through 4. 
Click the disclosure triangle next to the first one (number zero).

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/60-binding-data/4.png">
See it?  Do you see it?  I can barely contain myself. 
 There it is:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/60-binding-data/5.png">
Our first data value, the number <code>5</code>, is showing up under the first paragraph’s <code>__data__</code> attribute. 
Click into the other paragraph elements, and you’ll see they also contain <code>__data__</code> values: 10, 15, 20, and 25, just as we specified.

You see, when D3 binds data to an element, that data doesn’t exist in the DOM, but it does exist in memory as a <code>__data__</code> attribute of that element. 
And the console is where you can go to confirm whether or not your data was bound as expected.

The data is ready. 
Let’s do something with it.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

Once you’ve loaded in your data and bound it to newly created elements in the DOM, how can you <em>use</em> it? Here’s our code from last time:

<code>var dataset = [ 5, 10, 15, 20, 25 ];

d3.select("body").selectAll("p")
    .data(dataset)
    .enter()
    .append("p")
    .text("New paragraph!");</code>

Let’s change the last line to:

<code>    .text(function(d) { return d; });</code>

<a href="https://alignedleft.com/tutorials/d3/using-your-data/./1.html">Check out what the new code does on this demo page.</a> 

Whoa! We used our data to populate the contents of each paragraph, all thanks to the magic of the <code>data()</code> method. 
You see, when chaining methods together, anytime after you call <code>data()</code>, you can create an anonymous function that accepts <code>d</code> as input. 
 The magical <code>data()</code> method ensures that <code>d</code> is set to the corresponding value in your original data set, given the current element at hand.

The value of “the current element” changes over time as D3 loops through each element. 
 For example, when looping through the third time, our code creates the third <code>p</code> tag, and <code>d</code> will correspond to the third value in our data set (or <code>dataset[2]</code>). 
So the third paragraph gets text content of “15”.

<h2>High-functioning</h2>
In case you’re new to writing your own functions (a.k.a. 
methods), the basic structure of a function definition is:

<code>function(input_value) {
    //Calculate something here
    return output_value;
}</code>

The function we used above is dead simple, nothing fancy

<code>function(d) {
    return d;
}</code>

and it’s wrapped within D3’s <code>text()</code> function, so whatever our function returns is handed off to <code>text()</code>.

<code>.text(function(d) {
    return d;
});</code>

But we can (and will) get much fancier, because you can customize these functions however you want. 
Yes, it’s the pleasure and pain of writing your own JavaScript. 
We can define our own custom functions however we want. 
Maybe you’d like to add some extra text, which <a href="https://alignedleft.com/tutorials/d3/using-your-data/./2.html">produces this result</a>.

<code>.text(function(d) {
    return "I can count up to " + d;
});</code>

<h2>Data Wants to be Held</h2>
You may be wondering why you have to write out <code>function(d)...</code> instead of just <code>d</code> on its own. 
 For example, this won’t work:

<code>.text("I can count up to " + d);</code>

In this context, without wrapping <code>d</code> in an anonymous function, <code>d</code> has no value. 
 Think of <code>d</code> as a lonely little placeholder value that just needs a warm, containing hug from a kind, caring function’s parantheses. 
 (Extending this metaphor further, yes, it is creepy that the hug is being given by an <em>anonymous</em> function —stranger danger! — but that only confuses matters.)

Here is <code>d</code> being gently and appropriately held by a function:

<code>.text(function(d) {  // &lt;-- Note tender embrace at left
    return "I can count up to " + d;
});</code>

The reason for this syntax is that <code>.text()</code>, <code>attr()</code>, and many other D3 methods take a function as an argument. 
 For example, <code>text()</code> can take either simply a static string of text as an argument:

<code>.text("someString")</code>

…<em>or</em> the result of a function:

<code>.text(someFunction())</code>

…<em>or</em> an anonymous function itself can be the argument, such as when you write:

<code>.text(function(d) {
    return d;
})</code>

Above, you are defining an anonymous function. 
 If D3 sees a function there, it will <em>call</em> that function, while handing off the current datum <code>d</code> as the function’s argument. 
 Without the function in place, D3 can’t know to whom it should hand off the argument <code>d</code>.

At first, this may seem silly and like a lot of extra work to just get at <code>d</code>, but the value of this approach will become clear as we work on more complex pieces.

<h2>Beyond Text</h2>
Things get a lot more interesting when we explore D3’s other methods, like <code>attr()</code> and <code>style()</code>, which allow us to set HTML attributes and CSS properties on selections, respectively.

For example, adding one more line to our code <a href="https://alignedleft.com/tutorials/d3/using-your-data/./3.html">produces this result</a>.

<code>.style("color", "red");</code>

All the text is now red; big deal. 
But we could use a custom function to make the text red only if the current datum exceeds a certain threshold. 
So we revise that last line to use a function:

<code>.style("color", function(d) {
    if (d > 15) {   //Threshold of 15
        return "red";
    } else {
        return "black";
    }
});</code>

<a href="https://alignedleft.com/tutorials/d3/using-your-data/./4.html">See that code in action.</a> Notice how the first three lines are black, but once <code>d</code> exceeds the arbitrary threshold of 15, the text turns red.

In the next tutorial, we’ll use <code>attr()</code> and <code>style()</code> to manipulate <code>div</code>s, generating a simple bar chart — our first visualization!


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

It’s time to start drawing with data.

Let’s continue working with our simple data set from last time:

<code>var dataset = [ 5, 10, 15, 20, 25 ];</code>

We’ll use this to generate a super-simple bar chart. 
Bar charts are essentially just rectangles, and an HTML <code>&lt;div></code> is the easiest way to draw a rectangle. 
(Then again, to a web browser, <em>everything</em> is a rectangle, so you could easily adapt this example to use <code>span</code>s or whatever element you prefer.)

This <code>div</code> could work well as a data bar:

<div style="display: inline-block;
width: 20px;
height: 75px;
background-color: teal;"></div>

<code>&lt;div style="display: inline-block;
            width: 20px;
            height: 75px;
            background-color: teal;">&lt;/div></code>

(Among web standards folks, this is a semantic no-no. 
Normally, one shouldn’t use an empty <code>div</code> for purely visual effect, but coding tutorials are notable exceptions.)

Because this is a <code>div</code>, its <code>width</code> and <code>height</code> are set with CSS styles. 
Each bar in our chart will share the same display properties (except for <code>height</code>), so I’ll put those shared styles into a class called <code>bar</code>:

<code>div.bar {
    display: inline-block;
    width: 20px;
    height: 75px;   /* We'll override this later */
    background-color: teal;
}</code>

Now each <code>div</code> needs to be assigned the <code>bar</code> class, so our new CSS rule will apply. 
If you were writing the HTML code by hand, you would write:

<code>&lt;div class="bar">&lt;/div></code>

Using D3, to add a class to an element, we use the <code>selection.attr()</code> method. 
It’s important to understand the difference between <code>attr()</code> and its close cousin, <code>style()</code>.

<h2>Setting Attributes</h2>
<a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr"><code>attr()</code></a> is used to set an HTML attribute and its value on an element. 
An HTML attribute is any property/value pair that you could include between an element’s <code>&lt;></code> brackets. 
For example, these HTML elements

<code>&lt;p class="caption">
&lt;select id="country">
&lt;img class="lazy" data-src="https://alignedleft.com/tutorials/d3/logo.png" width="100px"></code>

contain a total of five attributes (and corresponding values), all of which could be set with <code>attr()</code>:

<code>class   |   caption
id      |   country
src     |   logo.png
width   |   100px
alt     |   Logo</code>

To give our <code>div</code>s a class of <code>bar</code>, we can use:

<code>.attr("class", "bar")</code>

<h2>A Note on Classes</h2>
Note that an element’s <em>class</em> is stored as an HTML attribute. 
The class, in turn, is used to reference a CSS style rule. 
This may cause some confusion because there is a difference between setting a <em>class</em> (from which styles are inferred) and applying a <em>style</em> directly to an element. 
You can do both with D3. 
Although you should use whatever approach makes the most sense to you, I recommend using <em>classes</em> for properties that are shared by multiple elements, and applying <em>style</em> rules directly only when deviating from the norm. 
(In fact, that’s what we’ll do in just a moment.)

I also want to briefly mention another D3 method, <code>classed()</code>, which can be used to quickly apply or remove classes from elements. 
The line of code above could be rewritten as:

<code>.classed("bar", true)</code>

<h2>Back to the Bars</h2>
Putting it all together with our data set, here is the complete D3 code so far:

<code>var dataset = [ 5, 10, 15, 20, 25 ];

d3.select("body").selectAll("div")
    .data(dataset)
    .enter()
    .append("div")
    .attr("class", "bar");</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/80-drawing-divs/1.png">
<a href="https://alignedleft.com/tutorials/d3/drawing-divs/./1.html">See this demo page with that code.</a> Make sure to view the source, and open your web inspector to see what’s going on. 
You should see five vertical bars, one generated for each point in our data set, although with no space between them, they look like one big rectangle.

<h2>Setting Styles</h2>
The <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style"><code>style()</code></a> method is used to apply a CSS property and value directly to an HTML element. 
This is the equivalent of including CSS rules within a <code>style</code> attribute right in your HTML, as in:

<code>&lt;div style="height: 75px;">&lt;/div></code>

In a bar chart, the height of each bar must be a function of the corresponding data value. 
So let’s add this to the end of our D3 code: 

<code>.style("height", function(d) {
    return d + "px";
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/80-drawing-divs/2.png">
<a href="https://alignedleft.com/tutorials/d3/drawing-divs/./2.html">See this demo page with that code.</a> You should see a very small bar chart!

When D3 loops through each data point, the value of <code>d</code> will be set to that of the corresponding data point. 
So we are setting a <code>height</code> value of <code>d</code> (the current data value) plus <code>px</code> (to specify the units are pixels). 
The resulting heights will be 5px, 10px, 15px, 20px, and 25px.

This looks a little bit silly, so let’s make those bars taller

<code>.style("height", function(d) {
    var barHeight = d * 5;  //Scale up by factor of 5
    return barHeight + "px";
});</code>

and add some space to the right of each bar, to space things out:

<code>margin-right: 2px;</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/80-drawing-divs/3.png">
Nice! We could go to SIGGRAPH with that chart.

<a href="https://alignedleft.com/tutorials/d3/drawing-divs/./3.html">Here’s the final demo page with that code.</a> Again, view the source and use the web inspector to contrast the original HTML against the final DOM.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

We left off with <a href="https://alignedleft.com/tutorials/d3/the-power-of-data/./1.html">a simple bar chart</a>, drawn with <code>div</code>s and generated from our simple data set.

<code>var dataset = [ 5, 10, 15, 20, 25 ];</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/1.png">
This is great, but real-world data never looks like this. 
 Let’s <a href="https://alignedleft.com/tutorials/d3/the-power-of-data/./2.html">modify our data</a>.

<code>var dataset = [ 25, 7, 5, 26, 11 ];</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/2.png">
We’re not limited to five data points, of course. 
Let’s <a href="https://alignedleft.com/tutorials/d3/the-power-of-data/./3.html">add more</a>!

<code>var dataset = [ 25, 7, 5, 26, 11, 8, 25, 14, 23, 19,
                14, 11, 22, 29, 11, 13, 12, 17, 18, 10,
                24, 18, 25, 9, 3 ];</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/3.png">
25 data points instead of five! How does D3 automatically expand our chart as needed?

<code>d3.select("body").selectAll("div")
    .data(dataset)  // &lt;-- The answer is here!
    .enter()
    .append("div")
    .attr("class", "bar")
    .style("height", function(d) {
        var barHeight = d * 5;
        return barHeight + "px";
    });</code>

Give <code>data()</code> ten values, and it will loop through ten times. 
Give it one million values, and it will loop through one million times. 
(Just be patient.)

That is the power of <code>data()</code> — being smart enough to loop through the full length of whatever data set you throw at it, executing each method below it in the chain, while updating the context in which each method operates, so <code>d</code> always refers to the current datum at that point in the loop.

That may be a mouthful, and if it all doesn’t make sense yet, it will soon. 
I encourage you to save the source code from the sample HTML pages above, tweak the <code>dataset</code> values, and note how the bar chart changes.

Remember, the <em>data</em> is driving the visualization — not the other way around.

<h2>Random Data</h2>
Sometimes it’s fun to generate random data values, for testing purposes or pure geekiness. 
<a href="https://alignedleft.com/tutorials/d3/the-power-of-data/./4.html">That’s just what I’ve done here.</a> Notice how each time you reload the page, the bars render differently.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/4.png">
<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/5.png">
<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/6.png">
View the source, and you’ll see this code:

<code>var dataset = [];                        //Initialize empty array
for (var i = 0; i &lt; 25; i++) {           //Loop 25 times
    var newNumber = Math.random() * 30;  //New random number (0-30)
    dataset.push(newNumber);             //Add new number to array
}</code>

This code doesn’t use any D3 methods; it’s just JavaScript. 
Without going into too much detail, this code:

<ol>
<li>Creates an empty array called <code>dataset</code>.</li>
<li>Initiates a <code>for</code> loop, which is executed 25 times.</li>
<li>Each time, it generates a new random number with a value between zero and 30.</li>
<li>That new number is appended to the <code>dataset</code> array. 
(<code>push()</code> is an array method that appends a new value to the end of an array.)</li>
</ol>
Just for kicks, open up the JavaScript console and enter <code>console.log(dataset)</code>. 
You should see the full array of 25 randomized data values.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/7.png">
Notice that they are all decimal or floating point values (14.793717765714973), not whole numbers or integers (14) like we used initially. 
For this example, decimal values are fine, but if you ever need whole numbers, you can use JavaScript’s <code>Math.round()</code> method. 
For example, you could wrap the random number generator from this line

<code>    var newNumber = Math.random() * 30;</code>

as follows:

<code>    var newNumber = Math.round(Math.random() * 30);</code>

<a href="https://alignedleft.com/tutorials/d3/the-power-of-data/./5.html">Try it out here</a>, and use the console to verify that the numbers have indeed been rounded to integers:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/90-the-power-of-data/8.png">
Next we’ll expand our visual possibilities with SVG.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

D3 is most useful when used to generate and manipulate visuals as SVGs. 
Drawing with <code>div</code>s and other native HTML elements is possible, but a bit clunky and subject to the usual inconsistencies across different browsers. 
Using SVG is more reliable, visually consistent, and faster.

Vector drawing software like Illustrator can be used to generate SVG files, but we need to learn how to generate them with code.

<h2>The SVG Element</h2>
Scalable Vector Graphics is a text-based image format. 
Each SVG image is defined using markup code similar to HTML. 
SVG code can be included directly within any HTML document. 
Every web browser supports SVG <em>except</em> <a href="http://caniuse.com/#feat=svg">Internet Explorer versions 8 and older</a>. 
SVG is XML-based, so you’ll notice that elements that don’t have a closing tag must be self-closing. 
 For example:

<code>&lt;element>&lt;/element>   &lt;!-- Uses closing tag -->
&lt;element/>            &lt;!-- Self-closing tag --></code>

Before you can draw anything, you must create an SVG element. 
Think of the SVG element as a canvas on which your visuals are rendered. 
(In that respect, SVG is conceptually similar to HTML’s <code>canvas</code> element.) At a minimum, it’s good to specify <code>width</code> and <code>height</code> values. 
If you don’t specify these, the SVG will take up as much room as it can within its enclosing element.

<code>&lt;svg width="500" height="50">
&lt;/svg></code>

Here is the SVG generated by that code:

<svg width="500" height="50"></svg>
Don’t see it? Right-click on the empty space above and choose “Inspect Element”. 
Your web inspector should look something like this:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/100-an-svg-primer/1.png">
Note that there is an <code>svg</code> element (yay!), and that it occupies 500 horizontal pixels and 50 vertical pixels. 
It just doesn’t look like much yet (boo!).

Also note that the browser assumed <em>pixels</em> as the default measurement units. 
We specified dimensions of <code>500</code> and <code>50</code>, not <code>500px</code> and <code>50px</code>. 
We could have specified <code>px</code> explicitly, or any number of other supported units, including <code>em</code>, <code>pt</code>, <code>in</code>, <code>cm</code>, and <code>mm</code>.

<h2>Simple Shapes</h2>
There are a number of visual elements that you can include between those <code>svg</code> tags, including <code>rect</code>, <code>circle</code>, <code>ellipse</code>, <code>line</code>, <code>text</code>, and <code>path</code>.

If you’re familiar with computer graphics programming, you’ll recognize the usual pixel-based coordinates system in which <code>0,0</code> is the top-left corner of the drawing space. 
Increasing <code>x</code> values move to the right, while increasing <code>y</code> values move down.

<svg width="505" height="65"><line x1="5" y1="5" x2="5" y2="50" stroke="gray" stroke-width="1"></line><line x1="5" y1="50" x2="0" y2="45" stroke="gray" stroke-width="1"></line><line x1="5" y1="50" x2="10" y2="45" stroke="gray" stroke-width="1"></line><line x1="5" y1="5" x2="500" y2="5" stroke="gray" stroke-width="1"></line><line x1="500" y1="5" x2="495" y2="0" stroke="gray" stroke-width="1"></line><line x1="500" y1="5" x2="495" y2="10" stroke="gray" stroke-width="1"></line><circle cx="5" cy="5" r="3" fill="#008"></circle><text x="10" y="20">0,0</text><circle cx="105" cy="25" r="3" fill="#008"></circle><text x="110" y="40">100,20</text><circle cx="205" cy="45" r="3" fill="#008"></circle><text x="210" y="60">200,40</text></svg>
<code>rect</code> draws a rectangle. 
Use <code>x</code> and <code>y</code> to specify the coordinates of the upper-left corner, and <code>width</code> and <code>height</code> to specify the dimensions. 
This rectangle fills the entire space of our SVG:

<code>&lt;rect x="0" y="0" width="500" height="50"/></code>

<svg width="500" height="50"><rect x="0" y="0" width="500" height="50"></rect></svg>
<code>circle</code> draws a circle. 
Use <code>cx</code> and <code>cy</code> to specify the coordinates of the <em>center</em>, and <code>r</code> to specify the radius. 
This circle is centered in the middle of our 500-pixel-wide SVG because its <code>cx</code> (“center-x”) value is 250.

<code>&lt;circle cx="250" cy="25" r="25"/></code>

<svg width="500" height="50"><circle cx="250" cy="25" r="25"></circle></svg>
<code>ellipse</code> is similar, but expects separate radius values for each axis. 
Instead of <code>r</code>, use <code>rx</code> and <code>ry</code>.

<code>&lt;ellipse cx="250" cy="25" rx="100" ry="25"/></code>

<svg width="500" height="50"><ellipse cx="250" cy="25" rx="100" ry="25"></ellipse></svg>
<code>line</code> draws a line. 
Use <code>x1</code> and <code>y1</code> to specify the coordinates of one end of the line, and <code>x2</code> and <code>y2</code> to specify the coordinates of the other end. 
A <code>stroke</code> color must be specified for the line to be visible.

<code>&lt;line x1="0" y1="0" x2="500" y2="50" stroke="black"/></code>

<svg width="500" height="50"><line x1="0" y1="0" x2="500" y2="50" stroke="black"></line></svg>
<code>text</code> renders text. 
Use <code>x</code> to specify the position of the left edge, and <code>y</code> to specify the vertical position of the type’s <em>baseline</em>.

<code>&lt;text x="250" y="25">Easy-peasy&lt;/text></code>

<svg width="500" height="50"><text x="250" y="25">Easy-peasy</text></svg>
<code>text</code> will inherit the CSS-specified font styles of its parent element unless specified otherwise. 
(More on styling text in a moment.) Notice how the formatting of the sample text above matches that of this paragraph. 
We could override that formatting as follows:

<code>&lt;text x="250" y="25" font-family="sans-serif"
 font-size="25" fill="gray">Easy-peasy&lt;/text></code>

<svg width="500" height="50"><text x="250" y="25" font-family="sans-serif" font-size="25" fill="gray">Easy-peasy</text></svg>
Also note that when any visual element runs up against the edge of the SVG, it will be clipped. 
Be careful when using <code>text</code> so your descenders don’t get cut off (ouch!). 
You can see this happen when we set the baseline (<code>y</code>) to 50, the same as the height of our SVG:

<code>&lt;text x="250" y="50" font-family="sans-serif"
 font-size="25" fill="gray">Easy-peasy&lt;/text></code>

<svg width="500" height="50"><text x="250" y="50" font-family="sans-serif" font-size="25" fill="gray">Easy-peasy</text></svg>
<code>path</code> is for drawing anything more complex than the shapes above (like country outlines for geomaps), and will be explained separately. 
For now, we’ll work with simple shapes.

<h2>Styling SVG Elements</h2>
SVG’s default style is a black fill with no stroke. 
If you want anything else, you’ll have to apply styles to your elements. 
Common SVG properties are:

<li>
<code>fill</code> — A color value. 
Just as with CSS, colors can be specified as
<li>named colors — <code>orange</code>
</li>
<li>hex values — <code>#3388aa</code> or <code>#38a</code>
</li>
<li>RGB values — <code>rgb(10, 150, 20)</code>
</li>
<li>RGB with alpha transparency — <code>rgba(10, 150, 20, 0.5)</code>
</li>

</li>
<li>
<code>stroke</code> — A color value.</li>
<li>
<code>stroke-width</code> — A numeric measurement (typically in pixels).</li>
<li>
<code>opacity</code> — A numeric value between 0.0 (completely transparent) and 1.0 (completely opaque).</li>

With <code>text</code>, you can also use these properties, which work just like in CSS:

<li><code>font-family</code></li>
<li><code>font-size</code></li>

In another parallel to CSS, there are two ways to apply styles to an SVG element: either directly (inline) as an attribute of the element, or with a CSS style rule.

Here are some style properties applied directly to a <code>circle</code> as attributes:

<code>&lt;circle cx="25" cy="25" r="22"
 fill="yellow" stroke="orange" stroke-width="5"/></code>

<svg width="500" height="50"><circle cx="25" cy="25" r="22" fill="yellow" stroke="orange" stroke-width="5"></circle></svg>
Alternatively, we could strip the style attributes, assign the <code>circle</code> a class (just as if it were a normal HTML element)

<code>&lt;circle cx="25" cy="25" r="22" class="pumpkin"/></code>

and then put the <code>fill</code>, <code>stroke</code>, and <code>stroke-width</code> rules into a CSS style that targets the new class:

<code>.pumpkin {
    fill: yellow;
    stroke: orange;
    stroke-width: 5;
 }</code>

The CSS approach has a few obvious benefits:

<ol>
<li>You can specify a style once and have it be applied to multiple elements.</li>
<li>CSS code is generally easier to read than inline attributes.</li>
<li>For those reasons, the CSS approach may be more maintainable and make design changes faster to implement.</li>
</ol>
Using CSS to apply SVG styles, however, can be disconcerting for some. 
<code>fill</code>, <code>stroke</code>, and <code>stroke-width</code>, after all, are <em>not</em> CSS properties. 
(The nearest CSS equivalents are <code>background-color</code> and <code>border</code>.) If it helps you remember which rules in your stylesheet are SVG-specific, consider including <code>svg</code> in those selectors:

<code>svg .pumpkin {
    /* ... 
*/
 }</code>

<h2>Layering and Drawing Order</h2>
There are no “layers” in SVG, and no real concept of depth. 
SVG does not support CSS’s <code>z-index</code> property, so shapes can only be arranged within the two-dimensional x/y plane.

And yet, if we draw multiple shapes, they overlap:

<code>&lt;rect x="0" y="0" width="30" height="30" fill="purple"/>
&lt;rect x="20" y="5" width="30" height="30" fill="blue"/>
&lt;rect x="40" y="10" width="30" height="30" fill="green"/>
&lt;rect x="60" y="15" width="30" height="30" fill="yellow"/>
&lt;rect x="80" y="20" width="30" height="30" fill="red"/></code>

<svg width="500" height="50"><rect x="0" y="0" width="30" height="30" fill="purple"></rect><rect x="20" y="5" width="30" height="30" fill="blue"></rect><rect x="40" y="10" width="30" height="30" fill="green"></rect><rect x="60" y="15" width="30" height="30" fill="yellow"></rect><rect x="80" y="20" width="30" height="30" fill="red"></rect></svg>
The order in which elements are coded determines their depth order. 
The purple square appears first in the code, so it is rendered first. 
Then, the blue square is rendered “on top” of the purple one, then the green square on top of that, and so on.

Think of SVG shapes as being rendered like paint on a canvas. 
The pixel-paint that is applied later obscures any earlier paint, and thus appears to be “in front.”

This aspect of drawing order becomes important when you have some visual elements that should not be obscured by others. 
For example, you may have axes or value labels that appear on a scatterplot. 
The axes and labels should be added to the SVG last, so they appear in front of any other elements.

<h2>Transparency</h2>
Transparency can be useful when elements in your visualization overlap but must remain visible, or you want to de-emphasize some elements while highlighting others.

There are two ways to apply transparency: use an RGB color with alpha, or set an <code>opacity</code> value.

You can use <code>rgba()</code> anywhere you specify a color, such as with <code>fill</code> or <code>stroke</code>. 
<code>rgba()</code> expects three values between 0 and 255 for red, green, and blue, plus an alpha (transparency) value between 0.0 and 1.0.

<code>&lt;circle cx="25" cy="25" r="20" fill="rgba(128, 0, 128, 1.0)"/>
&lt;circle cx="50" cy="25" r="20" fill="rgba(0, 0, 255, 0.75)"/>
&lt;circle cx="75" cy="25" r="20" fill="rgba(0, 255, 0, 0.5)"/>
&lt;circle cx="100" cy="25" r="20" fill="rgba(255, 255, 0, 0.25)"/>
&lt;circle cx="125" cy="25" r="20" fill="rgba(255, 0, 0, 0.1)"/></code>

<svg width="500" height="50"><circle cx="25" cy="25" r="20" fill="rgba(128, 0, 128, 1.0)"></circle><circle cx="50" cy="25" r="20" fill="rgba(0, 0, 255, 0.75)"></circle><circle cx="75" cy="25" r="20" fill="rgba(0, 255, 0, 0.5)"></circle><circle cx="100" cy="25" r="20" fill="rgba(255, 255, 0, 0.25)"></circle><circle cx="125" cy="25" r="20" fill="rgba(255, 0, 0, 0.1)"></circle></svg>
Note that with <code>rgba()</code>, transparency is applied to the <code>fill</code> and <code>stroke</code> colors independently. 
The following circles’ <code>fill</code> is 75% opaque, while their <code>stroke</code>s are only 25% opaque.

<code>&lt;circle cx="25" cy="25" r="20"
        fill="rgba(128, 0, 128, 0.75)" 
        stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"/>
&lt;circle cx="75" cy="25" r="20"
        fill="rgba(0, 255, 0, 0.75)"
        stroke="rgba(0, 0, 255, 0.25)" stroke-width="10"/>
&lt;circle cx="125" cy="25" r="20"
        fill="rgba(255, 255, 0, 0.75)"
        stroke="rgba(255, 0, 0, 0.25)" stroke-width="10"/></code>

<svg width="500" height="50"><circle cx="25" cy="25" r="20" fill="rgba(128, 0, 128, 0.75)" stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"></circle><circle cx="75" cy="25" r="20" fill="rgba(0, 255, 0, 0.75)" stroke="rgba(0, 0, 255, 0.25)" stroke-width="10"></circle><circle cx="125" cy="25" r="20" fill="rgba(255, 255, 0, 0.75)" stroke="rgba(255, 0, 0, 0.25)" stroke-width="10"></circle></svg>
To apply transparency to an entire element, set an <code>opacity</code> attribute. 
Here are some completely opaque circles

<svg width="500" height="50"><circle cx="25" cy="25" r="20" fill="purple" stroke="green" stroke-width="10"></circle><circle cx="65" cy="25" r="20" fill="green" stroke="blue" stroke-width="10"></circle><circle cx="105" cy="25" r="20" fill="yellow" stroke="red" stroke-width="10"></circle></svg>
followed by the same circles, with <code>opacity</code> values:

<code>&lt;circle cx="25" cy="25" r="20" fill="purple" 
        stroke="green" stroke-width="10"
        opacity="0.9"/>
&lt;circle cx="65" cy="25" r="20" fill="green"
        stroke="blue" stroke-width="10"
        opacity="0.5"/>
&lt;circle cx="105" cy="25" r="20" fill="yellow"
        stroke="red" stroke-width="10"
        opacity="0.1"/></code>

<svg width="500" height="50"><circle cx="25" cy="25" r="20" fill="purple" stroke="green" stroke-width="10" opacity="0.9"></circle><circle cx="65" cy="25" r="20" fill="green" stroke="blue" stroke-width="10" opacity="0.5"></circle><circle cx="105" cy="25" r="20" fill="yellow" stroke="red" stroke-width="10" opacity="0.1"></circle></svg>
You can employ <code>opacity</code> on an element that also has colors set with <code>rgba()</code>. 
When doing so, the transparencies are multiplied. 
The following circles use the same RGBA values for <code>fill</code> and <code>stroke</code>. 
The first circle below has no element <code>opacity</code> set, but the other two do:

<code>&lt;circle cx="25" cy="25" r="20"
        fill="rgba(128, 0, 128, 0.75)" 
        stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"/>
&lt;circle cx="65" cy="25" r="20"
        fill="rgba(128, 0, 128, 0.75)" 
        stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"
        opacity="0.5"/>
&lt;circle cx="105" cy="25" r="20"
        fill="rgba(128, 0, 128, 0.75)" 
        stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"
        opacity="0.2"/></code>

<svg width="500" height="50"><circle cx="25" cy="25" r="20" fill="rgba(128, 0, 128, 0.75)" stroke="rgba(0, 255, 0, 0.25)" stroke-width="10"></circle><circle cx="65" cy="25" r="20" fill="rgba(128, 0, 128, 0.75)" stroke="rgba(0, 255, 0, 0.25)" stroke-width="10" opacity="0.5"></circle><circle cx="105" cy="25" r="20" fill="rgba(128, 0, 128, 0.75)" stroke="rgba(0, 255, 0, 0.25)" stroke-width="10" opacity="0.2"></circle></svg>
Notice how the third circle’s <code>opacity</code> is <code>0.2</code> or 20%. 
Yet its purple fill already has an alpha value of <code>0.75</code> or 75%. 
The purple area, then, has a final transparency of 0.2 times 0.75 = 0.15 or 15%.

<blockquote>
For more on SVG — including patterns, animation, paths, clip-paths, masks, and filters — see the “<a href="http://svgpocketguide.com">Pocket Guide to Writing SVG</a>” by <a href="http://jonibologna.com/">Joni Trythall</a> as well as “<a href="http://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html">An SVG Primer for Today’s Browsers</a>” by <a href="http://srufaculty.sru.edu/david.dailey/">David Dailey</a>.

</blockquote>

Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

Now that we’re familiar with the basic structure of an SVG image and its elements, how can we start generating shapes from our data?

You may have noticed that all properties of SVG elements are specified as <em>attributes</em>. 
That is, they are included as property/value pairs within each element tag, like this:

<code>&lt;element property="value"/></code>

Hmm, that looks strangely like HTML!

<code>&lt;p class="eureka"></code>

We have already used D3’s handy <code>append()</code> and <code>attr()</code> methods to create new HTML elements and set their attributes. 
Since SVG elements exist in the DOM, just as HTML elements do, we can use <code>append()</code> and <code>attr()</code> in exactly the same way to generate SVG images!

<h2>Create the SVG</h2>
First, we need to create the SVG element in which to place all our shapes.

<code>d3.select("body").append("svg");</code>

That will find the <code>body</code> and append a new <code>svg</code> element just before the closing <code>&lt;/body></code> tag. 
While that will work, I recommend:

<code>var svg = d3.select("body").append("svg");</code>

Remember how most D3 methods return a reference to the DOM element on which they act? By creating a new variable <code>svg</code>, we are able to capture the reference handed back by <code>append()</code>. 
Think of <code>svg</code> not as a “variable” but as a “reference pointing to the SVG object that we just created.” This reference will save us a lot of code later. 
Instead of having to search for that SVG each time — as in <code>d3.select("svg")</code> — we just say <code>svg</code>.

<code>svg.attr("width", 500)
   .attr("height", 50);</code>

Alternatively, that could all be written as one line of code:

<code>var svg = d3.select("body")
            .append("svg")
            .attr("width", 500)
            .attr("height", 50);</code>

<a href="https://alignedleft.com/tutorials/d3/drawing-svgs/./1.html">See the demo for that code.</a> Inspect the DOM and notice that there is, indeed, an empty SVG element.

To simplify your life, I recommend putting the width and height values into variables at the top of your code, <a href="https://alignedleft.com/tutorials/d3/drawing-svgs/./2.html">like this</a> (view the source):

<code>//Width and height
var w = 500;
var h = 50;</code>

I’ll be doing that with all future examples. 
By variabalizing the size values, they can be easily referenced throughout your code, as in:

<code>var svg = d3.select("body")
            .append("svg")
            .attr("width", w)   // &lt;-- Here
            .attr("height", h); // &lt;-- and here!</code>

Also, if you send me a petition to make “variabalize” a real word, I will gladly sign it.

<h2>Data-driven Shapes</h2>
Time to add some shapes. 
I’ll bring back our trusty old data set

<code>var dataset = [ 5, 10, 15, 20, 25 ];</code>

and then use <code>data()</code> to iterate through each data point, creating a <code>circle</code> for each one:

<code>svg.selectAll("circle")
    .data(dataset)
    .enter()
    .append("circle");</code>

Remember, <code>selectAll()</code> will return empty references to all <code>circle</code>s (which don’t exist yet), <code>data()</code> binds our data to the elements we’re about to create, <code>enter()</code> returns a placeholder reference to the new element, and <code>append()</code> finally adds a <code>circle</code> to the DOM.

To make it easy to reference all of the <code>circle</code>s later, we can create a new variable to store references to them all:

<code>var circles = svg.selectAll("circle")
                 .data(dataset)
                 .enter()
                 .append("circle");</code>

Great, but all these circles still need positions and sizes. 
Be warned: The following code may blow your mind.

<code>circles.attr("cx", function(d, i) {
            return (i * 50) + 25;
        })
       .attr("cy", h/2)
       .attr("r", function(d) {
            return d;
       });</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/110-drawing-svgs/1.png">
<a href="https://alignedleft.com/tutorials/d3/drawing-svgs/./3.html">Feast your eyes on the demo.</a> Let’s step through the code.

<code>circles.attr("cx", function(d, i) {
            return (i * 50) + 25;
        })</code>

Takes the reference to all <code>circle</code>s and sets the <code>cx</code> attribute for each one. 
Our data has already been bound to the <code>circle</code> elements, so for each <code>circle</code>, the value <code>d</code> matches the corresponding value in our original data set (5, 10, 15, 20, or 25). 
Another value, <code>i</code>, is also automatically populated for us. 
<code>i</code> is a numeric index value of the current element. 
Counting starts at zero, so for our “first” circle <code>i == 0</code>, the second circle’s <code>i == 1</code> and so on. 
We’re using <code>i</code> to push each subsequent circle over to the right, because each subsequent loop through, the value of <code>i</code> increases.

<code>(0 * 50) + 25 returns 25
(1 * 50) + 25 returns 75
(2 * 50) + 25 returns 125
(3 * 50) + 25 returns 175
(4 * 50) + 25 returns 225</code>

To make sure <code>i</code> is available to your custom function, you must include it as an argument in the function definition (<code>function(d, i)</code>). 
You must also include <code>d</code>, even if you don’t use <code>d</code> within your function (as in the case above).

On to the next line.

<code>.attr("cy", h/2)</code>

<code>h</code> is the height of the entire SVG, so <code>h/2</code> is one-half of its height. 
This has the effect of aligning all <code>circle</code>s in the vertical center.

<code>.attr("r", function(d) {
    return d;
});</code>

Finally, the radius <code>r</code> of each <code>circle</code> is simply set to <code>d</code>, the corresponding data value.

<h2>Pretty Colors, Oooh!</h2>
Color fills and strokes are just other attributes which you can set using the same methods. 
Simply by appending this code

<code>.attr("fill", "yellow")
.attr("stroke", "orange")
.attr("stroke-width", function(d) {
    return d/2;
});</code>

we get the following (<a href="https://alignedleft.com/tutorials/d3/drawing-svgs/./4.html">see demo</a>):

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/110-drawing-svgs/2.png">
Of course, you can mix and match attributes and custom functions to apply any combination of properties. 
The trick with data visualization, of course, is choosing appropriate <em>mappings</em>, so the visual expression of your data is understandable and useful for the viewer.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

D3 is extremely flexible about its input data. 
This topic introduces data structures commonly used with JavaScript and D3.

<h2>Variables</h2>
A variable is a datum, the smallest building block of data. 
The variable is the foundation of all other data structures, which are simply different configurations of variables.

If you’re new to JavaScript, know that it is a <em>loosely typed</em> language, meaning you don’t have to specify what <em>type</em> of information will be stored in a variable in advance. 
 Many other languages, like Java (which is completely different from Java<em>Script</em>!), require you to declare a variable’s type, such as <code>int</code>, <code>float</code>, <code>boolean</code>, or <code>String</code>.

<code>//Declaring variables in Java
int number = 5;
float value = 12.3467;
boolean active = true;
String text = "Crystal clear";</code>

JavaScript, however, automatically <em>types</em> a variable based on what kind of information you assign to it. 
(Note that <code>''</code> or <code>""</code> indicate string values. 
I prefer double quotation marks <code>""</code>, but some people like singles <code>''</code>.)

<code>//Declaring variables in JavaScript
var number = 5;
var value = 12.3467;
var active = true;
var text = "Crystal clear";</code>

How boring — <code>var</code>, <code>var</code>, <code>var</code>, <code>var</code>! — yet handy, as we can declare and name variables before we even know what type of data will go into them. 
You can even change a variable’s type on-the-fly without JavaScript freaking out on you.

<code>var value = 100;
value = 99.9999;
value = false;
value = "This can't possibly work.";
value = "Argh, it does work! No errorzzzz!";</code>

<h2>Arrays</h2>
An array is a sequence of values, conveniently stored in a single variable.

Keeping track of related values in separate variables is inefficient:

<code>var numberA = 5;
var numberB = 10;
var numberC = 15;
var numberD = 20;
var numberE = 25;</code>

Rewritten as an array, those values are much simpler. 
Hard brackets <code>[]</code> indicate an array, while each value is separated by a comma:

<code>var numbers = [ 5, 10, 15, 20, 25 ];</code>

Arrays are ubiquitous in data visualization, so you should become very comfortable with them. 
You can access (retrieve) a value in an array by using bracket notation:

<code>numbers[2]  //Returns 15</code>

The numeral in the bracket refers to a corresponding position in the array. 
Remember, array positions begin counting at zero, so the first position is <code>0</code>, the second position is <code>1</code>, and so on.

<code>numbers[0]  //Returns 5
numbers[1]  //Returns 10
numbers[2]  //Returns 15
numbers[3]  //Returns 20
numbers[4]  //Returns 25</code>

Some people find it helpful to think of arrays in spatial terms, as though they have rows and columns, like in a spreadsheet:

<code> ID | Value
------------
 0  |  5
 1  |  10
 2  |  15
 3  |  20
 4  |  25</code>

Arrays can contain any type of data, not just integers.

<code>var percentages = [ 0.55, 0.32, 0.91 ];
var names = [ "Ernie", "Bert", "Oscar" ];

percentages[1]  //Returns 0.32
names[1]        //Returns "Bert"</code>

<h2>What Arrays Are Made for()</h2>
Code-based data visualization would not be possible without arrays and the mighty <code>for()</code> loop. 
Together, they form a data geek’s dynamic duo. 
(If you do not consider yourself a “data geek,” then may I remind you that you are reading a document titled “Types of data.”)

An array organizes lots of data values in one convenient place. 
Then <code>for()</code> can quickly “loop” through every value in an array and perform some action with it — such as, express the value as a visual form. 
D3 often manages this looping for us, with its magical <code>data()</code> method, but it’s important to be able to write your own loops.

I won’t go into the mechanics of <code>for()</code> loops here; that’s a whole separate tutorial. 
But note this example, which loops through the <code>numbers</code> values from above.

<code>for (var i = 0; i &lt; numbers.length; i++) {
    console.log(numbers[i]);  //Print value to console
}</code>

See that <code>numbers.length</code>? That’s the beautiful part. 
If <code>numbers</code> is ten positions long, the loop will run ten times. 
If it’s ten million positions long… yeah, you get it. 
This is what computers are good at: taking a set of instructions and executing them over and over. 
And this is at the heart of why data visualization can be so rewarding —you design and code the visualization system, and the system will respond appropriately, even as you feed it different data. 
The system’s mapping rules are consistent, even when the data are not.

<h2>Objects</h2>
Arrays are great for simple lists of values, but with more complex data sets, you’ll want to put your data into an object. 
For our purposes, think of a JavaScript object as a custom data structure. 
We use curly brackets <code>{}</code> to indicate an object. 
In between the brackets, we include <em>indices</em> and <em>values</em>. 
A colon <code>:</code> separates each index and its value, and a comma separates each index/value pair.

<code>var fruit = {
    kind: "grape",
    color: "red",
    quantity: 12,
    tasty: true
};</code>

To reference each value, we use <em>dot notation</em>, specifying the name of the index:

<code>fruit.kind      //Returns "grape"
fruit.color     //Returns "red"
fruit.quantity  //Returns 12
fruit.tasty     //Returns true</code>

Think of the value as “belonging” to the object. 
Oh, look, some fruit. 
“What kind of fruit is that?” you might ask. 
As it turns out, <code>fruit.kind</code> is <code>"grape"</code>. 
“Are they tasty?” Oh, definitely, because <code>fruit.tasty</code> is <code>true</code>.

<h2>Objects + Arrays</h2>
You can combine these two structures to create arrays of objects, or objects of arrays, or objects of objects or, well, basically whatever structure makes sense for your data set.

Let’s say we have acquired a couple more pieces of fruit, and we want to expand our catalogue accordingly. 
We use hard brackets <code>[]</code> on the outside, to indicate an array, followed by curly brackets <code>{}</code> and object notation on the inside, with each object separated by a comma.

<code>var fruits = [
    {
        kind: "grape",
        color: "red",
        quantity: 12,
        tasty: true
    },
    {
        kind: "kiwi",
        color: "brown",
        quantity: 98,
        tasty: true
    },
    {
        kind: "banana",
        color: "yellow",
        quantity: 0,
        tasty: true
    }
];</code>

To access this data, we just follow the trail of indices down to the values we want. 
Remember, <code>[]</code> means array, and <code>{}</code> means object. 
<code>fruits</code> is an array, so first we use bracket notation to specify an array index:

<code>fruits[1]</code>

Next, each array element is an object, so just tack on a dot and an index:

<code>fruits[1].quantity  //Returns 98</code>

Here’s a map of how to access every value in the <code>fruits</code> array of objects:

<code>fruits[0].kind      ==  "grape"
fruits[0].color     ==  "red"
fruits[0].quantity  ==  12
fruits[0].tasty     ==  true

fruits[1].kind      ==  "kiwi"
fruits[1].color     ==  "brown"
fruits[1].quantity  ==  98
fruits[1].tasty     ==  true

fruits[2].kind      ==  "banana"
fruits[2].color     ==  "yellow"
fruits[2].quantity  ==  0
fruits[2].tasty     ==  true</code>

Yes, that’s right, we have <code>fruits[2].quantity</code> bananas.

<h2>JSON</h2>
At some point in your D3 career, you will encounter JavaScript Object Notation. 

<code>var jsonFruit = {
    "kind": "grape",
    "color": "red",
    "quantity": 12,
    "tasty": true
};</code>

The only difference here is that our indices are now surrounded by double quotation marks <code>""</code>, making them string values.

<h2>GeoJSON</h2>
Just as JSON is just a formalization of existing JavaScript object syntax, GeoJSON is a formalized syntax of JSON objects, optimized for storing geodata. 
All GeoJSON object are JSON objects, and all JSON objects are JavaScript objects.

<a href="http://geojson.org/geojson-spec.html">GeoJSON</a> can store points in geographical space (typically as longitude/latitude coordinates), but also shapes (like lines and polygons) and other spatial features. 
If you have a lot of geodata, it’s worth it to parse it into GeoJSON format for best use with D3.

We’ll get into the details of GeoJSON when we talk about geomaps, but for now, just know that this is what  simple GeoJSON data could look like:

<code>var geodata = {
    "type": "FeatureCollection",
    "features": [
        {
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [ 150.1282427, -24.471803 ]
            },
            "properties": {
                "type": "town"
            }
        }
    ]
};</code>

(Confusingly, longitude is always listed before latitude. 
Get used to thinking in terms of lon/lat instead of lat/lon.)


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

Now we’ll integrate everything we’ve learned so far to generate a simple bar chart with D3.

We’ll start by reviewing the bar chart we made earlier using <code>div</code> elements. 
 Then we’ll adapt that code to draw the bars with SVG instead, giving us more flexibility over the visual presentation. 
Finally, we’ll add labels, so we can see the data values clearly.

<h2>The Old Chart</h2>
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./1.html">Here’s what we had last time, with some new data.</a>

<code>var dataset = [ 5, 10, 13, 19, 21, 25, 22, 18, 15, 13,
                11, 12, 15, 20, 18, 17, 16, 18, 23, 25 ];

d3.select("body").selectAll("div")
    .data(dataset)
    .enter()
    .append("div")
    .attr("class", "bar")
    .style("height", function(d) {
        var barHeight = d * 5;
        return barHeight + "px";
    });</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/1.png">
It may be hard to imagine, but we can definitely improve on this simple bar chart made of <code>div</code>s.

<h2>The New Chart</h2>
First things first, we need to decide on the size of the new SVG:

<code>//Width and height
var w = 500;
var h = 100;</code>

(Of course, you could name <code>w</code> and <code>h</code> something else, like <code>svgWidth</code> and <code>svgHeight</code>. 
Use whatever is most clear to you. 
JavaScript has a cultural fixation on efficiency, so you’ll often see single-character variable names, code written with no spaces, and other hard-to-read, yet programmatically efficient, syntax.)

Then, we tell D3 to create an empty SVG element and add it to the DOM:

<code>//Create SVG element
var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);</code>

This inserts a new <code>&lt;svg></code> element just before the closing <code>&lt;/body></code> tag, and assigns the SVG a width and height of 500 by 100 pixels. 
This statement also puts the result into our new variable called <code>svg</code>, so we can easily reference the new SVG without having to reselect it later using something like <code>d3.select("svg")</code>.

Next, instead of creating <code>div</code>s, we generate <code>rect</code>s and add them to <code>svg</code>.

<code>svg.selectAll("rect")
   .data(dataset)
   .enter()
   .append("rect")
   .attr("x", 0)
   .attr("y", 0)
   .attr("width", 20)
   .attr("height", 100);</code>

This code selects all <code>rect</code>s inside of <code>svg</code>. 
Of course, there aren’t any yet, so an empty selection is returned. 
(Weird, yes, but stay with me. 
With D3, you always have to first select whatever it is you’re about to act on, even if that selection is momentarily empty.)

Then, <code>data(dataset)</code> sees that we have 20 values in the data set, so it calls <code>enter()</code> 20 times. 
<code>enter()</code>, in turn, returns a placeholder selection for each data point that does not yet have a corresponding <code>rect</code> —which is to say, all of them.

For each of the 20 placeholders, <code>append("rect")</code> inserts a <code>rect</code> into the DOM. 
As we learned in the SVG primer, every <code>rect</code> must have <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> values. 
 We use <code>attr()</code> to add those attributes onto each newly created <code>rect</code>.

<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./2.html">Beautiful, no?</a>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/2.png">
Okay, maybe not. 
All of the bars are there (check the DOM of <a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./2.html">the demo page</a> with your web inspector), but they all share the same <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> values, with the result that they all overlap. 
This isn’t a visualization of data yet.

Let’s fix the overlap issue first. 
Instead of an <code>x</code> of zero, we’ll assign a dynamic value that corresponds to <code>i</code>, or each value’s position in the data set. 
So the first bar will be at zero, but subsequent bars will be at <code>21</code>, then <code>42</code>, and so on.

<code>.attr("x", function(d, i) {
    return i * 21;  //Bar width of 20 plus 1 for padding
})</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/3.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./3.html">Here’s that code in action.</a>

That works, but it’s not particularly flexible. 
If our data set were longer, then the bars would just run off to the right, past the end of the SVG! Since each bar is 20 pixels wide, plus 1 pixel of padding, then a 500-pixel wide SVG can only accommodate 23 data points. 
Note how the 24th bar here gets clipped:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/4.png">
It’s good practice to use flexible, dynamic coordinates — heights, widths, x values, and y values —so your visualization can scale appropriately along with your data.

As with anything else in programming, there are a thousand ways to achieve that end. 
I’ll use a simple one. 
First, I’ll amend the line where we set each bar’s <code>x</code> position:

<code>.attr("x", function(d, i) {
    return i * (w / dataset.length);
})</code>

Notice how the <code>x</code> value is now tied directly to the width of the SVG (<code>w</code>) and the number of values in the data set (<code>dataset.length</code>). 
This is exciting, because now our bars will be evenly spaced, whether we have 20 data values

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/5.png">
or only five:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/6.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./4.html">Here’s the working code so far.</a>

Now we should set the bar <em>widths</em> to be proportional, too, so they get narrower as more data is added, or wider when there are fewer values. 
I’ll add a new variable near where we set the SVG’s width and height

<code>//Width and height
var w = 500;
var h = 100;
var barPadding = 1;  // &lt;-- New!</code>

and then reference that variable in the line where we set each bar’s <code>width</code>. 
 Instead of a static value of <code>20</code>, the width will now be set as a fraction of the SVG width and number of data points, minus a padding value:

<code>.attr("width", w / dataset.length - barPadding)</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/7.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./5.html">It works!</a> The bar widths and x positions scale correctly whether there are 20 points, only five

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/8.png">
or even 100:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/9.png">
Finally, we encode our data as the <em>height</em> of each bar. 
You would hope it were as easy as referencing the <code>d</code> data value when setting each bar’s <code>height</code>:

<code>.attr("height", function(d) {
    return d;
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/10.png">
Hmm, that looks funky. 
Maybe we can just scale up our numbers a bit?

<code>.attr("height", function(d) {
    return d * 4;  // &lt;-- Times four!
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/11.png">
Alas, it is not that easy — we want our bars to grow upward from the bottom edge, not down from the top — but don’t blame D3, blame SVG.

You’ll recall from the SVG primer that, when drawing <code>rect</code>s, the <code>x</code> and <code>y</code> values specify the coordinates of the <em>upper-left corner</em>. 
 That is, the origin or reference point for every <code>rect</code> is its top-left. 
 For our purposes, it would be soooooo much easier to set the origin point as the bottom-left corner, but that’s just not how SVG does it, and, frankly, SVG is pretty indifferent about your feelings on the matter.

Given that our bars do have to “grow down from the top,” then where is “the top” of each bar in relationship to the top of the SVG?  Well, the top of each bar could be expressed as a relationship between the height of the SVG and the corresponding data value, as in:

<code>.attr("y", function(d) {
    return h - d;  //Height minus data value
})</code>

Then, to put the “bottom” of the bar on the bottom of the SVG, each <code>rect</code>s height can be just the data value itself:

<code>.attr("height", function(d) {
    return d;  //Just the data value
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/12.png">
Let’s scale things up a bit by changing <code>d</code> to <code>d * 4</code>. 
(Note: Later we’ll learn about D3 <em>scales</em>, which offer better ways to accomplish this.)

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/13.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./6.html">Here’s the working code for our growing-down-from-above bar chart.</a>

<h2>Color</h2>
Adding color is easy. 
 Just use <code>attr()</code> to set a <code>fill</code>:

<code>.attr("fill", "teal");</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/14.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./7.html">Here’s an all-teal bar chart.</a>  But often, you’ll want a shape’s color to reflect some quality of the data. 
 That is, you may want to <em>encode</em> the data as color. 
 (In the case of our bar chart, that makes a <em>dual encoding</em>, in which the same data value is encoded in two different visual properties: height and color.)

Using data to drive color is as easy as writing a custom function that again references <code>d</code>. 
Here, we replace <code>"teal"</code> with a custom function:

<code>.attr("fill", function(d) {
    return "rgb(0, 0, " + (d * 10) + ")";
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/15.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./8.html">Here’s that code.</a> This is not a particularly useful visual encoding, but you can get the idea of how to translate data into color. 
Here, <code>d</code> is multiplied by 10, and then used as the blue value in an <code>rgb()</code> color definition. 
So the greater values of <code>d</code> (taller bars) will be more blue. 
Smaller values of <code>d</code> (shorter bars) will be less blue (closer to black).

<h2>Labels</h2>
Visuals are great, but sometimes you need to show the actual data values as text within the visualization. 
Here’s where value labels come in, and they are very, very easy to generate with D3.

You’ll recall from the SVG primer that you can add <code>text</code> elements to an SVG element. 
We‘ll start with:

<code>svg.selectAll("text")
   .data(dataset)
   .enter()
   .append("text")</code>

Look familiar? Just as we did for the <code>rect</code>s, here we do for the <code>text</code>s. 
First, select what you want, bring in the data, enter the new elements (which are just placeholders at this point), and finally append the new <code>text</code> elements to the DOM.

We’ll extend that code to include a data value within each <code>text</code> element by using the <code>text()</code> method

<code>   .text(function(d) {
        return d;
   })</code>

and then extend it further, by including <code>x</code> and <code>y</code> values to position the text. 
It’s easiest if I just copy and paste the same x/y code we used above for the bars:

<code>   .attr("x", function(d, i) {
        return i * (w / dataset.length);
   })
   .attr("y", function(d) {
        return h - (d * 4);
   });</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/16.png">
Aha! Value labels! But some are getting cut off at the top. 
Let’s try moving them down, inside the bars, by adding a small amount to the <code>x</code> and <code>y</code> calculations:

<code>   .attr("x", function(d, i) {
        return i * (w / dataset.length) + 5;  // +5
   })
   .attr("y", function(d) {
        return h - (d * 4) + 15;              // +15
   });</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/17.png">
Better, but not legible. 
Fortunately, we can fix that:

<code>   .attr("font-family", "sans-serif")
   .attr("font-size", "11px")
   .attr("fill", "white");</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/18.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./9.html">Fantasti-code!</a> If you are not typographically obsessive, then you’re all done. 
If, however, you are like me, you’ll notice that the value labels aren’t perfectly aligned within their bars. 
That’s easy enough to fix. 
 Let’s use the SVG <code>text-anchor</code> attribute to center the text horizontally at the assigned <code>x</code> value:

<code>    .attr("text-anchor", "middle")</code>

Then, let’s change the way we calculate the <code>x</code> position by setting it to the left edge of each bar <em>plus</em> half the bar width:

<code>    .attr("x", function(d, i) {
        return i * (w / dataset.length) + (w / dataset.length - barPadding) / 2;
    })</code>

And I’ll also bring the labels up one pixel for perfect spacing:

<code>    .attr("y", function(d) {
        return h - (d * 4) + 14;  //15 is now 14
    })</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/19.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-bar-chart/./10.html">Done!</a>  Now, let’s branch out from bar charts.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

So far, we’ve drawn only bar charts with simple data — just one-dimensional sets of numbers.

But when you have two sets of values to plot against each other, you need a second dimension. 
The scatterplot is a common type of visualization that represents two sets of corresponding values on two different axes: horizontal and vertical, x and y.

<h2>The Data</h2>
As you saw in <em>Types of data</em>, you have a lot of flexibility around how you structure your data set. 
 For our scatterplot, I’m going to use an array of arrays. 
 The primary array will contain one element for each data “point.”  Each of those “point” elements will be another array, with just two values: one for the x value, and one for y.

<code>var dataset = [
                [5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
                [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
              ];</code>

Remember, <code>[]</code> means array, so nested hard brackets <code>[[]]</code> indicate an array within another array. 
 We separate array elements with commas, so an array containing three other arrays would look like: <code>[[],[],[]]</code>

We could rewrite our data set so it’s easier to read, like so:

<code>var dataset = [
                  [ 5,     20 ],
                  [ 480,   90 ],
                  [ 250,   50 ],
                  [ 100,   33 ],
                  [ 330,   95 ],
                  [ 410,   12 ],
                  [ 475,   44 ],
                  [ 25,    67 ],
                  [ 85,    21 ],
                  [ 220,   88 ]
              ];</code>

Now you can see that each of these 10 rows will correspond to one point in our visualization. 
 With the row <code>[5, 20]</code>, for example, we’ll use <code>5</code> as the x value, and <code>20</code> for the y.

<h2>The Scatterplot</h2>
Let’s carry over most of the code from our bar chart experiments, including the piece that creates the SVG element:

<code>//Create SVG element
var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);</code>

Instead of creating <code>rect</code>s, however, we’ll make a <code>circle</code> for each data point:

<code>svg.selectAll("circle")
   .data(dataset)
   .enter()
   .append("circle")</code>

Also, instead of specifying the <code>rect</code> attributes of <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>, our <code>circle</code>s need <code>cx</code>, <code>cy</code>, and <code>r</code>:

<code>   .attr("cx", function(d) {
        return d[0];
   })
   .attr("cy", function(d) {
        return d[1];
   })
   .attr("r", 5);</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/140-making-a-scatterplot/1.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-scatterplot/./1.html">Here’s that working scatterplot.</a>

Notice how we access the data values and use them for the <code>cx</code> and <code>cy</code> values. 
 When using <code>function(d)</code>, D3 automatically hands off the current data value as <code>d</code> to your function. 
 In this case, the current data value is one of the small arrays in our larger <code>dataset</code> array.

When <code>d</code> is an array of values (and not just a single value, like <code>3.14159</code>), you need to use bracket notation to access its values. 
 Hence, instead of <code>return d</code>, we have <code>return d[0]</code> and <code>return d[1]</code>, which return the first and second values of the array, respectively.

For example, in the case of our first data point <code>[5, 20]</code>, the first value (array position <code>0</code>) is <code>5</code>, and the second value (array position <code>1</code>) is <code>20</code>. 
 Thus:

<code>d[0] returns 5
d[1] returns 20</code>

By the way, if you ever want to access any value in the larger data set (outside of D3, say), you can do so using bracket notation. 
 For example:

<code>dataset[5] returns [410, 12]</code>

You can string brackets together, to access values within nested arrays:

<code>dataset[5][1] returns 12</code>

Don’t believe me?  <a href="https://alignedleft.com/tutorials/d3/making-a-scatterplot/./1.html">Take another look at the scatterplot</a>, open your JavaScript console, and try typing in <code>dataset[5]</code> or <code>dataset[5][1]</code> and see what happens.

<h2>Size</h2>
Maybe you want the circles to be different sizes, so their radii correspond to their y values. 
 Instead of setting all <code>r</code> values to <code>5</code>, try:

<code>.attr("r", function(d) {
    return Math.sqrt(h - d[1]);
});</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/140-making-a-scatterplot/2.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-scatterplot/./2.html">This is neither pretty nor useful</a>, but it illustrates how you might use <code>d</code>, along with bracket notation, to reference data values and set <code>r</code> accordingly.

<h2>Labels</h2>
Let’s label our data points with <code>text</code> elements. 
I’ll adapt the label code from our bar chart experiments, starting with:

<code>svg.selectAll("text")
   .data(dataset)
   .enter()
   .append("text")</code>

So far, this looks for all <code>text</code> elements in the SVG (there aren’t any yet), and then appends a new <code>text</code> element for each data point. 
 Use the <code>text()</code> method to specify each element’s contents:

<code>   .text(function(d) {
        return d[0] + "," + d[1];
   })</code>

This looks messy, but bear with me. 
 Once again, we’re using <code>function(d)</code> to access each data point. 
 Then, within the function, we’re using <em>both</em> <code>d[0]</code> <em>and</em> <code>d[1]</code> to get both values within that data point array.

The plus <code>+</code> symbols, when used with strings, such as the comma between quotation marks <code>","</code>, act as <em>append</em> operators. 
 So what this one line of code is really saying is:  Get the values of <code>d[0]</code> and <code>d[1]</code> and smush them together with a comma in the middle. 
 The end result should be something like <code>5,20</code> or <code>25,67</code>.

Next, we specify <em>where</em> the text should be placed with <code>x</code> and <code>y</code> values. 
 For now, let’s just use <code>d[0]</code> and <code>d[1]</code>, the same values that we used to specify the <code>circle</code> positions. 

<code>   .attr("x", function(d) {
        return d[0];
   })
   .attr("y", function(d) {
        return d[1];
   })</code>

Finally, add a bit of font styling with:

<code>   .attr("font-family", "sans-serif")
   .attr("font-size", "11px")
   .attr("fill", "red");</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/140-making-a-scatterplot/3.png">
<a href="https://alignedleft.com/tutorials/d3/making-a-scatterplot/./3.html">Here’s that working code.</a>

<h2>Next Steps</h2>
Hopefully, some core concepts of D3 are becoming clear: Loading data, generating new elements, and using data values to derive attribute values for those elements.

Yet the image above is barely passable as a data visualization. 
The scatterplot is hard to read, and the code doesn’t use our data flexibly. 
To be honest, we haven’t yet improved on —gag — Excel’s <em>Chart Wizard!</em>

Not to worry: D3 is way cooler than Chart Wizard (not to mention Clippy), but generating a shiny, interactive chart involves taking our D3 skills to the next level. 
 To use data flexibly, we’ll learn about D3’s <em>scales</em>. 
 To make our scatterplot easier to read, we’ll learn about <em>axis generators</em> and axis labels. 
 Following that, we’ll make things interactive and learn how to update data on the fly.

Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

“Scales are functions that map from an input domain to an output range.”

That’s <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales">Mike Bostock’s definition of D3 scales</a>.

The values in any data set are unlikely to correspond exactly to pixel measurements for use in your visualization. 
 Scales provide a convenient way to map those data values to new values useful for visualization purposes.

D3 scales are <em>functions</em> whose parameters you define. 
 Once they are created, you call the scale function, pass it a data value, and it nicely returns a scaled output value. 
 You can define and use as many scales as you like.

It may be tempting to think of a scale as something that appears visually in the final image —like a set of tick marks, indicating a progression of values. 
 <em>Do not be fooled!</em>  Those tick marks are part of an <em>axis</em>, which is essentially a visual representation of a scale. 
 A scale is a mathematical relationship, with no direct visual output. 
 I encourage you to think of scales and axes as two different, yet related, elements.

This topic addresses only <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear"><em>linear</em></a> scales, since they are most common and understandable. 
 Once you understand linear scales, the others will be a piece of cake.

<h2>Apples and Pixels</h2>
Imagine that the following data set represents the number of apples sold at a roadside fruit stand each month:

<code>var dataset = [ 100, 200, 300, 400, 500 ];</code>

First of all, this is great news, as the stand is selling 100 additional apples each month!  Business is booming. 
 To showcase this success, you want to make a bar chart illustrating the steep upward climb of apple sales, with each data value corresponding to the height of one bar.

Until now, we’ve used data values directly as display values, ignoring unit differences. 
 So if 500 apples were sold, the corresponding bar would be 500 pixels tall.

That could work, but what about next month, when 600 apples are sold?  And a year later, when 1,800 apples are sold?  Your audience would have to purchase ever-larger displays, just to be able to see the full height of those very tall apple-bars!  (Mmm, apple bars!)

This is where scales come in. 
 Because apples are not pixels (which are also not oranges), we need scales to translate between them.

<h2>Domains and Ranges</h2>
A scale’s <em>input domain</em> is the range of possible input data values. 
 Given the apples data above, appropriate input domains would be either 100 and 500 (the minimum and maximum values of the data set) or zero and 500.

A scale’s <em>output range</em> is the range of possible output values, commonly used as display values in pixel units. 
 The output range is completely up to you, as the information designer. 
 If you decide the shortest apple-bar will be 10 pixels tall, and the tallest will be 350 pixels tall, then you could set an output range of 10 and 350.

For example, create a scale with an input domain of <code>100,500</code> and an output range of <code>10,350</code>. 
 If you gave that scale the value <code>100</code>, it would return <code>10</code>. 
 If you gave it <code>500</code>, it would spit back <code>350</code>. 
 If you gave it <code>300</code>, it would hand <code>180</code> back to you on a silver platter. 
 (<code>300</code> is in the center of the domain, and <code>180</code> is in the center of the range.)

We could visualize the domain and range as corresponding axes, side-by-side:

<svg width="505" height="115"><text x="220" y="15" font-style="italic">Input domain</text><line x1="5" y1="30" x2="500" y2="30" stroke="gray" stroke-width="1"></line><circle cx="5" cy="30" r="3" fill="#008"></circle><text x="8" y="48">100</text><circle cx="255" cy="30" r="3" fill="#008"></circle><text x="258" y="48">300</text><circle cx="500" cy="30" r="3" fill="#008"></circle><text x="473" y="48">500</text><line x1="5" y1="90" x2="500" y2="90" stroke="gray" stroke-width="1"></line><circle cx="5" cy="90" r="3" fill="#008"></circle><text x="8" y="84">10</text><circle cx="255" cy="90" r="3" fill="#008"></circle><text x="258" y="84">180</text><circle cx="500" cy="90" r="3" fill="#008"></circle><text x="473" y="84">350</text><text x="220" y="110" font-style="italic">Output range</text></svg>
One more thing:  Given that it is very easy to mix up the <em>input domain</em> and <em>output range</em> terminology, I’d like to propose a little exercise. 
 When I say “input,” you say “domain.”  Then I say “output,” and you say “range.”  Ready?  Okay:

<li>Input! Domain!</li>
<li>Output! Range!</li>
<li>Input! Domain!</li>
<li>Output! Range!</li>

Got it?  Great.

<h2>Normalization</h2>
If you’re familiar with the concept of <em>normalization</em>, it may be helpful to know that, with a linear scale, that’s all that is really going on here.

Normalization is the process of mapping a numeric value to a new value between 0 and 1, based on the possible minimum and maximum values. 
 For example, with 365 days in the year, day number 310 maps to about 0.85, or 85% of the way through the year.

With linear scales, we are just letting D3 handle the math of the normalization process. 
 The input value is normalized according to the domain, and then the normalized value is scaled to the output range.

<h2>Creating a Scale</h2>
D3’s scale generators are accessed with <code>d3.scale</code> followed by the type of scale you want.

<code>var scale = d3.scale.linear();</code>

Congratulations!  Now <code>scale</code> is a function to which you can pass input values. 
 (Don’t be misled by the <code>var</code> above; remember that in JavaScript, variables can store functions.)

<code>scale(2.5);  //Returns 2.5</code>

Since we haven't set a domain and a range yet, this function is mapping input to output on a 1:1 scale. 
 That is, whatever we input will be returned unchanged.

We can set the scale’s input domain to <code>100,500</code> by passing those values to the <code>domain()</code> method as an array:

<code>scale.domain([100, 500]);</code>

Set the output range in similar fashion, with <code>range()</code>:

<code>scale.range([10, 350]);</code>

These steps can be done separately, as above, or chained together into one line of code:

<code>var scale = d3.scale.linear()
                    .domain([100, 500])
                    .range([10, 350]);</code>

Either way, our scale is ready to use!

<code>scale(100);  //Returns 10
scale(300);  //Returns 180
scale(500);  //Returns 350</code>

Typically, you will call scale functions from within an <code>attr()</code> method or similar, not on their own. 
 Let’s modify our scatterplot visualization to use dynamic scales.

<h2>Scaling the Scatterplot</h2>
To revisit our data set from the scatterplot:

<code>var dataset = [
                [5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
                [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
              ];</code>

You’ll recall that <code>dataset</code> is an array of arrays. 
 We mapped the first value in each array onto the x axis, and the second value onto the y axis. 
 Let’s start with the x axis.

Just by eyeballing the x values, it looks like they range from 5 to 480, so a reasonable input domain to specify might be <code>0,500</code>, right?

…

Why are you giving me that look?  Oh, because you want to keep your code flexible and scalable, so it will continue to work even if the data change in the future. 
 Very smart!

Instead of specifying fixed values for the domain, we can use convenient array functions like <code>min()</code> and <code>max()</code> to analyze our data set on the fly. 
 For example, this loops through each of the x values in our arrays and returns the value of the greatest one:

<code>d3.max(dataset, function(d) {    //Returns 480
    return d[0];  //References first value in each sub-array
});</code>

Putting it all together, let’s create the scale function for our x axis:

<code>var xScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[0]; })])
                     .range([0, w]);</code>

First, notice I named it <code>xScale</code>. 
 Of course, you can name your scales whatever you want, but a name like <code>xScale</code> helps me remember what this function does.

Second, notice I set the low end of the input domain to zero. 
 (Alternatively, you could use <code>min()</code> to calculate a dynamic value.)  The upper end of the domain is set to the maximum value in <code>dataset</code> (which is 480).

Finally, observe that the output range is set to <code>0</code> and <code>w</code>, the SVG’s width.

We’ll use very similar code to create the scale function for the y axis:

<code>var yScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                     .range([0, h]);</code>

Note that the <code>max()</code> function references <code>d[1]</code>, the y value of each sub-array. 
 Also, the upper end of <code>range()</code> is set to <code>h</code> instead of <code>w</code>.

The scale functions are in place! Now all we need to do is use them. 
Simply modify the code where we create a <code>circle</code> for each data value

<code>.attr("cx", function(d) {
    return d[0];
})</code>

to return a scaled value (instead of the original value):

<code>.attr("cx", function(d) {
    return xScale(d[0]);
})</code>

Likewise, for the y axis, this

<code>.attr("cy", function(d) {
    return d[1];
})</code>

is modified as:

<code>.attr("cy", function(d) {
    return yScale(d[1]);
})</code>

For good measure, let’s make the same change where we set the coordinates for the text labels, so these lines

<code>.attr("x", function(d) {
    return d[0];
})
.attr("y", function(d) {
    return d[1];
})</code>

become this:

<code>.attr("x", function(d) {
    return xScale(d[0]);
})
.attr("y", function(d) {
    return yScale(d[1]);
})</code>

And there we are!

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/1.png">
<a href="https://alignedleft.com/tutorials/d3/scales/./1.html">Here’s the working code.</a>  Visually, it is disappointingly similar to our original scatterplot!  Yet we are making more progress than may be apparent.

<h2>Refining the Plot</h2>
You may have noticed that smaller y values are at the top of the plot, and the larger y values are toward the bottom. 
Now that we’re using scales, it’s super easy to reverse that, so greater values are higher up, as you would expect. 
 It’s just a matter of changing the output range of <code>yScale</code> from

<code>.range([0, h]);</code>

to

<code>.range([h, 0]);</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/2.png">
<a href="https://alignedleft.com/tutorials/d3/scales/./2.html">Here’s that code.</a>  Yes, now a <em>smaller</em> input to <code>yScale</code> will produce a <em>larger</em> output value, thereby pushing those <code>circle</code>s and <code>text</code> elements down, closer to the base of the image. 
I know, it’s almost too easy!

Yet some elements are getting cut off. 
 Let’s introduce a <code>padding</code> variable:

<code>var padding = 20;</code>

Then we’ll incorporate the <code>padding</code> amount when setting the range of both scales. 
 The range for <code>xScale</code> was <code>range([0, w])</code>, but now it’s

<code>.range([padding, w - padding]);</code>

The range for <code>yScale</code> was <code>range([h, 0])</code>, but now it’s

<code>.range([h - padding, padding]);</code>

This should provide us with 20 pixels of extra room on the left, right, top, and bottom edges of the SVG. 
 And it does!

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/3.png">
But the text labels on the far right are still getting cut off, so I’ll double the amount of <code>xScale</code>’s padding on the right side by multiplying by two:

<code>.range([padding, w - padding * 2]);</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/4.png">
Better! <a href="https://alignedleft.com/tutorials/d3/scales/./3.html">Here’s the code so far.</a>  But there’s one more change I’d like to make. 
 Instead of setting the radius of each <code>circle</code> as the square root of its y value (which was a bit of a hack, and not useful in any case), why not create another custom scale?

<code>var rScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                     .range([2, 5]);</code>

Then, setting the radius looks like this:

<code>.attr("r", function(d) {
    return rScale(d[1]);
});</code>

This is exciting, because we are guaranteeing that our radius values will <em>always</em> fall within the range of <code>2,5</code>. 
(Or <em>almost</em> always: See reference to <code>clamp()</code> below.)  So data values of <code>0</code> (the minimum input) will get circles of radius <code>2</code> (or a diameter of 4 pixels). 
 The very largest data value will get a circle of radius <code>5</code> (diameter of 10 pixels).

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/5.png">
<a href="https://alignedleft.com/tutorials/d3/scales/./4.html">Voila</a>: Our first scale used for a visual property other than an axis value.

Finally, just in case the power of scales hasn’t yet blown your mind, I’d like to add one more array to the data set: <code>[600, 150]</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/6.png">
Boom! <a href="https://alignedleft.com/tutorials/d3/scales/./5.html">Here’s the code.</a>  Notice how all the old points maintained their relative positions, but have migrated closer together, down and to the left, to accommodate the newcomer.

And now, one final revelation: We can now very easily change the size of our SVG, and everything scales accordingly. 
 Here, I’ve increased the value of <code>h</code> from <code>100</code> to <code>300</code> and made <em>no other changes</em>:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/150-scales/7.png">
Boom, again! <a href="https://alignedleft.com/tutorials/d3/scales/./6.html">Here’s the updated code.</a>  Hopefully, you are seeing this and realizing: No more late nights tweaking your code because the client decided the graphic should be 800 pixels wide instead of 600. 
 Yes, you will get more sleep because of me (and D3’s brilliant built-in methods). 
 Being well-rested is a competitive advantage. 
 You can thank me later.

<h2>Other Methods</h2>
<code>d3.scale.linear()</code> has several other handy methods that deserve a brief mention here:

<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_nice"><code>nice()</code></a> — This tells the scale to take whatever input domain that you gave to <code>range()</code> and expand both ends to the nearest round value. 
 From the D3 wiki: “For example, for a domain of [0.20147987687960267, 0.996679553296417], the nice domain is [0.2, 1].”  This is useful for normal people, who find it hard to read numbers like 0.20147987687960267.</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_rangeRound"><code>rangeRound()</code></a> — Use <code>rangeRound()</code> in place of <code>range()</code> and all values output by the scale will be rounded to the nearest whole number. 
 This is useful if you want shapes to have exact pixel values, to avoid the fuzzy edges that may arise with antialiasing.</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_clamp"><code>clamp()</code></a> — By default, a linear scale <em>can</em> return values outside of the specified range. 
 For example, if given a value outside of its expected input domain, a scale will return a number also outside of the output range. 
 Calling <code>.clamp(true)</code> on a scale, however, forces all output values to be within the specified range. 
 Meaning, excessive values will be rounded to the range’s low or high value (whichever is nearest).</li>

<h2>Other Scales</h2>
In addition to <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear"><code>linear</code></a> scales (discussed above), D3 has several other scale methods built-in:

<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-identity"><code>identity</code></a> — A 1:1 scale, useful primarily for pixel values</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-sqrt"><code>sqrt</code></a> — A square root scale</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-pow"><code>pow</code></a> — A power scale (good for the gym)</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-log"><code>log</code></a> — A logarithmic scale</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantize"><code>quantize</code></a> — A linear scale with discrete values for its output range, for when you want to sort data into “buckets”</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-quantile"><code>quantile</code></a> — Similar to above, but with discrete values for its input domain (when you already have “buckets”)</li>
<li>
<a href="https://github.com/mbostock/d3/wiki/Ordinal-Scales"><code>ordinal</code></a> — Ordinal scales use non-quantitative values (like category names) for output; perfect for comparing apples and oranges</li>

Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

Having mastered the use of D3 scales, we now have this scatterplot:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/1.png">
Let’s add horizontal and vertical axes, so we can do away with the horrible red numbers cluttering up our chart.

<h2>Introducing Axes</h2>
Much like the scale functions, <a href="https://github.com/mbostock/d3/wiki/SVG-Axes">D3’s <em>axes</em></a> are actually <em>functions</em> whose parameters you define. 
 Unlike scales, when an axis function is called, it doesn’t return a value, but generates the visual elements of the axis, including lines, labels, and ticks.

Note that the axis functions are SVG-specific, as they generate SVG elements. 
Also, axes are intended for use with quantitative scales (as opposed to ordinal ones).

<h2>Setting up an Axis</h2>
Use <code>d3.svg.axis()</code> to create a generic axis function:

<code>var xAxis = d3.svg.axis();</code>

At a minimum, each axis also needs to be told on what <em>scale</em> to operate. 
 Here we’ll pass in the <code>xScale</code> from the scatterplot code:

<code>xAxis.scale(xScale);</code>

We can also specify where the labels should appear relative to the axis itself. 
The default is <code>bottom</code>, meaning the labels will appear below the axis line. 
 (Although this is the default, it can’t hurt to specify it explicitly.)

<code>xAxis.orient("bottom");</code>

Of course, we can be more concise and string all this together into one line:

<code>var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom");</code>

Finally, to actually generate the axis and insert all those little lines and labels into our SVG, we must <em>call</em> the <code>xAxis</code> function. 
I’ll put this code at the end of our script, so the axis is generated after the other elements in the SVG:

<code>svg.append("g")
    .call(xAxis);</code>

<a href="https://github.com/mbostock/d3/wiki/Selections#wiki-call">D3’s <code>call()</code> function</a> takes a <em>selection</em> as input and hands that selection off to any <em>function</em>. 
 So, in this case, we have just appended a new <code>g</code> group element to contain all of our about-to-be-generated axis elements. 
 (The <code>g</code> isn’t strictly necessary, but keeps the elements organized and allows us to apply a class to the entire group, which we’ll do in a moment.)

That <code>g</code> becomes the selection for the next link in the chain. 
<code>call()</code> hands that selection off to the <code>xAxis</code> function, so our axis is generated within the new <code>g</code>. 
 That snippet of code above is just nice, clean shorthand for this exact equivalent:

<code>svg.append("g")
    .call(d3.svg.axis()
                .scale(xScale)
                .orient("bottom"));</code>

See, you could cram the whole axis function within <code>call()</code>, but it’s usually easier on our brains to define functions first, then call them later.

In any case, <a href="https://alignedleft.com/tutorials/d3/axes/./1.html">here’s what that looks like:</a>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/2.png">
<h2>Cleaning it Up</h2>
Technically, that is an axis, but it’s neither pretty nor useful. 
 To clean it up, let’s first assign a class of <code>axis</code> to the new <code>g</code> element, so we can target it with CSS:

<code>svg.append("g")
    .attr("class", "axis")  //Assign "axis" class
    .call(xAxis);</code>

Then, we introduce our first CSS styles, up in the <code>&lt;head></code> of our page:

<code>.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}</code>

<a href="https://developer.mozilla.org/en/SVG/Attribute/shape-rendering">The <code>shape-rendering</code> property</a> is an SVG attribute, used here to make sure our axis and its tick mark lines are pixel-perfect. 
No blurry axes for us!

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/3.png">
That’s better, but the top of the axis is cut off, and we want it down at the base the chart anyway. 
 We can <code>transform</code> the entire axis group, pushing it to the bottom:

<code>svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(0," + (h - padding) + ")")
    .call(xAxis);</code>

Note the use of <code>(h - padding)</code>, so the group’s top edge is set to <code>h</code>, the height of the entire image, minus the <code>padding</code> value we created earlier.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/4.png">
Much better! <a href="https://alignedleft.com/tutorials/d3/axes/./2.html">Here’s the code so far.</a>

<h2>Check for Ticks</h2>
Some ticks spread disease, but <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_ticks">D3’s ticks</a> communicate information. 
Yet more ticks are not necessarily better, and at a certain point they begin to clutter your chart. 
You’ll notice that we never specified how many ticks to include on the axis, nor at what intervals they should appear. 
Without clear instruction, D3 has auto-magically examined our scale <code>xScale</code> and made informed judgements about how many ticks to include, and at what intervals (every 50, in this case).

As you would imagine, you can customize all aspects of your axes, starting with the rough number of ticks, using <code>ticks()</code>:

<code>var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom")
                  .ticks(5);  //Set rough # of ticks</code>

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/5.png">
<a href="https://alignedleft.com/tutorials/d3/axes/./3.html">Here’s that code.</a>

You probably noticed that, while we specified only five ticks, D3 has made an executive decision and ordered up a total of seven. 
 That’s because D3 has got your back, and figured out that including only <em>five</em> ticks would require slicing the input domain into less-than-gorgeous values —in this case, 0, 150, 300, 450, and 600. 
 D3 inteprets the <code>ticks()</code> value as merely a suggestion, and will override your suggestion with what it determines to be the most clean and human-readable values —in this case, intervals of 100 — even when that requires including slightly more or fewer ticks than you requested. 
This is actually a totally brilliant feature that increases the scalability of your design; as the data set changes, and the input domain expands or contracts (bigger numbers or smaller numbers), D3 ensures that the tick labels remain clear and easy to read.

<h2>Y Not?</h2>
Time to label the vertical axis!  By copying and tweaking the code we already wrote for the <code>xAxis</code>, we add this near the top of of our code

<code>//Define Y axis
var yAxis = d3.svg.axis()
                  .scale(yScale)
                  .orient("left")
                  .ticks(5);</code>

and this, near the bottom:

<code>//Create Y axis
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(" + padding + ",0)")
    .call(yAxis);</code>

Note that the labels will be oriented <code>left</code> and that the <code>yAxis</code> group <code>g</code> is translated to the right by the amount <code>padding</code>.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/6.png">
This is starting to look like something real! But the <code>yAxis</code> labels are getting cut off. 
To give them more room on the left, I’ll bump up the value of <code>padding</code> from 20 to 30:

<code>var padding = 30;</code>

Of course, you could also introduce separate <code>padding</code> variables for each axis, say <code>xPadding</code> and <code>yPadding</code>, for more control over the layout.

<a href="https://alignedleft.com/tutorials/d3/axes/./4.html">Here’s the code</a>, and here’s what it looks like:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/7.png">
<h2>Final Touches</h2>
To prove to you that our new axis are dynamic and scalable, I’d like to switch from using a static data set to using randomized numbers:

<code>//Dynamic, random dataset
var dataset = [];
var numDataPoints = 50;
var xRange = Math.random() * 1000;
var yRange = Math.random() * 1000;
for (var i = 0; i &lt; numDataPoints; i++) {
    var newNumber1 = Math.round(Math.random() * xRange);
    var newNumber2 = Math.round(Math.random() * yRange);
    dataset.push([newNumber1, newNumber2]);
}</code>

This code initializes an empty array, then loops through 50 times, chooses two random numbers each time, and adds (“pushes”) that pair of values to the <code>dataset</code> array.

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/8.png">
<a href="https://alignedleft.com/tutorials/d3/axes/./5.html">Try the code here.</a>  Each time you reload the page, you’ll get different data values. 
 Notice how both axes scale to fit the new domains, and ticks and label values are chosen accordingly.

Having made my point, I think we can finally cut those horrible, red labels, by commenting out the relevant lines of code:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/9.png">
<a href="https://alignedleft.com/tutorials/d3/axes/./6.html">Our final scatterplot code!</a>

<h2>Formatting Tick Labels</h2>
One last thing:  So far, we’ve been working with integers — whole numbers — which are nice and easy. 
 But data is often messier, and in those cases, you may want more control over how the axis labels are formatted. 
 Enter <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear_tickFormat"><code>tickFormat()</code></a>, which enables you to specify how your numbers should be formatted. 
 For example, you may want to include three places after the decimal point, or display values as percentages, or both.

In that case, you could first define a new number formatting function. 
 This one, for example, says to treat values as percentages with one decimal point precision. 
 (See <a href="https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format">the reference entry for d3.format()</a> for more options.)

<code>var formatAsPercentage = d3.format(".1%");</code>

Then, tell your axis to use that formatting function for its ticks, e.g.:

<code>xAxis.tickFormat(formatAsPercentage);</code>

Development tip: I find it easiest to test these formatting functions out in the JavaScript console. 
For example, just open any page that loads D3, such as <a href="https://alignedleft.com/tutorials/d3/axes/./6.html">our final scatterplot</a>, and type your format rule into the console. 
 Then test it by feeding it a value, as you would with any other function:

<img class="lazy" data-src="https://alignedleft.com/content/03-tutorials/01-d3/160-axes/10.png">
You can see here that a data value of <code>0.54321</code> is converted to <code>54.3%</code> for display purposes — perfect!

<a href="https://alignedleft.com/tutorials/d3/axes/./7.html">Give that code a try here.</a>  A percentage format doesn’t make sense with our scatterplot’s current data set, but as an exercise, you could try tweaking how the random numbers are generated, for more appropriate, non-whole number values, or experiment with the format function itself.


Download <a href="https://tinyletter.com/alignedleft">sign up to receive updates by email</a>. 
<a href="http://twitter.com/alignedleft">Follow me on Twitter</a> for other updates.

These tutorials have been generously translated to <a href="https://twitter.com/gabrielcoch">Gabriel Coch</a>.

First, <a href="/projects/2014/easy-as-pi/">check out my Eyeo Festival talk on D3 transitions</a>. 
 It’s interactive, silly, and fun. 
 Better than all of the tutorials so far put together. 
 Maybe.

Second, <a href="/work/d3-book-2e/">check out my book</a>, which has a whole chapter on transitions, and is actually somewhat readable.

<script src='https://williamkpchan.github.io/LibDocs/readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre></body></html>
