<base target="_blank"><html><head><title>MicroPython tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script>
  var showTopicNumber = false;
  var bookid = "MicroPython tutorial"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>MicroPython tutorial for ESP8266</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>

</div>
<pre>
<br>
<br>


<span id="tutorial-index"></span>
<h2><span class="orange">MicroPython tutorial for ESP8266</span></h2>
This tutorial is intended to get you started using MicroPython on the ESP8266
system-on-a-chip.  
If it is your first time it is recommended to follow the
tutorial through in the order below.  
Otherwise the sections are mostly self
contained, so feel free to skip to those that interest you.

The tutorial does not assume that you know Python, but it also does not attempt
to explain any of the details of the Python language.  
Instead it provides you
with commands that are ready to run, and hopes that you will gain a bit of
Python knowledge along the way.  
To learn more about Python itself please refer
to <a class="reference external" href="https://www.python.org">https://www.python.org</a>.


<span id="intro"></span>
<h2><span class="orange">1. Getting started with MicroPython on the ESP8266</span></h2>
Using MicroPython is a great way to get the most of your ESP8266 board.  
And
vice versa, the ESP8266 chip is a great platform for using MicroPython.  
This
tutorial will guide you through setting up MicroPython, getting a prompt, using
WebREPL, connecting to the network and communicating with the Internet, using
the hardware peripherals, and controlling some external components.

Let's get started!


<h2>1.1. Requirements</h2>
The first thing you need is a board with an ESP8266 chip.  
The MicroPython
software supports the ESP8266 chip itself and any board should work.  
The main
characteristic of a board is how much flash it has, how the GPIO pins are
connected to the outside world, and whether it includes a built-in USB-serial
convertor to make the UART available to your PC.

The minimum requirement for flash size is 1Mbyte. There is also a special
build for boards with 512KB, but it is highly limited comparing to the
normal build: there is no support for filesystem, and thus features which
depend on it won't work (WebREPL, upip, etc.). As such, 512KB build will
be more interesting for users who build from source and fine-tune parameters
for their particular application.

Names of pins will be given in this tutorial using the chip names (eg GPIO0)
and it should be straightforward to find which pin this corresponds to on your
particular board.

<h2>1.2. Powering the board</h2>
If your board has a USB connector on it then most likely it is powered through
this when connected to your PC.  
Otherwise you will need to power it directly.
Please refer to the documentation for your board for further details.

<h2>1.3. Getting the firmware</h2>
The first thing you need to do is download the most recent MicroPython firmware
.bin file to load onto your ESP8266 device. You can download it from the
<a class="reference external" href="http://micropython.org/download#esp8266">MicroPython downloads page</a>.
From here, you have 3 main choices

<ul class="simple">
<li>Stable firmware builds for 1024kb modules and above.</li>
<li>Daily firmware builds for 1024kb modules and above.</li>
<li>Daily firmware builds for 512kb modules.</li>
</ul>
If you are just starting with MicroPython, the best bet is to go for the Stable
firmware builds. If you are an advanced, experienced MicroPython ESP8266 user
who would like to follow development closely and help with testing new
features, there are daily builds (note: you actually may need some
development experience, e.g. being ready to follow git history to know
what new changes and features were introduced).

Support for 512kb modules is provided on a feature preview basis. For end
users, it's recommended to use modules with flash of 1024kb or more. As
such, only daily builds for 512kb modules are provided.

<h2>1.4. Deploying the firmware</h2>
Once you have the MicroPython firmware (compiled code), you need to load it onto
your ESP8266 device.  
There are two main steps to do this: first you
need to put your device in boot-loader mode, and second you need to copy across
the firmware.  
The exact procedure for these steps is highly dependent on the
particular board and you will need to refer to its documentation for details.

If you have a board that has a USB connector, a USB-serial convertor, and has
the DTR and RTS pins wired in a special way then deploying the firmware should
be easy as all steps can be done automatically.  
Boards that have such features
include the Adafruit Feather HUZZAH and NodeMCU boards.

For best results it is recommended to first erase the entire flash of your
device before putting on new MicroPython firmware.

Currently we only support esptool.py to copy across the firmware.  
You can find
this tool here: <a class="reference external" href="https://github.com/espressif/esptool/">https://github.com/espressif/esptool/</a>, or install it
using pip:

pip install esptool


Versions starting with 1.3 support both Python 2.7 and Python 3.4 (or newer).
An older version (at least 1.2.1 is needed) works fine but will require Python
2.7.

Any other flashing program should work, so feel free to try them out or refer
to the documentation for your board to see its recommendations.

Using esptool.py you can erase the flash with the command:

esptool.py --port /dev/ttyUSB0 erase_flash


And then deploy the new firmware using:

esptool.py --port /dev/ttyUSB0 --baud 460800 write_flash --flash_size=detect 0 esp8266-20170108-v1.8.7.bin


You might need to change the &#8220;port&#8221; setting to something else relevant for your
PC.  
You may also need to reduce the baudrate if you get errors when flashing
(eg down to 115200).  
The filename of the firmware should also match the file
that you have.

For some boards with a particular FlashROM configuration (e.g. some variants of
a NodeMCU board) you may need to use the following command to deploy
the firmware (note the <code class="docutils literal"><span class="pre">-fm</span> <span class="pre">dio</span></code> option):

esptool.py --port /dev/ttyUSB0 --baud 460800 write_flash --flash_size=detect -fm dio 0 esp8266-20170108-v1.8.7.bin


If the above commands run without error then MicroPython should be installed on
your board!

<h2>1.5. Serial prompt</h2>
Once you have the firmware on the device you can access the REPL (Python prompt)
over UART0 (GPIO1=TX, GPIO3=RX), which might be connected to a USB-serial
convertor, depending on your board.  
The baudrate is 115200.  
The next part of
the tutorial will discuss the prompt in more detail.

<h2>1.6. WiFi</h2>
After a fresh install and boot the device configures itself as a WiFi access
point (AP) that you can connect to.  
The ESSID is of the form MicroPython-xxxxxx
where the x's are replaced with part of the MAC address of your device (so will
be the same everytime, and most likely different for all ESP8266 chips).  
The
password for the WiFi is micropythoN (note the upper-case N).  
Its IP address
will be 192.168.4.1 once you connect to its network.  
WiFi configuration will
be discussed in more detail later in the tutorial.

<h2>1.7. Troubleshooting installation problems</h2>
If you experience problems during flashing or with running firmware immediately
after it, here are troubleshooting recommendations:

<ul>
<li>Be aware of and try to exclude hardware problems. There are 2 common problems:
bad power source quality and worn-out/defective FlashROM. Speaking of power
source, not just raw amperage is important, but also low ripple and noise/EMI
in general. If you experience issues with self-made or wall-wart style power
supply, try USB power from a computer. Unearthed power supplies are also known
to cause problems as they source of increased EMI (electromagnetic interference)
- at the very least, and may lead to electrical devices breakdown. So, you are
advised to avoid using unearthed power connections when working with ESP8266
and other boards. In regard to FlashROM hardware problems, there are independent
(not related to MicroPython in any way) reports
<a class="reference external" href="http://internetofhomethings.com/homethings/?p=538">(e.g.)</a>
that on some ESP8266 modules, FlashROM can be programmed as little as 20 times
before programming errors occur. This is <em>much</em> less than 100,000 programming
cycles cited for FlashROM chips of a type used with ESP8266 by reputable
vendors, which points to either production rejects, or second-hand worn-out
flash chips to be used on some (apparently cheap) modules/boards. You may want
to use your best judgement about source, price, documentation, warranty,
post-sales support for the modules/boards you purchase.

</li>
<li>The flashing instructions above use flashing speed of 460800 baud, which is
good compromise between speed and stability. However, depending on your
module/board, USB-UART convertor, cables, host OS, etc., the above baud
rate may be too high and lead to errors. Try a more common 115200 baud
rate instead in such cases.

</li>
<li>If lower baud rate didn't help, you may want to try older version of
esptool.py, which had a different programming algorithm:

pip install esptool==1.0.1


This version doesn't support <code class="docutils literal"><span class="pre">--flash_size=detect</span></code> option, so you will
need to specify FlashROM size explicitly (in megabits). It also requires
Python 2.7, so you may need to use <code class="docutils literal"><span class="pre">pip2</span></code> instead of <code class="docutils literal"><span class="pre">pip</span></code> in the
command above.

</li>
<li>The <code class="docutils literal"><span class="pre">--flash_size</span></code> option in the commands above is mandatory. Omitting
it will lead to a corrupted firmware.

</li>
<li>To catch incorrect flash content (e.g. from a defective sector on a chip),
add <code class="docutils literal"><span class="pre">--verify</span></code> switch to the commands above.

</li>
<li>Additionally, you can check the firmware integrity from a MicroPython REPL
prompt (assuming you were able to flash it and <code class="docutils literal"><span class="pre">--verify</span></code> option doesn't
report errors):

<span class="kn">import</span> <span class="nn">esp</span>
<span class="n">esp</span><span class="o">.</span><span class="n">check_fw</span><span class="p">()</span>


If the last output value is True, the firmware is OK. Otherwise, it's
corrupted and need to be reflashed correctly.

</li>
<li>If you experience any issues with another flashing application (not
esptool.py), try esptool.py, it is a generally accepted flashing
application in the ESP8266 community.

</li>
<li>If you still experience problems with even flashing the firmware, please
refer to esptool.py project page, <a class="reference external" href="https://github.com/espressif/esptool">https://github.com/espressif/esptool</a>
for additional documentation and bug tracker where you can report problems.

</li>
<li>If you are able to flash firmware, but <code class="docutils literal"><span class="pre">--verify</span></code> option or
<code class="docutils literal"><span class="pre">esp.check_fw()</span></code> return errors even after multiple retries, you
may have a defective FlashROM chip, as explained above.

</li>
</ul>



<h2><span class="orange">2. Getting a MicroPython REPL prompt</span></h2>
REPL stands for Read Evaluate Print Loop, and is the name given to the
interactive MicroPython prompt that you can access on the ESP8266.  
Using the
REPL is by far the easiest way to test out your code and run commands.

There are two ways to access the REPL: either via a wired connection through the
UART serial port, or via WiFi.


<h2>2.1. REPL over the serial port</h2>
The REPL is always available on the UART0 serial peripheral, which is connected
to the pins GPIO1 for TX and GPIO3 for RX.  
The baudrate of the REPL is 115200.
If your board has a USB-serial convertor on it then you should be able to access
the REPL directly from your PC.  
Otherwise you will need to have a way of
communicating with the UART.

To access the prompt over USB-serial you need to use a terminal emulator program.
On Windows TeraTerm is a good choice, on Mac you can use the built-in screen
program, and Linux has picocom and minicom.  
Of course, there are many other
terminal programs that will work, so pick your favourite!

For example, on Linux you can try running:

<span class="n">picocom</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">ttyUSB0</span> <span class="o">-</span><span class="n">b115200</span>


Once you have made the connection over the serial port you can test if it is
working by hitting enter a few times.  
You should see the Python REPL prompt,
indicated by <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>.

<h2>2.2. WebREPL - a prompt over WiFi</h2>
WebREPL allows you to use the Python prompt over WiFi, connecting through a
browser. The latest versions of Firefox and Chrome are supported.

For your convenience, WebREPL client is hosted at
<a class="reference external" href="http://micropython.org/webrepl">http://micropython.org/webrepl</a> . Alternatively, you can install it
locally from the the GitHub repository
<a class="reference external" href="https://github.com/micropython/webrepl">https://github.com/micropython/webrepl</a> .

Before connecting to WebREPL, you should set a password and enable it via
a normal serial connection. Initial versions of MicroPython for ESP8266
came with WebREPL automatically enabled on the boot and with the
ability to set a password via WiFi on the first connection, but as WebREPL
was becoming more widely known and popular, the initial setup has switched
to a wired connection for improved security:

<span class="kn">import</span> <span class="nn">webrepl_setup</span>


Follow the on-screen instructions and prompts. To make any changes active,
you will need to reboot your device.

To use WebREPL connect your computer to the ESP8266's access point
(MicroPython-xxxxxx, see the previous section about this).  
If you have
already reconfigured your ESP8266 to connect to a router then you can
skip this part.

Once you are on the same network as the ESP8266 you click the &#8220;Connect&#8221; button
(if you are connecting via a router then you may need to change the IP address,
by default the IP address is correct when connected to the ESP8266's access
point).  
If the connection succeeds then you should see a password prompt.

Once you type the password configured at the setup step above, press Enter once
more and you should get a prompt looking like <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code>.  
You can now start
typing Python commands!

<h2>2.3. Using the REPL</h2>
Once you have a prompt you can start experimenting!  Anything you type at the
prompt will be executed after you press the Enter key.  
MicroPython will run
the code that you enter and print the result (if there is one).  
If there is an
error with the text that you enter then an error message is printed.

Try typing the following at the prompt:

<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s1">&#39;hello esp8266!&#39;</span><span class="p">)</span>
<span class="go">hello esp8266!</span>


Note that you shouldn't type the <code class="docutils literal"><span class="pre">&gt;&gt;&gt;</span></code> arrows, they are there to indicate that
you should type the text after it at the prompt.  
And then the line following is
what the device should respond with.  
In the end, once you have entered the text
<code class="docutils literal"><span class="pre">print(&quot;hello</span> <span class="pre">esp8266!&quot;)</span></code> and pressed the Enter key, the output on your screen
should look exactly like it does above.

If you already know some python you can now try some basic commands here.  
 For
example:

<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">12</span><span class="o">**</span><span class="mi">34</span>
<span class="go">4922235242952026704037113243122008064</span>


If your board has an LED attached to GPIO2 (the ESP-12 modules do) then you can
turn it on and off using the following code:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">on</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">off</span><span class="p">()</span>


Note that <code class="docutils literal"><span class="pre">on</span></code> method of a Pin might turn the LED off and <code class="docutils literal"><span class="pre">off</span></code> might
turn it on (or vice versa), depending on how the LED is wired on your board.
To resolve this, machine.Signal class is provided.


<h3>2.3.1. Line editing</h3>
You can edit the current line that you are entering using the left and right
arrow keys to move the cursor, as well as the delete and backspace keys.  
Also,
pressing Home or ctrl-A moves the cursor to the start of the line, and pressing
End or ctrl-E moves to the end of the line.

<h3>2.3.2. Input history</h3>
The REPL remembers a certain number of previous lines of text that you entered
(up to 8 on the ESP8266).  
To recall previous lines use the up and down arrow
keys.

<h3>2.3.3. Tab completion</h3>
Pressing the Tab key will do an auto-completion of the current word that you are
entering.  
This can be very useful to find out functions and methods that a
module or object has.  
Try it out by typing &#8220;ma&#8221; and then pressing Tab.  
It
should complete to &#8220;machine&#8221; (assuming you imported machine in the above
example).  
Then type &#8221;.&#8221; and press Tab again to see a list of all the functions
that the machine module has.

<h3>2.3.4. Line continuation and auto-indent</h3>
Certain things that you type will need &#8220;continuing&#8221;, that is, will need more
lines of text to make a proper Python statement.  
In this case the prompt will
change to <code class="docutils literal"><span class="pre">...</span></code> and the cursor will auto-indent the correct amount so you can
start typing the next line straight away.  
Try this by defining the following
function:

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">toggle</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>   <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>


In the above, you needed to press the Enter key three times in a row to finish
the compound statement (that's the three lines with just dots on them).  
The
other way to finish a compound statement is to press backspace to get to the
start of the line, then press the Enter key.  
(If you did something wrong and
want to escape the continuation mode then press ctrl-C; all lines will be
ignored.)

The function you just defined allows you to toggle a pin.  
The pin object you
created earlier should still exist (recreate it if it doesn't) and you can
toggle the LED using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">toggle</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>


Let's now toggle the LED in a loop (if you don't have an LED then you can just
print some text instead of calling toggle, to see the effect):

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">toggle</span><span class="p">(</span><span class="n">pin</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>


This will toggle the LED at 1Hz (half a second on, half a second off).  
To stop
the toggling press ctrl-C, which will raise a KeyboardInterrupt exception and
break out of the loop.

The time module provides some useful functions for making delays and doing
timing.  
Use tab completion to find out what they are and play around with them!

<h3>2.3.5. Paste mode</h3>
Pressing ctrl-E will enter a special paste mode.  
This allows you to copy and
paste a chunk of text into the REPL.  
If you press ctrl-E you will see the
paste-mode prompt:

paste mode; Ctrl-C to cancel, Ctrl-D to finish
===


You can then paste (or type) your text in.  
Note that none of the special keys
or commands work in paste mode (eg Tab or backspace), they are just accepted
as-is.  
Press ctrl-D to finish entering the text and execute it.

<h3>2.3.6. Other control commands</h3>
There are four other control commands:

<ul class="simple">
<li>Ctrl-A on a blank line will enter raw REPL mode.  
This is like a permanent
paste mode, except that characters are not echoed back.</li>
<li>Ctrl-B on a blank like goes to normal REPL mode.</li>
<li>Ctrl-C cancels any input, or interrupts the currently running code.</li>
<li>Ctrl-D on a blank line will do a soft reset.</li>
</ul>
Note that ctrl-A and ctrl-D do not work with WebREPL.



<h2><span class="orange">3. The internal filesystem</span></h2>
If your devices has 1Mbyte or more of storage then it will be set up (upon first
boot) to contain a filesystem.  
This filesystem uses the FAT format and is
stored in the flash after the MicroPython firmware.


<h2>3.1. Creating and reading files</h2>
MicroPython on the ESP8266 supports the standard way of accessing files in
Python, using the built-in <code class="docutils literal"><span class="pre">open()</span></code> function.

To create a file try:

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;some data&#39;</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


The &#8220;9&#8221; is the number of bytes that were written with the <code class="docutils literal"><span class="pre">write()</span></code> method.
Then you can read back the contents of this new file using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">&#39;some data&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


Note that the default mode when opening a file is to open it in read-only mode,
and as a text file.  
Specify <code class="docutils literal"><span class="pre">'wb'</span></code> as the second argument to <code class="docutils literal"><span class="pre">open()</span></code> to
open for writing in binary mode, and <code class="docutils literal"><span class="pre">'rb'</span></code> to open for reading in binary
mode.

<h2>3.2. Listing file and more</h2>
The os module can be used for further control over the filesystem.  
First
import the module:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>


Then try listing the contents of the filesystem:

<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">()</span>
<span class="go">[&#39;boot.py&#39;, &#39;port_config.py&#39;, &#39;data.txt&#39;]</span>


You can make directories:

<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="s1">&#39;dir&#39;</span><span class="p">)</span>


And remove entries:

<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;data.txt&#39;</span><span class="p">)</span>


<h2>3.3. Start up scripts</h2>
There are two files that are treated specially by the ESP8266 when it starts up:
boot.py and main.py.  
The boot.py script is executed first (if it exists) and
then once it completes the main.py script is executed.  
You can create these
files yourself and populate them with the code that you want to run when the
device starts up.

<h2>3.4. Accessing the filesystem via WebREPL</h2>
You can access the filesystem over WebREPL using the web client in a browser
or via the command-line tool. Please refer to Quick Reference and Tutorial
sections for more information about WebREPL.




<h2><span class="orange">4. Network basics</span></h2>
The network module is used to configure the WiFi connection.  
There are two WiFi
interfaces, one for the station (when the ESP8266 connects to a router) and one
for the access point (for other devices to connect to the ESP8266).  
Create
instances of these objects using:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">network</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ap_if</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">AP_IF</span><span class="p">)</span>


You can check if the interfaces are active by:

<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span><span class="o">.</span><span class="n">active</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ap_if</span><span class="o">.</span><span class="n">active</span><span class="p">()</span>
<span class="go">True</span>


You can also check the network settings of the interface by:

<span class="gp">&gt;&gt;&gt; </span><span class="n">ap_if</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">()</span>
<span class="go">(&#39;192.168.4.1&#39;, &#39;255.255.255.0&#39;, &#39;192.168.4.1&#39;, &#39;8.8.8.8&#39;)</span>


The returned values are: IP address, netmask, gateway, DNS.


<h2>4.1. Configuration of the WiFi</h2>
Upon a fresh install the ESP8266 is configured in access point mode, so the
AP_IF interface is active and the STA_IF interface is inactive.  
You can
configure the module to connect to your own network using the STA_IF interface.

First activate the station interface:

<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>


Then connect to your WiFi network:

<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;&lt;your ESSID&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;your password&gt;&#39;</span><span class="p">)</span>


To check if the connection is established use:

<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span><span class="o">.</span><span class="n">isconnected</span><span class="p">()</span>


Once established you can check the IP address:

<span class="gp">&gt;&gt;&gt; </span><span class="n">sta_if</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">()</span>
<span class="go">(&#39;192.168.0.2&#39;, &#39;255.255.255.0&#39;, &#39;192.168.0.1&#39;, &#39;8.8.8.8&#39;)</span>


You can then disable the access-point interface if you no longer need it:

<span class="gp">&gt;&gt;&gt; </span><span class="n">ap_if</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>


Here is a function you can run (or put in your boot.py file) to automatically
connect to your WiFi network:

<span class="k">def</span> <span class="nf">do_connect</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">network</span>
    <span class="n">sta_if</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sta_if</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;connecting to network...&#39;</span><span class="p">)</span>
        <span class="n">sta_if</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">sta_if</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;&lt;essid&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;password&gt;&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">sta_if</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
            <span class="k">pass</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;network config:&#39;</span><span class="p">,</span> <span class="n">sta_if</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">())</span>


<h2>4.2. Sockets</h2>
Once the WiFi is set up the way to access the network is by using sockets.
A socket represents an endpoint on a network device, and when two sockets are
connected together communication can proceed.
Internet protocols are built on top of sockets, such as email (SMTP), the web
(HTTP), telnet, ssh, among many others.  
Each of these protocols is assigned
a specific port, which is just an integer.  
Given an IP address and a port
number you can connect to a remote device and start talking with it.

The next part of the tutorial discusses how to use sockets to do some common
and useful network tasks.




<h2><span class="orange">5. Network - TCP sockets</span></h2>
The building block of most of the internet is the TCP socket.  
These sockets
provide a reliable stream of bytes between the connected network devices.
This part of the tutorial will show how to use TCP sockets in a few different
cases.


<h2>5.1. Star Wars Asciimation</h2>
The simplest thing to do is to download data from the internet.  
In this case
we will use the Star Wars Asciimation service provided by the blinkenlights.nl
website.  
It uses the telnet protocol on port 23 to stream data to anyone that
connects.  
It's very simple to use because it doesn't require you to
authenticate (give a username or password), you can just start downloading data
straight away.

The first thing to do is make sure we have the socket module available:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">socket</span>


Then get the IP address of the server:

<span class="gp">&gt;&gt;&gt; </span><span class="n">addr_info</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s2">&quot;towel.blinkenlights.nl&quot;</span><span class="p">,</span> <span class="mi">23</span><span class="p">)</span>


The <code class="docutils literal"><span class="pre">getaddrinfo</span></code> function actually returns a list of addresses, and each
address has more information than we need.  
We want to get just the first valid
address, and then just the IP address and port of the server.  
To do this use:

<span class="gp">&gt;&gt;&gt; </span><span class="n">addr</span> <span class="o">=</span> <span class="n">addr_info</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


If you type <code class="docutils literal"><span class="pre">addr_info</span></code> and <code class="docutils literal"><span class="pre">addr</span></code> at the prompt you will see exactly what
information they hold.

Using the IP address we can make a socket and connect to the server:

<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>


Now that we are connected we can download and display the data:

<span class="gp">&gt;&gt;&gt; </span><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="gp">...</span>


When this loop executes it should start showing the animation (use ctrl-C to
interrupt it).

You should also be able to run this same code on your PC using normal Python if
you want to try it out there.

<h2>5.2. HTTP GET request</h2>
The next example shows how to download a webpage.  
HTTP uses port 80 and you
first need to send a &#8220;GET&#8221; request before you can download anything.  
As part
of the request you need to specify the page to retrieve.

Let's define a function that can download and print a URL:

<span class="k">def</span> <span class="nf">http_get</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">url</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">addr</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="mi">80</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">s</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="nb">bytes</span><span class="p">(</span><span class="s1">&#39;GET /</span><span class="si">%s</span><span class="s1"> HTTP/1.0</span><span class="se">\r\n</span><span class="s1">Host: </span><span class="si">%s</span><span class="se">\r\n\r\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">host</span><span class="p">),</span> <span class="s1">&#39;utf8&#39;</span><span class="p">))</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;utf8&#39;</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">s</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


Make sure that you import the socket module before running this function.  
Then
you can try:

<span class="gp">&gt;&gt;&gt; </span><span class="n">http_get</span><span class="p">(</span><span class="s1">&#39;http://micropython.org/ks/test.html&#39;</span><span class="p">)</span>


This should retrieve the webpage and print the HTML to the console.

<h2>5.3. Simple HTTP server</h2>
The following code creates an simple HTTP server which serves a single webpage
that contains a table with the state of all the GPIO pins:

<span class="kn">import</span> <span class="nn">machine</span>
<span class="n">pins</span> <span class="o">=</span> <span class="p">[</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">)]</span>

<span class="n">html</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&lt;!DOCTYPE html&gt;</span>
<span class="s2">&lt;html&gt;</span>
<span class="s2">    &lt;head&gt; &lt;title&gt;ESP8266 Pins&lt;/title&gt; &lt;/head&gt;</span>
<span class="s2">    &lt;body&gt; &lt;h1&gt;ESP8266 Pins&lt;/h1&gt;</span>
<span class="s2">        &lt;table border=&quot;1&quot;&gt; &lt;tr&gt;&lt;th&gt;Pin&lt;/th&gt;&lt;th&gt;Value&lt;/th&gt;&lt;/tr&gt; </span><span class="si">%s</span><span class="s2"> &lt;/table&gt;</span>
<span class="s2">    &lt;/body&gt;</span>
<span class="s2">&lt;/html&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">socket</span>
<span class="n">addr</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getaddrinfo</span><span class="p">(</span><span class="s1">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">80</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">s</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">s</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
<span class="n">s</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s1">&#39;listening on&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="n">cl</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;client connected from&#39;</span><span class="p">,</span> <span class="n">addr</span><span class="p">)</span>
    <span class="n">cl_file</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s1">&#39;rwb&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">cl_file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">==</span> <span class="n">b</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&lt;tr&gt;&lt;td&gt;</span><span class="si">%s</span><span class="s1">&lt;/td&gt;&lt;td&gt;</span><span class="si">%d</span><span class="s1">&lt;/td&gt;&lt;/tr&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pins</span><span class="p">]</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">html</span> <span class="o">%</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
    <span class="n">cl</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>



<h2><span class="orange">6. GPIO Pins</span></h2>
The way to connect your board to the external world, and control other
components, is through the GPIO pins.  
Not all pins are available to use,
in most cases only pins 0, 2, 4, 5, 12, 13, 14, 15, and 16 can be used.

The pins are available in the machine module, so make sure you import that
first.  
Then you can create a pin using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


Here, the &#8220;0&#8221; is the pin that you want to access.  
Usually you want to
configure the pin to be input or output, and you do this when constructing
it.  
To make an input pin use:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span>


You can either use PULL_UP or None for the input pull-mode.  
If it's
not specified then it defaults to None, which is no pull resistor.
You can read the value on the pin using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
<span class="go">0</span>


The pin on your board may return 0 or 1 here, depending on what it's connected
to.  
To make an output pin use:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>


Then set its value using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


Or:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">off</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pin</span><span class="o">.</span><span class="n">on</span><span class="p">()</span>

<h2>6.1. External interrupts</h2>
All pins except number 16 can be configured to trigger a hard interrupt if their
input changes.  
You can set code (a callback function) to be executed on the
trigger.

Let's first define a callback function, which must take a single argument,
being the pin that triggered the function.  
We will make the function just print
the pin:

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;pin change&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>


Next we will create two pins and configure them as inputs:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p0</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>


An finally we need to tell the pins when to trigger, and the function to call
when they detect an event:

<span class="gp">&gt;&gt;&gt; </span><span class="n">p0</span><span class="o">.</span><span class="n">irq</span><span class="p">(</span><span class="n">trigger</span><span class="o">=</span><span class="n">Pin</span><span class="o">.</span><span class="n">IRQ_FALLING</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p2</span><span class="o">.</span><span class="n">irq</span><span class="p">(</span><span class="n">trigger</span><span class="o">=</span><span class="n">Pin</span><span class="o">.</span><span class="n">IRQ_RISING</span> <span class="o">|</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IRQ_FALLING</span><span class="p">,</span> <span class="n">handler</span><span class="o">=</span><span class="n">callback</span><span class="p">)</span>


We set pin 0 to trigger only on a falling edge of the input (when it goes from
high to low), and set pin 2 to trigger on both a rising and falling edge.  
After
entering this code you can apply high and low voltages to pins 0 and 2 to see
the interrupt being executed.

A hard interrupt will trigger as soon as the event occurs and will interrupt any
running code, including Python code.  
As such your callback functions are
limited in what they can do (they cannot allocate memory, for example) and
should be as short and simple as possible.




<h2><span class="orange">7. Pulse Width Modulation</span></h2>
Pulse width modulation (PWM) is a way to get an artificial analog output on a
digital pin.  
It achieves this by rapidly toggling the pin from low to high.
There are two parameters associated with this: the frequency of the toggling,
and the duty cycle.  
The duty cycle is defined to be how long the pin is high
compared with the length of a single period (low plus high time).  
Maximum
duty cycle is when the pin is high all of the time, and minimum is when it is
low all of the time.

On the ESP8266 the pins 0, 2, 4, 5, 12, 13, 14 and 15 all support PWM.  
The
limitation is that they must all be at the same frequency, and the frequency
must be between 1Hz and 1kHz.

To use PWM on a pin you must first create the pin object, for example:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p12</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>


Then create the PWM object using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm12</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">PWM</span><span class="p">(</span><span class="n">p12</span><span class="p">)</span>


You can set the frequency and duty cycle using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm12</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm12</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span>


Note that the duty cycle is between 0 (all off) and 1023 (all on), with 512
being a 50% duty.  
If you print the PWM object then it will tell you its current
configuration:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm12</span>
<span class="go">PWM(12, freq=500, duty=512)</span>


You can also call the <code class="docutils literal"><span class="pre">freq()</span></code> and <code class="docutils literal"><span class="pre">duty()</span></code> methods with no arguments to
get their current values.

The pin will continue to be in PWM mode until you deinitialise it using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pwm12</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>

<h2>7.1. Fading an LED</h2>
Let's use the PWM feature to fade an LED.  
Assuming your board has an LED
connected to pin 2 (ESP-12 modules do) we can create an LED-PWM object using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">led</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">PWM</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>


Notice that we can set the frequency in the PWM constructor.

For the next part we will use timing and some math, so import these modules:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">math</span>


Then create a function to pulse the LED:

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pulse</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
<span class="gp">... </span>        <span class="n">l</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="mi">500</span> <span class="o">+</span> <span class="mi">500</span><span class="p">))</span>
<span class="gp">... </span>        <span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>


You can try this function out using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">pulse</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>


For a nice effect you can pulse many times in a row:

<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">pulse</span><span class="p">(</span><span class="n">led</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>


Remember you can use ctrl-C to interrupt the code.

<h2>7.2. Control a hobby servo</h2>
Hobby servo motors can be controlled using PWM.  
They require a frequency of
50Hz and then a duty between about 40 and 115, with 77 being the centre value.
If you connect a servo to the power and ground pins, and then the signal line
to pin 12 (other pins will work just as well), you can control the motor using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">servo</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">PWM</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">servo</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">servo</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">115</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">servo</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">77</span><span class="p">)</span>



<h2><span class="orange">8. Analog to Digital Conversion</span></h2>
The ESP8266 has a single pin (separate to the GPIO pins) which can be used to
read analog voltages and convert them to a digital value.  
You can construct
such an ADC pin object using:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adc</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">ADC</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


Then read its value with:

<span class="gp">&gt;&gt;&gt; </span><span class="n">adc</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="go">58</span>


The values returned from the <code class="docutils literal"><span class="pre">read()</span></code> function are between 0 (for 0.0 volts)
and 1024 (for 1.0 volts).  
Please note that this input can only tolerate a
maximum of 1.0 volts and you must use a voltage divider circuit to measure
larger voltages.


  

<h2><span class="orange">9. Power control</span></h2>
The ESP8266 provides the ability to change the CPU frequency on the fly, and
enter a deep-sleep state.  
Both can be used to manage power consumption.


<h2>9.1. Changing the CPU frequency</h2>
The machine module has a function to get and set the CPU frequency.  
To get the
current frequency use:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>
<span class="go">80000000</span>


By default the CPU runs at 80MHz.  
It can be change to 160MHz if you need more
processing power, at the expense of current consumption:

<span class="gp">&gt;&gt;&gt; </span><span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">160000000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>
<span class="go">160000000</span>


You can change to the higher frequency just while your code does the heavy
processing and then change back when it's finished.

<h2>9.2. Deep-sleep mode</h2>
The deep-sleep mode will shut down the ESP8266 and all its peripherals,
including the WiFi (but not including the real-time-clock, which is used to wake
the chip).  
This drastically reduces current consumption and is a good way to
make devices that can run for a while on a battery.

To be able to use the deep-sleep feature you must connect GPIO16 to the reset
pin (RST on the Adafruit Feather HUZZAH board).  
Then the following code can be
used to sleep and wake the device:

<span class="kn">import</span> <span class="nn">machine</span>

<span class="c1"># configure RTC.ALARM0 to be able to wake the device</span>
<span class="n">rtc</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">RTC</span><span class="p">()</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">irq</span><span class="p">(</span><span class="n">trigger</span><span class="o">=</span><span class="n">rtc</span><span class="o">.</span><span class="n">ALARM0</span><span class="p">,</span> <span class="n">wake</span><span class="o">=</span><span class="n">machine</span><span class="o">.</span><span class="n">DEEPSLEEP</span><span class="p">)</span>

<span class="c1"># set RTC.ALARM0 to fire after 10 seconds (waking the device)</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">alarm</span><span class="p">(</span><span class="n">rtc</span><span class="o">.</span><span class="n">ALARM0</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># put the device to sleep</span>
<span class="n">machine</span><span class="o">.</span><span class="n">deepsleep</span><span class="p">()</span>


Note that when the chip wakes from a deep-sleep it is completely reset,
including all of the memory.  
The boot scripts will run as usual and you can
put code in them to check the reset cause to perhaps do something different if
the device just woke from a deep-sleep.  
For example, to print the reset cause
you can use:

<span class="k">if</span> <span class="n">machine</span><span class="o">.</span><span class="n">reset_cause</span><span class="p">()</span> <span class="o">==</span> <span class="n">machine</span><span class="o">.</span><span class="n">DEEPSLEEP_RESET</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;woke from a deep sleep&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;power on or hard reset&#39;</span><span class="p">)</span>



<h2><span class="orange">10. Controlling 1-wire devices</span></h2>
The 1-wire bus is a serial bus that uses just a single wire for communication
(in addition to wires for ground and power).  
The DS18B20 temperature sensor
is a very popular 1-wire device, and here we show how to use the onewire module
to read from such a device.

For the following code to work you need to have at least one DS18S20 or DS18B20 temperature
sensor with its data line connected to GPIO12.  
You must also power the sensors
and connect a 4.7k Ohm resistor between the data pin and the power pin.

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">machine</span>
<span class="kn">import</span> <span class="nn">onewire</span><span class="o">,</span> <span class="nn">ds18x20</span>

<span class="c1"># the device is on GPIO12</span>
<span class="n">dat</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="c1"># create the onewire object</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">ds18x20</span><span class="o">.</span><span class="n">DS18X20</span><span class="p">(</span><span class="n">onewire</span><span class="o">.</span><span class="n">OneWire</span><span class="p">(</span><span class="n">dat</span><span class="p">))</span>

<span class="c1"># scan for devices on the bus</span>
<span class="n">roms</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;found devices:&#39;</span><span class="p">,</span> <span class="n">roms</span><span class="p">)</span>

<span class="c1"># loop 10 times and print all temperatures</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;temperatures:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="n">ds</span><span class="o">.</span><span class="n">convert_temp</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">rom</span> <span class="ow">in</span> <span class="n">roms</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">read_temp</span><span class="p">(</span><span class="n">rom</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">print</span><span class="p">()</span>


Note that you must execute the <code class="docutils literal"><span class="pre">convert_temp()</span></code> function to initiate a
temperature reading, then wait at least 750ms before reading the value.


  

<h2><span class="orange">11. Controlling NeoPixels</span></h2>
NeoPixels, also known as WS2812 LEDs, are full-colour LEDs that are connected in
serial, are individually addressable, and can have their red, green and blue
components set between 0 and 255.  
They require precise timing to control them
and there is a special neopixel module to do just this.

To create a NeoPixel object do the following:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span><span class="o">,</span> <span class="nn">neopixel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span> <span class="o">=</span> <span class="n">neopixel</span><span class="o">.</span><span class="n">NeoPixel</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">8</span><span class="p">)</span>


This configures a NeoPixel strip on GPIO4 with 8 pixels.  
You can adjust the
&#8220;4&#8221; (pin number) and the &#8220;8&#8221; (number of pixel) to suit your set up.

To set the colour of pixels use:

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># set to red, full brightness</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># set to green, half brightness</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>  <span class="c1"># set to blue, quarter brightness</span>


Then use the <code class="docutils literal"><span class="pre">write()</span></code> method to output the colours to the LEDs:

<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>


The following demo function makes a fancy show on the LEDs:

<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">(</span><span class="n">np</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">n</span>

    <span class="c1"># cycle</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">np</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">np</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>

    <span class="c1"># bounce</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">np</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="n">n</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">np</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>

    <span class="c1"># fade in/out</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">//</span> <span class="mi">256</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="mi">255</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">)</span>
            <span class="n">np</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>

    <span class="c1"># clear</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">np</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>


Execute it using:

<span class="gp">&gt;&gt;&gt; </span><span class="n">demo</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>




<h2><span class="orange">12. Temperature and Humidity</span></h2>
DHT (Digital Humidity &amp; Temperature) sensors are low cost digital sensors with
capacitive humidity sensors and thermistors to measure the surrounding air.
They feature a chip that handles analog to digital conversion and provide a
1-wire interface. Newer sensors additionally provide an I2C interface.

The DHT11 (blue) and DHT22 (white) sensors provide the same 1-wire interface,
however, the DHT22 requires a separate object as it has more complex
calculation. DHT22 have 1 decimal place resolution for both humidity and
temperature readings. DHT11 have whole number for both.

A custom 1-wire protocol, which is different to Dallas 1-wire, is used to get
the measurements from the sensor. The payload consists of a humidity value,
a temperature value and a checksum.

To use the 1-wire interface, construct the objects referring to their data pin:

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dht</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT11</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dht</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">machine</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT22</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>


Then measure and read their values with:

<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">humidity</span><span class="p">()</span>


Values returned from <code class="docutils literal"><span class="pre">temperature()</span></code> are in degrees Celsius and values
returned from <code class="docutils literal"><span class="pre">humidity()</span></code> are a percentage of relative humidity.

The DHT11 can be called no more than once per second and the DHT22 once every
two seconds for most accurate results. Sensor accuracy will degrade over time.
Each sensor supports a different operating range. Refer to the product
datasheets for specifics.

In 1-wire mode, only three of the four pins are used and in I2C mode, all four
pins are used. Older sensors may still have 4 pins even though they do not
support I2C. The 3rd pin is simply not connected.

Pin configurations:

Sensor without I2C in 1-wire mode (eg. DHT11, DHT22, AM2301, AM2302):

<blockquote>
1=VDD, 2=Data, 3=NC, 4=GND</blockquote>
Sensor with I2C in 1-wire mode (eg. DHT12, AM2320, AM2321, AM2322):

<blockquote>
1=VDD, 2=Data, 3=GND, 4=GND</blockquote>
Sensor with I2C in I2C mode (eg. DHT12, AM2320, AM2321, AM2322):

<blockquote>
1=VDD, 2=SDA, 3=GND, 4=SCL</blockquote>
You should use pull-up resistors for the Data, SDA and SCL pins.

To make newer I2C sensors work in backwards compatible 1-wire mode, you must
connect both pins 3 and 4 to GND. This disables the I2C interface.

DHT22 sensors are now sold under the name AM2302 and are otherwise identical.


  

<h2><span class="orange">13. Next steps</span></h2>
That brings us to the end of the tutorial!  Hopefully by now you have a good
feel for the capabilities of MicroPython on the ESP8266 and understand how to
control both the WiFi and IO aspects of the chip.

There are many features that were not covered in this tutorial.  
The best way
to learn about them is to read the full documentation of the modules, and to
experiment!

Good luck creating your Internet of Things devices!

<h2>proteus 中仿真 micropython</h2>
Proteus 是一个支持仿真单片机的EDA软件，以前经常用来仿真 51、avr、pic、msp40等单片机，后来也逐步支持Arduino、树莓派和STM32，而在最新版本（v8.17 sp4）的 proteus 中，开始支持 micropython 仿真了。
下面就展示一下怎样使用 proteus 仿真 micropython 程序、仿真的效果，以及仿真中的问题。
首先需要安装最新版本的 proteus 软件，然后新建一个项目，并选择项目的名称和位置：
<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EMKice8AABImxQf5wcZ84dk4icxeFtbQfhcsYsaoMptmzU8KlZStviaqRQ/640">

在项目向导中，选择创建原理图。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6E0yh1wuObmPkT8T2Wk0CzVyf5ptIJaP47TNxrLpraqZQObicibFaIE1aw/640">

如果只是为了仿真，可以不用创建 PCB 文件。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EQ8qVKmzmzZbwSVDibGafib8lqIKoia80SnDiadJBia7SYIZNr79OL9SuXLg/640">

然后选择创建固件项目（Create Firmware Project），并在系列（Family）中选择 MicroPython：
<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EqBg1UlibEJia1Gn3Uo6vFsark6aZFbo4ENyCY4j9KKjKJBCmksPRk9Eg/640">

接下来在控制器（Controller）中选择 PI PICO，也就是树莓派的RP2040。
目前 proteus 支持 ESP32-S3 和 RP2040 两种型号的微控制器，推荐选择 PI PICO，因为目前软件对 ESP32-S3的支持不太完善，部分硬件功能还不能正常仿真，如硬件 I2C 功能。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EzwNFyheWdrGGic6yEeFYbNfdXicic2w1u74TSP07Xu9oGkUicXkLwibNg8g/640">

确认参数无误后，单击 FInish 按钮完成项目设置。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6Enu7JJa6xib9QKYLhzHLjNC7GFzF3uAibIx42PqXAwkDhFwykYppCflLw/640">

完成项目设置后，就会显示如下界面：包含了原理图和代码编辑。
原理图部分已经包含了 RP2040（和PI PICO开发板一样，GPIO25连接到内部的LED，可以直接使用），代码编辑区中显示了默认的代码模板。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EicVSOhrgYvSalQhGNz3Y3L7jYib0ywWhwPTAxjDN6J3d7k46sMFVDvJA/640">

现在就可以和仿真其它电路一样，先添加各种元件，然后连接信号，再编写 MicroPython 代码，添加各种 MicroPython 库，最后进行仿真，验证电路设计或程序功能。
我们先在器件库中查找 I2C LCD，找到 I2C-16x2，也就是 I2C 接口的 LCD1602。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EjOrjPFJfgqP1NH5ED50ic3b8PpBm6ZnkG45a2nic1M79KofmQtk4LOAw/640">

添加元件到原理图，连接 LCD1602 的 VDD和VSS，再将 SDA/SCL 连接到 RP2040 的 GP0/GP1，这两个GPIO被用于 I2C0（注意RP2040的硬件I2C只能使用几个特定引脚，而不是像ESP32那样任意引脚都可以）。
这里省略了 I2C 的上拉电阻，它对仿真结果没有太大影响。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EPFRzVgCL5NDgT2picD8iavuVVKNnM0SP10dDk5pNutsssMONysLdhvbg/640">

在代码编辑器先输入下面代码，用 i2c.scan() 搜索一下器件地址：
from machine import Pin, I2C
i2c = I2C(0, scl=Pin(1), sda=Pin(0))
print(i2c.scan()) 
按下左下角的运行按钮，开始进行仿真，如果没有错误，就可以看到下面的结果，显示搜索到地址为63的设备。
如果出现错误就检查连线和代码，查找问题。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6ESfoN7AM4snQUm7wIwsuFic1x4mGtSoowia4vWHFtMib7tdt1XgKmwAxoQ/640">

然后停止仿真，先从 github 或 gitee 下载社区的 i2c lcd1602的驱动库（https://gitee.com/microbit/mpy-lib/blob/master/lcd/I2C_LCD1602/i2c_lcd1602.py），从菜单中选择 project -&gt; Add File，并选择下载后的 i2c_lcd1602.py 文件。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EUJayS7ZLJxFvibWficwefecdibrYlVVpRs2TbAwbNW80eIQia36Xvv2RLg/640">

这样就可以将 i2c_lcd1602.py 文件添加到项目中，并在程序中使用了。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EFia7coTrLF0cHxAUOJrLcJXypIGiagnlYcYCQzbVGPuPgmniaSrSnnYHw/640">

在 main.py 中编写一段测试代码，它先创建一个 i2c 对象，再创建一个 LCD1602 实例，最后在屏幕上显示一个不断递增的数字：
from machine import Pin, I2C
from i2c_lcd1602 import I2C_LCD1602
from time import sleep_ms
led = Pin(25, Pin.OUT)i2c = I2C(0, scl=Pin(1), sda=Pin(0))
print(i2c.scan())
lcd = I2C_LCD1602(i2c, 63)
n = 0
while 1:    lcd.puts(n, 0, 0)    n += 1    sleep_ms(1000)
运行仿真，我们就能看到下面的结果，可以看到仿真的效果和实际硬件上运行是一致的。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_gif/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EibY8oXtHgGUicabcCfa78XYbMODFpSFhBdlKRkZj2bJWLz1pEmGRyYIA/640">

我们再从元件库中查找并添加一个 BME280 （温湿度、气压传感器），并将它的各引脚连接起来，I2C接口和LCD是共用的。
为了方便，这里将BME280的SDO引脚连接到了VCC，也就是设备地址为 0x77。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EujKLxyRLqdiblusl7PmuJ75n3qpcBqJ2IP71yxQXPDYG1MnyKKV5Wrg/640">

从社区的驱动库中（https://gitee.com/microbit/mpy-lib/blob/master/sensor/bme280/bme280.py）下载BME280的驱动，并添加到项目中。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EQ2chZwLLmsr0ZKaqRMyAS8evdnCJlUXsK5Gq5J5g94M410QHTK2CAA/640">

修改mian.py，添加相关代码：
from machine import Pin, I2C
from bme280 import BME280
from i2c_lcd1602 import I2C_LCD1602
from time import sleep_ms
led = Pin(25, Pin.OUT)i2c = I2C(0, scl=Pin(1), sda=Pin(0))
print(i2c.scan())
bm = BME280(i2c, 0x77)lcd = I2C_LCD1602(i2c, 63)
n = 0
while 1:
   led(not led())
   n+=1
   lcd.puts(n, 0, 0)   lcd.puts(f"{bm.getHumi():.1f}%", 7, 0)   lcd.puts(f"{bm.getTemp():.1f}C", 0, 1)   lcd.puts(f"{bm.getPress()/100:.1f}P", 7, 1)
   sleep_ms(500)
仿真运行，就可以在LCD上看到传感器的数值。
仿真时，可以通过 BME280 下方的三个红色按钮，改变传感器的数值，在屏幕上可以看到采集的数据会同步变化。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_gif/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6ENYs0V1WYQ2B3tw4ic6ozwSVkue1jDjPUbrFbs8s314Ualxgc4EYe3kw/640">

从上面的过程中可以发现，使用 proteus 可以方便的使用 micropython 调试电路，简化开发过程。
用同样方法可以测试更多器件，下面是 DS3232（高精度时钟）、MCP4018（数字电位器）、SHT21（温湿度传感器）的仿真效果。
大家还可以尝试更多不同传感器和模块，测试在 proteus 中的仿真效果。

<img src="https://mmbiz.qpic.cn/sz_mmbiz_gif/Z8ssCo6dAQI9SV45NN15VurnwSyTtU6EvDfia7ic7jCmu9AMVgjqKbfNBAxYohbbfcm73RCZkkFfJHtcu946dKsA/640">

使用proteus可以简化开发流程，在没有实际硬件的情况下进行开发，快速验证软件算法、硬件功能，提高开发效率。
但是也需要注意到软件仿真并不能完全取代硬件，毕竟软件仿真擅长的是算法和功能模拟，但是无法完全模拟硬件的全部功能，也无法仿真电气性能。
下面是目前发现的几个问题。
目前已知限制：支持主控芯片型号太少，而且对 ESP32-S3 的支持不好。
不支持 REPL 功能。
部分器件不能在 micropython 中仿真，如 DS18B20、I2C OLED 12864等。
虽然存在着一些限制，但是proteus的仿真功能仍然是一个非常强大的工具，只要善加利用，配合其它软件和硬件，就能发挥出巨大作用。


<br>
<br>
<br>
<br>

<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre>
</body>
</html>
