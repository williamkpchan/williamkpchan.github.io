<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"/>
<link rel="stylesheet" href="..\maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script>
$(document).ready(function(){
    $('h1, h2, h3, h4, h5, .goldword, .apply, div.title').click(function(){
    parent.history.back();
    return false;
    });
});
</script>
<style>
body{margin-left:10%; width:80%;}
h1, h2 {color: gold;}
</style>
</head><body>
<center><h1></h1></center>
<div id="toc"></div>
<br>
<br>
<br>

<h1>Demystifying JavaScript’s ‘new’ keyword
</h1>

<div class="section-inner sectionLayout--insetColumn">
<p name="40c8" id="40c8" class="graf graf--p graf-after--figure">Over the weekend, I completed Will Sentance’s 
<a href="https://frontendmasters.com/courses/javascript-hard-parts/" data-href="https://frontendmasters.com/courses/javascript-hard-parts/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">JavaScript: The Hard Parts
</a>. It might not sound like the most glorious way to spend a weekend, but I actually found it pretty fun and relaxing to complete the course. It touched on functional programming, higher-order functions, closures, and asynchronous JavaScript.
</p>
<p name="3bca" id="3bca" class="graf graf--p graf-after--p">For me, the highlight of the course was how he expanded on the JavaScript approaches to Object-Oriented Programming (OOP) and demystified the magic behind the 
<strong class="markup--strong markup--p-strong">new 
</strong>operator. I now have a well-rounded understanding of what goes on under the hood when the 
<strong class="markup--strong markup--p-strong">new
</strong> operator is used.
</p>
<h3 name="2800" id="2800" class="graf graf--h3 graf-after--p">Object-Oriented Programming in JavaScript
</h3>

<p name="3ab6" id="3ab6" class="graf graf--p graf-after--figure">Object-Oriented Programming (OOP) is a programming paradigm based on the concept of “objects.” Data and functions (attributes and methods) are bundled within an object.
</p>
<p name="52b7" id="52b7" class="graf graf--p graf-after--p">An object in JavaScript is a collection of key-value pairs. These key-value pairs are properties of the object. A property can be an array, a function, an object itself or any primitive data type such as strings or integers.
</p>
<p name="332f" id="332f" class="graf graf--p graf-after--p">What techniques do we have in our JavaScript toolbox for object creation?
</p>
<p name="ebfb" id="ebfb" class="graf graf--p graf-after--p">Let’s assume that we are creating users in a game that we just designed. How would we store user details such as their names, points, and implement methods such as an increment in points? Here are two options for basic object creation.
</p>
<h4 name="5bdc" id="5bdc" class="graf graf--h4 graf-after--p">
<strong class="markup--strong markup--h4-strong">Option 1 — Object Literal Notation
</strong>
</h4>
<pre name="0751" id="0751" class="graf graf--pre graf-after--h4">let user1 = {
<br>  name: &quot;Taylor&quot;,
<br>  points: 5,
<br>  increment: function() {
<br>    user1.points++;
<br>  }
<br>};
</pre>
<p name="bb70" id="bb70" class="graf graf--p graf-after--pre">A JavaScript object literal is a list of name-value pairs wrapped in curly braces. In the example above, the object ‘user1’ is created, and the associated data is stored within it.
</p>
<h4 name="a0c8" id="a0c8" class="graf graf--h4 graf-after--p">
<strong class="markup--strong markup--h4-strong">Option 2 — Object.create()
</strong>
</h4>
<p name="5d1e" id="5d1e" class="graf graf--p graf-after--h4">
<code class="markup--code markup--p-code">Object.create(proto [, propertiesObject ])
</code>
</p>
<p name="f1f6" id="f1f6" class="graf graf--p graf-after--p">
<code class="markup--code markup--p-code">Object.create
</code> methods accept two arguments:
</p>
<ol class="postList">
<li name="1898" id="1898" class="graf graf--li graf-after--p">proto: the object which should be the prototype of the newly-created object. It has to be an object or null.
</li>
<li name="dd0d" id="dd0d" class="graf graf--li graf-after--li">propertiesObject: properties of the new object. This argument is optional.
</li>
</ol>
<p name="4efa" id="4efa" class="graf graf--p graf-after--li">Basically, you pass into 
<code class="markup--code markup--p-code">Object.create
</code> an object that you want to inherit from, and it returns a new object that inherits from the object you passed into it.
</p>
<pre name="8dcf" id="8dcf" class="graf graf--pre graf-after--p">let user2 = Object.create(null);
</pre>
<pre name="7d9d" id="7d9d" class="graf graf--pre graf-after--pre">user2.name = &quot;Cam&quot;;
<br>user2.points = 8;
<br>user2.increment = function() {
<br>  user2.points++;
<br>}
</pre>
<p name="63fa" id="63fa" class="graf graf--p graf-after--pre">The basic object creation options above are repetitive. It requires each one to be manually created.
</p>
<p name="b0c0" id="b0c0" class="graf graf--p graf-after--p">How do we overcome this?
</p>
<h3 name="69db" id="69db" class="graf graf--h3 graf-after--p">Solutions
</h3>
<h4 name="489e" id="489e" class="graf graf--h4 graf-after--h3">
<strong class="markup--strong markup--h4-strong">Solution 1 — Generate objects using a function
</strong>
</h4>
<p name="da1e" id="da1e" class="graf graf--p graf-after--h4">A simple solution is to write a function to create new users.
</p>
<pre name="9e43" id="9e43" class="graf graf--pre graf-after--p">function createUser(name, points) {
<br>  let newUser = {};
<br>  newUser.name = name;
<br>  newUser.points = points;
<br>  newUser.increment = function() {
<br>    newUser.points++;
<br>  };
<br>  return newUser;
<br>}
</pre>
<p name="9e2d" id="9e2d" class="graf graf--p graf-after--pre">To create a user, you would now enter the information in parameters of the function.
</p>
<pre name="7d79" id="7d79" class="graf graf--pre graf-after--p">let user1 = createUser(&quot;Bob&quot;, 5);
<br>user1.increment();
</pre>
<p name="6866" id="6866" class="graf graf--p graf-after--pre">However, the increment function in the example above is just a copy of the original increment function. This is not a good way to write your code, as any potential changes to the function will need to be done manually for each object.
</p>
<h4 name="3cf2" id="3cf2" class="graf graf--h4 graf-after--p">
<strong class="markup--strong markup--h4-strong">Solution 2 — Use the prototypal nature of JavaScript
</strong>
</h4>
<p name="857d" id="857d" class="graf graf--p graf-after--h4">Unlike object-oriented languages such as Python and Java, JavaScript does not have classes. It uses the concept of prototypes and prototype chaining for inheritance.
</p>
<p name="34ab" id="34ab" class="graf graf--p graf-after--p">When you create a new array, you automatically have access to built-in methods such as 
<code class="markup--code markup--p-code">Array.join
</code>, 
<code class="markup--code markup--p-code">Array.sort
</code>, and 
<code class="markup--code markup--p-code">Array.filter
</code>. This is due to the fact that array objects inherit properties from Array.prototype.
</p>

<p name="3ba8" id="3ba8" class="graf graf--p graf-after--figure">Every JavaScript function has a prototype property, which is empty by default. You can add functions to this prototype property, and in this form, it is known as a method. When an inherited function is executed, the value of this points to the inheriting object.
</p>
<pre name="a367" id="a367" class="graf graf--pre graf-after--p">function createUser(name, points) {
<br>  let newUser = Object.create(userFunction);
<br>  newUser.name = name;
<br>  newUser.points = points;
<br>  return newUser;
<br>}
</pre>
<pre name="70ed" id="70ed" class="graf graf--pre graf-after--pre">let userFunction = {
<br>  increment = function() {this.points++};
<br>  login = function() {console.log(&quot;Please login.&quot;)};
<br>}
</pre>
<pre name="9892" id="9892" class="graf graf--pre graf-after--pre">let user1 = createUser(&quot;Bob&quot;, 5);
<br>user1.increment();
</pre>
<p name="0c52" id="0c52" class="graf graf--p graf-after--pre">When the 
<code class="markup--code markup--p-code">user1
</code> object was created, a prototype chain bond with userFunction was formed.
</p>
<p name="e289" id="e289" class="graf graf--p graf-after--p">When 
<code class="markup--code markup--p-code">user1.increment() 
</code>is in the call stack, the interpreter will look for user1 in the global memory. Next, it will look for the increment function, but will not find it. The interpreter will look at the next object up the prototype chain and will find the increment function there.
</p>
<h4 name="fdcd" id="fdcd" class="graf graf--h4 graf-after--p">
<strong class="markup--strong markup--h4-strong">Solution 3 —
<em class="markup--em markup--h4-em"> new
</em> and 
<em class="markup--em markup--h4-em">this
</em> keywords
</strong>
</h4>
<figure name="9275" id="9275" class="graf graf--figure graf-after--h4">
<div class="aspectRatioPlaceholder is-locked" style="max-width: 629px; max-height: 139px;">

<p name="4a72" id="4a72" class="graf graf--p graf-after--figure">The

<strong class="markup--strong markup--p-strong">new
</strong> operator is used to create an instance of an object which has a constructor function.
</p>
<p name="cd46" id="cd46" class="graf graf--p graf-after--p">When we call the constructor function with new, we automate the following actions:
</p>
<ul class="postList">
<li name="cf6e" id="cf6e" class="graf graf--li graf-after--p">A new object is created
</li>
<li name="2669" id="2669" class="graf graf--li graf-after--li">It binds 
<code class="markup--code markup--li-code">this
</code> to the object
</li>
<li name="68a1" id="68a1" class="graf graf--li graf-after--li">The constructor function’s prototype object becomes the __proto__ property of the new object
</li>
<li name="4c0b" id="4c0b" class="graf graf--li graf-after--li">It returns the object from the function
</li>
</ul>
<p name="9ee7" id="9ee7" class="graf graf--p graf-after--li">This is fantastic, because the automation results in less repetitive code!
</p>
<pre name="b820" id="b820" class="graf graf--pre graf-after--p">function User(name, points) {
<br> this.name = name; 
<br> this.points = points;
<br>}
<br>User.prototype.increment = function(){
<br> this.points++;
<br>}
<br>User.prototype.login = function() {
<br> console.log(“Please login.”)
<br>}
</pre>
<pre name="8f7a" id="8f7a" class="graf graf--pre graf-after--pre">let user1 = new User(“Dylan”, 6);
<br>user1.increment();
</pre>
<p name="8122" id="8122" class="graf graf--p graf-after--pre">By using the prototype pattern, each method and property is added directly on the object’s prototype.
</p>
<p name="d206" id="d206" class="graf graf--p graf-after--p">The interpreter will go up the prototypal chain and find the increment function under the prototype property of User, which itself is also an object with the information inside it. Remember — 
<strong class="markup--strong markup--p-strong">All functions in JavaScript are also objects
</strong>. Now that the interpreter has found what it needs, it can create a new local execution context to run 
<code class="markup--code markup--p-code">user1.increment()
</code>.
</p>
<p name="6237" id="6237" class="graf graf--p graf-after--p">
<strong class="markup--strong markup--p-strong">Side note: Difference between __proto__ and prototype
</strong>
</p>
<p name="2daf" id="2daf" class="graf graf--p graf-after--p">If you are already getting confused about __proto__ and prototype, don’t worry! You are far from the only one to be confused about this.
</p>
<p name="46be" id="46be" class="graf graf--p graf-after--p">Prototype is a property of the constructor function that determines what will become the __proto__ property on the constructed object.
</p>
<p name="2bf0" id="2bf0" class="graf graf--p graf-after--p">So, __proto__ is the reference created, and that reference is known as the prototype chain bond.
</p>
<h4 name="dcaf" id="dcaf" class="graf graf--h4 graf-after--p">
<strong class="markup--strong markup--h4-strong">Solution 4 — ES6 ‘syntactic sugar’
</strong>
</h4>

<p name="f1eb" id="f1eb" class="graf graf--p graf-after--figure">Other languages allow us to write our shared methods within the object “constructor” itself. ECMAScript6 introduced the 
<strong class="markup--strong markup--p-strong">class
</strong> keyword, which allows us to write classes that resemble normal classes of other classical languages. In reality, it is syntactic sugar over JavaScript’s prototypal behavior.
</p>
<pre name="ef02" id="ef02" class="graf graf--pre graf-after--p">class User {
<br>  constructor(name, points) {
<br>    this.name = name;
<br>    this.points = points;
<br>  }
<br>  increment () {
<br>    this.points++;
<br>  }
<br>  login () {
<br>    console.log(&quot;Please login.&quot;)
<br>  }
<br>}
</pre>
<pre name="971d" id="971d" class="graf graf--pre graf-after--pre">let user1 = new User(&quot;John&quot;, 12);
<br>user1.increment();
</pre>
<p name="54e0" id="54e0" class="graf graf--p graf-after--pre">In solution 3, the associated methods were precisely implemented using 
<code class="markup--code markup--p-code">User.prototype.functionName
</code>. In this solution, the same results are achieved but the syntax looks cleaner.
</p>
<h3 name="8de4" id="8de4" class="graf graf--h3 graf-after--p">
<strong class="markup--strong markup--h3-strong">Conclusion
</strong>
</h3>
<p name="4032" id="4032" class="graf graf--p graf-after--h3">We have now learned more about the different options we have in JavaScript to create objects. While 
<strong class="markup--strong markup--p-strong">class
</strong> declarations and the
<em class="markup--em markup--p-em"> 
</em>
<strong class="markup--strong markup--p-strong">new
</strong> operator are relatively easy to use, it is important to understand what is automated.
</p>
<p name="b189" id="b189" class="graf graf--p graf-after--p">To recap, the following actions are automated when the constructor function is called with 
<strong class="markup--strong markup--p-strong">new
</strong>
<em class="markup--em markup--p-em">:
</em>
</p>
<ul class="postList">
<li name="b965" id="b965" class="graf graf--li graf-after--p">A new object is created
</li>
<li name="64c4" id="64c4" class="graf graf--li graf-after--li">It binds 
<code class="markup--code markup--li-code">this
</code> to the object
</li>
<li name="fe6a" id="fe6a" class="graf graf--li graf-after--li">The constructor function’s prototype object becomes the __proto__ property of the new object
</li>
<li name="474e" id="474e" class="graf graf--li graf-after--li graf--trailing">It returns the object from the function
</li>
</ul>
</div>
</div>
</section>
<section name="361f" class="section section--body section--last">
<div class="section-divider">
<hr class="section-divider">
</div>
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<p name="9c1a" id="9c1a" class="graf graf--p graf--leading graf--trailing">Thanks for reading my article, and clap if you liked it! Check out my other articles like 
<a href="https://medium.freecodecamp.org/how-i-built-my-pomodoro-clock-app-and-the-lessons-i-learned-along-the-way-51288983f5ee" data-href="https://medium.freecodecamp.org/how-i-built-my-pomodoro-clock-app-and-the-lessons-i-learned-along-the-way-51288983f5ee" class="markup--anchor markup--p-anchor" target="_blank">How I built my Pomodoro Clock app, and the lessons I learned along the way
</a>.
</p>
</div>
</div>
</section>
</div>
<br>
<br>
<br>
<br>

<script>
  $(function() {
    var toc = $('#toc');

    function makeLi(text, href) {
      return $('<a href="' + href + '" target="_self">' + text + '</a><br>');
    }

    $('h2, h3, h4').each(function(i) {
      var chapter = $(this), chapterNumber = i + 1;
      toc.append(
        makeLi(chapter.text(), '#chapter-' + chapterNumber)
      );
      chapter.attr('id', 'chapter-' + chapterNumber);
    });

  });
</script>
</body>
</html>
