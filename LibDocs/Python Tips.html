<base target="_blank"><html><head><title>Python Tips</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Python Tips</h1>
Essential Python Tips and Tricks for Programmers<br>
<div id="toc"></div></center>
<pre>
<br>
<br>
<br>
If you ask any Python programmer to tell about the strengths of Python, he will quote brevity and high readability as the most influencing ones. In this Python tutorial, we'll cover many essential Python tips and tricks that will authenticate the above two points.
We've been collecting these useful shortcuts (tips & tricks) since we started using Python. And what's best than sharing something we know and which could benefit others as well.

In the past, we'd shared a list of <strong><a href="/top-10-python-coding-tips-for-beginners/" target="_blank" rel="noopener">Python programming tips for beginners</a></strong> that aimed to optimize code and reduce coding efforts. And our readers still enjoy reading it.

So today, we're back with one more set of essential Python tips and tricks. All these tips can help you minify the code and optimize execution. Moreover, you can readily use them in live projects while working on regular assignments.


<h2>In-place swapping of two numbers.</h2>
Python provides an intuitive way to do assignments and swapping in one line. Please refer to the below example.

x, y = 10, 20
print(x, y)
 
x, y = y, x
print(x, y)
 
#1 (10, 20)
#2 (20, 10)
The assignment on the right seeds a new tuple. While the left one instantly unpacks that (unreferenced) tuple to the names &lt;a&gt; and &lt;b&gt;.

Once the assignment is through, the new tuple gets unreferenced and flagged for garbage collection. The swapping of variables also occurs at eventually.


<h2>Chaining of comparison operators.</h2>
Aggregation of comparison operators is another trick that can come handy at times.

n = 10
result = 1 &lt; n &lt; 20
print(result)

# True

result = 1 &gt; n &lt;= 9
print(result)

# False

<h2>Use of Ternary operator for conditional assignment.</h2>
Ternary operators are a shortcut for an if-else statement and also known as conditional operators.

[on_true] if [expression] else [on_false]
Here are a few examples which you can use to make your code compact and concise.

The below statement is doing the same what it is meant to i.e. &#8220;<strong>assign 10 to x if y is 9, otherwise assign 20 to x</strong>&#8220;. We can though extend the chaining of operators if required.

x = 10 if (y == 9) else 20
Likewise, we can do the same for class objects.

x = (classA if y == 1 else classB)(param1, param2)
In the above example, classA and classB are two classes and one of the class constructors would get called.

Below is one more example with a no. of conditions joining to evaluate the smallest number.

def small(a, b, c):
	return a if a &lt;= b and a &lt;= c else (b if b &lt;= a and b &lt;= c else c)
	
print(small(1, 0, 1))
print(small(1, 2, 2))
print(small(2, 2, 3))
print(small(5, 4, 3))

#Output
#0 #1 #2 #3
We can even use a ternary operator with the list comprehension.
[m**2 if m &gt; 10 else m**4 for m in range(50)]

#=&gt; [0, 1, 16, 81, 256, 625, 1296, 2401, 4096, 6561, 10000, 121, 144, 169, 196, 225, 256, 289, 324, 361, 400, 441, 484, 529, 576, 625, 676, 729, 784, 841, 900, 961, 1024, 1089, 1156, 1225, 1296, 1369, 1444, 1521, 1600, 1681, 1764, 1849, 1936, 2025, 2116, 2209, 2304, 2401]

<h2>Work with multi-line strings.</h2>
The basic approach is to use backslashes which derive itself from C language.

multiStr = "select * from multi_row \
where row_id &lt; 5"
print(multiStr)

# select * from multi_row where row_id &lt; 5
One more trick is to use the triple-quotes.

multiStr = """select * from multi_row 
where row_id &lt; 5"""
print(multiStr)

#select * from multi_row 
#where row_id &lt; 5
The common issue with the above methods is the lack of proper indentation. If we try to indent, it'll insert whitespaces in the string.

So the final solution is to split the string into multi lines and enclose the entire string in parenthesis.

multiStr= ("select * from multi_row "
"where row_id &lt; 5 "
"order by age") 
print(multiStr)

#select * from multi_row where row_id &lt; 5 order by age

<h2>Storing elements of a list into new variables.</h2>
We can use a list to initialize a no. of variables. While unpacking the list, the count of variables shouldn't exceed the no. of elements in the list.

testList = [1,2,3]
x, y, z = testList

print(x, y, z)

#-&gt; 1 2 3

<h2>Print the file path of imported modules.</h2>
If you want to know the absolute location of modules imported in your code, then use the below trick.

import threading 
import socket

print(threading)
print(socket)

#1- &lt;module 'threading' from '/usr/lib/python2.7/threading.py'&gt;
#2- &lt;module 'socket' from '/usr/lib/python2.7/socket.py'&gt;

<h2>Use the Interactive &#8220;_&#8221; operator.</h2>
It's a useful feature which not many of us know.

In the Python console, whenever we test an expression or call a function, the result dispatches to a temporary name, _ (an underscore).

&gt;&gt;&gt; 2 + 1
3
&gt;&gt;&gt; _
3
&gt;&gt;&gt; print _
3
The &#8220;_&#8221; references to the output of the last executed expression.


<h2>Dictionary/Set comprehensions.</h2>
Like we use list comprehensions, we can also use dictionary/set comprehensions. They are simple to use and just as effective. Here is an example.

testDict = {i: i * i for i in xrange(10)} 
testSet = {i * 2 for i in xrange(10)}

print(testSet)
print(testDict)

#set([0, 2, 4, 6, 8, 10, 12, 14, 16, 18])
#{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
<strong>Note-</strong> There is only a difference of &lt;:&gt; in the two statements. Also, to run the above code in Python3, replace &lt;xrange&gt; with &lt;range&gt;.


<h2>Debugging scripts.</h2>
We can set breakpoints in our Python script with the help of the &lt;pdb&gt; module. Please follow the below example.

import pdb
pdb.set_trace()
We can specify &lt;pdb.set_trace()&gt; anywhere in the script and set a breakpoint there. It's extremely convenient.


<h2>Setup file sharing.</h2>
Python allows running an HTTP server which you can use to share files from the server root directory. Below are the commands to start the server.

<h4># Python 2</h4>
python -m SimpleHTTPServer
<h4># Python 3</h4>
python3 -m http.server
Above commands would start a server on the default port i.e. 8000. You can also use a custom port by passing it as the last argument to the above commands.


<h2>Inspect an object in Python.</h2>
We can inspect objects in Python by calling the dir() method. Here is a simple example.

test = [1, 3, 5, 7]
print( dir(test) )
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

<h2>Simplify if statement.</h2>
To verify multiple values, we can do in the following manner.

if m in [1,3,5,7]:
instead of:

if m==1 or m==3 or m==5 or m==7:
Alternatively, we can use &#8216;{1,3,5,7}' instead of &#8216;[1,3,5,7]' for &#8216;in' operator because &#8216;set' can access each element by O(1).


<h2>Detect Python version at runtime.</h2>
Sometimes we may not want to execute our program if the Python engine currently running is less than the supported version. To achieve this, you can use the below coding snippet. It also prints the currently used Python version in a readable format.

import sys

#Detect the Python version currently in use.
if not hasattr(sys, "hexversion") or sys.hexversion != 50660080:
    print("Sorry, you aren't running on Python 3.5\n")
    print("Please upgrade to 3.5.\n")
    sys.exit(1)
    
#Print Python version in a readable format.
print("Current Python version: ", sys.version)
Alternatively, you can use<code>sys.version_info &gt;= (3, 5)</code> to replace<code>sys.hexversion!= 50660080</code> in the above code. It was a suggestion from one of the informed reader.

Output when running on Python 2.7.

Python 2.7.10 (default, Jul 14 2015, 19:46:27)
[GCC 4.8.2] on linux
   
Sorry, you aren't running on Python 3.5

Please upgrade to 3.5.

Output when running on Python 3.5.

Python 3.5.1 (default, Dec 2015, 13:05:11)
[GCC 4.8.2] on linux
   
Current Python version:  3.5.2 (default, Aug 22 2016, 21:11:05) 
[GCC 5.3.0]

<h2>Combining multiple strings.</h2>
If you want to concatenate all the tokens available in a list, then see the below example.

&gt;&gt;&gt; test = ['I', 'Like', 'Python', 'automation']
Now, let's create a single string from the elements in the list given above.

&gt;&gt;&gt; print ''.join(test)

<h2>Four ways to reverse string/list.</h2>
<h4># Reverse the list itself.</h4>
testList = [1, 3, 5]
testList.reverse()
print(testList)

#-&gt; [5, 3, 1]
<h4># Reverse while iterating in a loop.</h4>
for element in reversed([1,3,5]): print(element)

#1-&gt; 5
#2-&gt; 3
#3-&gt; 1

<h4># Reverse a string in line.</h4>
"Test Python"[::-1]
This gives the output as &#8221;nohtyP tseT&#8221;

<h4># Reverse a list using slicing.</h4>
[1, 3, 5][::-1]
The above command will give the output as [5, 3, 1].


<h2>Play with enumeration.</h2>
With enumerators, it's easy to find an index while you're inside a loop.

testlist = [10, 20, 30]
for i, value in enumerate(testlist):
	print(i, ': ', value)

#1-&gt; 0 : 10
#2-&gt; 1 : 20
#3-&gt; 2 : 30

<h2>Use of enums in Python.</h2>
We can use the following approach to create enum definitions.

class Shapes:
	Circle, Square, Triangle, Quadrangle = range(4)

print(Shapes.Circle)
print(Shapes.Square)
print(Shapes.Triangle)
print(Shapes.Quadrangle)

#1-&gt; 0
#2-&gt; 1
#3-&gt; 2
#4-&gt; 3

<h2>Return multiple values from functions.</h2>
Not many programming languages support this feature. However, functions in Python do return multiple values.

Please refer the below example to see it working.

# function returning multiple values.
def x():
	return 1, 2, 3, 4

# Calling the above function.
a, b, c, d = x()

print(a, b, c, d)

#-&gt; 1 2 3 4

<h2>Unpack function arguments using the splat operator.</h2>
The splat operator offers an artistic way to unpack arguments lists. Please refer the below example for clarity.

def test(x, y, z):
	print(x, y, z)

testDict = {'x': 1, 'y': 2, 'z': 3} 
testList = [10, 20, 30]

test(*testDict)
test(**testDict)
test(*testList)

#1-&gt; x y z
#2-&gt; 1 2 3
#3-&gt; 10 20 30

<h2>Use a dictionary to store a switch.</h2>
We can make a dictionary store expressions.

stdcalc = {
	'sum': lambda x, y: x + y,
	'subtract': lambda x, y: x - y
}

print(stdcalc['sum'](9,3))
print(stdcalc['subtract'](9,3))

#1-&gt; 12
#2-&gt; 6

<h2>Calculate the factorial of any number in one line.</h2>
<h4>Python 2.x.</h4>
result = (lambda k: reduce(int.__mul__, range(1,k+1),1))(3)
print(result)
#-&gt; 6
<h4>Python 3.x.</h4>
import functools
result = (lambda k: functools.reduce(int.__mul__, range(1,k+1),1))(3)
print(result)

#-&gt; 6

<h2>Find the most frequent value in a list.</h2>
test = [1,2,3,4,2,2,3,1,4,4,4]
print(max(set(test), key=test.count))

#-&gt; 4

<h2>Reset recursion limit.</h2>
Python restricts recursion limit to 1000. We can though reset its value.

import sys

x=1001
print(sys.getrecursionlimit())

sys.setrecursionlimit(x)
print(sys.getrecursionlimit())

#1-&gt; 1000
#2-&gt; 1001
Please apply the above trick only if you need it.


<h2>Check the memory usage of an object.</h2>
In Python 2.7, a 32-bit integer consumes 24-bytes whereas it utilizes 28-bytes in Python 3.5. To verify the memory usage, we can call the &lt;getsizeof&gt; method.

<h4>In Python 2.7.</h4>
import sys
x=1
print(sys.getsizeof(x))

#-&gt; 24
<h4>In Python 3.5.</h4>
import sys
x=1
print(sys.getsizeof(x))

#-&gt; 28

<h2>Use __slots__ to reduce memory overheads.</h2>
Have you ever observed your Python application consuming a lot of resources especially memory? Here is one trick which uses &lt;__slots__&gt; class variable to reduce memory overhead to some extent.

import sys
class FileSystem(object):

	def __init__(self, files, folders, devices):
		self.files = files
		self.folders = folders
		self.devices = devices

print(sys.getsizeof( FileSystem ))

class FileSystem1(object):

	__slots__ = ['files', 'folders', 'devices']
	
	def __init__(self, files, folders, devices):
		self.files = files
		self.folders = folders
		self.devices = devices

print(sys.getsizeof( FileSystem1 ))

#In Python 3.5
#1-&gt; 1016
#2-&gt; 888
Clearly, you can see from the results that there are savings in memory usage. But you should use __slots__ when the memory overhead of a class is unnecessarily large. Do it only after profiling the application. Otherwise, you'll make the code difficult to change and with no real benefit.


<h2>Lambda to imitate print function.</h2>
import sys
lprint=lambda *args:sys.stdout.write(" ".join(map(str,args)))
lprint("python", "tips",1000,1001)

#-&gt; python tips 1000 1001

<h2>Create a dictionary from two related sequences.</h2>
t1 = (1, 2, 3)
t2 = (10, 20, 30)

print(dict (zip(t1,t2)))

#-&gt; {1: 10, 2: 20, 3: 30}

<h2>In line search for multiple prefixes in a string.</h2>
print("http://www.google.com".startswith(("http://", "https://")))
print("http://www.google.co.uk".endswith((".com", ".co.uk")))

#1-&gt; True
#2-&gt; True

<h2>Form a unified list without using any loops.</h2>
import itertools
test = [[-1, -2], [30, 40], [25, 35]]
print(list(itertools.chain.from_iterable(test)))

#-&gt; [-1, -2, 30, 40, 25, 35]
If you have an input list with nested lists or tuples as elements, then use the below trick. However, the limitation here is that it's using a for Loop.

def unifylist(l_input, l_target):
    for it in l_input:
        if isinstance(it, list):
            unifylist(it, l_target)
        elif isinstance(it, tuple):
            unifylist(list(it), l_target)
        else:
            l_target.append(it)
    return l_target

test =  [[-1, -2], [1,2,3, [4,(5,[6,7])]], (30, 40), [25, 35]]

print(unifylist(test,[]))

#Output =&gt; [-1, -2, 1, 2, 3, 4, 5, 6, 7, 30, 40, 25, 35]
Another simpler method to unify the list containing lists and tuples is by using the Python's &lt;<strong>more_itertools</strong>&gt; package. It doesn't require looping. Just do a &lt;<strong>pip install more_itertools</strong>&gt;, if not already have it.

import more_itertools

test = [[-1, -2], [1, 2, 3, [4, (5, [6, 7])]], (30, 40), [25, 35]]

print(list(more_itertools.collapse(test)))

#Output=&gt; [-1, -2, 1, 2, 3, 4, 5, 6, 7, 30, 40, 25, 35]
<strong style="font-size: 10pt;"><a href="#toc">TOC</a></strong>

<h2>Implement a true switch-case statement in Python.</h2>
Here is the code that uses a dictionary to imitate a switch-case construct.

def xswitch(x): 
	return xswitch._system_dict.get(x, None) 

xswitch._system_dict = {'files': 10, 'folders': 5, 'devices': 2}

print(xswitch('default'))
print(xswitch('devices'))

#1-&gt; None
#2-&gt; 2

<h2>Summary - Python Tips and Tricks</h2>
We wish the essential Python tips and tricks given above would help you do the tasks quickly & efficiently. And you could use them for your assignments and projects.

Lastly, if you'd enjoyed the post, then please care to share it with friends and on social media.

<h2>Python Tricks</h2>
<pre>

<h2>Different ways to test multiple</h2>
# flags at once in Python
x, y, z = 0, 1, 0

if x == 1 or y == 1 or z == 1:
  print('passed')

if 1 in (x, y, z):
  print('passed')

# These only test for truthiness:
if x or y or z:
  print('passed')

if any((x, y, z)):
  print('passed')


<h2>How to merge two dictionaries</h2>
# in Python 3.5+

x = {'a': 1, 'b': 2}
y = {'b': 3, 'c': 4}
z = {**x, **y}

z
{'c': 4, 'a': 1, 'b': 3}

# In Python 2.x you could
# use this:
z = dict(x, **y)
z
{'a': 1, 'c': 4, 'b': 3}

# In these examples, Python merges dictionary keys
# in the order listed in the expression, overwriting 
# duplicates from left to right.
#
# See: https://www.youtube.com/watch?v=Duexw08KaC8


<h2>How to sort a Python dict by value</h2>
# (== get a representation sorted by value)
<strong>&gt;&gt;&gt; </strong>xs = { 'a' :  4 ,  'b' :  3 ,  'c' :  2 ,  'd' :  1 }
 &gt;&gt;&gt;   sorted (xs . items(), key =  lambda  x: x[ 1 ])
 [('d', 1), ('c', 2), ('b', 3), ('a', 4)] 

 # Or: 

 &gt;&gt;&gt;   import  operator 
 &gt;&gt;&gt;   sorted (xs . items(), key = operator . itemgetter( 1 ))
 [('d', 1), ('c', 2), ('b', 3), ('a', 4)] 



<h2>The get() method on dicts</h2>
# and its "default" argument
name_for_userid = {
382: "Alice",
590: "Bob",
951: "Dilbert",
}

defgreeting(userid):
return"Hi %s!"% name_for_userid.get(userid, "there")

&gt;&gt;&gt; greeting(382)
"Hi Alice!"

&gt;&gt;&gt; greeting(333333)
"Hi there!"

<h2>Using namedtuple is way shorter than</h2>
# defining a class manually:
&gt;&gt;&gt; from collections import namedtuple
&gt;&gt;&gt; Car = namedtuple( 'Car', 'color mileage')
# Our new "Car" class works as expected:&gt;&gt;&gt; my_car = Car( 'red', 3812.4)
&gt;&gt;&gt; my_car .color
'red'
&gt;&gt;&gt; my_car .mileage
3812.4
# We get a nice string repr for free:&gt;&gt;&gt; my_car
Car(color='red' , mileage=3812.4)
# Like tuples, namedtuples are immutable:&gt;&gt;&gt; my_car .color = 'blue'
AttributeError: "can't set attribute"


<h2>The standard string repr for dicts is hard to read: </h2>
&gt;&gt;&gt; my_mapping =  { 'a'  : 23, 'b' : 42, 'c' : 0xc0ffee}
&gt;&gt;&gt; my_mapping

{'b': 42, 'c': 12648430. 'a': 23}  # 😞 

# The "json" module can do a much better job: 
&gt;&gt;&gt; import json
&gt;&gt;&gt; print(json. dumps(my_mapping, indent= 4, sort_keys= True ))
{       "a": 23,
        "b": 42,
        "c": 12648430
} 

# Note this only works with dicts containing 
# primitive types (check out the "pprint" module): 

&gt;&gt;&gt; json. dumps({all : 'yup' })
TypeError: keys must be a string 


<h2>Function argument unpacking</h2>
def myfunc(x, y, z):
  print (x , y , z)

tuple_vec = ( 1, 0, 1)
dict_vec = { 'x': 1, 'y': 0, 'z': 1}

&gt;&gt;&gt; myfunc( *tuple_vec)
1, 0, 1

&gt;&gt;&gt; myfunc( **dict_vec)
1, 0, 1


<h2>time of small bits of Python code</h2>
&gt;&gt;&gt; import  timeit
&gt;&gt;&gt; timeit .timeit('"-".join(str(n) for n in range(100))', number = 10000)
&gt;&gt;&gt; timeit .timeit('"-".join([str(n) for n in range(100)])', number =  10000 )
&gt;&gt;&gt; timeit .timeit('"-".join(map(str, range(100)))', number =  10000 )



<h2>Functions are first-class citizens in Python.</h2>
# They can be passed as arguments to other functions,
# returned as values from other functions, and
# assigned to variables and stored in data structures.

>>> def myfunc(a, b):
...     return a + b
...
>>> funcs = [myfunc]
>>> funcs[0]
<function myfunc at 0x107012230>
>>> funcs[0](2, 3)
5


<h2>Because Python has first-class functions they can</h2>
# be used to emulate switch/case statements

def dispatch_if(operator, x, y):
	if operator == 'add':
		return x + y
	elif operator == 'sub':
		return x - y
	elif operator == 'mul':
		return x * y
	elif operator == 'div':
		return x / y
	else:
		return None


def dispatch_dict(operator, x, y):
	return {
		'add': lambda: x + y,
		'sub': lambda: x - y,
		'mul': lambda: x * y,
		'div': lambda: x / y,
	}.get(operator, lambda: None)()

>>> dispatch_if('mul', 2, 8)
16
>>> dispatch_dict('mul', 2, 8)
16
>>> dispatch_if('unknown', 2, 8)
None
>>> dispatch_dict('unknown', 2, 8)
None


<h2>Python has a HTTP server built into the standard library</h2>

# Python 3.x
$ python3 -m http.server

# Python 2.x
$ python -m SimpleHTTPServer 8000

# (This will serve the current directory at
#  http://localhost:8000)


<h2>Python 3.5+ supports 'type annotations' that can be</h2>
# used with tools like Mypy to write statically typed Python:

def my_add(a: int, b: int) -> int:
    return a + b



<h2>Python's list comprehensions are awesome.</h2>

vals = [expression 
        for value in collection 
        if condition]

# This is equivalent to:
vals = []
for value in collection:
    if condition:
        vals.append(expression)

# Example:
>>> even_squares = [x * x for x in range(10) if not x % 2]
>>> even_squares
[0, 4, 16, 36, 64]



<h2>Because Python has first-class functions they can</h2>
# be used to emulate switch/case statements

def dispatch_if(operator, x, y):
    if operator == 'add':
        return x + y
    elif operator == 'sub':
        return x - y
    elif operator == 'mul':
        return x * y
    elif operator == 'div':
        return x / y
    else:
        return None


def dispatch_dict(operator, x, y):
    return {
        'add': lambda: x + y,
        'sub': lambda: x - y,
        'mul': lambda: x * y,
        'div': lambda: x / y,
    }.get(operator, lambda: None)()


>>> dispatch_if('mul', 2, 8)
16

>>> dispatch_dict('mul', 2, 8)
16

>>> dispatch_if('unknown', 2, 8)
None

>>> dispatch_dict('unknown', 2, 8)
None


<h2>Python Lambda Functions</h2>
<a href="https://www.guru99.com/python-lambda-function.html" class="whitebut ">Python Lambda Functions</a>

Lambdas, also known as anonymous functions, are small, restricted functions which do not need a name (i.e., an identifier). 

Today, many modern programming languages like Java, Python, C#, and C++ support lambda functions to add functionality to the languages.

Syntax and Examples
lambda arguments : expression
lambda p1, p2: expression 

x = lambda a : a + 10
print(x(5))
15

adder = lambda x, y: x + y
print (adder (1, 2))
3

</pre>
<br>

<br>
<br>
<br>
<br>

<script type='text/javascript' src='readbook.js'></script>
