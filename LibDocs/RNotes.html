<base target="_blank"><html><head><title>R Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="../lazyload.min.js"></script>
<script type='text/javascript' src='../mainscript.js'></script>
<script src="D:/Dropbox/Public/commonfunctions.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>

<script>
  var showTopicNumber = true;
  var bookid = "R Notes"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2, h3 {color: gold; display:block;}
strong {color: orange;}
pre{width:100%;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px; background-color:#044;}
</style></head><body onkeypress="chkKey()"><center>
<h1>R Notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a>
<br><br>
<div id="toc"></div></center>
<br><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center><br>
<a href="https://global.rstudio.com/products/rstudio/older-versions/" class="whitebut ">Older Versions of RStudio</a>

<a href="https://bootstrappers.umassmed.edu/bootstrappers-courses/courses/rCourse/Additional_Resources/Updating_R.html" class="whitebut ">Update R</a>

<a href="https://cran.r-project.org/web/packages/available_packages_by_name.html" class="whitebut ">Available CRAN Packages</a>
<a href="https://cran.r-project.org/web/packages/available_packages_by_date.html" class="whitebut ">Available CRAN Packages By Date</a>

<a href="https://www.datacamp.com/community/tutorials/logistic-regression-R" class="whitebut ">logistic regression R</a>
<a href="https://www.datacamp.com/community/tags/data-analysis" class="whitebut ">Data Analysis</a>
<a href="https://www.scribbr.com/statistics/linear-regression-in-r/" class="whitebut ">Linear Regression in R</a>
<a href="https://www.scribbr.com/statistics/multiple-linear-regression/" class="whitebut ">Multiple Linear Regression</a>
<a href="https://www.r-bloggers.com/2015/09/how-to-perform-a-logistic-regression-in-r/" class="whitebut ">Logistic Regression in R</a>
<a href="http://www.sthda.com/english/articles/40-regression-analysis/167-simple-linear-regression-in-r/" class="whitebut ">Regression Analysis</a>
<a href="http://r-statistics.co/Linear-Regression.html" class="whitebut ">Linear Regression</a>
<a href="https://www.tutorialspoint.com/r/r_linear_regression.htm" class="whitebut ">R - Linear Regression</a>

<a href="https://www.r-bloggers.com/2015/09/passing-arguments-to-an-r-script-from-command-lines/" class="whitebut ">R command line arguments</a>
<a href="https://www.statology.org/levenshtein-distance-in-r/" class="whitebut ">Levenshtein Distance</a>

<a href="https://www.jessesadler.com/post/network-analysis-with-r/" class="whitebut ">Network Analysis with R</a>
<a href="https://kateto.net/netscix2016.html" class="whitebut ">Network Analysis and Visualization with R and igraph</a>

<a href="https://rvest.tidyverse.org/reference/html_element.html" class="whitebut ">Select elements from an HTML document</a>

<a href="https://jtr13.github.io/cc19/web-scraping-using-rvest.html" class="whitebut ">web-scraping-using-rvest</a>

<a href="https://dcl-wrangle.stanford.edu/rvest.html" class="whitebut ">data wrangle</a>

<a href="R for Data Science.html" class="redbut gold whitebs">R for Data Science</a>
<a href="https://www.youtube.com/watch?v=OCQU6M4pPiw" class="whitebut ">build R package</a>
<a href="https://www.youtube.com/watch?v=kL6L2MNqPHg" class="whitebut ">use Git and GitHub with R</a>

<a href="http://uc-r.github.io/ann_classification" class="whitebut ">Classification Artificial Neural Network</a>

<br>
<a href="http://adv-r.had.co.nz/Rcpp.html" class="whitebut ">High performance functions with Rcpp</a>

<a href="common R snippets.html" class="whitebut gold limebs">common R snippets</a>
<br>
<a href="https://www.youtube.com/watch?v=EOjObl_GSi4" class="goldbut red whitets bluebs borRad20">larger-than-RAM data manipulation with {disk.frame}</a>

<a href="https://stackoverflow.com/questions/12636764/r-built-in-web-server" class="whitebut ">R built in Web server</a>
<a href="https://github.com/yihui/servr" class="whitebut ">servr</a>
<a href="http://brooksandrew.github.io/simpleblog/articles/advanced-data-table/">Advanced tips and tricks with data.table package</a>


<a href="https://www.youtube.com/watch?v=tfN10IUX9Lo" class="whitebut ">Building Web Application in R Shiny</a>
<a href="https://www.youtube.com/watch?v=aReuLtY0YMI" class="whitebut ">Hadoop In 5 Minutes</a>

<a href="RProgrammingVideos.html" class="redbut gold">R Programming Videos</a>
<a href="RProgrammingMethods.html" class="redbut gold">R Programming Methods</a>

<a href="https://cran.r-project.org/web/packages/" class="whitebut ">Available Packages</a>

<a href="https://www.listendata.com/2016/08/dplyr-tutorial.html" class="whitebut ">DPLYR</a>
<a href="https://www.listendata.com/" class="whitebut ">listendata</a>

data visualization (ggplot2)
data manipulation (dplyr, lubridate, tidyr, stringr, readr, & forcats)
data analysis (combine ggplot2, dplyr to explore data and find insights)
<a href="https://beckmw.wordpress.com/" class="whitebut ">R is my friend</a>
<a href="https://www.youtube.com/user/westlandindia/playlists" class="whitebut ">Dr. Bharatendra Rai</a>
<pre>
<a href="R4DataScience.html" class="whitebut ">R4DataScience</a>

<a href="https://statisticsglobe.com/r-functions-list/" class="whitebut ">R Basic Commands of the</a>

<a href="Non-standard evaluation.html" class="whitebut ">Non-standard evaluation</a>
<a href="https://statisticsglobe.com" class="whitebut ">Statistics Globe</a>
<a href="http://www.datasciencemadesimple.com" class="whitebut ">DataScience Made Simple</a>

<a href="Libraries for Python & R.html">Libraries for Python & R</a>
<a href="sparklyr.html" class="redbut red blueblackgrad">sparklyr</a>

functions on non-tabular data
rlist is a set of tools for working with list objects.
<a href="RList Turorial.html" class="yellowbut gold purpleblackgrad">RList Turorial</a>
<a href="http://joshuamccrain.com/tutorials/web_scraping_R_selenium.html" class="whitebut gold redts">RSelenium Tutorial</a>
<a href="https://github.com/ropensci/RSelenium" class="whitebut gold redts">RSelenium</a>
</pre>

</div>
<pre>
<br>
<br>
<a href="Libraries for Python & R.html">Libraries for Python & R</a>


<h2>study the sample() function</h2>
totalRows = 15

<k>sample(fromPool, ChooseSize, replace=F)</k> # replace=F means cannot repeat, if fromPool is smaller than ChooseSize and cannot repeat, so not enough pool, so make it repeatable to work

e.g.
<k>sample(2, totalRows, replace = TRUE, prob=c(0.9,0.1))

sample(1:totalRows, totalRows/5, replace=F)</k>
11  2  4

<k>sample(1:3, 4, replace=F)</k>
Error: cannot take a sample larger than the population when 'replace = FALSE'

<r>use of sample_frac() function</r>
<k>library(ggplot2)
index1 = sample_frac(diamonds, 0.1)
str(index1)</k>
tibble [5,394 x 10] (S3: tbl_df/tbl/data.frame)

<h2>Introduction to R</h2>
<a href="Introduction to R.html" class="whitebut ">Introduction to R</a>

<h2>free books for R</h2>
<a href="http://www.cookbook-r.com/" target="_blank">Cookbook for R</a>
<a href="RCookbook.html" target="_blank" class="orangesha">&diams;RCookbook</a>
<a href="https://bookdown.org" class="whitebut " target="_blank">bookdown R books</a>
<a href="https://bookdown.org/home/archive/" class="whitebut " target="_blank">bookdown all books</a>
<a href="https://bookdown.org/home/tags/r-programming/" class="whitebut " target="_blank">bookdown r-programming books</a>
<a href="https://bookdown.org/rdpeng/rprogdatascience/" class="whitebut " target="_blank">R Programming for Data Science</a>

<h2>Data Frame</h2>

Data Frame is a list of vectors of equal length

to create a dataframe:
n = c(2,3,5)
s = c('a','b','c')
b = c(TRUE, FALSE, FALSE)
df = data.frame(n,s,b)

Components of dataframe:
header, column names, data row, name of the row cell single square bracket "[]", comma

Functions:
nrow(), ncol(), head()

Inport Data:
read.table("mydata.txt")
read.csv("mydata.csv")

retrieve the column vector by the double square bracket or the "$" operator
mtcars[[9]]
mtcars[["am"]]
mtcars$am
mtcars[,"am"]


retrieve a column slice with the single square bracket "[]"
mtcars[1]
mtcars["mpg"]
mtcars[c("mpg", "hp")]

Data frame Row Slice
mtcars[24,]
mtcars[c(3,24),]
mtcars["camaro z28",]
mtcars[c("datsun 710","camaro z28"),]

<h2># MLFundStat and Hangseng Fund Stat</h2>
#=================
MLFundStat.html
the computation is long, it is possible to cut time by adjusting the cutdate variable.
this should be modified to new version using r chart.

<h2># Start Of R</h2>
#=================
Sys.setlocale(category = 'LC_ALL', 'Chinese')

use the .Rprofile.site file to run R commands for all users when their R session starts.
D:\R-3.5.1\etc\Rprofile.site
See: Initialization at startup.
#c:\R-4.2.1\etc\Rprofile.site
#loadhistory("C:\Users\User\Desktop\.Rhistory")

check environment: Sys.getenv()

This command could be an environment set:
Sys.setenv(FAME="/opt/fame")

<a href="https://www.rdocumentation.org/packages/base/versions/3.5.0/topics/Startup">Start Of R Initialization</a>

set rstudio locale
to check locale: Sys.getlocale()
LC_COLLATE=Chinese (Simplified)_China.936;LC_CTYPE=Chinese (Simplified)_China.936;LC_MONETARY=Chinese (Simplified)_China.936;LC_NUMERIC=C;LC_TIME=Chinese (Simplified)_China.936"

to permanently change to english:
open C:\R-4.0.3 file Rprofile.site
add last line:
Sys.setlocale("LC_ALL","English")


<h2>Startup : Initialization at Start of an R Session</h2>
<h3>Description</h3>
In R, the startup mechanism is as follows.

Unless --no-environ was given on the command line, R searches for site and user files to process for setting environment variables.  
The name of the site file is the one pointed to by the environment variable <code>R_ENVIRON</code>; if this is unset, <code><a href="https://www.rdocumentation.org/link/R_HOME?package=base&version=3.5.0" data-mini-rdoc="base::R_HOME">R_HOME</a>/etc/Renviron.site</code> is used (if it exists, which it does not in a "factory-fresh" installation).  
The name of the user file can be specified by the <code>R_ENVIRON_USER</code> environment variable; if this is unset, the files searched for are <code>.Renviron</code> in the current or in the user's home directory (in that order).  
See "Details" for how the files are read.

Then R searches for the site-wide startup profile file of R code unless the command line option --no-site-file was given.  
The path of this file is taken from the value of the <code>R_PROFILE</code> environment variable (after <a href="https://www.rdocumentation.org/link/tilde%20expansion?package=base&version=3.5.0" data-mini-rdoc="base::tilde expansion">tilde expansion</a>).  
If this variable is unset, the default is <code><a href="https://www.rdocumentation.org/link/R_HOME?package=base&version=3.5.0" data-mini-rdoc="base::R_HOME">R_HOME</a>/etc/Rprofile.site</code>, which is used if it exists (which it does not in a "factory-fresh" installation). (it contains settings from the installer in a "factory-fresh" installation). This code is sourced into the base package.  
Users need to be careful not to unintentionally overwrite objects in base, and it is normally advisable to use <code><a href="https://www.rdocumentation.org/link/local?package=base&version=3.5.0" data-mini-rdoc="base::local">local</a></code> if code needs to be executed: see the examples.

Then, unless --no-init-file was given, R searches for a user profile, a file of R code.  
The path of this file can be specified by the <code>R_PROFILE_USER</code> environment variable (and <a href="https://www.rdocumentation.org/link/tilde%20expansion?package=base&version=3.5.0" data-mini-rdoc="base::tilde expansion">tilde expansion</a> will be performed).  
If this is unset, a file called <code>.Rprofile</code> is searched for in the current directory or in the user's home directory (in that order).  
The user profile file is sourced into the workspace.

Note that when the site and user profile files are sourced only the base package is loaded, so objects in other packages need to be referred to by e.g.<code>utils::dump.frames</code> or after explicitly loading the package concerned.

R then loads a saved image of the user workspace from <code>.RData</code> in the current directory if there is one (unless --no-restore-data or --no-restore was specified on the command line).

Next, if a function <code>.First</code> is found on the search path, it is executed as <code>.First()</code>.  
Finally, function <code>.First.sys()</code> in the base package is run.  
This calls <code><a href="https://www.rdocumentation.org/link/require?package=base&version=3.5.0" data-mini-rdoc="base::require">require</a></code> to attach the default packages specified by <code><a href="https://www.rdocumentation.org/link/options?package=base&version=3.5.0" data-mini-rdoc="base::options">options</a>("defaultPackages")</code>.  
If the methods package is included, this will have been attached earlier (by function <code>.OptRequireMethods()</code>) so that namespace initializations such as those from the user workspace will proceed correctly.

A function <code>.First</code> (and <code><a href="https://www.rdocumentation.org/link/.Last?package=base&version=3.5.0" data-mini-rdoc="base::.Last">.Last</a></code>) can be defined in appropriate <code>.Rprofile</code> or <code>Rprofile.site</code> files or have been saved in <code>.RData</code>.  
If you want a different set of packages than the default ones when you start, insert a call to <code><a href="https://www.rdocumentation.org/link/options?package=base&version=3.5.0" data-mini-rdoc="base::options">options</a></code> in the <code>.Rprofile</code> or <code>Rprofile.site</code> file.  
For example, <code>options(defaultPackages = character())</code> will attach no extra packages on startup (only the base package) (or set <code>R_DEFAULT_PACKAGES=NULL</code> as an environment variable before running R).  
Using <code>options(defaultPackages = "")</code> or <code>R_DEFAULT_PACKAGES=""</code> enforces the R <em>system</em> default.

On front-ends which support it, the commands history is read from the file specified by the environment variable <code>R_HISTFILE</code> (default <code>.Rhistory</code> in the current directory) unless --no-restore-history or --no-restore was specified.

The command-line option --vanilla implies --no-site-file, --no-init-file, --no-environ and (except for <code>R CMD</code>) --no-restore Under Windows, it also implies --no-Rconsole, which prevents loading the <code><a href="https://www.rdocumentation.org/link/Rconsole?package=base&version=3.5.0" data-mini-rdoc="base::Rconsole">Rconsole</a></code> file.
<h3>Arguments</h3><h3>Details</h3>Note that there are two sorts of files used in startup: <em>environment files</em> which contain lists of environment variables to be set, and <em>profile files</em> which contain R code.

Lines in a site or user environment file should be either comment lines starting with <code>#</code>, or lines of the form <code>name=value</code>. The latter sets the environmental variable <code>name</code> to <code>value</code>, overriding an existing value.  
If <code>value</code> contains an expression of the form <code>${foo-bar}</code>, the value is that of the environmental variable <code>foo</code> if that exists and is set to a non-empty value, otherwise <code>bar</code>.  
(If it is of the form <code>${foo}</code>, the default is <code>""</code>.)  This construction can be nested, so <code>bar</code> can be of the same form (as in <code>${foo-${bar-blah}}</code>).  
Note that the braces are essential: for example <code>$HOME</code> will not be interpreted.

Leading and trailing white space in <code>value</code> are stripped. <code>value</code> is then processed in a similar way to a Unix shell: in particular the outermost level of (single or double) quotes is stripped, and backslashes are removed except inside quotes.

On systems with sub-architectures (mainly Windows), the files <code>Renviron.site</code> and <code>Rprofile.site</code> are looked for first in architecture-specific directories, e.g.<code><a href="https://www.rdocumentation.org/link/R_HOME?package=base&version=3.5.0" data-mini-rdoc="base::R_HOME">R_HOME</a>/etc/i386/Renviron.site</code>. And e.g.<code>.Renviron.i386</code> will be used in preference to <code>.Renviron</code>.
<h3>See Also</h3>For the definition of the "home" directory on Windows see the <code>rw-FAQ</code> Q2.14.  
It can be found from a running R by <u>Sys.getenv("R_USER")</u>.

<code><a href="https://www.rdocumentation.org/link/.Last?package=base&version=3.5.0" data-mini-rdoc="base::.Last">.Last</a></code> for final actions at the close of an R session. <code><a href="https://www.rdocumentation.org/link/commandArgs?package=base&version=3.5.0" data-mini-rdoc="base::commandArgs">commandArgs</a></code> for accessing the command line arguments.

There are examples of using startup files to set defaults for graphics devices in the help for <code><a href="https://www.rdocumentation.org/link/windows.options?package=base&version=3.5.0" data-mini-rdoc="base::windows.options">windows.options</a></code>. <code><a href="https://www.rdocumentation.org/link/X11?package=base&version=3.5.0" data-mini-rdoc="base::X11">X11</a></code> and <code><a href="https://www.rdocumentation.org/link/quartz?package=base&version=3.5.0" data-mini-rdoc="base::quartz">quartz</a></code>.

<em>An Introduction to R</em> for more command-line options: those affecting memory management are covered in the help file for <a href="https://www.rdocumentation.org/link/Memory?package=base&version=3.5.0" data-mini-rdoc="base::Memory">Memory</a>.

<code><a href="https://www.rdocumentation.org/link/readRenviron?package=base&version=3.5.0" data-mini-rdoc="base::readRenviron">readRenviron</a></code> to read <code>.Renviron</code> files.

For profiling code, see <code><a href="https://www.rdocumentation.org/link/Rprof?package=base&version=3.5.0" data-mini-rdoc="base::Rprof">Rprof</a></code>.
<h3>Examples</h3>
# NOT RUN {
## Example ~/.Renviron on Unix
R_LIBS=~/R/library
PAGER=/usr/local/bin/less

## Example .Renviron on Windows
R_LIBS=C:/R/library
MY_TCLTK="c:/Program Files/Tcl/bin"

## Example of setting R_DEFAULT_PACKAGES (from R CMD check)
R_DEFAULT_PACKAGES='utils,grDevices,graphics,stats'
# this loads the packages in the order given, so they appear on
# the search path in reverse order.

## Example of .Rprofile
options(width=65, digits=5)
options(show.signif.stars=FALSE)
setHook(packageEvent("grDevices", "onLoad"),       function(...) grDevices::ps.options(horizontal=FALSE))
set.seed(1234)
.First &lt;- function() cat("\n   Welcome to R!\n\n")
.Last &lt;- function()  cat("\n   Goodbye!\n\n")

## Example of Rprofile.site
local({ # add MASS to the default packages, set a CRAN mirror old &lt;- getOption("defaultPackages"); r &lt;- getOption("repos") r["CRAN"] &lt;- "http://my.local.cran" options(defaultPackages = c(old, "MASS"), repos = r) ## (for Unix terminal users) set the width from COLUMNS if set cols &lt;- Sys.getenv("COLUMNS") if(nzchar(cols)) options(width = as.integer(cols)) # interactive sessions get a fortune cookie (needs fortunes package) if (interactive())   fortunes::fortune()
})

## if .Renviron contains
FOOBAR="coo\bar"doh\ex"abc\"def'"

## then we get
# > cat(Sys.getenv("FOOBAR"), "\n")
# coo\bardoh\exabc"def'
# }

<h2># Encoding Problems</h2>
<code>To write text UTF8 encoding on Windows</code>
Firstly, set encoding
options(encoding = "UTF-8")

To write text UTF8 encoding on Windows one has to use the <b class="gold embossts redbs borRad10">useBytes=T</b> options in functions like writeLines or readLines:

txt &lt;- "在"
<code>writeLines(txt, "test.txt", useBytes=T)

readLines("test.txt", encoding="UTF-8")</code>
[1] "在"

<code>writeLines(wholePage, theFilename, useBytes=T)</code>
The UTF-8 BOM is a sequence of bytes at the start of a text stream
(0xEF, 0xBB, 0xBF) that allows the reader to more reliably guess a file as being encoded in UTF-8.

Normally, the BOM is used to signal the endianness of an encoding, but since endianness is irrelevant to UTF-8, the BOM is unnecessary.

According to the Unicode standard, the BOM for UTF-8 files is not recommended

#=================
# Encoding Problems
Sys.getlocale()
getOption("encoding")
options(encoding = "UTF-8")
Encoding(txtstring) &lt;- "UTF-8"
Encoding(txtstring)
txtstring
Sys.setlocale
Sys.setlocale(category = 'LC_ALL', 'Chinese')
Sys.setlocale(category = "LC_ALL", locale = "chs") 
Sys.setlocale(category = "LC_ALL", locale = "cht") # fanti

Note: 
default: options("encoding" = "native.enc")
statTxtFile = "test.txt"
write("建设银行", statTxtFile, append=TRUE)
result file is ansi

add:
options("encoding" = "UTF-8")
write("建设银行", statTxtFile, append=TRUE)
result file is utf-8

mytext &lt;- "this is my text"
Encoding(mytext)

options(encoding = "UTF-8")
getOption("encoding")

options(encoding='native.enc')
getOption("encoding")


iconvlist()
theHeader = "http://qt.gtimg.cn/r=2&q=r_hk"
onecode = "02009"
con = url(paste0(theHeader,onecode), encoding = "GB2312")
thepage=readLines(con)
close(con)
Info=unlist(strsplit(thepage,"~"))
codename=Info[2]
codename
Encoding(codename)

==================
readLines(textConnection("Z\u00FCrich", encoding="UTF-8"), encoding="UTF-8")
readLines(filename, encoding="UTF-8")
readLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE, encoding = "unknown", skipNul = FALSE)

<span class="redword"># note! the chiname encoding is ok inside R, but will be wrong when write to file by local pc locale, to solve the problem, set Sys.setlocale(category = 'LC_ALL', 'Chinese') </span>

readLines(con &lt;- file("Unicode.txt", encoding = "UCS-2LE"))
close(con)
unique(Encoding(A)) # will most likely be UTF-8
==================
guess_encoding(pageHeader)
pageHeader = repair_encoding(pageHeader, from="utf-8")
pageHeader = repair_encoding(pageHeader, "UTF-8")

iconv(pageHeader, to="UTF-8")
Encoding(pageHeader) &lt;- "UTF-8"

Sys.getlocale("LC_ALL")
https://rpubs.com/mauriciocramos/encoding
==================

Read text as UTF-8 encoding

the following reads in encoding twice and works but reasons unknown
readLines(textConnection("Z\u00FCrich", encoding="UTF-8"), encoding="UTF-8")
[1] "Zürich"

==================
the page source claim to be using UTF-8 encoding:
meta http-equiv="Content-Type" content="text/html; charset=utf-8"

So, the question is, are they really using a different enough encoding, 
or can we just convert to utf-8, guessing that any errors will be negligible?

A quick and dirty approach just force utf-8 using iconv:

TV_Audio_Video &lt;- read_html(iconv(page_source[[1]], to = "UTF-8"), encoding = "utf8")

In general, this is a bad idea - better to specify the encoding it's from.
In this case, maybe the error is theirs, so this quick and dirty approach might be ok.


<h2>to remove leading zeros</h2>
substr(t,regexpr("[^0]",t),nchar(t))

<h2>Pop up message in windows 8.1</h2>
use the tcl/tk package in R to create a messageBox. 
Here is a very simple example:

require(tcltk)
tkmessageBox(title = "Title of message box",
                       message = "Hello, world!", icon = "info", type = "ok")

library(tcltk)
tk_messageBox(type='ok',message='I am a tkMessageBox!')

different types of messagebox (yesno, okcancel, etc).
See ?tk_messageBox.


or
use cmd
system('CMD /C "ECHO The R process has finished running && PAUSE"', 

or
use hta

in one line:
mshta "about:&lt;script>alert('Hello, world!');close()&lt;/script>"
or
mshta "javascript:alert('message');close()"
or
mshta.exe vbscript:Execute("msgbox ""message"",0,""title"":close")


mshta "about:&lt;script src='file://%~f0'>&lt;/script>&lt;script>close()&lt;/script>" %*

msg = paste0(
'mshta ',
"\"about:&lt;script>alert('Hello, world!');close()&lt;/script>\""
)

to show web page, use script to create

#=================
Pop up message in windows 8.1
c.bat:  start MessageBox.vbs "This will be shown in a popup."

MessageBox.vbs :
Set objArgs = WScript.Arguments
messageText = objArgs(0)
MsgBox messageText

in fact, save a file named test.vbs with content:
MsgBox "some message"

double click the file will run directly


# options("scipen"=999)
# format(xx, scientific=F)
# options("scipen"=100, "digits"=4)
# getOption("scipen")
# or as.integer(functionResult);

df &lt;- data.frame(matrix(ncol = 10000, nrow = 0))
colnames(df) &lt;- c("a", "b," "c")
rm(list=ls())
Extracting a Single, Simple Table
The first step is to load the ¡§XML¡¨ package, 
then use the htmlParse() function to read the html document into an R object, 
and readHTMLTable() to read the table(s) in the document. 
The length() function indicates there is a single table in the document, simplifying our work.

The plot3d() function in the rgl package
library(rgl)
open3d()
attach(mtcars)
plot3d(disp,wt,mpg, col = rainbow(10))






<h2>library(stringr)</h2>
#============
library(stringr)
library(htmltools)
library(threejs)
data(mtcars)
data &lt;- mtcars[order(mtcars$cyl),]
uv &lt;- tabulate(mtcars$cyl)
col &lt;- c(rep("red",uv[4]),rep("yellow",uv[6]),rep("blue",uv[8]))
row.names(mtcars)
scatterplot3d(data[,c(3,6,1)],
               labels=row.names(mtcars),
               size=mtcars$hp/100,
               flip.y=TRUE,
               color=col,renderer="canvas")

tabulate(bin, nbins = max(1, bin, na.rm = TRUE))
tabulate takes the integer-valued vector bin and counts the number of times each integer occurs in it.

tabulate(c(2,3,3,5), nbins = 10)
[1] 0 1 2 0 1 0 0 0 0 0

table(c(2,3,3,5))
2 3 5 
1 2 1 

tabulate(c(-2,0,2,3,3,5))  # -2 and 0 are ignored
[1] 0 1 2 0 1

tabulate(c(-2,0,2,3,3,5), nbins = 3)
[1] 0 1 2

tabulate(factor(letters[1:10])
[1] 1 1 1 1 1 1 1 1 1 1


<h2><span class="orange">Scatterplot3d: 3D graphics - R software and data visualization</span></h2>
<div id="scattertoc" class="toc">1 <a href="#scattertopic-1" target="_self">Install and load scaterplot3d</a><br>2 <a href="#scattertopic-2" target="_self">Prepare the data</a><br>3 <a href="#scattertopic-3" target="_self">The function scatterplot3d()</a><br>4 <a href="#scattertopic-4" target="_self">Basic 3D scatter plots</a><br>5 <a href="#scattertopic-5" target="_self">Change the main title and axis labels</a><br>6 <a href="#scattertopic-6" target="_self">Change the shape and the color of points</a><br>7 <a href="#scattertopic-7" target="_self">Change point shapes by groups</a><br>8 <a href="#scattertopic-8" target="_self">Change point colors by groups</a><br>9 <a href="#scattertopic-9" target="_self">Change the global appearance of the graph</a><br>10 <a href="#scattertopic-10" target="_self"><span class="orange">Remove the box around the plot</span></a><br>11 <a href="#scattertopic-11" target="_self"><span class="orange">Add grids on scatterplot3d</span></a><br>12 <a href="#scattertopic-12" target="_self">Add bars</a><br>13 <a href="#scattertopic-13" target="_self">Modification of scatterplot3d output</a><br>14 <a href="#scattertopic-14" target="_self"><span class="orange">Add legends</span></a><br>15 <a href="#scattertopic-15" target="_self">Specify the legend position using xyz.convert()</a><br>16 <a href="#scattertopic-16" target="_self">Specify the legend position using keywords</a><br>17 <a href="#scattertopic-17" target="_self">Customize the legend position</a><br>18 <a href="#scattertopic-18" target="_self"><span class="orange">Add point labels</span></a><br>19 <a href="#scattertopic-19" target="_self"><span class="orange">Add regression plane and supplementary points</span></a><br></div></center>
There are many packages in R (<em>RGL</em>, <em>car</em>, <em>lattice</em>, <em>scatterplot3d</em>, …) for creating <k>3D graphics</k>.

This <k>tutorial</k> describes how to generate a scatter pot in the <k>3D space</k> using <k>R software</k> and the package <k>scatterplot3d</k>.

<k>scaterplot3d</k> is very simple to use and it can be easily extended by adding supplementary points or regression planes into an already generated graphic.

It can be easily installed, as it requires only an installed version of R.

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/images/scatterplot3d.gif">

<h3 id="scattertopic-1">Install and load scaterplot3d</h3>
<code>install.packages("scatterplot3d") # Install
library("scatterplot3d") # load</code>

<h3 id="scattertopic-2">Prepare the data</h3>
The <em>iris</em> data set will be used:

<code>data(iris)
head(iris)</code>

<code>  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa</code>

<em>iris</em> data set gives the measurements of the variables sepal length and width, petal length and width, respectively, for 50 flowers from each of 3 species of iris. 
The species are Iris setosa, versicolor, and virginica.

<h3 id="scattertopic-3">The function scatterplot3d()</h3>
A simplified format is:

<code>scatterplot3d(x, y=NULL, z=NULL)</code>

x, y, z are the coordinates of points to be plotted. 
The arguments <em>y</em> and <em>z</em> can be optional depending on the structure of <em>x</em>.

In what cases, <em>y</em> and <em>z</em> are optional variables?

<k>Case 1 : x is a formula</k> of type <em>zvar ~ xvar + yvar</em>. 
xvar, yvar and zvar are used as x, y and z variables

<k>Case 2 : x is a matrix</k> containing at least 3 columns corresponding to x, y and z variables, respectively

<h3 id="scattertopic-4">Basic 3D scatter plots</h3>
<code># Basic 3d graphics
scatterplot3d(iris[,1:3])</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-scatter-plot-3d-r-data-visualization-1.png">

<code># Change the angle of point view
scatterplot3d(iris[,1:3], angle = 55)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-scatter-plot-3d-r-data-visualization-2.png">

<h3 id="scattertopic-5">Change the main title and axis labels</h3>
<code>scatterplot3d(iris[,1:3],
              main="3D Scatter Plot",
              xlab = "Sepal Length (cm)",
              ylab = "Sepal Width (cm)",
              zlab = "Petal Length (cm)")</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-title-1.png">

<h3 id="scattertopic-6">Change the shape and the color of points</h3>
The argument <em>pch</em> and <em>color</em> can be used:

<code>scatterplot3d(iris[,1:3], pch = 16, color="steelblue")</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-scatter-plot-3d-shape-r-data-visualization-1.png">
Read more on the different point shapes available in R : <a href="/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r">Point shapes in R</a>

<h3 id="scattertopic-7">Change point shapes by groups</h3>
<code>shapes = c(16, 17, 18) 
shapes &lt;- shapes[as.numeric(iris$Species)]
scatterplot3d(iris[,1:3], pch = shapes)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-scatter-plot-3d-shape-by-groups-r-data-visualization-1.png">
Read more on the different point shapes available in R : <a href="/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r">Point shapes in R</a>

<h3 id="scattertopic-8">Change point colors by groups</h3>
<code>colors &lt;- c("#999999", "#E69F00", "#56B4E9")
colors &lt;- colors[as.numeric(iris$Species)]
scatterplot3d(iris[,1:3], pch = 16, color=colors)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-scatter-plot-3d-color-by-groups-r-data-visualization-1.png">
Read more about colors in R: <a href="/english/wiki/colors-in-r">colors in R</a>

<h3 id="scattertopic-9">Change the global appearance of the graph</h3>
The arguments below can be used:

<k>grid</k>: a logical value. 
If TRUE, a grid is drawn on the plot.

<k>box</k>: a logical value. 
If TRUE, a box is drawn around the plot

<h3 id="scattertopic-10"><span class="orange">Remove the box around the plot</span></h3>
<code>scatterplot3d(iris[,1:3], pch = 16, color = colors,
              grid=TRUE, box=FALSE)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-remove-box-grid-1.png">
Note that, the argument <k>grid = TRUE</k> plots only the grid on the xy plane. 
In the next section, we’ll see how to add grids on the other facets of the 3D scatter plot.

<h3 id="scattertopic-11"><span class="orange">Add grids on scatterplot3d</span></h3>
This section describes how to add <em>xy-</em>, <em>xz-</em> and <em>yz-</em> to <k>scatterplot3d</k> graphics.

We’ll use a custom function named <k>addgrids3d()</k>. 
The source code is available here : <a href="http://www.sthda.com/sthda/RDoc/functions/addgrids3d.r">addgrids3d.r</a>. 
The function is inspired from the discussion on this <a href="http://stackoverflow.com/questions/20448539/add-yz-and-xz-grid-to-scatterplot3d">forum</a>.

A simplified format of the function is:

<code>addgrids3d(x, y=NULL, z=NULL, grid = TRUE,
           col.grid = "grey", lty.grid=par("lty"))</code>

<br>

<k>x, y, and z</k> are numeric vectors specifying the x, y, z coordinates of points. 
x can be a matrix or a data frame containing 3 columns corresponding to the x, y and z coordinates. 
In this case the arguments y and z are optional

<k>grid</k> specifies the facet(s) of the plot on which grids should be drawn. 
Possible values are the combination of “xy”, “xz” or “yz”. 
Example: grid = c(“xy”, “yz”). 
The default value is TRUE to add grids only on xy facet.

<k>col.grid, lty.grid</k>: the color and the line type to be used for grids

<br>

<k>Add grids on the different factes of scatterplot3d graphics</k>:

<code># 1. 
Source the function
source('http://www.sthda.com/sthda/RDoc/functions/addgrids3d.r')
# 2. 
3D scatter plot
scatterplot3d(iris[, 1:3], pch = 16, grid=FALSE, box=FALSE)
# 3. 
Add grids
addgrids3d(iris[, 1:3], grid = c("xy", "xz", "yz"))</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-add-grids-1.png">
The problem on the above plot is that the grids are drawn over the points.

The <k>R code</k> below, we’ll put the points in the foreground using the following steps:


An empty scatterplot3 graphic is created and the result of <k>scatterplot3d()</k> is assigned to <em>s3d</em>

The function <k>addgrids3d()</k> is used to add grids

Finally, the function <k>s3d$points3d</k> is used to add points on the 3D scatter plot

<code># 1. 
Source the function
source('~/hubiC/Documents/R/function/addgrids3d.r')
# 2. 
Empty 3D scatter plot using pch=""
s3d &lt;- scatterplot3d(iris[, 1:3], pch = "", grid=FALSE, box=FALSE)
# 3. 
Add grids
addgrids3d(iris[, 1:3], grid = c("xy", "xz", "yz"))
# 4. 
Add points
s3d$points3d(iris[, 1:3], pch = 16)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-add-grids2-1.png">
The function <k>points3d()</k> is described in the next sections.

<h3 id="scattertopic-12">Add bars</h3>
The argument <k>type = “h”</k> is used. 
This is useful to see very clearly the x-y location of points.

<code>scatterplot3d(iris[,1:3], pch = 16, type="h", 
              color=colors)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-add-bars-r-data-visualization-1.png">

<h3 id="scattertopic-13">Modification of scatterplot3d output</h3>
<k>scatterplot3d</k> returns a list of function closures which can be used to add elements on a existing plot.

The returned functions are :

<k>xyz.convert()</k>: to convert 3D coordinates to the 2D parallel projection of the existing scatterplot3d. 
It can be used to add arbitrary elements, such as legend, into the plot.

<k>points3d()</k>: to add <em>points</em> or <em>lines</em> into the existing plot

<k>plane3d()</k>: to add a <em>plane</em> into the existing plot

<k>box3d()</k>: to add or refresh a <em>box</em> around the plot

<h3 id="scattertopic-14"><span class="orange">Add legends</span></h3>
<h3 id="scattertopic-15">Specify the legend position using xyz.convert()</h3>
The result of <k>scatterplot3d()</k> is assigned to <em>s3d</em>

The function <k>s3d$xyz.convert()</k> is used to specify the coordinates for legends

the function <k>legend()</k> is used to add legends to plots

<code>s3d &lt;- scatterplot3d(iris[,1:3], pch = 16, color=colors)
legend(s3d$xyz.convert(7.5, 3, 4.5), legend = levels(iris$Species),
      col =  c("#999999", "#E69F00", "#56B4E9"), pch = 16)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-add-legend-r-data-visualization-1.png">
<br>

It’s also possible to specify the <k>position of legends</k> using the following keywords: “bottomright”, “bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right” and “center”.

Read more about <k>legend</k> in R: <a href="/english/wiki/add-legends-to-plots-in-r-software-the-easiest-way">legend in R</a>.

<br>

<h3 id="scattertopic-16">Specify the legend position using keywords</h3>
<code># "right" position
s3d &lt;- scatterplot3d(iris[,1:3], pch = 16, color=colors)
legend("right", legend = levels(iris$Species),
      col =  c("#999999", "#E69F00", "#56B4E9"), pch = 16)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-change-legend-position-right-r-data-visualization-1.png">
<code># Use the argument inset
s3d &lt;- scatterplot3d(iris[,1:3], pch = 16, color=colors)
legend("right", legend = levels(iris$Species),
  col = c("#999999", "#E69F00", "#56B4E9"), pch = 16, inset = 0.1)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-change-legend-position-right-r-data-visualization-2.png">
What means the argument <k>inset</k> in the R code above?

The argument <k>inset</k> is used to inset distance(s) from the margins as a fraction of the plot region when legend is positioned by keyword. 
( see ?legend from R). 
You can play with <em>inset</em> argument using negative or positive values.

<code># "bottom" position
s3d &lt;- scatterplot3d(iris[,1:3], pch = 16, color=colors)
legend("bottom", legend = levels(iris$Species),
      col = c("#999999", "#E69F00", "#56B4E9"), pch = 16)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-change-legend-position-r-data-visualization-1.png">
Using <em>keywords</em> to specify the <em>legend position</em> is very simple. 
However, sometimes, there is an overlap between some points and the legend box or between the axis and legend box.

Is there any solution to avoid this overlap?

Yes, there are several solutions using the combination of the following arguments for the function <k>legend()</k>:

<k>bty = “n”</k> : to <k>remove the box around the legend</k>. 
In this case the background color of the legend becomes transparent and the overlapping points become visible.

<k>bg = “transparent”</k>: to change the background color of the legend box to <em>transparent</em> color (this is only possible when bty != “n”).

<k>inset</k>: to modify the distance(s) between plot margins and the legend box.

<k>horiz</k>: a logical value; if TRUE, set the legend horizontally rather than vertically

<k>xpd</k>: a logical value; if TRUE, it enables the legend items to be drawn outside the plot.

<h3 id="scattertopic-17">Customize the legend position</h3>
<code># Custom point shapes
s3d &lt;- scatterplot3d(iris[,1:3], pch = shapes)
legend("bottom", legend = levels(iris$Species),
       pch = c(16, 17, 18), 
      inset = -0.25, xpd = TRUE, horiz = TRUE)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-custom-legend-position-r-data-visualization-1.png">
<code># Custom colors
s3d &lt;- scatterplot3d(iris[,1:3], pch = 16, color=colors)
legend("bottom", legend = levels(iris$Species),
      col =  c("#999999", "#E69F00", "#56B4E9"), pch = 16, 
      inset = -0.25, xpd = TRUE, horiz = TRUE)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-custom-legend-position-r-data-visualization-2.png">
<code># Custom shapes/colors
s3d &lt;- scatterplot3d(iris[,1:3], pch = shapes, color=colors)
legend("bottom", legend = levels(iris$Species),
      col =  c("#999999", "#E69F00", "#56B4E9"), 
      pch = c(16, 17, 18), 
      inset = -0.25, xpd = TRUE, horiz = TRUE)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-custom-legend-position-r-data-visualization-3.png">
In the R code above, you can play with the arguments <em>inset</em>, <em>xpd</em> and <em>horiz</em> to see the effects on the appearance of the legend box.

<h3 id="scattertopic-18"><span class="orange">Add point labels</span></h3>
The function <k>text()</k> is used as follow:

<code>scatterplot3d(iris[,1:3], pch = 16, color=colors)
text(s3d$xyz.convert(iris[, 1:3]), labels = rownames(iris),
     cex= 0.7, col = "steelblue")</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-text-r-data-visualization-1.png">

<h3 id="scattertopic-19"><span class="orange">Add regression plane and supplementary points</span></h3>
The result of <k>scatterplot3d()</k> is assigned to <em>s3d</em>

A linear model is calculated as follow : lm(zvar ~ xvar + yvar). 
Assumption : zvar depends on xvar and yvar

The function <k>s3d$plane3d()</k> is used to add the regression plane

Supplementary points are added using the function <k>s3d$points3d()</k>

The data sets <em>trees</em> will be used:

<code>data(trees)
head(trees)</code>

<code>  Girth Height Volume
1   8.3     70   10.3
2   8.6     65   10.3
3   8.8     63   10.2
4  10.5     72   16.4
5  10.7     81   18.8
6  10.8     83   19.7</code>

This data set provides measurements of the girth, height and volume for black cherry trees.

<k>3D scatter plot with the regression plane</k>:

<code># 3D scatter plot
s3d &lt;- scatterplot3d(trees, type = "h", color = "blue",
    angle=55, pch = 16)
# Add regression plane
my.lm &lt;- lm(trees$Volume ~ trees$Girth + trees$Height)
s3d$plane3d(my.lm)
# Add supplementary points
s3d$points3d(seq(10, 20, 2), seq(85, 60, -5), seq(60, 10, -10),
    col = "red", type = "h", pch = 8)</code>

<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/3d-graphics/scatterplot3d-regression-plane-1.png" width="480" style="margin-bottom:10px;">



<h2>scatterplot3d(data[,c(3,6,1)],</h2>
<a href="https://www.rdocumentation.org/packages/threejs/versions/0.3.3/topics/scatterplot3d" class="whitebut ">scatterplot3d</a>
<a href="http://www.sthda.com/english/wiki/amazing-interactive-3d-scatter-plots-r-software-and-data-visualization" class="whitebut ">interactive 3d scatterplots</a>
<a href="https://www.rdocumentation.org/packages/threejs/versions/0.3.3/topics/scatterplot3js" class="whitebut ">Interactive 3D Scatterplots</a>
<a href="http://www.sthda.com/english/wiki/a-complete-guide-to-3d-visualization-device-system-in-r-r-software-and-data-visualization" class="whitebut ">complete guide to 3D visualization</a>
<a href="http://www.sthda.com/english/wiki/data-visualization" class="whitebut ">Data Visualization</a>
<a href="http://www.sthda.com/english/wiki/impressive-package-for-3d-and-4d-graph-r-software-and-data-visualization" class="whitebut ">3D and 4D graph</a>
<a href="https://threejsfundamentals.org/threejs/lessons/threejs-fundamentals.html" class="whitebut ">Three.js Fundamentals</a>

#============
scatterplot3d(data[,c(3,6,1)],
               labels=row.names(mtcars),
               size=mtcars$hp/100,
               flip.y=TRUE,
               color=col,renderer="canvas")
# Gumball machine
N &lt;- 100
i &lt;- sample(3, N, replace=TRUE)
x &lt;- matrix(rnorm(N*3),ncol=3)
lab &lt;- c("small", "bigger", "biggest")
scatterplot3d(x, color=rainbow(N), labels=lab[i],
               size=i, renderer="canvas")
# Example 1 from the scatterplot3d package (cf.)
z &lt;- seq(-10, 10, 0.1)
x &lt;- cos(z)
y &lt;- sin(z)
scatterplot3d(x,y,z, color=rainbow(length(z)),
   labels=sprintf("x=%.2f, y=%.2f, z=%.2f", x, y, z))
# Interesting 100,000 point cloud example, should run this with WebGL!
N1 &lt;- 10000
N2 &lt;- 90000
x &lt;- c(rnorm(N1, sd=0.5), rnorm(N2, sd=2))
y &lt;- c(rnorm(N1, sd=0.5), rnorm(N2, sd=2))
z &lt;- c(rnorm(N1, sd=0.5), rpois(N2, lambda=20)-20)
col &lt;- c(rep("#ffff00",N1),rep("#0000ff",N2))
scatterplot3d(x,y,z, color=col, size=0.25)
cat("\014")	CLS Screen
#
match returns a vector of the positions
v1 &lt;- c("a","b","c","d")
v2 &lt;- c("g","x","d","e","f","a","c")
x &lt;- match(v1,v2)
6 NA  7  3
v1 %in% v2
TRUE FALSE  TRUE  TRUE
x &lt;- match(v1,v2,nomatch=-1)
6 -1  7  3
%in% returns a logical vector indicating if there is a match or not






<h2>this check whether an element is inside a group</h2>
#=============
this check whether an element is inside a group
v &lt;- c('a','b','c','e')
'b' %in% v





<h2>check vector includes in 31:37 %in% 0:36</h2>
#=============
31:37 %in% 0:36

if(all(31:36 %in% 0:36)){cat("good")}

#
dmInfo=data.matrix(Info)	# convert dataframe to matrix, but the row and column is exchanged
#
bob &lt;- data.frame(lapply(bob, as.character), stringsAsFactors=FALSE)	#Change numeric to characters
#
write.csv(Info,quote=FALSE, row.names = FALSE)	# write csv is the proper way to write the datafile
#

attach an excel file in R:
1: Install packages XLConnect and foreign and run both libraries
2: abcd &lt;- readWorksheet(loadWorkbook('file extension'),sheet=1)
#
allocate vector of size 1.7 Gb
Try memory.limit() for the current memory limit Use memory.limit (size=50000) to increase memory limit. Try using a cloud based environment, 
try using package slam
use factors 

Concatenate and Split Strings in R
==================================
use the paste() function to concatenate
strsplit() function to split
pangram &lt;- "The quick brown fox jumps over the lazy dog"
strsplit(pangram, " ")
"The"  "quick" "brown" "fox"  "jumps" "over" "the"  "lazy" "dog"

the unique elements
unique() function
unique(tolower(words))
"the"  "quick" "brown" "fox"  "jumps" "over" "lazy" "dog"

# <span class="gold">find duplicates</span>
# the intersect function is used for different set, not in inside a vector
# instead, use the duplicated function will be OK.

words = unlist(strsplit(pangram, " "))
words = tolower(words)
duplicated(words)
words[duplicated(words)]

arr = sample(1:36,6,replace=TRUE)
cat(arr, "\n")
arr[duplicated(arr)]


# test run remove duplicate items from a vector
originalArr = c(1,1,3,4,5,5,6,7,8,8,8,8,9,9)
cat(originalArr, "\n")

# find out duplicates
removeItems = unique(originalArr[duplicated(originalArr)]) # use unique to remove repeated duplicates
cat(removeItems, "\n")

finalArr = originalArr
for(item in removeItems){
  cat("remove this:", item,"  ")
  cat("they are:", which(finalArr == item)," ")
  finalArr = finalArr[-(which(finalArr == item))]
  cat("result vec:", finalArr, "\n")
}

# unique will not remove duplicates
originalArr = unique(originalArr)

# rmItems(fmList, itemList) remove itemList from fmList
  rmItems <- function(fmList, itemList){
        commons = unique(fmList[fmList %in% itemList])
        for(item in commons){fmList = fmList[-(which(fmList == item))]}
        return(fmList)
  }

rmItems(originalArr, removeItems)

# R base functions
duplicated(): for identifying duplicated elements and
unique(): for extracting unique elements,
distinct() [dplyr package] to remove duplicate rows in a data frame.


R split Function
================
split() function divides the data in a vector. 
unsplit() funtion do the reverse.
split(x, f, drop = FALSE, ...)
split(x, f, drop = FALSE, ...) &lt;- value
unsplit(value, f, drop = FALSE)
x: vector, data frame
f: indices
drop: discard non existing levels or not


# R not recognizing Chinese characters
# I have this saved as a script in RStudio:
# this works without problem in windows 8.1
a <- "中文"
cat("这是中文", a)
aaa = readline(prompt="输入汉字：")
cat(aaa)

This seems to be a Windows/UTF-8 encoding problem.
It works if you use eval(parse('test.R', encoding = 'UTF-8')) instead of source().

I try to use read_csv to read my csv file and the source code as follow:

ch4sample <- "D:/Rcode/最近一年內.csv"
ch4sample.exp1 <-read_csv(ch4sample, col_names = TRUE)

Unfortunately, the R console was showing the error message

You might use list.files() function to find out how R names these files, and refer to them that way.

For example
> list.files()
[1] "community_test"          "community-sandbox.Rproj"
[3] "poobär.r"

To source .R file saved using UTF-8 encoding
first of all:
Sys.setlocale(category = 'LC_ALL', 'Chinese')
and then source(filename, encoding = 'UTF-8')

but remember to save output file in utf

<h2>list objects in the working environment</h2>
ls()
data() will give you a list of the datasets of all loaded packages
help(package = "datasets")

show structure of datasets
dataStr = function(package="datasets", ...)
  {
  d = data(package=package, envir=new.env(), ...)$results[,"Item"]
  d = sapply(strsplit(d, split=" ", fixed=TRUE), "[", 1)
  d = d[order(tolower(d))]
  for(x in d){ message(x, ":  ", class(get(x))); message(str(get(x)))}
  }
dataStr()




<h2>x &lt;- read.csv("anova.csv",header=T,sep=",")</h2>
#=============
x &lt;- read.csv("anova.csv",header=T,sep=",")
Subtype,Gender,Expression
A,m,-0.54
A,m,-0.8
Split the "Expression" values into two groups based on "Gender" variable, 
"f" for female group, and 
"m" for male group:
>g &lt;- split(x$Expression, x$Gender)
>g
$f
  [1] -0.66 -1.15 -0.30 -0.40 -0.24 -0.92  0.48 -1.68 -0.80 -0.55 -0.11 -1.26
$m
  [1] -0.54 -0.80 -1.03 -0.41 -1.31 -0.43  1.01  0.14  1.42 -0.16  0.15 -0.62

Calculate the length, mean value of each group:
sapply(g,length)
  f   m 
135 146 
sapply(g,mean)
         f          m 
-0.3946667 -0.2227397

You may use lapply, return is a list:
lapply(g,mean)
unsplit() function combines the groups:
unsplit(g,x$Gender)

<h2><span class="blink red">Apply</span></h2>
=====
m &lt;- matrix(data=cbind(rnorm(30, 0), rnorm(30, 2), rnorm(30, 5)), nrow=30, ncol=3)
apply(m, 1, mean)
a 1 in the second argument, giving the mean of each row. 
apply(m, 2, mean)giving the mean of each column. 
apply(m, 2, function(x) length(x[x&lt;0]))	# count -ve values
apply(m, 2, function(x) is.matrix(x))
apply(m, 2, is.vector)
apply(m, 2, function(x) mean(x[x>0]))

#=========
ma &lt;- matrix(c(1:4, 1, 6:8), nrow = 2)

apply(ma, 1, table)

apply(ma, 1, stats::quantile)
apply(ma, 2, mean)

apply(m, 2, function(x) length(x[x&lt;0]))

sapply lapply rollapply
sapply(1:3, function(x) x^2)

lapply return a list:
lapply(1:3, function(x) x^2)
use unlist with lapply to get a vector

sapply(1:3, function(x, y) mean(y[,x]), y=m)

A&lt;-matrix(1:9, 3,3)
B&lt;-matrix(4:15, 4,3)
C&lt;-matrix(8:10, 3,2)
MyList&lt;-list(A,B,C)
Z=sapply(MyList,"[", 1,1 )

#==========
te=matrix(1:20,nrow=2)
sapply(te,mean)	# this is a vector, order arrange in matrix direction
matrix(sapply(te,mean),nrow=2)	# this is changed to matrix

subset()
apply()
sapply()
lapply()
tapply()
aggregate()
apply 	apply a function to the rows or columns of a matrix
M &lt;- matrix(seq(1,16), 4, 4)
apply(M, 1, min)
lapply 	apply a function to each element of a list in turn and get a list back
x &lt;- list(a = 1, b = 1:3, c = 10:100) 
lapply(x, FUN = length) 
sapply 	apply a function to each element of a list in turn, but you want a vector back
x &lt;- list(a = 1, b = 1:3, c = 10:100)
sapply(x, FUN = length)  
vapply 	squeeze some more speed out of sapply
x &lt;- list(a = 1, b = 1:3, c = 10:100)
vapply(x, FUN = length, FUN.VALUE = 0L) 

mapply 	apply a function to the 1st elements of each, and then the 2nd elements of each, etc., coercing the result to a vector/array as in sapply

Note: 
mApply(X, INDEX, FUN, …, simplify=TRUE, keepmatrix=FALSE)
from Hmisc package

is different from 
mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)


Examples

#Sums the 1st elements, the 2nd elements, etc. 
mapply(sum, 1:5, 1:5, 1:5) 
[1]  3  6  9 12 15

mapply(rep, 1:4, 4:1)
mapply(rep, times = 1:4, x = 4:1)
mapply(rep, times = 1:4, MoreArgs = list(x = 42))
mapply(function(x, y) seq_len(x) + y,
       c(a =  1, b = 2, c = 3),  # names from first
       c(A = 10, B = 0, C = -10))
word &lt;- function(C, k) paste(rep.int(C, k), collapse = "")
utils::str(mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE))

mapply(function(x,y){x^y},x=c(2,3),y=c(3,4))
8 81

values1 &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
values2 &lt;- list(a = c(10, 11, 12), b = c(13, 14, 15), c = c(16, 17, 18)) 
mapply(function(num1, num2) max(c(num1, num2)), values1, values2)
 a  b  c 
12 15 18 



Map 	A wrapper to mapply with SIMPLIFY = FALSE, so it is guaranteed to return a list
rapply	For when you want to apply a function to each element of a nested list structure, recursively
tapply	For when you want to apply a function to subsets of a vector and the subsets are defined by some other vector, usually a factor
lapply is a list apply which acts on a list or vector and returns a list.
sapply is a simple lapply (function defaults to returning a vector or matrix when possible)
vapply is a verified apply (allows the return object type to be prespecified)
rapply is a recursive apply for nested lists, i.e. lists within lists
tapply is a tagged apply where the tags identify the subsets
apply is generic: applies a function to a matrix's rows or columns
by	a "wrapper" for tapply. The power of by arises when we want to compute a task that tapply can't handle
aggregate can be seen as another a different way of use tapply if we use it in such a way


xx = c(1,3,5,7,9,8,6,4,2,1,5)
duplicated(xx)
xx[duplicated(xx)]

Accessing dataframe by names:
mtcars["mpg"]
QueueNo = 12
mtcars[QueueNo,"mpg"]

some functions to remember
charToRaw(key)
as.raw(key)

A motion chart is a dynamic chart to explore several indicators over time. 
subset(airquality, Temp > 80, select = c(Ozone, Temp))
subset(airquality, Day == 1, select = -Temp)
subset(airquality, select = Ozone:Wind) with(airquality, subset(Ozone, Temp > 80))
 ## sometimes requiring a logical 'subset' argument is a nuisance nm &lt;- rownames(state.x77) start_with_M &lt;- nm %in% grep("^M", nm, value = TRUE)
subset(state.x77, start_with_M, Illiteracy:Murder) # but in recent versions of R this can simply be
subset(state.x77, grepl("^M", nm), Illiteracy:Murder)

join 3 dataframes
library("plyr")
join() function
names(gdp)[3] &lt;- "GDP"
names(life_expectancy)[3] = "LifeExpectancy"
names(population)[3] = "Population"
gdp_life_exp &lt;- join(gdp, life_expectancy)
development &lt;- join(gdp_life_exp, population)

subset() function
dev_2005 &lt;- subset(development, Year == 2005)
dev_2005_big &lt;- subset(dev_2005, GDP >= 30000)

development_motion &lt;- subset(development_complete, Country %in% selection)
library(googleVis)
gvisMotionChart() function
motion_graph &lt;- gvisMotionChart(development_motion, idvar = "Country", timevar = "Year")
plot(motion_graph)
motion_graph &lt;- gvisMotionChart(development_motion, idvar = "Country", timevar = "Year", xvar = "GDP", yvar = "LifeExpectancy", sizevar = "Population")
development_motion$logGDP &lt;- log(development_motion$GDP)
motion_graph &lt;- gvisMotionChart(development_motion, idvar = "Country", timevar = "Year", xvar = "logGDP", yvar = "LifeExpectancy", sizevar = "Population")

my_list[[1]] extracts the first element of the list my_list, and my_list[["name"]] extracts the element in my_list that is called name. 
If the list is nested you can travel down the heirarchy by recursive subsetting. 
mylist[[1]][["name"]] is the element called name inside the first element of my_list.
A data frame is just a special kind of list, so you can use double bracket subsetting on data frames too. 
my_df[[1]] will extract the first column of a data frame and my_df[["name"]] will extract the column named name from the data frame.
names() and str() is a great way to explore the structure of a list.

i in 1:ncol(df)
This is a pretty common model for a sequence: a sequence of consecutive integers designed to index over one dimension of our data.
What might surprise you is that this isn't the best way to generate such a sequence, especially when you are using for loops inside your own functions. Let's look at an example where df is an empty data frame:
df &lt;- data.frame()
1:ncol(df)
for (i in 1:ncol(df)) {
  print(median(df[[i]]))
}
Our sequence is now the somewhat non-sensical: 1, 0. You might think you wouldn't be silly enough to use a for loop with an empty data frame, but once you start writing your own functions, there's no telling what the input will be.
A better method is to use the seq_along() function.
if you grow the for loop at each iteration (e.g. using c()), your for loop will be very slow.
A general way of creating an empty vector of given length is the vector() function. 
It has two arguments: the type of the vector ("logical", "integer", "double", "character", etc.) and the length of the vector.
Then, at each iteration of the loop you must store the output in the corresponding entry of the output vector, i.e. assign the result to output[[i]]. (You might ask why we are using double brackets here when output is a vector. It's primarily for generalizability: this subsetting will work whether output is a vector or a list.)

A time series can be thought of as a vector or matrix of numbers, 
along with some information about what times those numbers were recorded. This information is stored in a ts object in R.
read in some time series data from an xlsx file using read_excel(), 
a function from the readxl package, 
and store the data as a ts object.
Use the read_excel() function to read the data from "exercise1.xlsx" into mydata.
mydata &lt;- read_excel("exercise1.xlsx")
Create a ts object called myts using the ts() function. 
myts &lt;- ts(mydata[,2:4], start = c(1981, 1), frequency = 4)

The first step in any data analysis task is to plot the data. 
Graphs enable you to visualize many features of the data, including patterns, unusual observations, changes over time, and relationships between variables. 
The features that you see in the plots must then be incorporated into the forecasting methods that you use. 
Just as the type of data determines which forecasting method to use, it also determines which graphs are appropriate.
You will use the autoplot() function to produce time plots of the data. 
In each plot, look out for outliers, seasonal patterns, and other interesting features.
Use which.max() to spot the outlier in the gold series. 

library("fpp2")
autoplot(a10)
ggseasonplot(a10)
An interesting variant of a season plot uses polar coordinates, where the time axis is circular rather than horizontal. 
ggseasonplot(a10, polar = TRUE)
beer &lt;- window(a10, start=1992)
autoplot(beer)
ggseasonplot(beer)
Use the window() function to consider only the ausbeer data from 1992 and save this to beer. 
Set a keyword start to the appropriate year.

x &lt;- tryCatch( readLines("wx.qq.com/"), warning=function(w){ return(paste( "Warning:", conditionMessage(w)));}, 
error = function(e) { return(paste( "this is Error:", conditionMessage(e)));}, 
finally={print("This is try-catch test. check the output.")});





<h2>x &lt;- c(sort(sample(1:20, 9)), NA)</h2>
#===================
x &lt;- c(sort(sample(1:20, 9)), NA)
y &lt;- c(sort(sample(3:23, 7)), NA)
union(x, y)
intersect(x, y)
setdiff(x, y)
setdiff(y, x)
setequal(x, y)

alist = readLines("alist.txt")
blist = readLines("blist.txt")
out = setdiff(blist, alist)

writeClipboard(out)

use of sample command:
newData = sample[sample$x > 0 & sample$y > 0.4, ]




<h2># To skip 3rd iteration and go to next iteration</h2>
#===================
# To skip 3rd iteration and go to next iteration
for(n in 1:5) {
  if(n==3) next
  cat(n)
}





<h2>googleVis chart</h2>
#===================
googleVis chart
===============
library(googleVis)

Line chart
==========
df=data.frame(country=c("US", "GB", "BR"), 
              val1=c(10,13,14), val2=c(23,12,32))
Line &lt;- gvisLineChart(df)
plot(Line)

Scatter chart
=======================
# example 1
dat &lt;- data.frame(x=c(1,2,3,4,5), y1=c(0,3,7,5,2), y2=c(1,NA,0,3,2))
plot(gvisScatterChart(dat, options=list(lineWidth=2, pointSize=2, width=900, height=600)))

# example 2, women
Scatter &lt;- gvisScatterChart(women, 
               options=list(
                 legend="none", lineWidth=1, pointSize=2,
                 title="Women", vAxis="{title:'weight (lbs)'}",
                 hAxis="{title:'height (in)'}", width=900, height=600)
           )
plot(Scatter)

# example 3
ex3dat &lt;- data.frame(x=c(1,2,3,4,5,6,7,8), y1=c(0,3,7,5,2,0,8,6), y2=c(1,NA,0,3,2,6,4,2))
ex3 &lt;- gvisScatterChart(ex3dat, 
           options=list(
             legend="none", lineWidth=1, pointSize=2,
             title="ex3", vAxis="{title:'weight (lbs)'}",
             hAxis="{title:'height (in)'}", width=900, height=600)
       )
plot(ex3)
# Note: to plot timeline chart, arrange the time in x axis, beginning with -ve and the last is 1 to show the sequence


<h2>cat to a file using file(filename, open = "a")</h2>
cat("TITLE extra line", "2 3 5 7", "11 13 17", file = "data.txt", sep = "\n")

<h3>cat append to a file, open file in "a" mode</h3>
#===================
textVector = c("First thing","Second thing","c")

catObj &lt;- file("theappend.txt", open = "a")
cat(textVector, file = catObj, sep="\n")
close(catObj)






<h2>install.packages("readr")</h2>
#===================
install.packages("readr")
library(readr)

to read rectangular data (like csv, tsv, and fwf)
readr is part of the core tidyverse
library(tidyverse)

readr supports seven file formats with seven read_ functions:

read_csv(): comma separated (CSV) files
read_tsv(): tab separated files
read_delim(): general delimited files
read_fwf(): fixed width files
read_table(): tabular files where columns are separated by white-space.
read_log(): web log files





<h2>iconv(keyword, "unknown", "GB2312")</h2>
#===================
iconv(keyword, "unknown", "GB2312")






<h2>Grabbing HTML Tags</h2>
#==========
Grabbing HTML Tags

\b[^>]*>(.*?) matches the opening and closing pair of a specific HTML tag. 

Anything between the tags is captured into the first backreference. 
The question mark in the regex makes the star lazy, to make sure it stops before the first closing tag rather than before the last, like a greedy star would do. 
This regex will not properly match tags nested inside themselves, like in one two one.

<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)</\1> will match the opening and closing pair of any HTML tag. 
Be sure to turn off case sensitivity. 
The key in this solution is the use of the backreference \1 in the regex. 
Anything between the tags is captured into the second backreference. 
This solution will also not match tags nested in themselves






<h2>find the new item</h2>
#==========
find the new item

theList = c("00700","02318","02007")
newList=c("03333","01398","02007")

newList[!(newList %in% theList)]





<h2>formating numbers</h2>
#==========
formating numbers
a &lt;- seq(1,101,25)
sprintf("%03d", a)

format(round(a, 2), nsmall = 2)





<h2>the match function:</h2>
#==========
the match function:
match(x, table, nomatch = NA_integer_, incomparables = NULL)
%in%
match returns a vector of the positions of (first) matches of its first argument in its second.

Corpus&lt;- c('animalada', 'fe', 'fernandez', 'ladrillo')
Lexicon&lt;- c('animal', 'animalada', 'fe', 'fernandez', 'ladr', 'ladrillo')
Lexicon %in% Corpus

Lexicon[Lexicon %in% Corpus]





<h2>Machine Learning:</h2>

<a href="https://www.youtube.com/watch?v=atiYXm7JZv0" class="redbut white bluebs">Machine Learning with R and TensorFlow</a>

<a href="https://machinelearningmastery.com/machine-learning-in-r-step-by-step/">machine-learning-in-r-step-by-step</a>
<a href="https://lgatto.github.io/IntroMachineLearningWithR/index.html">An Introduction to Machine Learning with R</a>
<a href="https://www.r-bloggers.com/image-recognition-tutorial-in-r-using-deep-convolutional-neural-networks-mxnet-package/">mxnet</a>
<a href="https://blogs.rstudio.com/tensorflow/posts/2017-12-14-image-classification-on-small-datasets/">image classification</a>
<a href="https://www.youtube.com/watch?v=iExh0qj2Ouo" class="whitebut ">Image Recognition & Classification with Keras</a>

#==========
Machine Learning:

The caret package

Caret contains wrapper functions that allow you to use the exact same functions for training and predicting with dozens of different algorithms. On top of that, it includes sophisticated built-in methods for evaluating the effectiveness of the predictions you get from the model. 

Use The Titanic dataset

Training a model
training a bunch of different decision trees and having them vote 
Random forests work pretty well in *lots* of different situations, so I often try them first.

Evaluating the model

Cross-validation is a way to evaluate the performance of a model without needing any other data than the training data. 

Making predictions on the test set

Improving the model







<h2>to handle error 404 when scraping: use tryCatch()</h2>
#==========
to handle error 404 when scraping: use tryCatch()

for (i in urls) {
    tmp &lt;- tryCatch(readLines(url(i), warn=F), error = function (e) NULL)
    if (is.null(tmp)) {
        next() # skip to the next url.
    }
}
#==========
try(readLines(url), silent = TRUE)

tryCatch(readLines(url), error = function (e) conditionMessage(e))






<h2>write.table</h2>
write.table(matrixname, file = "outputname", append = FALSE, quote = FALSE, sep = "\t",
#==========
write.table(matrixname, file = "outputname", append = FALSE, quote = FALSE, sep = "\t",
            eol = "\n", na = "NA", dec = ".", row.names = FALSE,
            col.names = FALSE, qmethod = c("escape", "double"),
            fileEncoding = "")

write.table(finalTableList, theOutputname, row.names=FALSE, col.names=FALSE, quote = FALSE, sep = "\t" )






<h2>Four normal distribution functions:</h2>
#==========
Four normal distribution functions:

<a href="https://www.r-bloggers.com/normal-distribution-functions/">Four normal distribution functions:</a>

RNORM	Generates random numbers from normal distribution	
rnorm(n, mean, sd)
rnorm(1000, 3, .25)	Generates 1000 numbers from a normal with mean 3 and sd=.25

DNORM	Probability Density Function(PDF)
dnorm(x, mean, sd)
dnorm(0, 0, .5)	Gives the density (height of the PDF) of the normal with mean=0 and sd=.5. 

	
dnorm returns the value of the normal distribution given parameters for x, μ, and σ.
# x = 0, mu = 0 and sigma = 0

dnorm(0, mean = 0, sd = 1)
dnorm(1, mean = 1.2, sd = 0.5)  # result: 0.7365403

change x to dataset
dataset = seq(-3, 3, by = .1)
dvalues = dnorm(dataset)
plot(dvalues,      # y = values and x = index
     xaxt = "n",   # Don't label the x-axis
     type = "l",   # Make it a line plot
     main = "pdf of the Standard Normal",
     xlab= "Data Set") 

compare the data with dnorm:
dataset = c( 5, 1,2,5,3,5,6,4,7,4,5,4,8,6,3,3,6,5,4,3,4,3,4,3)
plot(dvalues,      # y = values and x = index
     xaxt = "n",   # Don't label the x-axis
     type = "l",   # Make it a line plot
     main = "pdf of the Standard Normal",
     xlab= "Data Set") 

to create a dnorm of a dataset to compare with current dataset
make a cut index
cutindex = seq(min(dataset),max(dataset),length = 10)
yfit = dnorm(cutindex, mean=mean(dataset), sd=sd(dataset))
lines(cutindex, yfit)


# Kernel Density Plot
d = density(mtcars$mpg) # returns the density data
plot(d) # plots the results

# Filled Density Plot
d = density(mtcars$mpg)
plot(d, main="Kernel Density of Miles Per Gallon")
polygon(d, col="red", border="blue")

Kernel density estimation is a technique that let's you create a smooth curve given a set of data.

PNORM	Cumulative Distribution Function
(CDF)	pnorm(q, mean, sd)
pnorm(1.96, 0, 1)	Gives the area under the standard normal curve to the left of 1.96, i.e. ~0.975

QNORM	Quantile Function – inverse of
pnorm	qnorm(p, mean, sd)
qnorm(0.975, 0, 1)	Gives the value at which the CDF of the standard normal is .975, i.e. ~1.96

Note that for all functions, leaving out the mean and standard deviation would result in default values of mean=0 and sd=1, a standard normal distribution.






<h2>pnorm students scoring higher than 84</h2>
#==========
pnorm students scoring higher than 84
> pnorm(84, mean=72, sd=15.2, lower.tail=FALSE) 
[1] 0.21492
Answer
The percentage of students scoring 84 or more in the college entrance exam is 21.5%.






<h2>plot a histogram of 1000</h2>
draws from a normal distribution with mean 10, standard deviation 2.
#==========
plot a histogram of 1000 draws from a normal distribution with mean 10, standard deviation 2.
set.seed(seed)
x = rnorm(1000, 10, 2)
plot(x)
hist(x)

Using a QQ plot. Assess the normality:
qqnorm(x)
qqline(x)

In statistics, a Q–Q (quantile-quantile) plot is a probability plot, 
which is a graphical method for comparing two probability distributions by plotting their quantiles against each other.
First, the set of intervals for the quantiles is chosen. 
A point (x, y) on the plot corresponds to one of the quantiles of the second distribution (y-coordinate) plotted against the same quantile of the first distribution (x-coordinate). 
Thus the line is a parametric curve with the parameter which is the number of the interval for the quantile.






<h2>format leading zeros</h2>
#==========
format leading zeros

formatC(1, width = 2, format = "d", flag = "0")
"01"
formatC(125, width = 5, format = "d", flag = "0")
"00125"






<h2>library(pdftools)</h2>
#==========
setwd("C:/Users/User/Desktop")
library(pdftools)
txt &lt;- pdf_text("a.pdf")
str(txt)	# 361 pages
writeClipboard(txt[1])

Sys.setlocale(category = 'LC_ALL', 'Chinese')
options("encoding" = "UTF-8")
sink("war.txt")
  for(i in txt){ cat(i, sep="\n")}
sink()
shell("war.txt")

txt1 = gsub(".*ORIGINATOR", "", txt)
txt1 = gsub("          ", "", txt1)

list = c(13:16, 19:22, 25:28, 31:34, 37:42, 45:48, 52:58, 62:68, 71:75, 78:85, 88:95, 98:105, 108:115, 118:124, 127:133, 136:142, 145:156, 159:169, 173:202, 206:221, 225:240, 244:258, 261:274, 277:290, 294:298, 302:308, 312:318, 323:331, 334:345, 348:359)

txt1 = txt1[list]

writeClipboard(txt1)

pdf_info("a.pdf")
pdf_text("a.pdf")
pdf_fonts("a.pdf")
pdf_attachments("a.pdf")
pdf_toc("a.pdf")

toc = pdf_toc("a.pdf")
sink("test.txt")
print(toc)
sink()


#==========
library(pdftools)
txt &lt;- pdf_text("a.pdf")
str(txt)
txtList = unlist(strsplit(txt, "\\s{2,}"))

writeClipboard(txtList)
<a href="https://cran.r-project.org/web/packages/pdftools/pdftools.pdf" class="whitebut ">pdftools.pdf</a>

pdftools Usage
pdf_text(pdf)

<h2>pdfimages</h2>
https://stackoverflow.com/questions/47133072/how-to-extract-images-from-a-scanned-pdf

http://www.xpdfreader.com/pdfimages-man.html
http://www.xpdfreader.com/download.html

https://rdrr.io/cran/metagear/src/R/PDF_extractImages.R

pdfimages a.pdf -j

Quote a string to be passed to an operating system shell.
Usage:
shQuote(string, type = c("sh", "csh", "cmd", "cmd2"))

  #("PDF to PPM")      
      files <- list.files(path = dest, pattern = 
 "pdf", full.names = TRUE)
    lapply(files, function(i){
      shell(shQuote(paste0("pdftoppm -f 1 -l 10 -r 300 ", i,".pdf", " ",i)))
      })

You could also just use the CMD prompt and type
pdftoppm -f 1 -l 10 -r 300 stuff.pdf stuff.ppm


<h2>OCR Extract Text from Images</h2>
<a href="https://github.com/UB-Mannheim/tesseract/wiki" class="whitebut ">download</a>
Using the Tesseract OCR engine in R
library(tesseract)
i = "https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Chineselanguage.svg/1200px-Chineselanguage.svg.png"
chi <- tesseract("chi_sim")
text <- ocr(i, engine = chi)
cat(text) # In love

# text <- ocr(i) # for english, default engine

library(tesseract)
eng <- tesseract("eng")
text <- tesseract::ocr("http://jeroen.github.io/images/testocr.png", engine = eng)
cat(text)
results <- tesseract::ocr_data("http://jeroen.github.io/images/testocr.png", engine = eng)

# list the languages have installed.
tesseract_info()
$datapath
[1] "/Users/jeroen/Library/Application Support/tesseract4/tessdata/"

$available
[1] "chi_sim" "eng"     "osd"    

chinese character recognition using Tesseract OCR
download chinese trained data (it will be a file like chi_sim.traineddata) and add it to your tessdata folder.

C:/Users/User/AppData/Local/tesseract4/tesseract4/tessdata/

To download the file https://github.com/tesseract-ocr/tessdata/raw/master/chi_sim.traineddata


library(tesseract)
chi <- tesseract("chi_sim")

datapath = "C:/Users/User/Desktop/testReact/"
setwd(datapath)
shell(shQuote("D:/XpdfReader-win64/xpdf-tools-win-4.03/bin64/pdfimages a.pdf -j"))

allFiles <- list.files(path = datapath, pattern = 
 "jpg", full.names = TRUE)

allText = character()
# for(i in allFiles){
for(file in 1:5){
    i = allFiles[file]
    cat(i, "\n")
    text <- tesseract::ocr(i, engine = chi)
    allText = c(allText, text)
}

setwd(datapath)

Sys.setlocale(category = 'LC_ALL', 'Chinese')

options("encoding" = "UTF-8")

sink("result.txt")
  cat(allText, sep="\n")
sink()

options("encoding" = "native.enc")
thepage = readLines("result.txt", encoding="UTF-8")
thepage = gsub(" ","", thepage)

sink("resultNew.txt")
  cat(thepage, sep="\n")
sink()

thepage = readLines("resultNew.txt", encoding="UTF-8")
thepage = gsub("。","。\n", thepage)
sink("resultNew.txt")
  cat(thepage, sep="\n")
sink()

<a href="https://b98606021.medium.com/實用心得-tesseract-ocr-eef4fcd425f0" class="whitebut ">Tesseract-OCR 實用心得</a>

<a href="https://www.glyphandcog.com/support/q0005.html" class="whitebut ">Xpdf language support packages with XpdfViewer, XpdfPrint, XpdfText</a>
First, download whichever language support package(s) you need and unpack them.
You can unpack them anywhere you like – in step 3, you'll set up the config file with the path to wherever you unpacked them.

Create an xpdfrc configuration file (if you haven't done this already).

All of the Glyph & Cog tools read an (optional) configuration file with various global settings. To use this config file with the Windows DLLs and COM components, simply create a text file called "xpdfrc" in the same directory as the DLL, COM component, or ActiveX control. This must be a plain text file (not Word or RTF) with no file name extension (correct: xpdfrc; incorrect: xpdfrc.txt).

Documentation on the configuration settings, i.e., available commands for the xpdfrc file, can be found in the documentation for the DLL or COM component.

Each language support package comes with a file called "add-to-xpdfrc". You need to insert the contents of that file into your own xpdfrc file (created in step 2). This information includes pointers to the various files installed when you unpacked the language support package – make sure you modify these paths to match your install directory.

The GPG/PGP key used to sign the packages is available <a href="http://www.xpdfreader.com/gpg-key.txt" class="whitebut ">here</a>, or from the PGP keyservers (search for xpdf@xpdfreader.com).


https://cran.r-project.org/web/packages/tesseract/vignettes/intro.html

tesseract_info() to show environment

remember to copy the train data to:
C:/Users/william/AppData/Local/tesseract4/tesseract4/tessdata/

<a href="https://ropensci.org/blog/2016/11/16/tesseract/" class="whitebut ">High Quality OCR in R</a>
<a href="https://cran.r-project.org/web/packages/tesseract/vignettes/intro.html" class="whitebut ">Using the Tesseract OCR engine in R</a>
<a href="https://b98606021.medium.com/%E5%AF%A6%E7%94%A8%E5%BF%83%E5%BE%97-tesseract-ocr-eef4fcd425f0" class="whitebut ">實用心得 Tesseract-OCR</a>

<h2>train tessdata library</h2>
<a href="https://tesseract-ocr.github.io/tessdoc/TrainingTesseract-4.00.html#creating-training-data" class="whitebut ">creating training data</a>
<a href="https://pretius.com/how-to-prepare-training-files-for-tesseract-ocr-and-improve-characters-recognition/" class="whitebut ">improve characters recognition</a>
<a href="https://github.com/tesseract-ocr/tessdata" class="whitebut ">lots of tessdata traindata</a>
<a href="https://github.com/tesseract-ocr/langdata" class="whitebut ">tessdata langdata</a>
<a href="https://tesseract-ocr.github.io/tessdoc/Data-Files.html" class="whitebut ">Traineddata Files</a>

Tesseract ocr train tessdata library on batch with lots of single character image

If they are of same font, put them in a multi-page TIFF and conduct training on it.
jTessBoxEditor can help you with the TIFF merging and box editing.
<a href="http://vietocr.sourceforge.net/training.html" class="whitebut ">jTessBoxEditor</a>

Here is a summary:
3. The more data, the better the OCR result, so repeat (1) and (2) until you have at least 4 pages. Limit is 32
4. Execute tesseract command to obtain the box files
5. Edit the box file using the bbTesseract editing tool
6. Execute tesseract command to generate the data files (clustering)
7. Rename files with "vie." prefix and copy the files to tessdata directory, overriding the existing data
8. Run OCR on the original images to validate your work. The accuracy rate should be in the high 90%
So that the community can benefit from your work, please submit your data files. They will be posted in the VietOCR's Download page. Be sure to indicate the names of the fonts that you have trained for, so users can know which data set they should load into tessdata directory when OCRing their document.

<a href="https://www.endpoint.com/blog/2018/07/09/training-tesseract-models-from-scratch" class="whitebut ">training tesseract models from scratch</a>

<h2>tesseract extra spaces in result when ocr chinese</h2>
# workaround to remove extra spaces in OCR result
# https://github.com/tesseract-ocr/tesseract/issues/991, 988 and 1009

This fix can be applied via adding the following to the config file and then running combine_tessdata.

preserve_interword_spaces 1

SetVariable("preserve_interword_spaces", false);

these files need to be fixed:
tessdata/chi_sim/chi_sim.config
tessdata/chi_tra/chi_tra.config
tessdata/jpn/jpn.config
tessdata/tha/tha.config
tessdata_best/chi_sim/chi_sim.config
tessdata_best/chi_tra/chi_tra.config
tessdata_best/jpn/jpn.config
tessdata_best/tha/tha.config

fixed tessdata_best/jpn_vert/jpn_vert.config which is included by tessdata_best/jpn/jpn.config

<h2>The name of the site environment variable R_ENVIRON</h2>
#==========
The name of the site environment variable R_ENVIRON
"R_HOME/etc/Renviron.site"

the default is "R_HOME/etc/Rprofile.site"

<u>Sys.getenv("R_USER")</u>

Examples

## Example ~/.Renviron on Unix
R_LIBS=~/R/library
PAGER=/usr/local/bin/less

## Example .Renviron on Windows
R_LIBS=C:/R/library
MY_TCLTK="c:/Program Files/Tcl/bin"

## Example of setting R_DEFAULT_PACKAGES (from R CMD check)
R_DEFAULT_PACKAGES='utils,grDevices,graphics,stats'
# this loads the packages in the order given, 
so they appear on
# the search path in reverse order.

## Example of .Rprofile
options(width=65, 
digits=5)
options(show.signif.stars=FALSE)
setHook(packageEvent("grDevices", 
"onLoad"),
        function(...) grDevices::ps.options(horizontal=FALSE))
set.seed(1234)
.First &lt;- function() cat("\n   Welcome to R!\n\n")
.Last &lt;- function()  cat("\n   Goodbye!\n\n")

## Example of Rprofile.site
local({
  # add MASS to the default packages, 
set a CRAN mirror
  old &lt;- getOption("defaultPackages"); r &lt;- getOption("repos")
  r["CRAN"] &lt;- "http://my.local.cran"
  options(defaultPackages = c(old, 
"MASS"), 
repos = r)
  ## (for Unix terminal users) set the width from COLUMNS if set
  cols &lt;- Sys.getenv("COLUMNS")
  if(nzchar(cols)) options(width = as.integer(cols))
  # interactive sessions get a fortune cookie (needs fortunes package)
  if (interactive())
    fortunes::fortune()
})

## if .Renviron contains
FOOBAR="coo\bar"doh\ex"abc\"def'"

## then we get
# > cat(Sys.getenv("FOOBAR"), 
"\n")
# coo\bardoh\exabc"def'







<h2>How to Convert Factor into Numerical?</h2>
#==========
How to Convert Factor into Numerical?

When you convert factors to numeric, 
first you should convert it into characters and then convert into numeric. 
as.numeric(as.character(X))

Df$column&lt;-as.numeric(as.factor(df$column)

as.integer(as.factor(region))





<h2>options(error=recover)</h2>
#==========
options(error=recover)

recover {utils}
Browsing after an Error

This function allows the user to browse directly on any of the currently active function calls, and is suitable as an error option.
The expression options(error = recover) will make this the error option.

Usage
recover()

When called, recover prints the list of current calls, and prompts the user to select one of them.
The standard R browser is then invoked from the corresponding environment;
the user can type ordinary R language expressions to be evaluated in that environment.

Turning off the options() debugging mode in R
options(error=NULL)





<h2>Extract hyperlink from Excel file in R</h2>

#==========

library(XML)

# rename file to .zip
my.zip.file &lt;- sub("xlsx", "zip", my.excel.file)
file.copy(from = my.excel.file, to = my.zip.file)

# unzip the file
unzip(my.zip.file)

# unzipping produces a bunch of files which we can read using the XML package
# assume sheet1 has our data
xml &lt;- xmlParse("xl/worksheets/sheet1.xml")

# finally grab the hyperlinks
hyperlinks &lt;- xpathApply(xml, "//x:hyperlink/@display", namespaces="x")


<span class="redword">To repair Hyperlink address corrupted:</span>
copy file to desk top and rename to zip file
open zip file and locate: <span class="redword">\xl\worksheets\_rels</span>
open the sheet1.xml.rels with editor
remove all text: D:\Users\Lawht\AppData\Roaming\Microsoft\Excel\




<h2>Extract part of a string</h2>

#==========
x &lt;- c("75 to 79", "80 to 84", "85 to 89")
substr(x, start = 1, stop = 2)

substr(x, start, stop)
x &lt;- "1234567890"
substr(x, 5, 7)
"567"

<h2>alter grades</h2>

#==========
alter grades

locate the word
get the line location
alter the score table
#==========

locate the word
v &lt;- c('a','b','c','e')
'b' %in% v ## returns TRUE
match('b',v) ## returns the first location of 'b', in this case: 2

subv &lt;- c('a', 'f')
subv %in% v ## returns a vector TRUE FALSE
is.element(subv, v) ## returns a vector TRUE FALSE

which()
which('a' == v) #[1] 2 4 For finding all occurances as vector of indices

grep() returns a vector of integers, which indicate where matches are.
yo &lt;- c("a", "a", "b", "b", "c", "c")
grep("b", yo) # [1] 3 4

ROC&lt;-"中華民國 – 維基百科，自由的百科全書"
grep("中華民國",ROC)

Partial String Matching
pmatch("med", c("mean", "median", "mode")) # returns 2

<h2>table, cut and barplot</h2>

atab=c(1,2,3,2,1,2,3,4,5,4)
table(atab)
<k>atab
1 2 3 4 5 
2 3 2 2 1 </k>

cut(atab, 2)
table( cut(atab, 2))
counts = table( cut(atab, 4))
barplot(counts, main="Qty", xlab="grade")

Note:
testgroup_A = c('@','#','$','#','@')
testgroup_B = c('#','$','*','~','*')
table(testgroup_A, testgroup_B)
<k>           testgroup_B
testgroup_A # $ * ~
          # 0 1 0 1
          $ 0 0 1 0
          @ 1 0 1 0</k>

testgroup_A = c('baby','boy','girl','boy','baby')
testgroup_B = c('boy','girl','baby','baby','baby')
table(testgroup_A, testgroup_B)
<k>           testgroup_B
testgroup_A baby boy girl
       baby    1   1    0
       boy     1   0    1
       girl    1   0    0</k>
This is to compare freq of two groups

<h2>non-paste answer to concatenate two strings</h2>

capture.output(cat(counts, sep = ","))


<h2>V8 is an R interface JavaScript engine. </h2>

This package helps us execute javascript code in R

#Loading both the required libraries
library(rvest)
library(V8)

#URL with js-rendered content to be scraped
link &lt;- 'https://food.list.co.uk/place/22191-brewhemia-edinburgh/'

#Read the html page content and extract all javascript codes that are inside a list

emailjs &lt;- read_html(link) %>% html_nodes('li') %>% html_nodes('script') %>% html_text()

# Create a new v8 context
ct &lt;- v8()

#parse the html content from the js output and print it as text
read_html(ct$eval(gsub('document.write','',emailjs))) %>%  html_text()

info@brewhemia.co.uk

Thus we have used rvest to extract the javascript code snippet from the desired location (that is coded in place of email ID) and used V8 to execute the javascript snippet (with slight code formatting) and output the actual email (that is hidden behind the javascript code). 

####################
Getting email address through rvest
You need a javascript engine here to process the js code.
R has got V8.

Modify your code after installing V8 package:
library(rvest)
library(V8)

link &lt;- 'https://food.list.co.uk/place/22191-brewhemia-edinburgh/'
page &lt;- read_html(link)
name_html &lt;- html_nodes(page,'.placeHeading')
business_adr &lt;- html_text(adr_html)
tel_html &lt;- html_nodes(page,'.value')
business_tel &lt;- html_text(tel_html)
emailjs &lt;- page %>% html_nodes('li') %>% html_nodes('script') %>% html_text()
ct &lt;- v8()
read_html(ct$eval(gsub('document.write','',emailjs))) %>% html_text()

<h2>extract protected pdf document</h2>

library(pdftools)
setwd("C:/Users/User/Desktop")
txt &lt;- pdf_text("a.pdf")
str(txt)	# 361 pages
# copy page 1
writeClipboard(txt[1])
# copy page 2
writeClipboard(txt[2])
# copy page 3
writeClipboard(txt[3])

Convert unicode character to string format: remove "\u"

theStr = "\u9999\u6e2f\u98df\u54c1\u6295\u8d44"	#  "香港食品投资"

=============================

Sys.setlocale(category = 'LC_ALL', 'Chinese')

library(pdftools)
setwd("C:/Users/User/Desktop")
txt &lt;- pdf_text("45.pdf")
str(txt)

chi1 = gsub('\\u' , '&#x', txt[1])
chi2 = gsub('\\u' , '&#x', txt[2])
chi3 = gsub('\\u' , '&#x', txt[3])
sink("aaa.txt")
cat(chi1)
cat(chi2)
cat(chi3)
sink()

<h2>Writing an R package</h2>

  <a href="https://support.rstudio.com/hc/en-us/articles/200486488-Developing-Packages-with-RStudio">Develop Packages with RStudio</a>

<a href="http://web.mit.edu/insong/www/pdf/rpackage_instructions.pdf">rpackage_instructions.pdf</a>

<a href="https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/">Writing an R package from scratch</a>
<a href="Writing an R package.html"><span class="goldb">Writing an R package</span></a> 

<h2>table, cut and breaks</h2>

table(cut(as.numeric(resultTable[,3]), 10))
cut(as.numeric(resultTable[,3]),10)
breaks = c(seq(lower, 0, by = 5), 0, seq(0, upper, by = 5))

tableA = c(1,3,5,7,9)
tableB = c(1,3,5,7,2,4,6,8)
tableA = c(tableA, tableB)
tableA = sort(tableA)

table(tableA)

table(cut(tableA, 3))

breaks = c(seq(1, 3, by = 1), 4, seq(5, 9, by = 2))
table(cut(tableA, breaks))

<h2>List the Files in a Directory</h2>

List the Files in a Directory/Folder
list.files()

list.dirs(R.home("doc"))
list.dirs()

<h2>test url exist</h2>

library(httr)
http_error(theUrl)

<a href="https://stackoverflow.com/questions/18407177/load-image-from-website">Load image from website</a>
download.file("url", destfile="tmp.png", mode="wb")

<a href="https://jangorecki.gitlab.io/data.table/library/RCurl/html/url.exists.html">url.exists {RCurl}	</a> return true of false
<a href="https://stackoverflow.com/questions/31420210/r-check-existence-of-url-problems-with-httrget-and-url-exists">With httr use url_success()</a>


<h2>download.file</h2>
This function can be used to download a file from the Internet.
download.file(url, destfile, method, quiet = FALSE, mode = "w",
              cacheOK = TRUE,
              extra = getOption("download.file.extra"),
              headers = NULL, ...)

example:
destfile <- "C:/Users/User/Desktop/aaaa.jpg"
url <- "https://i.pinimg.com/originals/22/2d/b8/222db84256aecf2a7532dcb1a3bab9af.jpg"
download.file(url, destfile, mode = "w", method='curl')

method	
Method to be used for downloading files. Current download methods are "internal", "wininet" (Windows only) "libcurl", "wget" and "curl", and there is a value "auto": see ‘Details’ and ‘Note’.

The method can also be set through the option "download.file.method": see options().

quiet	
If TRUE, suppress status messages (if any), and the progress bar.

mode	
character. The mode with which to write the file. Useful values are "w", "wb" (binary), "a" (append) and "ab". Not used for methods "wget" and "curl". See also ‘Details’, notably about using "wb" for Windows.

cacheOK	
logical. Is a server-side cached value acceptable?

extra	
character vector of additional command-line arguments for the "wget" and "curl" methods.

headers	
named character vector of HTTP headers to use in HTTP requests. It is ignored for non-HTTP URLs. The User-Agent header, coming from the HTTPUserAgent option (see options) is used as the first header, automatically.

...	
allow additional arguments to be passed, unused.



<h2>Passing arguments to R script</h2>

<a href="Passing arguments to R script.html"><span class="goldb">Passing arguments to R script</span></a> 

Rscript --vanilla testargument.R iris.txt newname

To avoid Rscript.exe loop forever for keyboard input:
use this:
cat("a string please: ");
a &lt;- readLines("stdin",n=1);

<h2>School Revision Papers</h2>

http://schoolsnetkenya.com/form-1-revision-papers-for-term-1-2018/
http://schoolsnetkenya.com/form-1-revision-papers-for-term-1-2017/
https://curriculum.gov.mt/en/Examination-Papers/Pages/list_secondary_papers.aspx
http://www2.hkedcity.net/sch_files/a/hf1/hf1-lin/visitor_cabinet/67726/F1-2ndTest-Eng.pdf
http://www2.hkedcity.net/sch_files/a/hf1/hf1-lin/visitor_cabinet/67726/F2-2ndTest-Eng.pdf
http://www.sttss.edu.hk/parents_corner/pastpaper.php
<h2>difference between 1L and 1</h2>

L specifies an integer type, rather than a double, it uses only 4 bytes per element
the function as.integer is simplified yb  "L " suffix

> str(1)
 num 1

> str(1L)
 int 1
<h2><span class="white goldbs">Datatable</span></h2>
<a href="data.table FAQ.html" class="redbut blue goldbs">data.table FAQ</a>
<a href="Data.Table Tutorial.html"><span class="silverredb">&diams;Data.Table Tutorial</span></a>
<a href="R Data.Table Tutorial.html" class="bluebut gold whitebs">R Data.Table Tutorial</a>

<a href="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf">Datatable Cheat Sheet</a>
<h3>setkey does two things:</h3>
reorders the rows of the data.table DT by the column(s) provided (a, b) by reference, always in increasing order.

marks those columns as key columns by setting an attribute called sorted to DT.

The reordering is both fast (due to data.table's internal radix sorting) and memory efficient (only one extra column of type double is allocated).

When is setkey() required?
For grouping operations, setkey() was never an absolute requirement. 
That is, we can perform a cold-by or adhoc-by.

A key is basically an index into a dataset, which allows for very fast and efficient sort, filter, and join operations. 
These are probably the best reasons to use data tables instead of data frames (the syntax for using data tables is also much more user friendly, but that has nothing to do with keys).

library(data.table)

dt=data.table(read.table("wAveTable.txt", header=TRUE, colClasses=c('character', 'numeric', 'numeric')))
colnames(dt)
"Code"   "WAve5"  "WAve10"
dt[WAve5 > 5, ]
summary(dt[WAve5 = 5, ])
summary(dt[WAve5 %between% c(7,9), ])

data.table dt subset rows using i, and manipulate columns with j, grouped according to by	dt[i, j, by]
Create a data.table	data.table(a = c(1, 2), b = c("a", "b"))
convert a data frame or a list to a data.table	setDT(df) or as.data.table(df)
Subset data.table rows using i	dt[1:2, ]
subset data.table rows based on values in one or more columns	dt[a > 5, ]
data.table Logical Operators To Use In i	>,<,<=,>=, |, !,&, is.na(),!is.na(), %in%, %like%,  %between%
data.table extract column(s) by number. Prefix column numbers with “-” to drop	dt[, c(2)]
data.table extract column(s) by name	dt[, .(b, c)]
create a data.table with new columns based on the summarized values of rows	dt[, .(x = sum(a))]
compute a data.table column based on an expression	dt[, c := 1 + 2]
compute a data.table column based on an expression but only for a subset of rows	dt[a == 1, c := 1 + 2]
compute a data.table multiple columns based on separate expressions	dt[, `:=`(c = 1 , d = 2)]
delete a data.table column	dt[, c := NULL]
convert the type of a data.table column using as.integer(), as.numeric(), as.character(), as.Date(), etc..	dt[, b := as.integer(b)]
group data.table rows by values in specified column(s)	dt[, j, by = .(a)]
group data.table and simultaneously sort rows according to values in specified column(s)	dt[, j, keyby = .(a)]
summarize data.table rows within groups	dt[, .(c = sum(b)), by = a]
create a new data.table column and compute rows within groups	dt[, c := sum(b), by = a]
extract first data.table row of groups	dt[, .SD[1], by = a]
extract last data.table row of groups	dt[, .SD[.N], by = a]
perform a sequence of data.table operations by chaining multiple “[]”	dt[…][…]
reorder a data.table according to specified columns	setorder(dt, a, -b), “-” for descending
data.table’s functions prefixed with “set” and the operator “:=”	work without “&lt;-” to alter data without making copies in memory
df &lt;- as.data.table(df)	setDT(df)
extract unique data.table rows based on columns specified in “by”. Leave out “by” to use all columns	unique(dt, by = c("a", "b"))
return the number of unique data.table rows based on columns specified in “by”	uniqueN(dt, by = c("a", "b"))
rename data.table column(s)	setnames(dt, c("a", "b"), c("x", "y"))
data.table Syntax	DT[ i , j , by], i refers to rows. j refers to columns. by refers to adding a group
data.table Syntax arguments	DT[ i , j , by], with, which, allow.cartesian, roll, rollends, .SD, .SDcols, on, mult, nomatch
data.table fread() function	to read data, mydata = fread("https://github.com/flights_2014.csv")
data.table select only 'origin' column returns a vector	dat1 = mydata[ , origin]
data.table select only 'origin' column returns a data.table	dat1 = mydata[ , .(origin)] or dat1 = mydata[, c("origin"), with=FALSE]
data.table select column	dat2 =mydata[, 2, with=FALSE]
data.table select column Multiple Columns	dat3 = mydata[, .(origin, year, month, hour)], dat4 = mydata[, c(2:4), with=FALSE]
data.table Dropping Column	adding ! sign, dat5 = mydata[, !c("origin"), with=FALSE]
data.table Dropping Multiple Columns	dat6 = mydata[, !c("origin", "year", "month"), with=FALSE]
data.table select variables that contain 'dep'	use %like% operator, dat7 = mydata[,names(mydata) %like% "dep", with=FALSE]
data.table Rename Variables	setnames(mydata, c("dest"), c("Destination"))
data.table  rename multiple variables	setnames(mydata, c("dest","origin"), c("Destination", "origin.of.flight"))
data.table find all the flights whose origin is 'JFK'	dat8 = mydata[origin == "JFK"]
data.table Filter Multiple Values	dat9 = mydata[origin %in% c("JFK", "LGA")]
data.table selects not equal to 'JFK' and 'LGA'	dat10 = mydata[!origin %in% c("JFK", "LGA")]
data.table Filter Multiple variables	dat11 = mydata[origin == "JFK" & carrier == "AA"]
data.table Indexing Set Key	tells system that data is sorted by the key column
data.table setting 'origin' as a key	setkey(mydata, origin), 'origin' key is turned on. data12 = mydata[c("JFK", "LGA")]
data.table Indexing Multiple Columns	setkey(mydata, origin, dest), key is turned on. mydata[.("JFK", "MIA")] # First key 'origin' matches “JFK” second key 'dest' matches “MIA”
data.table Indexing Multiple Columns equivalent	mydata[origin == "JFK" & dest == "MIA"]
data.table  identify the column(s) indexed by	key(mydata)
data.table sort data using setorder()	mydata01 = setorder(mydata, origin)
data.table sorting on descending order	mydata02 = setorder(mydata, -origin)
data.table Sorting Data based on multiple variables	mydata03 = setorder(mydata, origin, -carrier)
data.table Adding Columns (Calculation on rows)	use := operator, mydata[, dep_sch:=dep_time - dep_delay]
data.table Adding Multiple Columns	mydata002 = mydata[, c("dep_sch","arr_sch"):=list(dep_time - dep_delay, arr_time - arr_delay)]
data.table IF THEN ELSE Method I	mydata[, flag:= 1*(min < 50)] ,set flag= 1 if min is less than 50. Otherwise, set flag =0.
data.table IF THEN ELSE Method II	mydata[, flag:= ifelse(min < 50, 1,0)] ,set flag= 1 if min is less than 50. Otherwise, set flag =0.
data.table build a chain	DT[ ] [ ] [ ], mydata[, dep_sch:=dep_time - dep_delay][,.(dep_time,dep_delay,dep_sch)]
data.table Aggregate Columns mean	mydata[, .(mean = mean(arr_delay, na.rm = TRUE),
data.table Aggregate Columns median	median = median(arr_delay, na.rm = TRUE),
data.table Aggregate Columns min	min = min(arr_delay, na.rm = TRUE),
data.table Aggregate Columns max	max = max(arr_delay, na.rm = TRUE))]
data.table Summarize Multiple Columns	all the summary function in a bracket, mydata[, .(mean(arr_delay), mean(dep_delay))]
data.table .SD operator	implies 'Subset of Data'
data.table .SD and .SDcols operators	calculate summary statistics for a larger list of variables
data.table calculates mean of two variables	mydata[, lapply(.SD, mean), .SDcols = c("arr_delay", "dep_delay")]
data.table Summarize all numeric Columns	mydata[, lapply(.SD, mean)]
data.table Summarize with multiple statistics	mydata[, sapply(.SD, function(x) c(mean=mean(x), median=median(x)))]
data.table Summarize by group 'origin	mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = origin]
data.table Summary by group useing keyby= operator	mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), keyby = origin]
data.table Summarize multiple variables by group 'origin'	mydata[, .(mean(arr_delay, na.rm = TRUE), mean(dep_delay, na.rm = TRUE)), by = origin], or mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin]
data.table remove non-unique / duplicate cases with unique()	setkey(mydata, "carrier"), unique(mydata)
data.table remove duplicated	setkey(mydata, NULL), unique(mydata), Note : Setting key to NULL is not required if no key is already set.
data.table Extract values within a group	mydata[, .SD[1:2], by=carrier], selects first and second values from a categorical variable carrier.
data.table Select LAST value from a group	mydata[, .SD[.N], by=carrier]
data.table window function frank()	dt = mydata[, rank:=frank(-distance,ties.method = "min"), by=carrier], calculating rank of variable 'distance' by 'carrier'. 
data.table cumulative sum cumsum()	dat = mydata[, cum:=cumsum(distance), by=carrier]
data.table lag and lead with shift()	shift(variable_name, number_of_lags, type=c("lag", "lead")), DT &lt;- data.table(A=1:5), DT[ , X := shift(A, 1, type="lag")], DT[ , Y := shift(A, 1, type="lead")]
data.table  %between% operator to define a range	DT = data.table(x=6:10), DT[x %between% c(7,9)]
data.table %like% to find all the values that matches a pattern	DT = data.table(Name=c("dep_time","dep_delay","arrival"), ID=c(2,3,4)), DT[Name %like% "dep"] 
data.table Inner Join	Sample Data: (dt1 &lt;- data.table(A = letters[rep(1:3, 2)], X = 1:6, key = "A")), (dt2 &lt;- data.table(A = letters[rep(2:4, 2)], Y = 6:1, key = "A")), merge(dt1, dt2, by="A")
data.table Left Join	merge(dt1, dt2, by="A", all.x = TRUE)
data.table Right Join	merge(dt1, dt2, by="A", all.y = TRUE)
data.table Full Join	merge(dt1, dt2, all=TRUE)
Convert a data.table to data.frame	setDF(mydata)
convert data frame to data table	setDT(), setDT(X, key = "A")
data.table Reshape Data	dcast.data.table() and melt.data.table()
data.table Calculate total number of rows by month and then sort on descending order	mydata[, .N, by = month] [order(-N)], The .N operator is used to find count.
data.table Find top 3 months with high mean arrival delay	mydata[, .(mean_arr_delay = mean(arr_delay, na.rm = TRUE)), by = month][order(-mean_arr_delay)][1:3]
data.table Find origin of flights having average total delay is greater than 20 minutes	mydata[, lapply(.SD, mean, na.rm = TRUE), .SDcols = c("arr_delay", "dep_delay"), by = origin][(arr_delay + dep_delay) > 20]
data.table Extract average of arrival and departure delays for carrier == 'DL' by 'origin' and 'dest' variables	mydata[carrier == "DL", lapply(.SD, mean, na.rm = TRUE), by = .(origin, dest), .SDcols = c("arr_delay", "dep_delay")]
data.table Pull first value of 'air_time' by 'origin' and then sum the returned values when it is greater than 300	mydata[, .SD[1], .SDcols="air_time", by=origin][air_time > 300, sum(air_time)]

<h2>extract flickr image</h2>
seek .context-thumb
get background-image
convert _m.jpg -> _b.jpg

https://live.staticflickr.com/2941/15170815109_f81b1994d2_m.jpg
https://live.staticflickr.com/2941/15170815109_f81b1994d2_b.jpg

<h2><span class="gold bordred1 blink">R Web Scraping</span></h2>

<a href="https://blog.scrapinghub.com/2016/10/27/an-introduction-to-xpath-with-examples" class="whitebut red bluebs blueblackgrad whitets blinkNmove">get started xpath selectors</a>

<a href="https://www.datacamp.com/community/tutorials/r-web-scraping-rvest">R Web Scraping Rvest</a>
<a href="http://www.programmingr.com/content/webscraping-using-readlines-and-rcurl/">webscraping-using-readlines-and-rcurl</a>
<a href="https://www.rdocumentation.org/packages/XML/versions/3.98-1.16/topics/xmlTreeParse">xmlTreeParse, htmlTreeParse</a>
<a href="http://www.cse.chalmers.se/~chrdimi/downloads/web/getting_web_data_r4_parsing_xml_html.pdf">getting web data parsing xml html</a>
<a href="https://stackoverflow.com/questions/35479549/error-in-r-no-applicable-method-for-xpathapply">error in r no applicable method for xpathapply</a>
<a href="https://blog.rstudio.com/2015/04/21/xml2/">Parse and process XML (and HTML) with xml2</a>
==================
web_page &lt;- readLines("http://www.interestingwebsite.com")
web_page &lt;- read.csv("http://www.programmingr.com/jan09rlist.html")

    # General-purpose data wrangling
    library(tidyverse)  

    # Parsing of HTML/XML files  
    library(rvest)    

    # String manipulation
    library(stringr)   

    # Verbose regular expressions
    library(rebus)     

    # Eases DateTime manipulation
    library(lubridate)

==================
install.packages("RCurl", dependencies = TRUE)
library("RCurl")
library("XML")

past &lt;- getURL("http://www.iciba.com/past", ssl.verifypeer = FALSE)	# getURL cannot work
webpage &lt;- read_html("http://www.iciba.com/past")	# getURL cannot work

jan09_parsed &lt;- htmlTreeParse(jan09)

==================
http://www.iciba.com/past
ul class="base-list switch_part" class

library('rvest')
library(tidyverse)
url &lt;- 'http://www.iciba.com/past'
webpage &lt;- readLines(url, warn=FALSE)
webpage &lt;- read_html(webpage)
grappedData &lt;- html_nodes(webpage,'.base-list switch_part')

parseData = htmlTreeParse(webpage)

rank_data &lt;- html_text(grappedData)

html_node("#mw-content-text > div > table:nth-child(18)")
html_table()

the function htmlParse() which is equivalent to xmlParse(file, isHTML = TRUE)
output = htmlParse(webpage)
class(output)

To parse content into an R structure :
htmlTreeParse() which is equivalent to htmlParse(file, useInternalNodes = FALSE)
output = htmlTreeParse(webpage)
class(output)

htmlTreeParse(file) especially suited for parsing HTML content
returns class "XMLDocumentContent" (R data structure)
equivalent to
xmlParse(file, isHTML = TRUE, useInternalNodes = FALSE)
htmlParse(file, useInternalNodes = FALSE)

root =xmlRoot(output)
xmlChildren(output)
xmlChildren(xmlRoot(output))
XMLNodeList

Functions for a given node
Function Description
xmlName() name of the node
xmlSize() number of subnodes
xmlAttrs() named character vector of all attributes
xmlGetAttr() value of a single attribute
xmlValue() contents of a leaf node
xmlParent() name of parent node
xmlAncestors() name of ancestor nodes
getSibling() siblings to the right or to the left
xmlNamespace() the namespace (if there’s one)

to parse HTML tables using R
sched &lt;- readHTMLTable(html, stringsAsFactors = FALSE)

The html.raw object is not immediately useful because it literally contains all of the raw HTML for the entire webpage. We can parse the raw code using the xpathApply function which parses HTML based on the path argument, which in this case specifies parsing of HTML using the paragraph tag.

html.raw&lt;-htmlTreeParse('http://www.dnr.state.mn.us/lakefind/showreport.html?downum=27013300',
    useInternalNodes=T    )
html.parse&lt;-xpathApply(html.raw, "//p", xmlValue)

# evaluate input and convert to text
txt &lt;- htmlToText(url)

==================
url &lt;- 'http://www.iciba.com/past'
webpage &lt;- readLines(url, warn=FALSE)
scraping_wiki &lt;- read_html(webpage)
scraping_wiki %>% html_nodes("h1") %>% html_text()

url &lt;- 'testvibrate.html'
webpage &lt;- readLines(url, warn=FALSE)
x &lt;- read_xml(webpage)
xml_name(x)
===========

This cannot work in office
library(rvest)
Sys.setlocale(category = 'LC_ALL', 'Chinese')
webpage &lt;- read_html("http://www.iciba.com/haunt")
ullist = webpage %>% html_nodes("ul")
content = ullist[2] %>% html_text()
content = gsub("n.| |\n|adj.|adv.|prep.|vt.|vi.|&","",content)
content = gsub("，|；"," ",content) %>%  strsplit(split = " ") %>% unlist() %>% sort() %>% unique()
paste0("past","\t",capture.output(cat(content)))

<h2>R scraping html text example</h2>

<a href="http://bradleyboehmke.github.io/2015/12/scraping-html-text.html">scraping-html-text</a>
library(rvest)

scraping_wiki &lt;- read_html("https://en.wikipedia.org/wiki/Web_scraping")

scraping_wiki %>% html_nodes("h1")
scraping_wiki %>% html_nodes("h2")
scraping_wiki %>% html_nodes("h1") %>% html_text()
scraping_wiki %>% html_nodes("h2") %>% html_text()
p_nodes &lt;- scraping_wiki %>% html_nodes("p")
length(p_nodes)
p_text &lt;- scraping_wiki %>% html_nodes("p") %>% html_text()
p_text[1]
p_text[5]

ul_text &lt;- scraping_wiki %>% html_nodes("ul") %>% html_text()
length(ul_text)
ul_text[1]
substr(ul_text[2], start = 1, stop = 200)

li_text &lt;- scraping_wiki %>% html_nodes("li") %>% html_text()
length(li_text)
li_text[1:8]
li_text[104:136]

all_text &lt;- scraping_wiki %>% html_nodes("div") %>%  html_text()

body_text &lt;- scraping_wiki %>% html_nodes("#mw-content-text") %>%  html_text()

# read the first 207 characters
substr(body_text, start = 1, stop = 207)

# read the last 73 characters
substr(body_text, start = nchar(body_text)-73, stop = nchar(body_text))

# Scraping a specific heading
scraping_wiki %>% html_nodes("#Techniques") %>%  html_text()
## [1] "Techniques"

# Scraping a specific paragraph
scraping_wiki %>% html_nodes("#mw-content-text > p:nth-child(20)") %>%  html_text()

# Scraping a specific list
scraping_wiki %>% html_nodes("#mw-content-text > div:nth-child(22)") %>%  html_text()

# Scraping a specific reference list item
scraping_wiki %>% html_nodes("#cite_note-22") %>%  html_text()

# Cleaning up
library(magrittr)
scraping_wiki %>% html_nodes("#mw-content-text > div:nth-child(22)") %>%  html_text()

scraping_wiki %>% html_nodes("#mw-content-text > div:nth-child(22)") %>%  html_text() %>%  strsplit(split = "\n") %>% unlist() %>% .[. != ""]


library(stringr)

# read the last 700 characters
substr(body_text, start = nchar(body_text)-700, stop = nchar(body_text))

# clean up text
body_text %>% 
str_replace_all(pattern = "\n", replacement = " ") %>% 
str_replace_all(pattern = "[\\^]", replacement = " ") %>% 
str_replace_all(pattern = "\"", replacement = " ") %>% 
str_replace_all(pattern = "\\s+", replacement = " ") %>% 
str_trim(side = "both") %>% 
substr(start = nchar(body_text)-700, stop = nchar(body_text))

################
# rvest tutorials
https://blog.rstudio.com/2014/11/24/rvest-easy-web-scraping-with-r/
https://blog.gtwang.org/r/rvest-web-scraping-with-r/
https://www.rdocumentation.org/packages/rvest/versions/0.3.4
https://www.datacamp.com/community/tutorials/r-web-scraping-rvest
https://stat4701.github.io/edav/2015/04/02/rvest_tutorial/
https://lmyint.github.io/post/dnd-scraping-rvest-rselenium/

################
# parse guancha
library(rvest)
pageHeader="https://user.guancha.cn/main/content?id=181885"
pagesource &lt;- read_html(pageHeader)

################
# parse RTHK and metroradio
library(rvest)
pageHeader = "http://news.rthk.hk/rthk/ch/latest-news.htm"
pagesource &lt;- read_html(pageHeader)
className = ".ns2-title"
keywordList &lt;- html_nodes(pagesource, className)
html_text(keywordList)

pageHeader = "http://www.metroradio.com.hk/MetroFinance/News/NewsLive.aspx"
pagesource &lt;- read_html(pageHeader)
className = ".n13newslist"
keywordList &lt;- html_nodes(pagesource, className)
className = "a"
keywordList &lt;- html_nodes(keywordList, className)
html_text(keywordList)

################
# parse xhamster
library(rvest)
pageHeader = "https://xhamster.com/users/fredlake/photos"
pagesource &lt;- read_html(pageHeader)
className = ".xh-paginator-button"
keywordList &lt;- html_nodes(pagesource, className)
html_text(keywordList)
html_name(keywordList)
html_attrs(keywordList)

thelist = unlist(html_attrs(keywordList))

length(keywordList)
as.numeric(html_text(keywordList[length(keywordList)]))

pagesource %>% html_nodes(className) %>% html_text() %>% as.numeric()

for ( i in keywordList ) { 
 qlink &lt;- html_nodes(s, ".gallery-thumb")
 cat("Title:", html_text(qlink), "\n")
 qviews &lt;- html_nodes(s, "name")
 cat("Views:", html_text(qviews), "\n")
}
################
# parse text and href
pageHeader = "http://news.rthk.hk/rthk/ch/latest-news.htm"
pagesource &lt;- read_html(pageHeader)

className = ".ns2-title"
keywordList &lt;- html_nodes(pagesource, className)

className = "a"
a &lt;- html_nodes(keywordList, className)

html_text(a)
html_attr(a, "href")

################
# extract huanqiu.com gallery

pageHeader = "https://china.huanqiu.com/gallery/9CaKrnQhXac"
pagesource &lt;- read_html(pageHeader)
className = "article"
keywordList &lt;- html_nodes(pagesource, className)

className = "img"
img &lt;- html_nodes(keywordList, className)
html_attr(img, "src")
html_attr(img, "data-alt")

################
# html_nodes samples
html_nodes(".a1.b1")
html_nodes(".b1:not(.a1)")  # <i>Select class contains b1 not a1:</i>
html_nodes(".content__info__item__value")
html_nodes("[class='b1']")
html_nodes("center")
html_nodes("font")
html_nodes(ateam, "center")
html_nodes(ateam, "center font")
html_nodes(ateam, "center font b")
html_nodes("table") %>% .[[3]] %>% html_table()
html_nodes("td")
html_nodes() returns all nodes
html_nodes(pagesource, className)
html_nodes(pg, "div > input:first-of-type"), "value")
html_nodes(s, ".gallery-thumb")
html_nodes(s, "name")
html_nodes(xpath = '//*[@id="a"]')

ateam %>% html_nodes("center") %>% html_nodes("td")
ateam %>% html_nodes("center") %>% html_nodes("font")

td &lt;- ateam %>% html_nodes("center") %>% html_nodes("td")
td %>% html_nodes("font")

if (utils::packageVersion("xml2") > "0.1.2") {
  td %>% html_node("font")
}

# To pick out an element at specified position, use magrittr::extract2
# which is an alias for [[
library(magrittr)
ateam %>% html_nodes("table") %>% extract2(1) %>% html_nodes("img")
ateam %>% html_nodes("table") %>% `[[`(1) %>% html_nodes("img")

# Find all images contained in the first two tables
ateam %>% html_nodes("table") %>% `[`(1:2) %>% html_nodes("img")
ateam %>% html_nodes("table") %>% extract(1:2) %>% html_nodes("img")

# XPath selectors ---------------------------------------------
# If you prefer, you can use xpath selectors instead of css: 
html_nodes(doc, xpath = "//table//td")).

# chaining with XPath is a little trickier - you may need to vary
# the prefix you're using - // always selects from the root node
# regardless of where you currently are in the doc
ateam %>% html_nodes(xpath = "//center//font//b") %>% html_nodes(xpath = "//b")


read_html()
html_node()	# to find the first node
html_nodes(doc, "table td")	# to find the all node
html_nodes(doc, xpath = "//table//td"))

html_name()	# the name of the tag
html_tag()	# Extract the tag names
html_text()	# Extract all text inside the tag 

html_attr()	Extract the a single attribute
html_attrs()	Extract all the attributes

# html_attrs(keywordList) this cannot use id, just list all details
# html_attr(keywordList, "id") this select the ids
# html_attr(keywordList, "href") this select the hrefs

html_nodes("#titleCast .itemprop span")
html_nodes("#img_primary img")
html_nodes("div.name > strong > a")
html_attr("href")

html_text(keywordList, trim = FALSE)
html_name(keywordList)
html_children(keywordList)
html_attrs(keywordList)
html_attr(keywordList, "[href]", default = NA_character_)

parse with xml()
then extract components using 
xml_node()
xml_attr()
xml_attrs()
xml_text() and xml_name()

Parse tables into data frames with 
html_table().

Extract, modify and submit forms with 
html_form()
set_values()
submit_form().

Detect and repair encoding problems with 
guess_encoding()	Detect text encoding
repair_encoding()	repair text encoding

Navigate around a website as if you’re in a browser with 
html_session()
jump_to()
follow_link()
back()
forward()

Extract, modify and submit forms with 
html_form(), 
set_values() 
and submit_form()


The toString() function collapse the list of strings into one.

html_node(":not(#commentblock)")	# exclude tags

######### demos #########
# Inspired by https://github.com/notesofdabbler
library(rvest)
library(tidyr)

page &lt;- read_html("http://www.zillow.com/homes/for_sale/....")

houses &lt;- page %>% html_nodes(".photo-cards li article")
z_id &lt;- houses %>% html_attr("id")

address &lt;- houses %>% html_node(".zsg-photo-card-address") %>% html_text()

price &lt;- houses %>% html_node(".zsg-photo-card-price") %>% html_text() %>% readr::parse_number()

params &lt;- houses %>% html_node(".zsg-photo-card-info") %>% html_text() %>% strsplit("\u00b7")

beds &lt;- params %>% purrr::map_chr(1) %>% readr::parse_number()
baths &lt;- params %>% purrr::map_chr(2) %>% readr::parse_number()
house_area &lt;- params %>% purrr::map_chr(3) %>% readr::parse_number()

################
pagesource %>% html_nodes("table") %>% .[[3]] %>% html_table()

read_html(doc) %>% html_nodes(".b1:not(.a1)") # <i>Select class contains b1 not a1:</i>
# [1] <span class="b1"> text2 </span>

<i>use the attribute selector:</i>
read_html(doc) %>% html_nodes("[class='b1']")
# [1] <span class="b1"> text2 </span>

<i>Select class contains both:</i>
read_html(doc) %>% html_nodes(".a1.b1")  # <i>this is 'and' operation</i>
# [1] <span class="a1 b1"> text1 </span>

combine class and ID in CSS selector
div#content.sectionA  # <i>this is 'and' operation</i>

=====================
<i>select 2 classes in 1 tag</i>
Select class contains b1 not a1:
read_html(doc) %>% html_nodes(".b1:not(.a1)")

<i>use the attribute selector:</i>
read_html(doc) %>% html_nodes("[class='b1']")

<i>Select class contains both:</i>
read_html(doc) %>% html_nodes(".a1.b1")  # <i>this is 'and' operation</i>
=====================
standard CSS selector specify either or both

html_nodes(".content__info__item__value, skill")  # <i>the comma is 'or' operation</i>
{xml_nodeset (4)}
[1] <span class="content__info__item__value duration">5h 59m 42s</span>
[2] <span class="content__info__item__value skill">Beginner + Intermediate</span>
[3] <span class="content__info__item__value released">September 26, 2013</span>
[4] <span class="content__info__item__value viewers">82,552</span>

# has both classes in_learning_page
html_nodes(".content__info__item__value.skill")   # <i>this is 'and' operation</i>
{xml_nodeset (1)}
[1] <span class="content__info__item__value skill">Beginner + Intermediate</span>


in_learning_page %>%
  html_nodes(".content__info__item__value") %>% 
  str_subset(., "viewers")

h &lt;- read_html(text)

h %>% html_nodes(xpath = '//*[@id="a"]') %>% xml_attr("value")

html_attr(html_nodes(pg, "div > input:first-of-type"), "value")

ateam %>% html_nodes("center") %>% html_nodes("td")
ateam %>% html_nodes("center") %>% html_nodes("font")

td &lt;- ateam %>% html_nodes("center") %>% html_nodes("td")

# When applied to a list of nodes, html_nodes() returns all nodes,
# collapsing results into a new nodelist.
td %>% html_nodes("font")
# nodes, it returns a "missing" node
if (utils::packageVersion("xml2") > "0.1.2") {
  td %>% html_nodes("font")

<h2>sort() rank() order()</h2>

<k>Rank</k> references the position of the value in the sorted vector and is in the same order as the <k>original </k>sequence
<k>Order</k> returns the position of the original value and is in the order of <k>sorted </k>sequence
The graphic below helps tie together the values reported by rank and order with the positions from which they come.

<img class="lazy" data-src="https://cdn-images-1.medium.com/max/800/1*3KeaXU6luJDyoatWkEwdug.jpeg">
x = c(1, 8,9, 4)
sort(x)
1 4 8 9

# the original position in the sorted order
rank(x)
1 3 4 2

# the sorted position in the original position
order(x)
1 4 2 3
<h2>Bioinformatics</h2>

<a href="https://cran.r-project.org/doc/contrib/Krijnen-IntroBioInfStatistics.pdf">Bioinformatics using R</a>
<a href="https://www.bioconductor.org/">bioconductor</a>
<a href="https://www.r-exercises.com/product/introduction-to-bioconductor-annotation-and-analysis-of-genomes-and-genomic-assays/">Introduction to Bioconductor:Annotation and Analysis of Genomes and Genomics Assays</a>

<h2>a list of dataframes, 3D data arrangement</h2>

d1 &lt;- data.frame(y1=c(1,2,3),y2=c(4,5,6))
d2 &lt;- data.frame(y1=c(3,2,1),y2=c(6,5,4))
d3 &lt;- data.frame(y1=c(7,8,9),y2=c(5,2,6))
mylist &lt;- list(d1, d2, d3)
names(mylist) &lt;- c("List1","List2","List3")

mylist[1]	# same as mylist$List1

mylist[[2]][1,2]	# access an element inside a dataframe
mylist[[2]][2,2]	# same as mylist$List2[2,2]

to concate another dataframe:

d4 &lt;- data.frame(y1=c(2,5,8),y2=c(1,4,7))
mylist[[4]] &lt;- d4

to create an empty list:
data &lt;- list()
<h2>format time string</h2>

Sys.time()
sub(".* | .*", "", Sys.time())
format(Sys.time(), '%H:%M')
gsub(":", "", format(Sys.time(), '%H:%M'))
format(Sys.time(), '%H%M')


<h2>extract 5 digit from string</h2>

activityListCode = str_replace(activityListCode, ".*\\b(\\d{5})\\b.*", "\\1")


<h2>access Components of a Data Frame</h2>
<a href="https://www.datamentor.io/r-programming/data-frame/">access Components of a Data Frame</a>

Components of data frame can be accessed like a list or like a matrix.

<h3>Accessing like a list</h3>
We can use either <code>[</code>, <code>[[</code> or <code>$</code> operator to access columns of data frame.

<code>> x["Name"]
Name
1 John
2 Dora
> x$Name
[1] "John" "Dora"
> x[["Name"]]
[1] "John" "Dora"
> x[[3]]
[1] "John" "Dora"
</code>
Accessing with <code>[[</code> or <code>$</code> is similar. However, it differs for <code>[</code> in that, indexing with <code>[</code> <span class="redword">will return us a data frame</span> but the other two will <span class="redword">reduce it into a vector</span>.


<h3>Accessing like a matrix</h3>
Data frames can be accessed like a matrix by providing index for row and column.

To illustrate this, we use datasets already available in R. Datasets that are available can be listed with the command <code>library(help = "datasets")</code>.

We will use the <code>trees</code> dataset which contains <code>Girth</code>, <code>Height</code> and <code>Volume</code> for Black Cherry Trees.

A data frame can be examined using functions like <code>str()</code> and <code>head()</code>.

<code>> str(trees)
'data.frame':   31 obs. of 3 variables:
$ Girth : num  8.3 8.6 8.8 10.5 10.7 10.8 11 11 11.1 11.2 ...
$ Height: num  70 65 63 72 81 83 66 75 80 75 ...
$ Volume: num  10.3 10.3 10.2 16.4 18.8 19.7 15.6 18.2 22.6 19.9 ...
> head(trees,n=3)
Girth Height Volume
1   8.3     70   10.3
2   8.6     65   10.3
3   8.8     63   10.2
</code>
We can see that <code>trees</code> is a data frame with 31 rows and 3 columns. We also display the first 3 rows of the data frame.

Now we proceed to access the data frame like a matrix.

<code>> trees[2:3,]    # select 2nd and 3rd row
Girth Height Volume
2   8.6     65   10.3
3   8.8     63   10.2
> trees[trees$Height > 82,]    # selects rows with Height greater than 82
Girth Height Volume
6   10.8     83   19.7
17  12.9     85   33.8
18  13.3     86   27.4
31  20.6     87   77.0
> trees[10:12,2]
[1] 75 79 76
</code>
We can see in the last case that the returned type is a vector since we extracted data from a single column.

This behavior can be avoided by passing the argument <code>drop=FALSE</code> as follows.

<code>> trees[10:12,2, drop = FALSE]
Height
10     75
11     79
12     76
</code>


# access first row by index, returns a data.frame
x[1,]

# access first row by "name", returns a data.frame
> x["1",]

# access first row returns a vector
use as.numeric
str(as.numeric(wAveTable["1",]))

unlist which keeps the names.
str(unlist(wAveTable["1",]))

use transpose and as.vector
str(as.vector(t(wAveTable["1",])[,1]))

use only as.vector cannot convert to vector
str(as.vector(wAveTable["1",]))

# convert dataframe to matrix
data.matrix(wAveTable)

<h2>read.csv as character</h2>

wAveTable = read.csv("wAveTable.txt", sep="\t", colClasses=c('character', 'character', 'character'))
<h2>frequency manipulation</h2>

grade = c("low", "high", "medium", "high", "low", "medium", "high")

# using factor to count the frequency
foodfac &lt;- factor(grade)
summary(foodfac)
max(summary(foodfac))
min(summary(foodfac))
levels(foodfac)
nlevels(foodfac)
summary(levels(foodfac))

# use of table to count frequency:
table(grade)
sort(table(grade))

table(grade)[1]
max(table(grade))
summary(table(grade))

# this locate the max item:
table(grade)[which(table(grade) == max(table(grade)))]

# change to dataframe and find the max item:
theTable = as.data.frame(table(grade))
theTable[which(theTable$Freq == max(theTable$Freq)),]

# use of the count function in plyr:
library(plyr)
count(grade)
count(mtcars, 'gear')

# use of the which function:
which(letters == "g")
x &lt;- c(1,5,8,4,6)
which(x == 5)
which(x != 5)

<h2>5 must have R programming tools</h2>

<h4>1) RStudio</h4>
<h4>2) lintr</h4>
If you come from the world of Python, you’ve probably heard of 
<a href="https://stackoverflow.com/questions/8503559/what-is-linting" data-href="https://stackoverflow.com/questions/8503559/what-is-linting" rel="nofollow noopener" target="_blank">linting</a>. 
Essentially, linting 
<a href="https://en.wikipedia.org/wiki/Lint_%28software%29" data-href="https://en.wikipedia.org/wiki/Lint_%28software%29" rel="nofollow noopener" target="_blank">analyzes</a> your code for readability. 
It makes sure you don’t produce code that looks like this:
# This is some bad R code
<br>if ( mean(x,na.rm=T)==1) { print(“This code is bad”); } # Still bad code because this line is SO long
There are 
<em>many</em> things wrong with this code. 
For starters, the code is too long. 
Nobody likes to read code with seemingly endless lines. 
There are also no spaces after the comma in the 
<code>mean()</code> function, or any spaces between the 
<code>==</code> operator. 
Oftentimes data science is done hastily, but linting your code is a good reminder for creating portable and understandable code. 
After all, if you can’t explain what you are doing or how you are doing it, your data science job is incomplete. 

<a href="https://cran.r-project.org/web/packages/lintr/index.html" data-href="https://cran.r-project.org/web/packages/lintr/index.html" rel="nofollow noopener" target="_blank">lintr</a> is an R package, growing in popularity, that allows you to lint your code. 
Once you install lintr, linting a file is as easy as 
<code>lint("filename.R")</code> .
<h4>3) Caret</h4>
<a href="http://topepo.github.io/caret/index.html" data-href="http://topepo.github.io/caret/index.html" rel="nofollow noopener" target="_blank">Caret</a>, which you can find on 
<a href="https://cran.r-project.org/web/packages/caret/caret.pdf" data-href="https://cran.r-project.org/web/packages/caret/caret.pdf" rel="nofollow noopener" target="_blank">CRAN</a>, is central to a data scientist’s toolbox in R. 
Caret allows one to quickly develop models, set cross-validation methods and analyze model performance all in one. 
Right out of the box, Caret abstracts the various interfaces to user-made algorithms and allows you to swiftly create models from averaged neural networks to boosted trees. 
It can even handle parallel processing. 
Some of the models caret includes are: AdaBoost, Decision Trees & Random Forests, Neural Networks, Stochastic Gradient Boosting, nearest neighbors, support vector machines — among the most commonly used machine learning algorithms.
<h4>4) Tidyverse</h4>
You may not have heard of 
<code>tidyverse</code> as a whole, but chances are, you’ve used one of the packages in it. 
Tidyverse is a set of unified packages meant to make data science… 
<em>easyr</em> (classic R pun). 
These packages alleviate many of the problems a data scientist may run into when dealing with data, such as loading data into your workspace, manipulating data, tidying data or visualizing data. 
Undoubtedly, these packages make dealing with data in R more efficient.
It’s incredibly easy to get Tidyverse, you just run 
<code>install.packages("tidyverse")</code> and you get:
<a href="http://ggplot2.tidyverse.org/" data-href="http://ggplot2.tidyverse.org/" rel="nofollow noopener" target="_blank">ggplot2</a>: A popular R package for creating graphics
<a href="http://dplyr.tidyverse.org/" data-href="http://dplyr.tidyverse.org/" rel="nofollow noopener" target="_blank">dplyr</a>: A popular R package for efficiently manipulating data
tidyr: An R package for tidying up data sets
<a href="http://readr.tidyverse.org/" data-href="http://readr.tidyverse.org/" rel="nofollow noopener" target="_blank">readr</a>: An R package for reading in data
<a href="http://purrr.tidyverse.org/" data-href="http://purrr.tidyverse.org/" rel="nofollow noopener" target="_blank">purrr</a>: An R package which extends R’s functional programming toolkit
<a href="purrr Tutorial.html" class="whitebut ">purrr Tutorial</a>

<a href="http://tibble.tidyverse.org/" data-href="http://tibble.tidyverse.org/" rel="nofollow noopener" target="_blank">tibble</a>: An R package which introduces the 
<em>tibble (tbl_df)</em>, an enhancement of the data frame
By and large, ggplot2 and dplyr are some of the most common packages in the R sphere today, and you’ll see countless posts on StackOverflow on how to use either package.

<em>(Fine Print: Keep in mind, you can’t just load everything with </em>
<code>
<em>library(tidyverse)</em></code>
<em> you must load each individually!)</em>
<h4>5) Jupyter Notebooks or R Notebooks</h4>
Data science 
<em>MUST</em> be transparent and reproducible. 
For this to happen, we have to see your code! The two most common ways to do this are through 
<a href="http://jupyter.org/" data-href="http://jupyter.org/" rel="nofollow noopener" target="_blank">Jupyter Notebooks</a> or 
<a href="http://rmarkdown.rstudio.com/r_notebooks.html" data-href="http://rmarkdown.rstudio.com/r_notebooks.html" rel="nofollow noopener" target="_blank">R Notebooks</a>.
Essentially, a notebook (of either kind) allows you to run R code block by block, and show output block my block. 
We can see on the left that we are summarizing the data, then checking the output. 
After, we plot the data, then view the plot. 
All of these actions take place within the notebook, and it makes analyzing both output and code a simultaneous process. 
This can help data scientists collaborate and ease the friction of having to open up someone’s code and understand what it does. 
Additionally, notebooks also make data science 
<em>reproducible</em>, which gives validity to whatever data science work you do!
<h4>Honorable Mention: Git</h4>
Last but not least, I want to mention Git. 
Git is a 
<em>version control</em> system. 
So why use it? Well, it’s in the name. 
Git allows you to keep versions of the code you are working on. 
It also allows multiple people to work on the same project and allows those changes to be attributed to certain contributors. 
You’ve probably heard of 
<a href="http://www.github.com" data-href="http://www.github.com" rel="nofollow noopener" target="_blank">Github</a>, undoubtedly one of the most popular git servers.
You can visit my website at 
<a href="http://www.peterxeno.com" data-href="http://www.peterxeno.com" rel="nofollow noopener" target="_blank">www.peterxeno.com</a> and my Github at 
<a href="https://github.com/peterxeno" data-href="https://github.com/peterxeno" rel="nofollow noopener" target="_blank">www.github.com/peterxeno</a>


<h2>R with Javascript</h2>
<a href="R and D3.html">R and D3</a>
<a href="https://www.opencpu.org/posts/js-release-0-1/">tools for working with JavaScript in R</a>
<a href="http://www.di.fc.ul.pt/~jpn/r/langs/javascript.html">R Connecting with Javascript</a>

<h2><span class="white bordgreen1">tryCatch</span></h2>
<a href="https://codeday.me/bug/20170502/13495.html">如何在R中写trycatch</a>
<a href="https://stackoverflow.com/questions/12193779/how-to-write-trycatch-in-r">write trycatch in R</a>
<a href="http://mazamascience.com/WorkingWithData/?p=912">error Handing with tryCatch()</a>

e.g.
readUrl = function(url) {
    out = tryCatch(
        {
            message("This is the 'try' part")
            readLines(con=url, warn=FALSE) 
        },
        error=function(cond) {
            message(paste("URL does not seem to exist:", url))
            message("Here's the original error message:")
            message(cond)
            # Choose a return value in case of error
            return(NA)
        },
        warning=function(cond) {
            message(paste("URL caused a warning:", url))
            message("Here's the original warning message:")
            message(cond)
            # Choose a return value in case of warning
            return(NULL)
        },
        finally={
        # Here goes everything that should be executed at the end,
        # regardless of success or error.
        # If you want more than one expression to be executed, then you 
        # need to wrap them in curly brackets ({...}); otherwise you could
        # just have written 'finally={expression}' 
            message(paste("Processed URL:", url))
            message("Some other message at the end")
        }
    )    
    return(out)
}

e.g.
x &lt;- tryCatch( readLines("wx.qq.com/"), warning=function(w){ return(paste( "Warning:", conditionMessage(w)));}, 
error = function(e) { return(paste( "this is Error:", conditionMessage(e)));}, 
finally={print("This is try-catch test. check the output.")});

e.g.
for (i in urls) {
    tmp &lt;- tryCatch(readLines(url(i), warn=F), error = function (e) NULL)
    if (is.null(tmp)) {
        next() # skip to the next url.
    }
}

a retry function:
retry &lt;- function(dothis, max = 10, init = 0){
	suppressWarnings( tryCatch({
		if(init&lt;max) dothis}, 
			error = function(e){retry(dothis, max, init = init+1)}
		)
	)
}
dothis &lt;- function(){do somthing}

<h2>Download Image</h2>
<a href="https://stackoverflow.com/questions/29110903/how-to-download-and-display-an-image-from-an-url-in-r">Download Image</a>
when opened with windows image viewer it also says it is corrupt. The reason for this is that you don't have specified the mode in the download.file statement.

Try this:
download.file(y,'y.jpg', mode = 'wb')
download.file('http://78.media.tumblr.com/83a81c41926c1da585916a5c092b4789/tumblr_or0y0vdjOP1rttk8po1_1280.jpg','y.jpg', mode = 'wb')

To view the image in R
library(jpeg)
jj &lt;- readJPEG("y.jpg",native=TRUE)
plot(0:1,0:1,type="n",ann=FALSE,axes=FALSE)
rasterImage(jj,0,0,1,1)

<h2>testShiny</h2>
setwd("D:/KPC/testShiny")
runApp("D:/KPC/testShiny")


<h2>Error in file(filename, "r", encoding = encoding)</h2>
The error indicate that either the file doesn't exist or the source() command an incorrect path. 

<h2>call a R program from another R program</h2>
source("program_B.R")

<h2>to view all the functions present in a package</h2>

To list all objects in the package use ls
ls("package:Hmisc")
Note that the package must be attached.

To list all strings
lsf.str("package:dplyr")
lsf.str("package:Hmisc")

To see the list of currently loaded packages use
search()

Alternatively calling the help would also do, even if the package is not attached:
help(package = dplyr)
help(package = Hmisc)

Finally, use RStudio which provides an autocomplete function.
So, for instance, typing Hmisc:: in the console or while editing a file will result in a popup list of all dplyr functions/objects.



<h2>cut2</h2>

Function like cut but left endpoints are inclusive.

install.packages("Hmisc")
library(Hmisc)

alist = c(-15,18,2,5,4,-7,-5,-3,-1,0,2,1,5,4,6)
breaks = c(-5,-3,-1,0,1,3,5)
table(cut2(alist, breaks))

<h2>Reference A Data Frame Column</h2>

with the double square bracket "[[]]" operator.
LastDayTable[["Vol"]] 
or
LastDayTable$Vol
or
<span class="cyanword">LastDayTable[,"Vol"] </span>

<h2>Writing data to a file</h2>
<h3 id="problem">Problem</h3>
You want to write data to a file.


<h3 id="solution">Solution</h3>
<h3 id="writing-to-a-delimited-text-file">Writing to a delimited text file</h3>
The easiest way to do this is to use <code>write.csv()</code>. By default, <code>write.csv()</code> includes row names, but these are usually unnecessary and may cause confusion.


<code># A sample data frame
data &lt;- read.table(header=TRUE, text='
 subject sex size
       1   M    7
       2   F    NA
       3   F    9
       4   M   11
 ')


# Write to a file, suppress row names
write.csv(data, "data.csv", row.names=FALSE)

# Same, except that instead of "NA", output blank cells
write.csv(data, "data.csv", row.names=FALSE, na="")

# Use tabs, suppress row names and column names
write.table(data, "data.csv", sep="\t", row.names=FALSE, col.names=FALSE) 
</code>

<h3>Saving in R data format</h3>
<code>write.csv()</code> and <code>write.table()</code> are best for interoperability with other data analysis programs. They will not, however, preserve special attributes of the data structures, such as whether a column is a character type or factor, or the order of levels in factors. In order to do that, it should be written out in a special format for R.


Below are are three primary ways of doing this:


The first method is to output R source code which, when run, will re-create the object. This should work for most data objects, but it may not be able to faithfully re-create some more complicated data objects.


<code># Save in a text format that can be easily loaded in R
dump("data", "data.Rdmpd")
# Can save multiple objects:
dump(c("data", "data1"), "data.Rdmpd")

# To load the data again: 
source("data.Rdmpd")
# When loaded, the original data names will automatically be used.
</code>

The next method is to write out individual data objects in RDS format. This format can be binary or ASCII. Binary is more compact, while ASCII will be more efficient with version control systems like Git.

<code># Save a single object in binary RDS format
saveRDS(data, "data.rds")
# Or, using ASCII format
saveRDS(data, "data.rds", ascii=TRUE)

# To load the data again:
data &lt;- readRDS("data.rds")
</code>

It’s also possible to save multiple objects into an single file, using the RData format.


<code># Saving multiple objects in binary RData format
save(data, file="data.RData")
# Or, using ASCII format
save(data, file="data.RData", ascii=TRUE)
# Can save multiple objects
save(data, data1, file="data.RData")

# To load the data again:
load("data.RData")
</code>
An important difference between <code>saveRDS()</code> and <code>save()</code> is that, with the former, when you <code>readRDS()</code> the data, you specify the name of the object, and with the latter, when you <code>load()</code> the data, the original object names are automatically used. Automatically using the original object names can sometimes simplify a workflow, but it can also be a drawback if the data object is meant to be distributed to others for use in a different environment.


<h2>Debugging a script or function</h2>
    <h3>Problem</h3>
You want to debug a script or function.


<h3>Solution</h3>
Insert this into your code at the place where you want to start debugging:


browser()

When the R interpreter reaches that line, it will pause your code and you will be able to look at and change variables.


In the browser, typing these letters will do things:


<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>c</td>
      <td>Continue</td>
    </tr>
    <tr>
      <td>n (or Return)</td>
      <td>Next step</td>
    </tr>
    <tr>
      <td>Q</td>
      <td>quit</td>
    </tr>
    <tr>
      <td>Ctrl-C</td>
      <td>go to top level</td>
    </tr>
  </tbody>
</table>

When in the browser, you can see what variables are in the current scope.


ls()

To pause and start a browser for every line in your function:


debug(myfunction)
myfunction(x)

<h3>Useful options</h3>
By default, every time you press Enter at the browser prompt, it runs the next step. This is equivalent to pressing <code class="highlighter-rouge">n</code> and then Enter. This can be annoying. To disable it use:

options(browserNLdisabled=TRUE)

To start debugging whenever an error is thrown, run this before your function which throws an error:


options(error=recover)

If you want these options to be set every time you start R, you can put them in your ~/.Rprofile file.

<h2>Options Settings</h2>
options(digits = 3)

Usage
options(...)
getOption(x)
.Options

Arguments
...	any options can be defined, using name = value. However, only the ones below are used in ``base R''.
Further, options('name') == options()['name'], see the example.

prompt	a string, used for R's prompt; should usually end in a blank (" ").
continue	a string setting the prompt used for lines which continue over one line.
width	controls the number of characters on a line. You may want to change this if you re-size the window that R is running in.
digits	controls the number of digits to print when printing numeric values. It is a suggestion only.
editor	sets the default text editor, e.g., for edit. Set from the environment variable VISUAL on UNIX.
pager	the (stand-alone) program used for displaying ASCII files on R's console. Defaults to `$R_HOME/bin/pager' on UNIX.
browser	default HTML browser used by help.start() on UNIX.
mailer	default mailer used by bug.report(). can be "none".
contrasts	the default contrasts used in model fitting such as with aov or lm. A character vector of length two, the first giving the function to be used with unordered factors and the second the function to be used with ordered factors.
expressions	sets a limit on the number of nested expressions that will be evaluated. This is especially important on the Macintosh since stack overflow is likely if this is set too high.
keep.source	When TRUE, the default, the source code for functions loaded by is stored in their "source" attribute, allowing comments to be kept in the right places. This does not apply to functions loaded by library.
na.action	the name of a function for treating missing values (NA's) for certain situations.
papersize	the paper format used for graphics printing; currently read-only, set by environment variable R_PAPERSIZE, or in `config.site'.
printcmd	the command used for graphics printing; currently read-only, set by environment variable R_PRINTCMD, or in `config.site'.
show.signif.stars, show.coef.Pvalues	logical, affecting P value printing, see print.coefmat.
ts.eps	the relative tolerance for certain time series (ts) computations.
error	an expression governing the handling of non-catastrophic errors such as those generated by stop as well as by signals and internally detected errors. The default expression is NULL: see stop for the behaviour in that case. The function dump.frames provides one alternative that allows post-mortem debugging.
show.error.messages	a logical. Should error messages be printed? Intended for use with try or a user-installed error handler.
warn	sets the handling of warning messages. If warn is negative all warnings are ignored. If warn is zero (the default) warnings are stored until the top–level function returns. If fewer than 10 warnings were signalled they will be printed otherwise a message saying how many (max 50) were signalled. A top–level variable called last.warning is created and can be viewed through the function warnings. If warn is one, warnings are printed as they occur. If warn is two or larger all warnings are turned into errors.
echo	logical. Only used in non-interactive mode, when it controls whether input is echoed. Command-line options --quiet and --slave set this initially to FALSE.
verbose	logical. Should R report extra information on progress? Set to TRUE by the command-line option --verbose.
device	a character string giving the default device for that session.
CRAN	The URL of the preferred CRAN node for use by update.packages. Defaults to http://cran.r-project.org.
unzip	the command used unzipping help files. Defaults to "internal" when the internal unzip DLL is used.
x	a character string holding one of the above option names.

Details
Invoking options() with no arguments returns a list with the current values of the options. 
To access the value of a single option, one should use getOption("width"), e.g., rather than options("width") which is a list of length one.

The default settings of some of these options are
prompt	"> "	continue	"+ "
width	80	digits	7
expressions	500	keep.source	TRUE
show.signif.stars	TRUE	show.coef.Pvalues	TRUE
na.action	na.omit	ts.eps	1e-5
error	NULL	warn	0
echo	TRUE	verbose	FALSE
Others are set from environment variables or are platform-dependent.

Value
A list (in any case) with the previous values of the options changed, or all options when no arguments were given.

Examples
options() # printing all current options
op = options(); str(op) # nicer printing

# .Options is the same:
all(sapply(1:length(op), function(i) all(.Options[[i]] == op[[i]])))

options('width')[[1]] == options()$width # the latter needs more memory
options(digits=20)
pi

# set the editor, and save previous value
old.o = options(editor="nedit")
old.o

options(op)     # reset (all) initial options
options('digits')

## set contrast handling to be like S
options(contrasts=c("contr.helmert", "contr.poly"))

## on error, terminate the R session with error status 66
options(error=quote(q("no", status=66, runLast=FALSE)))
stop("test it")

options(papersize="a4")	
options(editor="notepad")	
options(tab.width = 2)	
options(width = 130)	
options(digits=4)	
options(stringsAsFactors=FALSE)	
options(show.signif.stars=FALSE)	
grDevices::windows.options(record=TRUE)
options(prompt="> ")	
options(continue="+ ")	
.libPaths("C:/my_R_library")	
local({r = getOption("repos")	
     r["CRAN"] = "http://cran.case.edu/"	
     options(repos=r)})	

 .First = function(){	
 library(lattice)	
 library(Hmisc)	
 source("C:/mydir/myfunctions.R")	
 cat("\nWelcome at", date(), "\n")	
}	
.Last = function(){	
 cat("\nGoodbye at ", date(), "\n")	
}	

<h2>data.table vs data.frame</h2>
<a href="data.table vs data.frame.html">data.table vs data.frame</a>
<a href="Introduction to data.table.html">Introduction to data.table</a>
<a href="http://rstudio-pubs-static.s3.amazonaws.com/52230_5ae0d25125b544caab32f75f0360e775.html">JOINing data in R using data.table</a>
<a href="Advanced tips and tricks with data.table.html"><span class="goldwhiteb">&diams;Advanced tips and tricks with data.table</span></a>

X = data.table(a=1:5, b=6:10, c=c(5:1))

length(X[b %between% c(7,9)])
length(X[b %inrange% c(7,9)])

# inrange()
Y = data.table(a=c(8,3,10,7,-10), val=runif(5))
range = data.table(start = 1:5, end = 6:10)
Y[a %inrange% range]

https://stackoverflow.com/questions/16652533/insert-a-row-in-a-data-table
insert-a-row-in-a-data-table
dt1 &lt;- list(1,4,7)
rbind(dt1, X)

dt1 &lt;- data.table(1,4,7)
rbindlist(list(dt1, X))

===================
use data.frame
df &lt;- data.frame( name=c("John", "Adam"), date=c(3, 5) )

Extract exact matches:

subset(df, date==3)
nrow(subset(df, date==3))

Extract matches in range:

subset(df, date>4 & date&lt;6)

  name date
2 Adam    5



<h2>DiagrammeR</h2>
<a href="http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html">DiagrammeR</a><br>
<a href="DiagrammeR Docs.html">DiagrammeR Docs</a>

<h2>ROC Curves</h2>
<a href="ROC Curves.html">ROC Curves</a>
<h2>capture.output to file</h2>
capture.output(options(), file="temp.txt")

capture.output to string vector
outvec= capture.output(options())

<h2>writing functions</h2>

a simple function:

square = function(x){x*x}

to square a vector:

x = c(1,3,5)
square(x)

to square a matrix:
x = cbind(c(1,3),c(5,7))
square(x)

to return a list of objects, use list():
square = function(x){return(list(x*x,x*x*x))}
square(x)

using debug() to debug:
debug(square)
square(x-a)

using print to debug in function:
square = function(x){
print(x)
print(x*x)
x*x
}

using stop() and stopifnot() to write your own error msg:
squareRoot = function(x){
	if(x&lt;0){
		stop("cannot use negative number!")
	}
	sqrt(x)
}
squareRoot(-1)

good function practices:
keep short function
write comments
try with examples
use debug and error msg

<h2>For Loop in R with Examples</h2>
<a href="https://www.guru99.com/r-for-loop.html">For Loop in R with Examples</a>

<h2>case_when and switch</h2>

switch("shape", "color" = "red", "shape" = "square", "length" = 5)

library(dplyr)
Length=3.5
mode &lt;- case_when(
                (Length < 1) ~ "Walk",
                (1 <= Length & Length < 5) ~ "bike",
                (5 <= Length & Length < 10) ~ "drive",
                (Length >= 10) ~ "fly"
          )

<h2>Calling multiple external program from R</h2>

<a href="https://stackoverflow.com/questions/21966209/calling-external-program-from-r-with-multiple-commands-in-system">Calling multiple external program from R</a>
for(i in 1:10){
cmd=paste("export FOO=",i," ; echo \"$FOO\" ",sep='')
system(cmd)
}

<h2>rmItems</h2>
# rmItems(fmList, itemList) remove itemList from fmList
 rmItems &lt;- function(fmList, itemList){return(fmList [! fmList %in% itemList])}

fmList = 1:10
itemList = c(2,4,5)
rmItems(fmList, itemList)

# remove fraudSTK
 CodeTable = rmItems(CodeTable, fraudSTK)

milList8 = c("a","b","c","d")
milList20 = c("a","b","c","f")
setdiff(fmList,itemList)


<h2>R porjects</h2>
<a href="R porjects.html">R porjects</a>

<h2>call C from R</h2>
<a href="call C from R.html">♦call C from R</a>
<a href="http://adv-r.had.co.nz/C-interface.html" class="whitebut ">R’s C interface</a>
<a href="http://adv-r.had.co.nz/" class="whitebut ">Advanced R by Hadley Wickham</a>
<a href="https://www.r-bloggers.com/2012/11/using-r-calling-c-code-hello-world/" class="whitebut ">Using R — Calling C Code</a>
<a href="https://www.r-bloggers.com/2014/02/three-ways-to-call-cc-from-r/" class="whitebut ">Three ways to call C/C++ from R</a>
<a href="https://stackoverflow.com/questions/28026818/how-to-call-c-function-from-r" class="whitebut ">call C function from R</a>

<h2>Make R Beep</h2>

<a href="https://www.geoffchappell.com/studies/windows/win32/kernel32/api/index.htm">KERNEL32 Functions</a>
<a href="https://stackoverflow.com/questions/3365657/is-there-a-way-to-make-r-beep-play-a-sound-at-the-end-of-a-script">Make R Beep</a>

rundll32.exe Kernel32.dll,Beep 550,1000
rundll32.exe cmdext.dll,MessageBeepStub
rundll32 user32.dll,MessageBeep
BOOL Beep(
  DWORD dwFreq,
  DWORD dwDuration
);

C:\Windows\Media\Delta

install.packages("audio") 
library(audio)

# play(x, rate, ...)
# x = audioSample(sin(1:8000/10), 8000)
# play(x)
# 10000 is the set of numbers, 10 is the freq code

play(sin(c(2000:1000,1500:2000) / 3))

play(sin(1:10000/3))
Sys.sleep(1)
play(sin(1:10000/4))
Sys.sleep(1)
play(sin(1:10000/5))
Sys.sleep(1)
play(sin(1:10000/6))
Sys.sleep(1)
play(sin(1:10000/7))
Sys.sleep(1)
play(sin(1:10000/8))
Sys.sleep(1)
play(sin(1:10000/9))
Sys.sleep(1)
play(sin(1:10000/10))
Sys.sleep(1)
play(sin(1:10000/20))
Sys.sleep(1)
play(sin(1:10000/30))
Sys.sleep(1)

The alarm function. It works by sending \a to the console
alarm()
cat('Hello world!\a')

alarm doesn't work so created a function that does actually make noise.

beep = function(n = 3){
    for(i in seq(n)){
        system("rundll32 user32.dll,MessageBeep -1")
        Sys.sleep(.5)
    }
}

On MacOSX you can let the computer speak:
system("say Just finished!")
and you can also change the artificial voice that will speak:
system("say -v Kathy Just finished!")

Use shell.exec("url") to open some YouTube clip on Windows

playing some music
shell.exec("foo/Born.to.be.wild.mp3")

Use notify-send command:
system("notify-send \"R script finished running\"")

Plays a typical Windows sound, which is usually on any Windows

#Function with loop, press Esc to stop

    alarm3 = function(){
        system("cmd.exe",input="C:/Windows/WinSxS/amd64_microsoft-windows-shell-sounds_31bf3856ad364e35_10.0.17134.1_none_fc93088a1eb3fd11/tada.wav")
        Sys.sleep(1)
    }

shell("C:/Users/User/Music/freesound/cmdmp3.exe C:/Users/User/Music/freesound/12.mp3")

<h2>Play a random sound</h2>
# Update all packages and "ping" when it's ready
# danger! will take a long time and may get wrong result

library(beepr)
update.packages(ask=FALSE); beep()

#Play a fanfare instead of a "ping".
beep("fanfare")
#or
beep(3)

# Play a random sound
beep(0)

beep(sound = 1, expr = NULL)
Arguments
sound character string or number specifying what sound to be played by either specifying one of the built in sounds or specifying the path to a wav file. The default is 1.
Possible sounds are:
"ping" "coin" "fanfare" "complete" "treasure" "ready" "shotgun" "mario" "wilhelm" "facebook" "sword"
beep("shotgun")

library(beepr)

alist = c("ping", "coin", "fanfare", "complete", "treasure", "ready", "shotgun", "mario", "wilhelm", "facebook", "sword")
for(item in alist){
   cat(item, "\n")
   beep(item)
   Sys.sleep(5)
}


<h2>read clipboard</h2>

simply use: readClipboard()

this gives too many columns:
read.table(file = "clipboard", sep = ",")

<h2>dplyr Data Manipulation</h2>
<a href="dplyr Data Manipulation.html">dplyr Data Manipulation</a>

<h2>Language Server Protocol</h2>
<a href="D:\R-3.4.3\bin\x64\R.exe">install.packages("languageserver") Language Server Protocol:</a>
Adding features like auto complete, go to definition, or documentation on hover for a programming language takes significant effort.

<h2>to run R by batch script</h2>
Rscript.exe  alert.r
Rscript.exe  something.r

Note: Rscript.exe cannot run with Chinese

calling chrome by batch script in sequence
can also call by R

<a href="https://kknews.cc/tech/92k2828.html">R与中文那些事 R script with Chinese</a>

<a href="https://stackoverflow.com/questions/31190468/integrating-r-and-its-graphics-with-existing-javascript-html-application"><k>R and Javascript : Execution, Libraries, Integration</k></a>

<h2>Create Apps with Rt</h2>
<a href="https://www.r-bloggers.com/deploying-desktop-apps-with-r/">Create Apps with R</a>


<h2>Integrate R into JavaScript</h2>
There can be various ways through which you can integrate R with JavaScript. 
Here I am discussing the following methods that I prefer for Rand Javascript integration.
<k>1. Deploy R open</k>
<a href="https://mran.microsoft.com/documents/getting-started" class="whitebut ">R open</a>
Through Deploy R opens you can easily embed results of various R functions like- data and charts into any application. 
This specific structure is an open source server-based system planned especially for R, which makes it simple to call the R code at a real time.
The workflow for this is simple: first, the programmer develops R script which is then published on the Deploy R server. 
The published R script that can be executed from any standard application using DeployR API. 
Using client libraries JavaScript now can make calls to the server. 
The results returned by the call can be embedded into the displayed or processed according to the application.
<k>2. Open CPU JavaScript API</k>
This offers straightforward RPC and information input/Output through Ajax strategies that can be fused in JavaScript of your HTML page.

<h2>Visualization with R and JavaScript</h2>
<a href="R Graph Gallery.html" class="goldbut red bluegrad">R Graph Gallery</a>
You can make use of numerous JavaScript libraries that help in creating web functionality for dynamic data visualizations for R.
Here I will be elaborating some of those tools like D3, Highchart, and leaflet. 
You can quickly implement these tools in your R and program knowledge of JavaScript is not mandatory for this.
As I have already mentioned that R is an open source analytical software, it can create high dimensional data visualizations. 
Ggplot2 is a standout among the most downloaded bundle that has helped R to accomplish best quality level as a data visualization tool.
Javascript then again is a scripting dialect in which R can be consolidated to make data visualisation. 
Numerous javascript libraries can help in creating great intuitive plots, some of them are d3.Js, c3.js, vis.js, plotly.js, sigma.js, dygraphs.js.
HTM widgets act as a bridge between R and JavaScript. 
It is the principal support for building connectors between two languages. 
The flow of a program for HTM widgets r can be visualized as under:
• Information is perused into R
• Data is handled (and conceivably controlled) by R
• Data is changed over to JavaScript Object Notation (JSON) arrange
• Information is bound to JavaScript
• Information is prepared (and conceivably controlled) by JavaScript
• Information is mapped to plotting highlights and rendered
Now let us discuss some of the data visualization packages:
<k>• r d3 package</k>
Data-driven documents or d3 is one of the popular JavaScript visualization libraries. 
D3 can produce visualization for almost everything including choropleths, scatter plots, graphs, network visualizations and many more. 
Multiple R packages are using only D3 plotting methods. 
You can refer r d3 package tutorials to learn about this.

<a href="https://datatricks.co.uk/creating-a-d3-js-bar-chart-in-r" class="whitebut ">Creating a D3.js bar chart in R</a>

<a href="https://blog.rstudio.com/2018/10/05/r2d3-r-interface-to-d3-visualizations/" class="whitebut ">r2d3 - R Interface to D3 Visualizations</a>
<a href="https://rstudio.github.io/r2d3/" class="whitebut ">r2d3: R Interface to D3 Visualizations</a>
<a href="https://rstudio.github.io/r2d3/articles/learning_d3.html" class="whitebut ">Learning D3</a>
<a href="https://rstudio.github.io/r2d3/articles/gallery.html" class="whitebut ">r2d3 examples</a>
• <k>ggplot2</k> <br> <br> It is really very easy to create plots in R, but you may ask me whether it is same for creating custom plots, the answer is “yes”, and that is the primary motivation behind why ggplot came into existence. 
With ggplot, you can make complex multi-layered designs effectively.
Here you can start plotting with axes then add points and lines. 
But the only drawback that it has it is relatively slower than base R, and new developers might find it difficult to learn.
• <k>Leaflet</k>
The leaflet has found its profound use in GIS (mapping), this is an open source library. 
The R packages that backings this is composed and kept up by RStudio and ports. 
Using this developer can create pop up text, custom zoom levels, tiles, polygon, planning and many more.
The ggmap bundle of javaScript can be utilised for the estimation of the latitude and longitude.
• <k>Lattice</k>
Lattice helps in plotting visualized multivariate data. 
Here you can have tilled plots that help in comparing values or subgroups of a given variable. 
Here you will discover numerous lattice highlights has been acquired as utilizes grid package for its usage. 
The underlying logic used by lattice is very much similar to base R.
<k>• visNetwork</k>
For the graphical representation of nodes and edges, the visual network is referred. 
Vis.js is a standout amongst the most famous library among numerous that can do this sort of plotting. 
visNetwork is the related with R package for this.
Network plots ought to be finished remembering nodes and edges. 
For visNetwork, these two should be separated into two different data frames one for the nodes and the other
<k>• Highcarter</k>
This is another visualization tool which is very similar to D3. 
You can use this tool for a variety of plots like line, spline, arealinerange, column range, polar chart and many more. 
For the commercial use of Highcarter, you need to get a license while for the non-commercial you don’t need one.
Highcarter library can be accessed very easily using various chart () functions. 
Using this function, you can create a plot in a single task. 
This function is very much similar to qplot() of ggplot2 of D3. 
chart () can produce different types of scenarios depending on the data inputs and specifications.
<k>• RColor Brewer</k>
With this package, you can use color for your plots, graphs, and maps. 
This package works nicely with schemes.
<k>• Plotly</k>
It is a well distinguish podium for data visualization that works inordinately with R and Python notebook. 
It has similarity with the high career as both are known for interactive plotting. 
But here you get some extra as it offers something that most of the package don’t like contour plots, candlestick chart, and 3d charts.
• <k>SunTrust</k>
It is the way for representing data visualization as it nicely describes the sequence of events. 
The diagram that it produces speaks about itself. 
You don’t need an explanation for the chart as it is self-explanatory.
• <k>RGL</k>
For creating three-dimensional plots in R you should check out RGL. 
It has comparability with lattice, and on the off chance that you are an accomplished R developer you will think that its simple.
<k>• Threejs</k>
This is an R package and an HTML widget that helps in incorporating several data visualization from the JavaScript library.
Some of the visualization function three are as follows:
• Graphjs: this is used for implementing 3D interactive data visualization. 
This function accepts igraph as the first argument. 
This manages definition for nodes and edges.
• Scatterplot3js: this function is used for creating three dimensional scatter plot.
• Globejs: this function of JavaScript is used for plotting surface maps and data points on earth.
• <k>Shiny</k>
The most significant benefit of JavaScript visualization is it can be implanted voluntarily into the web application. 
They can be injected into several frameworks, one of such context of R development is shiny.
Shiny is created and maintained by R Studio. 
It is a <a href="https://www.cuelogic.com/custom-software-development" data-href="https://www.cuelogic.com/custom-software-development" target="_blank">software application development</a> instrument, to a great extent employed for making wise interfaces with R. 
R shiny tutorial will take in more about shiny.
Shiny is a podium for facilitating R web development.
Connecting R with javascript using libraries
Web scuffling has formed into an original piece of examination as through this movement you can pucker your required information. 
But the data should be extracted before any web developer start to insert javascript render content into the web page. 
To help in such situation R has an excellent package called V8 which acts as an interface to JavaScript. 
R v8 is the most generally utilized capacity utilized for interfacing r in javascript. 
You can undoubtedly implement JS code in R without parting the current session. 
The library function used for this is rvest().
To run the JavaScript in R, we need a context handler, within that context handler you can start programming. 
Then you can export the R data into JavaScript.
Some other JavaScript libraries that help in analytical programming such as Linear Regression, SVMs etc. 
are as follows:
• Brain.js()
• Mljs
• Webdnn
• Convnetjs

<a href="https://hackernoon.com/r-and-javascript-execution-libraries-integration-40a30726f295">Integrating R and Javascript/HTML Application</a>
<h2>Rserve package</h2>
There is javascript implementation of Rserve client available rserve-js.
You can call R from javascript efficiently using Rserve package. 

<h2>FastRWeb</h2>
FastRWeb is an infrastructure that allows any webserver to use R scripts for generating content on the fly, such as web pages or graphics. 
URLs are mapped to scripts and can have optional arguments that are passed to the R function run from the script. 
For example http://my.server/cgi-bin/R/foo.png?n=100 would cause FastRWeb to look up a script foo.png.R, source it and call run(n="100"). 
So for example the script could be as simple as

run &lt;- function(n=10, ...) {
   p &lt;- WebPlot(800, 600)
   n &lt;- as.integer(n)
   plot(rnorm(n), rnorm(n), col=2, pch=19)
   p
}
This can potentially then be called using JavaScript to dynamically load images and display them.

<a href="https://stackoverflow.com/questions/22179512/suggestions-needed-for-building-r-server-rest-apis-that-i-can-call-from-externa/29537593#29537593">building R server REST API's that I can call from external app</a>
<h2>httpuv</h2>
You can use httpuv to fire up a basic server then handle the GET/POST requests. The following isn't "REST" per se, but it should provide the basic framework:

library(httpuv)
library(RCurl)
library(httr)

app &lt;- list(call=function(req) {

  query &lt;- req$QUERY_STRING
  qs &lt;- httr:::parse_query(gsub("^\\?", "", query))

  status &lt;- 200L
  headers &lt;- list('Content-Type' = 'text/html')

  if (!is.character(query) || identical(query, "")) {
    body &lt;- "\r\n<html><body></body></html>"
  } else {
    body &lt;- sprintf("\r\n<html><body>a=%s</body></html>", qs$a)
  }

  ret &lt;- list(status=status,
              headers=headers,
              body=body)

  return(ret)

})

message("Starting server...")

server &lt;- startServer("127.0.0.1", 8000, app=app)
on.exit(stopServer(server))

while(TRUE) {
  service()
  Sys.sleep(0.001)
}

stopServer(server)

<h2>Cucumber Selenium</h2>
<a href="https://www.guru99.com/using-cucumber-selenium.html">Cucumber Selenium</a>
<a href="https://www.youtube.com/watch?v=ZSfOEBh9BRM">Cucumber Selenium Tutorial</a>
<a href="https://blog.gtwang.org/r/rselenium-r-selenium-browser-web-scraping-tutorial/">RSelenium：R 使用 Selenium 操控瀏覽器下載網頁資料</a>

<h2>SQL databases and R</h2>
<a href="https://datacarpentry.org/R-ecology-lesson/05-r-and-databases.html">SQL databases and R</a>

<h2>SQLite</h2>
<a href="https://db.rstudio.com/databases/sqlite/">R SQLite</a>

install.packages("RSQLite")

Or install the latest development version from GitHub with:

devtools: Tools to Make Developing R Packages Easier

sometimes use remotes:
remotes::install_github()
remotes::install_github("kbroman/broman")

# install.packages("devtools")
devtools::install_github("rstats-db/RSQLite")

To install from GitHub, you’ll need a development environment.

Basic usage
library(DBI)
# Create an ephemeral in-memory RSQLite database
con &lt;- dbConnect(RSQLite::SQLite(), ":memory:")

dbListTables(con)
## character(0)
dbWriteTable(con, "mtcars", mtcars)
dbListTables(con)
## [1] "mtcars"
dbListFields(con, "mtcars")
##  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
## [11] "carb"
dbReadTable(con, "mtcars")
##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## 1  21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
...

# You can fetch all results:
res &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
dbFetch(res)
##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
## 1  22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
...

dbClearResult(res)

# Or a chunk at a time
res &lt;- dbSendQuery(con, "SELECT * FROM mtcars WHERE cyl = 4")
while(!dbHasCompleted(res)){
  chunk &lt;- dbFetch(res, n = 5)
  print(nrow(chunk))
}
## [1] 5
## [1] 5
## [1] 1
# Clear the result
dbClearResult(res)

# Disconnect from the database
dbDisconnect(con)
Acknowledgements
Many thanks to Doug Bates, Seth Falcon, Detlef Groth, Ronggui Huang, Kurt Hornik, Uwe Ligges, Charles Loboz, Duncan Murdoch, and Brian D. 
Ripley for comments, suggestions, bug reports, and/or patches.



<h2>Invoking the Rstudio Viewer</h2>
viewer &lt;- getOption("viewer")
viewer("<a href="https://www.rt.com/")">viewer("C:/Users/User/Desktop/Debugging with RStudio.html")</a>

<h2>to sum only elements greater than 5</h2>
a&lt;-sample.int(10,20,replace=TRUE)
sum(a[a>5])

<h2>Customizing RStudio themes</h2>
<a href="https://www.r-bloggers.com/make-rstudio-look-the-way-you-want-because-beauty-matters/">Make RStudio Beauty</a>

D:\RStudio\www\rstudio\806BBC582D6B8DF91384AD7E3EFC9A52.cache.css

<a href="https://support.rstudio.com/hc/en-us/articles/200532307-Customizing-Fonts-and-Appearance">Customizing Fonts and Appearance</a>

<h2>table()</h2>
table()的输出可以看成是一个带名字的数字向量。
可以用names()和as.numeric()分别得到名称和频数：> 

x &lt;- sample(c("a", "b", "c"), 100, replace=TRUE)
tablex = table(x)

names(tablex)
[1] "a" "b" "c"

> as.numeric(tablex)
[1] 42 25 33

可以直接把输出结果转化为数据框，as.data.frame()：> 
as.data.frame(tablex)
  x Freq
1 a   42
2 b   25
3 c   33

<h2>with(data, expr, …)</h2>
applys an expression to a dataset.
eg
with(BOD,{BOD$demand &lt;- BOD$demand + 1; print(BOD$demand)})

<h2>R regular expression</h2>
<a href="https://blog.yjtseng.info/post/regexpr/">R regex</a>

<h2>R Operator Syntax</h2>
<a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html">R Operator Syntax and Precedence</a>

:: :::	access variables in a namespace
$ @	component / slot extraction
[ [[	indexing
^	exponentiation (right to left)
- +	unary minus and plus
:	sequence operator
%any%	special operators (including %% and %/%)
* /	multiply, divide
+ -	(binary) add, subtract
< > <= >= == !=	ordering and comparison
!	negation
& &&	and
| ||	or
~	as in formulae
-> ->>	rightwards assignment
&lt;- <&lt;-	assignment (right to left)
=	assignment (right to left)
?	help (unary and binary)

%%  indicates x mod y (“x modulo y”)     # modulo 餘數
%/% indicates integer division           # quotient 商

exampleRPackage
The exampleRPackage can be installed from github:

# install.packages("devtools")
devtools::install_github("mvuorre/exampleRPackage")

The file you are reading now is the package’s README, which describes how to create R packages with functions, data, and appropriate documentation. 


A Simple Example of Using replyr::gapply
It’s a common situation to have data from multiple processes in a “long” data format. 
It’s also natural to split that data apart to analyze or transform it, per-process — and then to bring the results of that data processing together, for comparison. 
Such a work pattern is called “Split-Apply-Combine”. 
A simple example of one such implementation, replyr::gapply, from package, replyr.

K-means clustering
K-means is a clustering techniques that subdivide the data sets into a set of k groups, where k is the number of groups pre-specified by the analyst.

Determining the optimal number of clusters: use factoextra::fviz_nbclust()


<h2>树状图</h2>
<a href="Dendrograms in R.html" target="_blank">Dendrograms in R</a>
<h2>shiny and rpanel - a quick comparison</h2>

Shiny is a package from RStudio that lets you produce interactive web pages. 
You build a page with some control widgets and a handler that does something dependent on the value of those widgets. 
You can build your interface programmatically or create a boilerplate html page that gets filled in by control and output widgets.

A conceptually similar pattern is implemented by the rpanel package, but this uses the tcltk toolkit. 
A panel is created, control widgets added, and callbacks on the controls can run R code to, for example, update a plot.

qq plot example
Here's the rpanel version:

require(rpanel)
# box-cox transform
bc.fn &lt;- function(y, lambda) {
    if (abs(lambda) < 0.001) 
        z &lt;- log(y) else z &lt;- (y^lambda - 1)/lambda
}

# qqplot of transformed data
qq.draw &lt;- function(panel) {
    z &lt;- bc.fn(panel$y, panel$lambda)
    qqnorm(z, main = paste("lambda =", round(panel$lambda, 2)))
    panel
}

# create a new panel with some initial data
panel &lt;- rp.control(y = exp(rnorm(50)), lambda = 1)

# add a slider that calls qq.draw on change
rp.slider(panel, lambda, -2, 2, qq.draw)

Run these functions and you should see a slider and a graphics window. 
Move the slider to modify the plot.
Note that this might not work too well under RStudio because of the way the embedded RStudio graphics device captures output.


And here is the shiny version, which comes in two files living in their own folder.  ui.R and server.R

First qqplot/ui.R:

library(shiny)
# this defines our page layout
shinyUI(pageWithSidebar(
  headerPanel("qqplot example"),
  sidebarPanel(
  # a slider called 'lambda':
    sliderInput("lambda", "Lambda value", min = -2, max = 2, step=0.01, value = 0)
  ),
  mainPanel(
    # the main panel is the plotted output from qqplot:
    plotOutput("qqPlot")
  )
))

and qqplot/server.R:

library(shiny)
shinyServer(function(input, output) {
    # b-c transform
    bc.fn &lt;- function(y, lambda) {
        if (abs(lambda) < 0.001) 
            z &lt;- log(y) else z &lt;- (y^lambda - 1)/lambda
    }
    # initial data
    y = exp(rnorm(50))
    # here's the qqplot method:
    output$qqPlot &lt;- reactivePlot(function() {
        z &lt;- bc.fn(y, input$lambda)
        qqnorm(z, main = paste("lambda =", round(input$lambda, 2)))
    })
})

With that done, launch the app with:

runApp("qqplot")
that should open up the page in your web browser. 
Hit break, stop, or control-C to quit.


Notes
The rpanel plot updates as you drag the slider, whereas shiny updates only when you let go of the slider.

I find that when I hit Control-C and break a running shiny app, then my tcltk windows go all unresponsive until I quit R and start again. 
Threading issues? This is on Linux. 
I've always had problems with tcltk widgets going unresponsive on me, or ending up unkillable.

The shiny UI looks, well, “shiny”, but the rpanel interface looks a bit old and not very exciting (if you can get excited by user interfaces).

Using the tkrplot package, you can build integrated rpanel packages with controls and plots in the same window. 
Without it, you are stuck with separate graphics and control windows.

Which should I use?
How do I know?! Shiny looks better, but I do like the update on drag of rpanel - it gives you much better feedback as you control the plot. 
Maybe this can be done in shiny with some additional work.

I don't really like the two-file method of shiny. 
Looking at the code I see the files just get sourced in, so conceivably it could be possible to run shiny apps just by specifying the shinyServer and shinyUI functions - but shiny monitors the server.R and ui.R file for changes and updates the application, which is quite nice.

So there's the basic existential dilemma. 
Choice. 
I can even throw some more things into the mix if you want - there' RServe, or RApache with gWidgetsWWW and probably many many more. 
I'm sure we can all agree that the days of needing Java and Apache Tomcat to deploy R applications to the web are now over (http://sysbio.mrc-bsu.cam.ac.uk/Rwui/tutorial/quick_tour.html).

I might try and implement some more of the rpanel examples in shiny shortly. 
Or why don't you have a go, and publish your works here?

<h2>R GUI 視窗程式設計</h2>
<a href="http://www.hmwu.idv.tw/web/R/F01-hmwu_R-GUI-Design.pdf">R GUI 視窗程式設計 tcltk/tcltk2, rpanel</a>
<a href="http://adrian.waddell.ch/EssentialSoftware/Rtcltk_geometry.pdf">Rtcltk_geometry</a>

<a href="http://rstudio-pubs-static.s3.amazonaws.com/2666_f0de0980ac9048d0a71d0f507cd83c3f.html">shiny and rpanel - a quick comparison</a>

<h3>rpanel sample</h3>
<a href="https://www.academia.edu/370260/rpanel_Simple_Interactive_Controls_for_R_Functions_Using_the_tcltk_Package_9999_">rpanel: Simple Interactive Controls for R Functions Using the tcltk Package </a>
<a href="https://www.academia.edu/attachments/1880059/download_file?st=MTU2NDAxOTg4MywxODIuMjM5LjExNS4zNg%3D%3D&s=swp-splash-header">download rpanel sample</a>
<a href="www.stats.gla.ac.uk/~adrian/rpanel">The `rpanel' package</a>
<a href="http://www.stats.gla.ac.uk/~adrian/rpanel/scripts/rpanel-paper-scripts.r">Simple Interactive Controls for R Functions scripts</a>

library(rpanel)
x11(width=4,height=4)
qq.draw &lt;- function(panel)
 { z &lt;- bc.fn(panel$y, panel$lambda)
   qqnorm(z, main = paste("lambda =",round(panel$lambda, 2)))
   panel
 }
 panel &lt;- rp.control(y = exp(rnorm(50)), lambda = 1)
 rp.slider(panel, lambda, -2, 2, qq.draw,showvalue = TRUE)


<h3>create a  matrix</h3>
A = matrix( 
c(2, 4, 3, 1, 5, 7), # the data elements 
nrow=2,              # number of rows 
ncol=3,              # number of columns 
byrow = TRUE)        # fill matrix by rows 


<h2>cross tabulations</h2>
<a href="Contingency Table.html" class="bordred2 borRad10 green whitebs">Contingency Table</a>  <a href="Xtabs exercises.html" class="bordred2 borRad10 white whitebs">Xtabs exercises</a> 

a chart is different from a table
a chart is a graphic representation
a table is a numeric representation

frequaency table is a single row table

cross tabulations, 列联表, contingency tables, 又称交互分类表 按两个或更多变量分类时所列出的频数表。

R provides many methods for creating frequency and contingency tables. 

generate frequency tables using the table( ) function, table( ) function can also create cross tab, table( ) can also generate multidimensional tables based on 3 or more categorical variables.

generate tables of proportions using the prop.table( ) function
generate marginal frequencies using margin.table( )

# 2-Way Frequency Table using table() function
attach(mtcars)
mytable &lt;- table(mtcars$gear,mtcars$cyl) # A will be rows, B will be columns 
mytable # print table 

# 2-Way Frequency Table using xtabs()
y = xtabs(~ cyl + gear, mtcars)	# xtabs gives row and col labels

margin.table(mytable, 1) # A frequencies (summed over B) 
margin.table(mytable, 2) # B frequencies (summed over A)

prop.table(mytable) # cell percentages
prop.table(mytable, 1) # row percentages 
prop.table(mytable, 2) # column percentages

# 3-Way Frequency Table 
mytable &lt;- table(A, B, C) 
mytable &lt;- table(mtcars$gear,mtcars$cyl,mtcars$mpg)
mytable

# 3-Way Frequency Table
mytable &lt;- xtabs(~A+B+c, data=mydata)
mytable &lt;- xtabs(~gear+cyl+mpg, mtcars)
summary(mytable) # chi-square test of indepedence

<a href="https://www.statmethods.net/stats/frequencies.html">Frequencies and Crosstabs</a>

<h2>parallel 平行計算</h2>
<a href="https://blog.gtwang.org/r/r-parallel-computing-module-tutorial/">R 的 parallel 平行計算套件使用教學與範例</a>
<a href="How-to go parallel in R.html">How-to go parallel in R</a>
<h2>edply</h2>
<a href="https://www.r-bloggers.com/edply-combining-plyr-and-expand-grid/">edply: combining plyr and expand.grid</a>

<h2>column merge two tables</h2>
lista = c(1:5)
listb = c(6:10)
listc = paste0(lista, "  ",listb)
lista
listb
listc
1 2 3 4 5
6 7 8 9 10
"1 6" "2 7" "3 8" "4 9" "5 10"

data from files:
lista = readLines("list1.txt")
listb = readLines("list2.txt")
listc = paste0(lista, "  ",listb)
sink("list3.txt")
cat(listc, sep="\n")
sink()

note: may use cbind in dataframe
lista = c(1:5)
listb = c(6:10)
listc = c(11:15)
MC = matrix()  # this is an empty matrix

MB = matrix( c(lista,listb,listc), nrow=5, ncol=3)  # a 3 column matrix
MC = cbind(MB[,1],MB[,3])   # now MC is a two column matrix

<h2>chop in blocks</h2>
groupPageNum = 7
theList = 1:78
if(length(theList)%%groupPageNum==0){
  pageNo = length(theList)%/%groupPageNum
}else{
  pageNo = length(theList)%/%groupPageNum +1
}
pageNo


for(page in 1:pageNo){
  if(length(theList) > groupPageNum){
	thepage= theList[1:groupPageNum]
	theList= theList[-(1:groupPageNum)]
     arrangePages(thepage)
	page = page + 1
  }else{
     arrangePages(theList)
  }
}


<h2>remove items</h2>

fmList=c('02917','01876','01960','03938','02951','02952','06820','06110','03601','01895')
itemList=c('02718','02696')

commons = fmList[fmList %in% itemList]
cat("\n\nnumber of Items to remove: ", length(commons), "\n")
for(item in commons){fmList = fmList[-(which(fmList == item))]}
fmList

<h2>extract chinanews images</h2>
http://www.chinanews.com/tp/hd2011/2019/10-20/909276.shtml
copy the thumb address and replace ending 320x300.jpg with 1000x2000

<h2>cut(x,breaks)</h2>
x = sort(rnorm(13,5,12))
x
-15.0 -11.3  -3.2   1.0   3.8   6.1   7.6   7.8  10.7 13.7  15.4  15.9  23.4

cut(x,5)
(-15.1,-7.36] (-15.1,-7.36] (-7.36,0.339] (0.339,8.03]  (0.339,8.03]  (0.339,8.03]  (0.339,8.03]  (0.339,8.03]  (8.03,15.7]   (8.03,15.7]   (8.03,15.7]   (15.7,23.5]   (15.7,23.5]  
Levels: (-15.1,-7.36] (-7.36,0.339] (0.339,8.03] (8.03,15.7] (15.7,23.5]

<h2>R GUI: RGtk or Tcl/Tk, gWidgets</h2>
<a href="http://www.ggobi.org/rgtk2/">RGtk2</a>

<a href="https://www.r-bloggers.com/playing-with-guis-in-r-with-rgtk2/">Playing with GUIs in R with RGtk2</a>

<a href="https://www.r-bloggers.com/gui-building-in-r-gwidgets-vs-deducer/">GUI building in R: gWidgets vs Deducer</a>

require("RGtk2")

window &lt;- gtkWindow()
window["title"] &lt;- "Calculator"

frame &lt;- gtkFrameNew("Calculate")
window$add(frame)

box1 &lt;- gtkVBoxNew()
box1$setBorderWidth(30)
frame$add(box1)   #add box1 to the frame

box2 &lt;- gtkHBoxNew(spacing= 10) #distance between elements
box2$setBorderWidth(24)

TextToCalculate&lt;- gtkEntryNew() #text field with expresion to calculate
TextToCalculate$setWidthChars(25)
box1$packStart(TextToCalculate)

label = gtkLabelNewWithMnemonic("Result") #text label
box1$packStart(label)

result&lt;- gtkEntryNew() #text field with result of our calculation
result$setWidthChars(25)
box1$packStart(result)

box2 &lt;- gtkHBoxNew(spacing= 10) # distance between elements
box2$setBorderWidth(24)
box1$packStart(box2)

Calculate &lt;- gtkButton("Calculate")
box2$packStart(Calculate,fill=F) #button which will start calculating

Sin &lt;- gtkButton("Sin") #button to paste sin() to TextToCalculate
box2$packStart(Sin,fill=F)

Cos &lt;- gtkButton("Cos") #button to paste cos() to TextToCalculate
box2$packStart(Cos,fill=F)

model&lt;-rGtkDataFrame(c("double","integer"))
combobox &lt;- gtkComboBox(model)
#combobox allowing to decide whether we want result as integer or double

crt &lt;- gtkCellRendererText()
combobox$packStart(crt)
combobox$addAttribute(crt, "text", 0)

gtkComboBoxSetActive(combobox,0)
box2$packStart(combobox)

DoCalculation&lt;-function(button)
{

  if ((TextToCalculate$getText())=="") return(invisible(NULL)) #if no text do nothing

   #display error if R fails at calculating
   tryCatch(
      if (gtkComboBoxGetActive(combobox)==0)
   result$setText((eval(parse(text=TextToCalculate$getText()))))
   else (result$setText(as.integer(eval(parse(text=TextToCalculate$getText()))))),
   error=function(e)
      {
      ErrorBox &lt;- gtkDialogNewWithButtons("Error",window, "modal","gtk-ok", GtkResponseType["ok"])
      box1 &lt;- gtkVBoxNew()
      box1$setBorderWidth(24)
      ErrorBox$getContentArea()$packStart(box1)

      box2 &lt;- gtkHBoxNew()
      box1$packStart(box2)

      ErrorLabel &lt;- gtkLabelNewWithMnemonic("There is something wrong with your text!")
      box2$packStart(ErrorLabel)
      response &lt;- ErrorBox$run()


      if (response == GtkResponseType["ok"])
         ErrorBox$destroy()

      }
   )

}


  PasteSin&lt;-function(button)
{
   TextToCalculate$setText(paste(TextToCalculate$getText(),"sin()",sep=""))

}

PasteCos&lt;-function(button)
{
   TextToCalculate$setText(paste(TextToCalculate$getText(),"cos()",sep=""))

}

#however button variable was never used inside 
#functions, without it gSignalConnect would not work
gSignalConnect(Calculate, "clicked", DoCalculation)
gSignalConnect(Sin, "clicked", PasteSin)
gSignalConnect(Cos, "clicked", PasteCos)
Now it works like planned.



library(RGtk2)
createWindow &lt;- function()
{
    window &lt;- gtkWindow()
    label &lt;- gtkLabel("Hello World")
    window$add(label)
}
createWindow()
gtk.main() # this will create error

# using this will loop dead
gtkMain()


<h2>To keep the scripts and algorithm secret</h2>
by saving functions using save(). 
For example, here's a function f() you want to keep secret:

f &lt;- function(x, y) { return(x + y)}

Save it :
save(f, file = 'C:\\Users\\Joyce\\Documents\\R\\Secret.rda')

And when you want to use the function:
load("C:\\Users\\Joyce\\Documents\\R\\Secret.rda")

Save all functions in separate files, 
put them in a folder and have one plain old .R script
loading them all in and executing whatever.
Zip the whole thing up and distribute it to whoever.
Maybe even compile it into a package.
Effectively the whole thing would be read-only then.

This solution isn't that great though.
You can still see the function in R by typing the name of the function
so it's not hidden in that sense.
But if you open the .rda files their contents are all garbled.
It all depends really on how experienced the recipients of your code are with R.

One form of having encrypted code is implemented in the petals function in the TeachingDemos package.

it would only take intermediate level programing skills to find the hidden code,
however it does take deliberate effort and the user would not be able to claim having seen the code by accident.
You would then need some type of license agreement in place to enforce any no peeking agreements.

Well you are going to need R installed on the deployment machine.

<h2>Test if characters are in a string</h2>
grepl("abc", "abcde")
note: RE will be applied, take care of the expression

<h2>get password</h2>
install.packages("getPass")
pass = getPass::getPass(msg = "PASSWORD: ", noblank = FALSE, forcemask = FALSE)

<h2>tryCatch loop</h2>
  retrieveData &lt;- function(urlAddr){      
    retryCounter = 0
    while(retryCounter < 20) {
      cat("..",retryCounter," ") 
      retriveFile &lt;- tryCatch(readLines(urlAddr, warn=F), 
          warning = function(w){return("code param error")}, 
          error = function(e) {return("code param error")}
          )
      if (grepl("code param error", retriveFile)) {
        cat("Error in connection, try 5 secs later!\n")
        retryCounter &lt;- retryCounter + 1
        retriveFile = ""  # if end of loop this will be returned
      }else{
        retryCounter = 200  # to jump out of loop
      }
    }
    return(retriveFile)
  }

  retrieveData &lt;- function(urlAddr){      
    retryCounter = 1
    while(retryCounter < 20) {
      cat("..try ",retryCounter," ") 
      retriveFile &lt;- tryCatch(read_html(urlAddr, warn=F), 
          warning = function(w){return("code param error")}, 
          error = function(e) {return("code param error")}
          )
      if (grepl("code param error", retriveFile)) {
        cat("Error in connection, try 5 secs later!\n")
        retryCounter &lt;- retryCounter + 1
        retriveFile = ""  # if end of loop this will be returned
      }else{
        retryCounter = 200  # to jump out of loop
      }
    }
    return(retriveFile)
  }

<h2>變異數分析, 方差分析 ANOVA </h2>
<a href="http://personality-project.org/r/r.guide/r.anova.html">r.anova</a>
<a href="https://alex59638.pixnet.net/blog/post/403137005-用r進行anova%28變方分析%29">ANOVA可分析多組間的差異 變異數分析 (ANOVA)</a>
<a href="http://programmermagazine.github.io/201310/htm/article3.html">主成分分析 Principle Component Analysis</a>

<h2>常用統計檢驗法簡介</h2>

T.test(又稱 T 檢定、T檢驗、t.test，以下簡稱T檢驗)
T檢驗主要用於檢定樣本的平均值，這是一項重點。

如果要看一個樣本的平均是否等於某值，要用 T 檢驗。

如果要看兩個樣本的平均是否相等，要用 T 檢驗。

T 檢驗分成三種類別
1.單樣本T檢驗(One smaple T test)
2.獨立雙樣本T檢驗
3.配對雙樣本T檢驗

要看 30 個男生的身高是否等於 180，用單樣本T檢驗。
[R語法:t.test(樣本,mu=平均)]

要看 A 班與 B 班男生身高是否相等，用獨立雙樣本T檢驗。
[R語法:t.test(A樣本,B樣本)]

要看 30 個男生吃藥前與吃藥後身高是否相等，用配對雙樣本T檢驗
[R語法:t.test(A樣本,B樣本,paired=TURE)]

每一種 T 檢驗都還可以再分成雙尾與單尾檢驗。
[R語法:t.test(樣本,mu=平均,alternative= "two.sided")]

two.sided代表等於，就是雙尾的意思，也可以改成單尾的大於"greater"或是單尾的小於"less"。

重點只有"檢驗平均等於某值時"是雙尾，"檢驗平均小於某值時"是單尾，"檢驗平均大於某值時"是單尾。
請看到這裡後不要再講單尾或是雙尾了，一點意義也沒有，講大於等於小於就好了。
但Eecel沒有大於小於的選項，只有單尾雙尾，因此要自己判斷是大於還是小於(從樣本平均看即可)。
[Eecel語法:TTEST(A樣本,B樣本,2,2)]，2代表雙尾，改成1就變成單尾。

要看 30 個男生的身高是否大於 180，用單樣本T檢驗
[R語法:t.test(樣本,mu=180),alternative="greater"]

要看 A 班與 B 班男生身高差異是否小於 30，用獨立雙樣本T檢驗
[R語法:t.test(A,B,mu=30,alternative="less")]

要看 30 個男生吃藥前與吃藥後身高是否相等，用配對雙樣本T檢驗
[R語法:t.test(A,B,mu=30,paired=T)]
[Eecel語法:TTEST(A樣本,B樣本,2,1)]

其中獨立雙樣本T檢驗(Welch Two smaple T test)還細分成變異數相等或變異數不相等兩種，這要看你母體與取樣的方法，如果不確定，嚴格一點是認為不相等的。

變異數相等
[R語法:t.test(A,B,mu=0,var.equal=T)]

變異數不相等
[R語法:t.test(A,B,mu=0,var.equal=F)]

<h3>卡方檢定 chi-square test(以下簡稱卡方檢定)</h3>
卡方檢驗用於確認樣本是否符合某種分配
骰子丟一百次，每面的機率是否為1/6</a>)，
或是兩個屬性之間是否有所關聯(男生是否比較容易選擇藍色商品)。

這其實是一樣的概念，假設兩個屬性之間無關，其分佈上應該會呈現隨機;
如果兩個屬性有關，例如男生喜歡藍色商品，在同樣的其況下，男生買藍色商品的次數會比男生買紅色商品的次數多，也就是不符合隨機的分配(理論上無關的話次數會一樣多)。

卡方檢定分成三種
1.適合度檢定（Goodness of fit test）
2.獨立性檢定（Test of independence）
3.同質性檢定 (Test of Homogeneity)

其實獨立性與同質性檢定是同一個東西，只是問法不一樣而已卡方適合度檢定用來檢驗樣本是否服從某種分佈，這種分佈你的心裡要有底，比方隨機(丟骰子各面是1/6)，孟德爾的紅花白花是3:1等等，如果你不知道要選擇哪種分佈，那就不能用卡方適合度檢定。

紅花969株，白花360株，檢驗是否符合孟德爾3:1的分佈，用卡方適合度檢定
chisq.test(c(969,360),p=c(0.75,0.25))
#次數表放第一個變數,p後面接機率，機率合要等於1[R語法:chisq.test(次數表,p=機率)]

骰子1000次，檢驗每面是否為1/6的分佈，用卡方適合度檢定
x=ceiling(runif(1000)*6)#丟1000次骰子, ceiling是無條件進位，讓數值落在1~6的整數
table(x)
#這是卡方檢定的重點，必須輸入統計次數，知道骰出1的有幾次，2的有幾次
chisq.test(table(x),p=c(1/6,1/6,1/6,1/6,1/6,1/6))
#次數表放第一個，p後面接分佈的機率，本次是6個1/6。

[R語法:chisq.test(次數表,p=機率)]

<h3>費雪精確性檢定 Fisher's exact test</h3>
類似卡方檢定的小樣本方式，通常用於樣本小於20的狀況，案例是猜八杯茶是先加奶還是先加茶。
fisher.test(table(real,guess))

<h2>變異數分析 ANOVA</h2>
兩組資料連續看是否有差異，用t.test，兩組以上則用ANOVA，其虛無假說H0:u1=u2=u3=...un。
若p值小於0.05，則認為並非所有的資料來自同一個母體。

若要知道到底是哪組資料不同，可使用 
pairwise.t.test(Y, B, p.adjust.method="none")
其中Y為資料列，B為組別列，並且不調整p值。
雙因子變異數分析
aov(cardspent~factor(region)*factor(gender)
使用*符號而不是+


<h2>Logistic Regression</h2>
Logistic regression, also called a logit model, is used to model dichotomous outcome variables. 

Logistic regression is a method for fitting a regression curve, y = f(x), when y is a categorical variable. 
The typical use of this model is predicting y given a set of predictors x. The predictors can be continuous, categorical or a mix of both.

一般的線性迴歸都是連續數值，例如身高或體重。
但有些情況下的應變數為類別，例如生還與否(1或0)，就可以採用Logistic Regression。

Logistic Regression有幾項要點，
1.他需要應變數為類別變項
2.他會給出一個式子，帶入自變數後(可為連續變項或類別變項)，會得出一個值
3.這個值稱為勝算比


以鐵達尼號乘客名單的資料作為範例分析
model1 &lt;- glm(data = titanic_passenger, family = binomial(link= formula = survival~fare, logit = "" na.action="na.exclude) &lt;
summary(model1)
其中fare 對 survival 的對數機率為 0.013108
勝算比為exp(0.013108)=1.013085
多一英鎊，多1%生還率。
參考資料
<a href="https://sites.google.com/site/rlearningsite/catagory/logit" target="_blank">Logistic迴歸模型</a>
<a href="http://xn--r-vc8at2mlrkqvkh65cu2ccyjyqb/" target="_blank">R语言逻辑回归分析</a>
<a href="https://www.r-bloggers.com/how-to-perform-a-logistic-regression-in-r/" target="_blank">How to perform a Logistic Regression in R</a><!---glm-->


<a href="http://ccckmit.wikidot.com/r:optimize">一維空間優化方法：optimize()</a>
<a href="http://ccckmit.wikidot.com/r:main">R 統計軟體 作者：陳鍾誠</a>
<a href="http://programmermagazine.github.io/201309/htm/article3.html">R 統計軟體(6) – 迴歸分析</a>

<h2>Advanced Statistics Tree-Based Models</h2>
<a href="https://www.datacamp.com/community/tutorials/decision-trees-R">Decision Trees in R</a>
<a href="https://www.guru99.com/r-decision-trees.html">Decision Tree in R with Example</a>
<a href="https://www.statmethods.net/advstats/cart.html">Tree-Based Models</a>
<a href="http://www.di.fc.ul.pt/~jpn/r/tree/tree.html">Classification & Regression Trees</a>
<a href="https://blog.revolutionanalytics.com/2013/06/plotting-classification-and-regression-trees-with-plotrpart.html">Classification and Regression Trees with the rpart.plot package</a>

<h2>Grouping functions (tapply, by, aggregate) and the *apply family</h2>
R has many *apply functions.
Much of the functionality of the *apply family is covered by the extremely popular <code>plyr</code> package, the base functions remain useful and worth knowing.

<k>apply</k> - <em>When you want to apply a function to the rows or columns of a matrix (and higher-dimensional analogues); not generally advisable for data frames as it will coerce to a matrix first.</em>

<code># Two dimensional matrix
M &lt;- matrix(seq(1,16), 4, 4)

# apply min to rows
apply(M, 1, min)
[1] 1 2 3 4

# apply max to columns
apply(M, 2, max)
[1]  4  8 12 16

# 3 dimensional array
M &lt;- array( seq(32), dim = c(4,4,2))

# Apply sum across each M[*, , ] - i.e Sum across 2nd and 3rd dimension, look from top is an area
apply(M, 1, sum)
# Result is one-dimensional
[1] 120 128 136 144

# Apply sum across each M[*, *, ] - i.e Sum across 3rd dimension
apply(M, c(1,2), sum)
# Result is two-dimensional
     [,1] [,2] [,3] [,4]
[1,]   18   26   34   42
[2,]   20   28   36   44
[3,]   22   30   38   46
[4,]   24   32   40   48
</code>

If you want row/column means or sums for a 2D matrix, be sure to investigate the highly optimized, lightning-quick <code>colMeans</code>, <code>rowMeans</code>, <code>colSums</code>, <code>rowSums</code>.
<k>lapply</k> - <em>When you want to apply a function to each element of a list in turn and get a list back.</em>

This is the workhorse of many of the other *apply functions. 
Peel back their code and you will often find <code>lapply</code> underneath.

<code>x &lt;- list(a = 1, b = 1:3, c = 10:100) 
lapply(x, FUN = length) 
$a 
[1] 1
$b 
[1] 3
$c 
[1] 91
lapply(x, FUN = sum) 
$a 
[1] 1
$b 
[1] 6
$c 
[1] 5005</code>
<k>sapply</k> - <em>When you want to apply a function to each element of a list in turn, but you want a <k>vector</k> back, rather than a list.</em>

If you find yourself typing <code>unlist(lapply(...))</code>, stop and consider <code>sapply</code>.

<code>x &lt;- list(a = 1, b = 1:3, c = 10:100)
# Compare with above; a named vector, not a list 
sapply(x, FUN = length)  
a  b  c   
1  3 91

sapply(x, FUN = sum)   
a    b    c    
1    6 5005 
</code>

In more advanced uses of <code>sapply</code> it will attempt to coerce the result to a multi-dimensional array, if appropriate. 
For example, if our function returns vectors of the same length, <code>sapply</code> will use them as columns of a matrix:

<code>sapply(1:5,function(x) rnorm(3,x))
</code>

If our function returns a 2 dimensional matrix, <code>sapply</code> will do essentially the same thing, treating each returned matrix as a single long vector:

<code>sapply(1:5,function(x) matrix(x,2,2))</code>

Unless we specify <code>simplify = "array"</code>, in which case it will use the individual matrices to build a multi-dimensional array:

<code>sapply(1:5,function(x) matrix(x,2,2), simplify = "array")</code>

Each of these behaviors is of course contingent on our function returning vectors or matrices of the same length or dimension.
<k>vapply</k> - <em>When you want to use <code>sapply</code> but perhaps need to squeeze some more speed out of your code.</em>

For <code>vapply</code>, you basically give R an example of what sort of thing your function will return, which can save some time coercing returned values to fit in a single atomic vector.

<code>x &lt;- list(a = 1, b = 1:3, c = 10:100)
# Note that since the advantage here is mainly speed, this
# example is only for illustration. 
We're telling R that
# everything returned by length() should be an integer of length 1. 

vapply(x, FUN = length, FUN.VALUE = 0L) 
a  b  c  
1  3 91
</code>
<k>mapply</k> - <em>For when you have several data structures (e.g. vectors, lists) and you want to apply a function to the 1st elements of each, and then the 2nd elements of each, etc., coercing the result to a vector/array as in <code>sapply</code>.</em>

This is multivariate in the sense that your function must accept multiple arguments.

<code>#Sums the 1st elements, the 2nd elements, etc. 

mapply(sum, 1:5, 1:5, 1:5) 
[1]  3  6  9 12 15
#To do rep(1,4), rep(2,3), etc.
mapply(rep, 1:4, 4:1)   
[[1]]
[1] 1 1 1 1

[[2]]
[1] 2 2 2

[[3]]
[1] 3 3

[[4]]
[1] 4
</code>
<k>Map</k> - <em>A wrapper to <code>mapply</code> with <code>SIMPLIFY = FALSE</code>, so it is guaranteed to return a list.</em>

<code>Map(sum, 1:5, 1:5, 1:5)
[[1]]
[1] 3

[[2]]
[1] 6

[[3]]
[1] 9

[[4]]
[1] 12

[[5]]
[1] 15
</code>
<k>rapply</k> - <em>For when you want to apply a function to each element of a <k>nested list</k> structure, recursively.</em>

To give you some idea of how uncommon <code>rapply</code> is, I forgot about it when first posting this answer! Obviously, I'm sure many people use it, but YMMV. 
<code>rapply</code> is best illustrated with a user-defined function to apply:

<code># Append ! to string, otherwise increment
myFun &lt;- function(x){
    if(is.character(x)){
      return(paste(x,"!",sep=""))
    }
    else{
      return(x + 1)
    }
}

#A nested list structure
l &lt;- list(a = list(a1 = "Boo", b1 = 2, c1 = "Eeek"), 
          b = 3, c = "Yikes", 
          d = list(a2 = 1, b2 = list(a3 = "Hey", b3 = 5)))


# Result is named vector, coerced to character          
rapply(l, myFun)

# Result is a nested list like l, with values altered
rapply(l, myFun, how="replace")
</code>
<k>tapply</k> - <em>For when you want to apply a function to <k>subsets</k> of a vector and the subsets are defined by some other vector, usually a factor.</em>

The black sheep of the *apply family, of sorts. 
The help file's use of the phrase "ragged array" can be a bit <a href="https://stackoverflow.com/questions/6297201/explain-r-tapply-description/6297396#6297396">confusing</a>, but it is actually quite simple.

A vector:

<code>x &lt;- 1:20</code>

A factor (of the same length!) defining groups:

<code>y &lt;- factor(rep(letters[1:5], each = 4))</code>

Add up the values in <code>x</code> within each subgroup defined by <code>y</code>:

<code>tapply(x, y, sum)  
 a  b  c  d  e  
10 26 42 58 74 
</code>

More complex examples can be handled where the subgroups are defined by the unique combinations of a list of several factors. 
<code>tapply</code> is similar in spirit to the split-apply-combine functions that are common in R (<code>aggregate</code>, <code>by</code>, <code>ave</code>, <code>ddply</code>, etc.) Hence its black sheep status.

<b>Slice vector</b>
We can use lapply() or sapply() interchangeable to slice a data frame. 
We create a function, below_average(), that takes a vector of numerical values and returns a vector that only contains the values that are strictly above the average. 

below_ave &lt;- function(x) {  
    ave &lt;- mean(x) 
    return(x[x > ave])
}

Compare both results with the identical() function.
dataf_s&lt;- sapply(dataf, below_ave)
dataf_l&lt;- lapply(dataf, below_ave)
identical(dataf_s, dataf_l)


<h2>Principal Component Methods</h2>
<a href="Principal Component Methods.html">Principal Component Methods</a>
<a href="Principal Component Analysis.html" class="goldbut red whitebs">Principal Component Analysis</a>
<a href="http://programmermagazine.github.io/201310/htm/article3.html">主成分分析 Principle Component Analysis</a>
<a href="../Component Analysis PCA.html">&#x25B2;<b class="redword bordred1 borRad15">Component Analysis PCA</b></a>
library(stats)
pca &lt;- princomp(train, cor = TRUE)
train_reduced  &lt;- predict(pca,train)
test_reduced  &lt;- predict(pca,test)


<h2>NLP techniques</h2>
<a href="NLP techniques.html">NLP techniques</a>


<h2>RMySQL R connect to MySQL</h2>
root
asdf1234
SHOW DATABASES

# 1. Library
library(RMySQL)

# 2. Settings
db_user &lt;- 'root'
db_password &lt;- 'asdf1234'
db_name &lt;- 'sampledb'
# db_table &lt;- 'example'
db_table &lt;- 'world'

db_host &lt;- '127.0.0.1' # for local access
db_port &lt;- 3306

# 3. Read data from db
mydb &lt;-  dbConnect(MySQL(), user = db_user, password = db_password,
         dbname = db_name, host = db_host, port = db_port)
s &lt;- paste0("select * from ", db_table)
rs &lt;- dbSendQuery(mydb, s)
df &lt;-  fetch(rs, n = -1)
on.exit(dbDisconnect(mydb))

<h2>convert R {xml_node} to plain text while preserving the tags</h2>
className = "#icnt"
keywordList &lt;- html_nodes(pagesource, className)
as.character(keywordList)

<h2>convert R objects into a binary format</h2>
x &lt;- list(1, 2, 3)
serialize(x, NULL)
The serialize() function is used to convert individual R objects into a binary format that can be communicated across an arbitrary connection. This may get sent to a file, but it could get sent over a network or other connection.

<h2>Convert an R Object to a Character String</h2>
x &lt;- c("a", "b", "aaaaaaaaaaa")
toString(x)
toString(x, width = 8)


<h2>rvest: scraping the web using R</h2>
<h3>What can you do using rvest?</h3>
Create an html document from a url, a file on disk or a string containing html with html().
Select parts of an html document using css selectors: html_nodes(). 
Learn more about it using vignette(“selectorgadget”) after installing and loading rvest in R. 
CSS selectors are used to select elements based on properties such as id, class, type, etc.

<a href="http://selectorgadget.com/">Selector Gadget website</a>
Extract components with html_tag() (the name of the tag), html_text() (all text inside the tag), html_attr() (contents of a single attribute) and html_attrs() (all attributes). 
These are done after using html_nodes().

HTML tags normally come in pairs like &lt;tagname>content&lt;/tagname>. 
In the examples we go through below, the content is usually contained between the
 
tags.
You can also use rvest with XML files: parse with xml(), then extract components using xml_node(), xml_attr(), xml_attrs(), xml_text() and xml_tag().
Parse tables into data frames with html_table().
Extract, modify and submit forms with html_form(), set_values() and submit_form().
Detect and repair encoding problems with guess_encoding() and repair_encoding(). 
Then pass the correct encoding into html() as an argument.
Navigate around a website as if you’re in a browser with html_session(), jump_to(), follow_link(), back(), forward(), submit_form() and so on. 
(This is still a work in progress).
The package also supports using magrittr for commands.

Also have a look at the three links below for some more information:

<a href="https://github.com/hadley/rvest">rvest package on Github</a>
<a href="http://cran.r-project.org/web/packages/rvest/index.html">rvest documentation on CRAN</a>
<a href="http://blog.rstudio.org/2014/11/24/rvest-easy-web-scraping-with-r/">rstudio blog on rvest</a>


<h3>Starting off simple: Scraping The Lego Movie on imdb</h3>
<code>#install.packages("rvest")

library(rvest)

# Store web url
lego_movie &lt;- html("http://www.imdb.com/title/tt1490017/")

#Scrape the website for the movie rating
rating &lt;- lego_movie %>% 
  html_nodes("strong span") %>%
  html_text() %>%
  as.numeric()
rating
## [1] 7.8
# Scrape the website for the cast
cast &lt;- lego_movie %>%
  html_nodes("#titleCast .itemprop span") %>%
  html_text()
cast
##  [1] "Will Arnett"     "Elizabeth Banks" "Craig Berry"    
##  [4] "Alison Brie"     "David Burrows"   "Anthony Daniels"
##  [7] "Charlie Day"     "Amanda Farinos"  "Keith Ferguson" 
## [10] "Will Ferrell"    "Will Forte"      "Dave Franco"    
## [13] "Morgan Freeman"  "Todd Hansen"     "Jonah Hill"
#Scrape the website for the url of the movie poster
poster &lt;- lego_movie %>%
  html_nodes("#img_primary img") %>%
  html_attr("src")
poster
## [1] "http://ia.media-imdb.com/images/M/MV5BMTg4MDk1ODExN15BMl5BanBnXkFtZTgwNzIyNjg3MDE@._V1_SX214_AL_.jpg"

# Extract the first review
review &lt;- lego_movie %>%
  html_nodes("#titleUserReviewsTeaser p") %>%
  html_text()
review</code>
## [1] "The stand out feature of the Lego Movie for me would be the way the Lego Universe was created. 
The movie paid great attention to detail making everything appear as it would made from Lego, including the water and clouds, and the surfaces people walked on all had the circles sticking upwards a Lego piece would have. 
Combined with all the yellow faces, and Lego part during building, I was convinced action took place in the Lego Universe.A combination of adult and child friendly humour should entertain all, the movie has done well to ensure audiences of all ages are catered to. 
The voice cast were excellent, especially Liam Neeson's split personality police officer, making the 2 personalities sound distinctive, and giving his Bad Cop the usual Liam Neeson tough guy. 
The plot is about resisting an over-controlling ruler, highlighted by the name of the hero's \"resistance piece\". 
It is well thought through, well written, and revealing at the right times. 
Full of surprises, The Lego Movie won't let You see what's coming. 
Best animated film since Wreck it Ralph! Please let there be sequels."


<h3>Scraping indeed.com for jobs</h3>
<code># Submit the form on indeed.com for a job description and location using html_form() and set_values()
query = "data science"
loc = "New York"
session &lt;- html_session("http://www.indeed.com")
form &lt;- html_form(session)[[1]]
form &lt;- set_values(form, q = query, l = loc)

# The rvest submit_form function is still under construction and does not work for web sites which build URLs (i.e. GET requests. 
It does seem to work for POST requests). 

#url &lt;- submit_form(session, indeed)

# Version 1 of our submit_form function
submit_form2 &lt;- function(session, form){
  library(XML)
  url &lt;- XML::getRelativeURL(form$url, session$url)
  url &lt;- paste(url,'?',sep='')
  values &lt;- as.vector(rvest:::submit_request(form)$values)
  att &lt;- names(values)
  if (tail(att, n=1) == "NULL"){
    values &lt;- values[1:length(values)-1]
    att &lt;- att[1:length(att)-1]
  }
  q &lt;- paste(att,values,sep='=')
  q &lt;- paste(q, collapse = '&')
  q &lt;- gsub(" ", "+", q)
  url &lt;- paste(url, q, sep = '')
  html_session(url)
}

# Version 2 of our submit_form function
library(httr)
# Appends element of a list to another without changing variable type of x
# build_url function uses the httr package and requires a variable of the url class
appendList &lt;- function (x, val)
{
  stopifnot(is.list(x), is.list(val))
  xnames &lt;- names(x)
  for (v in names(val)) {
    x[[v]] &lt;- if (v %in% xnames && is.list(x[[v]]) && is.list(val[[v]]))
      appendList(x[[v]], val[[v]])
    else c(x[[v]], val[[v]])
  }
  x
}
 
# Simulating submit_form for GET requests
submit_geturl &lt;- function (session, form)
{
  query &lt;- rvest:::submit_request(form)
  query$method &lt;- NULL
  query$encode &lt;- NULL
  query$url &lt;- NULL
  names(query) &lt;- "query"
 
  relativeurl &lt;- XML::getRelativeURL(form$url, session$url)
  basepath &lt;- parse_url(relativeurl)
 
  fullpath &lt;- appendList(basepath,query)
  fullpath &lt;- build_url(fullpath)
  fullpath
}

# Submit form and get new url
session1 &lt;- submit_form2(session, form)

# Get reviews of last company using follow_link()
session2 &lt;- follow_link(session1, css = "#more_9 li:nth-child(3) a")
reviews &lt;- session2 %>% html_nodes(".description") %>% html_text()
reviews
## [1] "Custody Client Services"                                       
## [2] "An exciting position on a trading floor"                       
## [3] "Great work environment"                                        
## [4] "A company that helps its employees to advance career."         
## [5] "Decent Company to work for while you still have the job there."
# Get average salary for each job listing based on title and location
salary_links &lt;- html_nodes(session1, css = "#resultsCol li:nth-child(2) a") %>% html_attr("href")
salary_links &lt;- paste(session$url, salary_links, sep='')
salaries &lt;- lapply(salary_links, . 
%>% html() %>% html_nodes("#salary_display_table .salary") %>% html_text())
salary &lt;- unlist(salaries)

# Store web url
data_sci_indeed &lt;- session1

# Get job titles
job_title &lt;- data_sci_indeed %>% 
  html_nodes("[itemprop=title]") %>%
  html_text()

# Get companies
company &lt;- data_sci_indeed %>%
  html_nodes("[itemprop=hiringOrganization]") %>%
  html_text()

# Get locations
location &lt;- data_sci_indeed %>%
  html_nodes("[itemprop=addressLocality]") %>%
  html_text()

# Get descriptions
description &lt;- data_sci_indeed %>%
  html_nodes("[itemprop=description]") %>%
  html_text()

# Get the links
link &lt;- data_sci_indeed %>%
  html_nodes("[itemprop=title]") %>%
  html_attr("href")
link &lt;- paste('[Link](https://www.indeed.com', link, sep='')
link &lt;- paste(link, ')', sep='')

indeed_jobs &lt;- data.frame(job_title,company,location,description,salary,link)

library(knitr)
kable(indeed_jobs, format = "html")</code>
<table>
 <thead><tr><th>job_title</th><th>company</th><th>location</th><th>description</th><th>salary</th><th>link</th></tr>
 </thead>
<tbody><tr><td>Data Scientist</td><td>Career Path Group</td><td>New York, NY 10018 (Clinton area)</td><td>Or higher in Computer Science or related field. 
Design, develop, and optimize our data and analytics system….</td><td>$109,000</td><td><a href="https://www.indeed.com/rc/clk?jk=a2a76f399d9da571">Link</a></td></tr><tr><td>Data Scientist or Statistician</td><td>Humana</td><td>New York, NY</td><td>Experience with unstructured data analysis. 
Humana is seeking an experienced statistician with demonstrated health and wellness data analysis expertise to join…</td><td>$60,000</td><td><a href="https://www.indeed.com/rc/clk?jk=25cf421c9eeba56d">Link</a></td></tr><tr><td>Analyst</td><td>1010data</td><td>New York, NY</td><td>Data providers can also use 1010data to share and monetize their data. 
1010data is the leading provider of Big Data Discovery and data sharing solutions….</td><td>$81,000</td><td><a href="https://www.indeed.com/rc/clk?jk=2cea6a727056a108">Link</a></td></tr><tr><td>Data Scientist & Visualization Engineer</td><td>Enstoa</td><td>New York, NY</td><td>2+ years professional experience analyzing complex data sets, modeling, machine learning, and/or large-scale data mining….</td><td>$210,000</td><td><a href="https://www.indeed.com/rc/clk?jk=a3f522a4a2d9c317">Link</a></td></tr><tr><td>Data Scientist - Intelligent Solutions</td><td>JPMorgan Chase</td><td>New York, NY</td><td>Experience managing and growing a data science team. 
Data Scientist - Intelligent Solutions. 
Analyze communications data and Utilize statistical natural…</td><td>$109,000</td><td><a href="https://www.indeed.com/rc/clk?jk=79b3ac9ca7865c94">Link</a></td></tr><tr><td>Analytics Program Lead</td><td>AIG</td><td>New York, NY</td><td>Lead the analytical team for Data Solutions. 
Graduate degree from a renowned institution in any advanced quantitative modeling oriented discipline including but…</td><td>$126,000</td><td><a href="https://www.indeed.com/rc/clk?jk=8baf5b98905c68f6">Link</a></td></tr><tr><td>Data Engineer</td><td>Standard Analytics</td><td>New York, NY</td><td>Code experience in a production environment (familiar with data structures, parallelism, and concurrency). 
We aim to organize the world’s scientific information…</td><td>$122,000</td><td><a href="https://www.indeed.com/rc/clk?jk=af931bd8281d19e7">Link</a></td></tr><tr><td>Summer Intern - Network Science and Big Data Analytics</td><td>IBM</td><td>Yorktown Heights, NY</td><td>The Network Science and Big Data Analytics department at the IBM T. 
Our lab has access to large computing resources and data….</td><td>$36,000</td><td><a href="https://www.indeed.com/rc/clk?jk=d20c6a677eda7671">Link</a></td></tr><tr><td>Data Scientist</td><td>The Nielsen Company</td><td>New York, NY</td><td>As a Data Scientist in the Data Integration group, you will be involved in the process of integrating data to enable analyses of patterns and relationships…</td><td>$109,000</td><td><a href="https://www.indeed.com/rc/clk?jk=8bfb40468f28c10c">Link</a></td></tr><tr><td>Data Analyst, IM Data Science</td><td>BNY Mellon</td><td>New York, NY</td><td>The Data Analyst will support a wide variety of projects and initiatives of the Data Science Group, including the creation of back-end data management tools,…</td><td>$84,000</td><td><a href="https://www.indeed.com/rc/clk?jk=779dc28f2010c4c6">Link</a></td></tr>
</tbody>
</table>

Some more on CSS and HTML:

<a href="http://code.tutsplus.com/tutorials/the-30-css-selectors-you-must-memorize--net-16048">Useful CSS Rules</a>
<a href="http://www.w3.org/TR/microdata/#names:-the-itemprop-attribute">HTML5 microdata itemprop property</a>


<h3>More examples with LinkedIn</h3>
<code># Attempt to crawl LinkedIn, requires useragent to access Linkedin Sites
uastring &lt;- "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"
session &lt;- html_session("https://www.linkedin.com/job/", user_agent(uastring))
form &lt;- html_form(session)[[1]]
form &lt;- set_values(form, keywords = "Data Science", location="New York")
 
new_url &lt;- submit_geturl(session,form)
new_session &lt;- html_session(new_url, user_agent(uastring))
jobtitle &lt;- new_session %>% html_nodes(".job [itemprop=title]") %>% html_text
company &lt;- new_session %>% html_nodes(".job [itemprop=name]") %>% html_text
location &lt;- new_session %>% html_nodes(".job [itemprop=addressLocality]") %>% html_text
description &lt;- new_session %>% html_nodes(".job [itemprop=description]") %>% html_text
url &lt;- new_session %>% html_nodes(".job [itemprop=title]") %>% html_attr("href")
url &lt;- paste(url, ')', sep='')
url &lt;- paste('[Link](', url, sep='')
df &lt;- data.frame(jobtitle, company, location, url)

df %>% kable</code>
<table class="table table-condensed">
<thead>
<tr><th>jobtitle</th><th>company</th><th>location</th><th>url</th></tr>
</thead>
<tbody>
<tr><td>Data Science Lead: Metis</td><td>Kaplan</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/51429397?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Data Science Lead: Metis</td><td>Kaplan Test Prep</td><td>New York, NY</td><td><a href="https://www.linkedin.com/jobs2/view/38695388?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Senior Data Scientist</td><td>Think Big, A Teradata Company</td><td>US-NY-New York</td><td><a href="https://www.linkedin.com/jobs2/view/32056808?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Principal Data Scientist</td><td>Think Big, A Teradata Company</td><td>US-NY-New York</td><td><a href="https://www.linkedin.com/jobs2/view/32057641?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Data Scientist - Professional Services Consultant (East …</td><td>MapR Technologies</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/35995187?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Senior Data Scientist</td><td>Teradata</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/51068145?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Principal Data Scientist</td><td>Teradata</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/51068162?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Sr. Software Engineer - Data Science - HookLogic</td><td>HookLogic, Inc.</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/49975389?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Data Scientist</td><td>Think Big, A Teradata Company</td><td>US-NY-New York</td><td><a href="https://www.linkedin.com/jobs2/view/32057645?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Director of Data Science Programs</td><td>DataKind</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/35605329?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Lead Data Scientist - VP - Intelligent Solutions</td><td>JPMorgan Chase & Co.</td><td>US-NY-New York</td><td><a href="https://www.linkedin.com/jobs2/view/40828814?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Senior Data Scientist for US Quantitative Fund, NYC</td><td>GQR Global Markets</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/38602287?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Google Cloud Solutions Practice, Google Data Solution …</td><td>PricewaterhouseCoopers</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/53729956?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Senior Data Scientist</td><td>Dun and Bradstreet</td><td>Short Hills, NJ, US</td><td><a href="https://www.linkedin.com/jobs2/view/53796892?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Senior data scientist</td><td>Mezzobit</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/38019145?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Think Big Data Scientist</td><td>Teradata</td><td>New York City, NY, US</td><td><a href="https://www.linkedin.com/jobs2/view/51066835?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Data Scientist - Intelligent Solutions</td><td>JPMorgan Chase & Co.</td><td>US-NY-New York</td><td><a href="https://www.linkedin.com/jobs2/view/40855034?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Technical Trainer EMEA</td><td>Datameer</td><td>New York</td><td><a href="https://www.linkedin.com/jobs2/view/41600114?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Elementary School Science Teacher</td><td>Success Academy Charter Schools</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/38634099?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Middle School Science Teacher</td><td>Success Academy Charter Schools</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/38633208?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Data Scientist (various levels)</td><td>Burtch Works</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/41672840?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Sr. Data Scientist – Big Data, Online Advertising, Search</td><td>Magnetic</td><td>New York, NY</td><td><a href="https://www.linkedin.com/jobs2/view/33977941?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Sr. Big Data Engineer FlexGraph</td><td>ADP</td><td>New York, NY</td><td><a href="https://www.linkedin.com/jobs2/view/18708583?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Data Science Lead Instructor - Data Science, Teaching</td><td>CyberCoders</td><td>New York City, NY</td><td><a href="https://www.linkedin.com/jobs2/view/40896475?trk=jserp_job_details_text">Link</a></td></tr>
<tr><td>Director, Data Consulting</td><td>Havas Media</td><td>Greater New York City Area</td><td><a href="https://www.linkedin.com/jobs2/view/41671585?trk=jserp_job_details_text">Link</a></td></tr>
</tbody>
</table>

<h3>Attemping to scrape Columbia LionShare</h3>
<code># Attempt to crawl Columbia Lionshare for jobs
session &lt;- html_session("http://www.careereducation.columbia.edu/lionshare")
form &lt;- html_form(session)[[1]]
form &lt;- set_values(form, username = "uni")
#Below code commented out in Markdown

#pw &lt;- .rs.askForPassword("Password?")
#form &lt;- set_values(form, password = pw)
#rm(pw)
#session2 &lt;- submit_form(session, form)
#session2 &lt;- follow_link(session2, "Job")
#form2 &lt;- html_form(session2)[[1]]
#form2 &lt;- set_values(form2, PositionTypes = 7, Keyword = "Data")
#session3 &lt;- submit_form(session2, form2)

# Unable to scrape because the table containing the job data uses javascript and doesn't load soon enough for rvest to collect information</code>
There isn't any equivalent to checking if the document finishes loading before scraping the data. 
The general recommendation appears to be using something entirely different such as Selenium to scrape web data.

<a href="http://www.seleniumhq.org/">Selenium, automating web browsers</a>

If you are webscraping with Python chances are that you have already tried urllib, httplib, requests, etc. 
These are excellent libraries, but some websites don’t like to be webscraped. 
In these cases you may need to disguise your webscraping bot as a human being. 
Selenium is just the tool for that. 
Selenium is a webdriver: it takes control of your browser, which then does all the work. 
Hence what the website “sees” is Chrome or Firefox or IE; it does not see Python or Selenium. 
That makes it a lot harder for the website to tell your bot from a human being.

<a href="http://thiagomarzagao.com/2013/11/12/webscraping-with-selenium-part-1/">Selenium tutorial</a>

<h2>4 Types of Classification Tasks in Machine Learning</h2>
https://machinelearningmastery.com/types-of-classification-in-machine-learning/
<h3>Tutorial Overview</h3>
This tutorial is divided into five parts; they are:

Classification Predictive Modeling
Binary Classification
Multi-Class Classification
Multi-Label Classification
Imbalanced Classification

<h3>Classification Predictive Modeling</h3>
There are many different types of classification algorithms for modeling classification predictive modeling problems.

There is no good theory on how to map algorithms onto problem types; instead, it is generally recommended that a practitioner use controlled experiments and discover which algorithm and algorithm configuration results in the best performance for a given classification task.

Classification predictive modeling algorithms are evaluated based on their results. Classification accuracy is a popular metric used to evaluate the performance of a model based on the predicted class labels. <a href="https://machinelearningmastery.com/failure-of-accuracy-for-imbalanced-class-distributions/">Classification accuracy is not perfect</a> but is a good starting point for many classification tasks.

Instead of class labels, some tasks may require the prediction of a <a href="https://machinelearningmastery.com/probability-metrics-for-imbalanced-classification/">probability of class membership</a> for each example. This provides additional uncertainty in the prediction that an application or user can then interpret. A popular diagnostic for evaluating predicted probabilities is the <a href="https://machinelearningmastery.com/roc-curves-and-precision-recall-curves-for-classification-in-python/">ROC Curve</a>.

There are perhaps four main types of classification tasks that you may encounter; they are:

Binary Classification
Multi-Class Classification
Multi-Label Classification
Imbalanced Classification

Let's take a closer look at each in turn.

<h3>Binary Classification</h3>
The class for the normal state is assigned the class label 0 and the class with the abnormal state is assigned the class label 1.

It is common to model a binary classification task with a model that predicts a <a href="https://machinelearningmastery.com/discrete-probability-distributions-for-machine-learning/">Bernoulli probability distribution</a> for each example.

The Bernoulli distribution is a discrete probability distribution that covers a case where an event will have a binary outcome as either a 0 or 1. For classification, this means that the model predicts a probability of an example belonging to class 1, or the abnormal state.

Popular algorithms that can be used for binary classification include:

Logistic Regression
k-Nearest Neighbors
Decision Trees
Support Vector Machine
Naive Bayes

Some algorithms are specifically designed for binary classification and do not natively support more than two classes; examples include Logistic Regression and Support Vector Machines.

Next, let's take a closer look at a dataset to develop an intuition for binary classification problems.

We can use the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html">make_blobs() function</a> to generate a synthetic binary classification dataset.

The example below generates a dataset with 1,000 examples that belong to one of two classes, each with two input features.

# example of binary classification task
from numpy import where
from collections import Counter
from sklearn.datasets import make_blobs
from matplotlib import pyplot
# define dataset
X, y = make_blobs(n_samples=1000, centers=2, random_state=1)
# summarize dataset shape
print(X.shape, y.shape)
# summarize observations by class label
counter = Counter(y)
print(counter)
# summarize first few examples
for i in range(10):
	print(X[i], y[i])
# plot the dataset and color the by class label
for label, _ in counter.items():
	row_ix = where(y == label)[0]
	pyplot.scatter(X[row_ix, 0], X[row_ix, 1], label=str(label))
pyplot.legend()
pyplot.show()

Running the example first summarizes the created dataset showing the 1,000 examples divided into input (<em>X</em>) and output (<em>y</em>) elements.

The distribution of the class labels is then summarized, showing that instances belong to either class 0 or class 1 and that there are 500 examples in each class.

Next, the first 10 examples in the dataset are summarized, showing the input values are numeric and the target values are integers that represent the class membership.

(1000, 2) (1000,)

Counter({0: 500, 1: 500})

[-3.05837272  4.48825769] 0
[-8.60973869 -3.72714879] 1
[1.37129721 5.23107449] 0
[-9.33917563 -2.9544469 ] 1
[-11.57178593  -3.85275513] 1
[-11.42257341  -4.85679127] 1
[-10.44518578  -3.76476563] 1
[-10.44603561  -3.26065964] 1
[-0.61947075  3.48804983] 0
[-10.91115591  -4.5772537 ] 1

Finally, a scatter plot is created for the input variables in the dataset and the points are colored based on their class value.

We can see two distinct clusters that we might expect would be easy to discriminate.

<img class="lazy" data-src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2020/01/Scatter-Plot-of-Binary-Classification-Dataset.png">
Scatter Plot of Binary Classification Dataset

<h3>Multi-Class Classification</h3>
<a href="https://en.wikipedia.org/wiki/Multiclass_classification">Multi-class classification</a> refers to those classification tasks that have more than two class labels.

Examples include:

Face classification.
Plant species classification.
Optical character recognition.

Unlike binary classification, multi-class classification does not have the notion of normal and abnormal outcomes. Instead, examples are classified as belonging to one among a range of known classes.

The number of class labels may be very large on some problems. For example, a model may predict a photo as belonging to one among thousands or tens of thousands of faces in a face recognition system.

Problems that involve predicting a sequence of words, such as text translation models, may also be considered a special type of multi-class classification. Each word in the sequence of words to be predicted involves a multi-class classification where the size of the vocabulary defines the number of possible classes that may be predicted and could be tens or hundreds of thousands of words in size.

It is common to model a multi-class classification task with a model that predicts a <a href="https://machinelearningmastery.com/discrete-probability-distributions-for-machine-learning/">Multinoulli probability distribution</a> for each example.

The Multinoulli distribution is a discrete probability distribution that covers a case where an event will have a categorical outcome, e.g. <em>K</em> in {1, 2, 3, &#8230;, <em>K</em>}. For classification, this means that the model predicts the probability of an example belonging to each class label.

Many algorithms used for binary classification can be used for multi-class classification.

Popular algorithms that can be used for multi-class classification include:

k-Nearest Neighbors.
Decision Trees.
Naive Bayes.
Random Forest.
Gradient Boosting.

Algorithms that are designed for binary classification can be adapted for use for multi-class problems.

This involves using a strategy of fitting multiple binary classification models for each class vs. all other classes (called one-vs-rest) or one model for each pair of classes (called one-vs-one).

<k>One-vs-Rest</k>: Fit one binary classification model for each class vs. all other classes.
<k>One-vs-One</k>: Fit one binary classification model for each pair of classes.

Binary classification algorithms that can use these strategies for multi-class classification include:

Logistic Regression.
Support Vector Machine.

Next, let's take a closer look at a dataset to develop an intuition for multi-class classification problems.

We can use the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html">make_blobs() function</a> to generate a synthetic multi-class classification dataset.

The example below generates a dataset with 1,000 examples that belong to one of three classes, each with two input features.

# example of multi-class classification task
from numpy import where
from collections import Counter
from sklearn.datasets import make_blobs
from matplotlib import pyplot
# define dataset
X, y = make_blobs(n_samples=1000, centers=3, random_state=1)
# summarize dataset shape
print(X.shape, y.shape)
# summarize observations by class label
counter = Counter(y)
print(counter)
# summarize first few examples
for i in range(10):
	print(X[i], y[i])
# plot the dataset and color the by class label
for label, _ in counter.items():
	row_ix = where(y == label)[0]
	pyplot.scatter(X[row_ix, 0], X[row_ix, 1], label=str(label))
pyplot.legend()
pyplot.show()

Running the example first summarizes the created dataset showing the 1,000 examples divided into input (<em>X</em>) and output (<em>y</em>) elements.

The distribution of the class labels is then summarized, showing that instances belong to class 0, class 1, or class 2 and that there are approximately 333 examples in each class.

Next, the first 10 examples in the dataset are summarized showing the input values are numeric and the target values are integers that represent the class membership.

(1000, 2) (1000,)

Counter({0: 334, 1: 333, 2: 333})

[-3.05837272  4.48825769] 0
[-8.60973869 -3.72714879] 1
[1.37129721 5.23107449] 0
[-9.33917563 -2.9544469 ] 1
[-8.63895561 -8.05263469] 2
[-8.48974309 -9.05667083] 2
[-7.51235546 -7.96464519] 2
[-7.51320529 -7.46053919] 2
[-0.61947075  3.48804983] 0
[-10.91115591  -4.5772537 ] 1

Finally, a scatter plot is created for the input variables in the dataset and the points are colored based on their class value.

We can see three distinct clusters that we might expect would be easy to discriminate.

<img class="lazy" data-src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2020/01/Scatter-Plot-of-Multi-Class-Classification-Dataset.png">
Scatter Plot of Multi-Class Classification Dataset

<h3>Multi-Label Classification</h3>
<a href="https://en.wikipedia.org/wiki/Multi-label_classification">Multi-label classification</a> refers to those classification tasks that have two or more class labels, where one or more class labels may be predicted for each example.

Consider the example of <a href="https://machinelearningmastery.com/object-recognition-with-deep-learning/">photo classification</a>, where a given photo may have multiple objects in the scene and a model may predict the presence of multiple known objects in the photo, such as &#8220;<em>bicycle</em>,&#8221; &#8220;<em>apple</em>,&#8221; &#8220;<em>person</em>,&#8221; etc.

This is unlike binary classification and multi-class classification, where a single class label is predicted for each example.

It is common to model multi-label classification tasks with a model that predicts multiple outputs, with each output taking predicted as a Bernoulli probability distribution. This is essentially a model that makes multiple binary classification predictions for each example.

Classification algorithms used for binary or multi-class classification cannot be used directly for multi-label classification. Specialized versions of standard classification algorithms can be used, so-called multi-label versions of the algorithms, including:

Multi-label Decision Trees
Multi-label Random Forests
Multi-label Gradient Boosting

Another approach is to use a separate classification algorithm to predict the labels for each class.

Next, let's take a closer look at a dataset to develop an intuition for multi-label classification problems.

We can use the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html">make_multilabel_classification() function</a> to generate a synthetic multi-label classification dataset.

The example below generates a dataset with 1,000 examples, each with two input features. There are three classes, each of which may take on one of two labels (0 or 1).

# example of a multi-label classification task
from sklearn.datasets import make_multilabel_classification
# define dataset
X, y = make_multilabel_classification(n_samples=1000, n_features=2, n_classes=3, n_labels=2, random_state=1)
# summarize dataset shape
print(X.shape, y.shape)
# summarize first few examples
for i in range(10):
	print(X[i], y[i])

Running the example first summarizes the created dataset showing the 1,000 examples divided into input (<em>X</em>) and output (<em>y</em>) elements.

Next, the first 10 examples in the dataset are summarized showing the input values are numeric and the target values are integers that represent the class label membership.

(1000, 2) (1000, 3)

[18. 35.] [1 1 1]
[22. 33.] [1 1 1]
[26. 36.] [1 1 1]
[24. 28.] [1 1 0]
[23. 27.] [1 1 0]
[15. 31.] [0 1 0]
[20. 37.] [0 1 0]
[18. 31.] [1 1 1]
[29. 27.] [1 0 0]
[29. 28.] [1 1 0]

<h3>Imbalanced Classification</h3>
<a href="https://machinelearningmastery.com/what-is-imbalanced-classification/">Imbalanced classification</a> refers to classification tasks where the number of examples in each class is unequally distributed.

Typically, imbalanced classification tasks are binary classification tasks where the majority of examples in the training dataset belong to the normal class and a minority of examples belong to the abnormal class.

Examples include:

Fraud detection.
Outlier detection.
Medical diagnostic tests.

These problems are modeled as binary classification tasks, although may require specialized techniques.

Specialized techniques may be used to change the composition of samples in the training dataset by undersampling the majority class or oversampling the minority class.

Examples include:

<a href="https://machinelearningmastery.com/random-oversampling-and-undersampling-for-imbalanced-classification/">Random Undersampling</a>.
<a href="https://machinelearningmastery.com/smote-oversampling-for-imbalanced-classification/">SMOTE Oversampling</a>.

Specialized modeling algorithms may be used that pay more attention to the minority class when fitting the model on the training dataset, such as cost-sensitive machine learning algorithms.

Examples include:

<a href="https://machinelearningmastery.com/cost-sensitive-logistic-regression/">Cost-sensitive Logistic Regression</a>.
Cost-sensitive Decision Trees.
Cost-sensitive Support Vector Machines.

Finally, alternative performance metrics may be required as reporting the classification accuracy may be misleading.

Examples include:

Precision.
Recall.
F-Measure.

Next, let's take a closer look at a dataset to develop an intuition for imbalanced classification problems.

We can use the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_classification.html">make_classification() function</a> to generate a synthetic imbalanced binary classification dataset.

The example below generates a dataset with 1,000 examples that belong to one of two classes, each with two input features.

# example of an imbalanced binary classification task
from numpy import where
from collections import Counter
from sklearn.datasets import make_classification
from matplotlib import pyplot
# define dataset
X, y = make_classification(n_samples=1000, n_features=2, n_informative=2, n_redundant=0, n_classes=2, n_clusters_per_class=1, weights=[0.99,0.01], random_state=1)
# summarize dataset shape
print(X.shape, y.shape)
# summarize observations by class label
counter = Counter(y)
print(counter)
# summarize first few examples
for i in range(10):
	print(X[i], y[i])
# plot the dataset and color the by class label
for label, _ in counter.items():
	row_ix = where(y == label)[0]
	pyplot.scatter(X[row_ix, 0], X[row_ix, 1], label=str(label))
pyplot.legend()
pyplot.show()

Running the example first summarizes the created dataset showing the 1,000 examples divided into input (<em>X</em>) and output (<em>y</em>) elements.

The distribution of the class labels is then summarized, showing the severe class imbalance with about 980 examples belonging to class 0 and about 20 examples belonging to class 1.

Next, the first 10 examples in the dataset are summarized showing the input values are numeric and the target values are integers that represent the class membership. In this case, we can see that most examples belong to class 0, as we expect.

(1000, 2) (1000,)

Counter({0: 983, 1: 17})

[0.86924745 1.18613612] 0
[1.55110839 1.81032905] 0
[1.29361936 1.01094607] 0
[1.11988947 1.63251786] 0
[1.04235568 1.12152929] 0
[1.18114858 0.92397607] 0
[1.1365562  1.17652556] 0
[0.46291729 0.72924998] 0
[0.18315826 1.07141766] 0
[0.32411648 0.53515376] 0

Finally, a scatter plot is created for the input variables in the dataset and the points are colored based on their class value.

We can see one main cluster for examples that belong to class 0 and a few scattered examples that belong to class 1. The intuition is that datasets with this property of imbalanced class labels are more challenging to model.

<img class="lazy" data-src="https://3qeqpr26caki16dnhd19sv6by6v-wpengine.netdna-ssl.com/wp-content/uploads/2020/01/Scatter-Plot-of-Imbalanced-Binary-Classification-Dataset.png">
Scatter Plot of Imbalanced Binary Classification Dataset

<h3>Further Reading</h3>
This section provides more resources on the topic if you are looking to go deeper.

<a href="https://en.wikipedia.org/wiki/Statistical_classification">Statistical classification, Wikipedia</a>.
<a href="https://en.wikipedia.org/wiki/Binary_classification">Binary classification, Wikipedia</a>.
<a href="https://en.wikipedia.org/wiki/Multiclass_classification">Multiclass classification, Wikipedia</a>.
<a href="https://en.wikipedia.org/wiki/Multi-label_classification">Multi-label classification, Wikipedia</a>.
<a href="https://scikit-learn.org/stable/modules/multiclass.html">Multiclass and multilabel algorithms, scikit-learn API</a>.

<h3>Summary</h3>
In this tutorial, you discovered different types of classification predictive modeling in machine learning.

Specifically, you learned:

Classification predictive modeling involves assigning a class label to input examples.
Binary classification refers to predicting one of two classes and multi-class classification involves predicting one of more than two classes.
Multi-label classification involves predicting one or more classes for each example and imbalanced classification refers to classification tasks where the distribution of examples across the classes is not equal.



<h2>html_node, html_nodes</h2>
html_node retrieves the first element it encounter, 
while html_nodes returns each matching element in the page as a list.

use html_nodes instead of html_node.

The toString() function collapse the list of strings into one.

library(rvest)
pagesource &lt;- read_html("url")

testpost &lt;- pagesource %>% 
  html_nodes("#contentmiddle>:not(#commentblock)") %>% 
  html_text %>%
  as.character %>%
  toString

<h2>Excluding Nodes in RVest</h2>
library(rvest)
pagesource &lt;- read_html("url")

testpost &lt;- pagesource %>% 
  html_nodes("#content>:not(#commentblock)") %>% 
  html_text %>%
  as.character %>%
  toString

To exclude multiple nodes:
url = "https://www.tutorialspoint.com/angularjs/index.htm"
pagesource <- read_html(url)

txtTarget <- pagesource %>% html_nodes("#mainContent
:not(#google-top-ads):not(.mui-container-fluid):not(style):not(#load):not(clear):not(clearer)") %>% html_text %>% as.character %>% toString


<h2>view all xml_nodeset class object (output of rvest::html_nodes)</h2>
print.AsIs(keywordList)

<h2>unable to install rvest package</h2>
Error: package or namespace load failed for ‘xml2’ in loadNamespace

install.packages("tidyverse")  # might need other dependencies installed in Rstudio


<h2>Rvest Limitations and CasperJS for R</h2>
<a href="https://www.r-bloggers.com/2019/11/when-rvest-is-not-enough/" class="whitebut ">When rvest is not enough</a>


<h2><span class="orange">Using rvest when login is required</span></h2>
The overall flow is to login, go to a web page collect information, add it a dataframe and then move to the next page.

library(rvest) 

#Address of the login webpage
login = "https://stackoverflow.com/users/login?ssrc=head&returnurl=http%3a%2f%2fstackoverflow.com%2f"

#create a web session with the desired login address

pgsession = html_session(login)
pgform = html_form(pgsession)[[2]]  #in this case the submit is the 2nd form
filled_form = set_values(pgform, email="*****", password="*****")
submit_form(pgsession, filled_form)

#pre allocate the final results dataframe.
results = data.frame()  

#loop through all of the pages with the desired info
for (i in 1:5)
{
  #base address of the pages to extract information from
  url = "http://stackoverflow.com/users/**********?tab=answers&sort=activity&page="
  url = paste0(url, i)
  page = jump_to(pgsession, url)

  #collect info on the question votes and question title
  summary = html_nodes(page, "div .answer-summary")
  question = matrix(html_text(html_nodes(summary, "div"), trim=TRUE), ncol=2, byrow = TRUE)

  #find date answered, hyperlink and whether it was accepted
  dateans = html_node(summary, "span") %>% html_attr("title")
  hyperlink = html_node(summary, "div a") %>% html_attr("href")
  accepted = html_node(summary, "div") %>% html_attr("class")

  #create temp results then bind to final results 
  rtemp = cbind(question, dateans, accepted, hyperlink)
  results = rbind(results, rtemp)
}

#Dataframe Clean-up
names(results) = c("Votes", "Answer", "Date", "Accepted", "HyperLink")
results$Votes = as.integer(as.character(results$Votes))
results$Accepted = ifelse(results$Accepted=="answer-votes default", 0, 1)

The loop in this case is limited to only 5 pages.
User specific values is ******.


<h2>xml_remove()</h2>
By using xml_remove(), you can literally remove any nodes

text &lt;- '
<table> <tr class="alt">
     <td>1</td>
     <td>2</td>
     <td class="hidden">3</td>
   </tr>
   <tr class="tr0 close notule">
     <td colspan="9">4</td> </tr>
</table>'

html_tree &lt;- read_html(text)

#select nodes you want to remove
hidden_nodes &lt;- html_tree %>% html_nodes(".hidden")
close_nodes &lt;- html_tree %>% html_nodes(".tr0.close.notule")

#remove those nodes
xml_remove(hidden_nodes)
xml_remove(close_nodes)

html_tree %>% html_table()

<h2>filter out nodes with rvest</h2>
By using xml_remove(), you can literally remove those nodes

text = '<table>
    <tr class="alt">
        <td>1</td>
        <td>2</td>
        <td class="hidden">3</td>
   </tr>
   <tr class="tr0 close notule">
        <td colspan="9">4</td>
    </tr>
</table>'

pageSource = read_html(text)

#select nodes you want to remove
hidden_nodes = pageSource %>% html_nodes(".hidden")
close_nodes = pageSource %>% html_nodes(".tr0.close.notule")

#remove those nodes
xml_remove(hidden_nodes)
xml_remove(close_nodes)

pageSource %>% html_table()

Sample:
itemList = html_nodes(pagesource, className)

syz = itemList %>% html_nodes(".syz")
searchBox = itemList %>% html_nodes("#searchBox")
friendlink = itemList %>% html_nodes(".friendlink")
clear = itemList %>% html_nodes(".clear")
footer = itemList %>% html_nodes(".footer")

#remove those nodes
xml_remove(syz)
xml_remove(searchBox)
xml_remove(friendlink)
xml_remove(clear)
xml_remove(footer)

itemList = as.character(itemList)



<h2>Install package loaclly</h2>
# 安装export包
if(!require(export)){
install.packages('export')
require(export)
}

下载安装包文件
打开git bash，执行命令：
git clone https://github.com/tomwenseleers/export.git

BUILD 安装包文件
R CMD BUILD export

安装包压缩文件
R CMD INSTALL

测试export包是否可以使用
require(export)

<h2>e1071 package Support vector machine</h2>
<a href="e1071 package SVM.html" class="whitebut ">e1071 package SVM</a>

<h2>substitute()</h2>
a &lt;- 1
b &lt;- 2
substitute(a + b + z) ## a + b + z

<h2>parse, deparse & expression Functions</h2>
Basic Syntax:

expression(character)
parse(text = character)
deparse(expression)

expression() function creates object of the expression.
parse() function converts character class to an object.
deparse() function turns unevaluated expressions into character strings.

x1 = expression(2^2)  # create string expresion to object
eval(x1)  # 4

x2 = "3^4"
x2 = parse(text = x2)  # convert string object to expression
eval(x2)  # 81

# writeAlarmHtml
  writeAlarmHtml=function(dataVector){
    objName =deparse(substitute(dataVector)) # return the vector to name
    outputFilename = paste0(codeTableName," ",objName, format(Sys.Date(), format="%y%m%d"), '.html')
  }

<h2>When to use CPUs vs GPUs vs TPUs?</h2>
Behind every machine learning algorithm is hardware crunching away at multiple gigahertz. 
You may have noticed several processor options when setting up Kaggle notebooks, but which one is best for you? In this blog post, we compare the relative advantages and disadvantages of using CPUs (<a href="https://www.intel.com/content/www/us/en/products/processors/xeon.html" target="_blank">Intel Xeon</a>*) vs GPUs (<a href="https://www.nvidia.com/en-us/data-center/tesla-p100/" target="_blank">Nvidia Tesla P100</a>) vs TPUs (<a href="https://cloud.google.com/tpu/" target="_blank">Google TPU v3</a>) for training machine learning models that were written using <a href="https://keras.io/" target="_blank">tf.keras</a> (Figure 1**). 
We’re hoping this will help you make sense of the options and select the right choice for your project.


<img class="lazy" data-src="https://miro.medium.com/max/1466/1*suXcuHEe29aKLPrQnXGBrg.png">

How we prepared the test
In order to compare the performance of CPUs vs GPUs vs TPUs for accomplishing common data science tasks, we used the <a href="https://www.tensorflow.org/datasets/catalog/tf_flowers" target="_blank">tf_flowers dataset</a> to train a convolutional neural network, and then the exact same code was run three times using the three different backends (CPUs vs GPUs vs TPUs; GPUs were NVIDIA P100 with Intel Xeon 2GHz (2 core) CPU and 13GB RAM. 
TPUs were TPUv3 (8 core) with Intel Xeon 2GHz (4 core) CPU and 16GB RAM). 
The accompanying <a href="https://www.kaggle.com/mgornergoogle/flowers-with-keras-and-xception-fine-tuned-on-gpu" target="_blank">tutorial notebook</a> demonstrates a few best practices for getting the best performance out of your TPU.
For example:

Using a dataset of sharded files (<a href="https://www.kaggle.com/paultimothymooney/convert-kaggle-dataset-to-gcs-bucket-of-tfrecords" target="_blank">e.g., .TFRecord</a>)
Using the <a href="https://www.tensorflow.org/guide/data" target="_blank">tf.data</a> API to pass the training data to the TPU
Using large batch sizes (e.g. batch_size=128)

By adding these precursory steps to your workflow, it is possible to avoid a common I/O bottleneck that otherwise prevents the TPU from operating at its full potential. 
You can find additional tips for optimizing your code to run on TPUs by visiting the official <a href="https://www.kaggle.com/docs/tpu" target="_blank">Kaggle TPU documentation</a>.
How the hardware performed
The most notable difference between the three hardware types that we tested was the speed that it took to train a model using <a href="https://keras.io/" target="_blank">tf.keras</a>. 
The tf.keras library is one of the most popular machine learning frameworks because tf.keras makes it easy to quickly experiment with new ideas. 
If you spend less time writing code then you have more time to perform your calculations, and if you spend less time waiting for your code to run, then you have more time to evaluate new ideas (Figure 2). 
tf.keras and TPUs are a powerful combination when participating in <a href="https://kaggle.com/c/flower-classification-with-tpus" target="_blank">machine learning competitions</a>!


<img class="lazy" data-src="https://miro.medium.com/max/1438/1*bqmG-YzgJzVeLbQ5Ym1iFg.png">
For our first experiment, we used the same code (a modified version*** of the <a href="https://www.kaggle.com/mgornergoogle/flowers-with-keras-and-xception-fine-tuned-on-gpu" target="_blank">official tutorial notebook</a>) for all three hardware types, which required using a very small batch size of 16 in order to avoid out-of-memory errors from the CPU and GPU. 
Under these conditions, we observed that TPUs were responsible for a ~100x speedup as compared to CPUs and a ~3.5x speedup as compared to GPUs when training an <a href="https://keras.io/applications/#xception" target="_blank">Xception</a> model (Figure 3). 
Because TPUs operate more efficiently with large batch sizes, we also tried increasing the batch size to 128 and this resulted in an additional ~2x speedup for TPUs and out-of-memory errors for GPUs and CPUs. 
Under these conditions, the TPU was able to train an <a href="https://keras.io/applications/#xception" target="_blank">Xception</a> model more than 7x as fast as the GPU from the previous experiment****.


<img class="lazy" data-src="https://miro.medium.com/max/1438/1*p2X9DQcq9K5Iu76Kk82vrg.png">
The observed speedups for model training varied according to the type of model, with Xception and Vgg16 performing better than ResNet50 (Figure 4). Model training was the only type of task where we observed the TPU to outperform the GPU by such a large margin. 
For example, we observed that in our hands the TPUs were ~3x faster than CPUs and ~3x slower than GPUs for performing a small number of predictions (TPUs perform exceptionally when making predictions in some situations such as when <a href="https://docs.google.com/presentation/d/1O49AkNyYV48n0X4nWr7KE-5aask88pz9gBSQ26ZG-5o/edit#slide=id.g50ce3d3866_0_1590" target="_blank">making predictions</a> on very large batches, which were not present in this experiment).


<img class="lazy" data-src="https://miro.medium.com/max/46/1*p7U2zlYn9O5Yvjluh2P-dg.png">

<img class="lazy" data-src="https://miro.medium.com/max/1466/1*p7U2zlYn9O5Yvjluh2P-dg.png">
To supplement these results, we note that <a href="https://arxiv.org/abs/1907.10701" target="_blank">Wang<em> et. 
al</em></a> have developed a rigorous benchmark called ParaDnn [1] that can be used to compare the performance of different hardware types for training machine learning models. 
By using this method Wang<em> et. 
al</em> were able to conclude that the performance benefit for parameterized models ranged from 1x to 10x, and the performance benefit for real models ranged from 3x to 6.8x when a TPU was used instead of a GPU (Figure 5). 
TPUs perform best when combined with sharded datasets, large batch sizes, and large models.


<img class="lazy" data-src="https://miro.medium.com/max/1466/1*QbP2CPDZH5BQWlnaTtW3oA.png">
Price considerations when training models
While our comparisons treated the hardware equally, there is a sizeable difference in pricing. TPUs are ~5x as expensive as GPUs (<a href="https://cloud.google.com/compute/gpus-pricing" target="_blank">$1.46/hr</a> for a <a href="https://www.nvidia.com/en-us/data-center/tesla-p100/" target="_blank">Nvidia Tesla P100</a> GPU vs <a href="https://cloud.google.com/tpu/pricing" target="_blank">$8.00/hr</a> for a <a href="https://cloud.google.com/tpu/" target="_blank">Google TPU v3</a> vs <a href="https://cloud.google.com/tpu/pricing" target="_blank">$4.50/hr</a> for the TPUv2 with “on-demand” access on <a href="https://cloud.google.com/pricing/" target="_blank">GCP</a> ). 
If you are trying to optimize for cost then it makes sense to use a TPU if it will train your model at least 5 times as fast as if you trained the same model using a GPU.
We consistently observed model training speedups on the order of ~5x when the data was stored in <a href="https://www.kaggle.com/paultimothymooney/convert-kaggle-dataset-to-gcs-bucket-of-tfrecords" target="_blank">a sharded format</a> in a <a href="https://www.kaggle.com/paultimothymooney/how-to-move-data-from-kaggle-to-gcs-and-back" target="_blank">GCS bucket</a> then passed to the TPU in large batch sizes, and therefore we recommend TPUs to cost-conscious consumers that are familiar with the <a href="http://tf.data" target="_blank">tf.data</a> API.
Some machine learning practitioners prioritize the reduction of model training time as opposed to prioritizing the reduction of model training costs. 
For someone that just wants to train their model as fast as possible, the TPU is the best choice. 
If you spend less time training your model, then you have more time to iterate upon new ideas. 
But don’t take our word for it — you can evaluate the performance benefits of CPUs, GPUs, and TPUs by running your own code in a <a href="https://www.kaggle.com/docs/kernels#the-kernels-environment" target="_blank">Kaggle Notebook</a>, free-of-charge. 
Kaggle users are already having a lot of fun and success experimenting with TPUs and text data: check out <a href="https://www.kaggle.com/c/tensorflow2-question-answering/discussion/127333" target="_blank">this forum post</a> that describes how TPUs were used to train a BERT transformer model to win $8,000 (2nd prize) in a recent <a href="https://www.kaggle.com/c/tensorflow2-question-answering" target="_blank">Kaggle competition</a>.
Which hardware option should you choose?
In summary, we recommend CPUs for their versatility and for their large memory capacity. 
GPUs are a great alternative to CPUs when you want to speed up a variety of data science workflows, and TPUs are best when you specifically want to train a machine learning model as fast as you possibly can.
You can get better results by optimizing your code for the specific hardware that you are using and we think it would be especially interesting to compare runtimes for code that has been optimized for a GPU to runtimes for code that has been optimized for a TPU. 
For example, it would be interesting to record the time that it takes to train a gradient-boosted model using a GPU-accelerated library such as <a href="https://rapids.ai/" target="_blank">RAPIDS.ai</a> and then to compare that to the time that it takes to train a deep learning model using a TPU-accelerated library such as <a href="https://keras.io/" target="_blank">tf.keras</a>.
What is the least amount of time that one can train an accurate machine learning model? How many different ideas can you evaluate in a single day? When used in combination with tf.keras, TPUs allow machine learning practitioners to spend less time writing code and less time waiting for their code to run — leaving more time to evaluate new ideas and improve one’s performance in <a href="http://kaggle.com/c/flower-classification-with-tpus" target="_blank">Kaggle Competitions</a>.

<h3>Footnotes</h3>* CPU types vary according to variability. 
In addition to the Intel Xeon CPUs, you can also get assigned to either Intel Skylake, Intel Broadwell, or Intel Haswell CPUs. 
GPUs were NVIDIA P100 with Intel Xeon 2GHz (2 core) CPU and 13GB RAM. 
TPUs were TPUv3 (8 core) with Intel Xeon 2GHz (4 core) CPU and 16GB RAM).
** Image for Figure 1 from <a href="https://cloud.google.com/blog/products/ai-machine-learning/cloud-tpu-breaks-scalability-records-for-ai-inference" target="_blank">https://cloud.google.com/blog/products/ai-machine-learning/cloud-tpu-breaks-scalability-records-for-ai-inference,</a> with permission.
*** The tutorial notebook was modified to keep the parameters (e.g. batch_size, learning_rate, etc) consistent between the three different backends.
**** CPU and GPU experiments used a batch size of 16 because it allowed the Kaggle notebooks to run from top to bottom without memory errors or 9-hr timeout errors. 
Only TPU-enabled notebooks were able to run successfully when the batch size was increased to 128.


<h2>Diff function – Difference between elements of vector</h2>
Differences between elements of a vector

diff(x, lag = 1, differences = 1)
x – numeric vector
lag-an integer indicating how many lags to use.
Difference- order of difference

# diff in r examples
> x=c(1,2,3,5,8,13,21)
> diff(x)
[1] 1 1 2 3 5 8

The diff function provides the option “lag”.
The default specification of this option is 1.

If we want to increase the size of the lag, we can specify the lag option within the diff command as follows:

x &lt;- c(5, 2, 10, 1, 3)
diff(x, lag = 2)                # Apply diff with lag
# 5 -1 -7

Example of difference function in R with lag 1 and differences 2:

#difference function in R with lag=1 and differences=2

diff(c(2,3,5,18,4,6,4),lag=1,differences=2)
First it is differenced with lag=1 and the result is again differenced with lag=1
So the output will be
[1]   1  11  -27   16   -4

ie. get the lag difference result, and then redo the difference again on the result:
2,3,5,18,4,6,4
  1,2,13,-14,2,-2
    1,11,-27,16,-4

<h2>cut2 function</h2>
cut2(x, cuts, m, g, levels.mean, digits, minmax=TRUE, oneval=TRUE)
Cut a Numeric Variable into Intervals
but left endpoints are inclusive and labels are of the form [lower, upper), except that last interval is [lower,upper].

x &lt;- runif(1000, 0, 100)
z &lt;- cut2(x, c(10,20,30))
table(z)
table(cut2(x, g=10))      # quantile groups
table(cut2(x, m=50))      # group x into intevals with at least 50 obs.

<h2>To clear up the memory</h2>
rm(list = ls())
.rs.restartR() # this will restart

memory.size(max=T) # gives the amount of memory obtained by the OS
memory.size(max=F) # gives the amount of memory being used
m = matrix(runif(10e7), 10000, 1000)
memory.size(max=F)

To clear up the memory
gc()
memory.size(max=F)
# still some memory being used

<h2>remove XML nodes</h2>
<a href="https://cran.r-project.org/web/packages/xml2/vignettes/modification.html" class="whitebut ">Node Modification</a>
<a href="https://cran.r-project.org/web/packages/XML/XML.pdf" class="whitebut ">Package XML</a>

#find parent nodes
parent&lt;- review %>% html_nodes("blockquote")

#find children nodes to exclude
toremove&lt;-parent %>% html_node("div.bbcode_container")

#remove nodes
xml_remove(toremove)

The xml_remove() can be used to remove a node (and it’s children) from a tree. 

library(XML)
r &lt;- xmlRoot(doc)
removeNodes(r[names(r) == "location"])

<h2>Comment out block of code</h2>

if(FALSE) {
  all your code
}


<h2>Reading XML data</h2>
Data in XML format are rarely organized in a way that would allow the xmlToDataFrame function to work. 
You're better off extracting everything in lists and then binding the lists together in a data frame:

require(XML)
data &lt;- xmlParse("http://forecast.weather.gov/MapClick.php?lat=29.803&lon=-82.411&FcstType=digitalDWML")

xml_data &lt;- xmlToList(data)

<code>> install.packages("XML")</code>
<code>> library(XML)
text = paste0("&lt;bookstore>&lt;book>","&lt;title>Everyday Italian&lt;/title>","&lt;author>Giada De Laurentiis&lt;/author>","&lt;year>2005&lt;/year>","&lt;/book>&lt;/bookstore>")
</code>
Parse the XML file
<code>xmldoc &lt;- xmlParse(text)
rootNode &lt;- xmlRoot(xmldoc)
rootNode[1]

xmlToDataFrame(nodes = getNodeSet(xmldoc, "//title"))
xmlToDataFrame(nodes = getNodeSet(xmldoc, "//author"))
xmlToDataFrame(nodes = getNodeSet(xmldoc, "//book"))

newdf = xmlToDataFrame(getNodeSet(xmldoc, "//book"))
newdf = xmlToDataFrame(getNodeSet(xmldoc, "//title"))
</code>

Extract XML data:

<code>> data &lt;- xmlSApply(rootNode,function(x) xmlSApply(x, xmlValue))</code>

text = paste0("&lt;CD>","&lt;TITLE>Empire Burlesque&lt;/TITLE>","&lt;ARTIST>Bob Dylan&lt;/ARTIST>","&lt;COUNTRY>USA&lt;/COUNTRY>","&lt;COMPANY>Columbia&lt;/COMPANY>","&lt;PRICE>10.90&lt;/PRICE>","&lt;YEAR>1985&lt;/YEAR>","&lt;/CD>")
<code>xmldoc &lt;- xmlParse(text)
rootNode &lt;- xmlRoot(xmldoc)
rootNode[1]</code>

Convert the extracted data into a data frame:

<code>> cd.catalog &lt;- data.frame(t(data),row.names=NULL)</code>

Verify the results

The <code>xmlParse</code> function returns an object of the <code>XMLInternalDocument</code> class, which is a C-level internal data structure.
The <code>xmlRoot()</code> function gets access to the root node and its elements. 
We check the first element of the root node:

<code>> rootNode[1]

$CD
&lt;CD>
  &lt;TITLE>Empire Burlesque&lt;/TITLE>
  &lt;ARTIST>Bob Dylan&lt;/ARTIST>
  &lt;COUNTRY>USA&lt;/COUNTRY>
  &lt;COMPANY>Columbia&lt;/COMPANY>
  &lt;PRICE>10.90&lt;/PRICE>
  &lt;YEAR>1985&lt;/YEAR>
&lt;/CD>
attr(,"class")
[1] "XMLInternalNodeList" "XMLNodeList"</code>
To extract data from the root node, we use the <code>xmlSApply()</code> function iteratively over all the children of the root node. 
The <code>xmlSApply</code> function returns a matrix.
To convert the preceding matrix into a data frame, we transpose the matrix using the <code>t()</code> function. 
We then extract the first two rows from the <code>cd.catalog</code> data frame:

<code>> cd.catalog[1:2,]
             TITLE       ARTIST COUNTRY     COMPANY PRICE YEAR
1 Empire Burlesque    Bob Dylan     USA    Columbia 10.90 1985
2  Hide your heart Bonnie Tyler      UK CBS Records  9.90 1988</code>

XML data can be deeply nested and hence can become complex to extract. 
Knowledge of <code>XPath</code> will be helpful to access specific XML tags. 
R provides several functions such as <code>xpathSApply</code> and <code>getNodeSet</code> to locate specific elements.
<h4>Extracting HTML table data from a web page</h4>
Though it is possible to treat HTML data as a specialized form of XML, R provides specific functions to extract data from HTML tables as follows:

<code>> url &lt;- "http://en.wikipedia.org/wiki/World_population"

webpage = read_html(url)
output = htmlParse(webpage)
tables = readHTMLTable(output)
world.pop = tables[[5]]

table.list = readHTMLTable(output, header=F)

u = "https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population"
webpage = read_html(u)
tables = readHTMLTable(webpage)
names(tables)
</code>
The <code>readHTMLTable()</code> function parses the web page and returns a <code>list</code> of all tables that are found on the page. 
For tables that have an <code>id</code> attribute, the function uses the <code>id</code> attribute as the name of that list element.
We are interested in extracting the "10 most populous countries," which is the fifth table; hence we use <code>tables[[5]]</code>.

<h4>Extracting a single HTML table from a web page</h4>

A single table can be extracted using the following command:

<code>> table &lt;- readHTMLTable(url,which=5)</code>
Specify <code>which</code> to get data from a specific table. 
R returns a data frame.

<h2>use xpathSApply to extract html</h2>
library(rvest)
library(XML) # this is v. imp

html &lt;- read_html("https://williamkpchan.github.io/LibDocs/GoNotes.html", followlocation = TRUE)
or
html &lt;- readLines("https://williamkpchan.github.io/LibDocs/GoNotes.html", followlocation = TRUE)

doc = htmlParse(html, asText=TRUE)
plain.text &lt;- xpathSApply(doc, "//h2", xmlValue)
cat(paste(plain.text, collapse = "\n"))

pageHeader = "http://www.hkej.com/template/dnews/jsp/toc_main.jsp"
html &lt;- read_html(pageHeader, followlocation = TRUE)
doc = htmlParse(html, asText=TRUE)
plain.text &lt;- xpathSApply(doc, "//a", xmlValue)
cat(paste(plain.text, collapse = "\n"))

<h2>reading XML using xml2</h2>
library(xml2)
library(purrr)

txt &lt;- '&lt;Doc name="Doc1">
    &lt;Lists Count="1">
        &lt;List Name="List1">
            &lt;Points Count="3">
                &lt;Point Id="1">
                    &lt;Tags Count ="1">"a"&lt;/Tags>
                    &lt;Point Position="1"  /> 
                &lt;/Point>
                &lt;Point Id="2">
                    &lt;Point Position="2"  /> 
                &lt;/Point>
                &lt;Point Id="3">
                    &lt;Tags Count="1">"c"&lt;/Tags>
                    &lt;Point Position="3"  /> 
                &lt;/Point>
            &lt;/Points>
        &lt;/List>
    &lt;/Lists>
&lt;/Doc>'

doc &lt;- read_xml(txt)
xml_find_all(doc, ".//Points/Point") %>% 
  map_df(function(x) {
    list(
      Point=xml_attr(x, "Id"),
      Tag=xml_find_first(x, ".//Tags") %>%  xml_text() %>%  gsub('^"|"$', "", .),
      Position=xml_find_first(x, ".//Point") %>% xml_attr("Position")
    )
  })



<h2>An Introduction to XPath: How to Get Started</h2>

XPath is a powerful language that is often used for scraping the web. 
It allows you to select nodes or compute values from an XML or HTML document and is actually one of the languages that you can use to extract web data using Scrapy. 
The other is CSS and while CSS selectors are a popular choice, XPath can actually allow you to do more.

With XPath, you can extract data based on text elements' contents, and not only on the page structure. 
So when you are scraping the web and you run into a hard-to-scrape website, XPath may just save the day (and a bunch of your time!).

This is an introductory tutorial that will walk you through the basic concepts of XPath, crucial to a good understanding of it, before diving into more complex use cases.
<h3>The basics</h3>
Consider this HTML document:

<code>&lt;html>
  &lt;head>
    &lt;title>My page&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;h2>Welcome to my &lt;a href="#">page&lt;/a>&lt;/h2>
    &lt;p>This is the first paragraph.&lt;/p>
    &lt;!-- this is the end -->
  &lt;/body>
&lt;/html></code>

XPath handles any XML/HTML document as a tree. 
This tree's root node is not part of the document itself. 
It is in fact the parent of the document element node (<code>&lt;html></code> in case of the HTML above). 
This is how the XPath tree for the HTML document looks like:


<img class="lazy" data-src="https://blog.scrapinghub.com/hs-fs/hubfs/tree-7.png" style="background-color: gray">

As you can see, there are many node types in an XPath tree:

<k>Element node:</k> represents an HTML element, a.k.a an HTML tag.
<k>Attribute node:</k> represents an attribute from an element node, e.g. “href” attribute in <code>&lt;a href=”http://www.example.com”>example&lt;/a></code>.
<k>Comment node:</k> represents comments in the document (<code>&lt;!-- … --></code>).
<k>Text node:</k> represents the text enclosed in an element node (<code>example</code> in <code>&lt;p>example&lt;/p></code>).

Distinguishing between these different types is useful to understand how XPath expressions work. 
Now let's start digging into XPath.

Here is how we can select the title element from the page above using an XPath expression:

/html/head/title


This is what we call a location path. 
It allows us to specify the path from the <k>context node</k> (in this case the root of the tree) to the element we want to select, as we do when addressing files in a file system. 
The location path above has three location steps, separated by slashes. 
It roughly means: <em>start from the ‘html’ element, look for a ‘head’ element underneath, and a ‘title’ element underneath that ‘head’</em>. 
The context node changes in each step. 
For example, the <code>head</code> node is the context node when the last step is being evaluated.

However, we usually don't know or don’t care about the full explicit node-by-node path, we just care about the nodes with a given name. 
We can select them using:

//title


Which means:<em> look in the whole tree, starting from the root of the tree (<code>//</code>) and select only those nodes whose name matches <code>title</code></em>. 
In this example, <code>//</code> is the <k>axis</k> and <code>title</code> is the <k>node test</k>.

In fact, the expressions we've just seen are using XPath's abbreviated syntax. 
Translating <code>//title</code> to the full syntax we get:

/descendant-or-self::node()/child::title


So, <code>//</code> in the abbreviated syntax is short for <code>descendant-or-self</code>, which means <em>the current node or any node below it in the tree</em>. 
This part of the expression is called the <k>axis</k> and it specifies a set of nodes to select from, based on their direction on the tree from the current context (downwards, upwards, on the same tree level). 
Other examples of axes are: parent, child, ancestor, etc -- we’ll dig more into this later on.

The next part of the expression, <code>node()</code>, is called a <k>node test</k>, and it contains an expression that is evaluated to decide whether a given node should be selected or not. 
In this case, it selects nodes from all types. 
Then we have another axis,<code>child</code>, which means <em>go to the child nodes from the current context</em>, followed by another node test, which selects the nodes named as <code>title</code>.

<blockquote>
So, the <k>axis</k> defines where in the tree the <k>node test</k> should be applied and the nodes that match the node test will be returned as a <k>result</k>.

</blockquote>
You can test nodes against their name or against their type.

Here are some examples of name tests:

<table>
<tbody>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
<tr>
<td>/html</td>
<td>Selects the node named <code>html</code>, which is under the root.</td>
</tr>
<tr>
<td>/html/head</td>
<td>Selects the node named <code>head</code>, which is under the <code>html</code> node.</td>
</tr>
<tr>
<td>//title</td>
<td>Selects all the <code>title</code> nodes from the HTML tree.</td>
</tr>
<tr>
<td>//h2/a</td>
<td>Selects all <code>a</code> nodes which are directly under an <code>h2</code> node.</td>
</tr>
</tbody>
</table>
And here are some examples of node type tests:

<table>
<tbody>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
<tr>
<td>//comment()</td>
<td>Selects only comment nodes.</td>
</tr>
<tr>
<td>//node()</td>
<td>Selects any kind of node in the tree.</td>
</tr>
<tr>
<td>//text()</td>
<td>Selects only text nodes, such as "This is the first paragraph".</td>
</tr>
<tr>
<td>//*</td>
<td>Selects all nodes, except comment and text nodes.</td>
</tr>
</tbody>
</table>
We can also combine name and node tests in the same expression. 
For example:

//p/text()


This expression selects the text nodes from inside <code>p</code> elements. 
In the HTML snippet shown above, it would select "This is the first paragraph.".

Now, <k>let’s see how we can further filter and specify things</k>. 
Consider this HTML document:

<code>&lt;html>
  &lt;body>
    &lt;ul>
      &lt;li>Quote 1&lt;/li>
      &lt;li>Quote 2 with &lt;a href="...">link&lt;/a>&lt;/li>
      &lt;li>Quote 3 with &lt;a href="...">another link&lt;/a>&lt;/li>
      &lt;li>&lt;h2>Quote 4 title&lt;/h2> ...&lt;/li>
    &lt;/ul>
  &lt;/body>
&lt;/html></code>

Say we want to select only the first <code>li</code> node from the snippet above. 
We can do this with:

//li[position() = 1]


The expression surrounded by square brackets is called a predicate and it filters the node set returned by <code>//li</code> (that is, all <code>li</code> nodes from the document) using the given condition. 
In this case it checks each node's position using the <code>position()</code> function, which returns the position of the current node in the resulting node set (notice that positions in XPath start at 1, not 0). 
We can abbreviate the expression above to:

//li[1]


Both XPath expressions above would select the following element:

    &lt;li class="quote">Quote 1&lt;/li>


Check out a few more predicate examples:

<table>
<tbody>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
<tr>
<td>//li[position()%2=0]</td>
<td>Selects the <code>li</code> elements at even positions.</td>
</tr>
<tr>
<td>//li[a]</td>
<td>Selects the <code>li</code> elements which enclose an <code>a</code> element.</td>
</tr>
<tr>
<td>//li[a or h2]</td>
<td>Selects the <code>li</code> elements which enclose either an <code>a</code> or an <code>h2</code> element.</td>
</tr>
<tr>
<td>//li[ a [ text() = "link" ] ]</td>
<td>Selects the <code>li</code> elements which enclose an <code>a</code> element whose text is "link". 
Can also be written as <code>//li[ a/text()="link" ]</code>.</td>
</tr>
<tr>
<td>//li[last()]</td>
<td>Selects the last <code>li</code> element in the document.</td>
</tr>
</tbody>
</table>
So, a location path is basically composed by steps, which are separated by <code>/</code> and each step can have an axis, a node test and a predicate. 
Here we have an expression composed by two steps, each one with axis, node test and predicate:

&lt;span style="font-weight: 400;">//li[ 4 ]/h2[ text() = "Quote 4 title" ]&lt;/span>


And here is the same expression, written using the non-abbreviated syntax:

/descendant-or-self::node()<br>
    /child::li[ position() = 4 ]<br>
        /child::h2[ text() = "Quote 4 title" ]


We can also <k>combine</k> multiple XPath expressions in a single one using the union operator <code>|</code>. 
For example, we can select all <code>a</code> and <code>h2</code> elements in the document above using this expression:

//a | //h2


Now, consider this HTML document:

<code>&lt;html>
  &lt;body>
    &lt;ul>
      &lt;li id="begin">&lt;a href="https://scrapy.org">Scrapy&lt;/a>&lt;/li>
      &lt;li>&lt;a href="https://scrapinghub.com">Scrapinghub&lt;/a>&lt;/li>
      &lt;li>&lt;a href="https://blog.scrapinghub.com">Scrapinghub Blog&lt;/a>&lt;/li>
      &lt;li id="end">&lt;a href="http://quotes.toscrape.com">Quotes To Scrape&lt;/a>&lt;/li>
    &lt;/ul>
  &lt;/body>
&lt;/html></code>

Say we want to select only the <code>a</code> elements whose link points to an HTTPS URL. 
We can do it by checking their <code>href</code> <k>attribute</k>:

//a[starts-with(@href, "https")]


This expression first selects all the <code>a</code> elements from the document and for each of those elements, it checks whether their <code>href</code> attribute starts with "https". 
We can access any node attribute using the <code>@attributename</code> syntax.

Here we have a few additional examples using attributes:

<table>
<tbody>
<tr>
<th>Expression</th>
<th>Meaning</th>
</tr>
<tr>
<td>//a[@href="https://scrapy.org"]</td>
<td>Selects the <code>a</code> elements pointing to https://scrapy.org.</td>
</tr>
<tr>
<td>//a/@href</td>
<td>Selects the value of the <code>href</code> attribute from all the <code>a</code> elements in the document.</td>
</tr>
<tr>
<td>//li[@id]</td>
<td>Selects only the <code>li</code> elements which have an <code>id</code> attribute.</td>
</tr>
</tbody>
</table>
<h3>More on Axes</h3>
We've seen only two types of axes so far:

descendant-or-self
child

But there's plenty more where they came from and we'll see a few examples. 
Consider this HTML document:

<code>&lt;html>
  &lt;body>
    &lt;p>Intro paragraph&lt;/p>
    &lt;h1>Title #1&lt;/h1>
    &lt;p>A random paragraph #1&lt;/p>
    &lt;h1>Title #2&lt;/h1>
    &lt;p>A random paragraph #2&lt;/p>
    &lt;p>Another one #2&lt;/p>
    A single paragraph, with no markup
    &lt;div id="footer">&lt;p>Footer text&lt;/p>&lt;/div>
  &lt;/body>
&lt;/html></code>

Now we want to extract only the first paragraph after each of the titles. 
To do that, we can use the <code>following-sibling</code> axis, which selects all the siblings after the context node. 
Siblings are nodes who are children of the same parent, for example all children nodes of the <code>body</code> tag are siblings. 
This is the expression:

//h1/following-sibling::p[1]


In this example, the context node where the <code>following-sibling</code> axis is applied to is each of the <code>h1</code> nodes from the page.

What if we want to select only the text that is right before the <code>footer</code>? We can use the <code>preceding-sibling</code> axis:

//div[@id='footer']/preceding-sibling::text()[1]


In this case, we are selecting the first text node before the <code>div</code> footer (<em>"A single paragraph, with no markup"</em>).

XPath also allows us to select elements based on their text content. 
We can use such a feature, along with the <code>parent</code> axis, to select the parent of the <code>p</code> element whose text is "Footer text":

//p[ text()="Footer text" ]/..


The expression above selects <code>&lt;div id="footer">&lt;p>Footer text&lt;/p>&lt;/div></code>. 
As you may have noticed, we used <code>..</code> here as a shortcut to the <code>parent</code> axis.

As an alternative to the expression above, we could use:

//*[p/text()="Footer text"]


It selects, from all elements, the ones that have a <code>p</code> child which text is "Footer text", getting the same result as the previous expression.

You can find additional axes in the XPath specification: https://www.w3.org/TR/xpath/#axes

<h3>Wrap up</h3>
XPath is very powerful and this post is just an introduction to the basic concepts. 
If you want to learn more about it, check out these resources:

http://zvon.org/comp/r/tut-XPath_1.html
http://fr.slideshare.net/scrapinghub/xpath-for-web-scraping
https://blog.scrapinghub.com/2014/07/17/xpath-tips-from-the-web-scraping-trenches/

And <k>stay tuned</k>, because we will post a series with more XPath tips from the trenches in the following months.

<h2>to handle UTF</h2>
options("encoding" = "native.enc") # this is the natural environment
Sys.setlocale(category = 'LC_ALL', 'Chinese')	# to show chinese
# Sys.getlocale()
# options("encoding")

theNewsHeader = readLines("newsHeader.txt", encoding="UTF-8") # load UTF-8 file
options("encoding" = "UTF-8") # write UTF-8
sink("temp.html")

<h2><span class="gold embossts">R jsonlite to handle JSON</span></h2>
install.packages("jsonlite")
library(jsonlite)

# convert data frame to JSON array
my.json &lt;- toJSON(mtcars)

# convert JSON array to data frame
my.df &lt;- fromJSON(my.json)

# check data equality
all.equal(mtcars, my.df)
[1] TRUE

- set simplifyVector to FALSE, fromJSON will keep the raw JSON structure
ie, convert to list
fromJSON(json, simplifyVector = FALSE)

- fromJSON will convert multiple JSON structures to data frame
we may convert JSOn to data frame, and after fiddling, toJSON back to JSON.

- fromJSON will convert JSON matrix to R matrix

- higher order dimension JSON will be converted to R matrixs

<h2>Extract Components from Lists</h2>
Using [ ]
to extract a list components

Using [[ ]]
to extract only a single component

<h2>to view a list or dataframe</h2>
names(test), summary(test), head(test), tail(test), str(test)
typeof(test)

<h2>R function: cut</h2>
v &lt;- c( 8, 13, 19, 3, 14, 7, 6, 12, 18, 9, 7, 14, 2, 3, 8, 11, 17)
c &lt;- cut(v, c(0, 5, 10, 15, 20))
str(c)
 Factor w/ 4 levels "(0,5]","(5,10]",..: 2 3 4 1 3 2 2 3 4 2 ...

c # shows every element's category
#
#  [1] (5,10]  (10,15] (15,20] (0,5]   (10,15] (5,10]  (5,10]  (10,15] (15,20]
# [10] (5,10]  (5,10]  (10,15] (0,5]   (0,5]   (5,10]  (10,15] (15,20]

# Levels: (0,5] (5,10] (10,15] (15,20]

<h2>use cumsum() to create cumulative frequency graph</h2>

dataset = sample(1:20,100, replace= TRUE)
breaks = seq(0, 20, by=2) 
datasetCategory = cut(dataset, breaks, right=FALSE) 
dataset.freq = table(datasetCategory)

barplot(dataset.freq) # this show every category but not cumulative

We then compute its cumulative frequency with cumsum, add a starting zero element, and plot the graph.

cumfreq0 = c(0, cumsum(dataset.freq)) 
plot(breaks, cumfreq0,                 # plot the data 
 main="Old Faithful Eruptions",        # main title 
 xlab="dataset minutes",               # x−axis label 
 ylab="cumulative frequency graph")    # y−axis label 
lines(breaks, cumfreq0)                # join the points

<h2>to prevent scientific notation</h2>
Use a large positive value like 999 in options:
options(scipen=999)
to revert it back, the default scipen is 0

<h2>process daily data</h2>
# kline_dayqfq={"code":0,"msg":"","data":{"hk00700":{"qfqday":[["2020-01-14","410.000","400.400","413.000","396.600","26827634.000",{},"0.000","1086386.492"],

library(jsonlite)
urlAddr = "http://web.ifzq.gtimg.cn/appstock/app/hkfqkline/get?_var=kline_dayqfq&param=hk00700,day,,,40,qfq"

my.json &lt;- readLines(urlAddr, warn=F)
my.json = gsub("kline_dayqfq=","",my.json) # remove the leading command

my.dataframe = fromJSON(my.json)
my.dataframe = my.dataframe[[3]][[1]][[1]] # 40 obs., list of list
# chr "2020-01-14"   Date   1
# chr "410.000"      open   2
# chr "400.400"      close  3
# chr "413.000"      high   4
# chr "396.600"      low    5
# chr "26827634.000" Qty    6
# Named list()              7
# chr "0.000"               8
# chr "1086386.492"  Amt    9

my.dataframe[[1]][1]  # date
my.dataframe[[1]][3]  # close

for (i in 1:40){      # remove column 7
  my.dataframe[[i]] = my.dataframe[[i]][-(7:8)]
}

dataMatrix = matrix(unlist(my.dataframe), nrow=40, ncol=7)  # convert to matrix

<h2>process minute data</h2>
# {"code":0,"msg":"","data":{"hk00981":{"data":[{"date":"20200311","data":["0930 14.460 346508","0931 14.460 1564508",

library(jsonlite)
urlAddr = "http://web.ifzq.gtimg.cn/appstock/app/day/query?code=hk00981"
my.json &lt;- readLines(urlAddr, warn=F)
my.dataframe = fromJSON(my.json)
# str(my.dataframe), only the third item is useful
# List of 3
#  $ code: int 0
#  $ msg : chr ""
#  $ data:List of 1

my.dataframe = my.dataframe[[3]][[1]][[1]] # 5 obs. of  3 variables:"date" "data" "prec"
# names(my.dataframe)
my.list = my.dataframe[[2]] # this object is a list of five vectors, most recent day on top

datalist = unlist(my.list) # this is all strings in one vector


<h2>statistics of minute data</h2>
# {"code":0,"msg":"","data":{"hk00981":{"data":[{"date":"20200311","data":["0930 14.460 346508","0931 14.460 1564508",

library(jsonlite)
urlAddr = "http://web.ifzq.gtimg.cn/appstock/app/day/query?code=hk00388"
my.json &lt;- readLines(urlAddr, warn=F)
my.dataframe = fromJSON(my.json)
# str(my.dataframe), only list 3 is useful
# List of 3
#  $ code: int 0
#  $ msg : chr ""
#  $ data:List of 1

my.dataframe = my.dataframe[[3]][[1]][[1]] # 5 obs. of  3 variables:"date" "data" "prec", 5 obs for 5days
# names(my.dataframe)
my.list = my.dataframe[[2]] # this object is a list of five vectors, nearest day on top

datalist = unlist(my.list) # this is all strings in one vector

datalist = gsub("^.* ","",datalist) # this is the amount
datalist = round(as.numeric(datalist)/10000,0) # units in wan
datalist = sort(datalist)
datalist = datalist[-(1:20)]
datalist = datalist[-( (length(datalist)-20):length(datalist))] # remove the extremes

# max(datalist); min(datalist); length(datalist)

sections &lt;- cut(datalist, breaks = 100)
table(sections)
barplot(table(sections))

cumulative sums
plot(cumsum(table(sections)))

<h2>R examples</h2>
https://www.datamentor.io/r-programming/examples/
http://www.rexamples.com
https://www.guru99.com/r-tutorial.html
https://r4stats.com/examples/programming/
https://www.statmethods.net/r-tutorial/index.html
http://rprogramming.net

<h2>output text to the R console in color</h2>
library(crayon)
cat(blue("Hello", "world!\n"))

Genaral styles
reset, bold
blurred (usually called ‘dim’, renamed to avoid name clash)
italic (not widely supported)
underline, inverse, hidden
strikethrough (not widely supported)

Text colors
black, red, green, yellow, blue, magenta, cyan, white
silver (usually called ‘gray’, renamed to avoid name clash)

Background colors
bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan, bgWhite

Styling
The styling functions take any number of character vectors as arguments, and they concatenate and style them:

Crayon defines the %+% string concatenation operator, to make it easy to assemble stings with different styles.

cat("... to highlight the " %+%
    red("search term") %+%
    " in a block of text\n")

Styles can be combined using the $ operator:
  cat(yellow$bgMagenta$bold('Hello world!\n'))
See also combine_styles().

Styles can also be nested, and then inner style takes precedence:
  cat(green(
    'I am a green line ' %+%
    blue$underline$bold('with a blue substring') %+%
    ' that becomes green again!\n'
  ))

define your own themes:
  error &lt;- red $ bold
  warn &lt;- magenta $ underline
  note &lt;- cyan
  cat(error("Error: subscript out of bounds!\n"))
  cat(warn("Warning: shorter argument was recycled.\n"))
  cat(note("Note: no such directory.\n"))

See Also make_style() for using the 256 ANSI colors.

Examples
cat(blue("Hello", "world!"))
cat("... to highlight the " %+% red("search term") %+%
    " in a block of text")
cat(yellow$bgMagenta$bold('Hello world!'))
cat(green(
 'I am a green line ' %+%
 blue$underline$bold('with a blue substring') %+%
 ' that becomes green again!'
))
error &lt;- red $ bold
warn &lt;- magenta $ underline
note &lt;- cyan
cat(error("Error: subscript out of bounds!\n"))
cat(warn("Warning: shorter argument was recycled.\n"))
cat(note("Note: no such directory.\n"))

<h3>style - Add Style To A String</h3>
Usage
style(string, as = NULL, bg = NULL)
cat(style("I am pink\n", "pink"))
cat(style("#4682B433\n", "#4682B433"))
cat(style("#002050\n", "#002050"))


<h3>rgb()</h3>
To use the function:
rgb(red, green, blue, alpha) : quantity of red (between 0 and 1), of green and of blue, and finally transparency (alpha).
newcolor = rgb(0.5, 0.2, 0.1, 0.8)
newcolor
"#80331ACC"

cat(style("newcolor\n", newcolor))  # note, without quotation marks


<h3>make_style</h3>
pink &lt;- make_style("pink")
bgMaroon &lt;- make_style(rgb(0.93, 0.19, 0.65), bg = TRUE)
cat(bgMaroon(pink("pink style.\n")))

## Create a new style for pink and maroon background
make_style(pink = "pink")
make_style(bgMaroon = rgb(0.0, 0.3, 0.3), bg = TRUE)
"pink" %in% names(styles())
"bgMaroon" %in% names(styles())

cat(style("I am pink, too!\n", "pink"))
cat(style("I am pink, too!\n", "pink", bg = "blue")) # color will change
cat(style("I am pink, too!\n", "pink", bg = "bgMaroon"))
cat(style("I am pink, too!\n", "pink", bg = "cyan"))

<h2>print strings with wordwraps</h2>

strwrap(astring, width = 110, indent = 5, exdent = 2))
use writeLines to print it
note: control characters inside string will be ignored.

astring = "Substituted with the text matched by the capturing group that can be found by counting as many opening parentheses of named or numbered capturing groups as specified by the number from right to left starting at the backreference."

writeLines(strwrap(astring, width = 110, indent = 5, exdent = 2))

<h2>R.utils withTimeout()</h2>

withTimeout() from package R.utils, in concert with tryCatch(), might provide a cleaner solution.

For example:
require(R.utils)

for(i in 1:5) {
    tryCatch(
        expr = {
            withTimeout({Sys.sleep(i); cat(i, "\n")}, 
                         timeout = 3.1)
            }, 
        TimeoutException = function(ex) cat("Timeout. Skipping.\n")
    )
}

# 1 
# 2 
# 3 
# Timeout. Skipping.
# Timeout. Skipping.

In the artificial example above:

The first argument to withTimeout() contains the code to be evaluated within each loop.

The timeout argument to withTimeout() sets the time limit in seconds.

The TimeoutException argument to tryCatch() takes a function that is to be executed when an iteration of the loop is timed out.

<h2>drawing SVG</h2>
<a href="https://cran.r-project.org/web/packages/RIdeogram/vignettes/RIdeogram.html" class="whitebut ">RIdeogram: drawing SVG graphics</a>

<a href="https://cran.r-project.org/web/packages/magick/vignettes/intro.html" class="whitebut ">Magick: Advanced Image-Processing</a>

<a href="http://ralanbutler.com/blog/2016/03/31/animated-SVG-R" class="whitebut ">Animating an SVG</a>

svglite + ggsave function
Saving a plot as an SVG

sample code:
require("ggplot2")

#some sample data
head(diamonds) 

#to see actually what will be plotted and compare 
qplot(clarity, data=diamonds, fill=cut, geom="bar")

#save the plot in a variable image to be able to export to svg
image=qplot(clarity, data=diamonds, fill=cut, geom="bar")

#This actually save the plot in a image
ggsave(file="test.svg", plot=image, width=10, height=8)

<h2>Package ‘TTR’</h2>
Technical Trading Rules
x=c(1,2,4,3,5,6,5,4,5,6,7,9,10,11,10)

Usage
SMA(x, n = 4)
EMA(x, n = 4)
DEMA(x, n = 4)
WMA(x, n = 4, wts = 1:n)
EVWMA(price, volume, n = 4)
ZLEMA(x, n = 4, ratio = NULL)
VWAP(price, volume, n = 4)
VMA(x, w, ratio = 1)
HMA(x, n = 20)
ALMA(x, n = 9, offset = 0.85, sigma = 6)

<h3>Weighted moving average WMA</h3>
<img class="lazy" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Weighted_moving_average_weights_N%3D15.png/220px-Weighted_moving_average_weights_N%3D15.png">

<h3>Exponential moving average EMA</h3>
EMA is more exagerating

<img class="lazy" data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/Exponential_moving_average_weights_N%3D15.png/220px-Exponential_moving_average_weights_N%3D15.png">

<h2>自然语言处理中的Transformer和BERT</h2>
2018年马上就要过去，回顾深度学习在今年的进展，让人印象最深刻的就是谷歌提出的应用于自然语言处理领域的BERT解决方案，BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding（<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1810.04805">
https://arxiv.org/abs/1810.04805</a>）。
BERT解决方案刷新了各大NLP任务的榜单，在各种NLP任务上都做到state of the art。
这里我把BERT说成是解决方案，而不是一个算法，因为这篇文章并没有提出新的算法模型，还是沿用了之前已有的算法模型。
BERT最大的创新点，在于提出了一套完整的方案，利用之前最新的算法模型，去解决各种各样的NLP任务，因此BERT这篇论文对于算法模型完全不做介绍，以至于在我直接看这篇文章的时候感觉云里雾里。
但是本文中，我会从算法模型到解决方案，进行完整的诠释。
本文中我会分3个部分进行介绍，第一部分我会大概介绍一下NLP的发展，第二部分主要讲BERT用到的算法，最后一部分讲BERT具体是怎么操作的。

<h3>一，NLP的发展</h3>
要处理NLP问题，首先要解决文本的表示问题。
虽然我们人去看文本，能够清楚明白文本中的符号表达什么含义，但是计算机只能做数学计算，需要将文本表示成计算机可以处理的形式。
最开始的方法是采用one hot，比如，我们假设英文中常用的单词有3万个，那么我们就用一个3万维的向量表示这个词，所有位置都置0，当我们想表示apple这个词时，就在对应位置设置1，如图1.1所示。
这种表示方式存在的问题就是，高维稀疏，高维是指有多少个词，就需要多少个维度的向量，稀疏是指，每个向量中大部分值都是0。
另外一个不足是这个向量没有任何含义。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-597b011ddd148eb53b5a90730b6090ae_b.jpg">

<figcaption>图1.1</figcaption>
后来出现了词向量，word embedding，用一个低维稠密的向量去表示一个词，如图1.2所示。
通常这个向量的维度在几百到上千之间，相比one hot几千几万的维度就低了很多。
词与词之间可以通过相似度或者距离来表示关系，相关的词向量相似度比较高，或者距离比较近，不相关的词向量相似度低，或者距离比较远，这样词向量本身就有了含义。
文本的表示问题就得到了解决。
词向量可以通过一些无监督的方法学习得到，比如CBOW或者Skip-Gram等，可以预先在语料库上训练出词向量，以供后续的使用。
顺便提一句，在图像中就不存在表示方法的困扰，因为图像本身就是数值矩阵，计算机可以直接处理。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-840859265e735cce77233bb42a4bee6a_b.png">

<figcaption>图1.2</figcaption>
NLP中有各种各样的任务，比如分类（Classification），问答（QA），实体命名识别（NER）等。
对于这些不同的任务，最早的做法是根据每类任务定制不同的模型，输入预训练好的embedding，然后利用特定任务的数据集对模型进行训练，如图1.3所示。
这里存在的问题就是，不是每个特定任务都有大量的标签数据可供训练，对于那些数据集非常小的任务，恐怕就难以得到一个理想的模型。


<img class="lazy" data-src="https://pic1.zhimg.com/v2-4546b7aa51af50d3ac0c7504f965cc70_b.jpg">

<figcaption>图1.3</figcaption>
我们看一下图像领域是如何解决这个问题的。
图像分类是计算机视觉中最基本的任务，当我要解决一个小数据集的图像分类任务时，该怎么做？CV领域已经有了一套成熟的解决方案。
我会用一个通用的网络模型，比如Vgg，ResNet或者GoogleNet，在ImageNet上做预训练（pre-training）。
ImageNet有1400万张有标注的图片，包含1000个类别，这样的数据规模足以训练出一个规模庞大的模型。
在训练过程中，模型会不断的学习如何提取特征，底层的CNN网络结构会提取边缘，角，点等通用特征，模型越往上走，提取的特征也越抽象，与特定的任务更加相关。
当完成预训练之后，根据我自己的分类任务，调整最上层的网络结构，然后在小数据集里对模型进行训练。
在训练时，可以固定住底层的模型参数只训练顶层的参数，也可以对整个模型进行训练，这个过程叫做微调（fine-tuning），最终得到一个可用的模型。
总结一下，整个过程包括两步，拿一个通用模型在ImageNet上做预训练（pre-training），然后针对特定任务进行微调（fine-tuning），完美解决了特定任务数据不足的问题。
还有一个好处是，对于各种各样的任务都不再需要从头开始训练网络，可以直接拿预训练好的结果进行微调，既减少了训练计算量的负担，也减少了人工标注数据的负担。

NLP领域也引入了这种做法，用一个通用模型，在非常大的语料库上进行预训练，然后在特定任务上进行微调，BERT就是这套方案的集大成者。
BERT不是第一个，但目前为止，是效果最好的方案。
BERT用了一个已有的模型结构，提出了一整套的预训练方法和微调方法，我们在后文中再进行详细的描述。

<h3>二，算法</h3>
BERT所采用的算法来自于2017年12月份的这篇文章，Attenion Is All You Need（<a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1706.03762">
https://arxiv.org/abs/1706.03762</a>），同样来自于谷歌。
这篇文章要解决的是翻译问题，比如从中文翻译成英文。
这篇文章完全放弃了以往经常采用的RNN和CNN，提出了一种新的网络结构，即Transformer，其中包括encoder和decoder，我们只关注encoder。
这篇英文博客（<a href="https://link.zhihu.com/?target=https%3A//jalammar.github.io/illustrated-transformer/">
https://jalammar.github.io/illustrated-transformer/</a>）对Transformer介绍得非常详细，有兴趣的读者可以看一下，如果不想看英文博客也可以看本文，本文中的部分图片也截取自这篇博客。


<img class="lazy" data-src="https://pic4.zhimg.com/v2-393d5284f5132c3150b294cfc5e5218f_b.jpg">

<figcaption>图2.1</figcaption>
图2.1是Transformer encoder的结构，后文中我们都简称为Transformer。
首先是输入word embedding，这里是直接输入一整句话的所有embedding。
如图2.1所示，假设我们的输入是Thinking Machines，每个词对应一个embedding，就有2个embedding。
输入embedding需要加上位置编码（Positional Encoding），为什么要加位置编码，后文会做详细介绍。
然后经过一个Multi-Head Attention结构，这个结构是算法单元中最重要的部分，我们会在后边详细介绍。
之后是做了一个shortcut的处理，就是把输入和输出按照对应位置加起来，如果了解残差网络（ResNet）的同学，会对这个结构比较熟悉，这个操作有利于加速训练。
然后经过一个归一化normalization的操作。
接着经过一个两层的全连接网络，最后同样是shortcut和normalization的操作。
可以看到，除了Multi-Head Attention，都是常规操作，没有什么难理解的。
这里需要注意的是，每个小模块的输入和输出向量，维度都是相等的，比如，Multi-Head Attention的输入和输出向量维度是相等的，否则无法进行shortcut的操作；Feed Forward的输入和输出向量维度也是相等的；最终的输出和输入向量维度也是相等的。
但是Multi-Head Attention和Feed Forward内部，向量维度会发生变化。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-4019f1ffead184e3bc00aabb41e6b6b6_b.jpg">

<figcaption>图2.2</figcaption>
我们来详细看一下Multi-Head Attention的结构。
这个Multi-Head表示多头的意思，先从最简单的看起，看看单头Attention是如何操作的。
从图2.1的橙色方块可以看到，embedding在进入到Attention之前，有3个分叉，那表示说从1个向量，变成了3个向量。
具体是怎么算的呢？我们看图2.3，定义一个WQ矩阵（这个矩阵随机初始化，通过训练得到），将embedding和WQ矩阵做乘法，得到查询向量q，假设输入embedding是512维，在图3中我们用4个小方格表示，输出的查询向量是64维，图3中用3个小方格以示不同。
然后类似地，定义WK和WV矩阵，将embedding和WK做矩阵乘法，得到键向量k；将embeding和WV做矩阵乘法，得到值向量v。
对每一个embedding做同样的操作，那么每个输入就得到了3个向量，查询向量，键向量和值向量。
需要注意的是，查询向量和键向量要有相同的维度，值向量的维度可以相同，也可以不同，但一般也是相同的。


<img class="lazy" data-src="https://pic1.zhimg.com/v2-ac045486e0eff3b8a1eb27d2ae61a634_b.jpg">

<figcaption>图2.3</figcaption>
接下来我们计算每一个embedding的输出，以第一个词Thinking为例，参看图2.4。
用查询向量q1跟键向量k1和k2分别做点积，得到112和96两个数值。
这也是为什么前文提到查询向量和键向量的维度必须要一致，否则无法做点积。
然后除以常数8，得到14和12两个数值。
这个常数8是键向量的维度的开方，键向量和查询向量的维度都是64，开方后是8。
做这个尺度上的调整目的是为了易于训练。
然后把14和12丢到softmax函数中，得到一组加和为1的系数权重，算出来是大约是0.88和0.12。
将0.88和0.12对两个值向量v1和v2做加权求和，就得到了Thinking的输出向量z1。
类似的，可以算出Machines的输出z2。
如果一句话中包含更多的词，也是相同的计算方法。


<img class="lazy" data-src="https://pic2.zhimg.com/v2-b25bb6a8f9b57a4831b485015080b8c1_b.jpg">

<figcaption>图2.4</figcaption>
通过这样一系列的计算，可以看到，现在每个词的输出向量z都包含了其他词的信息，每个词都不再是孤立的了。
而且每个位置中，词与词的相关程度，可以通过softmax输出的权重进行分析。
如图2.5所示，这是某一次计算的权重，其中线条颜色的深浅反映了权重的大小，可以看到it中权重最大的两个词是The和animal，表示it跟这两个词关联最大。
这就是attention的含义，输出跟哪个词关联比较强，就放比较多的注意力在上面。
上面我们把每一步计算都拆开了看，实际计算的时候，可以通过矩阵来计算，如图2.6所示。


<img class="lazy" data-src="https://pic2.zhimg.com/v2-2dbdd8dfb5088d22c7dd9d05a0e1035d_b.jpg">

<figcaption>图2.5</figcaption>


<img class="lazy" data-src="https://pic4.zhimg.com/v2-a02ab6ab4cad1f8fef307ced0a4cf9d3_b.jpg" data-caption="">


<img class="lazy" data-src="https://pic2.zhimg.com/v2-d00785a9cfb835b5a345898e37b31be9_b.jpg">

<figcaption>图2.6</figcaption>
讲完了attention，再来讲Multi-Head。
对于同一组输入embedding，我们可以并行做若干组上面的操作，例如，我们可以进行8组这样的运算，每一组都有WQ，WK，WV矩阵，并且不同组的矩阵也不相同。
这样最终会计算出8组输出，我们把8组的输出连接起来，并且乘以矩阵WO做一次线性变换得到输出，WO也是随机初始化，通过训练得到，计算过程如图2.7所示。
这样的好处，一是多个组可以并行计算，二是不同的组可以捕获不同的子空间的信息。



<img class="lazy" data-src="https://pic3.zhimg.com/v2-2afc28e06f5550d5e20a2dc290f2224e_b.jpg">

<figcaption>图2.7</figcaption>
到这里就把Transformer的结构讲完了，同样都是做NLP任务，我们来和RNN做个对比。
图2.8是个最基本的RNN结构，还有计算公式。
当计算隐向量h4时，用到了输入x4，和上一步算出来的隐向量h3，h3包含了前面所有节点的信息。
h4中包含最多的信息是当前的输入x4，越往前的输入，随着距离的增加，信息衰减得越多。
对于每一个输出隐向量h都是如此，包含信息最多得是当前的输入，随着距离拉远，包含前面输入的信息越来越少。
但是Transformer这个结构就不存在这个问题，不管当前词和其他词的空间距离有多远，包含其他词的信息不取决于距离，而是取决于两者的相关性，这是Transformer的第一个优势。
第二个优势在于，对于Transformer来说，在对当前词进行计算的时候，不仅可以用到前面的词，也可以用到后面的词。
而RNN只能用到前面的词，这并不是个严重的问题，因为这可以通过双向RNN来解决。
第三点，RNN是一个顺序的结构，必须要一步一步地计算，只有计算出h1，才能计算h2，再计算h3，隐向量无法同时并行计算，导致RNN的计算效率不高，这是RNN的固有结构所造成的，之前有一些工作就是在研究如何对RNN的计算并行化。
通过前文的介绍，可以看到Transformer不存在这个问题。
通过这里的比较，可以看到Transformer相对于RNN有巨大的优势，因此我看到有人说RNN以后会被取代。


<img class="lazy" data-src="https://pic1.zhimg.com/v2-5bafe804c0dc77f945ade48561de63a0_b.jpg" data-caption="">


<img class="lazy" data-src="https://pic1.zhimg.com/v2-235854b916c55c54bbcad343443885c0_b.jpg">

<figcaption>图2.8</figcaption>
关于上面的第三点优势，可能有人会不认可，RNN的结构包含了序列的时序信息，而Transformer却完全把时序信息给丢掉了。
为了解决时序的问题，Transformer的作者用了一个绝妙的办法，这就是我在前文提到的位置编码（Positional Encoding）。
位置编码是和word embedding同样维度的向量，将位置embedding和词embedding加在一起，作为输入embedding，如图2.9所示。
位置编码可以通过学习得到，也可以通过设置一个跟位置或者时序相关的函数得到，比如设置一个正弦或者余弦函数，这里不再多说。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-df4b9de6b9feb1971ab7225ebc4454d2_b.jpg">

<figcaption>图2.9</figcaption>
我们把图2.1的结构作为一个基本单元，把N个这样的基本单元顺序连起来，就是BERT的算法模型，如图2.10所示。
从前面的描述中可以看到，当输入有多少个embedding，那么输出也就有相同数量的embedding，可以采用和RNN采用相同的叫法，把输出叫做隐向量。
在做具体NLP任务的时候，只需要从中取对应的隐向量作为输出即可。


<img class="lazy" data-src="https://pic1.zhimg.com/v2-81e63e36210c8e342d193be69c441e7c_b.jpg">

<figcaption>图2.10</figcaption>
<h3>三，BERT</h3>
在介绍BERT之前，我们先看看另外一套方案。
我在第一部分说过，BERT并不是第一个提出预训练加微调的方案，此前还有一套方案叫GPT，这也是BERT重点对比的方案，文章在这，Improving Language Understanding by Generative Pre-Training（<a href="https://link.zhihu.com/?target=https%3A//s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf">
https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf</a>）。
GPT的模型结构和BERT是相同的，都是图2.10的结构，只是BERT的模型规模更加庞大。
GPT是这么预训练的，在一个8亿单词的语料库上做训练，给出前文，不断地预测下一个单词。
比如这句话，Winter is coming，当给出第一个词Winter之后，预测下一个词is，之后再预测下一个词coming。
不需要标注数据，通过这种无监督训练的方式，得到一个预训练模型。

我们再来看看BERT有什么不同。
BERT来自于Bidirectional Encoder Representations from Transformers首字母缩写，这里提到了一个双向（Bidirectional）的概念。
BERT在一个33亿单词的语料库上做预训练，语料库就要比GPT大了几倍。
预训练包括了两个任务，第一个任务是随机地扣掉15%的单词，用一个掩码MASK代替，让模型去猜测这个单词；第二个任务是，每个训练样本是一个上下句，有50%的样本，下句和上句是真实的，另外50%的样本，下句和上句是无关的，模型需要判断两句的关系。
这两个任务各有一个loss，将这两个loss加起来作为总的loss进行优化。
下面两行是一个小栗子，用括号标注的是扣掉的词，用[MASK]来代替。

<b>正样本：我[MASK]（是）个算法工程师，我服务于WiFi万能钥匙这家[MASK]（公司）。
</b>
<b>负样本：我[MASK]（是）个算法工程师，今天[MASK]（股票）又跌了。
</b>
我们来对比下GPT和BERT两种预训练方式的优劣。
GPT在预测词的时候，只预测下一个词，因此只能用到上文的信息，无法利用到下文的信息。
而BERT是预测文中扣掉的词，可以充分利用到上下文的信息，这使得模型有更强的表达能力，这也是BERT中Bidirectional的含义。
在一些NLP任务中需要判断句子关系，比如判断两句话是否有相同的含义。
BERT有了第二个任务，就能够很好的捕捉句子之间的关系。
图3.1是BERT原文中对另外两种方法的预训练对比，包括GPT和ELMo。
ELMo采用的还是LSTM，这里我们不多讲ELMo。
这里会有读者困惑，这里的结构图怎么跟图2.10不一样？如果熟悉LSTM的同学，看到最右边的ELMo，就会知道那些水平相连的LSTM其实只是一个LSTM单元。
左边的BERT和GPT也是一样，水平方向的Trm表示的是同一个单元，图中那些复杂的连线表示的是词与词之间的依赖关系，BERT中的依赖关系既有前文又有后文，而GPT的依赖关系只有前文。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-287ba1129d213df7e2ed5adb7c4a440e_b.jpg">

<figcaption>图3.1</figcaption>
讲完了这两个任务，我们再来看看，如何表达这么复杂的一个训练样本，让计算机能够明白。
图3.2表示“my dog is cute, he likes playing.”的输入形式。
每个符号的输入由3部分构成，一个是词本身的embedding；第二个是表示上下句的embedding，如果是上句，就用A embedding，如果是下句，就用B embedding；最后，根据Transformer模型的特点，还要加上位置embedding，这里的位置embedding是通过学习的方式得到的，BERT设计一个样本最多支持512个位置；将3个embedding相加，作为输入。
需要注意的是，在每个句子的开头，需要加一个Classification（CLS）符号，后文中会进行介绍，其他的一些小细节就不说了。


<img class="lazy" data-src="https://pic1.zhimg.com/v2-ec06762a57a7d7176747627dc3ee20b4_b.jpg">

<figcaption>图3.2</figcaption>
完成预训练之后，就要针对特定任务就行微调了，这里描述一下论文中的4个例子，看图3.4。
首先说下分类任务，分类任务包括对单句子的分类任务，比如判断电影评论是喜欢还是讨厌；多句子分类，比如判断两句话是否表示相同的含义。
图3.4（a）（b）是对这类任务的一个示例，左边表示两个句子的分类，右边是单句子分类。
在输出的隐向量中，取出CLS对应的向量C，加一层网络W，并丢给softmax进行分类，得到预测结果P，计算过程如图3.3中的计算公式。
在特定任务数据集中对Transformer模型的所有参数和网络W共同训练，直到收敛。
新增加的网络W是HxK维，H表示隐向量的维度，K表示分类数量，W的参数数量相比预训练模型的参数少得可怜。


<img class="lazy" data-src="https://pic3.zhimg.com/v2-61486f520243716de645f904e3a36ac2_b.jpg">

<figcaption>图3.3</figcaption>


<img class="lazy" data-src="https://pic3.zhimg.com/v2-42514100ab16b207d2732729c85fccaa_b.jpg">

<figcaption>图3.4</figcaption>
我们再来看问答任务，如图3.4（c），以SQuAD v1.1为例，给出一个问题Question，并且给出一个段落Paragraph，然后从段落中标出答案的具体位置。
需要学习一个开始向量S，维度和输出隐向量维度相同，然后和所有的隐向量做点积，取值最大的词作为开始位置；另外再学一个结束向量E，做同样的运算，得到结束位置。
附加一个条件，结束位置一定要大于开始位置。
最后再看NER任务，实体命名识别，比如给出一句话，对每个词进行标注，判断属于人名，地名，机构名，还是其他。
如图3.4（d）所示，加一层分类网络，对每个输出隐向量都做一次判断。
可以看到，这些任务，都只需要新增少量的参数，然后在特定数据集上进行训练即可。
从实验结果来看，即便是很小的数据集，也能取得不错的效果。

<h2>Delete Files unlink("data.txt")</h2>
Delete Files and Directories. unlink deletes the file(s) or directories specified by x .

Usage. unlink(x, recursive = FALSE, force = FALSE)

<h2>scan</h2>
Read data into a vector or list from the console or file.

cat("TITLE extra line", "2 3 5 7", "11 13 17", file = "ex.data", sep = "\n")
pp &lt;- scan("ex.data", skip = 1, quiet = TRUE)
scan("ex.data", skip = 1)
scan("ex.data", skip = 1, nlines = 1) # only 1 line after the skipped one
scan("ex.data", what = list("","","")) # flush is F -> read "7"
scan("ex.data", what = list("","",""), flush = TRUE)
unlink("ex.data") # tidy up

## "inline" usage
scan(text = "1 2 3")

<h2>Copy an R data.frame to an Excel spreadsheet</h2>
write.excel &lt;- function(x,row.names=FALSE,col.names=TRUE,...) {
  write.table(x,"clipboard",sep="\t",row.names=row.names,col.names=col.names,...)
}

write.excel(my.df)

and finally Ctr+V in Excel :)

<h2>copy a table x to the clipboard preserving the table structure</h2>
write.table(x, "clipboard", sep="\t")

write.table(x, "clipboard", sep="\t", row.names=FALSE)
write.table(x, "clipboard", sep="\t", row.names=FALSE, col.names=FALSE)

s = c('aa','gb','rc')
n = c('af','rd','ac')
df = data.frame(n,s)

write.table(df, "clipboard", sep="\t", row.names=FALSE, col.names=FALSE)

"af"	"aa"
"rd"	"gb"
"ac"	"rc"

<h2>read.table</h2>
reads a file into data frame in table format

x &lt;- read.table("tp.txt",header=T,sep="\t");

<h3>copy a table from the clipboard</h3>
x &lt;- read.table("clipboard",header=F,sep="\t");

<h2>reading text file with multiple space as delimiter</h2>
change delimiter.
" " refers to one whitespace character.
"" refers to any length whitespace as being the delimiter

data = read.table(file, header = F , nrows = 100, sep = "" , na.strings ="", stringsAsFactors= F)

<h2>distributed programming</h2>
reasons for distributed programming:

To speed up a process or piece of code
To scale up an interface or application for multiple users

<a href="http://spark.apache.org/docs/latest/sparkr.html" class="whitebut ">SparkR</a>: R on Apache Spark

SparkR provides an R frontend to Apache Spark and using Spark’s distributed computation engine allows us to run large scale data analysis from the R shell.

To get started you need to set up a Spark cluster. 
<a href="http://paxcel.net/blog/how-to-setup-apache-spark-standalone-cluster-on-multiple-machine/" class="whitebut ">SETUP APACHE SPARK STANDALONE CLUSTER ON MULTIPLE MACHINE</a>

The Spark documentation, without using Mesos or YARN as your cluster manager
<a href="http://spark.apache.org/docs/latest/spark-standalone.html" class="whitebut ">Spark Standalone Mode</a>

Once you have Spark set up, see <a href="https://rpubs.com/wendyu/sparkr" class="whitebut ">Wendy Yu's tutorial on SparkR</a>

She also shows how to integrate H20 with Spark which is referred to as 'Sparkling Water'.

R has been shipping with a base library parallel. 

In a nutshell, you can just do something like

mclapply(1:nCores, someFunction())
and the function someFunction() will be run in parallel over nCores. 
A default value of half your physical cores may be a good start.

<a href="https://cran.r-project.org/web/views/HighPerformanceComputing.html" class="whitebut ">High Performance Computing</a>

<h2>matrix operation</h2>
MatA &lt;- matrix(1:9, nrow = 3)  
MatB &lt;- matrix(9:1, nrow = 3)  
MatA + MatB

> A &lt;- matrix(c(2,3,-2,1,2,2),3,2)
> A

     [,1] [,2]
[1,]    2    1
[2,]    3    2
[3,]   -2    2
Is Something a Matrix
> <span class="orange">is.matrix(A)</span>

[1] TRUE

> is.vector(A)

[1] FALSE
<span class="orange">Multiplication by a Scalar</span>
> c &lt;- 3
> c*A

     [,1] [,2]
[1,]    6    3
[2,]    9    6
[3,]   -6    6
<span class="orange">Matrix Addition & Subtraction</span>
> B &lt;- matrix(c(1,4,-2,1,2,1),3,2)
> B

     [,1] [,2]
[1,]    1    1
[2,]    4    2
[3,]   -2    1

> C &lt;- A + B
> C 

     [,1] [,2]
[1,]    3    2
[2,]    7    4
[3,]   -4    3

> D &lt;- A - B
> D

     [,1] [,2]
[1,]    1    0
[2,]   -1    0
[3,]    0    1

<span class="orange">Matrix Multiplication</span>
> D &lt;- matrix(c(2,-2,1,2,3,1),2,3)
> D

     [,1] [,2] [,3]
[1,]    2    1    3
[2,]   -2    2    1

> C &lt;- D %*% A
> C

     [,1] [,2]
[1,]    1   10
[2,]    0    4

> C &lt;- A %*% D
> C

     [,1] [,2] [,3]
[1,]    2    4    7
[2,]    2    7   11
[3,]   -8    2   -4

> D &lt;- matrix(c(2,1,3),1,3)
> D

     [,1] [,2] [,3]
[1,]    2    1    3

> C &lt;- D %*% A
> C

     [,1] [,2]
[1,]    1   10

> C &lt;- A %*% D

Error in A %*% D : non-conformable arguments
<span class="orange">Transpose of a Matrix</span>
> AT &lt;- t(A)
> AT

     [,1] [,2] [,3]
[1,]    2    3   -2
[2,]    1    2    2

> ATT &lt;- t(AT)
>ATT

     [,1] [,2]
[1,]    2    1
[2,]    3    2
[3,]   -2    2

<h3>R matrix with 1 row</h3>
specify drop = FALSE to stop R coercing a matrix or array to the lowest possible number of dimensions.

x <- matrix(1:4,ncol=2)
x[1,]
[1] 1 2

x[1,,drop=F]
     [,1] [,2]
[1,]    1    3

<h3>Common Vectors</h3>
<span class="orange">Unit Vector</span>
> U &lt;- matrix(1,3,1)
> U

     [,1]
[1,]    1
[2,]    1
[3,]    1
<span class="orange">Zero Vector</span>
> Z &lt;- matrix(0,3,1)
> Z

     [,1]
[1,]    0
[2,]    0
[3,]    0
Common Matrices
<span class="orange">Unit Matrix</span>
> U &lt;- matrix(1,3,2)
> U

     [,1] [,2]
[1,]    1    1
[2,]    1    1
[3,]    1    1
<span class="orange">Zero Matrix</span>
> Z &lt;- matrix(0,3,2)
> Z

     [,1] [,2]
[1,]    0    0
[2,]    0    0
[3,]    0    0
<span class="orange">Diagonal Matrix</span>
> S &lt;- matrix(c(2,3,-2,1,2,2,4,2,3),3,3)
> S

     [,1] [,2] [,3]
[1,]    2    1    4
[2,]    3    2    2
[3,]   -2    2    3

> D &lt;- diag(S)
> D

[1] 2 2 3

> D &lt;- diag(diag(S))
> D

     [,1] [,2] [,3]
[1,]    2    0    0
[2,]    0    2    0
[3,]    0    0    3
<span class="orange">Identity Matrix</span>
> I &lt;- diag(c(1,1,1))
> I

     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
<span class="orange">Symmetric Matrix</span>
> C &lt;- matrix(c(2,1,5,1,3,4,5,4,-2),3,3)
> C

     [,1] [,2] [,3]
[1,]    2    1    5
[2,]    1    3    4
[3,]    5    4   -2

> CT &lt;- t(C)
> CT

     [,1] [,2] [,3]
[1,]    2    1    5
[2,]    1    3    4
[3,]    5    4   -2
<span class="orange">Inverse of a Matrix</span>
> A &lt;- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)
> A

     [,1] [,2] [,3]
[1,]    4    2    2
[2,]    4    6    8
[3,]   -2    2    4


> AI &lt;- solve(A)
> AI

     [,1] [,2] [,3]
[1,]  1.0 -0.5  0.5
[2,] -4.0  2.5 -3.0
[3,]  2.5 -1.5  2.0

> A %*% AI

     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1

> AI %*% A

     [,1] [,2] [,3]
[1,]    1    0    0
[2,]    0    1    0
[3,]    0    0    1
<span class="orange">Inverse & Determinant of a Matrix</span>
> C &lt;- matrix(c(2,1,6,1,3,4,6,4,-2),3,3)
> C

     [,1] [,2] [,3]
[1,]    2    1    6
[2,]    1    3    4
[3,]    6    4   -2

> CI &lt;- solve(C)
CI

           [,1]        [,2]        [,3]
[1,]  0.2156863 -0.25490196  0.13725490
[2,] -0.2549020  0.39215686  0.01960784
[3,]  0.1372549  0.01960784 -0.04901961

> d &lt;- det(C)
> d

[1] -102
<span class="orange">Rank of a Matrix</span>
> A &lt;- matrix(c(2,3,-2,1,2,2,4,7,0),3,3)
> A

     [,1] [,2] [,3]
[1,]    2    1    4
[2,]    3    2    7
[3,]   -2    2    0

> matA &lt;- qr(A)
> matA$rank

[1] 3

> A &lt;- matrix(c(2,3,-2,1,2,2,4,6,-4),3,3)
> A

     [,1] [,2] [,3]
[1,]    2    1    4
[2,]    3    2    6
[3,]   -2    2   -4

> matA &lt;- qr(A)
> matA$rank

[1] 2

# note column 3 is 2 times column 1
Number of Rows & Columns
> X &lt;- matrix(c(3,2,4,3,2,-2,6,1),4,2)
> X

     [,1] [,2]
[1,]    3    2
[2,]    2   -2
[3,]    4    6
[4,]    3    1

> <span class="orange">dim(X)</span>

[1] 4 2

> r &lt;- nrow(X)
> r

[1] 4

> c &lt;- ncol(X)
> c

[1] 2
Computing Column & Row Sums
# note the uppercase S

> A &lt;- matrix(c(2,3,-2,1,2,2),3,2)
> A

     [,1] [,2]
[1,]    2    1
[2,]    3    2
[3,]   -2    2

> c &lt;- colSums(A)
> c

[1] 3 5

> r &lt;- rowSums(A)
> r

[1] 3 5 0

> a &lt;- sum(A)
> a

[1] 8
<span class="orange">Computing Column & Row Means</span>
# note the uppercase M

> cm &lt;- colMeans(A)
> cm

[1] 1.000000 1.666667

> rm &lt;- rowMeans(A)
> rm

[1] 1.5 2.5 0.0

> m &lt;- mean(A)
> m

[1] 1.333333
<span class="orange">Horizontal Concatenation</span>
> A

     [,1] [,2]
[1,]    2    1
[2,]    3    2
[3,]   -2    2

> B &lt;- matrix(c(1,3,2,1,4,2),3,2)
> B

     [,1] [,2]
[1,]    1    1
[2,]    3    4
[3,]    2    2

> C &lt;- cbind(A,B)
> C

     [,1] [,2] [,3] [,4]
[1,]    2    1    1    1
[2,]    3    2    3    4
[3,]   -2    2    2    2
<span class="orange">Vertical Concatenation (Appending)</span>
> C &lt;- rbind(A,B)
> C

     [,1] [,2]
[1,]    2    1
[2,]    3    2
[3,]   -2    2
[4,]    1    1
[5,]    3    4
[6,]    2    2

<span class="orange">Matrix Operations in R</span>
A * B	Element-wise multiplication
A %*% B	Matrix multiplication
A %o% B	Outer product. AB'
crossprod(A,B)
crossprod(A)	A'B and A'A respectively.
t(A)	Transpose
diag(x)	Creates diagonal matrix with elements of x in the principal diagonal
diag(A)	Returns a vector containing the elements of the principal diagonal
diag(k)	If k is a scalar, this creates a k x k identity matrix. Go figure.
solve(A, b)	Returns vector x in the equation b = Ax (i.e., A-1b)
solve(A)	Inverse of A where A is a square matrix.
ginv(A)	Moore-Penrose Generalized Inverse of A.
ginv(A) requires loading the MASS package.
y&lt;-eigen(A)	y$val are the eigenvalues of A
y$vec are the eigenvectors of A
y&lt;-svd(A)	Single value decomposition of A.
y$d = vector containing the singular values of A
y$u = matrix with columns contain the left singular vectors of A
y$v = matrix with columns contain the right singular vectors of A
R &lt;- chol(A)	Choleski factorization of A. Returns the upper triangular factor, such that R'R = A.
y &lt;- qr(A)	QR decomposition of A.
y$qr has an upper triangle that contains the decomposition and a lower triangle that contains information on the Q decomposition.
y$rank is the rank of A.
y$qraux a vector which contains additional information on Q.
y$pivot contains information on the pivoting strategy used.
cbind(A,B,...)	Combine matrices(vectors) horizontally. Returns a matrix.
rbind(A,B,...)	Combine matrices(vectors) vertically. Returns a matrix.
rowMeans(A)	Returns vector of row means.
rowSums(A)	Returns vector of row sums.
colMeans(A)	Returns vector of column means.
colSums(A)	Returns vector of column sums.

<h2>UCLA stat</h2>
<a href="http://www.philender.com/courses/intro/" class="whitebut ">ucla.edu Introduction to Research Design and Statistics</a>
<a href="http://www.philender.com/courses/linearmodels/" class="whitebut ">Linear Statistical Models: Regression & Anova, Better Living Through Linear Models</a>
<a href="http://www.philender.com/courses/multivariate/" class="whitebut ">Multivariate Statistical Analysis</a>

<h2>R Linear Algebra</h2>
R is especially handy with linear algebra. 
Its built-in data types like vectors and matrices mesh well with built-in functions like eigenvalue and determinant solvers and dynamic indexing capabilities.

<h3>Vector Assignment</h3>
x &lt;- c(1, 2, 3, 4)
In most contexts, <code>&lt;-</code> can be switched with <code>=</code>.
The function <code>assign()</code> can also be used:
assign(&#x27;x&#x27;, c(1, 2, 3, 4))
Assignments can also be made in the other direction:
c(1, 2, 3, 4) -> x

<h3>Vector Operations</h3>Vectors can also be used in a variety of ways.
The operation<code> y &lt;- c(x, 0, x)</code> would assign a vector <code>1, 2, 3, 4, 0, 1, 2, 3, 4 </code>to variable <code>y</code>.
Vectors can be freely multiplied and added by constants:
v &lt;- 2*x + y + 1
Note that this operation is valid even when <code>x</code> and <code>y</code> are different lengths. 
In this case, R will simply recycle x (sometimes fractionally) until it meets the length of y. 
Since y is 9 numbers long and x is 4 units long, x will be repeated 2.25 times to match the length of y.
The arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>^</code> can all be used. 
<code>log</code>, <code>exp</code>, <code>sin</code>, <code>cos</code>, <code>tan</code>, <code>sqrt</code>, and more can also be used. 
<code>max(x)</code> and <code>min(x)</code> represent the largest and smallest elements of a vector <code>x</code>, and <code>length(x)</code> is the number of elements in <code>x</code>. 
<code>sum(x)</code> gives the total of the elements in <code>x</code>, and <code>prod(x)</code> their product.
<code>mean(x)</code> calculates the sample mean, and <code>var(x)</code> returns the sample variance. 
<code>sort(x)</code> returns a vector of the same size as x with elements arranged in increasing order.

<h3>Generating Sequences</h3>R has many methods for generating sequences of numbers. 
<code>1:30</code> is the same as <code>c(1, 2, …, 29, 30)</code>. 
The colon as the highest priority in an expression, so<code>2*1:15</code> will return <code>c(2, 4, …, 28, 30)</code> instead of <code>c(2, 3, …, 14, 15)</code>.
30:1 may be used to generate the sequence backwards.
The <code>seq()</code> function can also be used to generate sequences. 
<code>seq(2,10) </code>returns the same vector as <code>2:10</code>. 
In <code>seq()</code>, one can also specify the length of the step in which to take: <code>seq(1,2,by=0.5)</code> returns <code>c(1, 1.5, 2)</code>.
A similar function is <code>rep()</code>, which replicates an object in various ways. 
For example, <code>rep(x, times=5)</code> will return five copies of <code>x</code> end-to-end.

<h3>Logical Vectors</h3>Logical values in R are TRUE, FALSE, and NA. 
Logical vectors are set by conditions. 
<code>val &lt;- x > 13</code> sets <code>val</code> as a vector of the same length as <code>x</code> with values <code>TRUE</code> where the condition is met and <code>FALSE</code> where the condition is not.
The logical operators in r are <code>&lt;</code>, <code>&lt;=</code>, <code>></code>, <code>>=</code>, <code>==</code>, and <code>!=</code>, which mean less than, less than or equal to, greater than, greater than or equal to, equality, and inequality.

<h3>Missing Values</h3>The function <code>is.na(x)</code> returns a logical vector of the same size as <code>x</code> with <code>TRUE</code> if the corresponding element to <code>x</code> is <code>NA</code>.
<code>x == NA</code> is different from <code>is.na(x)</code> since <code>NA</code> is not a value but a marker for an unavailable quantity.
A second type of ‘missing value’ is that which is produced by numerical computation, such as <code>0/0</code>. 
In this case, <code>NaN</code> (Not a Number) values are treated as <code>NA</code> values; that is, <code>is.na(x)</code> will return <code>TRUE</code> for both <code>NA</code> and <code>NaN</code> values. 
<code>is.nan(x)</code> can be used only for identifying <code>NaN</code> values.

<h3>Indexing Vectors</h3>The first kind of indexing is through a logical vector. 
<code>y &lt;- x[!is.na(x)]</code> sets <code>y</code> to the values of <code>x</code> that are not equal to <code>NA</code> or <code>NaN</code>.
<code>(x+1)[(!is.na(x)) & x>0] -> z</code> sets <code>z</code> to the values of <code>x+1</code> that are not <code>Na</code> or <code>NaN</code> and larger than 0.
A second method is with a vector of positive integral quantities. 
In this case, the values must be in the set <code>{1, 2, …, length(x)}</code>. 
The corresponding elements of the vector are selected and concatenated in that order to form a result. 
It is important to remember that unlike in other languages, the first index in R is 1 and not 0.
<code>x[1:10]</code> returns the first 10 elements of <code>x</code>, assuming <code>length(x)</code> is not less than 10. 
<code>c(‘x’, ‘y’)[rep(c(1,2,2,1), times=4)]</code> produces a character vector of length 16, where <code>‘x’, ‘y’, ‘y’, ‘x’</code> is repeated four times.
A vector of negative integral numbers specifies the values to be excluded rather than included. 
<code>y &lt;- x[-(1:5)]</code> sets <code>y</code> to all but the first five values of <code>x</code>.
Lastly, a vector of character strings can be used when an object has a names attribute to identify its components. 
With fruit <code>&lt;- c(1, 2, 3, 4)</code>, one can set the names of each index of the vector fruit with <code>names(fruit) &lt;- c(‘mango’, ‘apple’, ‘banana’, ‘orange’)</code>. 
Then, one can call the elements by name with <code>lunch &lt;- fruit[c(‘apple’, ‘orange’)]</code>.
The advantage of this is that alphanumeric names can sometimes be easier to remember than indices.
Note that an indexed expression can also appear on the receiving end of an assignment, in which the assignment is only performed on those elements of a vector. 
For example, <code>x[is.na(x)] &lt;- 0</code> replaces all <code>NA</code> and <code>NaN</code> values in vector <code>x</code> with the value <code>0</code>.
Another example: <code>y[y&lt;0] &lt;- -y[y&lt;0]</code> has the same effect as <code>y &lt;- abs(y)</code>. 
The code simply replaces all the values that are less than 0 with the negative of that value.
<h3>Arrays & Matrices</h3>
<h3>Arrays</h3>An array is a subscripted collection of data entries, not necessarily numeric.
A dimension vector is a vector of non-negative integers. 
If the length is <em>k</em> then the array is <em>k</em>-dimensional. 
The dimensions are indexed from one up to the values given in the dimension vector.
A vector can be used by R as an array as its <code>dim </code>attribute. 
If <code>z</code> were a vector of 1500 elements, the assignment <code>dim(z) &lt;- c(100, 5, 3)</code> would mean <code>z</code> is now treated as a 100 by 5 by 3 array.

<h3>Array Indexing</h3>Individual elements of an array can be referenced by giving the name of the array followed by the subscripts in square brackets, separated by columns.
A 3 by 4 by 6 vector <code>a</code> could have its first value called via <code>a[1, 1, 1]</code> and its last value called via <code>a[3, 4, 6]</code>.
<code>a[,,]</code> represents the entire array; hence, <code>a[1,1,]</code> takes the first row of the first 2-dimensional cross-section in <code>a</code>.

<h3>Indexing Matrices</h3>The following code generates a 4 by 5 array: <code>x &lt;- array(1:20, dim = c(4,5))</code>.
Arrays are specified by a vector of values and the dimensions of the matrix. 
Values are calculated top-down first, left-right second.
<code>array(1:4, dim = c(2,2))</code> would return
1 3
2 4
and not
1 2
3 4
Negative indices are not allowed in index matrices. 
<code>NA</code> and zero values are allowed.

<h3>Outer Product of 2 Arrays</h3>An important operation on arrays is the outer product. 
If <code>a</code> and <code>b</code> are two numeric arrays, their outer product is an array whose dimension vector is obtained by concatenating the two dimension vectors and whose data vector is achieved by forming all possible products of elements of the data vector of <code>a</code> with those of <code>b</code>. 
The outer product is calculated with the operator <code>%o%</code>:
<code>ab &lt;- a %o% b</code>
Another way to achieve this is
<code>ab &lt;- outer(a, b, ‘*’)</code>
In fact, any function can be applied on two arrays using the outer() function. 
Suppose we define a function <code>f &lt;- function(x, y) cos(y)/(1+x²)</code>. 
The function could be applied to two vectors <code>x</code> and <code>y</code> via <code>z &lt;- outer(x, y, f)</code>.

<h3>Demonstration: All Possible Determinants of 2x2 Single-Digit Matrices</h3>Consider the determinants of 2 by 2 matrices [a, b; c, d] where each entry is a non-negative integer from 0 to 9. 
The problem is to find the determinants of all possible matrices in this form and represent the frequency of which the value occurs with a high density plot.
Rephrased, find the probability distribution of the determinant if each digit is chosen independently and uniformly at random.
One clever way of doing this uses the outer(0 function twice.
d &lt;- outer(0:9,0:9)
fr &lt;- table(outer(d, d, ‘-’))
plot(fr, xlab = ‘Determinant’, ylab = ‘Frequency’)
The first line assigns d to this matrix:
The second line uses the outer() function again to calculate all possible determinants, and the last line plots it.
Generalized Transpose of an Array</h3>The function <code>aperm(a, perm)</code> can be used to permute an array a. 
The argument perm must be the permutation of the integers {1,…, <em>k</em>} where <em>k</em> is the number of subscripts in <em>a</em>. 
The result of the function is an array of the same size as a but with the old dimension given by <code>perm[j]</code> becoming the new <code>j-th</code> dimension.
An easy way to think about it is a generalization of transposition for matrices. 
If <code>A</code> is a matrix, then <code>B</code> is simply the transpose of <code>A</code>:
B &lt;- aperm(A, c(2, 1))
In these special cases the function <code>t()</code> performs a transposition.

<h3>Matrix Multiplication</h3>The operator %*% is used for matrix multiplication. 
If <code>A</code> and <code>B</code> are square matrices of the same size, <code>A*B</code> is the element-wise product of the two matrices. 
<code>A %*% B</code> is the dot product (matrix product).
If x is a vector, then <code>x %*% A %*% x</code> is a quadratic form.
<code>crossprod()</code> performs cross-products; thus, <code>crossprod(X, y)</code> is the same as the operation <code>t(X) %*% y</code>, but more efficient.
<code>diag(v)</code>, where <code>v</code> is a vector, gives a diagonal matrix with elements of the vector as the diagonal entries. 
<code>diag(M)</code>, where <code>m</code> is a matrix, gives the vector of the main diagonal entries of <code>M</code> (the same convention as in Matlab). 
<code>diag(k)</code>, where <code>k</code> is a single numeric value, returns a <code>k</code> by <code>k</code> identity matrix.

<h3>Linear Equations and Inversion</h3>Solving linear equations is the inverse of matrix multiplication. 
When
b &lt;- A %*% x
with only <code>A</code> and <code>b</code> given, vector <code>x</code> is the solution of the linear equation system. 
This can be solved quickly in R with
solve(A, b)

<h3>Eigenvalues and Eigenvectors</h3>The function <code>eigen(Sm)</code> calculates the eigenvalues and eigenvectors of a symmetric matrix Sm. 
The result is a list, with the first element named values and the second named vectors. 
<code>ev &lt;- eigen(Sm)</code> assigns this list to <code>ev</code>.
<code>ev$val</code> is the vector of eigenvalues of <code>Sm</code> and <code>ev$vec</code> the matrix of corresponding eigenvectors.
For large matrices, it is better to avoid computing the eigenvectors if they are not needed by using the expression
evals &lt;- eigen(Sm, only.values = TRUE)$values

<h3>Singular Value Decomposition and Determinants</h3>The function <code>svd(m)</code> takes an arbitrary matrix argument, <code>m</code>, and calculates the singular value decomposition of <code>m</code>. 
This consists of a matrix of orthonormal columns <code>U</code> with the same column space as <code>m</code>, a second matrix of orthonormal columns <code>V</code> whose column space is the row space of <code>m</code> and a diagonal matrix of positive entries <code>D</code> such that
m = U %*% D %*% t(V)
<code>det(m)</code> can be used to calculate the determinant of a square matrix <code>m</code>.

<h3>Least Squares Fitting & QR Decomposition</h3>The function <code>lsfit()</code> returns a list giving results of a least squares fitting procedure. 
An assignment like
ans &lt;- lsfit(X, y)
gives results of a least squares fit where y is the vector of observations and X is the design matrix.
<code>ls.diag()</code> can be used for regression diagnostics.
A closely related function is qr().
b &lt;- qr.coef(Xplus,y)
fit &lt;- qr.fitted(Xplus,y)
res &lt;- qr.resid(Xplus,y)
These compute the orthogonal projection of <code>y</code> onto the range of <code>X</code> in <code>fit</code>, the projection onto the orthogonal complement in <code>res</code> and the coefficient vector for the projection in <code>b</code>.

<h3>Forming Partitioned <code>Matrices</code></h3>Matrices can be built up from other vectors and matrices with the functions <code>cbind()</code> and <code>rbind()</code>.
<code>cbind()</code> forms matrices by binding matrices horizontally (column-wise), and <code>rbind()</code> binds matrices vertically (row-wise).
In the assignment <code>X &lt;- cbind(arg_1, arg_2, arg_3, …)</code> the arguments to <code>cbind()</code> must be either vectors of any length, or columns with the same column size (the same number of rows).
<code>rbind()</code> performs a corresponding operation for rows.

<h2>tcl/tk package to create messageBox</h2>
library(tcltk)

tkmessageBox(
 title = "Hello Friends Title",
 message = "Hello, world! message",
 icon = "warning",
 detail="This is the message details",
 type = "ok")

tk_messageBox(
message, 
icon = c("error", "info", "question", "warning")
type = c("ok", "okcancel", "yesno", "yesnocancel", "retrycancel", "abortretryignore"),
default = "", ...)

must be -default, -detail, -icon, -message, -parent, -title, or -type.

Arguments
title
character
string specifying title for dialog window

message
character
string specifying message displayed inside the alert extra arguments

A list of other arguments is shown here:
default character string specifying the default button of the dialog

detail
character string specifying a secondary message, usually displayed in a smaller font under the main message

parent
object of the class tkwin representing the window of the application for which this dialog is being posted.

type
character
string specifying predefined set of buttons to be displayed (askquestion only).

Possible values are:
 abortretryignore
  displays three buttons whose symbolic names are ‘abort’, ‘retry’ and ‘ignore’

 ok
  displays one button whose symbolic name is ‘ok’

 okcancel
  displays two buttons whose symbolic names are ‘ok’ and ‘cancel’

 retrycancel
  displays two buttons whose symbolic names are ‘retry’ and ‘cancel’

 yesno
  displays two buttons whose symbolic names are ‘yes’ and ‘no’

 yesnocancel displays three buttons whose symbolic names are ‘yes’, ‘no’ and ‘cancel’

<h2>Machine Learning in R for beginners</h2>
This small tutorial is meant to introduce you to the basics of machine learning in R: it will show you how to use R to work with KNN.

<h3>Introducing: Machine Learning in R</h3>
Machine learning is a branch in computer science that studies the design of algorithms that can learn. 
Typical machine learning tasks are concept learning, function learning or “predictive modeling”, clustering and finding predictive patterns. 
These tasks are learned through available data that were observed through experiences or instructions, for example. 
Machine learning hopes that including the experience into its tasks will eventually improve the learning. 
The ultimate goal is to improve the learning in such a way that it becomes automatic, so that humans like ourselves don’t need to interfere any more.

This small tutorial is meant to introduce you to the basics of machine learning in R: more specifically, it will show you how to use R to work with the well-known machine learning algorithm called “KNN” or <em>k</em>-nearest neighbors.


<h3>Using R For <em>k</em>-Nearest Neighbors (KNN)</h3>
The KNN or <em>k</em>-nearest neighbors algorithm is one of the simplest machine learning algorithms and is an example of instance-based learning, where new data are classified based on stored, labeled instances.

More specifically, the distance between the stored data and the new instance is calculated by means of some kind of a similarity measure. 
This similarity measure is typically expressed by a distance measure such as the Euclidean distance, cosine similarity or the Manhattan distance.

In other words, the similarity to the data that was already in the system is calculated for any new data point that you input into the system.

Then, you use this similarity value to perform predictive modeling. 
Predictive modeling is either classification, assigning a label or a class to the new instance, or regression, assigning a value to the new instance. 
Whether you classify or assign a value to the new instance depends of course on your how you compose your model with KNN.

The <em>k</em>-nearest neighbor algorithm adds to this basic algorithm that after the distance of the new point to all stored data points has been calculated, the distance values are sorted and the <em>k</em>-nearest neighbors are determined. 
The labels of these neighbors are gathered and a majority vote or weighted vote is used for classification or regression purposes.

In other words, the higher the score for a certain data point that was already stored, the more likely that the new instance will receive the same classification as that of the neighbor. 
In the case of regression, the value that will be assigned to the new data point is the mean of its <em>k</em> nearest neighbors.

<h3>Step One. Get Your Data</h3>
Machine learning usually starts from observed data. 
You can take your own data set or browse through other sources to find one.

<h3>Built-in Datasets of R</h3>
This tutorial uses the Iris data set, which is very well-known in the area of machine learning. 
This dataset is built into R, so you can take a look at this dataset by typing the following into your console:

iris

# Print first lines
head(iris)

<h3>Step Two. Know Your Data</h3>
Just looking or reading about your data is certainly not enough to get started!

You need to get your hands dirty, explore and visualize your data set and even gather some more domain knowledge if you feel the data is way over your head.

Probably you’ll already have the domain knowledge that you need, but just as a reminder, all flowers contain a sepal and a petal. 
The sepal encloses the petals and is typically green and leaf-like, while the petals are typically colored leaves. 
For the iris flowers, this is just a little bit different, as you can see in the following picture:


<img class="lazy" data-src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/iris-machinelearning.png" />

<h3>Initial Overview Of The Data Set</h3>
First, you can already try to get an idea of your data by making some graphs, such as histograms or boxplots. 
In this case, however, scatter plots can give you a great idea of what you’re dealing with: it can be interesting to see how much one variable is affected by another.

In other words, you want to see if there is any correlation between two variables.

You can make scatterplots with the <a href="http://www.rdocumentation.org/packages/ggvis"><code>ggvis</code> package</a>, for example.

<k>Note</k> that you first need to load the <code>ggvis</code> package:

<code># Load in `ggvis`
library(ggvis)

# Iris scatter plot
iris %>% ggvis(~Sepal.Length, ~Sepal.Width, fill = ~Species) %>% layer_points()</code>


<img alt="correlation iris" height="499" src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/plot_768312428.png" width="817" />

You see that there is a high correlation between the sepal length and the sepal width of the Setosa iris flowers, while the correlation is somewhat less high for the Virginica and Versicolor flowers: the data points are more spread out over the graph and don’t form a cluster like you can see in the case of the Setosa flowers.

The scatter plot that maps the petal length and the petal width tells a similar story:

<code>iris %>% ggvis(~Petal.Length, ~Petal.Width, fill = ~Species) %>% layer_points()</code>


<img alt="scatterplot iris" height="500" src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/plot_675020181.png" width="817" />

You see that this graph indicates a positive correlation between the petal length and the petal width for all different species that are included into the Iris data set. 
Of course, you probably need to test this hypothesis a bit further if you want to be really sure of this:

# Overall correlation `Petal.Length` and `Petal.Width`
cor(iris$Petal.Length, iris$Petal.Width)

# Return values of `iris` levels 
x=levels(iris$Species)

# Print Setosa correlation matrix
print(x[1])
cor(iris[iris$Species==x[1],1:4])

# Print Versicolor correlation matrix
print(x[2])
cor(iris[iris$Species==x[2],1:4])

# Print Virginica correlation matrix
print(x[3])
cor(iris[iris$Species==x[3],1:4])

You see that when you combined all three species, the correlation was a bit stronger than it is when you look at the different species separately: the overall correlation is 0.96, while for Versicolor this is 0.79. 
Setosa and Virginica, on the other hand, have correlations of petal length and width at 0.31 and 0.32 when you round up the numbers.

<b>Tip</b>: are you curious about ggvis, graphs or histograms in particular? Check out our <a href="https://www.datacamp.com/community/tutorials/make-histogram-basic-r/">histogram tutorial</a> and/or <a href="https://www.datacamp.com/courses/ggvis-data-visualization-r-tutorial/">ggvis course</a>.

After a general visualized overview of the data, you can also view the data set by entering

# Return all `iris` data
iris

# Return first 5 lines of `iris`
head(iris)

# Return structure of `iris`
str(iris)

However, as you will see from the result of this command, this really isn’t the best way to inspect your data set thoroughly: the data set takes up a lot of space in the console, which will impede you from forming a clear idea about your data. 
It is therefore a better idea to inspect the data set by executing <code>head(iris)</code> or <code>str(iris)</code>.

Note that the last command will help you to clearly distinguish the data type <code>num</code> and the three levels of the <code>Species</code> attribute, which is a factor. 
This is very convenient, since many R machine learning classifiers require that the target feature is coded as a factor.

Remember that factor variables represent categorical variables in R. 
They can thus take on a limited number of different values.

A quick look at the <code>Species</code> attribute through tells you that the division of the species of flowers is 50-50-50. 
On the other hand, if you want to check the percentual division of the <code>Species</code> attribute, you can ask for a table of proportions:

# Division of `Species`
table(iris$Species) 

# Percentual division of `Species`
round(prop.table(table(iris$Species)) * 100, digits = 1)

<k>Note</k> that the <code>round</code> argument rounds the values of the first argument, <code>prop.table(table(iris$Species))*100</code> to the specified number of digits, which is one digit after the decimal point. 
You can easily adjust this by changing the value of the <code>digits</code> argument.

<h3>Profound Understanding Of Your Data</h3>
Let’s not remain on this high-level overview of the data! R gives you the opportunity to go more in-depth with the <code>summary()</code> function. 
This will give you the minimum value, first quantile, median, mean, third quantile and maximum value of the data set Iris for numeric data types. 
For the class variable, the count of factors will be returned:

# Summary overview of `iris`
summary(....) 

# Refined summary overview
summary(....[c("Petal.Width", "Sepal.Width")])

As you can see, the <code>c()</code> function is added to the original command: the columns <code>petal width</code> and <code>sepal width</code> are concatenated and a summary is then asked of just these two columns of the Iris data set.

<h3>Step Three. Where To Go Now?</h3>
After you have acquired a good understanding of your data, you have to decide on the use cases that would be relevant for your data set. 
In other words, you think about what your data set might teach you or what you think you can learn from your data. 
From there on, you can think about what kind of algorithms you would be able to apply to your data set in order to get the results that you think you can obtain.
From there on, you can think about what kind of algorithms you would be able to apply to your data set in order to get the results that you think you can obtain.

<k>Tip</k>: keep in mind that the more familiar you are with your data, the easier it will be to assess the use cases for your specific data set. 
The same also holds for finding the appropriate machine algorithm.

For this tutorial, the Iris data set will be used for classification, which is an example of predictive modeling. 
The last attribute of the data set, <code>Species</code>, will be the target variable or the variable that you want to predict in this example.

<k>Note</k> that you can also take one of the numerical classes as the target variable if you want to use KNN to do regression.

<h3>Step Four. Prepare Your Workspace</h3>
Many of the algorithms used in machine learning are not incorporated by default into R. 
You will most probably need to download the packages that you want to use when you want to get started with machine learning.

<b>Tip</b>: got an idea of which learning algorithm you may use, but not of which package you want or need? You can find a pretty complete overview of all the packages that are used in R <a href="http://www.rdocumentation.org/domains/MachineLearning">right here</a>.

To illustrate the KNN algorithm, this tutorial works with the package <code>class</code>:

library(.....)

If you don’t have this package yet, you can quickly and easily do so by typing the following line of code:

<code>install.packages("&lt;package name>")</code>

<k>Remember</k> the nerd tip: if you’re not sure if you have this package, you can run the following command to find out!

<code>any(grepl("&lt;name of your package>", installed.packages()))</code>

<h3>Step Five. Prepare Your Data</h3>
After exploring your data and preparing your workspace, you can finally focus back on the task ahead: making a machine learning model. 
However, before you can do this, it’s important to also prepare your data. 
The following section will outline two ways in which you can do this: by normalizing your data (if necessary) and by splitting your data in training and testing sets.

<h3>Normalization</h3>
As a part of your data preparation, you might need to normalize your data so that its consistent. 
For this introductory tutorial, just remember that normalization makes it easier for the KNN algorithm to learn. 
There are two types of normalization:

example normalization is the adjustment of each example individually, while
feature normalization indicates that you adjust each feature in the same way across all examples.

So when do you need to normalize your dataset?

In short: when you suspect that the data is not consistent.

You can easily see this when you go through the results of the <code>summary()</code> function. 
Look at the minimum and maximum values of all the (numerical) attributes. 
If you see that one attribute has a wide range of values, you will need to normalize your dataset, because this means that the distance will be dominated by this feature.

For example, if your dataset has just two attributes, X and Y, and X has values that range from 1 to 1000, while Y has values that only go from 1 to 100, then Y’s influence on the distance function will usually be overpowered by X’s influence.

When you normalize, you actually adjust the range of all features, so that distances between variables with larger ranges will not be over-emphasised.

<b>Tip</b>: go back to the result of <code>summary(iris)</code> and try to figure out if normalization is necessary.

The Iris data set doesn’t need to be normalized: the <code>Sepal.Length</code> attribute has values that go from 4.3 to 7.9 and <code>Sepal.Width</code> contains values from 2 to 4.4, while <code>Petal.Length</code>’s values range from 1 to 6.9 and <code>Petal.Width</code> goes from 0.1 to 2.5. 
All values of all attributes are contained within the range of 0.1 and 7.9, which you can consider acceptable.

Nevertheless, it’s still a good idea to study normalization and its effect, especially if you’re new to machine learning. 
You can perform feature normalization, for example, by first making your own <code>normalize()</code> function.

You can then use this argument in another command, where you put the results of the normalization in a data frame through <code>as.data.frame()</code> after the function <code>lapply()</code> returns a list of the same length as the data set that you give in. 
Each element of that list is the result of the application of the <code>normalize</code> argument to the data set that served as input:

<code>YourNormalizedDataSet &lt;- as.data.frame(lapply(YourDataSet, normalize))</code>

Test this in the DataCamp Light chunk below!

# Build your own `normalize()` function
normalize &lt;- function(x) {
num &lt;- x - min(x)
denom &lt;- max(x) - min(x)
return (num/denom)
}

# Normalize the `iris` data
iris_norm &lt;- .............(......(iris[1:4], normalize))

# Summarize `iris_norm`
summary(.........)

For the Iris dataset, you would have applied the <code>normalize</code> argument on the four numerical attributes of the Iris data set (<code>Sepal.Length</code>, <code>Sepal.Width</code>, <code>Petal.Length</code>, <code>Petal.Width</code>) and put the results in a data frame.

<k>Tip</k>: to more thoroughly illustrate the effect of normalization on the data set, compare the following result to the summary of the Iris data set that was given in step two.

<h3>Training And Test Sets</h3>
In order to assess your model’s performance later, you will need to divide the data set into two parts: a training set and a test set.

The first is used to train the system, while the second is used to evaluate the learned or trained system. 
In practice, the division of your data set into a test and a training sets is disjoint: the most common splitting choice is to take 2/3 of your original data set as the training set, while the 1/3 that remains will compose the test set.

One last look on the data set teaches you that if you performed the division of both sets on the data set as is, you would get a training class with all species of “Setosa” and “Versicolor”, but none of “Virginica”. 
The model would therefore classify all unknown instances as either “Setosa” or “Versicolor”, as it would not be aware of the presence of a third species of flowers in the data.

In short, you would get incorrect predictions for the test set.

You thus need to make sure that all three classes of species are present in the training model. 
What’s more, the amount of instances of all three species needs to be more or less <em>equal</em> so that you do not favour one or the other class in your predictions.

To make your training and test sets, you first set a seed. 
This is a number of R’s random number generator. 
The major advantage of setting a seed is that you can get the same sequence of random numbers whenever you supply the same seed in the random number generator.

<code>set.seed(1234)</code>

Then, you want to make sure that your Iris data set is shuffled and that you have an equal amount of each species in your training and test sets.

You use the <code>sample()</code> function to take a sample with a size that is set as the number of rows of the Iris data set, or 150. 
You sample with replacement: you choose from a vector of 2 elements and assign either 1 or 2 to the 150 rows of the Iris data set. 
The assignment of the elements is subject to probability weights of 0.67 and 0.33.

<code>ind &lt;- sample(2, nrow(iris), replace=TRUE, prob=c(0.67, 0.33))</code>

<k>Note</k> that the <code>replace</code> argument is set to <code>TRUE</code>: this means that you assign a 1 or a 2 to a certain row and then reset the vector of 2 to its original state. 
This means that, for the next rows in your data set, you can either assign a 1 or a 2, each time again. 
The probability of choosing a 1 or a 2 should not be proportional to the weights amongst the remaining items, so you specify probability weights. 
Note also that, even though you don’t see it in the DataCamp Light chunk, the seed has still been set to <code>1234</code>.

<k>Remember</k> that you want your training set to be 2/3 of your original data set: that is why you assign “1” with a probability of 0.67 and the “2”s with a probability of 0.33 to the 150 sample rows.

You can then use the sample that is stored in the variable <code>ind</code> to define your training and test sets:

# Compose training set
iris.training &lt;- ....[ind==1, 1:4]

# Inspect training set
head(................)

# Compose test set
iris.test &lt;- ....[ind==2, 1:4]

# Inspect test set
head(...........)

<k>Note</k> that, in addition to the 2/3 and 1/3 proportions specified above, you don’t take into account all attributes to form the training and test sets. 
Specifically, you only take <code>Sepal.Length</code>, <code>Sepal.Width</code>, <code>Petal.Length</code> and <code>Petal.Width</code>. 
This is because you actually want to predict the fifth attribute, <code>Species</code>: it is your target variable. 
However, you do want to include it into the KNN algorithm, otherwise there will never be any prediction for it.

You therefore need to store the class labels in factor vectors and divide them over the training and test sets:
# Compose `iris` training labels
iris.trainLabels &lt;- iris[ind==1,5]

# Inspect result
print(iris.trainLabels)

# Compose `iris` test labels
iris.testLabels &lt;- iris[ind==2, 5]

# Inspect result
print(iris.testLabels)

<h3>Step Six. The Actual KNN Model</h3>
<h3>Building Your Classifier</h3>
After all these preparation steps, you have made sure that all your known (training) data is stored. 
No actual model or learning was performed up until this moment. 
Now, you want to find the <em>k</em> nearest neighbors of your training set.

An easy way to do these two steps is by using the <code>knn()</code> function, which uses the Euclidian distance measure in order to find the <em>k</em>-nearest neighbours to your new, unknown instance. 
Here, the <em>k</em> parameter is one that you set yourself.

As mentioned before, new instances are classified by looking at the majority vote or weighted vote. 
In case of classification, the data point with the highest score wins the battle and the unknown instance receives the label of that winning data point. 
If there is an equal amount of winners, the classification happens randomly.

<k>Note</k>: the <em>k</em> parameter is often an odd number to avoid ties in the voting scores.

# Build the model
iris_pred &lt;- ...(train = iris.training, test = iris.test, cl = iris.trainLabels, k=3)

# Inspect `iris_pred`
.........

You store into <code>iris_pred</code> the <code>knn()</code> function that takes as arguments the training set, the test set, the train labels and the amount of neighbours you want to find with this algorithm. 
The result of this function is a factor vector with the predicted classes for each row of the test data.

<k>Note</k> that you don’t want to insert the test labels: these will be used to see if your model is good at predicting the actual classes of your instances!

You see that when you inspect the the result, <code>iris_pred</code>, you’ll get back the factor vector with the predicted classes for each row of the test data.

<h3>Step Seven. Evaluation of Your Model</h3>
An essential next step in machine learning is the evaluation of your model’s performance. 
In other words, you want to analyze the degree of correctness of the model’s predictions.

For a more abstract view, you can just compare the results of <code>iris_pred</code> to the test labels that you had defined earlier:

# Put `iris.testLabels` in a data frame
irisTestLabels &lt;- data.frame(................)

# Merge `iris_pred` and `iris.testLabels` 
merge &lt;- data.frame(........., ...............)

# Specify column names for `merge`
names(.....) &lt;- c("Predicted Species", "Observed Species")

# Inspect `merge` 
merge


You see that the model makes reasonably accurate predictions, with the exception of one wrong classification in row 29, where “Versicolor” was predicted while the test label is “Virginica”.

This is already some indication of your model’s performance, but you might want to go even deeper into your analysis. 
For this purpose, you can import the package <code>gmodels</code>:

<code>install.packages("package name")</code>

However, if you have already installed this package, you can simply enter

<code>library(gmodels)</code>

Then you can make a cross tabulation or a contingency table. 
This type of table is often used to understand the relationship between two variables. 
In this case, you want to understand how the classes of your test data, stored in <code>iris.testLabels</code> relate to your model that is stored in <code>iris_pred</code>:

<code>CrossTable(x = iris.testLabels, y = iris_pred, prop.chisq=FALSE)</code>


<img alt="Crosstable iris knn" height="698" src="https://s3.amazonaws.com/assets.datacamp.com/blog_assets/Machine+Learning+R/Screenshot-2015-03-24-20.05.32.png" width="926" />

<k>Note</k> that the last argument <code>prop.chisq</code> indicates whether or not the chi-square contribution of each cell is included. 
The chi-square statistic is the sum of the contributions from each of the individual cells and is used to decide whether the difference between the observed and the expected values is significant.

From this table, you can derive the number of correct and incorrect predictions: one instance from the testing set was labeled <code>Versicolor</code> by the model, while it was actually a flower of species <code>Virginica</code>. 
You can see this in the first row of the “Virginica” species in the <code>iris.testLabels</code> column. 
In all other cases, correct predictions were made. 
You can conclude that the model’s performance is good enough and that you don’t need to improve the model!

<a href="https://www.datacamp.com/courses/" target="_blank">
<img alt="Learn Python for Data Science With DataCamp" src="http://community.datacamp.com.s3.amazonaws.com/community/production/ckeditor_assets/pictures/293/content_blog_banner.png" /></a>

<h3>Machine Learning in R with <code>caret</code></h3>
In the previous sections, you have gotten started with supervised learning in R via the KNN algorithm. 
As you might not have seen above, machine learning in R can get really complex, as there are various algorithms with various syntax, different parameters, etc. 
Maybe you’ll agree with me when I say that remembering the different package names for each algorithm can get quite difficult or that applying the syntax for each specific algorithm is just too much.

That’s where the <code>caret</code> package can come in handy: it’s short for “Classification and Regression Training” and offers everything you need to know to solve supervised machine learning problems: it provides a uniform interface to a ton of machine learning algorithms. 
If you’re a bit familiar with Python machine learning, you might see similarities with <code>scikit-learn</code>!

In the following, you’ll go through the steps as they have been outlined above, but this time, you’ll make use of <code>caret</code> to classify your data. 
Note that you have already done a lot of work if you’ve followed the steps as they were outlined above: you already have a hold on your data, you have explored it, prepared your workspace, etc. 
Now it’s time to preprocess your data with <code>caret</code>!

As you have done before, you can study the effect of the normalization, but you’ll see this later on in the tutorial.

You already know what’s next! Let’s split up the data in a training and test set. 
In this case, though, you handle things a little bit differently: you split up the data based on the labels that you find in <code>iris$Species</code>. 
Also, the ratio is in this case set at 75-25 for the training and test sets.

# Create index to split based on labels  
index &lt;- createDataPartition(iris$Species, p=0.75, list=FALSE)

# Subset training set with index
iris.training &lt;- iris[.......,]

# Subset test set with index
iris.test &lt;- iris[-.........,]

You’re all set to go and train models now! But, as you might remember, <code>caret</code> is an extremely large project that includes a lot of algorithms. 
If you’re in doubt on what algorithms are included in the project, you can get a list of all of them. 
Pull up the list by running <code>names(getModelInfo())</code>, just like the code chunk below demonstrates. 
Next, pick an algorithm and train a model with the <code>train()</code> function:

# Overview of algos supported by caret
names(getModelInfo())

# Train a model
model_knn &lt;- train(iris.training[, 1:4], iris.training[, 5], method='knn')

Note that making other models is extremely simple when you have gotten this far; You just have to change the <code>method</code> argument, just like in this example:

<code>model_cart &lt;- train(iris.training[, 1:4], iris.training[, 5], method='rpart2')</code>

Now that you have trained your model, it’s time to predict the labels of the test set that you have just made and evaluate how the model has done on your data:

# Predict the labels of the test set
predictions&lt;-predict(object=model_knn,iris.test[,1:4])

# Evaluate the predictions
table(predictions)

# Confusion matrix 
confusionMatrix(predictions,iris.test[,5])

Additionally, you can try to perform the same test as before, to examine the effect of preprocessing, such as scaling and centering, on your model. 
Run the following code chunk:


# Train the model with preprocessing
model_knn &lt;- train(iris.training[, 1:4], iris.training[, 5], method='knn', preProcess=c("center", "scale"))

# Predict values
predictions&lt;-predict.train(object=model_knn,iris.test[,1:4], type="raw")

# Confusion matrix
confusionMatrix(predictions,iris.test[,5])

<h3>Move On To Big Data</h3>
Congratulations! You’ve made it through this tutorial!

This tutorial was primarily concerned with performing basic machine learning algorithm KNN with the help of R. 
The Iris data set that was used was small and overviewable; Not only did you see how you can perform all of the steps by yourself, but you’ve also seen how you can easily make use of a uniform interface, such as the one that <code>caret</code> offers, to spark your machine learning.

But you can do so much more!

If you have experimented enough with the basics presented in this tutorial and other machine learning algorithms, you might want to find it interesting to go further into R and data analysis.

<h2>Machine Learning in R with Example</h2>
As a kid, you might have come across a picture of a fish and you would have been told by your kindergarten teachers or parents that this is a fish and it has some specific features associated with it like it has fins, gills, a pair of eyes, a tail and so on. 

Now, whenever your brain comes across an image with those set of features, it automatically registers it as a fish because your brain has <em>learned </em>that it is a fish.

That's how our brain functions but what about a machine? If the same image is fed to a machine, how will the machine identify it to be a fish?


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture6.png">

This is where M<em>achine Learning</em> comes in. 

We'll keep on feeding images of a fish to a computer with the tag "fish" until the <em>machine learns all the features associated</em> with a<em> fish. 
</em>


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture7.png">

Once the machine learns all the features associated with a fish, we will feed it new data to determine how much has it learned.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture8.png">

In other words,<em> Raw Data/Training Data </em>is given to the machine, so that it <em>learns </em>all the features associated with the <em>Training Data. 
</em>Once, the learning is done, it is given <em>New Data/Test Data </em>to determine how well the machine has learned.

Let us move ahead in this Machine Learning with R blog and understand about types of Machine Learning.
<h3><k>Types of Machine Learning</k></h3><h3><k>Supervised Learning: </k></h3>
Supervised Learning algorithm learns from a known data-set(Training Data) which has labels to make predictions.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture9.png">

Regression and Classification are some examples of Supervised Learning.
<h4><k>#Classification:</k></h4>
Classification determines to which set of categories does a new observation belongs i.e. a classification algorithm learns all the features and labels of the training data and when new data is given to it, it has to assign labels to the new observations depending on what it has learned from the training data.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture10.png">

For this example, if the first observation is given the label "Man" then it is rightly classified but if it is given the label "Woman", the classification is wrong. 

Similarly for the second observation, if the label given is "Woman", it is rightly classified, else the classification is wrong.
<h4><k>#Regression: </k></h4>
Regression is a supervised learning algorithm which helps in determining how does one variable influence another variable.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture11.png">

Over here, "living_area" is the independent variable and "price" is the dependent variable i.e. we are determining how does "price" vary with respect to "living_area".
<h3><k>Unsupervised Learning:</k></h3>
Unsupervised learning algorithm draws inferences from data which does not have labels.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture12.png">

<em>Clustering</em> is an example of unsupervised learning. 

"K-means", "Hierarchical", "Fuzzy C-Means" are some examples of clustering algorithms.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture13.png">

In this example, the set of observations is divided into two clusters. 

Clustering is done on the basis of similarity between the observations. 

There is a high intra-cluster similarity and low inter-cluster similarity i.e. there is a very high similarity between all the buses but low similarity between the buses and cars.

<h3><k>Reinforcement Learning:</k></h3>
Reinforcement Learning is a type of machine learning algorithm where the <em>machine/agent</em> in an <em>environment </em>learns ideal behavior in order to maximize its performance. 
Simple reward feedback is required for the agent to learn its behavior, this is known as the <em>reinforcement signal</em>.
<h3><k>
<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/pacman.png">
</k></h3>
Let's take <em>pacman</em> for example. 

As long as pacman keeps eating food, it earns points but when it crashes against a monster it loses it's life. 

Thus pacman learns that it needs to eat more food and avoid monsters so as to improve it's performance.
<h3><k>Implementing Machine Learning with R:</k></h3><h3><k>Linear Regression:</k></h3>
We'll be working with the diamonds data-set to implement linear regression algorithm:


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/diamond.png">

Description of the data-set:


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/diamond_description.png">

Prior to building any model on the data, we are supposed to split the data into "train" and "test" sets. 

The model will be built on the "train" set and it's accuracy will be checked on the "test" set.

We need to load the "caTools" package to split the data into two sets.

<code>library(caTools)</code>
"caTools" package provides a function "sample.split()" which helps in splitting the data.

<code>sample.split(diamonds$price,SplitRatio = 0.65)->split_index</code>
65% of the observations from price column have been assigned the "true" label and the rest 35% have been assigned "false" label.

<code>subset(diamonds,split_index==T)->train
subset(diamonds,split_index==F)->test</code>
All the observations which have "true" label have been stored in the "<em>train" object</em> and those observations having "false" label have been assigned to the "test" set.

Now that the splitting is done and we have our "train" and "test" sets, it's time to build the linear regression model on the training set.

We'll be using the "lm()" function to build the linear regression model on the "train" data. 

We are determining the <em>price</em> of the diamonds with respect to all other variables of the data-set. 

The built model is stored in the object "mod_regress".

<code>lm(price~.,data = train)->mod_regress</code><em> </em>
Now, that we have built the model, we need to make predictions on the "test" set. 

"predict()" function is used to get predictions. 

It takes two arguments: the <em>built model</em> and the <em>test set. 
</em>The predicted results are stored in the "result_regress" object.

<code>predict(mod_regress,test)->result_regress</code>
Let's bind the actual price values from the "test" data-set and the predicted values into a single data-set using the "cbind()" function. 

The new data-frame is stored in "Final_Data"

<code>cbind(Actual=test$price,Predicted=result_regress)->Final_Data</code> 
<code>as.data.frame(Final_Data)->Final_Data</code>
A glance at the "Final_Data" which comprises of actual values and predicted values:


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/final-data.png">

Let's find the error by subtracting the predicted values from the actual values and add this error as a new column to the "Final_Data":

<code>(Final_Data$Actual- Final_Data$Predicted)->error</code>
<code>cbind(Final_Data,error)->Final_Data</code>
A glance at the "Final_Data" which also comprises of the error in prediction:


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/final-data2.png">

Now, we'll go ahead and calculate "<em>Root Mean Square Error" </em>which gives an aggregate error for all the predictions

<code>rmse1&lt;-sqrt(mean(Final_Data$error^2))</code> 
<code>rmse1</code>

<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/rmse1.png">

Going ahead, let's build another model, so that we can compare the accuracy of both these models and determine which is a better one.

We'll build a new linear regression model on the "train" set but this time, we'll be dropping the &#8216;x' and &#8216;y' columns from the independent variables i.e. the "price" of the diamonds is determined by all the columns except &#8216;x' and &#8216;y'.

The model built is stored in "mod_regress2": 

<code>lm(price~.-y-z,data = train)->mod_regress2</code>
The predicted results are stored in "result_regress2"<br> 

<code>predict(mod_regress2,test)->result_regress2</code>
Actual and Predicted values are combined and stored in "Final_Data2":

<code>cbind(Actual=test$price,Predicted=result_regress2)->Final_Data2</code> 
<code>as.data.frame(Final_Data2)->Final_Data2</code>
Let's also add the error in prediction to "Final_Data2"

<code>(Final_Data2$Actual- Final_Data2$Predicted)->error2</code>
<code>cbind(Final_Data2,error2)->Final_Data2</code>
A glance at "Final_Data2":


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/final-data2.png">

Finding Root Mean Square Error to get the aggregate error:

<code>rmse2&lt;-sqrt(mean(Final_Data2$error^2))</code>

<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/rmse2.png">

We see that "rmse2" is marginally less than "rmse1" and hence the second model is marginally better than the first model.
<h3><k>Classification:</k></h3>
We'll be working with the "car_purchase" data-set to implement <em>recursive partitioning </em>which is a classification algorithm.


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/car-1.png">

Let's split the data into "train" and "test" sets using "sample.split()" function from "caTools" package.

<code>library(caTools)</code>
65% of the observations from &#8216;Purchased' column will be assigned "TRUE" labels and the rest will be assigned "FALSE" labels.

<code>sample.split(car_purchase$Purchased,SplitRatio = 0.65)->split_values</code>
All those observations which have "TRUE" label will be stored into &#8216;train' data and those observations having "FALSE" label will be assigned to &#8216;test' data.

<code>subset(car_purchase,split_values==T)->train_data</code>
<code>subset(car_purchase,split_values==F)->test_data</code>
Time to build the Recursive Partitioning algorithm:

We'll start off by loading the &#8216;rpart' package:

<code>library(rpart)</code>
"Purchased" column will be the dependent variable and all other columns are the independent variables i.e. we are determining whether the person has bought the car or not with respect to all other columns. 

The model is built on the "train_data" and the result is stored in "mod1".

<code>rpart(Purchased~.,data = train_data)->mod1</code>
Let's plot the result:

<code>plot(mod1,margin = 0.1)</code> <code>text(mod1,pretty = T,cex=0.8)</code>
<k>
<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/rplot.png">
</k>

Now, let's go ahead and predict the results on "test_data". 

We are giving the built rpart model "mod1" as the first argument, the test set "test_data" as the second argument and prediction type as "class" for the third argument. 

The result is stored in &#8216;result1' object. 

<code>predict(mod1,test_data,type = "class")->result1</code>
Let's evaluate the accuracy of the model using "confusionMatrix()" function from caret package.

<code>library(caret)</code> <code></code><code>confusionMatrix(table(test_data$Purchased,result1))</code>
<k>
<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/confusion.png">
</k>

The confusion matrix tells us that out of the 90 observations where the person did not buy the car, 79 observations have been rightly classified as "No" and 11 have been wrongly classified as "YES". 

Similarly, out of the 50 observations where the person actually bought the car, 47 have been rightly classified as "YES" and 3 have been wrongly classified as "NO".

We can find the accuracy of the model by dividing the correct predictions with total predictions i.e. (79+47)/(79+47+11+3).
<h3><k>K-Means Clustering:</k></h3>
We'll work with "iris" data-set to implement k-means clustering:


<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/iris.png">

Let's remove the "Species" column and create a new data-set which comprises only the first four columns from the &#8216;iris' data-set.

<code>iris[1:4]->iris_k</code>
Let us take the number of clusters to be 3. 

"Kmeans()" function takes the input data and the number of clusters in which the data is to be clustered. 

The syntax is : kmeans( data, k) where k is the number of cluster centers.

<code>kmeans(iris_k,3)->k1</code>
Analyzing the clustering:

<code>str(k1)</code>

<img class="lazy" data-src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2018/03/Picture15.png">

The str() function gives the structure of the kmeans which includes various parameters like withinss, betweenss, etc, analyzing which you can find out the performance of kmeans.

betweenss : Between sum of squares i.e. Intracluster similarity

withinss : Within sum of square i.e. Intercluster similarity

totwithinss : Sum of all the withinss of all the clusters i.e.Total intra-cluster similarity

A good clustering will have a lower value of "tot.withinss" and higher value of "betweenss" which depends on the number of clusters &lsquo;k&rsquo; chosen initially. 

The time is ripe to become an expert in Machine Learning to take advantage of new opportunities that come your way. 

This brings us to the end of this "<em><k>Machine Learning with R</k></em>" blog. 

I hope this blog was informative fruitful.

<h2>put the whole if else statement in one line</h2>
if (TRUE) 1 else 3

You have to use {} for allows the if statement to have more than one line. 

<h2>quit R</h2>
if logout, 
quit("yes")

<h2>Run R scripts from the Windows command line (CMD)</h2>
This use library RDCOMClient to send summary information to colleges with Microsoft Outlook

There are two ways to do that.

use batch file looks like this.
"C:\Program Files\R\R-3.4.3\bin\Rscript.exe" C:\Users\myusername\Documents\R\Send_Outlook_Email.R

The second one looks like this.
"C:\Program Files\R\R-3.4.3\bin\R.exe" CMD BATCH C:\Users\myusername\Documents\R\Send_Outlook_Email.R

Remember to use quotation marks when there is space in the file path.

<h2>Locate the position of patterns in a string</h2>
library("stringr")
fruit &lt;- "apple banana pear pineapple"
str_locate(fruit, "ea")
str_locate_all(fruit, "ea")

str_locate, an integer matrix.
First column gives start postion of match, and second column gives end position

str_locate_all a list of integer matrices.

<h3>trim string</h3>
x &lt;- "This string is moderately long"
strtrim(x, 20)

<h2>find the max length of string in array</h2>
setwd("D:/Dropbox/MyDocs/R misc Jobs/Learning Exercise/QuizData")
WordTableFIle <&lt;- readLines("EnglishWordList.txt", encoding="UTF-8", warn = FALSE)
WordTable <&lt;- matrix(unlist(strsplit(WordTableFIle, split = "\\t")), ncol=1, byrow=TRUE) # make it one column
maxNum = max(nchar(WordTable))
maxNum
WordTable[which(nchar(WordTable) == maxNum)]

<h2>Convert Character Vector between Encodings</h2>
iconv(x, from, to, sub=NA)

‘i’ stands for ‘internationalization’.

Usage
iconv(x, from, to, sub=NA)

Arguments
x	A character vector.
from	A character string describing the current encoding.

to	A character string describing the target encoding.

sub	character string. If not NA it is used to replace any non-convertible bytes in the input.
(This would normally be a single character, but can be more.
If "byte", the indication is "&lt;xx>" with the hex code of the byte.

Details
The names of encodings and which ones are available (and indeed, if any are) is platform-dependent. 
On systems that support R's iconv you can use "" for the encoding of the current locale, as well as "latin1" and "UTF-8".


iconvlist()
On many platforms iconvlist provides an alphabetical list of the supported encodings. 
On others, the information is on the man page for iconv(5) or elsewhere in the man pages (and beware that the system command iconv may not support the same set of encodings as the C functions R calls). 
Unfortunately, the names are rarely common across platforms.

Elements of x which cannot be converted (perhaps because they are invalid or because they cannot be represented in the target encoding) will be returned as NA unless sub is specified.

Some versions of iconv will allow transliteration by appending //TRANSLIT to the to encoding: see the examples.

Value
A character vector of the same length and the same attributes as x.

Note
Not all platforms support these functions. 

See Also
localeToCharset, file.

Examples
## Not run: 
iconvlist()

## convert from Latin-2 to UTF-8: two of the glibc iconv variants.
iconv(x, "ISO_8859-2", "UTF-8")
iconv(x, "LATIN2", "UTF-8")

## Both x below are in latin1 and will only display correctly in a
## latin1 locale.
(x &lt;- "fa\xE7ile")
charToRaw(xx &lt;- iconv(x, "latin1", "UTF-8"))
## in a UTF-8 locale, print(xx)

iconv(x, "latin1", "ASCII")          #   NA
iconv(x, "latin1", "ASCII", "?")     # "fa?ile"
iconv(x, "latin1", "ASCII", "")      # "faile"
iconv(x, "latin1", "ASCII", "byte")  # "faile"

# Extracts from R help files
(x &lt;- c("Ekstr\xf8m", "J\xf6reskog", "bi\xdfchen Z\xfcrcher"))
iconv(x, "latin1", "ASCII//TRANSLIT")
iconv(x, "latin1", "ASCII", sub="byte")
## End(Not run)

<h2>encoding error with read_html</h2>
<a href="https://stackoverflow.com/users/4350463/hodgenovice" class="whitebut ">hodgenovice R expert</a>
<a href="https://stackoverflow.com/questions/45290452/encoding-error-with-read-html" class="whitebut ">encoding error with read_html</a>
url = "http://www.chinanews.com/scroll-news/news1.html"
thekeyword = "新闻"
read_page = lapply(unique(iconvlist()), function(encoding_attempt) {

  # Optional print statement to show progress since this takes time
  # print(match(encoding_attempt, iconvlist()) / length(iconvlist()))

  read_attempt = tryCatch(expr=read_html(url, encoding=encoding_attempt),
                           error=function(condition) NA,
                           warning=function(condition) message(condition))
  read_attempt = as.character(read_attempt)
  fisrtLine = grep(thekeyword, read_attempt)
  if(length(fisrtLine)>0){
    cat(encoding_attempt, "\n")
    cat(read_attempt[fisrtLine], "\n")
  }
})

names(read_page) = unique(iconvlist())


# 2. See which encodings correctly display some complex characters
read_phrase = lapply(read_page, function(encoded_page) 
  if(!is.na(encoded_page))
    html_text(html_nodes(encoded_page, ".content_right")))

# ended up with encodings which could be sensible...
encoding_shortlist = names(read_phrase)[read_phrase == "新闻"]
encoding_shortlist

sink("testResult.txt")
print(read_page)
sink()

retriveFile &lt;- as.character(read_html(url, warn=F, encoding = "UTF-16"))
fisrtLine = grep(thekeyword, retriveFile)
fisrtLine

<h2>Object-oriented programming (OOP)</h2>
a programming paradigm based on the concept of "objects", 

which can contain data, in the form of fields (often known as attributes or properties), 

and code, in the form of procedures (often known as methods). 

A feature of objects is an object's procedures that can access and often modify the data fields of the object with which they are associated (objects have a notion of "this" or "self"). 

In OOP, computer programs are designed by making them out of objects that interact with one another.

OOP languages are diverse, but the most popular ones are class-based, meaning that objects are instances of classes, which also determine their types.

Many of the most widely used programming languages (such as C++, Java, Python, etc.) are multi-paradigm and they support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. 

Significant object-oriented languages include Java, C++, C#, Python, R, PHP, JavaScript, Ruby, Perl, Object Pascal, Objective-C, Dart, Swift, Scala, Kotlin, Common Lisp, MATLAB, and Smalltalk.


<h2>Reference classes</h2>
<!-- http://www.inside-r.org/r-doc/methods/ReferenceClasses -->
R has three object oriented (OO) systems: [[S3]], [[S4]] and Reference Classes (where the latter were for a while referred to as [[R5]], yet their official name is Reference Classes). 
This page describes this new reference-based class system.

Reference Classes (or refclasses) are new in R 2.12. 
They fill a long standing need for mutable objects that had previously been filled by non-core packages like R.oo, proto and mutatr. 
While the core functionality is solid, reference classes are still under active development and some details will change. 
The most up-to-date documentation for Reference Classes can always be found in ?ReferenceClasses.

There are two main differences between reference classes and S3 and S4:

Refclass objects use message-passing OO
Refclass objects are mutable: the usual R copy on modify semantics do not apply

These properties makes this object system behave much more like Java and C#. 
Surprisingly, the implementation of reference classes is almost entirely in R code - they are a combination of S4 methods and environments. 
This is a testament to the flexibility of S4.

Particularly suited for: simulations where you’re modelling complex state, GUIs.

Note that when using reference based classes we want to minimise side effects, and use them only where mutable state is absolutely required. 
The majority of functions should still be “functional”, and side effect free. 
This makes code easier to reason about (because you don’t need to worry about methods changing things in surprising ways), and easier for other R programmers to understand.

Limitations: can’t use enclosing environment - because that’s used for the object.

<h3>Classes and instances</h3>
Creating a new reference based class is straightforward: you use setRefClass. 
Unlike setClass from S4, you want to keep the results of that function around, because that’s what you use to create new objects of that type:

# Or keep reference to class around.
Person = setRefClass("Person")
Person$new()

A reference class has three main components, given by three arguments to setRefClass:

contains, the classes which the class inherits from. 
These should be other reference class objects:

setRefClass("Polygon")
setRefClass("Regular")

# Specify parent classes
setRefClass("Triangle", contains = "Polygon")
setRefClass("EquilateralTriangle", 
  contains = c("Triangle", "Regular"))

fields are the equivalent of slots in S4. 
They can be specified as a vector of field names, or a named list of field types:

setRefClass("Polygon", fields = c("sides"))
setRefClass("Polygon", fields = list(sides = "numeric"))

The most important property of refclass objects is that they are mutable, or equivalently they have reference semantics:

    Polygon = setRefClass("Polygon", fields = c("sides"))
    square = Polygon$new(sides = 4)
    
    triangle = square
    triangle$sides = 3
    
    square$sides        

methods are functions that operate within the context of the object and can modify its fields. 
These can also be added after object creation, as described below.

setRefClass("Dist")
setRefClass("DistUniform", c("a", "b"), "Dist", methods = list(
  mean = function() {
    (a + b) / 2
  }
))

You can also add methods after creation:

# Instead of creating a class all at once:
Person = setRefClass("Person", methods = list(
  say_hello = function() message("Hi!")
))

# You can build it up piece-by-piece
Person = setRefClass("Person")
Person$methods(say_hello = function() message("Hi!"))

It’s not currently possible to modify fields because adding fields would invalidate existing objects that didn’t have those fields.

The object returned by setRefClass (or retrieved later by getRefClass) is called a generator object. 
It has methods:

new for creating new objects of that class. 
The new method takes named arguments specifying initial values for the fields

methods for modifying existing or adding new methods

help for getting help about methods

fields to get a list of fields defined for class

lock locks the named fields so that their value can only be set once

accessors a convenience method that automatically sets up accessors of the form getXXX and setXXX.

<h3>Methods</h3>
Refclass methods are associated with objects, not with functions, and are called using the special syntax obj$method(arg1, arg2, ...). 
(You might recall we’ve seen this construction before when we called functions stored in a named list). 
Methods are also special because they can modify fields. 
This is different

We’ve also seen this construct before, when we used closures to create mutable state. 
Reference classes work in a similar manner but give us some extra functionality:

inheritance
a way of documenting methods
a way of specifying fields and their types

Modify fields with &lt;=. 
Will call accessor functions if defined.

Special fields: .self (Don’t use fields with names starting with . 
as these may be used for special purposes in future versions.)

initialize

<h3>Common methods</h3>
Because all refclass classes inherit from the same superclass, envRefClass, they a have common set of methods:

obj$callSuper:

obj$copy: creates a copy of the current object. 
This is necessary because Reference Classes classes don’t behave like most R objects, which are copied on assignment or modification.

obj$field: named access to fields. 
Equivalent to slots for S4. 
obj$field("xxx") the same as obj$xxx. 
obj$field("xxx", 5) the same as obj$xxx = 5

obj$import(x) coerces into this object, and obj$export(Class) coerces a copy of obj into that class. 
These should be super classes.

obj$initFields

<h1>R S3 Class</h1>
In this article, you will learn to work with S3 classes (one of the three class systems in R programming).

S3 class is the most popular and prevalent class in R programming language.

Most of the classes that come predefined in R are of this type. 
The fact that it is simple and easy to implement is the reason behind this.

<h2>How to define S3 class and create S3 objects?</h2>
S3 class has no formal, predefined definition.

Basically, a list with its class attribute set to some class name, is an S3 object. 
The components of the list become the member variables of the object.

Following is a simple example of how an S3 object of class student can be created.

> # create a list with required components
> s = list(name = "John", age = 21, GPA = 3.5)
> # name the class appropriately
> class(s) = "student"
> # That's it! we now have an object of class "student"
> s
$name
[1] "John"
$age
[1] 21
$GPA
[1] 3.5
attr(,"class")
[1] "student"

This might look awkward for programmers coming from C++, Python etc. 
where there are formal class definitions and objects have properly defined attributes and methods.

In R S3 system, it's pretty ad hoc. 
You can convert an object's class according to your will with objects of the same class looking completely different. 
It's all up to you.

<h2>How to use constructors to create objects?</h2>
It is a good practice to use a function with the same name as class (not a necessity) to create objects.

This will bring some uniformity in the creation of objects and make them look similar.

We can also add some integrity check on the member attributes. 
Here is an example. 
Note that in this example we use the attr() function to set the class attribute of the object.

# a constructor function for the "student" class
student = function(n,a,g) {
# we can add our own integrity checks
if(g>4 || g&lt;0)  stop("GPA must be between 0 and 4")
value = list(name = n, age = a, GPA = g)
# class can be set using class() or attr() function
attr(value, "class") = "student"
value
}

Here is a sample run where we create objects using this constructor.

> s = student("Paul", 26, 3.7)
> s
$name
[1] "Paul"
$age
[1] 26
$GPA
[1] 3.7
attr(,"class")
[1] "student"
> class(s)
[1] "student"
> s = student("Paul", 26, 5)
Error in student("Paul", 26, 5) : GPA must be between 0 and 4
> # these integrity check only work while creating the object using constructor
> s = student("Paul", 26, 2.5)
> # it's up to us to maintain it or not
> s$GPA = 5

<h2>Methods and Generic Functions</h2>
In the above example, when we simply write the name of the object, its internals get printed.

In interactive mode, writing the name alone will print it using the print() function.

> s
$name
[1] "Paul"
$age
[1] 26
$GPA
[1] 3.7
attr(,"class")
[1] "student"

Furthermore, we can use print() with vectors, matrix, data frames, factors etc. 
and they get printed differently according to the class they belong to.

How does print() know how to print these variety of dissimilar looking object?

The answer is, print() is a generic function. 
Actually, it has a collection of a number of methods. 
You can check all these methods with methods(print).

> methods(print)
[1] print.acf*                                   
[2] print.anova*
...
[181] print.xngettext*                             
[182] print.xtabs*                                 
Non-visible functions are asterisked

We can see methods like print.data.frame and print.factor in the above list.

When we call print() on a data frame, it is dispatched to print.data.frame().

If we had done the same with a factor, the call would dispatch to print.factor(). 
Here, we can observe that the method names are in the form generic_name.class_name(). 
This is how R is able to figure out which method to call depending on the class.

Printing our object of class "student" looks for a method of the form print.student(), but there is no method of this form.

So, which method did our object of class "student" call?

It called print.default(). 
This is the fallback method which is called if no other match is found. 
Generic functions have a default method.

There are plenty of generic functions like print(). 
You can list them all with methods(class="default").

> methods(class="default")
[1] add1.default*            aggregate.default*      
[3] AIC.default*             all.equal.default
...

<h2>How to write your own method?</h2>
Now let us implement a method print.student() ourself.

print.student = function(obj) {
cat(obj$name, "\n")
cat(obj$age, "years old\n")
cat("GPA:", obj$GPA, "\n")
}

Now this method will be called whenever we print() an object of class "student".

In S3 system, methods do not belong to object or class, they belong to generic functions. 
This will work as long as the class of the object is set.

> # our above implemented method is called
> s
Paul 
26 years old
GPA: 3.7 
> # removing the class attribute will restore as previous
> unclass(s)
$name
[1] "Paul"
$age
[1] 26
$GPA
[1] 3.7

<h2>Writing Your Own Generic Function</h2>
It is possible to make our own generic function like print() or plot(). 
Let us first look at how these functions are implemented.

> print
function (x, ...) 
UseMethod("print")
&lt;bytecode: 0x0674e230>
&lt;environment: namespace:base>
> plot
function (x, y, ...) 
UseMethod("plot")
&lt;bytecode: 0x04fe6574>
&lt;environment: namespace:graphics>

We can see that they have a single call to UseMethod() with the name of the generic function passed to it. 
This is the dispatcher function which will handle all the background details. 
It is this simple to implement a generic function.

For the sake of example, we make a new generic function called grade.

grade = function(obj) {
UseMethod("grade")
}

A generic function is useless without any method. 
Let us implement the default method.

grade.default = function(obj) {
cat("This is a generic function\n")
}

Now let us make method for our class "student".

grade.student = function(obj) {
cat("Your grade is", obj$GPA, "\n")
}

A sample run.

> grade(s)
Your grade is 3.7

In this way, we implemented a generic function called grade and later a method for our class.

<h1>R Inheritance</h1>
In this article, you’ll learn everything about inheritance in R. 
More specifically, how to create inheritance in S3, S4 and Reference classes, and use them efficiently in your program.

Inheritance is one of the key features of object-oriented programming which allows us to define a new class out of existing classes.

This is to say, we can derive new classes from existing base classes and adding new features. 
We don’t have to write from scratch. 
Hence, inheritance provides reusability of code.

Inheritance forms a hierarchy of class just like a family tree. 
Important thing to note is that the attributes define for a base class will automatically be present in the derived class.

Moreover, the methods for the base class will work for the derived.


<img class="lazy" data-src="https://cdn.datamentor.io/wp-content/uploads/2017/11/r-inheritance.jpg">

Below, we discuss how inheritance is carried out for the three different class systems in R programming language.

<h2>Inheritance in S3 Class</h2>
S3 classes do not have any fixed definition. 
Hence attributes of S3 objects can be arbitrary.

Derived class, however, inherit the methods defined for base class. 
Let us suppose we have a function that creates new objects of class student as follows.

student = function(n,a,g) {
value = list(name=n, age=a, GPA=g)
attr(value, "class") = "student"
value
}

Furthermore, we have a method defined for generic function print() as follows.

print.student = function(obj) {
cat(obj$name, "\n")
cat(obj$age, "years old\n")
cat("GPA:", obj$GPA, "\n")
}

Now we want to create an object of class InternationalStudent which inherits from student.

This is be done by assigning a character vector of class names like class(obj) = c(child, parent).

> # create a list
> s = list(name="John", age=21, GPA=3.5, country="France")
> # make it of the class InternationalStudent which is derived from the class student
> class(s) = c("InternationalStudent","student")
> # print it out
> s
John 
21 years old
GPA: 3.5

We can see above that, since we haven’t defined any method of the form print.InternationalStudent(), the method print.student() got called. 
This method of class student was inherited.

Now let us define print.InternationalStudent().

print.InternationalStudent = function(obj) {
cat(obj$name, "is from", obj$country, "\n")
}

This will overwrite the method defined for class student as shown below.

> s
John is from France

We can check for inheritance with functions like inherits() or is().

> inherits(s,"student")
[1] TRUE
> is(s,"student")
[1] TRUE

<h2>Inheritance in S4 Class</h2>
Since S4 classes have proper definition, derived classes will inherit both attributes and methods of the parent class.

Let us define a class student with a method for the generic function show().

# define a class called student
setClass("student",
slots=list(name="character", age="numeric", GPA="numeric")
)
# define class method for the show() generic function
setMethod("show",
"student",
function(object) {
cat(object@name, "\n")
cat(object@age, "years old\n")
cat("GPA:", object@GPA, "\n")
}
)

Inheritance is done during the derived class definition with the argument contains as shown below.

# inherit from student
setClass("InternationalStudent",
slots=list(country="character"),
contains="student"
)

Here we have added an attribute country, rest will be inherited from the parent.

> s = new("InternationalStudent",name="John", age=21, GPA=3.5, country="France")
> show(s)
John 
21 years old
GPA: 3.5

We see that method define for class student got called when we did show(s).

We can define methods for the derived class which will overwrite methods of the base class, like in the case of S3 systems.

<h2>Inheritance in Reference Class</h2>
Inheritance in reference class is very much similar to that of the S4 class. 
We define in the contains argument, from which base class to derive from.

Here is an example of student reference class with two methods inc_age() and dec_age().

student = setRefClass("student",
fields=list(name="character", age="numeric", GPA="numeric"),
methods=list(
inc_age = function(x) {
age &lt;= age + x
},
dec_age = function(x) {
age &lt;= age - x
}
)
)

Now we will inherit from this class. 
We also overwrite dec_age() method to add an integrity check to make sure age is never negative.

InternationalStudent = setRefClass("InternationalStudent",
fields=list(country="character"),
contains="student",
methods=list(
dec_age = function(x) {
if((age - x)&lt;0)  stop("Age cannot be negative")
age &lt;= age - x
}
)
)

Let us put it to test.

> s = InternationalStudent(name="John", age=21, GPA=3.5, country="France")
> s$dec_age(5)
> s$age
[1] 16
> s$dec_age(20)
Error in s$dec_age(20) : Age cannot be negative
> s$age
[1] 16

In this way, we are able to inherit from the parent class.


<h2>R Reference Class</h2>
In this article, you will learn to work with reference classes in R programming which is one of the three class systems (other two are S3 and S4).

Reference class in R programming is similar to the object oriented programming we are used to seeing in common languages like C++, Java, Python etc.

Unlike <a title="R S3 Class" href="/r-programming/S3-class">S3</a> and <a title="R S4 class" href="/r-programming/S4-class">S4 classes</a>, methods belong to class rather than generic functions. 
Reference class are internally implemented as S4 classes with an environment added to it.

<h3>How to define a reference class?</h3>
Defining reference class is similar to defining a S4 class. 
Instead of setClass() we use the setRefClass() function.

> setRefClass("student")

Member variables of a class, if defined, need to be included in the class definition. 
Member variables of reference class are called fields (analogous to slots in S4 classes).

Following is an example to define a class called student with 3 fields, name, age and GPA.

> setRefClass("student", fields = list(name = "character", age = "numeric", GPA = "numeric"))

<h3>How to create a reference objects?</h3>
The function setRefClass() returns a generator function which is used to create objects of that class.

> student = setRefClass("student",
fields = list(name = "character", age = "numeric", GPA = "numeric"))
> # now student() is our generator function which can be used to create new objects
> s = student(name = "John", age = 21, GPA = 3.5)
> s
Reference class object of class "student"
Field "name":
[1] "John"
Field "age":
[1] 21
Field "GPA":
[1] 3.5

<h3>How to access and modify fields?</h3>
Fields of the object can be accessed using the $ operator.

> s$name
[1] "John"
> s$age
[1] 21
> s$GPA
[1] 3.5

Similarly, it is modified by reassignment.

> s$name = "Paul"
> s
Reference class object of class "student"
Field "name":
[1] "Paul"
Field "age":
[1] 21
Field "GPA":
[1] 3.5

<h4>Warning Note</h4>

In R programming, objects are copied when assigned to new variable or passed to a function (pass by value). 
For example.

> # create list a and assign to b
> a = list("x" = 1, "y" = 2)
> b = a
> # modify b
> b$y = 3
> # a remains unaffected
> a
$x
[1] 1
$y
[1] 2
> # only b is modified
> b
$x
[1] 1
$y
[1] 3

But this is not the case with reference objects. 
Only a single copy exist and all variables reference to the same copy. 
Hence the name, reference.

> # create reference object a and assign to b
> a = student(name = "John", age = 21, GPA = 3.5)
> b = a
> # modify b
> b$name = "Paul"
> # a and b both are modified
> a
Reference class object of class "student"
Field "name":
[1] "Paul"
Field "age":
[1] 21
Field "GPA":
[1] 3.5
> b
Reference class object of class "student"
Field "name":
[1] "Paul"
Field "age":
[1] 21
Field "GPA":
[1] 3.5

This can cause some unwanted change in values and be the source of strange bugs. 
We need to keep this in mind while working with reference objects. 
To make a copy, we can use the copy() method made availabe to us.

> # create reference object a and assign a’s copy to b
> a = student(name = "John", age = 21, GPA = 3.5)
> b = a$copy()
> # modify b
> b$name = "Paul"
> # a remains unaffected
> a
Reference class object of class "student"
Field "name":
[1] "John"
Field "age":
[1] 21
Field "GPA":
[1] 3.5
> # only b is modified
> b
Reference class object of class "student"
Field "name":
[1] "Paul"
Field "age":
[1] 21
Field "GPA":
[1] 3.5

<h3>Reference Methods</h3>
Methods are defined for a reference class and do not belong to generic functions as in S3 and S4 classes.

All reference class have some methods predefined because they all are inherited from the superclass envRefClass.

> student
Generator for class "student":
Class fields:
Name:       name       age       GPA
Class: character   numeric   numeric
Class Methods:  
"callSuper", "copy", "export", "field", "getClass", "getRefClass", 
"import", "initFields", "show", "trace", "untrace", "usingMethods"
Reference Superclasses:  
"envRefClass"

We can see class methods like copy(), field() and show() in the above list. 
We can create our own methods for the class.

This can be done during the class definition by passing a list of function definitions to methods argument of setRefClass().

student = setRefClass("student",
fields = list(name = "character", age = "numeric", GPA = "numeric"),
methods = list(
inc_age = function(x) {
age &lt;= age + x
},
dec_age = function(x) {
age &lt;= age - x
}
)
)

In the above section of our code, we defined two methods called inc_age() and dec_age(). 
These two method modify the field age.

Note that we have to use the non-local assignment operator &lt;= since age isn’t in the method’s local environment. 
This is important.

Using the simple assignment operator = would have created a local variable called age, which is not what we want. 
R will issue a warning in such case.

Here is a sample run where we use the above defined methods.

> s = student(name = "John", age = 21, GPA = 3.5)
> s$inc_age(5)
> s$age
[1] 26
> s$dec_age(10)
> s$age
[1] 16

<h2>R S4 Class</h2>
In this article, you’ll learn everything about S4 classes in R; how to define them, create them, access their slots, and use them efficiently in your program.

Unlike <a title="R S3 class" href="/r-programming/S3-class">S3 classes</a> and <a title="R object" href="/r-programming/object-class-introduction">objects</a> which lacks formal definition, we look at S4 class which is stricter in the sense that it has a formal definition and a uniform way to create objects.

This adds safety to our code and prevents us from accidentally making naive mistakes.

<h3>How to define S4 Class?</h3>
S4 class is defined using the setClass() function.

In R terminology, member variables are called slots. 
While defining a class, we need to set the name and the slots (along with class of the slot) it is going to have.

<h4>Example 1: Definition of S4 class</h4>
setClass("student", slots=list(name="character", age="numeric", GPA="numeric"))

In the above example, we defined a new class called student along with three slots it’s going to have name, age and GPA.

There are other optional arguments of setClass() which you can explore in the help section with ?setClass.

<h3>How to create S4 objects?</h3>
S4 objects are created using the new() function.

<h4>Example 2: Creation of S4 object</h4>
> # create an object using new()
> # provide the class name and value for slots
> s = new("student",name="John", age=21, GPA=3.5)
> s
An object of class "student"
Slot "name":
[1] "John"
Slot "age":
[1] 21
Slot "GPA":
[1] 3.5

We can check if an object is an S4 object through the function isS4().

> isS4(s)
[1] TRUE

The function setClass() returns a generator function.

This generator function (usually having same name as the class) can be used to create new objects. 
It acts as a constructor.

> student = setClass("student", slots=list(name="character", age="numeric", GPA="numeric"))
> student
class generator function for class “student” from package ‘.GlobalEnv’
function (...) 
new("student", ...)

Now we can use this constructor function to create new objects.

Note above that our constructor in turn uses the new() function to create objects. 
It is just a wrap around.

<h4>Example 3: Creation of S4 objects using generator function</h4>
> student(name="John", age=21, GPA=3.5)
An object of class "student"
Slot "name":
[1] "John"
Slot "age":
[1] 21
Slot "GPA":
[1] 3.5

<h3>How to access and modify slot?</h3>
Just as components of a <a title="R list" href="/r-programming/list">list</a> are accessed using $, slot of an object are accessed using @.

<h4>Accessing slot</h4>
> s@name
[1] "John"
> s@GPA
[1] 3.5
> s@age
[1] 21

<h4>Modifying slot directly</h4>
A slot can be modified through reassignment.

> # modify GPA
> s@GPA = 3.7
> s
An object of class "student"
Slot "name":
[1] "John"
Slot "age":
[1] 21
Slot "GPA":
[1] 3.7

<h4>Modifying slots using slot() function</h4>
Similarly, slots can be access or modified using the slot() function.

> slot(s,"name")
[1] "John"
> slot(s,"name") = "Paul"
> s
An object of class "student"
Slot "name":
[1] "Paul"
Slot "age":
[1] 21
Slot "GPA":
[1] 3.7

<h3>Methods and Generic Functions</h3>
As in the case of S3 class, methods for S4 class also belong to generic functions rather than the class itself. 
Working with S4 generics is pretty much similar to S3 generics.

You can list all the S4 generic functions and methods available, using the function showMethods().

<h4>Example 4: List all generic functions</h4>
> showMethods()
Function: - (package base)
Function: != (package base)
...
Function: trigamma (package base)
Function: trunc (package base)

Writing the name of the object in interactive mode prints it. 
This is done using the S4 generic function show().

You can see this function in the above list. 
This function is the S4 analogy of the S3 print() function.

<h4>Example 5: Check if a function is a generic function</h4>
> isS4(print)
[1] FALSE
> isS4(show)
[1] TRUE

We can list all the methods of show generic function using showMethods(show).

<h4>Example 6: List all methods of a generic function</h4>
> showMethods(show)
Function: show (package methods)
object="ANY"
object="classGeneratorFunction"
...
object="standardGeneric"
(inherited from: object="genericFunction")
object="traceable"

<h3>How to write your own method?</h3>
We can write our own method using setMethod() helper function.

For example, we can implement our class method for the show() generic as follows.

setMethod("show",
"student",
function(object) {
cat(object@name, "\n")
cat(object@age, "years old\n")
cat("GPA:", object@GPA, "\n")
}
)

Now, if we write out the name of the object in interactive mode as before, the above code is executed.

> s = new("student",name="John", age=21, GPA=3.5)
> s    # this is same as show(s)
John 
21 years old
GPA: 3.5

In this way we can write our own S4 class methods for generic functions.

<h2>Write text to a file</h2>
fileConn=file("output.txt")
writeLines(c("Hello","World"), fileConn)
close(fileConn)

sink("outfile.txt")
cat("hello")
cat("world")
sink()

cat("Hello",file="outfile.txt",sep="\n")
cat("World",file="outfile.txt",append=TRUE)
cat("hello","world",file="output.txt",sep="\n",append=TRUE)
file.show("outfile.txt")

txt = "Hallo\nWorld"
writeLines(txt, "outfile.txt")

library(tidyverse)
c('Hello', 'World') %>% write_lines( "output.txt")

writeLines() with sink()
sink("tempsink", type="output")
writeLines("Hello\nWorld")
sink()
file.show("tempsink", delete.file=TRUE)

text = c("Hello", "World")
write.table(text, file = "output.txt", col.names = F, row.names = F, quote = F)

<h2>Play birthday music</h2>
<a href="https://stackoverflow.com/questions/31782580/how-can-i-play-birthday-music-using-r" class="whitebut ">play-birthday-music</a>
library("dplyr")
library("audio")
notes = c(A = 0, B = 2, C = 3, D = 5, E = 7, F = 8, G = 10)
pitch = "D D E D G F# D D E D A G D D D5 B G F# E C5 C5 B G A G"
duration = c( rep( c(0.75, 0.25, 1, 1, 1, 2), 2),
              0.75, 0.25, 1, 1, 1, 1, 1, 0.75, 0.25, 1, 1, 1, 2)
bday = data_frame(pitch = strsplit(pitch, " ")[[1]], duration = duration)

bday =
  bday %>%
  mutate(octave = substring(pitch, nchar(pitch)) %>%
          {suppressWarnings(as.numeric(.))} %>%
           ifelse(is.na(.), 4, .),
           note = notes[substr(pitch, 1, 1)],
           note = note + grepl("#", pitch) -
           grepl("b", pitch) + octave * 12 + 12 * (note < 3),
           freq = 2 ^ ((note - 60) / 12) * 440)

tempo = 120
sample_rate = 44100 # this is MP3 sample freq, the freq resolution is 40Hz
                    # the A4 freq is 440Hz
                    # the A#4 freq is 466Hz
                    # the Ab4 freq is 415Hz

# A3 (220) A4 (440) A5 (880) C6 (1046.502)

make_sine = function(freq, duration) {
  wave = sin( seq(0, duration /tempo *60, 1 /sample_rate) *freq *2 *pi)
  fade = seq(0, 1, 50 /sample_rate)
  wave * c(fade, rep(1, length(wave) - 2 * length(fade)), rev(fade))
}

bday_wave = mapply(make_sine, bday$freq, bday$duration) %>% do.call("c", .)

play(bday_wave)

There's a few points to note.
The default octave for the notes is octave 4, where A4 is at 440 Hz (the note used to tune the orchestra).
Octaves change over at C, so C3 is one semitone higher than B2.
The reason for the fade in make_sine is that without it there are audible pops when starting and stopping notes.

simple way:
library("audio")
bday = load.wave(bday_file)
play(bday)

<h2>S4 objects, slot</h2>
A slot can be seen as a part, element or a "property" of S4 objects. 
Say you have a car object, then you can have the slots "price", "number of doors", "type of engine", "mileage".

Slots can be accessed in numerous ways :
> aCar@price
> slot(aCar,"typeEngine")

<h2>Read a UTF-8 text file with BOM</h2>
library("data.table")
theName = "file_name.csv"
thetempData = fread(theName , encoding = "UTF-8", stringsAsFactors = F)

<h2>Data Cleanup: Remove NA</h2>
data = data[!is.na(data)]

<h3>Identifying missing values</h3>
We can test for the presence of missing values via the is.na() function.

<code># remove na in r - test for missing values (is.na example)
test &lt;- c(1,2,3,NA)
is.na(test)</code>

In the example above, is.na() will return a vector indicating which elements have a na value.

<h3>na.omit() &#8211; remove rows with na from a list</h3>
This is the easiest option. 
The na.omit() function returns a list without any rows that contain na values. 

try na.omit() or na.exclude()
max( na.omit(vec) )

<code># remove na in r - remove rows - na.omit function / option
ompleterecords &lt;- na.omit(datacollected) </code>

Passing your data frame through the na.omit() function is a simple way to purge incomplete records from your analysis. 
It is an efficient way to remove na values in r.

<h3>complete.cases() &#8211; returns vector of rows with na values</h3>
The na.omit() function relies on the sweeping assumption that the dropped rows (removed the na values) are similar to the typical member of the dataset. 

We accomplish this with the complete.cases() function. 
This r function will examine a dataframe and return a vector of the rows which contain missing values. 
We can examine the dropped records and purge them if we wish.

<code># na in R - complete.cases example
fullrecords &lt;-  collecteddata[!complete.cases(collecteddata)] droprecords &lt;-  collecteddata[complete.cases(collecteddata)] </code>

<h3>Fix in place using&nbsp;na.rm</h3>
For certain statistical functions in R, you can guide the calculation around a missing value through including the na.rm parameter (na.rm=True). 
The rows with na values are retained in the dataframe but excluded from the relevant calculations. 
Support for this parameter varies by package and function, so please check the documentation for your specific package.

This is often the best option if you find there are significant trends in the observations with na values. 
Use the na.rm parameter to guide your code around the missing values and proceed from there. 
We prepared a guide to using na.rm.

<h3>NA Values and regression analysis</h3>
Removal of missing values can distort a regression analysis. 
This is particularly true if you are working with higher order or more complicated models. 
Fortunately, there are several options in the common packages for working around these issues.

If you are using the lm function, it includes a na.action option. 
As part of defining your model, you can indicate how the regression function should handle missing values. 
Two possible choices are na.omit and na.exclude. 
na.omit will omit all rows from the calculations. 
The na.exclude option removes na values from the R calculations but makes an additional adjustment (padding out vectors with missing values) to maintain the integrity of the residual analytics and predictive calculations. 
This is often more effective that procedures that delete rows from the calculations.

You also have the option of attempting to &#8220;heal&#8221; the data using custom procedures. 
In this situation, map is.na against the data set to generate a logical vector that identifies which rows need to be adjusted. 
From there, you can build your own &#8220;healing&#8221; logic.

<h2>create a empty zero-length vector</h2>
numeric()
logical()
character()
integer()
double()
raw()
complex() 
vector('numeric')
vector('character')
vector('integer')
vector('double')
vector('raw')
vector('complex')
All return 0 length vectors of the appropriate atomic modes.


<h2>Export R tables to HTML</h2>
library(tableHTML)
#create an html table 
tableHTML(mtcars)

#and to export in a file
write_tableHTML(tableHTML(mtcars), file = 'myfile.html')

<h2>h2o max_depth</h2>
Available in: GBM, DRF, XGBoost, Isolation Forest

Hyperparameter: yes

Description
This specifies the maximum depth to which each tree will be built. 
A single tree will stop splitting when there are no more splits that satisfy the min_rows parameter, if it reaches max_depth, or if there are no splits that satisfy this min_split_improvement parameter.

In general, deeper trees can seem to provide better accuracy on a training set because deeper trees can overfit your model to your data. 
Also, the deeper the algorithm goes, the more computing time is required. 
This is especially true at depths greater than 10. 
At depth 4, 8 nodes, for example, you need 8 * 100 * 20 trials to complete this splitting for the layer.

One way to determine an appropriate value for max_depth is to run a quick Cartesian grid search. 
Each model in the grid search will use early stopping to tune the number of trees using the validation set AUC, as before. 
The examples below are also available in the GBM Tuning Tutorials folder on GitHub.

The max_depth default value varies depending on the algorithm.

library(h2o)
h2o.init()
# import the titanic dataset
df = h2o.importFile(path = "http://s3.amazonaws.com/h2o-public-test-data/smalldata/gbm_test/titanic.csv")
dim(df)
head(df)
tail(df)
summary(df, exact_quantiles = TRUE)

# pick a response for the supervised problem
response = "survived"

# the response variable is an integer.
# we will turn it into a categorical/factor for binary classification
df[[response]] = as.factor(df[[response]])

# use all other columns (except for the name) as predictors
predictors = setdiff(names(df), c(response, "name"))

# split the data for machine learning
splits = h2o.splitFrame(data = df,
                         ratios = c(0.6, 0.2),
                         destination_frames = c("train", "valid", "test"),
                         seed = 1234)
train = splits[[1]]
valid = splits[[2]]
test  = splits[[3]]

# Establish a baseline performance using a default GBM model trained on the 60% training split
# We only provide the required parameters, everything else is default
gbm = h2o.gbm(x = predictors, y = response, training_frame = train)

# Get the AUC on the validation set
h2o.auc(h2o.performance(gbm, newdata = valid))
# The AUC is over 94%, so this model is highly predictive!
[1] 0.9480135

# Determine the best max_depth value to use during a hyper-parameter search.
# Depth 10 is usually plenty of depth for most datasets, but you never know
hyper_params = list( max_depth = seq(1, 29, 2) )
# or hyper_params = list( max_depth = c(4, 6, 8, 12, 16, 20) ), which is faster for larger datasets

grid = h2o.grid(
  hyper_params = hyper_params,

  # full Cartesian hyper-parameter search
  search_criteria = list(strategy = "Cartesian"),

  # which algorithm to run
  algorithm = "gbm",

  # identifier for the grid, to later retrieve it
  grid_id = "depth_grid",

  # standard model parameters
  x = predictors,
  y = response,
  training_frame = train,
  validation_frame = valid,

  # more trees is better if the learning rate is small enough
  # here, use "more than enough" trees - we have early stopping
  ntrees = 10000,

  # smaller learning rate is better, but because we have learning_rate_annealing,
  # we can afford to start with a bigger learning rate
  learn_rate = 0.05,

  # learning rate annealing: learning_rate shrinks by 1% after every tree
  # (use 1.00 to disable, but then lower the learning_rate)
  learn_rate_annealing = 0.99,

  # sample 80% of rows per tree
  sample_rate = 0.8,

  # sample 80% of columns per split
  col_sample_rate = 0.8,

  # fix a random number generator seed for reproducibility
  seed = 1234,

  # early stopping once the validation AUC doesn't improve by at least
  # 0.01% for 5 consecutive scoring events
  stopping_rounds = 5,
  stopping_tolerance = 1e-4,
  stopping_metric = "AUC",

  # score every 10 trees to make early stopping reproducible
  # (it depends on the scoring interval)
  score_tree_interval = 10)

# by default, display the grid search results sorted by increasing logloss
# (because this is a classification task)
grid

# sort the grid models by decreasing AUC
sorted_grid = h2o.getGrid("depth_grid", sort_by="auc", decreasing = TRUE)
sorted_grid

# find the range of max_depth for the top 5 models
top_depths = sortedGrid@summary_table$max_depth[1:5]
min_depth = min(as.numeric(top_depths))
max_depth = max(as.numeric(top_depths))

> sorted_grid
#H2O Grid Details
Grid ID: depth_grid
Used hyper parameters:
 -  max_depth
Number of models: 15
Number of failed models: 0
Hyper-Parameter Search Summary: ordered by decreasing auc
     max_depth           model_ids                auc
  1         13  depth_grid_model_6 0.9552831783601015
...
  15         1  depth_grid_model_0 0.9478162862778248

It appears that max_depth values of 9 to 27 are best suited for this dataset, which is unusually deep.

<h2>Median</h2>
The middle most value in a data series is called the median.
The median() function is used in R to calculate this value.

data = c( 1, 2, 2, 2,3,3, 4, 7, 9 )
median(data) # Find the median 3

<h2>find mode</h2>
the value that has highest number of occurrences in a dataset
R does not have a standard in-built mode function

x = c(1,2,1,2,3,4,5,5,4,3,2,3,4)
getModes = function(x) {
  ux = unique(x)
  tab = tabulate(match(x, ux))
  ux[tab == max(tab)]
}
getModes(x)  # 2 3 4   three modes here


<h2>h2o Course Prerequisites</h2>
sample codes
http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-munging/merging-data.html
http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/algo-params/max_depth.html.

familiar with pandas
http://pandas.pydata.org/pandas-docs/stable/10min.html

R and Python+Pandas
https://www.slideshare.net/ajayohri/python-for-r-users

Basic Stats
https://mathwithbaddrawings.com/2016/07/13/why-not-to-trust-statistics/
http://www.itl.nist.gov/div898/handbook/eda/section3/eda366.htm

most important to understand the normal distribution and standard deviation:
https://en.wikipedia.org/wiki/Standard_deviation


https://students.brown.edu/seeing-theory
linear regression

advice intermixed with xkcd cartoons on stats:
http://livefreeordichotomize.com/2016/12/15/hill-for-the-data-scientist-an-xkcd-story

Confusion Matrix
http://www.dataschool.io/simple-guide-to-confusion-matrix-terminology/


Bias/Variance
http://scott.fortmann-roe.com/docs/BiasVariance.html
https://elitedatascience.com/bias-variance-tradeoff
https://en.wikipedia.org/wiki/Bias_of_an_estimator#Bias.2C_variance_and_mean_squared_error

<h2>droplevels</h2>
removes unused levels of a factor. 
x = factor(c(3, 4, 8, 1, 5, 4, 4, 5))        # Example factor vector
x = x[- 1]                                   # Delete first entry

Our example vector consists of five factor levels: 1, 3, 4, 5, and 8. 
However, the vector itself does not include the value 3. 
The factor level 3 might therefore be dropped. 

x_drop = droplevels(x)                       # Apply droplevels in R
x_drop
# 4 8 1 5 4 4 5
# Levels: 1 4 5 8

<h2>h2o samples</h2>
library(h2o)
h2o.init()

h2oiris = as.h2o( droplevels(iris[1:100,]))

h2oiris
class(h2oiris)
h2o.levels(h2oiris, 5)

write.csv( mtcars, file = 'mtcars.csv') # create local data
h2omtcars = h2o.importFile( path = 'mtcars.csv')
h2omtcars

h2obin = h2o.importFile( path = 'https://stats.idre.ucla.edu/stat/data/binary.csv') # load online data

gbmModel = h2o.gbm( x = c('Month', 'DayOfWeek', 'Distance'), y = 'IsDepDelayed', training_frame = airlinesTrainData) # train model use GBM

h2o.varimp(gbmModel) # find variable importance

xgBoostModel = h2o.xgboost( x = c('Month', 'DayOfWeek', 'Distance'), y = 'IsDepDelayed', training_frame = airlinesTrainData) # xgb model

h2o.predict( gbmModel, airlinesTrainData) # predict

# https://stats.idre.ucla.edu/other/dae/
# http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm.html
# http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-science/gbm.html#defining-a-gbm-model
# https://dzone.com/articles/how-do-you-measure-if-your-customer-churn-predicti

<h2>Gradient Boosting Machine</h2>
Gradient boosting is a machine learning technique for regression and classification problems, which produces a prediction model in the form of an ensemble of weak prediction models, typically decision trees. 

H2O's Gradient Boosting Machine (GBM) offers a Stochastic GBM, which can increase performance quite a bit compared to the original GBM implementation.

Now we will train a basic GBM model

The GBM model will infer the response distribution from the response encoding if not specified explicitly through the "distribution" argument.
A seed is required for reproducibility.

gbm_fit1 = h2o.gbm(
  x = x, y = y, training_frame = train, model_id = "gbm_fit1", seed = 1)

Next we will increase the number of trees used in the GBM by setting "ntrees=500".

The default number of trees in an H2O GBM is 50, so this GBM will trained using ten times the default.

Increasing the number of trees in a GBM is one way to increase performance of the model, however, you have to be careful not to overfit your model to the training data by using too many trees.

To automatically find the optimal number of trees, you must use H2O's early stopping functionality.

This example will not do that, however, the following example will.

gbm_fit2 = h2o.gbm(
  x = x, y = y, training_frame = train, model_id = "gbm_fit2",
    #validation_frame = valid, only used if stopping_rounds > 0
  ntrees = 500, seed = 1)

We will again set "ntrees = 500", however, this time we will use early stopping in order to prevent overfitting (from too many trees).

All of H2O's algorithms have early stopping available, however early stopping is not enabled by default (with the exception of Deep Learning).

There are several parameters that should be used to control early stopping.

The three that are common to all the algorithms are: "stopping_rounds", "stopping_metric" and "stopping_tolerance".

The stopping metric is the metric by which you'd like to measure performance, and so we will choose AUC here.

The "score_tree_interval" is a parameter specific to the Random Forest model and the GBM.

Setting "score_tree_interval = 5" will score the model after every five trees.

The parameters we have set below specify that the model will stop training after there have been three scoring intervals where the AUC has not increased more than 0.0005.

Since we have specified a validation frame, the stopping tolerance will be computed on validation AUC rather than training AUC. 

gbm_fit3 = h2o.gbm(
  x = x, y = y, training_frame = train, model_id = "gbm_fit3",
  validation_frame = valid,  #only used if stopping_rounds > 0
  ntrees = 500, score_tree_interval = 5,      #used for early stopping
                stopping_rounds = 3,          #used for early stopping
                stopping_metric = "AUC",      #used for early stopping
                stopping_tolerance = 0.0005,  #used for early stopping
                seed = 1)

Let's compare the performance of the two GBMs

gbm_perf1 = h2o.performance(model = gbm_fit1, newdata = test)
gbm_perf2 = h2o.performance(model = gbm_fit2, newdata = test)
gbm_perf3 = h2o.performance(model = gbm_fit3, newdata = test)

# Print model performance
gbm_perf1
gbm_perf2
gbm_perf3

# Retreive test set AUC
h2o.auc(gbm_perf1)  # 0.682765594191
h2o.auc(gbm_perf2)  # 0.671854616713
h2o.auc(gbm_perf3)  # 0.68309902855


To examine the scoring history, use the "scoring_history" method on a trained model.
If "score_tree_interval" is not specified, it will score at various intervals, as we can see for "h2o.scoreHistory()" below.
However, regular 5-tree intervals are used for "h2o.scoreHistory()".
The "gbm_fit2" was trained only using a training set (no validation set), so the scoring history is calculated for training set performance metrics only.

h2o.scoreHistory(gbm_fit2)


When early stopping is used, we see that training stopped at 105 trees instead of the full 500.
Since we used a validation set in "gbm_fit3", both training and validation performance metrics are stored in the scoring history object.
Take a look at the validation AUC to observe that the correct stopping tolerance was enforced.

h2o.scoreHistory(gbm_fit3)

Look at scoring history for third GBM model

plot(gbm_fit3, timestep = "number_of_trees", metric = "AUC")
plot(gbm_fit3, timestep = "number_of_trees", metric = "logloss")

4. Deep Learning
H2O's Deep Learning algorithm is a multilayer feed-forward artificial neural network.
It can also be used to train an autoencoder.
In this example we will train a standard supervised prediction model.

Train a default DL
First we will train a basic DL model with default parameters.
The DL model will infer the response distribution from the response encoding if it is not specified explicitly through the "distribution" argument.
H2O's DL will not be reproducible if it is run on more than a single core, so in this example, the performance metrics below may vary slightly from what you see on your machine.
In H2O's DL, early stopping is enabled by default, so below, it will use the training set and default stopping parameters to perform early stopping.

dl_fit1 = h2o.deeplearning(x = x,
     y = y,
     training_frame = train,
     model_id = "dl_fit1",
     seed = 1)

Train a DL with new architecture and more epochs.

Next we will increase the number of epochs used in the GBM by setting "epochs=20" (the default is 10).
Increasing the number of epochs in a deep neural net may increase performance of the model, however, you have to be careful not to overfit your model to your training data.
To automatically find the optimal number of epochs, you must use H2O's early stopping functionality.
Unlike the rest of the H2O algorithms, H2O's DL will use early stopping by default, so for comparison we will first turn off early stopping.
We do this in the next example by setting "stopping_rounds=0".

dl_fit2 = h2o.deeplearning(
  x = x, y = y, training_frame = train, model_id = "dl_fit2",
     #validation_frame = valid, only used if stopping_rounds > 0
     epochs = 20, hidden= c(10,10),
     stopping_rounds = 0,  # disable early stopping
     seed = 1)
Train a DL with early stopping This example will use the same model parameters as "dl_fit2".
This time, we will turn on  early stopping and specify the stopping criterion.
We will also pass a validation set, as is recommended for early stopping.

dl_fit3 = h2o.deeplearning(
  x = x, y = y, training_frame = train, model_id = "dl_fit3",
     validation_frame = valid,  #in DL, early stopping is on by default
     epochs = 20, hidden = c(10,10),
     score_interval = 1,           #used for early stopping
     stopping_rounds = 3,          #used for early stopping
     stopping_metric = "AUC",      #used for early stopping
     stopping_tolerance = 0.0005,  #used for early stopping
     seed = 1)


Let's compare the performance of the three DL models
dl_perf1 = h2o.performance(model = dl_fit1, newdata = test)
dl_perf2 = h2o.performance(model = dl_fit2, newdata = test)
dl_perf3 = h2o.performance(model = dl_fit3, newdata = test)

Print model performance
dl_perf1
dl_perf2
dl_perf3

# Retreive test set AUC
h2o.auc(dl_perf1)  # 0.6774335
h2o.auc(dl_perf2)  # 0.678446
h2o.auc(dl_perf3)  # 0.6770498

# Scoring history
h2o.scoreHistory(dl_fit3)
# Scoring History: 
  timestamp   duration  training_speed   epochs
1 2016-05-03 10:33:29  0.000 sec                  0.00000
2 2016-05-03 10:33:29  0.347 sec 424697 rows/sec  0.86851
3 2016-05-03 10:33:30  1.356 sec 601925 rows/sec  6.09185
4 2016-05-03 10:33:31  2.348 sec 717617 rows/sec 13.05168
5 2016-05-03 10:33:32  3.281 sec 777538 rows/sec 20.00783
6 2016-05-03 10:33:32  3.345 sec 777275 rows/sec 20.00783

# iterations        samples training_MSE training_r2
1          0       0.000000  
2          1   99804.000000      0.14402     0.03691
3          7  700039.000000      0.14157     0.05333
4         15 1499821.000000      0.14033     0.06159
5         23 2299180.000000      0.14079     0.05853
6         23 2299180.000000      0.14157     0.05333
# training_logloss training_AUC training_lift
1                     
2          0.45930      0.66685       2.20727
3          0.45220      0.68133       2.59354
4          0.44710      0.67993       2.70390
5          0.45100      0.68192       2.81426
6          0.45220      0.68133       2.59354
# training_classification_error validation_MSE validation_r2
1             
2                       0.36145        0.14682       0.03426
3                       0.33647        0.14500       0.04619
4                       0.37126        0.14411       0.05204
5                       0.32868        0.14474       0.04793
6                       0.33647        0.14500       0.04619
# validation_logloss validation_AUC validation_lift
1    
2            0.46692        0.66582         2.53209
3            0.46256        0.67354         2.64124
4            0.45789        0.66986         2.44478
5            0.46292        0.67117         2.70672
6            0.46256        0.67354         2.64124
# validation_classification_error
1         
2  0.37197
3  0.34716
4  0.34385
5  0.36544
6  0.34716

# Look at scoring history for third DL model
plot(dl_fit3, timestep = "epochs", metric = "AUC")


5. Naive Bayes model
The Naive Bayes (NB) algorithm does not usually beat an algorithm like a Random Forest or GBM, however it is still a popular algorithm, especially in the text domain (when your input is text encoded as "Bag of Words", for example).
The Naive Bayes algorithm is for binary or multiclass classification problems only, not regression.
Therefore, your response must be a factor instead of a numeric.

First we will train a basic NB model with default parameters. 

nb_fit1 = h2o.naiveBayes(
  x = x, y = y, training_frame = train, model_id = "nb_fit1")

Train a NB model with Laplace Smoothing
One of the few tunable model parameters for the Naive Bayes algorithm is the amount of Laplace smoothing. 
The H2O Naive Bayes model will not use any Laplace smoothing by default.

nb_fit2 = h2o.naiveBayes(
  x = x, y = y, training_frame = train, model_id = "nb_fit2", laplace = 6)

Let's compare the performance of the two NB models
nb_perf1 = h2o.performance(model = nb_fit1, newdata = test)
nb_perf2 = h2o.performance(model = nb_fit2, newdata = test)

# Print model performance
nb_perf1
nb_perf2

# Retreive test set AUC
h2o.auc(nb_perf1)  # 0.6488014
h2o.auc(nb_perf2)  # 0.6490678

<h2>Confusion Matrix</h2>
<a href="http://www.dataschool.io/simple-guide-to-confusion-matrix-terminology/" class="whitebut ">the basic yes/no confusion matrix</a>

<a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" class="whitebut ">Bias/Variance</a>

<a href="https://elitedatascience.com/bias-variance-tradeoff" class="whitebut ">the Bias-Variance Tradeoff</a>

<a href="https://en.wikipedia.org/wiki/Bias_of_an_estimator#Bias.2C_variance_and_mean_squared_error" class="whitebut ">shows biased estimator can be better than perfectly unbiased estimator</a>

<a href="https://www.coursera.org/learn/machine-learning-h2o/home/welcome" class="whitebut ">Practical Machine Learning on H2O</a>

<a href="http://docs.h2o.ai/h2o/latest-stable/h2o-docs/data-munging/merging-data.html" class="whitebut ">Merging Two Datasets</a>

<a href="https://www.h2o.ai/download/" class="whitebut ">Downloads</a>

<h2>Print Strings without Quotes</h2>
   print(resultTable, quote = FALSE, row.names = FALSE, col.names = FALSE)
   write.table(resultTable, file = "/tmp/foo.csv", quote = FALSE,  row.names = FALSE, sep = "\t")

<h2>The apply family</h2>
<a href="https://nicercode.github.io/guides/repeating-things/" class="whitebut ">repeating-things</a>

There are several related function in R which allow you to apply some function to a series of objects (eg. vectors, matrices, dataframes or files). They include:
lapply
sapply
tapply
aggregate
mapply
apply

Each repeats a function or operation on a series of elements, but they differ in the data types they accept and return. What they all in common is that <k>order of iteration is not important</k>.  This is crucial. If each each iteration is independent, then you can cycle through them in whatever order you like. Generally, we argue that you should only use the generic looping functions <code>for</code>, <code>while</code>, and <code>repeat</code> when the order or operations <k>is</k> important. Otherwise reach for one of the apply tools.

<h2>lapply and sapply</h2>

<code>lapply</code> applies a function to each element of a list (or vector), collecting results in a list.  <code>sapply</code> does the same, but will try to <em>simplify</em> the output if possible.

Lists are a very powerful and flexible data structure that few people seem to know about. Moreover, they are the building block for other data structures, like <code>data.frame</code> and <code>matrix</code>. To access elements of a list, you use the double square bracket, for example <code>X[[4]]</code> returns the fourth element of the list <code>X</code>. If you don’t know what a list is, we suggest you <a href="http://cran.r-project.org/doc/manuals/R-intro.html#Lists-and-data-frames">read more about them</a>, before you proceed.
<h3>Basic syntax</h3>
<code>result &lt;- lapply(a list or vector, a function, ...)</code>

This code will also return a list, stored in <code>result</code>, with same number of elements as <code>X</code>.

<h3>Usage</h3>
lapply is great for building analysis pipelines, where you want to repeat a series of steps on a large number of similar objects.  The way to do this is to have a series of lapply statements, with the output of one providing the input to another:
<code>first.step &lt;- lapply(X, first.function) second.step &lt;- lapply(first.step, next.function)</code>

The challenge is to identify the parts of your analysis that stay the same and those that differ for each call of the function. The trick to using <code>lapply</code> is to recognise that only one item can differ between different function calls.

It is possible to pass in a bunch of additional arguments to your function, but these must be the same for each call of your function. For example, let’s say we have a function <code>test</code> which takes the path of a file, loads the data, and tests it against some hypothesised value H0. We can run the function on the file
“myfile.csv” as follows.

<code>result &lt;- test("myfile.csv", H0=1)</code>

We could then run the test on a bunch of files using lapply:

<code>files &lt;- c("myfile1.csv", "myfile2.csv", "myfile3.csv") result &lt;- lapply(files, test, H0=1)</code>

But notice, that in this example, the <k>only this that differs</k> between the runs is a single number in the file name. So we could save ourselves typing these by adding an extra step to generate the file names

<code>files &lt;- lapply(1:10, function(x){paste0("myfile", x, ".csv")}) result &lt;- lapply(files, test, H0=1)</code>

The nice things about that piece of code is that it would extend as long as we wanted, to 10000000 files, if needed.

<h3>Example - plotting temperature for many sites using open weather data</h3>
Let’s look at the weather in some eastern Australian cities over the last couple of days.  The website
<a href="http://openweathermap.org">openweathermap.com</a> provides access to all sorts of neat data, lots of it essentially real time.  We’ve parcelled up some on the nicercode website to use.  In theory, this sort of analysis script could use the weather data directly, but we don’t want to hammer their website too badly.  The code used to generate these files is <a href="https://gist.github.com/richfitz/5795029">here</a>.

We want to look at the temperatures over the last few days for the cities

<code>cities &lt;- c("Melbourne", "Sydney", "Brisbane", "Cairns")</code>

The data are stored in a url scheme where the Sydney data is at
<a href="http://nicercode.github.io/guides/repeating-things/data/Sydney.csv">http://nicercode.github.io/guides/repeating-things/data/Sydney.csv</a> and so on.  

The URLs that we need are therefore:

<code>urls &lt;-
 sprintf("http://nicercode.github.io/guides/repeating-things/data/%s.csv",
         cities) urls</code>

<code>[1] "http://nicercode.github.io/guides/repeating-things/data/Melbourne.csv"
[2] "http://nicercode.github.io/guides/repeating-things/data/Sydney.csv"   
[3] "http://nicercode.github.io/guides/repeating-things/data/Brisbane.csv" 
[4] "http://nicercode.github.io/guides/repeating-things/data/Cairns.csv"   </code>

We can write a function to download a file if it does not exist:

<code>download.maybe &lt;- function(url, refetch=FALSE, path=".") {
 dest &lt;- file.path(path, basename(url))
 if (refetch || !file.exists(dest))
   download.file(url, dest)
 dest
}</code>
and then run that over the urls:

<code>path &lt;- "data" dir.create(path, showWarnings=FALSE) files &lt;- sapply(urls, download.maybe, path=path) names(files) &lt;- cities</code>

Notice that we never specify the order of which file is downloaded in which order; we just say “apply this function (<code>download.maybe</code>) to this list of urls.  We also pass the <code>path</code> argument to every function call.  So it was as if we’d written

<code>download.maybe(urls[[1]], path=path) download.maybe(urls[[2]], path=path) download.maybe(urls[[3]], path=path) download.maybe(urls[[4]], path=path)</code>
but much less boring, and scalable to more files.

The first column, <code>time</code> of each file is a string representing date and time, which needs processing into R’s native time format (dealing with times in R (or frankly, in any language) is a complete pain).  In a real case, there might be many steps involved in processing each file.  We can make a function like this:

<code>load.file &lt;- function(filename) {
 d &lt;- read.csv(filename, stringsAsFactors=FALSE)
 d$time &lt;- as.POSIXlt(d$time)
 d
}</code>
that reads in a file given a filename, and then apply that function to each filename using <code>lapply</code>:

<code>data &lt;- lapply(files, load.file) names(data) &lt;- cities</code>

We now have a <k>list</k>, where each element is a <code>data.frame</code> of weather data:

<code>head(data$Sydney)</code>

<code>             time  temp temp.min temp.max
1 2013-06-13 23:00:00 12.66     8.89    16.11
2 2013-06-14 00:00:00 15.90    12.22    20.00
3 2013-06-14 02:00:00 18.44    16.11    20.00
4 2013-06-14 03:00:00 18.68    16.67    20.56
5 2013-06-14 04:00:00 19.41    17.78    22.22
6 2013-06-14 05:00:00 19.10    17.78    22.22</code>

We can use <code>lapply</code> or <code>sapply</code> to easy ask the same question to each element of this list.  For example, how many rows of data are there?

<code>sapply(data, nrow)</code>

<code>Melbourne    Sydney  Brisbane    Cairns 
      97        99        99        80 </code>

What is the hottest temperature recorded by city?

<code>sapply(data, function(x) max(x$temp))</code>

<code>Melbourne    Sydney  Brisbane    Cairns 
   12.85     19.41     22.00     31.67 </code>
or, estimate the autocorrelation function for each set:

<code>autocor &lt;- lapply(data, function(x) acf(x$temp, lag.max=24))</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-221.png" alt="plot of chunk unnamed-chunk-22" /> 
<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-222.png" alt="plot of chunk unnamed-chunk-22" /> 
<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-223.png" alt="plot of chunk unnamed-chunk-22" /> 
<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-224.png" alt="plot of chunk unnamed-chunk-22" />

<code>plot(autocor$Sydney, main="Sydney")</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-225.png" alt="plot of chunk unnamed-chunk-22" />

<code>plot(autocor$Cairns, main="Cairns")</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-226.png" alt="plot of chunk unnamed-chunk-22" />

I find that for loops can be easier to plot data, partly because there is nothing to <em>collect</em> (or combine) at each iteration.

<code>xlim &lt;- range(sapply(data, function(x) range(x$time))) ylim &lt;- range(sapply(data, function(x) range(x[-1]))) plot(data[[1]]$time, data[[1]]$temp, ylim=ylim, type="n",
    xlab="Time", ylab="Temperature") cols &lt;- 1:4 for (i in seq_along(data))
 lines(data[[i]]$time, data[[i]]$temp, col=cols[i])</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-23.png" alt="plot of chunk unnamed-chunk-23" />

<code>plot(data[[1]]$time, data[[1]]$temp, ylim=ylim, type="n",
    xlab="Time", ylab="Temperature") mapply(function(x, col) lines(x$time, x$temp, col=col),
      data, cols)</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-24.png" alt="plot of chunk unnamed-chunk-24" />

<code>$Melbourne
NULL

$Sydney
NULL

$Brisbane
NULL

$Cairns
NULL</code>

<h3>Parallelising your code</h3>
Another great feature of lapply is that is <k>makes it really easy to parallelise your code</k>. All computers now contain multiple CPUs, and these can all be put to work using the great <a href="http://www.rforge.net/multicore/">multicore package</a>.

<code>result &lt;- lapply(x, f)   #apply f to x using a single core and lapply
library(multicore) result &lt;- mclapply(x, f) #same thing using all the cores in your machine</code>

<h2>tapply and aggregate</h2>

In the case above, we had naturally “split” data; we had a vector of city names that led to a list of different data.frames of weather data.  Sometimes the “split” operation depends on a factor.  For example, you might have an experiment where you measured the size of plants at different levels of added fertiliser - you then want to know the mean height as a function of this treatment.

However, we’re actiually going to use some data on <a href="https://github.com/audy/smalldata">ratings of seinfeld episodes</a>, taken from the [Internet movie Database]
(http://www.reddit.com/r/dataisbeautiful/comments/1g7jw2/seinfeld_imdb_episode_ratings_oc/).

<code>library(downloader) if (!file.exists("seinfeld.csv"))
 download("https://raw.github.com/audy/smalldata/master/seinfeld.csv",
          "seinfeld.csv") dat &lt;- read.csv("seinfeld.csv", stringsAsFactors=FALSE)</code>

Columns are Season (number), Episode (number), Title (of the episode), Rating (according to IMDb) and Votes (to construct the rating).

<code>head(dat)</code>

<code>  Season Episode             Title Rating Votes
1      1       2      The Stakeout    7.8   649
2      1       3       The Robbery    7.7   565
3      1       4    Male Unbonding    7.6   561
4      1       5     The Stock Tip    7.8   541
5      2       1 The Ex-Girlfriend    7.7   529
6      2       1        The Statue    8.1   509</code>

Make sure it’s sorted sensibly

<code>dat &lt;- dat[order(dat$Season, dat$Episode),]</code>

Biologically, this could be Site / Individual / ID / Mean size /
Things measured.

Hypothesis: Seinfeld used to be funny, but got progressively less good as it became too mainstream.  Or, does the mean episode rating per season decrease?

Now, we want to calculate the average rating per season:

<code>mean(dat$Rating[dat$Season == 1])</code>

<code>[1] 7.725</code>

<code>mean(dat$Rating[dat$Season == 2])</code>

<code>[1] 8.158</code>
and so on until:

<code>mean(dat$Rating[dat$Season == 9])</code>

<code>[1] 8.323</code>

As with most things, we <em>could</em> automate this with a for loop:

<code>seasons &lt;- sort(unique(dat$Season)) rating  &lt;- numeric(length(seasons)) for (i in seq_along(seasons))
 rating[i] &lt;- mean(dat$Rating[dat$Season == seasons[i]])</code>

That’s actually not that horrible to do.  But we it could be nicer.  We first <k>split</k> the ratings by season:

<code>ratings.split &lt;- split(dat$Rating, dat$Season) head(ratings.split)</code>

<code>$`1`
[1] 7.8 7.7 7.6 7.8

$`2`
[1] 7.7 8.1 8.0 7.9 7.8 8.5 8.7 8.5 8.0 8.0 8.4 8.3

$`3`
[1] 8.3 7.5 7.8 8.1 8.3 7.3 8.7 8.5 8.5 8.6 8.1 8.4 8.5 8.7 8.6 7.8 8.3
[18] 8.6 8.7 8.6 8.0 8.5 8.6

$`4`
[1] 8.4 8.3 8.6 8.5 8.7 8.6 8.1 8.2 8.7 8.4 8.3 8.7 8.5 8.6 8.3 8.2 8.4
[18] 8.5 8.4 8.7 8.7 8.4 8.5

$`5`
[1] 8.6 8.4 8.4 8.4 8.3 8.2 8.1 8.5 8.5 8.3 8.0 8.1 8.6 8.3 8.4 8.5 7.9
[18] 8.0 8.5 8.7 8.5

$`6`
[1] 8.1 8.4 8.3 8.4 8.2 8.3 8.5 8.4 8.3 8.2 8.1 8.4 8.6 8.2 7.5 8.4 8.2
[18] 8.5 8.3 8.4 8.1 8.5 8.2</code>

Then use sapply to loop over this list, computing the mean

<code>rating &lt;- sapply(ratings.split, mean)</code>

Then if we wanted to apply a different function (say, compute the per-season standard error) we could just do:

<code>se &lt;- function(x)
 sqrt(var(x) / length(x)) rating.se &lt;- sapply(ratings.split, se)
plot(rating ~ seasons, ylim=c(7, 9), pch=19) arrows(seasons, rating - rating.se, seasons, rating + rating.se,
      code=3, angle=90, length=0.02)</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-34.png" alt="plot of chunk unnamed-chunk-34" />

But there’s still repetition there.  Let’s abstract that away a bit.

Suppose we want a:
 1. response variable (like Rating was)
 2. grouping variable (like Season was)
 3. function to apply to each level

This just writes out <em>exactly</em> what we had before

<code>summarise.by.group &lt;- function(response, group, func) {
 response.split &lt;- split(response, group)
 sapply(response.split, func)
}</code>

We can compute the mean rating by season again:

<code>rating.new &lt;- summarise.by.group(dat$Rating, dat$Season, mean)</code>
which is the same as what we got before:

<code>identical(rating.new, rating)</code>

<code>[1] TRUE</code>

Of course, we’re not the first people to try this.  This is <k>exactly</k> what the <code>tapply</code> function does (but with a few bells and whistles, especially around missing values, factor levels, additional arguments and multiple grouping factors at once).

<code>tapply(dat$Rating, dat$Season, mean)</code>

<code>1     2     3     4     5     6     7     8     9 
7.725 8.158 8.304 8.465 8.343 8.283 8.441 8.423 8.323 </code>

So using <code>tapply</code>, you can do all the above manipulation in a single line.

There are a couple of limitations of <code>tapply</code>.

The first is that getting the season out of <code>tapply</code> is quite hard.  We could do:

<code>as.numeric(names(rating))</code>

<code>[1] 1 2 3 4 5 6 7 8 9</code>

But that’s quite ugly, not least because it involves the conversion numeric -> string -> numeric.

Better could be to use

<code>sort(unique(dat$Season))</code>

<code>[1] 1 2 3 4 5 6 7 8 9</code>

But that requires knowing what is going on inside of <code>tapply</code> (that unique levels are sorted and data are returned in that order).

I suspect that this approach:

<code>first &lt;- function(x) x[[1]] tapply(dat$Season, dat$Season, first)</code>

<code>1 2 3 4 5 6 7 8 9 
1 2 3 4 5 6 7 8 9 </code>
is probably the most fool-proof, but it’s certainly not pretty.

However, the returned format is extremely flexible.  If you do:

The <code>aggregate</code> function provides a simplfied interface to <code>tapply</code> that avoids this issue.  It has two interfaces: the first is similar to what we used before, but the grouping variable now must be a list or data frame:

<code>aggregate(dat$Rating, dat["Season"], mean)</code>

<code>  Season     x
1      1 7.725
2      2 8.158
3      3 8.304
4      4 8.465
5      5 8.343
6      6 8.283
7      7 8.441
8      8 8.423
9      9 8.323</code>

(note that <code>dat["Season"]</code> returns a one-column data frame).  The column ‘x’ is our response variable, Rating, grouped by season.  We can get its name included in the column names here by specifying the first argument as a <code>data.frame</code> too:

<code>aggregate(dat["Rating"], dat["Season"], mean)</code>

<code>  Season Rating
1      1  7.725
2      2  8.158
3      3  8.304
4      4  8.465
5      5  8.343
6      6  8.283
7      7  8.441
8      8  8.423
9      9  8.323</code>

The other interface is the formula interface, that will be familiar from fitting linear models:

<code>aggregate(Rating ~ Season, dat, mean)</code>

<code>  Season Rating
1      1  7.725
2      2  8.158
3      3  8.304
4      4  8.465
5      5  8.343
6      6  8.283
7      7  8.441
8      8  8.423
9      9  8.323</code>

This interface is really nice; we can get the number of votes here too.

<code>aggregate(cbind(Rating, Votes) ~ Season, dat, mean)</code>

<code>  Season Rating Votes
1      1  7.725 579.0
2      2  8.158 533.0
3      3  8.304 496.7
4      4  8.465 497.0
5      5  8.343 452.5
6      6  8.283 385.7
7      7  8.441 408.0
8      8  8.423 391.4
9      9  8.323 415.0</code>

If you have multiple grouping variables, you can write things like:
&lt;div class='bogus-wrapper'>&lt;figcaption>&lt;/figcaption>&lt;div class=&#8221;highlight&#8221;>&lt;table>&lt;tr>&lt;td class=&#8221;gutter&#8221;>&lt;pre class=&#8221;line-numbers&#8221;>1
&lt;/pre>&lt;/td>&lt;td class='code'>&lt;pre><code>aggregate(response ~ factor1 + factor2, dat, function)</code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>&lt;/div>&lt;/div>

to apply a function to each pair of levels of <code>factor1</code> and <code>factor2</code>.

<h2>replicate</h2>

This is great in Monte Carlo simulation situations.  For example.
Suppose that you flip a fair coin n times and count the number of heads:

<code>trial &lt;- function(n)
 sum(runif(n) &lt; 0.5) # could have done a binomial draw...</code>

You can run the trial a bunch of times:

<code>trial(10)</code>

<code>[1] 4</code>

<code>trial(10)</code>

<code>[1] 4</code>

<code>trial(10)</code>

<code>[1] 6</code>
and get a feel for the results.  If you want to replicate the trial
100 times and look at the distribution of results, you could do:

<code>replicate(100, trial(10))</code>

<code>  [1] 4 4 5 6 8 5 5 7 3 5 6 4 4 3 5 3 6 7 2 6 6 4 5 4 4 4 4 5 6 5 4 2 6 5 6
[36] 5 6 8 5 6 4 5 4 5 5 5 4 7 3 5 5 6 4 6 4 6 4 4 4 6 3 5 5 7 6 7 5 3 4 4
[71] 5 6 8 5 6 2 5 7 6 3 5 9 3 7 6 4 5 3 7 3 3 7 6 8 5 4 6 7 4 3</code>
and then you could plot these:

<code>plot(table(replicate(10000, trial(50))))</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-49.png" alt="plot of chunk unnamed-chunk-49" />

<h3>for loops</h3>
“<code>for</code>” loops shine where the output of one iteration depends on the result of the previous iteration.

Suppose you wanted to model random walk.  Every time step, with 50% probability move left or right.

Start at position 0

<code>x &lt;- 0</code>

Move left or right with probability p (0.5 = unbiased)

<code>p &lt;- 0.5</code>

Update the position

<code>x &lt;- x + if (runif(1) &lt; p) -1 else 1</code>

Let’s abstract the update into a function:

<code>step &lt;- function(x, p=0.5)
 x + if (runif(1) &lt; p) -1 else 1</code>

Repeat a bunch of times:

<code>x &lt;- step(x) x &lt;- step(x)</code>

To find out where we got to after 20 steps:

<code>for (i in 1:20)
 x &lt;- step(x)</code>

If we want to collect where we’re up to at the same time:

<code>nsteps &lt;- 200 x &lt;- numeric(nsteps + 1) x[1] &lt;- 0 # start at 0 for (i in seq_len(nsteps))
 x[i+1] &lt;- step(x[i]) plot(x, type="l")</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-56.png" alt="plot of chunk unnamed-chunk-56" />

Pulling <em>that</em> into a function:

<code>random.walk &lt;- function(nsteps, x0=0, p=0.5) {
 x &lt;- numeric(nsteps + 1)
 x[1] &lt;- x0
 for (i in seq_len(nsteps))
   x[i+1] &lt;- step(x[i])
 x
}</code>

We can then do 30 random walks:

<code>walks &lt;- replicate(30, random.walk(100)) matplot(walks, type="l", lty=1, col=rainbow(nrow(walks)))</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-58.png" alt="plot of chunk unnamed-chunk-58" />

Of course, in this case, if we think in terms of vectors we can actually implement random walk using implicit vectorisation:

<code>random.walk &lt;- function(nsteps, x0=0, p=0.5)
 cumsum(c(x0, ifelse(runif(nsteps) &lt; p, -1, 1)))
walks &lt;- replicate(30, random.walk(100)) matplot(walks, type="l", lty=1, col=rainbow(nrow(walks)))</code>


<img class="lazy" data-src="https://nicercode.github.io/guides/repeating-things/img/unnamed-chunk-59.png" alt="plot of chunk unnamed-chunk-59" />

Which reinforces one of the advantages of thinking in terms of functions: you can change the implementation detail without the rest of the program changing.

<h2>increase the max print rows limit</h2>
getOption("max.print")
options(max.print=999999)

<h2>parallel processing: foreach package</h2>
loops are incredibly inefficient at processing data in R.

iters&lt;-10  #number of iterations in the loop
ls&lt;-vector('list',length=iters)  #vector for appending output
strt&lt;-Sys.time()   #start time
for(i in 1:iters){   #loop
    cat(i,'\n')    #counter
    to.ls&lt;-rnorm(1e6)
    to.ls&lt;-summary(to.ls)
    ls[[i]]&lt;-to.ls    #export
}

print(Sys.time()-strt)   #end time
# Time difference of 2.944168 secs

repeated the above code with an increasing number of iterations, 10 to 100 at intervals of 10.

iters&lt;-seq(10,100,by=10)   #iterations to time
times&lt;-numeric(length(iters))  #output time vector for  iteration sets
for(val in 1:length(iters)){   #loop over iteration sets
    cat(val,' of ', length(iters),'\n')
    to.iter&lt;-iters[val]
    ls&lt;-vector('list',length=to.iter)    #vector for appending output
    strt&lt;-Sys.time()    #start time
    for(i in 1:to.iter){    #same for loop as before
        cat(i,'\n')
        to.ls&lt;-rnorm(1e6)
        to.ls&lt;-summary(to.ls)
        ls[[i]]&lt;-to.ls          #export
    }
    times[val]&lt;-Sys.time()-strt    #end time
}

library(ggplot2)   #plot the times
to.plo&lt;-data.frame(iters,times)
ggplot(to.plo,aes(x=iters,y=times)) + 
    geom_point() +
    geom_smooth() + 
    theme_bw() + 
    scale_x_continuous('No. of loop iterations') + 
    scale_y_continuous ('Time in seconds')


<img class="lazy" data-src="https://beckmw.files.wordpress.com/2014/01/seq_time1.jpg">
Fig: Processing time as a function of number of iterations for a simple loop.

The processing time increases linearly with the number of iterations.  
Again, processing time is not extensive for the above example.  
Suppose we wanted to run the example with ten thousand iterations.  
We can predict how long that would take based on the linear relationship between time and iterations.

mod&lt;-lm(times~iters)    #predict times
predict(mod,newdata=data.frame(iters=1e4))/60
# 45.75964


This is all well and good if we want to wait around for 45 minutes.  
Running the loop in parallel would greatly decrease this time.  
I want to first illustrate the problem of running loops in sequence before I show how this can done using the foreach package.  
If the above code is run with <code>1e4</code> iterations, a quick look at the performance metrics in the task manager (Windows 7 OS) gives you an idea of how hard your computer is working to process the code.  
My machine has eight processors and you can see that only a fraction of them are working while the script is running.


<img class="lazy" data-src="https://beckmw.files.wordpress.com/2014/01/proc1.jpg">
Fig: Resources used during sequential processing of a <code>for</code> loop.

Running the code using foreach will make full use of the computer's processors.
Individual chunks of the loop are sent to each processor so that the entire process can be run in parallel rather than in sequence.  
Here's how to run the code with <code>1e4</code> iterations in parallel.
That is, each processor gets a finite set of the total number of iterations, i.e., iterations 1&#8211;100 goes to processor one, iterations 101&#8211;200 go to processor two, etc. The output from each processor is then comiled after the iterations are completed.  

#import packages
library(foreach)
library(doParallel)
iters&lt;-1e4   #number of iterations

#setup parallel backend to use 8 processors
cl&lt;-makeCluster(8)
registerDoParallel(cl)

#start time
strt&lt;-Sys.time()

#loop
ls&lt;-foreach(icount(iters)) %dopar% {
    to.ls&lt;-rnorm(1e6)
    to.ls&lt;-summary(to.ls)
    to.ls
    }

print(Sys.time()-strt)
stopCluster(cl)

#Time difference of 10.00242 mins

Running the loop in parallel decreased the processing time about four-fold.  
Although the loop generally looks the same as the sequential version, several parts of the code have changed.  
First, we are using the <code>foreach</code> function rather than <code>for</code> to define our loop.  
The syntax for specifying the iterator is slightly different with <code>foreach</code> as well, i.e., <code>icount(iters)</code> tells the function to repeat the loop a given number of times based on the value assigned to <code>iters</code>.  
Additionally, the convention <code>%dopar%</code> specifies that the code is to be processed in parallel if a backend has been registered (using <code>%do%</code> will run the loop sequentially).  
The functions <code>makeCluster</code> and <code>registerDoParallel</code> from the <a href="http://cran.r-project.org/web/packages/doParallel/index.html" title="doParallel">doParallel</a> package are used to create the parallel backend.  
Another important issue is the method for recombining the data after the chunks are processed. By default, <code>foreach</code> will append the output to a list which we've saved to an object.  
The default method for recombining output can be changed using the <code>.combine</code> argument.  
Also be aware that packages used in the evaluated expression must be included with the <code>.packages</code> argument.
The processors should be working at full capacity if the the loop is executed properly.  
Note the difference here compared to the first loop that was run in sequence.


<img class="lazy" data-src="https://beckmw.files.wordpress.com/2014/01/proc2.jpg">
Fig: Resources used during parallel processing of a <code>for</code> loop.

A few other issues are worth noting when using the foreach package.  
These are mainly issues I've encountered and I'm sure others could contribute to this list.  
The foreach package does not work with all types of loops.  
For example, I chose the above example to use a large number (<code>1e6</code>) of observations with the <code>rnorm</code> function.  
I can't say for certain the exact type of data that works best, but I have found that functions     hat take a long time when run individually are generally handled very well.  
Interestingly, decreasing the number of observations and increasing the number of iterations may cause the processors to not run at maximum efficiency (try <code>rnorm(100)</code> with <code>1e5</code> iterations). I also haven't had much success running repeated models in parallel.  
The functions work but the processors never seem to reach max efficiency.  
The system statistics should cue you off as to whether or not the functions are working.
I also find it bothersome that monitoring progress seems is an issue with parallel loops.  
A simple call using <code>cat</code> to return the iteration in the console does not work with parallel loops.  
The most practical solution I've found is described <a href="http://vikparuchuri.com/blog/monitoring-progress-inside-foreach-loop/" title="here">here</a>, which involves exporting information to a separate file that tells you how far the loop has progressed.  
Also, be very aware of your RAM when running processes in parallel.  
I've found that it's incredibly easy to max out the memory, which not only causes the function to stop working correctly, but also makes your computer run like garbage.  
Finally, I'm a little concerned that I might be destroying my processors by running them at maximum capacity.  
The fan always runs at full blast leading me to believe that critical meltdown is imminent.  
I'd be pleased to know if this is an issue or not.
That's it for now.  
I have to give credit to <a href="http://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf" title="this tutorial">this tutorial</a> for a lot of the information in this post.  
<h3>Vectorised</h3>
E = sapply(1:10000, function(n) {max.eig(5, 1)})
summary(E)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
 0.7615  1.9150  2.2610  2.3160  2.6470  5.2800

Here eigenvalues are calculated from 10000 function calls, all of which use the same parameters. 
The distribution of the resulting eigenvalues is plotted in the histogram below. 
Generating these data took a couple of seconds on my middle-of-the-range laptop. 
Not a big wait. 
But it was only using one of the four cores on the machine, so in principle it could have gone faster.

We can make things more interesting by varying the dimensions of the matrix.
sapply(1:5, function(n) {max.eig(n, 1)})

Or changing both the dimensions (taking on integral values between 1 and 5) and the standard deviation (running through 1, 2 and 3).
sapply(1:5, function(n) {sapply(1:3, function(m) {max.eig(n, m)})})

The results are presented in an intuitive matrix. Everything up to this point is being done serially.
<h3>Enter foreach</h3>
library(foreach)

At first sight, the foreach library provides a slightly different interface for vectorisation. We’ll start off with simple repetition.
times(10) %do% max.eig(5, 1)

That just executes the function with the same arguments 10 times over. If we want to systematically vary the parameters, then instead of times() we use foreach().
foreach(n = 1:5) %do% max.eig(n, 1)

The results are returned as a list, which is actually more reminiscent of the behaviour of lapply() than sapply(). But we can get something more compact by using the .combine option.
foreach(n = 1:5, .combine = c) %do% max.eig(n, 1)


That’s better. Now, what about varying both the dimensions and standard deviation? We can string together multiple calls to foreach() using the %:% nesting operator.
foreach(n = 1:5) %:% foreach(m = 1:3) %do% max.eig(n, m)

I have omitted the output because it consists of nested lists: it’s long and somewhat ugly. But again we can use the .combine option to make it more compact.
foreach(n = 1:5, .combine = rbind) %:% foreach(m = 1:3) %do% max.eig(n, m)

foreach(n = 1:5, .combine = cbind) %:% foreach(m = 1:3) %do% max.eig(n, m)

You can choose between combining using cbind() or rbind() depending on whether you want the output from the inner loop to form the columns or rows of the output. 
There’s lots more magic to be done with .combine. 
You can find the details in the informative article <a href="http://r.adu.org.za/web/packages/foreach/vignettes/foreach.pdf" target="_blank">Using The foreach Package</a> by Steve Weston.

You can also use foreach() to loop over multiple variables simultaneously.
foreach(n = 1:5, m = 1:5) %do% max.eig(n, m)

But this is still all serial…

<h3>Filtering</h3>
One final capability before we move on to parallel execution, is the ability to add in a filter within the foreach() statement.

library(numbers)
foreach(n = 1:100, .combine = c) %:% when (isPrime(n)) %do% n

Here we identify the prime numbers between 1 and 100 by simply looping through the entire sequence of values and selecting only those that satisfy the condition in the when() clause. Of course, there are more efficient ways to do this, but this notation is rather neat.
<h3>Going Parallel</h3>
Making the transition from serial to parallel is as simple as changing %do% to %dopar%.
foreach(n = 1:5) %dopar% max.eig(n, 1)

Warning message:
executing %dopar% sequentially: no parallel backend registered

The warning gives us pause for thought: maybe it was not quite that simple? Yes, indeed, there are additional requirements. You need first to choose a parallel backend. And here, again, there are a few options. We will start with the most accessible, which is the multicore backend.
<h3>Multicore</h3>
Multicore processing is provided by the doMC library. You need to load the library and tell it how many cores you want to use.
library(doMC)
registerDoMC(cores=4)

Let’s make a comparison between serial and parallel execution times.

library(rbenchmark)

benchmark(
+     foreach(n = 1:50) %do% max.eig(n, 1),
+     foreach(n = 1:50) %dopar% max.eig(n, 1)
+ )

The overall execution time is reduced, but not by the factor of 4 that one might expect. 
This is due to the additional burden of having to distribute the job over the multiple cores. 
The tradeoff between communication and computation is one of the major limitations of parallel computing, but if computations are lengthy and there is not too much data to move around then the gains can be excellent.

On a single machine you are limited by the number of cores. But if you have access to a cluster then you can truly take things to another level.
<h3>Cluster</h3>
The foreach() functionality can be applied to a cluster using the doSNOW library. We will start by using doSNOW to create a collection of R instances on a single machine using a SOCK cluster.

library(doSNOW)
cluster = makeCluster(4, type = "SOCK")
registerDoSNOW(cluster)

benchmark(
+     foreach(n = 1:50) %do% max.eig(n, 1),
+     foreach(n = 1:50) %dopar% max.eig(n, 1)
+ )

stopCluster(cluster)

There is an improvement in execution time which is roughly comparable to what we got with the multicore implementation. Note that when you are done, you need to shut down the cluster.

Next we will create an <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank">MPI</a> cluster consisting of 20 threads.
cluster = makeCluster(20, type = "MPI")
#
registerDoSNOW(cluster)
#
benchmark(
+     foreach(n = 1:100) %do% max.eig(n, 1),
+     foreach(n = 1:100) %dopar% max.eig(n, 1)
+ )


There is an improvement in performance, with the parallel job running roughly 3 times as quickly.

How about a slightly more complicated example? We will try running some bootstrap calculations. We start out with the serial implementation.
random.data = matrix(rnorm(1000000), ncol = 1000)

bmed = function(d, n) median(d[n])

library(boot)
#
sapply(1:100, function(n) {sd(boot(random.data[, n], bmed, R = 10000)$t)})

First we generated a big array of normally distributed random numbers. Then we used sapply to calculate bootstrap estimates for the standard deviation of the median for each columns of the matrix.

The parallel implementation requires a little more work: first we need to make the global data (the random matrix and the bootstrap function) available across the cluster.
clusterExport(cluster, c("random.data", "bmed"))

Then we spread the jobs out over the cluster nodes. We will do this first using clusterApply(), which is part of the snow library and is the cluster analogue of sapply(). It returns a list, so to get a nice compact representation we use unlist().
results = clusterApply(cluster, 1:100, function(n) {
+     library(boot)
+     sd(boot(random.data[, n], bmed, R = 10000)$t)
+ })
head(unlist(results))


The foreach implementation is a little neater.
results = foreach(n = 1:100, .combine = c) %dopar% {
    library(boot); sd(boot(random.data[, n], bmed, R = 10000)$t)
}
head(results)

stopCluster(cluster)

The key in both cases is that the boot library must be loaded on each of the cluster nodes as well so that its functionality is available. Simply loading the library on the root node is not enough!

<h2>repeating timer by r asynchronously</h2>
The future package:

library("future")
plan(multiprocess)

myfun = function() {
  future(fun2())

  return(1+1)
}
Unless fun2() is function used purely for its side effects, you typically want to retrieve the value of that future expression, which you do as:

f = future(fun2())
y = fun3()
v = value(f)
z = v + y
An alternative is to use the %=% operator as in:

v %=% fun2()
y = fun3()
z = v + y
FYI, if you use

plan(cluster, workers = c("n1", "n3", "remote.server.org"))
then the future expression is resolved on one of those machines. Using

plan(future.BatchJobs::batchjobs_slurm)
will cause it to be resolved via a Slurm job scheduler queue.

<a href="https://rstudio.github.io/promises/articles/futures.html" class="whitebut ">Launching tasks with future</a>
<a href="https://cran.r-project.org/web/packages/future/vignettes/future-1-overview.html" class="whitebut ">A Future for R</a>
<a href="https://appsilon.com/an-example-of-how-to-use-the-new-r-promises-package/" class="whitebut ">example of new R promises package</a>

<h2>Set a timer in R to execute a program</h2>
executing same code block every 15 seconds:

interval = 15
x = data.frame()

repeat {
  startTime = Sys.time()
  x = rbind.data.frame(x, sum(data)) #replace this line with your code/functions
  sleepTime = startTime + interval - Sys.time()
  if (sleepTime > 0)
    Sys.sleep(sleepTime)
}

Or:
print_test=function(x){
    if(condition)
    {
        Sys.sleep(x);
        cat("hello world");
        print_test(x);
    }
}
print_test(15)

<h2>What Is a Formula in R?</h2>
Formula allow you to capture two things:

An unevaluated expression
The context or environment in which the expression was created

In R the tilde operator ~ characterizes formulas With this operator, you say: "capture the meaning of this code, without evaluating it" You can think of a formula in R as a "quoting" operator

<code># A formula
d &lt;- y ~ x + b</code>

The variable on the left-hand side of a tilde (~) is called the "dependent variable", while the variables on the right-hand side are called the "independent variables" and are joined by plus signs +.

You can access the elements of a formula with the help of the square brackets: [[and ]].

<code>f &lt;- y ~ x + b 
# Retrieve the elements at index 1 and 2
f[[1]] ## "~"
f[[2]] ## y
f[[3]] ## x + b</code>

<h3>Why Use Formulae in R?</h3>
Formulas are powerful, general-purpose tools that allow you to capture the values of variables without evaluating them so that they can be interpreted by the function

Also, you use these R objects to express a relationship between variables.

For example, in the first line of code in the code chunk below, you say "y is a function of x, a, and b"

<code>y ~ x + a + b
## y ~ x + a + b</code>

More complex formulas like the code chunk below:

<code>Sepal.Width ~ Petal.Width | Species
## Sepal.Width ~ Petal.Width | Species</code>

Where you mean to say "the sepal width is a function of petal width, conditioned on species"

<h3>Using Formulas in R</h3>
<h2>How To Create a Formula in R</h2>
1.With the help of ~ operator 2.Some times you need or want to create a formula from an R object, such as a string. In such cases, you can use the formula or as.formula() function

<code>"y ~ x1 + x2"
## [1] "y ~ x1 + x2"
h &lt;- as.formula("y ~ x1 + x2")
h &lt;- formula("y ~ x1 + x2")</code>

<h2>How To Concatenate Formulae</h2>
To glue or bring multiple formulas together, you have two option:

Create separate variables for each formula and then use list()

<code># Create variables
i &lt;- y ~ x
j &lt;- y ~ x + x1
k &lt;- y ~ x + x1 + x2

# Concatentate
formulae &lt;- list(as.formula(i),as.formula(j),as.formula(k))</code>

Use the lapply() function, where you pass in a vector with all of your formulas as a first argument and as.formula as the function that you want to apply to each element of that vector

<code># Join all with "c()"
l &lt;- c(i, j, k)

# Apply "as.formula" to all elements of "f"
lapply(l, as.formula)
[[1]] ## y ~ x
[[2]] ## y ~ x + x1
[[3]] ## y ~ x + x1 + x2</code>

<h3>Formula Operators</h3>
"+" for joining
"-" for removing terms
":" for interaction
"*" for crossing
"%in%" for nesting
"^" for limit crossing to the specified degree

<code># Use multiple independent variables
y ~ x1 + x2 ## y ~ x1 + x2
# Ignore objects in an analysis
y ~ x1 - x2 ## y ~ x1 - x2</code>

What if you want to actually perform an arithmetic operation? you have a couple of solutions:

1.You can calculate and store all of the variables in advance 2.You use the I() or "as-is" operator: y ~ x + I(x^2)

<h3>How To Inspect Formulas in R</h3>
You saw functions such as attributes(), typeof(), class(), etc

To examine and compare different formulae, you can use the terms() function:

<code>m &lt;- formula("y ~ x1 + x2")
terms(m)
## y ~ x1 + x2
## attr(,"variables")
## list(y, x1, x2)
## attr(,"factors")
##    x1 x2
## y   0  0
## x1  1  0
## x2  0  1
## attr(,"term.labels")
## [1] "x1" "x2"
## attr(,"order")
## [1] 1 1
## attr(,"intercept")
## [1] 1
## attr(,"response")
## [1] 1
## attr(,".Environment")
## &lt;environment: R_GlobalEnv>
class(m)
## [1] "formula"
typeof(m)
## [1] "language"
attributes(m)
## $class
## [1] "formula"
## 
## $.Environment
## &lt;environment: R_GlobalEnv></code>

If you want to know the names of the variables in the model, you can use all.vars.

<code>print(all.vars(m))
## [1] "y"  "x1" "x2"</code>

To modify formulae without converting them to character you can use the update() function:

<code>update(y ~ x1 + x2, ~. + x3)
## y ~ x1 + x2 + x3
y ~ x1 + x2 + x3
## y ~ x1 + x2 + x3</code>

Double check whether you variable is a formula by passing it to the is.formula() function.

<code># Load "plyr"
library(plyr)

# Check "m"
is.formula(m)
## [1] TRUE</code>

<h3>When To Use Formulas</h3>
1.Modeling Functions
2.Graphical Functions in R

<h3>R Formula Packages</h3>
1.Formula Package
2.formula.tools

<h2>dplyr samples</h2>
<a href="https://github.com/Apress/r-data-science-quick-reference" class="whitebut ">R data science quick reference</a>

library(tidyverse)
iris_df = as_tibble(iris)
print(iris_df, n = 3)
head(iris_df$Species)

## ============
iris_df %>% select(Sepal.Length, Species) %>% print(n = 3)
iris_df %>% select(-Species) %>% print(n = 3)
iris_df %>% select(-Species, -Sepal.Length) %>% print(n = 3)

<h2>get rid of all non-ASCII characters.</h2>

Texts = c("Let the stormy clouds chase, everyone from the place ☁  ♪ ♬",
    "See you soon brother ☮ ",
    "A boring old-fashioned message" ) 

gsub("[^\x01-\x7F]", "", Texts)
[1] "Let the stormy clouds chase, everyone from the place    "
[2] "See you soon brother  "                                  
[3] "A boring old-fashioned message"

Details: You can specify character classes in regex's with [ ]. 
When the class description starts with ^ it means everything except these characters. 
Here, I have specified everything except characters 1-127, i.e. everything except standard ASCII and I have specified that they should be replaced with the empty string.

<h2>Display a popup from a batch file</h2>
The goal is to display a popup, the calling batch file must stop and wait the popup closing.

<h3>Using powershell</h3>
echo calling popup
powershell [Reflection.Assembly]::LoadWithPartialName("""System.Windows.Forms""");[Windows.Forms.MessageBox]::show("""rgagnon.com""", """HowTo""",0)>nul
echo we are back!

<h3>Using MHTA</h3>
echo calling popup
mshta javascript:alert("rgagnon.com\n\nHowTo!");close();
echo we are back!
Regular CMD
echo calling popup
START /WAIT CMD /C "ECHO rgagnon.com && ECHO HowTo && ECHO. && PAUSE"
echo we are back!

<h3>Using JScript</h3>
 @if (@x)==(@y) @end /***** jscript comment ******
     @echo off
     echo calling popup
     cscript //E:JScript //nologo "%~f0" "%~nx0" %*
     echo we are back!
     exit /b 0
 @if (@x)==(@y) @end ******  end comment *********/

var wshShell = WScript.CreateObject("WScript.Shell");
wshShell.Popup("HowTo", -1, "rgagnon.com", 16);

<h2>select after the nth word form a string</h2>
library(stringr)
a="starting anything goes from here now"
res = gsub("^(\\w+\\s){1}","",a)
res
res = gsub("^(\\w+\\s){3}","",a)
res
res = gsub("^(\\w+\\s){4}","",a)
res

<h2>Significant network analysis packages</h2>
<a href="https://www.jessesadler.com/post/network-analysis-with-r/" class="redbut goldbs orangets">Introduction to Network Analysis with R</a>

<a href="http://statnet.org/" class="whitebut ">statnet</a>
<a href="https://igraph.org/" class="whitebut ">igraph</a>
<a href="https://www.data-imaginist.com/2017/introducing-tidygraph/" class="whitebut ">tidygraph</a>
<a href="https://www.data-imaginist.com/2017/ggraph-introduction-layouts/" class="whitebut ">ggraph</a>
<a href="http://www.viznetwork.com/" class="whitebut ">vizNetwork</a>
<a href="https://christophergandrud.github.io/networkD3/" class="whitebut ">networkD3</a>

<h3>Basic Managerial Applications of Network Analysis</h3>
Plans the projects by analyzing the project activities.

Projects are broken down to individual tasks or activities, which are arranged in logical sequence. 

It is also decided that which tasks will be performed simultaneously and which other sequentially.

A network diagram is prepared, which presents visually the relationship between all the activities involved and the cost for different activities. 

Network analysis helps designing, planning, coordi­nating, controlling and in decision-making in order to accom­plish the project economically in the minimum available time with the limited available resources. 

The network analysis fulfills the objectives of reducing total time, cost, idle resources, interruptions and conflicts. 

Managerial applications of network analysis are as follows:
Assembly line scheduling,
Research and development,
Inventory planning and control,
Shifting of manufacturing plant from one site to another,
Launching of new products and advertising campaigns,
Control of traffic flow in cities,
Budget and audit procedures,
Launching space programmes,
Installation of new equipments,
Long-range planning and developing staffing plans, etc.

Network techniques:
A number of network techniques:
PERT- Programme Evaluation and Review Technique
CPM- Critical Path Method
RAMS- Resource Allocation and Multi-project Scheduling
PEP- Programme Evolution Procedure
COPAC- Critical Operating Production Allocation Control
MAP- Manpower Allocation Procedure
RPSM- Resource Planning and Scheduling Method
LCS- Least Cost Scheduling
MOSS- Multi-Operation Scheduling System
PCS- Project Control System
GERT- Graphical Evaluation Review Technique.

<h2>shows exactly two decimal places for the number</h2>
format(round(x, 2), nsmall = 2)

<h2>R Customizing Startup</h2>
<a href="https://github.com/rstudio/rstudio/issues/5454" class="whitebut ">Tab for spaces setting</a>
<a href="https://github.com/rstudio/rstudio/issues/4448" class="whitebut ">Spaces per tab option</a>
<a href="https://www.statmethods.net/interface/customizing.html" class="whitebut ">R Customizing Startup</a>

<h2>R courses</h2>
<a href="https://www.datacamp.com/courses/free-introduction-to-r">free-introduction-to-r</a>
<a href="https://www.datacamp.com/courses/intermediate-r">intermediate-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-the-tidyverse">introduction-to-the-tidyverse</a>
<a href="https://www.datacamp.com/courses/data-manipulation-with-dplyr">data-manipulation-with-dplyr</a>
<a href="https://www.datacamp.com/courses/introduction-to-data-visualization-with-ggplot2">introduction-to-data-visualization-with-ggplot2</a>
<a href="https://www.datacamp.com/courses/introduction-to-importing-data-in-r">introduction-to-importing-data-in-r</a>
<a href="https://www.datacamp.com/courses/cleaning-data-in-r">cleaning-data-in-r</a>
<a href="https://www.datacamp.com/courses/joining-data-with-dplyr">joining-data-with-dplyr</a>
<a href="https://www.datacamp.com/courses/intermediate-data-visualization-with-ggplot2">intermediate-data-visualization-with-ggplot2</a>
<a href="https://www.datacamp.com/courses/exploratory-data-analysis-in-r">exploratory-data-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/correlation-and-regression-in-r">correlation-and-regression-in-r</a>
<a href="https://www.datacamp.com/courses/supervised-learning-in-r-classification">supervised-learning-in-r-classification</a>
<a href="https://www.datacamp.com/courses/introduction-to-data-in-r">introduction-to-data-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-regression-in-r">introduction-to-regression-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-statistics-in-r">introduction-to-statistics-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-writing-functions-in-r">introduction-to-writing-functions-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-r-for-finance">introduction-to-r-for-finance</a>
<a href="https://www.datacamp.com/courses/case-study-exploratory-data-analysis-in-r">case-study-exploratory-data-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/intermediate-importing-data-in-r">intermediate-importing-data-in-r</a>
<a href="https://www.datacamp.com/courses/multiple-and-logistic-regression-in-r">multiple-and-logistic-regression-in-r</a>
<a href="https://www.datacamp.com/courses/building-web-applications-with-shiny-in-r">building-web-applications-with-shiny-in-r</a>
<a href="https://www.datacamp.com/courses/data-visualization-in-r">data-visualization-in-r</a>
<a href="https://www.datacamp.com/courses/supervised-learning-in-r-regression">supervised-learning-in-r-regression</a>
<a href="https://www.datacamp.com/courses/writing-efficient-r-code">writing-efficient-r-code</a>
<a href="https://www.datacamp.com/courses/working-with-dates-and-times-in-r">working-with-dates-and-times-in-r</a>
<a href="https://www.datacamp.com/courses/unsupervised-learning-in-r">unsupervised-learning-in-r</a>
<a href="https://www.datacamp.com/courses/machine-learning-with-caret-in-r">machine-learning-with-caret-in-r</a>
<a href="https://www.datacamp.com/courses/time-series-analysis-in-r">time-series-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/manipulating-time-series-data-with-xts-and-zoo-in-r">manipulating-time-series-data-with-xts-and-zoo-in-r</a>
<a href="https://www.datacamp.com/courses/cluster-analysis-in-r">cluster-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/data-manipulation-with-datatable-in-r">data-manipulation-with-datatable-in-r</a>
<a href="https://www.datacamp.com/courses/reporting-with-rmarkdown">reporting-with-rmarkdown</a>
<a href="https://www.datacamp.com/courses/working-with-data-in-the-tidyverse">working-with-data-in-the-tidyverse</a>
<a href="https://www.datacamp.com/courses/forecasting-in-r">forecasting-in-r</a>
<a href="https://www.datacamp.com/courses/string-manipulation-with-stringr-in-r">string-manipulation-with-stringr-in-r</a>
<a href="https://www.datacamp.com/courses/fundamentals-of-bayesian-data-analysis-in-r">fundamentals-of-bayesian-data-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/intermediate-r-for-finance">intermediate-r-for-finance</a>
<a href="https://www.datacamp.com/courses/introduction-to-portfolio-analysis-in-r">introduction-to-portfolio-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/foundations-of-probability-in-r">foundations-of-probability-in-r</a>
<a href="https://www.datacamp.com/courses/foundations-of-inference-in-r">foundations-of-inference-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-text-analysis-in-r">introduction-to-text-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/joining-data-with-datatable-in-r">joining-data-with-datatable-in-r</a>
<a href="https://www.datacamp.com/courses/credit-risk-modeling-in-r">credit-risk-modeling-in-r</a>
<a href="https://www.datacamp.com/courses/modeling-with-data-in-the-tidyverse">modeling-with-data-in-the-tidyverse</a>
<a href="https://www.datacamp.com/courses/working-with-web-data-in-r">working-with-web-data-in-r</a>
<a href="https://www.datacamp.com/courses/parallel-programming-in-r">parallel-programming-in-r</a>
<a href="https://www.datacamp.com/courses/visualizing-geospatial-data-in-r">visualizing-geospatial-data-in-r</a>
<a href="https://www.datacamp.com/courses/importing-and-managing-financial-data-in-r">importing-and-managing-financial-data-in-r</a>
<a href="https://www.datacamp.com/courses/linear-algebra-for-data-science-in-r">linear-algebra-for-data-science-in-r</a>
<a href="https://www.datacamp.com/courses/hierarchical-and-mixed-effects-models-in-r">hierarchical-and-mixed-effects-models-in-r</a>
<a href="https://www.datacamp.com/courses/case-study-exploring-baseball-pitching-data-in-r">case-study-exploring-baseball-pitching-data-in-r</a>
<a href="https://www.datacamp.com/courses/case-studies-manipulating-time-series-data-in-r">case-studies-manipulating-time-series-data-in-r</a>
<a href="https://www.datacamp.com/courses/differential-expression-analysis-with-limma-in-r">differential-expression-analysis-with-limma-in-r</a>
<a href="https://www.datacamp.com/courses/analyzing-election-and-polling-data-in-r">analyzing-election-and-polling-data-in-r</a>
<a href="https://www.datacamp.com/courses/introduction-to-tensorflow-in-r">introduction-to-tensorflow-in-r</a>
<a href="https://www.datacamp.com/courses/intermediate-statistical-modeling-in-r">intermediate-statistical-modeling-in-r</a>
<a href="https://www.datacamp.com/courses/structural-equation-modeling-with-lavaan-in-r">structural-equation-modeling-with-lavaan-in-r</a>
<a href="https://www.datacamp.com/courses/bond-valuation-and-analysis-in-r">bond-valuation-and-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/garch-models-in-r">garch-models-in-r</a>
<a href="https://www.datacamp.com/courses/foundations-of-functional-programming-with-purrr">foundations-of-functional-programming-with-purrr</a>
<a href="https://www.datacamp.com/courses/anomaly-detection-in-r">anomaly-detection-in-r</a>
<a href="https://www.datacamp.com/courses/intermediate-interactive-data-visualization-with-plotly-in-r">intermediate-interactive-data-visualization-with-plotly-in-r</a>
<a href="https://www.datacamp.com/courses/network-analysis-in-the-tidyverse">network-analysis-in-the-tidyverse</a>
<a href="https://www.datacamp.com/courses/market-basket-analysis-in-r">market-basket-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/financial-analytics-in-r">financial-analytics-in-r</a>
<a href="https://www.datacamp.com/courses/visualizing-big-data-with-trelliscope-in-r">visualizing-big-data-with-trelliscope-in-r</a>
<a href="https://www.datacamp.com/courses/choice-modeling-for-marketing-in-r">choice-modeling-for-marketing-in-r</a>
<a href="https://www.datacamp.com/courses/handling-missing-data-with-imputations-in-r">handling-missing-data-with-imputations-in-r</a>
<a href="https://www.datacamp.com/courses/forecasting-product-demand-in-r">forecasting-product-demand-in-r</a>
<a href="https://www.datacamp.com/courses/defensive-r-programming">defensive-r-programming</a>
<a href="https://www.datacamp.com/courses/intermediate-functional-programming-with-purrr">intermediate-functional-programming-with-purrr</a>
<a href="https://www.datacamp.com/courses/analyzing-us-census-data-in-r">analyzing-us-census-data-in-r</a>
<a href="https://www.datacamp.com/courses/life-insurance-products-valuation-in-r">life-insurance-products-valuation-in-r</a>
<a href="https://www.datacamp.com/courses/mixture-models-in-r">mixture-models-in-r</a>
<a href="https://www.datacamp.com/courses/data-visualization-with-lattice-in-r">data-visualization-with-lattice-in-r</a>
<a href="https://www.datacamp.com/courses/fraud-detection-in-r">fraud-detection-in-r</a>
<a href="https://www.datacamp.com/courses/designing-and-analyzing-clinical-trials-in-r">designing-and-analyzing-clinical-trials-in-r</a>
<a href="https://www.datacamp.com/courses/chip-seq-with-bioconductor-in-r">chip-seq-with-bioconductor-in-r</a>
<a href="https://www.datacamp.com/courses/intermediate-regular-expressions-in-r">intermediate-regular-expressions-in-r</a>
<a href="https://www.datacamp.com/courses/survey-and-measurement-development-in-r">survey-and-measurement-development-in-r</a>
<a href="https://www.datacamp.com/courses/feature-engineering-in-r">feature-engineering-in-r</a>
<a href="https://www.datacamp.com/courses/human-resources-analytics-exploring-employee-data-in-r">human-resources-analytics-exploring-employee-data-in-r</a>
<a href="https://www.datacamp.com/courses/scalable-data-processing-in-r">scalable-data-processing-in-r</a>
<a href="https://www.datacamp.com/courses/practicing-statistics-interview-questions-in-r">practicing-statistics-interview-questions-in-r</a>
<a href="https://www.datacamp.com/courses/practicing-machine-learning-interview-questions-in-r">practicing-machine-learning-interview-questions-in-r</a>
<a href="https://www.datacamp.com/courses/human-resources-analytics-predicting-employee-churn-in-r">human-resources-analytics-predicting-employee-churn-in-r</a>
<a href="https://www.datacamp.com/courses/optimizing-r-code-with-rcpp">optimizing-r-code-with-rcpp</a>
<a href="https://www.datacamp.com/courses/predictive-analytics-using-networked-data-in-r">predictive-analytics-using-networked-data-in-r</a>
<a href="https://www.datacamp.com/courses/case-studies-network-analysis-in-r">case-studies-network-analysis-in-r</a>
<a href="https://www.datacamp.com/courses/building-response-models-in-r">building-response-models-in-r</a>
<a href="https://www.datacamp.com/courses/business-process-analytics-in-r">business-process-analytics-in-r</a>
<a href="https://www.datacamp.com/courses/interactive-data-visualization-with-rbokeh">interactive-data-visualization-with-rbokeh</a>
<a href="https://www.datacamp.com/courses/r-for-sas-users">r-for-sas-users</a>
<a href="https://www.datacamp.com/courses/probability-puzzles-in-r">probability-puzzles-in-r</a>
<a href="https://www.datacamp.com/courses/time-series-with-datatable-in-r">time-series-with-datatable-in-r</a>
<a href="https://www.datacamp.com/courses/data-privacy-and-anonymization-in-r">data-privacy-and-anonymization-in-r</a>
<a href="https://www.datacamp.com/courses/course-creation-at-datacamp">course-creation-at-datacamp</a>
<a href="https://www.datacamp.com/projects/796">projects/796</a>
<a href="https://www.datacamp.com/projects/78">projects/78</a>
<a href="https://www.datacamp.com/projects/758">projects/758</a>
<a href="https://www.datacamp.com/projects/74">projects/74</a>
<a href="https://www.datacamp.com/projects/738">projects/738</a>
<a href="https://www.datacamp.com/projects/712">projects/712</a>
<a href="https://www.datacamp.com/projects/697">projects/697</a>
<a href="https://www.datacamp.com/projects/691">projects/691</a>
<a href="https://www.datacamp.com/projects/68">projects/68</a>
<a href="https://www.datacamp.com/projects/677">projects/677</a>
<a href="https://www.datacamp.com/projects/673">projects/673</a>
<a href="https://www.datacamp.com/projects/668">projects/668</a>
<a href="https://www.datacamp.com/projects/664">projects/664</a>
<a href="https://www.datacamp.com/projects/643">projects/643</a>
<a href="https://www.datacamp.com/projects/638">projects/638</a>
<a href="https://www.datacamp.com/projects/62">projects/62</a>
<a href="https://www.datacamp.com/projects/614">projects/614</a>
<a href="https://www.datacamp.com/projects/584">projects/584</a>
<a href="https://www.datacamp.com/projects/567">projects/567</a>
<a href="https://www.datacamp.com/projects/561">projects/561</a>
<a href="https://www.datacamp.com/projects/552">projects/552</a>
<a href="https://www.datacamp.com/projects/547">projects/547</a>
<a href="https://www.datacamp.com/projects/515">projects/515</a>
<a href="https://www.datacamp.com/projects/511">projects/511</a>
<a href="https://www.datacamp.com/projects/496">projects/496</a>
<a href="https://www.datacamp.com/projects/49">projects/49</a>
<a href="https://www.datacamp.com/projects/489">projects/489</a>
<a href="https://www.datacamp.com/projects/478">projects/478</a>
<a href="https://www.datacamp.com/projects/464">projects/464</a>
<a href="https://www.datacamp.com/projects/458">projects/458</a>
<a href="https://www.datacamp.com/projects/445">projects/445</a>
<a href="https://www.datacamp.com/projects/438">projects/438</a>
<a href="https://www.datacamp.com/projects/435">projects/435</a>
<a href="https://www.datacamp.com/projects/41">projects/41</a>
<a href="https://www.datacamp.com/projects/309">projects/309</a>
<a href="https://www.datacamp.com/projects/208">projects/208</a>
<a href="https://www.datacamp.com/projects/182">projects/182</a>
<a href="https://www.datacamp.com/projects/177">projects/177</a>
<a href="https://www.datacamp.com/projects/166">projects/166</a>
<a href="https://www.datacamp.com/projects/139">projects/139</a>

<h2>Customizing Startup the R environment</h2>
R will always source the Rprofile.site file first. 
On Windows, the file is in the C:\Program Files\R\R-n.n.n\etc directory. 

You can also place a .Rprofile file in any directory that you are going to run R from or in the user home directory.

At startup, R will source the Rprofile.site file. 
It will then look for a .Rprofile file to source in the current working directory. 
If it doesn't find it, it will look for one in the user's home directory. 

There are two special functions you can place in these files. 
.First( ) will be run at the start of the R session and .Last( ) will be run at the end of the session.

# Sample Rprofile.site file

# Things you might want to change
# options(papersize="a4")
# options(editor="notepad")
# options(pager="internal")

# R interactive prompt
# options(prompt="> ")
# options(continue="+ ")

# to prefer Compiled HTML
help options(chmhelp=TRUE)
# to prefer HTML help
# options(htmlhelp=TRUE)

# General options
options(tab.width = 2)
options(width = 130)
options(graphics.record=TRUE)

.First = function(){
 library(Hmisc)
 library(R2HTML)
 cat("\nWelcome at", date(), "\n")
}

.Last = function(){
 cat("\nGoodbye at ", date(), "\n")
}

<h2>Managing R</h2>
with .Rprofile, .Renviron, Rprofile.site, Renviron.site, rsession.conf, and repos.conf
Upon startup, R and RStudio look for a few different files you can use to control the behavior of your R session, for example by setting options or environment variables. 
In the context of RStudio Team, these settings are often used to set RStudio Server Pro to search for packages in an RStudio Package Manager repository.

This article is a practical guide to how to set particular options on R startup. 
General information on how to manage R package environments is available at <a href="https://environments.rstudio.com" target="_blank">environments.rstudio.com</a> , and a deeper treatment of R process startup is available in <a href="https://rviews.rstudio.com/2017/04/19/r-for-enterprise-understanding-r-s-startup/" target="_blank">this article</a>.&nbsp;

Here is a summary table of how to control R options and environment variables on startup. 
More details are below.

<table border="black">
<tbody>
<tr><td>File</td><td>Who Controls</td><td>Level</td><td>Limitations</td></tr>
<tr><td><code>.Rprofile</code></td><td>User or Admin</td><td>User or Project</td><td>None, sourced as R code.</td></tr>
<tr><td><code>.Renviron</code></td><td>User or Admin</td><td>User or Project</td><td>Set environment variables only.</td></tr>
<tr><td><code>Rprofile.site</code></td><td>Admin</td><td>Version of R</td><td>None, sourced as R code.</td></tr>
<tr><td><code>Renviron.site</code></td><td>Admin</td><td>Version of R</td><td>Set environment variables only.</td></tr>
<tr><td><code>rsession.conf</code></td><td>Admin</td><td>Server</td><td>Only RStudio settings, only single repository.</td></tr>
<tr><td><code>repos.conf</code></td><td>Admin</td><td>Server</td><td>Only for setting repositories.</td></tr>
</tbody>
</table>
<h3><code>.Rprofile</code></h3>
<code>.Rprofile</code> files are user-controllable files to set options and environment variables. 
<code>.Rprofile</code> files can be either at the user or project level. 
User-level <code>.Rprofile</code> files live in the base of the user's home directory, and project-level <code>.Rprofile</code> files live in the base of the project directory.&nbsp;

R will source only one <code>.Rprofile</code> file. 
So if you have both a project-specific <code>.Rprofile</code> file and a user <code>.Rprofile</code> file that you want to use, you explicitly source the user-level <code>.Rprofile</code> at the top of your project-level <code>.Rprofile</code> with <code>source("~/.Rprofile")</code>.

<code>.Rprofile</code> files are sourced as regular R code, so setting environment variables must be done inside a <code>Sys.setenv(key = "value")</code> call.&nbsp;

One easy way to edit your <code>.RProfile</code> file is to use the <code>usethis::edit_r_profile()</code> function from within an R session. 
You can specify whether you want to edit the user or project level <code>.Rprofile.</code>

<h3><code>.Renviron</code></h3>
<code>.Renviron</code> is a user-controllable file that can be used to create environment variables. 
This is especially useful to avoid including credentials like API keys inside R scripts. 
This file is written in a key-value format, so environment variables are created in the format:

Key1=value1
Key2=value2
...

And then <code>Sys.getenv("Key1")</code> will return <code>"value1"</code> in an R session.

Like with the <code>.Rprofile</code> file, <code>.Renviron</code> files can be at either the user or project level. 
If there is a project-level <code>.Renviron</code>, the user-level file will not be sourced. 
The <code>usethis</code> package includes a helper function for editing <code>.Renviron</code> files from an R session with <code>usethis::edit_r_environ()</code>.

<h3><code>Rprofile.site</code> and <code>Renviron.site</code></h3>
Both <code>.Rprofile</code> and <code>.Renviron</code> files have equivalents that apply server wide. 
<code>Rprofile.site</code>&nbsp;and<code>Renviron.site</code> (no leading dot) files are managed by admins on RStudio Server and are specific to a particular version of R.&nbsp;The most common settings for these&nbsp;files involve access to package repositories. 
For example, using the <a href="https://environments.rstudio.com/shared.html" target="_blank">shared-baseline</a> package management strategy is generally done from an <code>Rprofile.site</code>.

Users can override settings in these files&nbsp;with their individual <code>.Rprofile</code>&nbsp;files.

These files are set for each version of R and should be located in <code>R_HOME/etc/</code>. 
You can find<code>R_HOME</code> by running the command&nbsp;<code>R.home(component
  = "home")</code> in a session of that version of R. 
So, for example, if you find that <code>R_HOME</code> is <code>/opt/R/3.6.2/lib/R</code>, the<code>Rprofile.site</code> for R 3.6.2 would go in <code>/opt/R/3.6.2/lib/R/etc/Rprofile.site</code>.

<h3><code>rsession.conf</code> and <code>repos.conf</code></h3>
RStudio Server allows server admins to configure particular server-wide R package repositories via the <code>rsession.conf</code> and <code>repos.conf</code> files. 
Only one repository can be configured in <code>rsession.conf</code>. 
If multiple repositories are needed, <code>repos.conf</code> should be used. 
Details on configuring RStudio Server with these files are in this <a href="https://support.rstudio.com/hc/en-us/articles/360009863114-Configuring-RStudio-Server-to-use-RStudio-Package-Manager" target="_blank">support article</a>.

<h2>R startup mechanism is as follows</h2>
Unless --no-environ was given on the command line, R searches for site and user files to process for setting environment variables. 
The name of the site file is the one pointed to by the environment variable R_ENVIRON; if this is unset, ‘R_HOME/etc/Renviron.site’ is used (if it exists, which it does not in a ‘factory-fresh’ installation). 
The name of the user file can be specified by the R_ENVIRON_USER environment variable; if this is unset, the files searched for are ‘.Renviron’ in the current or in the user's home directory (in that order). 
See ‘Details’ for how the files are read.

Then R searches for the site-wide startup profile file of R code unless the command line option --no-site-file was given. 
The path of this file is taken from the value of the R_PROFILE environment variable (after tilde expansion). 
If this variable is unset, the default is ‘R_HOME/etc/Rprofile.site’, which is used if it exists (it contains settings from the installer in a ‘factory-fresh’ installation). 
This code is sourced into the base package. 
Users need to be careful not to unintentionally overwrite objects in base, and it is normally advisable to use local if code needs to be executed: see the examples.

Then, unless --no-init-file was given, R searches for a user profile, a file of R code. 
The path of this file can be specified by the R_PROFILE_USER environment variable (and tilde expansion will be performed). 
If this is unset, a file called ‘.Rprofile’ is searched for in the current directory or in the user's home directory (in that order). 
The user profile file is sourced into the workspace.

Note that when the site and user profile files are sourced only the base package is loaded, so objects in other packages need to be referred to by e.g. utils::dump.frames or after explicitly loading the package concerned.

R then loads a saved image of the user workspace from ‘.RData’ in the current directory if there is one (unless --no-restore-data or --no-restore was specified on the command line).

Next, if a function .First is found on the search path, it is executed as .First(). 
Finally, function .First.sys() in the base package is run. 
This calls require to attach the default packages specified by options("defaultPackages"). 
If the methods package is included, this will have been attached earlier (by function .OptRequireMethods()) so that namespace initializations such as those from the user workspace will proceed correctly.

A function .First (and .Last) can be defined in appropriate ‘.Rprofile’ or ‘Rprofile.site’ files or have been saved in ‘.RData’. 
If you want a different set of packages than the default ones when you start, insert a call to options in the ‘.Rprofile’ or ‘Rprofile.site’ file. 
For example, options(defaultPackages = character()) will attach no extra packages on startup (only the base package) (or set R_DEFAULT_PACKAGES=NULL as an environment variable before running R). 
Using options(defaultPackages = "") or R_DEFAULT_PACKAGES="" enforces the R system default.

On front-ends which support it, the commands history is read from the file specified by the environment variable R_HISTFILE (default ‘.Rhistory’ in the current directory) unless --no-restore-history or --no-restore was specified.

The command-line option --vanilla implies --no-site-file, --no-init-file, --no-environ and (except for R CMD) --no-restore Under Windows, it also implies --no-Rconsole, which prevents loading the ‘Rconsole’ file.

Details
Note that there are two sorts of files used in startup: environment files which contain lists of environment variables to be set, and profile files which contain R code.

Lines in a site or user environment file should be either comment lines starting with #, or lines of the form name=value. 
The latter sets the environmental variable name to value, overriding an existing value. 
If value contains an expression of the form ${foo-bar}, the value is that of the environmental variable foo if that exists and is set to a non-empty value, otherwise bar. 
(If it is of the form ${foo}, the default is "".) This construction can be nested, so bar can be of the same form (as in ${foo-${bar-blah}}). 
Note that the braces are essential: for example $HOME will not be interpreted.

Leading and trailing white space in value are stripped. 
value is then processed in a similar way to a Unix shell: in particular the outermost level of (single or double) quotes is stripped, and backslashes are removed except inside quotes.

On systems with sub-architectures (mainly Windows), the files ‘Renviron.site’ and ‘Rprofile.site’ are looked for first in architecture-specific directories, e.g. ‘R_HOME/etc/i386/Renviron.site’. 
And e.g. ‘.Renviron.i386’ will be used in preference to ‘.Renviron’.

Note
It is not intended that there be interaction with the user during startup code. 
Attempting to do so can crash the R process.

The startup options are for Rgui, Rterm and R but not for Rcmd: attempting to use e.g. --vanilla with the latter will give a warning or error.

Unix versions of R have a file ‘R_HOME/etc/Renviron’ which is read very early in the start-up processing. 
It contains environment variables set by R in the configure process, and is not used on R for Windows.

R CMD check and R CMD build do not always read the standard startup files, but they do always read specific Renviron files. 
The location of these can be controlled by the environment variables R_CHECK_ENVIRON and R_BUILD_ENVIRON. 
If these are set their value is used as the path for the Renviron file; otherwise, files ‘~/.R/check.Renviron’ or ‘~/.R/build.Renviron’ or sub-architecture-specific versions are employed.

If you want ‘~/.Renviron’ or ‘~/.Rprofile’ to be ignored by child R processes (such as those run by R CMD check and R CMD build), set the appropriate environment variable R_ENVIRON_USER or R_PROFILE_USER to (if possible, which it is not on Windows) "" or to the name of a non-existent file.

See Also
For the definition of the ‘home’ directory on Windows see the ‘rw-FAQ’ Q2.14. 
It can be found from a running R by Sys.getenv("R_USER").

.Last for final actions at the close of an R session. 
commandArgs for accessing the command line arguments.

There are examples of using startup files to set defaults for graphics devices in the help for windows.options.

An Introduction to R for more command-line options: those affecting memory management are covered in the help file for Memory.

readRenviron to read ‘.Renviron’ files.

For profiling code, see Rprof.

Examples
## Not run: 
## Example ~/.Renviron on Unix
R_LIBS=~/R/library
PAGER=/usr/local/bin/less

## Example .Renviron on Windows
R_LIBS=C:/R/library
MY_TCLTK="c:/Program Files/Tcl/bin"

## Example of setting R_DEFAULT_PACKAGES (from R CMD check)
R_DEFAULT_PACKAGES='utils,grDevices,graphics,stats'
# this loads the packages in the order given, so they appear on
# the search path in reverse order.

## Example of .Rprofile
options(width=65, digits=5)
options(show.signif.stars=FALSE)
setHook(packageEvent("grDevices", "onLoad"),
        function(...) grDevices::ps.options(horizontal=FALSE))
set.seed(1234)
.First = function() cat("\n   Welcome to R!\n\n")
.Last = function()  cat("\n   Goodbye!\n\n")

## Example of Rprofile.site
local({
  # add MASS to the default packages, set a CRAN mirror
  old = getOption("defaultPackages"); r = getOption("repos")
  r["CRAN"] = "http://my.local.cran"
  options(defaultPackages = c(old, "MASS"), repos = r)
  ## (for Unix terminal users) set the width from COLUMNS if set
  cols = Sys.getenv("COLUMNS")
  if(nzchar(cols)) options(width = as.integer(cols))
  # interactive sessions get a fortune cookie (needs fortunes package)
  if (interactive())
    fortunes::fortune()
})

## if .Renviron contains
FOOBAR="coo\bar"doh\ex"abc\"def'"

## then we get
# > cat(Sys.getenv("FOOBAR"), "\n")
# coo\bardoh\exabc"def'

## End(Not run)

<h2>R-Studio size/positioning</h2>
<a href="https://community.rstudio.com/t/r-studio-size-positioning-changing-from-screen-to-screen/28906/3" class="whitebut ">R-Studio size/positioning changing from screen to screen</a>

The following worked (windows):

Note that launching RStudio in this way will only disable GPU rendering for that particular RStudio session (that is, only for RStudio sessions that see that environment variable active). If you'd like to make this change more permanently, you can directly modify RStudio Desktop's options file. The option file is located at:

Windows
%APPDATA%\Roaming\RStudio\desktop.ini

In each case, you can modify the entry called desktop.renderingEngine and set it to software to force software rendering. For example:

[General]
desktop.renderingEngine=software

<h2>Introduction to V8 for R</h2>
V8 is Google’s open source, high performance JavaScript engine. It is written in C++ and implements ECMAScript as specified in ECMA-262, 5th edition. The V8 R package builds on the C++ library to provide a completely standalone JavaScript engine within R:

<code># Create a new context
ct &lt;- v8()

# Evaluate some code
ct$eval("var foo = 123")
ct$eval("var bar = 456")
ct$eval("foo + bar")</code>

<code>[1] "579"</code>

A major advantage over the other foreign language interfaces is that V8 requires no compilers, external executables or other run-time dependencies. The entire engine is contained within a 6MB package (2MB zipped) and works on all major platforms.

<code># Create some JSON
cat(ct$eval("JSON.stringify({x:Math.random()})"))</code>

<code>{"x":0.5580623043314792}</code>

<code># Simple closure
ct$eval("(function(x){return x+1;})(123)")</code>

<code>[1] "124"</code>

However note that V8 by itself is just the naked JavaScript engine. Currently, there is no DOM (i.e. no <em>window</em> object), no network or disk IO, not even an event loop. Which is fine because we already have all of those in R. In this sense V8 resembles other foreign language interfaces such as Rcpp or rJava, but then for JavaScript.

<h3>Loading JavaScript Libraries</h3>
The <code>ct$source</code> method is a convenience function for loading JavaScript libraries from a file or url.

<code>ct$source(system.file("js/underscore.js", package="V8"))
ct$source("https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.11/crossfilter.min.js")</code>

<h3>Data Interchange</h3>
By default all data interchange between R and JavaScript happens via JSON using the bidirectional mapping implemented in the <a href="http://arxiv.org/abs/1403.2805">jsonlite</a> package.

<code>ct$assign("mydata", mtcars)
ct$get("mydata")</code>

<code>                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
...
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2</code>

Alternatively use <code>JS()</code> to assign the value of a JavaScript expression (without converting to JSON):

<code>ct$assign("foo", JS("function(x){return x*x}"))
ct$assign("bar", JS("foo(9)"))
ct$get("bar")</code>

<code>[1] 81</code>

<h3>Function Calls</h3>
The <code>ct$call</code> method calls a JavaScript function, automatically converting objects (arguments and return value) between R and JavaScript:

<code>ct$call("_.filter", mtcars, JS("function(x){return x.mpg &lt; 15}"))</code>

<code>                     mpg cyl disp  hp drat    wt  qsec vs am gear carb
Duster 360          14.3   8  360 245 3.21 3.570 15.84  0  0    3    4
Cadillac Fleetwood  10.4   8  472 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8  440 230 3.23 5.345 17.42  0  0    3    4
Camaro Z28          13.3   8  350 245 3.73 3.840 15.41  0  0    3    4</code>

It looks a bit like <code>.Call</code> but then for JavaScript instead of C.

<h3>Interactive JavaScript Console</h3>
A fun way to learn JavaScript or debug a session is by entering the interactive console:

<code># Load some data
data(diamonds, package = "ggplot2")
ct$assign("diamonds", diamonds)
ct$console()</code>

From here you can interactively work in JavaScript without typing <code>ct$eval</code> every time:

<code>var cf = crossfilter(diamonds)
var price = cf.dimension(function(x){return x.price})
var depth = cf.dimension(function(x){return x.depth})
price.filter([2000, 3000])
output = depth.top(10)</code>

To exit the console, either press <code>ESC</code> or type <code>exit</code>. Afterwards you can retrieve the objects back into R:

<code>output &lt;- ct$get("output")
print(output)</code>

<h3>warnings, errors and console.log</h3>
Evaluating invalid JavaScript code results in a SyntaxError:

<code># A common typo
ct$eval('var foo &lt;- 123;')</code>

<code>Error in context_eval(join(src), private$context, serialize): SyntaxError: Unexpected token '&lt;'</code>

JavaScript runtime exceptions are automatically propagated into R errors:

<code># Runtime errors
ct$eval("123 + doesnotexit")</code>

<code>Error in context_eval(join(src), private$context, serialize): ReferenceError: doesnotexit is not defined</code>

Within JavaScript we can also call back to the R console manually using <code>console.log</code>, <code>console.warn</code> and <code>console.error</code>. This allows for explicitly generating output, warnings or errors from within a JavaScript application.

<code>ct$eval('console.log("this is a message")')</code>

<code>this is a message</code>

<code>ct$eval('console.warn("Heads up!")')</code>

<code>Warning: Heads up!</code>

<code>ct$eval('console.error("Oh no! An error!")')</code>

<code>Error in context_eval(join(src), private$context, serialize): Oh no! An error!</code>

A example of using <code>console.error</code> is to verify that external resources were loaded:

<code>ct &lt;- v8()
ct$source("https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.11/crossfilter.min.js")
ct$eval('var cf = crossfilter || console.error("failed to load crossfilter!")')</code>

<h3>The Global Namespace</h3>
Unlike what you might be used to from Node or your browser, the global namespace for a new context if very minimal. By default it contains only a few objects: <code>global</code> (a reference to itself), <code>console</code> (for <code>console.log</code> and friends) and <code>print</code> (an alias of console.log needed by some JavaScript libraries)

<code>ct &lt;- v8(typed_arrays = FALSE);
ct$get(JS("Object.keys(global)"))</code>

<code>[1] "print"   "console" "global" </code>

If typed arrays are enabled it contains some additional functions:

<code>ct &lt;- v8(typed_arrays = TRUE);
ct$get(JS("Object.keys(global)"))</code>

<code>[1] "print"   "console" "global" </code>

A context always has a global scope, even when no name is set. When a context is initiated with <code>global = NULL</code>, it can still be reached by evaluating the <code>this</code> keyword within the global scope:

<code>ct2 &lt;- v8(global = NULL, console = FALSE)
ct2$get(JS("Object.keys(this).length"))</code>

<code>[1] 1</code>

<code>ct2$assign("cars", cars)
ct2$eval("var foo = 123")
ct2$eval("function test(x){x+1}")
ct2$get(JS("Object.keys(this).length"))</code>

<code>[1] 4</code>

<code>ct2$get(JS("Object.keys(this)"))</code>

<code>[1] "print" "cars"  "foo"   "test" </code>

To create your own global you could use something like:

<code>ct2$eval("var __global__ = this")
ct2$eval("(function(){var bar = [1,2,3,4]; __global__.bar = bar; })()")
ct2$get("bar")</code>

<code>[1] 1 2 3 4</code>

<h3>Syntax Validation</h3>
V8 also allows for validating JavaScript syntax, without actually evaluating it.

<code>ct$validate("function foo(x){2*x}")</code>

<code>[1] TRUE</code>

<code>ct$validate("foo = function(x){2*x}")</code>

<code>[1] TRUE</code>

This might be useful for all those R libraries that generate browser graphics via templated JavaScript. Note that JavaScript does not allow for defining anonymous functions in the global scope:

<code>ct$validate("function(x){2*x}")</code>

<code>[1] FALSE</code>

To check if an anonymous function is syntactically valid, prefix it with <code>!</code> or wrap in <code>()</code>. These are OK:

<code>ct$validate("(function(x){2*x})")</code>

<code>[1] TRUE</code>

<code>ct$validate("!function(x){2*x}")</code>

<code>[1] TRUE</code>

<h3>Callback To R</h3>
A recently added feature is to interact with R from within JavaScript using the <code>console.r</code> API`. This is most easily demonstrated via the interactive console.

<code>ctx &lt;- v8()
ctx$console()</code>

From JavaScript we can read/write R objects via <code>console.r.get</code> and <code>console.r.assign</code>. The final argument is an optional list specifying arguments passed to <code>toJSON</code> or <code>fromJSON</code>.

<code>// read the iris object into JS
var iris = console.r.get("iris")
var iris_col = console.r.get("iris", {dataframe : "col"})

//write an object back to the R session
console.r.assign("iris2", iris)
console.r.assign("iris3", iris, {simplifyVector : false})</code>

To call R functions use <code>console.r.call</code>. The first argument should be a string which evaluates to a function. The second argument contains a list of arguments passed to the function, similar to <code>do.call</code> in R. Both named and unnamed lists are supported. The return object is returned to JavaScript via JSON.

<code>//calls rnorm(n=2, mean=10, sd=5)
var out = console.r.call('rnorm', {n: 2,mean:10, sd:5})
var out = console.r.call('rnorm', [2, 20, 5])

//anonymous function
var out = console.r.call('function(x){x^2}', {x:12})</code>

There is also an <code>console.r.eval</code> function, which evaluates some code. It takes only a single argument (the string to evaluate) and does not return anything. Output is printed to the console.

<code>console.r.eval('sessionInfo()')</code>

Besides automatically converting objects, V8 also propagates exceptions between R, C++ and JavaScript up and down the stack. Hence you can catch R errors as JavaScript exceptions when calling an R function from JavaScript or vice versa. If nothing gets caught, exceptions bubble all the way up as R errors in your top-level R session.

<code>//raise an error in R
console.r.call('stop("ouch!")')

//catch error from JavaScript
try {
  console.r.call('stop("ouch!")')
} catch (e) {
  console.log("Uhoh R had an error: " + e)
}
//# Uhoh R had an error: ouch!</code>

<h2>sprintf Function</h2>
<k>Basic R Syntax of sprintf:</k>
sprintf("%f", x)

<k>Definition of sprintf:</k>

The sprintf function returns character objects containing a formatted combination of input values.

<h3>Example 1: Format Decimal Places with sprintf Function in R</h3>
x &lt;- 123.456               # Create example data

The default number of decimal places is six digits after the decimal point

sprintf("%f", x)           # sprintf with default specification
#  "123.456000"

We can control the number of decimal places by adding a point and a number between the percentage sign and the f. 
For instance, we can print ten digits after the decimal point…

sprintf("%.10f", x)        # sprintf with ten decimal places
# "123.4560000000"

…or we can round our numeric input value to only two digits after the decimal point:

sprintf("%.2f", x)         # sprintf with two rounded decimal places
# "123.46"

<k>Note:</k> The output of sprintf is a <a href="http://www.r-tutor.com/r-introduction/basic-data-types/character" rel="noopener noreferrer" target="_blank">character string</a> and not a numeric value as the input was.

<h3>Example 2: Format Places Before Decimal Point</h3>
sprintf also enables the formatting of the number of digits before the decimal separator. 
We can tell sprintf to print all digits before the decimal point, but no digits after the decimal point…

sprintf("%1.0f", x)        # sprintf without decimal places
# "123"

…or we can print a certain amount of leading blanks before our number without decimal places (as illustrated by the quotes below)…

sprintf("%10.0f", x)       # sprintf with space before number
# "       123"

…or with decimal places…

sprintf("%10.1f", x)       # Space before number & decimal places
# "     123.5"

…or we can print blanks at the right side of our output by writing a minus sign in front of the number within the sprintf function:

sprintf("%-15f", x)        # Space on right side
# "123.456000     "

<h3>Example 3: Print Non-Numeric Values with sprintf (e.g. + or %)</h3>
It is also possible to combine numeric with non-numeric inputs. 
The following R code returns a plus sign in front of our example number…

sprintf("%+f", x)          # Print plus sign before number
# "+123.456000"

…and the following R code prints a percentage sign at the end of our number:

paste0(sprintf("%f", x),   # Print %-sign at the end of number
       "%")
# "123.456000%"

<h3>Example 4: Control Scientific Notation</h3>
The sprintf R function is also used to <a href="https://statisticsglobe.com/disable-exponential-scientific-notation-in-r">control exponential notation in R</a>. 
The following syntax returns our number as scientific notation with a lower case e…

sprintf("%e", x)           # Exponential notation
# "1.234560e+02"

…and the following code returns an upper case E to the RStudio console:

sprintf("%E", x)           # Exponential with upper case E
# "1.234560e+02"

<h3>Example 5: Control Amount of Decimal Zeros</h3>
We can also control the amount of decimal zeros that we want to print to the RStudio console. 
The following R code prints our example number without any decimal zeros…

sprintf("%g", x)           # sprintf without decimal zeros
# "123.456"

…the following R code returns our example number * 1e10 in scientific notation…

sprintf("%g", 1e10 * x)    # Scientific notation
# "1.23456e+12"

…and by adding a number before the g within the sprintf function we can control the amount of decimal zeros that we want to print:

sprintf("%.13g", 1e10 * x) # Fixed decimal zeros
# "1234560000000"

<h3>Example 6: Several Input Values for sprintf Function</h3>
So far, we have only used a single numeric value (i.e. our example data object x) as input for sprintf. 
However, the sprintf command allows as many input values as we want.

Furthermore, we can print these input values within more complex character strings. 
Have a look at the following sprintf example:

sprintf("Let's create %1.0f more complex example %1.0f you.", 1, 4)
# "Let's create 1 more complex example 4 you."

The first specification (i.e. %1.0f) within the previous R code corresponds to the input value 1 and the second specification corresponds to the input value 4.

Of cause we could use sprintf in even more complex settings. 
Have a look at the sprintf examples of the R help documentation, if you are interested in more complex examples:


<img class="lazy" data-src="https://statisticsglobe.com/wp-content/uploads/2019/04/sprintf-r-help-documentation-more-sophisticated-examples.png">

<em><k>Figure 1: Complex sprintf Examples in R Help Documentation.</k></em>

Examples
## be careful with the format: most things in R are floats
## only integer-valued reals get coerced to integer.

sprintf("%s is %f feet tall\n", "Sven", 7.1)      # OK
try(sprintf("%s is %i feet tall\n", "Sven", 7.1)) # not OK
try(sprintf("%s is %i feet tall\n", "Sven", 7))   # OK

## use a literal % :
sprintf("%.0f%% said yes (out of a sample of size %.0f)", 66.666, 3)

## no truncation:
sprintf("%1.f",101)
## re-use one argument three times, show difference between %x and %X
xx = sprintf("%1$d %1$x %1$X", 0:15)
xx = matrix(xx, dimnames=list(rep("", 16), "%d%x%X"))
noquote(format(xx, justify="right"))

## More sophisticated:

sprintf("min 10-char string '%10s'",
        c("a", "ABC", "and an even longer one"))

n = 1:18
sprintf(paste("e with %2d digits = %.",n,"g",sep=""), n, exp(1))

## Using arguments out of order
sprintf("second %2$1.0f, first %1$5.2f, third %3$1.0f", pi, 2, 3)

## Using asterisk for width or precision
sprintf("precision %.*f, width '%*.3f'", 3, pi, 8, pi)

## Asterisk and argument re-use, 'e' example reiterated:
sprintf("e with %1$2d digits = %2$.*1$g", n, exp(1))

## re-cycle arguments 
sprintf("%s %d", "test", 1:3)

sprintf(fmt, …)
Create a character string that contains values from R objects. 

fmt – A character string with some occurrences of %s, which will be places that object values are inserted.
… – The R objects to be inserted. 
The number of items should correspond to the number of %s occurrences in fmt.

Example. 
x = 2349
sprintf("Substitute in a string or number: %s", x)
"Substitute in a string or number: 2349"

sprintf("Can have multiple %s occurrences %s", x, "- got it?")
"Can have multiple 2349 occurrences - got it?"

Creating Custom Themes for RStudio
<a href="https://github.com/gadenbuie/rsthemes" class="whitebut ">rsthemes</a>

Creating an rstheme
Another straightforward method would be to copy an existing rstheme and then modify the values.

Because of the structure of the elements being styled, not all the CSS rule sets may end up being used. 
Below is a table that describes the most relevant selectors, which tmTheme scope they correspond to, if any, and how they impact the style of RStudio.

Selector	Scope	Description
.ace_bracket		Overrides default styling for matching bracket highlighting provided by Ace.
.ace_comment	comment	Changes the color and style of comments.
.ace_constant	constant	Changes the color and style of constants like TRUE, FALSE, and numeric literals.
.ace_constant.ace_language	constant.language	Changes the color and style of language constants like TRUE and FALSE. 
This rule set will override rules in .ace_constant for language constants. 
Also in RMarkdown files, everything surrounded in *.
.ace_constant.ace_numeric	constant.numeric	Changes the color and style of numeric literals. 
This value will override the settings in the “constant” scope, if set. 
Also in RMarkdown files, everything surrounded in **.
.ace_cusor		Changes the color and style of the text cursor in the editor window.
.ace_editor		Changes the default color and background of the RStudio editor windows. 
This selector will usually be the first in a list of other selectors for the same rule set, such as .rstudio-themes-flat.ace_editor_theme and so on.
.ace_gutter		Changes the color and style of the gutter: the panel on the left-hand side of the editor which holds line numbers, breakpoints, and fold widgets.
.ace_gutter-active-line		Changes the color and style of the gutter at the active line in the editor.
.ace_heading		Changes the color and style of headings in RMarkdown documents.
.ace_indent-guide		Changes the color and style of the indent guide, which can be enabled or disabled through Global Options > Code > Display > Show indent guides.
.ace_invisible		Changes the color and style of invisible characters, which can be enabled or disabled through Global Options > Code Display > Show whitespace characters.
.ace_keyword	keyword	Changes the color and style of keywords like function, if, else, stop, and operators.
.ace_keyword.ace_operator	keyword.operator	Changes the color and style of operators like (, ), =, +, and -. 
This value will override the settings in the .ace_keyword block for operators, if set.
.ace_meta.ace_tag	meta.tag	Changes the color and style of metadata tags in RMarkdown documents, like title and output.
.ace_marker-layer .ace_active-debug-line	marker-layer.active_debug_line	Changes the color and style of the highlighting on the line of code which is currently being debugged.
.ace_marker-layer .ace_bracket		Changes the color and style of the highlighting on matching brackets.
.ace_marker-layer .ace_selection		Changes the color and style of the highlighting for the currently selected line or block of lines.
.ace_markup.ace_heading	markup.heading	Changes the color and style of the characters that start a heading in RMarkdown documents.
.ace_print-margin		Changes the color and style, if applicable, of the line-width margin that can be enabled or disabled through Global Options > Code > Display > Show margin.
.ace_selection.ace_start		Changes the color and style of the highlighting for the start of the currently selected block of lines.
.ace_string	string	Changes the color and style of string literals.
.ace_support.ace_function	support.function	Changes the color and style of code blocks in RMarkdown documents.
In addition to these rule sets, you will also find a number of rule sets related to the Terminal pane, with selectors that include .terminal or selectors that begin with .xterm. 
It is possible to change these values as well, but it may be advisable to keep a back up copy of your original theme in case you don’t like any of the changes. 
There are also a number of classes that can be used to modify parts of RStudio unrelated to the editor. 
These classes are all prefixed with rstheme_, with the exception of dataGridHeader and themedPopupPanel. 
Any classes you find in the html of RStudio which are not prefixed with rstheme_, ace_, or explicitly listed in this article are subject to change at anytime, and so are unsafe to use in custom themes.

Since an rstheme is just CSS, anything that you can do with CSS you can do in an rstheme.

Testing Changes to a Theme
If you’re modifying a theme which has already been added to RStudio, you may need to restart RStudio desktop in order to make the changes take effect.

Sharing a Theme
Once you’re satisfied with your theme, you can easily share it with anyone by simply sharing the tmTheme or rstheme file. 
You can find rstheme files in 
C:\Users\(your user account)\Documents\.R\rstudio\themes on Windows

You can also use the theme related functions provided in the RStudio API to save a local copy of your converted theme.

If you upload your rstheme file to a URL-addressable location, you can also share a snippet of code that anyone can run to try your theme:

rstudioapi::addTheme("http://your/theme/path/theme.rstheme", apply = TRUE)
This will download, install, and apply the theme immediately on the user’s machine.

<h2>theme in RStudio</h2>
<a href="https://tmtheme-editor.herokuapp.com/#!/editor/theme/Monokai" class="whitebut ">Monokai theme</a>
Select a theme from this theme editor and save it to your machine as a .tmTheme file. 
Add the theme in RStudio. 
RStudio automatically creates an .rstheme file from that. 
the rstheme file in Users/Eric/Documents/.R/rstudio/themes folder (Windows machine). 
Open the file in text editor and find the .ace entry that matches the one you want to change. 
This will have an rgba value similar to: background-color: rgba(238, 252, 81, 0.8);
Note that the last value is the alpha (transparency) value and should be between 0 and 1. 

<a href="https://stackoverflow.com/questions/40369595/altering-rstudio-editor-theme" class="whitebut ">Altering RStudio Editor Theme</a>
<a href="https://stackoverflow.com/questions/25582588/any-way-to-change-colors-in-rstudio-to-something-other-than-default-options" class="whitebut ">change colors in Rstudio</a>
<a href="https://stackoverflow.com/questions/37635237/editing-r-studio-theme-in-cache-css-theme-file-ace-editor" class="whitebut ">Editing R studio theme in cache.css theme file</a>

There's a much faster way to deal with this and 100% doable.

Open RStudio with your favourite Editor theme and open an .R script

Inspect the Source layout (Right-click>Inspect) and Ctrl + f an unique class selector such as .ace_comment. 
In the matched CSS rules box in the side pane copy an attribute as unique as possible (i.e. color: #0088FF; I use Cobalt theme).

Go to RStudio's install path and dive into /www/rstudio/. 
As jorloff rightly said, you'll find a bunch of files like this: VERYUGLYNAME.cache.css. 
Open all of them with your favourite text editor as administrator.

Find in files: Ctrl+ Shift + f (in sublime text) and type the unique attribute value you previously chosed. 
BOOM, there you have it.

Now delight yourself editing your crazy style, but remember to back it up first!

As Jonathan said, RStudio's editor is based on ACE themes, so all clases have the ace_ prefix. 
Take your time inspecting and understanding the editor hierarchy. 
I recommend you to take some time inspecting the html code to understand its structure. 
The editor starts in id="rstudio_source_text_editor"


i am new to R Studio and i would like to share how i was able to customize the color scheme of R Studio:

How to change the color of comments in Rstudio

Rstudio Pane Appearance > Set editor theme to monokai
Right click on editor pane > Inspect > find the specific file name (i.e. 838C7F60FB885BB7E5EED7F698E453B9.cache.css)
Open drive C > open Progam Files folder > open Rstudio folder
Open www folder > rstudio folder > find the 838C7F60FB885BB7E5EED7F698E453B9.cache.css (name of the theme you want to change)
Make a backup copy of the original
Change .ace_comment {color: #75715E} to .ace_comment {color: #F92672} > save to another location (don't change file name)
Copy the recently saved code and paste it in rstudio folder (step 4) > replace the original 838C7F60FB885BB7E5EED7F698E453B9.cache.css file with the modified 838C7F60FB885BB7E5EED7F698E453B9.cache.csss file
Click continue
Quit Rstudio
Open Rstudio
Check if the color of comment has changed from nightsand(#75715E) to orchid(#F92672)


I am using RStudio 1.0.136. 
According to all the posts, right click on the Editor -> Inspect. 
The Web Inspector comes up and shows the Elements tab. 
Then click the Sources tab, select "Only enable for this session", click "Enable Debugging" button. 
You will see the code for the theme xxxxxxx.cache.css file. 
If nothing in the editor, try the left top "Show Navigator" button right under the "Elements" menu. 
Select the .css file in the list and it should open.

My line number seems dim. 
So changed color: #222; to color: #818222; in this section: (forgive my bad color sense). 
And you can see the color change right away! How amazing!

.ace_gutter {
  background-color: #3d3d3d;
  background-image: -moz-linear-gradient(left, #3D3D3D, #333);
  background-image: -ms-linear-gradient(left, #3D3D3D, #333);
  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#3D3D3D), to(#333));
  background-image: -webkit-linear-gradient(left, #3D3D3D, #333);
  background-image: -o-linear-gradient(left, #3D3D3D, #333);
  background-image: linear-gradient(left, #3D3D3D, #333);
  background-repeat: repeat-x;
  border-right: 1px solid #4d4d4d;
  text-shadow: 0px 1px 1px #4d4d4d;
  color: #818222;
}
@skan mentioned selected words are too dim. 
I have the same problem. 
So here I found it:

.ace_marker-layer .ace_selected-word {
  border-radius: 4px;
  border: 8px solid #ff475d;
  box-shadow: 0 0 4px black;
}
I changed border: 8px solid #ff475d;. 
It is now very bright, or may be too bright. 
Anyway, it works. 
Thanks for every one. 
And hope this can help.

This is for current session only. 
Now you know which .css to modify and what you should do, it will be easy to modify the original .css file to keep it permanent.

<h2>file or folder is locked after script quited</h2>
switch to other folder before quit
setwd("C:/Users/User/Desktop")

<h2>Write file as UTF-8 encoding</h2>
<a href="https://tomizonor.wordpress.com/2013/04/17/file-utf8-windows/" class="whitebut ">Write file as UTF-8 encoding in R for Windows</a>

While the R uses UTF-8 encoding as default on Linux and Mac OS, the R for Windows does not use UTF-8 as default. So reading and writing UTF-8 files are something troublesome on Windows. In this article, I will show you a small script to help UTF-8 encoding.

options("encoding" = "UTF-8")
t2 = "®"
getOption("encoding")
Encoding(t2) = "UTF-8"
sink("test.txt")
cat("123")
cat(t2)
sink()

Sys.getlocale('LC_CTYPE')

writeLines(Sys.setlocale("LC_CTYPE", locale), con)
Sys.setlocale("LC_CTYPE")

options("encoding" = "UTF-8") # set encoding to utf when write file
Sys.getlocale(category = "LC_ALL") # read status
Sys.setlocale(category = "LC_ALL", locale = "") # reset to english internally

sink("test.txt")
cat("123")
cat(t2)
sink()


<h2>S4 Classes</h2>
<h3>The Basic Idea</h3>
The S4 approach differs from the S3 approach to creating a class in that it is a more rigid definition. 
The idea is that an object is created using the <em>setClass</em> command. 
The command takes a number of options. 
Many of the options are not required, but we make use of several of the optional arguments because they represent good practices with respect to object oriented programming.
We first construct a trivial, contrived class simply to demonstrate the basic idea. 
Next we demonstrate how to create a method for an S4 class. 
This example is a little more involved than what we saw in the section on S3 classes.
In this example, the name of the class is <em>FirstQuadrant</em>, and the class is used to keep track of an <em>(x,y)</em> coordinate pair in the first quadrant. 
There is a restriction that both values must be greater than or equal to zero. 
There are two data elements, called <em>slots</em>, and they are called <em>x</em> and <em>y</em>. 
The default values for the coordinate is the origin, <em>x=0</em> and <em>y=0</em>.
######################################################################
# Create the first quadrant class
#
# This is used to represent a coordinate in the first quadrant.
FirstQuadrant = setClass(
    # Set the name for the class
    "FirstQuadrant",

    # Define the slots
    slots = c( x = "numeric", y = "numeric" ),

    # Set the default values for the slots. (optional)
    prototype=list( x = 0.0, y = 0.0 ),

    # Make a function that can test to see if the data is consistent.
    # This is not called if you have an initialize function defined!
    validity=function(object){
        if((object@x &lt; 0) || (object@y &lt; 0)) {
            return("A negative number for one of the coordinates was given.")
        }
        return(TRUE)
    }
)



Note that the way to access one of the data elements is to use the “@” symbol. 
An example if given below. 
In the example three elements of the class defined above are created. 
The first uses the default values for the slots, the second overrides the defaults, and finally an attempt is made to create a coordinate in the second quadrant.
> x = FirstQuadrant()
> x
An object of class "FirstQuadrant"
Slot "x":
[1] 0
Slot "y":
[1] 0
> y = FirstQuadrant(x=5,y=7)
> y
An object of class "FirstQuadrant"
Slot "x":
[1] 5
Slot "y":
[1] 7
> y@x
[1] 5
> y@y
[1] 7
> z = FirstQuadrant(x=3,y=-2)
Error in validObject(.Object) :
      invalid class “FirstQuadrant” object: A negative number for one of the coordinates was given.
> z
Error: object 'z' not found



In the next example we create a method that is associated with the class. 
The method is used to set the values of a coordinate. 
The first step is to reserve the name using the <em>setGeneric</em> command, and then the <em>setMethod</em> command is used to define the function to be called when the first argument is an object from the <em>FirstQuadrant</em> class.
# create a method to assign the value of a coordinate setGeneric(name="setCoordinate",
    def=function(theObject,xVal,yVal)
    {
        standardGeneric("setCoordinate")
    }
    )
setMethod(f="setCoordinate",
    signature="FirstQuadrant",
    definition=function(theObject,xVal,yVal)
    {
       theObject@x = xVal
       theObject@y = yVal
       return(theObject)
    }
    )



It is important to note that R generally passes objects as values. 
For this reason the methods defined above return the updated object. 
When the method is called, it is used to replace the former object with the updated object.
> z = FirstQuadrant(x=2.5,y=10)
> z
An object of class "FirstQuadrant"
Slot "x":
[1] 2.5
Slot "y":
[1] 10
> z = setCoordinate(z,-3.0,-5.0)
> z
An object of class "FirstQuadrant"
Slot "x":
[1] -3
Slot "y":
[1] -5



Note that the <em>validity</em> function given in the original class definition is not called. 
It is called when an object is first defined. 
It can be called later, but only when an explicit request is made using the <em>validObject</em> command.


<h3>Creating an S4 Class</h3>
An S4 class is created using the <em>setClass()</em> command. 
At a minimum the name of the class is specified and the names of the data elements
(slots) is specified. 
There are a number of other options, and just as a matter of good practice we also specify a function to verify that the data is consistent (validation), and we specify the default values (the prototype). 
In the last section of this page,
S4 inheritance, we include an additional parameter used to specify a class hierarchy.
In this section we look at another example, and we examine some of the functions associated with S4 classes. 
The example we define will be used to motivate the use of methods associated with a class, and it will be used to demonstrate inheritance later. 
The idea is that we want to create a program to simulate a cellular automata model of a predator-prey system.
We do not develop the whole code here but concentrate on the data structures. 
In particular we will create a base class for the agents. 
In the next section we will create the basic methods for the class. 
In the inheritance section we will discuss how to build on the class to create different predators and different prey species. 
The basic structure of the class is shown in Figure 1.


<img class="lazy" data-src="https://www.cyclismo.org/tutorial/R/_images/s4AgentClass.png" />
Figure 1.

Diagram of the base class, Agent, used for the agents in a simulation.

The methods for this class are defined in the following section. 
Here we define the class and its slots, and the code to define the class is given below:
######################################################################
# Create the base Agent class
#
# This is used to represent the most basic agent in a simulation.
Agent = setClass(
    # Set the name for the class
    "Agent",
    # Define the slots
    slots = c(
        location = "numeric",
        velocity   = "numeric",
        active   = "logical"
        ),
    # Set the default values for the slots. 
(optional)
    prototype=list(
        location = c(0.0,0.0),
        active   = TRUE,
        velocity = c(0.0,0.0)
        ),
    # Make a function that can test to see if the data is consistent.
    # This is not called if you have an initialize function defined!
    validity=function(object)
    {
        if(sum(object@velocity^2)>100.0) {
            return("The velocity level is out of bounds.")
        }
        return(TRUE)
    }
    )



Now that the code to define the class is given we can create an object whose class is Agent.
> a = Agent()
> a
An object of class "Agent"
Slot "location":
[1] 0 0
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE



Before we define the methods for the class a number of additional commands are explored. 
The first set of functions explored are the
<em>is.object</em> and the <em>isS4</em> commands. 
The <em>is.object</em> command determines whether or not a variable refers to an object. 
The <em>isS4</em>
command determines whether or not the variable is an S4 object. 
The reason both are required is that the <em>isS4</em> command alone cannot determine if a variable is an S3 object. 
You need to determine if the variable is an object and then decide if it is S4 or not.
> is.object(a)
[1] TRUE
> isS4(a)
[1] TRUE



The next set of commands are used to get information about the data elements, or slots, within an object. 
The first is the <em>slotNames</em>
command. 
This command can take either an object or the name of a class. 
It returns the names of the slots associated with the class as strings.
> slotNames(a)
[1] "location" "velocity" "active"
> slotNames("Agent")
[1] "location" "velocity" "active"



The <em>getSlots</em> command is similar to the <em>slotNames</em> command. 
It takes the name of a class as a string. 
It returns a vector whose entries are the types associated with the slots, and the names of the entries are the names of the slots.
> getSlots("Agent")
     location  velocity    active
"numeric" "numeric" "logical"
> s = getSlots("Agent")
> s[1]
     location
"numeric"
> s[[1]]
[1] "numeric"
> names(s)
[1] "location" "velocity" "active"



The next command examined is the <em>getClass</em> command. 
It has two forms. 
If you give it a variable that is an S4 class it returns a list of slots for the class associated with the variable. 
If you give it a character string with the name of a class it gives the slots and their data types.
> getClass(a)
An object of class "Agent"
Slot "location":
[1] 0 0
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE
> getClass("Agent")
Class "Agent" [in ".GlobalEnv"]
Slots:
Name:  location velocity   active
Class:  numeric  numeric  logical



The final command examined is the <em>slot</em> command. 
It can be used to get or set the value of a slot in an object. 
It can be used in place of the “@” operator.
> slot(a,"location")
[1] 0 0
> slot(a,"location") = c(1,5)
> a
An object of class "Agent"
Slot "location":
[1] 1 5
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE





<h3>Creating Methods</h3>
We now build on the Agent class defined above. 
Once the class and its data elements are defined we can define the methods associated with the class. 
The basic idea is that if the name of a function has not been defined, the name must first be reserved using the <em>setGeneric</em>
function. 
The <em>setMethod</em> can then be used to define which function is called based on the class names of the objects sent to it.
We define the methods associated with the Agent method given in the previous section. 
Note that the <em>validity</em> function for an object is only called when it is first created and when an explicit call to the
<em>validObject</em> function is made. 
We make use of the <em>validObject</em>
command in the methods below that are used to change the value of a data element within an object.
# create a method to assign the value of the location setGeneric(name="setLocation",
    def=function(theObject,position)
    {
        standardGeneric("setLocation")
    }
    )
setMethod(f="setLocation",
    signature="Agent",
    definition=function(theObject,position)
    {
       theObject@location = position
       validObject(theObject)
       return(theObject)
    }
    )
# create a method to get the value of the location setGeneric(name="getLocation",
    def=function(theObject)
    {
        standardGeneric("getLocation")
    }
    )
setMethod(f="getLocation",
    signature="Agent",
    definition=function(theObject)
    {
       return(theObject@location)
    }
    )

# create a method to assign the value of active setGeneric(name="setActive",
    def=function(theObject,active)
    {
        standardGeneric("setActive")
    }
    )
setMethod(f="setActive",
    signature="Agent",
    definition=function(theObject,active)
    {
       theObject@active = active
       validObject(theObject)
       return(theObject)
    }
    )
# create a method to get the value of active setGeneric(name="getActive",
    def=function(theObject)
    {
        standardGeneric("getActive")
    }
    )
setMethod(f="getActive",
    signature="Agent",
    definition=function(theObject)
    {
       return(theObject@active)
    }
    )

# create a method to assign the value of velocity setGeneric(name="setVelocity",
    def=function(theObject,velocity)
    {
        standardGeneric("setVelocity")
    }
    )
setMethod(f="setVelocity",
    signature="Agent",
    definition=function(theObject,velocity)
    {
       theObject@velocity = velocity
       validObject(theObject)
       return(theObject)
    }
    )
# create a method to get the value of the velocity setGeneric(name="getVelocity",
    def=function(theObject)
    {
        standardGeneric("getVelocity")
    }
    )
setMethod(f="getVelocity",
    signature="Agent",
    definition=function(theObject)
    {
       return(theObject@velocity)
    }
    )



With these definitions the data elements are encapsulated and can be accessed and set using the methods given above. 
It is generally good practice in object oriented programming to keep your data private and not show them to everybody willy nilly.
> a = Agent()
> getVelocity(a)
[1] 0 0
> a = setVelocity(a,c(1.0,2.0))
> getVelocity(a)
[1] 1 2



The last topic examined is the idea of overloading functions. 
In the examples above the signature is set to a single element. 
The signature is a vector of characters and specifies the data types of the argument list for the method to be defined. 
Here we create two new methods. 
The name of the method is <em>resetActivity</em>, and there are two versions.
The first version accepts two arguments whose types are <em>Agent</em> and
<em>logical</em>. 
This version of the method will set the activity slot to a given value. 
The second version accepts two arguments whose types are
<em>Agent</em> and <em>numeric</em>. 
This version will set the activity to TRUE and then set the energy level to the value passed to it. 
Note that the names of the variables in the argument list must be exactly the same.
# create a method to reset the velocity and the activity setGeneric(name="resetActivity",
    def=function(theObject,value)
    {
        standardGeneric("resetActivity")
    }
    )
setMethod(f="resetActivity",
    signature=c("Agent","logical"),
    definition=function(theObject,value)
    {
       theObject = setActive(theObject,value)
       theObject = setVelocity(theObject,c(0.0,0.0))
       return(theObject)
    }
    )
setMethod(f="resetActivity",
    signature=c("Agent","numeric"),
    definition=function(theObject,value)
    {
       theObject = setActive(theObject,TRUE)
       theObject = setVelocity(theObject,value)
       return(theObject)
    }
    )



This definition of the function yields two options for the
<em>resetActivity</em> function. 
The decision to determine which function to call depends on two arguments and their type. 
For example, if the first argument is from the Agent class and the second is a value of
TRUE or FALSE, then the first version of the function is called. 
Otherwise, if the second argument is a number the second version of the function is called.
> a = Agent()
> a
An object of class "Agent"
Slot "location":
[1] 0 0
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE
> a = resetActivity(a,FALSE)
> getActive(a)
[1] FALSE
>  a = resetActivity(a,c(1,3))
> getVelocity(a)
[1] 1 3





<h3>Inheritance</h3>
A class’ inheritance hiearchy can be specified when the class is defined using the <em>contains</em> option. 
The <em>contains</em> option is a vector that lists the classes the new class inherits from. 
In the following example we build on the Agent class defined in the previous section. 
The idea is that we need agents that represent a predator and two prey. 
We will focus on two predators for this example.
The hierarchy for the classes is shown in
Figure 2.. 
 In this example we have one Prey class that is derived from the Agent class. 
There are two predator classes, Bobcat and Lynx. 
The Bobcat class is derived from the Agent class, and the Lynx class is derived from the Bobcat class. 
We will keep this very simple, and the only methods associated with the new classes is a <em>move</em> method. 
For our purposes it will only print out a message and set the values of the position and velocity to demonstrate the order of execution of the methods associated with the classes.


<img class="lazy" data-src="https://www.cyclismo.org/tutorial/R/_images/s4AgentPredPrey.png" />
Figure 2.

Diagram of the predator and prey classes derived from the Agent class.

The first step is to create the three new classes.
######################################################################
# Create the Prey class
#
# This is used to represent a prey animal
Prey = setClass(
    # Set the name for the class
    "Prey",
    # Define the slots - in this case it is empty...
    slots = character(0),
    # Set the default values for the slots. 
(optional)
    prototype=list(),
    # Make a function that can test to see if the data is consistent.
    # This is not called if you have an initialize function defined!
    validity=function(object)
    {
        if(sum(object@velocity^2)>70.0) {
            return("The velocity level is out of bounds.")
        }
        return(TRUE)
    },
    # Set the inheritance for this class
    contains = "Agent"
    )

######################################################################
# Create the Bobcat class
#
# This is used to represent a smaller predator
Bobcat = setClass(
    # Set the name for the class
    "Bobcat",
    # Define the slots - in this case it is empty...
    slots = character(0),
    # Set the default values for the slots. 
(optional)
    prototype=list(),
    # Make a function that can test to see if the data is consistent.
    # This is not called if you have an initialize function defined!
    validity=function(object)
    {
        if(sum(object@velocity^2)>85.0) {
            return("The velocity level is out of bounds.")
        }
        return(TRUE)
    },
    # Set the inheritance for this class
    contains = "Agent"
    )
######################################################################
# Create the Lynx class
#
# This is used to represent a larger predator
Lynx = setClass(
    # Set the name for the class
    "Lynx",
    # Define the slots - in this case it is empty...
    slots = character(0),
    # Set the default values for the slots. 
(optional)
    prototype=list(),
    # Make a function that can test to see if the data is consistent.
    # This is not called if you have an initialize function defined!
    validity=function(object)
    {
        if(sum(object@velocity^2)>95.0) {
            return("The velocity level is out of bounds.")
        }
        return(TRUE)
    },
    # Set the inheritance for this class
    contains = "Bobcat"
    )



The inheritance is specified using the <em>contains</em> option in the
<em>setClass</em> command. 
Note that this can be a vector allowing for multiple inheritance. 
We choose not to use that to keep things simpler. 
If you are feeling like you need more self-loathing in your life you should try it out and experiment.
Next we define a method, <em>move</em>, for the new classes. 
We will include methods for the Agent, Prey, Bobcat, and Lynx classes. 
The methods do not really do anything but are used to demonstrate the idea of how methods are executed.
# create a method to move the agent.
setGeneric(name="move",
    def=function(theObject)
    {
        standardGeneric("move")
    }
    )
setMethod(f="move",
    signature="Agent",
    definition=function(theObject)
    {
       print("Move this Agent dude")
       theObject = setVelocity(theObject,c(1,2))
       validObject(theObject)
       return(theObject)
    }
    )
setMethod(f="move",
    signature="Prey",
    definition=function(theObject)
    {
       print("Check this Prey before moving this dude")
       theObject = callNextMethod(theObject)
       print("Move this Prey dude")
       validObject(theObject)
       return(theObject)
    }
    )
setMethod(f="move",
    signature="Bobcat",
    definition=function(theObject)
    {
       print("Check this Bobcat before moving this dude")
       theObject = setLocation(theObject,c(2,3))
       theObject = callNextMethod(theObject)
       print("Move this Bobcat dude")
       validObject(theObject)
       return(theObject)
    }
    )
setMethod(f="move",
    signature="Lynx",
    definition=function(theObject)
    {
       print("Check this Lynx before moving this dude")
       theObject = setActive(theObject,FALSE)
       theObject = callNextMethod(theObject)
       print("Move this Lynx dude")
       validObject(theObject)
       return(theObject)
    }
    )



There are a number of things to note. 
First each method calls the
<em>callNextMethod</em> command. 
This command will execute the next version of the same method for the previous class in the hierarchy. 
Note that
I have included the arguments (in the same order) as those called by the original function. 
Also note that the function returns a copy of the object and is used to update the object passed to the original function.
Another thing to note is that the methods associated with the Lync,
Bobcat, and Agent classes arbitrarily change the values of the position, velocity, and activity for the given object. 
This is done to demonstrate the changes that take place and reinforce the necessity for using the <em>callNextMethod</em> function the way it is used here.
Finally, it should be noted that the <em>validObject</em> command is called in every method. 
You should try adding a print statement in the validity function. 
You might find that the order is a bit odd. 
You should experiment with this and play with it. 
There are times you do not get the expected results so be careful!
We now give a brief example to demonstrate the order that the functions are called. 
In the example we create a Bobcat object and then call the <em>move</em> method. 
We next create a Lynx object and do the same. 
We print out the slots for both agents just to demonstrate the values that are changed.
> robert = Bobcat()
> robert
An object of class "Bobcat"
Slot "location":
[1] 0 0
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE
> robert = move(robert)
[1] "Check this Bobcat before moving this dude"
[1] "Move this Agent dude"
[1] "Move this Bobcat dude"
> robert
An object of class "Bobcat"
Slot "location":
[1] 2 3
Slot "velocity":
[1] 1 2
Slot "active":
[1] TRUE
>
>
>
> lionel = Lynx()
> lionel
An object of class "Lynx"
Slot "location":
[1] 0 0
Slot "velocity":
[1] 0 0
Slot "active":
[1] TRUE
> lionel = move(lionel)
[1] "Check this Lynx before moving this dude"
[1] "Check this Bobcat before moving this dude"
[1] "Move this Agent dude"
[1] "Move this Bobcat dude"
[1] "Move this Lynx dude"
> lionel
An object of class "Lynx"
Slot "location":
[1] 2 3
Slot "velocity":
[1] 1 2
Slot "active":
[1] FALSE

<h2>convert named character to vector</h2>
a = unname(resultTable[,1][which(klineWave[,7]==TRUE)])

<h2>Neural Network Models in R</h2>
Neural Network (or Artificial Neural Network) has the ability to learn by examples. 

<h3>Activation Functions</h3>
Activation function defines the output of a neuron in terms of a local induced field. 
 Activation functions are a single line of code that gives the neural nets non-linearity and expressiveness. 
There are many activation functions. 
Some of them are as follows (<a href="https://www.analyticsvidhya.com/blog/2016/08/evolution-core-concepts-deep-learning-neural-networks/]">Source</a>):

<k>Identity function</k> is a function that maps input to the same output value. 
It is a linear operator in vector space. 
Also, known straight line function where activation is proportional to the input.
In <k>Binary Step Function</k>, if the value of Y is above a certain value known as the threshold, the output is True(or activated), and if it’s less than the threshold, then the output is false (or not activated). 
It is very useful in the classifier.
<k>Sigmoid Function</k> called S-shaped functions. 
Logistic and hyperbolic tangent functions are commonly used sigmoid functions. 
There are two types of sigmoid functions.
<k>Binary Sigmoid Function</k> is a logistic function where the output values are either binary or vary from 0 to 1.
<k>Bipolar Sigmoid Function</k> is a logistic function where the output value varies from -1 to 1. 
Also known as Hyperbolic Tangent Function or tanh.

<k>Ramp Function:</k> The name of the ramp function is derived from the appearance of its graph. 
It maps negative inputs to 0 and positive inputs to the same output.
<k>ReLu</k> stands for the rectified linear unit (ReLU). 
It is the most used activation function in the world. 
It output 0 for negative values of x.

<center>
<img class="lazy" data-src="https://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1547672259/4_jouacz.png" /></center>

<h3>Implementation of a Neural Network in R</h3>
<h3>Install required package</h3>
Let's first install the neuralnet library:

<code class="lang-python"># install package
install.packages("neuralnet")
</code>

<code>Updating HTML index of packages in '.Library'
Making 'packages.html' ... 
done
</code>
<h3>Create training dataset</h3>
<center>
<img class="lazy" data-src="https://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1547672259/5_lrfb0r.png" /></center>

Let's create your own dataset. 
Here you need two kinds of attributes or columns in your data: Feature and label. 
In the table shown above, you can see the technical knowledge, communication skills score and placement status of the student. 
So the first two columns(Technical Knowledge Score and Communication Skills Score) are features and third column(Student Placed) is the binary label.

<code class="lang-python"># creating training data set
TKS=c(20,10,30,20,80,30)
CSS=c(90,20,40,50,50,80)
Placed=c(1,0,0,0,1,1)
# Here, you will combine multiple columns or features into a single set of data
df=data.frame(TKS,CSS,Placed)
</code>

Let's build a NN classifier model using the neuralnet library.

First, import the neuralnet library and create NN classifier model by passing argument set of label and features, dataset, number of neurons in hidden layers, and error calculation.

<code class="lang-python"># load library
require(neuralnet)

# fit neural network
nn=neuralnet(Placed~TKS+CSS,data=df, hidden=3,act.fct = "logistic",
               linear.output = FALSE)
</code>

Here,

<code>  - Placed~TKS+CSS, Placed is label annd TKS and CSS are features.
 - df is dataframe,
 - hidden=3: represents single layer with 3 neurons respectively.
 - act.fct = "logistic" used for smoothing the result.
 - linear.ouput=FALSE: set FALSE for apply act.fct otherwise TRUE
</code>
<h3>Plotting Neural Network</h3>
Let's plot your neural net model.

<code class="lang-python"># plot neural network
plot(nn)
</code>

<center>
<img class="lazy" data-src="https://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1547672260/6_y5jnhr.png" /></center>

<h3>Create test dataset</h3>
Create test dataset using two features Technical Knowledge Score and Communication Skills Score

<code class="lang-python"># creating test set
TKS=c(30,40,85)
CSS=c(85,50,40)
test=data.frame(TKS,CSS)
</code>

<h3>Predict the results for the test set</h3>
Predict the probability score for the test data using the compute function.

<code class="lang-python">## Prediction using neural network
Predict=compute(nn,test)
Predict$net.result
</code>

0.9928202080
0.3335543925
0.9775153014

Now, Convert probabilities into binary classes.

<code class="lang-python"># Converting probabilities into binary classes setting threshold level 0.5
prob &lt;- Predict$net.result
pred &lt;- ifelse(prob>0.5, 1, 0)
pred
</code>

1
0
1

Predicted results are 1,0, and 1.

<h3>Pros and Cons</h3>
Neural networks are more flexible and can be used with both regression and classification problems. 
Neural networks are good for the nonlinear dataset with a large number of inputs such as images. 
Neural networks can work with any number of inputs and layers. 
Neural networks have the numerical strength that can perform jobs in parallel.

There are more alternative algorithms such as SVM, Decision Tree and Regression are available that are simple, fast, easy to train, and provide better performance. 
Neural networks are much more of the black box, require more time for development and more computation power. 
Neural Networks requires more data than other Machine Learning algorithms. 
NNs can be used only with numerical inputs and non-missing value datasets. 
A well-known neural network researcher said <i> "A neural network is the second best way to solve any problem. 
The best way is to actually understand the problem,"</i>

<h3>Use-cases of NN</h3>
NN's wonderful properties offer many applications such as:

<k>Pattern Recognition:</k>  neural networks are very suitable for pattern recognition problems such as facial recognition, object detection, fingerprint recognition, etc.
<k>Anomaly Detection:</k> neural networks are good at pattern detection, and they can easily detect the unusual patterns that don’t fit in the general patterns.
<k>Time Series Prediction:</k> Neural networks can be used to predict time series problems such as stock price, weather forecasting.
<k>Natural Language Processing:</k> Neural networks offer a wide range of applications in Natural Language Processing tasks such as text classification, Named Entity Recognition (NER), Part-of-Speech Tagging, Speech Recognition, and Spell Checking.



<h2>Neural Net Package Examples</h2>
<code>library("neuralnet")</code>
Going to create a neural network to perform square rooting 
Type ?neuralnet for more information on the neuralnet library

Generate 50 random numbers uniformly distributed between 0 and 100 And store them as a dataframe

<code>traininginput &lt;-  as.data.frame(runif(50, min=0, max=100))
trainingoutput &lt;- sqrt(traininginput)</code>

Column bind the data into one variable

<code>trainingdata &lt;- cbind(traininginput,trainingoutput)
colnames(trainingdata) &lt;- c("Input","Output")</code>

Train the neural network Going to have 10 hidden layers Threshold is a numeric value specifying the threshold for the partial derivatives of the error function as stopping criteria.

<code>net.sqrt &lt;- neuralnet(Output~Input,trainingdata, hidden=10, threshold=0.01)</code>

Plot the neural network
<code>plot(net.sqrt, rep = "best")</code>

Test the neural network on some training data

<code>testdata &lt;- as.data.frame((1:10)^2) #Generate some squared numbers
net.results &lt;- compute(net.sqrt, testdata) #Run them through the neural network</code>

Lets see what properties net.sqrt has

<code>ls(net.results)</code>

<code>## [1] "net.result" "neurons"</code>

Lets see the results

<code>print(net.results$net.result)</code>

<code>##              [,1]
##  [1,] 0.995651087
##  [2,] 2.004949735
##  [3,] 2.997236258
##  [4,] 4.003559121
##  [5,] 4.992983838
##  [6,] 6.004351125
##  [7,] 6.999959828
##  [8,] 7.995941860
##  [9,] 9.005608807
## [10,] 9.971903887</code>

Lets display a better version of the results

<code>cleanoutput &lt;- cbind(testdata,sqrt(testdata),
                     as.data.frame(net.results$net.result))
colnames(cleanoutput) &lt;- c("Input","Expected Output","Neural Net Output")
print(cleanoutput)</code>

<code>##    Input Expected Output Neural Net Output
## 1      1               1       0.995651087
## 2      4               2       2.004949735
## 3      9               3       2.997236258
## 4     16               4       4.003559121
## 5     25               5       4.992983838
## 6     36               6       6.004351125
## 7     49               7       6.999959828
## 8     64               8       7.995941860
## 9     81               9       9.005608807
## 10   100              10       9.971903887</code>

<h3><code>sin</code> function</h3>
Generate random data and the dependent variable

<code>x &lt;- sort(runif(50, min = 0, max = 4*pi))
y &lt;- sin(x)

data &lt;- cbind(x,y)</code>

Create the neural network responsible for the sin function

<code>library(neuralnet)
sin.nn &lt;- neuralnet(y ~ x, data = data, hidden = 5, stepmax = 100000, learningrate = 10e-6,  
                    act.fct = 'logistic', err.fct = 'sse', rep = 5, lifesign = "minimal", 
                    linear.output = T)</code>

<code>## hidden: 5    thresh: 0.01    rep: 1/5    steps: stepmax  min thresh: 0.01599376894
## hidden: 5    thresh: 0.01    rep: 2/5    steps:    7943  error: 0.41295  time: 0.73 secs
## hidden: 5    thresh: 0.01    rep: 3/5    steps:   34702  error: 0.02068  time: 3.13 secs
## hidden: 5    thresh: 0.01    rep: 4/5    steps:    4603  error: 0.4004   time: 0.41 secs
## hidden: 5    thresh: 0.01    rep: 5/5    steps:    3582  error: 0.26375  time: 0.34 secs</code>

<code>## Warning: algorithm did not converge in 1 of 5 repetition(s) within the
## stepmax</code>

Visualize the neural network

<code>plot(sin.nn, rep = "best")</code>

Generate data for the prediction of the using the neural net;

<code>testdata&lt;- as.data.frame(runif(10, min=0, max=(4*pi)))
testdata</code>

<code>##    runif(10, min = 0, max = (4 * pi))
## 1                         1.564816433
## 2                         4.692188270
## 3                        10.942269605
## 4                        11.432769193
## 5                         1.528565797
## 6                         4.277983023
## 7                         7.863112004
## 8                         3.233025098
## 9                         4.212822393
## 10                       11.584672483</code>

Calculate the real value using the <code>sin</code> function

<code>testdata.result &lt;- sin(testdata)</code>

Make the prediction

<code>sin.nn.result &lt;- compute(sin.nn, testdata)
sin.nn.result$net.result</code>

<code>##                 [,1]
##  [1,]  1.04026644587
##  [2,] -0.99122081475
##  [3,] -0.77154683268
##  [4,] -0.80702735515
##  [5,]  1.03394587608
##  [6,] -0.91997356615
##  [7,]  1.02031970677
##  [8,] -0.08226873533
##  [9,] -0.89463523567
## [10,] -0.81283835083</code>

Compare with the real values:

<code>better &lt;- cbind(testdata, sin.nn.result$net.result, testdata.result, (sin.nn.result$net.result-testdata.result))
colnames(better) &lt;- c("Input", "NN Result", "Result", "Error")

better</code>

<code>##           Input      NN Result         Result           Error
## 1   1.564816433  1.04026644587  0.99998212049  0.040284325379
## 2   4.692188270 -0.99122081475 -0.99979597259  0.008575157839
## 3  10.942269605 -0.77154683268 -0.99857964177  0.227032809091
## 4  11.432769193 -0.80702735515 -0.90594290260  0.098915547446
## 5   1.528565797  1.03394587608  0.99910842368  0.034837452408
## 6   4.277983023 -0.91997356615 -0.90712021799 -0.012853348159
## 7   7.863112004  1.02031970677  0.99995831846  0.020361388309
## 8   3.233025098 -0.08226873533 -0.09130510334  0.009036368006
## 9   4.212822393 -0.89463523567 -0.87779026852 -0.016844967152
## 10 11.584672483 -0.81283835083 -0.83144207031  0.018603719479</code>

Calculate the RMSE:

<code>library(Metrics)
rmse(better$Result, better$`NN Result`)</code>

<code>## [1] 0.08095028855</code>

Plot the results:

<code>plot(x,y)
plot(sin, 0, (4*pi), add=T)
x1 &lt;- seq(0, 4*pi, by=0.1)
lines(x1, compute(sin.nn, data.frame(x=x1))$net.result, col="green")</code>


<h3>A classification problem</h3>
Using the <code>iris</code> dataset

<code>data(iris)
iris.dataset &lt;- iris</code>

Check what is inside the dataset:

<code>head(iris.dataset)</code>

<code>##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1          5.1         3.5          1.4         0.2  setosa
## 2          4.9         3.0          1.4         0.2  setosa
## 3          4.7         3.2          1.3         0.2  setosa
## 4          4.6         3.1          1.5         0.2  setosa
## 5          5.0         3.6          1.4         0.2  setosa
## 6          5.4         3.9          1.7         0.4  setosa</code>

Change the dataset so we are able to predict classes:

<code>iris.dataset$setosa &lt;- iris.dataset$Species=="setosa"
iris.dataset$virginica = iris.dataset$Species == "virginica"
iris.dataset$versicolor = iris.dataset$Species == "versicolor"</code>

Separate into train and test data:

<code>train &lt;- sample(x = nrow(iris.dataset), size = nrow(iris)*0.5)
train</code>

<code>##  [1] 116   3 137 124 100  48  28 123  99  54 129 128  96  11  97 115  53
## [18]   8 133  85  91  70  60  45 113 119  69 126 114  86 109 140  58  13
## [35]  77  57   7  61   9 111 141  39 120  98 104  88  83 106  20 147  74
## [52] 122  93  72  73 146   4  38   1  22 118 103  51  21  80  82  25  78
## [69] 148 143  14  50  23  84  40</code>

<code>iristrain &lt;- iris.dataset[train,]
irisvalid &lt;- iris.dataset[-train,]
print(nrow(iristrain))</code>

<code>## [1] 75</code>

<code>print(nrow(irisvalid))</code>

<code>## [1] 75</code>

Build the Neural Network for the classification:

<code>nn &lt;- neuralnet(setosa+versicolor+virginica ~ Sepal.Length + Sepal.Width, data=iristrain, hidden=3,  
                rep = 2, err.fct = "ce", linear.output = F, lifesign = "minimal", stepmax = 1000000)</code>

<code>## hidden: 3    thresh: 0.01    rep: 1/2    steps:   77918  error: 54.96826 time: 9.41 secs
## hidden: 3    thresh: 0.01    rep: 2/2    steps:   53687  error: 54.24648 time: 6.25 secs</code>

Let’s check the neural network that we just built

<code>plot(nn, rep="best")</code>

Let’s try to make the prediction:

<code>comp &lt;- compute(nn, irisvalid[-3:-8])
pred.weights &lt;- comp$net.result
idx &lt;- apply(pred.weights, 1, which.max)
pred &lt;- c('setosa', 'versicolor', 'virginica')[idx]
table(pred, irisvalid$Species)</code>

<code>##             
## pred         setosa versicolor virginica
##   setosa         28          0         0
##   versicolor      1         13         5
##   virginica       0          9        19</code>

<h3>AND operation</h3>
<code>AND &lt;- c(rep(0,3),1)
OR &lt;- c(0,rep(1,3))
binary.data &lt;- data.frame(expand.grid(c(0,1), c(0,1)), AND)
net &lt;- neuralnet(AND~Var1+Var2, binary.data, hidden=0, rep=10, err.fct="ce", linear.output=FALSE)
</code>

Now to validate the predictions:

<code>input &lt;- data.frame(expand.grid(c(0,1), c(0,1)))
net.results &lt;- compute(net, input)
cbind(round(net.results$net.result), AND)</code>

<code>##        AND
## [1,] 0   0
## [2,] 0   0
## [3,] 0   0
## [4,] 1   1</code>

<h3>sqrt example</h3>
inputData = as.data.frame(runif(550,0,100))
outputData = sqrt(inputData)
trainData = cbind(inputData, outputData)
colnames(trainData) = c("In","Out")
sqrtModel = neuralnet(Out~In,trainData,hidden = 10, threshold = 0.01)

testData = as.data.frame((0.5:9)^2)
testResult = compute(sqrtModel, testData)
testResult$net.result
testResult$net.result^2
pctError = 100-(100*testResult$net.result^2/testData)


<h2>neuralnet examples</h2>
<a href="https://www.rdocumentation.org/packages/neuralnet/versions/1.44.2/topics/neuralnet" class="whitebut ">neuralnet: Training of neural networks</a>
<a href="https://www.datacamp.com/community/tutorials/neural-network-models-r" class="whitebut ">Neural Network Models Activation Functions</a>
<a href="https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781788397872/1/ch01lvl1sec24/simple-example-using-r-neural-net-library-neuralnet" class="whitebut ">Simple example neuralnet()</a>
<a href="https://www.r-bloggers.com/2015/09/fitting-a-neural-network-in-r-neuralnet-package/" class="whitebut ">Fitting a neural network</a>
<a href="https://rstudio-pubs-static.s3.amazonaws.com/341320_a4aea4aa0f6c47f2b7242e0bee322683.html" class="whitebut ">Neural Net Package Examples</a>
<a href="https://www.r-bloggers.com/2015/09/fitting-a-neural-network-in-r-neuralnet-package/" class="whitebut ">Fitting a neural network</a>
<a href="https://medium.com/@brscntyz/neural-network-in-r-e275302b6e44" class="whitebut ">Neural Network in R</a>
<a href="https://www.analyticsvidhya.com/blog/2017/09/creating-visualizing-neural-network-in-r/" class="whitebut ">Creating & Visualizing Neural Network in R</a>

Examples
require(neuralnet)
TKS=c(20,10,30,20,80,30,10,30,20,80,30,30,10,30,20,80,30,30)
CSS=c(90,20,40,50,50,80,50,50,80,50,50,20,40,50,50,80,50,50)
Placed=c(1,0,0,0,1,1)
df=data.frame(TKS,CSS,Placed)

nn=neuralnet(
   Placed~TKS+CSS,
   data=df, hidden=3, act.fct = "logistic",
   linear.output = FALSE)

TKS=c(10,20,55,25,30,20)
CSS=c(15,50,30,35,20,80)
test=data.frame(TKS,CSS)

Predict=compute(nn,test)
ifelse(Predict$net.result>0.5, 1, 0)

Examples
# Binary classification
nn <- neuralnet(Species == "setosa" ~ Petal.Length + Petal.Width, iris, linear.output = FALSE)

# Multiclass classification
nn <- neuralnet(Species ~ Petal.Length + Petal.Width, iris, linear.output = FALSE)

# Custom activation function
softplus <- function(x) log(1 + exp(x))
nn <- neuralnet((Species == "setosa") ~ Petal.Length + Petal.Width, iris, 
                linear.output = FALSE, hidden = c(3, 2), act.fct = softplus)


<h2>Commonly used Machine Learning Algorithms (with Python and R Codes)</h2>
<h3>Overview</h3>
1. Linear Regression
2. Logistic Regression
3. Decision Tree
4. SVM (Support Vector Machine)
5. Naive Bayes
6. kNN (k- Nearest Neighbors)
7. K-Means
8. Random Forest
9. Dimensionality Reduction Algorithms
10. Gradient Boosting Algorithms

Major focus on commonly used <a href="https://www.analyticsvidhya.com/machine-learning/?utm_source=blog&utm_medium=commonly-used-machine-learning-algorithms" target="_blank" rel="noopener noreferrer">machine learning</a> algorithms
Algorithms covered- Linear regression, logistic regression, Naive Bayes, kNN, Random forest, etc.
Learn both theory and implementation of these algorithms in R and python

<h3>Introduction</h3>
We are probably living in the most defining period of human history. 
The period when computing moved from large mainframes to PCs to cloud. 
But what makes it defining is not what has happened, but what is coming our way in years to come.

What makes this period exciting and enthralling for someone like me is the democratization of the various tools and techniques, which followed the boost in computing. 
Welcome to the world of <a href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2/?utm_source=blog&utm_medium=essentialMLalgorithmsarticle">data science</a>!

Today, as a data scientist, I can build data-crunching machines with complex algorithms for a few dollars per hour. 
But reaching here wasn't easy! I had my dark days and nights.

<em>Are you a beginner looking for a place to start your data science journey? Presenting two comprehensive courses, full of knowledge and data science learning, curated just for you to learn data science (using Python) from scratch:</em>

<em><a href="https://courses.analyticsvidhya.com/courses/introduction-to-data-science-2/?utm_source=blog&utm_medium=essentialMLalgorithmsarticle" target="_blank" rel="noopener noreferrer">Introduction to Data Science</a></em>
<em><a href="https://courses.analyticsvidhya.com/bundles/data-science-beginners-with-interview" target="_blank" rel="noopener noreferrer">Certified Program: Data Science for Beginners (with Interviews)</a></em>

<h3>Who can benefit the most from this guide?</h3>
<h5>What I am giving out today is probably the most valuable guide, I have ever created.</h5>

The idea behind creating this guide is to simplify the journey of aspiring data scientists and <a href="https://www.analyticsvidhya.com/machine-learning/?utm_source=blog&utm_medium=commonly-used-machine-learning-algorithms" target="_blank" rel="noopener noreferrer">machine learning</a> enthusiasts across the world. 
Through this guide, I will enable you to work on machine learning problems and gain from experience. 
<k>I am providing a high-level understanding of various machine learning algorithms along with R & Python codes to run them. 
These should be sufficient to get your hands dirty.</k>

Essentials of machine learning algorithms with implementation in R and Python

I have deliberately skipped the statistics behind these techniques, as you don't need to understand them at the start. 
So, if you are looking for statistical understanding of these algorithms, you should look elsewhere. 
But, if you are looking to equip yourself to start building machine learning project, you are in for a treat.

<h3>Broadly, there are 3 <a href="https://www.analyticsvidhya.com/machine-learning/?utm_source=blog&utm_medium=commonly-used-machine-learning-algorithms" target="_blank" rel="noopener noreferrer">types of Machine Learning</a> Algorithms</h3>
<h4>1. Supervised Learning</h4>

<k>How it works:</k> This algorithm consist of a target / outcome variable (or dependent variable) which is to be predicted from a given set of predictors (independent variables). 
Using these set of variables, we generate a function that map inputs to desired outputs. 
The training process continues until the model achieves a desired level of accuracy on the training data. 
Examples of Supervised Learning: Regression, <a href="https://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="noopener noreferrer">Decision Tree</a>, <a href="https://www.analyticsvidhya.com/blog/2014/06/introduction-random-forest-simplified/" target="_blank" rel="noopener noreferrer">Random Forest</a>, KNN, Logistic Regression etc.

<h4>2. Unsupervised Learning</h4>

<k>How it works: </k>In this algorithm, we do not have any target or outcome variable to predict / estimate. 
It is used for clustering population in different groups, which is widely used for segmenting customers in different groups for specific intervention. 
Examples of Unsupervised Learning: Apriori algorithm, K-means.

<h4>3. Reinforcement Learning:</h4>

<k>How it works:</k> Using this algorithm, the machine is trained to make specific decisions. 
It works this way: the machine is exposed to an environment where it trains itself continually using trial and error. 
This machine learns from past experience and tries to capture the best possible knowledge to make accurate business decisions. 
Example of Reinforcement Learning: Markov Decision Process

<h3><k>List of Common Machine Learning Algorithms</k></h3>
Here is the list of commonly used machine learning algorithms. 
These algorithms can be applied to almost any data problem:

Linear Regression
Logistic Regression
Decision Tree
SVM
Naive Bayes
kNN
K-Means
Random Forest
Dimensionality Reduction Algorithms
Gradient Boosting algorithms
GBM
XGBoost
LightGBM
CatBoost

<h3>1. Linear Regression</h3>
It is used to estimate real values (cost of houses, number of calls, total sales etc.) based on continuous variable(s). 
Here, we establish relationship between independent and dependent variables by fitting a best line. 
This best fit line is known as regression line and represented by a linear equation Y= a *X + b.

The best way to understand linear regression is to relive this experience of childhood. 
Let us say, you ask a child in fifth grade to arrange people in his class by increasing order of weight, without asking them their weights! What do you think the child will do? He / she would likely look (visually analyze) at the height and build of people and arrange them using a combination of these visible parameters. 
This is linear regression in real life! The child has actually figured out that height and build would be correlated to the weight by a relationship, which looks like the equation above.

In this equation:

Y – Dependent Variable
a – Slope
X – Independent variable
b – Intercept

These coefficients a and b are derived based on minimizing the sum of squared difference of distance between data points and regression line.

Look at the below example. 
Here we have identified the best fit line having linear equation <k>y=0.2811x+13.9</k>. 
Now using this equation, we can find the weight, knowing the height of a person.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/Linear_Regression.png">

Linear Regression is mainly of two types: Simple Linear Regression and Multiple Linear Regression. 
Simple Linear Regression is characterized by one independent variable. 
And, Multiple Linear Regression(as the name suggests) is characterized by multiple (more than 1) independent variables. 
While finding the best fit line, you can fit a polynomial or curvilinear regression. 
And these are known as polynomial or curvilinear regression.

Here's a coding window to try out your hand and build your own linear regression model in Python:

<k>R Code</k>

#Load Train and Test datasets
#Identify feature and response variable(s) and values must be numeric and numpy arrays
x_train &lt;- input_variables_values_training_datasets
y_train &lt;- target_variables_values_training_datasets
x_test &lt;- input_variables_values_test_datasets
x &lt;- cbind(x_train,y_train)
# Train the model using the training sets and check score
linear &lt;- lm(y_train ~ ., data = x)
summary(linear)
#Predict Output
predicted= predict(linear,x_test)

<h3>2. Logistic Regression</h3>
Don't get confused by its name! It is a classification not a regression algorithm. 
It is used to estimate discrete values ( Binary values like 0/1, yes/no, true/false ) based on given set of independent variable(s). 
In simple words, it predicts the probability of occurrence of an event by fitting data to a <a href="https://en.wikipedia.org/wiki/Logistic_function" target="_blank" rel="nofollow noopener noreferrer">logit function</a>. 
Hence, it is also known as <k>logit regression</k>. 
Since, it predicts the probability, its output values lies between 0 and 1 (as expected).

Again, let us try and understand this through a simple example.

Let's say your friend gives you a puzzle to solve. 
There are only 2 outcome scenarios – either you solve it or you don't. 
Now imagine, that you are being given wide range of puzzles / quizzes in an attempt to understand which subjects you are good at. 
The outcome to this study would be something like this – if you are given a trignometry based tenth grade problem, you are 70% likely to solve it. 
On the other hand, if it is grade fifth history question, the probability of getting an answer is only 30%. 
This is what Logistic Regression provides you.

Coming to the math, the log odds of the outcome is modeled as a linear combination of the predictor variables.

odds= p/ (1-p) = probability of event occurrence / probability of not event occurrence
ln(odds) = ln(p/(1-p))
logit(p) = ln(p/(1-p)) = b0+b1X1+b2X2+b3X3....+bkXk

Above, p is the probability of presence of the characteristic of interest. 
It chooses parameters that maximize the likelihood of observing the sample values rather than that minimize the sum of squared errors (like in ordinary regression).

Now, you may ask, why take a log? For the sake of simplicity, let's just say that this is one of the best mathematical way to replicate a step function. 
I can go in more details, but that will beat the purpose of this article.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/Logistic_Regression.png">

<k>R Code</k>

x &lt;- cbind(x_train,y_train)
# Train the model using the training sets and check score
logistic &lt;- glm(y_train ~ ., data = x,family='binomial')
summary(logistic)
#Predict Output
predicted= predict(logistic,x_test)

<h4>Furthermore..</h4>

There are many different steps that could be tried in order to improve the model:

including interaction terms
removing features
<a href="https://www.analyticsvidhya.com/blog/2015/02/avoid-over-fitting-regularization/" target="_blank" rel="noopener noreferrer">regularization techniques</a>
using a non-linear model

<h3>3. Decision Tree</h3>
This is one of my favorite algorithm and I use it quite frequently. 
It is a type of supervised learning algorithm that is mostly used for classification problems. 
Surprisingly, it works for both categorical and continuous dependent variables. 
In this algorithm, we split the population into two or more homogeneous sets. 
This is done based on most significant attributes/ independent variables to make as distinct groups as possible. 
For more details, you can read: <a href="https://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="noopener noreferrer">Decision Tree Simplified</a>.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/IkBzK.png">

source: <a href="http://stats.stackexchange.com" target="_blank" rel="nofollow noopener noreferrer">statsexchange</a>

In the image above, you can see that population is classified into four different groups based on multiple attributes to identify &#8216;if they will play or not'. 
To split the population into different heterogeneous groups, it uses various techniques like Gini, Information Gain, Chi-square, entropy.

The best way to understand how decision tree works, is to play Jezzball – a classic game from Microsoft (image below). 
Essentially, you have a room with moving walls and you need to create walls such that maximum area gets cleared off with out the balls.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/download.jpg">

So, every time you split the room with a wall, you are trying to create 2 different populations with in the same room. 
Decision trees work in very similar fashion by dividing a population in as different groups as possible.

<em>More</em>: <a href="https://www.analyticsvidhya.com/blog/2015/01/decision-tree-simplified/" target="_blank" rel="noopener noreferrer">Simplified Version of Decision Tree Algorithms</a>

<k>R Code</k>

library(rpart)
x &lt;- cbind(x_train,y_train)
# grow tree 
fit &lt;- rpart(y_train ~ ., data = x,method="class")
summary(fit)
#Predict Output 
predicted= predict(fit,x_test)

<h3>4. SVM (Support Vector Machine)</h3>
It is a classification method. 
In this algorithm, we plot each data item as a point in n-dimensional space (where n is number of features you have) with the value of each feature being the value of a particular coordinate.

For example, if we only had two features like Height and Hair length of an individual, we'd first plot these two variables in two dimensional space where each point has two co-ordinates (these co-ordinates are known as <k>Support Vectors</k>)


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/SVM1.png">

Now, we will find some <em>line</em> that splits the data between the two differently classified groups of data. 
This will be the line such that the distances from the closest point in each of the two groups will be farthest away.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/SVM2-300x204.png">

In the example shown above, the line which splits the data into two differently classified groups is the <em>black</em> line, since the two closest points are the farthest apart from the line. 
This line is our classifier. 
Then, depending on where the testing data lands on either side of the line, that's what class we can classify the new data as.

More: <a href="https://www.analyticsvidhya.com/blog/2014/10/support-vector-machine-simplified/" target="_blank" rel="noopener noreferrer">Simplified Version of Support Vector Machine</a>

<k>Think of this algorithm as playing JezzBall in n-dimensional space. 
The tweaks in the game are:</k>

You can draw lines/planes at any angles (rather than just horizontal or vertical as in the classic game)
The objective of the game is to segregate balls of different colors in different rooms.
And the balls are not moving.

<k>R Code</k>

library(e1071)
x &lt;- cbind(x_train,y_train)
# Fitting model
fit &lt;-svm(y_train ~ ., data = x)
summary(fit)
#Predict Output 
predicted= predict(fit,x_test)

<h3>5. Naive Bayes</h3>
It is a classification technique based on <a href="https://en.wikipedia.org/wiki/Bayes%27_theorem" target="_blank" rel="nofollow noopener noreferrer">Bayes’ theorem</a> with an assumption of independence between predictors. 
In simple terms, a Naive Bayes classifier assumes that the presence of a particular feature in a class is unrelated to the presence of any other feature. 
For example, a fruit may be considered to be an apple if it is red, round, and about 3 inches in diameter. 
Even if these features depend on each other or upon the existence of the other features, a naive Bayes classifier would consider all of these properties to independently contribute to the probability that this fruit is an apple.

<a href="https://courses.analyticsvidhya.com/courses/naive-bayes?utm_source=blog&utm_medium=common-machine-learning-algorithms">Naive Bayesian</a> model is easy to build and particularly useful for very large data sets. 
Along with simplicity, Naive Bayes is known to outperform even highly sophisticated classification methods.

Bayes theorem provides a way of calculating posterior probability P(c|x) from P(c), P(x) and P(x|c). 
Look at the equation below:<br />

<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/Bayes_rule-300x172.png">

Here,

<i>P</i>(<i>c|x</i>) is the posterior probability of <i>class</i> (<i>target</i>) given <i>predictor</i> (<i>attribute</i>). 

<i>P</i>(<i>c</i>) is the prior probability of <i>class</i>. 

<i>P</i>(<i>x|c</i>) is the likelihood which is the probability of <i>predictor</i> given <i>class</i>. 

<i>P</i>(<i>x</i>) is the prior probability of <i>predictor</i>.

<k>Example: </k>Let's understand it using an example. 
Below I have a training data set of weather and corresponding target variable &#8216;Play'. 
Now, we need to classify whether players will play or not based on weather condition. 
Let's follow the below steps to perform it.

Step 1: Convert the data set to frequency table

Step 2: Create Likelihood table by finding the probabilities like Overcast probability = 0.29 and probability of playing is 0.64.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/Bayes_41.png">

Step 3: Now, use Naive Bayesian equation to calculate the posterior probability for each class. 
The class with the highest posterior probability is the outcome of prediction.

<k>Problem: </k>Players will pay if weather is sunny, is this statement is correct?

We can solve it using above discussed method, so P(Yes | Sunny) = P( Sunny | Yes) * P(Yes) / P (Sunny)

Here we have P (Sunny |Yes) = 3/9 = 0.33, P(Sunny) = 5/14 = 0.36, P( Yes)= 9/14 = 0.64

Now, P (Yes | Sunny) = 0.33 * 0.64 / 0.36 = 0.60, which has higher probability.

<a href="https://courses.analyticsvidhya.com/courses/naive-bayes?utm_source=blog&utm_medium=common-machine-learning-algorithms">Naive Bayes</a> uses a similar method to predict the probability of different class based on various attributes. 
This algorithm is mostly used in text classification and with problems having multiple classes.

<k>R Code</k>

library(e1071)
x &lt;- cbind(x_train,y_train)
# Fitting model
fit &lt;-naiveBayes(y_train ~ ., data = x)
summary(fit)
#Predict Output 
predicted= predict(fit,x_test)

<h3>6. kNN (k- Nearest Neighbors)</h3>
It can be used for both classification and regression problems. 
However, it is more widely used in classification problems in the industry. 
K nearest neighbors is a simple algorithm that stores all available cases and classifies new cases by a majority vote of its k neighbors. 
The case being assigned to the class is most common amongst its K nearest neighbors measured by a distance function.

These distance functions can be Euclidean, Manhattan, Minkowski and Hamming distance. 
First three functions are used for continuous function and fourth one (Hamming) for categorical variables. 
If K = 1, then the case is simply assigned to the class of its nearest neighbor. 
At times, choosing K turns out to be a challenge while performing kNN modeling.

More: <a href="http://Introduction to k-nearest neighbors : Simplified">Introduction to k-nearest neighbors : Simplified</a>.


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/KNN.png">

KNN can easily be mapped to our real lives. 
If you want to learn about a person, of whom you have no information, you might like to find out about his close friends and the circles he moves in and gain access to his/her information!

<k>Things to consider before selecting kNN:</k>

KNN is computationally expensive
Variables should be normalized else higher range variables can bias it
Works on pre-processing stage more before going for kNN like an outlier, noise removal

<h5>Python Code</h5>
'''
The following code is for the K-Nearest Neighbors
Created by - ANALYTICS VIDHYA
'''
# importing required libraries
import pandas as pd
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

# read the train and test dataset
train_data = pd.read_csv('train-data.csv')
test_data = pd.read_csv('test-data.csv')

# shape of the dataset
print('Shape of training data :',train_data.shape)
print('Shape of testing data :',test_data.shape)

# Now, we need to predict the missing target variable in the test data
# target variable - Survived

# seperate the independent and target variable on training data
train_x = train_data.drop(columns=['Survived'],axis=1)
train_y = train_data['Survived']

# seperate the independent and target variable on testing data
test_x = test_data.drop(columns=['Survived'],axis=1)
test_y = test_data['Survived']

'''
Create the object of the K-Nearest Neighbor model
You can also add other parameters and test your code here
Some parameters are : n_neighbors, leaf_size
Documentation of sklearn K-Neighbors Classifier: 

https://scikit-learn.org/stable/modules/generated/sklearn.neighbors.KNeighborsClassifier.html

 '''
model = KNeighborsClassifier()  

# fit the model with the training data
model.fit(train_x,train_y)

# Number of Neighbors used to predict the target
print('\nThe number of neighbors used to predict the target : ',model.n_neighbors)

# predict the target on the train dataset
predict_train = model.predict(train_x)
print('\nTarget on train data',predict_train) 

# Accuray Score on train dataset
accuracy_train = accuracy_score(train_y,predict_train)
print('accuracy_score on train dataset : ', accuracy_train)

# predict the target on the test dataset
predict_test = model.predict(test_x)
print('Target on test data',predict_test) 

# Accuracy Score on test dataset
accuracy_test = accuracy_score(test_y,predict_test)
print('accuracy_score on test dataset : ', accuracy_test)
<k>R Code</k>

library(knn)
x &lt;- cbind(x_train,y_train)
# Fitting model
fit &lt;-knn(y_train ~ ., data = x,k=5)
summary(fit)
#Predict Output 
predicted= predict(fit,x_test)

<h3>7. K-Means</h3>
It is a type of unsupervised algorithm which solves the clustering problem. 
Its procedure follows a simple and easy way to classify a given data set through a certain number of clusters (assume k clusters). 
Data points inside a cluster are homogeneous and heterogeneous to peer groups.

Remember figuring out shapes from ink blots? k means is somewhat similar this activity. 
You look at the shape and spread to decipher how many different clusters / population are present!


<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/splatter_ink_blot_texture_by_maki_tak-d5p6zph-284x300.jpg">

<k>How K-means forms cluster:</k>

K-means picks k number of points for each cluster known as centroids.
Each data point forms a cluster with the closest centroids i.e. k clusters.
Finds the centroid of each cluster based on existing cluster members. 
Here we have new centroids.
As we have new centroids, repeat step 2 and 3. 
Find the closest distance for each data point from new centroids and get associated with new k-clusters. 
Repeat this process until convergence occurs i.e. centroids does not change.

<k>How to determine value of K:</k>

In K-means, we have clusters and each cluster has its own centroid. 
Sum of square of difference between centroid and the data points within a cluster constitutes within sum of square value for that cluster. 
Also, when the sum of square values for all the clusters are added, it becomes total within sum of square value for the cluster solution.

We know that as the number of cluster increases, this value keeps on decreasing but if you plot the result you may see that the sum of squared distance decreases sharply up to some value of k, and then much more slowly after that. 
Here, we can find the optimum number of cluster.

<img class="lazy" data-src="https://www.analyticsvidhya.com/wp-content/uploads/2015/08/Kmenas-1024x516.png">

<k>R Code</k>

library(cluster)
fit &lt;- kmeans(X, 3) # 5 cluster solution

<h3>8. Random Forest</h3>
Random Forest is a trademark term for an ensemble of decision trees. 
In Random Forest, we've collection of decision trees (so known as &#8220;Forest&#8221;). 
To classify a new object based on attributes, each tree gives a classification and we say the tree &#8220;votes&#8221; for that class. 
The forest chooses the classification having the most votes (over all the trees in the forest).

Each tree is planted & grown as follows:

If the number of cases in the training set is N, then sample of N cases is taken at random but <em>with replacement</em>. 
This sample will be the training set for growing the tree.
If there are M input variables, a number m&lt;&lt;M is specified such that at each node, m variables are selected at random out of the M and the best split on these m is used to split the node. 
The value of m is held constant during the forest growing.
Each tree is grown to the largest extent possible. 
There is no pruning.

For more details on this algorithm, comparing with decision tree and tuning model parameters, I would suggest you to read these articles:

<a href="https://www.analyticsvidhya.com/blog/2014/06/introduction-random-forest-simplified/">Introduction to Random forest – Simplified</a>

<a href="https://www.analyticsvidhya.com/blog/2014/06/comparing-cart-random-forest-1/">Comparing a CART model to Random Forest (Part 1)</a>

<a href="https://www.analyticsvidhya.com/blog/2014/06/comparing-random-forest-simple-cart-model/">Comparing a Random Forest to a CART model (Part 2)</a>

<a href="https://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/">Tuning the parameters of your Random Forest model</a>

<k>R Code</k>

library(randomForest)
x &lt;- cbind(x_train,y_train)
# Fitting model
fit &lt;- randomForest(Species ~ ., x,ntree=500)
summary(fit)
#Predict Output 
predicted= predict(fit,x_test)

<h3>9. Dimensionality Reduction Algorithms</h3>
In the last 4-5 years, there has been an exponential increase in data capturing at every possible stages. 
Corporates/ Government Agencies/ Research organisations are not only coming with new sources but also they are capturing data in great detail.

For example: E-commerce companies are capturing more details about customer like their demographics, web crawling history, what they like or dislike, purchase history, feedback and many others to give them personalized attention more than your nearest grocery shopkeeper.

As a data scientist, the data we are offered also consist of many features, this sounds good for building good robust model but there is a challenge. 
How'd you identify highly significant variable(s) out 1000 or 2000? In such cases, dimensionality reduction algorithm helps us along with various other algorithms like Decision Tree, Random Forest, PCA, Factor Analysis, Identify based on correlation matrix, missing value ratio and others.

To know more about this algorithms, you can read &#8220;<a href="https://www.analyticsvidhya.com/blog/2015/07/dimension-reduction-methods/">Beginners Guide To Learn Dimension Reduction Techniques</a>&#8220;.

library(stats)
pca &lt;- princomp(train, cor = TRUE)
train_reduced  &lt;- predict(pca,train)
test_reduced  &lt;- predict(pca,test)

<h3>10. Gradient Boosting Algorithms</h3>
<h4>10.1. 
GBM</h4>

GBM is a boosting algorithm used when we deal with plenty of data to make a prediction with high prediction power. 
Boosting is actually an ensemble of learning algorithms which combines the prediction of several base estimators in order to improve robustness over a single estimator. 
It combines multiple weak or average predictors to a build strong predictor. 
These boosting algorithms always work well in data science competitions like Kaggle, AV Hackathon, CrowdAnalytix.

More: <a href="https://www.analyticsvidhya.com/blog/2015/05/boosting-algorithms-simplified/" target="_blank" rel="noopener noreferrer">Know about Boosting algorithms in detail</a>

library(caret)
x &lt;- cbind(x_train,y_train)
# Fitting model
fitControl &lt;- trainControl( method = "repeatedcv", number = 4, repeats = 4)
fit &lt;- train(y ~ ., data = x, method = "gbm", trControl = fitControl,verbose = FALSE)
predicted= predict(fit,x_test,type= "prob")[,2] 

GradientBoostingClassifier and Random Forest are two different boosting tree classifier and often people ask about the <a href="http://discuss.analyticsvidhya.com/t/what-is-the-fundamental-difference-between-randomforest-and-gradient-boosting-algorithms/2341" target="_blank" rel="noopener noreferrer">difference between these two algorithms</a>.

<h4>10.2. 
XGBoost</h4>

Another classic gradient boosting algorithm that's known to be the decisive choice between winning and losing in some Kaggle competitions.

The XGBoost has an immensely high predictive power which makes it the best choice for accuracy in events as it possesses both linear model and the tree learning algorithm, making the algorithm almost 10x faster than existing gradient booster techniques.

The support includes various objective functions, including regression, classification and ranking.

One of the most interesting things about the XGBoost is that it is also called a regularized boosting technique. 
This helps to reduce overfit modelling and has a massive support for a range of languages such as Scala, Java, R, Python, Julia and C++.

Supports distributed and widespread training on many machines that encompass GCE, AWS, Azure and Yarn clusters. 
XGBoost can also be integrated with Spark, Flink and other cloud dataflow systems with a built in cross validation at each iteration of the boosting process.

To learn more about XGBoost and parameter tuning, visit <a href="https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/">https://www.analyticsvidhya.com/blog/2016/03/complete-guide-parameter-tuning-xgboost-with-codes-python/</a>.

require(caret)
x &lt;- cbind(x_train,y_train)

# Fitting model
TrainControl &lt;- trainControl( method = "repeatedcv", number = 10, repeats = 4)

model&lt;- train(y ~ ., data = x, method = "xgbLinear", trControl = TrainControl,verbose = FALSE)

OR 

model&lt;- train(y ~ ., data = x, method = "xgbTree", trControl = TrainControl,verbose = FALSE)

predicted &lt;- predict(model, x_test)

<h4>10.3. LightGBM</h4>

LightGBM is a gradient boosting framework that uses tree based learning algorithms. 
It is designed to be distributed and efficient with the following advantages:

Faster training speed and higher efficiency
Lower memory usage
Better accuracy
Parallel and GPU learning supported
Capable of handling large-scale data

The framework is a fast and high-performance gradient boosting one based on decision tree algorithms, used for ranking, classification and many other machine learning tasks. 
It was developed under the Distributed Machine Learning Toolkit Project of Microsoft.

Since the LightGBM is based on decision tree algorithms, it splits the tree leaf wise with the best fit whereas other boosting algorithms split the tree depth wise or level wise rather than leaf-wise. 
So when growing on the same leaf in Light GBM, the leaf-wise algorithm can reduce more loss than the level-wise algorithm and hence results in much better accuracy which can rarely be achieved by any of the existing boosting algorithms.

Also, it is surprisingly very fast, hence the word &#8216;Light'.

Refer to the article to know more about LightGBM: <a href="https://www.analyticsvidhya.com/blog/2017/06/which-algorithm-takes-the-crown-light-gbm-vs-xgboost/">https://www.analyticsvidhya.com/blog/2017/06/which-algorithm-takes-the-crown-light-gbm-vs-xgboost/</a>

Python Code:

data = np.random.rand(500, 10) # 500 entities, each contains 10 features
label = np.random.randint(2, size=500) # binary target

train_data = lgb.Dataset(data, label=label)
test_data = train_data.create_valid('test.svm')

param = {'num_leaves':31, 'num_trees':100, 'objective':'binary'}
param['metric'] = 'auc'

num_round = 10
bst = lgb.train(param, train_data, num_round, valid_sets=[test_data])

bst.save_model('model.txt')

# 7 entities, each contains 10 features
data = np.random.rand(7, 10)
ypred = bst.predict(data)

R Code:

library(RLightGBM)
data(example.binary)
#Parameters

num_iterations &lt;- 100
config &lt;- list(objective = "binary",  metric="binary_logloss,auc", learning_rate = 0.1, num_leaves = 63, tree_learner = "serial", feature_fraction = 0.8, bagging_freq = 5, bagging_fraction = 0.8, min_data_in_leaf = 50, min_sum_hessian_in_leaf = 5.0)

#Create data handle and booster
handle.data &lt;- lgbm.data.create(x)

lgbm.data.setField(handle.data, "label", y)

handle.booster &lt;- lgbm.booster.create(handle.data, lapply(config, as.character))

#Train for num_iterations iterations and eval every 5 steps

lgbm.booster.train(handle.booster, num_iterations, 5)

#Predict
pred &lt;- lgbm.booster.predict(handle.booster, x.test)

#Test accuracy
sum(y.test == (y.pred > 0.5)) / length(y.test)

#Save model (can be loaded again via lgbm.booster.load(filename))
lgbm.booster.save(handle.booster, filename = "/tmp/model.txt")

If you're familiar with the Caret package in R, this is another way of implementing the LightGBM.

require(caret)
require(RLightGBM)
data(iris)

model &lt;-caretModel.LGBM()

fit &lt;- train(Species ~ ., data = iris, method=model, verbosity = 0)
print(fit)
y.pred &lt;- predict(fit, iris[,1:4])

library(Matrix)
model.sparse &lt;- caretModel.LGBM.sparse()

#Generate a sparse matrix
mat &lt;- Matrix(as.matrix(iris[,1:4]), sparse = T)
fit &lt;- train(data.frame(idx = 1:nrow(iris)), iris$Species, method = model.sparse, matrix = mat, verbosity = 0)
print(fit)

<h4>10.4. Catboost</h4>

CatBoost is a recently open-sourced machine learning algorithm from Yandex. 
It can easily integrate with deep learning frameworks like Google's TensorFlow and Apple's Core ML.

The best part about CatBoost is that it does not require extensive data training like other ML models, and can work on a variety of data formats; not undermining how robust it can be.

Make sure you handle missing data well before you proceed with the implementation.

Catboost can automatically deal with categorical variables without showing the type conversion error, which helps you to focus on tuning your model better rather than sorting out trivial errors.

Learn more about Catboost from this article: <a href="https://www.analyticsvidhya.com/blog/2017/08/catboost-automated-categorical-data/">https://www.analyticsvidhya.com/blog/2017/08/catboost-automated-categorical-data/</a>

Python Code:

import pandas as pd
import numpy as np

from catboost import CatBoostRegressor

#Read training and testing files
train = pd.read_csv("train.csv")
test = pd.read_csv("test.csv")

#Imputing missing values for both train and test
train.fillna(-999, inplace=True)
test.fillna(-999,inplace=True)

#Creating a training set for modeling and validation set to check model performance
X = train.drop(['Item_Outlet_Sales'], axis=1)
y = train.Item_Outlet_Sales

from sklearn.model_selection import train_test_split

X_train, X_validation, y_train, y_validation = train_test_split(X, y, train_size=0.7, random_state=1234)
categorical_features_indices = np.where(X.dtypes != np.float)[0]

#importing library and building model
from catboost import CatBoostRegressormodel=CatBoostRegressor(iterations=50, depth=3, learning_rate=0.1, loss_function='RMSE')

model.fit(X_train, y_train,cat_features=categorical_features_indices,eval_set=(X_validation, y_validation),plot=True)

submission = pd.DataFrame()

submission['Item_Identifier'] = test['Item_Identifier']
submission['Outlet_Identifier'] = test['Outlet_Identifier']
submission['Item_Outlet_Sales'] = model.predict(test)

R Code:

set.seed(1)

require(titanic)

require(caret)

require(catboost)

tt &lt;- titanic::titanic_train[complete.cases(titanic::titanic_train),]

data &lt;- as.data.frame(as.matrix(tt), stringsAsFactors = TRUE)

drop_columns = c("PassengerId", "Survived", "Name", "Ticket", "Cabin")

x &lt;- data[,!(names(data) %in% drop_columns)]y &lt;- data[,c("Survived")]

fit_control &lt;- trainControl(method = "cv", number = 4,classProbs = TRUE)

grid &lt;- expand.grid(depth = c(4, 6, 8),learning_rate = 0.1,iterations = 100, l2_leaf_reg = 1e-3,            rsm = 0.95, border_count = 64)

report &lt;- train(x, as.factor(make.names(y)),method = catboost.caret,verbose = TRUE, preProc = NULL,tuneGrid = grid, trControl = fit_control)

print(report)

importance &lt;- varImp(report, scale = FALSE)

print(importance)

<h3>Projects</h3>
Now, its time to take the plunge and actually play with some other real datasets. 
So are you ready to take on the challenge? Accelerate your data science journey with the following Practice Problems:

<table border="1">
<tbody>
<tr><td>

<img class="lazy" data-src="https://cdn.analyticsvidhya.com/wp-content/uploads/2016/01/food_500x250-300x150.jpg"></td><td><a href="https://datahack.analyticsvidhya.com/contest/genpact-machine-learning-hackathon-1/?utm_source=common-machine-learning-algorithms&utm_medium=blog" target="_blank" rel="noopener noreferrer">Practice Problem: Food Demand Forecasting Challenge</a></td><td>Predict the demand of meals for a meal delivery company</td></tr>
<tr><td>

<img class="lazy" data-src="https://cdn.analyticsvidhya.com/wp-content/uploads/2016/01/hr_500x250-300x150.jpg"></td><td><a href="https://datahack.analyticsvidhya.com/contest/wns-analytics-hackathon-2018-1/?utm_source=common-machine-learning-algorithms&utm_medium=blog" target="_blank" rel="noopener noreferrer">Practice Problem: HR Analytics Challenge</a></td><td>Identify the employees most likely to get promoted</td></tr>
<tr><td>

<img class="lazy" data-src="https://cdn.analyticsvidhya.com/wp-content/uploads/2016/01/upvote_500x250-300x150.jpg"></td><td><a href="https://datahack.analyticsvidhya.com/contest/enigma-codefest-machine-learning-1/?utm_source=common-machine-learning-algorithms&utm_medium=blog" target="_blank" rel="noopener noreferrer">Practice Problem: Predict Number of Upvotes</a></td><td>Predict number of upvotes on a query asked at an online question & answer platform</td></tr>
</tbody>
</table>

<h2>Files Manipulation</h2>
Creating Files and Directories
dir.create("new_folder")
file.create("new_text_file.txt")

Copying a file / folder
file.copy("source_file.txt", "destination_folder")

# list all files in current directory
list.files()
 
# list all files in another directory
list.files("C:/path/to/somewhere/else")

# delete a file
unlink("some_file.csv")

# check if a file exists
file.exists("C:/path/to/file/some_file.txt")

Get the base name of a file
basename("C:/path/to/file.txt")

get the directory name of a file
dirname("C:/path/to/file.txt")

Get a file’s extension
library(tools)
file_ext("C:/path/to/file.txt") # returns "txt"

launch a file
shell.exec("C:/path/to/file/some_file.txt")
 
# or file.show to launch a file
file.show("C:/path/to/file/some_file.txt")

file.rename
 file.rename(statusList, paste0(format(Sys.Date(), format="%m%d")," ",format(Sys.time(), "%H%M")," ",statusList))

<h2>loadhistory</h2>
loadhistory(file = ".Rhistory")
savehistory(file = ".Rhistory")

<h4>Basics</h4>
<h2>Vectors, lists, matrices, data frames</h2>

# Goals: A first look at R objects - vectors, lists, matrices, data frames.

# To make vectors "x" "y" "year" and "names"
x = c(2,3,7,9)
y = c(9,7,3,2)
year = 1990:1993
names = c("payal", "shraddha", "kritika", "itida")
# Accessing the 1st and last elements of y --
y[1]
y[length(y)]

# To make a list "person" --
person = list(name="payal", x=2, y=9, year=1990)
person
# Accessing things inside a list --
person$name
person$x

# To make a matrix, pasting together the columns "year" "x" and "y"
# The verb cbind() stands for "column bind"
cbind(year, x, y)

# To make a "data frame", which is a list of vectors of the same length --
D = data.frame(names, year, x, y)
nrow(D)
# Accessing one of these vectors
D$names
# Accessing the last element of this vector
D$names[nrow(D)]
# Or equally,
D$names[length(D$names)]


<h2>Sorting</h2>

# Goal: To do sorting.
#
# The approach here needs to be explained. If `i' is a vector of
# integers, then the data frame D[i,] picks up rows from D based
# on the values found in `i'.
#
# The order() function makes an integer vector which is a correct
# ordering for the purpose of sorting.

D = data.frame(x=c(1,2,3,1), y=c(7,19,2,2))
D

# Sort on x
indexes = order(D$x)
D[indexes,]

# Print out sorted dataset, sorted in reverse by y
D[rev(order(D$y)),]


<h2>Prices and returns</h2>

# Goal: Prices and returns

# I like to multiply returns by 100 so as to have "units in percent".
# In other words, I like it for 5% to be a value like 5 rather than 0.05.

---------------
# I. Simulate random-walk prices, switch between prices & returns.
---------------
# Simulate a time-series of PRICES drawn from a random walk
# where one-period returns are i.i.d. N(mu, sigma^2).
ranrw = function(mu, sigma, p0=100, T=100) {
  cumprod(c(p0, 1 + (rnorm(n=T, mean=mu, sd=sigma)/100)))
}
prices2returns = function(x) {
  100*diff(log(x))
}
returns2prices = function(r, p0=100) {
  c(p0, p0 * exp(cumsum(r/100)))
}

cat("Simulate 25 points from a random walk starting at 1500 --\n")
p = ranrw(0.05, 1.4, p0=1500, T=25)
    # gives you a 25-long series, starting with a price of 1500, where
    # one-period returns are N(0.05,1.4^2) percent.
print(p)

cat("Convert to returns--\n")
r = prices2returns(p)
print(r)

cat("Go back from returns to prices --\n")
goback = returns2prices(r, 1500)
print(goback)

---------------
# II. Plenty of powerful things you can do with returns....
---------------
summary(r); sd(r)                       # summary statistics
plot(density(r))                        # kernel density plot
acf(r)                                  # Autocorrelation function
ar(r)                                   # Estimate a AIC-minimising AR model
Box.test(r, lag=2, type="Ljung")        # Box-Ljung test
library(tseries)
runs.test(factor(sign(r)))              # Runs test
bds.test(r)                             # BDS test.

---------------
# III. Visualisation and the random walk
---------------
# I want to obtain intuition into what kinds of price series can happen,
# given a starting price, a mean return, and a given standard deviation.
# This function simulates out 10000 days of a price time-series at a time,
# and waits for you to click in the graph window, after which a second
# series is painted, and so on. Make the graph window very big and
# sit back and admire.
# The point is to eyeball many series and thus obtain some intuition
# into what the random walk does.
visualisation = function(p0, s, mu, labelstring) {
  N = 10000
  x = (1:(N+1))/250                        # Unit of years
  while (1) {
    plot(x, ranrw(mu, s, p0, N), ylab="Level", log="y",
         type="l", col="red", xlab="Time (years)",
         main=paste("40 years of a process much like", labelstring))
    grid()
    z=locator(1)
  }
}

# Nifty -- assuming sigma of 1.4% a day and E(returns) of 13% a year
visualisation(2600, 1.4, 13/250, "Nifty")

# The numerical values here are used to think about what the INR/USD
# exchange rate would have looked like if it started from 31.37, had
# a mean depreciation of 5% per year, and had the daily vol of a floating
# exchange rate like EUR/USD.
visualisation(31.37, 0.7, 5/365, "INR/USD (NOT!) with daily sigma=0.7")
# This is of course not like the INR/USD series in the real world -
# which is neither a random walk nor does it have a vol of 0.7% a day.

# The numerical values here are used to think about what the USD/EUR
# exchange rate, starting with 1, having no drift, and having the observed
# daily vol of 0.7. (This is about right).
visualisation(1, 0.7, 0, "USD/EUR with no drift")

---------------
# IV. A monte carlo experiment about the runs test
---------------
# Measure the effectiveness of the runs test when faced with an
# AR(1) process of length 100 with a coeff of 0.1
set.seed(101)
one.ts = function() {arima.sim(list(order = c(1,0,0), ar = 0.1), n=100)}
table(replicate(1000, runs.test(factor(sign(one.ts())))$p.value &lt; 0.05))
# We find that the runs test throws up a prob value of below 0.05
# for 91 out of 1000 experiments.
# Wow! :-)
# To understand this, you need to look up the man pages of:
#    set.seed, arima.sim, sign, factor, runs.test, replicate, table.
# e.g. say ?replicate


<h2>Writing functions</h2>

# Goals: To write functions
#        To write functions that send back multiple objects.

# FIRST LEARN ABOUT LISTS --
X = list(height=5.4, weight=54)
print("Use default printing --")
print(X)
print("Accessing individual elements --")
cat("Your height is ", X$height, " and your weight is ", X$weight, "\n")

# FUNCTIONS --
square = function(x) {
  return(x*x)
}
cat("The square of 3 is ", square(3), "\n")

                 # default value of the arg is set to 5.
cube = function(x=5) {
  return(x*x*x);
}
cat("Calling cube with 2 : ", cube(2), "\n")    # will give 2^3
cat("Calling cube        : ", cube(), "\n")     # will default to 5^3.

# LEARN ABOUT FUNCTIONS THAT RETURN MULTIPLE OBJECTS --
powers = function(x) {
  parcel = list(x2=x*x, x3=x*x*x, x4=x*x*x*x);
  return(parcel);
}

X = powers(3);
print("Showing powers of 3 --"); print(X);

# WRITING THIS COMPACTLY (4 lines instead of 7)

powerful = function(x) {
  return(list(x2=x*x, x3=x*x*x, x4=x*x*x*x));
}
print("Showing powers of 3 --"); print(powerful(3));

# In R, the last expression in a function is, by default, what is
# returned. So you could equally just say:
powerful = function(x) {list(x2=x*x, x3=x*x*x, x4=x*x*x*x)}


<h2>Amazing R vector notation</h2>

# Goal: The amazing R vector notation.

cat("EXAMPLE 1: sin(x) for a vector --\n")
# Suppose you have a vector x --
x = c(0.1,0.6,1.0,1.5)

# The bad way --
n = length(x)
r = numeric(n)
for (i in 1:n) {
  r[i] = sin(x[i])
}
print(r)

# The good way -- don't use loops --
print(sin(x))


cat("\n\nEXAMPLE 2: Compute the mean of every row of a matrix --\n")
# Here's another example. It isn't really about R; it's about thinking in
# matrix notation. But still.
# Let me setup a matrix --
N=4; M=100;
r = matrix(runif(N*M), N, M)

# So I face a NxM matrix
#               [r11 r12 ... r1N]
#               [r21 r22 ... r2N]
#               [r32 r32 ... r3N]
# My goal: each column needs to be reduced to a mean.

# Method 1 uses loops:
mean1 = numeric(M)
for (i in 1:M) {
  mean1[i] = mean(r[,i])
}

# Alternatively, just say:
mean2 = rep(1/N, N) %*% r               # Pretty!

# The two answers are the same --
all.equal(mean1,mean2[,])
#
# As an aside, I should say that you can do this directly by using
# the rowMeans() function. But the above is more about pedagogy rather
# than showing you how to get rowmeans.


cat("\n\nEXAMPLE 3: Nelson-Siegel yield curve\n")
# Write this asif you're dealing with scalars --
# Nelson Siegel function
nsz = function(b0, b1, b2, tau, t) {
  tmp = t/tau
  tmp2 = exp(-tmp)
  return(b0 + ((b1+b2)*(1-tmp2)/(tmp)) - (b2*tmp2))
}

timepoints = c(0.01,1:5)

# The bad way:
z = numeric(length(timepoints))
for (i in 1:length(timepoints)) {
  z[i] = nsz(14.084,-3.4107,0.0015,1.8832,timepoints[i])
}
print(z)

# The R way --
print(z = nsz(14.084,-3.4107,0.0015,1.8832,timepoints))


cat("\n\nEXAMPLE 3: Making the NPV of a bond--\n")
# You know the bad way - sum over all cashflows, NPVing each.
# Now look at the R way.
C = rep(100, 6)
nsz(14.084,-3.4107,0.0015,1.8832,timepoints)        # Print interest rates
C/((1.05)^timepoints)                               # Print cashflows discounted &#64; 5%
C/((1 + (0.01*nsz(14.084,-3.4107,0.0015,1.8832,timepoints))^timepoints)) # Using NS instead of 5%
# NPV in two different ways --
C %*% (1 + (0.01*nsz(14.084,-3.4107,0.0015,1.8832,timepoints)))^-timepoints
sum(C * (1 + (0.01*nsz(14.084,-3.4107,0.0015,1.8832,timepoints)))^-timepoints)
# You can drop back to a flat yield curve at 5% easily --
sum(C * 1.05^-timepoints)

# Make a function for NPV --
npv = function(C, timepoints, r) {
  return(sum(C * (1 + (0.01*r))^-timepoints))
}
npv(C, timepoints, 5)

# Bottom line: Here's how you make the NPV of a bond with cashflows C
# at timepoints timepoints when the zero curve is a Nelson-Siegel curve --
npv(C, timepoints, nsz(14.084,-3.4107,0.0015,1.8832,timepoints))
# Wow!

# ---------------------------------------------------------------------------
# Elegant vector notation is amazingly fast (in addition to being beautiful)
N = 1e5
x = runif(N, -3,3)
y = runif(N)

method1 = function(x,y) {
  tmp = NULL
  for (i in 1:N) {
    if (x[i] &lt; 0) tmp = c(tmp, y[i])
  }
  tmp
}

method2 = function(x,y) {
  y[x &lt; 0]
}

s1 = system.time(ans1 = method1(x,y))
s2 = system.time(ans2 = method2(x,y))
all.equal(ans1,ans2)
s1/s2           # On my machine it's 2000x faster


<h2>Amazing R indexing notation</h2>

# Goal: To show amazing R indexing notation, and the use of is.na()

x = c(2,7,9,2,NA,5)                 # An example vector to play with.

# Give me elems 1 to 3 --
x[1:3]

# Give me all but elem 1 --
x[-1]

# Odd numbered elements --
indexes = seq(1,6,2)
x[indexes]
# or, more compactly,
x[seq(1,6,2)]

# Access elements by specifying "on" / "off" through booleans --
require = c(TRUE,TRUE,FALSE,FALSE,FALSE,FALSE)
x[require]
# Short vectors get reused! So, to get odd numbered elems --
x[c(TRUE,FALSE)]

# Locate missing data --
is.na(x)

# Replace missing data by 0 --
x[is.na(x)] = 0
x

# Similar ideas work for matrices --
y = matrix(c(2,7,9,2,NA,5), nrow=2)
y

# Make a matrix containing columns 1 and 3 --
y[,c(1,3)]

# Let us see what is.na(y) does --
is.na(y)
str(is.na(y))
# So is.na(y) gives back a matrix with the identical structure as that of y.
# Hence I can say
y[is.na(y)] = -1
y


<h2>Making latex tabular objects</h2>

# Goal: To make latex tabular out of an R matrix

# Setup a nice R object:
m = matrix(rnorm(8), nrow=2)
rownames(m) = c("Age", "Weight")
colnames(m) = c("Person1", "Person2", "Person3", "Person4")
m

# Translate it into a latex tabular:
library(xtable)
xtable(m, digits=rep(3,5))

# Production latex code that goes into a paper or a book --
print(xtable(m,
             caption="String",
             label="t:"),
             type="latex",
             file="blah.gen",
             table.placement="tp",
             latex.environments=c("center", "footnotesize"))
# Now you do \input{blah.gen} in your latex file.
# You're lazy, and want to use R to generate latex tables for you?
data = cbind(
              c(7,9,11,2),
              c(2,4,19,21)
              )
colnames(data) = c("a","b")
rownames(data) = c("x","y","z","a")
xtable(data)

# or you could do
data = rbind(
              c(7,2),
              c(9,4),
              c(11,19),
              c(2,21)
              )
# and the rest goes through identically.


<h2>Associative arrays / hashes</h2>

# Goal: Associative arrays (as in awk) or hashes (as in perl).
#       Or, more generally, adventures in R addressing.

# Here's a plain R vector:
x = c(2,3,7,9)
# But now I tag every elem with labels:
names(x) = c("kal","sho","sad","aja")
# Associative array operations:
x["kal"] = 12
# Pretty printing the entire associative array:
x

# This works for matrices too:
m = matrix(runif(10), nrow=5)
rownames(m) = c("violet","indigo","blue","green","yellow")
colnames(m) = c("Asia","Africa")
# The full matrix --
m
# Or even better --
library(xtable)
xtable(m)

# Now address symbolically --
m[,"Africa"]
m["indigo",]
m["indigo","Africa"]

# The "in" operator, as in awk --
for (colour in c("yellow", "orange", "red")) {
  if (colour %in% rownames(m)) {
    cat("For Africa and ", colour, " we have ", m[colour, "Africa"], "\n")
  } else {
    cat("Colour ", colour, " does not exist in the hash.\n")
  }
}

# This works for data frames also --
D = data.frame(m)
D
# Look closely at what happened --
str(D)                                  # The colours are the rownames(D).

# Operations --
D$Africa
D[,"Africa"]
D["yellow",]
# or
subset(D, rownames(D)=="yellow")

colnames(D) = c("Antarctica","America")
D
D$America


<h2>Matrix notation (portfolio computations in financial economics)</h2>

# Goal: Utilise matrix notation
#       We use the problems of portfolio analysis as an example.

# Prices of 4 firms to play with, at weekly frequency (for calendar 2004) --
p = structure(c(300.403, 294.604, 291.038, 283.805, 270.773, 275.506, 292.271, 292.837, 284.872, 295.037, 280.939, 259.574, 250.608, 268.84, 266.507, 263.94, 273.173, 238.609, 230.677, 192.847, 219.078, 201.846, 210.279, 193.281, 186.748, 197.314, 202.813, 204.08, 226.044, 242.442, 261.274, 269.173, 256.05, 259.75, 243, 250.3, 263.45, 279.5, 289.55, 291.95, 302.1, 284.4, 283.5, 287.8, 298.3, 307.6, 307.65, 311.9, 327.7, 318.1, 333.6, 358.9, 385.1, 53.6, 51.95, 47.65, 44.8, 44.85, 44.3, 47.1, 44.2, 41.8, 41.9, 41, 35.3, 33.35, 35.6, 34.55, 35.55, 40.05, 35, 34.85, 28.95, 31, 29.25, 29.05, 28.95, 24.95, 26.15, 28.35, 29.4, 32.55, 37.2, 39.85, 40.8, 38.2, 40.35, 37.55, 39.4, 39.8, 43.25, 44.75, 47.25, 49.6, 47.6, 46.35, 49.4, 49.5, 50.05, 50.5, 51.85, 56.35, 54.15, 58, 60.7, 62.7, 293.687, 292.746, 283.222, 286.63, 259.774, 259.257, 270.898, 250.625, 242.401, 248.1, 244.942, 239.384, 237.926, 224.886, 243.959, 270.998, 265.557, 257.508, 258.266, 257.574, 251.917, 250.583, 250.783, 246.6, 252.475, 266.625, 263.85, 249.925, 262.9, 264.975, 273.425, 275.575, 267.2, 282.25, 284.25, 290.75, 295.625, 296.25, 291.375, 302.225, 318.95, 324.825, 320.55, 328.75, 344.05, 345.925, 356.5, 368.275, 374.825, 373.525, 378.325, 378.6, 374.4, 1416.7, 1455.15, 1380.97, 1365.31, 1303.2, 1389.64, 1344.05, 1266.29, 1265.61, 1312.17, 1259.25, 1297.3, 1327.38, 1250, 1328.03, 1347.46, 1326.79, 1286.54, 1304.84, 1272.44, 1227.53, 1264.44, 1304.34, 1277.65, 1316.12, 1370.97, 1423.35, 1382.5, 1477.75, 1455.15, 1553.5, 1526.8, 1479.85, 1546.8, 1565.3, 1606.6, 1654.05, 1689.7, 1613.95, 1703.25, 1708.05, 1786.75, 1779.75, 1906.35, 1976.6, 2027.2, 2057.85, 2029.6, 2051.35, 2033.4, 2089.1, 2065.2, 2091.7), .Dim = c(53, 4), .Dimnames = list(NULL, c("TISCO", "SAIL", "Wipro", "Infosys")))
# Shift from prices to returns --
r = 100*diff(log(p))

# Historical expected returns --
colMeans(r)
# Historical correlation matrix --
cor(r)
# Historical covariance matrix --
S = cov(r)
S

# Historical portfolio variance for a stated portfolio of 20%,20%,30%,30% --
w = c(.2, .2, .3, .3)
t(w) %*% S %*% w

# The portfolio optimisation function in tseries --
library(tseries)
optimised = portfolio.optim(r)         # This uses the historical facts from r
optimised$pw                            # Weights
optimised$pm                            # Expected return using these weights
optimised$ps                            # Standard deviation of optimised port.


<h2>Handling missing data</h2>

# Goal:
#       A stock is traded on 2 exchanges.
#       Price data is missing at random on both exchanges owing to non-trading.
#       We want to make a single price time-series utilising information
#          from both exchanges. I.e., missing data for exchange 1 will
#          be replaced by information for exchange 2 (if observed).

# Let's create some example data for the problem.
e1 = runif(15)                         # Prices on exchange 1
e2 = e1 + 0.05*rnorm(15)               # Prices on exchange 2.
cbind(e1, e2)
# Blow away 5 points from each at random.
e1[sample(1:15, 5)] = NA
e2[sample(1:15, 5)] = NA
cbind(e1, e2)

# Now how do we reconstruct a time-series that tries to utilise both?
combined = e1                          # Do use the more liquid exchange here.
missing = is.na(combined)
combined[missing] = e2[missing]        # if it's also missing, I don't care.
cbind(e1, e2, combined)
# There you are.



<h4>Reading files</h4>
<h2>Reading a file with a few columns of numbers, and look at what is there.</h2>

# Goal: To read in a simple data file, and look around it's contents.

# Suppose you have a file "x.data" which looks like this:
#        1997,3.1,4
#        1998,7.2,19
#        1999,1.7,2
#        2000,1.1,13
# To read it in --

A = read.table("x.data", sep=",",
                col.names=c("year", "my1", "my2"))
nrow(A)                                 # Count the rows in A

summary(A$year)                         # The column "year" in data frame A
                                        # is accessed as A$year

A$newcol = A$my1 + A$my2               # Makes a new column in A
newvar = A$my1 - A$my2                 # Makes a new R object "newvar"
A$my1 = NULL                           # Removes the column "my1"

# You might find these useful, to "look around" a dataset --
str(A)
summary(A)
library(Hmisc)          # This requires that you've installed the Hmisc package
contents(A)
describe(A)


<h2>Reading a file involving dates</h2>

# Goal: To read in a simple data file where date data is present.

# Suppose you have a file "x.data" which looks like this:
#        1997-07-04,3.1,4
#        1997-07-05,7.2,19
#        1997-07-07,1.7,2
#        1997-07-08,1.1,13

A = read.table("x.data", sep=",",
                col.names=c("date", "my1", "my2"))
A$date = as.Date(A$date, format="%Y-%m-%d")
       # Say ?strptime to learn how to use "%" to specify
       # other date formats. Two examples --
       # "15/12/2002"  needs "%d/%m/%Y"
       # "03 Jun 1997" needs "%d %b %Y"

       # Actually, if you're using the ISO 8601 date format, i.e.        # "%Y-%m-%d", that's the default setting and you don't need to
       # specify the format.

A$newcol = A$my1 + A$my2               # Makes a new column in A
newvar = A$my1 - A$my2                 # Makes a new R object "newvar"
A$my1 = NULL                           # Delete the `my1' column
summary(A)                              # Makes summary statistics


<h2>Reading in a file made by CMIE's <i>Business Beacon</i> program</h2>

# Goal: To read in files produced by CMIE's "Business Beacon".
#       This assumes you have made a file of MONTHLY data using CMIE's
#       Business Beacon program. This contains 2 columns: M3 and M0.

A = read.table(
                # Generic to all BB files --
                sep="|",                # CMIE's .txt file is pipe delimited
                skip=3,                 # Skip the 1st 3 lines
                na.strings=c("N.A.","Err"),  # The ways they encode missing data
                # Specific to your immediate situation --
                file="bb_data.text",
                col.names=c("junk", "date", "M3", "M0")
                )
A$junk = NULL                          # Blow away this column

# Parse the CMIE-style "Mmm yy" date string that's used on monthly data
A$date = as.Date(paste("1", as.character(A$date)), format="%d %b %Y")



Reading and writing both ascii files and binary files. Also, measure speed of these.

# Goal: Reading and writing ascii files, reading and writing binary files.
#       And, to measure how much faster it is working with binary files.

# First manufacture a tall data frame:
                # FYI -- runif(10) yields 10 U(0,1) random numbers.
B = data.frame(x1=runif(100000), x2=runif(100000), x3=runif(100000))
summary(B)

# Write out ascii file:
write.table(B, file = "/tmp/foo.csv", sep = ",", col.names = NA)
# Read in this resulting ascii file:
C=read.table("/tmp/foo.csv", header = TRUE, sep = ",", row.names=1)
# Write a binary file out of dataset C:
save(C, file="/tmp/foo.binary")
# Delete the dataset C:
rm(C)
# Restore from foo.binary:
load("/tmp/foo.binary")
summary(C)                              # should yield the same results
                                        # as summary(B) above.


# Now we time all these operations --
cat("Time creation of dataset:\n")
system.time({
  B = data.frame(x1=runif(100000), x2=runif(100000), x3=runif(100000))
})

cat("Time writing an ascii file out of dataset B:\n")
system.time(
            write.table(B, file = "/tmp/foo.csv", sep = ",", col.names = NA)
            )

cat("Time reading an ascii file into dataset C:\n")
system.time(
            {C=read.table("/tmp/foo.csv", header = TRUE, sep=",", row.names=1)
           })

cat("Time writing a binary file out of dataset C:\n")
system.time(save(C, file="/tmp/foo.binary"))

cat("Time reading a binary file + variablenames from /tmp/foo.binary:\n")
system.time(load("/tmp/foo.binary"))    # and then read it in from binary file


<h2>Sending an R data object to someone else</h2>file.

# Goals: Lots of times, you need to give an R object to a friend,
#        or embed data into an email.

# First I invent a little dataset --
set.seed(101)   # To make sure you get the same random numbers as me
                # FYI -- runif(10) yields 10 U(0,1) random numbers.
A = data.frame(x1=runif(10), x2=runif(10), x3=runif(10))
# Look at it --
print(A)

# Writing to a binary file that can be transported
save(A, file="/tmp/my_data_file.rda")   # You can give this file to a friend
load("/tmp/my_data_file.rda")

# Plan B - you want pure ascii, which can be put into an email --
dput(A)
# This gives you a block of R code. Let me utilise that generated code
# to create a dataset named "B".
B = structure(list(x1 = c(0.372198376338929, 0.0438248154241592,
0.709684018278494, 0.657690396532416, 0.249855723232031, 0.300054833060130,
0.584866625955328, 0.333467143354937, 0.622011963743716, 0.54582855431363
), x2 = c(0.879795730113983, 0.706874740775675, 0.731972594512627,
0.931634427979589, 0.455120594473556, 0.590319729177281, 0.820436094887555,
0.224118480458856, 0.411666829371825, 0.0386105608195066), x3 = c(0.700711545301601,
0.956837461562827, 0.213352001970634, 0.661061500199139, 0.923318882007152,
0.795719761401415, 0.0712125543504953, 0.389407767681405, 0.406451216200367,
0.659355078125373)), .Names = c("x1", "x2", "x3"), row.names = c("1",
"2", "3", "4", "5", "6", "7", "8", "9", "10"), class = "data.frame")

# Verify that A and B are near-identical --
A-B
# or,
all.equal(A,B)


<h2>Make a "zoo" object, for handling time-series data.</h2>

# Goal: Make a time-series object using the "zoo" package

A = data.frame(date=c("1995-01-01", "1995-01-02", "1995-01-03", "1995-01-06"),
                x=runif(4),
                y=runif(4))
A$date = as.Date(A$date) # yyyy-mm-dd is the default format
# So far there's nothing new - it's just a data frame. I have hand-
# constructed A but you could equally have obtained it using read.table().

# I want to make a zoo matrix out of the numerical columns of A
library(zoo)
B = A
B$date = NULL
z = zoo(as.matrix(B), order.by=A$date)
rm(A, B)

# So now you are holding "z", a "zoo" object. You can do many cool
# things with it.
# See http://www.google.com/search?hl=en&q=zoo+quickref+achim&btnI=I%27m+Feeling+Lucky

# To drop down to a plain data matrix, say
C = coredata(z)
rownames(C) = as.character(time(z))
# Compare --
str(C)
str(z)

# The above is a tedious way of doing these things, designed to give you
# an insight into what is going on. If you just want to read a file
# into a zoo object, a very short path is something like:
#        z = read.zoo(filename, format="%d %b %Y")


<h2>Exporting and importing data.</h2>

# Goal: All manner of import and export of datasets.

# Invent a dataset --
A = data.frame(
                name=c("a","b","c"),
                ownership=c("Case 1","Case 1","Case 2"),
                listed.at=c("NSE",NA,"BSE"),
                   # Firm "b" is unlisted.
                is.listed=c(TRUE,FALSE,TRUE),
                   # R convention - boolean variables are named "is.something"
                x=c(2.2,3.3,4.4),
                date=as.Date(c("2004-04-04","2005-05-05","2006-06-06"))
              )

# To a spreadsheet through a CSV file --
write.table(A,file="demo.csv",sep = ",",col.names = NA,qmethod = "double")
B = read.table("demo.csv", header = TRUE, sep = ",", row.names = 1)

# To R as a binary file --
save(A, file="demo.rda")
load("demo.rda")

# To the Open XML standard for transport for statistical data --
library(StatDataML)
writeSDML(A, "/tmp/demo.sdml")
B = readSDML("/tmp/demo.sdml")

# To Stata --
library(foreign)
write.dta(A, "/tmp/demo.dta")
B = read.dta("/tmp/demo.dta")

# foreign::write.foreign() also has a pathway to SAS and SPSS.


<h2>Reading .gz .bz2 files and URLs</h2>

# Goal: Special cases in reading files

# Reading in a .bz2 file --
read.table(bzfile("file.text.bz2"))           # Requires you have ./file.text.bz2

# Reading in a .gz file --
read.table(gzfile("file.text.gz"))            # Requires you have ./file.text.bz2

# Reading from a pipe --
mydata = read.table(pipe("awk -f filter.awk input.txt"))

# Reading from a URL --
read.table(url("http://www.mayin.org/ajayshah/A/demo.text"))

# This also works --
read.table("http://www.mayin.org/ajayshah/A/demo.text")

# Hmm, I couldn't think of how to read a .bz2 file from a URL. How about:
read.table(pipe("links -source http://www.mayin.org/ajayshah/A/demo.text.bz2 | bunzip2"))

# Reading binary files from a URL --
load(url("http://www.mayin.org/ajayshah/A/nifty_weekly_returns.rda"))


<h2>Directly reading Microsoft Excel files</h2>
<k>Using xlsx package</k>
There are two main functions in xlsx package for reading both xls and xlsx Excel files: read.xlsx() and read.xlsx2()

The simplified formats are:
read.xlsx(file, sheetIndex, header=TRUE)
read.xlsx2(file, sheetIndex, header=TRUE)

# read.xlsx(file, 1)  # read first sheet
xlsData = read.xlsx("D:/Dropbox/STK/!!! STKMon !!!/analysis.xlsx", 1) # test run xlsx only

<k>Using readxl package</k>
install.packages("readxl")
library("readxl")
my_data <- read_excel("a.xls")
my_data <- read_excel("a.xlsx")


library(gdata)
a = read.xls("file.xls", sheet=2)                # This reads in the 2nd sheet

# Look at what the cat dragged in
str(a)

# If you have a date column, you'll want to fix it up like this:
a$date = as.Date(as.character(a$X), format="%d-%b-%y")
a$X = NULL


# Also see http://tolstoy.newcastle.edu.au/R/help/06/04/25674.html for
# another path.



<h4>Graphs</h4>
<h2>A grid of multiple pictures on one screen</h2>

# Goal: To make a panel of pictures.

par(mfrow=c(3,2))                       # 3 rows, 2 columns.

# Now the next 6 pictures will be placed on these 6 regions. :-)

# Let me take some pains on the 1st
plot(density(runif(100)), lwd=2)
text(x=0, y=0.2, "100 uniforms")        # Showing you how to place text at will
abline(h=0, v=0)
              # All these statements effect the 1st plot.

x=seq(0.01,1,0.01)
par(col="blue")                         # default colour to blue.

# 2 --
plot(x, sin(x), type="l")
lines(x, cos(x), type="l", col="red")

# 3 --
plot(x, exp(x), type="l", col="green")
lines(x, log(x), type="l", col="orange")

# 4 --
plot(x, tan(x), type="l", lwd=3, col="yellow")

# 5 --
plot(x, exp(-x), lwd=2)
lines(x, exp(x), col="green", lwd=3)

# 6 --
plot(x, sin(x*x), type="l")
lines(x, sin(1/x), col="pink")


<h2>Making PDF files that go into books/papers</h2>

# Goal: Make pictures in PDF files that can be put into a paper.

xpts = seq(-3,3,.05)

# Here is my suggested setup for a two-column picture --
pdf("demo2.pdf", width=5.6, height=2.8, bg="cadetblue1", pointsize=8)
par(mai=c(.6,.6,.2,.2))
plot(xpts, sin(xpts*xpts), type="l", lwd=2, col="cadetblue4",
     xlab="x", ylab="sin(x*x)")
grid(col="white", lty=1, lwd=.2)
abline(h=0, v=0)

# My suggested setup for a square one-column picture --
pdf("demo1.pdf", width=2.8, height=2.8, bg="cadetblue1", pointsize=8)
par(mai=c(.6,.6,.2,.2))
plot(xpts, sin(xpts*xpts), type="l", lwd=2, col="cadetblue4",
     xlab="x", ylab="sin(x*x)")
grid(col="white", lty=1, lwd=.2)
abline(h=0, v=0)




<h2>A histogram with tails in red</h2>

# Goal: A histogram with tails shown in red.

# This happened on the R mailing list on 7 May 2004.
# This is by Martin Maechler &lt;maechler&#64;stat.math.ethz.ch>, who was
# responding to a slightly imperfect version of this by
# "Guazzetti Stefano" &lt;Stefano.Guazzetti&#64;ausl.re.it>

x = rnorm(1000)
hx = hist(x, breaks=100, plot=FALSE)
plot(hx, col=ifelse(abs(hx$breaks) &lt; 1.669, 4, 2))
         # What is cool is that "col" is supplied a vector.


<h2>z=f(x,y) using contour lines and colours</h2>

# Goal: Visualisation of 3-dimensional (x,y,z) data using contour
#       plots and using colour to represent the 3rd dimension.
#       The specific situation is: On a grid of (x,y) points, you have
#       evaluated f(x,y). Now you want a graphical representation of
#       the resulting list of (x,y,z) points that you have.

# Setup an interesting data matrix of (x,y,z) points:
points = structure(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.15, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.3, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.35, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.45, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.55, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.6, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.65, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.7, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.75, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.8, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0.998, 0.124, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0.998, 0.71, 0.068, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0.998, 0.898, 0.396, 0.058, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.998, 0.97, 0.726, 0.268, 0.056, 0.006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0.996, 0.88, 0.546, 0.208, 0.054, 0.012, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.998, 0.964, 0.776, 0.418, 0.18, 0.054, 0.014, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.998, 0.906, 0.664, 0.342, 0.166, 0.056, 0.018, 0.006, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.986, 0.862, 0.568, 0.29, 0.15, 0.056, 0.022, 0.008, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.954, 0.778, 0.494, 0.26, 0.148, 0.056, 0.024, 0.012, 0.004, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.906, 0.712, 0.43, 0.242, 0.144, 0.058, 0.028, 0.012, 0.006, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.878, 0.642, 0.38, 0.222, 0.142, 0.066, 0.034, 0.014, 0.008, 0.004, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0.846, 0.586, 0.348, 0.208, 0.136, 0.068, 0.034, 0.016, 0.012, 0.006, 0.004, 0.002, 0, 0, 0, 0, 0, 0, 0, 0.8, 0.538, 0.318, 0.204, 0.136, 0.07, 0.046, 0.024, 0.012, 0.008, 0.004, 0.002, 0.002, 0, 0, 0, 0, 0, 0, 0.762, 0.496, 0.294, 0.2, 0.138, 0.072, 0.05, 0.024, 0.014, 0.012, 0.006, 0.004, 0.002, 0.002, 0, 0, 0, 0, 0, 0.704, 0.472, 0.286, 0.198, 0.138, 0.074, 0.054, 0.028, 0.016, 0.012, 0.008, 0.006, 0.004, 0.002, 0.002, 0, 0, 0, 0, 0.668, 0.438, 0.276, 0.196, 0.138, 0.078, 0.054, 0.032, 0.024, 0.014, 0.012, 0.008, 0.004, 0.004, 0.002, 0.002, 0, 0, 0, 0.634, 0.412, 0.27, 0.194, 0.14, 0.086, 0.056, 0.032, 0.024, 0.016, 0.012, 0.01, 0.006, 0.004, 0.004, 0.002, 0.002, 0, 0, 0.604, 0.388, 0.26, 0.19, 0.144, 0.088, 0.058, 0.048, 0.026, 0.022, 0.014, 0.012, 0.008, 0.006, 0.004, 0.004, 0.002, 0.002, 0, 0.586, 0.376, 0.256, 0.19, 0.146, 0.094, 0.062, 0.052, 0.028, 0.024, 0.014, 0.012, 0.012, 0.008, 0.004, 0.004, 0.004, 0.002, 0.002, 0.566, 0.364, 0.254, 0.192, 0.148, 0.098, 0.064, 0.054, 0.032, 0.024, 0.022, 0.014, 0.012, 0.012, 0.008, 0.004, 0.004, 0.004, 0.002), .Dim = c(399, 3), .Dimnames = list(NULL, c("x", "y", "z")))

# Understand this object --
summary(points)
  # x is a grid from 0 to 1
  # y is a grid from 20 to 200
  # z is the interesting object which will be the 3rd dimension.

# Solution using contourplot() from package 'lattice'
library(lattice)
d3 = data.frame(points)
contourplot(z ~ x+y, data=d3)
## or nicer
contourplot(z ~ x+y, data=d3, cuts=20, region = TRUE)
## or using logit - transformed z values:
contourplot(qlogis(z) ~ x+y, data=d3, pretty=TRUE, region = TRUE)

# An interesting alternative is levelplot()
levelplot(z ~ x+y, pretty=TRUE, contour=TRUE, data=d3)

# There is a contour() function in R. Even though it sounds obvious
# for the purpose, it is a bit hard to use.
# contour() wants 3 inputs: vectors of x and y values, and a matrix of
# z values, where the x values correspond to the rows of z, and the y
# values to the columns.  A collection of points like `points' above
# needs to be turned into such a grid. It might sound odd, but contour()
# image() and persp() have used this kind of input for the longest time.
#
# For irregular data, there's an interp function in the akima package
# that can convert from irregular data into the grid format.
#
# The `points' object that I have above - a list of (x,y,z) points -
# fits directly into the mentality of lattice::contourplot() but not
# into the requirements of contour()


<h2>Show recessions using filled  colour in a macro time-series plot</h2>

# Goal: Display of a macroeconomic time-series, with a filled colour
#       bar showing a recession.

years = 1950:2000
timeseries = cumsum(c(100, runif(50)*5))
hilo = range(timeseries)
plot(years, timeseries, type="l", lwd=3)
# A recession from 1960 to 1965 --
polygon(x=c(1960,1960, 1965,1965),
        y=c(hilo, rev(hilo)),
        density=NA, col="orange", border=NA)
lines(years, timeseries, type="l", lwd=3) # paint again so line comes on top

# alternative method -- though not as good looking --
# library(plotrix)
# gradient.rect(1960, hilo[1], 1965, hilo[2],
#               reds=c(0,1), greens=c(0,0), blues=c(0,0),
#               gradient="y")



Plotting two series on one graph, one  with a left y axis and another with a right y axis.

# Goal: Display two series on one plot, one with a left y axis
#       and another with a right y axis.

y1 = cumsum(rnorm(100))
y2 = cumsum(rnorm(100, mean=0.2))

par(mai=c(.8, .8, .2, .8))
plot(1:100, y1, type="l", col="blue", xlab="X axis label", ylab="Left legend")
par(new=TRUE)
plot(1:100, y2, type="l", ann=FALSE, yaxt="n")
axis(4)
legend(x="topleft", bty="n", lty=c(1,1), col=c("blue","black"),
       legend=c("String 1 (left scale)", "String 2 (right scale)"))



<h4>Probability and statistics</h4>
<h2>Tables, joint and marginal distributions</h2>

# Goal: Joint distributions, marginal distributions, useful tables.

# First let me invent some fake data
set.seed(102)                           # This yields a good illustration.
x = sample(1:3, 15, replace=TRUE)
education = factor(x, labels=c("None", "School", "College"))
x = sample(1:2, 15, replace=TRUE)
gender = factor(x, labels=c("Male", "Female"))
age = runif(15, min=20,max=60)

D = data.frame(age, gender, education)
rm(x,age,gender,education)
print(D)

# Table about education
table(D$education)

# Table about education and gender --
table(D$gender, D$education)
# Joint distribution of education and gender --
table(D$gender, D$education)/nrow(D)

# Add in the marginal distributions also
addmargins(table(D$gender, D$education))
addmargins(table(D$gender, D$education))/nrow(D)

# Generate a good LaTeX table out of it --
library(xtable)
xtable(addmargins(table(D$gender, D$education))/nrow(D),
       digits=c(0,2,2,2,2))             # You have to do | and \hline manually.

# Study age by education category
by(D$age, D$gender, mean)
by(D$age, D$gender, sd)
by(D$age, D$gender, summary)

# Two-way table showing average age depending on education & gender
a = matrix(by(D$age, list(D$gender, D$education), mean), nrow=2)
rownames(a) = levels(D$gender)
colnames(a) = levels(D$education)
print(a)
# or, of course,
print(xtable(a))


<h2>`Moving window' standard deviation</h2>

# Goal: To do `moving window volatility' of returns.

library(zoo)

# Some data to play with (Nifty on all fridays for calendar 2004) --
p = structure(c(1946.05, 1971.9, 1900.65, 1847.55, 1809.75, 1833.65, 1913.6, 1852.65, 1800.3, 1867.7, 1812.2, 1725.1, 1747.5, 1841.1, 1853.55, 1868.95, 1892.45, 1796.1, 1804.45, 1582.4, 1560.2, 1508.75, 1521.1, 1508.45, 1491.2, 1488.5, 1537.5, 1553.2, 1558.8, 1601.6, 1632.3, 1633.4, 1607.2, 1590.35, 1609, 1634.1, 1668.75, 1733.65, 1722.5, 1775.15, 1820.2, 1795, 1779.75, 1786.9, 1852.3, 1872.95, 1872.35, 1901.05, 1996.2, 1969, 2012.1, 2062.7, 2080.5), index = structure(c(12419, 12426, 12433, 12440, 12447, 12454, 12461, 12468, 12475, 12482, 12489, 12496, 12503, 12510, 12517, 12524, 12531, 12538, 12545, 12552, 12559, 12566, 12573, 12580, 12587, 12594, 12601, 12608, 12615, 12622, 12629, 12636, 12643, 12650, 12657, 12664, 12671, 12678, 12685, 12692, 12699, 12706, 12713, 12720, 12727, 12734, 12741, 12748, 12755, 12762, 12769, 12776, 12783), class = "Date"), frequency = 0.142857142857143, class = c("zooreg", "zoo"))

# Shift to returns --
r = 100*diff(log(p))
head(r)
summary(r)
sd(r)

# Compute the moving window vol --
vol = sqrt(250) * rollapply(r, 20, sd, align = "right")

# A pretty plot --
plot(vol, type="l", ylim=c(0,max(vol,na.rm=TRUE)),
     lwd=2, col="purple", xlab="2004",
     ylab=paste("Annualised sigma, 20-week window"))
grid()
legend(x="bottomleft", col=c("purple", "darkgreen"),
       lwd=c(2,2), bty="n", cex=0.8,
       legend=c("Annualised 20-week vol (left scale)", "Nifty (right scale)"))
par(new=TRUE)
plot(p, type="l", lwd=2, col="darkgreen",
     xaxt="n", yaxt="n", xlab=", ylab=")
axis(4)


<h2>Quartiles/deciles tables/graphs.</h2>

Requires this data file

# Get the data in place --
load(file="demo.rda")
summary(firms)

# Look at it --
plot(density(log(firms$mktcap)))
plot(firms$mktcap, firms$spread, type="p", cex=.2, col="blue", log="xy",
     xlab="Market cap (Mln USD)", ylab="Bid/offer spread (bps)")
m=lm(log(spread) ~ log(mktcap), firms)
summary(m)

# Making deciles --
library(gtools)
library(gdata)
                                      # for deciles (default=quartiles)
size.category = quantcut(firms$mktcap, q=seq(0, 1, 0.1), labels=F)
table(size.category)
means = aggregate(firms, list(size.category), mean)
print(data.frame(means$mktcap,means$spread))

# Make a picture combining the sample mean of spread (in each decile)
# with the weighted average sample mean of the spread (in each decile),
# where weights are proportional to size.
wtd.means = by(firms, size.category,
  function(piece) (sum(piece$mktcap*piece$spread)/sum(piece$mktcap)))
lines(means$mktcap, means$spread, type="b", lwd=2, col="green", pch=19)
lines(means$mktcap, wtd.means, type="b", lwd=2, col="red", pch=19)
legend(x=0.25, y=0.5, bty="n",
       col=c("blue", "green", "red"),
       lty=c(0, 1, 1), lwd=c(0,2,2),
       pch=c(0,19,19),
       legend=c("firm", "Mean spread in size deciles",
         "Size weighted mean spread in size deciles"))

# Within group standard deviations --
aggregate(firms, list(size.category), sd)

# Now I do quartiles by BOTH mktcap and spread.
size.quartiles = quantcut(firms$mktcap, labels=F)
spread.quartiles = quantcut(firms$spread, labels=F)
table(size.quartiles, spread.quartiles)
# Re-express everything as joint probabilities
table(size.quartiles, spread.quartiles)/nrow(firms)
# Compute cell means at every point in the joint table:
aggregate(firms, list(size.quartiles, spread.quartiles), mean)

# Make pretty two-way tables
aggregate.table(firms$mktcap, size.quartiles, spread.quartiles, nobs)
aggregate.table(firms$mktcap, size.quartiles, spread.quartiles, mean)
aggregate.table(firms$mktcap, size.quartiles, spread.quartiles, sd)
aggregate.table(firms$spread, size.quartiles, spread.quartiles, mean)
aggregate.table(firms$spread, size.quartiles, spread.quartiles, sd)


<h2>Distribution of sample mean and sample median</h2>

# Goal: Show the efficiency of the mean when compared with the median
#       using a large simulation where both estimators are applied on
#       a sample of U(0,1) uniformly distributed random numbers.

one.simulation = function(N=100) {     # N defaults to 100 if not supplied
  x = runif(N)
  return(c(mean(x), median(x)))
}

# Simulation --
results = replicate(100000, one.simulation(20)) # Gives back a 2x100000 matrix

# Two kernel densities --
k1 = density(results[1,])              # results[1,] is the 1st row
k2 = density(results[2,])

# A pretty picture --
xrange = range(k1$x, k2$x)
plot(k1$x, k1$y, xlim=xrange, type="l", xlab="Estimated value", ylab=")
grid()
lines(k2$x, k2$y, col="red")
abline(v=.5)
legend(x="topleft", bty="n",
       lty=c(1,1),
       col=c("black", "red"),
       legend=c("Mean", "Median"))


<h2>The bootstrap</h2>

  Getting started with the `boot' package in R for bootstrap inference


The package <code>boot</code> has elegant and powerful support for
bootstrapping. In order to use it, you have to repackage your
estimation function as follows.


R has very elegant and abstract notation in array indexes. Suppose
there is an integer vector <code>OBS</code> containing the elements 2,
3, 7, i.e. that <code>OBS = c(2,3,7);</code>. Suppose x is a
vector. Then the notation <code>x[OBS]</code> is a vector containing
elements x[2], x[3] and x[7]. This beautiful notation works for x as a
dataset (data frame) also. Here are demos:


# For vectors --
> x = c(10,20,30,40,50)
> d = c(3,2,2)
> x[d]
[1] 30 20 20

# For data frames --
> D = data.frame(x=seq(10,50,10), y=seq(500,100,-100))
> t(D)
    1   2   3   4   5
x  10  20  30  40  50
y 500 400 300 200 100
> D[d,]
     x   y
3   30 300
2   20 400
2.1 20 400



Now for the key point: how does the R boot package work? The R
package <code>boot</code> repeatedly calls your estimation function,
and each time, the bootstrap sample is supplied using an integer
vector of indexes like above. Let me show you two examples of how you
would write estimation functions which are compatible with the
package:


samplemean = function(x, d) {
  return(mean(x[d]))
}

samplemedian = function(x, d) {
  return(median(x[d]))
}



The estimation function (that you write) consumes data
<code>x</code> and a vector of indices <code>d</code>. This function
will be called many times, one for each bootstrap replication. Every
time, the data `x' will be the same, and the bootstrap sample `d' will
be different.


At each call, the boot package will supply a fresh set of indices
d. The notation x[d] allows us to make a brand-new vector (the
bootstrap sample), which is given to mean() or median(). This reflects
sampling with replacement from the original data vector.


Once you have written a function like this, here is how you would
obtain bootstrap estimates of the standard deviation of the
distribution of the median:


    b = boot(x, samplemedian, R=1000)           # 1000 replications



The object `b' that is returned by boot() is interesting and
useful. Say ?boot to learn about it. For example, after making
<code>b</code> as shown above, you can say:

    print(sd(b$t[,1]))



Here, I'm using the fact that b$t is a matrix containing 1000 rows
which holds all the results of estimation. The 1st column in it is the
only thing being estimated by samplemedian(), which is the sample
median.


The default plot() operator does nice things when fed with this
object. Try it: say <code>plot(b)</code>
<h2>Dealing with data frames</h2>


Here is an example, which uses the bootstrap to report the ratio of
two standard deviations:


library(boot)

sdratio = function(D, d) {
  E=D[d,]
  return(sd(E$x)/sd(E$y))
}

x = runif(100)
y = 2*runif(100)
D = data.frame(x, y)

b = boot(D, sdratio, R=1000)
cat("Standard deviation of sdratio = ", sd(b$t[,1]), "\n")
ci = boot.ci(b, type="basic")
cat("95% CI from ", ci$basic[1,4], " - ", ci$basic[1,5], "\n")



Note the beautiful syntax <code>E = D[d,]</code> which gives you a
data frame E using the rows out of data frame D that are specified by
the integer vector d.
<h2>Sending more stuff to your estimation function</h2>


Many times, you want to send additional things to your estimation
function. You're allowed to say whatever you want to boot(), after you
have supplied the two mandatory things that he wants. Here's an
example: the trimmed mean.


The R function mean() is general, and will also do a trimmed
mean. If you say mean(x, 0.1), then it will remove the most extreme
10% of the data at both the top and the bottom, and report the mean of
the middle 80%. Suppose you want to explore the sampling
characteristics of the trimmed mean using boot(). You would write this:


trimmedmean = function(x, d, trim=0) {
  return(mean(x[d], trim/length(x)))
}



Here, I'm defaulting trim to 0. And, I'll allowing the caller to
talk in the units of observations, not fractions of the data. So the
user would say "5" to trim off the most extreme 5 observations at the
top and the bottom. I convert that into fractions before feeding this
to mean().


Here's how you would call boot() using this:


    b = boot(x, trimmedmean, R=1000, trim=5)



This sends the extra argument trim=5 to boot, which sends it on to
our trimmedmean() function.
<h2>Finding out more</h2>


The boot() function is very powerful. The above examples only
scratch the surface. Among other things, it does things like the block
bootstrap for time-series data, randomly censored data, etc. The
manual can be accessed by saying:


library(boot)
?boot



but what you really need is the article <i>Resampling Methods in R:
The <code>boot</code> package</i> by Angelo J. Canty, which appeared
in the December 2002 issue of <a href="http://cran.r-project.org/doc/Rnews"><i>R News</i></a>.


Also see the web appendix to <i>An R and S-PLUS Companion to
Applied Regression</i> by John Fox [<a href="http://socserv.mcmaster.ca/jfox/Books/Companion/appendix-bootstrapping.pdf">pdf</a>],
and a tutorial by Patrick Burns [<a href="http://www.burns-stat.com/pages/Tutor/bootstrap_resampling.html">html</a>].

Return to <a href="../index.html"><i>R by example</i></a>

<a href="http://www.mayin.org/ajayshah">Ajay Shah</a>
ajayshah at mayin dot org

<h2>Notes on boot()</h2>

# Goals: Do bootstrap inference, as an example, for a sample median.

library(boot)

samplemedian = function(x, d) {        # d is a vector of integer indexes
  return(median(x[d]))                  # The genius is in the x[d] notation
}

data = rnorm(50)                          # Generate a dataset with 50 obs
b  =  boot(data, samplemedian, R=2000)    # 2000 bootstrap replications
cat("Sample median has a sigma of ", sd(b$t[,1]), "\n")
plot(b)

# Make a 99% confidence interval
boot.ci(b, conf=0.99, type="basic")


<h2>Doing MLE with your own likelihood function</h2>

  Roll your own likelihood function with R

This document assumes you know something about maximum likelihood
estimation. It helps you get going in terms of doing MLE in R. All
through this, we will use the "ordinary least squares" (OLS) model
(a.k.a. "linear regression" or "classical least squares" (CLS)) as the
simplest possible example. <a href="ols-lf.pdf">Here are the formulae
for the OLS likelihood, and the notation that I use.</a>


There are two powerful optimisers in R: optim() and nlminb().
This note only uses optim(). You should also explore nlminb().


You might find it convenient to <a href="mlefiles.tar.bz2">snarf
a tarfile of all the .R programs involved in this page.</a>
<h2>Writing the likelihood function</h2>


You have to write an R function which computes out the likelihood
function. As always in R, this can be done in several different
ways.


One issue is that of restrictions upon parameters. When the search
algorithm is running, it may stumble upon nonsensical values - such as
a sigma below 0 - and you do need to think about this. One traditional
way to deal with this is to "transform the parameter space". As an
example, for all positive values of sigma, log(sigma) ranges from
-infinity to +infinity. So it's safe to do an unconstrained search
using log(sigma) as the free parameter.

<a href="html/ols_lfn.html">Here is the OLS likelihood, written in a few ways.</a>


Confucius he said, when you write a likelihood function, do take
the trouble of also writing it's gradient (the vector of first
derivatives). You don't absolutely need it, but it's highly
recommended. In my toy experiment, this seems to be merely a question
of speed - using the analytical gradient makes the MLE go faster. But
the OLS likelihood is unique and simple; it is globally quasiconcave
and has a clear top. There could not be a simpler task for a
maximisation routine. In more complex situations, numerical
derivatives are known to give more unstable searches, while analytical
derivatives give more reliable answers.
<h2>A simulation setup</h2>


To use the other files on this page, you need to take my <a href="html/simulated_setup.html">simulation setup file</a>.
<h2>Comparing these alternatives</h2>


Now that I've written the OLS likelihood function in a few ways,
it's natural to ask: Do they all give the same answer? And, which is
the fastest?


I <a href="html/lfn_testing_timing.html">wrote a simple R program in order
to learn these things</a>. This gives the result:


True theta =  2 4 6 
OLS theta =  2.004311 3.925572 6.188047 

Kick the tyres --
                 lf1() lf1() in logs    lf2()    lf3()
A weird theta 1864.956      1864.956 1864.956 1864.956
True theta    1766.418      1766.418 1766.418 1766.418
OLS theta     1765.589      1765.589 1765.589 1765.589
Cost (ms)        0.450         0.550    1.250    1.000

Derivatives -- first let me do numerically --
  Derivative in sigma     --  10.92756 
  Derivative in intercept -- -8.63967 
  Derivative in slope     -- -11.82872 
  Analytical derivative in sigma -- 10.92705 
  Analytical derivative in beta  -- -8.642051 -11.82950 



This shows us that of the 4 ways of writing it, ols.lf1() is the
fastest, and that there is a fair match between my claimed analytical
gradient and numerical derivatives.

<h2>A minimal program which does the full MLE</h2>
Using this foundation, I can jump to a self-contained and <a href="html/minimal.html">minimal R program which does the full job</a>. It
gives this result:


True theta =  2 4 6 
OLS theta =  2.004311 3.925572 6.188047 

Gradient-free (constrained optimisation) --
$par
[1] 2.000304 3.925571 6.188048
$value
[1] 1765.588
$counts
function gradient 
      18       18 
$convergence
[1] 0
$message
[1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

Using the gradient (constrained optimisation) --
$par
[1] 2.000303 3.925571 6.188048
$value
[1] 1765.588
$counts
function gradient 
      18       18 
$convergence
[1] 0
$message
[1] "CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"

You say you want a covariance matrix?
MLE results --
          Coefficient  Std. Err.        t
Sigma        2.000303 0.08945629 22.36068
Intercept    3.925571 0.08792798 44.64530
X            6.188048 0.15377325 40.24138
Compare with the OLS results --
            Estimate Std. Error  t value      Pr(>|t|)
(Intercept) 3.925572 0.08801602 44.60065 7.912115e-240
X[, 2]      6.188047 0.15392722 40.20112 6.703474e-211



The file minimal.R also generates this picture:

<h2>Measurement about the full MLE</h2>


The R optim() function has many different paths to MLE. I wrote <a href="html/mle_testing_timing.html">a simple R program</a> in order to learn
about these. This yields the result:


True theta =  2 4 6 
OLS theta =  2.004311 3.925572 6.188047 

                        Hit rate   Cost
L-BFGS-B, analytical         100   25.1
BFGS, analytical             100   33.1
Nelder-Mead, trans.          100   59.2
Nelder-Mead                  100   60.5
L-BFGS-B, numerical          100   61.2
BFGS, trans., numerical      100   68.5
BFGS, numerical              100   71.2
SANN                          99 4615.5
SANN, trans.                  96 4944.9



The algorithms compared above are:

<i>L-BFGS-B, analytical</i>. This uses L-BFGS-B which is a
variant of BFGS which allows "box" constraints (you can specify a
permitted range for each parameter). This uses the ols.gradient()
function to do analytical derivatives. It is the fastest (25.1
milliseconds on my machine) and works 100% of the time.

<i>BFGS, analytical</i>. This uses BFGS instead of L-BFGS-B --
i.e. no constraints are permitted. Analytical derivatives are used.

<i>Nelder-Mead, trans.</i>. Nelder-Mead is a derivative-free
algorithm. It does not need you to write the gradient. This variant
uses the log() transformation in order to ensure that sigma is positive.

<i>Nelder-Mead</i> This is Nelder-Mead without the transformation.

<i>L-BFGS-B, numerical</i> This is the same L-BFGS-B but instead
of giving him analytical derivative, I leave optim() to fend for himself
with numerical derivatives. A worse than doubling of cost!

<i>BFGS, trans., numerical</i> This uses plain BFGS, with
the log() transformation to ensure that sigma stays positive, but using
numerical derivatives.

<i>BFGS, numerical</i> This is plain BFGS, with no transformation
to ensure a sane sigma, and using numerical derivatives.

<i>SANN</i> This is a stochastic search algorithm based on
simulated annealing. As you see, it failed for 1% of the runs. It is
very costly. The attraction is that it might be more effective at
finding global maxima and in "staying out of troublesome territory".

<i>SANN trans.</i> This uses the log() transform for sigma
and does the search using simulated annealing.

<h2>Notes on MLE</h2>
# Goal: To do OLS by MLE.
# OLS likelihood function
# Note: I am going to write the LF using sigma2=sigma^2 and not sigma.
ols.lf1 = function(theta, y, X) {
  beta = theta[-1]
  sigma2 = theta[1]
  if (sigma2 &lt;= 0) return(NA)
  n = nrow(X)
  e = y - X%*%beta                                  # t() = matrix transpose
  logl = ((-n/2)*log(2*pi)) - ((n/2)*log(sigma2)) - ((t(e)%*%e)/(2*sigma2))
  return(-logl) # since optim() does minimisation by default.
}

# Analytical derivatives
ols.gradient = function(theta, y, X) {
  beta = theta[-1]
  sigma2 = theta[1]
  e = y - X%*%beta
  n = nrow(X)

  g = numeric(length(theta))
  g[1] = (-n/(2*sigma2)) + (t(e)%*%e)/(2*sigma2*sigma2) # d logl / d sigma
  g[-1] = (t(X) %*% e)/sigma2                           # d logl / d beta

  return(-g)
}

X = cbind(1, runif(1000))
theta.true = c(2,4,6) # error variance = 2, intercept = 4, slope = 6.
y = X %*% theta.true[-1] + sqrt(theta.true[1]) * rnorm(1000)

# Estimation by OLS --
d = summary(lm(y ~ X[,2]))
theta.ols = c(sigma2 = d$sigma^2, d$coefficients[,1])
cat("OLS theta = ", theta.ols, "\n\n")

cat("\nGradient-free (constrained optimisation) --\n")
optim(c(1,1,1), method="L-BFGS-B", fn=ols.lf1,
      lower=c(1e-6,-Inf,-Inf), upper=rep(Inf,3), y=y, X=X)

cat("\nUsing the gradient (constrained optimisation) --\n")
optim(c(1,1,1), method="L-BFGS-B", fn=ols.lf1, gr=ols.gradient,
      lower=c(1e-6,-Inf,-Inf), upper=rep(Inf,3), y=y, X=X)

cat("\n\nYou say you want a covariance matrix?\n")
p = optim(c(1,1,1), method="L-BFGS-B", fn=ols.lf1, gr=ols.gradient,
           lower=c(1e-6,-Inf,-Inf), upper=rep(Inf,3), hessian=TRUE,
           y=y, X=X)
inverted = solve(p$hessian)
results = cbind(p$par, sqrt(diag(inverted)), p$par/sqrt(diag(inverted)))
colnames(results) = c("Coefficient", "Std. Err.", "t")
rownames(results) = c("Sigma", "Intercept", "X")
cat("MLE results --\n")
print(results)
cat("Compare with the OLS results --\n")
d$coefficients

# Picture of how the loglikelihood changes if you perturb the sigma
theta = theta.ols
delta.values = seq(-1.5, 1.5, .01)
logl.values = as.numeric(lapply(delta.values,
                                 function(x) {-ols.lf1(theta+c(x,0,0),y,X)}))
plot(sqrt(theta[1]+delta.values), logl.values, type="l", lwd=3, col="blue",
     xlab="Sigma", ylab="Log likelihood")
grid()


<h2>The strange Cauchy distribution</h2>

# Goals: Scare the hell out of children with the Cauchy distribution.

# A function which simulates N draws from one of two distributions,
# and returns the mean obtained thusly.
one.simulation = function(N=100, distribution="normal") {
  if (distribution == "normal") {
    x = rnorm(N)
  } else {
    x = rcauchy(N)
  }
  mean(x)
}

k1 = density(replicate(1000, one.simulation(20)))
k2 = density(replicate(1000, one.simulation(20, distribution="cauchy")))

xrange = range(k1$x, k2$x)
plot(k1$x, k1$y, xlim=xrange, type="l", xlab="Estimated value", ylab=")
grid()
lines(k2$x, k2$y, col="red")
abline(v=.5)
legend(x="topleft", bty="n",
       lty=c(1,1),
       col=c("black", "red"),
       legend=c("Mean of Normal", "Mean of Cauchy"))
# The distribution of the mean of normals collapses into a point;
# that of the cauchy does not.

# Here's more scary stuff --
for (i in 1:10) {
  cat("Sigma of distribution of 1000 draws from mean of normal - ",
      sd(replicate(1000, one.simulation(20))), "\n")
}
for (i in 1:10) {
  cat("Sigma of distribution of 1000 draws from mean of cauchy - ",
      sd(replicate(1000, one.simulation(20, distribution="cauchy"))), "\n")
}

# Exercise for the reader: Compare the distribution of the median of
# the Normal against the distribution of the median of the Cauchy.


<h2>An example of simulation-based inference</h2>

# Goal: An example of simulation-based inference.
# This is in the context of testing for time-series dependence in
# stock market returns data.
# The code here does the idea of Kim, Nelson, Startz (1991).
# We want to use the distribution of realworld returns data, without
# needing assumptions about normality.
# The null is lack of dependence (i.e. an efficient market).
# So repeatedly, the data is permuted, and the sample ACF is computed.
# This gives us the distribution of the ACF under H0: independence, but
# while using the empirical distribution of the returns data.

# Weekly returns on Nifty, 1/1/2002 to 31/12/2003, 104 weeks of data.
r = c(-0.70031182197603, 0.421690133064168, -1.20098072984689, 0.143402360644984, 3.81836537549516, 3.17055939373247, 0.305580301919228, 1.23853814691852, 0.81584795095706, -1.51865139747764, -2.71223626421522, -0.784836480094242, 1.09180041170998, 0.397649587762761, -4.11309534220923, -0.263912425099111, -0.0410144239805454, 1.75756212770972, -2.3335373897992, -2.19228764624217, -3.64578978183987, 1.92535789661354, 3.45782867883164, -2.15532607229374, -0.448039988298987, 1.50124793565896, -1.45871585874362, -2.13459863369767, -6.2128068251802, -1.94482987066289, 0.751294815735637, 1.78244982829590, 1.61567494389745, 1.53557708728931, -1.53557708728931, -0.322061470004265, -2.28394919698225, 0.70399304137414, -2.93580952607737, 2.38125098034425, 0.0617697039252185, -4.14482733720716, 2.04397528093754, 0.576400673606603, 3.43072725191913, 2.96465382864843, 2.89833358015583, 1.85387040058336, 1.52136515035952, -0.637268376944444, 1.75418926224609, -0.804391905851354, -0.861816058320475, 0.576902488444109, -2.84259880663331, -1.35375536139417, 1.49096529042234, -2.05404881010045, 2.86868849528146, -0.258270670200478, -4.4515881438687, -1.73055019137092, 3.04427015714648, -2.94928202352018, 1.62081315773994, -6.83117945164824, -0.962715713711582, -1.75875847071740, 1.50330330252721, -0.0479705789653728, 3.68968303215933, -0.535807567290103, 3.94034871061182, 3.85787174417738, 0.932185956989873, 4.08598654183674, 2.27343783689715, 1.13958830440017, 2.01737201171230, -1.88131458327554, 1.97596267156648, 2.79857144562001, 2.22470306481695, 2.03212951411427, 4.95626853448883, 3.40400972901396, 3.03840139165246, -1.89863129741417, -3.70832135042951, 4.78478922155396, 4.3973589590097, 4.9667050392987, 2.99775078737081, -4.12349101552438, 3.25638269809945, 2.29683376253966, -2.64772825878214, -0.630835277076258, 4.72528848505451, 1.87368447333380, 3.17543946162564, 4.58174427843208, 3.23625985632168, 2.29777651227296)

# The 1st autocorrelation from the sample:
acf(r, 1, plot=FALSE)$acf[2]

# Obtain 1000 draws from the distribution of the 1st autocorrelation
# under the null of independence:
set.seed = 101
simulated = replicate(1000, acf(r[sample(1:104, replace=FALSE)], 1, plot=FALSE)$acf[2])
# At 95% --
quantile(simulated, probs=c(.025,.975))
# At 99% --
quantile(simulated, probs=c(.005,.995))

# So we can reject the null at 95% but not at 99%.

# A pretty picture.
plot(density(simulated), col="blue")
abline(v=0)
abline(v=quantile(simulated, probs=c(.025,.975)), lwd=2, col="purple")
abline(v=acf(r, 1, plot=FALSE)$acf[2], lty=2, lwd=4, col="yellow")


<h2>Four standard operations with standard distributions</h2>

# Goal: Standard computations with well-studied distributions.

# The normal distribution is named "norm". With this, we have:

# Normal density
dnorm(c(-1.96,0,1.96))

# Cumulative normal density
pnorm(c(-1.96,0,1.96))

# Inverse of this
qnorm(c(0.025,.5,.975))
pnorm(qnorm(c(0.025,.5,.975)))

# 1000 random numbers from the normal distribution
summary(rnorm(1000))


# Here's the same ideas, for the chi-squared distribution with 10 degrees
# of freedom.
dchisq(c(0,5,10), df=10)

# Cumulative normal density
pchisq(c(0,5,10), df=10)

# Inverse of this
qchisq(c(0.025,.5,.975), df=10)

# 1000 random numbers from the normal distribution
summary(rchisq(1000, df=10))


<h2>Two CDFs and a two-sample Kolmogorov-Smirnoff test</h2>

# Goal: Given two vectors of data,
#       superpose their CDFs
#       and show the results of the two-sample Kolmogorov-Smirnoff test

# The function consumes two vectors x1 and x2.
# You have to provide a pair of labels as `legendstrings'.
# If you supply an xlab, it's used
# If you specify log - e.g. log="x" - this is passed on to plot.
# The remaining args that you specify are sent on into ks.test()
two.cdfs.plot = function(x1, x2, legendstrings, xlab=", log=", ...) {
  stopifnot(length(x1)>0,
            length(x2)>0,
            length(legendstrings)==2)
  hilo = range(c(x1,x2))

  par(mai=c(.8,.8,.2,.2))
  plot(ecdf(x1), xlim=hilo, verticals=TRUE, cex=0,
       xlab=xlab, log=log, ylab="Cum. distribution", main=")
  grid()
  plot(ecdf(x2), add=TRUE, verticals=TRUE, cex=0, lwd=3)
  legend(x="bottomright", lwd=c(1,3), lty=1, bty="n",
         legend=legendstrings)

  k = ks.test(x1,x2, ...)
  text(x=hilo[1], y=c(.9,.85), pos=4, cex=.8,
     labels=c(
       paste("KS test statistic: ", sprintf("%.3g", k$statistic)),
       paste("Prob value: ", sprintf("%.3g", k$p.value))
       )
     )
  k
}

x1 = rnorm(100, mean=7, sd=1)
x2 = rnorm(100, mean=9, sd=1)

# Check error detection --
two.cdfs.plot(x1,x2)

# Typical use --
two.cdfs.plot(x1, x2, c("X1","X2"), xlab="Height (metres)", log="x")

# Send args into ks.test() --
two.cdfs.plot(x1, x2, c("X1","X2"), alternative="less")


<h2>Simulation to measure size and power of a test</h2>

# Goal: Simulation to study size and power in a simple problem.

set.seed(101)

# The data generating process: a simple uniform distribution with stated mean
dgp = function(N,mu) {runif(N)-0.5+mu}

# Simulate one FIXED hypothesis test for H0:mu=0, given a true mu for a sample size N
one.test = function(N, truemu) {
  x = dgp(N,truemu)
  muhat = mean(x)
  s = sd(x)/sqrt(N)
  # Under the null, the distribution of the mean has standard error s
  threshold = 1.96*s
  (muhat &lt; -threshold) || (muhat > threshold)
} # Return of TRUE means reject the null

# Do one experiment, where the fixed H0:mu=0 is run Nexperiments times with a sample size N.
# We return only one number: the fraction of the time that H0 is rejected.
experiment = function(Nexperiments, N, truemu) {
  sum(replicate(Nexperiments, one.test(N, truemu)))/Nexperiments
}

# Measure the size of a test, i.e. rejections when H0 is true
experiment(10000, 50, 0)
# Measurement with sample size of 50, and true mu of 0.

# Power study: I.e. Pr(rejection) when H0 is false
# (one special case in here is when the H0 is actually true)

muvalues = seq(-.15,.15,.01)
  # When true mu &lt; -0.15 and when true mu > 0.15,
  # the Pr(rejection) veers to 1 (full power) and it's not interesting.

# First do this with sample size of 50
results = NULL
for (truth in muvalues) {
  results = c(results, experiment(10000, 50, truth))
}
par(mai=c(.8,.8,.2,.2))
plot(muvalues, results, type="l", lwd=2, ylim=c(0,1),
     xlab="True mu", ylab="Pr(Rejection of H0:mu=0)")
abline(h=0.05, lty=2)

# Now repeat this with sample size of 100 (should yield a higher power)
results = NULL
for (truth in muvalues) {
  results = c(results, experiment(10000, 100, truth))
}
lines(muvalues, results, lwd=2, col="blue")
legend(x=-0.15, y=.2, lwd=c(2,1,2), lty=c(1,2,1), cex=.8,
       col=c("black","black","blue"), bty="n",
       legend=c("N=50", "Size, 0.05", "N=100"))



<h4>Regression</h4>
<h2>Doing OLS</h2>

# Goal: Simulate a dataset from the OLS model and obtain
#       obtain OLS estimates for it.

x = runif(100, 0, 10)                  # 100 draws from U(0,10)
y = 2 + 3*x + rnorm(100)               # beta = [2, 3] and sigma = 1

# You want to just look at OLS results?
summary(lm(y ~ x))

# Suppose x and y were packed together in a data frame --
D = data.frame(x,y)
summary(lm(y ~ x, D))

# Full and elaborate steps --
d = lm(y ~ x)
# Learn about this object by saying ?lm and str(d)
# Compact model results --
print(d)
# Pretty graphics for regression diagnostics --
par(mfrow=c(2,2))
plot(d)

d = summary(d)
# Detailed model results --
print(d)
# Learn about this object by saying ?summary.lm and by saying str(d)
cat("OLS gave slope of ", d$coefficients[2,1],
    "and a error sigma of ", d$sigma, "\n")


## I need to drop down to a smaller dataset now --
x = runif(10)
y = 2 + 3*x + rnorm(10)
m = lm(y ~ x)

# Now R supplies a wide range of generic functions which extract
# useful things out of the result of estimation of many kinds of models.

residuals(m)
fitted(m)
AIC(m)
AIC(m, k=log(10))                        # SBC
vcov(m)
logLik(m)


<h2>Dummy variables in regression</h2>

# Goal: "Dummy variables" in regression.

# Suppose you have this data:
people = data.frame(
  age =       c(21,62,54,49,52,38),
  education = c("college", "school", "none", "school", "college", "none"),
  education.code = c(  2,        1,      0,        1,         2,      0 )
  )
# Here people$education is a string categorical variable and
# people$education.code is the same thing, with a numerical coding system.
people

# Note the structure of the dataset --
str(people)
# The strings supplied for `education' have been treated (correctly) as
# a factor, but education.code is being treated as an integer and not as
# a factor.


# We want to do a dummy variable regression. Normally you would have:
#  1 Chosen college as the omitted category
#  2 Made a dummy for "none" named educationnone
#  3 Made a dummy for "school" named educationschool
#  4 Ran a regression like lm(age ~ educationnone + educationschool, people)
# But this is R. Things are cool:
lm(age ~ education, people)

# ! :-)
# When you feed him an explanatory variable like education, he does all
# these steps automatically. (He chose college as the omitted category).

# If you use an integer coding, then the obvious thing goes wrong --
lm(age ~ education.code, people)
# because he's thinking that education.code is an integer explanatory
# variable. So you need to:

lm(age ~ factor(education.code), people)
# (he choose a different omitted category)

# Alternatively, fix up the dataset --
people$education.code = factor(people$education.code)
lm(age ~ education.code, people)

#
# Bottom line:
# Once the dataset has categorical variables correctly represented as factors, i.e. as
str(people)
# doing OLS in R induces automatic generation of dummy variables while leaving one out:
lm(age ~ education, people)
lm(age ~ education.code, people)

# But what if you want the X matrix?
m = lm(age ~ education, people)
model.matrix(m)
# This is the design matrix that went into the regression m.


<h2>Generate latex tables of OLS results</h2>

# Goal: To make a latex table with results of an OLS regression.

# Get an OLS --
x1 = runif(100)
x2 = runif(100, 0, 2)
y = 2 + 3*x1 + 4*x2 + rnorm(100)
m = lm(y ~ x1 + x2)

# and print it out prettily --
library(xtable)
# Bare --
xtable(m)
xtable(anova(m))

# Better --
print.xtable(xtable(m, caption="My regression",
                    label="t:mymodel",
                    digits=c(0,3,2,2,3)),
             type="latex",
             file="xtable_demo_ols.tex",
             table.placement = "tp",
             latex.environments=c("center", "footnotesize"))

print.xtable(xtable(anova(m),
                    caption="ANOVA of my regression",
                    label="t:anova_mymodel"),
             type="latex",
             file="xtable_demo_anova.tex",
             table.placement = "tp",
             latex.environments=c("center", "footnotesize"))

# Read the documentation of xtable. It actually knows how to generate
# pretty latex tables for a lot more R objects than just OLS results.
# It can be a workhorse for making tabular out of matrices, and
# can also generate HTML.


<h2>`Least squares dummy variable' (LSDV) or `fixed effects' model</h2>

# Goals: Simulate a dataset from a "fixed effects" model, and
#        obtain "least squares dummy variable" (LSDV) estimates.
#
# We do this in the context of a familiar "earnings function" -
#  log earnings is quadratic in log experience, with parallel shifts by
#  education category.

# Create an education factor with 4 levels --
education = factor(sample(1:4,1000, replace=TRUE),
                    labels=c("none", "school", "college", "beyond"))
# Simulate an experience variable with a plausible range --
experience = 30*runif(1000)            # experience from 0 to 20 years
# Make the intercept vary by education category between 4 given values --
intercept = c(0.5,1,1.5,2)[education]

# Simulate the log earnings --
log.earnings = intercept +
  2*experience - 0.05*experience*experience + rnorm(1000)
A = data.frame(education, experience, e2=experience*experience, log.earnings)
summary(A)

# The OLS path to LSDV --
summary(lm(log.earnings ~ -1 + education + experience + e2, A))


<h2>Estimate beta of Sun Microsystems using data from Yahoo finance</h2><h2>Elaborate version</h2>

# Goal: Using data from Yahoo finance, estimate the beta of Sun Microsystems
#       for weekly returns.
# This is the `elaborate version' (36 lines), also see terse version (16 lines)

library(tseries)

# I know that the yahoo symbol for the common stock of Sun Microsystems
# is "SUNW" and for the S&P 500 index is "^GSPC".
prices = cbind(get.hist.quote("SUNW", quote="Adj", start="2003-01-01", retclass="zoo"),
                get.hist.quote("^GSPC", quote="Adj", start="2003-01-01", retclass="zoo"))
colnames(prices) = c("SUNW", "SP500")
prices = na.locf(prices)               # Copy last traded price when NA

# To make weekly returns, you must have this incantation:
nextfri.Date = function(x) 7 * ceiling(as.numeric(x - 1)/7) + as.Date(1)
# and then say
weekly.prices = aggregate(prices, nextfri.Date,tail,1)

# Now we can make weekly returns --
r = 100*diff(log(weekly.prices))

# Now shift out of zoo to become an ordinary matrix --
r = coredata(r)
rj = r[,1]
rM = r[,2]
d = lm(rj ~ rM)               # Market model estimation.
print(summary(d))

# Make a pretty picture
big = max(abs(c(rj, rM)))
range = c(-big, big)
plot(rM, rj, xlim=range, ylim=range,
     xlab="S&P 500 weekly returns (%)", ylab="SUNW weekly returns (%)")
grid()
abline(h=0, v=0)
lines(rM, d$fitted.values, col="blue")


<h2>Terse version.</h2>

# Goal : Terse version of estimating the beta of Sun Microsystems
#        using weekly returns and data from Yahoo finance.
#        By Gabor Grothendieck.

library(tseries)

getstock = function(x)
   c(get.hist.quote(x, quote = "Adj", start = "2003-01-01", compress = "w"))
r = diff(log(cbind(sp500 = getstock("^gspc"), sunw = getstock("sunw"))))

mm = lm(sunw ~ ., r)
print(summary(mm))

range = range(r, -r)
plot(r[,1], r[,2], xlim = range, ylim = range,
     xlab = "S&P 500 weekly returns (%)", ylab = "SUNW weekly returns (%)")
grid()
abline(mm, h = 0, v = 0, col = "blue")


<h2>Nonlinear regression</h2>

# Goal: To do nonlinear regression, in three ways
#       By just supplying the function to be fit,
#       By also supplying the analytical derivatives, and
#       By having him analytically differentiate the function to be fit.
#
# John Fox has a book "An R and S+ companion to applied regression"
# (abbreviated CAR).
# An appendix associated with this book, titled
#   "Nonlinear regression and NLS"
# is up on the web, and I strongly recommend that you go read it.
#
# This file is essentially from there (I have made slight changes).

# First take some data - from the CAR book --
library(car)
data(US.pop)
attach(US.pop)
plot(year, population, type="l", col="blue")

# So you see, we have a time-series of the US population. We want to
# fit a nonlinear model to it.

library(stats)                            # Contains nonlinear regression
time = 0:20
pop.mod = nls(population ~ beta1/(1 + exp(beta2 + beta3*time)),
  start=list(beta1=350, beta2=4.5, beta3=-0.3), trace=TRUE)
# You just write in the formula that you want to fit, and supply
# starting values. "trace=TRUE" makes him show iterations go by.

summary(pop.mod)
# Add in predicted values into the plot
lines(year, fitted.values(pop.mod), lwd=3, col="red")

# Look at residuals
plot(year, residuals(pop.mod), type="b")
abline(h=0, lty=2)

# Using analytical derivatives:
model = function(beta1, beta2, beta3, time) {
  m = beta1/(1+exp(beta2+beta3*time))
  term = exp(beta2 + beta3*time)
  gradient = cbind((1+term)^-1,
                    -beta1*(1+term)^-2 * term,
                    -beta1*(1+term)^-2 * term * time)
  attr(m, 'gradient') = gradient
  return(m)
}

summary(nls(population ~ model(beta1, beta2, beta3, time),
            start=list(beta1=350, beta2=4.5, beta3=-0.3)))

# Using analytical derivatives, using automatic differentiation (!!!):
model = deriv(~ beta1/(1 + exp(beta2+beta3*time)), # rhs of model
               c('beta1', 'beta2', 'beta3'), # parameter names
               function(beta1, beta2, beta3, time){} # arguments for result
               )
summary(nls(population ~ model(beta1, beta2, beta3, time),
            start=list(beta1=350, beta2=4.5, beta3=-0.3)))


<h2>Standard tests</h2>

# Goal: Some of the standard tests

# A classical setting --
x = runif(100, 0, 10)                  # 100 draws from U(0,10)
y = 2 + 3*x + rnorm(100)               # beta = [2, 3] and sigma is 1
d = lm(y ~ x)
# CLS results --
summary(d)

library(sandwich)
library(lmtest)
# Durbin-Watson test --
dwtest(d, alternative="two.sided")
# Breusch-Pagan test --
bptest(d)
# Heteroscedasticity and autocorrelation consistent (HAC) tests
coeftest(d, vcov=kernHAC)

# Tranplant the HAC values back in --
library(xtable)
sum.d = summary(d)
xtable(sum.d)
sum.d$coefficients[1:2,1:4] = coeftest(d, vcov=kernHAC)[1:2,1:4]
xtable(sum.d)


<h2>Using orthogonal polynomials</h2>

# Goal: Experiment with fitting nonlinear functional forms in
#       OLS, using orthogonal polynomials to avoid difficulties with
#       near-singular design matrices that occur with ordinary polynomials.
#       Shriya Anand, Gabor Grothendieck, Ajay Shah, March 2006.

# We will deal with noisy data from the d.g.p. y = sin(x) + e
x = seq(0, 2*pi, length.out=50)
set.seed(101)
y = sin(x) + 0.3*rnorm(50)
basicplot = function(x, y, minx=0, maxx=3*pi, title=") {
  plot(x, y, xlim=c(minx,maxx), ylim=c(-2,2), main=title)
  lines(x, sin(x), col="blue", lty=2, lwd=2)
  abline(h=0, v=0)
}
x.outsample = seq(0, 3*pi, length.out=100)

# Severe multicollinearity with ordinary polynomials
x2 = x*x
x3 = x2*x
x4 = x3*x
cor(cbind(x, x2, x3, x4))
# and a perfect design matrix using orthogonal polynomials
m = poly(x, 4)
all.equal(cor(m), diag(4))              # Correlation matrix is I.

par(mfrow=c(2,2))
# Ordinary polynomial regression --
  p = lm(y ~ x + I(x^2) + I(x^3) + I(x^4))
  summary(p)
  basicplot(x, y, title="Polynomial, insample") # Data
  lines(x, fitted(p), col="red", lwd=3)  # In-sample
  basicplot(x, y, title="Polynomial, out-of-sample")
  predictions.p = predict(p, list(x = x.outsample))    # Out-of-sample
  lines(x.outsample, predictions.p, type="l", col="red", lwd=3)
  lines(x.outsample, sin(x.outsample), type="l", col="blue", lwd=2, lty=2)
  # As expected, polynomial fitting gives terrible results out of sample.

# These IDENTICAL things using orthogonal polynomials
  d = lm(y ~ poly(x, 4))
  summary(d)
  basicplot(x, y, title="Orth. poly., insample") # Data
  lines(x, fitted(d), col="red", lwd=3)  # In-sample
  basicplot(x, y, title="Orth. poly., out-of-sample")
  predictions.op = predict(d, list(x = x.outsample))    # Out-of-sample
  lines(x.outsample, predictions.op, type="l", col="red", lwd=3)
  lines(x.outsample, sin(x.outsample), type="l", col="blue", lwd=2, lty=2)

# predict(d) is magical! See ?SafePrediction
# The story runs at two levels. First, when you do an OLS model,
# predict()ion requires applying coefficients to an appropriate
# X matrix. But one level deeper, the polynomial or orthogonal-polynomial
# needs to be utilised for computing the X matrix based on the
# supplied x.outsample data.
# If you say p = poly(x, n)
# then you can say predict(p, new) where predict.poly() gets invoked.
# And when you say predict(lm()), the full steps are worked out for
# you automatically: predict.poly() is used to make an X matrix and
# then prediction based on the regression results is done.

all.equal(predictions.p, predictions.op) # Both paths are identical for this
                                         # (tame) problem.


<h2>A function that takes a model specification as an argument</h2>

# Goal: R syntax where model specification is an argument to a function.

# Invent a dataset
x = runif(100); y = runif(100); z = 2 + 3*x + 4*y + rnorm(100)
D = data.frame(x=x, y=y, z=z)

amodel = function(modelstring) {
  summary(lm(modelstring, D))
}

amodel(z ~ x)
amodel(z ~ y)



<h4>Time-series analysis</h4>
<h2>ARMA estimation, diagnostics, forecasting</h2>

# Goals: ARMA modeling - estimation, diagnostics, forecasting.


# 0. SETUP DATA
rawdata = c(-0.21,-2.28,-2.71,2.26,-1.11,1.71,2.63,-0.45,-0.11,4.79,5.07,-2.24,6.46,3.82,4.29,-1.47,2.69,7.95,4.46,7.28,3.43,-3.19,-3.14,-1.25,-0.50,2.25,2.77,6.72,9.17,3.73,6.72,6.04,10.62,9.89,8.23,5.37,-0.10,1.40,1.60,3.40,3.80,3.60,4.90,9.60,18.20,20.60,15.20,27.00,15.42,13.31,11.22,12.77,12.43,15.83,11.44,12.32,12.10,12.02,14.41,13.54,11.36,12.97,10.00,7.20,8.74,3.92,8.73,2.19,3.85,1.48,2.28,2.98,4.21,3.85,6.52,8.16,5.36,8.58,7.00,10.57,7.12,7.95,7.05,3.84,4.93,4.30,5.44,3.77,4.71,3.18,0.00,5.25,4.27,5.14,3.53,4.54,4.70,7.40,4.80,6.20,7.29,7.30,8.38,3.83,8.07,4.88,8.17,8.25,6.46,5.96,5.88,5.03,4.99,5.87,6.78,7.43,3.61,4.29,2.97,2.35,2.49,1.56,2.65,2.49,2.85,1.89,3.05,2.27,2.91,3.94,2.34,3.14,4.11,4.12,4.53,7.11,6.17,6.25,7.03,4.13,6.15,6.73,6.99,5.86,4.19,6.38,6.68,6.58,5.75,7.51,6.22,8.22,7.45,8.00,8.29,8.05,8.91,6.83,7.33,8.52,8.62,9.80,10.63,7.70,8.91,7.50,5.88,9.82,8.44,10.92,11.67)

# Make a R timeseries out of the rawdata: specify frequency & startdate
gIIP = ts(rawdata, frequency=12, start=c(1991,4))
print(gIIP)
plot.ts(gIIP, type="l", col="blue", ylab="IIP Growth (%)", lwd=2,
        main="Full data")
grid()

# Based on this, I decide that 4/1995 is the start of the sensible period.
gIIP = window(gIIP, start=c(1995,4))
print(gIIP)
plot.ts(gIIP, type="l", col="blue", ylab="IIP Growth (%)", lwd=2,
        main="Estimation subset")
grid()

# Descriptive statistics about gIIP
mean(gIIP); sd(gIIP); summary(gIIP);
plot(density(gIIP), col="blue", main="(Unconditional) Density of IIP growth")
acf(gIIP)


# 1. ARMA ESTIMATION
m.ar2 = arima(gIIP, order = c(2,0,0))
print(m.ar2)                       # Print it out


# 2. ARMA DIAGNOSTICS
tsdiag(m.ar2)                      # His pretty picture of diagnostics
## Time series structure in errors
print(Box.test(m.ar2$residuals, lag=12, type="Ljung-Box"));
## Sniff for ARCH
print(Box.test(m.ar2$residuals^2, lag=12, type="Ljung-Box"));
## Eyeball distribution of residuals
plot(density(m.ar2$residuals), col="blue", xlim=c(-8,8),
     main=paste("Residuals of AR(2)"))


# 3. FORECASTING
## Make a picture of the residuals
plot.ts(m.ar2$residual, ylab="Innovations", col="blue", lwd=2)
s = sqrt(m.ar2$sigma2)
abline(h=c(-s,s), lwd=2, col="lightGray")

p = predict(m.ar2, n.ahead = 12)         # Make 12 predictions.
print(p)

## Watch the forecastability decay away from fat values to 0.
## sd(x) is the naive sigma. p$se is the prediction se.
gain = 100*(1-p$se/sd(gIIP))
plot.ts(gain, main="Gain in forecast s.d.", ylab="Per cent",
        col="blue", lwd=2)

## Make a pretty picture that puts it all together
ts.plot(gIIP, p$pred, p$pred-1.96*p$se, p$pred+1.96*p$se,
        gpars=list(lty=c(1,1,2,2), lwd=c(2,2,1,1),
          ylab="IIP growth (%)", col=c("blue","red", "red", "red")))
grid()
abline(h=mean(gIIP), lty=2, lwd=2, col="lightGray")
legend(x="bottomleft", cex=0.8, bty="n",
       lty=c(1,1,2,2), lwd=c(2,1,1,2),
       col=c("blue", "red", "red", "lightGray"),
       legend=c("IIP", "AR(2) forecasts", "95% C.I.", "Mean IIP growth"))

<h2>Web Scrapping</h2><a href="https://aidenloe.github.io/webscrapping.html#scrape_from_discussion_forums" class="whitebut ">Web Scrapping</a>
<h3>Scrape content (Wiki)</h3>
We will be using the <code>RCurl</code> and <code>XML</code> package to help us with the scrapping.

Let’s use the Eurovision_Song_Contest as an example.

The <code>XML</code> package has plenty functions that can allow us to scrape the data.

Usually we are extracting information based on the tags of the web pages.

<code>##### SCRAPPING CONTENT OFF WEBSITES ######
require(RCurl)
require(XML)
# XPath is a language for querying XML 
# //Select anywhere in the document
# /Select from root
# @select attributes. Used in [] brackets

#### Wikipedia Example ####
url &lt;- "https://en.wikipedia.org/wiki/Eurovision_Song_Contest"
txt = getURL(url) # get the URL html code

# parsing html code into readable format
PARSED &lt;- htmlParse(txt)

# Parsing code using tags
xpathSApply(PARSED, "//h1")

# strops code and return content of the tag
xpathSApply(PARSED, "//h1", xmlValue) # h1 tag
xpathSApply(PARSED, "//h3", xmlValue) # h3 tag
xpathSApply(PARSED, "//a[@href]") # a tag with href attribute

# Go to url 
# Highlight references
# right click, inspect element
# Search for tags
xpathSApply(PARSED, "//span[@class='reference-text']",xmlValue) # parse notes and citations
xpathSApply(PARSED, "//cite[@class='citation news']",xmlValue) # parse citation news
xpathSApply(PARSED, "//span[@class='mw-headline']",xmlValue) # parse headlines
xpathSApply(PARSED, "//p",xmlValue) # parsing contents in p tag
xpathSApply(PARSED, "//cite[@class='citation news']/a/@href") # parse links under citation. xmlValue not needed. 
xpathSApply(PARSED, "//p/a/@href") # parse href links under all p tags
xpathSApply(PARSED, "//p/a/@*") # parse all atributes under all p tags

# Partial matches - subtle variations within or between pages. 
xpathSApply(PARSED, "//cite[starts-with(@class, 'citation news')]",xmlValue) # parse citataion news that starts with..
xpathSApply(PARSED, "//cite[contains(@class, 'citation news')]",xmlValue) # parse citataion news that contains.

# Parsing tree like structure
parsed&lt;-   htmlTreeParse(txt, asText = TRUE)</code>

<h3>Scrape content (BBC)</h3>
When you know the structure of the data.

All you need to do is to find the correct function to scrape.

<code>##### BBC Example ####
url &lt;- "https://www.bbc.co.uk/news/uk-england-london-46387998"
url &lt;- "https://www.bbc.co.uk/news/education-46382919"
txt = getURL(url) # get the URL html code

# parsing html code into readable format
PARSED &lt;- htmlParse(txt)
xpathSApply(PARSED, "//h1", xmlValue) # h1 tag
xpathSApply(PARSED, "//p", xmlValue) # p tag
xpathSApply(PARSED, "//p[@class='story-body__introduction']", xmlValue) # p tag body
xpathSApply(PARSED, "//div[@class='date date--v2']",xmlValue) # date, only the first is enough
xpathSApply(PARSED, "//meta[@name='OriginalPublicationDate']/@content") # sometimes there is meta data. </code>

<h3>Create simple BBC scrapper</h3>
Sometimes, creating a function will make your life better and make your script look simpler.

<code>##### Create simple BBC scrapper #####
# scrape title, date and content
BBCscrapper1&lt;- function(url){
  txt = getURL(url) # get the URL html code
  PARSED &lt;- htmlParse(txt) # Parse code into readable format
  title &lt;- xpathSApply(PARSED, "//h1", xmlValue) # h1 tag
  paragraph &lt;- xpathSApply(PARSED, "//p", xmlValue) # p tag
  date &lt;- xpathSApply(PARSED, "//div[@class='date date--v2']",xmlValue) # date, only the first is enough
  date &lt;- date[1]
  return(cbind(title,date))
  #return(as.matrix(c(title,date)))
}

# Use function that was just created. 
BBCscrapper1("https://www.bbc.co.uk/news/education-46382919")</code>

<code>##      title                                                         
## [1,] "Ed Farmer: Expel students who defy initiations ban, says dad"
##      date              
## [1,] "29 November 2018"</code>

<h3>Keeping it neat</h3>
Using the <code>plyr</code> package helps to arrange the data in an organised way.

<code>## Putting the title and date into a dataframe
require(plyr)
#url
url&lt;- c("https://www.bbc.co.uk/news/uk-england-london-46387998", "https://www.bbc.co.uk/news/education-46382919")
## ldply: For each element of a list, apply function then combine results into a data frame
#put into a dataframe
ldply(url,BBCscrapper1)</code>

<code>##                                                          title
## 1              Man murdered widow, 80, in London allotment row
## 2 Ed Farmer: Expel students who defy initiations ban, says dad
##               date
## 1 29 November 2018
## 2 29 November 2018</code>

<h1>Web Scrapping (Part 2)</h1>
This example below is taken from code kindly written by David stillwell.

Some editing has been made to the original code.

<h3>Scrape from Wiki tables</h3>
You have learned how to scrape viewership on wikipedia and content on web pages.

This section is about scrapping data tables online.

<code># Install the packages that you don't have first. 
library("RCurl") # Good package for getting things from URLs, including https
library("XML") # Has a good function for parsing HTML data
library("rvest") #another package that is good for web scraping. We use it in the Wikipedia example

#####################
### Get a table of data from Wikipedia
## all of this happens because of the read_html function in the rvest package
# First, grab the page source
us_states = read_html("https://en.wikipedia.org/wiki/List_of_U.S._states_and_territories_by_population") %>% # piping
  # then extract the first node with class of wikitable
  html_node(".wikitable") %>% 
  # then convert the HTML table into a data frame
  html_table()</code>

<h3>Scrape from online tables</h3>
If we can have two data tables that have at least one column with the same name, then we can merge them together.

The main idea is to link the data together to run simple analysis.

In this case we can get data about <a href="http://apps.saferoutesinfo.org/legislation_funding/state_apportionment.cfm">funding</a> given to various US states to support building infrastructure to improve students’ ability to walk and bike to school.

<code>######################
url &lt;- "http://apps.saferoutesinfo.org/legislation_funding/state_apportionment.cfm"
funding&lt;-htmlParse(url) #get the data

# find the table on the page and read it into a list object
funding&lt;- XML::readHTMLTable(funding,stringsAsFactors = FALSE)

funding.df &lt;- do.call("rbind", funding) #flatten data
# Contain empty spaces previously.
colnames(funding.df)[1]&lt;- c("State") # shorten colname to just State. 

# Match up the tables by State/Territory names
# so we have two data frames, x and y, and we're setting the columns we want to do the matching on by setting by.x and by.y
mydata = merge(us_states, funding.df, by.x="State, federal district, or territory", by.y="State")
# it looks pretty good, but note that we're down to 50 US States, because the others didn't match up by name
# e.g. "District of Columbia" in the us_states data, doesn't match "Dist. of Col." in the funding data

#Replace the total spend column name with a name that's easier to use.
colnames(mydata)[18] = "total_spend"

#  We need to remove commas so that R can treat it as a number.
mydata[,"Population estimate, July 1, 2017[4]"] = gsub(",", ", mydata[,"Population estimate, July 1, 2017[4]"]) 
mydata[,"Population estimate, July 1, 2017[4]"] = as.numeric(mydata[,"Population estimate, July 1, 2017[4]"]) #this converts it to a number data type

# Now we have to do the same thing with the funding totals, which are in a format like this: $17,309,568
mydata[,"total_spend"] = gsub(",", ", mydata[,"total_spend"]) #this removes all commas
mydata[,"total_spend"] = gsub("\\$", ", mydata[,"total_spend"]) #this removes all dollar signs. We have a \\ because the dollar sign is a special character.
mydata[,"total_spend"] = as.numeric(mydata[,"total_spend"]) #this converts it to a number data type

# Now we can do the plotting
options(scipen=9999) #stop it showing scientific notation
plot(mydata[,"Population estimate, July 1, 2017[4]"], mydata[,"total_spend"])</code>

<code>## What's does the correlation between state funding and state population look like?
cor(mydata[,"Population estimate, July 1, 2017[4]"], mydata[,"total_spend"]) # 0.9924265 - big correlation!</code>

<code>## [1] 0.9885666</code>

<h3>Plot funding data on map</h3>
Perhaps it might be more interesting to see how the data is like on a map.

We can utilise <code>map_data</code> function in the <code>ggplot</code> package to help us with that.

Again, with a bit of data manipulation, we can merge the data table that contains the longitude and latitude information together with the funding data across different states.

<code>require(ggplot2)
all_states &lt;- map_data("state") # states
colnames(mydata)[1] &lt;- "state" # rename to states
mydata$state &lt;- tolower(mydata$state) #set all to lower case
Total &lt;- merge(all_states, mydata, by.x="region", by.y = 'state') # merge data
# we have data for delaware but not lat, long data in the maps
i &lt;- which(!unique(all_states$region) %in% mydata$state) 

# Plot data
ggplot() + 
  geom_polygon(data=Total, aes(x=long, y=lat, group = group, fill=Total$total_spend),colour="white") + 
  scale_fill_continuous(low = "thistle2", high = "darkred", guide="colorbar") + 
  theme_bw()  + 
  labs(fill = "Funding for School" ,title = "Funding for School between 2005 to 2012", x=", y=") + 
  scale_y_continuous(breaks=c()) +
  scale_x_continuous(breaks=c()) +
  theme(panel.border =  element_blank(),
        text = element_text(size=20))</code>


<h2>XPath for Web Scraping</h2>
<a href="https://www.opencodez.com/how-to-guide/how-to-use-xpath-for-web-scraping-with-r.htm" class="whitebut ">XPath for Web Scraping</a>

We have already learned about Web Scraping Technology in our previous post <a href="https://www.opencodez.com/web-development/web-scraping-using-beautiful-soup-part-1.htm" target="_blank">Web Scraping Using Beautiful Soup in Python.</a> In addition to that, a learner/developer might also be interested in fetching nodes/elements from the HTML or XML document using XPaths.

<h3>XPath For Web Scraping with R:</h3>
This article essentially elaborates on XPath and explains how to use XPath for web scraping with <a href="https://en.wikipedia.org/wiki/R_(programming_language)" target="_blank">R Programming language</a>.

<h3>What is XPath</h3>
XPath stands for XML Path Language. 
It is a query language to extract nodes from HTML or XML documents.

<h3>Required Tools and Knowledge</h3>
R Programming Language
XML Package
HTML/XML

<h3>How to get XPath in Mozilla Firefox Browser</h3>
Let us see how to find out XPath of any element on <a href="https://www.opencodez.com/" target="_blank">www.opencodez.com</a> using the Mozilla Firefox browser. 
We want to identify the XPath for the heading text of the first article on the home page. 
When we right-click on the highlighted element, we can find the Inspect Element option. 
A screenshot is attached below.


<img class="lazy" src="https://www.opencodez.com/wp-content/uploads/2020/02/Title-Tag-Inspect-Element-1024x511.png">

Observing the element HTML Code, we can identify that our target text is contained in the &#8216;a' tag. 
(highlighted in blue at the lower section of the screenshot). 
Next, we need to right-click on the blue highlight. 
Another box with several options opens up. 
Click on &#8220;Copy&#8221; which will show us new options. 
There will be an XPath option also. 
Click on that. 
Have a look at it in the below screenshot.


<img class="lazy" src="https://www.opencodez.com/wp-content/uploads/2020/02/XPath-option-1024x526.png">

Copy this XPath in any text file and check how does it look like. 
The XPath copied is /html/body/div[2]/div/div/div/div[1]/div[1]/article[1]/header/h2/a.

<h3>Absolute and Relative XPath</h3>
<h3>Absolute Path &#8211;</h3>
The XPath provided above is called the absolute path. 
It starts with &#8216;/' and traverses from the root node to the target node. 
Let us take a look if this XPath is correctly identified by Firefox. 
The set of commands is provided below.

Absolute Path

library(XML)
url &lt;- "https://www.opencodez.com/"
source &lt;- readLines(url, encoding = "UTF-8")
parsed_doc &lt;- htmlParse(source, encoding = "UTF-8")
xpathSApply(parsed_doc, path = '/html/body/div[2]/div/div/div/div[1]/div[1]/article[1]/header/h2/a', xmlValue)

12345

library(XML)url &lt;- "https://www.opencodez.com/"source &lt;- readLines(url, encoding = "UTF-8")parsed_doc &lt;- htmlParse(source, encoding = "UTF-8")xpathSApply(parsed_doc, path = '/html/body/div[2]/div/div/div/div[1]/div[1]/article[1]/header/h2/a', xmlValue)

When we run the commands in R Studio, we find that the result is a NULL. 
The corrected XPath is provided below.

Absolute XPath

xpathSApply(parsed_doc, path = '/html/body/div[1]/div[1]/div[1]/div[1]/div[1]/div[1]/article[1]/header/h2/a', xmlValue)

xpathSApply(parsed_doc, path = '/html/body/div[1]/div[1]/div[1]/div[1]/div[1]/div[1]/article[1]/header/h2/a', xmlValue)

xpathSApply is a function available in the XML library in R. 
xmlValue is the argument we need to pass so that we get the value of the target node. 
In our case its the heading of the article.

<h3>Relative Path &#8211;</h3>
We can create a short and concise path to our target node by using &#8216;//' to jump between nodes. 
For example, the above absolute path can also be written as //h2/a. 
This path also points to our target &#8216;a' tag. 
There can be other ways to represent this path as well. 
Now let us take a look at the command to extract the heading text.

Relative XPath

xpathSApply(doc = parsed_doc, path ="//h2/a", xmlValue)[1]

xpathSApply(doc = parsed_doc, path ="//h2/a", xmlValue)[1]

The output is a character vector with 22 values in it. 
A snapshot of the output is provided below. 
Hence we need to fetch the first text by using [1] in the command.


<img class="lazy" src="https://www.opencodez.com/wp-content/uploads/2020/02/Character-output-1024x598.png">

<h3>Other ways to represent XPaths</h3>
<h3>Wildcard Operator * &#8211;</h3>
The wildcard operator * matches any (single) node with an arbitrary name at its position. 
In our case, a wildcard operated XPath will look like below.

Wildcard XPath

(xpathSApply(doc = parsed_doc, path ="//h2/*", xmlValue))[1]

(xpathSApply(doc = parsed_doc, path ="//h2/*", xmlValue))[1]

<h3>Wildcard Operator . 
and .. 
&#8211;</h3>
Here we are going to explain two more operators &#8216;.' and &#8216;..' and its usage in the XPath command. 
The . 
operator selects the current nodes (or self-axis) in a selected node-set. 
The .. 
operator selects the node one level up the hierarchy from the current node. 
Let us all try this for ourselves. 
Do share the commands or scenarios in the comments where any difficulty is faced.

<h3>Numerical Predicate &#8211;</h3>
Some predicates or functions can also be used to pinpoint nodes using position, last or count in the command. 
Our target node XPath will change in the below manner.

Numerical Predicates

#Position
xpathSApply(doc = parsed_doc, path ="//h2[position()=1]", xmlValue)[1]

#Last
xpathSApply(doc = parsed_doc, path ="//h2[last()]", xmlValue)[1]

#Count
xpathSApply(parsed_doc,"//h2[count(.//a)>0]", xmlValue)[1]

#PositionxpathSApply(doc = parsed_doc, path ="//h2[position()=1]", xmlValue)[1] #LastxpathSApply(doc = parsed_doc, path ="//h2[last()]", xmlValue)[1] #CountxpathSApply(parsed_doc,"//h2[count(.//a)>0]", xmlValue)[1]

<h4>Position &#8211;</h4>
We are trying to locate all the h2 tags which have got the first position in the node tree structure. 
As explained earlier, this will generate a character of 22 values. 
Our &#8216;position' command extracts the first value because of [1] in the command.

<h4>Last &#8211;</h4>
Similar to the above, all the h2 tags which are last in the tree structure will be extracted. 
The first value can be fetched using [1]. 
We can experiment to fetch other article headings by changing the value inside the box bracket.

<h4>Count &#8211;</h4>
The command looks a bit scary!! But don't be. 
It simply extracts all the h2 nodes which have got &#8216;a' tag present. 
If we observe the &#8216;h2' tags in the HTML code, we will notice that all the &#8216;h2' tags do have a child tag &#821#8216;a' and so this command is the same as the one we saw in the relative path section. 
With the presence of [1], it allows us to fetch the first article heading text.

If you were facing issues working with the . 
operator command as suggested earlier, this example should provide you with some understanding.

<h3>Text Predicate &#8211;</h3>
We can also locate some nodes with the manipulation of text related predicates. 
Explaining this will require a change in our target node. 
Text predicates help us in cases where we want to extract text which contains a specific word or characters or let say has a length condition on characters. 
Let us see some commands.

<h4>Contains &#8211;</h4>

Text Predicate

library(stringr)
xpathSApply(parsed_doc,"//a[contains(text(), '10')]", xmlValue)

library(stringr)xpathSApply(parsed_doc,"//a[contains(text(), '10')]", xmlValue)

The above command will throw a list of headings that have got 10 in its text. 
The output snapshot is provided below.


<img class="lazy" src="https://www.opencodez.com/wp-content/uploads/2020/02/10.png">

<h4>Starts-with &#8211;</h4>
When we want to fetch text of any attribute which starts with a particular string pattern, we can use starts-with predicate in the command. 
Attributes in any tag are addressed using &#8216;@' symbol. 
Have a look at the command. 
Do try to understand the output for this and let us know if you face any difficulty.

starts-with

xpathSApply(parsed_doc,"//a[starts-with(./@title, '10')]", xmlValue)

xpathSApply(parsed_doc,"//a[starts-with(./@title, '10')]", xmlValue)

<h3>XPath Node Relations &#8211;</h3>
A very interesting way to prepare XPaths is by understanding the tree analogy of the nodes in the HTML code structure. 
As is usual in describing tree-structured data formats, we employ notation based on family relationships (child, parent, grandparent, …) to describe the between-node relations. 
The construction of a proper XPath statement that employs this feature follows the pattern node1/<i>relation</i>::node2, where node2 has a specific <i>relation</i> to node1. 
 Let us see some examples.

<h3>Ancestor &#8211;</h3>
Ancestor

xpathSApply(parsed_doc,"//a/ancestor::article", xmlValue)

xpathSApply(parsed_doc,"//a/ancestor::article", xmlValue)

The command locates and fetches all the article tags which are an ancestor to a tag.

<h4>Child &#8211;</h4>

Child

xpathSApply(parsed_doc,"//div[position()=1]/child::article", xmlValue)

xpathSApply(parsed_doc,"//div[position()=1]/child::article", xmlValue)

The command locates and fetches all article tags which is a child of div tag in the first position in the tree structure.

There are many other such relations that we can utilize like a sibling, preceding-sibling, descendant, following, etc.

<h3>Conclusion &#8211;</h3>
I hope you found this step by step detailed guide on XPath for Web Scraping with R useful. 
There are many more options with which we can create XPaths apart from the ones we have explained in this article.

It is encouraged that the reader tries these commands themselves to practice and gain a deeper understanding of a faster smoother experience with Web Scraping. 
Do comment if you want to understand any specific XPath command, if you face any error or you want to know about any other concept related to Web Scraping.

<h2>web scraping</h2>
url &lt;- 'http://www.r-datacollection.com/materials/html/fortunes.html'

install.packages('XML')
library(XML)
parsed_doc &lt;- htmlParse(url)
parsed_doc &lt;- htmlParse(getURL(apple.news.url, .encoding = 'utf8'))

分析 html
這邊用絕對路徑抓取 Tag 裡的文字

xpathApply : 會多加 Tag 屬性

xpathSApply : 只抓取文字
xpathSApply(doc = parsed_doc, path = '/html/body/div/p/i')


相對路徑 ( 推薦 ) : 兩條斜線
xpathSApply(doc = parsed_doc, path = '//div/p/i')

/* 簡化 */
xpathSApply(parsed_doc, '//div/p/i')

萬用字元
&lt;div>底下所有 i
xpathSApply(parsed_doc, '//html/body/div/*/i')
[[1]]
&lt;i>'What we have is nice, but we need something very different'&lt;/i>
[[2]]
&lt;i>'R is wonderful, but it cannot work magic'&lt;/i>

抓取條件

.. : 上一層
xpathSApply(parsed_doc, '//title/..')
&lt;head>
  &lt;title>Collected R wisdoms&lt;/title>
&lt;/head>


| : 或
xpathSApply(parsed_doc, '//address | //title')
[[1]]
&lt;title>Collected R wisdoms&lt;/title>
[[2]]
&lt;address>
  &lt;a href="www.r-datacollectionbook.com">
    &lt;i>The book homepage&lt;/i>
  &lt;/a>
  &lt;a/>
&lt;/address>

利用變數 text2 節省時間，下次要用就直接呼叫
text2 &lt;- c(address = '//address', title = '//title')
xpathSApply(parsed_doc, text2)

節點關係

ancestor : 由當前節點向上，從父節點至根節點
xpathSApply(parsed_doc, '//a/ancestor::div')
xpathSApply(parsed_doc, '//a/ancestor::div//i')
/* 說明 */
a 節點以上是 div 的
a 節點以上是 div 的 i

節點底下有 title 的都抓下來，title 上面有兩層，所以會有兩組結果
xpathSApply(parsed_doc, '//title/ancestor::*')

ancestor-or-self : 由當前節點向上，從當前節點 到父節點直至根節點，就是多一組包含自己
xpathSApply(parsed_doc, '//title/ancestor-or-self::*')


attribute : 抓出屬性
xpathSApply(parsed_doc, '//a/attribute::*')
/* 結果 */
href 
"https://stat.ethz.ch/mailman/listinfo/r-help" 
href 
"www.r-datacollectionbook.com"
xpathSApply(parsed_doc, '//div/attribute::*')
/* 結果 */
id           lang           date           lang           date 
  "R Inventor"      "english"    "June/2003"      "english" "October/2011"


child : 子節點
xpathSApply(parsed_doc, '//div/child::h1')
/* 說明 */
div 底下是 h1 的

descendant : 底下所有子節點，不管第幾層

descendant-or-self : 多一個自己
xpathSApply(parsed_doc, '//div/descendant::*')

following : 當前節點的後續節點(子節點除外)
xpathSApply(parsed_doc, "//div/following::*")

following-sibling : 同一層兄弟底下
xpathSApply(parsed_doc, "//div/following-sibling::*")

namespace : 命名空間搜尋
xpathSApply(parsed_doc, "*[name() = 'div']")


parent : 父節點
xpathSApply(parsed_doc, "//i/parent::a")
/* 說明 */
i 的上一層是 a

preceding : 上一個兄弟節點
xpathSApply(parsed_doc, "//i/preceding::a")
/* 說明 */
i 上一個兄弟是 a

preceding-sibling : 同一層兄弟
xpathSApply(parsed_doc, "//body/preceding-sibling::*")

self : 自己
xpathSApply(parsed_doc, "//body/self::*")
屬性抓值

text() : 第一個結果包含文字
xpathSApply(parsed_doc,"//*[text()='The book homepage']")

attribute : 屬性，用 @ 表示
xpathSApply(parsed_doc,"//div[@id='R Inventor']")
xpathSApply(parsed_doc,"//div[@date='October/2011']")

string-length() : 字串的長度
xpathSApply(parsed_doc, '//h1[string-length() > 5]')
/* 說明 */
字串長度大於5

contains(str1,str2) : 包含屬性
xpathSApply(parsed_doc, "//*[contains(text(),'Source')]")
/* 說明 */
文字包含 Source

starts-with(str1,str2) : 字串開頭
xpathSApply(parsed_doc,"//i[starts-with(text(),'The')]")
/* 說明 */
開頭是 The

substring-before : 篩選條件之前

substring-after : 篩選條件之後
xpathSApply(parsed_doc,"//div[substring-before(@date,'/')='June']")
/* 說明 */
屬性是 date 裡面 / 之前是 June 的
xpathSApply(parsed_doc, "//a[substring-after(@href,'k.') = 'com']")

not() : 不包含的
xpathSApply(parsed_doc,"//div[not(contains(@id,'Inventor'))]")

local-name() : 網頁名稱
xpathSApply(parsed_doc,"//*[local-name()='address']")
[[1]]
&lt;address>
  &lt;a href="www.r-datacollectionbook.com">
    &lt;i>The book homepage&lt;/i>
  &lt;/a>
  &lt;a/>
&lt;/address>

count() : 節點個數
xpathSApply(parsed_doc,"//div[count(.//a)>0]")
/* 說明 */
.就是div自己，數字可改

position() : 位置
xpathSApply(parsed_doc,"//div/p[position()=1]")
/* 說明 */
div 底下第一個 p，數字可改

last() : 最後一個節點
xpathSApply(parsed_doc,"//div/p[last()]")

萃取函式

|  Function   |  回傳值  

| xmlValue    | 節點內容
| xmlName     | Tag名稱
| xmlAttrs    | 所有屬性
| xmlGetAttr  | 指定屬性
| xmlChildren | 子節點  
| xmlSize     | 節點數量

範例
xpathSApply(parsed_doc,"//title", xmlValue)
xpathSApply(parsed_doc,"//div",xmlAttrs)
xpathSApply(parsed_doc,"//div",xmlGetAttr,"lang")
xpathSApply(parsed_doc,"//div/*",xmlName)
xpathSApply(parsed_doc,"//div",xmlChildren)
xpathSApply(parsed_doc,"//body",xmlSize) => 7
自己寫函示

return : 回傳值

require() : 引用， 比如說 require ( stringr )
my-lower &lt;- function(x) {
  x &lt;- tolower(xmlName(x))
  x
}
xpathSApply(parsed_doc,"//div//i",fun = my-lower)

<h2>ggplot</h2>
library("ggplot2")
p = ggplot(mtcars) +
     geom_point(aes(x = wt, y = mpg, colour = factor(gear))) +
     facet_wrap(~am) +
     # Economist puts x-axis labels on the right-hand side
     scale_y_continuous(position = "right")

## Standard
p + theme_economist() + scale_colour_economist()

# Change axis lines to vertical
p + theme_economist(horizontal = FALSE) + scale_colour_economist() + coord_flip()

## White panel/light gray background
p + theme_economist_white() + scale_colour_economist()

## All white variant
p + theme_economist_white(gray_bg = FALSE) + scale_colour_economist()

## The Economist uses ITC Officina Sans
library("extrafont")
p + theme_economist(base_family="ITC Officina Sans") + scale_colour_economist()

## Verdana is a widely available substitute
p + theme_economist(base_family="Verdana") + scale_colour_economist()

<h2>A basic plot</h2>
# load data
managers_energy = read.csv("managers_energy_data.csv")
simulation = read.csv("simulation.csv")

Next, we'll make a basic ggplot. Compared to other plotting languages, ggplot syntax might seem weird at first. In ggplot, we build the plot one layer at a time. The first thing we do is create a blank canvas by calling the ggplot() command:

# blank ggplot
manager_plot =  ggplot() 

This creates a blank ggplot called manager_plot. To this canvas, we'll add different 'geometric objects'. In ggplot notation, these geometric objects are called a geom. The geom tells ggplot how we want the data represented. To represent the data using points, we use geom_point. To represent the data using lines, we use geom_line, and so on. Here we'll use points:

# basic ggplot syntax
manager_plot =  ggplot() + geom_point()

This is the basic syntax of a ggplot chart. We first evoke ggplot, and then add features to the plot using the + sign.

Next we need to add data. Inside geom_point, we tell ggplot to use managers_energy as the source data:

# add data
manager_plot =  ggplot() + geom_point(data = managers_energy)

We can also put the command data = managers_energy inside the ggplot() command, as in ggplot(data = managers_energy). Personally, I don't like to do this because my plots usually combine different datasets. Putting the data inside the ggplot() command locks the whole chart into using only that data.

Next, we tell ggplot about the 'aesthetics' we want, using the aes() command. We tell ggplot that the x-axis should plot energy_pc and the y-axis should plot managers_employment_share. This gives us the syntax for a basic ggplot:

# basic plot of managers vs. energy use
manager_plot =  ggplot() + geom_point(data = managers_energy,
                aes(x = energy_pc, y = managers_employment_share))

Refining the chart
The secret to good data visualization, I've found, is the refinements that come after you've created a basic chart. These refinements highlight the aspects of the data that you want to showcase.

First, let's refine the size of our data points. My philosophy is that the point size of scatter plots should vary inversely with the number of points. If you have only a few data observations, you want large points so you can see the data. But if you have many data observations (thousands or millions), you want to shrink the point size so that you can actually see all the data.

In our managers plot, we've go quite a few data observations. So let's shrink the point size from the ggplot default. To do this, we'll put size = 0.8 inside geom_point. For reasons that I'll discuss later, this size command doesn't go inside the aesthetic command aes().


# smaller point size
manager_plot = ggplot() +
                geom_point( data = managers_energy,
                size = 0.8,
                aes(x = energy_pc, y = managers_employment_share))

Reducing the point size in our scatter plot gives us:

fig_02_size
Smaller point size
The next thing I notice about the plot is that the data is crushed against the origin. When you see this happen, it's a good sign that you need to use logarithmic scales. Log scales spread the data out so that we can see variation in all the observations, not just the largest ones.

Let's tell ggplot to use logarithmic scales instead of linear scales:


# add log scales
manager_plot =  manager_plot +
                scale_x_log10() +
                scale_y_log10()

Here I'm using an interesting feature of ggplot --- it let's you recursively add layers to your plot. Having defined manager_plot, we tell ggplot to change the axes by adding commands to the original plot. To be honest, I don't use this recursive feature very often. But it's useful here because I can highlight the new code that I've adding with each refinement to the chart. Changing to log scales gives us:

fig_03_log_scale
Add log scales
Now the scatter plot looks much better. We can actually see the trend across countries.

Next, let's tweek the values on the axes. When log scales span only a few orders of magnitude, I like to add numbers in between the factors of ten. To change the axis numbers, we use the breaks command. To make custom breaks, we use the concatenate command c(). If I wanted axis labels of 1, 5, and 10, I'd write breaks = c(1, 5, 10). Here's the custom breaks that I'll use:


# better axis breaks
manager_plot = manager_plot +
  scale_x_log10(breaks = c(5,10,20,50,100,200,500,1000)) +
  scale_y_log10(breaks = c(0.1,0.2,0.5,1,2,5,10,20))

This gives a plot with better axis numbers:

fig_04_breaks
Better axis breaks
Next, let's fix our axis labels. By default, ggplot will use your variable names as the axis labels. This is rarely what you want in your final plot. To change the axis labels we use the command labs(). While we're at it, we'll add a title to the chart using ggtitle():


# descriptive labels and title
manager_plot = manager_plot +
  labs(x = "Energy use per capita (GJ)",
       y = "Managers (% of Total Employment)" ) +
  ggtitle("Managers Employment vs. Energy Use")

Now our plot has better labels:

fig_05_labels
Descriptive labels and title
Adding simulation data
To our empirical data, we'll now add the simulation data. We're going to use one of the nicest features of ggplot: the ability to use color to represent changes in a variable. To do this, we put the color command inside the aesthetics, aes().

In our simulation, we want energy_pc on the x-axis, managers_employment_share on the y-axis, and span_of_control in color. To plot this using points, we write:


#plot simulation data with span of control indicated by color
  geom_point(data = simulation,
             aes(x = energy_pc,
                 y = managers_employment_share,
                 color = span_of_control)
             ) 
 
The logic here is that any aesthetic getting mapped onto variables goes inside the aes() command. If I wanted point size to be a function of the span_of_control, I would write:


# point size as function of span of control
  geom_point(data = simulation,
             aes(x = energy_pc,
                 y = managers_employment_share,
                 size = span_of_control)
             ) 

But if I want to set the size of points to a single value, this goes outside the aes() command.


# point size has a single value
  geom_point(data = simulation,
             size = 0.1,
             aes(x = energy_pc,
                 y = managers_employment_share,
                 color = span_of_control)
             ) 

Let's add the simulation data to our management plot. We want the simulation data to appear under the empirical data, so we have to add it to the ggplot before adding the empirical data.

Because we don't want the simulation data to overwhelm the empirical data, we're going to make the simulation data partially transparent. This makes it feel like it's in the background.

In ggplot, we set the transparency of our points using the alpha command. alpha = 0 is completely transparent. alpha = 1 is completely opaque. We'll add alpha = 0.3 inside our geom. Heres the code with the simulation data added to the empirical data, along with all the refinements so far:


# add simulation data
manager_plot = ggplot() +
  geom_point(data = simulation,
             size = 0.1,
             alpha = 0.3,
             aes(x = energy_pc,
                 y = managers_employment_share,
                 color = span_of_control)
             ) +
  geom_point(data = managers_energy,
             size = 0.8,
             aes(x = energy_pc,
                 y = managers_employment_share)
             ) +
  scale_x_log10(breaks = c(5,10,20,50,100,200,500,1000)) +
  scale_y_log10(breaks = c(0.1,0.2,0.5,1,2,5,10,20)) +
  labs(x = "Energy use per capita (GJ)",
       y =  "Managers (% of Total Employment)") +
  ggtitle("Managers Employment vs. Energy Use") 

This code gives us:

fig_06_simulation
Add simulation data
More refinements
After adding the simulation data, we need to do more plot refining. First, the simulation data spans a far greater range than the empirical data. So now our empirical data is compressed into the corner of the chart. We don't want that.

We'll fix this by limiting the x-y range of the chart using the command coord_cartesian(). Inside the command we put the x and y range that we want. I'll restrict x to range from 5 to 1000 and y from 0.1 to 30. We use the concatenate function c() to denote these limits:


# limit plot range
manager_plot = manager_plot +
  coord_cartesian(xlim = c(5,1000), ylim = c(0.1,30)) 

Our plot now looks like this:

fig_07_cartesion
Limit plot range
Notice that ggplot has again used variable names to label the plot, this time for the color legend. We fix this using the labs() command. We want to label the color scale "Span of Control", so we write:


# descriptive label for color legend  
manager_plot = manager_plot +
  labs(color = "Span of Control")

We get:

fig_08_span_label
Descriptive label for color legend
Adding the label creates a new problem. The label is too long and compresses the graph. To fix this, we add a line split to the label using \n:


# line break in legend label
manager_plot = manager_plot +
  labs(color = "Span of\nControl")

We now get:

fig_09_span_label_line
Line break in legend label
Now let's refine the colors used by ggplot to represent the span of control. By default, ggplot uses shades of blue. I prefer to use the whole color spectrum. To represent the span of control using a rainbow with 8 colors, we write:


# rainbow colors for span of control
manager_plot = manager_plot +
  scale_color_gradientn( colours = rainbow(8) )

Now the chart is starting to pop!

fig_10_rainbow
Rainbow colors for span of control
But if we're picky (and we should be), we see that the rainbow on the color legend is upside down compared to the rainbow in the chart. Let's fix that by reversing the direction of the legend:


# reverse color legend
manager_plot = manager_plot +
  scale_color_gradientn(colours = rainbow(8),
                        guide = guide_colourbar(reverse = T))

Now the legend and the chart have matching rainbows:

fig_11_rainbow_reverse
Reverse direction of color legend
The plot theme
The default ggplot theme uses a grey background. We can change the theme using the theme command. I prefer the black and white theme, theme_bw():


# black and white theme
manager_plot = manager_plot + theme_bw()

Our plot now looks like this:

fig_12_black_white
Black and white theme
I also prefer serif fonts over sans-serif. Let's change the font to Times:


# change font to Times
manager_plot = manager_plot +
  theme(text=element_text(size = 10, family="Times"))

Our chart is looking close to the final version:

fig_13_times
Change font to Times
The last thing we'll do is add my personal theme that I use for all my plots. This theme removes the grid lines and flips the tick marks to the inside of the plot box. It also centeres the plot title and makes it bold. Here's the code:


theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      plot.title = element_text(face="bold", size = rel(1), hjust = 0.5),
      axis.line = element_line(color = "black"),
      axis.title.x = element_text(vjust= 0, size=rel(0.9)),
      axis.title.y = element_text(vjust= 1.1, size=rel(0.9)),
      axis.text.x = element_text(margin=margin(5,5,0,0,"pt")),
      axis.text.y = element_text(margin=margin(3,5,0,3,"pt")),
      axis.ticks.length = unit(-0.7, "mm"),
      text=element_text(size = 10, family="Times"))

Putting all the steps together, here's the finished code for the graphic:


# all code with custom theme
manager_plot = ggplot() +
  geom_point(data = simulation,
             size = 0.1,
             alpha = 0.3,
             aes(x = energy_pc,
                 y = managers_employment_share,
                 color = span_of_control)
  ) +
  geom_point(data = managers_energy,
             size = 0.8,
             aes(x = energy_pc,
                 y = managers_employment_share)
  ) +
  scale_x_log10(breaks = c(5,10,20,50,100,200,500,1000)) +
  scale_y_log10(breaks = c(0.1,0.2,0.5,1,2,5,10,20)) +
  labs(x = "Energy use per capita (GJ)",
       y =  "Managers (% of Total Employment)",
       color = "Span of \nControl") +
  ggtitle("Managers Employment vs. Energy Use") +
  coord_cartesian(xlim = c(5,1000), ylim = c(0.1,30)) +
  scale_color_gradientn(colours = rainbow(8),
                        guide=guide_colourbar(reverse = T) ) +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      plot.title = element_text(face="bold", size = rel(1), hjust = 0.5),
      axis.line = element_line(color = "black"),
      axis.title.x = element_text(vjust= 0, size=rel(0.9)),
      axis.title.y = element_text(vjust= 1.1, size=rel(0.9)),
      axis.text.x = element_text(margin=margin(5,5,0,0,"pt")),
      axis.text.y = element_text(margin=margin(3,5,0,3,"pt")),
      axis.ticks.length = unit(-0.7, "mm"),
      text=element_text(size = 10, family="Times"))

<a href="https://www.youtube.com/watch?v=r0n_p7POzDE" class="whitebut ">ggplot youtube</a>

<h2>download YouTube data in R using tuber and purrr</h2>
<a href="https://www.storybench.org/how-to-download-youtube-data-in-r-using-tuber-and-purrr/" class="whitebut ">download YouTube data</a>

Accessing YouTube's metadata such as views, likes, dislikes and comments is simple in R thanks to the<code><a href="https://soodoku.github.io/tuber/articles/tuber-ex.html">tuber</a></code>

<code>install.packages("tuber")
library(tuber) # youtube API
library(magrittr) # Pipes %>%, %T>% and equals(), extract().
library(tidyverse) # all tidyverse packages
library(purrr) # package for iterating/extracting data</code>

<h3>1) Enable the APIs</h3>
First head over to your <a href="https://console.developers.google.com/apis/dashboard">Google APIs dashboard</a> (you’ll need an account for this). 
Click on “ENABLE APIS AND SERVICES”.


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-00-google-api-2-1200x419.png">

This will bring up a laundry list of APIs, but we only need the four pertaining to YouTube (see below) and the Freebase API.

Click on the search bar and type in YouTube and you should see four options. 
Enable all of them.


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-01-youtube-api-1-1200x642.png">

<k>IMPORTANT</k> you’ll also have to search for and enable the Freebase API.

<h3>2) Create your credentials</h3>
After these have been enabled, you’ll need to create credentials for the API. 
Click on the Credentials label on the left side of your Google dashboard (there should be a little key icon next to it).


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-02-google-api-credentials-1-1200x373.png">

After clicking on the Credentials icon, you’ll need to select the OAuth client ID option.


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-03-create-credentials-1.png">

<h3>Create your OAuth</h3>
Here is where we name our app and indicate it’s an “Other” Application type.


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-04-create-youtube-api-r-1-1200x673.png">

We’re told we’re limited to 100 sensitive scope logins until the OAuth consent screen is published. 
That’s not a problem for us, so we can copy the client ID and client secret


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-05-oauth-cred-google-1.png">

After clicking on the copy icons, we save them into two objects in RStudio (<code>client_id</code> and <code>client_secret</code>).

<code>client_id &lt;- "XXXXXXXXX"
client_secret &lt;- "XXXXXXXXX"</code>

<h3>3) Authenticate the application</h3>
Now you can run <code>tuber</code>’s <code>yt_oauth()</code> function to authenticate your application. 
I included the token as a blank string (<code>token = ''</code>) because it kept looking for the <code>.httr-oauth</code> in my local directory (and I didn’t create one).

<code># use the youtube oauth 
yt_oauth(app_id = client_id,
         app_secret = client_secret,
         token = '')</code>

Provided you did everything correct, this <em>should</em> open your browser and ask you to sign into the Google account you set everything up with (see the images below). 
You’ll see the name of your application in place of “<em>Your application name</em>”.


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-06-sign-in-with-youtube.png">

After signing in, you’ll be asked if the YouTube application you created can access your Google account. 
If you approve, click “Allow.”


<img class="lazy" data-src="https://www.storybench.org/wp-content/uploads/2019/09/32-07-google-credentials-allow-1-878x1200.png">

This should give you a blank page with a cryptic, <code>Authentication
complete. 
Please close this page and return to R.</code> message.

<hr class="wp-block-separator"/>

<h3>Accessing YouTube data</h3>
Great! Now that we’re all set up, we will download some data into RStudio. 
Be sure to check out the <a href="https://soodoku.github.io/tuber/reference/index.html">reference page</a> and the <a href="https://developers.google.com/youtube/v3/docs/">YouTube API reference doc</a> on how to access various meta data from YouTube videos.

We’ll download some example data from <a href="https://www.youtube.com/playlist?list=PLG6HoeSC3raE-EB8r_vVDOs-59kg3Spvd">Dave Chappelle’s comedy central playlist</a>, which is a collection of 200 of his most popular skits.

<h3>Downloading the playlist data</h3>
We will be using the <code>playlistId</code> from the url to access the content from the videos. 
Here is some information on the <code>playlistId</code> parameter:

<blockquote class="wp-block-quote">The <code>playlistId</code> parameter specifies the unique ID of the playlist for<br>
  which you want to retrieve playlist items. 
Note that even though this<br>
  is an optional parameter, every request to retrieve playlist items<br>
  must specify a value for either the <code>id</code> parameter or the <code>playlistId</code><br>
  parameter.
</blockquote>

Dave Chappelle’s playlist is in the url below. 
We pass it to the<br>
<code>stringr::str_split()</code> function to get the <code>playlistId</code> out of it.

<code>dave_chappelle_playlist_id &lt;- stringr::str_split(
    string = "https://www.youtube.com/playlist?list=PLG6HoeSC3raE-EB8r_vVDOs-59kg3Spvd", 
    pattern = "=", 
    n = 2,
    simplify = TRUE)[ , 2]
dave_chappelle_playlist_id

[1] "PLG6HoeSC3raE-EB8r_vVDOs-59kg3Spvd"</code>

Ok–we have a vector for Dave Chappelle’s <code>playlistId</code> named <code>dave_chappelle_playlist_id</code>, now we can use the <code>tuber::get_playlist_items()</code> to collect the videos into a <code>data.frame</code>.

<code>DaveChappelleRaw &lt;- tuber::get_playlist_items(filter = 
             c(playlist_id = "PLG6HoeSC3raE-EB8r_vVDOs-59kg3Spvd"), 
                                           part = "contentDetails",
                                  # set this to the number of videos
                                              max_results = 200) </code>

We should check these data to see if there is one row per video from the playlist (recall that Dave Chappelle had 200 videos).

# check the data for Dave Chappelle
DaveChappelleRaw %>% dplyr::glimpse(78)
    Observations: 200
    Variables: 6
    $ .id                             &lt;chr> "items1", "items2", "items3", "item…
    $ kind                            &lt;fct> youtube#playlistItem, youtube#playl…
    $ etag                            &lt;fct> "p4VTdlkQv3HQeTEaXgvLePAydmU/G-gTM9…
    $ id                              &lt;fct> UExHNkhvZVNDM3JhRS1FQjhyX3ZWRE9zLTU…
    $ contentDetails.videoId          &lt;fct> oO3wTulizvg, ZX5MHNvjw7o, MvZ-clcMC…
    $ contentDetails.videoPublishedAt &lt;fct> 2019-04-28T16:00:07.000Z, 2017-12-3…

<h3>Collecting statistics from a YouTube playlist</h3>
Now that we have all of the video <code>ids</code> (not <code>.id</code>), we can create a function that extracts the statistics for each video on the playlist. 
We’ll start by putting the video ids in a vector and call it <code>dave_chap_ids</code>.

dave_chap_ids = base::as.vector(DaveChappelleRaw$contentDetails.videoId)
dplyr::glimpse(dave_chap_ids)
chr [1:200] "oO3wTulizvg" "ZX5MHNvjw7o" "MvZ-clcMCec" "4trBQseIkkc" ...

<code>tuber</code> has a <code>get_stats()</code> function we will use with the vector we just created for the show ids.

<code># Function to scrape stats for all vids
get_all_stats &lt;- function(id) {
  tuber::get_stats(video_id = id)
} </code>

<h3>Using purrr to iterate and extract metadata </h3>
Now we introduce a bit of iteration from <a href="https://purrr.tidyverse.org/">the <code>purrr</code> package</a>. 
The <code>purrr</code> package provides tools for ‘functional programming,’ but that is a much bigger topic for a later post.

For now, just know that the <code>purrr::map_df()</code> function takes an object as .<code>x</code>, and whatever function is listed in <code>.f</code> gets applied over the <code>.x</code> object. 
Check out the code below:

# Get stats and convert results to data frame 
DaveChappelleAllStatsRaw = purrr::map_df(.x = dave_chap_ids, 
                                          .f = get_all_stats)

DaveChappelleAllStatsRaw %>% dplyr::glimpse(78)

Observations: 200
Variables: 6
$ id            &lt;chr> "oO3wTulizvg", "ZX5MHNvjw7o", "MvZ-clcMCec", "4trBQse…
$ viewCount     &lt;chr> "4446789", "19266680", "6233018", "8867404", "7860341…
$ likeCount     &lt;chr> "48699", "150691", "65272", "92259", "56584", "144625…
$ dislikeCount  &lt;chr> "1396", "6878", "1530", "2189", "1405", "3172", "1779…
$ favoriteCount &lt;chr> "0", "0", "0", "0", "0", "0", "0", "0", "0", "0", "0"…
$ commentCount  &lt;chr> "2098", "8345", "5130", "5337", "2878", "9071", "4613…

Fantastic! We have the <code>DaveChappelleRaw</code> and <code>DaveChappelleAllStatsRaw</code> in two <code>data.frame</code>s we can export (and timestamp!)

# export DaveChappelleRaw
readr::write_csv(x = as.data.frame(DaveChappelleRaw), 
                 path = paste0("data/", 
                               base::noquote(lubridate::today()),
                               "-DaveChappelleRaw.csv"))

# export DaveChappelleRaw
readr::write_csv(x = as.data.frame(DaveChappelleAllStatsRaw), 
                 path = paste0("data/", 
                               base::noquote(lubridate::today()),
                               "-DaveChappelleAllStatsRaw.csv"))

# verify
fs::dir_ls("data", regexp = "Dave")

Be sure to go through the following <code>purrr</code> tutorials if you want to learn more about functional programming:

<a href="http://r4ds.had.co.nz/iteration.html#the-map-functions">R for Data Science by H. Wickham & G.
Grolemund</a>
<a href="https://jennybc.github.io/purrr-tutorial/">purrr Tutorial by J.
Bryan</a>
<a href="https://github.com/cwickham/purrr-tutorial">A purrr tutorial - useR! 2017 by C.
Wickham</a>
<a href="https://colinfay.me/happy-dev-purrr/">Happy dev with {purrr} - by C. Fay</a>

Also check out the <a href="https://www.storybench.org/how-to-access-apis-in-r/">previous post on using
APIs</a>.

<h2>R package library</h2>
to remove package: may not work!
remove.packages('dplyr')

to install dplyr, first install Rcpp, one by one
install.packages("Rcpp")

install.packages("dplyr")

this is the c compiler"
C:/RBuildTools/3.4/mingw_64/bin/g++  -I"D:/R-3.4.3/include" -DNDEBUG          -O2 -Wall  -mtune=generic -c slice.cpp -o slice.o

The downloaded source packages are in
‘C:\Users\User\AppData\Local\Temp\Rtmp0sfeZ8\downloaded_packages’

to manually deleting the dplyr folder
find the folder

Change the Default Library in Rstudio
view the current library path:

.libPaths gets/sets the library trees within which packages are looked for.

.libPaths()                 # all library trees R knows about
"<span class="red">D:/R-3.4.3/library</span>"

https://stackoverflow.com/questions/31707941/how-do-i-change-the-default-library-path-for-r-packages/42643674

<h2>Sorting by Multiple Columns</h2>
dataset[with(dataset, order(z, x)),]
dataset[with(dataset, order(-z, b)),]

with dplyr Package arrange Function

library("dplyr")
arrange(data, x2, x3)

with data.table Package

library("data.table")
data_ordered = data
setorder(data_ordered, x2, x3)
data_ordered

<h2>print frequency table vertically</h2>
options("encoding" = "native.enc")
thelist = readLines("thelist.txt", encoding="UTF-8")

thetable = sort(table(thelist),  decreasing = TRUE)

names(thetable)
for(i in 1:length(thetable)){
  cat(names(thetable[i]), thetable[i],"\n")
}

<h2>reorder table</h2>
activityList = readLines("testtrial.txt", encoding="UTF-8")
activityList <= matrix(unlist(strsplit(activityList, split = ",")), ncol=2, byrow=TRUE)
sink("result.txt")
write.table(activityList[order(activityList[,1]),], row.names=F, col.names=F, quote=F)
sink()

<h2>dump data</h2>
keywordList &lt;-
structure(list(structure(list(node = &lt;pointer: 0x0000000003a118b0>, 
    doc = &lt;pointer: 0x000000001166c5f0>), .Names = c("node", 
"doc"), class = "xml_node")), class = "xml_nodeset")

<h2>Appending a list to a list of lists</h2>
    histList = list()
    for(item in historyList){
      setwd(paste0(folderName,"/",item))
      alist = readLines("alarm history.txt")
      histList[[length(histList)+1]] = list(alist)
      setwd("..")
    }

L=list()
for (i in 1:3) { L=c(L, list(list(sample(1:3)))) }


<h2>find the mode name of vector</h2>
x = c(1,2,4,3,3,4,5,6,6,4,3,2,3,4)
freqtable = table(x)
names(freqtable)[freqtable == max(freqtable)]

<h2>分佈式計算</h2>
在全世界個人電腦用戶等的協作下，推進新冠病毒蛋白質結構分析的分佈式計算項目「Folding@home（FAH）」實現了最尖端超級計算機也尚未達到的「Exa級」計算能力。

分佈式計算又被稱為網格計算，除FAH以外，還有很多項目在採用，例如美國加州大學柏克萊分校的「SETI@home」，該項目1999年啟動，通過射電望遠鏡探測地球以外智慧生命體的信號證據，於今年3月結束。

在物聯網（IoT）時代，名為邊緣計算（EdgeComputing）的分佈式系統正在受到關注。
速度快、延遲少的新一代通信標準「5G」對其起到支撐作用。

<h2>Make R Studio plots only show up in new window</h2>
In RStudio, the default graphics device is normally "RStudioGD".
Change that to something else: the normal choices are "windows" on Windows

options(device = "windows")
dev.new()
Call dev.new() after changing the option

or try using the windows command before your plot call.
windows()

To open another window, run the command a second time to open a second window.

dev.off() will shut down the window (in the order they were opened by default).

Commenting the following lines in "RStudio\R\Tools.R"

# set our graphics device as the default and cause it to be created/set
.rs.addFunction( "initGraphicsDevice", function()
{
   # options(device="RStudioGD")
   # grDevices::deviceIsInteractive("RStudioGD")
  grDevices::deviceIsInteractive()
})

<h2>Describing data using Hmisc and psych package - R Programming</h2><a href="https://www.youtube.com/watch?v=2F1RioDkBUg">
<img class="lazy" data-src="https://i.ytimg.com/vi/2F1RioDkBUg/hqdefault.jpg"></a>
<h2>Data Aggregation and Structure (Simple or Pivot)|| Simple Table||Pivot Table</h2><a href="https://www.youtube.com/watch?v=guSQmfjdP_U">
<img class="lazy" data-src="https://i.ytimg.com/vi/guSQmfjdP_U/hqdefault.jpg"></a>
<h2>Creating Joins on Datasets or Data frames|| Datasets|| Data Frames</h2><a href="https://www.youtube.com/watch?v=tiFMmnoDzzc">
<img class="lazy" data-src="https://i.ytimg.com/vi/tiFMmnoDzzc/hqdefault.jpg"></a>

<h2>Creating and adding calculated column to dataset / dataframe|| Dataset and Dataframe</h2><a href="https://www.youtube.com/watch?v=CsFRM1_heM4">
<img class="lazy" data-src="https://i.ytimg.com/vi/CsFRM1_heM4/hqdefault.jpg"></a>
<h2>Identifying duplicate rows in dataset and removing them</h2><a href="https://www.youtube.com/watch?v=LKoknpFOEUw">
<img class="lazy" data-src="https://i.ytimg.com/vi/LKoknpFOEUw/hqdefault.jpg"></a>
<h2>Hypothesis testing in theory</h2><a href="https://www.youtube.com/watch?v=RV8h9B4BV8k">
<img class="lazy" data-src="https://i.ytimg.com/vi/RV8h9B4BV8k/hqdefault.jpg"></a>
<h2>DataFrame and Matrix aggregation functions</h2><a href="https://www.youtube.com/watch?v=Mc2eNpOS530">
<img class="lazy" data-src="https://i.ytimg.com/vi/Mc2eNpOS530/hqdefault.jpg"></a>
<h2>Interpretation of statisitcal terms in Linear Regression</h2><a href="https://www.youtube.com/watch?v=QuXN9oKL48Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/QuXN9oKL48Y/hqdefault.jpg"></a>

<h2>Combining multiple datasets</h2><a href="https://www.youtube.com/watch?v=_qJpnrvYbK4">
<img class="lazy" data-src="https://i.ytimg.com/vi/_qJpnrvYbK4/hqdefault.jpg"></a>
<h2>Exploring Apply function</h2><a href="https://www.youtube.com/watch?v=3RXJhMq9jFY">
<img class="lazy" data-src="https://i.ytimg.com/vi/3RXJhMq9jFY/hqdefault.jpg"></a>
<h2>R Apply family functions</h2><a href="https://www.youtube.com/watch?v=pS4AkSBomBo">
<img class="lazy" data-src="https://i.ytimg.com/vi/pS4AkSBomBo/hqdefault.jpg"></a>

<h2>Fetching Data from Vector & Matrix|| R Vector|| R Matrix</h2><a href="https://www.youtube.com/watch?v=AWeAs622y6s">
<img class="lazy" data-src="https://i.ytimg.com/vi/AWeAs622y6s/hqdefault.jpg"></a>
<h2>R House keeping commands like ls and rm to manage objects|| R-Is|| R- rm||R Programming Tutorial</h2><a href="https://www.youtube.com/watch?v=2q-VNrRHr04">
<img class="lazy" data-src="https://i.ytimg.com/vi/2q-VNrRHr04/hqdefault.jpg"></a>
<h2>Sample Data in R | Sample datasets for data mining | sample data sets for statistical analysis</h2><a href="https://www.youtube.com/watch?v=Q3hSogORyZo">
<img class="lazy" data-src="https://i.ytimg.com/vi/Q3hSogORyZo/hqdefault.jpg"></a>
<h2>Creating Simple Dataset in R using Combine and Scan command|| R Programming</h2><a href="https://www.youtube.com/watch?v=10Jm0yAX03w">
<img class="lazy" data-src="https://i.ytimg.com/vi/10Jm0yAX03w/hqdefault.jpg"></a>

<h2>Code | Market Basket Analysis | Association Rules | R Programming</h2><a href="https://www.youtube.com/watch?v=2otyDYe_V0o">
<img class="lazy" data-src="https://i.ytimg.com/vi/2otyDYe_V0o/hqdefault.jpg"></a>
<h2>Automating Assocation Rules or Market Basket Analysis in Shiny | R Programming | Shiny</h2><a href="https://www.youtube.com/watch?v=jzdwMA5BVyI">
<img class="lazy" data-src="https://i.ytimg.com/vi/jzdwMA5BVyI/hqdefault.jpg"></a>

<h2>RStudio and Git - an Example (Part 2)</h2><a href="https://www.youtube.com/watch?v=qcjpHFwCugE">
<img class="lazy" data-src="https://i.ytimg.com/vi/qcjpHFwCugE/hqdefault.jpg"></a>
<h2>RStudio and Git - an Overview (Part 1)</h2><a href="https://www.youtube.com/watch?v=KjLycV1IWqc">
<img class="lazy" data-src="https://i.ytimg.com/vi/KjLycV1IWqc/hqdefault.jpg"></a>
<h2>The Production Function Model, An Introduction - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=-rteAEb3iJM">
<img class="lazy" data-src="https://i.ytimg.com/vi/-rteAEb3iJM/hqdefault.jpg"></a>
<h2>A Change in the Rate of Depreciation (delta) - Solow Model Application Part 3 of 4</h2><a href="https://www.youtube.com/watch?v=-eanLMbhjac">
<img class="lazy" data-src="https://i.ytimg.com/vi/-eanLMbhjac/hqdefault.jpg"></a>
<h2>A Change in Technology - Solow Model Application - Part 4 of 4</h2><a href="https://www.youtube.com/watch?v=9-3TFXc5yxo">
<img class="lazy" data-src="https://i.ytimg.com/vi/9-3TFXc5yxo/hqdefault.jpg"></a>
<h2>Solow Model Transition Dynamics (Level vs. Growth Effects) - Part 5 of 5</h2><a href="https://www.youtube.com/watch?v=Bdr34lhGI-Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/Bdr34lhGI-Q/hqdefault.jpg"></a>
<h2>Golden Rule Level of Capital & Savings Rate - Solow Model</h2><a href="https://www.youtube.com/watch?v=HGxr6cwnPfo">
<img class="lazy" data-src="https://i.ytimg.com/vi/HGxr6cwnPfo/hqdefault.jpg"></a>
<h2>A Change in the Savings Rate (s) - Solow Model Application Part 2 of 4</h2><a href="https://www.youtube.com/watch?v=IiPWNiKhrL0">
<img class="lazy" data-src="https://i.ytimg.com/vi/IiPWNiKhrL0/hqdefault.jpg"></a>
<h2>A Reduction in the Capital Stock - War! - Solow Model Application Part 1 of 4</h2><a href="https://www.youtube.com/watch?v=K3XmPnV_j-I">
<img class="lazy" data-src="https://i.ytimg.com/vi/K3XmPnV_j-I/hqdefault.jpg"></a>
<h2>Solow Swan Model with Population Growth - Part 1 of 2</h2><a href="https://www.youtube.com/watch?v=cESaITRvS2o">
<img class="lazy" data-src="https://i.ytimg.com/vi/cESaITRvS2o/hqdefault.jpg"></a>
<h2>Solow Model with Technology Growth and Population Growth - Part 2 of 5</h2><a href="https://www.youtube.com/watch?v=eIXquvF3N_Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/eIXquvF3N_Q/hqdefault.jpg"></a>
<h2>Solow Model Diagram - Adding Technology & Population Growth - Part 3 of 5</h2><a href="https://www.youtube.com/watch?v=mDiVFk7wj3w">
<img class="lazy" data-src="https://i.ytimg.com/vi/mDiVFk7wj3w/hqdefault.jpg"></a>
<h2>Solow Model with Technology Growth and Population Growth - Part 1 of 5</h2><a href="https://www.youtube.com/watch?v=md0cjl51JTk">
<img class="lazy" data-src="https://i.ytimg.com/vi/md0cjl51JTk/hqdefault.jpg"></a>
<h2>Calculating Growth Rates of the Solow Swan Model - Part 4 of 5</h2><a href="https://www.youtube.com/watch?v=qQc94rpvNPI">
<img class="lazy" data-src="https://i.ytimg.com/vi/qQc94rpvNPI/hqdefault.jpg"></a>
<h2>Solow Swan Model with Population Growth - Part 2 of 2</h2><a href="https://www.youtube.com/watch?v=rjHrm06s0kY">
<img class="lazy" data-src="https://i.ytimg.com/vi/rjHrm06s0kY/hqdefault.jpg"></a>
<h2>Solow Model - Transition Dynamics & Time Series (Part 4)</h2><a href="https://www.youtube.com/watch?v=-06UOz8or34">
<img class="lazy" data-src="https://i.ytimg.com/vi/-06UOz8or34/hqdefault.jpg"></a>
<h2>Solow Model Application   Effect of an Increase in the Savings Rate</h2><a href="https://www.youtube.com/watch?v=2h2BJIJRJMM">
<img class="lazy" data-src="https://i.ytimg.com/vi/2h2BJIJRJMM/hqdefault.jpg"></a>
<h2>Solow Model (Part 1 of Many)</h2><a href="https://www.youtube.com/watch?v=Dx7ZvAKfL9k">
<img class="lazy" data-src="https://i.ytimg.com/vi/Dx7ZvAKfL9k/hqdefault.jpg"></a>
<h2>Solow Model Example - The Effect of Destruction of Capital</h2><a href="https://www.youtube.com/watch?v=GqDln9wE3Lk">
<img class="lazy" data-src="https://i.ytimg.com/vi/GqDln9wE3Lk/hqdefault.jpg"></a>
<h2>Solow Model Problem - Change in the Rate of Depreciation</h2><a href="https://www.youtube.com/watch?v=PDZUeYH6nn0">
<img class="lazy" data-src="https://i.ytimg.com/vi/PDZUeYH6nn0/hqdefault.jpg"></a>
<h2>Solow Model - The Steady State Level of Capital (Part 2)</h2><a href="https://www.youtube.com/watch?v=PfTJQrL1QZc">
<img class="lazy" data-src="https://i.ytimg.com/vi/PfTJQrL1QZc/hqdefault.jpg"></a>
<h2>Solow Model Example - A Change in Population Growth Rate</h2><a href="https://www.youtube.com/watch?v=Row9WKvqA18">
<img class="lazy" data-src="https://i.ytimg.com/vi/Row9WKvqA18/hqdefault.jpg"></a>
<h2>Solow Model - Solow Diagram & Convergence (Part 3)</h2><a href="https://www.youtube.com/watch?v=UwQBlJ6ve5U">
<img class="lazy" data-src="https://i.ytimg.com/vi/UwQBlJ6ve5U/hqdefault.jpg"></a>
<h2>Application of Solow Swan Model - Effect of an Increase in Technology Growth</h2><a href="https://www.youtube.com/watch?v=r3jI1dAIueU">
<img class="lazy" data-src="https://i.ytimg.com/vi/r3jI1dAIueU/hqdefault.jpg"></a>
<h2>Level-Log Regression & Interpretation (What do the Regression Coefficient Estimate Results Mean?)</h2><a href="https://www.youtube.com/watch?v=L9ZL6_DB4fQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/L9ZL6_DB4fQ/hqdefault.jpg"></a>
<h2>Log-Level Regression & Interpretation (What do the Regression Coefficient Estimate Results Mean?)</h2><a href="https://www.youtube.com/watch?v=wXC2kViEGz8">
<img class="lazy" data-src="https://i.ytimg.com/vi/wXC2kViEGz8/hqdefault.jpg"></a>
<h2>Log-Log Regression & Interpretation (What do the Regression Coefficient Estimate Results Mean?)</h2><a href="https://www.youtube.com/watch?v=NZCSt9WkpkI">
<img class="lazy" data-src="https://i.ytimg.com/vi/NZCSt9WkpkI/hqdefault.jpg"></a>
<h2>Level-Level Regression & Interpretation (What do Coefficient Estimate Results Mean?)</h2><a href="https://www.youtube.com/watch?v=TJACbJspao0">
<img class="lazy" data-src="https://i.ytimg.com/vi/TJACbJspao0/hqdefault.jpg"></a>
<h2>Do a Linear Regression (with free R Statistics Software)</h2><a href="https://www.youtube.com/watch?v=Ktks5K95uQM">
<img class="lazy" data-src="https://i.ytimg.com/vi/Ktks5K95uQM/hqdefault.jpg"></a>
<h2>IS-LM Model Diagrams - The Effect of Policy Mixes - Shifting Both the IS and LM Curves</h2><a href="https://www.youtube.com/watch?v=ZA66asJE0ew">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZA66asJE0ew/hqdefault.jpg"></a>
<h2>ISLM Practice Problem Part 1 - Deriving the IS and LM Curves, and the IS-LM Diagram</h2><a href="https://www.youtube.com/watch?v=_19w5dcGhCo">
<img class="lazy" data-src="https://i.ytimg.com/vi/_19w5dcGhCo/hqdefault.jpg"></a>
<h2>IS-LM Equations - Deriving Aggregate Demand Equation</h2><a href="https://www.youtube.com/watch?v=5EPvwarCqDA">
<img class="lazy" data-src="https://i.ytimg.com/vi/5EPvwarCqDA/hqdefault.jpg"></a>
<h2>IS-LM Curves and Diagram and a Change in the Price Level</h2><a href="https://www.youtube.com/watch?v=yBBpE8PzoKU">
<img class="lazy" data-src="https://i.ytimg.com/vi/yBBpE8PzoKU/hqdefault.jpg"></a>
<h2>IS-LM Model & Diagram - LM Curve Shift from a Monetary Shock (Money Supply Increase)</h2><a href="https://www.youtube.com/watch?v=b28lsOUFOtw">
<img class="lazy" data-src="https://i.ytimg.com/vi/b28lsOUFOtw/hqdefault.jpg"></a>
<h2>IS-LM Curves and Diagram - Fiscal Shock and a Shift to the IS Curve (Government Purchases Increase)</h2><a href="https://www.youtube.com/watch?v=vx6w5JFIjzw">
<img class="lazy" data-src="https://i.ytimg.com/vi/vx6w5JFIjzw/hqdefault.jpg"></a>
<h2>Macro Problem - Calculate the IS Curve & LM Curve Equations - Equilibrium Interest Rate & Output</h2><a href="https://www.youtube.com/watch?v=pAX7mR4ii5Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/pAX7mR4ii5Y/hqdefault.jpg"></a>
<h2>Macro Problem - Numerical Example with Money Demand and Supply - Find Equilibrium Interest Rate</h2><a href="https://www.youtube.com/watch?v=BX7b1EUn5_Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/BX7b1EUn5_Y/hqdefault.jpg"></a>
<h2>Solow Growth Model Diagram Problem - Shocks & Effects on Steady State per-worker Capital & Output</h2><a href="https://www.youtube.com/watch?v=MRwX8vvpHio">
<img class="lazy" data-src="https://i.ytimg.com/vi/MRwX8vvpHio/hqdefault.jpg"></a>
<h2>Solow Model Diagram Problem - Effect of Decrease in Population Growth (per capita Capital & Output)</h2><a href="https://www.youtube.com/watch?v=ceqUYIYd2Og">
<img class="lazy" data-src="https://i.ytimg.com/vi/ceqUYIYd2Og/hqdefault.jpg"></a>
<h2>Solow Model Practice - Calculate the Steady State & Compare Economies with Varying Saving Rates</h2><a href="https://www.youtube.com/watch?v=b0FZuvKvOyo">
<img class="lazy" data-src="https://i.ytimg.com/vi/b0FZuvKvOyo/hqdefault.jpg"></a>
<h2>Macro Problem - Central Bank Loss Function and Alternative Inflation Targets</h2><a href="https://www.youtube.com/watch?v=-FH4U0eBX80">
<img class="lazy" data-src="https://i.ytimg.com/vi/-FH4U0eBX80/hqdefault.jpg"></a>
<h2>Tax Cut and the Traditional View vs Ricardian View - Public, Private & National Savings</h2><a href="https://www.youtube.com/watch?v=5BiR3caIL4s">
<img class="lazy" data-src="https://i.ytimg.com/vi/5BiR3caIL4s/hqdefault.jpg"></a>
<h2>Macro Practice - Political Business Cycle - Independent Central Bank and Inflation & Unemployment</h2><a href="https://www.youtube.com/watch?v=l00xcKtVEQk">
<img class="lazy" data-src="https://i.ytimg.com/vi/l00xcKtVEQk/hqdefault.jpg"></a>
<h2>Macro Problem - Hysteresis vs the Natural Rate Hypothesis - Inflation and Unemployment Trade-off</h2><a href="https://www.youtube.com/watch?v=-7n5PgdLF5Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/-7n5PgdLF5Y/hqdefault.jpg"></a>
<h2>Macro Problem - Sticky Price Model and an Unanticipated Monetary Expansion (vs Anticipated)</h2><a href="https://www.youtube.com/watch?v=EDXaAyhVhl4">
<img class="lazy" data-src="https://i.ytimg.com/vi/EDXaAyhVhl4/hqdefault.jpg"></a>
<h2>Macro Practice - Social Security, Marginal Propensity to Consume & Altruistically Linked Generations</h2><a href="https://www.youtube.com/watch?v=xk4U1KQi6Nk">
<img class="lazy" data-src="https://i.ytimg.com/vi/xk4U1KQi6Nk/hqdefault.jpg"></a>
<h2>Macro Problem - Trade-Off Between Inflation, Unemployment and GDP</h2><a href="https://www.youtube.com/watch?v=q3Uey9ladUg">
<img class="lazy" data-src="https://i.ytimg.com/vi/q3Uey9ladUg/hqdefault.jpg"></a>
<h2>What is Decreasing Returns to Scale (DRS)?  - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=vellgNFKztw">
<img class="lazy" data-src="https://i.ytimg.com/vi/vellgNFKztw/hqdefault.jpg"></a>
<h2>What is Increasing Returns to Scale (IRS)?   - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=5W7GUxomGpM">
<img class="lazy" data-src="https://i.ytimg.com/vi/5W7GUxomGpM/hqdefault.jpg"></a>
<h2>What is Constant Returns to Scale (CRS)?   - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=in6CK8sTQgk">
<img class="lazy" data-src="https://i.ytimg.com/vi/in6CK8sTQgk/hqdefault.jpg"></a>
<h2>Calculate Returns to Scale - Nine Different Prod. Func. Examples - Intermediate Macro economics</h2><a href="https://www.youtube.com/watch?v=gPyPvWxJOlc">
<img class="lazy" data-src="https://i.ytimg.com/vi/gPyPvWxJOlc/hqdefault.jpg"></a>
<h2>Returns to Scale Overview - Definition & Discussion - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=AttvGU47Eg8">
<img class="lazy" data-src="https://i.ytimg.com/vi/AttvGU47Eg8/hqdefault.jpg"></a>
<h2>Fiscal Expansion + Classical Model of a Closed Economy in the Long Run - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=RJ7a5nEU5aA">
<img class="lazy" data-src="https://i.ytimg.com/vi/RJ7a5nEU5aA/hqdefault.jpg"></a>
<h2>Impact of Fiscal Contraction on Closed Economy Long Run Model - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=69mSo2pIXUk">
<img class="lazy" data-src="https://i.ytimg.com/vi/69mSo2pIXUk/hqdefault.jpg"></a>
<h2>Change In Investment Demand and the Loanable Funds Market - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=2j780pByEeI">
<img class="lazy" data-src="https://i.ytimg.com/vi/2j780pByEeI/hqdefault.jpg"></a>
<h2>The Classical Model - A Closed Economy in the Long Run & Market for Loanable Funds -  Macroeconomics</h2><a href="https://www.youtube.com/watch?v=JlOs6AyYiTY">
<img class="lazy" data-src="https://i.ytimg.com/vi/JlOs6AyYiTY/hqdefault.jpg"></a>
<h2>Small Open Economy Model Overview - Example with a Drop in Consumer Confidence - Intermediate Macro</h2><a href="https://www.youtube.com/watch?v=8NsstM92wtM">
<img class="lazy" data-src="https://i.ytimg.com/vi/8NsstM92wtM/hqdefault.jpg"></a>
<h2>Real Wages Related to Labor Productivity, Laborss Share of Income (with Cobb-Douglas Prod Function)</h2><a href="https://www.youtube.com/watch?v=9baU77J-eJ8">
<img class="lazy" data-src="https://i.ytimg.com/vi/9baU77J-eJ8/hqdefault.jpg"></a>
<h2>Find Changes in the Fraction of Income to Labor, Output, Rental Price of Capital and the Real Wage</h2><a href="https://www.youtube.com/watch?v=FImvmUDNBFA">
<img class="lazy" data-src="https://i.ytimg.com/vi/FImvmUDNBFA/hqdefault.jpg"></a>
<h2>Cobb-Douglas Production Function Differentiation Example</h2><a href="https://www.youtube.com/watch?v=rYsNHYgIUL4">
<img class="lazy" data-src="https://i.ytimg.com/vi/rYsNHYgIUL4/hqdefault.jpg"></a>
<h2>Quickly find output, wages rental price of land, and laborss share of income</h2><a href="https://www.youtube.com/watch?v=hIgcnjU-7g8">
<img class="lazy" data-src="https://i.ytimg.com/vi/hIgcnjU-7g8/hqdefault.jpg"></a>
<h2>Laborss Share of Income - Intermediate Macroeconomics</h2><a href="https://www.youtube.com/watch?v=C-czP-S55hg">
<img class="lazy" data-src="https://i.ytimg.com/vi/C-czP-S55hg/hqdefault.jpg"></a>
<h2>The Production Function, Finding the Wage Rate, Rental Rate, and Laborss Share of Income</h2><a href="https://www.youtube.com/watch?v=5rLbBV--W7o">
<img class="lazy" data-src="https://i.ytimg.com/vi/5rLbBV--W7o/hqdefault.jpg"></a>
<h2>Shifts in both Supply and Demand Curves - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=EiYbrhFwErI">
<img class="lazy" data-src="https://i.ytimg.com/vi/EiYbrhFwErI/hqdefault.jpg"></a>
<h2>Shifts to Demand or Supply Curves - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=es_g3L1kmR8">
<img class="lazy" data-src="https://i.ytimg.com/vi/es_g3L1kmR8/hqdefault.jpg"></a>
<h2>Supply and Demand (and Equilibrium Price & Quanitity) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=op70yS_7du8">
<img class="lazy" data-src="https://i.ytimg.com/vi/op70yS_7du8/hqdefault.jpg"></a>
<h2>Continuous Time Rock Paper Scissors (RPS) - ConG Experiment Software</h2><a href="https://www.youtube.com/watch?v=41YlphE4J54">
<img class="lazy" data-src="https://i.ytimg.com/vi/41YlphE4J54/hqdefault.jpg"></a>
<h2>Discrete Time Rock Paper Scissors (RPS) - ConG Experiment Software</h2><a href="https://www.youtube.com/watch?v=fr2HoiOIwjA">
<img class="lazy" data-src="https://i.ytimg.com/vi/fr2HoiOIwjA/hqdefault.jpg"></a>
<h2>Break Even Price and Shut Down Price -- Calculate and Interpret</h2><a href="https://www.youtube.com/watch?v=0nrt-SFwvOI">
<img class="lazy" data-src="https://i.ytimg.com/vi/0nrt-SFwvOI/hqdefault.jpg"></a>
<h2>What is the Shut Down Price, Find the Break Even Price? - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=0dUetpTRxJ8">
<img class="lazy" data-src="https://i.ytimg.com/vi/0dUetpTRxJ8/hqdefault.jpg"></a>
<h2>Firm Entry and Exit - Will Firms Enter or Exit a Perfectly Competitive Market?</h2><a href="https://www.youtube.com/watch?v=IyJXO89Ss98">
<img class="lazy" data-src="https://i.ytimg.com/vi/IyJXO89Ss98/hqdefault.jpg"></a>
<h2>Example of a Firm in a Perfectly Competitive Market - Economic Profits and Firm Entry</h2><a href="https://www.youtube.com/watch?v=S3nulylUYQ0">
<img class="lazy" data-src="https://i.ytimg.com/vi/S3nulylUYQ0/hqdefault.jpg"></a>
<h2>The Firmss Supply Curve - Given Firm Costs Information, Draw and Interpret the Firm Supply Curve</h2><a href="https://www.youtube.com/watch?v=SuvaPSov21E">
<img class="lazy" data-src="https://i.ytimg.com/vi/SuvaPSov21E/hqdefault.jpg"></a>
<h2>Total Utility and Marginal Utility - Definition & Overview - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=Yfslg-hFSiM">
<img class="lazy" data-src="https://i.ytimg.com/vi/Yfslg-hFSiM/hqdefault.jpg"></a>
<h2>How to Calculate Marginal Cost, Average Total Cost, Average Variable Cost, and Average Fixed Cost</h2><a href="https://www.youtube.com/watch?v=3-j-rZ6hz74">
<img class="lazy" data-src="https://i.ytimg.com/vi/3-j-rZ6hz74/hqdefault.jpg"></a>
<h2>Giffen Good Example - Price Change, Income and Substitution Effect - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=VRC-DVqKYCE">
<img class="lazy" data-src="https://i.ytimg.com/vi/VRC-DVqKYCE/hqdefault.jpg"></a>
<h2>Income and Substitution Effects with an Inferior Good - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=GB3VVQaNC4k">
<img class="lazy" data-src="https://i.ytimg.com/vi/GB3VVQaNC4k/hqdefault.jpg"></a>
<h2>Income Effect and Substitution Effect - a long rambling discussion</h2><a href="https://www.youtube.com/watch?v=1DCb6dIXYfM">
<img class="lazy" data-src="https://i.ytimg.com/vi/1DCb6dIXYfM/hqdefault.jpg"></a>
<h2>Marginal Utility Examples - Increasing, Diminishing and Constant - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=BS-3NXVpdaA">
<img class="lazy" data-src="https://i.ytimg.com/vi/BS-3NXVpdaA/hqdefault.jpg"></a>
<h2>Positive and Zero Marginal Utility Examples -- Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=_QzZEntl6XI">
<img class="lazy" data-src="https://i.ytimg.com/vi/_QzZEntl6XI/hqdefault.jpg"></a>
<h2>Calculating Marginal Utility - Example from Introduction to Microeconomics</h2><a href="https://www.youtube.com/watch?v=tmfXKaUjo5Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/tmfXKaUjo5Q/hqdefault.jpg"></a>
<h2>Example of Optimal Consumption Bundle - Income and Substitution Effect</h2><a href="https://www.youtube.com/watch?v=zHrrsJlXVt8">
<img class="lazy" data-src="https://i.ytimg.com/vi/zHrrsJlXVt8/hqdefault.jpg"></a>
<h2>Substitution and Income Effect Examples - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=BEb3-fpgG4s">
<img class="lazy" data-src="https://i.ytimg.com/vi/BEb3-fpgG4s/hqdefault.jpg"></a>
<h2>Utility Maximization with Budget Line + Indifference Curves - Price and Income Changes</h2><a href="https://www.youtube.com/watch?v=airLmoNWNw8">
<img class="lazy" data-src="https://i.ytimg.com/vi/airLmoNWNw8/hqdefault.jpg"></a>
<h2>Consumer Budget Constraint Shift Example</h2><a href="https://www.youtube.com/watch?v=l1DFLAIgewk">
<img class="lazy" data-src="https://i.ytimg.com/vi/l1DFLAIgewk/hqdefault.jpg"></a>
<h2>Utility Maximization Example with Perfect Compliments - Price Change - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=tnehG-Qn_Rg">
<img class="lazy" data-src="https://i.ytimg.com/vi/tnehG-Qn_Rg/hqdefault.jpg"></a>
<h2>Utility Maximization Example with Inferior Good - Price Change, Income and Substitution Effect</h2><a href="https://www.youtube.com/watch?v=nR3dyoPjgjc">
<img class="lazy" data-src="https://i.ytimg.com/vi/nR3dyoPjgjc/hqdefault.jpg"></a>
<h2>Demand & Supply Curves with an Excise Tab (Example, Texarkana Cigarettes - Intro to Microeconomics)</h2><a href="https://www.youtube.com/watch?v=DpAUgi9O2qE">
<img class="lazy" data-src="https://i.ytimg.com/vi/DpAUgi9O2qE/hqdefault.jpg"></a>
<h2>Example of Excise Tax with Supply & Demand Curves - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=axgM7dpRbbw">
<img class="lazy" data-src="https://i.ytimg.com/vi/axgM7dpRbbw/hqdefault.jpg"></a>
<h2>Working Through Elasticity Examples - Demand Elasticity & Income Elasticity - Intro to Micro</h2><a href="https://www.youtube.com/watch?v=zVuHHOUhp14">
<img class="lazy" data-src="https://i.ytimg.com/vi/zVuHHOUhp14/hqdefault.jpg"></a>
<h2>Price and Income Elasticity Word Problem - VW Beetles - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=fACUQeXNw6s">
<img class="lazy" data-src="https://i.ytimg.com/vi/fACUQeXNw6s/hqdefault.jpg"></a>
<h2>Price and Income Elasticity - Midpoint Method - Tourist T-shirts - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=u8TWHUbIzlk">
<img class="lazy" data-src="https://i.ytimg.com/vi/u8TWHUbIzlk/hqdefault.jpg"></a>
<h2>Quota - Quantity Control Example - Maine Lobster - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=CiKEmE7scwk">
<img class="lazy" data-src="https://i.ytimg.com/vi/CiKEmE7scwk/hqdefault.jpg"></a>
<h2>Price Floor Example - USDA & Milk - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=Pe8uxhvJGnU">
<img class="lazy" data-src="https://i.ytimg.com/vi/Pe8uxhvJGnU/hqdefault.jpg"></a>
<h2>Price Controls - New York City Bread - Both Price Floor & Price Ceiling - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=3jxCwP4N5ww">
<img class="lazy" data-src="https://i.ytimg.com/vi/3jxCwP4N5ww/hqdefault.jpg"></a>
<h2>Marginal Analysis Example - Marginal Cost & Marginal Benefit - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=tKmzUYttrzY">
<img class="lazy" data-src="https://i.ytimg.com/vi/tKmzUYttrzY/hqdefault.jpg"></a>
<h2>Opportunity Cost Examples - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=ftJM9yf-HxQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/ftJM9yf-HxQ/hqdefault.jpg"></a>
<h2>Producer Surplus (Taxis) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=8UrS9J4NCJc">
<img class="lazy" data-src="https://i.ytimg.com/vi/8UrS9J4NCJc/hqdefault.jpg"></a>
<h2>Consumer Surplus (Fun World) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=cFRkcO6KRe8">
<img class="lazy" data-src="https://i.ytimg.com/vi/cFRkcO6KRe8/hqdefault.jpg"></a>
<h2>Producer and Consumer Surplus - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=bhucQFXX1Gs">
<img class="lazy" data-src="https://i.ytimg.com/vi/bhucQFXX1Gs/hqdefault.jpg"></a>
<h2>More Shifts to Demand and Supply Curves - Equilibrium Analysis - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=aybmcZtkM6k">
<img class="lazy" data-src="https://i.ytimg.com/vi/aybmcZtkM6k/hqdefault.jpg"></a>
<h2>Supply and Demand Curve Analysis Example (Trucks, Intro to Microeconomics)</h2><a href="https://www.youtube.com/watch?v=sKbSmLu9V0I">
<img class="lazy" data-src="https://i.ytimg.com/vi/sKbSmLu9V0I/hqdefault.jpg"></a>
<h2>Supply and Demand Curve Analysis (Pearl Jam) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=qb9gDpzRptQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/qb9gDpzRptQ/hqdefault.jpg"></a>
<h2>Supply & Demand Curve Shift Examples - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=TEsp7CzsOU0">
<img class="lazy" data-src="https://i.ytimg.com/vi/TEsp7CzsOU0/hqdefault.jpg"></a>
<h2>Normative vs. Positive Statement Examples - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=R0k3FvPsZW8">
<img class="lazy" data-src="https://i.ytimg.com/vi/R0k3FvPsZW8/hqdefault.jpg"></a>
<h2>Feasibility and Efficiency with Production Possibility Frontier (PPF) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=tTyMOlgqvSw">
<img class="lazy" data-src="https://i.ytimg.com/vi/tTyMOlgqvSw/hqdefault.jpg"></a>
<h2>Production Possibility Frontier (PPF) - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=NeO4aKaP6EE">
<img class="lazy" data-src="https://i.ytimg.com/vi/NeO4aKaP6EE/hqdefault.jpg"></a>
<h2>Examples of Efficient and Inefficient Situations - Intro to Microeconomics</h2><a href="https://www.youtube.com/watch?v=ymU1Jvn03TE">
<img class="lazy" data-src="https://i.ytimg.com/vi/ymU1Jvn03TE/hqdefault.jpg"></a>
<h2>Equilibrium examples - intro to microeconomics</h2><a href="https://www.youtube.com/watch?v=6F-dvaddlGc">
<img class="lazy" data-src="https://i.ytimg.com/vi/6F-dvaddlGc/hqdefault.jpg"></a>
<h2>Marginal Analysis Examples & Applications - intro to microeconomics</h2><a href="https://www.youtube.com/watch?v=v9NcBobA_Qw">
<img class="lazy" data-src="https://i.ytimg.com/vi/v9NcBobA_Qw/hqdefault.jpg"></a>
<h2>ConG - Software Demonstration</h2><a href="https://www.youtube.com/watch?v=lLRLQaetx10">
<img class="lazy" data-src="https://i.ytimg.com/vi/lLRLQaetx10/hqdefault.jpg"></a>
<h2>Public Goods Game with ConG</h2><a href="https://www.youtube.com/watch?v=TDC1SdlCnn0">
<img class="lazy" data-src="https://i.ytimg.com/vi/TDC1SdlCnn0/hqdefault.jpg"></a>
<h2>Prisonerss Dilemma Game in ConG Software</h2><a href="https://www.youtube.com/watch?v=Lt3FYoIOKyg">
<img class="lazy" data-src="https://i.ytimg.com/vi/Lt3FYoIOKyg/hqdefault.jpg"></a>
<h2>Hawk Dove with ConG - Economics Experiment Software</h2><a href="https://www.youtube.com/watch?v=4iJpRgidPPk">
<img class="lazy" data-src="https://i.ytimg.com/vi/4iJpRgidPPk/hqdefault.jpg"></a>
<h2>Creating Functions with R Software - example: the statistical mode</h2><a href="https://www.youtube.com/watch?v=rQEQAZ2Xzno">
<img class="lazy" data-src="https://i.ytimg.com/vi/rQEQAZ2Xzno/hqdefault.jpg"></a>
<h2>Calculating Mode with R Software (More on Rss Summary Stats)</h2><a href="https://www.youtube.com/watch?v=YvdYwC2YgeI">
<img class="lazy" data-src="https://i.ytimg.com/vi/YvdYwC2YgeI/hqdefault.jpg"></a>
<h2>Export Data with R (csv, tab-delineated and space separated examples)</h2><a href="https://www.youtube.com/watch?v=Md1hSm7kvy8">
<img class="lazy" data-src="https://i.ytimg.com/vi/Md1hSm7kvy8/hqdefault.jpg"></a>
<h2>Summary Stats with R Software</h2><a href="https://www.youtube.com/watch?v=J90kt3vGpFA">
<img class="lazy" data-src="https://i.ytimg.com/vi/J90kt3vGpFA/hqdefault.jpg"></a>
<h2>Creating a Histogram in R Software (the hist() function)</h2><a href="https://www.youtube.com/watch?v=wGW9M93YswY">
<img class="lazy" data-src="https://i.ytimg.com/vi/wGW9M93YswY/hqdefault.jpg"></a>
<h2>Loading Packages & Working With Libraries - R Software</h2><a href="https://www.youtube.com/watch?v=hHqNxR1lUjY">
<img class="lazy" data-src="https://i.ytimg.com/vi/hHqNxR1lUjY/hqdefault.jpg"></a>
<h2>Summary Statistics In R Software (Pt. 1 of 3)</h2><a href="https://www.youtube.com/watch?v=O03ysvNRlxo">
<img class="lazy" data-src="https://i.ytimg.com/vi/O03ysvNRlxo/hqdefault.jpg"></a>
<h2>An Introduction to R - A Brief Tutorial for R {Software for Statistical Analysis}</h2><a href="https://www.youtube.com/watch?v=LjuXiBjxryQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/LjuXiBjxryQ/hqdefault.jpg"></a>
<h2>Loading Data Into R Software - (read.table, Data/CSV Import Tutorial)</h2><a href="https://www.youtube.com/watch?v=VLtazaiYo-c">
<img class="lazy" data-src="https://i.ytimg.com/vi/VLtazaiYo-c/hqdefault.jpg"></a>
<h2>How to use SQL within R and some performance comparisons | R Programming</h2><a href="https://www.youtube.com/watch?v=l2dKAq6ujnY">
<img class="lazy" data-src="https://i.ytimg.com/vi/l2dKAq6ujnY/hqdefault.jpg"></a>
<h2>Python vs R: some performance comparisons | R Programming</h2><a href="https://www.youtube.com/watch?v=FSBx9lpz0fs">
<img class="lazy" data-src="https://i.ytimg.com/vi/FSBx9lpz0fs/hqdefault.jpg"></a>
<h2>Can Julia really make your R code faster?! | R Programming</h2><a href="https://www.youtube.com/watch?v=1dvnJdK9nCQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/1dvnJdK9nCQ/hqdefault.jpg"></a>
<h2>Make your R code 18,878 times faster! (Abridged) | R Programming</h2><a href="https://www.youtube.com/watch?v=dhfM4xeHVHI">
<img class="lazy" data-src="https://i.ytimg.com/vi/dhfM4xeHVHI/hqdefault.jpg"></a>
<h2>Make your R code 18,878 times faster! (Unabridged) | R Programming</h2><a href="https://www.youtube.com/watch?v=78icyDMZJyQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/78icyDMZJyQ/hqdefault.jpg"></a>
<h2>Welcome to Dynamic Data Script!</h2><a href="https://www.youtube.com/watch?v=Hdz3R0tUqHs">
<img class="lazy" data-src="https://i.ytimg.com/vi/Hdz3R0tUqHs/hqdefault.jpg"></a>
<h2>dplyr intro | Data manipulation in R</h2><a href="https://www.youtube.com/watch?v=rm0BQSWoJlc">
<img class="lazy" data-src="https://i.ytimg.com/vi/rm0BQSWoJlc/hqdefault.jpg"></a>
<h2>dplyr | My classic workflow | Data Science | R Programming</h2><a href="https://www.youtube.com/watch?v=27zCOiIWwhE">
<img class="lazy" data-src="https://i.ytimg.com/vi/27zCOiIWwhE/hqdefault.jpg"></a>
<h2>dplyr::arrange() | How to use dplyr arrange function | R Programming</h2><a href="https://www.youtube.com/watch?v=QjFG1rGOPHk">
<img class="lazy" data-src="https://i.ytimg.com/vi/QjFG1rGOPHk/hqdefault.jpg"></a>
<h2>dplyr::summarize() | How to use dplyr summarise function | R Programming</h2><a href="https://www.youtube.com/watch?v=8oY1SIA92JQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/8oY1SIA92JQ/hqdefault.jpg"></a>
<h2>dplyr::mutate() | How to use dplyr mutate function | R Programming</h2><a href="https://www.youtube.com/watch?v=Y0zE9AWBVfg">
<img class="lazy" data-src="https://i.ytimg.com/vi/Y0zE9AWBVfg/hqdefault.jpg"></a>
<h2>dplyr::group_by() | How to use dplyr group by function | R Programming</h2><a href="https://www.youtube.com/watch?v=EUlEQiy3LBA">
<img class="lazy" data-src="https://i.ytimg.com/vi/EUlEQiy3LBA/hqdefault.jpg"></a>
<h2>dplyr::filter() | How to use dplyr filter function | R Programming</h2><a href="https://www.youtube.com/watch?v=5sGtqnz7Hss">
<img class="lazy" data-src="https://i.ytimg.com/vi/5sGtqnz7Hss/hqdefault.jpg"></a>
<h2>dplyr::select() | How to use dplyr select function | R Programming</h2><a href="https://www.youtube.com/watch?v=B5K5cQsHs8U">
<img class="lazy" data-src="https://i.ytimg.com/vi/B5K5cQsHs8U/hqdefault.jpg"></a>
<h2>R Programming for Beginners (2020) | Complete Tutorial | R & RStudio</h2><a href="https://www.youtube.com/watch?v=BvKETZ6kr9Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/BvKETZ6kr9Q/hqdefault.jpg"></a>
<h2>The paste() Function in R</h2><a href="https://www.youtube.com/watch?v=_mNnbWGAroU">
<img class="lazy" data-src="https://i.ytimg.com/vi/_mNnbWGAroU/hqdefault.jpg"></a>
<h2>The aggregate() Function in R</h2><a href="https://www.youtube.com/watch?v=zmiC7X9fUmo">
<img class="lazy" data-src="https://i.ytimg.com/vi/zmiC7X9fUmo/hqdefault.jpg"></a>
<h2>Apply Family of Functions in R Part 1: apply()</h2><a href="https://www.youtube.com/watch?v=f0U74ZvLfQo">
<img class="lazy" data-src="https://i.ytimg.com/vi/f0U74ZvLfQo/hqdefault.jpg"></a>
<h2>Making Functions in R</h2><a href="https://www.youtube.com/watch?v=i2VH5jIL76Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/i2VH5jIL76Y/hqdefault.jpg"></a>
<h2>While Loops in R</h2><a href="https://www.youtube.com/watch?v=SJVrHumq0zc">
<img class="lazy" data-src="https://i.ytimg.com/vi/SJVrHumq0zc/hqdefault.jpg"></a>
<h2>For Loops in R</h2><a href="https://www.youtube.com/watch?v=h987LWDvqlQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/h987LWDvqlQ/hqdefault.jpg"></a>
<h2>Conditional Statements in R</h2><a href="https://www.youtube.com/watch?v=cvlej_eKbmE">
<img class="lazy" data-src="https://i.ytimg.com/vi/cvlej_eKbmE/hqdefault.jpg"></a>
<h2>Apply Family of Functions in R Part 2: lapply() and sapply()</h2><a href="https://www.youtube.com/watch?v=ejVWRKidi9M">
<img class="lazy" data-src="https://i.ytimg.com/vi/ejVWRKidi9M/hqdefault.jpg"></a>
<h2>Apply Family of Functions  in R Part 3: tapply()</h2><a href="https://www.youtube.com/watch?v=HmBPDTtb6Bg">
<img class="lazy" data-src="https://i.ytimg.com/vi/HmBPDTtb6Bg/hqdefault.jpg"></a>
<h2>Inset graphs within ggplots</h2><a href="https://www.youtube.com/watch?v=Dkew_9bSCwE">
<img class="lazy" data-src="https://i.ytimg.com/vi/Dkew_9bSCwE/hqdefault.jpg"></a>
<h2>histograms in Rss ggplot</h2><a href="https://www.youtube.com/watch?v=HbzM53riug0">
<img class="lazy" data-src="https://i.ytimg.com/vi/HbzM53riug0/hqdefault.jpg"></a>
<h2>ggplot scatterplots in R</h2><a href="https://www.youtube.com/watch?v=oVShyv8i3EI">
<img class="lazy" data-src="https://i.ytimg.com/vi/oVShyv8i3EI/hqdefault.jpg"></a>
<h2>ggplot2 boxplots in R</h2><a href="https://www.youtube.com/watch?v=j5b7NNRycxs">
<img class="lazy" data-src="https://i.ytimg.com/vi/j5b7NNRycxs/hqdefault.jpg"></a>
<h2>Removing NAs in R dataframes</h2><a href="https://www.youtube.com/watch?v=wu9LNdPS0Ro">
<img class="lazy" data-src="https://i.ytimg.com/vi/wu9LNdPS0Ro/hqdefault.jpg"></a>
<h2>Selecting and removing columns from R dataframes</h2><a href="https://www.youtube.com/watch?v=XpgIPfHhsqU">
<img class="lazy" data-src="https://i.ytimg.com/vi/XpgIPfHhsqU/hqdefault.jpg"></a>
<h2>Naming and renaming columns in R dataframes</h2><a href="https://www.youtube.com/watch?v=Okc0IL5uTnA">
<img class="lazy" data-src="https://i.ytimg.com/vi/Okc0IL5uTnA/hqdefault.jpg"></a>
<h2>Selecting and removing rows in R dataframes</h2><a href="https://www.youtube.com/watch?v=KXSPxjjS8Fc">
<img class="lazy" data-src="https://i.ytimg.com/vi/KXSPxjjS8Fc/hqdefault.jpg"></a>
<h2>Exploring data in R</h2><a href="https://www.youtube.com/watch?v=mgslMeYwNmM">
<img class="lazy" data-src="https://i.ytimg.com/vi/mgslMeYwNmM/hqdefault.jpg"></a>
<h2>Combining data in R</h2><a href="https://www.youtube.com/watch?v=v5SIMV6Fi04">
<img class="lazy" data-src="https://i.ytimg.com/vi/v5SIMV6Fi04/hqdefault.jpg"></a>
<h2>Course Review | Linear Regression, Logistic Regression, Poisson Regression, Survival Analysis</h2><a href="https://www.youtube.com/watch?v=5rOUGoNWw0Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/5rOUGoNWw0Y/hqdefault.jpg"></a>
<h2>Survival Analysis Part 12 | Checking Cox PH Model Assumptions in R with RStudio</h2><a href="https://www.youtube.com/watch?v=M1QQ8QQn8Zs">
<img class="lazy" data-src="https://i.ytimg.com/vi/M1QQ8QQn8Zs/hqdefault.jpg"></a>
<h2>Survival Analysis Part 11 | Cox Proportional Hazards Model in R with RStudio</h2><a href="https://www.youtube.com/watch?v=TrS2M5imOt8">
<img class="lazy" data-src="https://i.ytimg.com/vi/TrS2M5imOt8/hqdefault.jpg"></a>
<h2>Survival Analysis Part 10 | Model Assumptions for Cox Proportional Hazards Model</h2><a href="https://www.youtube.com/watch?v=QAgtZKpKj9M">
<img class="lazy" data-src="https://i.ytimg.com/vi/QAgtZKpKj9M/hqdefault.jpg"></a>
<h2>Survival Analysis Part 9 | Cox Proportional Hazards Model</h2><a href="https://www.youtube.com/watch?v=aETMUW_TWV0">
<img class="lazy" data-src="https://i.ytimg.com/vi/aETMUW_TWV0/hqdefault.jpg"></a>
<h2>A COVID-19 Special: Social Distancing and Bending the Curve with R</h2><a href="https://www.youtube.com/watch?v=TIsXHxLNw6k">
<img class="lazy" data-src="https://i.ytimg.com/vi/TIsXHxLNw6k/hqdefault.jpg"></a>
<h2>Survival Analysis Part 8 | Kaplan Meier vs Exponential vs Cox Proportional Hazards (How The Differ)</h2><a href="https://www.youtube.com/watch?v=KDpAtrqS39w">
<img class="lazy" data-src="https://i.ytimg.com/vi/KDpAtrqS39w/hqdefault.jpg"></a>
<h2>Survival Analysis Part 7 | Exponential Model (Intro to Regression Models for Survival)</h2><a href="https://www.youtube.com/watch?v=T_goHnU8Eu4">
<img class="lazy" data-src="https://i.ytimg.com/vi/T_goHnU8Eu4/hqdefault.jpg"></a>
<h2>Survival Analysis Part 5 | Kaplan Meier Model in R with RStudio</h2><a href="https://www.youtube.com/watch?v=6_AF9mMuk9E">
<img class="lazy" data-src="https://i.ytimg.com/vi/6_AF9mMuk9E/hqdefault.jpg"></a>
<h2>Survival Analysis Part 4 | Kaplan Meier Model</h2><a href="https://www.youtube.com/watch?v=VJPPeUpyC6c">
<img class="lazy" data-src="https://i.ytimg.com/vi/VJPPeUpyC6c/hqdefault.jpg"></a>
<h2>Survival Analysis Part 3 | Kaplan Meier vs. Exponential vs. Cox Proportional Hazards (Pros & Cons)</h2><a href="https://www.youtube.com/watch?v=K7bmmbD7KIg">
<img class="lazy" data-src="https://i.ytimg.com/vi/K7bmmbD7KIg/hqdefault.jpg"></a>
<h2>Survival Analysis Part 2 | Survival Function, Hazard, & Hazard Ratio</h2><a href="https://www.youtube.com/watch?v=MdmWdIV5k-I">
<img class="lazy" data-src="https://i.ytimg.com/vi/MdmWdIV5k-I/hqdefault.jpg"></a>
<h2>Survival Analysis Part 1 | What is Censoring?</h2><a href="https://www.youtube.com/watch?v=vX3l36ptrTU">
<img class="lazy" data-src="https://i.ytimg.com/vi/vX3l36ptrTU/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #9</h2><a href="https://www.youtube.com/watch?v=mxNlTHBpJ3o">
<img class="lazy" data-src="https://i.ytimg.com/vi/mxNlTHBpJ3o/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #8</h2><a href="https://www.youtube.com/watch?v=SViNAyZTOA8">
<img class="lazy" data-src="https://i.ytimg.com/vi/SViNAyZTOA8/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #7</h2><a href="https://www.youtube.com/watch?v=NQB4W71WDh4">
<img class="lazy" data-src="https://i.ytimg.com/vi/NQB4W71WDh4/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #6</h2><a href="https://www.youtube.com/watch?v=ZWR6Bns90nQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZWR6Bns90nQ/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #5</h2><a href="https://www.youtube.com/watch?v=zFKOILNnN3w">
<img class="lazy" data-src="https://i.ytimg.com/vi/zFKOILNnN3w/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #4</h2><a href="https://www.youtube.com/watch?v=ewtqpg3ZbvE">
<img class="lazy" data-src="https://i.ytimg.com/vi/ewtqpg3ZbvE/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #3</h2><a href="https://www.youtube.com/watch?v=Sth3mdWk1IU">
<img class="lazy" data-src="https://i.ytimg.com/vi/Sth3mdWk1IU/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #2</h2><a href="https://www.youtube.com/watch?v=CpUAXsPAk30">
<img class="lazy" data-src="https://i.ytimg.com/vi/CpUAXsPAk30/hqdefault.jpg"></a>
<h2>MHA Meeting #2 Video #1</h2><a href="https://www.youtube.com/watch?v=IdjtA3ZgAks">
<img class="lazy" data-src="https://i.ytimg.com/vi/IdjtA3ZgAks/hqdefault.jpg"></a>
<h2>Poisson Regression: Overdispersion causes and Solutions</h2><a href="https://www.youtube.com/watch?v=0W5QF_OnR7w">
<img class="lazy" data-src="https://i.ytimg.com/vi/0W5QF_OnR7w/hqdefault.jpg"></a>
<h2>Poisson Regression: Zero Inflation (Excessive Zeros)</h2><a href="https://www.youtube.com/watch?v=eIY--zc5f24">
<img class="lazy" data-src="https://i.ytimg.com/vi/eIY--zc5f24/hqdefault.jpg"></a>
<h2>Poisson Regression Review</h2><a href="https://www.youtube.com/watch?v=A8H6gc9Eq0w">
<img class="lazy" data-src="https://i.ytimg.com/vi/A8H6gc9Eq0w/hqdefault.jpg"></a>
<h2>The Monty Hall Problem in Statistics | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=0aVZVRxMCzE">
<img class="lazy" data-src="https://i.ytimg.com/vi/0aVZVRxMCzE/hqdefault.jpg"></a>
<h2>Measures of Spread & Variability: Range, Variance, SD, etc| Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=C7AoEjLyW78">
<img class="lazy" data-src="https://i.ytimg.com/vi/C7AoEjLyW78/hqdefault.jpg"></a>
<h2>Percentiles, Quantiles and Quartiles in Statistics | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Ky7QeVgv-BA">
<img class="lazy" data-src="https://i.ytimg.com/vi/Ky7QeVgv-BA/hqdefault.jpg"></a>
<h2>Plots for Two Variables | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=sbsY6neZ07g">
<img class="lazy" data-src="https://i.ytimg.com/vi/sbsY6neZ07g/hqdefault.jpg"></a>
<h2>Study Designs (Cross-sectional, Case-control, Cohort) | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=gXwI9W5wqjc">
<img class="lazy" data-src="https://i.ytimg.com/vi/gXwI9W5wqjc/hqdefault.jpg"></a>
<h2>Statistics Terminology and Definitions| Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=-JXDd52XsQE">
<img class="lazy" data-src="https://i.ytimg.com/vi/-JXDd52XsQE/hqdefault.jpg"></a>
<h2>Describing Distributions: Center, Spread & Shape | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=2Y2l9QJCe6M">
<img class="lazy" data-src="https://i.ytimg.com/vi/2Y2l9QJCe6M/hqdefault.jpg"></a>
<h2>Mean, Median and Mode in Statistics | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=2pyq0TJmpzs">
<img class="lazy" data-src="https://i.ytimg.com/vi/2pyq0TJmpzs/hqdefault.jpg"></a>
<h2>Boxplots in Statistics | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=9AKLd5FHzfI">
<img class="lazy" data-src="https://i.ytimg.com/vi/9AKLd5FHzfI/hqdefault.jpg"></a>
<h2>Histograms and Density Plots for Numeric Variables | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=p-VOptZ0E5Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/p-VOptZ0E5Y/hqdefault.jpg"></a>
<h2>Bar Chart, Pie Chart, Frequency Tables | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Rx8wSEDq5Hs">
<img class="lazy" data-src="https://i.ytimg.com/vi/Rx8wSEDq5Hs/hqdefault.jpg"></a>
<h2>Variables and Types of Variables | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ZxV-kf0yBss">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZxV-kf0yBss/hqdefault.jpg"></a>
<h2>Outtakes! MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=zrdujGQtp8Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/zrdujGQtp8Y/hqdefault.jpg"></a>
<h2>Permutation Hypothesis Test in R with Examples | R Tutorial 4.6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=xRzEWLfEEIA">
<img class="lazy" data-src="https://i.ytimg.com/vi/xRzEWLfEEIA/hqdefault.jpg"></a>
<h2>Permutation Hypothesis Testing with Example | Statistics Tutorial # 37 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=rJ3AZCQuiLw">
<img class="lazy" data-src="https://i.ytimg.com/vi/rJ3AZCQuiLw/hqdefault.jpg"></a>
<h2>Course Review: Review of Regression Models | Statistics for Applied Epidemiology | Tutorial 12</h2><a href="https://www.youtube.com/watch?v=E5o1qz6nn7s">
<img class="lazy" data-src="https://i.ytimg.com/vi/E5o1qz6nn7s/hqdefault.jpg"></a>
<h2>Survival Analysis | Statistics for Applied Epidemiology | Tutorial 11</h2><a href="https://www.youtube.com/watch?v=sJPti8Yh4k4">
<img class="lazy" data-src="https://i.ytimg.com/vi/sJPti8Yh4k4/hqdefault.jpg"></a>
<h2>Poisson Regression Part II | Statistics for Applied Epidemiology | Tutorial 10</h2><a href="https://www.youtube.com/watch?v=URvhjZxyPhM">
<img class="lazy" data-src="https://i.ytimg.com/vi/URvhjZxyPhM/hqdefault.jpg"></a>
<h2>Poisson Regression Part I | Statistics for Applied Epidemiology | Tutorial 9</h2><a href="https://www.youtube.com/watch?v=0XfXHYDYoBA">
<img class="lazy" data-src="https://i.ytimg.com/vi/0XfXHYDYoBA/hqdefault.jpg"></a>
<h2>Logistic Regression Part III | Statistics for Applied Epidemiology | Tutorial 8</h2><a href="https://www.youtube.com/watch?v=oVeMquBjNYs">
<img class="lazy" data-src="https://i.ytimg.com/vi/oVeMquBjNYs/hqdefault.jpg"></a>
<h2>Bootstrap Confidence Interval with R | R Video Tutorial 4.5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Om5TMGj9td4">
<img class="lazy" data-src="https://i.ytimg.com/vi/Om5TMGj9td4/hqdefault.jpg"></a>
<h2>Linear Regression Assignment Review | Statistics for Applied Epidemiology | Tutorial 7</h2><a href="https://www.youtube.com/watch?v=bsGz0Judj4Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/bsGz0Judj4Q/hqdefault.jpg"></a>
<h2>Logistic Regression II | Statistics for Applied Epidemiology | Tutorial 6</h2><a href="https://www.youtube.com/watch?v=uK7n9A48YzQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/uK7n9A48YzQ/hqdefault.jpg"></a>
<h2>Logistic Regression I | Statistics for Applied Epidemiology | Tutorial 5</h2><a href="https://www.youtube.com/watch?v=tgVlcVSPNrA">
<img class="lazy" data-src="https://i.ytimg.com/vi/tgVlcVSPNrA/hqdefault.jpg"></a>
<h2>Multiple Linear Regression III | Statistics for Applied Epidemiology | Tutorial 4</h2><a href="https://www.youtube.com/watch?v=g0UKccXfW6I">
<img class="lazy" data-src="https://i.ytimg.com/vi/g0UKccXfW6I/hqdefault.jpg"></a>
<h2>Multiple Linear Regression II | Statistics for Applied Epidemiology | Tutorial 3</h2><a href="https://www.youtube.com/watch?v=YQkoVDPKtTQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/YQkoVDPKtTQ/hqdefault.jpg"></a>
<h2>Bootstrap Confidence Interval with Examples | Statistics Tutorial #36 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=-YgeLJRZQYY">
<img class="lazy" data-src="https://i.ytimg.com/vi/-YgeLJRZQYY/hqdefault.jpg"></a>
<h2>Multiple Linear Regression | Statistics for Applied Epidemiology | Tutorial 2</h2><a href="https://www.youtube.com/watch?v=Nwdp3wVxEBM">
<img class="lazy" data-src="https://i.ytimg.com/vi/Nwdp3wVxEBM/hqdefault.jpg"></a>
<h2>Simple Linear Regression | Statistics for Applied Epidemiology | Tutorial 1</h2><a href="https://www.youtube.com/watch?v=vt_akgeMd6g">
<img class="lazy" data-src="https://i.ytimg.com/vi/vt_akgeMd6g/hqdefault.jpg"></a>
<h2>Samples from a Normal Distribution | Statistics Tutorial #4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=y0Vwi7O5l6k">
<img class="lazy" data-src="https://i.ytimg.com/vi/y0Vwi7O5l6k/hqdefault.jpg"></a>
<h2>Bootstrap Hypothesis Testing in R with Example | R Video Tutorial 4.4 | MarinStatsLecutres</h2><a href="https://www.youtube.com/watch?v=Zet-qmEEfCU">
<img class="lazy" data-src="https://i.ytimg.com/vi/Zet-qmEEfCU/hqdefault.jpg"></a>
<h2>Bootstrap Hypothesis Testing in Statistics with Example |Statistics Tutorial #35 |MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=9STZ7MxkNVg">
<img class="lazy" data-src="https://i.ytimg.com/vi/9STZ7MxkNVg/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 12: Course Review and Exam Preparation</h2><a href="https://www.youtube.com/watch?v=OV19OmxCKkQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/OV19OmxCKkQ/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 11: Linear Regression</h2><a href="https://www.youtube.com/watch?v=k30BDpGBHxo">
<img class="lazy" data-src="https://i.ytimg.com/vi/k30BDpGBHxo/hqdefault.jpg"></a>
<h2>Importing/Reading Excel data into R using RStudio (readxl) | R Tutorial 1.5b | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=JYVWufSQ4OI">
<img class="lazy" data-src="https://i.ytimg.com/vi/JYVWufSQ4OI/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 10: Correlation, Simple Linear Regression</h2><a href="https://www.youtube.com/watch?v=upUFvcsnvS4">
<img class="lazy" data-src="https://i.ytimg.com/vi/upUFvcsnvS4/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 9: Chi Square, Risk Difference, NNT, Risk Ratio, Odds Ratio</h2><a href="https://www.youtube.com/watch?v=3IYxWOSqj0M">
<img class="lazy" data-src="https://i.ytimg.com/vi/3IYxWOSqj0M/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 8: ANOVA and Bonferroni Correction</h2><a href="https://www.youtube.com/watch?v=pDbXxC7O7O4">
<img class="lazy" data-src="https://i.ytimg.com/vi/pDbXxC7O7O4/hqdefault.jpg"></a>
<h2>R Squared or Coefficient of Determination | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=GI8ohuIGjJA">
<img class="lazy" data-src="https://i.ytimg.com/vi/GI8ohuIGjJA/hqdefault.jpg"></a>
<h2>Nonlinearity in Linear Regression | Statistics Tutorial #33 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=tOzwEv0PoZk">
<img class="lazy" data-src="https://i.ytimg.com/vi/tOzwEv0PoZk/hqdefault.jpg"></a>
<h2>Statistics for Health Research Tutorial 7: Analysis of Variance, The Test, and Assumptions</h2><a href="https://www.youtube.com/watch?v=CE-00a8lTGI">
<img class="lazy" data-src="https://i.ytimg.com/vi/CE-00a8lTGI/hqdefault.jpg"></a>
<h2>Simple Linear Regression Concept | Statistics Tutorial #32 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=vblX9JVpHE8">
<img class="lazy" data-src="https://i.ytimg.com/vi/vblX9JVpHE8/hqdefault.jpg"></a>
<h2>Case-Control Study and Odds Ratio | Statistics Tutorial #31| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=NqsSun9HZfI">
<img class="lazy" data-src="https://i.ytimg.com/vi/NqsSun9HZfI/hqdefault.jpg"></a>
<h2>Odds Ratio, Relative Risk, Risk Difference | Statistics Tutorial #30| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=JmuciUfCJ_w">
<img class="lazy" data-src="https://i.ytimg.com/vi/JmuciUfCJ_w/hqdefault.jpg"></a>
<h2>Chi Square Test of Independence | Statistics Tutorial #29| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=pfc9MUz03XA">
<img class="lazy" data-src="https://i.ytimg.com/vi/pfc9MUz03XA/hqdefault.jpg"></a>
<h2>Paired t Test, Two Sample t Test, Rank Sum Test & more | Tutorial 6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ciwlWyUe6sk">
<img class="lazy" data-src="https://i.ytimg.com/vi/ciwlWyUe6sk/hqdefault.jpg"></a>
<h2>Intro to Statistics: Bivariate, Parametric vs Non Parametric Tests | Tutorial 5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=dyGjxBi4-qo">
<img class="lazy" data-src="https://i.ytimg.com/vi/dyGjxBi4-qo/hqdefault.jpg"></a>
<h2>ANOVA Part IV: Bonferroni Correction | Statistics Tutorial #28 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=pscJPuCwUG0">
<img class="lazy" data-src="https://i.ytimg.com/vi/pscJPuCwUG0/hqdefault.jpg"></a>
<h2>ANOVA Part III: F Statistic and P Value | Statistics Tutorial #27 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=k-xZzEYL8oc">
<img class="lazy" data-src="https://i.ytimg.com/vi/k-xZzEYL8oc/hqdefault.jpg"></a>
<h2>ANOVA (Analysis of Variance) and Sum of Squares | Statistics Tutorial #26 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=-AeU4y2vkIs">
<img class="lazy" data-src="https://i.ytimg.com/vi/-AeU4y2vkIs/hqdefault.jpg"></a>
<h2>One Way ANOVA (Analysis of Variance): Introduction | Statistics Tutorial #25 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=_VFLX7xJuqk">
<img class="lazy" data-src="https://i.ytimg.com/vi/_VFLX7xJuqk/hqdefault.jpg"></a>
<h2>Two Sample t-Test:Equal vs Unequal Variance Assumption| Statistics Tutorial #24| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ikS7itcmWZM">
<img class="lazy" data-src="https://i.ytimg.com/vi/ikS7itcmWZM/hqdefault.jpg"></a>
<h2>Two Sample t-test for Independent Groups | Statistics Tutorial #23| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=mBiVCrW2vSU">
<img class="lazy" data-src="https://i.ytimg.com/vi/mBiVCrW2vSU/hqdefault.jpg"></a>
<h2>Intro to Statistics: Hypothesis Testing, Types of Errors, Power | Tutorial 4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=xbvaj7f6nFE">
<img class="lazy" data-src="https://i.ytimg.com/vi/xbvaj7f6nFE/hqdefault.jpg"></a>
<h2>Intro to Statistics: Confidence Interval & Margin of Error | Tutorial 3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=vBdCgit8uaU">
<img class="lazy" data-src="https://i.ytimg.com/vi/vBdCgit8uaU/hqdefault.jpg"></a>
<h2>Wilcoxon Signed Rank Test | Statistics Tutorial #22 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=v4ZHlTbTOK8">
<img class="lazy" data-src="https://i.ytimg.com/vi/v4ZHlTbTOK8/hqdefault.jpg"></a>
<h2>Paired t Test | Statistics Tutorial #21| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Q0V7WpzICI8">
<img class="lazy" data-src="https://i.ytimg.com/vi/Q0V7WpzICI8/hqdefault.jpg"></a>
<h2>Bivariate Analysis for Categorical & Numerical | Statistics Tutorial #20 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=tnYcNyJB5FQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/tnYcNyJB5FQ/hqdefault.jpg"></a>
<h2>Statistical Literacy for Medical Students (UBC MEDD 419)| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=xNqEzV1CtlQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/xNqEzV1CtlQ/hqdefault.jpg"></a>
<h2>Bivariate Analysis Meaning | Statistics Tutorial #19 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=_m8v77qbkBA">
<img class="lazy" data-src="https://i.ytimg.com/vi/_m8v77qbkBA/hqdefault.jpg"></a>
<h2>Power Calculations in Hypothesis Testing | Statistics Tutorial #17 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ryWoLqe0sd8">
<img class="lazy" data-src="https://i.ytimg.com/vi/ryWoLqe0sd8/hqdefault.jpg"></a>
<h2>Intro to Statistics: Normal Distribution & Central Limit Theorem | Tutorial 2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=521VS6Pgx2E">
<img class="lazy" data-src="https://i.ytimg.com/vi/521VS6Pgx2E/hqdefault.jpg"></a>
<h2>Intro to Statistics: Plots, Screening Tests, Normal Distribution | Tutorial 1|  MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=EzNnJ9nfc50">
<img class="lazy" data-src="https://i.ytimg.com/vi/EzNnJ9nfc50/hqdefault.jpg"></a>
<h2>Errors and Power in Hypothesis Testing | Statistics Tutorial #16 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=OYbc3uKpGmg">
<img class="lazy" data-src="https://i.ytimg.com/vi/OYbc3uKpGmg/hqdefault.jpg"></a>
<h2>Bootstrapping and Resampling in Statistics with Example| Statistics Tutorial #12 |MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=O_Fj4q8lgmc">
<img class="lazy" data-src="https://i.ytimg.com/vi/O_Fj4q8lgmc/hqdefault.jpg"></a>
<h2>Margin of Error & Sample Size for Confidence Interval | Statistics Tutorial #11| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=d96hI8vQRvs">
<img class="lazy" data-src="https://i.ytimg.com/vi/d96hI8vQRvs/hqdefault.jpg"></a>
<h2>Statistical Inference Definition with Example | Statistics Tutorial #18 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=wyu7uUbVYYM">
<img class="lazy" data-src="https://i.ytimg.com/vi/wyu7uUbVYYM/hqdefault.jpg"></a>
<h2>Hypothesis Test vs. Confidence Interval | Statistics Tutorial #15 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=J-yMiTaai4c">
<img class="lazy" data-src="https://i.ytimg.com/vi/J-yMiTaai4c/hqdefault.jpg"></a>
<h2>Hypothesis Testing: One Sided vs Two Sided Alternative | Statistics Tutorial #14 |MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Fsa-5_XdIMs">
<img class="lazy" data-src="https://i.ytimg.com/vi/Fsa-5_XdIMs/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Calculations and Interpretations| Statistics Tutorial #13 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=zH_3FBKuQHA">
<img class="lazy" data-src="https://i.ytimg.com/vi/zH_3FBKuQHA/hqdefault.jpg"></a>
<h2>Standard Error of the Mean: Concept and Formula | Statistics Tutorial #6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=-Xz89dB_Hco">
<img class="lazy" data-src="https://i.ytimg.com/vi/-Xz89dB_Hco/hqdefault.jpg"></a>
<h2>Statistics Video Tutorials at a Glance | Best Statistics Tutorials | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=3fYlGZWBdM4">
<img class="lazy" data-src="https://i.ytimg.com/vi/3fYlGZWBdM4/hqdefault.jpg"></a>
<h2>Statistics Course Overview | Best Statistics Course | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=AN3UkzE3HMg">
<img class="lazy" data-src="https://i.ytimg.com/vi/AN3UkzE3HMg/hqdefault.jpg"></a>
<h2>t-distribution in Statistics and Probability | Statistics Tutorial #9 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=sVkzPI1M7Ms">
<img class="lazy" data-src="https://i.ytimg.com/vi/sVkzPI1M7Ms/hqdefault.jpg"></a>
<h2>Confidence Interval for Mean with Example | Statistics Tutorial #10 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=nKQ2KcCCnb0">
<img class="lazy" data-src="https://i.ytimg.com/vi/nKQ2KcCCnb0/hqdefault.jpg"></a>
<h2>Hypothesis Testing Explained | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=6F6frEyMxuk">
<img class="lazy" data-src="https://i.ytimg.com/vi/6F6frEyMxuk/hqdefault.jpg"></a>
<h2>Confidence Interval Concept Explained  | Statistics Tutorial #7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=dl0CXDsTYjk">
<img class="lazy" data-src="https://i.ytimg.com/vi/dl0CXDsTYjk/hqdefault.jpg"></a>
<h2>Central Limit Theorem & Sampling Distribution Concepts | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=horm4zWU-vA">
<img class="lazy" data-src="https://i.ytimg.com/vi/horm4zWU-vA/hqdefault.jpg"></a>
<h2>Normal Distribution,  Z-Scores & Empirical Rule | Statistics Tutorial #3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=zUnC1CV4FAc">
<img class="lazy" data-src="https://i.ytimg.com/vi/zUnC1CV4FAc/hqdefault.jpg"></a>
<h2>Sample and Population in Statistics | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=DOnucdP7LNU">
<img class="lazy" data-src="https://i.ytimg.com/vi/DOnucdP7LNU/hqdefault.jpg"></a>
<h2>Standard Deviation & Degrees of Freedom Explained | Statistics Tutorial | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=nlm9gfso4mw">
<img class="lazy" data-src="https://i.ytimg.com/vi/nlm9gfso4mw/hqdefault.jpg"></a>
<h2>tApply Function in R | R Tutorial 1.16 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=9ZWHfozPn6k">
<img class="lazy" data-src="https://i.ytimg.com/vi/9ZWHfozPn6k/hqdefault.jpg"></a>
<h2>Apply Function in R  | R Tutorial 1.15 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=7sJ8r6Lb7-o">
<img class="lazy" data-src="https://i.ytimg.com/vi/7sJ8r6Lb7-o/hqdefault.jpg"></a>
<h2>Export Data from R (csv , txt and other formats) | R Tutorial 1.6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=WjpcbmcJjjM">
<img class="lazy" data-src="https://i.ytimg.com/vi/WjpcbmcJjjM/hqdefault.jpg"></a>
<h2>Starbucks and Statistics | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=WrnGRsECzT4">
<img class="lazy" data-src="https://i.ytimg.com/vi/WrnGRsECzT4/hqdefault.jpg"></a>
<h2>What is a Hypothesis Test and a P-Value? | Puppet Master of Statistics</h2><a href="https://www.youtube.com/watch?v=vwWEa8wU_6U">
<img class="lazy" data-src="https://i.ytimg.com/vi/vwWEa8wU_6U/hqdefault.jpg"></a>
<h2>What is a Confidence Interval? | Puppet Master of Statistics</h2><a href="https://www.youtube.com/watch?v=9jTJD5SLweY">
<img class="lazy" data-src="https://i.ytimg.com/vi/9jTJD5SLweY/hqdefault.jpg"></a>
<h2>What is a Sampling Distribution? | Puppet Master of Statistics</h2><a href="https://www.youtube.com/watch?v=olK80ngCbXc">
<img class="lazy" data-src="https://i.ytimg.com/vi/olK80ngCbXc/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Errors and Power (one sample t test) I Statistics 101 #7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ZXc9SRPDESc">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZXc9SRPDESc/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Conclusion (one sample t test) I Statistics 101 #6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=R7y1dIRIqq8">
<img class="lazy" data-src="https://i.ytimg.com/vi/R7y1dIRIqq8/hqdefault.jpg"></a>
<h2>Hypothesis Testing: P Value (one sample t test) I Statistics 101 #5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=WojcyhC7EVc">
<img class="lazy" data-src="https://i.ytimg.com/vi/WojcyhC7EVc/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Critical values & Rejection Regions I Statistics 101 #4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=BdeuCflLPQI">
<img class="lazy" data-src="https://i.ytimg.com/vi/BdeuCflLPQI/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Test Statistic (one sample t test) I Statistics 101 #3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=fTYewURFLR0">
<img class="lazy" data-src="https://i.ytimg.com/vi/fTYewURFLR0/hqdefault.jpg"></a>
<h2>Hypothesis Testing: Null & Alternative Hypothesis I Statistics 101 #2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=L1GV6nLnbyE">
<img class="lazy" data-src="https://i.ytimg.com/vi/L1GV6nLnbyE/hqdefault.jpg"></a>
<h2>Hypothesis Testing: The Big Picture (One Sample t-test) I Statistics 101 #1 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=WVG-2xmzjyc">
<img class="lazy" data-src="https://i.ytimg.com/vi/WVG-2xmzjyc/hqdefault.jpg"></a>
<h2>What is RStudio and Why Should You Download It? | R Tutorial 1.1 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=riONFzJdXcs">
<img class="lazy" data-src="https://i.ytimg.com/vi/riONFzJdXcs/hqdefault.jpg"></a>
<h2>Polynomial Regression in R | R Tutorial 5.12 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ZYN0YD7UfK4">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZYN0YD7UfK4/hqdefault.jpg"></a>
<h2>Install R and RStudio</h2><a href="https://www.youtube.com/watch?v=d-u_7vdag-0">
<img class="lazy" data-src="https://i.ytimg.com/vi/d-u_7vdag-0/hqdefault.jpg"></a>
<h2>Partial F-Test for Variable Selection in Linear Regression | R Tutorial 5.11| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=G_obrpV70QQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/G_obrpV70QQ/hqdefault.jpg"></a>
<h2>Sensitivity, Specificity, Positive and Negative Predictive Values | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=eeM7KPRNlSs">
<img class="lazy" data-src="https://i.ytimg.com/vi/eeM7KPRNlSs/hqdefault.jpg"></a>
<h2>Box Plots with Two Factors (Stratified Boxplots) in R | R Tutorial 2.3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=s7ljwAzB5dQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/s7ljwAzB5dQ/hqdefault.jpg"></a>
<h2>Interpreting Interaction in Linear Regression with R | R Tutorial 5.10 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=vZUtDJbzFRQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/vZUtDJbzFRQ/hqdefault.jpg"></a>
<h2>Multiple Linear Regression with Interaction in R | R Tutorial 5.9 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=8YuuIsoYqsg">
<img class="lazy" data-src="https://i.ytimg.com/vi/8YuuIsoYqsg/hqdefault.jpg"></a>
<h2>Including Variables/ Factors in Regression with R, Part II | R Tutorial 5.8 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ZtBmMhGkxxA">
<img class="lazy" data-src="https://i.ytimg.com/vi/ZtBmMhGkxxA/hqdefault.jpg"></a>
<h2>Including Variables/ Factors in Regression with R, Part I | R Tutorial 5.7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=KHTBwTBkCzg">
<img class="lazy" data-src="https://i.ytimg.com/vi/KHTBwTBkCzg/hqdefault.jpg"></a>
<h2>Changing Numeric Variable to Categorical in R | R Tutorial 5.4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=EWs1Ordh8nI">
<img class="lazy" data-src="https://i.ytimg.com/vi/EWs1Ordh8nI/hqdefault.jpg"></a>
<h2>Add and Customize Legends to Plots in R | R Tutorial 2.11| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=mB3iSp9-OPc">
<img class="lazy" data-src="https://i.ytimg.com/vi/mB3iSp9-OPc/hqdefault.jpg"></a>
<h2>Add and Customize Text in Plots with R | R Tutorial 2.10 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Zx3Nspy8sws">
<img class="lazy" data-src="https://i.ytimg.com/vi/Zx3Nspy8sws/hqdefault.jpg"></a>
<h2>Change Reference (Baseline) Category in Regression with R | R Tutorial 5.6 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=XJw6xdBYG7c">
<img class="lazy" data-src="https://i.ytimg.com/vi/XJw6xdBYG7c/hqdefault.jpg"></a>
<h2>Dummy Variables or Indicator Variables in R | R Tutorial 5.5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=2s8AwoKZ-UE">
<img class="lazy" data-src="https://i.ytimg.com/vi/2s8AwoKZ-UE/hqdefault.jpg"></a>
<h2>Valentiness Day Gift for Math/Stats Nerds [MarinStatsLectures]</h2><a href="https://www.youtube.com/watch?v=tceJhELBWow">
<img class="lazy" data-src="https://i.ytimg.com/vi/tceJhELBWow/hqdefault.jpg"></a>
<h2>Multiple Linear Regression in R | R Tutorial 5.3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=q1RD5ECsSB0">
<img class="lazy" data-src="https://i.ytimg.com/vi/q1RD5ECsSB0/hqdefault.jpg"></a>
<h2>Checking Linear Regression Assumptions in R | R Tutorial 5.2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=eTZ4VUZHzxw">
<img class="lazy" data-src="https://i.ytimg.com/vi/eTZ4VUZHzxw/hqdefault.jpg"></a>
<h2>MarinStatsLectures! About Us.</h2><a href="https://www.youtube.com/watch?v=ECQLuizC7mk">
<img class="lazy" data-src="https://i.ytimg.com/vi/ECQLuizC7mk/hqdefault.jpg"></a>
<h2>Sheldon Fail: Probability vs. Odds (Big Bang Theory)</h2><a href="https://www.youtube.com/watch?v=ec5CkOYnXfc">
<img class="lazy" data-src="https://i.ytimg.com/vi/ec5CkOYnXfc/hqdefault.jpg"></a>
<h2>Simple Linear Regression in R | R Tutorial 5.1 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=66z_MRwtFJM">
<img class="lazy" data-src="https://i.ytimg.com/vi/66z_MRwtFJM/hqdefault.jpg"></a>
<h2>Correlations and Covariance in R with Example  | R Tutorial 4.12 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=XaNKst8ODEQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/XaNKst8ODEQ/hqdefault.jpg"></a>
<h2>Odds Ratio, Relative Risk & Risk Difference with R | R Tutorial 4.11| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=V_YNPQoAyCc">
<img class="lazy" data-src="https://i.ytimg.com/vi/V_YNPQoAyCc/hqdefault.jpg"></a>
<h2>Import Data, Copy Data from Excel to R CSV & TXT Files | R Tutorial 1.5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=qPk0YEKhqB8">
<img class="lazy" data-src="https://i.ytimg.com/vi/qPk0YEKhqB8/hqdefault.jpg"></a>
<h2>Chi-Square Test, Fisher¡¯s Exact Test, & Cross Tabulations in R | R Tutorial 4.10| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=POiHEJqmiC0">
<img class="lazy" data-src="https://i.ytimg.com/vi/POiHEJqmiC0/hqdefault.jpg"></a>
<h2>ANOVA, ANOVA Multiple Comparisons & Kruskal Wallis in R | R Tutorial 4.9 | MarinStatsLectures|</h2><a href="https://www.youtube.com/watch?v=lpdFr5SZR0Q">
<img class="lazy" data-src="https://i.ytimg.com/vi/lpdFr5SZR0Q/hqdefault.jpg"></a>
<h2>Wilcoxon Signed Rank Test in R with Example | R Tutorial 4.8 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=zM8OZUM5I4Y">
<img class="lazy" data-src="https://i.ytimg.com/vi/zM8OZUM5I4Y/hqdefault.jpg"></a>
<h2>Paired t-Test in R with Examples | R Tutorial 4.7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=yD6aU0fY2lo">
<img class="lazy" data-src="https://i.ytimg.com/vi/yD6aU0fY2lo/hqdefault.jpg"></a>
<h2>Mann Whitney U / Wilcoxon Rank-Sum Test in R | R Tutorial 4.3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=KroKhtCD9eE">
<img class="lazy" data-src="https://i.ytimg.com/vi/KroKhtCD9eE/hqdefault.jpg"></a>
<h2>Two-Sample t Test in R (Independent Groups) with Example | R Tutorial 4.2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=RlhnNbPZC0A">
<img class="lazy" data-src="https://i.ytimg.com/vi/RlhnNbPZC0A/hqdefault.jpg"></a>
<h2>One-Sample t Test & Confidence Interval in R with Example | R Tutorial 4.1| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=kvmSAXhX9Hs">
<img class="lazy" data-src="https://i.ytimg.com/vi/kvmSAXhX9Hs/hqdefault.jpg"></a>
<h2>t Distribution and t Scores in R | R Tutorial 3.4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ETd-jPhI_tE">
<img class="lazy" data-src="https://i.ytimg.com/vi/ETd-jPhI_tE/hqdefault.jpg"></a>
<h2>Normal Distribution, Z Scores, and Normal Probabilities in R | R Tutorial 3.3| MarinStatslectures</h2><a href="https://www.youtube.com/watch?v=peEsXbdMY_4">
<img class="lazy" data-src="https://i.ytimg.com/vi/peEsXbdMY_4/hqdefault.jpg"></a>
<h2>Poisson Distribution in R | R Tutorial 3.2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=778WK1Pf8eI">
<img class="lazy" data-src="https://i.ytimg.com/vi/778WK1Pf8eI/hqdefault.jpg"></a>
<h2>Binomial Distribution in R | R Tutorial 3.1| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=iG995W0XefU">
<img class="lazy" data-src="https://i.ytimg.com/vi/iG995W0XefU/hqdefault.jpg"></a>
<h2>Calculating Mean, Standard Deviation, Frequencies and More in R | R Tutorial 2.8| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=ACWuV16tdhY">
<img class="lazy" data-src="https://i.ytimg.com/vi/ACWuV16tdhY/hqdefault.jpg"></a>
<h2>How to Modify and Customize Plots in R | R Tutorial 2.9 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=lPOSwfxMd3c">
<img class="lazy" data-src="https://i.ytimg.com/vi/lPOSwfxMd3c/hqdefault.jpg"></a>
<h2>Scatterplots in R | R Tutorial 2.7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=FEAS3akVxD8">
<img class="lazy" data-src="https://i.ytimg.com/vi/FEAS3akVxD8/hqdefault.jpg"></a>
<h2>Stacked and Grouped Bar Charts and Mosaic Plots in R |R Tutorial 2.6| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=rl1tB9p3FLg">
<img class="lazy" data-src="https://i.ytimg.com/vi/rl1tB9p3FLg/hqdefault.jpg"></a>
<h2>Stem and Leaf Plots in R  | R Tutorial 2.5 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=NpBRo0tRNeY">
<img class="lazy" data-src="https://i.ytimg.com/vi/NpBRo0tRNeY/hqdefault.jpg"></a>
<h2>Histograms in R | R Tutorial 2.4 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Hj1pgap4UOY">
<img class="lazy" data-src="https://i.ytimg.com/vi/Hj1pgap4UOY/hqdefault.jpg"></a>
<h2>Boxplots and Grouped Boxplots in R | R Tutorial 2.2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=U64yNvlhv9I">
<img class="lazy" data-src="https://i.ytimg.com/vi/U64yNvlhv9I/hqdefault.jpg"></a>
<h2>Bar Charts and Pie Charts in R | R Tutorial 2.1 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=Eph_Y0BmHU0">
<img class="lazy" data-src="https://i.ytimg.com/vi/Eph_Y0BmHU0/hqdefault.jpg"></a>
<h2>Customizing The Look of R Studio | R Tutorial 1.14 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=5dNNcC-UBeA">
<img class="lazy" data-src="https://i.ytimg.com/vi/5dNNcC-UBeA/hqdefault.jpg"></a>
<h2>How to Install Packages in R | R Tutorial 1.13 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=3RWb5U3X-T8">
<img class="lazy" data-src="https://i.ytimg.com/vi/3RWb5U3X-T8/hqdefault.jpg"></a>
<h2>Writing Scripts in R | R Tutorial 1.12 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=qqz_D1vzS5M">
<img class="lazy" data-src="https://i.ytimg.com/vi/qqz_D1vzS5M/hqdefault.jpg"></a>
<h2>Setting Up Working Directory in R  | R Tutorial 1.11 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=OJ4WBjV5o1I">
<img class="lazy" data-src="https://i.ytimg.com/vi/OJ4WBjV5o1I/hqdefault.jpg"></a>
<h2>Logic Statements (TRUE/FALSE), cbind and rbind Functions in R | R Tutorial 1.10| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=NFaK1Qn4u3A">
<img class="lazy" data-src="https://i.ytimg.com/vi/NFaK1Qn4u3A/hqdefault.jpg"></a>
<h2>Subsetting (Sort/Select) Data in R with Square Brackets | R Tutorial 1.9| MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=jGf7WNh-LX8">
<img class="lazy" data-src="https://i.ytimg.com/vi/jGf7WNh-LX8/hqdefault.jpg"></a>
<h2>Working with Variables and Data in R | R Tutorial 1.8 | MarinStatslectures</h2><a href="https://www.youtube.com/watch?v=1BcGnHwUT6k">
<img class="lazy" data-src="https://i.ytimg.com/vi/1BcGnHwUT6k/hqdefault.jpg"></a>
<h2>Importing , Checking and Working with Data in R | R Tutorial 1.7 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=U4-RnTW5dfw">
<img class="lazy" data-src="https://i.ytimg.com/vi/U4-RnTW5dfw/hqdefault.jpg"></a>
<h2>Create and Work with Vectors and Matrices in R | R Tutorial 1.4 | MarinStatslectures</h2><a href="https://www.youtube.com/watch?v=2TcPAZOyV0U">
<img class="lazy" data-src="https://i.ytimg.com/vi/2TcPAZOyV0U/hqdefault.jpg"></a>
<h2>Getting started with R: Basic Arithmetic and Coding in R | R Tutorial 1.3 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=UYclmg1_KLk">
<img class="lazy" data-src="https://i.ytimg.com/vi/UYclmg1_KLk/hqdefault.jpg"></a>
<h2>Download and Install R and RStudio  | R Tutorial 1.2 | MarinStatsLectures</h2><a href="https://www.youtube.com/watch?v=cX532N_XLIs">
<img class="lazy" data-src="https://i.ytimg.com/vi/cX532N_XLIs/hqdefault.jpg"></a>
<h2>Using the lapply function in R</h2><a href="https://www.youtube.com/watch?v=GgdR2OV8r_M">
<img class="lazy" data-src="https://i.ytimg.com/vi/GgdR2OV8r_M/hqdefault.jpg"></a>
<h2>Using the apply function in R</h2><a href="https://www.youtube.com/watch?v=csLati8vpOo">
<img class="lazy" data-src="https://i.ytimg.com/vi/csLati8vpOo/hqdefault.jpg"></a>
<h2>Using tapply and split in R</h2><a href="https://www.youtube.com/watch?v=9yCLZnKkLBg">
<img class="lazy" data-src="https://i.ytimg.com/vi/9yCLZnKkLBg/hqdefault.jpg"></a>
<h2>The mapply function in R</h2><a href="https://www.youtube.com/watch?v=EziuPEgNqvU">
<img class="lazy" data-src="https://i.ytimg.com/vi/EziuPEgNqvU/hqdefault.jpg"></a>
<h2>Control Structures in R</h2><a href="https://www.youtube.com/watch?v=s_h9ruNwI_0">
<img class="lazy" data-src="https://i.ytimg.com/vi/s_h9ruNwI_0/hqdefault.jpg"></a>
<h2>Reading/Writing Data: Part 1</h2><a href="https://www.youtube.com/watch?v=aBzAels6jPk">
<img class="lazy" data-src="https://i.ytimg.com/vi/aBzAels6jPk/hqdefault.jpg"></a>
<h2>Reading/Writing Data: Part 2</h2><a href="https://www.youtube.com/watch?v=cUUqDWttMws">
<img class="lazy" data-src="https://i.ytimg.com/vi/cUUqDWttMws/hqdefault.jpg"></a>
<h2>Lecture 2c: Vectorized Operations</h2><a href="https://www.youtube.com/watch?v=Fm8SORJQjPY">
<img class="lazy" data-src="https://i.ytimg.com/vi/Fm8SORJQjPY/hqdefault.jpg"></a>
<h2>Lecture 2b: Subsetting</h2><a href="https://www.youtube.com/watch?v=hWbgqzsQJF0">
<img class="lazy" data-src="https://i.ytimg.com/vi/hWbgqzsQJF0/hqdefault.jpg"></a>
<h2>Lecture 2a: Data Types</h2><a href="https://www.youtube.com/watch?v=5AQM-yUX9zg">
<img class="lazy" data-src="https://i.ytimg.com/vi/5AQM-yUX9zg/hqdefault.jpg"></a>
<h2>Background and Overview</h2><a href="https://www.youtube.com/watch?v=kzxHxFHW6hs">
<img class="lazy" data-src="https://i.ytimg.com/vi/kzxHxFHW6hs/hqdefault.jpg"></a>
<h2>Simulation in R</h2><a href="https://www.youtube.com/watch?v=tvv4IA8PEzw">
<img class="lazy" data-src="https://i.ytimg.com/vi/tvv4IA8PEzw/hqdefault.jpg"></a>
<h2>PlottingBase</h2><a href="https://www.youtube.com/watch?v=R2Zh_kPxrmg">
<img class="lazy" data-src="https://i.ytimg.com/vi/R2Zh_kPxrmg/hqdefault.jpg"></a>
<h2>PlottingBaseDemo</h2><a href="https://www.youtube.com/watch?v=4KLfzsj-qkE">
<img class="lazy" data-src="https://i.ytimg.com/vi/4KLfzsj-qkE/hqdefault.jpg"></a>
<h2>PlottingLattice</h2><a href="https://www.youtube.com/watch?v=AhTjV9nAJv0">
<img class="lazy" data-src="https://i.ytimg.com/vi/AhTjV9nAJv0/hqdefault.jpg"></a>
<h2>PlottingMath</h2><a href="https://www.youtube.com/watch?v=gNT33XIgw6E">
<img class="lazy" data-src="https://i.ytimg.com/vi/gNT33XIgw6E/hqdefault.jpg"></a>
<h2>Manta Unleashed BigDataSG Meetup - Part 1 of 2</h2><a href="https://www.youtube.com/watch?v=5XwOzb3LcOA">
<img class="lazy" data-src="https://i.ytimg.com/vi/5XwOzb3LcOA/hqdefault.jpg"></a>
<h2>Manta Unleashed BigDataSG Meetup - Part 2 of 2</h2><a href="https://www.youtube.com/watch?v=W2kywGUuz3g">
<img class="lazy" data-src="https://i.ytimg.com/vi/W2kywGUuz3g/hqdefault.jpg"></a>
<h2>Manipulating Data in R</h2><a href="https://www.youtube.com/watch?v=Y05UK1phiTA">
<img class="lazy" data-src="https://i.ytimg.com/vi/Y05UK1phiTA/hqdefault.jpg"></a>
<h2>Simple Graphs in R</h2><a href="https://www.youtube.com/watch?v=S0uoef36iFU">
<img class="lazy" data-src="https://i.ytimg.com/vi/S0uoef36iFU/hqdefault.jpg"></a>
<h2>Open and Save in R</h2><a href="https://www.youtube.com/watch?v=owYP9OgmrJk">
<img class="lazy" data-src="https://i.ytimg.com/vi/owYP9OgmrJk/hqdefault.jpg"></a>
<h2>Setting Up R</h2><a href="https://www.youtube.com/watch?v=OhHmQmih9EM">
<img class="lazy" data-src="https://i.ytimg.com/vi/OhHmQmih9EM/hqdefault.jpg"></a>
<h2>The R Language</h2><a href="https://www.youtube.com/watch?v=Y7ZGgsMwfkk">
<img class="lazy" data-src="https://i.ytimg.com/vi/Y7ZGgsMwfkk/hqdefault.jpg"></a>
<h2>Cell</h2><a href="https://www.youtube.com/watch?v=4fhSoN3tuSA">
<img class="lazy" data-src="https://i.ytimg.com/vi/4fhSoN3tuSA/hqdefault.jpg"></a>
<h2>HitPipes - Flintstones Theme</h2><a href="https://www.youtube.com/watch?v=TyY9t9kVnno">
<img class="lazy" data-src="https://i.ytimg.com/vi/TyY9t9kVnno/hqdefault.jpg"></a>
<h2>HitPipes - My Sharona</h2><a href="https://www.youtube.com/watch?v=L03e2M9QTW4">
<img class="lazy" data-src="https://i.ytimg.com/vi/L03e2M9QTW4/hqdefault.jpg"></a>
<h2>HitPipes AC/DC Thunderstruck Intro</h2><a href="https://www.youtube.com/watch?v=eEnk8uXq5wQ">
<img class="lazy" data-src="https://i.ytimg.com/vi/eEnk8uXq5wQ/hqdefault.jpg"></a>
<h2>Stefanie finds Bioinformatics (1999) Flash Movie</h2><a href="https://www.youtube.com/watch?v=yzL1yJ8znz0">
<img class="lazy" data-src="https://i.ytimg.com/vi/yzL1yJ8znz0/hqdefault.jpg"></a>
<h2>Prototype PVC Instrument - HitPipes(tm)</h2><a href="https://www.youtube.com/watch?v=LdrNOB1dA28">
<img class="lazy" data-src="https://i.ytimg.com/vi/LdrNOB1dA28/hqdefault.jpg"></a>

<h2>unname</h2>
Remove the names or dimnames attribute of an R object.
unname(obj, force = FALSE)

<h2>convert date to a day of week</h2>
weekdays(as.Date("201022", format="%y%m%d"))

<h2>RGB to Hex converter</h2>
rgb(123,212,125, maxColorValue=255)


<h2>generate crayon color table</h2>
  # rgb(123,212,125, maxColorValue=255), edit final commands
sink("colorcmd.txt")
for(i in 0:7){
  for(j in 0:7){
    for(k in 0:7){
      colorCode = rgb(i*32,j*32,k*32, maxColorValue=256)
      colorName = gsub("#","c",colorCode)
      cat("\n",colorName, '= make_style\\("', colorCode, '"\\)', sep="")
      cat(';cat\\(',colorName,'\\(\"',colorCode,"\"\\),\"\\n\\\")", sep="")
    }
  }
  cat("\n")
}
sink()
<h2>find repeated characters on same line</h2>
    for(i in 1:length(jsPrep)){
      MultiBracket = length(unlist(gregexpr("\\(", jsPrep[i])))
    }

<h2>Parallel Computing</h2>
<h3>Terminology</h3>
Let’s just nail down some terminology.

A <em>core</em> is a general term for either a single processor on your own computer (technically you only have one processor, but a modern processor like the i7 can have multiple cores - hence the term) or a single machine in a cluster network.

A <em>cluster</em> is a collection of objecting capable of hosting cores, either a network or just the collection of cores on your personal computer.

A <em>process</em> is a single running version of R (or more generally any program). 
Each core runs a single process.

<h3>The <code>parallel</code> package</h3>
There are a number of packages which can be used for parallel processing in R. 
Two of the earliest and strongest were <code>multicore</code> and <code>snow</code>. 
However, both were adopted in the base R installation and merged into the <code>parallel</code> package.

<code>library(parallel)</code>

You can easily check the number of cores you have access to with <code>detectCores</code>:

<code>detectCores()</code>

<code>## [1] 4</code>

The number of cores represented is not neccessarily correlated with the number of processors you actually have thanks to the concept of "logical CPUs". 
For the most part, you can use this number as accurate. 
Trying to use more cores than you have available won’t provide any benefit.

<h3>Methods of Paralleization</h3>
There are two main ways in which code can be parallelized, via <em>sockets</em> or via <em>forking</em>. 
These function slightly differently:

The <em>socket</em> approach launches a new version of R on each core. 
Technically this connection is done via networking (e.g.&nbsp;the same as if you connected to a remote server), but the connection is happening all on your own computer<a href="#fn3" id="fnref3"><sup>3</sup></a> I mention this because you may get a warning from your computer asking whether to allow R to accept incoming connections, you should allow it.

The <em>forking</em> approach copies the entire current version of R and moves it to a new core.

There are various pro’s and con’s to the two approaches:

Socket:

Pro: Works on any system (including Windows).

Pro: Each process on each node is unique so it can’t cross-contaminate.

Con: Each process is unique so it will be slower

Con: Things such as package loading need to be done in each process separately. 
Variables defined on your main version of R don’t exist on each core unless explicitly placed there.

Con: More complicated to implement.

Forking:

Con: Only works on POSIX systems (Mac, Linux, Unix, BSD) and not Windows.

Con: Because processes are duplicates, it can cause issues specifically with random number generation (which should usually be handled by <code>parallel</code> in the background) or when running in a GUI (such as RStudio). 
This doesn’t come up often, but if you get odd behavior, this may be the case.

Pro: Faster than sockets.

Pro: Because it copies the existing version of R, your entire workspace exists in each process.

Pro: Trivially easy to implement.

In general, I’d recommend using forking if you’re not on Windows.

<em>Note</em>: These notes were compiled on OS X.

<h3>Forking with <code>mclapply</code></h3>
The most straightforward way to enable parallel processing is by switching from using <code>lapply</code> to <code>mclapply</code>. 
(Note I’m using <code>system.time</code> instead of <code>profvis</code> here because I only care about running time, not profiling.)

<code>library(lme4)</code>

<code>## Loading required package: Matrix</code>

<code>f &lt;- function(i) {
  lmer(Petal.Width ~ . 
- Species + (1 | Species), data = iris)
}
 
system.time(save1 &lt;- lapply(1:100, f))</code>

<code>##    user  system elapsed 
##   2.048   0.019   2.084</code>

<code>system.time(save2 &lt;- mclapply(1:100, f))</code>

<code>##    user  system elapsed 
##   1.295   0.150   1.471</code>

If you were to run this code on Windows, <code>mclapply</code> would simply call <code>lapply</code>, so the code works but sees no speed gain.

<code>mclapply</code> takes an argument, <code>mc.cores</code>. 
By default, <code>mclapply</code> will use all cores available to it. 
If you don’t want to (either becaues you’re on a shared system or you just want to save processing power for other purposes) you can set this to a value lower than the number of cores you have. 
Setting it to 1 disables parallel processing, and setting it higher than the number of available cores has no effect.

<h3>Using sockets with <code>parLapply</code></h3>
As promised, the sockets approach to parallel processing is more complicated and a bit slower, but works on Windows systems. 
The general process we’ll follow is


Start a cluster with <mi>n</mi></math>" role="presentation" style="position: relative;"><nobr aria-hidden="true">n</nobr><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>n</mi></math><script type="math/tex" id="MathJax-Element-3">n</script> nodes.

Execute any pre-processing code necessary in each node (e.g.&nbsp;loading a package)

Use <code>par*apply</code> as a replacement for <code>*apply</code>. 
Note that unlike <code>mcapply</code>, this is <em>not</em> a drop-in replacement.

Destroy the cluster (not necessary, but best practices).


<h4>Starting a cluster</h4>
The function to start a cluster is <code>makeCluster</code> which takes in as an argument the number of cores:

<code>numCores &lt;- detectCores()
numCores</code>

<code>## [1] 4</code>

<code>cl &lt;- makeCluster(numCores)</code>

The function takes an argument <code>type</code> which can be either <code>PSOCK</code> (the socket version) or <code>FORK</code> (the fork version). 
Generally, <code>mclapply</code> should be used for the forking approach, so there’s no need to change this.

If you were running this on a network of multiple computers as opposed to on your local machine, there are additional argumnts you may wish to run, but generally the other defaults should be specific.

<h4>Pre-processing code</h4>
When using the socket approach to parallel processing, each process is started fresh, so things like loaded packages and any variables existing in your current session do not exist. 
We must instead move those into each process.

The most generic way to do this is the <code>clusterEvalQ</code> function, which takes a cluster and any expression, and executes the expression on each process.

<code>clusterEvalQ(cl, 2 + 2)</code>

<code>## [[1]]
## [1] 4
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 4
## 
## [[4]]
## [1] 4</code>

Note the lack of inheritance:

<code>x &lt;- 1
clusterEvalQ(cl, x)</code>

<code>## Error in checkForRemoteErrors(lapply(cl, recvResult)): 4 nodes produced errors; first error: object 'x' not found</code>

We could fix this by wrapping the assignment in a <code>clusterEvalQ</code> call:

<code>clusterEvalQ(cl, y &lt;- 1)</code>

<code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1</code>

<code>clusterEvalQ(cl, y)</code>

<code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1</code>

<code>y</code>

<code>## Error in eval(expr, envir, enclos): object 'y' not found</code>

However, now <code>y</code> doesn’t exist in the main process. 
We can instead use <code>clusterExport</code> to pass objects to the processes:

<code>clusterExport(cl, "x")
clusterEvalQ(cl, x)</code>

<code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1
## 
## [[3]]
## [1] 1
## 
## [[4]]
## [1] 1</code>

The second argument is a vector of strings naming the variables to pass.

Finally, we can use <code>clusterEvalQ</code> to load packages:

<code>clusterEvalQ(cl, {
  library(ggplot2)
  library(stringr)
})</code>

<code>## [[1]]
## [1] "stringr"   "ggplot2"   "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[2]]
## [1] "stringr"   "ggplot2"   "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[3]]
## [1] "stringr"   "ggplot2"   "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[4]]
## [1] "stringr"   "ggplot2"   "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"</code>

Note that this helpfully returns a list of the packages loaded in each process.

<h4>Using <code>par*apply</code></h4>
There are parallel versions of the three main <code>apply</code> statements: <code>parApply</code>, <code>parLapply</code> and <code>parSapply</code> for <code>apply</code>, <code>lapply</code> and <code>sapply</code> respectively. 
They take an additional argument for the cluster to operate on.

<code>parSapply(cl, Orange, mean, na.rm = TRUE)</code>

<code>##          Tree           age circumference 
##            NA      922.1429      115.8571</code>

All the general advice and rules about <code>par*apply</code> apply as with the normal <code>*apply</code> functions.

<h4>Close the cluster</h4>
<code>stopCluster(cl)</code>

This is not fully necessary, but is best practices. 
If not stopped, the processes continue to run in the background, consuming resources, and any new processes can be slowed or delayed. 
If you exit R, it should automatically close all processes also. 
This <em>does not</em> delete the <code>cl</code> object, just the cluster it refers to in the background.

Keep in mind that closing a cluster is equivalent to quitting R in each; anything saved there is lost and packages will need to be re-loaded.

<h4>Continuing the example</h4>
<code>cl &lt;- makeCluster(detectCores())
clusterEvalQ(cl, library(lme4))</code>

<code>## [[1]]
## [1] "lme4"      "Matrix"    "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[2]]
## [1] "lme4"      "Matrix"    "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[3]]
## [1] "lme4"      "Matrix"    "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"     
## 
## [[4]]
## [1] "lme4"      "Matrix"    "stats"     "graphics"  "grDevices" "utils"    
## [7] "datasets"  "methods"   "base"</code>

<code>system.time(save3 &lt;- parLapply(cl, 1:100, f))</code>

<code>##    user  system elapsed 
##   0.095   0.017   1.145</code>

<code>stopCluster(cl)</code>

Timing this is tricky - if we just time the <code>parLapply</code> call we’re not capturing the time to open and close the cluster, and if we time the whole thing, we’re including the call to lme4. 
To be completely fair, we need to include loading <code>lme4</code> in all three cases. 
I do this outside of this Markdown file to ensure no added complications. 
The three pieces of code were, with a complete restart of R after each:

<code>### lapply
library(parallel)
f &lt;- function(i) {
  lmer(Petal.Width ~ . 
- Species + (1 | Species), data = iris)
}

system.time({
  library(lme4)
  save1 &lt;- lapply(1:100, f)
})

### mclapply
library(parallel)
f &lt;- function(i) {
  lmer(Petal.Width ~ . 
- Species + (1 | Species), data = iris)
}

system.time({
  library(lme4)
  save2 &lt;- mclapply(1:100, f)
})

### mclapply
library(parallel)
f &lt;- function(i) {
  lmer(Petal.Width ~ . 
- Species + (1 | Species), data = iris)
}

system.time({
  cl &lt;- makeCluster(detectCores())
  clusterEvalQ(cl, library(lme4))
  save3 &lt;- parLapply(cl, 1:100, f)
  stopCluster(cl)
})</code>

<table>
<thead>
<tr>
<th align="center">lapply</th>
<th align="center">mclapply</th>
<th align="center">parLapply</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">4.237</td>
<td align="center">4.087</td>
<td align="center">6.954</td>
</tr>
</tbody>
</table>

This shows the additional overhead that can occur with the socket approach - it can definitely be faster, but in this case the overhead which is added slows it down. 
The individual running time of the single <code>parLapply</code> call is faster.

Also known as "embarrassingly parallel" though I don’t like that term.<a href="#fnref1">↩</a>

In this situation, we would actually run <em>slower</em> because of the overhead!<a href="#fnref2">↩</a>

The flexibility of this to work across computers is what allows massive servers made up of many computers to work in parallel.<a href="#fnref3">↩</a>

<h3>Loops and repetitive tasks using lapply</h3>
Let’s build a simple loop that uses sample with replacement to do a bootstrap analysis. 
In this case, we select <code>Sepal.Length</code> and <code>Species</code> from the <code>iris</code> dataset, subset it to 100 observations, and then iterate across 10,000 trials, each time resampling the observations with replacement. 
We then run a logistic regression fitting species as a function of length, and record the coefficients for each trial to be returned.

<code class="r">x &lt;- iris[which(iris[,5] != "setosa"), c(1,5)]
trials &lt;- 10000
res &lt;- data.frame()
system.time({
  trial &lt;- 1
  while(trial &lt;= trials) {
    ind &lt;- sample(100, 100, replace=TRUE)
    result1 &lt;- glm(x[ind,2]~x[ind,1], family=binomial(logit))
    r &lt;- coefficients(result1)
    res &lt;- rbind(res, r)
    trial &lt;- trial + 1
  }
})</code>

<code>##    user  system elapsed 
##  20.031   0.458  21.220</code>

The issue with this loop is that we execute each trial sequentially, which means that only one of our 8 processors on this machine are in use. 
In order to exploit parallelism, we need to be able to dispatch our tasks as functions, with one task going to each processor. 
To do that, we need to convert our task to a function, and then use the <code>*apply()</code> family of R functions to apply that function to all of the members of a set. 
In R, using <code>apply</code> is often significantly faster than the equivalent code in a loop. 
Here’s the same code rewritten to use <code>lapply()</code>, which applies a function to each of the members of a list (in this case the trials we want to run):

<code class="r">x &lt;- iris[which(iris[,5] != "setosa"), c(1,5)]
trials &lt;- seq(1, 10000)
boot_fx &lt;- function(trial) {
  ind &lt;- sample(100, 100, replace=TRUE)
  result1 &lt;- glm(x[ind,2]~x[ind,1], family=binomial(logit))
  r &lt;- coefficients(result1)
  res &lt;- rbind(data.frame(), r)
}
system.time({
  results &lt;- lapply(trials, boot_fx)
})</code>

<code>##    user  system elapsed 
##  19.340   0.553  20.315</code>

<h3>Approaches to parallelization</h3>
When parallelizing jobs, one can:


Use the multiple cores on a local computer through <code>mclapply</code>

Use multiple processors on local (and remote) machines using <code>makeCluster</code> and <code>clusterApply</code>


In this approach, one has to manually copy data and code to each cluster member using <code>clusterExport</code>
This is extra work, but sometimes gaining access to a large cluster is worth it



<h3>Parallelize using: mclapply</h3>
The <code>parallel</code> library can be used to send tasks (encoded as function calls) to each of the processing cores on your machine in parallel. 
This is done by using the <code>parallel::mclapply</code> function, which is analogous to <code>lapply</code>, but distributes the tasks to multiple processors. 
<code>mclapply</code> gathers up the responses from each of these function calls, and returns a list of responses that is the same length as the list or vector of input data (one return per input item).

<code class="r">library(parallel)
library(MASS)

starts &lt;- rep(100, 40)
fx &lt;- function(nstart) kmeans(Boston, 4, nstart=nstart)
numCores &lt;- detectCores()
numCores</code>

<code>## [1] 8</code>

<code class="r">system.time(
  results &lt;- lapply(starts, fx)
)</code>

<code>##    user  system elapsed 
##   1.346   0.024   1.372</code>

<code class="r">system.time(
  results &lt;- mclapply(starts, fx, mc.cores = numCores)
)</code>

<code>##    user  system elapsed 
##   0.801   0.178   0.367</code>

Now let’s demonstrate with our bootstrap example:

<code class="r">x &lt;- iris[which(iris[,5] != "setosa"), c(1,5)]
trials &lt;- seq(1, 10000)
boot_fx &lt;- function(trial) {
  ind &lt;- sample(100, 100, replace=TRUE)
  result1 &lt;- glm(x[ind,2]~x[ind,1], family=binomial(logit))
  r &lt;- coefficients(result1)
  res &lt;- rbind(data.frame(), r)
}
system.time({
  results &lt;- mclapply(trials, boot_fx, mc.cores = numCores)
})</code>

<code>##    user  system elapsed 
##  25.672   1.343   5.003</code>

<h3>Parallelize using: foreach and doParallel</h3>
The normal <code>for</code> loop in R looks like:

<code class="r">for (i in 1:3) {
  print(sqrt(i))
}</code>

<code>## [1] 1
## [1] 1.414214
## [1] 1.732051</code>

The <code>foreach</code> method is similar, but uses the sequential <code>%do%</code> operator to indicate an expression to run. 
Note the difference in the returned data structure.

<code class="r">library(foreach)
foreach (i=1:3) %do% {
  sqrt(i)
}</code>

<code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051</code>

In addition, <code>foreach</code> supports a parallelizable operator <code>%dopar%</code> from the <code>doParallel</code> package. 
This allows each iteration through the loop to use different cores or different machines in a cluster. 
Here, we demonstrate with using all the cores on the current machine:

<code class="r">library(foreach)
library(doParallel)</code>

<code>## Loading required package: iterators</code>

<code class="r">registerDoParallel(numCores)  # use multicore, set to the number of our cores
foreach (i=1:3) %dopar% {
  sqrt(i)
}</code>

<code>## [[1]]
## [1] 1
## 
## [[2]]
## [1] 1.414214
## 
## [[3]]
## [1] 1.732051</code>

<code class="r"># To simplify output, foreach has the .combine parameter that can simplify return values

# Return a vector
foreach (i=1:3, .combine=c) %dopar% {
  sqrt(i)
}</code>

<code>## [1] 1.000000 1.414214 1.732051</code>

<code class="r"># Return a data frame
foreach (i=1:3, .combine=rbind) %dopar% {
  sqrt(i)
}</code>

<code>##              [,1]
## result.1 1.000000
## result.2 1.414214
## result.3 1.732051</code>

The <a href="https://cran.r-project.org/web/packages/doParallel/vignettes/gettingstartedParallel.pdf">doParallel vignette</a> on CRAN shows a much more realistic example, where one can use `%dopar% to parallelize a bootstrap analysis where a data set is resampled 10,000 times and the analysis is rerun on each sample, and then the results combined:

<code class="r"># Let's use the iris data set to do a parallel bootstrap
# From the doParallel vignette, but slightly modified
x &lt;- iris[which(iris[,5] != "setosa"), c(1,5)]
trials &lt;- 10000
system.time({
  r &lt;- foreach(icount(trials), .combine=rbind) %dopar% {
    ind &lt;- sample(100, 100, replace=TRUE)
    result1 &lt;- glm(x[ind,2]~x[ind,1], family=binomial(logit))
    coefficients(result1)
  }
})</code>

<code>##    user  system elapsed 
##  24.117   1.303   4.944</code>

<code class="r"># And compare that to what it takes to do the same analysis in serial
system.time({
  r &lt;- foreach(icount(trials), .combine=rbind) %do% {
    ind &lt;- sample(100, 100, replace=TRUE)
    result1 &lt;- glm(x[ind,2]~x[ind,1], family=binomial(logit))
    coefficients(result1)
  }
})</code>

<code>##    user  system elapsed 
##  19.445   0.571  20.302</code>

<code class="r"># When you're done, clean up the cluster
stopImplicitCluster()</code>

<h2>R run vbs</h2>
write the VBS as follows:

Dim Msg_Text
Msg_Text = WScript.Arguments(0)
MsgBox("Hello " & Msg_Text)

Create a system command in R like this:
system_command <- paste("WScript",
                        '"Msg_Script.vbs"',
                        '"World"',
                        sep = " ")

system(command = system_command, wait = TRUE)


If use named arguments instead:
Dim Msg_Text
Msg_Text = WScript.Arguments.Named.Item("Msg_Text")
MsgBox("Hello " & Msg_Text)

Then create a system command in R like this:
system_command <- paste("WScript",
                        '"Msg_Script.vbs"',
                        '/Msg_Text:"World"',
                        sep = " ")
system(command = system_command, wait = TRUE)

    system(paste("WScript", '"D:/Dropbox/STK/!!! STKMon !!!/playSound.vbs"', sep = " "))


<h2>colorspace: Manipulating and Assessing Colors and Palettes</h2>
https://cran.r-project.org/web/packages/colorspace/vignettes/colorspace.html
The <em>colorspace</em> package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualizations.

At the core of the package there are various utilities for computing with color spaces (as the name conveys). 
Thus, the package helps to map various three-dimensional representations of color to each other. 
A particularly important mapping is the one from the perceptually-based and device-independent color model HCL (Hue-Chroma-Luminance) to standard Red-Green-Blue (sRGB) which is the basis for color specifications in many systems based on the corresponding hex codes (e.g., in HTML but also in R). 
For completeness further standard color models are included as well in the package: <code>polarLUV()</code> (= HCL), <code>LUV()</code>, <code>polarLAB()</code>, <code>LAB()</code>, <code>XYZ()</code>, <code>RGB()</code>, <code>sRGB()</code>, <code>HLS()</code>, <code>HSV()</code>.

The HCL space (= polar coordinates in CIELUV) is particularly useful for specifying individual colors and color palettes as its three axes match those of the human visual system very well: Hue (= type of color, dominant wavelength), chroma (= colorfulness), luminance (= brightness).

The <em>colorspace</em> package provides three types of palettes based on the HCL model:

<em>Qualitative:</em> Designed for coding categorical information, i.e., where no particular ordering of categories is available and every color should receive the same perceptual weight. 
Function: <code>qualitative_hcl()</code>.

<em>Sequential:</em> Designed for coding ordered/numeric information, i.e., where colors go from high to low (or vice versa). 
Function: <code>sequential_hcl()</code>.

<em>Diverging:</em> Designed for coding ordered/numeric information around a central neutral value, i.e., where colors diverge from neutral to two extremes. 
Function: <code>diverging_hcl()</code>.

To aid choice and application of these palettes there are: scales for use with <em>ggplot2</em>; <em>shiny</em> (and <em>tcltk</em>) apps for interactive exploration; visualizations of palette properties; accompanying manipulation utilities (like desaturation, lighten/darken, and emulation of color vision deficiencies).

More detailed overviews and examples are provided in the articles:

<a href="http://colorspace.R-Forge.R-project.org/articles/color_spaces.html">Color Spaces: S4 Classes and Utilities</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/hcl_palettes.html">HCL-Based Color Palettes</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/ggplot2_color_scales.html">HCL-Based Color Scales for <em>ggplot2</em></a>

<a href="http://colorspace.R-Forge.R-project.org/articles/palette_visualization.html">Palette Visualization and Assessment</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/hclwizard.html">Apps for Choosing Colors and Palettes Interactively</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/color_vision_deficiency.html">Color Vision Deficiency Emulation</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/manipulation_utilities.html">Color Manipulation and Utilities</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/approximations.html">Approximating Palettes from Other Packages</a>

<a href="http://colorspace.R-Forge.R-project.org/articles/endrainbow.html">Somewhere over the Rainbow</a>

<h3>Installation</h3>
The stable release version of <em>colorspace</em> is hosted on the Comprehensive R Archive Network (CRAN) at <a href="https://CRAN.R-project.org/package=colorspace" class="uri">https://CRAN.R-project.org/package=colorspace</a> and can be installed via

<code>install.packages("colorspace")</code>

The development version of <em>colorspace</em> is hosted on R-Forge at <a href="https://R-Forge.R-project.org/projects/colorspace/" class="uri">https://R-Forge.R-project.org/projects/colorspace/</a> in a Subversion (SVN) repository. 
It can be installed via

<code>install.packages("colorspace", repos = "http://R-Forge.R-project.org")</code>

For Python users a beta re-implementation of the full <em>colorspace</em> package in Python 2/Python 3 is also available, see <a href="https://github.com/retostauffer/python-colorspace" class="uri">https://github.com/retostauffer/python-colorspace</a>.

<h3>Choosing HCL-based color palettes</h3>
The <em>colorspace</em> package ships with a wide range of predefined color palettes, specified through suitable trajectories in the HCL (hue-chroma-luminance) color space. 
A quick overview can be gained easily with the <code>hcl_palettes()</code> function:

<code>library("colorspace")
hcl_palettes(plot = TRUE)</code>

A suitable vector of colors can be easily computed by specifying the desired number of colors and the palette name (see the plot above), e.g.,

<code>q4 &lt;- qualitative_hcl(4, palette = "Dark 3")
q4</code>

<code>## [1] "#E16A86" "#909800" "#00AD9A" "#9183E6"</code>

The functions <code>sequential_hcl()</code>, and <code>diverging_hcl()</code> work analogously. 
Additionally, their hue/chroma/luminance parameters can be modified, thus allowing for easy customization of each palette. 
Moreover, the <code>choose_palette()</code>/<code>hclwizard()</code> app provide convenient user interfaces to perform palette customization interactively. 
Finally, even more flexible diverging HCL palettes are provided by <code>divergingx_hcl()</code>.

<h3>Usage with base graphics</h3>
The color vectors returned by the HCL palette functions can usually be passed directly to most base graphics function, typically through the <code>col</code> argument. 
Here, the <code>q4</code> vector created above is used in a time series display:

<code>plot(log(EuStockMarkets), plot.type = "single", col = q4, lwd = 2)
legend("topleft", colnames(EuStockMarkets), col = q4, lwd = 3, bty = "n")</code>

As another example for a sequential palette, we demonstrate how to create a spine plot displaying the proportion of Titanic passengers that survived per class. 
The <code>Purples 3</code> palette is used, which is quite similar to the <k>ColorBrewer.org</k> palette <code>Purples</code>. 
Here, only two colors are employed, yielding a dark purple and light gray.

<code>ttnc &lt;- margin.table(Titanic, c(1, 4))[, 2:1]
spineplot(ttnc, col = sequential_hcl(2, palette = "Purples 3"))</code>

<h3>Usage with <em>ggplot2</em></h3>
To provide access to the HCL color palettes from within <em>ggplot2</em> graphics suitable discrete and/or continuous <em>gglot2</em> color scales are provided. 
The scales are named via the scheme <code>scale_&lt;aesthetic>_&lt;datatype>_&lt;colorscale>()</code>, where <code>&lt;aesthetic></code> is the name of the aesthetic (<code>fill</code>, <code>color</code>, <code>colour</code>), <code>&lt;datatype></code> is the type of the variable plotted (<code>discrete</code> or <code>continuous</code>) and <code>&lt;colorscale></code> sets the type of the color scale used (<code>qualitative</code>, <code>sequential</code>, <code>diverging</code>, <code>divergingx</code>).

To illustrate their usage two simple examples are shown using the qualitative <code>Dark 3</code> and sequential <code>Purples 3</code> palettes that were also employed above. 
For the first example, semi-transparent shaded densities of the sepal length from the iris data are shown, grouped by species.

<code>library("ggplot2")
ggplot(iris, aes(x = Sepal.Length, fill = Species)) + geom_density(alpha = 0.6) +
  scale_fill_discrete_qualitative(palette = "Dark 3")</code>

And for the second example the sequential palette is used to code the cut levels in a scatter of price by carat in the diamonds data (or rather a small subsample thereof). 
The scale function first generates six colors but then drops the first color because the light gray is too light here. 
(Alternatively, the chroma and luminance parameters could also be tweaked.)

<code>dsamp &lt;- diamonds[1 + 1:1000 * 50, ]
ggplot(dsamp, aes(carat, price, color = cut)) + geom_point() +
  scale_color_discrete_sequential(palette = "Purples 3", nmax = 6, order = 2:6)</code>

<h3>Palette visualization and assessment</h3>
The <em>colorspace</em> package also provides a number of functions that aid visualization and assessment of its palettes.

<code>demoplot()</code> can display a palette (with arbitrary number of colors) in a range of typical and somewhat simplified statistical graphics.

<code>hclplot()</code> converts the colors of a palette to the corresponding hue/chroma/luminance coordinates and displays them in HCL space with one dimension collapsed. 
The collapsed dimension is the luminance for qualitative palettes and the hue for sequential/diverging palettes.

<code>specplot()</code> also converts the colors to hue/chroma/luminance coordinates but draws the resulting spectrum in a line plot.

For the qualitative <code>Dark 3</code> palette from above the following plots can be obtained.

<code>demoplot(q4, "bar")
hclplot(q4)
specplot(q4, type = "o")</code>

The bar plot is used as a typical application for a qualitative palette (in addition to the time series and density plots used above). 
The other two displays show that luminance is (almost) constant in the palette while the hue changes linearly along the color “wheel”. 
Ideally, chroma would have also been constant to completely balance the colors. 
However, at this luminance the maximum chroma differs across hues so that the palette is fixed up to use less chroma for the yellow and green elements.

Note also that in a bar plot areas are shaded (and not just points or lines) so that lighter colors would be preferable. 
In the density plot above this was achieved through semi-transparency. 
Alternatively, luminance could be increased as is done in the <code>"Pastel 1"</code> or <code>"Set 3"</code> palettes.

Subsequently, the same types of assessment are carried out for the sequential <code>"Purples 3"</code> palette as employed above.

<code>s9 &lt;- sequential_hcl(9, "Purples 3")
demoplot(s9, "heatmap")
hclplot(s9)
specplot(s9, type = "o")</code>

Here, a heatmap (based on the well-known Maunga Whau volcano data) is used as a typical application for a sequential palette. 
The elevation of the volcano is brought out clearly, using dark colors to give emphasis to higher elevations.

The other two displays show that hue is constant in the palette while luminance and chroma vary. 
Luminance increases monotonically from dark to light (as required for a proper sequential palette). 
Chroma is triangular-shaped which allows to better distinguish the middle colors in the palette when compared to a monotonic chroma trajectory.

<h2>figure margins too large</h2>
Every time you are creating plots you might get this error - "Error in plot.new() : figure margins too large".
To avoid such errors you can first check par("mar") output. You should be getting:
[1] 3.1 3.1 3.1 0.6
change to:
par(mar=c(1,1,1,1))

<h2>displayable colors from four planes of Lab space</h2>
ab = expand.grid(a = (-10:15)*15, b = (-15:10)*15)
require(graphics); require(stats) # for na.omit
par(mfrow = c(2, 2), mar = .1+c(3, 3, 3, .5), mgp = c(2,  .8,  0))

Lab = cbind(L = 20, ab)
srgb = convertColor(Lab, from = "Lab", to = "sRGB", clip = NA)
clipped = attr(na.omit(srgb), "na.action")
srgb[clipped, ] = 0
cols = rgb(srgb[, 1], srgb[, 2], srgb[, 3])
image((-10:15)*15, (-15:10)*15, matrix(1:(26*26), ncol = 26), col = cols,
  xlab = "a", ylab = "b", main = "Lab: L=20")

Lab = cbind(L = 40, ab)
srgb = convertColor(Lab, from = "Lab", to = "sRGB", clip = NA)
clipped = attr(na.omit(srgb), "na.action")
srgb[clipped, ] = 0
cols = rgb(srgb[, 1], srgb[, 2], srgb[, 3])
image((-10:15)*15, (-15:10)*15, matrix(1:(26*26), ncol = 26), col = cols,
  xlab = "a", ylab = "b", main = "Lab: L=40")

Lab = cbind(L = 60, ab)
srgb = convertColor(Lab, from = "Lab", to = "sRGB", clip = NA)
clipped = attr(na.omit(srgb), "na.action")
srgb[clipped, ] = 0
cols = rgb(srgb[, 1], srgb[, 2], srgb[, 3])
image((-10:15)*15, (-15:10)*15, matrix(1:(26*26), ncol = 26), col = cols,
  xlab = "a", ylab = "b", main = "Lab: L=60")

Lab = cbind(L = 80, ab)
srgb = convertColor(Lab, from = "Lab", to = "sRGB", clip = NA)
clipped = attr(na.omit(srgb), "na.action")
srgb[clipped, ] = 0
cols = rgb(srgb[, 1], srgb[, 2], srgb[, 3])
image((-10:15)*15, (-15:10)*15, matrix(1:(26*26), ncol = 26), col = cols,
  xlab = "a", ylab = "b", main = "Lab: L=80")

cols = t(col2rgb(palette())); rownames(cols) = palette(); cols
zapsmall(lab = convertColor(cols, from = "sRGB", to = "Lab", scale.in = 255))
stopifnot(all.equal(cols, # converting back.. getting the original:
   round(convertColor(lab, from = "Lab", to = "sRGB", scale.out = 255)),
                    check.attributes = FALSE))

<h2>R语言用数学生成美丽的图案</h2>
https://cran.r-project.org/web/packages/pacman/pacman.pdf

p_load
Load One or More Packages

This function is a wrapper for library and require.
It checks to see if a package is installed, if not it attempts to install the package from CRAN and/or any other repository in the pacman repository list.
Usage
p_load(..., char, install = TRUE, update = getOption("pac_update"),
character.only = FALSE)

一、ggplot2
ggplot2是R语言强大的可视化包，基于图像语法和分层架构以实现各种高质量的图形。

# ggplot2包安装和加载
library(pacman)
p_load(ggplot2)

二、在一个圆上画散点图
圆是一种美

ggplot2对数据有强大的表示能力，对应着各式各样的图形，可以从简单的散点图到复杂的小提琴图。
以geom_开头的函数族定义了要把数据以一种什么几何体来绘制。

我们先从半径为1的圆上绘制50个点开始。
即每个点(x,y)都对应在单位圆上。

2、半径为1的圆上绘制50个点
# 半径为1的圆上50个点
t = seq(0, 2*pi, length.out = 50)x = sin(t)y = cos(t)df = class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqb4dgEPO7Y8Lumic2h3X95bibeYcE8N2ICox6l54pvFWhu4ed2Qtm090Vg/640">

三、螺旋式排列
黄金角的美

植物的叶子呈螺旋状排列。
螺旋线是一条曲线，它从原点开始，随着它绕其旋转而远离该点。
在上面的图中，我们所有的点到原点的距离都是相同的。
将它们螺旋排列的一种简单方法是在x和y乘以一个因子。
我们使用黄金角：

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqbS5e5f9ClQWQlLFzTDebw8NRmSqHibr80vZJNSeNoXLUPy6C8qicQ867w/640">


<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqbQ2vfrBLNLHOTTAbBRwEPJb0miaXOASkbyTpyyTlNZuUQnOQiaFTFtuxQ/640">

此数字的灵感来自黄金分割率，这是数学史上最著名的数字之一。
黄金分割率和黄金分割角都出现在自然界中意想不到的地方。
除了花瓣和植物叶子，您还会在种子头，松果，向日葵种子，贝壳，螺旋星系，飓风等中找到它们。

3、基于黄金角螺旋排列散点图
# 基于黄金角螺旋排列散点图
points = 500angle = pi * (3 - sqrt(5)) 
# 环境角计算公式
t = (1:points) * anglex = sin(t)y = cos(t)df = class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqbj5YibEGv2YRZKoKMzOFoD3pTeRDDJm9rxteDFvfODKt4s2zEE4eIPsw/640">

四、图像的修饰
精雕细琢

艺术的东西，总是一种恰到好处，不多不少。
使用ggplot2绘制的图形，除了把数据展示出一种美，也增加了一些其它组件，例如：
灰色的背景
水平和垂直的白线组成的网格线
轴的刻度
每个轴上都有一个标题
文本沿着轴方向做了标记
我们移除这些不必要的组件，同时对点的大小、颜色和透明做修饰和配置。

4、图像的修饰
# 图像的修饰
p = ggplot(df, aes(x*t, y*t))p + geom_point(size=8, alpha=0.5, color="darkgreen") +   theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "white")  )


<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqb7TFTPhUAEoaYjSua8M44rP1iamgvEjse1Z5G7PDSicIp45A9VgibJBMoA/640">

五、蒲公英
迎风而飘

直到现在，所有的点都有相同的外观(大小，颜色，形状和alpha)。
有时，我们希望使点的外观依赖于数据集中的一个变量。
现在我们将设置大小变量。
我们还将改变点的形状。
虽然我们不能吹它，但最终的图像应该会让你想起蒲公英。

5、生成蒲公英
# 生成蒲公英
p = ggplot(df, aes(x*t, y*t))p + geom_point(aes(size = t), alpha = 0.5, shape = 8, color = "black") +  theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"  )


<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqbuCcicFvfuGicyDkVia3sZCuwUic9lTbHquWa93g8owAIxDB7bsr8dnjMibQ/640">

六、向日葵
向阳而生

植物不仅使用黄金角来布置叶子。
在葵花籽的排列中也满足这个规律。
 我们稍加修改，就可以绘制出向日葵，真奇妙。

6、生成向日葵
# 生成向日葵
p = ggplot(df, aes(x*t, y*t))p + geom_point(aes(size = t), alpha = 0.5, shape = 17, color = "yellow") +  theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "darkmagenta"),
    legend.position = "none"  )


<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqbTxbxHATIG8SfTdibjY5cncgmmjG54fzoeImxBYaewGI2kDyOT2AfNnw/640">

七、角度变化
多姿多彩

通过角度的调整，可以生成多姿多彩的图案，感慨大自然的千变万化和奇妙无穷。
举一例如下。

7、角度变化后新图形
angle = 2.0points = 1000t = (1:points)*anglex = sin(t)y = cos(t)df = class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/pMPbyicMFiactibdfoUT7sXQsARXwtvoxqb8rjAdNDyGDiaciczFGHDpaNJnKbsq2WJH15jQibYcdJtsznBYRlaIo6Qg/640">

八、总结
充分发挥您的想象力

到目前为止，上面所展示的技术可以让我们根据自然的灵感创建无限数量的模式:唯一的限制是个人的想象力。
通过艺术的创造，美丽的欣赏，学习和使用ggplot2包，也是一件有趣的事情。

请发挥您的想象力，从各个方面做修改和创新，生成一幅幅美好的图案，以让人赏心悦目，其乐无穷。

附录：本文完整代码

# ggplot2包安装和加载
library(pacman)p_load(ggplot2)

# 半径为1的圆上50个点
t = seq(0, 2*pi, length.out = 50)x = sin(t)y = cos(t)df = data.frame(t, x, y)p = ggplot(df, aes(x, y))p + geom_point()

# 基于黄金角螺旋排列散点图
points = 500angle = pi * (3 - sqrt(5)) 

# 环境角计算公式
t = (1:points) * anglex = sin(t)y = cos(t)df = data.frame(t, x, y)p = ggplot(df, aes(x*t, y*t))p + geom_point()

# 图像的修饰
p = ggplot(df, aes(x*t, y*t))p + geom_point(size=8, alpha=0.5, color="darkgreen") +   theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "white")  )

# 生成蒲公英
p = ggplot(df, aes(x*t, y*t))p + geom_point(aes(size = t), alpha = 0.5, shape = 8, color = "black") +  theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "white"),
    legend.position = "none"  )

# 生成向日葵
p = ggplot(df, aes(x*t, y*t))p + geom_point(aes(size = t), alpha = 0.5, shape = 17, color = "yellow") +  theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "darkmagenta"),
    legend.position = "none"  )angle = 2.0points = 1000t = (1:points)*anglex = sin(t)y = cos(t)df = data.frame(t, x, y)p = ggplot(df, aes(x*t, y*t))p + geom_point(aes(size = t), alpha = 0.5, shape = 17, color = "yellow") +  theme(    panel.grid = element_blank(),
    axis.ticks = element_blank(),
    title = element_blank(),
    text = element_blank(),
    panel.background = element_rect(fill = "darkmagenta"),
    legend.position = "none"  )

参考资料
1、ggplot2包学习和使用
https://ggplot2.tidyverse.org/reference/
2、黄金角
https://en.wikipedia.org/wiki/Golden_angle

<h2>call python script from R with arguments</h2>
system('python scriptname')

To run the script asynchronously you can set the wait flag to false.

system('python test.py hello world', wait=FALSE)
https://stackoverflow.com/questions/41638558/how-to-call-python-script-from-r-with-arguments

<h2>plot with red tails</h2>
x = rnorm(1000)
hx = hist(x, breaks=10, plot=FALSE)
plot(hx, col=ifelse(abs(hx$breaks) < 1.669, 4, 2))

<h2>to remove empty list items</h2>
emptyItems = numeric()
for(i in 1:length(alist)){
  if( length(alist[[i]]) == 0){
    emptyItems = c(emptyItems, i)
  }
}
alist = alist[-emptyItems]

to append list item:
alist = append("asdf", alist)

<h2>to reverse a matrix</h2>
b <- apply(a, 2, rev)

<h2>data.table cbind two tables</h2>
c = 1:6
d = seq(-2,18,by=4)
(dt = data.table(c,d))

e = 12:17
f = seq(22,50,by=5)
g = data.table(e,f)

# using base R
(dt = cbind(dt,g))

<h2>Multivariate Analysis</h2>
<a href="http://www.sthda.com/english/articles/32-r-graphics-essentials/130-plot-multivariate-continuous-data/" class="whitebut ">Plot Multivariate Continuous Data</a>
<a href="https://little-book-of-r-for-multivariate-analysis.readthedocs.io/en/latest/src/multivariateanalysis.html" class="whitebut ">Multivariate Analysis</a>

# use 2D Scatter plot
# ggplot Change colors by groups
library(ggplot2)
ggplot(mtcars, aes(x=wt, y=mpg, color=cyl+1)) + geom_point()
ggplot(iris[,1:3], aes(iris[,1], iris[,2], color=iris[,3])) + geom_point()

# use 3D scatterplot3d
library(scatterplot3d)
scatterplot3d(
  iris[,1:3], pch = 19, color = "steelblue",
   grid = TRUE, box = FALSE,
   mar = c(3, 3, 0.5, 3)        
  )

<h2>count occurences in list</h2>
srcList = c("a","c")

FLSZList = c("a","b","c")
FLSZ5List = c("a","e","f", "a")
X3List = c("k","e","g", "a")

totalList = list(FLSZList, FLSZ5List, X3List)

# for(i in srcList){
#   cat("element ",i, "\n")
#   totalCount = 0
#   for(j in 1:length(totalList)){
#       cat(totalList[[j]],": ")
#       if(length(grep(i, totalList[[j]]))>0){
#         totalCount = totalCount + 1
#       }
#       cat("after ",totalCount, " ")
#   }
#   cat(totalCount, "\n")
# }

  for(item in srcList){
    totalCount = 0
    for(j in 1:length(totalList)){
        if(length(grep(item, totalList[[j]]))>0){
          totalCount = totalCount + 1
        }
    }
    if(totalCount>1) cat(item, " ")
  }

<h2>svgViewR Plotting 3D points</h2>
<a href="https://aaronolsen.github.io/tutorials/3d_visualization/plot_points.html" class="whitebut ">3D points</a>

<h2>Rstudio Keyboard Shortcuts</h2>
<h3>Console</h3>
Move cursor to Console
Ctrl+2

Clear console
Ctrl+L

Move cursor to beginning of line
Home

Move cursor to end of line
End

Navigate command history
Up/Down

Popup command history
Ctrl+Up

Interrupt currently executing command
Esc

Change working directory
Ctrl+Shift+H

<h3>Source</h3>
Go to File/Function
Ctrl+. [period]

Move cursor to Source Editor
Ctrl+1

Toggle document outline
Ctrl+Shift+O

Toggle Visual Editor
Ctrl+Shift+F4

New document (except on Chrome/Windows)
Ctrl+Shift+N

New document (Chrome only)
Ctrl+Alt+Shift+N

Open document
Ctrl+O

Save active document
Ctrl+S

Save all documents
Ctrl+Alt+S

Close active document (except on Chrome)
Ctrl+W

Close active document (Chrome only)
Ctrl+Alt+W

Close all open documents
Ctrl+Shift+W

Close other documents
Ctrl+Shift+Alt+W

Preview HTML (Markdown and HTML)
Ctrl+Shift+K

Knit Document (knitr)
Ctrl+Shift+K

Compile Notebook
Ctrl+Shift+K

Compile PDF (TeX and Sweave)
Ctrl+Shift+K

Insert chunk (Sweave and Knitr)
Ctrl+Alt+I

Insert code section
Ctrl+Shift+R

Run current line/selection
Ctrl+Enter

Run current line/selection (retain cursor position)
Alt+Enter

Re-run previous region
Ctrl+Alt+P

Run current document
Ctrl+Alt+R

Run from document beginning to current line
Ctrl+Alt+B

Run from current line to document end
Ctrl+Alt+E

Run the current function definition
Ctrl+Alt+F

Run the current code section
Ctrl+Alt+T

Run previous Sweave/Rmd code
Ctrl+Shift+Alt+P

Run the current Sweave/Rmd chunk
Ctrl+Alt+C

Run the next Sweave/Rmd chunk
Ctrl+Alt+N

Source a file
Ctrl+Alt+G

Source the current document
Ctrl+Shift+S

Source the current document (with echo)
Ctrl+Shift+Enter

Send current line/selection to terminal
Ctrl+Alt+Enter

Fold Selected
Alt+L

Unfold Selected
Shift+Alt+L

Fold All
Alt+O

Unfold All
Shift+Alt+O

Go to line
Shift+Alt+G

Jump to
Shift+Alt+J

Expand selection
Ctrl+Shift+Up

Shrink selection
Ctrl+Shift+Down

Next section
Ctrl+PgDn

Previous section
Ctrl+PgUp

Split into lines
Ctrl+Alt+A

Edit lines from start
Ctrl+Alt+Shift+A

Switch to tab
Ctrl+Shift+. [period]

Previous tab
Ctrl+F11

Previous tab (desktop)
Ctrl+Shift+Tab

Next tab
Ctrl+F12

Next tab (desktop)
Ctrl+Tab

First tab
Ctrl+Shift+F11

Last tab
Ctrl+Shift+F12

Navigate back
Ctrl+F9

Navigate forward
Ctrl+F10

Extract function from selection
Ctrl+Alt+X

Extract variable from selection
Ctrl+Alt+V

Reindent lines
Ctrl+I

Comment/uncomment current line/selection
Ctrl+Shift+C

Reflow Comment
Ctrl+Shift+/

Reformat Selection
Ctrl+Shift+A

Show Diagnostics
Ctrl+Shift+Alt+D

Transpose Letters
&nbsp;No shortcut

Move Lines Up/Down
Alt+Up/Down

Copy Lines Up/Down
Shift+Alt+Up/Down

Jump to Matching Brace/Paren
Ctrl+P

Expand to Matching Brace/Paren
Ctrl+Shift+Alt+E

Add Cursor Above Current Cursor
Ctrl+Alt+Up

Add Cursor Below Current Cursor
Ctrl+Alt+Down

Move Active Cursor Up
Ctrl+Alt+Shift+Up

Move Active Cursor Down
Ctrl+Alt+Shift+Down

Find and Replace
Ctrl+F

Find Next
Win: F3, Linux: Ctrl+G

Find Previous
Win: Shift+F3, Linux: Ctrl+Shift+G

Use Selection for Find
Ctrl+F3

Replace and Find
Ctrl+Shift+J

Find in Files
Ctrl+Shift+F

Check Spelling
F7

Rename Symbol in Scope
Ctrl+Alt+Shift+M

Insert Roxygen Skeleton
Ctrl+Alt+Shift+R

<h3>Editing (Console and Source)</h3>
Undo
Ctrl+Z

Redo
Ctrl+Shift+Z

Cut
Ctrl+X

Copy
Ctrl+C

Paste
Ctrl+V

Select All
Ctrl+A

Jump to Word
Ctrl+Left/Right

Jump to Start/End
Ctrl+Home/End or Ctrl+Up/Down

Delete Line
Ctrl+D

Select
Shift+[Arrow]

Select Word
Ctrl+Shift+Left/Right

Select to Line Start
Alt+Shift+Left

Select to Line End
Alt+Shift+Right

Select Page Up/Down
Shift+PageUp/PageDown

Select to Start/End
Ctrl+Shift+Home/End or Shift+Alt+Up/Down

Delete Word Left
Ctrl+Backspace

Delete Word Right
No shortcut

Delete to Line End
No shortcut

Delete to Line Start
No shortcut
Indent
Tab (at beginning of line)

Outdent
Shift+Tab

Yank line up to cursor
Ctrl+U

Yank line after cursor
Ctrl+K

Insert currently yanked text
Ctrl+Y

Insert assignment operator
Alt+-

Insert pipe operator
Ctrl+Shift+M

Show help for function at cursor
F1

Show source code for function at cursor
F2

Find usages for symbol at cursor (C++)
Ctrl+Alt+U

<h3>Completions (Console and Source)</h3>
Attempt completion
Tab or Ctrl+Space

Navigate candidates
Up/Down

Accept selected candidate
Enter, Tab, or Right

Dismiss completion popup
Esc

<h3>Views</h3>
Move focus to Source Editor
Ctrl+1

Zoom Source Editor
Ctrl+Shift+1

Add Source Column
Ctrl+F7

Move focus to Console
Ctrl+2

Zoom Console
Ctrl+Shift+2

Move focus to Help
Ctrl+3

Zoom Help
Ctrl+Shift+3

Move focus to Terminal
Alt+Shift+M

Show History
Ctrl+4

Zoom History
Ctrl+Shift+4

Show Files
Ctrl+5

Zoom Files
Ctrl+Shift+5

Show Plots
Ctrl+6

Zoom Plots
Ctrl+Shift+6

Show Packages
Ctrl+7

Zoom Packages
Ctrl+Shift+7

Show Environment
Ctrl+8

Zoom Environment
Ctrl+Shift+8

Show Viewer
Ctrl+9

Zoom Viewer
Ctrl+Shift+9

Show Git/SVN
Ctrl+F1

Zoom Git/SVN
Ctrl+Shift+F1

Show Build
Ctrl+F2

Zoom Build
Ctrl+Shift+F2

Show Connections
Ctrl+F5

Zoom Connections
Ctrl+Shift+F5

Show Find in Files Results
Ctrl+F6

Zoom Tutorial
Ctrl+Shift+F6

Sync Editor & PDF Preview
Ctrl+F8

Global Options
No shortcut

Project Options
No shortcut

<h3>Help</h3>
Show Keyboard Shortcut Reference
Alt+Shift+K

Search R Help
Ctrl+Alt+F1

Find in Help Topic
Ctrl+F

Previous Help Topic
Shift+Alt+F2

Next Help Topic
Shift+Alt+F3

Show Command Palette
Ctrl+Shift+P, Ctrl+Alt+Shift+P (Firefox)

<h3>Build</h3>
Build and Reload
Ctrl+Shift+B

Load All (devtools)
Ctrl+Shift+L

Test Package (Desktop)
Ctrl+Shift+T

Test Package (Web)
Ctrl+Alt+F7

Check Package
Ctrl+Shift+E

Document Package
Ctrl+Shift+D

<h3>Debug</h3>
Toggle Breakpoint
Shift+F9

Execute Next Line
F10

Step Into Function
Shift+F4

Finish Function/Loop
Shift+F7

Continue
Shift+F5

Stop Debugging
Shift+F8

<h3>Plots</h3>
Previous plot
Ctrl+Alt+F11

Next plot
Ctrl+Alt+F12

<h3>Git/SVN</h3>
Diff active source document
Ctrl+Alt+D

Commit changes
Ctrl+Alt+M

Scroll diff view
Ctrl+Up/Down

Stage/Unstage (Git)
Spacebar

Stage/Unstage and move to next (Git)
Enter

<h3>Session</h3>
Quit Session (desktop only)
Ctrl+Q

Restart R Session
Ctrl+Shift+F10

<h3>Terminal</h3>
New Terminal
Alt+Shift+R

Move Focus to Terminal
Alt+Shift+M

Previous Terminal
Alt+Shift+F11

Next Terminal
Alt+Shift+F12

<h3>Main Menu (Server)</h3>
File Menu
Alt+Shift+F

Edit Menu
Alt+Shift+E

Code Menu
Alt+Shift+C

View Menu
Alt+Shift+V

Plots Menu
Alt+Shift+P

Session Menu
Alt+Shift+S

Build Menu
Alt+Shift+B

Debug Menu
Alt+Shift+U

Profile Menu
Alt+Shift+I

Tools Menu
Alt+Shift+T

Help Menu
Alt+Shift+H

<h3>Accessibility</h3>
Toggle Screen Reader Support
Alt+Shift+/

Toggle Tab Key Always Moves Focus
Ctrl+Alt+Shift+T

Speak Text Editor Location
Ctrl+Alt+Shift+B

Focus Main Toolbar
Alt+Shift+Y

Focus Console Output
Alt+Shift+2

Focus Next Pane
F6

Focus Previous Pane
Shift+F6

<h2>opencv Face recognition</h2>
<a href="https://cran.r-project.org/web/packages/opencv/opencv.pdf" class="whitebut ">opencv.pdf</a>
install.packages("opencv")

Basic stuff:

Face recognition:

unconf <- ocv_read('https://jeroen.github.io/images/unconf18.jpg')
faces <- ocv_face(unconf)
ocv_write(faces, 'faces.jpg')

Or get the face location data:

facemask <- ocv_facemask(unconf)
attr(facemask, 'faces')

Live Webcam Examples

Live face detection:

library(opencv)
ocv_video(ocv_face)

Edge detection:

library(opencv)
ocv_video(ocv_edges)

Combine with Graphics
Replaces the background with a plot:

library(opencv)
library(ggplot2)

# get webcam size
test <- ocv_picture()
bitmap <- ocv_bitmap(test)
width <- dim(bitmap)[2]
height <- dim(bitmap)[3]

png('bg.png', width = width, height = height)
par(ask=FALSE)
print(ggplot2::qplot(speed, dist, data = cars, geom = c("smooth", "point")))
dev.off()
bg <- ocv_read('bg.png')
unlink('pg.png')
ocv_video(function(input){
  mask <- ocv_mog2(input)
  return(ocv_copyto(input, bg, mask))
})

Put your face in the plot:

# Overlay face filter
ocv_video(function(input){
  mask <- ocv_facemask(input)
  ocv_copyto(input, bg, mask)
})

Live Face Survey
Go stand on the left if you're a tidier

library(opencv)

# get webcam size
test <- ocv_picture()
bitmap <- ocv_bitmap(test)
width <- dim(bitmap)[2]
height <- dim(bitmap)[3]

# generates the plot
makeplot <- function(x){
  png('bg.png', width = width, height = height, res = 96)
  on.exit(unlink('bg.png'))
  groups <- seq(0, width, length.out = 4)
  left <- rep("left", sum(x < groups[2]))
  middle <- rep("middle", sum(x >= groups[2] & x < groups[3]))
  right <- rep("right", sum(x >= groups[3]))
  f <- factor(c(left, middle, right), levels = c('left', 'middle', 'right'),
              labels = c("Tidy!", "Whatever Works", "Base!"))
  color = I(c("#F1BB7B", "#FD6467", "#5B1A18"))
  plot(f, ylim = c(0, 5),
       main = "Are you a tidyer or baser?", col = color)
  dev.off()
  ocv_read('bg.png')
}

# overlays faces on the plot
ocv_video(function(input){
  mask <- ocv_facemask(input)
  faces <- attr(mask, 'faces')
  bg <- makeplot(faces$x)
  return(ocv_copyto(input, bg, mask))
})

<h2>magick package: Advanced Image-Processing</h2>
<a href="magick.html" class="redbut gold goldbs whitets">magick</a>
<a href="https://cran.r-project.org/web/packages/magick/vignettes/intro.html" class="whitebut ">The magick package: Advanced Image-Processing in R</a>

<h2>googleLanguageR speech-to-text voice recognition</h2>
includes speech-to-text via the Google Cloud Speech API
<a href="https://cran.r-project.org/web/packages/googleLanguageR/googleLanguageR.pdf" class="whitebut ">googleLanguageR.pdf</a>

<h2>R set timeout</h2>
R timeout: Set maximum request time.
getOption("timeout")
timeout(seconds) # number of seconds to wait for a response until giving up. Can not be less than 1 ms.

<h2>file.path</h2>
file.path("f:", "git", "surveyor")
# "f:/git/surveyor"

setwd(file.path("F:", "git", "roxygen2"))

getwd()
# "F:/git/roxygen2"

<h2>Extract images from pdf</h2>
shell(shQuote("D:/XpdfReader-win64/xpdf-tools-win-4.03/bin64/pdfimages a.pdf -j"))

<h2>expand.grid</h2>
expand.grid(c(0,1), c(0,1), c(0,1))
expand.grid(c(0,1), c(0,1,2))


<h2>handling chinese characters</h2>
remember to load file with utf-8 encoding
historyList = readLines("D:/Dropbox/Public/LibDocs/ChineseMed/醫案.html", encoding="UTF-8")

filter and replace as usual
historyList = gsub("　"," ",historyList)

remember to set encoding when writing file
options("encoding" = "UTF-8")
setwd("C:/Users/User/Desktop")
sink("test.html")
cat(historyList,sep="\n")
sink()

<h2>grep chinese characters</h2>
v=c("a","b","c","中","e","文")
grep("[\\p{Han}]",v, value = TRUE)  # to grep chinese, this not work
grep("[\\p{Han}]", v, value = T, perl = T)  # this works
grep("文", v, value = T, perl = T)  # this works



<h2>retrieving own ip address</h2>
issue a system() ipconfig command to operating system:

x <- system("ipconfig", intern=TRUE)

to extract just the ip address:
z <- x[grep("IPv4", x)]
gsub(".*? ([[:digit:]])", "\\1", z)

<h2>retrieving mac address</h2>
mac_addr <- system("getmac", intern = TRUE)

in dos: getmac /V | findstr /V disconnected

<h2>pre loaded data</h2>
LibPath: "D:/R-3.4.3/library"
1	"AirPassengers
	"Monthly Airline Passenger Numbers 1949-1960"                    

2	"BJsales
	"Sales Data with Leading Indicator"                              

3	"BJsales.lead (BJsales)
	"Sales Data with Leading Indicator"                              

4	"BOD
	"Biochemical Oxygen Demand"                                      

5	"CO2
	"Carbon Dioxide Uptake in Grass Plants"                          

6	"ChickWeight
	"Weight versus age of chicks on different diets"                 

7	"DNase
	"Elisa assay of DNase"                                           

8	"EuStockMarkets
	"Daily Closing Prices of Major European Stock Indices, 1991-1998"

9	"Formaldehyde
	"Determination of Formaldehyde"                                  

10	"HairEyeColor
	"Hair and Eye Color of Statistics Students"                      

11	"Harman23.cor
	"Harman Example 2.3"                                             

12	"Harman74.cor
	"Harman Example 7.4"                                             

13	"Indometh
	"Pharmacokinetics of Indomethacin"                               

14	"InsectSprays
	"Effectiveness of Insect Sprays"                                 

15	"JohnsonJohnson
	"Quarterly Earnings per Johnson & Johnson Share"                 

16	"LakeHuron
	"Level of Lake Huron 1875-1972"                                  

17	"LifeCycleSavings
	"Intercountry Life-Cycle Savings Data"                           

18	"Loblolly
	"Growth of Loblolly pine trees"                                  

19	"Nile
	"Flow of the River Nile"                                         

20	"Orange
	"Growth of Orange Trees"                                         

21	"OrchardSprays
	"Potency of Orchard Sprays"                                      

22	"PlantGrowth
	"Results from an Experiment on Plant Growth"                     

23	"Puromycin
	"Reaction Velocity of an Enzymatic Reaction"                     

24	"Seatbelts
	"Road Casualties in Great Britain 1969-84"                       

25	"Theoph
	"Pharmacokinetics of Theophylline"                               

26	"Titanic
	"Survival of passengers on the Titanic"                          

27	"ToothGrowth
	"The Effect of Vitamin C on Tooth Growth in Guinea Pigs"         

28	"UCBAdmissions
	"Student Admissions at UC Berkeley"                              

29	"UKDriverDeaths
	"Road Casualties in Great Britain 1969-84"                       

30	"UKgas
	"UK Quarterly Gas Consumption"                                   

31	"USAccDeaths
	"Accidental Deaths in the US 1973-1978"                          

32	"USArrests
	"Violent Crime Rates by US State"                                

33	"USJudgeRatings
	"Lawyers' Ratings of State Judges in the US Superior Court"      

34	"USPersonalExpenditure
	"Personal Expenditure Data"                                      

35	"UScitiesD
	"Distances Between European Cities and Between US Cities"        

36	"VADeaths
	"Death Rates in Virginia (1940)"                                 

37	"WWWusage
	"Internet Usage per Minute"                                      

38	"WorldPhones
	"The World's Telephones"                                         

39	"ability.cov
	"Ability and Intelligence Tests"                                 

40	"airmiles
	"Passenger Miles on Commercial US Airlines, 1937-1960"           

41	"airquality
	"New York Air Quality Measurements"                              

42	"anscombe
	"Anscombe's Quartet of 'Identical' Simple Linear Regressions"    

43	"attenu
	"The Joyner-Boore Attenuation Data"                              

44	"attitude
	"The Chatterjee-Price Attitude Data"                             

45	"austres
	"Quarterly Time Series of the Number of Australian Residents"    

46	"beaver1 (beavers)
	"Body Temperature Series of Two Beavers"                         

47	"beaver2 (beavers)
	"Body Temperature Series of Two Beavers"                         

48	"cars
	"Speed and Stopping Distances of Cars"                           

49	"chickwts
	"Chicken Weights by Feed Type"                                   

50	"co2
	"Mauna Loa Atmospheric CO2 Concentration"                        

51	"crimtab
	"Student's 3000 Criminals Data"                                  

52	"discoveries
	"Yearly Numbers of Important Discoveries"                        

53	"esoph
	"Smoking, Alcohol and (O)esophageal Cancer"                      

54	"euro
	"Conversion Rates of Euro Currencies"                            

55	"euro.cross (euro)
	"Conversion Rates of Euro Currencies"                            

56	"eurodist
	"Distances Between European Cities and Between US Cities"        

57	"faithful
	"Old Faithful Geyser Data"                                       

58	"fdeaths (UKLungDeaths)" [58"Monthly Deaths from Lung Diseases in the UK"                    

59	"freeny
	"Freeny's Revenue Data"                                          

60	"freeny.x (freeny)
	"Freeny's Revenue Data"                                          

61	"freeny.y (freeny)
	"Freeny's Revenue Data"                                          

62	"infert
	"Infertility after Spontaneous and Induced Abortion"             

63	"iris
	"Edgar Anderson's Iris Data"                                     

64	"iris3
	"Edgar Anderson's Iris Data"                                     

65	"islands
	"Areas of the World's Major Landmasses"                          

66	"ldeaths (UKLungDeaths)" [66"Monthly Deaths from Lung Diseases in the UK"                    

67	"lh
	"Luteinizing Hormone in Blood Samples"                           

68	"longley
	"Longley's Economic Regression Data"                             

69	"lynx
	"Annual Canadian Lynx trappings 1821-1934"                       

70	"mdeaths (UKLungDeaths)" [70"Monthly Deaths from Lung Diseases in the UK"                    

71	"morley
	"Michelson Speed of Light Data"                                  

72	"mtcars
	"Motor Trend Car Road Tests"                                     

73	"nhtemp
	"Average Yearly Temperatures in New Haven"                       

74	"nottem
	"Average Monthly Temperatures at Nottingham, 1920-1939"          

75	"npk
	"Classical N, P, K Factorial Experiment"                         

76	"occupationalStatus
	"Occupational Status of Fathers and their Sons"                  

77	"precip
	"Annual Precipitation in US Cities"                              

78	"presidents
	"Quarterly Approval Ratings of US Presidents"                    

79	"pressure
	"Vapor Pressure of Mercury as a Function of Temperature"         

80	"quakes
	"Locations of Earthquakes off Fiji"                              

81	"randu
	"Random Numbers from Congruential Generator RANDU"               

82	"rivers
	"Lengths of Major North American Rivers"                         

83	"rock
	"Measurements on Petroleum Rock Samples"                         

84	"sleep
	"Student's Sleep Data"                                           

85	"stack.loss (stackloss)" [85"Brownlee's Stack Loss Plant Data"                               

86	"stack.x (stackloss)
	"Brownlee's Stack Loss Plant Data"                               

87	"stackloss
	"Brownlee's Stack Loss Plant Data"                               

88	"state.abb (state)
	"US State Facts and Figures"                                     

89	"state.area (state)
	"US State Facts and Figures"                                     

90	"state.center (state)
	"US State Facts and Figures"                                     

91	"state.division (state)" [91"US State Facts and Figures"                                     

92	"state.name (state)
	"US State Facts and Figures"                                     

93	"state.region (state)
	"US State Facts and Figures"                                     

94	"state.x77 (state)
	"US State Facts and Figures"                                     

95	"sunspot.month
	"Monthly Sunspot Data, from 1749 to \"Present\""                 

96	"sunspot.year
	"Yearly Sunspot Data, 1700-1988"                                 

97	"sunspots
	"Monthly Sunspot Numbers, 1749-1983"                             

98	"swiss
	"Swiss Fertility and Socioeconomic Indicators (1888) Data"       

99	"treering
	"Yearly Treering Data, -6000-1979"                               

100	"trees
	"Girth, Height and Volume for Black Cherry Trees"                

101	"uspop
	"Populations Recorded by the US Census"                          

102	"volcano
	"Topographic Information on Auckland's Maunga Whau Volcano"      

103	"warpbreaks
	"The Number of Breaks in Yarn during Weaving"                    

104	"women
	"Average Heights and Weights for American Women"                 


<h2>Check value in column is less than the median of that column</h2>

df <- data.frame(a = c(1:10), b = rnorm(10), c = rnorm(10))
sapply(df, function(x){ x >= median(x) })


<h2>Creating dummies for categorical variables</h2>
In situations where we have categorical variables (factors) but need to use them in analytical methods that require numbers (for example, <span class="orange">K nearest neighbors (KNN), Linear Regression</span>), we need to create dummy variables.

A <code>dummy variable</code> is a numeric interpretation of the category or level of the factor variable.
That is, it represents every group or level of the categorical variable as a single numeric entity.

Read the <code>data-conversion.csv</code> file and store it in the working directory of your R environment. Install the <code>dummies</code> package. Then read the data:
<code>
install.packages("dummies")
library(dummies)
students &lt;- read.csv("data-conversion.csv")</code>

Create dummies for all factors in the data frame:
<code>students.new &lt;- dummy.data.frame(students, sep = ".")
names(students.new)

[1] "Age"      "State.NJ" "State.NY" "State.TX" "State.VA"
[6] "Gender.F" "Gender.M" "Height"   "Income"</code>
The <code>students.new</code> data frame now contains all the original variables and the newly added dummy variables. The <code>dummy.data.frame()</code> function has created dummy variables for all four levels of the <code>State</code> and two levels of <code>Gender</code> factors. However, we will generally omit one of the dummy variables for <code>State</code> and one for <code>Gender</code> when we use machine-learning techniques.
We can use the optional argument <code>all = FALSE</code> to specify that the resulting data frame should contain only the generated dummy variables and none of the original variables.

<h3>How it works...</h3>
The <code>dummy.data.frame()</code> function creates dummies for all the factors in the data frame supplied. Internally, it uses another <code>dummy()</code> function which creates dummy variables for a single factor. The <code>dummy()</code> function creates one new variable for every level of the factor for which we are creating dummies. It appends the variable name with the factor level name to generate names for the dummy variables. We can use the <code>sep</code> argument to specify the character that separates them—an empty string is the default:

<code>dummy(students$State, sep = ".")

      State.NJ State.NY State.TX State.VA
 [1,]        1        0        0        0
 [2,]        0        1        0        0
 [3,]        1        0        0        0
 [4,]        0        0        0        1
 [5,]        0        1        0        0
 [6,]        0        0        1        0
 [7,]        1        0        0        0
 [8,]        0        0        0        1
 [9,]        0        0        1        0
[10,]        0        0        0        1</code>

<h3>There's more...</h3>
In situations where a data frame has several factors, and you plan on using only a subset of these, you will create dummies only for the chosen subset.
<h4>Choosing which variables to create dummies for</h4>
To create dummies only for one variable or a subset of variables, we can use the <code>names</code> argument to specify the column names of the variables we want dummies for:

<code>students.new1 &lt;- dummy.data.frame(students, names = c("State","Gender") , sep = ".")</code>

<h2>How to Create dummy variables in R</h2>
<h3>Why do we need dummy variables in R?</h3>
Let us first understand the concept of dummy variables. 
Consider a dataset that represents some categorical data values.

Handling such a huge number of categories and groups is a cumbersome task for the <a href="https://www.journaldev.com/48036/machine-learning-in-r-introduction">machine learning model</a>. 
Thus arises the need to treat categorical or level entries.

This is when the concept of dummy entries comes into picture.

A <code>dummy variable</code> is a numeric interpretation of the category or level of the factor variable. 
That is, it represents every group or level of the categorical variable as a single numeric entity.

For example, consider a data set that contains a variable &#8216;Poll' with values &#8216;Yes' and &#8216;No'. 
Now, in order to represent the two groups as numeric entries, we can create dummies of the same.

So, the transformed dataset would now have two more additional columns as &#8216;Poll.1' which would represent &#8216;yes' type values (would assign 1 to all the data rows that are associated with level yes) and &#8216;Poll.2' for &#8216;No' type values.

<h3>R fast.dummies library to create dummy variables</h3>
R provides us with <b>fast.dummies</b> library that contains of dummy_cols() function for the creation of dummy variables at ease.

With <code>dummy_cols()</code> function, one can select the variables for whom the dummies need to be created.

<b>Syntax:</b>

dummy_cols(data, select_columns = 'columns')</code>

<b>Example:</b>

In this example, we have made use of the Bank Load Defaulter dataset. 
You can find the dataset <a href="https://github.com/Safa1615/Dataset--loan/blob/main/bank-loan.csv">here</a>.

Further, we have made use of dummy_cols() function to create dummy variables for the column &#8216;ed'.

rm(list = ls())
 
#install.packages('fastDummies')
library('fastDummies')
dta = read.csv("bank-loan.csv",header=TRUE)
dim(dta)
dum &lt;- dummy_cols(dta, select_columns = 'ed')
dim(dum)

</code>

<b>Output:</b>

As witnessed below, the initial number of columns of the data set equals to 9. 
Post creation of dummy variables, the number of columns equals to 14.

All the 5 levels of the ed variable has been segregated as a separate column. 
Only those rows which belongs to a certain category are set as 1, rest all values are set to zero(0).

> dim(dta)
&#91;1] 850   9

> dim(dum)
&#91;1] 850  14
</code>


<img class="lazy" data-src="https://cdn.journaldev.com/wp-content/uploads/2021/02/Creation-of-dummies-using-fastDummies-library.png">

What if we need to create dummies for multiple variables in a single shot or at once?

Well, we can then create a list of all the variables for which we need dummies using <a href="https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/c" target="_blank" rel="noreferrer noopener">c() function</a> and pass them as arguments through select_columns.

<b>Example:</b>

rm(list = ls())
 
#install.packages('fastDummies')
library('fastDummies')
dta = read.csv("bank-loan.csv",header=TRUE)
dim(dta)
dum &lt;- dummy_cols(dta, select_columns = c('ed','default'))
dim(dum)

</code>

<b>Output:</b>

Here, we have created dummies for both &#8216;ed' and &#8216;default' data columns.

> dim(dta)
&#91;1] 850   9
> dum &lt;- dummy_cols(dta, select_columns = c('ed','default'))
> dim(dum)
&#91;1] 850  17
</code>


<img class="lazy" data-src="https://cdn.journaldev.com/wp-content/uploads/2021/02/Creation-of-dummies-for-multiple-columns.png">

<h3>R dummies library to create dummy variables</h3>
R <b>dummies </b>library can also be used to create dummy data variables for the categorical data columns at ease.

For the same, we can make use of <code>dummy()</code> function that enables us to create dummy entries for selected columns.

<b>Example:</b>

In the below example, we have created dummy variables of the column &#8216;ed' using dummy() function.

rm(list = ls())

library('dummies')
dta = read.csv("bank-loan.csv",header=TRUE)
dim(dta)
dum &lt;- dummy(dta$ed)
dim(dum)

</code>

<b>Output:</b>

As seen below, all the levels have been segregated as a different column.

Also, only those data rows that match to the particular level is set to 1 in the column else it is represented as zero.

For example, if the data represents the level &#8216;ed1', then it is set to 1 else it is set to 0.

<img class="lazy" data-src="https://cdn.journaldev.com/wp-content/uploads/2021/02/Creation-of-dummies-using-dummies-library.png">

<h2>Build your own neural network classifier</h2>
<h3>​Introduction</h3>
Image classification is one important field in Computer Vision, not only because so many applications are associated with it, but also a lot of Computer Vision problems can be effectively reduced to image classification. 
The state of art tool in image classification is Convolutional Neural Network (CNN). 
In this article, I am going to write a simple Neural Network with 2 layers (fully connected). 
I will first train it to classify a set of 4-class 2D data and visualize the decision boundary. 
Second, I am going to train my NN with the famous MNIST data (you can download it here: <a href="https://www.kaggle.com/c/digit-recognizer/download/train.csv" rel="noopener nofollow">https://www.kaggle.com/c/digit-recognizer/download/train.csv</a>) and see its performance. 
The first part is inspired by CS 231n course offered by Stanford: <a href="http://cs231n.github.io/" rel="noopener nofollow">http://cs231n.github.io/</a>, which is taught in Python.

<h3>​Data set generation</h3>
First, let’s create a spiral dataset with 4 classes and 200 examples each.

library(ggplot2)
library(caret)
 
N <- 200 # number of points per class
D <- 2 # dimensionality
K <- 4 # number of classes
X <- data.frame() # data matrix (each row = single example)
y <- data.frame() # class labels
 
set.seed(308)
 
for (j in (1:K)){
  r <- seq(0.05,1,length.out = N) # radius
  t <- seq((j-1)*4.7,j*4.7, length.out = N) + rnorm(N, sd = 0.3) # theta
  Xtemp <- data.frame(x =r*sin(t) , y = r*cos(t)) 
  ytemp <- data.frame(matrix(j, N, 1))
  X <- rbind(X, Xtemp)
  y <- rbind(y, ytemp)
}
 
data <- cbind(X,y)
colnames(data) <- c(colnames(X), 'label')

<code>X</code>, <code>y</code> are 800 by 2 and 800 by 1 data frames respectively, and they are created in a way such that a linear classifier cannot separate them. 
Since the data is 2D, we can easily visualize it on a plot. 
They are roughly evenly spaced and indeed a line is not a good decision boundary.

x_min <- min(X[,1])-0.2; x_max <- max(X[,1])+0.2
y_min <- min(X[,2])-0.2; y_max <- max(X[,2])+0.2
 
# lets visualize the data:
ggplot(data) + geom_point(aes(x=x, y=y, color = as.character(label)), size = 2) + theme_bw(base_size = 15) +
  xlim(x_min, x_max) + ylim(y_min, y_max) +
  ggtitle('Spiral Data Visulization') +
  coord_fixed(ratio = 0.8) +
  theme(axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text=element_blank(), axis.title=element_blank(), legend.position = 'none')


<img class="lazy" data-src="https://miro.medium.com/max/1650/0*0oU0nasKE2BDgb1d.png">

<h3>Neural network construction</h3>
Now, let’s construct a NN with 2 layers. 
But before that, we need to convert X into a matrix (for matrix operation later on). 
For labels in y, a new matrix Y (800 by 4) is created such that for each example (each row in Y), the entry with index==label is 1 (and 0 otherwise).

X <- as.matrix(X)
Y <- matrix(0, N*K, K)
 
for (i in 1:(N*K)){
  Y[i, y[i,]] <- 1
}

Next, let’s build a function <code>nnet</code> that takes two matrices <code>X</code> and <code>Y</code> and returns a list of 4 with <code>W</code>, <code>b</code> and <code>W2</code>, <code>b2</code> (weight and bias for each layer). 
I can specify <code>step_size</code> (learning rate) and regularization strength (<code>reg</code>, sometimes symbolized as λ ).<br> ​<br>For the choice of activation and loss (cost) function, ReLU and softmax are selected respectively. 
If you have taken the ML class by Andrew Ng (strongly recommended), sigmoid and logistic cost function are chosen in the course notes and assignment. 
They look slightly different, but can be implemented fairly easily just by modifying the following code. 
Also note that the implementation below uses vectorized operation that may seem hard to follow. 
If so, you can write down dimensions of each matrix and check multiplications and so on. 
By doing so, you also know what’s under the hood for a neural network.

# %*% dot product, * element wise product
nnet <- function(X, Y, step_size = 0.5, reg = 0.001, h = 10, niteration){
  # get dim of input
  N <- nrow(X) # number of examples
  K <- ncol(Y) # number of classes
  D <- ncol(X) # dimensionality
 
  # initialize parameters randomly
  W <- 0.01 * matrix(rnorm(D*h), nrow = D)
  b <- matrix(0, nrow = 1, ncol = h)
  W2 <- 0.01 * matrix(rnorm(h*K), nrow = h)
  b2 <- matrix(0, nrow = 1, ncol = K)
 
  # gradient descent loop to update weight and bias
  for (i in 0:niteration){
    # hidden layer, ReLU activation
    hidden_layer <- pmax(0, X%*% W + matrix(rep(b,N), nrow = N, byrow = T))
    hidden_layer <- matrix(hidden_layer, nrow = N)
    # class score
    scores <- hidden_layer%*%W2 + matrix(rep(b2,N), nrow = N, byrow = T)
 
    # compute and normalize class probabilities
    exp_scores <- exp(scores)
    probs <- exp_scores / rowSums(exp_scores)
 
    # compute the loss: sofmax and regularization
    corect_logprobs <- -log(probs)
    data_loss <- sum(corect_logprobs*Y)/N
    reg_loss <- 0.5*reg*sum(W*W) + 0.5*reg*sum(W2*W2)
    loss <- data_loss + reg_loss
    # check progress
    if (i%%1000 == 0 | i == niteration){
      print(paste("iteration", i,': loss', loss))}
 
    # compute the gradient on scores
    dscores <- probs-Y
    dscores <- dscores/N
 
    # backpropate the gradient to the parameters
    dW2 <- t(hidden_layer)%*%dscores
    db2 <- colSums(dscores)
    # next backprop into hidden layer
    dhidden <- dscores%*%t(W2)
    # backprop the ReLU non-linearity
    dhidden[hidden_layer <= 0] <- 0
    # finally into W,b
    dW <- t(X)%*%dhidden
    db <- colSums(dhidden)
 
    # add regularization gradient contribution
    dW2 <- dW2 + reg *W2
    dW <- dW + reg *W
 
    # update parameter 
    W <- W-step_size*dW
    b <- b-step_size*db
    W2 <- W2-step_size*dW2
    b2 <- b2-step_size*db2
  }
  return(list(W, b, W2, b2))
}

<h3>​Prediction function and model training</h3>
Next, create a prediction function, which takes <code>X</code> (same col as training <code>X</code> but may have different rows) and layer parameters as input. 
The output is the column index of max score in each row. 
In this example, the output is simply the label of each class. 
Now we can print out the training accuracy.

nnetPred <- function(X, para = list()){
  W <- para[[1]]
  b <- para[[2]]
  W2 <- para[[3]]
  b2 <- para[[4]]
 
  N <- nrow(X)
  hidden_layer <- pmax(0, X%*% W + matrix(rep(b,N), nrow = N, byrow = T)) 
  hidden_layer <- matrix(hidden_layer, nrow = N)
  scores <- hidden_layer%*%W2 + matrix(rep(b2,N), nrow = N, byrow = T) 
  predicted_class <- apply(scores, 1, which.max)
 
  return(predicted_class)  
}
 
nnet.model <- nnet(X, Y, step_size = 0.4,reg = 0.0002, h=50, niteration = 6000)
## [1] "iteration 0 : loss 1.38628868932674"
## [1] "iteration 1000 : loss 0.967921639616882"
## [1] "iteration 2000 : loss 0.448881467342854"
## [1] "iteration 3000 : loss 0.293036646147359"
## [1] "iteration 4000 : loss 0.244380009480792"
## [1] "iteration 5000 : loss 0.225211501612035"
## [1] "iteration 6000 : loss 0.218468573259166"
predicted_class <- nnetPred(X, nnet.model)
print(paste('training accuracy:',mean(predicted_class == (y))))
## [1] "training accuracy: 0.96375"

<h3>Decision boundary</h3>
Next, let’s plot the decision boundary. 
We can also use the caret package and train different classifiers with the data and visualize the decision boundaries. 
It is very interesting to see how different algorithms make decisions. 
This is going to be another post.

# plot the resulting classifier
hs <- 0.01
grid <- as.matrix(expand.grid(seq(x_min, x_max, by = hs), seq(y_min, y_max, by =hs)))
Z <- nnetPred(grid, nnet.model)
 
ggplot()+
  geom_tile(aes(x = grid[,1],y = grid[,2],fill=as.character(Z)), alpha = 0.3, show.legend = F)+ 
  geom_point(data = data, aes(x=x, y=y, color = as.character(label)), size = 2) + 
  theme_bw(base_size = 15) +
  ggtitle('Neural Network Decision Boundary') +
  coord_fixed(ratio = 0.8) + 
  theme(axis.ticks=element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), 
        axis.text=element_blank(), axis.title=element_blank(), legend.position = 'none')


<img class="lazy" data-src="https://miro.medium.com/max/1650/0*cRBaC-lD_r5TrSlC.png">

<h3>​MNIST data and preprocessing</h3>
The famous MNIST (“Modified National Institute of Standards and Technology”) dataset is a classic within the Machine Learning community that has been extensively studied. 
It is a collection of handwritten digits that are decomposed into a csv file, with each row representing one example, and the column values are grey scale from 0–255 of each pixel. 
First, let’s display an image.


<img class="lazy" data-src="https://miro.medium.com/max/1650/0*f_Cenh62jDzZITzQ.png">

Now, let’s preprocess the data by removing near zero variance columns and scaling by <code>max(X)</code>. 
The data is also splitted into two for cross validation. 
Once again, we need to create a <code>Y</code> matrix with dimension <code>N</code> by <code>K</code>. 
This time the non-zero index in each row is offset by 1: label 0 will have entry 1 at index 1, label 1 will have entry 1 at index 2, and so on. 
In the end, we need to convert it back. 
(Another way is put 0 at index 10 and no offset for the rest labels.)

<h3>​Model training and CV accuracy</h3>
Now we can train the model with the training set. 
Note even after removing nzv columns, the data is still huge, so it may take a while for result to converge. 
Here I am only training the model for 3500 iterations. 
You can vary the iterations, learning rate and regularization strength and plot the learning curve for optimal fitting.​

<h3>Prediction of a random image</h3>
Finally, let’s randomly select an image and predict the label.​

<h3>​Conclusion</h3>
It is rare nowadays for us to write our own machine learning algorithm from ground up. 
There are tons of packages available and they most likely outperform this one. 
However, by doing so, I really gained a deep understanding how neural network works. 
And at the end of the day, seeing your own model produces a pretty good accuracy is a huge satisfaction.

<h2>securely encrypt a string</h2>
library(sodium)
passkey <- sha256(charToRaw("password123"))
plaintext <- "西兰花"
plaintext.raw <- serialize(plaintext, NULL)
ciphertext <- data_encrypt(plaintext.raw, key = passkey)
unserialize(data_decrypt(ciphertext, key = sha256(charToRaw("password123"))))

<h2>Exploratory data analysis</h2>
Exploratory data analysis (EDA) is used by data scientists to analyze and investigate data sets and summarize their main characteristics, often employing data visualization methods. 

It helps determine how best to manipulate data sources to get the answers you need, making it easier for data scientists to discover patterns, spot anomalies, test a hypothesis, or check assumptions.

EDA is primarily used to see what data can reveal beyond the formal modeling or hypothesis testing task and provides a provides a better understanding of data set variables and the relationships between them. 

Exploratory data analysis tools
Specific statistical functions and techniques you can perform with EDA tools include:

Clustering and dimension reduction techniques, which help create graphical displays of high-dimensional data containing many variables.

Univariate visualization of each field in the raw dataset, with summary statistics.

Bivariate visualizations and summary statistics that allow you to assess the relationship between each variable in the dataset and the target variable you’re looking at.

Multivariate visualizations, for mapping and understanding interactions between different fields in the data.

K-means Clustering is a clustering method in unsupervised learning where data points are assigned into K groups, i.e. the number of clusters, based on the distance from each group’s centroid. 

The data points closest to a particular centroid will be clustered under the same category. 

K-means Clustering is commonly used in market segmentation, pattern recognition, and image compression.

Predictive models, such as linear regression, use statistics and data to predict outcomes.

Types of exploratory data analysis
There are four primary types of EDA:

Univariate non-graphical. 
This is simplest form of data analysis, where the data being analyzed consists of just one variable. 
Since it’s a single variable, it doesn’t deal with causes or relationships. 

The main purpose of univariate analysis is to describe the data and find patterns that exist within it.

Univariate graphical. 
Non-graphical methods don’t provide a full picture of the data. 
Graphical methods are therefore required. 

Common types of univariate graphics include:

Stem-and-leaf plots, which show all data values and the shape of the distribution.

Histograms, a bar plot in which each bar represents the frequency (count) or proportion (count/total count) of cases for a range of values.

Box plots, which graphically depict the five-number summary of minimum, first quartile, median, third quartile, and maximum.
Multivariate nongraphical: Multivariate data arises from more than one variable. 

Multivariate non-graphical EDA techniques generally show the relationship between two or more variables of the data through cross-tabulation or statistics.

Multivariate graphical: Multivariate data uses graphics to display relationships between two or more sets of data. 

The most used graphic is a grouped bar plot or bar chart with each group representing one level of one of the variables and each bar within a group representing the levels of the other variable.

Other common types of multivariate graphics include:

Scatter plot, which is used to plot data points on a horizontal and a vertical axis to show how much one variable is affected by another.

Multivariate chart, which is a graphical representation of the relationships between factors and a response.

Run chart, which is a line graph of data plotted over time.
Bubble chart, which is a data visualization that displays multiple circles (bubbles) in a two-dimensional plot.

Heat map, which is a graphical representation of data where values are depicted by color.

Exploratory Data Analysis Tools

Some of the most common data science tools used to create an EDA include:

Python: An interpreted, object-oriented programming language with dynamic semantics. 
Its high-level, built-in data structures, combined with dynamic typing and dynamic binding, make it very attractive for rapid application development, as well as for use as a scripting or glue language to connect existing components together. 

Python and EDA can be used together to identify missing values in a data set, which is important so you can decide how to handle missing values for machine learning.

R: An open-source programming language and free software environment for statistical computing and graphics supported by the R Foundation for Statistical Computing. 

The R language is widely used among statisticians in data science in developing statistical observations and data analysis.

<h2>Exploratory Data Analysis</h2>
Topics: <i>Variation; Visualising distributions;
Typical values; Unusual values; Missing values;
Covariation; A categorical and continuous variable;
Two categorical variables; Two continuous variables;
Patterns and models; ggplot2 calls</i>

Exploratory data analysis, or EDA for short. 
EDA is an iterative cycle. 

You:
Generate questions about your data.
Search for answers by visualising, transforming, and modelling your data.
Use what you learn to refine your questions and/or generate new questions.

EDA is not a formal process with a strict set of rules. 
More than anything, EDA is a state of mind. 
During the initial phases of EDA you should feel free to investigate every idea that occurs to you. 
Some of these ideas will pan out, and some will be dead ends. 
As your exploration continues, you will home in on a few particularly productive areas that you’ll eventually write up and communicate to others.

EDA is an important part of any data analysis, even if the questions are handed to you on a platter, because you always need to investigate the quality of your data. 
Data cleaning is just one application of EDA: you ask questions about whether your data meets your expectations or not. 
To do data cleaning, you’ll need to deploy all the tools of EDA: visualisation, transformation, and modelling.

<h3>Prerequisites</h3>
In this chapter we’ll combine what you’ve learned about dplyr and ggplot2 to interactively ask questions, answer them with data, and then ask new questions.

<code><a href="https://rdrr.io/r/base/library.html">library</a>(<a href="http://tidyverse.tidyverse.org">tidyverse</a>)</code>

<h3>Questions</h3>
“There are no routine statistical questions, only questionable statistical
routines.” — Sir David Cox
“Far better an approximate answer to the right question, which is often
vague, than an exact answer to the wrong question, which can always be made
precise.” — John Tukey

Your goal during EDA is to develop an understanding of your data. 
The easiest way to do this is to use questions as tools to guide your investigation. 
When you ask a question, the question focuses your attention on a specific part of your dataset and helps you decide which graphs, models, or transformations to make.

EDA is fundamentally a creative process. 
And like most creative processes, the key to asking <em>quality</em> questions is to generate a large <em>quantity</em> of questions. 
It is difficult to ask revealing questions at the start of your analysis because you do not know what insights are contained in your dataset. 
On the other hand, each new question that you ask will expose you to a new aspect of your data and increase your chance of making a discovery. 
You can quickly drill down into the most interesting parts of your data—and develop a set of thought-provoking questions—if you follow up each question with a new question based on what you find.

There is no rule about which questions you should ask to guide your research. 
However, two types of questions will always be useful for making discoveries within your data. 
You can loosely word these questions as:

What type of variation occurs within my variables?

What type of covariation occurs between my variables?

The rest of this chapter will look at these two questions. 
I’ll explain what variation and covariation are, and I’ll show you several ways to answer each question. 
To make the discussion easier, let’s define some terms:

A <k>variable</k> is a quantity, quality, or property that you can measure.

A <k>value</k> is the state of a variable when you measure it. 
The value of a
variable may change from measurement to measurement.

An <k>observation</k> is a set of measurements made under similar conditions
(you usually make all of the measurements in an observation at the same
time and on the same object). 
An observation will contain several values,
each associated with a different variable. 
I’ll sometimes refer to
an observation as a data point.

<k>Tabular data</k> is a set of values, each associated with a variable and an
observation. 
Tabular data is <em>tidy</em> if each value is placed in its own
“cell”, each variable in its own column, and each observation in its own
row.

So far, all of the data that you’ve seen has been tidy. 
In real-life, most data isn’t tidy, so we’ll come back to these ideas again in <a href="tidy-data.html#tidy-data-1">tidy data</a>.

<h3>Variation</h3>
<k>Variation</k> is the tendency of the values of a variable to change from measurement to measurement. 
You can see variation easily in real life; if you measure any continuous variable twice, you will get two different results. 
This is true even if you measure quantities that are constant, like the speed of light. 
Each of your measurements will include a small amount of error that varies from measurement to measurement. 
Categorical variables can also vary if you measure across different subjects (e.g. the eye colors of different people), or different times (e.g. the energy levels of an electron at different moments).
Every variable has its own pattern of variation, which can reveal interesting information. 
The best way to understand that pattern is to visualise the distribution of the variable’s values.

<h3>Visualising distributions</h3>
How you visualise the distribution of a variable will depend on whether the variable is categorical or continuous. 
A variable is <k>categorical</k> if it can only take one of a small set of values. 
In R, categorical variables are usually saved as factors or character vectors. 
To examine the distribution of a categorical variable, use a bar chart:

<code>ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7f4cb432b8891f01b8097e31f286cb54d7473ced/02c81/eda_files/figure-html/unnamed-chunk-1-1.png">
The height of the bars displays how many observations occurred with each x value. 
You can compute these values manually with <code><a href="https://dplyr.tidyverse.org/reference/count.html">dplyr::count()</a></code>:

<code>diamonds %>% 
  count(cut)
#> # A tibble: 5 x 2
#>   cut           n
#>   &lt;ord>     &lt;int>
#> 1 Fair       1610
#> 2 Good       4906
#> 3 Very Good 12082
#> 4 Premium   13791
#> 5 Ideal     21551</code>
A variable is <k>continuous</k> if it can take any of an infinite set of ordered values. 
Numbers and date-times are two examples of continuous variables. 
To examine the distribution of a continuous variable, use a histogram:

<code>ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat), binwidth = 0.5)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/832184b1db9d6bca2080fa526b7d791f77d37b8f/880fa/eda_files/figure-html/unnamed-chunk-3-1.png">
You can compute this by hand by combining <code><a href="https://dplyr.tidyverse.org/reference/count.html">dplyr::count()</a></code> and <code><a href="https://ggplot2.tidyverse.org/reference/cut_interval.html">ggplot2::cut_width()</a></code>:

<code>diamonds %>% 
  count(cut_width(carat, 0.5))
#> # A tibble: 11 x 2
#>   `cut_width(carat, 0.5)`     n
#>   &lt;fct>                   &lt;int>
#> 1 [-0.25,0.25]              785
#> 2 (0.25,0.75]             29498
#> 3 (0.75,1.25]             15977
#> 4 (1.25,1.75]              5313
#> 5 (1.75,2.25]              2002
#> 6 (2.25,2.75]               322
#> # … with 5 more rows</code>
A histogram divides the x-axis into equally spaced bins and then uses the height of a bar to display the number of observations that fall in each bin. 
In the graph above, the tallest bar shows that almost 30,000 observations have a <code>carat</code> value between 0.25 and 0.75, which are the left and right edges of the bar.

You can set the width of the intervals in a histogram with the <code>binwidth</code> argument, which is measured in the units of the <code>x</code> variable. 
You should always explore a variety of binwidths when working with histograms, as different binwidths can reveal different patterns. 
For example, here is how the graph above looks when we zoom into just the diamonds with a size of less than three carats and choose a smaller binwidth.

<code>smaller &lt;- diamonds %>% 
  <a href="https://rdrr.io/r/stats/filter.html">filter</a>(carat &lt; 3)
  
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/2f4885ec2541f7490d6504d1e4c2d2707b7cd8d5/b5df8/eda_files/figure-html/unnamed-chunk-5-1.png">
If you wish to overlay multiple histograms in the same plot, I recommend using <code>geom_freqpoly()</code> instead of <code>geom_histogram()</code>. 
<code>geom_freqpoly()</code> performs the same calculation as <code>geom_histogram()</code>, but instead of displaying the counts with bars, uses lines instead. 
It’s much easier to understand overlapping lines than bars.

<code>ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/73b1aa01f56fdebb5829f8bb9efefd2d424165dd/0799c/eda_files/figure-html/unnamed-chunk-6-1.png">
There are a few challenges with this type of plot, which we will come back to in <a href="exploratory-data-analysis.html#cat-cont">visualising a categorical and a continuous variable</a>.

Now that you can visualise variation, what should you look for in your plots? And what type of follow-up questions should you ask? I’ve put together a list below of the most useful types of information that you will find in your graphs, along with some follow-up questions for each type of information. 
The key to asking good follow-up questions will be to rely on your curiosity (What do you want to learn more about?) as well as your skepticism (How could this be misleading?).

<h3>Typical values</h3>
In both bar charts and histograms, tall bars show the common values of a variable, and shorter bars show less-common values. 
Places that do not have bars reveal values that were not seen in your data. 
To turn this information into useful questions, look for anything unexpected:

Which values are the most common? Why?

Which values are rare? Why? Does that match your expectations?

Can you see any unusual patterns? What might explain them?

As an example, the histogram below suggests several interesting questions:

Why are there more diamonds at whole carats and common fractions of carats?

Why are there more diamonds slightly to the right of each peak than there
are slightly to the left of each peak?

Why are there no diamonds bigger than 3 carats?

<code>ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.01)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/d4853921e3a2dbbac40b7b4ff2f138f0766b1f82/c7f2a/eda_files/figure-html/unnamed-chunk-7-1.png">
# 
smaller <- diamonds %>% filter(carat < 3)

ggplot(data = smaller, mapping = aes(x = carat)) + geom_histogram(binwidth = 0.1)

# same result:
index = diamonds$carat < 3
smaller1 <- diamonds[index,]
barplot(table(smaller1$carat))
cut_interval(smaller1$carat, n = NULL, length = 0.01)
barplot(table(cut_interval(smaller1$carat, n = NULL, length = 0.02)))

geom_freqpoly() performs the same calculation as geom_histogram(), but uses lines instead. 

ggplot(data = smaller, mapping = aes(x = carat, colour = cut)) + geom_freqpoly(binwidth = 0.1)

Clusters of similar values suggest that subgroups exist in your data. 
To understand the subgroups, ask:

How are the observations within each cluster similar to each other?

How are the observations in separate clusters different from each other?

How can you explain or describe the clusters?

Why might the appearance of clusters be misleading?

The histogram below shows the length (in minutes) of 272 eruptions of the Old Faithful Geyser in Yellowstone National Park. 
Eruption times appear to be clustered into two groups: there are short eruptions (of around 2 minutes) and long eruptions (4-5 minutes), but little in between.

<code>ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/aaa1365ef32c8038eab5a48634c2f78274ab1386/7b1be/eda_files/figure-html/unnamed-chunk-8-1.png">
Many of the questions above will prompt you to explore a relationship <em>between</em> variables, for example, to see if the values of one variable can explain the behavior of another variable. 
We’ll get to that shortly.

<h3>Unusual values</h3>
Outliers are observations that are unusual; data points that don’t seem to fit the pattern. 
Sometimes outliers are data entry errors; other times outliers suggest important new science. 
When you have a lot of data, outliers are sometimes difficult to see in a histogram. 
For example, take the distribution of the <code>y</code> variable from the diamonds dataset. 
The only evidence of outliers is the unusually wide limits on the x-axis.

<code>ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e6b7f3c6684eff5146e447bc122ca4ed032aec87/08e60/eda_files/figure-html/unnamed-chunk-9-1.png">
There are so many observations in the common bins that the rare bins are so short that you can’t see them (although maybe if you stare intently at 0 you’ll spot something). 
To make it easy to see the unusual values, we need to zoom to small values of the y-axis with <code>coord_cartesian()</code>:

<code>ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = <a href="https://rdrr.io/r/base/c.html">c</a>(0, 50))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0d4e86fd0fb0909eae2ea1df2e703feaa1732297/d1e5d/eda_files/figure-html/unnamed-chunk-10-1.png">
(<code>coord_cartesian()</code> also has an <code><a href="https://rdrr.io/r/graphics/plot.window.html">xlim()</a></code> argument for when you need to zoom into the x-axis. 
ggplot2 also has <code><a href="https://rdrr.io/r/graphics/plot.window.html">xlim()</a></code> and <code><a href="https://rdrr.io/r/graphics/plot.window.html">ylim()</a></code> functions that work slightly differently: they throw away the data outside the limits.)

This allows us to see that there are three unusual values: 0, ~30, and ~60. 
We pluck them out with dplyr:

<code>unusual &lt;- diamonds %>% 
  <a href="https://rdrr.io/r/stats/filter.html">filter</a>(y &lt; 3 | y > 20) %>% 
  select(price, x, y, z) %>%
  arrange(y)
unusual
#> # A tibble: 9 x 4
#>   price     x     y     z
#>   &lt;int> &lt;dbl> &lt;dbl> &lt;dbl>
#> 1  5139  0      0    0   
#> 2  6381  0      0    0   
#> 3 12800  0      0    0   
#> 4 15686  0      0    0   
#> 5 18034  0      0    0   
#> 6  2130  0      0    0   
#> 7  2130  0      0    0   
#> 8  2075  5.15  31.8  5.12
#> 9 12210  8.09  58.9  8.06</code>
The <code>y</code> variable measures one of the three dimensions of these diamonds, in mm. 
We know that diamonds can’t have a width of 0mm, so these values must be incorrect. 
We might also suspect that measurements of 32mm and 59mm are implausible: those diamonds are over an inch long, but don’t cost hundreds of thousands of dollars!

It’s good practice to repeat your analysis with and without the outliers. 
If they have minimal effect on the results, and you can’t figure out why they’re there, it’s reasonable to replace them with missing values, and move on. 
However, if they have a substantial effect on your results, you shouldn’t drop them without justification. 
You’ll need to figure out what caused them (e.g. a data entry error) and disclose that you removed them in your write-up.

<h3>Exercises</h3>
Explore the distribution of each of the <code>x</code>, <code>y</code>, and <code>z</code> variables
in <code>diamonds</code>. 
What do you learn? Think about a diamond and how you
might decide which dimension is the length, width, and depth.

Explore the distribution of <code>price</code>. 
Do you discover anything unusual
or surprising? (Hint: Carefully think about the <code>binwidth</code> and make sure
you try a wide range of values.)

How many diamonds are 0.99 carat? How many are 1 carat? What
do you think is the cause of the difference?

Compare and contrast <code>coord_cartesian()</code> vs <code><a href="https://rdrr.io/r/graphics/plot.window.html">xlim()</a></code> or <code><a href="https://rdrr.io/r/graphics/plot.window.html">ylim()</a></code> when
zooming in on a histogram. 
What happens if you leave <code>binwidth</code> unset?
What happens if you try and zoom so only half a bar shows?

<h3>Missing values</h3>
If you’ve encountered unusual values in your dataset, and simply want to move on to the rest of your analysis, you have two options.

Drop the entire row with the strange values:

<code>diamonds2 &lt;- diamonds %>% 
  <a href="https://rdrr.io/r/stats/filter.html">filter</a>(between(y, 3, 20))</code>
I don’t recommend this option because just because one measurement
is invalid, doesn’t mean all the measurements are. 
Additionally, if you
have low quality data, by time that you’ve applied this approach to every
variable you might find that you don’t have any data left!

Instead, I recommend replacing the unusual values with missing values.
The easiest way to do this is to use <code>mutate()</code> to replace the variable
with a modified copy. 
You can use the <code><a href="https://rdrr.io/r/base/ifelse.html">ifelse()</a></code> function to replace
unusual values with <code>NA</code>:

<code>diamonds2 &lt;- diamonds %>% 
  mutate(y = <a href="https://rdrr.io/r/base/ifelse.html">ifelse</a>(y &lt; 3 | y > 20, NA, y))</code>

<code><a href="https://rdrr.io/r/base/ifelse.html">ifelse()</a></code> has three arguments. 
The first argument <code>test</code> should be a logical vector. 
The result will contain the value of the second argument, <code>yes</code>, when <code>test</code> is <code>TRUE</code>, and the value of the third argument, <code>no</code>, when it is false. 
Alternatively to ifelse, use <code><a href="https://dplyr.tidyverse.org/reference/case_when.html">dplyr::case_when()</a></code>. 
<code>case_when()</code> is particularly useful inside mutate when you want to create a new variable that relies on a complex combination of existing variables.

Like R, ggplot2 subscribes to the philosophy that missing values should never silently go missing. 
It’s not obvious where you should plot missing values, so ggplot2 doesn’t include them in the plot, but it does warn that they’ve been removed:

<code>ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point()
#> Warning: Removed 9 rows containing missing values (geom_point).</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0567235adf6a020b121e8bbbb68aca6c3ec757e1/4bb0c/eda_files/figure-html/unnamed-chunk-16-1.png">
To suppress that warning, set <code>na.rm = TRUE</code>:

<code>ggplot(data = diamonds2, mapping = aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)</code>
Other times you want to understand what makes observations with missing values different to observations with recorded values. 
For example, in <code><a href="https://rdrr.io/pkg/nycflights13/man/flights.html">nycflights13::flights</a></code>, missing values in the <code>dep_time</code> variable indicate that the flight was cancelled. 
So you might want to compare the scheduled departure times for cancelled and non-cancelled times. 
You can do this by making a new variable with <code><a href="https://rdrr.io/r/base/NA.html">is.na()</a></code>.

<code>nycflights13::<a href="https://rdrr.io/pkg/nycflights13/man/flights.html">flights</a> %>% 
  mutate(
    cancelled = <a href="https://rdrr.io/r/base/NA.html">is.na</a>(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>% 
  ggplot(mapping = aes(sched_dep_time)) + 
    geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/3b39886be0ed133839461341db7faeb7420c7942/2b3e3/eda_files/figure-html/unnamed-chunk-18-1.png">
However this plot isn’t great because there are many more non-cancelled flights than cancelled flights. 
In the next section we’ll explore some techniques for improving this comparison.

<h3>Exercises</h3>
What happens to missing values in a histogram? What happens to missing
values in a bar chart? Why is there a difference?

What does <code>na.rm = TRUE</code> do in <code><a href="https://rdrr.io/r/base/mean.html">mean()</a></code> and <code><a href="https://rdrr.io/r/base/sum.html">sum()</a></code>?

<h3>Covariation</h3>
If variation describes the behavior <em>within</em> a variable, covariation describes the behavior <em>between</em> variables. 
<k>Covariation</k> is the tendency for the values of two or more variables to vary together in a related way. 
The best way to spot covariation is to visualise the relationship between two or more variables. 
How you do that should again depend on the type of variables involved.

<h3>A categorical and continuous variable</h3>
It’s common to want to explore the distribution of a continuous variable broken down by a categorical variable, as in the previous frequency polygon. 
The default appearance of <code>geom_freqpoly()</code> is not that useful for that sort of comparison because the height is given by the count. 
That means if one of the groups is much smaller than the others, it’s hard to see the differences in shape. 
For example, let’s explore how the price of a diamond varies with its quality:

<code>ggplot(data = diamonds, mapping = aes(x = price)) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/e1fa3645c501327ca1dd355d1a58e4b5dd5ae395/175af/eda_files/figure-html/unnamed-chunk-19-1.png">
It’s hard to see the difference in distribution because the overall counts differ so much:

<code>ggplot(diamonds) + 
  geom_bar(mapping = aes(x = cut))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/8eef08495f22577681edeb581899317bcae342de/0dc3d/eda_files/figure-html/unnamed-chunk-20-1.png">
To make the comparison easier we need to swap what is displayed on the y-axis. 
Instead of displaying count, we’ll display <k>density</k>, which is the count standardised so that the area under each frequency polygon is one.

<code>ggplot(data = diamonds, mapping = aes(x = price, y = ..density..)) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/f9865bcc8f3f3b4213c6356cf214f11be754e3c7/4a632/eda_files/figure-html/unnamed-chunk-21-1.png">
There’s something rather surprising about this plot - it appears that fair diamonds (the lowest quality) have the highest average price! But maybe that’s because frequency polygons are a little hard to interpret - there’s a lot going on in this plot.

Another alternative to display the distribution of a continuous variable broken down by a categorical variable is the boxplot. 
A <k>boxplot</k> is a type of visual shorthand for a distribution of values that is popular among statisticians. 
Each boxplot consists of:

A box that stretches from the 25th percentile of the distribution to the
75th percentile, a distance known as the interquartile range (IQR). 
In the
middle of the box is a line that displays the median, i.e. 50th percentile,
of the distribution. 
These three lines give you a sense of the spread of the
distribution and whether or not the distribution is symmetric about the
median or skewed to one side.

Visual points that display observations that fall more than 1.5 times the
IQR from either edge of the box. 
These outlying points are unusual
so are plotted individually.

A line (or whisker) that extends from each end of the box and goes to the<br>
farthest non-outlier point in the distribution.


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/153b9af53b33918353fda9b691ded68cd7f62f51/5b616/images/eda-boxplot.png">
Let’s take a look at the distribution of price by cut using <code>geom_boxplot()</code>:

<code>ggplot(data = diamonds, mapping = aes(x = cut, y = price)) +
  geom_boxplot()</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/dd32748293488cb51f7ca92587c4c8745c5855c0/9dcb3/eda_files/figure-html/unnamed-chunk-23-1.png">
We see much less information about the distribution, but the boxplots are much more compact so we can more easily compare them (and fit more on one plot). 
It supports the counterintuitive finding that better quality diamonds are cheaper on average! In the exercises, you’ll be challenged to figure out why.

<code>cut</code> is an ordered factor: fair is worse than good, which is worse than very good and so on. 
Many categorical variables don’t have such an intrinsic order, so you might want to reorder them to make a more informative display. 
One way to do that is with the <code><a href="https://rdrr.io/r/stats/reorder.factor.html">reorder()</a></code> function.

For example, take the <code>class</code> variable in the <code>mpg</code> dataset. 
You might be interested to know how highway mileage varies across classes:

<code>ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
  geom_boxplot()</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/9d74715c7564aa5b82548d56f35a55ffa8f845ed/463c0/eda_files/figure-html/unnamed-chunk-24-1.png">
To make the trend easier to see, we can reorder <code>class</code> based on the median value of <code>hwy</code>:

<code>ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = <a href="https://rdrr.io/r/stats/reorder.factor.html">reorder</a>(class, hwy, FUN = median), y = hwy))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/ef621dd0d8904e2091d1ed7db8553d90f89f33a5/29adc/eda_files/figure-html/unnamed-chunk-25-1.png">
If you have long variable names, <code>geom_boxplot()</code> will work better if you flip it 90°. 
You can do that with <code>coord_flip()</code>.

<code>ggplot(data = mpg) +
  geom_boxplot(mapping = aes(x = <a href="https://rdrr.io/r/stats/reorder.factor.html">reorder</a>(class, hwy, FUN = median), y = hwy)) +
  coord_flip()</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/46d22e252c5cc27cebbd2568030ac57be1e53ef9/f34fd/eda_files/figure-html/unnamed-chunk-26-1.png">

<h4>Exercises</h4>

Use what you’ve learned to improve the visualisation of the departure times
of cancelled vs. 
non-cancelled flights.

What variable in the diamonds dataset is most important for predicting
the price of a diamond? How is that variable correlated with cut?
Why does the combination of those two relationships lead to lower quality
diamonds being more expensive?

Install the ggstance package, and create a horizontal boxplot.
How does this compare to using <code>coord_flip()</code>?

One problem with boxplots is that they were developed in an era of
much smaller datasets and tend to display a prohibitively large
number of “outlying values”. 
One approach to remedy this problem is
the letter value plot. 
Install the lvplot package, and try using
<code>geom_lv()</code> to display the distribution of price vs cut. 
What
do you learn? How do you interpret the plots?

Compare and contrast <code>geom_violin()</code> with a facetted <code>geom_histogram()</code>,
or a coloured <code>geom_freqpoly()</code>. 
What are the pros and cons of each
method?

If you have a small dataset, it’s sometimes useful to use <code>geom_jitter()</code>
to see the relationship between a continuous and categorical variable.
The ggbeeswarm package provides a number of methods similar to
<code>geom_jitter()</code>. 
List them and briefly describe what each one does.

<h3>Two categorical variables</h3>
To visualise the covariation between categorical variables, you’ll need to count the number of observations for each combination. 
One way to do that is to rely on the built-in <code>geom_count()</code>:

<code>ggplot(data = diamonds) +
  geom_count(mapping = aes(x = cut, y = color))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7b7010bda735b55f17db8d3afffacd63b833d147/12920/eda_files/figure-html/unnamed-chunk-27-1.png">
The size of each circle in the plot displays how many observations occurred at each combination of values. 
Covariation will appear as a strong correlation between specific x values and specific y values.

Another approach is to compute the count with dplyr:

<code>diamonds %>% 
  count(color, cut)
#> # A tibble: 35 x 3
#>   color cut           n
#>   &lt;ord> &lt;ord>     &lt;int>
#> 1 D     Fair        163
#> 2 D     Good        662
#> 3 D     Very Good  1513
#> 4 D     Premium    1603
#> 5 D     Ideal      2834
#> 6 E     Fair        224
#> # … with 29 more rows</code>
Then visualise with <code>geom_tile()</code> and the fill aesthetic:

<code>diamonds %>% 
  count(color, cut) %>%  
  ggplot(mapping = aes(x = color, y = cut)) +
    geom_tile(mapping = aes(fill = n))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6076a5cc3814716d72982f5025c9a9fcfe271135/d09ef/eda_files/figure-html/unnamed-chunk-29-1.png">
If the categorical variables are unordered, you might want to use the seriation package to simultaneously reorder the rows and columns in order to more clearly reveal interesting patterns. 
For larger plots, you might want to try the d3heatmap or heatmaply packages, which create interactive plots.

<h4>Exercises</h4>

How could you rescale the count dataset above to more clearly show
the distribution of cut within colour, or colour within cut?

Use <code>geom_tile()</code> together with dplyr to explore how average flight
delays vary by destination and month of year. 
What makes the
plot difficult to read? How could you improve it?

Why is it slightly better to use <code>aes(x = color, y = cut)</code> rather
than <code>aes(x = cut, y = color)</code> in the example above?

<h3>Two continuous variables</h3>
You’ve already seen one great way to visualise the covariation between two continuous variables: draw a scatterplot with <code>geom_point()</code>. 
You can see covariation as a pattern in the points. 
For example, you can see an exponential relationship between the carat size and price of a diamond.

<code>ggplot(data = diamonds) +
  geom_point(mapping = aes(x = carat, y = price))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/fce2e7b428f14530f408483742ecd32043598796/21088/eda_files/figure-html/unnamed-chunk-30-1.png">
Scatterplots become less useful as the size of your dataset grows, because points begin to overplot, and pile up into areas of uniform black (as above).
You’ve already seen one way to fix the problem: using the <code>alpha</code> aesthetic to add transparency.

<code>ggplot(data = diamonds) + 
  geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100)</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/fec521e4f29a7d938da5f243cf3e1cd8d8a514ec/344ef/eda_files/figure-html/unnamed-chunk-31-1.png">
But using transparency can be challenging for very large datasets. 
Another solution is to use bin. 
Previously you used <code>geom_histogram()</code> and <code>geom_freqpoly()</code> to bin in one dimension. 
Now you’ll learn how to use <code>geom_bin2d()</code> and <code>geom_hex()</code> to bin in two dimensions.

<code>geom_bin2d()</code> and <code>geom_hex()</code> divide the coordinate plane into 2d bins and then use a fill color to display how many points fall into each bin. 
<code>geom_bin2d()</code> creates rectangular bins. 
<code>geom_hex()</code> creates hexagonal bins. 
You will need to install the hexbin package to use <code>geom_hex()</code>.

<code>ggplot(data = smaller) +
  geom_bin2d(mapping = aes(x = carat, y = price))

# install.packages("hexbin")
ggplot(data = smaller) +
  geom_hex(mapping = aes(x = carat, y = price))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/bd8faa5a44198b42b39eb84a94a8aa9090723aec/9a45f/eda_files/figure-html/unnamed-chunk-32-1.png">


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/48c515b1c463019bf93e32b648beeea37d848911/dc464/eda_files/figure-html/unnamed-chunk-32-2.png">

Another option is to bin one continuous variable so it acts like a categorical variable. 
Then you can use one of the techniques for visualising the combination of a categorical and a continuous variable that you learned about. 
For example, you could bin <code>carat</code> and then for each group, display a boxplot:

<code>ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.1)))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/6a7c21b0a75c6cd54a707e6be1190559e1780dfe/97fb8/eda_files/figure-html/unnamed-chunk-33-1.png">
<code>cut_width(x, width)</code>, as used above, divides <code>x</code> into bins of width <code>width</code>. 
By default, boxplots look roughly the same (apart from number of outliers) regardless of how many observations there are, so it’s difficult to tell that each boxplot summarises a different number of points. 
One way to show that is to make the width of the boxplot proportional to the number of points with <code>varwidth = TRUE</code>.

Another approach is to display approximately the same number of points in each bin. 
That’s the job of <code>cut_number()</code>:

<code>ggplot(data = smaller, mapping = aes(x = carat, y = price)) + 
  geom_boxplot(mapping = aes(group = cut_number(carat, 20)))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/85b4b0538dc988dcf6ad4fb5c64ef5a45d286ea5/82b02/eda_files/figure-html/unnamed-chunk-34-1.png">

<h4>Exercises</h4>

Instead of summarising the conditional distribution with a boxplot, you
could use a frequency polygon. 
What do you need to consider when using
<code>cut_width()</code> vs <code>cut_number()</code>? How does that impact a visualisation of
the 2d distribution of <code>carat</code> and <code>price</code>?

Visualise the distribution of carat, partitioned by price.

How does the price distribution of very large diamonds compare to small
diamonds? Is it as you expect, or does it surprise you?

Combine two of the techniques you’ve learned to visualise the
combined distribution of cut, carat, and price.

Two dimensional plots reveal outliers that are not visible in one
dimensional plots. 
For example, some points in the plot below have an
unusual combination of <code>x</code> and <code>y</code> values, which makes the points outliers
even though their <code>x</code> and <code>y</code> values appear normal when examined separately.

<code>ggplot(data = diamonds) +
  geom_point(mapping = aes(x = x, y = y)) +
  coord_cartesian(xlim = <a href="https://rdrr.io/r/base/c.html">c</a>(4, 11), ylim = <a href="https://rdrr.io/r/base/c.html">c</a>(4, 11))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/b75ede65f85da37195fc8d31cae5f70efcd5e0b0/b8a4a/eda_files/figure-html/unnamed-chunk-35-1.png">
Why is a scatterplot a better display than a binned plot for this case?

<h3>Patterns and models</h3>
Patterns in your data provide clues about relationships. 
If a systematic relationship exists between two variables it will appear as a pattern in the data. 
If you spot a pattern, ask yourself:

Could this pattern be due to coincidence (i.e. random chance)?

How can you describe the relationship implied by the pattern?

How strong is the relationship implied by the pattern?

What other variables might affect the relationship?

Does the relationship change if you look at individual subgroups of the data?

A scatterplot of Old Faithful eruption lengths versus the wait time between eruptions shows a pattern: longer wait times are associated with longer eruptions. 
The scatterplot also displays the two clusters that we noticed above.

<code>ggplot(data = faithful) + 
  geom_point(mapping = aes(x = eruptions, y = waiting))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7427e8aa85fc6150d830776fca343b9d39f239bc/35c23/eda_files/figure-html/unnamed-chunk-36-1.png">
Patterns provide one of the most useful tools for data scientists because they reveal covariation. 
If you think of variation as a phenomenon that creates uncertainty, covariation is a phenomenon that reduces it. 
If two variables covary, you can use the values of one variable to make better predictions about the values of the second. 
If the covariation is due to a causal relationship (a special case), then you can use the value of one variable to control the value of the second.

Models are a tool for extracting patterns out of data. 
For example, consider the diamonds data. 
It’s hard to understand the relationship between cut and price, because cut and carat, and carat and price are tightly related. 
It’s possible to use a model to remove the very strong relationship between price and carat so we can explore the subtleties that remain. 
The following code fits a model that predicts <code>price</code> from <code>carat</code> and then computes the residuals (the difference between the predicted value and the actual value). 
The residuals give us a view of the price of the diamond, once the effect of carat has been removed.

<code><a href="https://rdrr.io/r/base/library.html">library</a>(<a href="https://modelr.tidyverse.org">modelr</a>)

mod &lt;- <a href="https://rdrr.io/r/stats/lm.html">lm</a>(<a href="https://rdrr.io/r/base/Log.html">log</a>(price) ~ <a href="https://rdrr.io/r/base/Log.html">log</a>(carat), data = diamonds)

diamonds2 &lt;- diamonds %>% 
  <a href="https://modelr.tidyverse.org/reference/add_residuals.html">add_residuals</a>(mod) %>% 
  mutate(resid = <a href="https://rdrr.io/r/base/Log.html">exp</a>(resid))

ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x = carat, y = resid))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/0db11cf59fcd403141ac4a164f4163141c9ecec0/0d9cf/eda_files/figure-html/unnamed-chunk-37-1.png">
Once you’ve removed the strong relationship between carat and price, you can see what you expect in the relationship between cut and price: relative to their size, better quality diamonds are more expensive.

<code>ggplot(data = diamonds2) + 
  geom_boxplot(mapping = aes(x = cut, y = resid))</code>


<img class="lazy" data-src="https://d33wubrfki0l68.cloudfront.net/7bd23f88dac60d143f81be465a23a687fadad9fb/de235/eda_files/figure-html/unnamed-chunk-38-1.png">
You’ll learn how models, and the modelr package, work in the final part of the book, <a href="model-intro.html#model-intro">model</a>. 
We’re saving modelling for later because understanding what models are and how they work is easiest once you have tools of data wrangling and programming in hand.

<h3>ggplot2 calls</h3>
As we move on from these introductory chapters, we’ll transition to a more concise expression of ggplot2 code. 
So far we’ve been very explicit, which is helpful when you are learning:

<code>ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_freqpoly(binwidth = 0.25)</code>
Typically, the first one or two arguments to a function are so important that you should know them by heart. 
The first two arguments to <code>ggplot()</code> are <code>data</code> and <code>mapping</code>, and the first two arguments to <code>aes()</code> are <code>x</code> and <code>y</code>. 
In the remainder of the book, we won’t supply those names. 
That saves typing, and, by reducing the amount of boilerplate, makes it easier to see what’s different between plots. 
That’s a really important programming concern that we’ll come back in <a href="functions.html#functions">functions</a>.

Rewriting the previous plot more concisely yields:

<code>ggplot(faithful, aes(eruptions)) + 
  geom_freqpoly(binwidth = 0.25)</code>
Sometimes we’ll turn the end of a pipeline of data transformation into a plot. 
Watch for the transition from <code><a href="https://modelr.tidyverse.org/reference/pipe.html">%>%</a></code> to <code><a href="https://rdrr.io/r/base/Arithmetic.html">+</a></code>. 
I wish this transition wasn’t necessary but unfortunately ggplot2 was created before the pipe was discovered.

<code>diamonds %>% 
  count(cut, clarity) %>% 
  ggplot(aes(clarity, cut, fill = n)) + 
    geom_tile()</code>

<h3>Learning more</h3>
If you want to learn more about the mechanics of ggplot2, I’d highly recommend grabbing a copy of the ggplot2 book: <a href="https://amzn.com/331924275X">https://amzn.com/331924275X</a>. 
It’s been recently updated, so it includes dplyr and tidyr code, and has much more space to explore all the facets of visualisation. 
Unfortunately the book isn’t generally available for free, but if you have a connection to a university you can probably get an electronic version for free through SpringerLink.

Another useful resource is the <a href="https://amzn.com/1449316956"><em>R Graphics Cookbook</em></a> by Winston Chang. 
Much of the contents are available online at <a href="http://www.cookbook-r.com/Graphs/">http://www.cookbook-r.com/Graphs/</a>.

I also recommend <a href="https://amzn.com/1498715230"><em>Graphical Data Analysis with R</em></a>, by Antony Unwin. 
This is a book-length treatment similar to the material covered in this chapter, but has the space to go into much greater depth.

<h2>Tibbles</h2>
Tibbles are data.frames that are lazy and surly: they do less (i.e. they don’t change variable names or types, and don’t do partial matching) and complain more (e.g. when a variable does not exist). 

Tibbles also have an enhanced print() method which makes them easier to use with large datasets containing complex objects.

Here we will describe the <k>tibble</k> package, which provides opinionated data frames that make working in the tidyverse a little easier. 
In most places, I’ll use the term tibble and data frame interchangeably; when I want to draw particular attention to R’s built-in data frame, I’ll call them <code>data.frame</code>s.

If this chapter leaves you wanting to learn more about tibbles, you might enjoy <code>vignette("tibble")</code>.

<h3>Prerequisites</h3>
In this chapter we’ll explore the <k>tibble</k> package, part of the core tidyverse.

<code><a href="https://rdrr.io/r/base/library.html">library</a>(<a href="http://tidyverse.tidyverse.org">tidyverse</a>)</code>

<h3>Creating tibbles</h3>
Almost all of the functions that you’ll use in this book produce tibbles, as tibbles are one of the unifying features of the tidyverse. 
Most other R packages use regular data frames, so you might want to coerce a data frame to a tibble. 
You can do that with <code>as_tibble()</code>:

<code>as_tibble(iris)
#> # A tibble: 150 x 5
#>   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#>          &lt;dbl>       &lt;dbl>        &lt;dbl>       &lt;dbl> &lt;fct>  
#> 1          5.1         3.5          1.4         0.2 setosa 
#> 2          4.9         3            1.4         0.2 setosa 
#> 3          4.7         3.2          1.3         0.2 setosa 
#> 4          4.6         3.1          1.5         0.2 setosa 
#> 5          5           3.6          1.4         0.2 setosa 
#> 6          5.4         3.9          1.7         0.4 setosa 
#> # … with 144 more rows</code>

You can create a new tibble from individual vectors with <code>tibble()</code>. 
<code>tibble()</code> will automatically recycle inputs of length 1, and allows you to refer to variables that you just created, as shown below.

<code>tibble(
  x = 1:5, 
  y = 1, 
  z = x ^ 2 + y
)
#> # A tibble: 5 x 3
#>       x     y     z
#>   &lt;int> &lt;dbl> &lt;dbl>
#> 1     1     1     2
#> 2     2     1     5
#> 3     3     1    10
#> 4     4     1    17
#> 5     5     1    26</code>

If you’re already familiar with <code><a href="https://rdrr.io/r/base/data.frame.html">data.frame()</a></code>, note that <code>tibble()</code> does much less: it never changes the type of the inputs (e.g. it never converts strings to factors!), it never changes the names of variables, and it never creates row names.

It’s possible for a tibble to have column names that are not valid R variable names, aka <k>non-syntactic</k> names. 
For example, they might not start with a letter, or they might contain unusual characters like a space. 
To refer to these variables, you need to surround them with backticks, <code>`</code>:

<code>tb &lt;- tibble(
  `:)` = "smile", 
  ` ` = "space",
  `2000` = "number"
)
tb
#> # A tibble: 1 x 3
#>   `:)`  ` `   `2000`
#>   &lt;chr> &lt;chr> &lt;chr> 
#> 1 smile space number</code>

You’ll also need the backticks when working with these variables in other packages, like ggplot2, dplyr, and tidyr.

Another way to create a tibble is with <code>tribble()</code>, short for <k>tr</k>ansposed tibble. 
<code>tribble()</code> is customised for data entry in code: column headings are defined by formulas (i.e. they start with <code><a href="https://rdrr.io/r/base/tilde.html">~</a></code>), and entries are separated by commas. 
This makes it possible to lay out small amounts of data in easy to read form.

<code>tribble(
  ~x, ~y, ~z,
  #--|--|----
  "a", 2, 3.6,
  "b", 1, 8.5
)
#> # A tibble: 2 x 3
#>   x         y     z
#>   &lt;chr> &lt;dbl> &lt;dbl>
#> 1 a         2   3.6
#> 2 b         1   8.5</code>

I often add a comment (the line starting with <code>#</code>), to make it really clear where the header is.

<h3>Tibbles vs. 
data.frame</h3>
There are two main differences in the usage of a tibble vs. 
a classic <code>data.frame</code>: printing and subsetting.

<h3>Printing</h3>
Tibbles have a refined print method that shows only the first 10 rows, and all the columns that fit on screen. 
This makes it much easier to work with large data. 
In addition to its name, each column reports its type, a nice feature borrowed from <code><a href="https://rdrr.io/r/utils/str.html">str()</a></code>:

<code>tibble(
  a = lubridate::<a href="http://lubridate.tidyverse.org/reference/now.html">now</a>() + <a href="https://rdrr.io/r/stats/Uniform.html">runif</a>(1e3) * 86400,
  b = lubridate::<a href="http://lubridate.tidyverse.org/reference/now.html">today</a>() + <a href="https://rdrr.io/r/stats/Uniform.html">runif</a>(1e3) * 30,
  c = 1:1e3,
  d = <a href="https://rdrr.io/r/stats/Uniform.html">runif</a>(1e3),
  e = <a href="https://rdrr.io/r/base/sample.html">sample</a>(letters, 1e3, replace = TRUE)
)
#> # A tibble: 1,000 x 5
#>   a                   b              c     d e    
#>   &lt;dttm>              &lt;date>     &lt;int> &lt;dbl> &lt;chr>
#> 1 2020-10-09 13:55:17 2020-10-16     1 0.368 n    
#> 2 2020-10-10 08:00:26 2020-10-21     2 0.612 l    
#> 3 2020-10-10 02:24:06 2020-10-31     3 0.415 p    
#> 4 2020-10-09 15:45:23 2020-10-30     4 0.212 m    
#> 5 2020-10-09 12:09:39 2020-10-27     5 0.733 i    
#> 6 2020-10-09 23:10:37 2020-10-23     6 0.460 n    
#> # … with 994 more rows</code>

Tibbles are designed so that you don’t accidentally overwhelm your console when you print large data frames. 
But sometimes you need more output than the default display. 
There are a few options that can help.

First, you can explicitly <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> the data frame and control the number of rows (<code>n</code>) and the <code>width</code> of the display. 
<code>width = Inf</code> will display all columns:

<code>nycflights13::<a href="https://rdrr.io/pkg/nycflights13/man/flights.html">flights</a> %>% 
  <a href="https://rdrr.io/r/base/print.html">print</a>(n = 10, width = Inf)</code>

You can also control the default print behaviour by setting options:


<code><a href="https://rdrr.io/r/base/options.html">options(tibble.print_max = n, tibble.print_min = m)</a></code>: if more than <code>n</code>
rows, print only <code>m</code> rows. 
Use <code><a href="https://rdrr.io/r/base/options.html">options(tibble.print_min = Inf)</a></code> to always show all rows.

Use <code><a href="https://rdrr.io/r/base/options.html">options(tibble.width = Inf)</a></code> to always print all columns, regardless of the width of the screen.


You can see a complete list of options by looking at the package help with <code>package?tibble</code>.

A final option is to use RStudio’s built-in data viewer to get a scrollable view of the complete dataset. 
This is also often useful at the end of a long chain of manipulations.

<code>nycflights13::<a href="https://rdrr.io/pkg/nycflights13/man/flights.html">flights</a> %>% 
  <a href="https://rdrr.io/r/utils/View.html">View</a>()</code>

<h3>Subsetting</h3>
So far all the tools you’ve learned have worked with complete data frames. 
If you want to pull out a single variable, you need some new tools, <code><a href="https://rdrr.io/r/base/Extract.html">$</a></code> and <code><a href="https://rdrr.io/r/base/Extract.html">[[</a></code>. 
<code><a href="https://rdrr.io/r/base/Extract.html">[[</a></code> can extract by name or position; <code><a href="https://rdrr.io/r/base/Extract.html">$</a></code> only extracts by name but is a little less typing.

<code>df &lt;- tibble(
  x = <a href="https://rdrr.io/r/stats/Uniform.html">runif</a>(5),
  y = <a href="https://rdrr.io/r/stats/Normal.html">rnorm</a>(5)
)

# Extract by name
df$x
#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161
df[["x"]]
#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161

# Extract by position
df[[1]]
#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161</code>

To use these in a pipe, you’ll need to use the special placeholder <code>.</code>:

<code>df %>% .$x
#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161
df %>% .[["x"]]
#> [1] 0.73296674 0.23436542 0.66035540 0.03285612 0.46049161</code>

Compared to a <code>data.frame</code>, tibbles are more strict: they never do partial matching, and they will generate a warning if the column you are trying to access does not exist.

<h3>Interacting with older code</h3>
Some older functions don’t work with tibbles. 
If you encounter one of these functions, use <code><a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame()</a></code> to turn a tibble back to a <code>data.frame</code>:

<code><a href="https://rdrr.io/r/base/class.html">class</a>(<a href="https://rdrr.io/r/base/as.data.frame.html">as.data.frame</a>(tb))
#> [1] "data.frame"</code>

The main reason that some older functions don’t work with tibble is the <code><a href="https://rdrr.io/r/base/Extract.html">[</a></code> function. 
We don’t use <code><a href="https://rdrr.io/r/base/Extract.html">[</a></code> much in this book because <code><a href="https://dplyr.tidyverse.org/reference/filter.html">dplyr::filter()</a></code> and <code><a href="https://dplyr.tidyverse.org/reference/select.html">dplyr::select()</a></code> allow you to solve the same problems with clearer code (but you will learn a little about it in <a href="vectors.html#vector-subsetting">vector subsetting</a>). 
With base R data frames, <code><a href="https://rdrr.io/r/base/Extract.html">[</a></code> sometimes returns a data frame, and sometimes returns a vector. 
With tibbles, <code><a href="https://rdrr.io/r/base/Extract.html">[</a></code> always returns another tibble.

<h3>Exercises</h3>
How can you tell if an object is a tibble? (Hint: try printing <code>mtcars</code>,
which is a regular data frame).

Compare and contrast the following operations on a <code>data.frame</code> and equivalent tibble. 
What is different? Why might the default data frame behaviours cause you frustration?

<code>df &lt;- <a href="https://rdrr.io/r/base/data.frame.html">data.frame</a>(abc = 1, xyz = "a")
df$x
df[, "xyz"]
df[, <a href="https://rdrr.io/r/base/c.html">c</a>("abc", "xyz")]</code>

If you have the name of a variable stored in an object, e.g. <code>var &lt;- "mpg"</code>,
how can you extract the reference variable from a tibble?

Practice referring to non-syntactic names in the following data frame by:


Extracting the variable called <code>1</code>.

Plotting a scatterplot of <code>1</code> vs <code>2</code>.

Creating a new column called <code>3</code> which is <code>2</code> divided by <code>1</code>.

Renaming the columns to <code>one</code>, <code>two</code> and <code>three</code>.

<code>annoying &lt;- tibble(
  `1` = 1:10,
  `2` = `1` * 2 + <a href="https://rdrr.io/r/stats/Normal.html">rnorm</a>(<a href="https://rdrr.io/r/base/length.html">length</a>(`1`))
)</code>

What does <code><a href="https://tibble.tidyverse.org/reference/enframe.html">tibble::enframe()</a></code> do? When might you use it?

What option controls how many additional column names are printed at the footer of a tibble?

<h2>differences in histograms</h2>
ggplot(data = diamonds) + geom_bar(mapping = aes(x = cut))

barplot(table(diamonds$cut))
barplot(prop.table(table(diamonds$cut)))

hist(table(diamonds$cut))
hist(prop.table(table(diamonds$cut)))

<h2>Count frequency</h2>
diamonds %>%  count(cut)
table(diamonds$cut)
tabulate(diamonds$cut)

library("plyr")
count(diamonds, 'cut')

<h2>generate sine form values</h2>
0-2pi, steps 15 degree

sinvalue = numeric()
cosvalue = numeric()
sinvalueAdd45 = numeric()
cosvalueAdd45 = numeric()
elements = seq(0, 4*pi, 15*pi/180)
for (i in elements) sinvalue = c(sinvalue, sin(i))
for (i in elements) sinvalueAdd45 = c(sinvalueAdd45, sin(i+45*pi/180))
for (i in elements) cosvalue = c(cosvalue, cos(i))
for (i in elements) cosvalueAdd45 = c(cosvalueAdd45, cos(i+45*pi/180))
sinvalue = round(sinvalue, 4)
sinvalueAdd45 = round(sinvalueAdd45, 4)
cosvalue = round(cosvalue, 4)
cosvalueAdd45 = round(cosvalueAdd45, 4)
cat(sinvalue, ",", sinvalueAdd45, ",", cosvalue, ",", cosvalueAdd45)

<h2>datatble filter and grouping</h2>
create a data set with four variables
dt <- data.table(
  grp = factor(sample(1L:3L, 1e6, replace = TRUE)),
  x = rnorm(1e6),
  y = rnorm(1e6),
  z = sample(c(1:10, NA), 1e6, replace = TRUE)
)

dt[x < -.5, x_cat := "low"]
dt[x >= -.5 & x < .5, x_cat := "moderate"]
dt[x >= .5, x_cat := "high"]
This filters by the condition and then assigns values to x_cat either low, moderate, or high. 


<h2>Syntax of ifelse() function</h2>
ifelse(test_expression, x, y)

a = c(5,7,2,9)
ifelse(a %% 2 == 0,"even","odd")
[1] "odd"  "odd"  "even" "odd" 

<h2>select a subset</h2>
m <- matrix(1:20, ncol = 4) 
colnames(m) <- letters[1:4]

choose = c(16, 17, 18)
subset(m, m[,4] == choose)

<h2>subset of data table</h2>
aTable <- data.table(a=sample(c('a', 'b', 'c'), 10, replace=TRUE),
                 b=sample(c('a', 'b', 'c'), 10, replace=TRUE),
                 c=sample(10), key=c('a', 'b'))
chosen = c("a","c")
subset(aTable, b %in% chosen)

<h2>read ctv file</h2>
options("encoding" = "native.enc")
#options("encoding" = "UTF-8")
Sys.setlocale(category = 'LC_ALL', 'Chinese')	# this must be added to script to show chinese

dirStr = "D:/yhzq/T0002/export"
setwd(dirStr)
datafildname = "a210507.txt"
datafile = read.csv(datafildname, encoding="UTF-8", header=F, sep="\t")
head(datafile)

colnames(datafile) <- c("stkCode", "chiName", "U/D","amt","price")
datafile = datafile[,c("stkCode", "chiName", "U/D","amt","price")]

<h2>to grep multiple string variables</h2>
strs = c("whether in the any", "of the strings", "in the pattern", "in the")
toMatch = c("whether", "in", "pattern")
# use of the paste | method
haveMatch = grep(paste(toMatch,collapse="|"), atr)
matches <- unique(haveMatch)

<h2>tab width</h2>
The tab width is saved within a user-preference file located at:

C:\Users\william\AppData\Local\RStudio-Desktop\monitored\user-settings\
file:
user-settings
If RStudio is unable to read / write that file for some reason, then it will default back to using 2 spaces for the tab width.

If RStudio is unable to read / write that file for some reason, then it will default back to using 2 spaces for the tab width.

It might be worth trying to reset your RStudio's state: https://support.rstudio.com/hc/en-us/articles/200534577-Resetting-RStudio-Desktop-s-State

<h2>table and count function comparison</h2>
The table() function gives the counts of a categorical variable, but the output is not a data frame – it’s a table, and it’s not easily accessible like a data frame. You can convert this to a data frame, but the result does not retain the variable name in the corresponding column name.
With Complements to the “plyr” Package
count() to the Rescue!
https://www.r-bloggers.com/2015/02/how-to-get-the-frequency-table-of-a-categorical-variable-as-a-data-frame-in-r/

w = table(mtcars$gear)
class(w)
[1] "table"

<h2>to chop large blocks into small blocks</h2>
# length of out = 99550
# chop into 20 blocks
for(i in 0:18){
     block = out[(i*5000+1):((i+1)*5000)]
	sink(paste0(theOutName,i,".html"))
	cat(htmlHeader, sep="\n")
	cat(block, sep="\n")
	cat(htmlTail, sep="\n")
	sink()
}
# this is final block
     block = out[95001:length(out)]
	sink(paste0(theOutName,"20.html"))
	cat(htmlHeader, sep="\n")
	cat(block, sep="\n")
	cat(htmlTail, sep="\n")
	sink()

# testing sequence
for(i in 0:18){
     cat(i*5000+1,(i+1)*5000, " ")
}

# testing sequence
for(i in 0:18){
     cat(i*5000+1,(i+1)*5000, " ")
     block = out[(i*5000+1):((i+1)*5000)]
     cat(length(block))
}

<h2>avoid script break by escape key</h2>
  longLine = readline()
  if((longLine == "as.raw(27)") | (longLine  ==  "")) {
    cat(yellow("\n\nScript Ended!\n\n"))
    break
  }

<h2>Packages For Natural Language Processing NLP</h2>
<h3>1 koRpus</h3>
It includes a diverse collection of functions for automatic language detection. 
It also includes indices of lexical diversity, such as type token ratio, MTLD, etc. 
koRpus' also provides a plugin for R GUI as well as IDE RKWard that assists in providing graphical dialogs for its basic features.&nbsp;
Know more <a href="https://cran.r-project.org/web/packages/koRpus/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>2 lsa</h3>
Latent Semantic Analysis or lsa is an R package that provides routines for performing a latent semantic analysis with R. 
The basic idea of this package is that text do have a higher-order or latent semantic structure which is obscured by word usage e.g. through the use of synonyms or polysemy.
Know more <a href="https://cran.r-project.org/web/packages/lsa/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>3 OpenNLP</h3>
OpenNLP provides an R interface to Apache OpenNLP, which is a collection of natural language processing tools written in Java. 
OpenNLP supports common <a href="https://analyticsindiamag.com/limits-of-transfer-learning-in-nlp/" data-wpel-link="internal">natural language processing</a> tasks such as tokenisation, sentence segmentation, part-of-speech tagging, named entity extraction, chunking, parsing and coreference resolution.
Know more <a href="https://cran.r-project.org/web/packages/openNLP/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>4 Quanteda</h3>
Quanteda is an R package for managing and analysing text. 
It is a fast, flexible, and comprehensive framework for quantitative text analysis in R. 
Quanteda provides functionality for corpus management, creating and manipulating tokens and ngrams, exploring keywords in context, forming and manipulating sparse matrices of documents by features and more.
Know more <a href="https://quanteda.io/" data-wpel-link="external" target="_blank">here</a>.
<h3>5 RWeka</h3>
RWeka is an interface to Weka, which is a collection of <a href="https://analyticsindiamag.com/name-language-prediction-using-recurrent-neural-network-in-pytorch/" data-wpel-link="internal">machine learning algorithms</a> for data mining tasks written in Java. 
It contains tools for data pre-processing, clustering, association rules, visualisation and more. 
This package contains an interface code, known as the Weka jar that resides in a separate package called &#8216;RWekajars'.
Know more <a href="https://cran.r-project.org/web/packages/RWeka/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>6 Spacyr</h3>
Spacyr is an R wrapper to the Python spaCy <a href="https://analyticsindiamag.com/hands-on-guide-to-sign-language-classification-using-cnn/" data-wpel-link="internal">NLP library</a>. 
The package is designed to provide easy access to the functionality of spaCy library in a simple format. 
One of the easiest methods to install spaCy and spacyr is through the spacyr function spacy_install().&nbsp;
Know more <a href="https://spacyr.quanteda.io/" data-wpel-link="external" target="_blank">here</a>.
<h3>7 Stringr</h3>
Stringr is a consistent, simple and easy to use R package that provides consistent wrappers for the string package and therefore simplifies the manipulation of character strings in R. 
It includes a set of internally consistent tools for working with character strings, i.e. sequences of characters surrounded by quotation marks.&nbsp;&nbsp;
See Also
<a href="https://analyticsindiamag.com/datasaur/" data-wpel-link="internal"><img width="180" height="180" src="https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-20x20.png" class="attachment-theissue-thumbnail-x2 size-theissue-thumbnail-x2 thb-lazyload lazyload wp-post-image" alt="" loading="lazy" sizes="(max-width: 180px) 100vw, 180px" data-src="https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-180x180.png" data-sizes="auto" data-srcset="https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-180x180.png 180w, https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-150x150.png 150w, https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-90x90.png 90w, https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-20x19.png 20w, https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-50x50.png 50w, https://analyticsindiamag.com/wp-content/uploads/2020/11/datasaur-96x96.png 96w" /></a>
<h6><a href="https://analyticsindiamag.com/datasaur/" title="Comprehensive Guide to Datasaur &#8211; The Text Data Annotator Tool" data-wpel-link="internal">Comprehensive Guide to Datasaur &#8211; The Text Data Annotator Tool</a></h6> 
Know more <a href="https://cran.r-project.org/web/packages/stringr/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>8 Text2vec&nbsp;</h3>
Text2vec is an R package which provides an efficient framework with a concise API for text analysis and <a href="https://analyticsindiamag.com/computer-vision-text-caption-google/" data-wpel-link="internal">natural language processing (NLP)</a>. 
Some of its important features include allowing users to easily solve complex tasks, maximise efficiency per single thread, transparently scale to multiple threads on multicore machines, use streams and iterators, among others.
Know more <a href="https://github.com/dselivanov/text2vec" data-wpel-link="external" target="_blank">here</a>.
<h3>9 TM</h3>
TM or Text Mining Package is a framework for text mining applications within R. 
The package provides a set of predefined sources, such as DirSource, DataframeSource, etc. 
which handle a directory, a vector interpreting each component as a document, or data frame like structures (such as CSV files), and more.
Know more <a href="https://cran.r-project.org/web/packages/tm/index.html" data-wpel-link="external" target="_blank">here</a>.
<h3>10 Wordcloud</h3>
Wordcloud is an R package that creates pretty word clouds, visualises differences and similarity between documents, and avoids overplotting in scatter plots with text. 
The word cloud is a commonly used plot to visualise a speech or set of documents in a clear way.&nbsp;
Know more <a href="https://cran.r-project.org/web/packages/wordcloud/wordcloud.pdf" data-wpel-link="external" target="_blank">here</a>.

<h2>Text Analysis Packages</h2>
A Complete Overview of the Most Useful Packages in R Data Scientists Should Know About for Text Analysis
<h3>1. The All-Encompassing: Quanteda</h3>install.packages("quanteda")
library(quanteda)
This ranges from the basics in natural language processing — lexical diversity, text-preprocessing, constructing a corpus, token objects, document-feature matrix) — to more advanced statistical analysis such as wordscores or wordfish, document classification (e.g. Naive Bayes) and topic modelling.
A useful tutorial of the package is the one developed by Kohei Watanabe and Stefan Müller (<a href="https://tutorials.quanteda.io">link</a>).

<h3>2. The Transformer: Text2vec</h3>install.packages("text2vec")
library(text2vec)
This package allows you to construct a document-term matrix (dtm) or term co-occurence matrix (tcm) from documents. 
As such, you vectorize text by creating a map from words or n-grams to a vector space. 
Based on this, you can then fit a model to that dtm or tcm. 
This ranges from topic modelling (LDA, LSA), word embeddings (GloVe), collocations, similarity searches and more.
You can find a useful tutorial of the package <a href="http://text2vec.org/index.html">here</a>.

<h3>3. The Adapter: Tidytext</h3>install.packages("tidytext")
library(tidytext)
One of its benefits is that it works very well in tandem with other tidy tools in R such as dplyr or tidyr. 
You can find a useful tutorial of the package <a href="https://www.tidytextmining.com">here</a>.

<h3>4. The Matcher: Stringr</h3>install.packages("stringr")
library(stringr)
When it comes to text analysis, stringr is a particularly handy package to work with regular expressions as it provides a few useful pattern matching functions. 
Other functions include character manipulation (manipulating individual characters within the strings in character vectors) and whitespace tools (add, remove, manipulate whitespace).
The CRAN — R project has a useful tutorial on the package (<a href="https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html">link</a>).

<h3>5. The Show-Off: Spacyr</h3>install.packages("spacyr")
library(spacyr)spacy_install()spacy_initialize()
Most of you may know the spaCy package in Python. 
Well, spacyr provides a convenient wrapper of that package in R, making it easy to access the powerful functionality of spaCy in a simple format. 
To access these Python functionalities, spacyr opens a connection by being initialized within your R session.
This package is essential for more advanced natural language processing models — e.g. preparing text for deep learning — and other useful functionalities such as speech tagging, tokenization, parsing etc. 
In addition, it also works well in combination with the quanteda and tidytext packages.
You can find a useful tutorial to the package <a href="https://spacyr.quanteda.io/articles/using_spacyr.html">here</a>.

<h2>Text mine using NLP techniques</h2>
To investigate a collection of text documents (corpus) and find the words (entities) that represent the collection of words in this corpus. 
<h3>Operation Buggy</h3>
Say you are a tester and you are called in to help a DevOps team with their issue management system. 
But the only thing you have been given are text documents made by the testers, which are exports of JIRA issues they reported. 
They are large documents, and no one (including you) has time to manually read through them.

As a data scientist and QA expert, it’s your job to make sense of the data in the text documents. 
What parts of the system were tested, and which system components had the most found issues? This is where Natural Language Processing (NLP) can enter to tackle the problem, and R, the statistical computing environment with different R packages, can be used to perform NLP methods on your data. 
(Some packages include: <a href="https://www.rdocumentation.org/packages/tm/versions/0.7-5">tm</a>, <a href="https://cran.r-project.org/web/packages/textreuse/index.html">test reuse</a>, <a href="https://opennlp.apache.org/">openNLP</a>, etc.) The choice of package depends on what you want to analyze with your data.

In this example, the immediate objective is to turn a large library of text into actionable data to:




Find the issues with the highest risks (not the most buggy components of the system, because this component can also contain a lot of trivial issues).
Fix the component of the system with the most issues.



To tackle the problem, we need statistics. 
By using the statistical programming language R, we can make statistical algorithms to find the most buggy component of the system under test.

<h3>Retrieval of the data</h3>
First, we have to retrieve and preprocess the files to enable the search for the most buggy component. 
what R packages do we actually need?

These are mentioned in Table 1, including their functions.

<img class="lazy" data-src="https://sweetcode.io/wp-content/uploads/2018/08/Screen-Shot-2018-08-21-at-8.15.39-AM.png">

Table 1: R packages used

The functions of these R packages will be explained when the R packages are addressed.
Before you start to build the algorithm in R, you first have to install and load the libraries of the R packages.

After installation, every R script first starts with addressing the R libraries as shown below.

library(tm)
library(SnowballC)
library(topicmodels)

You can start with retrieving the dataset (or corpus for NLP).

For this experiment, we saved three text files with bug reports from three testers in a separate directory, also being our working directory (use setwd(“directory”) to set the working directory).

#set working directory (modify path as needed)
setwd(directory)

You can load the files from this directory in the corpus:

#load files into corpus
#get listing of .txt files in directory
filenames &lt;- list.files(getwd(),pattern="*.txt")  #getwd() represents working directory

Read the files into a character vector, which is a basic data structure and can be read by R.

#read files into a character vector
files &lt;- lapply(filenames,readLines)

We now have to create a corpus from the vector.

#create corpus from vector
articles.corpus &lt;- Corpus(VectorSource(files))

<h3>Preprocessing the data</h3>
Next, we need to preprocess the text to convert it into a format that can be processed for extracting information. 
An essential aspect involves the reduction of the size of the feature space before analyzing the text, i.e. normalization. 
(Several preprocessing methods are available, such as case-folding, stop word removal, stemming, lemmatization, contraction simplification etc.) What preprocessing method is necessary depends on the data we retrieve, and the kind of analysis to be performed.

Here,we use case-folding and stemming.

Case-folding to match all possible instances of a word (Auto and auto, for instance).

Stemming is the process of reducing the modified or derived words to their root form.
This way, we also match the resulting root forms.

# make each letter lowercase
articles.corpus &lt;- tm_map(articles.corpus, tolower)
#stemming
articles.corpus &lt;- tm_map(articles.corpus, stemDocument);

<h3>Create the DTM</h3>
The next step is to create a document-term matrix (DTM). 
This is critical, because to interpret and analyze the text files, they must ultimately be converted into a document-term matrix.
The DTM holds the number of term occurrences per document. 
The rows in a DTM represent the documents, and each term in a document is represented as a column. 
We’ll also remove the low-frequency words (or sparse terms) after converting the corpus into the DTM.

<h3>articleDtm &lt;- DocumentTermMatrix(articles.corpus, control = list(minWordLength = 3));
articleDtm2 &lt;- removeSparseTerms(articleDtm, sparse=0.98)</h3>
<h3>Topic modeling</h3>
We are now ready to find the words in the corpus that represent the collection of words used in the corpus: the essentials.

This is also called topic modeling.
The topic modeling technique we will use here is latent Dirichlet allocation (LDA). 
The purpose of <a href="https://www.linkedin.com/pulse/lda-explanation-gaurhari-dass">LDA</a> is to learn the representation of a fixed number of topics, and given this number of topics, learn the topic distribution that each document in a collection of documents has.

Explaining LDA goes far beyond the scope of this article. 
For now, just follow the code as written below.

#LDA
k = 5;
SEED = 1234;
article.lda &lt;- LDA(articleDtm2, k, method="Gibbs", control=list(seed = SEED))
lda.topics &lt;- as.matrix(topics(article.lda))
lda.topics
lda.terms &lt;- terms(article.lda)

If you now run the full code in R as explained above, you will calculate the essentials, the words in the corpus that represent the collection of words used in the corpus.

For this experiment, the results were:

> lda.terms
    Topic 1     Topic 2     Topic 3     Topic 4     Topic 5 
     "theo" "customers"    "angela"       "crm"      "paul"

Topics 1 and 3 can be explained: theo and angela are testers.

Topic 5 is also easily explained: paul is a fixer.

Topic 4, crm, is the system under test, so it’s not surprising it shows up as a term in the LDA, because it is mentioned in every issue by every tester.

Now, we still have topic 2: customers.

Customers is a component of the system under test: crm.

Customers is most mentioned as a component in the issues found by all the testers involved.

Finally, we have found our most buggy component.

<h3>Wrap-up</h3>
This article described a method we can use to investigate a collection of text documents (corpus) and find the words that represent the collection of words in this corpus. 
For this article’s example, R (together with NLP techniques) was used to find the component of the system under test with the most issues found.

<h3>R code</h3>
library(tm)
library(SnowballC)
library(topicmodels)

# TEXT RETRIEVAL

#set working directory (modify path as needed)
ld

#load files into corpus
#get listing of .txt files in directory
filenames &lt;- list.files(getwd(),pattern="*.txt")
#read files into a character vector
files &lt;- lapply(filenames,readLines)
#create corpus from vector
articles.corpus &lt;- Corpus(VectorSource(files))

# TEXT PROCESSING

# make each letter lowercase
articles.corpus &lt;- tm_map(articles.corpus, tolower)

# stemming
articles.corpus &lt;- tm_map(articles.corpus, stemDocument);

# Ceate the Document Term Matrix (DTM)
articleDtm &lt;- DocumentTermMatrix(articles.corpus, control = list(minWordLength = 3));
articleDtm2 &lt;- removeSparseTerms(articleDtm, sparse=0.98)

# TOP MODELING

k = 5;
SEED = 1234;
article.lda &lt;- LDA(articleDtm2, k, method="Gibbs", control=list(seed = SEED))
lda.topics &lt;- as.matrix(topics(article.lda))
lda.topics
lda.terms &lt;- terms(article.lda)
lda.terms

<h2>Text Mining and Sentiment Analysis</h2>
In the third article of this series, Sanil Mhatre demonstrates how to perform a sentiment analysis using R including generating a word cloud, word associations, sentiment scores, and emotion classification. 
<a href="https://www.red-gate.com/simple-talk/sql/bi/text-mining-and-sentiment-analysis-introduction/">Text Mining and Sentiment Analysis: Introduction</a>
<a href="https://www.red-gate.com/simple-talk/sql/bi/text-mining-and-sentiment-analysis-power-bi-visualizations">Text Mining and Sentiment Analysis: Power BI Visualizations</a>
<a href="https://www.red-gate.com/simple-talk/sql/bi/text-mining-and-sentiment-analysis-with-r/">Text Mining and Sentiment Analysis: Analysis with R</a>
This is the third article of the "Text Mining and Sentiment Analysis" Series. 
The first article introduced Azure Cognitive Services and demonstrated the setup and use of Text Analytics APIs for extracting key Phrases & Sentiment Scores from text data. 
The second article demonstrated Power BI visualizations for analyzing Key Phrases & Sentiment Scores and interpreting them to gain insights. 
This article explores R for text mining and sentiment analysis. 
I will demonstrate several common text analytics techniques and visualizations in R.
Note: This article assumes basic familiarity with R and RStudio. 
Please jump to the References section for more information on installing R and RStudio. 
The Demo data raw text file and R script are available for download from my GitHub repository; please find the link in the References section.
R is a language and environment for statistical computing and graphics. 
It provides a wide variety of statistical and graphical techniques and is highly extensible. 
R is available as free software. 
It's easy to learn
and use and can produce well designed publication-quality plots. 
For the demos in this article, I am using R version 3.5.3 (2019-03-11), RStudio Version 1.1.456
The input file for this article has only one column, the "Raw text" of survey responses and is a text file.
A sample of the first few rows are shown in Notepad++ (showing all characters) in Figure 1.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-computer-description-automatica.png">
The demo R script and demo input text file are available on my GitHub repo (please find the link in the References section).
R has a rich set of packages for Natural Language Processing (NLP) and generating plots. 
The foundational steps involve loading the text file into an R Corpus, then cleaning and stemming the data before performing analysis. 
I will demonstrate these steps and analysis like Word Frequency, Word Cloud, Word Association, Sentiment Scores and Emotion Classification using various plots and charts.
<h3>Installing and loading R packages</h3>
The following packages are used in the examples in this article:
<k>tm</k> for text mining operations like removing numbers, special characters, punctuations and stop words (Stop words in any language are the most commonly occurring words that have very little value for NLP and should be filtered out. 
Examples of stop words in English are "the", "is", "are".)
<k>snowballc</k> for stemming, which is the process of reducing words to their base or root form. 
For example, a stemming algorithm would reduce the words "fishing", "fished" and "fisher" to the stem "fish".
<k>wordcloud</k> for generating the word cloud plot.
<k>RColorBrewer</k> for color palettes used in various plots
<k>syuzhet</k> for sentiment scores and emotion classification
<k>ggplot2</k> for plotting graphs
Open RStudio and create a new R Script. 
Use the following code to install and load these packages.
# Install
install.packages("tm")  # for text mining
install.packages("SnowballC") # for text stemming
install.packages("wordcloud") # word-cloud generator 
install.packages("RColorBrewer") # color palettes
install.packages("syuzhet") # for sentiment analysis
install.packages("ggplot2") # for plotting graphs
# Load
library("tm")
library("SnowballC")
library("wordcloud")
library("RColorBrewer")
library("syuzhet")
library("ggplot2")
<h3>Reading file data into R</h3>
The R base function <code>read.table()</code> is generally used to read a file in table format and imports data as a data frame. 
Several variants of this function are available, for importing different file formats;
<k>read.csv() is</k> used for reading comma-separated value (csv) files, where a comma "," is used a field separator
<k>read.delim()</k> is used for reading tab-separated values (.txt) files
The input file has multiple lines of text and no columns/fields (data is not tabular), so you will use the <code>readLines</code> function. 
This function takes a file (or URL) as input and returns a vector containing as many elements as the number of lines in the file. 
The <code>readLines</code> function simply extracts the text from its input source and returns each line as a character string. 
The <code>n=</code> argument is useful to read a limited number (subset) of lines from the input source (Its default value is -1, which reads all lines from the input source). 
When using the filename in this function's argument, R assumes the file is in your current working directory (you can use the <code>getwd()</code> function in R console to find your current working directory). 
You can also choose the input file interactively, using the <code>file.choose()</code> function within the argument. 
The next step is to load that Vector as a Corpus. 
In R, a Corpus is a collection of text document(s) to apply text mining or NLP routines on. 
Details of using the <code>readLines</code> function are sourced from: <a href="https://www.stat.berkeley.edu/~spector/s133/Read.html">https://www.stat.berkeley.edu/~spector/s133/Read.html</a> .
In your R script, add the following code to load the data into a corpus.
# Read the text file from local machine , choose file interactively
text &lt;- readLines(file.choose())
# Load the data as a corpus
TextDoc &lt;- Corpus(VectorSource(text))
Upon running this, you will be prompted to select the input file. 
Navigate to your file and click <em>Open </em>as shown in Figure 2.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-computer-description-automatica-1.png">
<h3>Cleaning up Text Data</h3>
Cleaning the text data starts with making transformations like removing special characters from the text. 
This is done using the <code>tm_map()</code> function to replace special characters like <code>/</code>, <code>@</code> and <code>|</code> with a space. 
The next step is to remove the unnecessary whitespace and convert the text to lower case.
Then remove the <em>stopwords</em>. 
They are the most commonly occurring words in a language and have very little value in terms of gaining useful information. 
They should be removed before performing further analysis. 
Examples of stopwords in English are "the, is, at, on<em>"</em>. 
There is no single universal list of stop words used by all NLP tools. 
<code>stopwords</code> in the <code>tm_map()</code> function supports several languages like English, French, German, Italian, and Spanish. 
Please note the language names are case sensitive. 
I will also demonstrate how to add your own list of stopwords, which is useful in this Team Health example for removing non-default stop words like "team", "company", "health". 
Next, remove numbers and punctuation.
The last step is text stemming. 
It is the process of reducing the word to its root form. 
The stemming process simplifies the word to its common origin. 
For example, the stemming process reduces the words "fishing", "fished" and "fisher" to its stem "fish". 
Please note stemming uses the <em>SnowballC</em> package. 
(You may want to skip the text stemming step if your users indicate a preference to see the original "unstemmed" words in the word cloud plot)
In your R script, add the following code to transform and run to clean-up the text data.
#Replacing "/", "@" and "|" with space
toSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, " ", x))
TextDoc &lt;- tm_map(TextDoc, toSpace, "/")
TextDoc &lt;- tm_map(TextDoc, toSpace, "@")
TextDoc &lt;- tm_map(TextDoc, toSpace, "\\|")
# Convert the text to lower case
TextDoc &lt;- tm_map(TextDoc, content_transformer(tolower))
# Remove numbers
TextDoc &lt;- tm_map(TextDoc, removeNumbers)
# Remove english common stopwords
TextDoc &lt;- tm_map(TextDoc, removeWords, stopwords("english"))
# Remove your own stop word
# specify your custom stopwords as a character vector
TextDoc &lt;- tm_map(TextDoc, removeWords, c("s", "company", "team")) 
# Remove punctuations
TextDoc &lt;- tm_map(TextDoc, removePunctuation)
# Eliminate extra white spaces
TextDoc &lt;- tm_map(TextDoc, stripWhitespace)
# Text stemming - which reduces words to their root form
TextDoc &lt;- tm_map(TextDoc, stemDocument)
 
<h3>Building the term document matrix</h3>
After cleaning the text data, the next step is to count the occurrence of each word, to identify popular or trending topics. 
Using the function <code>TermDocumentMatrix()</code> from the text mining package, you can build a Document Matrix &ndash; a table containing the frequency of words.
In your R script, add the following code and run it to see the top 5 most frequently found words in your text.
# Build a term-document matrix
TextDoc_dtm &lt;- TermDocumentMatrix(TextDoc)
dtm_m &lt;- as.matrix(TextDoc_dtm)
# Sort by descearing value of frequency
dtm_v &lt;- sort(rowSums(dtm_m),decreasing=TRUE)
dtm_d &lt;- data.frame(word = names(dtm_v),freq=dtm_v)
# Display the top 5 most frequent words
head(dtm_d, 5)
The following table of word frequency is the expected output of the <code>head</code> command on RStudio Console.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/word-image-1.png">
Plotting the top 5 most frequent words using a bar chart is a good basic way to visualize this word frequent data. 
In your R script, add the following code and run it to generate a bar chart, which will display in the <em>Plots</em> sections of RStudio.
# Plot the most frequent words
barplot(dtm_d[1:5,]$freq, las = 2, names.arg = dtm_d[1:5,]$word,
        col ="lightgreen", main ="Top 5 most frequent words",
        ylab = "Word frequencies")
The plot can be seen in Figure 3.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati.png">
One could interpret the following from this bar chart:
The most frequently occurring word is "good". 
Also notice that negative words like "not" don't feature in the bar chart, which indicates there are no negative prefixes to change the context or meaning of the word "good" ( In short, this indicates most responses don't mention negative phrases like "not good").
"work", "health" and "feel" are the next three most frequently occurring words, which indicate that most people feel good about their work and their team's health.
Finally, the root "improv" for words like "improve", "improvement", "improving", etc. 
is also on the chart, and you need further analysis to infer if its context is positive or negative
<h3>Generate the Word Cloud</h3>
A word cloud is one of the most popular ways to visualize and analyze qualitative data. 
It's an image composed of keywords found within a body of text, where the size of each word indicates its frequency in that body of text. 
Use the word frequency data frame (table) created previously to generate the word cloud. 
In your R script, add the following code and run it to generate the word cloud and display it in the <em>Plots</em> section of RStudio.
#generate word cloud
set.seed(1234)
wordcloud(words = dtm_d$word, freq = dtm_d$freq, min.freq = 5,
          max.words=100, random.order=FALSE, rot.per=0.40, 
          colors=brewer.pal(8, "Dark2"))
Below is a brief description of the arguments used in the word cloud function;
<k>words</k> &#8211; words to be plotted
<k>freq</k> &#8211; frequencies of words
<k>min.freq</k> &ndash; words whose frequency is at or above this threshold value is plotted (in this case, I have set it to 5)
<k>max.words</k> &ndash; the maximum number of words to display on the plot (in the code above, I have set it 100)
<k>random.order</k> &ndash; I have set it to FALSE, so the words are plotted in order of decreasing frequency
<k>rot.per</k> &ndash; the percentage of words that are displayed as vertical text (with 90-degree rotation). 
I have set it 0.40 (40 %), please feel free to adjust this setting to suit your preferences
<k>colors</k> &ndash; changes word colors going from lowest to highest frequencies
You can see the resulting word cloud in Figure 4.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-1.png">
The word cloud shows additional words that occur frequently and could be of interest for further analysis. 
Words like "need", "support", "issu" (root for "issue(s)", etc. 
could provide more context around the most frequently occurring words and help to gain a better understanding of the main themes.
<h3>Word Association</h3>
Correlation is a statistical technique that can demonstrate whether, and how strongly, pairs of variables are related. 
This technique can be used effectively to analyze which words occur most often in association with the most frequently occurring words in the survey responses, which helps to see the context around these words
In your R script, add the following code and run it.
# Find associations 
findAssocs(TextDoc_dtm, terms = c("good","work","health"), corlimit = 0.25)
You should see the results as shown in Figure 5.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-2.png">
This script shows which words are most frequently associated with the top three terms (<code>corlimit = 0.25</code> is the lower limit/threshold I have set. 
You can set it lower to see more words, or higher to see less). 
The output indicates that "integr" (which is the root for word "integrity") and "synergi" (which is the root for words "synergy", "synergies", etc.) and occur 28% of the time with the word "good". 
You can interpret this as the context around the most frequently occurring word ("good") is positive. 
Similarly, the root of the word "together" is highly correlated with the word "work". 
This indicates that most responses are saying that teams "work together" and can be interpreted in a positive context.
You can modify the above script to find terms associated with words that occur at least 50 times or more, instead of having to hard code the terms in your script.
# Find associations for words that occur at least 50 times
findAssocs(TextDoc_dtm, terms = findFreqTerms(TextDoc_dtm, lowfreq = 50), corlimit = 0.25)
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-3.png">
<h3>Sentiment Scores</h3>
Sentiments can be classified as positive, neutral or negative. 
They can also be represented on a numeric scale, to better express the degree of positive or negative strength of the sentiment contained in a body of text.
This example uses the Syuzhet package for generating sentiment scores, which has four sentiment dictionaries and offers a method for accessing the sentiment extraction tool developed in the NLP group at Stanford. 
The <code>get_sentiment</code> function accepts two arguments: a character vector (of sentences or words) and a method. 
The selected method determines which of the four available sentiment extraction methods will be used. 
The four methods are <code>syuzhet</code> (this is the default), <code>bing</code>, <code>afinn</code> and <code>nrc</code>. 
Each method uses a different scale and hence returns slightly different results. 
Please note the outcome of <code>nrc</code> method is more than just a numeric score, requires additional interpretations and is out of scope for this article. 
The descriptions of the <code>get_sentiment</code> function has been sourced from : <a href="https://cran.r-project.org/web/packages/syuzhet/vignettes/syuzhet-vignette.html?">https://cran.r-project.org/web/packages/syuzhet/vignettes/syuzhet-vignette.html?</a>
Add the following code to the R script and run it.
# regular sentiment score using get_sentiment() function and method of your choice
# please note that different methods may have different scales
syuzhet_vector &lt;- get_sentiment(text, method="syuzhet")
# see the first row of the vector
head(syuzhet_vector)
# see summary statistics of the vector
summary(syuzhet_vector)
Your results should look similar to Figure 7.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-4.png">
<k>Figure 7. 
Syuzhet vector</k>
An inspection of the Syuzhet vector shows the first element has the value of <em>2.60</em>. 
It means the sum of the sentiment scores of all meaningful words in the first response(line) in the text file, adds up to 2.60. 
The scale for sentiment scores using the <code>syuzhet</code> method is decimal and ranges from -1(indicating most negative) to +1(indicating most positive). 
Note that the summary statistics of the <code>suyzhet</code> vector show a median value of 1.6, which is above zero and can be interpreted as the overall average sentiment across all the responses is positive.
Next, run the same analysis for the remaining two methods and inspect their respective vectors. 
Add the following code to the R script and run it.
# bing
bing_vector &lt;- get_sentiment(text, method="bing")
head(bing_vector)
summary(bing_vector)
#affin
afinn_vector &lt;- get_sentiment(text, method="afinn")
head(afinn_vector)
summary(afinn_vector)
Your results should resemble Figure 8.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-5.png">
<k>Figure 8. 
bing and afinn vectors</k>
Please note the scale of sentiment scores generated by:
<k>bing</k> &ndash; binary scale with -1 indicating negative and +1 indicating positive sentiment
<k>afinn</k> &ndash; integer scale ranging from -5 to +5
The summary statistics of <code>bing</code> and <code>afinn</code> vectors also show that the <code>Median</code> value of Sentiment scores is above 0 and can be interpreted as the overall average sentiment across the all the responses is positive.
Because these different methods use different scales, it's better to convert their output to a common scale before comparing them. 
This basic scale conversion can be done easily using R's built-in <code>sign</code> function, which converts all positive number to 1, all negative numbers to -1 and all zeros remain 0.
Add the following code to your R script and run it.
#compare the first row of each vector using sign function
rbind(
  sign(head(syuzhet_vector)),
  sign(head(bing_vector)),
  sign(head(afinn_vector))
)
Figure 9 shows the results.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-6.png">
<k> Figure 9. 
Normalize scale and compare three vectors</k>
Note the first element of each row (vector) is <em>1</em>, indicating that all three methods have calculated a positive sentiment score, for the first response (line) in the text.
<h3>Emotion Classification</h3>
Emotion classification is built on the NRC Word-Emotion Association Lexicon (aka EmoLex). 
The definition of "NRC Emotion Lexicon", sourced from <a href="http://saifmohammad.com/WebPages/NRC-Emotion-Lexicon.htm">http://saifmohammad.com/WebPages/NRC-Emotion-Lexicon.htm</a> is "The NRC Emotion Lexicon is a list of English words and their associations with eight basic emotions (anger, fear, anticipation, trust, surprise, sadness, joy, and disgust) and two sentiments (negative and positive). 
The annotations were manually done by crowdsourcing."
To understand this, explore the <code>get_nrc_sentiments</code> function, which returns a data frame with each row representing a sentence from the original file. 
The data frame has ten columns (one column for each of the eight emotions, one column for positive sentiment valence and one for negative sentiment valence). 
The data in the columns (anger, anticipation, disgust, fear, joy, sadness, surprise, trust, negative, positive) can be accessed individually or in sets. 
The definition of <code>get_nrc_sentiments</code> has been sourced from: <a href="https://cran.r-project.org/web/packages/syuzhet/vignettes/syuzhet-vignette.html?">https://cran.r-project.org/web/packages/syuzhet/vignettes/syuzhet-vignette.html?</a>
Add the following line to your R script and run it, to see the data frame generated from the previous execution of the <code>get_nrc_sentiment</code> function.
# run nrc sentiment analysis to return data frame with each row classified as one of the following
# emotions, rather than a score: 
# anger, anticipation, disgust, fear, joy, sadness, surprise, trust 
# It also counts the number of positive and negative emotions found in each row
d&lt;-get_nrc_sentiment(text)
# head(d,10) - to see top 10 lines of the get_nrc_sentiment dataframe
head (d,10)
The results should look like Figure 10.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-7.png">
<k>Figure 10. 
Data frame returned by get_nrc_sentiment function</k>
The output shows that the first line of text has;
Zero occurrences of words associated with emotions of anger, disgust, fear, sadness and surprise
One occurrence each of words associated with emotions of anticipation and joy
Two occurrences of words associated with emotions of trust
Total of one occurrence of words associated with negative emotions
Total of two occurrences of words associated with positive emotions
The next step is to create two plots charts to help visually analyze the emotions in this survey text. 
First, perform some data transformation and clean-up steps before plotting charts. 
The first plot shows the total number of instances of words in the text, associated with each of the eight emotions. 
Add the following code to your R script and run it.
#transpose
td&lt;-data.frame(t(d))
#The function rowSums computes column sums across rows for each level of a grouping variable.
td_new &lt;- data.frame(rowSums(td[2:253]))
#Transformation and cleaning
names(td_new)[1] &lt;- "count"
td_new &lt;- cbind("sentiment" = rownames(td_new), td_new)
rownames(td_new) &lt;- NULL
td_new2&lt;-td_new[1:8,]
#Plot One - count of words associated with each sentiment
quickplot(sentiment, data=td_new2, weight=count, geom="bar", fill=sentiment, ylab="count")+ggtitle("Survey sentiments")
You can see the bar plot in Figure 11.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-8.png">
<k>Figure 11. 
Bar Plot showing the count of words in the text, associated with each emotion</k>
This bar chart demonstrates that words associated with the positive emotion of "trust" occurred about five hundred times in the text, whereas words associated with the negative emotion of "disgust" occurred less than 25 times. 
A deeper understanding of the overall emotions occurring in the survey response can be gained by comparing these number as a percentage of the total number of meaningful words. 
Add the following code to your R script and run it.
#Plot two - count of words associated with each sentiment, expressed as a percentage
barplot(
  sort(colSums(prop.table(d[, 1:8]))), 
  horiz = TRUE, 
  cex.names = 0.7, 
  las = 1, 
  main = "Emotions in Text", xlab="Percentage"
)
The Emotions bar plot can be seen in figure 12.
<img class="lazy" data-src="https://www.red-gate.com/simple-talk/wp-content/uploads/2020/05/a-screenshot-of-a-cell-phone-description-automati-9.png">
<k>Figure 12. 
Bar Plot showing the count of words associated with each sentiment expressed as a percentage </k>
This bar plot allows for a quick and easy comparison of the proportion of words associated with each emotion in the text. 
The emotion "trust" has the longest bar and shows that words associated with this positive emotion constitute just over 35% of all the meaningful words in this text. 
On the other hand, the emotion of "disgust" has the shortest bar and shows that words associated with this negative emotion constitute less than 2% of all the meaningful words in this text. 
Overall, words associated with the positive emotions of "trust" and "joy" account for almost 60% of the meaningful words in the text, which can be interpreted as a good sign of team health.
<h3>Conclusion</h3>
This article demonstrated reading text data into R, data cleaning and transformations. 
It demonstrated how to create a word frequency table and plot a word cloud, to identify prominent themes occurring in the text. 
Word association analysis using correlation, helped gain context around the prominent themes. 
It explored four methods to generate sentiment scores, which proved useful in assigning a numeric value to strength (of positivity or negativity) of sentiments in the text and allowed interpreting that the average sentiment through the text is trending positive. 
Lastly, it demonstrated how to implement an emotion classification with NRC sentiment and created two plots to analyze and interpret emotions found in the text.

<h2>Algorithmic Trading</h2>
<a href="https://hackernoon.com/unsupervised-machine-learning-for-fun-profit-with-basket-clusters-17a1161e7aa1" class="whitebut ">Generating Alpha with Vectorspace AI NLP/NLU Correlation Matrix</a>
<a href="https://www.datacamp.com/community/tutorials/finance-python-trading" class="whitebut ">Python For Finance: Algorithmic Trading</a>
<a href="https://www.oreilly.com/content/algorithmic-trading-in-less-than-100-lines-of-python-code/" class="whitebut ">Algorithmic trading in less than 100 lines of Python code</a>
<a href="https://github.com/llSourcell/AI_in_Finance" class="whitebut ">AI in Finance</a>
<a href="https://marutitech.com/ways-ai-transforming-finance/" class="whitebut ">5 Ways AI is Transforming the Finance Industry</a>
<a href="https://www.investopedia.com/articles/active-trading/101014/basics-algorithmic-trading-concepts-and-examples.asp" class="whitebut ">Basics of Algorithmic Trading: Concepts and Examples</a>
<a href="https://www.investopedia.com/terms/a/algorithmictrading.asp" class="whitebut ">Algorithmic Trading</a>
<a href="https://corporatefinanceinstitute.com/resources/knowledge/trading-investing/algorithmic-trading/" class="whitebut ">What is Algorithmic Trading?</a>
<a href="https://www.trality.com/blog/algorithmic-trading" class="whitebut ">algorithmic-trading account</a>
<a href="https://www.analyticsvidhya.com/blog/2017/09/common-machine-learning-algorithms/" class="whitebut ">Common Machine Learning Algorithms</a>

<h2>Tools for AI with R</h2>

C50
C50 finds application in building decision tree algorithms.

Class
‘class’ contains the knn( ) function which provides the food for constructing the k-nearest neighbours algorithm- an easy machine learning algorithm.
The knn( ) function uses the Euclidean distance method to identify the k-nearest neighbours; k is a user-specified number.

e1071
Provides the function naiveBayes( ) based on the simple application of conditional probability.

Let us try to analyse a situation where retailers need to find out what is the probability of a customer to buy bread when he has already bought butter.

Such type of analysis requires conditional probability which can be made available using e1071 package which in turn helps in finding effective business solutions.

Gmodels
During statistical analysis, we may often want to compare relationship between two nominal variables.
To explain this, let’s consider 2 nominal variables, one being ‘Income groups’ (Levels=High, Medium, Low), and the other being ‘Highest level of Education’ (Levels= Undegraduation, Graduation, Post-Graduation).We might be interested to find out whether the Income has a significant relationship with the affordability of the level of education.
Such analysis can be done using CrossTable( ) function available in gmodels package, where the results are represented in a tabular format with rows indicating the levels of one variable and the columns indicating the levels of the other variable.

Kernlab
OCR reads various characters using key dimensions.
The typical machine has to be able to distinguish the letters accurately.
Image processing is perhaps one of the most difficult tasks involved considering the amount of noise present, the positioning and orientation and how the image gets captured.
Support Vector Machine(SVM) models finds extensive applications in pattern recognition fields as it is highly dexterous in learning the complex patterns efficiently.

Neuralnet
Artificial Neural Network Algorithms (ANN) often referred to as ‘deep learning’ can be practised through the ‘neuralnet’ package.
ANN builds a model based on the understanding of how the human brain works by establishing a relationship between the input and the output signals.

RODBC
If the data is stored in SQL databases (Oracle, MySQL) or ODBC(Open Database Connectivity) and needs to be converted into R data frame, then nothing can be as effective as RODBC package to import this data frame.

rpart
For building regression trees.
Regression is a concept which involves establish relationship between a single dependant variable and independent variable(s).Suppose, a product company needs to determine how it’s sales have been due to promotions on TV, Out of Home (OOH), Newspapers, Magazines etc.
The rpart package containing the rpart() function helps explain the variance in the dependant variable( eg.
sales) caused by the independent variables(TV ads, newspaper ads, magazines).

Tm
These days lots of statistical analysis requires thorough processing of text data, be it SMS’s or mails, which involves a lot of tedious efforts.
This kind of analysis might even require removing punctuation marks, numbers and certain unwanted words like ‘but’,’or’ etc.
depending upon the business requirement.
The tm package contains flexible functions like corpus( ) which can read from pdf’s and word documents, and convert the text data into R vector and tm_map() which helps in cleaning the text data( removing blanks, conversion from upper to lower and viceversa etc.), thereby making the data ready for analysis.

Wordcloud
The package ‘wordcloud’ helps to create a diagrammatic representation of words and a user can actually customize the ‘wordcloud’ such as place the high-frequency words closer together in the centre, arrange the words in a random fashion, specify the frequency of a particular word etc.
thereby etching a long lasting impression in anyone’s mind.
Data science is driving the AI market, with organizations looking to leverage AI capabilities for predictive modeling.
To leverage these capabilities, organizations need developers trained in developing Artificial intelligence applications using R.
Businesses all over the world are looking for smarter tools and applications that help them reduce efforts and maximize profits.

<h2>Packages for sending emails from R</h2>
Here are the R packages you can use for sending emails:
<a href="https://github.com/olafmersmann/sendmailR" target="_blank">sendmailR</a>	A portable solution for sending emails from R (contains a simple SMTP client)
<a href="https://cran.r-project.org/web/packages/mail/index.html" target="_blank">mail</a>	An easy to use package for sending emails from R
<a href="https://github.com/rpremraj/mailR" target="_blank">mailR</a>	A wrapper around Apache Commons Email for sending emails from R
<a href="https://github.com/rich-iannone/blastula" target="_blank">blastula</a>	A package for creating and sending HTML emails from R through an SMTP server or Mailgun API
<a href="https://cran.r-project.org/web/packages/blatr/index.html" target="_blank">blatr</a>	A wrapper around Blat – a Windows command line utility that sends emails via SMTP or posts to Usenet via NNTP
<a href="https://github.com/r-lib/gmailr" target="_blank">gmailR</a>	A package for sending emails via the Gmail’s RESTful API
<a href="https://cran.r-project.org/web/packages/IMmailgun/index.html" target="_blank">IMmailgun</a>	A package for sending emails via the Mailgun API
<a href="https://github.com/datawookie/emayili/" target="_blank">emayili</a>	A package for sending emails from R via an SMTP server
<a href="https://github.com/omegahat/RDCOMClient" target="_blank">RDCOMClient</a>	A Windows-specific package for sending emails in R from the Outlook app
<a href="https://github.com/ropenscilabs/ponyexpress" target="_blank">ponyexpress</a>	A package to automate email sending from R via Gmail (based on the gmailR package)
We won’t focus on all of them, but we will introduce the most common and convenient options.
<h3>Sending emails in R via SMTP</h3>
Whichever R package of the following you choose, keep in mind that you need to have an SMTP server to send emails. 
In our examples, we’ll be using Mailtrap, a service providing a fake SMTP server for testing. 
<h3>sendmailR </h3>
sendmailR can be used for sending all sorts of email notifications such as completed jobs and scheduled tasks. 
At the same time, you can distribute analytical results to stakeholders using this R package as well. 
sendmailR is mostly used for SMTP servers without authentication. 
That’s why we won’t use Mailtrap in the following examples. 

Let’s install the package first:
install.packages("sendmailR",repos="http://cran.r-project.org")
Next, we create a data structure called Server, which is a map with a single key value pair – key: smtpServer, value: smtp.example.io: 
Server&lt;-list(smtpServer= "smtp.example.io")

Now, let’s write a few R lines to send a simple email:
library(sendmailR)
from &lt;- sprintf("&lt;user@sender.com>","The Sender") # the sender’s name is an optional value
to &lt;- sprintf("&lt;user@recipient.com>")
subject &lt;- "Test email subject"
body &lt;- "Test email body"
sendmail(from,to,subject,body,control=list(smtpServer= "smtp.example.io"))

The following code sample is for sending an email to multiple recipients:
from &lt;- sprintf("&lt;user@sender.com>","The Sender")
to &lt;-sprintf(c("&lt;user@recipient.com>","&lt;user2@recipient.com>", "&lt;user3@recipient.com>")
subject &lt;- "Test email subject"
body &lt;- "Test email body"
sapply(to,function(x) sendmail(from,to=x,subject,body,control=list(smtpServer= "smtp.example.io"))

And now, let’s send an email with an attachment as well:
from &lt;- sprintf("&lt;user@sender.com>","The Sender")
to &lt;- sprintf("&lt;user@recipient.com>")
subject &lt;- "Test email subject"
body &lt;- "Test email body"
attachmentPath &lt;-"C:/.../Attachment.png"
attachmentObject &lt;-mime_part(x=attachmentPath,name=attachmentName)
bodyWithAttachment &lt;- list(body,attachmentObject)
sendmail(from,to,subject,bodyWithAttachment,control=list(smtpServer= "smtp.example.io"))

NB: To send emails with sendmailR, you may also need to configure your machine so it can send emails from your local host. 
We’ve covered this step in <a rel="noreferrer noopener" aria-label=" (opens in a new tab)" href="/blog/setup-smtp-server/" target="_blank">How To Set Up An SMTP Server</a>.
<h3>mailR</h3>
If you employ an authentication-based SMTP server, you’d better pick the mailR package. 
It’s a wrapper around Apache Commons Email, an email library built on top of the Java Mail API. 
Due to this, mailR has a dependency on the rJava package, a low-level interface to Java VM. 
This requires Java Runtime Environment to be installed. 
You can download it from <a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank">Oracle</a>. 
In case of problems with pointing to the right Java binary, refer to <a href="https://github.com/s-u/rJava/issues/151" target="_blank">this troubleshooting guide</a> on GitHub. 
In practice, this may cause a bit of trouble when deploying in some environments. 
Nevertheless, mailR is a rather popular solution to automate sending emails with the R that offers the following:
multiple recipients (Cc, Bcc, and ReplyTo)multiple attachments (both from the file system and URLs)HTML formatted emails 
Install the package:
install.packages("mailR",repos="http://cran.r-project.org")
Now, we can use the Mailtrap SMTP server that requires authentication to send an email:
library(mailR)
send.mail(from = "user@sender.com",
    to = "user@recipient.com",
    subject = "Test email subject",
    body = "Test emails body",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,
    send = TRUE)

Insert your Mailtrap credentials (user.name and passwd) and pick any SMTP port of 25, 465, 587, 2525.
Here is how to send an email to multiple recipients:
library(mailR)
send.mail(from = "user@sender.com",
    to = c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>"),
    cc = c("CC Recipient &lt;cc.user@recipient.com>"),
    bcc = c("BCC Recipient &lt;bcc.user@recipient.com>"),
    replyTo = c("Reply to Recipient &lt;reply-to@recipient.com>"),
    subject = "Test email subject",
    body = "Test emails body",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,
    send = TRUE)

Now, let’s add a few attachments to the email:
library(mailR)
send.mail(from = "user@sender.com",
    to = c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>"),
    cc = c("CC Recipient &lt;cc.user@recipient.com>"),
    bcc = c("BCC Recipient &lt;bcc.user@recipient.com>"),
    replyTo = c("Reply to Recipient &lt;reply-to@recipient.com>"),
    subject = "Test email subject",
    body = "Test emails body",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,
    send = TRUE,
    attach.files = c("./attachment.png", "https://dl.dropboxusercontent.com/u/123456/Attachment.pdf"),
    file.names = c("Attachment.png", "Attachment.pdf"), #this is an optional parameter
    file.descriptions = c("Description for Attachment.png", "Description for Attachment.pdf")) #this is an optional parameter
Eventually, let’s send an HTML email from R:
library(mailR)
send.mail(from = "user@sender.com",
    to = "user@recipient.com",
    subject = "Test email subject",
    body = "&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,
    send = TRUE)
You can also point to an HTML template by specifying its location, as follows:
body = "./Template.html",
<h3>blastula</h3>
The blastula package allows you to craft and send responsive HTML emails in R programming. 
We’ll review how to send emails via the SMTP server, however, blastula also supports the Mailgun API. 
Install the package:
install.packages("blastula",repos="http://cran.r-project.org")
and load it:
library(blastula)
Compose an email using Markdown formatting. 
You can also employ the following string objects:
add_readable_time – creates a nicely formatted date/time string for the current time 
add_image – transforms an image to an HTML string object
For example,
date_time &lt;- add_readable_time() # => "Thursday, November 28, 2019 at 4:34 PM (CET)"
img_file_path &lt;- "./attachment.png" # => "&lt;img cid=\"mtwhxvdnojpr__attachment.png\" src=\"data:image/png;base64,iVBORw0KG...g==\" width=\"520\" alt=\"\"/>\n"
img_string &lt;- add_image(file = img_file_path)

When composing an email, you will need the c() function to combine the strings in the email body and footer. 
You can use three main arguments: body, header, and footer. 
If you have Markdown and HTML fragments in the email body, use the md() function. 
Here is what we’ve got:
library(blastula)
email &lt;-
compose_email(
  body = md(
    c("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>",
img_string
      )
    ),
 footer = md(
    c(
      "Test email footer", date_time, "."
      )
  )
)
Preview the email using attach_connect_email(email = email)
Now, let’s send the email. 
This can be done with the smtp_send() function through one of the following ways:
Providing the SMTP credentials directly via the creds() helper: smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds(
    host = "smtp.mailtrap.io",
    port = 25,
    user = "********"
  )
)
Using a credentials key that you can generate with the create_smtp_creds_key() function: create_smtp_creds_key(
  id = "mailtrap",
  host = "smtp.mailtrap.io",
  port = 25,
  user = "********"
)
smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds_key("mailtrap")
)
Using a credentials file that you can generate with the create_smtp_creds_file() function:create_smtp_creds_file(
  file = "mailtrap_file",
  host = "smtp.mailtrap.io",
  port = 25,
  user = "********"
)
smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds_file("mailtrap_file")
)
NB: There is no way to programmatically specify a password for authentication. 
The user will be prompted to provide one during code execution.
<h3>emayili </h3>
emayili is the last package on our list for sending emails in R via SMTP. 
The package works with all SMTP servers and has minimal dependencies. 
Install it from GitHub and let’s move on:
install.packages("remotes")
library(remotes)
remotes::install_github("datawookie/emayili")
Emayili has two classes at the core:
envelope – to create emails server – to communicate with the SMTP server
Let’s create an email first:
library(emayili)
email &lt;- envelope() %>%
  from("user@sender.com") %>%
  to("user@recipient.com") %>%
  subject("Test email subject") %>%
  body("Test email body")
Now, configure the SMTP server:
smtp &lt;- server(host = "smtp.mailtrap.io",
         port = 25,
         username = "********",
         password = "*********")

To send the email to multiple recipients, enhance your emails with Cc, Bcc, and Reply-To header fields as follows:
email &lt;- envelope() %>%
  from("user@sender.com") %>%
  to(c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>")) %>%
  cc("cc@recipient.com") %>%
  bcc("bcc@recipient.com") %>%
  reply("reply-to@recipient.com") %>%
  subject("Test email subject") %>%
  body("Test email body")

You can also use the attachment() method to add attachments to your email:
email &lt;- email %>% attachment(c("./attachment.png", "https://dl.dropboxusercontent.com/u/123456/Attachment.pdf"))
Eventually, you can send your email with:
smtp(email, verbose = TRUE)
<h3>Sending emails via Gmail API – gmailR</h3>
Today, Gmail is one of the most popular email services. 
It provides RESTful API for a bunch of functionalities, such as:
send/receive HTML emails with attachmentsCRUD (create, read, update, and delete) operations with messages, drafts, threads, and labels access control of your Gmail inboxand so on
For sending emails from R via Gmail API, you need two things: the gmailR package and the API access. 
Let’s start with the latest, which requires four steps to be done:
Create a project in the Google API Console
Enable Gmail API
Set up credentials and authentication with OAuth 2.0
Download a JSON file with your credentialsWe’ve described all these steps in <a href="/blog/send-emails-with-gmail-api/" target="_blank" rel="noreferrer noopener" aria-label=" (opens in a new tab)">How to send emails with Gmail API</a>, so feel free to reference this blog post. 
After you’ve accomplished the preparation stage, get back to gmailR. 
The package is available on CRAN, so you can install, as follows:
install.packages("gmailr", repos="http://cran.r-project.org")
and load in your R script:
library(gmailr)
Now, you can use your downloaded JSON credentials file. 
Employ the use_secret_file() function. 
For example, if your JSON file is named GmailCredentials.json, this will look, as follows:
use_secret_file("GmailCredentials.json")
After that, create a MIME email object:
email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_text_body("Test email body")
To create an HTML email, use markup to shape your HTML string, for example:
email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>")
To add an attachment, you can:
use the gm_attach_file() function, if the attachment has not been loaded into R. 
You can specify the MIME type yourself using the type parameter or let it be automatically guessed by mime::guess_type
email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>") %>%
  gm_attach_file("Attachment.png")
use attach_part() to attach the binary data to your file:
email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>") %>%
  gm_attach_part(part = charToRaw("attach me!"), name = "please")
If you need to include an image into HTML, you can use the &lt;img class="lazy" data-src=”cid:xy”> tag to reference the image. 
First create a plot to send, and save it to AttachImage.png:
# 1. 
use built-in mtcars data set
my_data &lt;- mtcars
# 2. 
Open file for writing
png("AttachImage.png", width = 350, height = 350)
# 3. 
Create the plot
plot(x = my_data$wt, y = my_data$mpg,
  pch = 16, frame = FALSE,
  xlab = "wt", ylab = "mpg", col = "#2E9FDF")
# 4. 
Close the file
dev.off()
Now, create an HTML email that references the plot as foobar:
email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body(
    '&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>
    &lt;br>&lt;img class="lazy" data-src="cid:foobar">'
  ) %>%
  gm_attach_file("AttachImage.png", id = "foobar")
Eventually, you can send your email:
gm_send_message(email)
Enjoying this Post?Join Our NewsletterOnly the best content, delivered once a month. 
Unsubscribe anytime.</p><form class="hustle-layout-form" novalidate="novalidate"><label for="hustle-field-email-module-1" id="hustle-field-email-module-1-label" class="hustle-screen-reader">Your email address</label><input id="hustle-field-email-module-1" type="email" class="hustle-input " name="email" value="" aria-labelledby="hustle-field-email-module-1-label" data-validate="1" data-required-error="Your email is required." data-validation-error="Please enter a valid email.">Your Email<button class="hustle-button hustle-button-submit " aria-live="polite" data-loading-text="Form is being submitted, please wait a bit.">Submit</button><input type="hidden" name="hustle_module_id" value="1"><input type="hidden" name="post_id" value="2497"><input type="hidden" name="hustle_sub_type" value="shortcode"><label for="hustle-gdpr-module-1-1" class="hustle-checkbox hustle-gdpr "><input type="checkbox" name="gdpr" id="hustle-gdpr-module-1-1" data-required-error="Please accept the terms and try again.">I have read and agree with <a href="https://mailtrap.io/privacy/" target="_blank">Mailtrap's privacy policy</a>.</label></form>
<h3>Sending emails from Outlook – RDCOMClient</h3>
R has a package for sending emails from Microsoft Outlook as well. 
It’s called RDCOMClient and allows you to connect to DCOM architecture, which you can consider an API for communicating with Microsoft Office in Windows environments. 
Let’s explore how to connect R to the Outlook app installed on your Windows.
Install RDCOMClient via an option of your choice:
from CRAN:
install.packages("RDCOMClient")
via devtools:
devtools::install_github("omegahat/RDCOMClient")
from the Windows command line:
R CMD INSTALL RDCOMClient
Warning: if you receive a message like package ‘RDCOMClient’ is not available (for R version 3.5.1)” during the installation from CRAN, try to install RDCOMClient from the source repository:
install.packages("RDCOMClient", repos = "http://www.omegahat.net/R")
Load the package, open Outlook, and create a simple email:
library(RDCOMClient)
Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)
Email[["to"]] = "user@recipient.com"
Email[["subject"]] = "Test email subject"
Email[["body"]] = "Test email body"
If you need to change the default From: field and send from a secondary mailbox, use:
Email[["SentOnBehalfOfName"]] = "user@sender.com"
Here is how you can specify multiple recipients, as well as Cc and Bcc headers:
Email[["to"]] = "user1@recipient.com, user2@recipient.com"
Email[["cc"]] = "cc.user@recipient.com"
Email[["bcc"]] = "bcc.user@recipient.com"
To create an HTML email, use [["htmlbody"]]. 
You can simply add your HTML in the R code as follows:
library(RDCOMClient)
Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)
Email[["to"]] = "user@recipietn.com"
Email[["subject"]] = "Test email subject"
Email[["htmlbody"]] =
"&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>"
Let’s also add an attachment: 
library(RDCOMClient)
Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)
Email[["to"]] = "user@recipient.com"
Email[["subject"]] = "Test email subject"
Email[["htmlbody"]] =
"&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>"
Email[["attachments"]]$Add("C:/.../Attachment.png")
Now, you can send the email:
outMail$Send()
<h3>How to send bulk emails from R?</h3>
Let’s say your mail list includes many more than ten recipients and you need to send bulk emails from R. 
We’ll show you how this can be done via Web API (gmailR) and SMTP (mailR).
<h3>Bulk emails with gmailR</h3>
As an example, we’ll inform recipients of how much they won in the lottery. 
For this, we need:
an enabled API access on your Google account. an installed gmailr R package.a set of R packages for data iteration: readr, dplyr, and purrr (or plyr as an alternative).a file containing the variable bits (lottery wins), Variables.csv, with the following format:
lastname,firstname,win_amount,email_address
SMITH,JOHN,1234,johnsmith@winner.com
LOCKWOOD,JANE,1234,janelockwood24@example.com
Now, let’s go through the mail steps to create an R script for bulk emails.
Load the packages and files we need:
suppressPackageStartupMessages(library(gmailr))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(purrr))
library(readr) # => if you don’t have it, run: install.packages("readr", repos="http://cran.r-project.org")
my_dat &lt;- read_csv("Variables.csv") 
Create a data frame that will insert variables from the file into the email: 
this_hw &lt;- "Lottery Winners"
email_sender &lt;- 'Best Lottery Ever &lt;info@best-lottery-ever.com>'
optional_bcc &lt;- 'Anonymous &lt;bcc@example.com>'
body &lt;- "Hi, %s.
Your lottery win is %s.
Thanks for betting with us!
"
edat &lt;- my_dat %>%
    mutate(
        To = sprintf('%s &lt;%s>', firstname, email_address),
        Bcc = optional_bcc,
        From = email_sender,
        Subject = sprintf('Lottery win for %s', win_amount),
        body = sprintf(body, firstname, win_amount)) %>%
    select(To, Bcc, From, Subject, body)
write_csv(edat, "data-frame.csv")
The data frame will be saved to data-frame.csv. 
This will provide an easy-to-read record of the composed emails. 
Now, convert each row of the data frame into a MIME object using the gmailr::mime() function. 
After that, purrr::pmap() generates the list of MIME objects, one per row of the input data frame:
emails &lt;- edat %>%
  pmap(mime)
str(emails, max.level = 2, list.len = 2)
If you use plyr (install.packages("plyr")), you can do this, as follows:
emails &lt;- plyr::dlply(edat, ~ To, function(x) mime(
  To = x$To,
  Bcc = x$Bcc,
  From = x$From,
  Subject = x$Subject,
  body = x$body))
Specify your JSON credentials file:
use_secret_file("GmailCredentials.json")
And send emails with purrr::safely(). 
This will protect your bulk emails from failures in the middle:
safe_send_message &lt;- safely(send_message)
sent_mail &lt;- emails %>%
  map(safe_send_message)
saveRDS(sent_mail,
        paste(gsub("\\s+", "_", this_hw), "sent-emails.rds", sep = "_"))
List recipients with TRUE in case of errors:
errors &lt;- sent_mail %>%
  transpose() %>%
  .$error %>%
  map_lgl(Negate(is.null))
Take a look at the full code now:
suppressPackageStartupMessages(library(gmailr))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(purrr))
library(readr) # => if you don’t have it, run: install.packages("readr", repos="http://cran.r-project.org")
my_dat &lt;- read_csv("Variables.csv")
this_hw &lt;- "Lottery Winners"
email_sender &lt;- 'Best Lottery Ever &lt;info@best-lottery-ever.com>'
optional_bcc &lt;- 'Anonymous &lt;bcc@example.com>'
body &lt;- "Hi, %s.
Your lottery win is %s.
Thanks for betting with us!
"
edat &lt;- my_dat %>%
    mutate(
        To = sprintf('%s &lt;%s>', firstname, email_address),
        Bcc = optional_bcc,
        From = email_sender,
        Subject = sprintf('Lottery win for %s', win_amount),
        body = sprintf(body, firstname, win_amount)) %>%
    select(To, Bcc, From, Subject, body)
write_csv(edat, "data-frame.csv")
emails &lt;- edat %>%
  pmap(mime)
str(emails, max.level = 2, list.len = 2)
use_secret_file("GmailCredentials.json")
safe_send_message &lt;- safely(send_message)
sent_mail &lt;- emails %>%
  map(safe_send_message)
saveRDS(sent_mail,
        paste(gsub("\\s+", "_", this_hw), "sent-emails.rds", sep = "_"))
errors &lt;- sent_mail %>%
  transpose() %>%
  .$error %>%
  map_lgl(Negate(is.null))
<h3>Bulk emails with mailR</h3>
If you want to send bulk emails with SMTP, make sure to have an appropriate SMTP server and install the mailR package. 
Once again, we’ll need a .csv file that will contain the data frame you want to integrate into the email. 
The data should be separated by a special character such as a comma, a semicolon, or a tab9. 
For example:
lastname; firstname; win_amount; email_address
SMITH; JOHN; 1234; johnsmith@winner.com
LOCKWOOD; JANE; 1234; janelockwood24@example.com
What you need to do next:
Build the HTML email body for a given recipient using the message_text function:
message_text &lt;- function(x) sprintf('Hello %s %s!\nCongratulation to your win.\nYour prize is XXX.\nBet with the Best Lottery Ever!', x$firstname, x$lastname)
Load the package and read in the mail list:
library(mailR)
mail_list &lt;- read.csv2("Variables.csv",as.is=TRUE)
Values in the Variables.csv should be separated with a semicolon (;). 
You can configure settings to read the data frame using the read.table or read.csv functions.
Create a file to write the information of each individual row in the mail_list after each email is sent.
my_file &lt;- file("mail.out",open="w")
# … write data here
close(my_file)
Perform the batch emailing to all students in the mail list:
for (recipient in 1:nrow(mail_list)) {
  body &lt;- message_text(mail_list[recipient,])
  send.mail(from="info@best-lottery-ever.com",
    to=as.character(mail_list[recipient,]$email_address),
    subject="Lottery Winners",
    body=body,
    html=TRUE,
    authenticate=TRUE,
    smtp = list(host.name = "smtp.mailtrap.io",
    user.name = "*****", passwd = "*****", ssl = TRUE),
    encoding = "utf-8",send=TRUE)
  print(mail_list[recipient,])
  Sys.sleep(runif(n=1,min=3,max=6))
  #write each recipient to a file
  result_file &lt;- file("mail.out",open="a")
  writeLines(text=paste0("[",recipient,"] ",
    paste0(as.character(mail_list[recipient,]),collapse="\t")),
    sep="\n",con=result_file)
  close(result_file)
}
And here is the full code:
message_text &lt;- function(x) sprintf('Hello %s %s!\nCongratulation to your win.\nYour prize is XXX.\nBet with the Best Lottery Ever!', x$firstname, x$lastname)
library(mailR)
mail_list &lt;- read.csv2("Variables.csv",as.is=TRUE)
my_file &lt;- file("mail.out",open="w")
# … write data here
close(my_file)
for (recipient in 1:nrow(mail_list)) {
  body &lt;- message_text(mail_list[recipient,])
  send.mail(from="info@best-lottery-ever.com",
    to=as.character(mail_list[recipient,]$email_address),
    subject="Lottery Winners",
    body=body,
    html=TRUE,
    authenticate=TRUE,
    smtp = list(host.name = "smtp.mailtrap.io",
    user.name = "*****", passwd = "*****", ssl = TRUE),
    encoding = "utf-8",send=TRUE)
  print(mail_list[recipient,])
  Sys.sleep(runif(n=1,min=3,max=6))
  #write each recipient to a file
  result_file &lt;- file("mail.out",open="a")
  writeLines(text=paste0("[",recipient,"] ",
    paste0(as.character(mail_list[recipient,]),collapse="\t")),
    sep="\n",con=result_file)
  close(result_file)
}
<h3>How to test email sending in R with Mailtrap</h3>
If you choose to send emails from R via SMTP, then Mailtrap is what you need for testing. 
It’s a universal service with a fake SMTP server underneath. 
This means, your test emails are not actually being sent. 
They go from your app or any other mail client to the SMTP server and are trapped there. 
Thus, you protect your real recipients from an undesirable experience – they won’t receive any of your test emails. 
All the aforementioned examples with Mailtrap credentials work in this way. 
If you need to test anything else, just replace your SMTP credentials with those of Mailtrap and that’s it. 
For this, you need to <a aria-label=" (opens in a new tab)" rel="noreferrer noopener" href="/register/signup?ref=header" target="_blank">sign up</a> first using your email, GitHub or Google account. 
A FREE FOREVER plan is available! For more on the features and functions provided by Mailtrap, read the <a href="https://help.mailtrap.io/article/12-getting-started-guide">Getting Started Guide</a>.
<h3>To wrap up</h3>
We’ve listed a number of options for sending emails in R, so choose the one that best fits your requirements. 
For example, if you need to send hundreds (or even thousands) of emails daily, gmailR may be the best solution. 
On the other hand, sending via SMTP is a more common and reliable way and R provides a few packages for this. 
So, good luck with your choice!

<h2>forecast trends</h2>
FCH:=(FORCAST(H,period)+FORCAST(H,periodS))/2;
FCL:=(FORCAST(L,period)+FORCAST(L,periodS))/2;
FC:C-(FCH+FCL)/2,COLORYELLOW;
DH:=(H-FCH);
DL:=(L-FCL);
FA:(FC+DH+DL)/3,COLORCYAN;

FCDH:=FORCAST(DH,periodB);
FCDL:=FORCAST(DL,periodB);

FCD:(FCDH+FCDL)/2,COLORLICYAN;
FFCD:FORCAST(FCD,period2),COLORLIRED;

LCD:FORCAST(FCD,periodVL),COLORWHITE;
LLCD:FORCAST(FCD,periodVL*2),COLORGRAY;

FDH:FCD+STDP(FCDH,periodL1)*1.2,COLORGREEN,DOTLINE;
FDL:FCD-STDP(FCDL,periodL1)*1.2,COLORGREEN,DOTLINE;

<h2>locate the block header and block end</h2>
# grep the topic marks
# topicHead = grep("&lt;div class='topic'>", allYaofang)

# grep the topic end marks
# topicTail = grep("&lt;/div>", allYaofang)

headerHead = grep("&lt;h4>", allYaofang)

# grep the topic end marks
headerTail = headerHead[-1]  # remove the first head will shift to end mark
headerTail = headerTail -1   # move up one line is the block end
headerTail = c(headerTail,length(allYaofang)) # add the last one

# extract the topic name
# topicName = grep("&lt;h3>", allYaofang)

<h2>simple file server</h2>
<a href="https://github.com/yihui/servr" class="whitebut ">A simple HTTP server to serve files</a>

<a href="https://stackoverflow.com/questions/12636764/r-built-in-web-server" class="whitebut ">built-in-web-server</a>
Example code
writeLines("&lt;h1>Hi&lt;/H1>", "index.html")

# install.packages("servr")
library(servr)
servr::httd()

# createTcpServer: address already in use
# To stop the server, run servr::daemon_stop(2) or restart your R session
# Serving the directory /Users/st/R/localhost at http://127.0.0.1:7826


<h2>Stringr data manipulation Tips and Tricks</h2><h2>Stringr in r</h2>
Variety of functions available in stringr package but we are going cover only important functions in our day-to-day data analysis.

library(stringr)
<h3>1. Word Length</h3>
statement&lt;-c("R", "is powerful", "tool", "for data", "analysis")
Suppose if you want to find the length of each word, you can use str_length

statement
"R"           "is powerful" "tool"        "for data"    "analysis"
str_length(statement)
1 11  4  8  8
<h3>2. Concatnate</h3>
If you want to join the string str_c will be useful.

<a href="https://finnstats.com/index.php/2021/04/16/market-basket-analysis-in-r/" rel="nofollow" target="_blank">Market Basket Analysis in R » What Goes With What » </a>

str_c(statement,collapse=" ")
“R is powerful tool for data analysis”

str_c("test",1:10, sep="-")[1] "test-1"  "test-2"  "test-3"  "test-4"  "test-5"  "test-6"  "test-7"  "test-8"  "test-9"
[10] "test-10"
str_c("test",1:10, sep=",")
[1] "test,1"  "test,2"  "test,3"  "test,4"  "test,5"  "test,6"  "test,7"  "test,8"  "test,9"
[10] "test,10"
<h3>3. NA Replace</h3>
Now will see how to handle missing data’s

str_c(c("My Name", NA, "Jhon"),".")
"My Name." NA         "Jhon."
So you can see missing value is not concatenated. This we can overcome based on str_replace_na()

replace NA with . or character

str_replace_na(c("My Name", NA, "Jhon"),".")
"My Name" "."       "Jhon"
<h3>4. String Extraction</h3>
If you want to extract the substring then str_sub will be handy.

str_sub(statement,1,5)
"R"     "is po" "tool"  "for d" "analy"
Now you can see the first 5 characters extracted from the string vector.

<a href="https://finnstats.com/index.php/2021/04/19/decision-trees-in-r/" rel="nofollow" target="_blank">Decision Trees in R » Classification & Regression » </a>

If you know the length of the string you can update your string also.

str_sub(statement, 4,-1)&lt;-"Wow"
statement
"RWow"   "is Wow" "tooWow" "forWow" "anaWow"

<h3>5. Split</h3>
If you want to split the string based on pattern, str_split will be useful.

str_split(statement,pattern=" ")
[[1]]
[1] "RWow"
[[2]]
[1] "is"  "Wow"
[[3]]
[1] "tooWow"
[[4]]
[1] "forWow"
[[5]]
[1] "anaWow"
<h3>6. Subset</h3>
Suppose if you want to subset word in the particular pattern you can make use of str_subset

<a href="https://finnstats.com/index.php/2021/04/24/handling-missing-values-in-r/" rel="nofollow" target="_blank">Handling missing values in R Programming » </a>

str_subset(colors(),pattern="green")
[1] "darkgreen"         "darkolivegreen"    "darkolivegreen1"   "darkolivegreen2" 
 [5] "darkolivegreen3"   "darkolivegreen4"   "darkseagreen"      "darkseagreen1"   
 [9] "darkseagreen2"     "darkseagreen3"     "darkseagreen4"     "forestgreen"     
[13] "green"             "green1"            "green2"            "green3"          
[17] "green4"            "greenyellow"       "lawngreen"         "lightgreen"      
[21] "lightseagreen"     "limegreen"         "mediumseagreen"    "mediumspringgreen"
[25] "palegreen"         "palegreen1"        "palegreen2"        "palegreen3"      
[29] "palegreen4"        "seagreen"          "seagreen1"         "seagreen2"       
[33] "seagreen3"         "seagreen4"         "springgreen"       "springgreen1"    
[37] "springgreen2"      "springgreen3"      "springgreen4"      "yellowgreen"
If  you want to extract colors start with orange or end with red then ^$ will be helpful
str_subset(colors(),pattern="^orange|red$")
1] "darkred"         "indianred"       "mediumvioletred" "orange"          "orange1"      
 [6] "orange2"         "orange3"         "orange4"         "orangered"       "orangered1"    
[11] "orangered2"      "orangered3"      "orangered4"      "palevioletred"   "red"           
[16] "violetred"
^ indicate the starting of the string and $ indicate string ending with

If you want to extract characters or numbers from string str_extract will be useful

list&lt;-c("Hai1", "my 10", "Name 20")
str_extract(list,pattern="[a-z]")
“a” “m” “a”

If you want full word then you can use

str_extract(list,pattern="[a-z]+")
“ai”  “my”  “ame”

<h3>7. html view</h3>
If you want to see the html vie output then you can use str_view

<a href="https://finnstats.com/index.php/2021/05/05/stock-prediction/" rel="nofollow" target="_blank">Stock Prediction-Intraday Trading » With High Accuracy » </a>

str_view(statement,"a.")
Return first match in first string

<h3>9. Count</h3>
str_count for counting the character

str_count(statement,"[ae]")
0 0 0 0 2
<h3>9. Location</h3>
str_locate(statement,"[ae]")
start end
[1,]    NA  NA
[2,]    NA  NA
[3,]    NA  NA
[4,]    NA  NA
[5,]     1   1
str_locate will display the first match

<a href="https://finnstats.com/index.php/2021/05/17/filtering-data-in-r-tidyverse/" rel="nofollow" target="_blank">Filtering Data in R 10 Tips -tidyverse package »</a>

Filtering data
tbl <- read.table(file.choose(),header=TRUE,sep=',')
pop <- tbl[c("name","estimate","nochange")]
smallest.state.pop <- min(pop$estimate)
print(pop[pop$estimate==smallest.state.pop,])


<h3>10. Lower/Upper case</h3>
For lower case letters

str_to_lower(statement)
“rwow”   “is wow” “toowow” “forwow” “anawow”

str_to_upper(statement)
“RWOW”   “IS WOW” “TOOWOW” “FORWOW” “ANAWOW”

For case, the sensitive first letter in upper case and rest will be lower case

<a href="https://finnstats.com/index.php/2021/05/20/apply-family-in-r-lapply-sapply-mapply-tapply/" rel="nofollow" target="_blank">apply family in r apply(), lapply(), sapply(), mapply() and tapply() </a>

str_to_title(statement)
“Rwow”   “Is Wow” “Toowow” “Forwow” “Anawow”

?stringr and go to index you will get all stringr functions.


<h2>to log in to non-standard forms on a webpage</h2>
library(rvest)
url = "http://forum.axishistory.com/memberlist.php"
pgsession <- html_session(url)
pgform    <- html_form(pgsession)[[2]]
filled_form <- set_values(pgform, "username" = "username", 
                      "password" = "password")
submit_form(pgsession,filled_form)
memberlist <-  jump_to(pgsession, "http://forum.axishistory.com/memberlist.php")
page <-  html(memberlist)

usernames <-  html_nodes(x = page, css = "#memberlist .username") 

data_usernames <-  html_text(usernames, trim = TRUE) 

example again:

sc  <-  spark_connect(master = "local")

library(rvest) 
#Address of the login webpage
login <- "https://stackoverflow.com/users/login?ssrc=head&returnurl=http%3a%2f%2fstackoverflow.com%2f"

#create a web session with the desired login address
pgsession <- html_session(login)
pgform <- html_form(pgsession)[[2]]  #in this case the submit is the 2nd form
filled_form <- set_values(pgform, email="*****", password="*****")

submit_form(pgsession, filled_form)

# pre allocate the final results dataframe.
results <- data.frame()  

#loop through all of the pages with the desired info
for (i in 1:5)
{
  #base address of the pages to extract information from
  url <- "http://stackoverflow.com/users/**********?tab=answers&sort=activity&page="
  url <- paste0(url, i)
  page <- jump_to(pgsession, url)

  #collect info on the question votes and question title
  summary <- html_nodes(page, "div .answer-summary")
  question <- matrix(html_text(html_nodes(summary, "div"), trim=TRUE), ncol=2, byrow = TRUE)

  #find date answered, hyperlink and whether it was accepted
  dateans <- html_node(summary, "span") %>% html_attr("title")
  hyperlink <- html_node(summary, "div a") %>% html_attr("href")
  accepted <- html_node(summary, "div") %>% html_attr("class")

  #create temp results then bind to final results 
  rtemp <- cbind(question, dateans, accepted, hyperlink)
  results <- rbind(results, rtemp)
}

#Dataframe Clean-up
names(results) <- c("Votes", "Answer", "Date", "Accepted", "HyperLink")
results$Votes <- as.integer(as.character(results$Votes))
results$Accepted <- ifelse(results$Accepted=="answer-votes default", 0, 1)

<a href="https://rvest.tidyverse.org/reference/html_session.html" class="whitebut ">Simulate a session in web browser</a>

<h2>grep empty string ""</h2>
list = c("", "a", "b")
grep("^$", list)

<h2>R date, Sys.Date() and format function</h2>
date()
"Fri Aug 13 11:04:46 2021"

Sys.Date()
"2021-08-13"

format(Sys.Date(), format="%b %d %Y")
"å…«æœˆ 13 2021"
format(Sys.Date(), format="%y%b%d")
"218æœˆ13"
format(Sys.Date(), format="%y%m%d")
"210813"

Character to Date: dates <- as.Date("08/16/1975", "%m/%d/%Y")
Date to Character: as.character(dates)

<h2>speech to text</h2>
<a href="https://blog.pulipuli.info/2019/01/web-speech-to-text-speech-recognition.html" class="goldbut ">Speech recognition</a>
<a href="https://vac.muzychenko.net/en/usage.htm" class="goldbut ">Virtual Audio Cable</a>
<a href="https://www.youtube.com/watch?v=dGY9en_z5bQ&ab_channel=kfsoft" class="goldbut ">Python Speech recognition</a>
<a href="https://cran.r-project.org/web/packages/googleLanguageR/googleLanguageR.pdf" class="goldbut ">googleLanguageR</a>
<a href="https://github.com/ropensci/googleLanguageR/blob/master/R/speech-to-text.R" class="goldbut ">R speech to text</a>

<h2>shell.exec to open the file</h2>
shell.exec("\\\\network\\path\\file.bat")

The shell.exec command uses the Windows-associated application to open the file.
Note the double back-ticks.

Pro tip: write.csv(file='tmp.csv',tmpdat);
shell.exec('tmp.csv') is useful (assuming you've associated CSV files with your preferred application for viewing CSV files) for quickly checking output.

<h2>Crayon styles</h2>
General styles
reset, bold, blurred (usually called dim, renamed to avoid name clash)
italic (not widely supported)
underline, inverse, hidden, strikethrough (not widely supported)

Text colors
black, red, green, yellow, blue, magenta, cyan, white
silver (usually called gray, renamed to avoid name clash)

Background colors
bgBlack, bgRed, bgGreen, bgYellow, bgBlue, bgMagenta, bgCyan. bgWhite

Usage
The styling functions take any number of character vectors as arguments, and they concatenate and style them:

library(crayon)
cat(blue("Hello", "world!\n"))
Crayon defines the %+% string concatenation operator, to make it easy to assemble stings with different styles.

cat("... to highlight the " %+% red("search term") %+% " in a block of text\n")
Styles can be combined using the $ operator:

cat(yellow$bgMagenta$bold('Hello world!\n'))
Styles can also be nested, and then inner style takes precedence:

cat(green(
  'I am a green line ' %+%
  blue$underline$bold('with a blue substring') %+%
  ' that becomes green again!\n'
))
It is easy to define your own themes:

error <- red $ bold
warn <- magenta $ underline
note <- cyan
cat(error("Error: subscript out of bounds!\n"))
cat(warn("Warning: shorter argument was recycled.\n"))
cat(note("Note: no such directory.\n"))
256 colors
Most modern terminals support the ANSI standard for 256 colors, and you can define new styles that make use of them. The make_style function defines a new style. It can handle R's built in color names (see the output of colors()), and also RGB specifications, via the rbg() function. It automatically chooses the ANSI colors that are closest to the specified R and RGB colors, and it also has a fallback to terminals with 8 ANSI colors only.

ivory <- make_style("ivory")
bgMaroon <- make_style("maroon", bg = TRUE)
fancy <- combine_styles(ivory, bgMaroon)
cat(fancy("This will have some fancy colors"), "\n")

Installation
devtools::install_github("gaborcsardi/crayon")
library(crayon)

Styles can be combined using the $ operator:
cat(yellow$bgMagenta$bold('Hello world!\n'))

Styles can also be nested, and then inner style takes precedence:
cat(green(
  'I am a green line ' %+%
  blue$underline$bold('with a blue substring') %+%
  ' that becomes green again!\n'
))

to define your own themes:
error <- red $ bold
warn <- magenta $ underline
note <- cyan



<h2>convert categorical variables into numeric</h2>
data.matrix
converting all the variables in a data frame to numeric mode
Factors and ordered factors are replaced by their internal codes.

Example:
mydf <- data.frame(A = letters[1:5],
                   B = LETTERS[1:5],
                   C = month.abb[1:5],
                   D = 1:5)
data.matrix(mydf)
#      A B C D
# [1,] 1 1 3 1
# [2,] 2 2 2 2
# [3,] 3 3 4 3
# [4,] 4 4 1 4
# [5,] 5 5 5 5

use unclass() is the same: data.matrix(data.frame(unclass(mydf))) 

only to convert factors to numeric
mydf[sapply(mydf, is.factor)] <- data.matrix(mydf[sapply(mydf, is.factor)])

<h2>R and Javascript Execution, Libraries, Integration</h2>
For what reason somebody might want to incorporate R into web applications?

There are quite a few reasons for this. 
When you add R to your solution, a vast opportunity of analytics opens up like statistics, predictive data modelling, forecasting, machine learning, visualization and much more.

R is developed by statisticians, scientists or professional analysts using the script but the reports and the results generated by them on the desktop can be easily emailed or presented in the form of presentation, but that is limiting the business use and other potential uses.

If R is incorporated with JavaScript, then web delivery can happen smoothly, and it can help in making efficient business decision making. 
Integrating R into web application naturally becomes quintessential.

<h3>Integrate R into JavaScript</h3>
There can be various ways through which you can integrate R with JavaScript. 
Here I am discussing the following methods that I prefer for Rand Javascript integration.

<k>1. Deploy R open</k>
<a href="https://blog.revolutionanalytics.com/2014/10/integrate-r-into-applications-with-deployr-open.html" class="whitebut ">DeployR Open</a>
Through Deploy R opens you can easily embed results of various R functions like- data and charts into any application. 
This specific structure is an open source server-based system planned especially for R, which makes it simple to call the R code at a real time.
The workflow for this is simple: first, the programmer develops R script which is then published on the Deploy R server. 
The published R script that can be executed from any standard application using DeployR API. 
Using client libraries JavaScript now can make calls to the server. 
The results returned by the call can be embedded into the displayed or processed according to the application.
<k>2. Open CPU JavaScript API</k>
<a href="https://www.opencpu.org/jslib.html" class="whitebut ">opencpu.js</a>

This offers straightforward RPC and information input/Output through Ajax strategies that can be fused in JavaScript of your HTML page.
<h3>Visualization with R and JavaScript</h3>
You can make use of numerous JavaScript libraries that help in creating web functionality for dynamic data visualizations for R.
Here I will be elaborating some of those tools like D3, Highchart, and leaflet. 
You can quickly implement these tools in your R and program knowledge of JavaScript is not mandatory for this.
As I have already mentioned that R is an open source analytical software, it can create high dimensional data visualizations. 
Ggplot2 is a standout among the most downloaded bundle that has helped R to accomplish best quality level as a data visualization tool.
Javascript then again is a scripting dialect in which R can be consolidated to make data visualisation. 
Numerous javascript libraries can help in creating great intuitive plots, some of them are d3.Js, c3.js, vis.js, plotly.js, sigma.js, dygraphs.js.
HTM widgets act as a bridge between R and JavaScript. 
<a href="https://www.htmlwidgets.org/" class="whitebut ">htmlwidgets for R</a>
It is the principal support for building connectors between two languages. 
The flow of a program for HTM widgets r can be visualized as under:
• Information is perused into R
• Data is handled (and conceivably controlled) by R
• Data is changed over to JavaScript Object Notation (JSON) arrange
• Information is bound to JavaScript
• Information is prepared (and conceivably controlled) by JavaScript
• Information is mapped to plotting highlights and rendered
Now let us discuss some of the data visualization packages:
<k>• r d3 package</k>
Data-driven documents or d3 is one of the popular JavaScript visualization libraries. 
D3 can produce visualization for almost everything including choropleths, scatter plots, graphs, network visualizations and many more. 
Multiple R packages are using only D3 plotting methods. 
You can refer r d3 package tutorials to learn about this.
• <k>ggplot2</k> <br/> <br/> It is really very easy to create plots in R, but you may ask me whether it is same for creating custom plots, the answer is “yes”, and that is the primary motivation behind why ggplot came into existence. 
With ggplot, you can make complex multi-layered designs effectively.
Here you can start plotting with axes then add points and lines. 
But the only drawback that it has it is relatively slower than base R, and new developers might find it difficult to learn.
• <k>Leaflet</k>
The leaflet has found its profound use in GIS (mapping), this is an open source library. 
The R packages that backings this is composed and kept up by RStudio and ports. 
Using this developer can create pop up text, custom zoom levels, tiles, polygon, planning and many more.
The ggmap bundle of javaScript can be utilised for the estimation of the latitude and longitude.
• <k>Lattice</k>
Lattice helps in plotting visualized multivariate data. 
Here you can have tilled plots that help in comparing values or subgroups of a given variable. 
Here you will discover numerous lattice highlights has been acquired as utilizes grid package for its usage. 
The underlying logic used by lattice is very much similar to base R.
<k>• visNetwork</k>
For the graphical representation of nodes and edges, the visual network is referred. 
Vis.js is a standout amongst the most famous library among numerous that can do this sort of plotting. 
visNetwork is the related with R package for this.
Network plots ought to be finished remembering nodes and edges. 
For visNetwork, these two should be separated into two different data frames one for the nodes and the other
<k>• Highcarter</k>
This is another visualization tool which is very similar to D3. 
You can use this tool for a variety of plots like line, spline, arealinerange, column range, polar chart and many more. 
For the commercial use of Highcarter, you need to get a license while for the non-commercial you don’t need one.
Highcarter library can be accessed very easily using various chart () functions. 
Using this function, you can create a plot in a single task. 
This function is very much similar to qplot() of ggplot2 of D3. 
chart () can produce different types of scenarios depending on the data inputs and specifications.
<k>• RColor Brewer</k>
With this package, you can use color for your plots, graphs, and maps. 
This package works nicely with schemes.
<k>• Plotly</k>
It is a well distinguish podium for data visualization that works inordinately with R and Python notebook. 
It has similarity with the high career as both are known for interactive plotting. 
But here you get some extra as it offers something that most of the package don’t like contour plots, candlestick chart, and 3d charts.
• <k>SunTrust</k>
It is the way for representing data visualization as it nicely describes the sequence of events. 
The diagram that it produces speaks about itself. 
You don’t need an explanation for the chart as it is self-explanatory.
• <k>RGL</k>
For creating three-dimensional plots in R you should check out RGL. 
It has comparability with lattice, and on the off chance that you are an accomplished R developer you will think that its simple.
<k>• Threejs</k>
This is an R package and an HTML widget that helps in incorporating several data visualization from the JavaScript library.
Some of the visualization function three are as follows:
• Graphjs: this is used for implementing 3D interactive data visualization. 
This function accepts igraph as the first argument. 
This manages definition for nodes and edges.
• Scatterplot3js: this function is used for creating three dimensional scatter plot.
• Globejs: this function of JavaScript is used for plotting surface maps and data points on earth.
• <k>Shiny</k>
The most significant benefit of JavaScript visualization is it can be implanted voluntarily into the web application. 
They can be injected into several frameworks, one of such context of R development is shiny.
Shiny is created and maintained by R Studio. 
It is a <a href="https://www.cuelogic.com/custom-software-development" target="_blank" rel="noopener noreferrer ugc">software application development</a> instrument, to a great extent employed for making wise interfaces with R. 
R shiny tutorial will take in more about shiny.
Shiny is a podium for facilitating R web development.
Connecting R with javascript using libraries
Web scuffling has formed into an original piece of examination as through this movement you can pucker your required information. 
But the data should be extracted before any web developer start to insert javascript render content into the web page. 
To help in such situation R has an excellent package called V8 which acts as an interface to JavaScript. 
R v8 is the most generally utilized capacity utilized for interfacing r in javascript. 
You can undoubtedly implement JS code in R without parting the current session. 
The library function used for this is rvest().
To run the JavaScript in R, we need a context handler, within that context handler you can start programming. 
Then you can export the R data into JavaScript.
Some other JavaScript libraries that help in analytical programming such as Linear Regression, SVMs etc. 
are as follows:
• Brain.js()
• Mljs
• Webdnn
• Convnetjs
<h3>Conclusion:</h3>
R and Javascript can practically unlock innumerable possibility in Data Science and Analytics. 
Both technologies are working towards developing better integrations, knowledge repositories, libraries and use cases. 
It is a good time to use both of this together. 
The future looks bright.


<h2>Tutorial 1: R talks to JavaScript</h2>
<h3>1.1 Basic framework</h3>
<h3>Introduction</h3>
In this tutorial, we go through a simple example of interacting with JavaScript(JS) in R. 

To create an app, you will need a html file to display your app along with some JS to specify how the app behaves. 
And since we want to do all this in R, we also need R.
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/setup.png">
Diagram 1: JS-R app setup

To make R talk to JS, you need three functions:


<code>ws.send(str0)</code>(“ws” stands for “websocket”): this command lives in JS, and it sends a string to R every time it’s called. 
The common usage is <code>ws.send(JSON.stringify(my_complex_data))</code>, where we convert the (JSON) data into a string using <code>JSON.stringify</code>; this function applies to all lists in JS.

<code>ws.onmessage(msg) = function { ... }</code>: this function lives in JS. 
It continuously monitors if R has sent JS a message, and it runs the code in the body when it gets a message. 

The message contains many things other than your data, and we can use <code>JSON.parse(msg.data)</code> to extract the data from it.

Your R function (well, clearly) lives in R. 
It describes what R should do when JS sends R some data. 
The input is assumed to be a named list, and the output must also be a named list.

The following is a common pattern to use. 
It is very flexible; in fact, all examples in the package are created under this framework. 
Additional patterns can be created, but we shall leave that to another tutorial.
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/basic_framework.png">

Diagram 2: JS-R communication model
<h3>Two simple examples</h3>
<h4>Example 1</h4>

JavaScript

<code>ws.send("hi");
ws.onmessage = function(msg) {
  var r_data = JSON.parse(msg.data);
  console.log(r_data['r_msg']);   // this prints the message in JS console
}</code>

R
<code>my_r_function &lt;- function(msg) {
  print(msg)  # this will print the message in R console
  list(r_msg = msg)  # return the message to JS
}</code>

<h4>Example 2</h4>

JavaScript
<code>ws.send("JSON.stringify({x:3, y:4})");    // sends a named list in JS to R
ws.onmessage = function(msg) {
  var r_data = JSON.parse(msg.data);
  console.log(r_data['r_msg'], r_data['z']);   // this prints the message in JS console
}</code>


R
<code>my_r_function &lt;- function(msg) {
  print(msg)   # this will print the message in R console
  print(msg$x) # expects 3
  print(msg$y) # expects 4
  list(r_msg = msg, z = rnorm(1))  # return the message to JS
}</code>

<h3>1.2 Our first app</h3>
Now we are ready to create our first app, which looks like this:
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/gif_images/example.gif" style="width:50.0%">
The goal is to get ourselves familiar with the JS-R communication model and the whole app development process. 
The full code can be found <a href="https://github.com/kcf-jackson/jsReact/blob/master/inst/example.R">here</a>.

<h3>1.2.1 App interface</h3>
First, let’s inspect the interface.
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/app_interface.png" style="width:50.0%">
Two comments to make:

To create a slider, you need to specify these three attributes: <code>min, max, oninput</code>. 
<code>min, max</code> refers to the minimum and maximum value the slider can take; <code>oninput</code> refers to a function which describes the desired behaviour when the slider is moved.

In html, most things are just containers with different defaults. 
Containers are referred to as <code>&lt;div></code> elements.

<h3>1.2.2 Code</h3>
Next, let’s decompose and analyse the codes.
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/codes.png" style="width:80.0%">
# Example 1. This file explores the basic mechanism for R and JS to interact.
rm(list = ls())
library(jsReact)
library(magrittr)
my_html <- create_html() %>%
  add_title("Send message") %>%
  add_slider(min = "Q", max = "100", oninput = "Show_value(value)") %>%
  add_title("Receive message") %>%
  add_div(id = "output")
my_html %<>% add_script(
  "function show_value(value) {
     ws.send(value) ;
   }
   ws.onmessage = function(msg) {
     document .getELementById("output").innerHTML = msg.data;
   }")
write_html_to_file(my_html, file = "inst/sample.htm1")
r_fun <- function(msg) { print(msg) }
my_app <- create_appC"inst/sample.htmL", r_fun, insert_socket = T)
start_app(my_app)

The code is divided into four sections: Html, JS, R and others. 

Thanks to the <code>jsReact</code> package, the code can be developed entirely in R. 
Though as you get more experienced and the app gets more complicated, it is preferable to create the html, js and R files separately. 
(Side note: this is where beginners, e.g. me, got tripped up, and this is partly why I created this package.)

<h4>Html</h4>
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/html.png" style="width:80.0%">

The code is fairly self-explanatory. 
You create a empty html (<code>create_html</code>), add a title (<code>add_title</code>), a slider(<code>add_slider</code>) and another title, then add a container (<code>add_div</code>).


We give the container an <code>id</code> as later we want to refer to it and update its content.
<h4>Javascript</h4>
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/javascript.png" style="width:80.0%">

<code>show_value(value)</code> takes the slider value and send the value to R.

<code>ws.onmessage(msg)</code> takes a message from R and display it on the <code>&lt;div></code> container we created previously. 
<code>document.getElementById("_ID_")</code> is the easiest way to refer to a particular element in a html file. 
We will use that quite often.

In JS, both <code>function NAME(ARG) {...}</code> and <code>NAME = function(ARG) {...}</code> are valid ways to create functions.

<h4>R function</h4>
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/r.png" style="width:80.0%">

This R function prints the message it gets from the JS side (which is the slider value in our case).
<h4>Others</h4>
<img class="lazy" data-src="https://kcf-jackson.github.io/jsReact/articles/articles/example_1_images/others2.png" style="width:80.0%">
<code>write_html_to_file</code>, <code>create_app</code> and <code>start_app</code> are three functions from the <code>jsReact</code> package that helps you build and run an app.

<code>write_html_to_file</code> writes the html object we created in the previous section to hard-drive. 
This is not needed if you supply your own html file.


<code>create_app</code> links the html and the R function you provided (using the model presented in Diagram 2) and creates an app object. 
<code>insert_socket</code> is by default <code>TRUE</code>; you could set it to <code>FALSE</code> if you are not doing any R processing.

<code>start_app</code> launches a R server to serve your website. 
By default, the address is set to “localhost:9454”, and the website is shown in your viewer. 

You can use the option <code>browser = "browser"</code> to open the app with your browser instead.
<h3>1.3 Summary</h3>
In this tutorial, we went through how to interact with JavaScript in R. 
The package <code>jsReact</code> setups a simple framework for this, and the three key functions to know are:


<code>ws.send(str0)</code>, <code>ws.onmessage(msg)</code> and <code>your_r_function(named_list0) { named_list1 }</code>.
Along the way, we have also learnt about some useful functions for apps development:

for building the html interface, we have <code>jsReact::add_title, jsReact::add_slider, jsReact::add_div</code>;

for JavaScript, we have <code>document.getElementById('_ID_')</code>;

for running the app, we have <code>jsReact::write_html_to_file(), jsReact::create_app(), jsReact::start_app()</code>.
I hope you successfully created an app in R, and I shall see you in the next tutorial!
https://kcf-jackson.github.io/jsReact/articles/index.html


<h2>start_app</h2>
<a href="https://rdrr.io/github/r-lib/cli/man/start_app.html" class="whitebut ">start_app, creates an app, and places it on the top of the app stack</a>
Install the latest version of this package by entering the following in R:
install.packages("remotes")
remotes::install_github("r-lib/cli")
<a href="https://rdrr.io/github/r-lib/cli/api/" class="whitebut ">API for r-lib/cli, Helpers for Developing Command Line Interfaces</a>


<h2>JavaScript OpenCPU client library</h2>
&lt;!-- OpenCPU client library -->
&lt;script src="//code.jquery.com/jquery-1.11.1.min.js">&lt;/script>
&lt;script src="//cdn.opencpu.org/opencpu-0.4.js">&lt;/script>

<h3>About the Library</h3>
The <a href="https://github.com/jeroenooms/opencpu.js">opencpu.js</a> JavaScript client library builds on <a target="_blank" href="http://jquery.com">jQuery</a> to provide Ajax wrappers for calling R from within a web page. The library works on all modern browsers, and lays the foundations for building scalable R web applications.
<h4>Apps<small><em> â€” develop, ship and deploy standalone R web applications</em></small></h4>
The opencpu.js library is primarly designed for developing apps. An app is an R package which includes web page(s) that call R functions in the package through the OpenCPU API. Thereby you can easily package, ship and deploy portable, standalone R web applications. A repository of public OpenCPU apps is available at <a href="http://github.com/opencpu" target="_blank">http://github.com/opencpu</a>. Because apps are simply R packages, they are installed just like any other R package:

<code>#install apps: 'stocks', 'markdownapp' and 'nabel'
library(devtools)
install_github(c("stocks", "markdownapp", "nabel"), username="opencpu")</code>
By convention, the web pages are placed in the <code>/inst/www/</code> directory in the R package. To use an app locally, simply start the opencpu single-user server:

<code>library(opencpu)
opencpu$browse("/library/stocks/www")
opencpu$browse("/library/nabel/www")</code>
The same apps can be installed and accessed on a cloud server by navigating to <code>/ocpu/library/[pkgname]/www/</code>:


<a href="https://cloud.opencpu.org/ocpu/library/stocks/www" target="_blank">https://cloud.opencpu.org/ocpu/library/stocks/www</a>

<a href="https://cloud.opencpu.org/ocpu/library/markdownapp/www" target="_blank">https://cloud.opencpu.org/ocpu/library/markdownapp/www</a>

<a href="https://cloud.opencpu.org/ocpu/library/nabel/www" target="_blank">https://cloud.opencpu.org/ocpu/library/nabel/www</a>
One app in the public repository is called <a href="https://cloud.opencpu.org/ocpu/library/appdemo/www">appdemo</a>. This application contains some minimal examples to demonstrate basic functionality and help you get started with building apps using <code>opencpu.js</code>.

<h4>OpenCPU and jQuery<small><em>  â€” loading the libraries</em></small></h4>
The latest version of <code>opencpu.js</code> is available from github: <a href="https://github.com/jeroenooms/opencpu.js">https://github.com/jeroenooms/opencpu.js</a>. The jQuery library must be included in your web page <k>before</k> opencpu.js, because one depends on the other. Your application code must be included <k>after</k> opencpu.js.
<code>&lt;script src="js/jquery.js">&lt;/script>
&lt;script src="js/opencpu.js">&lt;/script>

&lt;script src="js/app.js">&lt;/script></code>
It is recommended to ship a copy of the <code>opencpu.js</code> library with your application or website (as opposed to hotlinking it from some public location). This because the JavaScript library is in active development (0.x version) and the latest version might (radically) change from time to time. Shipping a version of <code>opencpu.js</code> with your app prevents it from breaking with upstream changes in the library. Also it is practical both for development and deployment if your app works offline.
Most functions in opencpu.js call out to <code>$.ajax</code> and return the <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a> object. Thereby you (the programmer) have full control over the request. Note that the A in Ajax stands for <k>asynchronous</k>, which means each ajax request returns immediately. Server responses are processed using <k>callback functions</k>. This paradigm can be a bit confusing to R users, but it results in flexible, non-blocking applications. If you are new to jQuery, at least familiarize yourself with the <code>jqXHR.done</code>, <code>jqXHR.fail</code> and <code>jqXHR.always</code> methods (see <a href="http://api.jquery.com/jQuery.ajax/#jqXHR">jqXHR</a>). 
<h4>CORS<small><em>  â€” cross-domain opencpu requests</em></small></h4>

The recommended design for OpenCPU apps is to include the web pages in the R package. This results in a standalone application, which is easy to distribute and deploy and can also be used offline. Furthermore, it guarantees that the version of front-end and R code are in sync, and the package manager automatically takes care of dependencies when the app is installed on a server. 
However it is also possible to use the <code>opencpu.js</code> library from an external site that is not hosted on OpenCPU. In this case, we must specify the external OpenCPU server using <code>ocpu.seturl()</code>:
<code>//set page to communicate to with "mypackage" on server below
ocpu.seturl("//cloud.opencpu.org/ocpu/library/mypackage/R")</code>

Cross domain requests are convenient for development and illustrative examples, see e.g: <a href="http://jsfiddle.net/user/opencpu/fiddles/">jsfiddle examples</a>. However, when possible it is still recommended to include a copy of your web pages in the R package for every release of your app. That way you get a nice redistributable app and there is no ambiguity over version compatibility of the front-end (web pages) and back-end (R functions). 
Also note that even when using CORS, the <code>opencpu.js</code> library still requires that all R functions used by a certain application are contained in a single R package. This is on purpose, to force you to keep things organized. If you would like to use functionality from various R packages, you need to create an R package that includes some wrapper functions and formally declares its dependencies on the other packages. Writing an R package is really easy these days, so this should be no problem. 
<h4>JSfiddle<small><em>  â€” fiddle around with some examples</em></small></h4>
Since OpenCPU now supports CORS, and so do all major browsers, we started using JSfiddle to illustrate how to use the library. The <a href="http://jsfiddle.net/user/opencpu/fiddles/">opencpu jsfiddle</a> homepage lists all our fiddles, and we will keep adding new examples. Many of these examples are actually referenced and explained in this manual page. But if this is all tl;dr, just <a href="http://jsfiddle.net/user/opencpu/fiddles/">start playing</a>.

<h3>Stateless functions</h3>
This chapter describes two high-level functions that are used to call R functions that generate either a plot or return some data. They are easy to use because they directly take the output from the R function; no session management is required.
 <!-- Default panel contents -->
<h4>The Plot Widget <small><em>  â€” generate an R plot in a div</em></small></h4>

  
<h3><tt>$("#mydiv").rplot( fun, [, args ] [, callback ]) Returns: <a target="_blank" href="http://api.jquery.com/jQuery.ajax/#jqXHR"><code>jqXHR</code></a> </tt></h3>
  
  

  <k>fun</k> <tt>(string)</tt> <br>Name of the R function <em>(required)</em> <hr>
  <k>args</k> <tt>(object)</tt> <br>Function arguments. <hr>
  <k>callback</k> <tt>(function)</tt> <br>Callback function. Not needed for plot widget. Called with session object.
  

A fun an easy way to get started is by making plots. The <code>opencpu.js</code> library implements a jquery plugin called <code>rplot</code> which makes it easy to embed live plots in your webpage. For example, consider the R function <a href="http://cloud.opencpu.org/ocpu/library/stocks/R/smoothplot">smoothplot</a> in the <a href="http://github.com/opencpu/stocks">stocks package</a>:
<code>#The R function
function(ticker = "GOOG", from = "2013-01-01", to=Sys.time()){
  mydata &lt;- yahoodata(ticker, from, to);

  qplot(Date, Close, data = mydata, geom = c("line", "smooth"));
}</code>
It defines three arguments, each of which optional: <code>ticker</code>, <code>from</code>, and <code>to</code>. These are the arguments that we can pass from the <code>opencpu.js</code> client app. In this example, we only pass the first two arguments.
<code>//JavaScript client code

var ticker = $("#ticker").val();
var req = $("#plotdiv").rplot("smoothplot", {
ticker : ticker,
from : "2013-01-01"

})
//optional: add custom callbacks
req.fail(function(){
alert("R returned an error: " + req.responseText);

});</code>
This creates a plot widget in the <code>#plotdiv</code> element (a div in your html). It calls the R function <code>smoothplot</code> and passes argument values as specified, and displays the generated plot including PNG, PDF, and SVG export links. The final lines specify an error handler, which is optional but recommended. Have a look at the <a href="http://jsfiddle.net/opencpu/MkAVF/">jsfiddle</a>, or the full <a href="https://cloud.opencpu.org/ocpu/library/stocks/www/">stocks app</a> to see all of this in action!
<!-- Default panel contents -->
<h4>Basic JSON RPC <small><em>  â€” a.k.a Data Processing Unit</em></small></h4>

  
<h3><tt>ocpu.rpc( fun, [, args ] [, complete ] ) Returns: <a target="_blank" href="http://api.jquery.com/jQuery.ajax/#jqXHR"><code>jqXHR</code></a> </tt></h3>
  
  

  <k>fun</k> <tt>(string)</tt> <br>Name of the R function <em>(required)</em> <hr>
  <k>args</k> <tt>(object)</tt> <br>Function arguments. <hr>
  <k>complete</k> <tt>(function)</tt> <br>Callback function. Is called only on success with one arg: R function return value.
  

With opencpu.js we can use R as a remote calculator. Consider the very simple example of calculating the standard deviation for a vector of numbers. In this case we call the default R function sd in the stats package
<code>var mydata = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
//call R function: stats::sd(x=data)
var req = ocpu.rpc("sd",{

x : mydata
}, function(output){
alert("Standard Deviation equals: " + output);
});

//optional
req.fail(function(){
alert("R returned an error: " + req.responseText);
});</code>

See it in action <a href="http://jsfiddle.net/opencpu/T3cqH/">here</a>. When calling <code>ocpu.rpc</code>, the arguments as well as return value are transferred using JSON. On the R side, the <code>jsonlite</code> package is used to convert between JSON and R objects. Hence, the above code is equivalent to the R code below. The <code>output</code> object is a JSON string which is sent back to the client and parsed by JavaScript.
<code>library(jsonlite)
#parse input from JSON into R
jsoninput &lt;- '{"x" : [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]}'

fnargs &lt;- fromJSON(jsoninput)
#the actual function call
result &lt;- do.call(stats::sd, fnargs)
#convert result back to JSON

jsonoutput &lt;- toJSON(result)</code>
Another example is available here: <a href="http://jsfiddle.net/opencpu/9nVd5/">http://jsfiddle.net/opencpu/9nVd5/</a>. This example calls the <code>lowess</code> function in R, to smooth a bunch of values. This can be useful to remove outliers from noisy data. One difference with the previous example, is that <code>lowess</code> does not return a single value, but a list with two vectors: <code>x</code> and <code>y</code>. See the lowess help page for more detail.
<h3>Calls and Sessions</h3>
The stateless functions are convenient for applications with a single R function call and a single output (either a plot or the function return value). However, other applications might require more sophisticated interaction with the R session. This section section talks about stateful applications; i.e. the client creates and manipulates objects on the server. Therefore, the difference with before is that calling functions (POST) is decoupled from retrieving output (GET).

<!-- Default panel contents -->
<h4>State in OpenCPU<small><em>  â€” managing sessions</em></small></h4>
Management of state in OpenCPU is quite different from what R users are used to, which can be confusing at first. In OpenCPU, the client does <k>not</k> have a single private R process on the server which handles all incoming requests, such as in e.g. Shiny or in an R terminal session. Instead, OpenCPU is plain HTTP, and therefore each requests is anonymous and <em>stateless</em>. After every function call, OpenCPU cleans (or kills) the R process that was used to handle the request. 
 However, all outputs of every function call, such as return value, graphics, stdout or files in working directory, are stored on the server, and a <k>session ID</k> is returned to the client. These session IDs can be used to control these outputs on the server in future requests. For example, a client can retrieve outputs in various formats, share them with others, or use stored R objects as arguments in subsequent function calls. Hence to build a <em>statefull</em> application, there is no point in assigning objects to the global environment. Instead, we need to design R functions to return the value of interest. This way the client can call the function, and use its return value in subsequent function calls. 

This design has several advantages that are important for scalable applications:


Non blocking: everything is async, your GUI won't block while waiting for R to return.

Robustness: if an R call gets stuck, errors or crashes, it doesn't take down your application.


Concurrency: applications are parallel by design. Clients can perform simultaneous requests and combine results later.

<!-- Default panel contents -->
<h4>Call an R function <small><em>  â€” decouple call from output</em></small></h4>

 <h3><tt>ocpu.call( fun, [, args ] [, callback ] ) Returns: <a target="_blank" href="http://api.jquery.com/jQuery.ajax/#jqXHR"><code>jqXHR</code></a> </tt></h3>
<k>fun</k> <tt>(string)</tt> <br>Name of the R function <em>(required)</em> <hr>
<k>args</k> <tt>(object)</tt> <br>Function arguments. <hr>
<k>callback</k> <tt>(function)</tt> <br>Callback function. 1 argument: Session object.

  
The <code>ocpu.call</code> function is the stateful equivalent of <code>ocpu.rpc</code>. It has the same arguments, but the difference is in the callback function. The <code>ocpu.rpc</code> callback argument is a JSON object containing the data returned by the R function. The <code>ocpu.call</code> callback argument is a <em>Session object</em>. The session object is a javascript class that stores the session ID; it does not contain any actual data. However, from the session object, we can asynchronously retrieve data, plots, files, stdout, etc. See <a href="http://jsfiddle.net/opencpu/tmqab/">this jsfiddle</a> in action.
<code>//toy example
var req = ocpu.call("rnorm", {n: 100}, function(session){

//read the session properties (just for fun)
$("#key").text(session.getKey());
$("#location").text(session.getLoc());
//retrieve session console (stdout) async

session.getConsole(function(outtxt){
    $("#output").text(outtxt);
});
//retrieve the returned object async

session.getObject(function(data){
    //data is the object returned by the R function
    alert("Array of length " + data.length + ".\nFirst few values:" + data.slice(0,3));
});

})</code>
We can also use the Session object to pass the R value returned by the function call as an argument to a subsequent function call, without ever retrieving the object. All state in OpenCPU is managed by controlling R objects in sessions on the server. This <a href="http://jsfiddle.net/opencpu/ecwbd/">jsfiddle example</a> continues on the previous example, and calculates the variance of the vector generated before, by passing the session object as an argument. A more simple example <a href="http://jsfiddle.net/opencpu/mH52T/">here</a>
<code>var req1 = ocpu.call("rnorm", {n: 100}, function(session1){
var req2 = ocpu.call("var", {x : session1}, function(session2){

    session2.getObject(function(data){
        alert("Variance equals: " + data);
    });
});

});</code>
<!-- Default panel contents -->
<h4>Argument Types <small><em>  â€” passing data to opencpu</em></small></h4>
In <code>opencpu.js</code> there are 4 types of arguments: a basic JavaScript value/object (automatically converted to R via JSON), a session object (represents an R value from a previous function call), a file and a code snippet. We have already seen examples the first two argument types earlier. Below is an example of using a file as an argument. The file will automatically be uploaded and used to call the R function. See it in action using <a href="http://jsfiddle.net/opencpu/5Rqcm/">this jsfiddle</a>.

<code>//This must be HTML5 &lt;input type="file">
var myfile = $("#csvfile")[0].files[0];
var header = true;
//call read.csv in R. File is automatically uploaded

var req = ocpu.call("read.csv", {
"file" : myfile,
"header" : myheader
}, function(session){

//use output here
});</code>
The final type of argument is a code snippet. This injects raw R code into the function call. It is usually recommended to use this type only when really needed, because it requires the client to understand R code, which kills interoperability. But this argument type is useful for example in applications that explicitly let the user do some R coding. See <a href="http://jsfiddle.net/opencpu/4dgdM/">here</a> for a basic example: 
<code>//create snippet argument

var x = new ocpu.Snippet($("#input").val());
//perform the request
var req = ocpu.call("mean", {
"x" : x

}, function(session){
//use output here
});</code>
One interesting special case is using a code Snippet when calling the <code>identity</code> function in R. This comes down to executing a raw block of code in a session. Try <a href="http://jsfiddle.net/opencpu/v42v3/">this jsfiddle</a> to see this in action.

   
<!-- Default panel contents -->
<h4>The Session Object <small><em>  â€” controlling objects, plots, files, etc</em></small></h4>
The callback argument for <code>ocpu.call()</code> is always a session object. This object does not contain actual data, it just holds a sessoin ID and which can be used to retrieve output from the server. All session objects have the following methods:

 <h3><tt>session.getKey() Returns: string </tt></h3>
Read the session ID. For debugging only.
  
 <h3><tt>session.getLoc() Returns: string </tt></h3>
Read the session URL. For debugging only.
  
 <h3><tt>session.getFileURL( path ) Returns: string </tt></h3>
<k>path</k> <tt>(string)</tt> <br>Path of the file w.r.t. working directory. <em>(required)</em>

  
The methods below initiate an ajax request and return the jqXHR object. A callback is required to process output.
 <h3><tt>session.getObject( [ name ] [, data ] [, success ]) Returns: jqXHR </tt></h3>
<k>name</k> <tt>(string)</tt> <br>Name of the object. Usually not required. Defaults to .val which means the function return value. <hr>

<k>data</k> <tt>(object)</tt> <br>Arguments for the /json output format. <hr>
<k>success</k> <tt>(function)</tt> <br>Callback argument: function return data.
  
 <h3><tt>session.getConsole( [ success ] ) Returns: jqXHR </tt></h3>
<k>success</k> <tt>(function)</tt> <br>Callback argument: session console text.
  
 <h3><tt>session.getStdout( [ success ] ) Returns: jqXHR </tt></h3>
<k>success</k> <tt>(function)</tt> <br>Callback argument: session stdout text.

  
 <h3><tt>session.getFile( path [, success ] ) Returns: jqXHR </tt></h3>
<k>path</k> <tt>(string)</tt> <br>Path of the file w.r.t. working directory. <em>(required)</em>  <hr>
<k>success</k> <tt>(function)</tt> <br>Callback argument: file content.


<a href="https://www.datacamp.com/community/tutorials/scraping-javascript-generated-data-with-r" class="whitebut ">Scraping Javascript Generated Data with R</a>

<a href="https://subscription.packtpub.com/book/application-development/9781786468949/1/ch01lvl1sec9/building-an-html-and-javascript-chat-client" class="whitebut ">Building an HTML and JavaScript chat client</a>

<a href="https://community.rstudio.com/t/communication-between-r-and-javascript-works-on-laptop-but-not-after-deployment/71090" class="whitebut ">Communication between R and javascript works on laptop but not after deployment</a>

# Use `devtools` to install directly from github
library(devtools)
install_github("Microsoft/deployrUtils")

Working with deployR, there is a package named deployrUtils which already has the deployrPackage function to load and install the package (if not present)

library(deployrUtils)
deployrPackage("XLConnect")


<a href="https://github.com/yihui/servr" class="whitebut ">servr A simple HTTP server</a>

library(ggplot2)
library(plotly)
p <- ggplot(data = diamonds, aes(x = cut, fill = clarity)) +
            geom_bar(position = "dodge")
ggplotly(p)


<h2>reactR</h2>
<a href="https://github.com/react-R/reactR" class="whitebut ">reactR, a set of functions for using React in R with htmlwidget constructor templates</a>

install.packages("devtools")
devtools::install_github("react-R/reactR")

<h2>to calculate mode</h2>
R does not have a standard in-built function to calculate mode. 

p = c(132,132,133,134,135,136,136,137,137,138,138,138,139,139,139,140,140,141,141,142,142,142,142,142,143,143,143,144,144,144,144,144,144,144,145,145,145,145,145,145,145,145,146,146,146,146,146,147,148,148,148,148,148,148,148,149,149,149,149,149,151,151,151,152,152,152,152,152,154,154,154,155,156,156,157,157,158,158,158,159)

# Create the function.
getmode <- function(v) {
   uniqv <- unique(v) # find the unique catagories
   uniqv[which.max(tabulate(match(v, uniqv)))] # find max freq
}
mode = getmode(p)

Frequency Distributions
table(p)

Scatterplots
plot the frequency distributions
plot(table(p))

Histograms
hist(table(p))


<h2>The yarrr package (0.0.8)</h2>
Great news R pirates! The yarrr package, which contains the pirateplot, has now been updated to version 0.0.8 and is up on CRAN (after hiding in plain sight on GitHub). Let&#8217;s install the latest version (0.0.8) and go over some of the updates:
install.packages("yarrr")  # Install package from CRAN
library("yarrr") # Load the package!

The most important function in the yarrr package is pirateplot(). What the heck is a pirateplot? A pirateplot is a modern way of visualising the relationship between a categorical independent variable, and a continuous dependent variable. Unlike traditional plotting methods, like barplots and boxplots, a pirateplot is an RDI plotting trifecta which presents Raw data (all data as points), Descriptive statistics (as a horizontal line at the mean &#8212; or any other function you wish), and Inferential statistics (95% Bayesian Highest Density Intervals, and smoothed densities).
<img class="lazy" data-src="https://i1.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/pirateplot-elements.png" target="_blank">
For a full guide to the package, check out the package guide at CRAN 
<a href="https://cran.r-project.org/web/packages/yarrr/vignettes/guide.html" onclick="_gaq.push(['_trackEvent', 'outbound-article', 'https://cran.r-project.org/web/packages/yarrr/vignettes/guide.html', 'here']);" ref="nofollow" target="_blank">here</a>.
For now, here are some examples of pirateplots showing off some the package updates.
<h3>Up to 3 IVs</h3>
You can now include up to three independent variables in your pirateplot. The first IV is presented as adjacent beans, the second is presented in different groups of beans in the same plot, and the third IV is shown in separate plots.
Here is a pirateplot of the heights of pirates based on three separate IVs: headband (whether the pirate wears a headband or not), sex, and eyepatch (whether the pirate wears an eye patch or not):

pirateplot(formula = height ~ sex + headband + eyepatch,
  point.o = .1,  data = pirates)
<img class="lazy" data-src="https://i2.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/threeivpp-1.png">
Here, we can see that male pirates tend to be the tallest, but there there doesn&#8217;t seem to be a difference between those who wear headbands or not, and those who have eye patches or not.

<h3>New color palettes</h3>
The updated package has a few fun new color palettes contained in the piratepal() function. The first, called &#8216;xmen&#8217;, is inspired by my 90s Saturday morning cartoon nostalgia. 
# Display the xmen palette
piratepal(palette = "xmen",  trans = .1, # Slightly transparent colors     plot.result = TRUE)

<img class="lazy" data-src="https://i2.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/xmen_display-1.png">
Here, I&#8217;ll use the xmen palette to plot the distribution of the weights of chickens over time (if someone has a more suitable dataset for the xmen palette let me know!):
pirateplot(formula = weight ~ Time,       data = ChickWeight,       main = "Weights of chickens by Time",      pal = "xmen",       gl.col = "gray")
mtext(text = "Using the xmen palette!",  side = 3,  font = 3)

mtext(text = "*The mean and variance of chicken\nweights tend to increase over time.",  side = 1,  adj = 1, line = 3.5, font = 3, cex = .7)
<img class="lazy" data-src="https://i0.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/xmen_chikens.png">
The second palette called &#8220;pony&#8221; is inspired by the Bronys in our IT department.
# Display the pony palette
piratepal(palette = "pony",  trans = .1, # Slightly transparent colors     plot.result = TRUE)
<img class="lazy" data-src="https://i0.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/pony_image.png">
Here, I&#8217;ll plot the distribution of the lengths of movies as a function of their MPAA ratings (where G is for suitable for children, and R is suitable for adults)
pirateplot(formula= time ~ rating,       data = subset(movies, time > 0 & rating %in% c("G", "PG", "PG-13", "R")),       pal = "pony",       point.o = .05,       bean.o = 1,       main = "Movie times by rating",       bean.lwd = 2,       gl.col = "gray")

mtext(text = "Using the pony palette!",  side = 3,  font = 3)
mtext(text = "*Movies rated for children\n(G and PG) tend to be longer \nthan those rated for adults",  side = 1,  adj = 1, font = 3, line = 3.5, cex = .7)
<img class="lazy" data-src="https://i2.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/pony_times.png">
To see all of the palettes (including those inspired by movies and a transit map of Basel), just run the function with &#8220;all&#8221; as the main argument

piratepal(palette = "all")
Of course, if you find that these color palettes give you a headache, you can always set the plot to grayscale (or any other color), by specifying a single color in the palette argument. Here, I&#8217;ll create a grayscale pirateplot showing the distribution of movie budgets by their creative type:
pirateplot(formula = budget ~ creative.type,       data = subset(movies, budget > 0 &                     creative.type %in% c("Multiple Creative Types", "Factual") == FALSE),      point.o = .02,      xlab = "Movie Creative Type",      main = "Movie budgets (in millions) by rating",      gl.col = "gray",      pal = "black")
mtext("Using a grayscale pirateplot",  side = 3,  font = 3)

mtext("*Superhero movies tend to have the highest budgets\n...by far!",  side = 1, adj = 1, line = 3,  cex = .8, font = 3)
<img class="lazy" data-src="https://i2.wp.com/nathanieldphillips.com/wp-content/uploads/2016/10/moviebudgetpp.png">
Looks like super hero movies have the highest budgets&#8230;by far!
<h3>Acknowledgements and Comments</h3>
The pirateplot is largely inspired by the great beanplot package (
<a href = "https://cran.r-project.org/web/packages/beanplot/index.html">beanplot package link</a>)
Bayesian 95% HDIs are calculated using the truly amazing BayesFactor package (
<a href = "https://cran.r-project.org/web/packages/BayesFactor/index.html">BayesFactor package link)</a>
The latest developer version of yarrr is always available at 
<a href = "https://github.com/ndphillips/yarrr">https://github.com/ndphillips/yarrr</a>. Please post any bugs, issues, or feature requests at 
<a href = "https://github.com/ndphillips/yarrr/issues">https://github.com/ndphillips/yarrr/issues</a>


<h2>How to Send an Email in R</h2>
<div id="emailtoc" class="toc">1 <a href="#emailtopic-1" target="_self">Packages for sending emails from R</a><br>2 <a href="#emailtopic-2" target="_self">Sending emails in R via SMTP</a><br>3 <a href="#emailtopic-3" target="_self">sendmailR</a><br>4 <a href="#emailtopic-4" target="_self">mailR</a><br>5 <a href="#emailtopic-5" target="_self">blastula</a><br>6 <a href="#emailtopic-6" target="_self">emayili</a><br>7 <a href="#emailtopic-7" target="_self">Sending emails via Gmail API – gmailR</a><br>8 <a href="#emailtopic-8" target="_self">Sending emails from Outlook – RDCOMClient</a><br>9 <a href="#emailtopic-9" target="_self">How to send bulk emails from R?</a><br>10 <a href="#emailtopic-10" target="_self">Bulk emails with gmailR</a><br>11 <a href="#emailtopic-11" target="_self">Bulk emails with mailR</a><br>12 <a href="#emailtopic-12" target="_self">How to test email sending in R with Mailtrap</a><br>13 <a href="#emailtopic-13" target="_self">To wrap up</a><br>14 <a href="#emailtopic-14" target="_self">Sending emails via Gmail API – gmailR</a><br>15 <a href="#emailtopic-15" target="_self">Gmail API – why you should consider using it</a><br>16 <a href="#emailtopic-16" target="_self">Resource types and methods</a><br>17 <a href="#emailtopic-17" target="_self">How to make your app send emails with Gmail API</a><br>18 <a href="#emailtopic-18" target="_self">Step 1: Create a project at Google API Console</a><br>19 <a href="#emailtopic-19" target="_self">Step 2: Enable Gmail API</a><br>20 <a href="#emailtopic-20" target="_self">Step 3: Credentials and authentication with OAuth 2.0</a><br>21 <a href="#emailtopic-21" target="_self">Step 4: Pick a quickstart guide&nbsp;</a><br>22 <a href="#emailtopic-22" target="_self">Step 5: API client library</a><br>23 <a href="#emailtopic-23" target="_self">Step 6: Access to Gmail</a><br>24 <a href="#emailtopic-24" target="_self">Step 7: Create an email</a><br>25 <a href="#emailtopic-25" target="_self">Step 8: Send an email</a><br>26 <a href="#emailtopic-26" target="_self">Step 8.1: Send an email with attachments</a><br>27 <a href="#emailtopic-27" target="_self">Step 9: Read a specific email from your inbox</a><br>28 <a href="#emailtopic-28" target="_self">Why is Gmail API better or worse than traditional SMTP?&nbsp;</a><br>29 <a href="#emailtopic-29" target="_self">Email protocol used</a><br>30 <a href="#emailtopic-30" target="_self">How are emails sent?</a><br>31 <a href="#emailtopic-31" target="_self">Authentication</a><br>32 <a href="#emailtopic-32" target="_self">Quota</a><br>33 <a href="#emailtopic-33" target="_self">SMTP or API?</a><br>34 <a href="#emailtopic-34" target="_self"><span class="orange">Send Emails with Gmail API</span></a><br>35 <a href="#emailtopic-35" target="_self">Gmail API – why you should consider using it</a><br>36 <a href="#emailtopic-36" target="_self">Resource types and methods</a><br>37 <a href="#emailtopic-37" target="_self">How to make your app send emails with Gmail API</a><br>38 <a href="#emailtopic-38" target="_self">Step 1: Create a project at Google API Console</a><br>39 <a href="#emailtopic-39" target="_self">Step 2: Enable Gmail API</a><br>40 <a href="#emailtopic-40" target="_self">Step 3: Credentials and authentication with OAuth 2.0</a><br>41 <a href="#emailtopic-41" target="_self">Step 4: Pick a quickstart guide&nbsp;</a><br>42 <a href="#emailtopic-42" target="_self">Step 5: API client library</a><br>43 <a href="#emailtopic-43" target="_self">Step 6: Access to Gmail</a><br>44 <a href="#emailtopic-44" target="_self">Step 7: Create an email</a><br>45 <a href="#emailtopic-45" target="_self">Step 8: Send an email</a><br>46 <a href="#emailtopic-46" target="_self">Step 8.1: Send an email with attachments</a><br>47 <a href="#emailtopic-47" target="_self">Step 9: Read a specific email from your inbox</a><br>48 <a href="#emailtopic-48" target="_self">Why is Gmail API better or worse than traditional SMTP?&nbsp;</a><br>49 <a href="#emailtopic-49" target="_self">Email protocol used</a><br>50 <a href="#emailtopic-50" target="_self">How are emails sent?</a><br>51 <a href="#emailtopic-51" target="_self">Authentication</a><br>52 <a href="#emailtopic-52" target="_self">Quota</a><br>53 <a href="#emailtopic-53" target="_self">SMTP or API?</a><br></div></center>
<br>
R is a powerful solution to deal with statistics-heavy projects and explore datasets. 
It can be used for UX monitoring, data-based predictions, and much more. 
Some say the R programming language can do everything and we’re not going to disprove such a bold claim. 

What we’re interested in is how you can share the results of your R-based analysis with different stakeholders. 
Of all possible channels for this, email is the most common one. 
So, let’s explore multiple ways of how to send an email with R.
<h3 id="emailtopic-1">Packages for sending emails from R</h3>
Here are the R packages you can use for sending emails:<br>
<table><tbody><tr><td><k>Package</k></td><td><k>Description</k></td><td><k>Latest version</k></td><td><k>Dependency</k></td></tr><tr><td><a href="https://github.com/olafmersmann/sendmailR" target="_blank"><k>sendmailR</k></a></td><td>A portable solution for sending emails from R (contains <br>a simple SMTP client).</td><td>1.2-1</td><td>R 3.0.0+</td></tr><tr><td><a href="https://cran.r-project.org/web/packages/mail/index.html" target="_blank"><k>mail</k></a></td><td>An easy to use package for sending emails from R.</td><td>1.0</td><td>R 2.0.0+</td></tr><tr><td><a href="https://github.com/rpremraj/mailR" target="_blank"><k>mailR</k></a></td><td>A wrapper around Apache Commons Email for sending <br>emails from R.</td><td>0.6</td><td>N/A</td></tr><tr><td><a href="https://github.com/rich-iannone/blastula" target="_blank"><k>blastula</k></a></td><td>A package for creating and sending HTML emails from R <br>through an SMTP server or Mailgun API.</td><td>0.2.1<br></td><td>R 3.2.1+</td></tr><tr><td><a href="https://cran.r-project.org/web/packages/blatr/index.html" target="_blank"><k>blatr</k></a></td><td>A wrapper around Blat – a Windows command line utility <br>that sends emails <br>via SMTP or posts to Usenet via NNTP. http://www.blat.net/</td><td>1.0.1</td><td>N/A</td></tr><tr><td><a href="https://github.com/r-lib/gmailr" target="_blank"><k>gmailR</k></a></td><td>A package for sending emails via the Gmail’s RESTful API.</td><td>1.0.0</td><td>R 3.0.0+</td></tr><tr><td><a href="https://cran.r-project.org/web/packages/IMmailgun/index.html" target="_blank"><k>IMmailgun</k></a></td><td>A package for sending emails via the Mailgun API.</td><td>0.1.2</td><td>N/A</td></tr><tr><td><a href="https://github.com/datawookie/emayili/" target="_blank"><k>emayili</k></a></td><td>A package for sending emails from R via an SMTP server.</td><td>0.1.1</td><td>N/A</td></tr><tr><td><a href="https://github.com/omegahat/RDCOMClient" target="_blank"><k>RDCOMClient</k></a></td><td>A Windows-specific package for sending emails in R from <br>the Outlook app.</td><td>0.94-0</td><td>N/A</td></tr><tr><td><a href="https://github.com/ropenscilabs/ponyexpress" target="_blank"><k>ponyexpress</k></a></td><td>A package to automate email sending from R via Gmail <br>(based on the gmailR package).</td><td>N/A</td><td>N/A</td></tr></tbody></table>
We won’t focus on all of them, but we will introduce the most common and convenient options.
<h3 id="emailtopic-2">Sending emails in R via SMTP</h3>
Whichever R package of the following you choose, keep in mind that you need to have an SMTP server to send emails. 
In our examples, we’ll be using Mailtrap, a service providing a fake SMTP server for testing. 
<h3 id="emailtopic-3">sendmailR</h3>
<k>sendmailR</k> can be used for sending all sorts of email notifications such as completed jobs and scheduled tasks. 

At the same time, you can distribute analytical results to stakeholders using this R package as well. 
sendmailR is mostly used for SMTP servers without authentication. 
That’s why we won’t use Mailtrap in the following examples. 
Let’s install the package first:

<code>install.packages("sendmailR",repos="http://cran.r-project.org")</code>
Next, we create a data structure called Server, which is a map with a single key value pair – key: <code>smtpServer</code>, value: <code>smtp.example.io</code>: 
<code>Server&lt;-list(smtpServer= "smtp.example.io")</code>
Now, let’s write a few R lines to send a simple email:

<code>library(sendmailR)
from &lt;- sprintf("&lt;user@sender.com>","The Sender") # the sender’s name is an optional value
to &lt;- sprintf("&lt;user@recipient.com>")
subject &lt;- "Test email subject"

body &lt;- "Test email body"
sendmail(from,to,subject,body,control=list(smtpServer= "smtp.example.io"))</code>
The following code sample is for sending an email to multiple recipients:
<code>from &lt;- sprintf("&lt;user@sender.com>","The Sender")

to &lt;-sprintf(c("&lt;user@recipient.com>","&lt;user2@recipient.com>", "&lt;user3@recipient.com>")
subject &lt;- "Test email subject"
body &lt;- "Test email body"
sapply(to,function(x) sendmail(from,to=x,subject,body,control=list(smtpServer= "smtp.example.io"))</code>

And now, let’s send an email with an attachment as well:
<code>from &lt;- sprintf("&lt;user@sender.com>","The Sender")
to &lt;- sprintf("&lt;user@recipient.com>")
subject &lt;- "Test email subject"

body &lt;- "Test email body"
attachmentPath &lt;-"C:/.../Attachment.png"
attachmentObject &lt;-mime_part(x=attachmentPath,name=attachmentName)
bodyWithAttachment &lt;- list(body,attachmentObject)

sendmail(from,to,subject,bodyWithAttachment,control=list(smtpServer= "smtp.example.io"))</code>
<em>NB: To send emails with </em><k><em>sendmailR</em></k><em>, you may also need to configure your machine so it can send emails from your local host. 
We’ve covered this step in </em><a href="https://mailtrap.io/blog/setup-smtp-server/" target="_blank"><em>How To Set Up An SMTP Server</em></a><em>.</em>
<h3 id="emailtopic-4">mailR</h3>
If you employ an authentication-based SMTP server, you’d better pick the <k>mailR </k>package. 
It’s a wrapper around Apache Commons Email, an email library built on top of the Java Mail API. 
Due to this, <k>mailR</k> has a dependency on the rJava package, a low-level interface to Java VM. 
This requires Java Runtime Environment to be installed. 

You can download it from <a href="https://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html" target="_blank">Oracle</a>. 
In case of problems with pointing to the right Java binary, refer to <a href="https://github.com/s-u/rJava/issues/151" target="_blank">this troubleshooting guide</a> on GitHub. 
In practice, this may cause a bit of trouble when deploying in some environments. 
Nevertheless, mailR is a rather popular solution to automate sending emails with the R that offers the following:


multiple recipients (Cc, Bcc, and ReplyTo)
multiple attachments (both from the file system and URLs)
HTML formatted emails
Install the package:
<code>install.packages("mailR",repos="http://cran.r-project.org")</code>
Now, we can use the Mailtrap SMTP server that requires authentication to send an email:

<code>library(mailR)
send.mail(from = "user@sender.com",
    to = "user@recipient.com",
    subject = "Test email subject",

    body = "Test emails body",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),

    authenticate = TRUE,
    send = TRUE)</code>
Insert your Mailtrap credentials (<code>user.name</code> and <code>passwd</code>) and pick any SMTP port of 25, 465, 587, 2525.
Here is how to send an email to multiple recipients:

<code>library(mailR)
send.mail(from = "user@sender.com",
    to = c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>"),
    cc = c("CC Recipient &lt;cc.user@recipient.com>"),

    bcc = c("BCC Recipient &lt;bcc.user@recipient.com>"),
    replyTo = c("Reply to Recipient &lt;reply-to@recipient.com>"),
    subject = "Test email subject",
    body = "Test emails body",

    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,

    send = TRUE)</code>
Now, let’s add a few attachments to the email:
<code>library(mailR)
send.mail(from = "user@sender.com",

    to = c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>"),
    cc = c("CC Recipient &lt;cc.user@recipient.com>"),
    bcc = c("BCC Recipient &lt;bcc.user@recipient.com>"),
    replyTo = c("Reply to Recipient &lt;reply-to@recipient.com>"),

    subject = "Test email subject",
    body = "Test emails body",
    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",

          passwd = "******", ssl = TRUE),
    authenticate = TRUE,
    send = TRUE,
    attach.files = c("./attachment.png", "https://dl.dropboxusercontent.com/u/123456/Attachment.pdf"),

    file.names = c("Attachment.png", "Attachment.pdf"), #this is an optional parameter
    file.descriptions = c("Description for Attachment.png", "Description for Attachment.pdf")) #this is an optional parameter</code>
Eventually, let’s send an HTML email from R:
<code>library(mailR)

send.mail(from = "user@sender.com",
    to = "user@recipient.com",
    subject = "Test email subject",
    body = "&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>",

    smtp = list(host.name = "smtp.mailtrap.io", port = 25,
          user.name = "********",
          passwd = "******", ssl = TRUE),
    authenticate = TRUE,

    send = TRUE)</code>
You can also point to an HTML template by specifying its location, as follows:
<code>body = "./Template.html",</code>
<h3 id="emailtopic-5">blastula</h3>
The <k>blastula</k> package allows you to craft and send responsive HTML emails in R programming. 
We’ll review how to send emails via the SMTP server, however, <k>blastula </k>also supports the Mailgun API.
Install the package:
<code>install.packages("blastula",repos="http://cran.r-project.org")</code>

and load it:
<code>library(blastula)</code>
Compose an email using Markdown formatting. 
You can also employ the following string objects:


<code>add_readable_time</code> – creates a nicely formatted date/time string for the current time

<code>add_image</code> – transforms an image to an HTML string object
For example,
<code>date_time &lt;- add_readable_time() # => "Thursday, November 28, 2019 at 4:34 PM (CET)"

img_file_path &lt;- "./attachment.png" # => "&lt;img cid=\"mtwhxvdnojpr__attachment.png\" src=\"data:image/png;base64,iVBORw0KG...g==\" width=\"520\" alt=\"\"/>\n"
img_string &lt;- add_image(file = img_file_path)</code>
When composing an email, you will need the <code>c()</code> function to combine the strings in the email body and footer.
You can use three main arguments: <code>body</code>, <code>header</code>, and <code>footer</code>. 

If you have Markdown and HTML fragments in the email body, use the <code>md()</code> function. 
Here is what we’ve got:
<code>library(blastula)
email &lt;-
compose_email(
  body = md(
    c("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>", img_string )
    ),
 footer = md(
    c("Test email footer", date_time, "." )
  )
)</code>

Preview the email using <code>attach_connect_email(email = email)</code>
Now, let’s send the email. 
This can be done with the <code>smtp_send()</code> function through one of the following ways:

Providing the SMTP credentials directly via the <code>creds()</code> helper:
<code>smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds(
    host = "smtp.mailtrap.io",
    port = 25,
    user = "********"
  )
)</code>

Using a credentials key that you can generate with the <code>create_smtp_creds_key()</code> function:<code>create_smtp_creds_key(
  id = "mailtrap",
  host = "smtp.mailtrap.io",
  port = 25,
  user = "********"
)
smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds_key("mailtrap")
)</code>

Using a credentials file that you can generate with the <code>create_smtp_creds_file()</code> function:
<code>create_smtp_creds_file(
  file = "mailtrap_file",
  host = "smtp.mailtrap.io",
  port = 25,
  user = "********"
)
smtp_send(
  email = email,
  from = "user@sender.com",
  to = "user@recipient.com",
  credentials = creds_file("mailtrap_file")
)</code>

<em>NB: There is no way to programmatically specify a password for authentication. 
The user will be prompted to provide one during code execution.</em>
<h3 id="emailtopic-6">emayili</h3>
<k>emayili </k>is the last package on our list for sending emails in R via SMTP. 

The package works with all SMTP servers and has minimal dependencies. 
Install it from GitHub and let’s move on:
<code>install.packages("remotes")
library(remotes)
remotes::install_github("datawookie/emayili")</code>
Emayili has two classes at the core:

<code>envelope</code> – to create emails
<code>server</code> – to communicate with the SMTP server
Let’s create an email first:

<code>library(emayili)
email &lt;- envelope() %>%
  from("user@sender.com") %>%
  to("user@recipient.com") %>%
  subject("Test email subject") %>%
  body("Test email body")</code>
Now, configure the SMTP server:
<code>smtp &lt;- server(host = "smtp.mailtrap.io",
         port = 25,
         username = "********",
         password = "*********")</code>
To send the email to multiple recipients, enhance your emails with Cc, Bcc, and Reply-To header fields as follows:

<code>email &lt;- envelope() %>%
  from("user@sender.com") %>%
  to(c("Recipient 1 &lt;user1@recipient.com>", "Recipient 2 &lt;user@recipient.com>")) %>%
  cc("cc@recipient.com") %>%
  bcc("bcc@recipient.com") %>%
  reply("reply-to@recipient.com") %>%
  subject("Test email subject") %>%
  body("Test email body")</code>

You can also use the <code>attachment()</code> method to add attachments to your email:
<code>email &lt;- email %>% attachment(c("./attachment.png", "https://dl.dropboxusercontent.com/u/123456/Attachment.pdf"))</code>
Eventually, you can send your email with:
<code>smtp(email, verbose = TRUE)</code>

<h3 id="emailtopic-7">Sending emails via Gmail API – gmailR</h3>
Today, Gmail is one of the most popular email services. 
It provides RESTful API for a bunch of functionalities, such as:

send/receive HTML emails with attachments
CRUD (create, read, update, and delete) operations with messages, drafts, threads, and labels
access control of your Gmail inbox
and so on

For sending emails from R via Gmail API, you need two things: the <k>gmailR</k> package and the API access. 
Let’s start with the latest, which requires four steps to be done:

Create a project in the Google API Console
Enable Gmail API
Set up credentials and authentication with OAuth 2.0
Download a JSON file with your credentialsWe’ve described all these steps in <a href="https://mailtrap.io/blog/send-emails-with-gmail-api/" target="_blank">How to send emails with Gmail API</a>, so feel free to reference this blog post. 

After you’ve accomplished the preparation stage, get back to <k>gmailR</k>. 
The package is available on CRAN, so you can install, as follows:
<code>install.packages("gmailr", repos="http://cran.r-project.org")</code>
and load in your R script:

<code>library(gmailr)</code>
Now, you can use your downloaded JSON credentials file. 
Employ the <code>use_secret_file()</code> function. 
For example, if your JSON file is named <em>GmailCredentials.json</em>, this will look, as follows:

<code>use_secret_file("GmailCredentials.json")</code>
After that, create a MIME email object:
<code>email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_text_body("Test email body")</code>
To create an HTML email, use markup to shape your HTML string, for example:

<code>email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>")</code>
To add an attachment, you can:

use the <code>gm_attach_file()</code> function, if the attachment has not been loaded into R. 
You can specify the MIME type yourself using the type parameter or let it be automatically guessed by <code>mime::guess_type</code>

<code>email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>") %>%
  gm_attach_file("Attachment.png")</code>

use <code>attach_part()</code> to attach the binary data to your file:
<code>email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%
  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body("&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>") %>%

  gm_attach_part(part = charToRaw("attach me!"), name = "please")</code>
If you need to include an image into HTML, you can use the <code>&lt;img class="lazy" data-src=”cid:xy”></code> tag to reference the image. 
First create a plot to send, and save it to <em>AttachImage.png</em>:
<code># 1. 

use built-in mtcars data set
my_data &lt;- mtcars
# 2. 
Open file for writing
png("AttachImage.png", width = 350, height = 350)
# 3. 
Create the plot
plot(x = my_data$wt, y = my_data$mpg,
  pch = 16, frame = FALSE,
  xlab = "wt", ylab = "mpg", col = "#2E9FDF")
# 4. 
Close the file
dev.off()</code>
Now, create an HTML email that references the plot as <code>foobar</code>:
<code>email &lt;- gm_mime() %>%
  gm_to("user@recipient.com") %>%

  gm_from("user@sender.com") %>%
  gm_subject("Test email subject") %>%
  gm_html_body(
    '&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>

    &lt;br>&lt;img class="lazy" data-src="cid:foobar">'
  ) %>%
  gm_attach_file("AttachImage.png", id = "foobar")</code>
Eventually, you can send your email:

<code>gm_send_message(email)</code>
<h3 id="emailtopic-8">Sending emails from Outlook – RDCOMClient</h3>
R has a package for sending emails from Microsoft Outlook as well. 
It’s called <k>RDCOMClient </k>and allows you to connect to DCOM architecture, which you can consider an API for communicating with Microsoft Office in Windows environments. 

Let’s explore how to connect R to the Outlook app installed on your Windows.
Install <k>RDCOMClient </k>via an option of your choice:

from CRAN:
<code>install.packages("RDCOMClient")</code>


via devtools:
<code>devtools::install_github("omegahat/RDCOMClient")</code>

from the Windows command line:
<code>R CMD INSTALL RDCOMClient</code>

<em>Warning: if you receive a message like <code>package ‘RDCOMClient’ is not available (for R version 3.5.1)</code>” during the installation from CRAN, try to install </em><k><em>RDCOMClient </em></k><em>from the source repository:</em>
<code>install.packages("RDCOMClient", repos = "http://www.omegahat.net/R")</code>
Load the package, open Outlook, and create a simple email:
<code>library(RDCOMClient)

Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)
Email[["to"]] = "user@recipient.com"
Email[["subject"]] = "Test email subject"

Email[["body"]] = "Test email body"</code>
If you need to change the default <code>From:</code> field and send from a secondary mailbox, use:
<code>Email[["SentOnBehalfOfName"]] = "user@sender.com"</code>
Here is how you can specify multiple recipients, as well as Cc and Bcc headers:

<code>Email[["to"]] = "user1@recipient.com, user2@recipient.com"
Email[["cc"]] = "cc.user@recipient.com"
Email[["bcc"]] = "bcc.user@recipient.com"</code>
To create an HTML email, use <code>[["htmlbody"]]</code>. 

You can simply add your HTML in the R code as follows:
<code>library(RDCOMClient)
Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)

Email[["to"]] = "user@recipietn.com"
Email[["subject"]] = "Test email subject"
Email[["htmlbody"]] =
"&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>"</code>

Let’s also add an attachment:
<code>library(RDCOMClient)
Outlook &lt;- COMCreate("Outlook.Application")
Email = Outlook$CreateItem(0)

Email[["to"]] = "user@recipient.com"
Email[["subject"]] = "Test email subject"
Email[["htmlbody"]] =
"&lt;html>Test &lt;k>email&lt;/k> body&lt;/html>"

Email[["attachments"]]$Add("C:/.../Attachment.png")</code>
Now, you can send the email:
<code>outMail$Send()</code>
<h3 id="emailtopic-9">How to send bulk emails from R?</h3>
Let’s say your mail list includes many more than ten recipients and you need to send bulk emails from R. 
We’ll show you how this can be done via Web API (<k>gmailR</k>) and SMTP (<k>mailR</k>).
<h3 id="emailtopic-10">Bulk emails with gmailR</h3>
As an example, we’ll inform recipients of how much they won in the lottery. 

For this, we need:

an enabled API access on your Google account.
an installed gmailr R package.
a set of R packages for data iteration: <k>readr</k>, <k>dplyr, </k>and <k>purrr </k>(or <k>plyr </k>as an alternative).
a file containing the variable bits (lottery wins), <em>Variables.csv</em>, with the following format:
<code>lastname,firstname,win_amount,email_address
SMITH,JOHN,1234,johnsmith@winner.com

LOCKWOOD,JANE,1234,janelockwood24@example.com</code>
Now, let’s go through the mail steps to create an R script for bulk emails.

Load the packages and files we need:
<code>suppressPackageStartupMessages(library(gmailr))

suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(purrr))
library(readr) # => if you don’t have it, run: install.packages("readr", repos="http://cran.r-project.org")

my_dat &lt;- read_csv("Variables.csv") </code>

Create a data frame that will insert variables from the file into the email:
<code>this_hw &lt;- "Lottery Winners"
email_sender &lt;- 'Best Lottery Ever &lt;info@best-lottery-ever.com>'

optional_bcc &lt;- 'Anonymous &lt;bcc@example.com>'
body &lt;- "Hi, %s.
Your lottery win is %s.
Thanks for betting with us!

"
edat &lt;- my_dat %>%
    mutate(
        To = sprintf('%s &lt;%s>', firstname, email_address),

        Bcc = optional_bcc,
        From = email_sender,
        Subject = sprintf('Lottery win for %s', win_amount),
        body = sprintf(body, firstname, win_amount)) %>%

    select(To, Bcc, From, Subject, body)
write_csv(edat, "data-frame.csv")</code>
The data frame will be saved to <em>data-frame.csv</em>. 
This will provide an easy-to-read record of the composed emails.

Now, convert each row of the data frame into a MIME object using the <code>gmailr::mime()</code> function. 
After that, <code>purrr::pmap()</code> generates the list of MIME objects, one per row of the input data frame:
<code>emails &lt;- edat %>%
  pmap(mime)

str(emails, max.level = 2, list.len = 2)</code>
If you use <k>plyr</k> (<code>install.packages("plyr")</code>), you can do this, as follows:
<code>emails &lt;- plyr::dlply(edat, ~ To, function(x) mime(
  To = x$To,

  Bcc = x$Bcc,
  From = x$From,
  Subject = x$Subject,
  body = x$body))</code>

Specify your JSON credentials file:
<code>use_secret_file("GmailCredentials.json")</code>
And send emails with <code>purrr::safely()</code>. 
This will protect your bulk emails from failures in the middle:

<code>safe_send_message &lt;- safely(send_message)
sent_mail &lt;- emails %>%
  map(safe_send_message)
saveRDS(sent_mail,

        paste(gsub("\\s+", "_", this_hw), "sent-emails.rds", sep = "_"))</code>
List recipients with <code>TRUE</code> in case of errors:
<code>errors &lt;- sent_mail %>%
  transpose() %>%

  .$error %>%
  map_lgl(Negate(is.null))</code>
Take a look at the full code now:
<code>suppressPackageStartupMessages(library(gmailr))

suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(purrr))
library(readr) # => if you don’t have it, run: install.packages("readr", repos="http://cran.r-project.org")

my_dat &lt;- read_csv("Variables.csv")
this_hw &lt;- "Lottery Winners"
email_sender &lt;- 'Best Lottery Ever &lt;info@best-lottery-ever.com>'
optional_bcc &lt;- 'Anonymous &lt;bcc@example.com>'

body &lt;- "Hi, %s.
Your lottery win is %s.
Thanks for betting with us!
"

edat &lt;- my_dat %>%
    mutate(
        To = sprintf('%s &lt;%s>', firstname, email_address),
        Bcc = optional_bcc,

        From = email_sender,
        Subject = sprintf('Lottery win for %s', win_amount),
        body = sprintf(body, firstname, win_amount)) %>%
    select(To, Bcc, From, Subject, body)

write_csv(edat, "data-frame.csv")
emails &lt;- edat %>%
  pmap(mime)
str(emails, max.level = 2, list.len = 2)

use_secret_file("GmailCredentials.json")
safe_send_message &lt;- safely(send_message)
sent_mail &lt;- emails %>%
  map(safe_send_message)

saveRDS(sent_mail,
        paste(gsub("\\s+", "_", this_hw), "sent-emails.rds", sep = "_"))
errors &lt;- sent_mail %>%
  transpose() %>%

  .$error %>%
  map_lgl(Negate(is.null))</code>
<h3 id="emailtopic-11">Bulk emails with mailR</h3>
If you want to send bulk emails with SMTP, make sure to have an appropriate SMTP server and install the mailR package. 

Once again, we’ll need a <em>.csv</em> file that will contain the data frame you want to integrate into the email. 
The data should be separated by a special character such as a comma, a semicolon, or a tab9. 
For example:
<code>lastname; firstname; win_amount; email_address

SMITH; JOHN; 1234; johnsmith@winner.com
LOCKWOOD; JANE; 1234; janelockwood24@example.com</code>
What you need to do next:

Build the HTML email body for a given recipient using the <code>message_text</code> function:

<code>message_text &lt;- function(x) sprintf('Hello %s %s!\nCongratulation to your win.\nYour prize is XXX.\nBet with the Best Lottery Ever!', x$firstname, x$lastname)</code>
Load the package and read in the mail list:
<code>library(mailR)
mail_list &lt;- read.csv2("Variables.csv",as.is=TRUE)</code>

Values in the <em>Variables.csv</em> should be separated with a semicolon (<code>;</code>). 
You can configure settings to read the data frame using the <code>read.table</code> or <code>read.csv</code> functions.
Create a file to write the information of each individual row in the <code>mail_list</code> after each email is sent.
<code>my_file &lt;- file("mail.out",open="w")

# … write data here
close(my_file)</code>
Perform the batch emailing to all students in the mail list:
<code>for (recipient in 1:nrow(mail_list)) {

  body &lt;- message_text(mail_list[recipient,])
  send.mail(from="info@best-lottery-ever.com",
    to=as.character(mail_list[recipient,]$email_address),
    subject="Lottery Winners",

    body=body,
    html=TRUE,
    authenticate=TRUE,
    smtp = list(host.name = "smtp.mailtrap.io",

    user.name = "*****", passwd = "*****", ssl = TRUE),
    encoding = "utf-8",send=TRUE)
  print(mail_list[recipient,])
  Sys.sleep(runif(n=1,min=3,max=6))

  #write each recipient to a file
  result_file &lt;- file("mail.out",open="a")
  writeLines(text=paste0("[",recipient,"] ",
    paste0(as.character(mail_list[recipient,]),collapse="\t")),

    sep="\n",con=result_file)
  close(result_file)
}</code>
And here is the full code:

<code>message_text &lt;- function(x) sprintf('Hello %s %s!\nCongratulation to your win.\nYour prize is XXX.\nBet with the Best Lottery Ever!', x$firstname, x$lastname)
library(mailR)
mail_list &lt;- read.csv2("Variables.csv",as.is=TRUE)
my_file &lt;- file("mail.out",open="w")

# … write data here
close(my_file)
for (recipient in 1:nrow(mail_list)) {
  body &lt;- message_text(mail_list[recipient,])

  send.mail(from="info@best-lottery-ever.com",
    to=as.character(mail_list[recipient,]$email_address),
    subject="Lottery Winners",
    body=body,

    html=TRUE,
    authenticate=TRUE,
    smtp = list(host.name = "smtp.mailtrap.io",
    user.name = "*****", passwd = "*****", ssl = TRUE),

    encoding = "utf-8",send=TRUE)
  print(mail_list[recipient,])
  Sys.sleep(runif(n=1,min=3,max=6))
  #write each recipient to a file

  result_file &lt;- file("mail.out",open="a")
  writeLines(text=paste0("[",recipient,"] ",
    paste0(as.character(mail_list[recipient,]),collapse="\t")),
    sep="\n",con=result_file)

  close(result_file)
}</code>
<h3 id="emailtopic-12">How to test email sending in R with Mailtrap</h3>
If you choose to send emails from R via SMTP, then Mailtrap is what you need for testing. 

It’s a universal service with a fake SMTP server underneath. 
This means, your test emails are not actually being sent. 
They go from your app or any other mail client to the SMTP server and are trapped there. 
Thus, you protect your real recipients from an undesirable experience – they won’t receive any of your test emails. 

All the aforementioned examples with Mailtrap credentials work in this way. 
If you need to test anything else, just replace your SMTP credentials with those of Mailtrap and that’s it. 
For this, you need to <a href="https://mailtrap.io/register/signup?ref=header" target="_blank">sign up</a> first using your email, GitHub or Google account. 
A FREE FOREVER plan is available! For more on the features and functions provided by Mailtrap, read the <a href="https://help.mailtrap.io/article/12-getting-started-guide">Getting Started Guide</a>.

<h3 id="emailtopic-13">To wrap up</h3>
We’ve listed a number of options for sending emails in R, so choose the one that best fits your requirements. 
For example, if you need to send hundreds (or even thousands) of emails daily, gmailR may be the best solution. 
On the other hand, sending via SMTP is a more common and reliable way and R provides a few packages for this. 
So, good luck with your choice!

<h3 id="emailtopic-14">Sending emails via Gmail API – gmailR</h3>
Gmail is one of the most popular email services so far, and you will very probably want to use it as a mailbox for your web or mobile app. 
It is safe and credible, which is crucial to <a href="https://mailtrap.io/blog/avoid-spam-filters/" target="_blank">prevent your emails from going into the spam folder</a>. 
That’s why we decided to flesh out how to send emails with Gmail API. 

<h3 id="emailtopic-15">Gmail API – why you should consider using it</h3>
The API provides you with a RESTful access to the features you usually have with Gmail:

Send and receive HTML emails
Send and receive emails with attachments
CRUD (create, read, update, and delete) operations with messages, drafts, threads, and labels&nbsp;
Access control of your Gmail inbox
Full search capabilities of the web UI
Perform specific queries&nbsp;
And many more…
Developers love Gmail API because it’s easy to implement. 
We’ll talk about that a bit later. 
Also, you can use this option for versatile cases like: 

automated email sending
mail backup
mail migration from other email services
<h3 id="emailtopic-16">Resource types and methods</h3>
With Gmail API, you can deal with several resource types and manage them using the following methods:
<table><tbody><tr><th width="30%">Resource type</th><th width="70%">Method</th></tr><tr><td><k>Draft</k><br>an unsent message that you can modify once created</td><td>
create (creating a new draft)<br>
delete (removing the specified draft)<br>
get (obtaining the specified draft)<br>
list (listing drafts in the mailbox)<br>
send (sending the specified draft according to the To, Cc, and Bcc headers)<br>
update (updating the specified draft’s content)</td></tr><tr><td><k>Message</k><br>an immutable resource that you cannot modify</td><td>
batchDelete (removing messages by message ID)<br>
batchModify (modifying labels on the specified messages)<br>
delete (removing the specified message)<br>
get (obtaining the specified message)<br>
import (importing the message into the mailbox (similar to receiving via SMTP))<br>
insert (inserting the message into the mailbox (similar to IMAP)<br>
list (listing messages in the mailbox)<br>
modify (modifying labels on the specified message)<br>
send (sending the specified message according to the To, Cc, and Bcc headers)<br>
trash (transferring the specified message to the trash)<br>
untrash (transferring the specified message from the trash)</td></tr><tr><td><k>Thread</k><br>a collection of messages within a single conversation</td><td>
delete (removing the specified thread)<br>
get (obtaining the specified thread)<br>
list (listing threads in the mailbox)<br>
modify (modifying labels in the thread)<br>
trash (transferring the specified thread to the trash)<br>
untrash (transferring the specified thread from the trash)</td></tr><tr><td><k>Label</k><br>a resource to organize messages and threads (for example, inbox, spam, trash, etc.)</td><td>
create (creating a new label)<br>
delete (removing the specified label)<br>
get (obtaining the specified label)<br>
list (listing labels in the mailbox)<br>
patch (patching the specified label) – this method supports patch semantics<br>
update (updating the specified label).</td></tr><tr><td><k>History</k><br>a collection of changes made to the mailbox</td><td>
list (listing the history of all changes to the mailbox)</td></tr><tr><td><k>Settings</k><br>setting up Gmail features</td><td>
getAutoForwarding (auto-forwarding setting)<br>
updateAutoForwarding (updating the auto-forwarding setting)<br>
getImap (IMAP settings)<br>
updateImap (updating IMAP settings)<br>
getLanguage (language settings)<br>
updateLanguage (updating language settings)<br>
getPop (POP3 settings)<br>
updatePop (updating POP3 settings)<br>
getVacation (vacation responder settings)<br>
updateVacation (updating vacation responder settings)</td></tr></tbody></table>
<h3 id="emailtopic-17">How to make your app send emails with Gmail API</h3>
<h3 id="emailtopic-18">Step 1: Create a project at Google API Console</h3>
If you want to have access to your Gmail from your mobile or web app, you should start with <a href="https://console.developers.google.com/" target="_blank">Google Developers Console</a>. 
Those who visit this page for the first time ever will have to agree with the <em>Terms of Service</em> and pick their <em>Country of residence</em>. 
Then click <k>Select a project</k> and create a new one.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh4.googleusercontent.com/cQ3I0lmHvuA46MI7Btd3fL-4AVbcyFE6Z_a6OA3l3XrN6jsETLZNzt-uvrfu9wfiTN-BmL3EX2RLQapRZ1ILEmjfFB_BhcunrubAgBhRSJCmlXtg2Cv1toNKm7lznukYB0LgjYbP"><noscript><img class="lazy" data-src="https://lh4.googleusercontent.com/cQ3I0lmHvuA46MI7Btd3fL-4AVbcyFE6Z_a6OA3l3XrN6jsETLZNzt-uvrfu9wfiTN-BmL3EX2RLQapRZ1ILEmjfFB_BhcunrubAgBhRSJCmlXtg2Cv1toNKm7lznukYB0LgjYbP" alt="" data-eio="l"></noscript></figure>
Name your new project and press <k>Create</k> at the bottom.&nbsp;
<h3 id="emailtopic-19">Step 2: Enable Gmail API</h3>
Once that’s done, you can press the <k>Library</k> tab on the left and find yourself in the API Library page. 
Enter “<em>Gmail API</em>” in the search bar and click on it once found. 
Now, you need to enable the API for your project.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/qRA82H-dl5bKqCzC8H_YpR8cDa23K85f6s5Q2piOw95VO62mqn_YfOkLFVaSD_p0qCVKTLGRLeFDMzU3Ad-Lb8Ou0Yde3efa7diXO5QDVC7IjCQcrbQh-H30xBVpy24KfrSZJ1Uc"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/qRA82H-dl5bKqCzC8H_YpR8cDa23K85f6s5Q2piOw95VO62mqn_YfOkLFVaSD_p0qCVKTLGRLeFDMzU3Ad-Lb8Ou0Yde3efa7diXO5QDVC7IjCQcrbQh-H30xBVpy24KfrSZJ1Uc" alt="" data-eio="l"></noscript></figure>
<em>Note that you’ll have to enable it separately for each new project you work on.&nbsp;</em>
<h3 id="emailtopic-20">Step 3: Credentials and authentication with OAuth 2.0</h3>
Once the API is enabled, you’ll be taken to a nice dashboard that says, “<em>To use this API, you may need credentials</em>”. 
If you click <k>Create credentials</k>, you’ll have to pass through a set of questions to find out what kind of credentials you need. 
We advise you to go another way since we already know what it is: OAuth client ID. 
So, click the Credential tab on the left, and then pick OAuth client ID from the drop-down list of the <k>Create Credentials</k> button.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/UwsT80hMiX5B1TjEg51gbqkkJ-iembuOfCu3cM9k1pdcv2mlleKht4k_FmeRFBwFApyuHkqb8Xgxut9dHybJAIQCtzfvul60Uh957dPXi3fRFrsU4ZjhTSZo_-8byEsxIy52jSRv"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/UwsT80hMiX5B1TjEg51gbqkkJ-iembuOfCu3cM9k1pdcv2mlleKht4k_FmeRFBwFApyuHkqb8Xgxut9dHybJAIQCtzfvul60Uh957dPXi3fRFrsU4ZjhTSZo_-8byEsxIy52jSRv" alt="" data-eio="l"></noscript></figure>
You’ll see the Configure consent screen button. 
It will bring you to a page with many fields. 
You can just enter the name of your app and specify authorized domains. 
Fill in other fields if you want.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh5.googleusercontent.com/WAhpqm_Hwa640iUPpKK7eWRPDIPf2FlpQ7Y5XT2uKa9UrfO-i868IpL-O4orLMXSMT6wRnubrYzyZD0LRUSjKt9xJDSOdZSrZmjBTuDKj3w9pGHG2U_m_afZ8RlN9R2SXmDHcXht"><noscript><img class="lazy" data-src="https://lh5.googleusercontent.com/WAhpqm_Hwa640iUPpKK7eWRPDIPf2FlpQ7Y5XT2uKa9UrfO-i868IpL-O4orLMXSMT6wRnubrYzyZD0LRUSjKt9xJDSOdZSrZmjBTuDKj3w9pGHG2U_m_afZ8RlN9R2SXmDHcXht" alt="" data-eio="l"></noscript></figure>
Click save and then pick the type of your app (web app, Android, Chrome App, iOS, or other). 
After that, name your OAuth Client ID. 
Also, enter JavaScript origins and redirect domains for use with requests from a browser or a web server respectively. 
Click create to finalize.&nbsp;That’s it. 
Download a JSON file with your credentials – you’ll need it later. 

<h3 id="emailtopic-21">Step 4: Pick a quickstart guide&nbsp;</h3>
The next step is to select a quickstart guide according to the technology your app is built with. 
So far, there are the following options:

<a href="https://developers.google.com/gmail/api/quickstart/go" target="_blank">API for Go</a>
<a href="https://developers.google.com/gmail/api/quickstart/java" target="_blank">API for Java</a>
<a href="https://developers.google.com/gmail/api/quickstart/ruby" target="_blank">API for Ruby</a>
<a href="https://developers.google.com/gmail/api/quickstart/dotnet" target="_blank">API for .NET</a>
<a href="https://developers.google.com/gmail/api/quickstart/nodejs" target="_blank">API for Node.js</a>
<a href="https://developers.google.com/gmail/api/quickstart/php" target="_blank">API for PHP</a>
<a href="https://developers.google.com/gmail/api/quickstart/python" target="_blank">API for Python</a>
<a href="https://developers.google.com/gmail/api/quickstart/js" target="_blank">API for browser (JavaScript)</a>
For mobile apps, there are G Suite APIs for <a href="https://developers.google.com/gsuite/guides/ios" target="_blank">iOS</a> and <a href="https://developers.google.com/gsuite/guides/android" target="_blank">Android</a> as well.&nbsp;
What you need first in this quickstart guide is the Prerequisites section. 
Let’s say your choice is PHP. 
In this case, make sure your PHP version corresponds to the given one. 
Also, install the JSON extension and the Composer dependency management tool if you haven’t already. 
After that, you can install the Google Client Library. 
For Java, you’ll need to create a new project structure and the <code>src/main/resources/</code> directory. 
Then, copy the JSON file with credentials to this directory and replace the content of the <code>build.gradle</code> file with <a href="https://github.com/gsuitedevs/java-samples/blob/master/gmail/quickstart/build.gradle" target="_blank">this code</a>. 
So, pay attention when preparing your project.&nbsp;
<k><a href="https://mailtrap.io/register/signup?ref=anchor">Route your test emails to Mailtrap for safe testing.</a></k>
<h3 id="emailtopic-22">Step 5: API client library</h3>
Google provides client libraries to work with the API:
<a href="https://github.com/googleapis/google-api-go-client" target="_blank">API client for Go</a>
<code>Installation:
go get -u google.golang.org/api/gmail/v1
go get -u golang.org/x/oauth3/google</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-java-client" target="_blank">API client for Java</a>
</p><code>Installation via Gradle
repositories {
      mavenCentral()
  }
  dependencies {
      compile 'com.google.api-client:google-api-client:1.30.2' 
  }</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-ruby-client" target="_blank">API client for Ruby</a>
</p><code>Installation:
gem install google-api-client</code>
<p id="block-0c16e9a3-17ba-4365-9083-7f3c2b398e1b"><a href="https://github.com/googleapis/google-api-dotnet-client" target="_blank">API client for .NET</a>
</p><code>Installation via NuGet Package Manager Console:
Install-Package Google.Apis.Gmail.v1</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-nodejs-client" target="_blank">API client for Node.js</a>
</p><code>Installation via npm:
npm install googleapis@39 --save</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-php-client" target="_blank">API client for PHP</a>
</p><code>Installation via Composer:
composer require google/apiclient:"^2.0"</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-python-client" target="_blank">API client for Python</a>
</p><code>Installation:
pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
or
easy_install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib</code>

<a href="https://github.com/google/google-api-javascript-client" target="_blank">API client for JavaScript</a> 
<a href="https://github.com/google/google-api-objectivec-client-for-rest/" target="_blank">API client for Objective-C</a> 
<a href="https://github.com/dart-lang/googleapis" target="_blank">API client for Dart</a>

<h3 id="emailtopic-23">Step 6: Access to Gmail</h3>
In this step, we need to authorize access to your Gmail account from the app, and then you’ll be able to manage emails. 
For this, you need to create a file in your working directory. 
Below you’ll find the specific file names for each technology. 
Copy-paste a corresponding code sample from the chosen Quickstart Guide and run it. 
Here are the links to the code samples: 
<h4>Go</h4>

Filename: <em>quickstart.go</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/go-samples/blob/master/gmail/quickstart/quickstart.go" target="_blank">Code sample for Go</a>
Run with: <code>go run quickstart.go</code>
<h4>Java</h4>

Flinename: <em>GmailQuickstart.java</em>
Directory: <em>src/main/java/</em>
<a href="https://github.com/gsuitedevs/java-samples/blob/master/gmail/quickstart/src/main/java/GmailQuickstart.java" target="_blank">Code sample for Java</a>
Run with: <code>gradle run</code>
<h4>Ruby</h4>

Filename: <em>quickstart.rb</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/ruby-samples/blob/master/gmail/quickstart/quickstart.rb" target="_blank">Code sample for Ruby</a>
Run with: <code>ruby quickstart.rb</code>
<h4>.NET</h4>

Filename: <em>GmailQuickstart.cs</em>
Directory: <em>gmail/GmailQuickstart/</em>
<a href="https://github.com/gsuitedevs/dotnet-samples/blob/master/gmail/GmailQuickstart/GmailQuickstart.cs" target="_blank">Code sample for .NET</a>
Run by clicking Start in the Visual Studio toolbar
<h4>Node.js</h4>

Filename: <em>index.js</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/node-samples/blob/master/gmail/quickstart/index.js" target="_blank">Code sample for Node.js</a>
Run with: <code>node .</code>
<h4>PHP</h4>

Filename: <em>quickstart.php</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/php-samples/blob/master/gmail/quickstart/quickstart.php" target="_blank">Code sample for PHP</a>
Run with: <code>php quickstart.php</code>
<h4>Python</h4>

Filename: <em>quickstart.py</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/python-samples/blob/master/gmail/quickstart/quickstart.py" target="_blank">Code sample for Python</a>
Run with: <code>python quickstart.py</code>
<h4>JavaScript (browser)</h4>

Filename: <em>index.html</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/browser-samples/blob/master/gmail/quickstart/index.html" target="_blank">Code sample for browser (JavaScript)</a>
Replace &lt;YOUR_CLIENT_ID> with your client ID and &lt;YOUR_API_KEY> with your API key. 
Run with:
<code>python -m SimpleHTTPServer 8000</code> – for Python 2+
<code>python -m http.server 8000</code> – for Python 3+
It worked…or not. 
Google will warn you about a probable failure of the sample you run to open a new window in your default browser. 
If this happens, you’ll need to do it manually. 
Copy the URL from the console and paste it in the browser. 
It will look like this: 
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh3.googleusercontent.com/T1kyjSBNMmPyABN6RmOFOg50zCIqK8oKJdpLQYiwjK6tV8ZtNuCXGwdEKDxCW5R3ecG3OFxi3ieSLOrdLRZKN5Y_ZpOidLmLS89MxLJw2YiNZgE13xSeThSXhlFZY_xPceFkkyiK"><noscript><img class="lazy" data-src="https://lh3.googleusercontent.com/T1kyjSBNMmPyABN6RmOFOg50zCIqK8oKJdpLQYiwjK6tV8ZtNuCXGwdEKDxCW5R3ecG3OFxi3ieSLOrdLRZKN5Y_ZpOidLmLS89MxLJw2YiNZgE13xSeThSXhlFZY_xPceFkkyiK" alt="" data-eio="l"></noscript></figure>
Next, you’ll be asked to either log into your Google account or select one account for authorization. 
Press allow and you’ll see all your inbox labels in the SSH shell like this: 
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/Np1QRG1CulZGsyk8YCVECvoGilEbpDC5bnWlJoVPVlzmtRy9BDBo5AQ1TNphpoq97mPdWrb4Z33m5ZIb7pPyhmQmudhRUsJYYSO4vosez3R_ZRO636ToE0UJyA4i-PCn_N3M3NE7"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/Np1QRG1CulZGsyk8YCVECvoGilEbpDC5bnWlJoVPVlzmtRy9BDBo5AQ1TNphpoq97mPdWrb4Z33m5ZIb7pPyhmQmudhRUsJYYSO4vosez3R_ZRO636ToE0UJyA4i-PCn_N3M3NE7" alt="" data-eio="l"></noscript></figure>
Congrats! Gmail API works and you can send your first email.
<h3 id="emailtopic-24">Step 7: Create an email</h3>
To send a message, first you need to create one. 
For this, your app can use the <em>drafts.create</em> method which includes:

Creation of a MIME message
Conversion of the message into a base64url encoded string
Creation of a draft
Let’s see how this is done in practice with Python:
<code>def create_message(sender, to, subject, message_text):
 message = MIMEText(message_text)
 message['to'] = to
 message['from'] = sender
 message['subject'] = subject
 raw_message = base64.urlsafe_b64encode(message.as_string().encode("utf-8"))
 return {
   'raw': raw_message.decode("utf-8")
 }
def create_draft(service, user_id, message_body):
 try:
   message = {'message': message_body}
   draft = service.users().drafts().create(userId=user_id, body=message).execute()
   print("Draft id: %s\nDraft message: %s" % (draft['id'], draft['message']))
   return draft
 except Exception as e:
   print('An error occurred: %s' % e)
   return None  </code>
and PHP 
<code>/**
* @param $sender string sender email address
* @param $to string recipient email address
* @param $subject string email subject
* @param $messageText string email text
* @return Google_Service_Gmail_Message
*/
function createMessage($sender, $to, $subject, $messageText) {
$message = new Google_Service_Gmail_Message();
$rawMessageString = "From: &lt;{$sender}>\r\n";
$rawMessageString .= "To: &lt;{$to}>\r\n";
$rawMessageString .= 'Subject: =?utf-8?B?' . 
base64_encode($subject) . 
"?=\r\n";
$rawMessageString .= "MIME-Version: 1.0\r\n";
$rawMessageString .= "Content-Type: text/html; charset=utf-8\r\n";
$rawMessageString .= 'Content-Transfer-Encoding: quoted-printable' . 
"\r\n\r\n";
$rawMessageString .= "{$messageText}\r\n";
$rawMessage = strtr(base64_encode($rawMessageString), array('+' => '-', '/' => '_'));
$message->setRaw($rawMessage);
return $message;
}
/**
* @param $service Google_Service_Gmail an authorized Gmail API service instance.
* @param $user string User's email address or "me"
* @param $message Google_Service_Gmail_Message
* @return Google_Service_Gmail_Draft
*/
function createDraft($service, $user, $message) {
$draft = new Google_Service_Gmail_Draft();
$draft->setMessage($message);
try {
  $draft = $service->users_drafts->create($user, $draft);
  print 'Draft ID: ' . 
$draft->getId();
} catch (Exception $e) {
  print 'An error occurred: ' . 
$e->getMessage();
}
return $draft;
}</code>
<a href="https://mailtrap.io/register/signup" target="_blank">Test Your Emails Now</a>
<h3 id="emailtopic-25">Step 8: Send an email</h3>
Once you have created your message, you can either call <em>messages.send</em> or <em>drafts.send</em> to send it. 
Here is how it may look: 
Python
<code>def send_message(service, user_id, message):
 try:
   message = service.users().messages().send(userId=user_id, body=message).execute()
   print('Message Id: %s' % message['id'])
   return message
 except Exception as e:
   print('An error occurred: %s' % e)
   return None</code>
and PHP
<code>/**
* @param $service Google_Service_Gmail an authorized Gmail API service instance.
* @param $userId string User's email address or "me"
* @param $message Google_Service_Gmail_Message
* @return null|Google_Service_Gmail_Message
*/
function sendMessage($service, $userId, $message) {
try {
  $message = $service->users_messages->send($userId, $message);
  print 'Message with ID: ' . 
$message->getId() . 
' sent.';
  return $message;
} catch (Exception $e) {
  print 'An error occurred: ' . 
$e->getMessage();
}
return null;
}</code>
<h3 id="emailtopic-26">Step 8.1: Send an email with attachments</h3>
You can also create and send a multi-part MIME message. 
For example, this is how it looks with Python: 
<code>def send_message(service, user_id, message):
 try:
   message = service.users().messages().send(userId=user_id, body=message).execute()
   print('Message Id: %s' % message['id'])
   return message
 except Exception as e:
   print('An error occurred: %s' % e)
   return None
def create_message_with_attachment(sender, to, subject, message_text, file):
 message = MIMEMultipart()
 message['to'] = to
 message['from'] = sender
 message['subject'] = subject
 msg = MIMEText(message_text)
 message.attach(msg)
 content_type, encoding = mimetypes.guess_type(file)
 if content_type is None or encoding is not None:
   content_type = 'application/octet-stream'
 main_type, sub_type = content_type.split('/', 1)
 if main_type == 'text':
   fp = open(file, 'rb')
   msg = MIMEText(fp.read().decode("utf-8"), _subtype=sub_type)
   fp.close()
 elif main_type == 'image':
   fp = open(file, 'rb')
   msg = MIMEImage(fp.read(), _subtype=sub_type)
   fp.close()
 elif main_type == 'audio':
   fp = open(file, 'rb')
   msg = MIMEAudio(fp.read(), _subtype=sub_type)
   fp.close()
 else:
   fp = open(file, 'rb')
   msg = MIMEBase(main_type, sub_type)
   msg.set_payload(fp.read())
   fp.close()
 filename = os.path.basename(file)
 msg.add_header('Content-Disposition', 'attachment', filename=filename)
 message.attach(msg)
 raw_message = base64.urlsafe_b64encode(message.as_string().encode("utf-8"))
 return {'raw': raw_message.decode("utf-8")}</code>
<k><a href="https://mailtrap.io/register/signup?ref=anchor">Test your emails before they are sent to real users.</a></k>
<h3 id="emailtopic-27">Step 9: Read a specific email from your inbox</h3>
It would be weird if you can’t use the API to read messages from Gmail. 
Luckily you can by using the <em>get</em> method by the message ID. 
Here is how it may look in a Python app: 
<code>import base64
import email
def get_messages(service, user_id):
 try:
   return service.users().messages().list(userId=user_id).execute()
 except Exception as error:
   print('An error occurred: %s' % error)
def get_message(service, user_id, msg_id):
 try:
   return service.users().messages().get(userId=user_id, id=msg_id, format='metadata').execute()
 except Exception as error:
   print('An error occurred: %s' % error)
def get_mime_message(service, user_id, msg_id):
 try:
   message = service.users().messages().get(userId=user_id, id=msg_id,
                                            format='raw').execute()
   print('Message snippet: %s' % message['snippet'])
   msg_str = base64.urlsafe_b64decode(message['raw'].encode("utf-8")).decode("utf-8")
   mime_msg = email.message_from_string(msg_str)
   return mime_msg
 except Exception as error:
   print('An error occurred: %s' % error)</code>
If the message contains an attachment, expand your code with the following: 
<code>def get_attachments(service, user_id, msg_id, store_dir):
 try:
   message = service.users().messages().get(userId=user_id, id=msg_id).execute()
   for part in message['payload']['parts']:
     if(part['filename'] and part['body'] and part['body']['attachmentId']):
       attachment = service.users().messages().attachments().get(id=part['body']['attachmentId'], userId=user_id, messageId=msg_id).execute()
       file_data = base64.urlsafe_b64decode(attachment['data'].encode('utf-8'))
       path = ''.join([store_dir, part['filename']])
       f = open(path, 'wb')
       f.write(file_data)
       f.close()
 except Exception as error:
   print('An error occurred: %s' % error)</code>
<h3 id="emailtopic-28">Why is Gmail API better or worse than traditional SMTP?&nbsp;</h3>
<h3 id="emailtopic-29">Email protocol used</h3>
Simple Mail Transfer Protocol (SMTP) is a set of rules for sending emails either from the sender to the email server or between servers. 
Most email service providers use SMTP to send and POP3/IMAP4 to receive emails. 
To learn more about these protocols, you can read our <a href="https://mailtrap.io/blog/imap-pop3-smtp/" target="_blank">IMAP vs. 
POP3 vs. 
SMTP</a> blog post. 
Google also provides the Gmail SMTP server as a free SMTP service. 
Application Programming Interface (API) is an interaction channel used by apps, platforms, and codes to reach each other. 
With Gmail API, you can send emails using only HyperText Transfer Protocol (HTTP), a set of rules that defines how messages are formatted and transmitted. 

<h3 id="emailtopic-30">How are emails sent?</h3>
You can call the API from the app to communicate with an email service that is used to send emails from another server.&nbsp;
For SMTP, a client establishes a TCP connection to the SMTP server and transfers an email. 
After authorization, the server sends the email to the recipient’s SMTP server, which, in turn, forwards it to the IMAP4 or POP3 server. 
Client and server communicate with each other using <a href="https://mailtrap.io/blog/smtp-commands-and-responses/" target="_blank">SMTP commands and responses</a>.
<h3 id="emailtopic-31">Authentication</h3>
Gmail API uses open authentication (Oauth3), which only lets you request the scope of access you need. 
SMTP provides full access to the account using client login and password <a href="https://mailtrap.io/blog/smtp-auth/" target="_blank">SMTP authentication</a>.
<h3 id="emailtopic-32">Quota</h3>
The usage limit of Gmail API is one billion quota units per day. 
Each method requires a particular number of quota units. 
For example, a <code>drafts.create</code> is 10 units and a <code>messages.send</code> is 100 units. 
Gmail API enforces standard daily <a href="https://support.google.com/a/answer/166852" target="_blank">mail sending limits</a>. 
Also, keep in mind that the <a href="https://mailtrap.io/blog/email-size/" target="_blank" aria-label="maximum email size in Gmail (opens in a new tab)">maximum email size in Gmail</a> is 25MB.
<h3 id="emailtopic-33">SMTP or API?</h3>
Each option has its own pros and cons. 
SMTP is a widely adopted and easy-to-set-up solution to send emails. 
Moreover, you don’t need any coding skills to handle stuff. 
Also, you can benefit from using a fake SMTP server such as <a href="https://mailtrap.io">Mailtrap</a> as a playground for safe email testing.
Besides, it is a great option to automate processes and provide a wide range of functionality for the app. 
Also, API can boast an extra level of security, which is crucial if you deal with sending sensitive data in emails. 


<h3 id="emailtopic-34"><span class="orange">Send Emails with Gmail API</span></h3>
Gmail is one of the most popular email services so far, and you will very probably want to use it as a mailbox for your web or mobile app. 
It is safe and credible, which is crucial to <a href="https://mailtrap.io/blog/avoid-spam-filters/" target="_blank">prevent your emails from going into the spam folder</a>. 
That’s why we decided to flesh out how to send emails with Gmail API. 

<h3 id="emailtopic-35">Gmail API – why you should consider using it</h3>
The API provides you with a RESTful access to the features you usually have with Gmail:

Send and receive HTML emails
Send and receive emails with attachments
CRUD (create, read, update, and delete) operations with messages, drafts, threads, and labels&nbsp;
Access control of your Gmail inbox
Full search capabilities of the web UI
Perform specific queries&nbsp;
And many more…
Developers love Gmail API because it’s easy to implement. 
We’ll talk about that a bit later. 
Also, you can use this option for versatile cases like: 

automated email sending
mail backup
mail migration from other email services
<h3 id="emailtopic-36">Resource types and methods</h3>
With Gmail API, you can deal with several resource types and manage them using the following methods:
<table><tbody><tr><th width="30%">Resource type</th><th width="70%">Method</th></tr><tr><td><k>Draft</k><br>an unsent message that you can modify once created</td><td>
create (creating a new draft)<br>
delete (removing the specified draft)<br>
get (obtaining the specified draft)<br>
list (listing drafts in the mailbox)<br>
send (sending the specified draft according to the To, Cc, and Bcc headers)<br>
update (updating the specified draft’s content)</td></tr><tr><td><k>Message</k><br>an immutable resource that you cannot modify</td><td>
batchDelete (removing messages by message ID)<br>
batchModify (modifying labels on the specified messages)<br>
delete (removing the specified message)<br>
get (obtaining the specified message)<br>
import (importing the message into the mailbox (similar to receiving via SMTP))<br>
insert (inserting the message into the mailbox (similar to IMAP)<br>
list (listing messages in the mailbox)<br>
modify (modifying labels on the specified message)<br>
send (sending the specified message according to the To, Cc, and Bcc headers)<br>
trash (transferring the specified message to the trash)<br>
untrash (transferring the specified message from the trash)</td></tr><tr><td><k>Thread</k><br>a collection of messages within a single conversation</td><td>
delete (removing the specified thread)<br>
get (obtaining the specified thread)<br>
list (listing threads in the mailbox)<br>
modify (modifying labels in the thread)<br>
trash (transferring the specified thread to the trash)<br>
untrash (transferring the specified thread from the trash)</td></tr><tr><td><k>Label</k><br>a resource to organize messages and threads (for example, inbox, spam, trash, etc.)</td><td>
create (creating a new label)<br>
delete (removing the specified label)<br>
get (obtaining the specified label)<br>
list (listing labels in the mailbox)<br>
patch (patching the specified label) – this method supports patch semantics<br>
update (updating the specified label).</td></tr><tr><td><k>History</k><br>a collection of changes made to the mailbox</td><td>
list (listing the history of all changes to the mailbox)</td></tr><tr><td><k>Settings</k><br>setting up Gmail features</td><td>
getAutoForwarding (auto-forwarding setting)<br>
updateAutoForwarding (updating the auto-forwarding setting)<br>
getImap (IMAP settings)<br>
updateImap (updating IMAP settings)<br>
getLanguage (language settings)<br>
updateLanguage (updating language settings)<br>
getPop (POP3 settings)<br>
updatePop (updating POP3 settings)<br>
getVacation (vacation responder settings)<br>
updateVacation (updating vacation responder settings)</td></tr></tbody></table>
<h3 id="emailtopic-37">How to make your app send emails with Gmail API</h3>
<h3 id="emailtopic-38">Step 1: Create a project at Google API Console</h3>
If you want to have access to your Gmail from your mobile or web app, you should start with <a href="https://console.developers.google.com/" target="_blank">Google Developers Console</a>. 
Those who visit this page for the first time ever will have to agree with the <em>Terms of Service</em> and pick their <em>Country of residence</em>. 
Then click <k>Select a project</k> and create a new one.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh4.googleusercontent.com/cQ3I0lmHvuA46MI7Btd3fL-4AVbcyFE6Z_a6OA3l3XrN6jsETLZNzt-uvrfu9wfiTN-BmL3EX2RLQapRZ1ILEmjfFB_BhcunrubAgBhRSJCmlXtg2Cv1toNKm7lznukYB0LgjYbP"><noscript><img class="lazy" data-src="https://lh4.googleusercontent.com/cQ3I0lmHvuA46MI7Btd3fL-4AVbcyFE6Z_a6OA3l3XrN6jsETLZNzt-uvrfu9wfiTN-BmL3EX2RLQapRZ1ILEmjfFB_BhcunrubAgBhRSJCmlXtg2Cv1toNKm7lznukYB0LgjYbP" alt="" data-eio="l"></noscript></figure>
Name your new project and press <k>Create</k> at the bottom.&nbsp;
<h3 id="emailtopic-39">Step 2: Enable Gmail API</h3>
Once that’s done, you can press the <k>Library</k> tab on the left and find yourself in the API Library page. 
Enter “<em>Gmail API</em>” in the search bar and click on it once found. 
Now, you need to enable the API for your project.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/qRA82H-dl5bKqCzC8H_YpR8cDa23K85f6s5Q2piOw95VO62mqn_YfOkLFVaSD_p0qCVKTLGRLeFDMzU3Ad-Lb8Ou0Yde3efa7diXO5QDVC7IjCQcrbQh-H30xBVpy24KfrSZJ1Uc"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/qRA82H-dl5bKqCzC8H_YpR8cDa23K85f6s5Q2piOw95VO62mqn_YfOkLFVaSD_p0qCVKTLGRLeFDMzU3Ad-Lb8Ou0Yde3efa7diXO5QDVC7IjCQcrbQh-H30xBVpy24KfrSZJ1Uc" alt="" data-eio="l"></noscript></figure>
<em>Note that you’ll have to enable it separately for each new project you work on.&nbsp;</em>
<h3 id="emailtopic-40">Step 3: Credentials and authentication with OAuth 2.0</h3>
Once the API is enabled, you’ll be taken to a nice dashboard that says, “<em>To use this API, you may need credentials</em>”. 
If you click <k>Create credentials</k>, you’ll have to pass through a set of questions to find out what kind of credentials you need. 
We advise you to go another way since we already know what it is: OAuth client ID. 
So, click the Credential tab on the left, and then pick OAuth client ID from the drop-down list of the <k>Create Credentials</k> button.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/UwsT80hMiX5B1TjEg51gbqkkJ-iembuOfCu3cM9k1pdcv2mlleKht4k_FmeRFBwFApyuHkqb8Xgxut9dHybJAIQCtzfvul60Uh957dPXi3fRFrsU4ZjhTSZo_-8byEsxIy52jSRv"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/UwsT80hMiX5B1TjEg51gbqkkJ-iembuOfCu3cM9k1pdcv2mlleKht4k_FmeRFBwFApyuHkqb8Xgxut9dHybJAIQCtzfvul60Uh957dPXi3fRFrsU4ZjhTSZo_-8byEsxIy52jSRv" alt="" data-eio="l"></noscript></figure>
You’ll see the Configure consent screen button. 
It will bring you to a page with many fields. 
You can just enter the name of your app and specify authorized domains. 
Fill in other fields if you want.&nbsp;
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh5.googleusercontent.com/WAhpqm_Hwa640iUPpKK7eWRPDIPf2FlpQ7Y5XT2uKa9UrfO-i868IpL-O4orLMXSMT6wRnubrYzyZD0LRUSjKt9xJDSOdZSrZmjBTuDKj3w9pGHG2U_m_afZ8RlN9R2SXmDHcXht"><noscript><img class="lazy" data-src="https://lh5.googleusercontent.com/WAhpqm_Hwa640iUPpKK7eWRPDIPf2FlpQ7Y5XT2uKa9UrfO-i868IpL-O4orLMXSMT6wRnubrYzyZD0LRUSjKt9xJDSOdZSrZmjBTuDKj3w9pGHG2U_m_afZ8RlN9R2SXmDHcXht" alt="" data-eio="l"></noscript></figure>
Click save and then pick the type of your app (web app, Android, Chrome App, iOS, or other). 
After that, name your OAuth Client ID. 
Also, enter JavaScript origins and redirect domains for use with requests from a browser or a web server respectively. 
Click create to finalize.&nbsp;That’s it. 
Download a JSON file with your credentials – you’ll need it later. 

<h3 id="emailtopic-41">Step 4: Pick a quickstart guide&nbsp;</h3>
The next step is to select a quickstart guide according to the technology your app is built with. 
So far, there are the following options:

<a href="https://developers.google.com/gmail/api/quickstart/go" target="_blank">API for Go</a>
<a href="https://developers.google.com/gmail/api/quickstart/java" target="_blank">API for Java</a>
<a href="https://developers.google.com/gmail/api/quickstart/ruby" target="_blank">API for Ruby</a>
<a href="https://developers.google.com/gmail/api/quickstart/dotnet" target="_blank">API for .NET</a>
<a href="https://developers.google.com/gmail/api/quickstart/nodejs" target="_blank">API for Node.js</a>
<a href="https://developers.google.com/gmail/api/quickstart/php" target="_blank">API for PHP</a>
<a href="https://developers.google.com/gmail/api/quickstart/python" target="_blank">API for Python</a>
<a href="https://developers.google.com/gmail/api/quickstart/js" target="_blank">API for browser (JavaScript)</a>
For mobile apps, there are G Suite APIs for <a href="https://developers.google.com/gsuite/guides/ios" target="_blank">iOS</a> and <a href="https://developers.google.com/gsuite/guides/android" target="_blank">Android</a> as well.&nbsp;
What you need first in this quickstart guide is the Prerequisites section. 
Let’s say your choice is PHP. 
In this case, make sure your PHP version corresponds to the given one. 
Also, install the JSON extension and the Composer dependency management tool if you haven’t already. 
After that, you can install the Google Client Library. 
For Java, you’ll need to create a new project structure and the <code>src/main/resources/</code> directory. 
Then, copy the JSON file with credentials to this directory and replace the content of the <code>build.gradle</code> file with <a href="https://github.com/gsuitedevs/java-samples/blob/master/gmail/quickstart/build.gradle" target="_blank">this code</a>. 
So, pay attention when preparing your project.&nbsp;
<k><a href="https://mailtrap.io/register/signup?ref=anchor">Route your test emails to Mailtrap for safe testing.</a></k>
<h3 id="emailtopic-42">Step 5: API client library</h3>
Google provides client libraries to work with the API:
<a href="https://github.com/googleapis/google-api-go-client" target="_blank">API client for Go</a>
<code>Installation:
go get -u google.golang.org/api/gmail/v1
go get -u golang.org/x/oauth3/google</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-java-client" target="_blank">API client for Java</a>
</p><code>Installation via Gradle
repositories {
      mavenCentral()
  }
  dependencies {
      compile 'com.google.api-client:google-api-client:1.30.2' 
  }</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-ruby-client" target="_blank">API client for Ruby</a>
</p><code>Installation:
gem install google-api-client</code>
<p id="block-0c16e9a3-17ba-4365-9083-7f3c2b398e1b"><a href="https://github.com/googleapis/google-api-dotnet-client" target="_blank">API client for .NET</a>
</p><code>Installation via NuGet Package Manager Console:
Install-Package Google.Apis.Gmail.v1</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-nodejs-client" target="_blank">API client for Node.js</a>
</p><code>Installation via npm:
npm install googleapis@39 --save</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-php-client" target="_blank">API client for PHP</a>
</p><code>Installation via Composer:
composer require google/apiclient:"^2.0"</code>
<p id="block-1ca5a28f-7d04-490e-8921-d364e6d54b93"><a href="https://github.com/googleapis/google-api-python-client" target="_blank">API client for Python</a>
</p><code>Installation:
pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
or
easy_install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib</code>

<a href="https://github.com/google/google-api-javascript-client" target="_blank">API client for JavaScript</a> 
<a href="https://github.com/google/google-api-objectivec-client-for-rest/" target="_blank">API client for Objective-C</a> 
<a href="https://github.com/dart-lang/googleapis" target="_blank">API client for Dart</a>

<h3 id="emailtopic-43">Step 6: Access to Gmail</h3>
In this step, we need to authorize access to your Gmail account from the app, and then you’ll be able to manage emails. 
For this, you need to create a file in your working directory. 
Below you’ll find the specific file names for each technology. 
Copy-paste a corresponding code sample from the chosen Quickstart Guide and run it. 
Here are the links to the code samples: 
<h4>Go</h4>

Filename: <em>quickstart.go</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/go-samples/blob/master/gmail/quickstart/quickstart.go" target="_blank">Code sample for Go</a>
Run with: <code>go run quickstart.go</code>
<h4>Java</h4>

Flinename: <em>GmailQuickstart.java</em>
Directory: <em>src/main/java/</em>
<a href="https://github.com/gsuitedevs/java-samples/blob/master/gmail/quickstart/src/main/java/GmailQuickstart.java" target="_blank">Code sample for Java</a>
Run with: <code>gradle run</code>
<h4>Ruby</h4>

Filename: <em>quickstart.rb</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/ruby-samples/blob/master/gmail/quickstart/quickstart.rb" target="_blank">Code sample for Ruby</a>
Run with: <code>ruby quickstart.rb</code>
<h4>.NET</h4>

Filename: <em>GmailQuickstart.cs</em>
Directory: <em>gmail/GmailQuickstart/</em>
<a href="https://github.com/gsuitedevs/dotnet-samples/blob/master/gmail/GmailQuickstart/GmailQuickstart.cs" target="_blank">Code sample for .NET</a>
Run by clicking Start in the Visual Studio toolbar
<h4>Node.js</h4>

Filename: <em>index.js</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/node-samples/blob/master/gmail/quickstart/index.js" target="_blank">Code sample for Node.js</a>
Run with: <code>node .</code>
<h4>PHP</h4>

Filename: <em>quickstart.php</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/php-samples/blob/master/gmail/quickstart/quickstart.php" target="_blank">Code sample for PHP</a>
Run with: <code>php quickstart.php</code>
<h4>Python</h4>

Filename: <em>quickstart.py</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/python-samples/blob/master/gmail/quickstart/quickstart.py" target="_blank">Code sample for Python</a>
Run with: <code>python quickstart.py</code>
<h4>JavaScript (browser)</h4>

Filename: <em>index.html</em>
Directory: <em>gmail/quickstart/</em>
<a href="https://github.com/gsuitedevs/browser-samples/blob/master/gmail/quickstart/index.html" target="_blank">Code sample for browser (JavaScript)</a>
Replace &lt;YOUR_CLIENT_ID> with your client ID and &lt;YOUR_API_KEY> with your API key. 
Run with:
<code>python -m SimpleHTTPServer 8000</code> – for Python 2+
<code>python -m http.server 8000</code> – for Python 3+
It worked…or not. 
Google will warn you about a probable failure of the sample you run to open a new window in your default browser. 
If this happens, you’ll need to do it manually. 
Copy the URL from the console and paste it in the browser. 
It will look like this: 
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh3.googleusercontent.com/T1kyjSBNMmPyABN6RmOFOg50zCIqK8oKJdpLQYiwjK6tV8ZtNuCXGwdEKDxCW5R3ecG3OFxi3ieSLOrdLRZKN5Y_ZpOidLmLS89MxLJw2YiNZgE13xSeThSXhlFZY_xPceFkkyiK"><noscript><img class="lazy" data-src="https://lh3.googleusercontent.com/T1kyjSBNMmPyABN6RmOFOg50zCIqK8oKJdpLQYiwjK6tV8ZtNuCXGwdEKDxCW5R3ecG3OFxi3ieSLOrdLRZKN5Y_ZpOidLmLS89MxLJw2YiNZgE13xSeThSXhlFZY_xPceFkkyiK" alt="" data-eio="l"></noscript></figure>
Next, you’ll be asked to either log into your Google account or select one account for authorization. 
Press allow and you’ll see all your inbox labels in the SSH shell like this: 
<figure><img class="lazy" data-src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="" data-src="https://lh6.googleusercontent.com/Np1QRG1CulZGsyk8YCVECvoGilEbpDC5bnWlJoVPVlzmtRy9BDBo5AQ1TNphpoq97mPdWrb4Z33m5ZIb7pPyhmQmudhRUsJYYSO4vosez3R_ZRO636ToE0UJyA4i-PCn_N3M3NE7"><noscript><img class="lazy" data-src="https://lh6.googleusercontent.com/Np1QRG1CulZGsyk8YCVECvoGilEbpDC5bnWlJoVPVlzmtRy9BDBo5AQ1TNphpoq97mPdWrb4Z33m5ZIb7pPyhmQmudhRUsJYYSO4vosez3R_ZRO636ToE0UJyA4i-PCn_N3M3NE7" alt="" data-eio="l"></noscript></figure>
Congrats! Gmail API works and you can send your first email.
<h3 id="emailtopic-44">Step 7: Create an email</h3>
To send a message, first you need to create one. 
For this, your app can use the <em>drafts.create</em> method which includes:

Creation of a MIME message
Conversion of the message into a base64url encoded string
Creation of a draft
Let’s see how this is done in practice with Python:
<code>def create_message(sender, to, subject, message_text):
 message = MIMEText(message_text)
 message['to'] = to
 message['from'] = sender
 message['subject'] = subject
 raw_message = base64.urlsafe_b64encode(message.as_string().encode("utf-8"))
 return {
   'raw': raw_message.decode("utf-8")
 }
def create_draft(service, user_id, message_body):
 try:
   message = {'message': message_body}
   draft = service.users().drafts().create(userId=user_id, body=message).execute()
   print("Draft id: %s\nDraft message: %s" % (draft['id'], draft['message']))
   return draft
 except Exception as e:
   print('An error occurred: %s' % e)
   return None  </code>
and PHP 
<code>/**
* @param $sender string sender email address
* @param $to string recipient email address
* @param $subject string email subject
* @param $messageText string email text
* @return Google_Service_Gmail_Message
*/
function createMessage($sender, $to, $subject, $messageText) {
$message = new Google_Service_Gmail_Message();
$rawMessageString = "From: &lt;{$sender}>\r\n";
$rawMessageString .= "To: &lt;{$to}>\r\n";
$rawMessageString .= 'Subject: =?utf-8?B?' . 
base64_encode($subject) . 
"?=\r\n";
$rawMessageString .= "MIME-Version: 1.0\r\n";
$rawMessageString .= "Content-Type: text/html; charset=utf-8\r\n";
$rawMessageString .= 'Content-Transfer-Encoding: quoted-printable' . 
"\r\n\r\n";
$rawMessageString .= "{$messageText}\r\n";
$rawMessage = strtr(base64_encode($rawMessageString), array('+' => '-', '/' => '_'));
$message->setRaw($rawMessage);
return $message;
}
/**
* @param $service Google_Service_Gmail an authorized Gmail API service instance.
* @param $user string User's email address or "me"
* @param $message Google_Service_Gmail_Message
* @return Google_Service_Gmail_Draft
*/
function createDraft($service, $user, $message) {
$draft = new Google_Service_Gmail_Draft();
$draft->setMessage($message);
try {
  $draft = $service->users_drafts->create($user, $draft);
  print 'Draft ID: ' . 
$draft->getId();
} catch (Exception $e) {
  print 'An error occurred: ' . 
$e->getMessage();
}
return $draft;
}</code>
<a href="https://mailtrap.io/register/signup" target="_blank">Test Your Emails Now</a>
<h3 id="emailtopic-45">Step 8: Send an email</h3>
Once you have created your message, you can either call <em>messages.send</em> or <em>drafts.send</em> to send it. 
Here is how it may look: 
Python
<code>def send_message(service, user_id, message):
 try:
   message = service.users().messages().send(userId=user_id, body=message).execute()
   print('Message Id: %s' % message['id'])
   return message
 except Exception as e:
   print('An error occurred: %s' % e)
   return None</code>
and PHP
<code>/**
* @param $service Google_Service_Gmail an authorized Gmail API service instance.
* @param $userId string User's email address or "me"
* @param $message Google_Service_Gmail_Message
* @return null|Google_Service_Gmail_Message
*/
function sendMessage($service, $userId, $message) {
try {
  $message = $service->users_messages->send($userId, $message);
  print 'Message with ID: ' . 
$message->getId() . 
' sent.';
  return $message;
} catch (Exception $e) {
  print 'An error occurred: ' . 
$e->getMessage();
}
return null;
}</code>
<h3 id="emailtopic-46">Step 8.1: Send an email with attachments</h3>
You can also create and send a multi-part MIME message. 
For example, this is how it looks with Python: 
<code>def send_message(service, user_id, message):
 try:
   message = service.users().messages().send(userId=user_id, body=message).execute()
   print('Message Id: %s' % message['id'])
   return message
 except Exception as e:
   print('An error occurred: %s' % e)
   return None
def create_message_with_attachment(sender, to, subject, message_text, file):
 message = MIMEMultipart()
 message['to'] = to
 message['from'] = sender
 message['subject'] = subject
 msg = MIMEText(message_text)
 message.attach(msg)
 content_type, encoding = mimetypes.guess_type(file)
 if content_type is None or encoding is not None:
   content_type = 'application/octet-stream'
 main_type, sub_type = content_type.split('/', 1)
 if main_type == 'text':
   fp = open(file, 'rb')
   msg = MIMEText(fp.read().decode("utf-8"), _subtype=sub_type)
   fp.close()
 elif main_type == 'image':
   fp = open(file, 'rb')
   msg = MIMEImage(fp.read(), _subtype=sub_type)
   fp.close()
 elif main_type == 'audio':
   fp = open(file, 'rb')
   msg = MIMEAudio(fp.read(), _subtype=sub_type)
   fp.close()
 else:
   fp = open(file, 'rb')
   msg = MIMEBase(main_type, sub_type)
   msg.set_payload(fp.read())
   fp.close()
 filename = os.path.basename(file)
 msg.add_header('Content-Disposition', 'attachment', filename=filename)
 message.attach(msg)
 raw_message = base64.urlsafe_b64encode(message.as_string().encode("utf-8"))
 return {'raw': raw_message.decode("utf-8")}</code>
<k><a href="https://mailtrap.io/register/signup?ref=anchor">Test your emails before they are sent to real users.</a></k>
<h3 id="emailtopic-47">Step 9: Read a specific email from your inbox</h3>
It would be weird if you can’t use the API to read messages from Gmail. 
Luckily you can by using the <em>get</em> method by the message ID. 
Here is how it may look in a Python app: 
<code>import base64
import email
def get_messages(service, user_id):
 try:
   return service.users().messages().list(userId=user_id).execute()
 except Exception as error:
   print('An error occurred: %s' % error)
def get_message(service, user_id, msg_id):
 try:
   return service.users().messages().get(userId=user_id, id=msg_id, format='metadata').execute()
 except Exception as error:
   print('An error occurred: %s' % error)
def get_mime_message(service, user_id, msg_id):
 try:
   message = service.users().messages().get(userId=user_id, id=msg_id,
                                            format='raw').execute()
   print('Message snippet: %s' % message['snippet'])
   msg_str = base64.urlsafe_b64decode(message['raw'].encode("utf-8")).decode("utf-8")
   mime_msg = email.message_from_string(msg_str)
   return mime_msg
 except Exception as error:
   print('An error occurred: %s' % error)</code>
If the message contains an attachment, expand your code with the following: 
<code>def get_attachments(service, user_id, msg_id, store_dir):
 try:
   message = service.users().messages().get(userId=user_id, id=msg_id).execute()
   for part in message['payload']['parts']:
     if(part['filename'] and part['body'] and part['body']['attachmentId']):
       attachment = service.users().messages().attachments().get(id=part['body']['attachmentId'], userId=user_id, messageId=msg_id).execute()
       file_data = base64.urlsafe_b64decode(attachment['data'].encode('utf-8'))
       path = ''.join([store_dir, part['filename']])
       f = open(path, 'wb')
       f.write(file_data)
       f.close()
 except Exception as error:
   print('An error occurred: %s' % error)</code>
<h3 id="emailtopic-48">Why is Gmail API better or worse than traditional SMTP?&nbsp;</h3>
<h3 id="emailtopic-49">Email protocol used</h3>
Simple Mail Transfer Protocol (SMTP) is a set of rules for sending emails either from the sender to the email server or between servers. 
Most email service providers use SMTP to send and POP3/IMAP4 to receive emails. 
To learn more about these protocols, you can read our <a href="https://mailtrap.io/blog/imap-pop3-smtp/" target="_blank">IMAP vs. 
POP3 vs. 
SMTP</a> blog post. 
Google also provides the Gmail SMTP server as a free SMTP service. 
Application Programming Interface (API) is an interaction channel used by apps, platforms, and codes to reach each other. 
With Gmail API, you can send emails using only HyperText Transfer Protocol (HTTP), a set of rules that defines how messages are formatted and transmitted. 

<h3 id="emailtopic-50">How are emails sent?</h3>
You can call the API from the app to communicate with an email service that is used to send emails from another server.&nbsp;
For SMTP, a client establishes a TCP connection to the SMTP server and transfers an email. 
After authorization, the server sends the email to the recipient’s SMTP server, which, in turn, forwards it to the IMAP4 or POP3 server. 
Client and server communicate with each other using <a href="https://mailtrap.io/blog/smtp-commands-and-responses/" target="_blank">SMTP commands and responses</a>.
<h3 id="emailtopic-51">Authentication</h3>
Gmail API uses open authentication (Oauth3), which only lets you request the scope of access you need. 
SMTP provides full access to the account using client login and password <a href="https://mailtrap.io/blog/smtp-auth/" target="_blank">SMTP authentication</a>.
<h3 id="emailtopic-52">Quota</h3>
The usage limit of Gmail API is one billion quota units per day. 
Each method requires a particular number of quota units. 
For example, a <code>drafts.create</code> is 10 units and a <code>messages.send</code> is 100 units. 
Gmail API enforces standard daily <a href="https://support.google.com/a/answer/166852" target="_blank">mail sending limits</a>. 
Also, keep in mind that the <a href="https://mailtrap.io/blog/email-size/" target="_blank" aria-label="maximum email size in Gmail (opens in a new tab)">maximum email size in Gmail</a> is 25MB.
<h3 id="emailtopic-53">SMTP or API?</h3>
Each option has its own pros and cons. 
SMTP is a widely adopted and easy-to-set-up solution to send emails. 
Moreover, you don’t need any coding skills to handle stuff. 
Also, you can benefit from using a fake SMTP server such as <a href="https://mailtrap.io">Mailtrap</a> as a playground for safe email testing.
Besides, it is a great option to automate processes and provide a wide range of functionality for the app. 
Also, API can boast an extra level of security, which is crucial if you deal with sending sensitive data in emails. 


<h2>R set CORS-headers</h2>
<a href="https://www.rdocumentation.org/packages/jug/versions/0.1.7/topics/cors" class="whitebut ">set CORS-headers</a>
cors(jug, path = NULL,
     allow_methods = c("POST", "GET", "PUT", "OPTIONS", "DELETE", "PATCH"),
     allow_origin = "*", allow_credentials = NULL,
     allow_headers = NULL, max_age = NULL,
     expose_headers = NULL)


<a href="https://search.r-project.org/CRAN/refmans/beakr/html/cors.html" class="whitebut ">Allow Cross-Origin-Requests</a>

library(beakr)
# Create an new beakr instance
beakr <- newBeakr()

# beakr pipeline
beakr %>%
  # Enable CORS
  cors() %>%

  # Respond to GET requests at the "/hi" route
  httpGET(path = "/hi", function(req, res, err) {
    print("Hello, World!")
  }) %>%

  # Respond to GET requests at the "/bye" route
  httpGET(path = "/bye", function(req, res, err) {
    print("Farewell, my friends.")
  }) %>%

  # Start the server on port 25118
  listen(host = "127.0.0.1", port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/hi
# * http://127.0.0.1:25118/bye
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)


<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" class="whitebut ">Access_control_CORS</a>

<h2>Install Rcmdr package</h2>
install.packages("Rcmdr")
library(Rcmdr)


<h2>R charting</h2>
<a href="https://r-charts.com" class="whitebut ">R charts: </a>, Distribution, Correlation, Evolution, Spatial, Part of a whole, Ranking, Flow, Miscellaneous

<a href="https://reference.wolfram.com/language/ref/StreamPlot.html" class="whitebut ">StreamPlot x and y function {vx,vy} vector chart</a>

<a href="https://statsandr.com/blog/graphics-in-r-with-ggplot2/" class="whitebut ">Graphics with ggplot2</a>, Scatter plot, Line plot, Combination of line and points, Histogram, Density plot, Combination of histogram and densities, Boxplot, Barplot

<a href="https://www.r-graph-gallery.com/ridgeline-plot.html" class="whitebut ">ridgeline chart visualize the distribution of several numeric variables using the ridgelines package</a>
library(<span class="orange">ggridges</span>)
library(ggplot2)
ggplot(diamonds, aes(x = price, y = cut, fill = cut)) +
  geom_density_ridges() +
  theme_ridges() + 
  theme(legend.position = "none")


https://r-charts.com/part-whole/hclust/
Hierarchical cluster dendrogram with hclust
df <- USArrests[1:20, ]

Option 1: Plot the hierarchical clustering object with the plot function.
# Distance matrix
d <- dist(df)
# Hierarchical clustering
hc <- hclust(d)
# Dendrogram
plot(hc)

Option 2
Transform the hierarchical clustering output to dendrogram class with as.dendrogram. This will create a nicer visualization.

# Distance matrix
d <- dist(df)
# Hierarchical clustering
hc <- hclust(d)
# Dendrogram
plot(as.dendrogram(hc))



<h2>tcltk sample</h2>
require(tcltk)
mydialog <- function(){
       xvar <- tclVar("")
       yvar <- tclVar("")
       zvar <- tclVar("")
       tt <- tktoplevel()
       tkwm.title(tt,"MYTEST")
       x.entry <- tkentry(tt, textvariable=xvar)
       y.entry <- tkentry(tt, textvariable=yvar)
       z.entry <- tkentry(tt, textvariable=zvar)
       reset <- function() {
         tclvalue(xvar)<-""
         tclvalue(yvar)<-""
         tclvalue(zvar)<-""
        }
       reset.but <- tkbutton(tt, text="Reset", command=reset)
       submit <- function() {
         x <- as.numeric(tclvalue(xvar))
         y <- as.numeric(tclvalue(yvar))
         z <- as.numeric(tclvalue(zvar))
         tkmessageBox(message=paste("x + y + z = ", x+y+z, ""))
       }
       submit.but <- tkbutton(tt, text="submit", command=submit)
       
       quit.but <- tkbutton(tt, text = "Close Session", 
           command = function() {
           q(save = "no")
           tkdestroy(tt)
           }
        )
       tkgrid(tklabel(tt,text="Put your variables.."),columnspan=3, pady = 10)
       tkgrid(tklabel(tt,text="x variable"), x.entry, pady= 10, padx= 10)
       tkgrid(tklabel(tt,text="y variable"), y.entry, pady= 10, padx= 10)
       tkgrid(tklabel(tt,text="z variable"), z.entry, pady= 10, padx= 10)
       tkgrid(submit.but, reset.but, quit.but, pady= 10, padx= 10)
    }
mydialog()

<h2>Executing R from Python and Vice Versa</h2>
Command Line Execution and Executing Subprocesses
To better understand what’s happening when a subprocess is executed, it is worth revisiting in more detail what happens when a Python or R process is executed on the command line. When the following command is run, a new Python process is started to execute the script.

python path/to/myscript.py arg1 arg2 arg3

During executing, any outputs that are printed to the standard output and standard error streams are displayed back to the console. The most common way this is achieved is via a built in function (print() in Python and cat() or print() in R), which writes a given string to the stdout stream. The Python process is then closed once the script has finished executing.

Running command line scripts in this fashion is useful, but can become tedious and error prone if there are a number of sequential but separate scripts that you wish to execute this way. However it is possible for a Python or R process to execute another directly in a similar way to the above command line approach. This is beneficial as it allows, say a parent Python process to fire up a child R process to run a specific script for the analysis. The outputs of this child R process can then be passed back to the parent Python process once the R script is complete, instead of being printed to the console. Using this approach removes the need to manually execute steps individually on the command line.

Examples
To illustrate the execution of one process by another we are going to use two simple examples: one where Python calls R, and one where R calls Python. The analysis performed in each case is trivial on purpose so as to focus on the machinery around how this is achieved.

Sample R Script
Our simple example R script is going to take in a sequence of numbers from the command line and return the maximum.

# max.R

# Fetch command line arguments
myArgs <- commandArgs(trailingOnly = TRUE)

# Convert to numerics
nums = as.numeric(myArgs)

# cat will write the result to the stdout stream
cat(max(nums))

Executing an R Script from Python
To execute this from Python we make use of the subprocess module, which is part of the standard library. We will be using the function, check_output to call the R script, which executes a command and stores the output of stdout.

To execute the max.R script in R from Python, you first have to build up the command to be executed. This takes a similar format to the command line statement we saw in part I of this blog post series, and in Python terms is represented as a list of strings, whose elements correspond to the following:

['<command_to_run>', '<path_to_script>', 'arg1' , 'arg2', 'arg3', 'arg4']

An example of executing an R script form Python is given in the following code.

# run_max.py
import subprocess

# Define command and arguments
command ='Rscript'
path2script ='path/to your script/max.R'

# Variable number of args in a list
args = ['11','3','9','42']

# Build subprocess command
cmd = [command, path2script] + args

# check_output will run the command and store to result
x = subprocess.check_output(cmd, universal_newlines=True)

print('The maximum of the numbers is:', x)

The argument universal_newlines=True tells Python to interpret the returned output as a text string and handle both Windows and Linux newline characters. If it is omitted, the output is returned as a byte string and must be decoded to text by calling x.decode() before any further string manipulation can be performed.

Sample Python Script
For our simple Python script, we will split a given string (first argument) into multiple substrings based on a supplied substring pattern (second argument). The result is then printed to the console one substring per line.

# splitstr.py
import sys

# Get the arguments passed in
string = sys.argv[1]
pattern = sys.argv[2]

# Perform the splitting
ans = string.split(pattern)

# Join the resulting list of elements into a single newline
# delimited string and print
print('\n'.join(ans))

Executing a Python Script from R
When executing subprocess with R, it is recommended to use R’s system2 function to execute and capture the output. This is because the inbuilt system function is trickier to use and is not cross-platform compatible.

Building up the command to be executed is similar to the above Python example, however system2 expects the command to be parsed separately from its arguments. In addition the first of these arguments must always be the path to the script being executed.

One final complication can arise from dealing with spaces in the path name to the R script. The simplest method to solve this issue is to double quote the whole path name and then encapsulate this string with single quotes so that R preserves the double quotes in the argument itself.

An example of executing a Python script from R is given in the following code.

# run_splitstr.R

command ="python“

# Note the single + double quotes in the string (needed if paths have spaces)
path2script='"path/to your script/splitstr.py"'

# Build up args in a vector
string ="3523462---12413415---4577678---7967956---5456439"
pattern ="---"
args = c(string, pattern)

# Add path to script as first arg
allArgs = c(path2script, args)

output = system2(command, args=allArgs, stdout=TRUE)

print(paste("The Substrings are:\n", output))

To capture the standard output in a character vector (one line per element), stdout=TRUE must be specified in system2, else just the exit status is returned. When stdout=TRUE the exit status is stored in an attribute called “status”.

Summary
It is possible to integrate Python and R into a single application via the use of subprocess calls. These allow one parent process to call another as a child process, and capture any output that is printed to stdout. In this post we have gone through examples of using this approach to get an R script to call Python and vice versa.

In a future upcoming article will draw on the material of this post and part I, to show a real world example of using Python and R together in an application.


<h2>R make an infix operator</h2>

`%+=%` = function(e1,e2) eval.parent(substitute(e1 <- e1 + e2))
x = 1
x %+=% 2 ; x


implement increment operator

inc <- function(x)
{
 eval.parent(substitute(x <- x + 1))
}
In that case you would call

x <- 10
inc(x)

Increment and decrement by 10.
require(Hmisc)
inc(x) <- 10 

dec(x) <- 10


<h2>R to run vbs script</h2>
setwd("C:/Users/william/Desktop/vbscript")
system("cscript dropdownList.vbs")
system("wscript dropdownList.vbs")


<h2>R convert html space to normal space</h2>
keywordList = gsub("[[:space:]]"," ",keywordList)

The &nbsp stands for "non-breaking space" which, in the unicode space, has it's own distinct character from a "regular" space (ie " ").
The &nbsp stands for "non-breaking space" which, in the unicode space, has it's own distinct character from a "regular" space (ie " ").

charToRaw(" foo")
# [1] 20 66 6f 6f

<h2>R to call C function</h2>
use the Rcpp package.
It allows you to write C++ functions directly in R.

http://adv-r.had.co.nz/Rcpp.html.
C++ functions can be done very fast with these instructions.

library("Rcpp")
cppFunction("
NumericVector addOneToVector(NumericVector vector) {
  int n = vector.size();

  for (int i = 0; i < n; ++i)
    vector[i] = vector[i] + 1.0;

  return vector;
}")


Here's a small C code

Step 1: Write the C Program
#include <stdio.h>
int func_test() {
    for(int i = 0; i < 5; i++) {
        printf("The value of i is: %d\n", i);
    }
    return 0;
}

Step 2: Compile the program using
R CMD SHLIB func_test.c
This will produce a func_test.so file

Step 3: Now write the R Code that invokes this C function from within R Studio
dyn.load("/users/my_home_dir/xxx/ccode/ac.so")
.C("func_test")

Step 4: Output:
.C("func_test")
The value of i is: 0
The value of i is: 1
The value of i is: 2
The value of i is: 3
The value of i is: 4
list()

Then tried the direct method
library("Rcpp")
cppFunction("
NumericVector addOneToVector(NumericVector vector) {
  int n = vector.size();
  for (int i = 0; i < n; ++i)
    vector[i] = vector[i] + 1.0;
  return vector;
}")

# Test code to test the function
addOneToVector(c(1,2,3))
Both methods worked superbly. I can now start writing functions in C or C++ and use them in R


<h2>Three ways to call C/C++ from R</h2>
<img class="lazy" data-src="https://i0.wp.com/1.bp.blogspot.com/-TuuDIWPa0BE/Ush1COW99KI/AAAAAAAAAMg/wrtcDh9kQXY/s1600/C1.PNG?w=578"> 
the function f(<em>x</em>)= 2<em>x</em>. 
<h2>The .C function interface</h2>
Inside a running R session, the .C interface allows objects to be directly accessed in an R session's active memory. 
Thus, to write a compatible C function, <em>all arguments must be pointers</em>. 
No matter the nature of your function's return value, it too must be handled using pointers. 
The C function you will write is effectively a subroutine. 
Our function f(<em>x</em>)= 2<em>x</em>, implemented as double_me in the file doubler.c, is shown below. 
void double_me(int* x) {
 // Doubles the value at the memory location pointed to by x
 *x = *x + *x;
}
 To compile the C code, run the following line at your terminal:
$ R CMD SHLIB doubler.c 
In an R interactive session, run:
dyn.load(&quot;doubler.so&quot;)
.C(&quot;double_me&quot;, x = as.integer(5))
$x
[1] 10
Notice that the output of .C is a list with names corresponding to the arguments. 
While the above code is pure C, adding C++ code (instead of C) is made possible by using the <a href="https://cran.r-project.org/doc/manuals/R-exts.html#Interfacing-C_002b_002b-code">extern wrapper</a>. 

<h2>.Call interface</h2>
The .Call interface is the more fully featured and complex cousin of the .C interface. 
Unlike .C, .Call requires header files that come standard with every R installation. 
These header files provide access to a new data type, SEXP. 
The following code, stored in the file, doubler2.c, illustrates its use. 
#include &lt;R.h>
#include &lt;Rdefines.h>
SEXP double_me2(SEXP x) {
 // Doubles the value of the first integer element of the SEXP input
 SEXP result;
 PROTECT(result = NEW_INTEGER(1)); // i.e., a scalar quantity
 INTEGER(result)[0] = INTEGER(x)[0] * 2;
 UNPROTECT(1); // Release the one item that was protected
 return result;
}
Unlike our experience with the .C interface, double_me2 is a function and  does return a value. 
While that appeals to intuition, no matter what the native input and output types, they must now live in a SEXP object. 
To code double_me2, you must know that there's an integer in the input x, and extract it as if it were the first item in a C array. 
For the return value, you must add your integer result to a SEXP object in an equally unnatural way. 
The PROTECT function must be used to prevent R's automatic garbage collection from destroying all the objects. 

As before, use R at the command line to compile doubler2.c:
$ R CMD SHLIB doubler2.c 
 Back in the R interactive console, the steps are very similar. 
dyn.load(&quot;doubler2.so&quot;)
.Call(&quot;double_me2&quot;, as.integer(5))

[1] 10
Notice now that the output is an integer vector instead of a list. 
 
<h2>Rcpp and the sourceCpp function</h2>
The .C and .Call examples above owe a debt to Jonathan Callahan's entries <a href="http://mazamascience.com/WorkingWithData/?p=1067">8</a> and <a href="http://mazamascience.com/WorkingWithData/?p=1099">10</a> of his <a href = "http://mazamascience.com/WorkingWithData/?series=using-r">Using R</a> series. 
When the examples started working, I tweeted to share my excitement.
Let's check it out. 
 
In terms of the code alone, it's easy to see where Hadley is coming from. 
It's readable, looks just like standard C++ code, and features data types that make intuitive sense. 
Our simple function is implemented below, saved in the final static file doubler3.cpp (though, in all humility, it's really just C). 
#include &lt;Rcpp.h>
using namespace Rcpp;
// [[Rcpp::export]]
int double_me3(int x) {
 // takes a numeric input and doubles it
 return 2 * x;
}
I'll refer you to Hadley's article <a href="http://adv-r.had.co.nz/Rcpp.html">High performance functions with Rcpp</a> for details on Rcpp, but for now, note the &#8220;// [[Rcpp::export]]&#8221; comment, necessary before each C/C++ function, and the updated #include statement. 
Most importantly, notice how the pointers and SEXP objects have been replaced. 
Just like our original function f(<em>x</em>), double_me3 takes one integer input and returns one integer output. 
 
After installing the Rcpp package, we're back to the console one final time. 
library(Rcpp)
sourceCpp(&quot;doubler3.cpp&quot;)
double_me3(5)

[1] 10
With Rcpp, the function is waiting for us in the global environment, without even compiling at the command line. 
Pretty convenient!  

<h2>run Python in R</h2>
In addition to reticulate, you need Python installed on your system. 
You also need any Python modules, packages, and files your Python code depends on.

If you'd like to follow along, install and load reticulate with <code>install.packages("reticulate")</code> and <code>library(reticulate)</code>.

To keep things simple, let's start with just two lines of Python code to import the <a href="http://www.numpy.org/" rel="noopener nofollow" target="_blank" title="NumPy">NumPy package</a> for basic scientific computing and create an array of four numbers. 
The Python code looks like this:
import numpy as np
my_python_array = np.array([2,4,6,8])

And here’s one way to do that right in an R script:

py_run_string("import numpy as np")
py_run_string("my_python_array = np.array([2,4,6,8])")

The <code>py_run_string()</code> function executes whatever Python code is within the parentheses and quotation marks. 

If you run that code in R, it may look like nothing happened. 
Nothing shows up in your RStudio environment pane, and no value is returned. 
If you run <code>print(my_python_array)</code> in R, you get an error that <code>my_python_array</code> doesn't exist.

But if you run a <em>Python</em> print command inside the <code>py_run_string()</code> function such as 
py_run_string("for item in my_python_array: print(item)")

you should see a result. 

It’s going to get annoying running Python code line by line like this, though, if you have more than a couple of lines of code. 
So there are a few other ways to run Python in R and reticulate.

One is to put all the Python code in a regular .py file, and use the <code>py_run_file()</code> function. 
Another way I like is to use an R Markdown document. 

R Markdown lets you combine text, code, code results, and visualizations in a single document. 
R Markdown lets you combine text, code, code results, and visualizations in a single document. 
You can create a new R Markdown document in RStudio by choosing File > New File > R Markdown.

Code chunks start with three backticks (<code>```</code>) and end with three backticks, and they have a gray background by default in RStudio.

This first chunk is for R code—you can see that with the <code>r</code> after the opening bracket. 
It loads the reticulate package and then you specify the version of Python you want to use. 
(If you don’t specify, it’ll use your system default.)
```{r setup, include=FALSE, echo=TRUE}
library(reticulate)
use_python("/usr/bin/python")
```

This second chunk below is for Python code. 
You can type the Python like you would in a Python file. 
The code below imports NumPy, creates an array, and prints the array.
```{python}
import numpy as np
my_python_array = np.array([2,4,6,8])
for item in my_python_array:
    print(item)
```

Here’s the cool part: You can use that array in R by referring to it as <code>py$my_python_array</code> (in general, <code>py$objectname</code>).

In this next code chunk, I store that Python array in an R variable called <code>my_r_array</code>. 
And then I check the class of that array.
```{r}
my_r_array &lt;- py$my_python_array
class(my_r_array)
``

It’s a class “array,” which isn’t exactly what you’d expect for an R object like this. 
But I can turn it into a regular vector with <code>as.vector(my_r_array)</code> and run whatever R operations I’d like on it, such as  multiplying each item by 2. 

```{r}
my_r_vector &lt;- as.vector(py$my_python_array)
class(my_r_vector)
my_r_vector &lt;- my_r_vector * 2
```

Next cool part: I can use that R variable back in Python, as <code>r.my_r_array</code> (more generally, <code>r.variablename</code>), such as 
```{python}
my_python_array2 = r.my_r_vector
print(my_python_array2)
```

<h2>to avoid command error</h2>
error: not recognized as an internal or external command,
operable program or batch file.
use double quote to contain the command

<h2>to toggle a boolean<h2>
audioSwitch = FALSE
audioSwitch = !audioSwitch

<h2>to let go of memory</h2>
magick refuses to let go of memory
Running a gc() fixes this issue


<h2>two options to kill processes</h2>
## Option 1
system("taskkill /im java.exe /f", intern=FALSE, ignore.stdout=FALSE)
## Option 2
system(paste0("Taskkill /F /T" ," /PID ", pid = rD$server$process$get_pid()))


<h2>take screenshots using Selenium</h2>
https://github.com/wch/webshot
library(webshot)
webshot("https://www.r-project.org/", "r.png")

Using RSelenium
library(RSelenium)
pDrv <- phantomjs(port = 4569L)
remDr <- remoteDriver(browserName = "phantomjs", port = 4569L)
remDr$open()
remDr$navigate("http://www.r-project.org")
remDr$screenshot(file = tf <- tempfile(fileext = ".png"))
shell.exec(tf) # on windows
remDr$close()
rD$server$stop()

<h2>RSelenium</h2>
#The RSelenium::phantom function is deprecated.
# Alternatively using the wdman package

library(RSelenium)
library(wdman)
pDrv <- phantomjs(port = 4569L)
remDr <- remoteDriver(browserName = "phantomjs", port = 4569L)
remDr$open()
remDr$navigate("http://www.google.com/ncr")
...
...
# clean up
remDr$close()
pDrv$stop()


to avoid keep reassigning random port numbers
library(netstat)
rD <- rsDriver(verbose = TRUE,
               port= free_port(), 
               browserName = 'chrome', 
               chromever = '83.0.4103.39',
               check = TRUE)

Doing all three of the below should cover most cases:

remDr$close()
rm(rD)
gc()


<h2>Integration between R and php</h2>
There are several options, but one option is to use RApache. 
Install RApache as indicated in http://rapache.net/manual.html

Set the Apache directive in httpd.conf which will make sure all files under /var/www/brew are parsed as R scripts

<Directory /var/www/brew>
  SetHandler r-script
  RHandler brew::brew
</Directory>

Make your R script with your API with file name plot.R and put it under the /var/www/brew folder. 

This R script file can e.g. look as follows:
<%
library(rjson)
args <- GET
tmp <- lapply(args, FUN=function(x) strsplit(x, " "))
typeOfData <- tmp[[1]][1]
month <- tmp[[2]][1]
year <- tmp[[3]][1]
output <- list(imgname="imgs/tmax.tiff")
cat(toJSON(output))
%>

Mark the GET

Now you can call your API from PHP as you would call any other webservice by calling http://localhost/brew/plot.R?typeOfData=1&month=2&year=2014. 
Replace localhost with the IP of the server where you are hosting the API.

When using RApache, each time you get GET, POST, COOKIES, FILES, SERVER variables which were passed on to the API call. 
So if you want to use POST in your call instead of the GET example, go ahead. 
See the documentation in http://rapache.net/manual.html for these variables.

Check out <a href="https://github.com/cturbelin/rserve-php" class="whitebut ">Rserve-php</a>. 
It uses Rserve as a backend which is a TCP/IP server for R.

Have a look at <a href="https://github.com/kachkaev/php-r" class="whitebut ">php-r</a> library on github, it lets you execute R code from PHP (having R interpreter installed on your machine).

<h2>How to Integrate R with PHP</h2>
This tutorial explains how to integrate R with PHP.

Online reporting tools have gained popularity in recent years. 
There is a growing demand to implement advanced analytics in these tools. 
Use of advanced analytics help to solve various organization problems such as retaining existing customers or acquiring new customers, increasing customer satisfaction etc.

PHP is one of the most popular programming language to develop websites and online reporting tools. 
It has rich functionality to write business logic, however they are not effective when it comes to data science and machine learning. 
In the field of data science, R dominates in terms of popularity among statisticians and data scientists with over 10k number of packages.

<b>How to make PHP communicate with R</b>
There are times when you want to showcase the output of R program like charts that you create based on the user inputted data from a web page. 
In that case you might want your PHP based web application to communicate with the R script.

<b>When it comes to PHP, it has a very useful function called</b> <b>exec().</b> 
It lets you execute the outside program you provide as the source. 
We will be using the very same function to execute the R script you created. 
The then generates the graph and we will show the graph in our web page.

The <b>exec function</b> can be used on both the Linux and Windows environments.
On the Linux environment it will open the terminal window to execute the command you set and arguments you specify. 

While on the Windows environment it will open the CMD to execute the command you provide along with the arguments you specify.

I will walk you through the process of integrating the R code with PHP web page with code and explanation.&#8195;

<b>Let's first create a PHP based web form:</b>

<b>index.php:</b>
<blockquote>
&lt;html>
  &lt;head>
    &lt;title>PHP and R Integration Sample&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;div id=&#8221;r-output&#8221; id=&#8221;width: 100%; padding: 25px;&#8221;>
    &lt;?php
      // Execute the R script within PHP code
      // Generates output as test.png image.
      exec("sample.R");
    ?>
    &lt;img class="lazy" data-src=&#8221;test.png?var1.1&#8221; alt=&#8221;R Graph&#8221; />
    &lt;/div>
  &lt;/body>
&lt;/html></blockquote>
Now save the file as index.php under your <b>/htdocs/PROJECT-NAME/index.php.</b>

<b>Let's create a sample chart using R code.</b>
Write the following code and save it as <b>sample.R file</b>.
<blockquote>
x &lt;- rnorm(6,0,1)
png(filename="test.png", width=500, height=500)
hist(x, col="red")
dev.off()</blockquote>

<img class="lazy" data-src="https://3.bp.blogspot.com/-35PXxfvHn5o/WOpvdiPrIgI/AAAAAAAAGHA/AQndI2BK3ZEQJjT2ccfsX8z8ConCuelvACLcB/s1600/Histogram.png">
Histogram
<b>rnorm(6, 0 ,1)</b> means generating 6 random values with mean 0 and standard deviation 1. 
The dev.off() command is used to close the graph. 
Once chart created it will save it as the test.png file.
<blockquote>
The only downside of this code is that it will create the same test.png file for all the incoming requests. 
Meaning if you are creating charts based on user specified inputs, there will always be one test.png file created for various purpose.</blockquote>
<b>Let's understand the code</b>
As specified earlier the exec('<b>sample.R'</b>); will execute the R script. 
It in turn generates the test.png graph image.

In the very next line we used the HTML &lt;img /> tag to display the R program generated image on the page. 
We used the src=test.png?ver1.1 where ver1.1 is used to invalidate the browser cache and download the new image from server.

All modern browsers supports the browser caching. 
You might have experienced some website loads way faster on your repetitive visits. 
It's due to the fact that browsers cache the image and other static resources for brief period of time.

<b>How to serve concurrent requests?</b>

<b>sample2.R</b>
<blockquote>
args &lt;- commandArgs(TRUE)
cols &lt;- args[1]
fname &lt;- args[2]
x &lt;- rnorm(cols,0,1)
fname = paste(fname, "png", sep = ".")
png(filename=fname, width=500, height=500)
hist(x, col="red") dev.off()</blockquote>
<b>Index.php</b>
<blockquote>
&lt;html>
  &lt;head>
    &lt;title>PHP and R Integration Sample&lt;/title>
  &lt;/head>
  &lt;body>
    &lt;div id=&#8221;r-output&#8221; id=&#8221;width: 100%; padding: 25px;&#8221;>
    &lt;?php
      // Execute the R script within PHP code
      // Generates output as test.png image.
      $filename = &#8220;samplefile&#8221;.rand(1,100);
      exec("sample2.R 6 &#8220;.$filename.");
    ?>
    &lt;img class="lazy" data-src=&#8221;.$filename.&#8221;.png?var1.1&#8221; alt=&#8221;R Graph&#8221; />
    &lt;/div>
  &lt;/body>
&lt;/html></blockquote>
It will help you eliminate the need to using the same test.png file name. 
I have used the $filename=&#8221;samplefile&#8221;. 
You can use any random sequence as I have used in the end of the samplefile name. 
rand(min, max) will help you generate a random number.

It will help you fix the file overwriting issue. 
And you will be able to handle the concurrent requests and server each with unique set of image(s).

You might need to take care of old file removals. 
If you are on a linux machine you can setup a cron job which will find and delete the chart image files those are older than 24 hours.

<b>Here is the code to find and remove files:</b>

<b>Delete.php</b>
<blockquote>
&lt;?php
// set the path to your chart image directory
$dir = "images/temp/";
// loop through all the chart png files inside the directory.
foreach (glob($dir."*.png") as $file) {
// if file is 24 hours old then delete it
if (filemtime($file) &lt; time() - 86400) {
    unlink($file);
    }
}
?></blockquote>
<b>Conclusion</b>
Making PHP communicate with R and showcase the result is very simple. 
You might need to understand the exec() function and some PHP code if in-case you want to delete those residual files/images generated by your R program.


<h2>PHP 呼叫 R 整合教學，線上資料分析與繪圖工具開發</h2>
如果您想要開發一個線上分析資料的工具，網頁部份可以使用 PHP、HTML、JavaScript 與 CSS 等傳統技術來處理，而資料的統計分析與繪圖則可以借重 R 語言來解決，以下是常見的幾種 PHP 與 R 語言的整合方式與範例程式碼。

<h3>PHP 執行外部 R 指令稿</h3>
建立一個 PHP 指令稿，將其命名為 <code>r.php</code>，內容如下：
&lt;html>
&lt;body>
&lt;form action='r.php' method='get'>
輸入 N 值: &lt;input type='text' name='n' />
&lt;input type='submit' />
&lt;/form>
&lt;?php
if(isset($_GET['n'])) {
  $n = $_GET['n'];
  // 以外部指令的方式呼叫 R 進行繪圖
  exec("Rscript script.R $n");
  // 產生亂數
  $nocache = rand();
  // 輸出圖檔
  echo("&lt;img class="lazy" data-src='output/hist.png?$nocache' />");
}
?>
&lt;/body>&lt;/html>

上面這段程式碼的上半部是一個普通的 HTML form，可以用來送出使用者所輸入的參數，而下半部則是 PHP 的程式碼，在接收使用者輸入的 <code>n</code> 值之後，透過 PHP 的 <code>exec</code> 執行外部程式，而 <code>Rscript</code> 這個程式則是附屬在 R 中的一個程式，只要安裝好 R 之後系統上就會有這個程式，它是專門用來執行 R 指令稿的工具程式。

最後在執行完 R 指令稿之後，要顯示繪圖的結果，由於我們每一次所繪製的圖檔檔名都一樣，所以需要在圖檔後方加上一串亂數，強迫讓瀏覽器重新抓取新的圖檔（也就是不要使用瀏覽器的快取），這樣每次送出新的 <code>n</code> 值才會顯示新的結果。

以下是 <code>script.R</code> 這一個 R 指令稿的內容：
args &lt;- commandArgs(TRUE)
# 取得使用者輸入的 N 值
n &lt;- args[1]
# 產生資料
x &lt;- rnorm(n, 0, 1)
# 繪製直方圖
png(filename="output/hist.png", width = 500, height = 300)
hist(x, col = "orange")
dev.off()

在 R 中我們透過 <code>commandArgs</code> 取得從 shell 中傳入的參數，其中第一個參數就是使用者輸入的 <code>n</code> 值，藉由這樣的方式就可以取得從 PHP 傳過來的資料。
接著產生一些常態分佈的亂數資料，並繪製一張直方圖，我們將圖形儲存至 <code>output</code> 這個目錄中，然後再讓網頁直接讀取這個圖檔，這樣就可以將結果傳給使用者。

這裡我是規劃 <code>output</code> 目錄專門用來放置輸出的圖檔，由於 R 的指令稿會以執行網頁伺服器的使用者（在 Ubuntu Linux 中通常是 <code>www-data</code>）權限來執行，所以請注意目錄權限的設定，要讓伺服器有權限可以寫入這個目錄。

執行的結果會像這樣：
<img class="lazy" data-src="https://blog.gtwang.org/wp-content/uploads/2016/11/integrating-php-and-r-20161101-1.png">

PHP 呼叫 R 的網頁
<h3>PHP 開啟管線執行 R 指令稿</h3>
以 PHP 的 <code>exec</code> 執行外部的 R 指令稿是一個比較簡單的方式，不過缺點就是它需要另外建立一個單獨的 R 指令稿，如果不想要另外建立一個 R 檔案，可以改用 <code>proc_open</code> 的方式，直接把 R 的指令從 PHP 中透過 Linux 的管線（pipe）寫到 R 的行程（process）中，這樣就可以省去建立 R 檔案的麻煩，以下是一個簡單的範例：
&lt;html>&lt;body>
&lt;form action='r.php' method='get'>
輸入 N 值: &lt;input type='text' name='n' />
&lt;input type='submit' />
&lt;/form>
&lt;?php
if(isset($_GET['n'])) {
  $n = $_GET['n'];

  $descriptorspec = array(
    0 => array(&quot;pipe&quot;, &quot;r&quot;),             // stdin
    1 => array(&quot;file&quot;, &quot;/tmp/output.txt&quot;, &quot;w&quot;),// stdout
    2 => array(&quot;file&quot;, &quot;/tmp/error.txt&quot;, &quot;w&quot;) // stderr
  );

  // 以管線的方式執行 R 指令稿進行繪圖
  $rproc = proc_open(&quot;R --vanilla&quot;, $descriptorspec, $pipes);

  if (is_resource($rproc)) {

    fwrite($pipes[0], &quot;x &lt;- rnorm($n, 0, 1);&quot;);
    fwrite($pipes[0], &quot;png(filename='output/hist.png', width = 500, height = 300);&quot;);
    fwrite($pipes[0], &quot;hist(x, col = 'orange');&quot;);
    fwrite($pipes[0], &quot;dev.off();&quot;);

    fclose($pipes[0]);

    proc_close($rproc);

    // 產生亂數
    $nocache = rand();

    // 輸出圖檔
    echo(&quot;&lt;img class="lazy" data-src='output/hist.png?$nocache' />&quot;);
  }
}
?>
&lt;/body>&lt;/html>

這個範例我們利用 <code>proc_open</code> 從 PHP 中開啟一個 R 的行程，在開啟新的行程之前，要先以 <code>$descriptorspec</code> 設定好新行程的標準輸入、標準輸出與標準錯誤，此處我們將新 R 行程的標準輸入指定為管線，方便我們直接從 PHP 寫入資料，而 R 的輸出與錯訊息則是導入兩個暫存檔中，通常在開發階段這樣可以方便我們檢視程式是否有正確執行，除錯也比較方便。

將 R 的指令都寫入 R 的行程之後，在呼叫 <code>proc_close</code> 關閉 R 行程之前，要記得先將所有的管線關閉，避免造成 deadlock。
最後一樣照舊將圖檔顯示在網頁上，不管是使用 <code>proc_close</code> 還是 <code>exec</code> 來整合 PHP 與 R，顯示出來的效果看起來都相同，只有內部的程式結構上有些差異而已。
<h2>R basic statistics functions</h2>
http://www.sthda.com/english/wiki/descriptive-statistics-and-graphics

mean():  Mean
sd():  Standard deviation
var():  Variance
min():  Minimum
maximum():  Maximum
median():  Median
range():  Range of values (minimum and maximum)
quantile():  Sample quantiles
summary():  Generic function
IQR():  Interquartile range

Measure of central tendency: mean, median, mode
Measure of variablity: gives how “spread out” the data are.
Range: minimum & maximum
Interquartile range: quantile(x, probs = seq(0, 1, 0.25))
Variance and standard deviation: represents the average squared deviation from the mean. The standard deviation is the square root of the variance. It measures the average deviation of the values, in the data, from the mean value.
Median absolute deviation: (MAD) measures the deviation of the values, in the data, from the median value.

Computing an overall summary: summary() function

Case of missing values: na.rm = TRUE
mean(my_data$Sepal.Length, na.rm = TRUE)

<h2>Find Index of an Element in a R Vector</h2>
which(), match()

x <- c(5,6,8,9,7,5,7,8)
which(x == 7)
which(x %in% c(7,8))
match(7,x)
match(c(7,8),x)

<h2>23 RStudio Tips, Tricks, and Shortcuts</h2>
Published: June 10, 2020
<img class="lazy" data-src="https://www.dataquest.io/wp-content/uploads/2020/06/rstudio-tips-tricks-shortcuts-1.png">RStudio is an open-source tool for programming in R. 
If you are interested in programming with R, it’s worth knowing about the capabilities of RStudio. 
It is a flexible tool that helps you create readable analyses, and keeps your code, images, comments, and plots together in one place.

In this blog post, we’ll cover some of the best features from the free version of RStudio: <a href="https://rstudio.com/products/rstudio/download/" style="outline: none;">RStudio Desktop</a>. 
We’ve collected some of the top RStudio tips, tricks, and shortcuts to quickly turn you into an RStudio power user!

> install.packages("Dataquest")
Start learning R today with our <a href="/course/intro-to-r/">Introduction to R course</a> — no credit card required!
<a class="btn btn-success" href="https://app.dataquest.io/signup">SIGN UP</a>


<h3>1. Navigate Quickly Between Window Panes</h3>
RStudio window panes keep important information about your project accessible. 
Knowing how to toggle between panes without touching your mouse to move your cursor will save time and improve your workflow. 
Use these shortcuts to instantly move between panes:


<code>Control/Ctrl + 1</code>: Source editor (your script)
<code>Control/Ctrl + 2</code>: Console
<code>Control/Ctrl + 3</code>: Help
<code>Control/Ctrl + 4</code>: History
<code>Control/Ctrl + 5</code>: Files
<code>Control/Ctrl + 6</code>: Plots
<code>Control/Ctrl + 7</code>: Packages
<code>Control/Ctrl + 8</code>: Environment
<code>Control/Ctrl + 9</code>: Viewer

If you prefer to only have one pane in view at a time, add <code>Shift</code> to any of the above commands to maximize the pane. 
For example, enter <code>Control/Ctrl + Shift + 1</code> to maximize the R script, notebook, or R Markdown file you are working in.

(Side note: The <code>+</code> we show in the shortcuts means “and”, so there’s no need to actually type the <code>+</code> key.)

But what if you want to return to the standard four-pane view? No problem! Enter <code>Control/Ctrl + Shift + 0</code>:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/panes.png">

<h3>2. Keyboard Shortcuts</h3>
Knowing RStudio keyboard shortcuts will save lots of time when programming. 
RStudio provides dozens of useful shortcuts that you can access through the menu at the top: <code>Tools > Keyboard Shortcuts Help</code>.

Another way to access RStudio keyboard shortcuts is with a shortcut! To access shortcuts, type <code>Option + Shift + K</code> on a Mac, or <code>Alt + Shift + K</code> on Linux and Windows.

Here are some of our favorite RStudio shortcuts:


Insert the &lt;- assignment operator with <code>Option + -</code> on a Mac, or <code>Alt + -</code> on Linux and Windows.
Insert the pipe operator <code>%>%</code> with <code>Command + Shift + M</code> on a Mac, or <code>Ctrl + Shift + M</code> on Linux and Windows.
Run the current line of code with <code>Command + Enter</code> on a Mac or <code>Control + Enter</code> on Linux and Windows.
Run all lines of code with <code>Command + A + Enter</code> on a Mac or <code>Control + A + Enter</code> on Linux and Windows.
Restart the current R session and start fresh with <code>Command + Shift + F10</code> on a Mac or <code>Control + Shift + F10</code> on Linux and Windows.
Comment or uncomment lines with <code>Command + Shift + C</code> on a Mac or <code>Control + Shift + C</code> on Linux and Windows.
Trying to remember a command you submitted earlier? Search the command history from the Console with <code>Command + [up arrow]</code> on a Mac or <code>Control + [up arrow]</code> on Linux and Windows.

There are many more useful shortcuts available, but by mastering the shortcuts above, you’ll be on your way to becoming an RStudio power user!

Another great resource for RStudio shortcuts is the official RStudio cheat sheet available <a href="https://rstudio.com/resources/cheatsheets/">here</a>.

<h3>3. Save Time with Code Completion</h3>
After you begin typing, a suggestion window will pop up with matching names of functions, objects, and snippets. 
You can toggle through the list using the up or down arrows and hit <code>return/Enter</code> to make your selection.

Alternatively, you can utilize a very cool feature called <k>fuzzy matching,</k> which allows you to narrow your search options by entering letters unique to the item you are matching. 
You do not need to enter all of the letters as long as your entry matches the order of the string.

Let’s take a look at how these code completion methods work. 
First, we’ll select the <code>installed.packages()</code> function by typing part of the function name, and then use arrows to make the selection. 
Next, we’ll use fuzzy matching to only enter <code>instd</code> to narrow our selection further:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/code_completion.gif">

<h3>4. Quickly Find Files and Functions</h3>
In RStudio there’s no need to fumble through your folder structure to find files, and there’s no need to dig for functions! Enter the shortcut <code>control/ctrl + .</code> to open the <code>Go to File/Function</code> window and then use your fuzzy matching skills to narrow your selection:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/open_file.gif">

<h3>5. Customize the Appearance</h3>
RStudio offers a wealth of options to customize the appearance to your liking. 
Under the <code>RStudio</code> tab, navigate to <code>Preferences > Appearance</code> to explore the many options available. 
A nice feature of RStudio is that you can quickly click through the <code>Editor theme</code> window to preview each theme.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/RStudio_theme.png">

<h3>6. Easy Links to Documentation</h3>
Under the <code>Help</code> tab in the lower-right window, you’ll find handy links to the online documentation for R functions and R packages. 
For example, if we search for information about the <code>install.packages()</code> function using the search bar, the official documentation is returned:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/help.png">

We can also access documentation in the <code>Help</code> tab by prepending a package or function with <code>?</code>, (e.g. <code>?install.packages</code>) and running the command into the Console. 
With either approach, RStudio auto-fills matching function names as you type!

<h3>7. Preview and Save Your Plots</h3>
Plots generated during an RStudio session are displayed under the <code>Plots</code> tab in the lower-right window. 
In this window, you can inspect your plots by zooming in and out. 
If you want to save your plot, you can save the plot as a PDF or image file.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/plot.png">

<h3>8. Import and Preview Datasets</h3>
RStudio makes it easy to import and preview datasets, no coding required! Under the <code>Environment</code> tab in the upper-right window, there is feature that enables you to import a dataset. 
This feature supports a variety of formats:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/import.png">

You can even preview the dataset before it is loaded:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/import_options.png">

And after the dataset is loaded into RStudio, you can view it with the <code>View()</code> command, or by clicking the name of the dataset:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/view.png">

<h3>9. Review the Command History with One Click</h3>
Earlier, we learned the shortcut to the command history from the console. 
RStudio also enables you to view your entire command history in the upper-right window by clicking the <code>History</code> tab:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/history.png">

<h3>10. Save Your “Real” Work. Delete the Rest.</h3>
Practice good housekeeping to avoid unforeseen challenges down the road. 
If you create an R object worth saving, capture the R code that generated the object in an R script file. 
Save the R script, but don’t save the environment, or workspace, where the object was created.

To prevent RStudio from saving your workspace, open <code>Preferences > General</code> and un-select the option to restore <code>.RData</code> into workspace at startup. 
Be sure to specify that you never want to save your workspace, like this:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/never_save_workspace.png">

Now, each time you open RStudio, you will begin with an empty session. 
None of the code generated from your previous sessions will be remembered. 
The R script and datasets can be used to recreate the environment from scratch.

<h3>11. Organize Your Work with Projects</h3>
RStudio offers a powerful feature to keep you organized; Projects. 
It is important to stay organized when you work on multiple analyses. 
Projects from RStudio allow you to keep all of your important work in one place, including code scripts, plots, figures, results, and datasets.

Create a new project by navigating to the <code>File</code> tab in RStudio and select <code>New Project...</code>. 
You have the option to create your new project in a new directory, or an existing directory. 
RStudio offers dedicated project types if you are working on an R package, or a Shiny Web Application.

RStudio Projects are useful when you need to share your work with colleagues. 
You can send your project file (ending in <code>.Rproj</code>) along with all supporting files, which will make it easier for your colleagues to recreate the working environment and reproduce the results.

But if you want seamless collaboration, you may need to introduce package management into your workflow. 
Fortunately, RStudio offers a useful tool for package management, <code><a href="https://rstudio.github.io/renv/">renv</a></code>, that is now compatible with RStudio projects. 
We’ll cover <code>renv</code> next.

<h3>12. Manage Package Versions with renv</h3>
We love R at Dataquest, but managing package versions can be a challenge! Fortunately, R package management is easier than ever, thanks to <a href="https://rstudio.github.io/renv/" style="outline: none;">the <code>renv</code> (“reproducible environment”) package</a> from RStudio. 
And now, RStudio includes built-in support for <code>renv</code>.

We won’t get into the details of how to use <code>renv</code> with RStudio projects in this blog because RStudio provides you with the info you need in the link we provided and in the <a href="https://rstudio.github.io/renv/articles/renv.html">vignette</a>. 
But using <code>renv</code> with RStudio can make R package management much easier, so we wanted to let you know!

The <code>renv</code> package is replacing <a href="https://rstudio.github.io/packrat/">the <code>Packrat</code> package</a> that RStudio used to maintain.

To use the <code>renv</code> package with your RStudio projects upgrade to the latest version of RStudio and then install the <code>renv</code> package with <code>library("renv")</code>. 
From there you will have the option to use <code>renv</code> with all new projects:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/renv_new.png">

If you would like to use <code>renv</code> with an existing project navigate to <code>Tools > Project Options > Environments</code> and check the box to enable <code>renv</code>:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/renv_existing.png">

<h3>13. Manage Version Control with GitHub in RStudio</h3>
In addition to managing packages in RStudio, you can also use GitHub with RStudio to maintain version control of your projects and R scripts. 
Check out <a href="https://resources.github.com/whitepapers/github-and-rstudio/" style="outline: none;">this article from GitHub</a> and <a href="https://support.rstudio.com/hc/en-us/articles/200532077?version=1.3.959&mode=desktop">this article from RStudio</a> for all the information you need to integrate Git into your RStudio workflow.

<h3>14. Code Snippets</h3>
RStudio offers a very useful feature for inserting common chunks of code, called code snippets. 
One of our favorites is the <code>lib</code> snippet that saves you a bit of typing when calling the <code>library()</code> function to load an R package:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/snippet.png">

After you hit return to select the snippet, the <code>library()</code> function is loaded and the cursor is positioned so you can immediately begin typing the name of the package you want to load:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/library.png">

Our other favorite is the fun snippet that provides a basic template for writing a custom function. 
And you can even add snippets of your own! To learn more, check out <a href="https://support.rstudio.com/hc/en-us/articles/204463668-Code-Snippets" style="outline: none;">this article</a> on code snippets from RStudio.

<h3>15. Dig Into the Source Code of a Function</h3>
If you’d like to investigate the source code of a function, move your cursor to the function of interest and enter <code>F2</code> (on a Mac you may need to enter <code>fn + F2</code>). 
This feature even works for functions loaded from any R packages you use.

<h3>16. Function Extraction</h3>
If you’ve written a chunk of code that you want to turn into a function, highlight the code chunk and enter <code>control + option X</code> on a Mac, <code>Ctrl + Alt + X</code> on Linux/Windows. 
A pop-up will appear that will ask you to select a function name.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/extract_function.png">

After the function name is selected, the inputs and code structure needed to turn your code into a function will be added automatically.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/extracted_function.png">

If you have a variable that you would like to extract, highlight the variable and enter <code>control + option V</code> on a Mac, <code>Ctrl + Alt + V</code> on Linux/Windows.

<h3>17. Rename in Scope</h3>
At some point, you may need to change the name of a function or a variable used in one of your functions. 
But using find and replace to do this can be nerve-wracking! Fortunately, RStudio makes it possible to rename in scope. 
This means your changes will be limited to the variable or function of interest. 
This will prevent you from accidentally replacing a variable of the same name elsewhere in your code script. 
To use this feature select the function or variable you want to change and enter <code>control + shift + option + M</code> on a Mac, or <code>Ctrl + Shift + Alt + M</code> on Linux/Windows.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/scope.png">

<h3>18. Multicursor Support</h3>
RStudio supports multiple cursors. 
Simply click and drag your mouse while holding down <code>option</code> on a Mac, or <code>Alt</code> on Windows/Linux.

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/cursor_select.png">

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/cursor_edit.png">

<h3>19. Use Python with RStudio and reticulate</h3>
RStudio supports coding in python. 
The process to get python up and running within RStudio involves these general steps:


Install a base version of Python
Install <code>pip</code> and <code>virtualenv</code>
Create a Python environment in your RStudio project
Activate your Python environment
Install desired Python packages in your environment
Install and configure the R <code>reticulate</code> package to use Python

<a href="https://support.rstudio.com/hc/en-us/articles/360023654474-Installing-and-Configuring-Python-with-RStudio" style="outline: none;">This article</a> provides the code you’ll need for the steps above. 
We tried it out and were able to run python in RStudio in only a few minutes:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/python.png">

For full details, check out this <a href="https://docs.rstudio.com/tutorials/user/using-python-with-rstudio-and-reticulate/">RStudio tutorial</a>.

<h3>20. Query SQL Using the DBI Package</h3>
There are many ways to run SQL queries in RStudio. 
Here are three of the most popular methods, beginning with the <code>DBI</code> package from R.

You’ll start by generating an in-memory SQL database to use in all your SQL query examples. 
You’ll generate a SQL database of the well-known “mtcars” dataset. 
Here’s the code:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/create_db.png">Now write a SQL query to select all cars from the database with a four-cylinder engine. 
This command returns a dataframe that you’ll save as <code>dbi_query</code>:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/dbi_query.png">

The dataframe looks like this:<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/dataframe.png">

<h3>21. Query SQL in R Markdown or Using an R Notebook</h3>
You can achieve the same result in R Notebook or R Markdown by creating a <code>{sql}</code> code chunk. 
Using the connection and database from the first example, run this code:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/sql_pure.png">

Specify <code>output.var = "mt_cars_df"</code> to save the results of your query to a dataframe. 
This dataframe is a standard R dataframe that is identical to the one you generated in the previous example. 
You can use this dataframe in R code chunks to perform analysis or to generate a ggplot, for example:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/ggplot_code.png">

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/Rplot.png">

<h3>22. Query SQL with dbplyr</h3>
Finally, you’ll use the <code>dbplyr</code> package to write standard <code>dplyr</code> commands that get converted to SQL! Once again, using the connection and database from the first example, you can write a standard <code>filter()</code> call to query the cars with four cylinders, this returns a list object:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/dbplyr_1.png">

If you want to see the SQL code that this command was converted to, you can use the <code>show_query()</code> function from <code>dbplyr</code>:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/dbplyr_2.png">When you’re satisfied with your query results, you use the <code>collect()</code> function from <code>dbplyr</code> to save your results as a dataframe:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/dbplyr_3.png">

There you have it! Three different approaches to querying a SQL database with similar results. 
The only difference between the examples is that the <code>dbplyr</code> method returns a tibble, whereas the first two methods return a standard R dataframe.

To learn more about querying SQL databases with RStudio, check out <a href="https://db.rstudio.com/getting-started/database-queries/">this article</a>.

<h3>23. Take it to the Cloud!</h3>
RStudio now offers a cloud-based version of RStudio Desktop called, you guessed it… <a href="https://rstudio.cloud/">RStudio Cloud</a>. 
RStudio Cloud allows you to code in RStudio without installing software, you only need a web browser.

Work in RStudio Cloud is organized into projects similar to the desktop version, but RStudio Cloud enables you to specify the version of R you wish to use for each project.

RStudio Cloud also makes it easy and secure to share projects with colleagues, and ensures that the working environment is fully reproducible every time the project is accessed.

As you can see, the layout of RStudio Cloud is very similar to RStudio Desktop:

<img class="lazy" data-src="https://dq-blog-files.s3.amazonaws.com/rstudio_tips/cloud.png">

<h3>Bonus: Cheatsheets</h3>
RStudio has published <a href="https://rstudio.com/resources/cheatsheets/" style="outline: none;">numerous cheatsheets</a> for working with R, including a detailed cheatsheet on using RStudio! Select cheatsheets can be accessed from within RStudio by selecting <code>Help > Cheatsheets</code>.

<h2>Customizing Keyboard Shortcuts in the RStudio IDE</h2>
<h3>Customizing Keyboard Shortcuts</h3>
You can now customize keyboard shortcuts in the RStudio IDE -- you can bind keys to execute RStudio application commands, editor commands, or (using <a href="https://rstudio.github.io/rstudioaddins/" target="_blank">RStudio Addins</a>) even user-defined R functions.
Access the keyboard shortcuts by clicking&nbsp;<code>Tools -> Modify Keyboard Shortcuts...</code>:
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202570047/modify.png">
You will then see the set of available editor commands (commands that affect the current&nbsp;document's contents, or the current selection), alongside RStudio commands (commands whose actions are scoped beyond just the current editor).
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202570087/Screen_Shot_2015-07-31_at_12.49.32_PM.png">
Each row represents a particular command binding -- the command's <k>Name</k>, the keyboard <k>Shortcut</k> it is bound to, and the <k>Scope</k> where that binding is active.
You can modify a command's shortcut by clicking on the cell containing the current shortcut key sequence, and typing the new sequence you'd like to bind the command to. As you type, the current row will be marked to show that the binding has been updated, and the shortcut field will be updated based on the keys entered.
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202570217/Screen_Shot_2015-07-31_at_12.52.59_PM.png">&nbsp;
If you made a mistake, you can press <code>Backspace</code> to clear a single key combination, or <code>Delete</code>&nbsp;to reset that binding to the&nbsp;original value it had when the widget was opened.
Commands&nbsp;can be either a single 'key chord'; for example, <code>Ctrl+Alt+F</code>, or also to&nbsp;a sequence of keys, as in <code>Ctrl+X Ctrl+F</code>.
You can also filter, based on the names of commands, by typing within the <code>Filter...</code> search box at the top left, to more easily find commands of interest:
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202644108/Screen_Shot_2015-07-31_at_12.55.42_PM.png">
After you've updated the bindings to your liking, click <code>Apply</code> and the shortcuts will be applied to the current session and saved for future sessions.
<h3>Handling Conflicts</h3>
By default, RStudio application command bindings will override editor command bindings. If an editor command and an RStudio command are both bound to the same key sequence, the RStudio command will take precedence and the editor command will not be executed. Editor commands&nbsp;that are masked by an RStudio command will be crossed out and have a small icon showing the masking command:
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202570317/masked.png">
If two commands are bound to the same key sequence, then that conflict will be highlighted and displayed in yellow.
<img class="lazy" data-src="https://support.rstudio.com/hc/en-us/article_attachments/202644238/conflict.png">
<h3>Saving and Loading</h3>
The RStudio keybindings are saved as JSON files in the directory <code>~/.R/rstudio/keybindings/</code> -- you can find the bindings for the editor and RStudio itself at:
<k>RStudio 1.2 and prior</k>
~/.R/rstudio/keybindings/rstudio_commands.json
~/.R/rstudio/keybindings/editor_commands.json
<k>RStudio 1.3+ (Windows)</k>
~/AppData/Roaming/RStudio/keybindings/rstudio_bindings.json
~/AppData/Roaming/RStudio/keybindings/editor_bindings.json

<h2>sorting a table in R by count</h2>
alltriList = c("8","3","9","5","9","2","0","5","9","0","9","3","0","5","4")
thetable = table(alltriList)
thetable = thetable[order(thetable, decreasing = TRUE)]
freq = as.vector(table(alltriList)[names(table(alltriList)) == 9]) #  4

<h2>Reshape Data </h2>
https://www.statmethods.net/management/reshape.html
R provides a variety of methods for reshaping data prior to analysis. 
<h3>Transpose </h3>
Use the t() function to transpose a matrix or a data frame. In the later case, rownames become variable (column) names. 
<code># example using built-in dataset 
  mtcars
  t(mtcars)</code>
<h3>The Reshape Package </h3>
Hadley Wickham has created a comprehensive package called <a href="http://had.co.nz/reshape/">reshape</a> to massage data. Both an <a href="http://had.co.nz/reshape/introduction.pdf">introduction</a> and <a href="http://www.jstatsoft.org/v21/i12/paper">article</a> are available. There is even a <a href="http://had.co.nz/reshape/french-fries-demo.html">video</a>! 
Basically, you &quot;melt&quot; data so that each row is a unique id-variable combination. Then you &quot;cast&quot; the melted data into any shape you would like. Here is a very simple example. 
<k>mydata </k>
<table>
<tr><td><k>id</k></td><td><k>time</k></td><td><k>x1</k></td><td><k>x2</k></td></tr>
<tr><td>1</td><td>1</td><td>5</td><td>6</td></tr>
<tr><td>1</td><td>2</td><td>3</td><td>5</td></tr>
<tr><td>2</td><td>1</td><td>6</td><td>1</td></tr>
<tr><td>2</td><td>2</td><td>2</td><td>4</td></tr>
</table>

<code># example of melt function
  
  library(reshape)
  mdata &lt;- melt(mydata, id=c(&quot;id&quot;,&quot;time&quot;))</code>
<k>newdata</k>
<table>
<tr><td><k>id</k></td><td><k>time</k></td><td><k>variable</k></td><td><k>value</k></td></tr>
<tr><td>1</td><td>1</td><td>x1</td><td>5</td></tr>
<tr><td>1</td><td>2</td><td>x1</td><td>3</td></tr>
<tr><td>2</td><td>1</td><td>x1</td><td>6</td></tr>
<tr><td>2</td><td>2</td><td>x1</td><td>2</td></tr>
<tr><td>1</td><td>1</td><td>x2</td><td>6</td></tr>
<tr><td>1</td><td>2</td><td>x2</td><td>5</td></tr>
<tr><td>2</td><td>1</td><td>x2</td><td>1</td></tr>
<tr><td>2</td><td>2</td><td>x2</td><td>4</td></tr>
</table>
<code># cast the melted data
  # cast(data, formula, function) 
  subjmeans &lt;- cast(mdata, id~variable, mean)
  timemeans &lt;- cast(mdata, time~variable, mean)</code>
<k>subjmeans</k>
<table>
<tr><td><k>id</k></td><td><k>x1</k></td><td><k>x2</k></td></tr>
<tr><td>1</td><td>4</td><td>5.5</td></tr>
<tr><td>2</td><td>4</td><td>2.5</td></tr>
</table>
<k>timemeans</k>
<table>
<tr><td><k>time</k></td><td><k>x1</k></td><td><k>x2</k></td></tr>
<tr><td>1</td><td>5.5</td><td>3.5</td></tr>
<tr><td>2</td><td>2.5</td><td>4.5</td></tr>
</table>
There is much more that you can do with the <k>melt( )</k> and <k>cast( )</k> functions. See the documentation for more details. 



<h2>R to count freq</h2>
to find numbers > 100
numbers <- c(4,23,4,23,5,43,54,56,657,67,67,435,453,435,324,34,456,56,567,65,34,435)
sum(numbers > 100)
length(which(numbers>100))
s = summary(as.factor(numbers))
names(s)

sum(titanic_train$Age>50, na.rm = TRUE)
sapply(titanic_train, function(x) sum(is.na(x)))

length(grep(435, numbers))
table(numbers)
table(numbers)['435']

<h2>to convert table into a data.frame</h2>
as.data.frame(table(numbers))

<h2>to convert factor into a data.frame</h2>
as.data.frame(cbind(Number = names(s),Freq = s), stringsAsFactors=F, row.names = 1:length(s))

<h2>check how many unique values for each variable</h2>
sapply(titanic_train, function(x) length(unique(x)))
<h2>plot dataset and highlight missing values</h2>
library(Amelia)
missmap(training.data.raw, main = "Missing values vs observed")

<h2>drop some columns using the subset() function</h2>
data <- subset(training.data.raw, select=c(2,3,5,6,7,8,10,12))
<h2>typical approach to replace the NAs</h2>
with the average, the median or the mode

data$Age[is.na(data$Age)] <- mean(data$Age,na.rm=T)

<h2>change language settings in R</h2>
Sys.getenv() gives you a list of all the environment variables that are set,
Sys.setenv sets environment variables
Sys.setenv(LANG = "en")

D:\R-3.5.1\etc\Rprofile.site
Sys.setlocale("LC_ALL","English")
options(scipen=999)
Sys.setenv(LANG = "en")

<h2>Linear Regression in R</h2>
<div id="LRegressiontoc" class="toc"><a href="#LRegressiontopic-1" target="_self">What is a linear regression?</a><br><a href="#LRegressiontopic-2" target="_self">Creating a Linear Regression in R.</a><br><a href="#LRegressiontopic-3" target="_self">Coefficients.</a><br><a href="#LRegressiontopic-4" target="_self">Residuals</a><br><a href="#LRegressiontopic-5" target="_self">How to test if your linear model has a good fit?</a><br><a href="#LRegressiontopic-6" target="_self">Don’t forget to look at the residuals!</a><br><a href="#LRegressiontopic-7" target="_self">Detect Influential Points.</a><br><a href="#LRegressiontopic-8" target="_self">Conclusion</a><br></div>
<h3 id="LRegressiontopic-1">What is a linear regression?</h3>
A linear regression is a statistical model that analyzes the relationship between a response variable (often called y) and one or more variables and their interactions (often called x or explanatory variables). 
You make this kind of relationships in your head all the time, for example when you calculate the age of a child based on her height, you are assuming the older she is, the taller she will be. 
Linear regression is one of the most basic statistical models out there, its results can be interpreted by almost everyone, and it has been around since the 19th century. 
This is precisely what makes linear regression so popular. 
It’s simple, and it has survived for hundreds of years. 
Even though it is not as sophisticated as other algorithms like artificial neural networks or random forests, according to a survey made by KD Nuggets, regression was the algorithm most used by data scientists in <a href="https://www.kdnuggets.com/2016/09/poll-algorithms-used-data-scientists.html">2016</a> and <a href="https://www.kdnuggets.com/2017/12/top-data-science-machine-learning-methods.html">2017</a>. 
It’s even predicted it’s still going to be the used in year <a href="https://www.kdnuggets.com/2018/02/machine-learning-algorithm-2118.html">2118</a>!

<h3 id="LRegressiontopic-2">Creating a Linear Regression in R.</h3>
Not every problem can be solved with the same algorithm. 
In this case, linear regression assumes that there exists a linear relationship between the response variable and the explanatory variables. 
This means that you can fit a line between the two (or more variables). 
In the previous example, it is clear that there is a relationship between the age of children and their height.

<img class="lazy" data-src="http://res.cloudinary.com/dydmodel1 &lt;- glm(data = titanic_passenger, family = binomial(link= formula = survival~fare, logit = "" na.action="na.exclude) &lt;
summary(model1)
911kmh/image/upload/f_auto,q_auto:best/v1526911465/1_afqiyx.png">

In this particular example, you can calculate the height of a child if you know her age:

$\text{Height} = a + \text{Age} * b$

In this case, “a” and “b” are called the intercept and the slope respectively. 
With the same example, “a” or the intercept, is the value from where you start measuring. 
Newborn babies with zero months are not zero centimeters necessarily; this is the function of the intercept. 
The slope measures the change of height with respect to the age in months. 
In general, for every month older the child is, his or her height will increase with “b”.

A linear regression can be calculated in R with the command <code>lm</code>. 
In the next example, use this command to calculate the height based on the age of the child.

First, import the library <code>readxl</code> to read Microsoft Excel files, it can be any kind of format, as long R can read it. 
To know more about importing data to R, you can take <a href="https://www.datacamp.com/courses/importing-data-in-r-part-1">this DataCamp course</a>.

The data to use for this tutorial can be downloaded <a href="https://drive.google.com/drive/folders/1TcO4eVmpAn7gt4DbZ31HCz0t_gkca1Fp">here</a>. 
Download the data to an object called <code>ageandheight</code> and then create the linear regression in the third line. 
The <code>lm</code> command takes the variables in the format:

<code>lm([target variable] ~ [predictor variables], data = [data source])</code>

With the command <code>summary(lmHeight)</code> you can see detailed information on the model’s performance and coefficients.

<code>library(readxl)
ageandheight &lt;- read_excel("ageandheight.xls", sheet = "Hoja2") #Upload the data
lmHeight = lm(height~age, data = ageandheight) #Create the linear regression
summary(lmHeight) #Review the results</code>

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911465/2_asteeq.png  ">

<h3 id="LRegressiontopic-3">Coefficients.</h3>
In the red square, you can see the values of the intercept (“a” value) and the slope (“b” value) for the age. 
These “a” and “b” values plot a line between all the points of the data. 
So in this case, if there is a child that is 20.5 months old, a is 64.92 and b is 0.635, the model predicts (on average) that its height in centimeters is around 64.92 + (0.635 * 20.5) = 77.93 cm.

When a regression takes into account two or more predictors to create the linear regression, it’s called multiple linear regression. 
By the same logic you used in the simple example before, the height of the child is going to be measured by:

<em>Height = a + Age × b<sub>1</sub> + (Number of Siblings} × b<sub>2</sub></em>

You are now looking at the height as a function of the age in months and the number of siblings the child has. 
In the image above, the red rectangle indicates the coefficients (b1 and b2). 
You can interpret these coefficients in the following way:

When comparing children with the same number of siblings, the average predicted height increases in 0.63 cm for every month the child has. 
The same way, when comparing children with the same age, the height decreases (because the coefficient is negative) in -0.01 cm for each increase in the number of siblings.

In R, to add another coefficient, add the symbol "+" for every additional variable you want to add to the model.

<code>lmHeight2 = lm(height~age + no_siblings, data = ageandheight) #Create a linear regression with two variables
summary(lmHeight2) #Review the results</code>

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911465/3_yaepnf.png">

As you might notice already, looking at the number of siblings is a silly way to predict the height of a child. 
Another aspect to pay attention to your linear models is the p-value of the coefficients.
In the previous example, the blue rectangle indicates the p-values for the coefficients age and number of siblings. 
In simple terms, a p-value indicates whether or not you can reject or accept a hypothesis. 
The hypothesis, in this case, is that the predictor is not meaningful for your model.

The p-value for age is 4.34*e-10 or 0.000000000434. 
A very small value means that age is probably an excellent addition to your model.

The p-value for the number of siblings is 0.85. 
In other words, there’s 85% chance that this predictor is not meaningful for the regression.

A standard way to test if the predictors are not meaningful is looking if the p-values smaller than 0.05.

<h3 id="LRegressiontopic-4">Residuals</h3>
A good way to test the quality of the fit of the model is to look at the residuals or the differences between the real values and the predicted values. 
The straight line in the image above represents the predicted values. 
The red vertical line from the straight line to the observed data value is the residual.

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911465/4_pjp8qf.png">

The idea in here is that the sum of the residuals is approximately zero or as low as possible. 
In real life, most cases will not follow a perfectly straight line, so residuals are expected. 
In the R summary of the lm function, you can see descriptive statistics about the residuals of the model, following the same example, the red square shows how the residuals are approximately zero.

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911465/5_nbcx2m.png">

<h3 id="LRegressiontopic-5">How to test if your linear model has a good fit?</h3>
One measure very used to test how good is your model is the coefficient of determination or R². 
This measure is defined by the proportion of the total variability explained by the regression model.

$R^2 = \frac{\text{Explained Variation of the model}}{\text{Total variation of the model}}$

This can seem a little bit complicated, but in general, for models that fit the data well, R² is near 1. 
Models that poorly fit the data have R² near 0. 
In the examples below, the first one has an R² of 0.02; this means that the model explains only 2% of the data variability. 
The second one has an R² of 0.99, and the model can explain 99% of the total variability.**

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911465/6.1_tnja1z.png">
<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911466/7_uyik0q.png">

However, it’s essential to keep in mind that sometimes a high R² is not necessarily good every single time (see below residual plots) and a low R² is not necessarily always bad. 
In real life, events don’t fit in a perfectly straight line all the time. 
For example, you can have in your data taller or smaller children with the same age. 
In some fields, an R² of 0.5 is considered good.

With the same example as above, look at the summary of the linear model to see its R².

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911466/8_udtgwq.png">

In the blue rectangle, notice that there’s two different R², one multiple and one adjusted. 
The multiple is the R² that you saw previously. 
One problem with this R² is that it cannot decrease as you add more independent variables to your model, it will continue increasing as you make the model more complex, even if these variables don’t add anything to your predictions (like the example of the number of siblings). 
For this reason, the adjusted R² is probably better to look at if you are adding more than one variable to the model, since it only increases if it reduces the overall error of the predictions.

<h3 id="LRegressiontopic-6">Don’t forget to look at the residuals!</h3>
You can have a pretty good R² in your model, but let’s not rush to conclusions here. 
Let’s see an example. 
You are going to predict the pressure of a material in a laboratory based on its temperature.

Let’s plot the data (in a simple scatterplot) and add the line you built with your linear model. 
In this example, let R read the data first, again with the <code>read_excel</code> command, to create a dataframe with the data, then create a linear regression with your new data. 
The command <code>plot</code> takes a data frame and plots the variables on it. 
In this case, it plots the pressure against the temperature of the material. 
Then, add the line made by the linear regression with the command <code>abline</code>.

<code>pressure &lt;- read_excel("pressure.xlsx") #Upload the data
lmTemp = lm(Pressure~Temperature, data = pressure) #Create the linear regression
plot(pressure, pch = 16, col = "blue") #Plot the results
abline(lmTemp) #Add a regression line</code>

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911467/output_13_0_utufts.png">

If you see the summary of your new model, you can see that it has pretty good results (look at the R²and the adjusted R²)

<code>summary(lmTemp)</code>
<code>Call:
lm(formula = Pressure ~ Temperature, data = pressure)

Residuals:
   Min     1Q Median     3Q    Max
-41.85 -34.72 -10.90  24.69  63.51

Coefficients:
            Estimate Std. 
Error t value Pr(>|t|)    
(Intercept) -81.5000    29.1395  -2.797   0.0233 *  
Temperature   4.0309     0.4696   8.583 2.62e-05 ***
---
Signif. 
codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 42.66 on 8 degrees of freedom
Multiple R-squared:  0.902,    Adjusted R-squared:  0.8898
F-statistic: 73.67 on 1 and 8 DF,  p-value: 2.622e-05</code>
Ideally, when you plot the residuals, they should look random. 
Otherwise means that maybe there is a hidden pattern that the linear model is not considering.
To plot the residuals, use the command <code>plot(lmTemp$residuals)</code>.

<code>plot(lmTemp$residuals, pch = 16, col = "red")</code>

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911466/output_17_0_niceec.png">

This can be a problem. 
If you have more data, your simple linear model will not be able to generalize well. 
In the previous picture, notice that there is a pattern (like a curve on the residuals). 
This is not random at all.

What you can do is a transformation of the variable. 
Many possible transformations can be performed on your data such as adding a quadratic term $(x^2)$, a cubic $(x^3)$ or even more complex such as ln(X), ln(X+1), sqrt(X), 1/x, Exp(X). 
The choice of the correct transformation will come with some knowledge of algebraic functions, practice, trial, and error.

Let’s try with a quadratic term. 
For this, add the term “I” (capital "I") before your transformation, for example, this will be the normal linear regression formula:

<code>lmTemp2 = lm(Pressure~Temperature + I(Temperature^2), data = pressure) #Create a linear regression with a quadratic coefficient
summary(lmTemp2) #Review the results</code>
<code>Call:
lm(formula = Pressure ~ Temperature + I(Temperature^2), data = pressure)

Residuals:
    Min      1Q  Median      3Q     Max
-4.6045 -1.6330  0.5545  1.1795  4.8273

Coefficients:
                  Estimate Std. 
Error t value Pr(>|t|)    
(Intercept)      33.750000   3.615591   9.335 3.36e-05 ***
Temperature      -1.731591   0.151002 -11.467 8.62e-06 ***
I(Temperature^2)  0.052386   0.001338  39.158 1.84e-09 ***
---
Signif. 
codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 3.074 on 7 degrees of freedom
Multiple R-squared:  0.9996,    Adjusted R-squared:  0.9994
F-statistic:  7859 on 2 and 7 DF,  p-value: 1.861e-12</code>
Notice that the model improved significantly. 
If you plot the residuals of the new model, they will look like this:

<code>plot(lmTemp2$residuals, pch = 16, col = "red")</code>

<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911467/output_21_0_cur6lb.png">

Now you don’t see any clear patterns on your residuals, which is good!

<h3 id="LRegressiontopic-7">Detect Influential Points.</h3>
In your data, you may have influential points that might skew your model, sometimes unnecessarily. 
Think of a mistake on the data entry and instead of writing “2.3” the value was “23”. 
The most common kind of influential point are the outliers, which are data points where the observed response does not appear to follow the pattern established by the rest of the data.

You can detect influential points by looking at the object containing the linear model, using the function <code>cooks.distance</code> and then plot these distances. 
Change a value on purpose to see how it looks on the Cooks Distance plot. 
To change a specific value, you can directly point at it with <code>ageandheight[row number, column number] = [new value]</code>. 
In this case, the height is changed to 7.7 of the second example:

<code>ageandheight[2, 2] = 7.7
head(ageandheight)</code>

<table>
<thead><tr><th scope="col">age</th><th scope="col">height</th><th scope="col">no_siblings</th></tr></thead>
<tbody>
    <tr><td>18  </td><td>76.1</td><td>0   </td></tr>
    <tr><td>19  </td><td> 7.7</td><td>2   </td></tr>
    <tr><td>20  </td><td>78.1</td><td>0   </td></tr>
    <tr><td>21  </td><td>78.2</td><td>3   </td></tr>
    <tr><td>22  </td><td>78.8</td><td>4   </td></tr>
    <tr><td>23  </td><td>79.7</td><td>1   </td></tr>
</tbody>
</table>


You create again the model and see how the summary is giving a bad fit, and then plot the Cooks Distances. 
For this, after creating the linear regression, use the command <code>cooks.distance([linear model]</code> and then if you want you can plot these distances with the command <code>plot</code>.

<code>lmHeight3 = lm(height~age, data = ageandheight)#Create the linear regression
summary(lmHeight3)#Review the results
plot(cooks.distance(lmHeight3), pch = 16, col = "blue") #Plot the Cooks Distances.</code>
<code>Call:
lm(formula = height ~ age, data = ageandheight)

Residuals:
    Min      1Q  Median      3Q     Max
-53.704  -2.584   3.609   9.503  17.512

Coefficients:
            Estimate Std. 
Error t value Pr(>|t|)
(Intercept)    7.905     38.319   0.206    0.841
age            2.816      1.613   1.745    0.112

Residual standard error: 19.29 on 10 degrees of freedom
Multiple R-squared:  0.2335,    Adjusted R-squared:  0.1568
F-statistic: 3.046 on 1 and 10 DF,  p-value: 0.1115</code>
<img class="lazy" data-src="http://res.cloudinary.com/dyd911kmh/image/upload/f_auto,q_auto:best/v1526911467/output_26_1_tk3u9f.png">

<k>Notice</k> that there is a point that does not follow the pattern, and it might be affecting the model. 
Here you can make decisions on this point, in general, there are three reasons why a point is so influential:

Someone made a recording error

Someone made a fundamental mistake collecting the observation

The data point is perfectly valid, in which case the model cannot account for the behavior.

If the case is 1 or 2, then you can remove the point (or correct it). 
If it's 3, it's not worthy to delete a valid point; maybe you can try on a non-linear model rather than a linear model like linear regression.

Beware that an influential point can be a valid point, be sure to check the data and its source before deleting it. 
It’s common to see on statistics books this quote: “Sometimes we throw out perfectly good data when we should be throwing out questionable models.”

<h3 id="LRegressiontopic-8">Conclusion</h3>
You made it to the end! Linear regression is a big LRegressiontopic, and it's here to stay. 
Here I presented a few tricks that can help to tune and take the most advantage of such powerful algorithm, yet so simple. 
You also learned how to understand what's behind this simple statistical model and how you can modify it according to your needs. 
You can also explore other options by typing “?lm” on the R console and looking at the different parameters not covered in here. 
If you are interested in diving into statistical models, go ahead and check the course on <a href="https://www.datacamp.com/courses/statistical-modeling-in-r-part-1">Statistical Modeling in R</a>.


<h2>use RCurl to read file from url</h2>
library(RCurl)
pagesource = getURL(theURL, ssl.verifyhost=FALSE, ssl.verifypeer=FALSE)

What are the arguments ssl.verifyhost=F and ssl.verifypeer=F doing?
To be quite honest, I don’t really know. 
But if I’m having trouble reading from a URL I try specifying these arguments and changing one or both to FALSE almost always circumvents whatever error I’m getting.
This grabs the content residing at the specified URL, but doesn’t return a data.frame object. 

It has simply put the URL’s content into a string.
class(myfile)
[1] "character"


<h2>Emoji</h2>
Emoji unicode can be found in
https://emojiterra.com/
or searched using search_emoji function.
The search_emoji function will return emoji aliases which can be converted to unicode by emoji function.

install.packages("emojifont")
library(emojifont)
search_emoji('smile')
## [1] "smiley"      "smile"       "sweat_smile" "smiley_cat"  
emoji(search_emoji('smile'))
## [1] "😃" "😄" "😅" "😺" "😸"
cat("😃")
cat("😺")
cat("😸")
search_emoji('trophy')
cat("🏆")

https://github.com/hadley/emo
devtools::install_github("hadley/emo")
emo::ji("poop")
#> 💩
emo::ji("face")

<h2>Concatenate a vector of strings</h2>
paste(sdata, collapse = '')
paste(sdata, collapse = '\\n')

<h2>update R</h2>
installr is the R package which helps install and update software.

install.packages("installr")
library(installr)
updateR()

<h2>To hide internal functions</h2>
When writing packages, it is sometimes useful to use leading dots in function names because these functions are somewhat hidden from general view. Functions that are meant to be purely internal to a package sometimes use this.

"somewhat hidden" simply means that the variable (or function) won't normally show up when you list object with ls().
To force ls to show these variables, use ls(all.names=TRUE).
By using a dot as first letter of a variable, you change the scope of the variable itself.

For example:
x <- 3
.x <- 4

ls() # "x"
ls(all.names=TRUE) # ".x" "x" 
x # 3
.x # 4


<h2>y ~ I(x^3)</h2>
The tilde operator is actually a function that returns an unevaluated expression, a type of language object. 

The expression then gets interpreted by modeling functions in a manner that is different than the interpretation of operators operating on numeric objects.

The issue here is how formulas and specifically the "+, ":", and "^" operators in them are interpreted. 

(A side note: the correct statistical procedure would be to use the function poly when attempting to make higher order terms in a regression formula.) 

Within R formulas the infix operators "+", "*", ":" and "^" have entirely different meanings than when used in calculations with numeric vectors. 

In a formula the tilde (~) separates the left hand side from the right hand side. 

The ^ and : operators are used to construct interactions so x = x^2 = x^3 rather than becoming perhaps expected mathematical powers. 
(A variable interacting with itself is just the same variable.)

If you had typed (x+y)^2 the R interpreter would have produced (for its own good internal use), not a mathematical: x^2 +2xy +y^2 , but rather a symbolic: x + y +x:y where x:y is an interaction term without its main effects. 
(The ^ gives you both main effects and interactions.)

?formula
The I() function acts to convert the argument to "as.is", i.e. what you expect. 

So I(x^2) would return a vector of values raised to the second power.
The ~ should be thought of as saying "is distributed as" or "is dependent on" when seen in regression functions. 
The ~ is an infix function in its own right. 

You can see that LHS ~ RHS is almost shorthand for formula(LHS, RHS) by typing this at the console:
`~`(LHS,RHS)
#LHS ~ RHS

class( `~`(LHS,RHS) )
#[1] "formula"
identical( `~`(LHS,RHS), as.formula("LHS~RHS") )

#[1] TRUE   # cannot use `formula` since it interprets its first argument

<h2>数据科学重要概念和图表</h2>
10 Must-Know Plots in Data Science
<div id="ideaNcharttoc"><a href="#ideaNcharttoctopic-0" target="_self" onclick="jumpto(0)">1、偏差-方差权衡</a><br><a href="#ideaNcharttoctopic-1" target="_self" onclick="jumpto(1)">2、基尼不纯度与熵</a><br><a href="#ideaNcharttoctopic-2" target="_self" onclick="jumpto(2)">3、精度与召回曲线</a><br><a href="#ideaNcharttoctopic-3" target="_self" onclick="jumpto(3)">4、ROC曲线</a><br><a href="#ideaNcharttoctopic-4" target="_self" onclick="jumpto(4)">5、弯头曲线（K-Means）</a><br><a href="#ideaNcharttoctopic-5" target="_self" onclick="jumpto(5)">6、Scree Plot (PCA)</a><br><a href="#ideaNcharttoctopic-6" target="_self" onclick="jumpto(6)">7、线性和逻辑回归曲线</a><br><a href="#ideaNcharttoctopic-7" target="_self" onclick="jumpto(7)">8、支持向量机(几何理解)</a><br><a href="#ideaNcharttoctopic-8" target="_self" onclick="jumpto(8)">9、标准正态分布规则(z -分布)</a><br><a href="#ideaNcharttoctopic-9" target="_self" onclick="jumpto(9)">10、学生 T 分布</a><br><a href="#ideaNcharttoctopic-10" target="_self" onclick="jumpto(10)">最后总结</a><br><a href="#ideaNcharttoctopic-11" target="_self" onclick="jumpto(11)">1. Bias-Variance Tradeoff</a><br><a href="#ideaNcharttoctopic-12" target="_self" onclick="jumpto(12)">2. Gini-Impurity vs Entropy</a><br><a href="#ideaNcharttoctopic-13" target="_self" onclick="jumpto(13)">3. Precision vs recall curve</a><br><a href="#ideaNcharttoctopic-14" target="_self" onclick="jumpto(14)">4. ROC Curve</a><br><a href="#ideaNcharttoctopic-15" target="_self" onclick="jumpto(15)">5. Elbow Curve (K-Means)</a><br><a href="#ideaNcharttoctopic-16" target="_self" onclick="jumpto(16)">6. Scree plot (PCA)</a><br><a href="#ideaNcharttoctopic-17" target="_self" onclick="jumpto(17)">7. Linear and Logistic Regression curve</a><br><a href="#ideaNcharttoctopic-18" target="_self" onclick="jumpto(18)">8. Support Vector Machines (geometric intuition)</a><br><a href="#ideaNcharttoctopic-19" target="_self" onclick="jumpto(19)">9. Adaboost Error Function</a><br><a href="#ideaNcharttoctopic-20" target="_self" onclick="jumpto(20)">10. a) Rule of Standard Normal Distribution (Z-distribution)</a><br><a href="#ideaNcharttoctopic-21" target="_self" onclick="jumpto(21)">10. b) Student's T Distribution</a><br><a href="#ideaNcharttoctopic-22" target="_self" onclick="jumpto(22)">Final Thoughts</a><br></div></center><br><br>

<span class="brown">当算法给你一条曲线时，一定要知道这个曲线的含义！</span>
When algorithms give you curves, use them intelligently!
<h3 id="ideaNcharttoctopic-0">1、偏差-方差权衡</h3>这是一个总是在机器学习最重要理论中名列前茅的概念。

机器学习中的几乎所有算法（包括深度学习）都努力在偏差和方差之间取得适当的平衡，这个图清楚地解释了二者的对立关系。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuX4U3mSsNiaNBkZanwYv4d9AicyGHJ9HyyXQU39KQeOmbCnQAzdU45SYhw/640">

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXRk0v8iayBQleOAcLsEnm6iciaIJ9m1ccCCCKyp5qE9y5e7jvGMp92doIw/640">

<h3 id="ideaNcharttoctopic-1">2、基尼不纯度与熵</h3>Gini（缺乏同质性的度量）和 Entropy（随机性的度量）都是决策树中节点不纯度的度量。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuX9zvz2fw4fOpLjWxDQufTKAxN23d9TpfDHA9aibhVAyxoeZI2h6ZiaY2g/640">

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXj4qedpWjiao4OTor1vL9bjGib0vRcyaS0UGXf8ZLfzsolR3kOk3mdHqQ/640">

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXjElibDPJCDjfymHTWr8kiaPGeian6IRZ8qfo9sTOydKcOz5GNFxyNvCdQ/640">
对于这两个概念更重要的是要了解它们之间的关系，以便能够在给定的场景中选择正确的指标。
基尼不纯度（系数）通常比熵更容易计算（因为熵涉及对数计算）

<h3 id="ideaNcharttoctopic-2">3、精度与召回曲线</h3>精度-召回曲线显示了不同阈值的精度和召回率之间的权衡。
曲线下面积大代表高召回率和高精度，其中高精度与低误报率相关，高召回率与低误报率相关。

它可以帮助我们根据需要选择正确的阈值。
例如，如果我们的目标是减少类型 1 错误，我们需要选择高精度，而如果我们的目标是最小化类型 2 错误，那么我们应该选择一个阈值，使得召回率很高。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXuoU89tZQR6dSIRicic8icicYsn1r6ZUsZshqfOLDicicw1ZqiapKV1rOqbscw/640">
精度分母是一个变量：
即假阳性（归类为阳性的负样本）每次都会变化。
召回分母是一个常数：
它代表真值的总数，因此将始终保持不变。

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXbtvw7eIMCXLln1UyZIWev00V6IzCf9M6tUhxcCmapKK2jkPTjZQMow/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXbtvw7eIMCXLln1UyZIWev00V6IzCf9M6tUhxcCmapKK2jkPTjZQMow/640" data-was-processed="true">
这就是为什么下图 Precision 在结束时有一个波动，而召回始终保持平稳的原因。

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXOLmYnwYCwFCFoUbFtEtlmFb4fLIEYvtAoPT58flVfpQsaR8lPsf4qA/640" src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXOLmYnwYCwFCFoUbFtEtlmFb4fLIEYvtAoPT58flVfpQsaR8lPsf4qA/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-3">4、ROC曲线</h3>ROC 曲线是显示分类模型在所有分类阈值下的性能的图表。
这条曲线绘制了两个参数：
<ul><li>真阳性率</li><li>误报率</li></ul>
<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXeakdXEMz1O8v8fhia5HBg8gPuKWtmFibMOabfdAJZANutfdR6D5q9WNw/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXeakdXEMz1O8v8fhia5HBg8gPuKWtmFibMOabfdAJZANutfdR6D5q9WNw/640" data-was-processed="true">
此曲线下的面积（称为 AUC），也可用作性能指标。

AUC 越高，模型越好。

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXia298F4OuZthB5zB1DpavRibF5W2HOLxzrjpOvdmWALnIHh4vc8BTX8g/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXia298F4OuZthB5zB1DpavRibF5W2HOLxzrjpOvdmWALnIHh4vc8BTX8g/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-4">5、弯头曲线（K-Means）</h3>用于K-means算法中最优簇数的选择。
WCSS（簇内平方和）是给定簇中每个点与质心之间的平方距离之和。
当我们用 K（簇数）值绘制 WCSS 时，该图看起来像一个肘部（弯头）。

随着聚类数量的增加，WCSS 值将开始下降。
K = 1时WCSS值最大
<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXxlmLM61M6fKtWWWpxq2vceEXYEhib9UehXtcmmu6dy08u8HVVKI1QFQ/640" src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXxlmLM61M6fKtWWWpxq2vceEXYEhib9UehXtcmmu6dy08u8HVVKI1QFQ/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-5">6、Scree Plot (PCA)</h3>它帮助我们在对高维数据执行主成分分析后，可视化每个主成分解释的变异百分比。
为了选择正确数量的主成分来考虑我们的模型，我们通常会绘制此图并选择能够为我们提供足够好的总体方差百分比的值。

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXZZFtVymhxnoNOYxDVltlmrK53zeXvicMdtrUCj4KUBHsR4EO57Isuiaw/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXZZFtVymhxnoNOYxDVltlmrK53zeXvicMdtrUCj4KUBHsR4EO57Isuiaw/640" data-was-processed="true">

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXUljJgEd3N8ByIDQQyvdlkqEkicEhiblsHmAkcNzibbXDlrzN1GkLQDq1Q/640" src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXUljJgEd3N8ByIDQQyvdlkqEkicEhiblsHmAkcNzibbXDlrzN1GkLQDq1Q/640" data-was-processed="true">

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXEAia7o0licBcnXfQ9coXDbPwBURaM6urx7VvTOvpJCb1fLycsXq2C7nw/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXEAia7o0licBcnXfQ9coXDbPwBURaM6urx7VvTOvpJCb1fLycsXq2C7nw/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-6">7、线性和逻辑回归曲线</h3>
<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXLGibHbaEpMS7Z3AhUp1gvTib72dyWubl95st70wNRviaPibQTEwwsN1CiaA/640" src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXLGibHbaEpMS7Z3AhUp1gvTib72dyWubl95st70wNRviaPibQTEwwsN1CiaA/640" data-was-processed="true">
对于线性可分数据，我们可以进行线性回归或逻辑回归，二者都可以作为决策边界曲线/线。
但是，在逻辑回归的情况下，由于通常只有 2 个类别，因此具有线性直线决策边界可能不起作用，在一条直线上值从低到高非常均匀地上升，因为它不够陡峭在值突然上升后会得到很多临界的高值或者低值，最终会错误分类。

因此，“边界”区域，即概率从高到低转变的区域并不真正存在。
所以一般情况下会应用 sigmoid 变换将其转换为 sigmoid 曲线，该曲线在极端情况下是平滑的，在中间几乎是线性的
<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXt7bCibCibdFZuE7v1086GqydDVMx9gPBlQ8uboVNvYwIicEO7kcD2bCYw/640" src="https://mmbiz.qpic.cn/mmbiz_png/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXt7bCibCibdFZuE7v1086GqydDVMx9gPBlQ8uboVNvYwIicEO7kcD2bCYw/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-7">8、支持向量机(几何理解)</h3>
<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXms5SQGBd1P5GQ5d5iaz8WBbasFh3LXUicoewuymm4OByfN7IysibmIqYg/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXms5SQGBd1P5GQ5d5iaz8WBbasFh3LXUicoewuymm4OByfN7IysibmIqYg/640" data-was-processed="true">

<h3 id="ideaNcharttoctopic-8">9、标准正态分布规则(z -分布)</h3>均值为0，标准差为1的特殊正态分布。

<img class="lazy loaded" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXYKtQU8SCs9PYYSsZTeMtXNuKrl8LA00ibzsM5RlhXbLAkIOC3g3zu5w/640" src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXYKtQU8SCs9PYYSsZTeMtXNuKrl8LA00ibzsM5RlhXbLAkIOC3g3zu5w/640" data-was-processed="true">
经验法则指出，按照正态分布观察到的数据中有 99.7% 位于平均值的 3 个标准差以内。
根据该规则，68% 的数据在一个标准差内，95% 在两个标准差内，99.7% 在三个标准差内。

<h3 id="ideaNcharttoctopic-9">10、学生 T 分布</h3>T 分布（也称为学生 T 分布）是一系列分布，看起来几乎与正态分布曲线相同，只是更短和更宽/更胖。
当我们有较小的样本时，我们使用 t 分布而不是正态分布。

样本量越大，t 分布越像正态分布。
事实上，在 30 个样本之后，T 分布几乎与正态分布完全一样。

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuXP2tT8lgprKabdbKRdvC9kEfyuyuYT5Ll48mGbQGun0zfB2LkVddMibw/640">

<h3 id="ideaNcharttoctopic-10">最后总结</h3>我们可能会遇到许多小而关键的概念，这些概念构成了我们做出决定或选择正确模型的基础。
本文中提到的重要概念都可以通过相关的图表进行表示，这些概念是非常重要的，需要我们在看到其第一眼时就知道他的含义，如果你已经对上面的概念都掌握了，那么可以试试说明下图代表了什么：

<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/gX9JE5tiaI7ib96MGdWVuuFpvmbPFxwKuX3NYPR6xUAwqccez2p0z0sn6AWM0LzhNmxFkrVMGva6KpRVDYEhLeFA/640">

<h3 id="ideaNcharttoctopic-11">1. Bias-Variance Tradeoff</h3>
This one is likely to always top the list in Machine Learning's most important distributions and theories. 
Almost every algorithm in Machine learning strives to strike a right balance between Bias and Variance and this plot clearly explains how struggle is so real (with one decreasing as the other increases)

<img class="lazy" data-src="https://miro.medium.com/max/1228/0*oUAdv7cGigbujCrA.png">

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*PEhOXmHmxqkQvNAp.png">

<h3 id="ideaNcharttoctopic-12">2. Gini-Impurity vs Entropy</h3>
Both Gini (measure of lack of homogeneity) and Entropy (measure of randomness) are measures of impurity of nodes in a Decision Tree.

<img class="lazy" data-src="https://miro.medium.com/max/1154/0*0g2fuTjm-e27BQtw.png">

<img class="lazy" data-src="https://miro.medium.com/max/892/0*K12qwl9-pwCIkBLo.png">

<img class="lazy" data-src="https://miro.medium.com/max/1090/0*TWJZCCvWDBo5GUGZ.png">

It is however important to understand the relation between them in order to be able to pick the right metric in a given scenario.

Gini Impurity is usually easier to compute than Entropy (involves logarithmic calculations )

<h3 id="ideaNcharttoctopic-13">3. Precision vs recall curve</h3>
The precision-recall curve shows the tradeoff between precision and recall for different thresholds. 
A high area under the curve represents both high recall and high precision, where high precision relates to a low false positive rate, and high recall relates to a low false negative rate.
<blockquote>
It can helps us pick the right threshold value depending on what we need. 
For e.g if our motive is to reduce Type 1 error, we need to pick high precision whereas if we aim to minimize Type 2 error then we should pick a threshold such that sensitivity or recall is high.
</blockquote>

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*srrytFhasC9hk4Kp.png">
<blockquote>
Why do precision have bumpy nature at the end ?
</blockquote>
<h4>Precision = True Positive / Predicted Results</h4>
<h4>Recall = True Positive / Actual Results</h4><blockquote>
Predicted Results are likely to vary in each tril, while Actual results are fixed.
</blockquote>
<img class="lazy" data-src="https://miro.medium.com/proxy/0*x1tzvLkTfW1OagXE.png">

Denominator of Precision is a variable : i.e the False positives (negative samples classified as positive) can vary each time in our solution.

Denominator of Recall is a constant : It represents the total Positive cases (i.e True Positive + False Negative) & hence will remain fixed throughout.

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*s4M7lbt4ZwkPHrFO">

That's the reason why Precision has a bumpy end whereas recall/sensitive remains smooth throughout.

<img class="lazy" data-src="https://miro.medium.com/max/1124/0*dFU6yEA3D1e1km1F.png">
<h3 id="ideaNcharttoctopic-14">4. ROC Curve</h3>
An ROC curve (receiver operating characteristic curve) is a graph showing the performance of a classification model at all classification thresholds.

This curve plots two parameters :<blockquote>
True Positive Rate (or sensitivity)
False Positive Rate (or 1-specificity)
</blockquote>

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*0PFBOGMWTKZ_jdK2.png">

Area under this curve (called AUC) and can also be used as a performance metric. 
The higher the AUC, better the model.

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*8CY7L2v0D88AErRR.jpeg">
<h3 id="ideaNcharttoctopic-15">5. Elbow Curve (K-Means)</h3>
Used for the selection of optimal number of clusters in K-means algorithm.

WCSS (Within-Cluster Sum of Square) is the sum of squared distance between each point and the centroid in a given cluster. 
When we plot the WCSS with the K (number of clusters) value, the plot looks like an Elbow.
<blockquote>
As the number of clusters increases, the WCSS value will start to decrease. 
WCSS value is largest when K = 1
</blockquote>
<img class="lazy" data-src="https://miro.medium.com/max/814/0*5yiJhX4sc3zJwJXB.png">

<h3 id="ideaNcharttoctopic-16">6. Scree plot (PCA)</h3>
It helps us visualize the percentage of variation explained by each principal component after performing principal component analysis on a high dimensional data.

So in order to pick the right number of principal components to consider for our model, we usually plot this and choose the value which gives us a good enough variance percentage overall.

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*kWBwC9qgSe6m2481">

<img class="lazy" data-src="https://miro.medium.com/max/782/0*BEYJ9zH6w06UMfxo.png">

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*BbEYGA25vHjbvaXu.jpg">

<h3 id="ideaNcharttoctopic-17">7. Linear and Logistic Regression curve</h3>
<img class="lazy" data-src="https://miro.medium.com/max/1400/0*Nzsf0QeEdcf_rQuK.png">

For a linearly separable data, we can either have a linear regression or logistic regression. 
However the decision boundary cries for both.

<h4>We need a curve/line that has all these properties —</h4><blockquote>
extremely low values in the start
extremely high values in the end
and intermediate values in the middle
</blockquote>
Both the plots satisfy this property. 
However, in case of logistic regression, since there are usually only 2 categories, having a linear straight decision boundary may not work as it is not steep enough & will end up misclassifying points In the sigmoid curve, we have low values for a lot of points, then the values rise all of a sudden, after which we have a lot of high values.

In a straight line though, the values rise from low to high very uniformly, and hence, the “boundary” region, the one where the probabilities transition from high to low is not really present..

Hence we apply a sigmoid transformation to convert it to a sigmoid curve which is smooth at the extremes and almost linear in middle (for moderate values)

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*3EEmf6LQ07cC6XY4.png">
<h3 id="ideaNcharttoctopic-18">8. Support Vector Machines (geometric intuition)</h3>
Here is a wonderful article on SVM, one of the most powerful ML algorithms.

<img class="lazy" data-src="https://miro.medium.com/max/1132/0*Q1OQLkQcxr2wj5oC.png">

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*8_Zo5KmDYT_tTBke.gif">
<figcaption>Image Source</figcaption>
Here is another great blog in the intuition of SVMs
<h3 id="ideaNcharttoctopic-19">9. Adaboost Error Function</h3>
The final output of the adaboost classifier depends on the sign of the following expression :

<img class="lazy" data-src="https://miro.medium.com/max/766/0*VGzXZtZ7VWI_HBI-.png">

where,

ht(x) — output of the weak classifier ‘t'

αt — weight applied to classifier ‘t'

<img class="lazy" data-src="https://miro.medium.com/max/536/0*qA0kplddvaa3ZVsT.png">

Here, εt is the error term of the classifier ‘t'

Interpretation:
<ul><li>If yt*ht(xi) is positive and α>0, then it is a strong classifier and hence the weight assigned is small.</li><li>If yt*ht(xi) is positive and α&lt;0, then it is a weak classifier and hence the weight assigned is large.</li><li>If yt*ht(xi) is negative and α>0, then it is a weak classifier and hence the weight assigned is large.</li><li>If yt*ht(xi) is negative and α&lt;0, then it is a strong classifier and hence the weight assigned is small.</li></ul>

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*nwfiTaIOO7zGlx67.png">

<h3 id="ideaNcharttoctopic-20">10. a) Rule of Standard Normal Distribution (Z-distribution)</h3>
special normal distribution where the mean is 0 and the standard deviation is 1.

<img class="lazy" data-src="https://miro.medium.com/max/1400/0*T5kp6xrfFfQjk03w.png">

The Empirical Rule states that 99.7% of data observed following a normal distribution lies within 3 standard deviations of the mean.

Under this rule, 68% of the data falls within one standard deviation, 95% percent within two standard deviations, and 99.7% within three standard deviations from the mean.
<h3 id="ideaNcharttoctopic-21">10. b) Student's T Distribution</h3>
<img class="lazy" data-src="https://miro.medium.com/max/1400/0*69FZ6dPw6GwYqxLz.png">

The T distribution (also called Student's T Distribution) is a family of distributions that look almost identical to the normal distribution curve, only a bit shorter and wider/fatter.

We use the t distribution instead of the normal distribution, when we have smaller samples.

The larger the sample size, the more the t distribution looks like the normal distribution. 
In fact, after 30 samples, the T- distribution is almost exactly like the normal distribution.
<h3 id="ideaNcharttoctopic-22">Final Thoughts</h3>
Once we understand the intuitions behind each of the Machine learning algorithms, we are likely to come across many small, yet crucial concepts which form the very basis of making a decision or choosing the right value for our model.

One of many such concepts were these plots which I found extremely useful while revisiting machine learning algorithms. 
Keeping these in mind can be a bit challenging amidst tones of other concepts. 
Hence decided to write this short blog compiling them all together.

<img class="lazy" data-src="https://miro.medium.com/max/1280/0*GI1VMUXL8A_Cda58.gif">

<h2>shell file with space character</h2>
output = '"youtube TOC.txt"' # shell file with space character
shell(output)

# testRingSound
output = 'C:/Users/william/Desktop/vbscript/testRingSound.vbs'
shell(output)

# image
output = '补气血.gif'
shell(output)

<h2>find end punctuations</h2>
[^。！？>；]

<h2>remove unicode &lt;U+00A0></h2>
"\u00a0" pattern is incompatible with PCRE regex flavor, to match unicode code points, you need to use \x{00a0} notation.

<h2>Colors in R</h2>

<div id="ColorsinRtoc" class="toc"><a href="#ColorsinRtopic-0" target="_self">Built-in color names in R</a><br><a href="#ColorsinRtopic-1" target="_self">Specifying colors by hexadecimal code</a><br><a href="#ColorsinRtopic-2" target="_self">Using RColorBrewer palettes</a><br><a href="#ColorsinRtopic-3" target="_self">Use Wes Anderson color palettes</a><br><a href="#ColorsinRtopic-4" target="_self">Create a vector of n contiguous colors</a><br><a href="#ColorsinRtopic-5" target="_self">Infos</a><br></div></center><br><br>
In <i>R</i>, <i>colors</i> can be specified either by name (e.g <i>col = “red”</i>) or as a hexadecimal RGB triplet (such as <i>col = “#FFCC00”</i>). 
You can also use other <i>color</i> systems such as ones taken from the <i>RColorBrewer package</i>.

<h3 id="ColorsinRtopic-0">Built-in color names in R</h3>
We will use the following custom R function to generate a plot of color names available in R :
<code># Generate a plot of color names which R knows about.
#++++++++++++++++++++++++++++++++++++++++++++
# cl : a vector of colors to plots
# bg: background of the plot
# rot: text rotation angle
#usage=showCols(bg="gray33")
showCols &lt;- function(cl=colors(), bg = "grey",
                     cex = 0.75, rot = 30) {
    m &lt;- ceiling(sqrt(n &lt;-length(cl)))
    length(cl) &lt;- m*m; cm &lt;- matrix(cl, m)
    require("grid")
    grid.newpage(); vp &lt;- viewport(w = .92, h = .92)
    grid.rect(gp=gpar(fill=bg))
    grid.text(cm, x = col(cm)/m, y = rev(row(cm))/m, rot = rot,
              vp=vp, gp=gpar(cex = cex, col = cm))
  }</code>
The names of the first sixty colors are shown in the following chart :
<code># The first sixty color names
showCols(bg="gray20",cl=colors()[1:60], rot=30, cex=0.9)
# Barplot using color names
barplot(c(2,5), col=c("chartreuse", "blue4"))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-built-in-color-names1.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-built-in-color-names2.png">

To view all the built-in color names which R knows about (n = 657), use the following <i>R</i> code :
<code>showCols(cl= colors(), bg="gray33", rot=30, cex=0.75)</code>

<h3 id="ColorsinRtopic-1">Specifying colors by hexadecimal code</h3>
Colors can be specified using hexadecimal color code, such as <i>“#FFC00”</i>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/images/hextable.gif" alt="Hexadecimal color code">

<code># Barplot using hexadecimal color code
barplot(c(2,5), col=c("#009999", "#0000FF"))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-hexadecimal-color-code.png">


<h3 id="ColorsinRtopic-2">Using RColorBrewer palettes</h3>
You have to install the <i>RColorBrewer</i> package as follow :
<code>install.packages("RColorBrewer")</code>
<i>RColorBrewer</i> package create a nice looking color palettes. 

The color palettes associated to <i>RColorBrewer</i> package can be drawn using <i>display.brewer.all()</i> R function as follow :
<code>library("RColorBrewer")
display.brewer.all()</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-rcolorbrewer-palettes.png">

There are <i>3 types of palettes</i> : sequential, diverging, and qualitative.
<i>Sequential palettes</i> are suited to ordered data that progress from low to high (gradient). 
The palettes names are : Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu YlOrBr, YlOrRd.
<i>Diverging palettes</i> put equal emphasis on mid-range critical values and extremes at both ends of the data range. 
The diverging palettes are : BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral
<i>Qualitative palettes</i> are best suited to representing nominal or categorical data. 
They not imply magnitude differences between groups. 
The palettes names are : Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3

You can also view a single RColorBrewer palette by specifying its name as follow :
<code># View a single RColorBrewer palette by specifying its name
display.brewer.pal(n = 8, name = 'RdBu')</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-display-rcolorbrewer-single-palette.png">

<code># Hexadecimal color specification 
brewer.pal(n = 8, name = "RdBu")</code>
<code>## [1] "#B2182B" "#D6604D" "#F4A582" "#FDDBC7" "#D1E5F0" "#92C5DE" "#4393C3" "#2166AC"</code>
<code># Barplot using RColorBrewer
barplot(c(2,5,7), col=brewer.pal(n = 3, name = "RdBu"))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-plot-wusing-rcolorbrewer-palette.png">


<h3 id="ColorsinRtopic-3">Use Wes Anderson color palettes</h3>
This color palettes can be installed and loaded as follow :
<code># Install
install.packages("wesanderson")
# Load
library(wesanderson)</code>
The available color palettes are :
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes1.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes2.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes3.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes4.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes5.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes6.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes7.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes8.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes9.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes10.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes11.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes12.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-wesanderson-palettes13.png">

Use the palettes as follow :
<code># simple barplot
barplot(c(2,5,7), col=wes.palette(n=3, name="GrandBudapest"))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-grandbudapest-barplot.png">

<code>library(ggplot2)
ggplot(iris, aes(Sepal.Length, Sepal.Width, color = Species)) + 
  geom_point(size = 2) + 
  scale_color_manual(values = wes.palette(n=3, name="GrandBudapest"))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-grandbudapest-ggplot2.png">


<h3 id="ColorsinRtopic-4">Create a vector of n contiguous colors</h3>
You can also generate a vector of n contiguous colors using the functions <i>rainbow(n)</i>, <i>heat.colors(n)</i>, <i>terrain.colors(n)</i>, <i>topo.colors(n)</i>, and <i>cm.colors(n)</i>.
<code># Use rainbow colors
barplot(1:5, col=rainbow(5))
# Use heat.colors
barplot(1:5, col=heat.colors(5))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-contiguous-colors1.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-contiguous-colors2.png">

<code># Use terrain.colors
barplot(1:5, col=terrain.colors(5))
# Use topo.colors
barplot(1:5, col=topo.colors(5))
# Use cm.colors
barplot(1:5, col=cm.colors(5))</code>
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-contiguous-colors-terrain-topo1.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-contiguous-colors-terrain-topo2.png">
<img class="lazy" data-src="http://www.sthda.com/sthda/RDoc/figure/graphs/colors-in-r-contiguous-colors-terrain-topo3.png">


<h3 id="ColorsinRtopic-5">Infos</h3>
<code>This analysis has been performed using R (ver. 3.1.0).</code>

<h2>stock price range statistics</h2>
  Sys.setlocale(category = 'LC_ALL', 'Chinese')

  dirStr = "D:/Dropbox/STK/!!! STKMon !!!/"
  setwd(dirStr)
  ACodeTableDataFile = readLines("全部Ａ股20230131.txt")
  HKCodeTableDataFile = readLines("香港主板20230131.txt")

  DataFile = ACodeTableDataFile

  tableNames = c(unlist(strsplit(DataFile[1], "\t")))

  DataFile = DataFile[-1]
  DataFile = DataFile[-length(DataFile)]
  CodeTableDataLen = length(DataFile)
  CodeTableWidth = length(tableNames)

  CodeTable = unlist(strsplit(DataFile, "\t"))
  CodeTable = matrix(CodeTable, nrow = CodeTableDataLen, ncol = CodeTableWidth, byrow=TRUE)

  colnames(CodeTable) = tableNames
  CodeTable = as.data.frame(CodeTable)
  stkCodes = CodeTable[,1]
  stkNames = CodeTable[,2]
  price = as.numeric(CodeTable[,5])
  minPrice = min(price)
  maxPrice = max(price)
  breaks = seq(minPrice-0.1, maxPrice, by = 0.5)
  breaktable = table(cut(price, breaks))

  range = round(length(breaktable)/50, 0)
  breaktable = breaktable[1:range]

  par(mar = c(1, 1, 1, 1))
  plot(breaktable)

  max(breaktable)
  which.max(breaktable)
  breaktable[which.max(breaktable)]
  plotrange = which.max(breaktable) * 3
  breaktable = breaktable[1:plotrange]
  breaktable[1:11]
  plot(cumsum(breaktable[1:22]))
  plot(breaktable[1:33])
  sum(breaktable[5:11])
  breaktable[5:11] # 1.9:5.4
  breaktable[5:33] # 1.9:16.4
  sum(breaktable[5:33]) # total: 3007

  Sys.setlocale(category = 'LC_ALL', 'Chinese')

  dirStr = "D:/Dropbox/STK/!!! STKMon !!!/"
  setwd(dirStr)
  ACodeTableDataFile = readLines("全部Ａ股20230131.txt")
  HKCodeTableDataFile = readLines("香港主板20230131.txt")

  DataFile = HKCodeTableDataFile

  tableNames = c(unlist(strsplit(DataFile[1], "\t")))

  DataFile = DataFile[-1]
  DataFile = DataFile[-length(DataFile)]
  CodeTableDataLen = length(DataFile)
  CodeTableWidth = length(tableNames)

  CodeTable = unlist(strsplit(DataFile, "\t"))
  CodeTable = matrix(CodeTable, nrow = CodeTableDataLen, ncol = CodeTableWidth, byrow=TRUE)

  colnames(CodeTable) = tableNames
  CodeTable = as.data.frame(CodeTable)
  tradeAmt = as.numeric(CodeTable[,4])

  ActiveCodeTable = CodeTable[tradeAmt>100,]
  stkCodes = ActiveCodeTable[,1]
  stkNames = ActiveCodeTable[,2]
  price = as.numeric(ActiveCodeTable[,5])
  minPrice = min(price)
  maxPrice = max(price)

  breaks = seq(minPrice-0.1, maxPrice, by = 0.4)
  cutTable = table(cut(price, breaks)) # frequency table of price range
  length(cutTable) # 1185

  range = round(length(cutTable)/20, 0) # select the first 5%
  cutTable = cutTable[1:range]

  par(mar = c(1, 1, 1, 1))
  plot(cutTable)

  max(cutTable) # max frequency 51
  which.max(cutTable) # max frequency price range 0.739,1.139
  cutTable[which.max(cutTable)] # index position of max
  plotrange = which.max(cutTable) * 6

  cutTable = cutTable[1:plotrange]
  sum(cutTable[1:plotrange]) # 456
  cutTable[1:plotrange] # 0:7.1
  sum(cutTable[1:10]) # 315
  cutTable[1:10] # 0:3.9

<h2>check file exist and modify src addr</h2>
setwd("D:/Dropbox/MyDocs/R misc Jobs/ExtractFiles")
url = readLines("checkFIleExist.txt")  # url addr to be verified

modifyTxt = character()
for (i in url) {
    cat(". ")
    tmp <- tryCatch(
             readLines(url(i), warn=F), silent = TRUE,
             error = function (e) NULL
           )
    if (is.null(tmp)) {
      print(paste(i, " doesn't exist"))
      modifyTxt = c(modifyTxt, i)
      next() # skip to the next url.
    }
}

srcTxt = url
for (i in modifyTxt) {
    targetIdx = grep(i, srcTxt)
    cat(targetIdx, srcTxt[targetIdx], "\n")
    srcTxt[targetIdx] = gsub("originals", "564x", srcTxt[targetIdx])
}

# write back file
sink("checkFIleExist.txt")
  cat(srcTxt, sep="\n")
sink()

<h2>determine image width and height in pixels</h2>
use the jpeg package.

require(jpeg)
img <- readJPEG("myimage.jpg") 

dim(img)
[1] 700 700   3

<h2>machine learning tutorial</h2>
<div id="machinelearningtoc" class="toc"><a href="#machinelearningtopic-0" target="_self" onclick="jumpto(0)">What is “machine learning”?</a><br><a href="#machinelearningtopic-1" target="_self" onclick="jumpto(1)">The difference between (inferential) statistics vs. machine-learning, and typical examples</a><br><a href="#machinelearningtopic-2" target="_self" onclick="jumpto(2)">Step 1: Get data</a><br><a href="#machinelearningtopic-3" target="_self" onclick="jumpto(3)">Step 2: Visual inspection / descriptive statistics</a><br><a href="#machinelearningtopic-4" target="_self" onclick="jumpto(4)">Step 3: Partition data into training and test datasets</a><br><a href="#machinelearningtopic-5" target="_self" onclick="jumpto(5)">Step 4: Pre-processing and feature engineering</a><br><a href="#machinelearningtopic-6" target="_self" onclick="jumpto(6)">Step 5: Visualize exemplary algorithm</a><br><a href="#machinelearningtopic-7" target="_self" onclick="jumpto(7)">Step 6: Model training</a><br><a href="#machinelearningtopic-8" target="_self" onclick="jumpto(8)">Step 7: Model evaluation against the test data</a><br><a href="#machinelearningtopic-9" target="_self" onclick="jumpto(9)">Step 8: Model deployment</a><br><a href="#machinelearningtopic-10" target="_self" onclick="jumpto(10)">Next steps</a><br></div></center>
<br><br>

If you’re a graduate of economics, psychology, sociology, medicine, biostatistics, ecology, or related fields, you probably have received some training in statistics, but much less likely in machine learning. 
This is a problem because machine-learning algorithms are much better capable to solve many real-world applications compared with the procedures we learned in statistics class (randomized experiments, significance tests, correlation, ANOVA, linear regression, and so on).

Examples:
You have data on a patient (clinical data such as resting heart rate, laboratory values, etc.) and you want to predict whether this patient will likely suffer from a heart attack soon. 

You have sensor data from machines (e.g., temperature, oil pressure, battery charge level, current consumption…) and you want to forecast which machines are likely to fail in the near future in order to prevent these failures (predictive maintenance).
You have data on a lot of customers and you want to predict which of the customer is likely interested in buying a certain new product (think “you might also like…”).
You have images, audio, or video data from, say, satellite images of rainforest districts, X-ray scans of patients, photos of microorganisms, etc., and you want a machine to automatically classify what the images contain (e.g., illegal deforestation, bone fracture, subspecies of microorganisms, …). 

(For this type of use case, read also <a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2021/03/16/how-to-build-your-own-image-recognition-app-with-r-part-1/" target="_blank">this tutorial</a>).
You have text data, e.g. from customer e-mails, transcripts of speeches, tweets by politicians, etc., and you want a machine to detect machinelearningtopics in these texts (if you have a case like this, see also <a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2021/11/29/detecting-machinelearningtopics-in-mails-tweets-etc-how-to-create-a-text-classification-algorithm-from-scratch-in-r/" target="_blank">this tutorial</a>).

In all of these examples, statistical models are used to solve the problem, but in a different way than how you learned it in “Introduction to Statistics”.

In this post I want to give you a brief introduction what “machine learning” means, what the differences to “classical” statistical procedures are, and how you can train a machine learning model in R for your own use case in 8 simple steps.
<h3 id="machinelearningtopic-0">What is “machine learning”?</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Think of a facial-recognition app. 

How does the app know whether it’s John or rather Jane it’s looking at? 
A conventional approach would be: Create an exhaustive list of features about John which can be quantitatively measured for the computer to memorize. 
E.g.: Look for short, brown hair, a three-day beard, a prominent nose, a scar on the left forehead, the distance between his eyes is 10.4 centimeters, he often wears a black hat, etc., that’s John. 

The problems with this approach are obvious:
Hard-coding these rules is tedious, especially if you want your app to be able to detect hundreds or thousands of different people.
You might have left out one or more important features that differentiate John from others. 
You’re probably not a domain expert (e.g., a forensic scientist, a cosmetic surgeon, etc.) who has the time to study each face rigorously.


The machine-learning approach works differently: You feed a computer many pictures labelled “John” or “Jane”, and that’s it, you don’t provide any additional information – rather, you let the machine infer the important features which best discern John from Jane. 
It might be that the form of the cheek bones are actually a better predictor of whether or not it’s John on the image, rather than the hair color or the distance between the eyes. 
You don’t care, you let the machine figure it out. 

Thus, this is a data-driven (inductive) approach, where a machine *learns* the rules how to classify faces (e.g., if X1 and X2 are present, then it’s likely John) from a set of training data. 
You don’t specify these rules manually. 
This is why machine learning is considered (a subfield of) artificial intelligence: The machine carries out tasks without being explicitly told what to do. 

We will discuss how this “learning” works later in this post. 
Importantly, to make sure that your program is good at detecting John in <em>new and unseen</em> pictures (e.g., John not wearing a hat, having shaved), you usually reserve a number of pictures of John which are not used during training in order to validate the model (see how accurate the machine can predict out-of-sample, i.e. data it hasn’t been trained on).

In sum, the essence of machine-learning is: A computer program learns from a set of training data which features are most important for the outcome you want to predict, and then the program can use the aquired skills to predict values in new data it hasn’t seen before. 
This is the most important difference to standard statistical approaches where most often, all available data are used to determine the statistical relationship under study (e.g., all respondents from a survey, all patients in a randomized control study… are used to determine whether a vaccine is effective; your main goal is not to leave aside a subset of the study participants to later test the model with unseen new data; rather, your goal is to report the relationships in all of the present data). 
<h3 id="machinelearningtopic-1">The difference between (inferential) statistics vs. machine-learning, and typical examples</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Roughly speaking, there are two types of statistical models: Models to explain vs. models to predict (see, e.g., <a rel="nofollow" href="https://projecteuclid.org/journals/statistical-science/volume-25/issue-3/To-Explain-or-to-Predict/10.1214/10-STS330.pdf" target="_blank">here</a> for further reading, or <a rel="nofollow" href="https://projecteuclid.org/journals/statistical-science/volume-16/issue-3/Statistical-Modeling--The-Two-Cultures-with-comments-and-a/10.1214/ss/1009213726.full" target="_blank">this classic paper</a> about the “two cultures” in statistics by Leo Breiman, pioneer of machine-learning models such as the random forest which we will use in this post). 

To keep it simple, I’m referring to the former as (inferential) “statistics” and to the latter as “machine-learning” (although machine-learning is a form of applied statistics as well, of course). 
Here is an overview table with explanations following below:

<table><tbody><tr><td> <k>“Statistics”</k></td><td> <k>“Machine learning”</k></td></tr>
<tr><td>Typical goal: Explanation</td><td>Typical goal: Prediction</td></tr>
<tr><td>Does X have an effect on Y?</td><td>What best predicts Y?</td></tr>
<tr><td>Example: Does a low-carb diet lead to a reduced risk of heart attack?</td><td>Example: Given various clinical parameters, how can we use them to predict heart attacks?</td></tr>
<tr><td>Task: Develop research design based on a theory about the data-generating process to identify the causal effect (via a randomized experiment, or an observational study with statistical control variables). <br>Don’t try out various model specifications until you get your desired result (better: pre-register your hypothesized model).</td><td>Task: Try out and tune many different algorithms in order to maximize predictive accuracy in new and unseen test datasets.<br>
A theory about the true data-generating process is useful but not strictly necessary, and often not available (think of, e.g., image recognition).</td></tr>
<tr><td>Parameters of interest: Causal effect size, <a href="https://forloopsandpiepkicks.wordpress.com/2022/01/09/finally-understanding-what-statistical-significance-and-p-values-mean-a-simple-example-with-r-code/" rel="nofollow" target="_blank">p-value</a>.</td><td>Parameters of interest: Accuracy (%), precision/recall, sensitivity/specificity, …</td></tr>
<tr><td>DON’T: Throw all kinds of variables into the model which might mask/bias your obtained effect (e.g., “spurious correlation”, “collider bias”).</td><td>Use whatever features are available and prove to be useful in predicting the outcome.</td></tr>
<tr><td>Use all the data to calculate your effect of interest. After all, your sample was probably designed to be representative (e.g. a random sample) of a population.</td><td>DON’T: Use all data to train a model. Always reserve subsets for validation/testing in order to avoid overfitting.</td></tr>
</tbody></table>

Stylized overview of the differences between statistics and machine-learning
Statistical models – models to explain – are most prevalent in the fields of economics, psychology, medicine, ecology, and related fields. 

They typically seek to uncover causal relations, i.e. explain relationships observed in the real world. 
Example: Does a low-carb diet, all other things being equal, lead to a lower risk of suffering from a heart attack? If you want to address this research question, you need a carefully designed study, either in the form of a randomized control trial, or observational data where you control for confounding factors (<a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2022/01/05/simple-examples-to-understand-what-confounders-colliders-mediators-and-moderators-are-and-how-to-control-for-variables-in-r-with-regression-and-propensity-score-matching/" target="_blank">here</a> is a tutorial on the difference between correlation and causation and what it means to control for confounding factors). 

The most important thing is thus to get a good research design. 
The statistical model, in the end, may be trivial, such as a simple significance test (what does this mean? –> cf. 
<a href="https://forloopsandpiepkicks.wordpress.com/2022/01/09/finally-understanding-what-statistical-significance-and-p-values-mean-a-simple-example-with-r-code/" rel="nofollow" target="_blank">here</a>) between the number of heart attacks observed in the experimental vs. 
the control group.
By contrast, in machine-learning you want to predict an outcome as accurately as possible. 
For instance, you want to predict whether a person suffers from a heart attack or not, based on various clinical parameters. 

“Prediction” here does not necessarily refer to things that happen in the future, but more importantly to data that were previously unseen to the algorithm. 
You thus want an algorithm that is able to accurately tell whether a person is about to suffer from a heart attack although the algorithm has not seen this particular person before.
In terms of X (cause) and Y (effect), therefore, most statistical studies are concerned with obtaining an estimate for X that is as unbiased as possible. 

For instance, eating 100 g fewer carbohydrates per day, by how much does this lower my risk of getting a heart attack in the next year. 
A machine-learning model, by contrast, is more concerned with predicting Y as accurately as possible (see, e.g., <a rel="nofollow" href="https://pubs.aeaweb.org/doi/pdfplus/10.1257/jep.31.2.87" target="_blank">here</a>). 
Indeed – and this might come as a surprise to you – as this <a rel="nofollow" href="https://projecteuclid.org/journals/statistical-science/volume-25/issue-3/To-Explain-or-to-Predict/10.1214/10-STS330.pdf" target="_blank">paper</a> by Shmueli shows (in the Appendix), you can have a model with <em>wrong</em> causal specifications about X that has greater predictive accuracy regarding Y as opposed to a model that represents the true data generating process. 

This is because in big datasets, many features are often highly correlated (say, crime rate, unemployment rate, population density, education, income level etc. 
between counties) and if you have wrong assumptions but many, many variables highly correlated to the true predictors, you will end up with a model which is just as good or (for random reasons) even better at predicting your outcome under study. 
This has famously lead people to <a rel="nofollow" href="https://pdodds.w3.uvm.edu/files/papers/others/2008/anderson2008a.pdf" target="_blank">declare</a> that scientific methods are obsolete, “correlation is causation”, and that big data and machine learning can replace classical statistics. 

But, we will soon learn the pitfall of this assumption.
In reality, the dichotomy of explanation (statistics) vs. prediction (machine-learning) is over-simplified. 

Many causal statistical studies also use their obtained model to predict new and unseen data. 
This is in general a good idea because failing to do so contributes to what is known as the <a rel="nofollow" href="https://science.sciencemag.org/content/349/6251/aac4716.abstract" target="_blank">replication crisis in science</a>. 
Effects from over-fitted models (“I have found a statistically significant interaction between gender and state of origin affecting the probability to get a promotion within the next three years, but this effect only shows in certain industries and only for respondents younger than 30”) are reported in scientific papers, and subsequent studies fail to replicate these often random findings. 

Therefore it is always good to perform out-of-sample tests even in explanatory studies such as medical randomized control trials. 
If you claim to have found a causal relationship, but it cannot predict new data better than a random guess, then what is the real-world significance of your findings?
Conversely, machine-learning applications can benefit from considering causality, instead of dismissing it as unnecessary. 

An example: Survey researchers and political pundits famously failed to predict Donald Trump’s win at the 2016 US presidential elections. 
Why was that? The models they used were based on correlations, not causations. 
They were working with statistical models where for each election district, the proportion of Republican vs. 
Democrat votes was predicted based on the latest survey results enriched with regional parameters such as percentage of Black or White voters, average income, percentage highly educated voters, blue-collar workers, general region (Mid-West, South, New England, etc.). 
These were all factors that were correlated with voting Republican or Democrat in the past, so the predictive accuracy of these models had been good. 
But, it turned out that White male blue-collar workers from the Mid-West had not voted Democrat in the past <em>because of</em> their ethnicity, education, or region of residence. 

These were just correlations without causal implications. 
When during the 2016 electoral campaigns, Democrats increasingly focused on machinelearningtopics such as identity politics which appealed more to well-educated urban voters rather than to blue-collar workers from the “rust belt”, many working-class voters favored Trump over Clinton. 
This is an example where the causal relations changed over time, and as a consequence, predictive models built on surrogate correlations stopped working. 

This is important, because in the same way, your machine-learning models predicting customer retention or machine failure may perform less well over time if the models disregard the true causal relations at work, and if these relationships change over time (e.g., your customer base gets older).
Alright, I apologize for the lengthy introduction. 
Hopefully, some of you are still following and this has made sense so far to you. 

The bottom line is:
If you are concerned with identifying a causal effect (does my marketing campaign/ vaccine/ product design change/ illegal deforestation have an effect on my product’s sales/ patient survival rates/ social media likes/ athmospheric temperature…), then this is not the tutorial for you. 
Look e.g. <a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2022/01/05/simple-examples-to-understand-what-confounders-colliders-mediators-and-moderators-are-and-how-to-control-for-variables-in-r-with-regression-and-propensity-score-matching/" target="_blank">here</a>, instead.
If you want to train an algorithm to accurately predict new data, and you have some basic knowledge of R, let’s get to it.

<h3 id="machinelearningtopic-2">Step 1: Get data</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
We are using a small dataset here containing medical records of 303 patients, and we want to predict whether or not they have coronary heart disease. 

For you to follow this tutorial, you can download the dataset <a href="https://www.kaggle.com/ronitf/heart-disease-uci" rel="nofollow" target="_blank">here</a>. 
(If you don’t have a Kaggle account, there are many other places to find this dataset since it’s widely used as a training dataset). 
You might recall from statistics or science classes that statistical studies usually start with a research question, theory, literature review, etc., so you might be confused why the first step is getting data rather than theoretical or conceptual considerations. 

While I’m not saying this is completely obsolete in a machine-learning project – see the example about the Trump vote above, and indeed it is good to have domain experts in your project team, as we will soon see -, it’s much less important compared with a causal research design. 
The more complex a dataset and the less meaningful the features (e.g., pixel values of an image, thousands of columns of IoT data from sensors…), the less likely you add value to your data-driven model with theoretical insights. 
Thus, keep in mind the point about changing underlying causal structures, but for now let’s focus on the data and modeling.

Download the file and move it to a folder of your choice, and then in R, run:
library(tidyverse)
library(caret)

library(party)
dat &lt;- read.csv("C:/Users/User/Desktop/heart.xls")
names(dat)[[1]] &lt;- "age"

dat$target &lt;- dplyr::recode(dat$target, `0` = 1L, `1` = 0L)
Where you of course replace “MyFolder” with the path to where you stored the dataset. 
Also, you have to install the three packages via, e.g., <em>install.packages(‘tidyverse’)</em> if you don’t have them installed yet, which you will notice if R throws an error when executing the first three lines..

First, let’s clean the data and check for duplicates or missing values.
sapply(dat, function(x) table(is.na(x)))
table(duplicated(dat))

dat &lt;- dat[!duplicated(dat),]
The first line gives us the number of missing cases for each column:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-54.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-54.png" data-was-processed="true">
Missing values (“TRUE”) by feature column

We see that missingness (is.na) is FALSE for all columns, which is great. 
The second line in the code chunk above tells us that there is one duplicated record, which we remove in line 3.
<h3 id="machinelearningtopic-3">Step 2: Visual inspection / descriptive statistics</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

This is often the most important part, because it tells you most of what is going on in your data. 
Let’s start with a plot of histograms for all features. 
Note that if your data has 100 columns instead of only 14, you could divide your data into parts of, say, 25 columns each. 

Just start the following code chunk with, e.g., dat[,1:25] %>% …
dat %>% gather() %>%
ggplot(aes(x=value)) + 
geom_histogram(fill="steelblue", alpha=.7) +
theme_minimal() +
facet_wrap(~key, scales="free")

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-55.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-55.png" data-was-processed="true">
Histograms of all our variables in our dataset
Here you see the univariate distributions – univariate because you’re looking at one variable at a time, not at bivariate correlations at this point. 
The most important variable to look at here is our Y, labeled “target”. 

This is coded 1 for patients with heart disease, and 0 for healthy patients. 
You can see that the data are not heavily imbalanced, there are only a few more healthy patients than patients with the disease. 
Regarding the other categorical features such as sex, you can also see from this graph whether they are imbalanced (1 = male, 0 = female here). 

With regard to the continuous variables such as age or maximum heart rate achieved (“thalach”), you can visually check whether they are more or less normally distributed (such as age), or whether they exhibit some distribution that might need some form of normalization or discretization (e.g., “oldpeak”).
You can also see that there are some categorical variables where certain values are represented only rarely among the patients. 
For instance, “restecg” has only very few instances of values == 2. 

We will deal with this in a minute.
Let’s move on to bivariate statistics. 
We are plotting a correlation matrix, in order to
 a) check if we have features that are highly correlated (which is problematic for some algorithms), and
 b) get a first feeling about which features are correlated with the target (heart disease) and which are not:

cormat &lt;- cor(dat %>% keep(is.numeric))
cormat %>% as.data.frame %>% mutate(var2=rownames(.)) %>%
pivot_longer(!var2, values_to = "value") %>%
ggplot(aes(x=name,y=var2,fill=abs(value),label=round(value,2))) +
geom_tile() + geom_label() + xlab(") + ylab(") +
ggtitle("Correlation matrix of our predictors") +
labs(fill="Correlation\n(absolute):")

This prints the following correlation matrix:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-56.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-56.png" data-was-processed="true">
Correlation matrix of all our predictor variables

We can see that aside from the diagonal (correlation of a variable with itself, which is 1), we have no problematically strong correlations between our predictors (strong meaning greater than 0.8 or 0.9 here). 
If you have many, many features and don’t want to look at 1,000 by 1,000 correlation matrices, you can also print a list of all correlations that are greater than, say, 0.8 with the following code:
highcorr &lt;- which(cormat > .8, arr.ind = T)

paste(rownames(cormat)[row(cormat)[highcorr]], 
colnames(cormat)[col(cormat)[highcorr]], sep=" vs. ") %>%

cbind(cormat[highcorr])
Now let’s look at the bivariate relations between the predictors and the outcome. 
For continuous predictors and a dichotomous outcome (heart disease or no heart disease), box plots are a good way of visualizing a bivariate association:

dat %>% select(-c(sex,cp,ca,thal,restecg,slope,exang,fbs)) %>%
pivot_longer(!target, values_to = "value") %>%
ggplot(aes(x=factor(target), y=value, fill=factor(target))) +

geom_boxplot(outlier.shape = NA) + geom_jitter(size=.7, width=.1, alpha=.5) +
scale_fill_manual(values=c("steelblue", "orangered1")) +
labs(fill="Heart disease:") +

theme_minimal() +
facet_wrap(~name, scales="free")
I’ve de-selected the non-continuous variables in the first line here manually, because I haven’t transformed the categorical variables (say, “ca” or “restecg”) into factors yet, which is of course a bit lazy, but if you have hundreds of features, there are of course more flexible ways to keep only continuous variables for the following plot. 

This is what the chunk above returns:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-57.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-57.png" data-was-processed="true">
Boxplots of the associations between our continuous predictors and the outcome
You can read this graph as follows: With regard to age, the patients with heart disease (red box) are on average older compared with the patients without heart disease (blue box). 

The thick horizontal line within each box denotes the median. 
The box encompasses 50% of all cases (i.e. from the 25 percentile to the 75 percentile). 

The jitter points show you where all of the patients are located within each group. 
So you see that, yes, heart disease patients are typically older, but you also have a couple of patients younger than 50 in the dataset who have coronary heart disease, and of course many older ones that are healthy. 
But comparing the medians, you can see that age, oldpeak, and thalach are better predictors of heart disease compared with chol or trestbps, where the median values are almost equal in both groups.

For our categorical variables, we just use simple stacked barplots to show the differences between healthy and sick patients:
dat %>% select(sex,cp,ca,thal,restecg,slope,exang,fbs,target) %>% 
pivot_longer(!target, values_to = "value") %>%

ggplot(aes(x=factor(value), fill=factor(target))) +
scale_fill_manual(values=c("steelblue", "orangered1")) +
geom_bar(position="fill", alpha=.7)+

theme_minimal() +
labs(fill="Heart disease:") +
facet_wrap(~name, scales="free")

Which gives us:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-58.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/01/grafik-58.png" data-was-processed="true">
Associations between our categorical predictors and the outcome
Again, you can see at a glance that “fbs” is obviously not a strong predictor of heart disease, whereas “exang” definitely is. 

We also see that males are overrepresented in sick patients compared with females.
So far, we have used very simple means to visualize the data. 
In my experience, in many applied business use cases, you already know most of what you wanted to know at this stage! A few simple descriptive graphs and indicators most often show you what are the most important predictors, what are the important sub-groups you need to focus on in greater detail, where do you have outliers or a lot of missing data which distorts the overall picture, and so on. 

Often, the complicated algorithm later on only confirms what we have seen so far. 
So it’s important not to skip this step and always do visual und descriptive inspection of your data.
You might ask, if in many cases bar charts and correlation coefficients is all we need to understand what is going on, why do we need the complicated machine-learning part? That is because while 80% of the explanation is often simple and can be inferred from looking at a graph or table, the other 20% is more complicated and requires domain knowledge and/or more sophisticated statistical analysis. 

Our example here perfectly illustrates this point: Older people suffer from heart disease more often than younger people; men are much more likely to get it compared with females; these findings are  trivial and everyone can see that from the graphs, no PhD in statistics required. 
And these simple associations can already guide clinical practice to a significant degree. 
You’re an older male? You’re in a risk group. 

You’re a young female? You’re probably fine. 
However, there are many more complex relationships at work. 
For instance, females often present themselves with different forms of chest pain compared with males. 

This is an example for an interaction effect that you couldn’t easily infer from the bivariate graphs above. 
Non-linearity, interaction effects, spurious correlations caused by third variables and multi-collinearity, complex data structures (e.g. time series, nested data…) – these are examples of aspects that cause descriptive inspections to be insufficient when we not only want to find out the most obvious things (older people are more at risk than young people), but also want to get behind the more complex relations.

<h3 id="machinelearningtopic-4">Step 3: Partition data into training and test datasets</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
As you probably know, splitting data into training and test sets is of uttermost importance in order to avoid overfitting your model. 
“Overfit” is one of these ubiquitous terms in machine learning, let’s explain this briefly with two examples. 

Skip the next couple of paragraphs if this bores you.
Let’s consider the following simple algorithm: “Whenever a patient is male, predict ‘heart disease’, otherwise predict ‘no heart disease’.” This algorithm would have an accuracy of 61% in our dataset, which you can verify by running:
pred &lt;- as.factor(ifelse(dat$sex==1,1,0))

confusionMatrix(pred,as.factor(dat$target))
This is better than nothing – always guessing “no heart disease” would be correct in 54% of cases, so the 61% of our “algorithm” are an improvement over this baseline (always check for class imbalance, i.e. the majority class’ percentage in your outcome, this is your baseline). 

This algorithm is often wrong – but we can be quite sure that it would be useful with <em>new</em> data to a similar degree (i.e. around 61% correct classifications), unless we have a very biased sample and in the total population, males are not suffering from heart disease more often than females. 
Contrast this with the following algorithm: “If a person is 77 years old, predict ‘heart disease’. 

If the person is 76 or 71 years old, however, predict ‘no heart disease’. 
If the person is 69 years old, then it depends: If the serum cholesterol level is between 234 and 239 mg/dl, then predict ‘no heart disease’, but if it’s exactly 254 mg/dl, then predict ‘heart disease’.” And so on, until all of our 303 patients are captured by one of these very specific rules. 
You get the idea: We would get an accuracy of 100% in our data if we continued like this. 

(By the way, you can generate a full set of these rules by growing a full-size decision tree, see below for example code). 
But while this very complex algorithm can correctly classify 100% of our patients in the present dataset, it would probably perform very poorly with new patients. 
This is because, for random reasons, all three patients aged 71 in our dataset were healthy whereas the one 77 year-old in our data was sick, but this can certainly not be generalized to a universal law: A new 71 year-old patient would always be classified as healthy by our algorithm, whereas all 77 year-olds would be predicted to have heart disease. 

This is obviously nonsense and as a result, despite a supposed accuracy of 100%, our algorithm might fare even worse than the very simple “if male, then sick” rule when applied to new patients. 
This is overfitting: The algorithm is too specific and captures everything in our data, even the random noise and idiosyncrasies (for whatever reasons, we have two 40 year-olds with coronary heart disease in our data but only one healthy 40 year-old). 
On the one hand, thus, you should not “learn” from all this random noise and be too specific in your classification rules. 

On the other hand, of course, you don’t want the algorithm to be too crude (e.g., simply predict a linear increase in diseases with age and nothing else) because you want to capture the true existing associations and interactions that are likely more complex. 
This is ensured by judging your algorithm’s performance against an unseen new test dataset, i.e. out-of-sample. 

We create a sequence of random numbers which encompass 70% of our dataset, designate this as “training”, and the rest as a test dataset which will not be touched again until the very end of the analysis:
set.seed(2022)
split &lt;- sample(1:nrow(dat), as.integer(0.7*nrow(dat)), F)

train &lt;- dat[split,]
test &lt;- dat[-split,]
<h3 id="machinelearningtopic-5">Step 4: Pre-processing and feature engineering</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

Pre-processing means that you apply transformations to some or all variables in order to better be able to use them in your models. 
Examples: Some models such as neural networks work better if all variables are scaled to mean = 0 and standard deviation = 1. 
Or, if a feature has a very skewed distribution (e.g. monthly income, where you have a few millionaires and an otherwise poor population), it might make sense to take the logarithm to normalize the variable. 
Or discretize, e.g. create 10 bins from “poorest percentile” to “richest percentile”. 

This makes sense if theoretically, the difference between earning 1 Million per year and 2 Million per year is less important compared to the difference between earning 30,000 or 60,000 per year. 
Because linear models (e.g., linear regression) give you estimates à la “earning one Euro more translates into an effect on Y the size of beta”, these estimates would be heavily influenced by the large numbers of the earners of 1M and 2M where not much changes between these numbers with regard to your Y.
In general, you get a good idea of what you have to do at this step by looking at the graph with the histograms above. 

We saw that “age” or “thalach” were pretty much normally distributed, so there’s nothing to do here. 
By contrast, “oldpeak” (which measures the S-T depression in an ecg under exercise relative to resting levels) has a skewed distribution: A significant number of patients don’t have any S-T depression, so it might make sense to transform the variable into a dichotomous or otherwise discretiziced variable. 
We also want to transform nominal variables with multiple categories (e.g., ethnicity, blood type, etc.) into binary variables for each outcome (also called one-hot encoding, or “dummy variables”). 

So instead of one variable with values 1 = Black, 2 = White,  3 = Asian, etc. 
you would create several variables “ethnicity_black” (1 or 0), “ethnicity_white” (1 or 0), and so on. 
In our dataset at hand, for instance, “cp” refers to 4 different chest pain types. 

Some algorithms such as tree-based models can deal with nominal variables, but others such as linear regression or neural networks usually cannot. 
There are also a few outliers and data errors. 
For instance, the description of the dataset notes that variable “ca” (number of major vessels colored by flouroscopy) has valid values 0 to 3, but we have one observation in the dataset where the value is 4. 

We take this and a few other outliers and assign them the modal value (i.e. the one that is most prevalent). 
Different strategies would be listwise deletion (i.e. drop the whole patient as a case if one value seems suspicious) or multiple imputation (where you replace the value not with the modal value, as we do it here, but a bit more sophisticated based on a model that consideres the other variables as well). 
Besides pre-processing we could also do feature engineering at this point – that is, if we have enough domain knowledge to do so. 
I don’t. 

But for the sake of demonstration, let’s just make something up. 
Feature engineering means that you create new variables out of the existing ones because of your knowledge about the data-generating process. 
For instance, we have the maximum heart rate achieved in the dataset. 

But we know that this is not only a function coronary heart disease, but is also affected by age. 
So we could calculate the age-standardized heart rate by simply dividing the heart rate by the patient’s age. 
Here, too, it’s important for you to know that some algorithms (e.g. tree-based models) can map these type of interactions automatically (if given enough data) whereas others such as linear regression do not. 
Thus, depending on the model, feature engineering is sometimes not needed at all (e.g., image recognition with convoluted neural networks which capture all interactions (e.g., neighboring pixel color values)), but in other applications it will affect your end result if you do meaningful transformations and interactions with your variables. 
We create a function where we apply all of the pre-processing steps. 

This allows us to later apply the same function to new data. 
For instance, if in the end, you want to deploy your algorithm in an app for doctors to use, you take the new data, apply the pre-processing function we built here, and then let the model (which we will train in a minute) predict the data:
preprocess_data &lt;- function(df){
  #R Outliers are assigned the modal value
  df &lt;- df %>% mutate(
    restecg = recode(restecg, `2`=1L),
    thal = recode(thal, `0`=2L),
    ca = recode(ca, `4`=0L))

  #Nominal variables
  nomvars &lt;- c("cp", "ca", "thal", "restecg", "slope")
  df[,names(df) %in% nomvars] &lt;- sapply(df[,names(df) %in% nomvars], as.character)
  dummies &lt;- dummyVars(~ ., df)
  df &lt;- predict(dummies, newdata = df) %>% as.data.frame
  
  #Age-standardized variables
  df$hr_age &lt;- df$thalach / df$age
  df$chol_age &lt;- df$chol / df$age

  #Oldpeak: Is there any ST depression
  df$st &lt;- ifelse(df$oldpeak>0,1,0)
  return(df[,names(df)!="target"])
}

We then apply the function to both our training and test datasets. 
We also create vectors y_train and y_test which consist of only the target (heart disease 1 or 0). 

This is not strictly necessary but the clear separation of predictors (x_…) and outcome (y_…) as well as the separation of train and test sets reduces the risk that you accidentally, say, train a model with the target included in the list of predictors, or apply some pre-processing function to your target, etc. 
x_train &lt;- preprocess_data(train)
x_test &lt;- preprocess_data(test)
y_train &lt;- factor(train[,"target"], levels=c(1,0))
y_test &lt;- factor(test[,"target"], levels=c(1,0))
<h3 id="machinelearningtopic-6">Step 5: Visualize exemplary algorithm</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

This step is optional but it greatly helps you understand what is going on when you subsequently train a more complex algorithm on your data. 
We are running and then plotting a simple algorithm, and in my opinion this is also great for presentation slides (e.g. for management who don’t want to be bothered with the more technical details). 

We choose a decision tree here, because this is the foundation of more complex algorithms such as random forests which are widely used with tabular data (3D or 4D data, e.g. image recognition, is usually done with neural networks only). 
Train a simple decision tree on our training data and plot the results:

set.seed(2022)
tree1 &lt;- party::ctree(y_train ~ .,
  data=cbind(x_train, y_train), 
  controls = ctree_control(minsplit=10, mincriterion = .9))
plot(tree1)

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik.png" data-was-processed="true">
Decision tree on our training data
How do you read this tree? Starting from the top, the most important feature that can split the data in two most dissimilar subsets (with regard to how often heart disease occurs) is “thal2”, i.e. wether the patient has a normal blood flow as opposed to a defect from a blood disorder called thalassemia. 
If the patient has a normal blood flow (value > 0 , i.e. 1), then we continue to the right branch of the tree, if not, continue to the left. 

If the blood flow is normal, then the next most important variable is “thalach”, i.e. the maximum heart rate achieved during exercise. 
You can see that if this is greater than 155 bpm, then we continue to the right where we then check for “ca1”, i.e. whether one major vessel was colored by flouroscopy. 
I’m just pretending here to understand what any of this means, but recall the bar chart above where we saw that 0 vessels colored by flouroscopy was associated with the lowest proportion of patients with coronary heart disease, whereas those with 1, 2 or 3 colored vessels were predominantly diagnosed with heart disease. 
In our tree, if ca1 == 0, i.e. <em>not </em>one major vessel colored, we continue to the left where we reach the end note 14 (second bar from the right).
What do the bars on the bottom of the chart mean? They show the proportion of patients in each bucket with (light grey) vs. without (dark grey) heart disease. 

Meaning that end node 14 (second bar from the right) is the group of patients with the lowest risk of having coronary heart disease. 
Thus, our algorithm here finds that if you:
don’t have thalassemia,
can achieve a heart rate of more than 155 bpm while exercising, and
don’t have one major vessel colored by flouroscopy,


then we predict “no heart disease” with a 98% probability (i.e. the proportion of healthy patients in the respective bucket). 
If, by contrast, you do have thalassemia, there are 1 or more colored major vessels, and your chest pain type (cp) is not “2” (2 standing for non-anginal pain), then the algorithm predicts “heart disease” with a high confidence.

You can also see that there are several end node buckets (e.g., node 5, node 15) which are quite mixed. 
Patients with these combinations of features are not well understood by the algorithm and the predictions are often wrong for these groups. 
Now, recall what we discussed about overfitting: Of course we could go into these groups and find more features that separated the healthy from the sick patients. 

In fact, if you set the values “minsplit” (minimum number of cases separated at a split) to 1, “minbucket” (minimum number of patients in an endnote) to 0, and “mincriterion” to a small value (p-value to determine if a split is significant), you get a vastly overfitted tree. 
Let’s try it out:
set.seed(2022)

tree2 &lt;- party::ctree(y_train ~ ., data=cbind(x_train, y_train), 
controls = ctree_control(minsplit=1, mincriterion = 0.01,minbucket = 0))
plot(tree2)

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-1.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-1.png" data-was-processed="true">
Overfitted tree
As you can see, just like we discussed above when we were warning against the dangers of overfitting, the algorithm has come up with very specific rules that often only apply to 2 or 3 people in the dataset. 
For instance, if the maximum heart rate achieved is above 109, but below 144, and the patient is male, older than 59 and does not suffer from thalassemia, the algorithm always predicts heart disease. 

You can see why this type of algorithm would perform poorly with new, unseen data. 
We would want to “prune” this tree of nodes that introduce classification rules that are too idiosyncratic/specific to the training data. 
But of course we don’t want to prune nodes that reflect true causal relations, i.e. the actual data-generating process (which is obviously unknown to us). 
Thus, the challenge in any machine-learning model is to get an algorithm that classifies the data with as specific rules as necessary, but without getting too specific and overfit to the training data. 
In your real-world application, of course, you don’t grow the second (overfitted) tree, but you can use the first one for presentation slides and as a benchmark for the models which we are about to train.

<h3 id="machinelearningtopic-7">Step 6: Model training</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
We now have a pretty good idea about how the data look like, which factors are associated with the outcome, and thus what to expect from a more complex algorithm. 
Let’s start with a random forest which is basically an ensemble of many trees as the one we built in the previous section. 

The trick is that each tree is grown with only a random subset of all features considered at each node, and in the end all trees take a vote how to classify a specific patient. 
Taking a subset of all features at each run ensures that the trees are less correlated, i.e. not all of them use the same rules as the example tree shown above. 

If there are a few dominant features (such as thalassemia or maximum heart rate in our data), then there will be some trees in our forest grown without these dominant features. 
These trees will be better able to classify the subgroup of our patients for whom, for whatever reasons, thalassemia and maximum heart rate are not good predictors of heart disease. 
Imagine that for some patients with a specific genetic make-up or a specific pre-existing condition (which we don’t have as information in our dataset so our algorithms cannot use it for classification), factors other than thalassemia and maximum heart rate are important to classify heart disease. 

Our first tree in the previous section would be confused about what to predict for these patients. 
In our forest, however, there are trees that understand these patients as well. 
Thus, an ensemble of learners such as a random forest most often outperforms a single learner.

We use the wrapper function <em>train()</em> from the <em>caret </em>package to train a random forest on our data. 
Note that the author of the <em>caret </em>package, Max Kuhn, has moved on to developing the <em>tidymodels</em> package. 
I haven’t adapted my workflow to the new package family yet, but for this example here, it doesn’t really matter which package you are using, <em>caret</em> still works just fine (especially since it only provides the wrapper function here which calls the <em>randomforest</em> package).

set.seed(2022)
mod &lt;- caret::train(x_train, y_train, method="rf", 
  tuneGrid = expand.grid(mtry = seq(5,ncol(x_train),by=5)),
  trControl = trainControl(method="cv", number=5, verboseIter = T))
mod

With “method = ‘rf'” we tell the train() function to use a random forest. 

The <em>tuneGrid</em> argument tells the function which values to try out for tuning parameter “mtry”. 
This is a so-called hyperparamter. 
As we just discussed, a random forest takes a subset of all features (variables) at each tree node. 

The “mtry” parameter specifies how many of the features to consider at each split. 
We have 27 features in our training dataset, so if you set mtry == 27, then it’s not a random forest any more, because all features are used and no random selection is applied. 
If you set mtry == 1, then the trees will be totally different from each other, but most ones will perform poorly because they are forced to use certain variables at the top split which are maybe not useful. 

The lower mtry, the more decorrelated the trees are, and the higher the value, the more features each tree can consider and thus the better the performance of a single tree. 
Somewhere between 1 and 27 is the optimal value, and there is no theoretical guidance as to which value should be taken. 
It depends on your data at hand, how correlated the features are, whether there are distinct sub-groups where the causal structure of the features works differently, and so on. 

The point is: You cannot determine this with “theory” or with general methodological knowledge. 
Therefore you have to “tune” these hyperparameters, i.e. try out different values and see which one works best. 

Note the difference to the classical statistical approach. 
In a vaccine effectiveness study, you wouldn’t expect to read that the author tried out different models (logit, probit, linear probability, and whatnot) and different parameters until the coefficient of interest (effectiveness of the vaccine) was maximized, this would be considered a violation of academic integrity. 
Machine learning, by contrast, in the words of deep learning pioneer Francois Chollet, “isn’t mathematics or physics, where major advances can be done with a pen and a piece of paper. 

It’s an engineering science” (<em>Deep Learning with R</em>, 2018, Manning). 
You try out different things and use what works best. 
Just remember that since you’re optimizing a prediction of Y, you cannot infer causal statements about X. 

Hyperparameter tuning is done in the train() function with the <em>tune.grid</em> parameter, where we tell the function to try out values between 5 and the number of our variables (<em>ncol(x_train)</em>).
Finally, note that in the “trainControl” function passed to train(), we specified “method = ‘cv'”. 
CV stands for “cross validation”. 

Above we stressed the importance of separating training and test datasets. 
But inside our training routine, where we try out multiple varations of the random forest algorithm with different values for the parameter “mtry”, how does the function determine which of the specifications “works best”? We don’t touch the test dataset so far. 
Which means we have to create another random split, splitting the training data into training and validation sets for the purpose of determining which algorithm works best on the training data. 

Since we set “number = 5”, the function creates a validation set of size 1/5 of x_train and takes 4/5 of the data for training. 
Now, this would mean we would lose more cases, from 211 patients in our training data we would only use 169 for the actual training. 
“Cross validation” therefore repeats this training process and changes the validation set to another fifth of the data. 

This is done 5 times in total, so that all parts of the data served as validation set once, and then the results are averaged. 
This routine thus lets you use all of your training data and still have train/validation splits in order to avoid overfitting. 
Running the code chunk above gives us the following output:

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-2.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-2.png" data-was-processed="true">
Summary of model training (random forest)
What does this mean? From the summary we can verify that we set up our dataset correctly. 
There are 27 features, 211 patients, and two outcomes (1 = heart disease, 0 = no heart disease). 

Then you see that five values were tried for the hyperparameter “mtry”. 
With each of the values, 5-fold cross validation was performed. 
If you look at the accuracy values, you can see that mtry = 10 worked best with our data. 

On average (of the five runs using cross-validation), 82.4% of the validation sets (= 42 patients during each run) were classified correctly. 
Although this accuracy was obtained with a train/validation split, we still have yet to judge the final evaluation score of the algorithm against the unseen test dataset, because all the patients in the training data were used to train the model at some point, so technically it’s not an “out-of-sample” accuracy. 
But before the final evaluation, we want to try out a few more algorithms.

With a random forest, you can obtain a feature importance plot which tells you which of the variables were most often used as the important splits at the top of the trees. 
Just run:
plot(varImp(mod), main="Feature importance of random forest model on training data")

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-3.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-3.png" data-was-processed="true">
Feature importance plot of our random forest
You can see that, unlike our single decision tree on all of the training data, where “thal2” was the most important feature before “ca0”, across an ensemble of 500 different trees, it’s actually “ca0” (= zero major vessels colored by flouroscopy, whatever that means) that ends up the most important predictor, tied with “cp0” (chest pain type 0 = asymptomatic). 
Recall that a machine-learning model tuned for prediction such as a random forest cannot be interpreted as revealing causal associations between the predictors and the outcome. 

Nevertheless, it can guide clinical practice knowing which features are the most useful for predicting heart disease. 
This best works when enriched with domain knowledge about mechanisms and causality.
Next, let’s try out a neural network, simply because many of you will probably associate machine-learning or artificial intelligence in general with artificial neural networks, or deep learning. 

In general, it is true that neural networks outperform all other machine-learning algorithms when it comes to the classification of abstract data such as images or videos. 
For a more detailed tutorial about how you can build a deep learning algorithm in R, see <a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2021/03/16/how-to-build-your-own-image-recognition-app-with-r-part-1/" target="_blank">here</a>. 
In cases with classical flat data files such as ours, on the other hand, other algorithms often work equally well or better. 

Here, let’s use a simple network with as few lines of code as necessary:
set.seed(2022)
mod2 &lt;- caret::train(x_train, y_train, method="avNNet",

preProcess = c("center", "scale", "nzv"),
tuneGrid = expand.grid(size = seq(3,21,by=3), decay=c(1e-03, 0.01, 0.1,0),bag=c(T,F)),
trControl = trainControl(method="cv", number=5, verboseIter = T),

importance=T)
mod2
Here we use the pre-processing steps of centering and scaling the data because, as noted above, neural networks are optimized more easily if the features have similar numerical ranges, instead of, say, maximum heart rate being in the range of 140-200 whereas other features having values bounded by 0 and 1. 

Near-zero variance (“nzv”) means that we disregard features where almost all patients have the same value. 
Tree-based methods such as random forests are not as sensitive to these issues. 
We have a few more tuning parameters here. 

“Size” refers to the number of nodes in the hidden layer. 
Our network has an input layer of 27 nodes (i.e. the number of features) and an output layer with one node (the prediction of 1 or 0) and in between, a hidden layer where interactions between the features and non-linear transformations can be learned. 

As with other hyperparameters, the optimal size of the hidden layer(s) depend on the data at hand, so we just try out different values. 
Decay is a regularization parameter that causes the weights of our nodes to decrease a bit after each round of updating the values after backpropagation (i.e. the opposite of what the learning rate does wich is used in other implementations of neural networks). 

What this means is, roughly speaking, we don’t want the network to learn too ambitiously with each step of adapting its parameters to the evidence, in order to avoid overfitting. 
Anyway, as you can see from the code, we have passed 7 different values for “size” to consider, 4 values for “decay”, and two for “bag” (true or false, specifying how to aggregate several networks’ predictions with various random number seeds, which is what the <em>avNNet</em> classifier does, bagging = bootstrap aggregating), so we have 7*4*2 = 56 combinations to try out. 
The result:

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-4.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-4.png" data-was-processed="true">
Output of neural network training
Thus, our best-performing model yields 85.3% accuracy, which is a slight improvement over the random forest. 
Again, we can look at a feature importance plot:

plot(varImp(mod2), main="Feature importance of neural network classifier on training data")
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-5.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-5.png" data-was-processed="true">
Feature importance plot with neural network
It’s slightly different than the plot before, but the top five features are the same, just in a different order. 

Note that with “unstable” methods such as neural networks, if you run the same code 10 times, you can end up with ten (slightly) different feature importance lists, but the general pattern of which features are important and which aren’t will be the same.
Let’s try out one last algorithm. 
The popular “(extreme) gradient boosted machines” (xgboost) work similar to a random forest, except they proceed sequentially: A first tree is grown, then more weight is put on the badly predicted samples before the next tree is grown. 

As a result, in many cases, xgboost outperforms random forests. 
Let’s see if this is the case here as well:
set.seed(2022)

mod3 &lt;- caret::train(x_train, y_train, method="xgbTree", 
tuneGrid = expand.grid(nrounds=c(50,100),max_depth=c(5,7,9),
colsample_bytree=c(0.8,1),subsample=c(0.8,1),

min_child_weight=c(1,5,10),eta=c(0.1,0.3),gamma=c(0,0.5)),
trControl = trainControl(method="cv", number=5, verboseIter = T))
mod3

plot(varImp(mod3), main="Feature importance of XGBoost model on training data")
Here we have more tuning parameters compared with the random forest; I just inserted a few values that I deemed plausible into the tuning grid, but if you want to do serious hyperparameter tuning, you can of course spend a bit more time here determining which combination of parameters works best. 
Xgboost is in general quite fast so even though we try out 2*3*2*2*3*2*2 = 288 parameter combinations, running this code should only take a minute at most even on a local machine. 

Which means that you could tune even more.
Compare the performance of the three algorithms:
results &lt;- data.frame(Model = c(mod$method,mod2$method, mod3$method),

Accuracy = c(max(mod$results$Accuracy), max(mod2$results$Accuracy), max(mod3$results$Accuracy)))
results %>% ggplot(aes(x=Model, y=Accuracy, label=paste(round(100*Accuracy,1),"%"))) +
geom_col(fill="steelblue") + theme_minimal() + geom_label() +

ggtitle("Accuracy in the training data by algorithm")
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-6.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-6.png" data-was-processed="true">
Comparison of our used algorithms during model training
The neural network actually performed slightly better than the xgboosted tree, although the values are quite similar and if you repeat the model training a couple of times, you might get different results. 

With use cases like this, I prefer to go with tree-based models such as random forests or xgboost over neural networks because with the former, I can understand better how the algorithm arrives at its predictions (see our example tree in the previous section). 
You could also, of course, visualize a neural network with all the weights obtained during training displayed next to the nodes, it’s not alchemy, but it’s less easily interpreted when you want to reconstruct how the network processes a certain patient. 
Anyways, let’s decide at this point that our neural network (“mod2”) was the best model and we want to move forward with it.

<h3 id="machinelearningtopic-8">Step 7: Model evaluation against the test data</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
We now compare our model’s prediction against the reserved test dataset. 
These are patients our algorithm has not seen before. 

We use the neural network to predict the test data, and then compare the predictions against the actual outcomes:
predictions &lt;- predict(mod2, newdata = x_test)
confusionMatrix(predictions, y_test)

Which gives us:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-7.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-7.png" data-was-processed="true">
Confusion matrix and summary statistics of our predictions on the test set
As you can see, our out-of-sample predictive accuracy was 87.9%. 

The confusion matrix tells us that 40 patients with heart disease were correctly classified, and 40 healthy patients were also correctly classified, but there were 3 patients where our model thought they had heart disease but in reality they didn’t, and, conversely, we overlooked coronary heart disease in 8 patients. 
In addition to accuracy, other metrics are often used to evaluate the goodness of a machine-learning algorithm. 
Keep in mind that our sample was balanced (47% have heart disease, 53% don’t), whereas in many other use cases, you often have a severe class imbalance (e.g., 99% of customers won’t buy, 1% do buy, or 99% of patients won’t die vs. 
1% die), so “99% accuracy” is useless to you as an indicator in these cases. 
You can resort to using sensitivity/specificity which are also given in the output (specificity = how many of the true positive cases are detected, which is a useful indicator if the positive cases are rare, and specificity = how many true negatives are correctly classified). 
Which of these metrics is more important to you depends on your case, i.e. your cost function. 
In this case, I’d say it’s better to detect all true cases who have the disease, and we can live with a few false positives, so I’d look at sensitivity rather than specificity. 
In other cases, you want to avoid many false positives (e.g., spam detection, it’s much more annoying if many of your important work e-mails disappear in the spam folder), so sensitivity is maybe more important. 

In addition to these metrics, you also often find precision (proportion of true positive predictions relative to all “positive” predictions), and recall (proportion of true positive predictions relative to all actual positives), and F1 (harmonic mean of precision and recall). 
You can get these as well with 
precision(predictions, y_test)

recall(predictions, y_test)
F_meas(predictions, y_test)
<h3 id="machinelearningtopic-9">Step 8: Model deployment</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

We don’t cover this step here in great detail, you can refer <a rel="nofollow" href="https://forloopsandpiepkicks.wordpress.com/2021/03/30/how-to-build-your-own-image-recognition-app-with-r-part-2/" target="_blank">here</a> for an example of how you can build a shinyapp which you can access from your computer or phone to send new data to your machine-learning model. 
This type of app could be used by a doctor to enter a patient’s new values and get the prediction of whether or not coronary heart disease is present (I guess a doctor would be able to figure that out without a machine-learning model with the clinical diagnostics used to get the data, but you get the idea. 
For instance, if you were to build a model that does not rely on data that you can only gather in a hospital, such as results from flouroscopy, but rather on data that come solely from standard instruments that every ambulance is carrying, such as ECG, blood pressure, etc., or maybe even recorded by the patients at home themselves, then the whole thing might make more sense. 

But again, this is just an example for demonstration purposes).
Let’s just quickly show how you would process new data. 
Imagine you have an app, or a spreadsheet, etc., where a doctor can input new data for a new patient. 

You read in the spreadsheet, or collect the input data from the app, but here for the sake of demonstration we just enter a new patient’s information like this: 
newpatient &lt;- data.frame(age=62,sex=1,cp=0,trestbps =130,chol=220, fbs=0, restecg=0, 
thalach=161, exang=0, oldpeak=0, slope=0, ca=0, thal=2)

Now unfortunately we cannot just use the preprocessing function we created earlier, because the new dataset does not have all the values for all our dummy variables (e.g., there is only cp == 0 in the new dataset and no instances of 1, 2 or 3). 
Which is why we copy the function from above but insert a bit of new code to ensure that all dummy variables are present in the new dataset. 
It’s an ugly nested for-loop but whatever works….

preprocess_new_data &lt;- function(df){
#Convert features to int like the original dataset
df[,names(df) != "oldpeak"] &lt;- purrr::map_df(df[,names(df) != "oldpeak"], as.integer)

df &lt;- df %>% mutate(restecg = recode(restecg, `2`=1L),
thal = recode(thal, `0`=2L),
ca = recode(ca, `4`=0L))

#Nominal variables - attention: we don't have all the values for the dummies in the new dataset!
existing_cols &lt;- names(x_train)[names(x_train) %in% names(df)]
new_cols &lt;- names(x_train)[!names(x_train) %in% names(df)]

df[new_cols] &lt;- 0
nomvars &lt;- c("cp", "ca", "thal", "restecg", "slope")
for (i in 1:nrow(df)){

for(j in 1:length(nomvars)){
df[i,paste0(nomvars[j],df[nomvars[j]][i])] &lt;- 1 
}

}
df &lt;- df[,names(df) %in% c(existing_cols, new_cols)]
df$hr_age &lt;- df$thalach / df$age

df$chol_age &lt;- df$chol / df$age
df$st &lt;- ifelse(df$oldpeak>0,1,0)
return(df)

}
save(mod2, x_train, preprocess_new_data, file="Heart_disease_prediction.RData")
We saved our trained model and the two other objects needed to pre-process new data. 

From now on, when in a new session (or an interactive app etc.), you just need to load the RData file and the libraries (caret, tidyverse), and you can then predict new data as follows:
predict(mod2, newdata = preprocess_new_data(newpatient))
predict(mod2, newdata = preprocess_new_data(newpatient), type="prob")

Result:
<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-8.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-8.png" data-was-processed="true">
Prediction of a new patient (binary and with probabilities)
The first command just predicts yes or no. 

For this new patient, we predict “no heart disease”. 
With the second command, we also get the probabilities to belong in each class. 
We see that the new patient has a 86% probability of being healthy and a 13.9% probability of having coronary heart disease according to our algorithm. 

Especially with new data I find it helpful to get the predicted probabilities to get a sense for how certain the algorithm is in assigning this prediction. 
<h3 id="machinelearningtopic-10">Next steps</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
After a model is deployed, you often might want to monitor its performance, maybe re-train with new training data when you have collected more real data over time, or when you have learned more things about the causal structure behind your predictions, or when there’s a new fancy algorithm which could improve accuracy compared to your current best model. 

Some final remarks: In my experience, the two steps that take up most of the time in a real-world use case are the first and the last one. 
In the toy examples used to teach machine learning (such as this one), “get data” just means read in a csv file which is readily available at some url. 
In reality, you often have to find a way to get your data from, say, an old SQL server located somewhere in a production plant, or a cloud storage (e.g. AWS S3), or worse, from various physical machines (e.g. ECG devices in a hospital). 
Thus, the most complicated part of the whole project is often to get access to the data (e.g., query an API with the <em>httr </em>package, or get credentials for a SQL server and then connect to the server with the <em>DBI </em>package), write queries to retrieve the data (e.g. via SQL code which you can write in R with, e.g., the <em>dbplyr </em>package), schedule your queries so that you regularly get the latest data (e.g., daily cronjob for your R script on a Linux server), merge the data with other relevant datasets – what are we even looking for, what do we need? – and store it somewhere were you can access it for your model training.
Similarly, in the end, you want to deploy your model which might mean setting up a pipeline where new data from the source systems (ECG devices, SQL servers in plants, IoT sensors, etc.) run through your model and the output can be accessed via some app, or is integrated into your company’s BI solution, etc. 
This can get complicated in many ways as well. 

By contrast, the whole model training is easy in comparison, especially with packages such as tidymodels, caret, keras/tensorflow, Python’s scikit-learn, or various auto-ML packages which make the whole process of pre-processing, feature selection, hyperparameter tuning etc. 
very easy. 
I’ve read somewhere that it’s the best kept secret among data scientists and machine-learning engineers that they actually just run “import scikit-learn as sklearn” or “library(caret)” and then something such as “train(x,y,model = “fancy_algorithm”) rather than hand-crafting complicated models which many people outside of data science probably think they are doing. 

<img class="lazy loaded" data-src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-10.png" src="https://forloopsandpiepkicks.files.wordpress.com/2022/02/grafik-10.png" data-was-processed="true">
Let’s hope they won’t find out
In my view, thus, the most important skill for you to bring to the table as an aspiring data scientist/machine-learning engineer isn’t so much the ability to write down tensorflow code from scratch. 
Rather, it’s the ingenuity to come up with new ideas for how to use existing data to solve business problems or scientific research questions. 
This kind of skill will hardly get automated in the near future. 

<h2>What is random forest?</h2>
Random forest is a commonly-used machine learning algorithm that combines the output of multiple decision trees to reach a single result. 
<h3>Decision trees</h3>
Since the random forest model is made up of multiple decision trees, it would be helpful to start by describing the decision tree algorithm briefly. 

Decision trees start with a basic question, such as, “Should I surf?”
From there, you can ask a series of questions to determine an answer, such as, “Is it a long period swell?” or “Is the wind blowing offshore?”. 
These questions make up the decision nodes in the tree, acting as a means to split the data. 

Each question helps an individual to arrive at a final decision, which would be denoted by the leaf node. 
Observations that fit the criteria will follow the “Yes” branch and those that don’t will follow the alternate path. 
Decision trees seek to find the best split to subset the data, and they are typically trained through the Classification and Regression Tree (CART) algorithm. 

Metrics, such as Gini impurity, information gain, or mean square error (MSE), can be used to evaluate the quality of the split. 
This decision tree is an example of a classification problem, where the class labels are "surf" and "don't surf."
While decision trees are common supervised learning algorithms, they can be prone to problems, such as bias and overfitting. 

However, when multiple decision trees form an ensemble in the random forest algorithm, they predict more accurate results, particularly when the individual trees are uncorrelated with each other.
<h3>Ensemble methods</h3>
Ensemble learning methods are made up of a set of classifiers
— e.g. decision trees
— and their predictions are aggregated to identify the most popular result. 

The most well-known ensemble methods are bagging, also known as bootstrap aggregation, and boosting. 
In 1996, Leo Breiman introduced the bagging method; in this method, a random sample of data in a training set is selected with replacement—meaning that the individual data points can be chosen more than once. 

After several data samples are generated, these models are then trained independently, and depending on the type of task—i.e. regression or classification—the average or majority of those predictions yield a more accurate estimate. 
This approach is commonly used to reduce variance within a noisy dataset.

<h3>Random forest algorithm</h3>
The random forest algorithm is an extension of the bagging method as it utilizes both bagging and feature randomness to create an uncorrelated forest of decision trees. 
Feature randomness, also known as feature bagging or the random subspace method (link resides outside ibm.com) (PDF, 121 KB), generates a random subset of features, which ensures low correlation among decision trees. 

This is a key difference between decision trees and random forests. 
While decision trees consider all the possible feature splits, random forests only select a subset of those features.
If we go back to the “should I surf?” example, the questions that I may ask to determine the prediction may not be as comprehensive as someone else’s set of questions. 

By accounting for all the potential variability in the data, we can reduce the risk of overfitting, bias, and overall variance, resulting in more precise predictions.

<h3>How it works</h3>
Random forest algorithms have three main hyperparameters, which need to be set before training. 
These include node size, the number of trees, and the number of features sampled. 
From there, the random forest classifier can be used to solve for regression or classification problems.

The random forest algorithm is made up of a collection of decision trees, and each tree in the ensemble is comprised of a data sample drawn from a training set with replacement, called the bootstrap sample. 
Of that training sample, one-third of it is set aside as test data, known as the out-of-bag (oob) sample, which we’ll come back to later. 
Another instance of randomness is then injected through feature bagging, adding more diversity to the dataset and reducing the correlation among decision trees. 

Depending on the type of problem, the determination of the prediction will vary. 
For a regression task, the individual decision trees will be averaged, and for a classification task, a majority vote—i.e. the most frequent categorical variable—will yield the predicted class. 

Finally, the oob sample is then used for cross-validation, finalizing that prediction.

<img class="lazy" data-src="https://www.ibm.com/content/dam/connectedassets-adobe-cms/worldwide-content/cdp/cf/ul/g/50/f9/ICLH_Diagram_Batch_03_27-RandomForest.component.l.ts=1679336476850.png/content/adobe-cms/us/en/topics/random-forest/jcr:content/root/table_of_contents/body/simple_narrative/image">

<h3>Benefits and challenges of random forest</h3>
There are a number of key advantages and challenges that the random forest algorithm presents when used for classification or regression problems. 

Some of them include:
<h3>Key Benefits</h3>
Reduced risk of overfitting: Decision trees run the risk of overfitting as they tend to tightly fit all the samples within training data. 

However, when there’s a robust number of decision trees in a random forest, the classifier won’t overfit the model since the averaging of uncorrelated trees lowers the overall variance and prediction error.
Provides flexibility: Since random forest can handle both regression and classification tasks with a high degree of accuracy, it is a popular method among data scientists. 
Feature bagging also makes the random forest classifier an effective tool for estimating missing values as it maintains accuracy when a portion of the data is missing.

Easy to determine feature importance: Random forest makes it easy to evaluate variable importance, or contribution, to the model. 
There are a few ways to evaluate feature importance. 
Gini importance and mean decrease in impurity (MDI) are usually used to measure how much the model’s accuracy decreases when a given variable is excluded. 

However, permutation importance, also known as mean decrease accuracy (MDA), is another importance measure. 
MDA identifies the average decrease in accuracy by randomly permutating the feature values in oob samples.
<h3>Key Challenges</h3>
Time-consuming process: Since random forest algorithms can handle large data sets, they can be provide more accurate predictions, but can be slow to process data as they are computing data for each individual decision tree.
Requires more resources: Since random forests process larger data sets, they’ll require more resources to store that data.
More complex: The prediction of a single decision tree is easier to interpret when compared to a forest of them.

Random forest applications
The random forest algorithm has been applied across a number of industries, allowing them to make better business decisions. 
Some use cases include:

Finance: It is a preferred algorithm over others as it reduces time spent on data management and pre-processing tasks. 
It can be used to evaluate customers with high credit risk, to detect fraud, and option pricing problems.
Healthcare: The random forest algorithm has applications within <a href="https://www.cs.cmu.edu/~qyj/papersA08/11-rfbook.pdf">computational biology</a> (link resides outside ibm.com) (PDF, 737 KB), allowing doctors to tackle problems such as gene expression classification, biomarker discovery, and sequence annotation. 

As a result, doctors can make estimates around drug responses to specific medications.
E-commerce: It can be used for recommendation engines for cross-sell purposes.

<h2>Understand Random Forest Algorithms With Examples</h2>
<div id="UnderstandRFtoc" class="toc"><a href="#UnderstandRFtopic-0" target="_self" onclick="jumpto(0)">What is Random Forest Algorithm?</a><br><a href="#UnderstandRFtopic-1" target="_self" onclick="jumpto(1)">Real-Life Analogy of Random Forest</a><br><a href="#UnderstandRFtopic-2" target="_self" onclick="jumpto(2)">Working of Random Forest Algorithm</a><br><a href="#UnderstandRFtopic-3" target="_self" onclick="jumpto(3)">Important Features of Random Forest</a><br><a href="#UnderstandRFtopic-4" target="_self" onclick="jumpto(4)">Difference Between DecisionTree and Random Forest</a><br><a href="#UnderstandRFtopic-5" target="_self" onclick="jumpto(5)">Important Hyperparameters in Random Forest</a><br><a href="#UnderstandRFtopic-6" target="_self" onclick="jumpto(6)">Coding in Python – Random Forest</a><br><a href="#UnderstandRFtopic-7" target="_self" onclick="jumpto(7)">Random Forest Algorithm Use Cases</a><br><a href="#UnderstandRFtopic-8" target="_self" onclick="jumpto(8)">Advantages and Disadvantages of Random Forest Algorithm</a><br><a href="#UnderstandRFtopic-9" target="_self" onclick="jumpto(9)">Conclusion</a><br><a href="#UnderstandRFtopic-10" target="_self" onclick="jumpto(10)">Frequently Asked Questions</a><br></div></center>
<h3 id="UnderstandRFtopic-0">What is Random Forest Algorithm?</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Random Forest is one of the most popular and commonly used algorithms by Data Scientists. 

Random forest is a <k>Supervised Machine Learning Algorithm</k>that is <k>used widely in Classification and Regression problems</k>. 
It builds decision trees on different samples and takes their majority vote for classification and average in case of regression.
One of the most important features of the Random Forest Algorithm is that it can handle the data set containing <k>continuous variables,</k>as in the case of regression, and <k>categorical variables,</k>as in the case of classification. 

It performs better for classification and regression tasks. 
In this tutorial, we will understand the working of random forest and implement random forest on a classification task.

<h3 id="UnderstandRFtopic-1">Real-Life Analogy of Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Let’s dive into a real-life analogy to understand this concept further. 
A student named X wants to choose a course after his 10+2, and he is confused about the choice of course based on his skill set. 

So he decides to consult various people like his cousins, teachers, parents, degree students, and working people. 
He asks them varied questions like why he should choose, job opportunities with that course, course fee, etc. 
Finally, after consulting various people about the course he decides to take the course suggested by most people.

<img class="lazy" data-src="https://cdn.analyticsvidhya.com/wp-content/uploads/2021/06/r1.png">

<h3 id="UnderstandRFtopic-2">Working of Random Forest Algorithm</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Before understanding the working of the random forest algorithm in machine learning, we must look into the ensemble learning technique. 
 <k>Ensemble </k>simplymeans combining multiple models. 
Thus a collection of models is used to make predictions rather than an individual model.

Ensemble uses two types of methods:
1. <k>Bagging</k>– It creates a different training subset from sample training data with replacement & the final output is based on majority voting. 

For example, Random Forest.
2. <k>Boosting</k>– It combines weak learners into strong learners by creating sequential models such that the final model has the highest accuracy. 

For example, ADA BOOST, XG BOOST.
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/4661536426211ba43ea612c8e1a6a1ed4550721164.png">
As mentioned earlier, Random forest works on the Bagging principle. 

Now let’sdive in and understand bagging in detail.
<h4>Bagging</h4>
Bagging, also known as <k>Bootstrap Aggregation,</k> is the ensemble technique used by random forest.Bagging chooses a random sample/random subset from the entire data set. 

Hence each model is generated from the samples (Bootstrap Samples) provided by the Original Data with replacement known as <k>row sampling</k>. 
This step of row sampling with replacement is called <k> bootstrap</k>. 
Now each model is trained independently, which generates results. 

The final output is based on majority voting after combining the results of all models. 
This step which involves combining all the results and generating output based on majority voting, is known as <k>aggregation</k>.
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/77772440px-Ensemble_Bagging66584.png">

Now let’s look at an example by breaking it down with the help of the following figure. 
Here the bootstrap sample is taken from actual data (Bootstrap sample 01, Bootstrap sample 02, and Bootstrap sample 03) with a replacement which means there is a high possibility that each sample won’t contain unique data. 
The model (Model 01, Model 02, and Model 03) obtained from this bootstrap sample is trained independently. 

Each model generates results as shown. 
Now the Happy emoji has a majority when compared to the Sad emoji. 
Thus based on majority voting final output is obtained as Happy emoji.

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/325745-Bagging-ensemble-method78495.png">
<h4>Boosting</h4>
Boosting is one of the techniques that use the concept of ensemble learning. 

A boosting algorithm combines multiple simple models (also known as weak learners or base estimators) to generate the final output. 
It is done by building a model by using weak models in series.
There are several boosting algorithms; AdaBoost was the first really successful boosting algorithm that was developed for the purpose of binary classification. 

AdaBoost is an abbreviation for Adaptive Boosting and is a prevalent boosting technique that combines multiple “weak classifiers” into a single “strong classifier.” There are Other Boosting techniques. 
For more, you can visit
4 Boosting Algorithms You Should Know – GBM, XGBoost, LightGBM & CatBoost

<h4>Steps Involved in Random Forest Algorithm</h4>
<u>Step 1</u>: In the Random forest model, a subset of data points and a subset of features is selected for constructing each decision tree. 
Simply put, n random records and m features are taken from the data set having k number of records.

<u>Step 2</u>: Individual decision trees are constructed for each sample.
<u>Step 3</u>: Each decision tree will generate an output.
<u>Step 4</u>: Final output is considered based on <k>Majority Voting or Averaging </k>for Classification and regression, respectively.

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/24015Random+Forest64097.png">
For example: consider the fruit basket as the data as shown in the figure below. 
Now n number of samples are taken from the fruit basket, and an individual decision tree is constructed for each sample. 

Each decision tree will generate an output, as shown in the figure. 
The final output is considered based on majority voting. 
In the below figure, you can see that the majority decision tree gives output as an apple when compared to a banana, so the final output is taken as an apple.

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/33019random-forest-algorithm287548.png">
<h3 id="UnderstandRFtopic-3">Important Features of Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>


 <k>Diversity: </k>Not all attributes/variables/features are considered while making an individual tree; each tree is different.

 <k>Immune to the curse of dimensionality:</k> Since each tree does not consider all the features, the feature space is reduced.

 <k>Parallelization: </k>Each tree is created independently out of different data and attributes. 

This means we can fully use the CPU to build random forests.

 <k>Train-Test split: </k>In a random forest, we don’t have to segregate the data for train and test as there will always be 30% of the data which is not seen by the decision tree.

 <k>Stability: </k>Stability arises because the result is based on majority voting/ averaging.



<h3 id="UnderstandRFtopic-4">Difference Between DecisionTree and Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Random forest is a collection of decision trees; still, there are a lot of differences in their behavior.

 <k>Decision trees Random Forest</k>1. Decision trees normally suffer from the problem of overfitting if it’s allowed to grow without any control.1. Random forests are created from subsets of data, and the final output is based on average or majority ranking; hence the problem of overfitting is taken care of.2. A single decision tree is faster in computation.2. It is comparatively slower.3. When a data set with features is taken as input by a decision tree, it will formulate some rules to make predictions.3. Random forest randomly selects observations, builds a decision tree, and takes the average result. 
It doesn’t use any set of formulas.
Thus random forests are much more successful than decision trees only if the trees are diverse and acceptable.

<h3 id="UnderstandRFtopic-5">Important Hyperparameters in Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Hyperparameters are used in random forests to either enhance the performance and predictive power of models or to make the model faster.
<h4>Hyperparameters to Increase the Predictive Power</h4>

 <k>n_estimators:</k> Number of trees the algorithm builds before averaging the predictions.
 <k>max_features:</k> Maximum number of features random forest considers splitting a node.
 <k>mini_sample_leaf:</k> Determines the minimum number of leaves required to split an internal node.

 <k>criterion:</k> How to split the node in each tree? (Entropy/Gini impurity/Log Loss)
 <k>max_leaf_nodes: </k>Maximum leaf nodes in each tree
<h4>Hyperparameters to Increase the Speed</h4>

 <k>n_jobs: </k>it tells the engine how many processors it is allowed to use. 
If the value is 1, it can use only one processor, but if the value is -1, there is no limit.
 <k>random_state: </k>controls randomness of the sample. 

The model will always produce the same results if it has a definite value of random state and has been given the same hyperparameters and training data.
 <k>oob_score:</k>OOB means out of the bag. 
It is a random forest cross-validation method. 

In this, one-third of the sample is not used to train the data; instead used to evaluate its performance. 
These samples are called out-of-bag samples.
<h3 id="UnderstandRFtopic-6">Coding in Python – Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

Now let’s implement Random Forest in scikit-learn.
<h4>1. Let’s import the libraries.</h4>

# Importing the required libraries
import pandas as pd, numpy as np
import matplotlib.pyplot as plt, seaborn as sns

%matplotlib inline
<h4>2. Import the dataset.</h4>

 <k>Python Code:</k>
<img class="lazy" data-src="https://s3-ap-south-1.amazonaws.com/av-blog-media/wp-content/uploads/2019/08/coding-window-noshow.jpg">

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/97911136435.png">

<h4>3. Putting Feature Variable to X and Target variable to y.</h4>
# Putting feature variable to X

X = df.drop('heart disease',axis=1)
# Putting response variable to y
y = df['heart disease']

<h4>4. Train-Test-Split is performed</h4>
# now lets split the data into train and test

from sklearn.model_selection import train_test_split
# Splitting the data into train and test
X_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, random_state=42)

X_train.shape, X_test.shape
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/32108232399.png">
<h4>5. Let’s import RandomForestClassifier and fit the data.</h4>
from sklearn.ensemble import RandomForestClassifier
classifier_rf = RandomForestClassifier(random_state=42, n_jobs=-1, max_depth=5,

n_estimators=100, oob_score=True)
%%time
classifier_rf.fit(X_train, y_train)

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/21858364548.png">
# checking the oob score
classifier_rf.oob_score_

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/52714423821.png">
<h4>6. Let’s do hyperparameter tuning for Random Forest using GridSearchCV and fit the data.</h4>

rf = RandomForestClassifier(random_state=42, n_jobs=-1)
params = {
'max_depth': [2,3,5,10,20],

'min_samples_leaf': [5,10,20,50,100,200],
'n_estimators': [10,25,30,50,100,200]
}

from sklearn.model_selection import GridSearchCV
# Instantiate the grid search model
grid_search = GridSearchCV(estimator=rf,

param_grid=params,
cv = 4,
n_jobs=-1, verbose=1, scoring="accuracy")

%%time
grid_search.fit(X_train, y_train)
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/62325576382.png">

grid_search.best_score_
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/90547625254.png">
rf_best = grid_search.best_estimator_
rf_best
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/64954731668.png">
From hyperparameter tuning, we can fetch the best estimator, as shown. 

The best set of parameters identified was max_depth=5, min_samples_leaf=10,n_estimators=10
<h4>7. Now, let’s visualize</h4>

from sklearn.tree import plot_tree
plt.figure(figsize=(80,40))
plot_tree(rf_best.estimators_[5], feature_names = X.columns,class_names=['Disease', "No Disease"],filled=True);

<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/8223084133.png">
from sklearn.tree import plot_tree
plt.figure(figsize=(80,40))

plot_tree(rf_best.estimators_[7], feature_names = X.columns,class_names=['Disease', "No Disease"],filled=True);
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/22097992212.png">
The trees created by estimators_[5] and estimators_[7] are different. 

Thus we can say that each tree is independent of the other.
<h4>8. Now let’s sort the data with the help of feature importance</h4>

rf_best.feature_importances_
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/758361052877.png">
imp_df = pd.DataFrame({

"Varname": X_train.columns,
"Imp": rf_best.feature_importances_
})

imp_df.sort_values(by="Imp", ascending=False)
<img class="lazy" data-src="https://av-eks-blogoptimized.s3.amazonaws.com/88318116210.png">
<h3 id="UnderstandRFtopic-7">Random Forest Algorithm Use Cases</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

This algorithm is widely used in E-commerce, banking, medicine, the stock market, etc.
For example: In the Banking industry, it can be used to find which customer will default on a loan.
<h3 id="UnderstandRFtopic-8">Advantages and Disadvantages of Random Forest Algorithm</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

<h4>Advantages</h4>
1. It can be used in classification and regression problems.
2. It solves the problem of overfittingas output is based on majority voting or averaging.
3. It performs well even if the data contains null/missing values.
4. Each decision tree created is independent of the other; thus, it shows the property of parallelization.

5. It is highly stable as the average answers given by a large number of trees are taken.
6. It maintains diversity as all the attributes are not considered while making each decision tree though it is not true in all cases.
7. It is immune to the curse of dimensionality. 
Since each tree does not consider all the attributes, feature space is reduced.
8. We don’t have to segregate data into train and test as there will always be 30% of the data, which is not seen by the decision tree made out of bootstrap.

<h4>Disadvantages</h4>
1. Random forest is highly complex compared to decision trees, where decisions can be made by following the path of the tree.
2. Training time is more than other models due to its complexity. 
Whenever it has to make a prediction, each decision tree has to generate output for the given input data.

<h3 id="UnderstandRFtopic-9">Conclusion</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Random forest is a great choice if anyone wants to build the model fast and efficiently, as one of the best things about the random forest is it can handle missing values. 
It is one of the best techniques with high performance, widely used in various industries for its efficiency. 
It can handle binary, continuous, and categorical data. 
Overall, random forest is a fast, simple, flexible, and robust model with some limitations.

 <k>Key Takeaways</k>
Random forest algorithm is an ensemble learning technique combining numerous classifiers to enhance a model’s performance.
Random Forest is a supervised machine-learning algorithm made up of decision trees.
Random Forest is used for both classification and regression problems.

<h3 id="UnderstandRFtopic-10">Frequently Asked Questions</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
 <k>Q1. How do you explain a random forest?</k> A. 

Random Forest is a supervised learning algorithm that works on the concept of bagging. 
In bagging, a group of models is trained on different subsets of the dataset, and the final output is generated by collating the outputs of all the different models. 
In the case of random forest, the base model is a decision tree.  <k>Q2. How random forest works step by step?</k> A. 
The following steps will tell you how random forest works:1. <k>Create Bootstrap Samples</k>: Construct different samples of the dataset with replacements by randomly selecting the rows and columns from the dataset. 

These are known as bootstrap samples.2. <k>Build Decision Trees</k>: Construct the decision tree on each bootstrap sample as per the hyperparameters.3. <k>Generate Final Output</k>: Combine the output of all the decision trees to generate the final output.  <k>Q3. What are the advantages of Random Forest?</k> A. 
Random Forest tends to have a low bias since it works on the concept of bagging. 
It works well even with a dataset with a large no. 

of features since it works on a subset of features. 
Moreover, it is faster to train as the trees are independent of each other, making the training process parallelizable.  <k> <k>Q4. Why do we use random forest algorithms?</k></k> A. 

Random Forest is a popular machine learning algorithm used for classification and regression tasks due to its high accuracy, robustness, feature importance, versatility, and scalability. 
Random Forest reduces overfitting by averaging multiple decision trees and is less sensitive to noise and outliers in the data. 
It provides a measure of feature importance, which can be useful for feature selection and data interpretation.  

<h2>to perform Random Forest in R</h2>
<div id="performRFtoc" class="toc"><a href="#performRFtopic-0" target="_self" onclick="jumpto(0)">Install required packages</a><br><a href="#performRFtopic-1" target="_self" onclick="jumpto(1)">Read the dataset</a><br><a href="#performRFtopic-2" target="_self" onclick="jumpto(2)">Dataset Description</a><br><a href="#performRFtopic-3" target="_self" onclick="jumpto(3)">Split the data into train and test data sets</a><br><a href="#performRFtopic-4" target="_self" onclick="jumpto(4)">Convert target variable to a factor form</a><br><a href="#performRFtopic-5" target="_self" onclick="jumpto(5)">Finding optimized value of 'm'(random variables)</a><br><a href="#performRFtopic-6" target="_self" onclick="jumpto(6)">Create a Random forest model</a><br><a href="#performRFtopic-7" target="_self" onclick="jumpto(7)">Make predictions on test data</a><br></div></center>

Supervised learning is a type of machine learning ,were the user is given a data set and he already knows what the correct output should look like, having the idea that there is a relationship between the input and the output. 

There are two types of supervised learning :
Regression : Linear Regression is a supervised learning algorithm used for continuous variables. 

Simple Linear Regression describes the relation between 2 variables, an independent variable (x) and a dependent variable (y). 
Classification : Logistic Regression is a classification type supervised learning model. 
Logistic Regression is used when the independent variable x, can be continuous or categorical variable , but the dependent variable (y) is a categorical variable. 

Decision tress : The random forest algorithm are built using the decision tress which can be regression or classification in nature. 
The decision tress builds model in the form of a tress structure. 
It splits you entire dataset into a structure of tress and makes decision on every node. 

Now, what is a random forest and why do we need it ? Random forest is a supervised learning algorithm that grows multiple decision tress and complies their results them into one. 
It is an ensemble technique made using multiple decision models. 
The ensemble technique uses multiple machine learning algorithms to obtain better predictive performance. 

Random forest selects random parameters for the decision making i.e its adds additional randomness to the model, while growing the trees. 
This leads to searching for the best feature among a random subset of feature which results in a wide diversity that generally results in a better model. 
This recipe demonstrates an example on performing Random Forest in R.

<h3 id="performRFtopic-0">Install required packages</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
install.packages("dplyr")
library("dplyr")

install.packages("caTools")    # For Logistic regression 
library(caTools)

install.packages('randomForest') # For generating random forest model
library(randomForest)

install.packages('caret')                    # 
# classification and regression training : The library caret has a function to make prediction.

library(caret)
install.packages('e1071', dependencies=TRUE)

<h3 id="performRFtopic-1">Read the dataset</h3>
A dataset on heart disease is taken (classification problem), were predictions are to be made whether a patient has heart disease or not. 
The target variable is y : 'target'. 
class 0 : patient does not have heart disease
class 1 : patient does not have heart disease

<h3 id="performRFtopic-2">Dataset Description</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
age: age in years
sex: sex (1 = male; 0 = female)
 cp: chest pain type
 Value 1: typical angina
 Value 2: atypical angina
 Value 3: non-anginal pain
 Value 4: asymptomatic

trestbps: resting blood pressure (in mm Hg on admission to the hospital)
chol: serum cholestoral in mg/dl
fbs: (fasting blood sugar > 120 mg/dl) (1 = true; 0 = false)

restecg: resting electrocardiographic results
 Value 0: normal
 Value 1: having ST-T wave abnormality (T wave inversions and/or ST elevation or depression of > 0.05 mV)
 Value 2: showing probable or definite left ventricular hypertrophy by Estes' criteria

thalach: maximum heart rate achieved
exang: exercise induced angina (1 = yes; 0 = no)
oldpeak : ST depression induced by exercise relative to rest

slope: the slope of the peak exercise ST segment
ca: number of major vessels (0-3) colored by flourosopy
thal: 3 = normal; 6 = fixed defect; 7 = reversable defect

target: diagnosis of heart disease (angiographic disease status)

 Value 0: &lt; 50% diameter narrowing
 Value 1: > 50% diameter narrowing

data = read.csv("http://storage.googleapis.com/dimensionless/ML_with_Python/Chapter%205/heart.csv")

print(head(data))
dim(data) # returns the number of rows and columns in the dataset 
summary(data)  # summary() function generates the statistical summary of the data
<h3 id="performRFtopic-3">Split the data into train and test data sets</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
The training data is used for building a model, while the testing data is used for making predictions. 

This means after fitting a model on the training data set, finding of the errors and minimizing those error, the model is used for making predictions on the unseen data which is the test data.

split &lt;- sample.split(data, SplitRatio = 0.8) 

split 

The split method splits the data into train and test datasets with a ratio of 0.8 This means 80% of our dataset is passed in the training dataset and 20% in the testing dataset.
data_train &lt;- subset(data, split == "TRUE") 
data_test &lt;- subset(data, split == "FALSE") 
The train dataset gets all the data points after split which are 'TRUE' and similarly the test dataset gets all the data points which are 'FALSE'.
dim(data_train) # dimension/shape of train dataset
head(data_train)
dim(data_test)  # dimension/shape of test dataset

head(data_test)

<h3 id="performRFtopic-4">Convert target variable to a factor form</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Since are target variable is a yes/no type variable and the rest are numeric type variables, we convert target variable to a factor form in order to maintain the consistency

data$target &lt;- as.factor(data$target)    

data_train$target &lt;- as.factor(data_train$target)

<h3 id="performRFtopic-5">Finding optimized value of 'm'(random variables)</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

tune RF returns the best optimized value of random varaible is 3 corresponding to a OOB of 0% (OOB - prediction error)

bestmtry &lt;- tuneRF(data_train,data_train$target,stepFactor = 1.2, improve = 0.01, trace=T, plot= T) 
<h3 id="performRFtopic-6">Create a Random forest model</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
model &lt;- randomForest(target~.,data= data_train)
model                        
The model summary suggests that, the type of random forest is classification , and 500 random forest trees were created and at every node, the node splits into 3 child nodes . 
The confusion matrix suggests that , TP - 115 patients were correctly identified for having a heart disease TN - 81 patients were correctly identifies for not having a heart disease FP - 27 patients were falsely identifies for having a heart disease when infact they did not have a heart disease FN - 14 patients were falsely identifies for not having a heart disease when infact they did have a heart disease
importance(model) # returns the importance of the variables : most siginificant - cp followed by thalach and so on......
varImpPlot(model) # visualizing the importance of variables of the model.
<h3 id="performRFtopic-7">Make predictions on test data</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
After the model is created and fitted, this model is used for making predictions on the unseen data values i.e the test dataset.
pred_test &lt;- predict(model, newdata = data_test, type= "class")
pred_test
confusionMatrix(table(pred_test,data_test$target)) # The prediction to compute the confusion matrix and see the accuracy score 
The confusion matrix shows the clear picture of the test data The accuracy is 83.33% which is pretty good.
{"mode":"full",
"isActive":false}

<h2>summary notes for randomForest</h2>
install.packages("dplyr")
library("dplyr")

install.packages("caTools")    # For Logistic regression 
library(caTools)

install.packages('randomForest')
library(randomForest)

Split the data into train and test data sets
split <- sample.split(data, SplitRatio = 0.8) 

data_train <- subset(data, split == "TRUE") 
data_test <- subset(data, split == "FALSE") 

Convert target variable to a factor form
Since target variable is a yes/no type variable and the rest are numeric type variables, we convert target variable to a factor form in order to maintain the consistency

data$target <- as.factor(data$target)    
data_train$target <- as.factor(data_train$target)

Create a Random forest model
model <- randomForest(target~., data= data_train)

importance(model) # returns the importance of the variables
varImpPlot(model) # visualizing the importance of variables

Make predictions on test data
pred_test <- predict(model, newdata = data_test, type= "class")
confusionMatrix(table(pred_test,data_test$target)) # compute the confusion matrix and see the accuracy score

Random Forest with Key Predictors
The process of using randomForest package to build an RF model is the same as the decision tree package rpart. 

Note also if a dependent (response) variable is a factor, classification is assumed, otherwise, regression is assumed. 

So to uses randomForest, we need to convert the dependent variable into a factor.
# convert variables into factor
# convert other attributes which really are categorical data but in form of numbers

train$Group_size <- as.factor(train$Group_size)
sapply(train, class) #confirm types



<h2>Random Forest prediction model in R</h2>

<div id="predictionmodeltoc" class="toc"><a href="#predictionmodeltopic-0" target="_self" onclick="jumpto(0)">Random Forest</a><br><a href="#predictionmodeltopic-1" target="_self" onclick="jumpto(1)">Importing the dataset</a><br><a href="#predictionmodeltopic-2" target="_self" onclick="jumpto(2)">Encoding the target feature, catagorical variable, as factor</a><br><a href="#predictionmodeltopic-3" target="_self" onclick="jumpto(3)">Splitting the dataset into the Training set and Test set</a><br><a href="#predictionmodeltopic-4" target="_self" onclick="jumpto(4)">Feature Scaling</a><br><a href="#predictionmodeltopic-5" target="_self" onclick="jumpto(5)">Fitting Decision Tree to the Training set</a><br><a href="#predictionmodeltopic-6" target="_self" onclick="jumpto(6)">Predict the Test set results - Random Forest</a><br><a href="#predictionmodeltopic-7" target="_self" onclick="jumpto(7)">Making the Confusion Matrix - Decision Tree</a><br><a href="#predictionmodeltopic-8" target="_self" onclick="jumpto(8)">Visualising the Training set results - Decision Tree</a><br><a href="#predictionmodeltopic-9" target="_self" onclick="jumpto(9)">Visualising the Test set results - Decision Tree</a><br><a href="#predictionmodeltopic-10" target="_self" onclick="jumpto(10)">Added bonus let’s visualize the Decsion Trees</a><br></div></center>
<h3 id="predictionmodeltopic-0">Random Forest</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
Intuition Lecture 126 <a href="https://www.udemy.com/machinelearning/learn/lecture/5714412">https://www.udemy.com/machinelearning/learn/lecture/5714412</a>

Lecutre 129 <a href="https://www.udemy.com/machinelearning/learn/lecture/5771094">https://www.udemy.com/machinelearning/learn/lecture/5771094</a>

Decision tree algorithms are about splitting the data into classifications to then have an algorithm that will predict where new points of data will land. 
Those classifications are based on values of the independent and dependent variables.

Random forests are about having multiple trees, a forest of trees. 
Those trees can all be of the same type or algorithm or the forest can be made up of a mixture of tree types (algorithms). 
There are some very interesting further metaphorical thoughts that describe how the forest acts (decides).

Again as with Decision Trees the Random Forest is not based on euclidian distances but rather classifications.
Check Working directory getwd() to always know where you are working.
<h3 id="predictionmodeltopic-1">Importing the dataset</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

we are after the age and salary and the y/n purchased so in R that’s columns 3-5
dataset = read.csv('Social_Network_Ads.csv')
dataset = dataset[3:5]

Have a look at data
summary(dataset)
##       Age        EstimatedSalary    Purchased     
##  Min. :18.00   Min. : 15000   Min. :0.0000  
##  1st Qu.:29.75   1st Qu.: 43000   1st Qu.:0.0000  
##  Median :37.00   Median : 70000   Median :0.0000  
##  Mean   :37.66   Mean   : 69742   Mean   :0.3575  
##  3rd Qu.:46.00   3rd Qu.: 88000   3rd Qu.:1.0000  
##  Max. :60.00   Max. :150000   Max. :1.0000

head(dataset)
##   Age EstimatedSalary Purchased
## 1  19           19000         0
## 2  35           20000         0
## 3  26           43000         0
## 4  27           57000         0
## 5  19           76000         0
## 6  27           58000         0
<h3 id="predictionmodeltopic-2">Encoding the target feature, catagorical variable, as factor</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

We do this remember because the model we are using doesn’t do this for us.
dataset$Purchased = factor(dataset$Purchased, levels = c(0, 1))
Let’s look again

summary(dataset)
##       Age        EstimatedSalary  Purchased
##  Min. :18.00   Min. : 15000   0:257    
##  1st Qu.:29.75   1st Qu.: 43000   1:143    
##  Median :37.00   Median : 70000            
##  Mean   :37.66   Mean   : 69742            
##  3rd Qu.:46.00   3rd Qu.: 88000            
##  Max. :60.00   Max. :150000

<h3 id="predictionmodeltopic-3">Splitting the dataset into the Training set and Test set</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
General rule of thumb is 75% for split ratio; 75% train, 25% test
# install.packages('caTools')

library(caTools)
set.seed(123)
split = sample.split(dataset$Purchased, SplitRatio = 0.75)

training_set = subset(dataset, split == TRUE)
test_set = subset(dataset, split == FALSE)
<h3 id="predictionmodeltopic-4">Feature Scaling</h3>
Feature Scaling - for classification it’s better to do feature scalling additionally we have variables where the units are not the same. 
For decision trees we don’t need to do this because the model is not based on euclidian distances, however it will make the graphing faster.
training_set[-3] = scale(training_set[-3])
test_set[-3] = scale(test_set[-3])

Let’s have a look.
head(training_set)

##           Age EstimatedSalary Purchased
## 1  -1.7655475      -1.4733414         0
## 3  -1.0962966      -0.7883761         0
## 6  -1.0006894      -0.3602727         0
## 7  -1.0006894       0.3817730         0
## 8  -0.5226531       2.2654277         1
## 10 -0.2358313      -0.1604912         0
<h3 id="predictionmodeltopic-5">Fitting Decision Tree to the Training set</h3>
Things are a little different here, we don’t need formula, and other features we just need x and y. 

x will be the independent variables (hence the datase -3 removing the column we don’t need), y is the dependent variable.
# install.packages('randomForest')
library(randomForest)
## randomForest 4.6-14
## Type rfNews() to see new features/changes/bug fixes.
classifier = randomForest(x = training_set[-3],
  y = training_set$Purchased,
  ntree = 500, random_state = 0)
<h3 id="predictionmodeltopic-6">Predict the Test set results - Random Forest</h3>
Because of the slight variation in structure of the decision tree we need to add the type = class.
y_pred = predict(classifier, newdata = test_set[-3])

Let’s have a look
y_pred<i style="font-size:10px;">
##   2   4   5   9  12  18  19  20  22  29  32  34  35  38  45  46  48  52 
##   0   0   0   0   0   0   1   1   0   0   1   0   0   0   0   0   0   0 
##  66  69  74  75  82  84  85  86  87  89 103 104 107 108 109 117 124 126 
##   0   0   1   0   0   1   0   1   0   0   1   1   0   0   0   0   0   0 
## 127 131 134 139 148 154 156 159 162 163 170 175 176 193 199 200 208 213 
##   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   1   1 
## 224 226 228 229 230 234 236 237 239 241 255 264 265 266 273 274 281 286 
##   1   0   1   0   0   1   0   0   1   1   1   0   1   1   1   1   1   1 
## 292 299 302 305 307 310 316 324 326 332 339 341 343 347 353 363 364 367 
##   1   0   0   0   1   0   0   1   0   1   0   1   0   1   1   0   0   1 
## 368 369 372 373 380 383 389 392 395 400 
##   1   0   1   0   1   1   1   1   0   1 
## Levels: 0 1</i>
<h3 id="predictionmodeltopic-7">Making the Confusion Matrix - Decision Tree</h3> <a href="#top" target="_self"><b>⇧</b></a><br>

Now we have the normal CM because we added the class
cm = table(test_set[, 3], y_pred)
cm

##    y_pred
##      0  1
##   0 56  8

##   1  7 29
<img class="lazy" data-src="data:image/png;base64,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BERABERABERABERABETAYju2Lm2AIRFJU20anNWOCIiACIiACIiACIiACIiACIiACIiACIhAexCIbVnxRoN84xGa0sicpgEU7YiACIiACIiACIiACIiACIiACIiACIhAOxOI7NU0Tu2MWNmLgAiIgAiIgAiIgAiIgAiIgAiIgAiIQMsEItBo5Ca4ZU6KIQIiIAIiIAIiIAIiIAIiIAIiIAIiIALtSkAOaNoVrzIXAREQAREQAREQAREQAREQAREQAREQgewISKTJjpNiiYAIiIAIiIAIiIAIiIAIiIAIiIAIiEC7EpBI0654lbkIiIAIiIAIiIAIiIAIiIAIiIAIiIAIZEdAIk12nBRLBERABERABERABERABERABERABERABNqVgESadsWrzEVABERABERABERABERABERABERABEQgOwISabLjpFgiIAIiIAIiIAIiIAIiIAIiIAIiIAIi0K4EJNK0K15lLgIiIAIiIAIiIAIiIAIiIAIiIAIiIALZEZBIkx0nxRIBERABERABERABERABERABERABERCBdiUgkaZd8SpzERABERABERABERABERABERABERABEciOgESa7DgplgiIgAiIgAiIgAiIgAiIgAiIgAiIgAi0KwGJNO2KV5mLgAiIgAiIgAiIgAiIgAiIgAiIgAiIQHYEJNJkx0mxREAEREAEREAEREAEREAEREAEREAERKBdCUikaVe8ylwEREAEREAEREAEREAEREAEREAEREAEsiMgkSY7ToolAiIgAiIgAiIgAiIgAiIgAiIgAiIgAu1KQCJNu+JV5iIgAiIgAiIgAiIgAiIgAiIgAiIgAiKQHQGJNNlxUiwREAEREAEREAEREAEREAEREAEREAERaFcCEmnaFa8yFwEREAEREAEREAEREAEREAEREAEREIHsCEikyY6TYomACIiACIiACIiACIiACIiACIiACIhAuxKQSNOueJW5CIiACIiACIiACIiACIiACIiACIiACGRHQCJNdpwUSwREoIMJJNLK4376sbQo2hUBERABERABERABERABERCB/ZpAbL+uvSovAiLQLQnUxuvs8T/+0dauXQtlJmHxeNziWCewVhABERCBziRAsbi2psaGDBliRxx5pB027TCL5ek3r868JipbBERABERABLoTAYk03elqqi0i0E0IPPjgQzb7ndmWh45PIinS+HU3aaKaIQIisB8TiMVitnrNGlu8ZIkd+r1DrS5iFo1IqNmPL6mqLgIiIAIiIAJdhoBEmi5zKVQRERABT2D5iuVWXVVledGoRbHU1dW5U5EIekIKIiACItCJBCgY19bWOgF5z549VgDBhoF2fnxC6SlFGgoiIAIiIAIiIAJtJSCRpq3klE4ERKDdCHAogUGQYWdoypQp1q9fP+yq69NuwJWxCIhAqwg899xzwfBLDXNqFTdFFgEREAEREAERaJmARJqWGSmGCIhAJxLo06eP9e7du16kcd6D5UK4Ey+JihYBEUgjoCdSGhDtioAIiIAIiIAItJmARJo2o1NCERCBjiCQBwuasBUN3Ad3RLEqQwREQARaRYDPJjytWpVGkUVABERABERABEQgnYC83KUT0b4IiECXIcDhTqWlpc4vTZeplCoiAiIgAiIgAiIgAiIgAiIgAu1EQJY07QRW2YqACOSKQMNfpsNWNbkqQfmIgAiIgAiIgAiIgAiIgAiIQFcgIEuarnAVVAcREAEREAEREAEREAEREAEREAEREIEeT0AiTY+/BQRABERABERABESgNQQ4FJMz0CmIgAiIgAiIgAiIQK4JSKTJNVHlJwIiIAIiIAIiIAIiIAIiIAIiIAIiIAJtICCRpg3QlEQEREAEREAEREAEREAEREAEREAEREAEck1AIk2uiSo/ERABERABERABERABERABERABERABEWgDAYk0bYCmJCIgAiIgAiIgAiIgAiIgAiIgAiIgAiKQawISaXJNVPmJgAiIgAiIgAiIgAiIgAiIgAiIgAiIQBsISKRpAzQlEQEREAEREAEREAEREAEREAEREAEREIFcE5BIk2uiyk8EREAEREAEREAEREAEREAEREAEREAE2kBAIk0boCmJCIiACHQZAokuUxNVRAR6PIFIjycgACIgAiIgAiIgAvtKQCLNvhJUehEQARHoCAIJqDEZBJlEpoMdUR+VIQIiIAIiIAIiIAIiIAIikHMCEmlyjlQZioAIiEDuCeTn51s8EXcZRyIRKykpsbq6utwXpBxFQAREQAREQAREQAREQAQ6jUCs00pWwSIgAiIgAlkTqKmttby8PJs+fboddNBBsKqBWQ3EmvKycnv++eesLh4IOFlnqIgiIAIiIAIiIAIiIAIiIAJdjoAsabrcJVGFREAERKAxgVg0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vFWaCIiACIiACIiACIiACIiACIiACIiACGQkIJEmIxYdFAEREAEREAEREAEREAEREAEREAEREIGOJSCRpmN5qzQREAEREAEREAEREAEREAEREAEREAERyEhAjoMzYtFBERCBTiWAqYLysHDGIMxtZBFNHdSqy+FnXGpVIkUWAREQAREQAREQAREQARHodAISaTr9EqgCItBzCHitJdJCk6OQZvLcpNQQa5LbkQTlmu4TAgEq+/ak2p7aoIgFkqF95hZJcks/nn1JiikCItAygeRTLO3713I6xRABERABERABERCB5glIpGmej86KgAh0AgF2f7yQQ9Eh2O9eIg1FlNb071LiC1IlIFgpiIAIdCYBfQc7k77KFgEREAEREIHuTEAiTXe+umqbCHQnAlQ0enC/KJFojaTTnS682iICIiACIiACIiACIiACPYeARJqec63VUhHY7wjQt8o7s2dbdU2txVF7GZDsd5ewC1TYK3uZVL564SsRr9/uApVWFbowAdiytc4Mrgu3RVUTAREQAREQARHoegQk0nS9a6IaiUCPJxBJYOI59IOg0diGDRsslp9vdVBpXOeox9MRgNYQ4L0Uh+dpCnx0QE1vR0Fwsl8qK4k0KRTayIJAFA+ndOs2LwdmkVxRREAEREAEREAERKBJAhJpmkSjEyIgAp1F4IRZ77ennngaIk2eRdnzQX86L9nR7qw6qdz9lQAEmry4xbFE4hHLj3uRJtqgQXnuRmtwSDsikJFAPB6HaIz7CULN8AMHUE+2mtpay4/WQQSsghLYJ2M6HRQBERABERABERCBbAhE8EsQ3y8UREAERKBLEdi8frPVoePDQCsIWtFouFOXukRdvzLuhsmzmljEaiDyRSHSFNIki91qmtWEgqYtD8HQZrMEeK9wycvLs5LSmJX26oP9fKShSFOLpbDZ9DopAiIgAiIgAiIgAs0RkEjTHB2dEwER6HgCyb5zog4dHnSEUgGdavSxFUSgFQRww9TlWQI2o7ytuLArzY1EhGJNEHhb8ZxuryQQrZol4O4l9/sWnkkQAmlVkx+LYSCd7qBmwemkCIiACIiACIhAVgQ03CkrTIokAiLQUQT2VtXY5j0JdHfqOzyBBQ2GrHRUJVRONyEAawdYOBRH49a/b9QqKs22lSdgAUELLXa1FURg3wgUQTkuwDCn3n0h0bgRdNHQk2vf8lZqERABERABERCBnklAIk3PvO5qtQh0SQJ1qNX6bXvs7scWwKzB+w5JdqcDX8Jdst6qVFciELKJgc5XVx21KQfG7bMXHGvPz1tjf3puvRWWpIs0gSDYltG/9dZeGI6Xhe5THz87Zs3VqbV5ZVeiYrWGQP+ybTZ+WMw+/alzIPvBH42TaOqfXa3JS3FFQAREQAREQAREgAQk0ug+EAER6HwCyc5tJUxl9kT7W1Udf5Ju2NFpuNf5VVYNuh4BzLfjKkU7LAbYzFgsstvyMYU73NJYvDZmRXkY8FSHmGGfNEiWgLlWc4II83PWXeEheK4MnvEheSMnV/5oeJ065aoY1DN8Pn07kWjafsznlale6fkE+z5F5rM8yhp5fk3H4pkemBea7PgkL1siErNdBQOtMm8XeNAXDQfT6UnFu0NBBERABERABESg7QQk0rSdnVKKgAjkigD7e+j41Hf7nJvgVO7sT9efSx3Whgg0IJASWXwnGncN//nA835paPbSskDDPFxu8fr8gnyTN6crMyg4TcfxxTdcM1kWpjfZ5JW5Xg2L4152eeWyXt0sr+Sl9mTjSb80fl9rERABERABERABEcgFAYk0uaCoPERABERABLoUASeAQDPJNCQoEEfqxZZMcZpqTGOhg4U0Fbv5443zaj5+c2eVV3N0Gp/LJa/GueuICIiACIiACIiACLSdgOxy285OKUVABERABPYjAt6Kxq/3o6qrql2agFfp6oW/Ll1dVU4EREAEREAERKBLE5BI06UvjyonAiIgAiIgAiIgAiIgAiIgAiIgAiLQUwhIpOkpV1rtFAEREAEREAERyDEBbz3jrWlynL2yEwEREAEREAER6HEEJNL0uEuuBouACIiACIiACOSOgBdovGCTu5yVU8cT4FXUlex47ipRBERABESgnoBEmnoW2hIBERABERABERABEWgDgVpMF18HeYMLJ47PVuiowyxZLm0yfXVtTRtK3/ckrK+f8L6putfG44jT1Nl9r0M2ObB0MlYQAREQARHovgQ0u1P3vbZqmQjsdwT879H7XcVVYREQARHoAQRaElAKYvmtFjGimGqruq7O6rDkIz2Xzgj8+8OFAkgUW5XVVQ2qwVng8vLyLIZ/7R28BJPpb2JVTTVqh3/5+eZ/aWX8THHbu57KXwREQAREoH0I+Od7++SuXEVABESgNQTwlokf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EsVQmEXo1HsLG86M9J/f/a4tW7bMzv/weda3b1/4Sim2saNG2w033GD9MRPUP/7xjwZImJYCkM+DJ3/729/atMOm2ftPfL/16dvHBmGY1KWXXGq333679YVYQcHjKggInBL8+eefh/hzhh2AoTl9SnvZ5AkT7W9PPOEEHIoa1Rji07qAAUfJIT4shzYkVVVV9rennrSrr77aJh9yiB2L4UkMTz/ztN3+ndvtvvvus5tuvNEmYphQXwyz4lCraRgu9L//8z923nnn2Ze+9CXbsXsXcorY8hUrrA7WK6dBwOnbtx+sckqdFcxTTz5lvXr3cqISh4D5wOFdjOePccgY201mPrC+rCenDT/vwx+238BnzjZYL3mmXG+C1dFvfvMbuwk+bPKQP0t49bXX7OWX/m0PQwC75gtftKFDh1ovMBw+dJhdAsueW+Ak+Sc/+S/btWcP6pUupfnStRYBERABEcgVgfone65yVD4iIAIiIAIiIAIiIALdkEDExowb6yw0aKURXvr37++GFHH4EYUCihRjR49x1i70NcOhOZVVe+0FiCkcslQBvzFePAhAJRoIDjzGITtz33nHfvLTe2Bhss45seWLawGmms6HaLFnT5n985//tE996lNu2I+XNHy+rMPlGE7E4UGcPrtVAZldfNFFzhdMBOJHJJpnfXr3duLHwIED7Pe/+72rB+vzv//7vxjKNMI+jpmf6MQ3HKKwvCkpKrabb7rZNmPa7r/+9a/u9NFHHw3TobjdBSfECxcttJrqaieYxNA2L8SELWm8t55AVqm3WuK05T7QIoYM2P6rICRxTd81ngvPfAuzQJ108sl22imnuuM89y8wrIP109kf+EDK0THFGCfIwEro+uuvxzXbaY//8XF3bZFEQQREQAREoB0JyCdNO8JV1iIgAiIgAp1JgLOf1HdPOrMmKlsEugUBfJ1GjRoFfzCXNWqOF0b8CTrYnTdvnt1777325JNPwuomCiEgbps2bkpZqPi4wZqOgxvmwiFCf3jscfvof1xgt952q514/Al2AyxVZsDPCq1GKNy8t2WL/RQOfB9//HErhw8VikHhUA3hgkLGu3A+PDrDdNnhuJYM64AAAEAASURBVOnbHzz3XBs7NnCsy3OHHXaYs8yh4+L+ffpaLWaRoiULLVZuvfVWi2H6a7Yg01Nn6LChdiGm7qYVzkUQf4YP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SnejqCy0eqFfmQgsYuhUeO6mtE2/4GsWGjfdyk/+uA066VtOoKFQs2Bzne177RUWnT7DojNnWGzPE9z02/6Qq6KktSsCIiACIiACIiACIiACIiACIiACIlBiBCTSlNgNKS4OhRrO+FSHKbkXbq630Qfv6/mWySbhl2YB/NHAXw0iUMhZ+95iRM5ZsAyzQx33MVvekHTJuTQw0Ek3u5iu9kVABERABERABERABERABERABESgdAio314696LVkmTgayaLhdYy9UG4ECqvwOxOmK1pdcpSsx+DpQ18z8DaZnv4p1nw5wctEE5jmBOm4h5c7qbfplNhZ02DdVecBLdaGB0UAREQAREQAREQAREQAREQAREQARHoMQISaXoM7dYnTB8y9ElD58EUazK5rIUiYculMZvTis22MVXvBJo4rGjKw0HbuGARHAV7IRCNuBmdNNwpD0QrERABERABERABERABERABERABEShxAhJpSvgGecOUvOFOvFFB2MKkMYNTIGIWGl5hlZGxloCvmnoMharBrE6TDzocQ6EiEGog5CTTbigUtB0FERABERABERABERABERABERABERCBPkBAIk3+JpWSlkFxhgsDLWHodyaGIU0jQmELbNpg2RCm5d6h2qq+/DVbl6q0tzbVWm6HvWzfr37BcpiOm1dnN9Y5PzUcKtVddSsUfHLIg+n6C8uqIALFBDizGBevpfhnm1pk05Z/TmsREAEREAEREAEREAEREAERGLgE4OREoVBo8MWRtqh0dL6t6zp73E/f77xymBNFl8pwyKZW5uzdO35nu3ztGzgWsfAnTrSdjj7cpiRrLFweg3ITtwz90dSZNdxxpw2PhvPDpfzUOluK5vEcH4g/1H/cdn7tx3Jl3ros/KS07mcEsrmMq1HAqTVe5WgRFoSD6wCXQuWvn9Vd1REBEej/BPhsc8+3/l9V1VAEREAEREAERKCXCMiSppdAb0k2FD9i8DfDEMMMTlOrymzOLb+ytbPfgJOatEVxnOJMZMhIy8YGc5CThRrWW81v77H1i590goq7WB8iIAIiIAIiIAIiIAIiIAIiIAIiIAIlT0AiTYneIgo0nI2JBggZWKlwyNMwWMbsWl1h//z8/7MEhJpcImm5DIY2ZVIWrdtomVUbbPNv7rT37v0R4vN6BREQAREQAREQAREQAREQAREQAREQgb5C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3zPed8SzIfPq2fStadoqXQIqmQiIgAiIgAiIgAiIgAiIQF8hUNz/7ivlLqFyspPWtLjhD9gv/tf5AjelVZhu03bnU2q6pq00u5KW4opA3yQQDCeNbmLfWbjRXnp+vmUbAnbc8YfZiJFDLJlKOisauCuGvxkMTYS/mbLyMiuHSFM8hMH7Tnvfqr5JQqUWAREQAREQAREQAREQAREodQIyiij1O6TyiYAIbBUBTJpta2pzdsVVv7Fcfdp23m6knXLqMbZp01pMoZ2AwRmt1zwJhk6CuVCsafK+tFXZ62IREAEREAEREAEREAEREAER6DQBiTSdRqWIIiACXSHQ0cA9Py3aefVkaMBsTr+5+XEMa6Lj67R98dxPQpNpsHSmjqObPIfBEGloOcOpdHksP8KpJ4ultEVABERABERABERABERABESgBQGJNC2Q6IAIiEDfJ+BZx9DJ9Yuvr7VZz78OR981dvppB9qk7YZZbW0NrGUwcxn81AQDQQsFQhaJRZ0PGld3p9K0ptb0tKTU98mrBiIgAiIgAiIgAiIgAiIgAltOQD5ptpydrhQBEWiHAOWMziztJLHFpzgLE2cfW7c5Z1f+6k64Cd5k228XtE+fdhiOw4omCS80VHAQLxwMww9NucXLyiDcQKzBcKcAhJuAG/Lk+RTe4oLoQhEQAREQAREQAREQAREQARHoAgFZ0nQBlqKKgAiUPgHa0GCEk2FSJ7v9zw/Z5s1rrCKWtXPPOstyqSwEGsg32Swsa7wQCUcsBmEmFA4Zp90OhijQ0EdNx/Oj5ZPQSgREQAREQAREQAREQAREQAS6hYDfT+mWxJSICIiACGxLAlnM45REARog0PztuYX2p0dmWS6zwc485WjbbafplqxNWjbpDYXi1NpB+KGJumFOEWdFQ4fBPK5BTdvyLipvERABERABERABERABERi4BGRJM3DvvWouAv2SANzMYEhTzn57+30WLKu0qkCNfeL4IyyRqLcUptzOYDYn+qPhsCZa0YQwxImiDB0H83gor9BQylEQAREQAREQAREQAREQAREQgd4kIEua3qStvERABHqUQMYiBncz9tOr77eNq2ptBCxjrvjW+RjmVGP1dZssnYV8A2c0FGDCGNoUDoch1kScYBOCOgONRkEEREAEREAEREAEREAEREAEthkBiTTbDL0yFgER6FYCUF5SWF57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">
A caption

<h3 id="predictionmodeltopic-8">Visualising the Training set results - Decision Tree</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
library(ElemStatLearn)
# declare set as the training set

set = training_set
# this section creates the background region red/green. 
It does that by the 'by' which you can think of as the steps in python, so each 0.01 is interpreted as 0 or 1 and is either green or red. 

The -1 and +1 give us the space around the edges so the dots are not jammed. 
Another way to think of the 'by' as is as the resolution of the graphing of the background
X1 = seq(min(set[, 1]) - 1, max(set[, 1]) + 1, by = 0.01)

X2 = seq(min(set[, 2]) - 1, max(set[, 2]) + 1, by = 0.01)
grid_set = expand.grid(X1, X2)
# just giving a name to the X and Y 

colnames(grid_set) = c('Age', 'EstimatedSalary')
# this is the MAGIC of the background coloring
# here we use the classifier to predict the result of each of each of the pixel bits noted above. 

NOTE we need class here because we have a y_grid is a matrix!
y_grid = predict(classifier, newdata = grid_set, type = 'class')
# that's the end of the background

# now we plat the actual data 
plot(set[, -3],
main = 'Random Forest classification (Training set)',

xlab = 'Age', ylab = 'Estimated Salary',
xlim = range(X1), ylim = range(X2)) # this bit creates the limits to the values plotted this is also a part of the MAGIC as it creates the line between green and red
contour(X1, X2, matrix(as.numeric(y_grid), length(X1), length(X2)), add = TRUE)

# here we run through all the y_pred data and use ifelse to color the dots
# note the dots are the real data, the background is the pixel by pixel determination of y/n
# graph the dots on top of the background give you the image

points(grid_set, pch = '.', col = ifelse(y_grid == 1, 'springgreen3', 'tomato'))
points(set, pch = 21, bg = ifelse(set[, 3] == 1, 'green4', 'red3'))
<img class="lazy" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVACAYAAACp1UVbAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0J3HXVvDjwlXoVb6lIaUCURg2UBjQZQ5FEN6SUmWsKVwM+IUNKwzVcpOtKmSq5oShFQkmSDFGiUSXNs+r892//7eeeYZ/nOc9zzn7ec/b+7s/n7Zyz9tprr/Vd++zndH5nrbVYK9uSjQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQmXuBBE98CDSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBXEAA2IVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmggIANekIzWDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAsCuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNREQAC4Jh2pGQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAAdg0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgJgICwDXpSM0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQICAALBrgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAjUREACuSUdqBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBASAXQMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoiYAAcE06UjMIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAgAOwaIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQE0EBIBr0pGaQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQFg1wABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqIiAAXJOO1AwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgIALsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBMBAeCadKRmECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAQADYNUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCAgA16QjNYMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQICwK4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1ERAALgmHakZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQEAB2DRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAmAgLANelIzSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgIAAsGuAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECNREQAK5JR2oGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEBIBdAwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiJgABwTTpSMwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQICAA7BogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBATQQEgGvSkZpBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAWDXAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGoiIABck47UDAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAgAuwYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQEwEB4Jp0pGYQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBAANg1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoICADXpCM1gwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgLArgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUREAAuCYdqRkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQAHYNECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoCYCAsA16UjNIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgACwa4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1ERAArklHagYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQEgF0DBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqImAAHBNOlIzCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIADsGiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBNBASAa9KRmkGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEBYNcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEaiIgAFyTjtQMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQICAC7BggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFATAQHgmnSkZhAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAA2DVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmggIANekIzWDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAsCuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNREQAC4Jh2pGQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAAdg0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgJgICwDXpSM0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQICAALBrgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAjUREACuSUdqBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBASAXQMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoiYAAcE06UjMIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAgAOwaIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQE0EBIBr0pGaQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQFg1wABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqIiAAXJOO1AwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgIALsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBOBJWrSDs0gQIAAAQIECIy1wHXXXZe+8IUvDFzHxRZbLC1cuDAts8wyaemll04rrbRS2mSTTfLXAxfSgIyXX355OuaYY3paut9++6UHPchvHXtg/pXw97//PX3uc5/rt3tW6euss07aZZddZnWMzPUUuOKKK9KXv/zlnsbtu+++afHFF+9Jb3LCXKzuuOOOdPrpp6dzzz03//e73/0urbrqqmnttdfO/2200UZpp512SnMpu459wWHmXj3hhBPSHnvsMZXx6KOPTi972cvSKP9GTBWePVl33XXTS17ykvaksXo+LtfMuNRjrDqnppXZf//90xFHHJG3bsGCBem8885La665Zk1bq1kECBAgQIDAfAss1sq2+T6p8xEgQIAAAQIEmiZw4YUXpo033nioZkdAM748fetb35pe85rXCHBmmj/+8Y/Ttttu2+P6z3/+My2xhN869sD8KyECR0984hP77Z5VenyZf/zxx8/qGJlnL3D33XenQw45JG211VZpm222mX0B83DEWWedVVq3e+65Jz34wQ+ehxpMzilma/WHP/whD+7+6U9/6tvIuDai3NmW3bfAMd4xyPuhCQ7DdNHtt9+ef6a46qqr8mJWWGGFFM+XXHLJ9Nvf/jZtsMEGwxRfemz8WOib3/xm6b5xSByXa2Zc6jEOfTLpdZjpXhX39PghXfHV7Pbbb59OOeWUSW+2+hMgQIAAAQJjImBYxJh0hGoQIECAAAECBGYSeOCBB1IE7l7/+tenLbbYIt1yyy0zHWI/AQI1EDjxxBPzQM373ve+dOedd9agRZowG4F77703H2U/XfA3ynvSk540m2InNq/3w2i67sADD8wDvkVpe+21Vx78LV57JEBgOIFB7lVrrbVWeuYznzl1olNPPTXFyHwbAQIECBAgQGAUAgLAo1BUBgECBAgQIEBgngViirgYeXnffffN85mdjgCB+RKIUXjxxXC81//617/O12mdZ8wEzj777PT73/9+xlo9+clPnjHPJGfwfhhd78WPyQ4//PCpAmOGkfhxmY0AgeEFZnuvetOb3tRx0ne84x0ppvy3ESBAgAABAgSGFTAv3rCCjidAgAABAgQILCKBH/7wh+mrX/1q2n333RdRDZyWAIEqBWLa+Pvvv7/KUyh7AgR+/vOfl9byve99b3rpS1+aT3cfPxDYfPPNS/PVJdH7YXQ9edBBB3X8gOy5z31uevzjHz+6EyiJQIMFZnuv2nHHHfP13K+++upc7corr8zXBd5vv/0arKjpBAgQIECAwCgEBIBHoagMAgQIECBAgMAcBT72sY+lF77whR1Hx1TP8S9G9950003pi1/8Yvra176Wp3VkzF4cdthhAsDdKF7PWeDDH/5w2nnnnWd1/DLLLDOr/DIPLiD4O7jVpOWMaT+POuqonmqXrV1+ww039OR7ylOekj760Y9OpW+44YZTz2dT9tRBE/Bktu+HujoM21VXXHFFzzq8e++9d0exT3jCE6YddR6fT9qvueLg17zmNemd73xn8bLn8WEPe1hP2jgljMs1My71GKe+maS6zPZeFff9PfbYI33kIx+ZauZnPvOZ9J73vCf/gc9UoicECBAgQIAAgVkKCADPEkx2AgQIECBAgMAoBVZdddV8bc/pynzGM56RYjq4zTbbLLVarY6sF1xwQR4kXn755TvSvSAwF4FVVlllxutxLuU6hgCBToFHPepRqTvo1pnj/17deuut//fiX89WX331nrQiYTZlF8fU8ZFDea8eccQRHaN/l1pqqbT99tt3ZF5yySWn/VvQb/mJFVZYYdrjOk4yhi/G5ZoZl3qMYRfVtko77bRTRwA4RgPHGsIve9nLattmDSNAgAABAgSqFxAArt7YGQgQIECAAAECQwtsuumm+fSe55xzTk9Zl112Wdpkk0160rsTbrvttnTNNdfk/66//vq0cOHC9PCHPzw98pGPTDHaZ1RbrFV5+eWX5yOWY03KlVdeeaiib7zxxvSrX/0qPfjBD07h8NCHPnSo8roPvvbaa1OMiLrqqqvSiiuumDbYYIO07LLLdmcbyetLL700/eEPf0jhEsH/6bb4gj0C/FGvyLveeuulpZdeerpDJmJf1d4x8ibeJxE0W3vttQea1vTee+9NsWZfTLu47rrrpjXXXDPFmpjDbDfffHN+XcV7Ieq00korpfhSP94PEXAZ1y3qHeuDXnfddWm11VZLj33sY/P3xWKLLVZplau6P1XRD1WUOR1uzAjRvcX9sOptlNdCVf1btUGUX/U9q2jDqP92FuW2P8Z98Qtf+EJ7UnrWs56Vfx7oSByTF7O9n4/jdTYf/TpId42yHjE7zfnnn5/uuuuuFD9GeeITn5iq/hvR3cYq78NVfCborn/36/h8Gz/Ci8/pxXbkkUcKABcYHgkQIECAAIG5CWSjSGwECBAgQIAAAQIVC/z617+Oobs9/4455piBz/z+97+/5/go86yzzupbRhZEbJ1wwgmt7bbbrvTYok7Zl06t1772ta0sWNW3rDPOOKOVBUg7/r397W/P88d5DjnkkNYaa6zRc54s6NV63ete18q+mO1bdveO7EvFVpSdfbHYUV42TV4rC3a3srWP80N+9KMfdewv2vPPf/6zu8iO11lwq/WJT3yitc4665Qe/5jHPKa1ww47TGvbXuCb3/zmDpdw+uUvf5lnufjii1u77LJLKwsAdpzrcY97XGuvvfZqZcGF9qJa3/rWt1rPec5zWlmwtyN/vA7HLCDekX8uL7JgZ0fZhdvRRx89l+JmPGaU3tkXoj3W2VS6rSxI1tp3331bWfC+o21bbrll66KLLuqpY1yz2XSLrWytvtaCBQs6jsl+HNHaYost8v2Rb9DtH//4R16HbER+R3mFbzxmgbtWNqKndfrpp+d17i47+qB4n7UfVzyP9hX7o+6j2OL+lK1B2MoCvqX1zn4o0jrggANa2Q9Hpj3dj3/849Lj77nnntLjRnl/aj/BKPqhvbx4Puoys3V9p/qx6M94zAIP+ak/8IEPTO3PfjDQ4xpp7cdl6wFPVXmmsqcyljwZ1bUQRY+if4d5PwzjMMp71nz+7Szp0o6kr3/96z3XUtw/Z7vF39jintT+2H4dDlLmKO7no7jOirrO5pqpsl/HpR6FSzzGfTybkriVrRXd0/eR9p//+Z9Tf9OyKaw77k9xrxrFNur7cHud4joa5jPBMPeqoh5veMMbemwvvPDCYrdHAgQIECBAgMCsBWIaQRsBAgQIECBAgEDFAqMIAGdrs/Z8MRRfvMYX1WXb3Xff3cpG9pQe0/6FbfvzCDKedNJJZcW1Tj311J6ysilMW9lohVY2PXXPvvZy43l8IRgOM23Z6MNWNppkxvLe9ra3tU477bTSfNMFgLMp9XqChN11LV5no0BbcZ477rhj2mq/8pWv7KlHNgq19f3vf7+13HLL9ewryo/HbERoKxsZnAdLIiDcvq/seTZau5WNWJ62PjPtnM8A8Ki9s3Wze4zii+d3vetdPenhl41Kav3lL3/pIIkfOjz96U8vzd9tHvmm+2FEUXD8mCNbD3mgMotzvPrVr25lI9yKIvLHT33qUwOXEQHbYbZ4n3zwgx/sCYAX9et+fMhDHtI6/vjj+55yNgHgUd+fikqNqh+K8uKxijJnstpnn30Gvg6in+JHKMU2U9lFvvbHUV8Lo+rfYd4Pc3EIk1Hfs+brb2d7f/Z7XvY3pvtHSP2ObU8fVQB42Pv5qK6zom2zuWaq7NdxqUfh8qc//amVzVwy4z0pfrwWn5fKfgRVlDXXxyruw0VdRvGZYJh7VVGP733vez3G8R6xESBAgAABAgTmKiAAPFc5xxEgQIAAAQIEZiEwbAA4Rt6VBRJjZF7ZFkGlGNHXHcAZ5HWMfrzkkkt6ii37sjNbs6y1/vrrD3yebBrjqREiPSfIEn7zm9+0Isg0SD0jTzY1cmnefgHg/fffvzT/TOfLpgRuZVM3l1U5TysLAO+5556txRdffKDzxajmV7ziFQPljbq+4AUv6FuXQXbMVwC4Cu+ygEGM1o5Ab1k/Pu1pT+sgOffcc0vfS2XHFmnx3ovR5v22X/ziF61szczS8xdl9HuMkfft2yi+RG4vr9/zGGkao5z71atfeoxg/sEPflBa7KBBiyruT1GhUfZD0cAqyoyyZ7KazwDwqK+FUfbvMO+HmYyLPm5/rOKeNR9/O9vbMN3z7r+Z2RTv02Xvu6/KAPCg9/NRXmdFQ2dzzVTZr+NSj3CJWUy6ZyTp9/ch0p///Oe3Hvawh/X8bSmM5/JY1X046jKqzwTD3KsKk7///e89bhFUtxEgQIAAAQIE5iow3MJW2ac7GwECBAgQIECAQHUCt9xyS/rud7+bsqleU6x31r3tvvvu3Un56zjm5JNPLt0Xa8lmAcR8Pd1sSuWePNnojfSNb3yjJ70sIRstnK8XWuyL9YS33Xbbvmucxhp0/eoVZbz73e/O15Qrymt/jHWKn/3sZ+frkRbpV199dfF0xsdsauV00EEH9c2XTQPcd1+s3fuqV70qX8u1b6auHV/60pem8sear+ESa6qWbbGW3rHHHju1Kwsmpmza7r7r10b/Zj8qmMo/qifnnXdeykZ4DvQv+/J72tPOp/d3vvOd+GFraX2ywPpUeqyl+sY3vrH0vRRr82ZftOZrLXev/xvvvWyEZb6u9VRhbU+yHwCkbHrMtpSU991b3/rWlE0pmfbbb7+UjSTO17HuyJS9iPU4symqu5Mrf33YYYflayWXnSgLePe99mJtxJe85CUp1oCc61bV/amKfqiizLm6VXXcqK+Fqvq3qvYX5c7nPWvUfzuLNkz3GOucd//NjDXvx20b9H4+jtfZoujXsv4bZT3ic9ntt9/ec5pY83fttdfOP5fFZ79iy0axplhrepRbVffhqj4TzLXtK6ywQsqWTek4/Oyzz07xd9dGgAABAgQIEJiTwFwjx44jQIAAAQIECBAYXKDfCOBYFy3WzS3+xTpqMa1r9mXajNPJxpqyWWCqtBLPfOYze0YRvPCFL+xZb/bKK69sxZTC2QfJjn9ZoLWn3LLRLsVxMTXgT3/606npbO+8885WTG9b7G9/zL7I6yk7EmJUYXu+4nmslfurX/2q45gsWDrtSOHuEcAxxWWMli7KbH+M+mSBz3x9uxtuuKH17W9/u3SNuzjm4IMP7qhH8SLKaC+z/fmnP/3pVvblaZG19dGPfrRv3jjuwx/+cCv78nQqf6wF2l5e8fzwww+fyjPbJ/1GABdlD/IYo6L7bVV6l40ALuobI3WzQH0rRuLE9OQxJXP0abHFWpdF3uIxRu5G/vbtZz/7WStGxhV5isfjjjuuPVv+PKZAL/YXjzHSPdYT7N7i/VY2kj/qWmwxFWVMA1k2FWSUf+CBB07tjzUo57JlQaDSEV1xL4ipy4stpmPvNxL14x//eJFt6nHQUWtV3J9G3Q/RqCrKLLBmsoppy7Mv/vN/z3ve83qusRgVVuyPxz//+c9F0TOOLp7KmD2p4loYZf8O836Yybjdocp7VtV/O9vbMd3zQw89tOc6yn6cMt0hffdVOQK4uI/OdD8f5XVWNHQ210yV/Tou9Yi/MUV/tD/Gkh7x96F9i89lMYNMe7725+15Z/O8yvvwKD8TDHOvavcoW7rlrLPOas/iOQECBAgQIEBgYAFTQA9MJSMBAgQIECBAYO4C/QLA7V+Ozeb5Ix7xiL7TsMa0iP/1X//VykY6tmL625iKL/5lI/ZKGxB5u8+djTjuydvvy85ll122ddlll/XkjyBwBAm7y95yyy178kbCU5/61J68D33oQ/MgTNkB3/zmN3vyF+fqDgB/6EMfKs0bX4iXbRFYL6tPTE9dNj12vwDwm970pp7io3/KgotR9xe/+MU9+aMtZUHDd77znT15B02oOgBcpXe/AHD8aKJ7beT2H0jcdtttrfjBRXGNFI8RUC3bIgjcPa10NtqpJ7D7v//7vz1lbrXVVmVF5mkRRI4pvCPw8vWvf731xz/+ceqHE90HFXVsf4zA8LDbHnvs0VPnuEe0B8vbz/GUpzylJ3/8UKX7fTZI0KKq+1MV/VBFmYXrIFZF3phOvv0aiOcxZXy/bTZlj/paqKp/o63dBvF6uvfDbByqvGdV/bez33XQnf7617++x7DsRy3dx5W9rjoAPNP9vKrrbDbXTJX9Oi71yGau6LlmYjroWJakbMtGb/fkL963ZfkHSavqPlzVZ4JoU9Hm9sfp7lXtDu94xzt6jh/mB3/tZXtOgAABAgQINE+gd86/7BOKjQABAgQIECBAYHwFYirhr3zlKylby6+0kjF9bfZFb8e+f/zjHykLInakFS+yUcfF06nHmHp60C2mVc5G6fZkz4Kl6RnPeEaK6ZPbt35TA5ZNafyWt7wlxdS8ZdvOO++cTz+YBdDKdk+lZR/x09FHHz31uniy6aabpuyLtuJlx2MW1E7ZyN2UjWzumFr4rrvuSlngOe27774d+cteZGulpkMOOaRnV/TPE5/4xJSNFunZ95nPfKYnLabpjnpkI3E69vVz7Mi0CF4sKu8s2J4e/ehHd7Q4+rHYLrjggpR9aV28zB/jGn3Xu97VkVa8yH6okLKROOm0004rklJca2eeeWaeXiSWvQ9/8pOfpG222SZlwbW0/fbbp1VWWaXInnbbbbf831TCIniSrWfcc9aY4jr7YUlPeiRkwbH03ve+N2200UZpww03nPpXNoV8aQFtiVXdn6rohyrKbKMYi6ejvhaq6t8qsRbVPWtUfzsHtem+/8Vx/f6+DlpmVflmup+P83U23/3arw9GUY/4u9m9xeey9imf2/fH8iLZ2vJ9lxdozzvo86ruw1V9Jhi0Xf3ydU8BHfmuu+66ftmlEyBAgAABAgSmFRAAnpbHTgIECBAgQIDAeAhEMGmHHXZI2VSgaf311591pboDO9mUeuncc89Np5xySspGV/SUF+sAD7rFl339ttVXX71n1913392Tlk2/mbIRwz3psdZovy2+AH7Zy16WB6f65Yn0bJrClE2n2pMl1mWNNez6bbHu8vOf//x8Deb2PIOu1xr9FAHGsq09MFnsD6uyL/5if1n+Mq+irEX5uKi84wcB023ZyO2e3fHjh2yUeU96kRDBzvYAcKR3B+4jKJqNiOpZIzGbsjHFv9jWWWedtPXWW+drJcY6w9lo2zx9Ufwn3n/ZSOmeUz/3uc/tSSsSYt90+4t8c30cxf2pin6oosy5GlVx3HxdC6Po3yraX5S5qO5Zo/jbWbRhkMeyINKivBdNV+eZ7udlx47LdTbf/VpmEWnD1iOul7LPgtlyIv1OmafH57JsKYFp88xmZ1X34ao+E8ymbWV5y96Tf//738uySiNAgAABAgQIzCggADwjkQwECBAgQIAAgeoEdtxxxzygG1+yZWsxpmzavxSjdbu3GKGUTTPcN0DYnb/7dbaGbopRidlakfkXc1dddVV3lo7X0wVGOzJmL8qCvEWepZZaqng69fjAAw9MPS+eZFNIF087HrOpkjted7/IpqHtTup5XRb8jUwxCnemLfJ897vf7cg2aAB4upFV2bqzHWXGi8c85jE9aUVCtpZt8XTqMa6JUW8xCjRbV3GgYiPoWbYtCu+4XiPIOt32pz/9qWd3fKm666679qQXCWXHxPu0fVt88cXTXnvtlY488sj25I7nF198cYp/n//859OCBQvyYHD8uCFb+zfFSPH53GJEftm1M8h7qap6juL+VEU/VFFmVYZzKXe+roVR9O9c2jfoMYvinhV1G8XfzkHbGPnKRgCXBZtmU2YVeQe5n5edd1yus/nu1zKLSBu2Htm64qVFT/dZJQ6YaX9podMkVnUfLvv7PorPBNM0ZaBdZe/JsvfuQIXJRIAAAQIECDReQAC48ZcAAAIECBAgQGBRCsRIiQjsFlsEf9/whjek448/vkjKH2MkYUwDnK0ZmrL1RTv2Tffik5/8ZD6Vcb8Aa79jY3TtoFu/Ua5xfFkAuKzcsvrF9LLZmq1l2afSyqYGnNr5ryfdIzYjOb5QnO7L0aKMsumxYxrgbP3DPJBX5Ct7XLhwYVlynhZBwO6tX0A18kV952PbZJNNUrYO8VCnWhTeyy+//IyB1LLRPvGl6je+8Y1Ztbc7ABwHH3bYYSlG1Xe/b8sKjmvnhz/8Yf7vE5/4RDr44IPTLrvsUpa1krSyL73jRNP9YKGSimSFjvr+VEU/VFFmVZ6zLbfqa2HU/Tvb9g2af1Hcs6Juo/jbOWgbI9+kjAAe5H7e3u5xu87mu1/bLdqfD1uPsgBwBOdn+lvRvRRDe53m+ryK+3CVnwnm2s44riwAfMMNNwxTpGMJECBAgACBBgsM/s1eg5E0nQABAgQIECAwXwIxhWGsMdseFC7O/be//S1fU/cHP/hBkdT38b777svXH91nn31SWXA1DowA6+abb146AnI2AcfpvmQctJyyfNGGe++9t28bizZMmyHbWVa/+BIz/s20leUpSysrZ9Dgd3FsWT2LfZP0WNaOqr3LvjDtNpvNutbdx7a/LgsAxw8mjj322HTggQemCF4MusXIw5e+9KXphBNOGPSQofNFALpsu+2228qSK0mr6v5URT9UUWYlqHMotKproar+nUMTBzpkUdyzomJl5y0qXPY3sdg318ey2TcG/Xs213PO5bhB7udR7rheZ/Pdr/2Mh61H2TUYs0fcfPPN/U6Zp4/qb237Saq4D4+qnmWfCdrrPtvn8dm8eyubNaY7j9cECBAgQIAAgTKB3k8WZbmkESBAgAABAgQIzKtATBV7wQUX5OvXtp84vvDcbbfd0vnnn59WL1lft8gb6+edfPLJxcupx1jXNqad3m677fLgb6x/esYZZ+Qji6cyZU/iy7ZBtviCcBRfIK+xxhqlp4tRD9ON8i1by7S7oFVWWaU7Kf/iOI4tG+HbnrkseL722mvPOPo3ypity2zzt9dznJ4vCu/pRlsXNmXvl7XWWitfV7vIM8hjv2nJYyrn97///em9731v+s53vpNOOumk9P3vf7902tXu87zmNa/Jp95ebrnluneN/HW0uWyLH5istNJKZbtGnlbl/amKfqiizJGjzqHAqq6FKvt3Ds2c8ZBFcc8a1d/OGRvXliFm1Oie7jpGBT/ykY9sy7Xonw5yP49ajuN1tij6tazHRlGPsr+Zca4rr7wyPfzhDy87bZ7217/+te++YXaM+j5c1r5RfiaYa1vLAuwrrLDCXItzHAECBAgQINBwAQHghl8Amk+AAAECBAiMp0CM3DjmmGPyIG33KK0bb7wxvepVr8rXCy4LGv7sZz/rCf5GvqOPPjrtueeePQ2+++67e9IGDQD3HDjHhDXXXLP0yJiCcLoA8CBfNPY7PtZknSkAHHm6tw033LA7yes2gUXhXTZipq1K+dPHPe5x3UkpRtwffvjhPenDJMSX1BGYiH8xWurCCy/M196ONbjPPPPMFGsMdm/xhW/8qGOQ9ZfL1u/tLm+61/2CfvGlfvxApN/2gQ98IF+DPNbFXn/99acNAPQrI9Ln6/5URT9UUeZ0VlXvq+JamK/+LWyGfT9EOYvinlXUfz4fI9BbFgCO9/Q4bYPcz+f7Ohsnn/mqS1mANM4df9M22mijvtX4xS9+0XffKHaM6j48X58JijYPeq8qG5kcn1VsBAgQIECAAIG5CAw2tGMuJTuGAAECBAgQIEBgKIEnPelJKYIuZVsEkz796U+X7UqnnXZaT/pTn/rU0uBvZCwLSJUFlnsKHWFCjCYpG/043fqsERg/7rjjZqzFeuutVzrCKdZfnW6L4G/ZKOoNNthgusMav29ReMdop5m2smD/7373u2mnGT/nnHPyKdQH+eI21u+OoMR///d/p+KHA/E+iqDqW97ylnyU/bXXXtt3zeGLLrqopwllP8S4//77e/LNJiFG15UFvOIHJ/22GAn/wQ9+ML3pTW9KW2+9dR44j1GTMUvBbLeq709V9EMVZc7WrYr8VVwLVfZvFe+HcF0U96wq+nOmMmMEcPdWti5wd575fj3I/bzK62y+2zuu54u1fsum4z7kkEPyHzeV1Tv+VvzP//xP2a6h00Z9H67yM8Ew9yojgIe+VBRAgAABAgQItAkIALdheEqAAAECBAgQGDeBmE52s802K63Wvvvumy6//PKefRFk6t76rQUXwaQvfOEL3dmnDYr1ZB5RwpZbbtlT0le+8pV8tEnPjizhqKOOSoOMAI7RRC9/+ct7ivjRj36UvvzlL/ekR8I999yT3v72t6fuYFs4vuQlLyk9RuL/F1gU3oP8YOHZz352iinP27dbb701ffKTn2xPmnoeP4zYZpttUkxPvvTSS6dNN900X1f73HPPncoT18dzn/vcFNMzxr+nPe1paa+99kqvfe1rp/K0P4kvhWPN37IpZ8vSFixY0H54/vyuu+7qSZttQvwgpHs78cQT0+9///vu5Pz1oYce2pMe5nMZDV/F/amKfqiizB7EMUgY9bVQRf8WTFW9HxbFPato03w+lv3wYxwDwIPcz6u8zuazT8b5XNEPsTxB9xY/VoofJ3b/MCqWEXjlK1+Zumet6T5+Nq+rvA9X8ZmgaNsw96qyH2XGrBs2AgQIECBAgMBcBASA56LmGAIECBAgQIDAPAnESJgvfelLackll+w54+23356PyOveUbae7llnnZV+/etfd2dN73vf+9JPf/rTnvSyaaF7Mo044cMf/nDPurkxFd6znvWsFPV/4IEH8jPGF4KHHXZY+vd///eBaxBBubJRRXvssUfaZ5998jXtorD44jICfBGMjvVbu7cDDzww9Zuu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/exn8x/vxd+kss+Ns/2sVta+Ku/Do/5MMNd71Y9+9KOOpsff+fC2ESBAgAABAgTmKrBYDB2e68GOI0CAAAECBAgQGH+Bm266KQ8G//GPf8xHEGfrpeZf3sUX3ZOwXXLJJencc89N2TTYaa211krZVNilQe25tCWb8jNlUzunbOrpdOWVV+ZfZm600UZpjTXWyAMBcynTMf0FxtE7rqsYCRvB22z6xTzQm61TnVZfffUUAYa5bNHOq6++Or+m4rq64YYbUjbVc15mlDtd0LnsfPG/bH/+859TjA669dZbU1yj66+/fuoXsC0rY5C0bFrVFO+3CEzHfSMc4l/8KGPQkfaDnKc9T5X3p1H3Q9S7ijLbPcbl+aiuhSr6d77eD0V/1+lvRNzv4kdU11577dSl9m//9m/pq1/96tTrSXxSxXU2iQ7jUOeTTz45vfCFL+yoSvwtvfzyyzvShnlR5X14lJ8JZnuvis/nMQtOscUPNk466aTipUcCBAgQIECAwKwFBIBnTeYAAgQIECBAgAABAgQIECBAgMDkCey///7pIx/5yFTFV1pppY6A8NQOTxovENfJLbfckv8IKH4IVPxbZpll+tpka+qmGFHbvsUo4Z/85CftSZ53CcSPMuKHYu1jdE488cT04he/uCunlwQIECBAgACBwQV65wMc/Fg5CRAgQIAAAQIECBAgQIAAAQIEJkTgta99bccsGtddd10+6n9Cqq+a8ygQM8ccfPDB6c1vfnPaYYcd0gYbbJBiSYwDDzywtBZ33313iiVJurcY2WqbXuCUU07pCP4+4hGPSC94wQumP8heAgQIECBAgMAMAgLAMwDZTYAAAQIECBAgQIAAAQIECBCog0BMQ7/99tt3NOWYY47peO0FgRCIJTfKtiOOOCJFwPKuu+7Kd99+++3p7LPPTrvssks6//zzew4xirWHpCehexr2CLo/+MEP7skngQABAgQIECAwGwFTQM9GS14CBAgQIECAAAECBAgQIECAwAQLxHriT37yk/M1raMZMQ10rFde1VrfE0zV6Kr/5S9/SRtuuGGKAG+/LYKU9957b7/dadddd01f+9rX+u63I6XLLrssrbnmmlMjgFdeeeV0ySWXpIULF+IhQIAAAQIECAwlYATwUHwOJkCAAAECBAgQIECAAAECBAhMjsBGG22U9t5776kKxzTQxx9//NRrTwiEwOMe97j05S9/OS222GJ9QaYL/i699NLpkEMO6XusHf9f4LOf/exU8DdSDjroIMFfFwcBAgQIECAwEgEjgEfCqBACBAgQIECAAAECBAgQIECAwGQIXH/99ekJT3hCuvXWW/MKP+UpT0m/+MUvJqPyajmvAscee2y+7m+MSh1023nnndPHP/7xfGTroMc0Md9tt92WVltttan34cYbb5xPo/2gBxmv08TrQZsJECBAgMCoBXyiGLWo8ggQIECAAAECBAgQIECAAAECYyyw4oorpgMOOGCqhuedd16+jutUgicE/iXwile8Il188cXpxBNPTC996UvTlltumR772MemJZdccsoonq+33nppzz33zK+jE044QfB3Sqf/k6OOOmoq+Bu5Dj300CT429/LHgIECBAgQGB2AkYAz85LbgIECBAgQIAAAQIECBAgQIDAxAvcf//96aabbppqR6w5+pCHPGTqtScEZhK45ZZb8msm1gK2zV4gRuAX02jHVNuPeMQjZl+IIwgQIECAAAECfQQEgPvASCZAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMCkCZgCetJ6TH0JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQR0AAuA+MZAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEyagADwpPWY+hIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCPgABwHxjJBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQmDQBAeBJ6zH1JUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQB8BAeA+MJIJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAwaQICwJPWY+pLgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBPgICwH1gJBMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGDSBASAJ63H1JcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ9BASA+8BIJkCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwKQJCABPWo+pLwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBPoICAD3gZFMgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBSRMQAJ60HlNfAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI9BEQAO4DI5kAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKTJiAAPGk9pr4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoIyAA3AdGMgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCZNQAB40npMfQkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINBHQAC4D4xkAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQITJqAAPCk9Zj6EiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoI+AAHAfGMkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCYNAEB4EnrMfUlQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAHwEB4D4wkgkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDBpAgLAk9Zj6kuAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIE+AgLAfWAkEyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAYNIEBIAnrcfUlwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAn0EBID7wEgmQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDApAkIAE9aj6kvAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE+ggIAPeBkUyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFJExAAnrQeU18CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj0ERAA7gMjmQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABApMmIAA8aT2mvgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOgjIADcB0YyAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEJk1AAHjSekx9CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0EdAALgPjGQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhMmoAA8KT1mPoSIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgj4AAcB8YyQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEJg0AQHgSesx9SVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAfAQHgPjCSCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMGkCAsCT1mPqS4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgT4CAsB9YCQTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBg0gQEgCetx9SXAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfQQEgPvASCZAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMCkCQgAT1qPqS8BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgT6CAgA94GRTIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgUkTEACetB5TXwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPQREADuAyOZAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECkyYgADxpPaa+BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6CMgANwHRjIBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQmTUAAeNJ6TH0JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQR0AAuA+MZAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEyagADwpPWY+hIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCPgABwHxjJBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQmDQBAeBJ6zH1JUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQB+BJfqkSyZQicAVV1yRPvWpT6V//vOflZSvUAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgckVWHbZZdO73/3utHDhwsltxCKuuQDwIu6App0+gr+f+MQnmtZs7SVAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBhQYN1110277rrrgLll6xYQAO4W8bpSgWLk70477ZS22WabSs+lcAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgckR+MpXvpLOP/98M8kO2WUCwEMCOnxuAhH8ffvb3z63gx1FgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQO4EI/sY/23ACDxrucEcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLgICACPS0+oBwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBIYUEAAeEtDhBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBcBAeBx6Qn1IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJACAsBDAjqcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC4yIgADwuPaEeBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGFJAAHhIQIcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgXAQEgMelJ9SDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECQwoIAA8J6HACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjxmSEMAABAAElEQVSMi4AA8Lj0hHoQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgSAEB4CEBHU6AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFxERAAHpeeUA8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMKSAAPCSgwwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDAuAgLA49IT6kGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEhBQSAhwR0OAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBMZFQAB4XHpCPQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDCkgADwkIAOJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLgICACPS0+oBwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBIYUEAAeEtDhBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBcBAeBx6Qn1IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJACAsBDAjqcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC4yIgADwuPaEeBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGFJAAHhIQIcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgXAQEgMelJ9SDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECQwoIAA8J6HACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiMi4AA8Lj0hHoQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgSAEB4CEBHU6AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFxERAAHpeeUA8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMKSAAPCSgwwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDAuAgLA49IT6kGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEhBQSAhwR0OAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBMZFQAB4XHpCPQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDCkgADwkIAOJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLgILDEuFVEPAnUWWPWcXercPG0jQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKhC4eovjKyhVkXUXMAK47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1AALjuPax9BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0RkAAuDFdraEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNRdQAC47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1AALjuPax9BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0RkAAuDFdraEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNRdQAC47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1AALjuPax9BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0RkAAuDFdraEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNRdQAC47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1AALjuPax9BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0RkAAuDFdraEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNRdQAC47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1AALjuPax9BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAg0RkAAuDFdraEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNRdQAC47j2sfQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQINEZAALgxXa2hBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUXUAAuO49rH0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRGQAC4MV2toQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1F1gibo3cFLb97e//S1deuml6Y477kgbb7xxetSjHjWpTVFvAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTmScAI4HmCLk5zzz33pD/+8Y/pxhtvLJI6Hi+66KK0ww47pFVWWSVtvfXW6XnPe15aeeWV06qrrpo++clPplar1ZHfCwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBQCAsCFRMWPN910U3r961+fll9++bTOOuukFVdcMW211Vbps5/97NSZI/gbQd/vfve7U2nFk2uuuSbts88+6TnPeU669tpri2SPBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQmBIwBfQURXVP7rrrrrTjjjumn/70p1Mnuf/++9PZZ5+d/4vEN77xjenlL395uvnmm/M8D33oQ9MGG2yQVlpppfS73/0uXXbZZfno39NPPz3tvvvu6bTTTpsqyxMCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiEgBHAFV8HEejdddddp4K/yy23XNp2223TJptskhYsWJCf/a1vfWs66KCD0m9/+9v8dQSCr7zyynTOOeekb3/72/lawD//+c/zkcORIYLAxxxzTJ7XfwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAICAAXEhU9Hnfccenkk0/OS3/Vq16VB3bPPPPM9Mtf/jJ//uQnPzndd9996YADDsjzPP/5z0/HHntsevjDH95Ro8033zz97Gc/y9cGjh377rtvx34vCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgYAroiq+BCObGttFGG6UvfvGLaYkl/o88pnc+9dRT0+qrr57uvPPOPN+hhx6aP5b9J9YPPuyww/IRxVdffXW6/vrr87WEy/KOMu2kk05KRx99dHrggQeGLvaCCy7Iy4gprW0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECIxW4P+ikaMtV2n/Eoj1e2PbbbfdOoK//9qdHvnIR6ZXvvKV6fOf/3xaZpll0tprr13sKn3cbrvtptKj7BVXXHHqdVVPYrrpYhTzqM4RU1rbCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAYrYAA8Gg9e0q74YYb8rTVVlutZ1+RsOmmm+YB4IULF6bFFlusSC59jIDxUkstle6+++4Uo4DnYzvqqKPS3nvvnVqt1tCni/WOY/TvqquuOnRZCiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoFNAALjTY+SvYnrniy++OF166aV9y45RvyuvvHK69tpr0y233JKWXXbZvnmvuOKKPPgbGdZYY42++Ua5I6aejrWJR7G9733vy4uZKdA9inMpgwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDTBB7UtAbPd3vXWWed/JSx/u/tt99eevqtt946XXPNNfk6wEsvvXRpniLxyCOPLJ6m9dZbb+q5JwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAArvga2GOPPfIzXHnllelFL3rRtNM2x9TOiy++eN8aRfD3iCOOyPc/61nPmnakcN9C7CBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoLYCAsAVd+1OO+2Utt122/wsZ5xxRlprrbXSjjvumM4///yBznzdddelQw89NG222WbpbW97W7rvvvvSggULUvtI4IEKkokAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoLCADPQxd/7WtfS0972tPyM915553pO9/5TrrxxhsHOvNZZ52V3vWud6Xzzjsvz7/EEkukww47LK277roDHS8TAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLNERAAnoe+XmmlldKZZ56ZDjjggPToRz86P+OGG2440Jkf//jHT+VbddVVU4wifvOb3zyV5gkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQKAQHgQqLix5i2+UMf+lC6/PLL0znnnJMiKDzItuaaa6b3v//96eyzz05//etf01ZbbTXIYfIQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINBAgSUa2OZF2uTFFlssbb755gPXYdlll00HHnjgwPllJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECguQJGADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCQgA16xDNYcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeYKCAA3t++1nAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgkIANesQzWHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHmCggAN7fvtZwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoJCADXrEM1hwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB5goIADe377WcAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGaCSxRs/ZoDgECBAgQIECAAAECDRS4/+Z70j1n/y3d+7sb0wP/uDsttnBBWuLRS6elnr5yWrDWcg0U0WQCBAgQIDDeAq1WK937m3+ke35+Xbr/mttT694H0oNWWCotufEKacktH5UelP0ttxEgQIAAAQIECMxNQAB4bm6OIkCAAAECBAgQIEBgDARa996fbvviH9LtX7skpeyL4+7tti/8Pj14k0emZd+5cVrw+Id17/aaAAECBAgQWAQC91x4Q7r1sAvTP/94c8/Z7/x/7N0HnCRVuTbwp6pzTw4b2Jwjy8IuaUFgl6SCioEgeEW4inwiGBAT4vdhuOo1exUUFUmKXBUDqIAgYRfYJWxi2ciyOU8OnUN976maXnpmemaqZ3tmOjznR+/0dJ2qOvWv7p6m33rf8/AOaBUuVFwzB2UfnAlN13r14QMUoAAFKEABClCAAv0LMADcvw+XUoACFKAABShAAQpQgAJ5KqCyfps/9wJim1rMETqnA64ZGnSJ8xoRIH7AQGyjxIVXN6DxY0+j5hunwXvmcXl6NBwWBShAAQpQoDQEAn/bibbvrQUShgR6Afd8wDFWgrzyLWVS4sGxrQYSe2No/+kGRNY2ovabp0HzOEoDh0dJAQpQgAIUoAAFciTAAHCOILkZClCAAhSgAAUoQAEKUGD4BIx4Ei1fXmUGf3Wp8Ox/vwbnuO4ZQu4TNBhLDYT+pUpMJtB86yrU37UU7jk1wzdQ7okCFKAABShAgaMC4RUH0Pbfa+RKLcBzBuA9W4Pm7P7323u6hth2A8G/Geb0Dq3fWo2ar516dBu8QwEKUIACFKAABSgwsIA+cBf2oAAFKEABClCAAhSgAAUokF8CgT/vQHRdIzTJ9i2/pnfwNzVazavB/x4d7kXyiJSIbv2v1VBzDrJRgAIUoAAFKDC8AslQHK3fsYK/3nM1+M7VewV/UyNSFT3Kr5bAsBtyIddeqMAxGwUoQAEKUIACFKCAfQEGgO1bsScFKEABClCAAhSgAAUokAcCRtJA531bzJH4L5KSz+XdM4cyDdF3ofSrkrLQ29vMbKJMffgYBShAAQpQgAJDJxB8ZCeSzRE4Jkjm7xkD/+12jJIg8TKrX8e91t/9oRsdt0wBClCAAhSgAAWKS4AB4OI6nzwaClCAAhSgAAUoQAEKFL1AdEOT+QWyXmvN+WvngFV5SffJ1pfIoWeZRWTHjH0oQAEKUIACuRQIP2f9/fWcNnDwN7Vf90lyT7KAY5takDgSSj3MnxSgAAUoQAEKUIACAwgwADwAEBdTgAIUoAAFKEABClCAAvklEH+z3RyQc3J240r1j+9oy25F9qYABShAAQpQ4JgFYoP4+60u4HKOt3Yd49/vYz4H3AAFKEABClCAAqUjwABw6ZxrHikFKEABClCAAhSgAAWKQiDZHjWPQ/Nndziaz+qfbLPWz25t9qYABShAAQpQYLAChmHASP397vp7bHdbqb/3yfaY3VXYjwIUoAAFKEABCpS8gLPkBQhAAQpQgAIUoAAFKECBPBaIbmxGeMUBxHd1INkZg17jgXtuDbxLx8M5riyPRz50Q9OrpBakNCOY3T5S/fVqT3YrsjcFKEABClCAAsckoGka1N9vdRGW+nusZfER5ujf766//8c0EK5MAQpQgAIUoAAFSkSAAeASOdE8TApQgAIUoAAFKECBwhKI7WhH2/fXIrq2sdfAw0/tQ/sdG+C/eAoqb1oAvcIKiPbqWKQPuGZUmUcW35XdAab6p9bPbm32pgAFKEABClDgWASc8vc7urpBLmqTaX3n29uSETcQ32f1dU2vtLcSe1GAAhSgAAUoQAEKgCWg+SSgAAUoQAEKUIACFKBAngmEVx5C48eeNoO/quyh5zTAf6mGsg9p8F+iwXW8DFgDgo/uQsNHn0H8QCDPjmBoh+OaXwu93otkCxDbatjamfoCObLa6utdOs7WOuxEAQpQgAIUoEDuBHxSvUS1yEtSDlpKQttpkdXSKwb57FMLR32WtaPt7IB9KEABClCAAhSgQJEKMABcpCeWh0UBClCAAhSgAAUoUJgCse1taLl1FYxQAq4TgMpPavBdoMM9RwK/UzW4F0gg+L06Kq7X4BgLJPZ2ovmWF5AMxgvzgAcxak3XUHHtHHPN4GMGku0Df4kckn5Gu3yBPLsaniUCx0YBClCAAhSgwLAK+N81xbyAK3FAgsArBt514rCB8LPW3/iK/5w78ArsQQEKUIACFKAABShwVIAB4KMUvEMBClCAAhSgAAUoQIGRF2j9zhoY4QTcC4Gy9+jQPJLqm6E5ajWUXy3z6Y0C4js70Hnflgy9ivch/yXT4D5lNIxOoONeKQ+5J3MQOBk0EPhzEtH1kjTtdaD6tpOh5iEs9RY/GEBkXaN5K7UM8lI/9zx+ClCAAiMlYP4d/spiqHqE4eUGQv9Kwohm/vsd3WKg835ZJtm/vosnw8uLt0bqtHG/FKAABShAAQoUqADnAC7QE8dhU4ACFKAABShAAQoUn0Bk9RHENjZDK5cvO98xcJBSc0tJ6PcAnXfLl6T/ux3lkhWre0vjI77m0FD7zdPQ/MWViEogU31J7JwstxkSFJcpAo2IZEfvNxDdLM+TqAR/y5yo+dbpKOX5f9WFBZ1/3I7gIzuR2Ne9bLhjXBn8756MsitmQveVxnOo+N5BeEQUoAAF8l/Ae/pYVH/lZLR+ezUiL8vf6Y0GXHMNqWqiQZM/P+b0DtsMJA5ax+JdNh7VX1yU/wfGEVKAAhSgAAUoQIE8E+D/2efZCeFwKEABClCAAhSgAAVKVyD8nNRElOY+UQKWroEDwKqv8zgpBT1Bvijdl5A59Q7Dd441v55aVuxNr3Sj7qdnmdnPnb/bhvjuhNx6ZxJ5zhiLqs+cAOfEimIn6fP4Ym+2ofkLK5Homi9azS2t11ndk80SLJfHO+7ahMBfd6Luu2fANau6z21xAQUoQAEKUOBYBPwXTYZzSgXafrQesdebEX1Vba3732+92o2Kj82D//3TWLnjWLC5LgUoQAEKUIACJSvAAHDJnnoeOAUoQAEKUIACFKBAvgnEdnWYQ3JOshf8TY3fOUkCePusUtA4J/VoafzUnDIf8kfnmZmr4RcPmRnUieYwdL8TzkkV8Jw5Fq4pkhJcwi22qx2N1z8LIxCHYwzgPU+Dc6pcZNBVCtswpIT2binH+W+VcRVC4/95FvW/XFbS2dIl/HThoVOAAhQYFgH3vFqM+tUyRLe0ILLyEMzpCKJJc45gz4n18Jwyxpy6YVgGw51QgAIUoAAFKECBIhRgALgITyoPiQIUoAAFKEABClCgMAWMdqlVLE3zZTd+zacCxgaSHdb62a1dHL31chf8F04E1I3tqIART6LlS6vM4K9rNuB/nyqxqZ4vbzUVCHZNkWzyayDloQ0JoifM0tqjf38BNLfjrY68RwEKUIACFMixgHtODdSNjQIUoAAFKEABClAgtwIMAOfWk1ujAAUoQAEKUIACFKDAoAX0ao+5rtF9etYBt2cErLKJqfUHXIEdSkZAzfcb391hlnv2v7d38DcdQs2rrOaU7miQTGApCR14eAfKr5yZ3iVv7se2tiL0zD7EtrUh2RqReZ/dktVcAe/Z4+A5aVTejJMDoQAFKFDIApHVRxBefhBxqSSR7IhBr/HANbsavnMnsEpEIZ9Yjp0CFKAABShAgZIQYAC4JE4zD5ICFKAABShAAQpQoBAEXDOrzHl84zsN+WK1e5Zmf+OP77SWct7W/pRKc1nwH1LbWZp3qQR/bcwrrYLAvmVA4H8NBP+5O+8CwIkjQbR+bx0izx/sdULVHNiBh7bDfUIdqr5wElzTq3r14QMUoAAFKDCwQGxbK1r/ew1im1p6dY7IdAud92yB95xxqLrlRDjqsyxb0muLfIACFKAABShAAQpQYCgEGAAeClVukwIUoAAFKEABClCAAoMQ8EpGTedvtyGyDjJ3rSHz2A4cBI7tkGzNw1I2usIFzyJmPg6CvWhXSYbj1pf3UsXZlUUir3OakLhkTuntkl0rZclVdm0+NBWQaPrM80i2RAAZknuhDHOqBLbLpQB6UMa7x0B0PRB9rQmN1z2Dmm8vgfc0mfSYjQIUoAAFbAuE5QKb5tteAiIJ8/3VfaJMETBR3mu98l4rFUrU5w71Xht+7gCiG5tR95Oz4JpWaXv77EgBClCAAhSgAAUoMDwC+vDshnuhAAUoQAEKUIACFKAABQYScM+tgWfJWPnSVeZi/ZsBI2mVdu5rvWSHZGk+avWpuGaOZHjy431fVqX4eLIhbB62Lt/L95z3tz8PlQWsV1s9Eg2h/roO27JEcxhNn3vBDP6qAHXlJ6Vc9dt1uGZpcI6TOYwlY953rm4+7logQYpQAi1fXoXYzvZhGyN3RAEKUKDQBWJvtB4N/rpPst5rfUvlvXa6vNeOl/daec/1v8N6r3VOBpKNYTSr9+Y2+eDCRgEKUIACFKAABSiQVwL8hiivTgcHQwEKUIACFKAABShQ6gKqdK2aYy/+ppTh/Z1k97ZmDgLHdxvouEeCxB2SCXlSPcoun1HqdDz+ngJOK4PcSPZcYOP31DoSDM6H1v7z181Agwo4lF0hAeqyzOPS3BrKLpFgxfEqCBxH2/clnZ6NAhSgAAVsCbR+d62Z+auyfv0X631OHaCXy3vtlRoc44HEoSDaf7nJ1vbZiQIUoAAFKEABClBg+AQYAB4+a+6JAhSgAAUoQAEKUIACAwo4x/pR+8Mzodd7Ed8NdNxpIPCHJMIrDUTWGggvl8DvvUl0PiDBX0ludC+sQ62UutWc/Gg/IG6JdTDnZZQArnqeJEOZLyTIRGJEDSRbZYk8pRyj/Zm6DOtjiaYwQmouYyll7XuXlCG1EZT2v1P6ybSU0TUNZonSYR0wd0YBClCgAAUiaxsQe73ZLPvsuzDzRTbph6UqS/jfLf3kv+DfdppTBqQv530KUIACFKAABShAgZEV4LdEI+vPvVOAAhSgAAUoQAEKUKCXgHtODUbdex58F0u6o8TtYttkrr1/GxIEswLAiX3yfavfiYrr56Hup2dDr8qPOVp7HQgfGFEBVRLcs1jmhVbPoY32hxJViVwJubhgQZ3MQ+20v+IQ9Qy/cNA8Bud0iQHXDByUUMPQPJqM3xpQeIWsz0YBClCAAv0KhJdb75XuE+Q9VKop2GmOeikNPVV6JuTzyYuH7KzCPhSgAAUoQAEKUIACwyQw8v83P0wHyt1QgAIUoAAFKEABClCgkAQcdV7U3HYyKj9xPMLPH0R8TweMzphZHtolAWLPaWOg+/hxvpDO6UiM1f++aYi8fAThFQZccySpV8p29teSQfkS/zkrW1itmw8tvlvqnEtzTux/7D3H6lD9XzYQ38V5gHva8HcKUIACPQUG+16r3pvjO+S9tuu9uud2+TsFKEABClCAAhSgwMgI8BujkXHnXilAAQpQgAIUoAAFKGBLQAWCyy5R6TVsFMhewLd0PAKSBRxd3YDAQ4bMnytB4IrMgdRkQJUbt+aVdi2ohe/CidnvcAjWUBc+qKZ5s9t4qn+ya/3s1mZvClCAAqUlkOyMmgeceu+0e/Sp/qn3arvrsR8FKEABClCAAhSgwNAKMAA8tL7cOgUoQAEKUIACFKAABShAgREVqPnmaWi87hkk9gXQ8UsDnjOlvPM8CQRXWoHgZKch8+QCkRck+BuUMstqHmo1r7SWOVA80MHEJOM2/NQ+RF5rQrIxJOWYHXCML4f3jLHwnjseuje7/w3VazzmLo3OgfbcfXmqf2r97kv5GwUokI8CRlzmvH/2gFS+OID43k55T4pDr/XCPV8uSjlvAlyzq/Nx2EUxJkeNF+pym2SW77XJDqtqBN9ri+JpUPAHEd/bgdCT+xBd14hE6jPIuDJ4l6jPIBPyYmqLgkfmAVCAAhSgQMEIZPd/3gVzWBwoBShAAQpQgAIUoAAFKEABCigBR7UHo369DC3/7xVEXjoswVkp8/yULHDLl/YqxhtRvazmlmzhmq+fCocEXLJtyUAMbT9aj9A/d5tz9qavH9vSKvNY74N+5+uo+swJ8J1vP7s4FfCJSYlR71n2g9Kqv2pqTm02ClAg/wXCKw+h7fvrkDgQ6D7YXR2IrmlA5wNb4ZWqBlVfOEnmA7cuDOnekb8di4BrTjXCyyXwLu+d7rn232vjO6y9qvXZKDBSAslQHO0/eQ3BR3fKVQzdR2F+Bnl6v/kZpPKmBfC/c3L3DvyNAhSgAAUoUKQCDAAX6YnlYVGAAhSgAAUoQAEKUIACFEgJ6FUe1P34bVABluAju2Re4MNmZp1arvmd8Jw8Gv53TZYA67jUKln9TDSH0XTjcsR3yny9Dgm6ngC4ZmnQJR5gSEpZ4iAQXW9IYCeMlq++jJj0q7xO0pBtNM/pY80xJvbGZS5sA85JAwcmEi0GYpLVrALc3qWDOyYbQ2MXClAgRwKBh99E2w/WmReP6KMAz0maVA6Ql7BbYjkyjXdsu1QqkMXhZ/cjtqUZdf9ztswLXp6jvXMzSsC7bLxUidiE6Aa5f5ZxtEpEfzrqQpvEITlPFS7z70h/fbmMAkMlkGiNoOmmFYhvb5PyJvIZ5MSuzyBy/Zf5GUSeo9HX5Lm6L4LWr78qFzm0o/KTC4ZqONwuBShAAQpQIG8EGADOm1PBgVCAAhSgAAUoQAEKUIACFBhaAbMEopRBVE1l7EKSZPVy1zHtVJVsbf7iSjP4qwI3ZZdJ4Ka2e5DWKTFYz2INkdUGQk8Y6PzNZjjH+eG/eMqA+9Z9TvjfOxWBB99A4K8GKv5Tjbn79tM3YkQNBP8sByYZQJ6zjoNTyk+zUYAC+StgZv52BX+9SzWzTH16CXqHvK+4pmtSRl7mKX9YBXFCaP78i6j/zbks55rD0+qaUgnfBRPM8rkBeQ8t/5AEdl19v9cm2+W99lF5r5VW8ZE5EqyXq3/YKDDMAkbCQMutq8zgr14nn0Eul88gdd2ft+ZnkEXyGWSdfAZ5TD6D/HYbHFIWuux904Z5tNwdBShAAQpQYHgF5LooNgpQgAIUoAAFKEABClCAAhQoNQG9zHXMwV9lFvzbTsReb4ZWBZR/uHfwN91VBYH9F1tfzLZJqcZkezR9cZ/3Ew0hc5khmYAdv5Hs3p1W0KHnCvFDBjrulQCRZByrlmiy1rN+478UoEC+CRjRBNq+u9a8GMW7TIK8b9P6nH9cr9BQfpVUFhgNxHd3mCWh8+14Cn08lZ89UeaB90mQHei8T95Lj2R+r429Ke+198i88VL0wb1oFMqumJHXh27Ekoisb0Toqb0IyXQE0Y3NUBcvsRW+gJp2Irq2UbLQuz6D9Aj+ph+h50T5DPIe6zNI+882INGSNgdGekcb91Xlk/Aqqary+B6Zs/wg4vuynDzbxj7YhQIUoAAFKHCsAswAPlZBrk8BClCAAhSgAAUoQAEKUKCEBVQmjWr+t0tgxt896yYTi3uhJl++G1KCMSbZY7sky2xWpm5HH0scCSH8pEQj5PJlxxirnHTgd4YEKaQc9FTJUJNsYCMk29sjy+Smml4rCcAS+41vapWyj01SklrSgtgoQIG8EwjJvJyJQ0EzqOs5Y+DhaW51EYkEJyX4GPjDdqkIMFeyVJnbMLCcvR5qbuW6n5yFps+9KEHgTnT8SpXdl/dbmbZd88l7bad675b32sPW9lTwt/bbp0Nz5uc5UBcPddy9WbKa9x6d9iAlocpW+981xcxe1quk1jhbQQp0/s76DOK7QD6D9FMdJHVw7vnyGeR1eR6/EUfwrztQce3c1CJbPyOrj6Dj15ulJH1jr/7OqRUov3oOfG+f2OeFLL1W4gMUoAAFKECBIRTIz09oQ3jA3DQFKEABClCAAhSgAAUoQAEK5EYg9mabGbxRmTfOmfa36ZZSjKqprJmBWvhFq49L4sTl10iG4LmSIeiRAITM6RdZKdt40kDk+a7gr1zi7Fki5Ug/KmVkF1pbtrOPgcbA5RSgwNAIhJ8/YG7YI+8J6WWf+9ubc7xUGpBK9kYwjsjahv66ctkgBJyTKjDqN8tQ9kF5U5fAbny3vNfKe6z5XivvuSr4q1W6UfmpBRIsfpvMFZyfwVNVWvzIlf8yq1So54q6gMglU8+7JN6n18vzpyOGwO/fwJGr/iUBwaZBSHGVkRaI7+0wqwFofuu82h2PqkaiWjafD1Sp6bYfrkPTjSus4K983lAXobmOl58z1AUSctHZzg60fu0VNN/8ApKdMs0GGwUoQAEKUGCEBeTPFRsFKEABClCAAhSgAAUoQAEKUCB7gfgeqf8pzTlevvzUrC9U7WzFOcHqpcq4DtTiu62yio4JEiByqHlAJch7qnzRussKAhtBw8xMU1/ou6bLOCRDUDWHuQ+VGTzwPswV+A8FKDDsAvE9qdd3drtWr291EYj5HnKqRPbYciqgV7hR9ekTUPGxuYisOizvt+1mQEuv9sA1u1rmdB+d15nXkZcPo/mWF8y54J1y8ZDv/N7TE6gpA1RQO747gkYJ6o26a6l5bDmF5MaGVODo+8e47D6DWJ8P5P2j6/3HziDbvrsGwUd2yYcLwHu2XGQmn0PS58g2kjI9xeuQMuNyUZq8Zppufh71d5yT168TO8fNPhSgAAUoUNgCDAAX9vnj6ClAAQpQgAIUoAAFKEABCoyYgBGIm/tWGbnZtFT/ZHDgDBmjq09qHbUfzanBJRk36ia/qX96tVT/ZGDgffRamQ9QgALDInCs7yGp9YdlsCW4EzVXvO+8rit2CuT41dzyzV992Qz+qooQvvMyFz90jtVQ9iGZx/7vErh7LYHmW1dh9EMXMmBXIOdZDTN5jJ9BDPl8YBhyEdkAF7CpEuJm8Fe+RS//kAbnxN6fOzRdk+km5IK4yUDH/fKc2tCMjl9uROUnFxSQKIdKAQpQgALFJsAAcLGdUR4PBShAAQpQgAIUoAAFKECBYRLQa63IbzLLJNtUf0eNd8CR6l19ku2G9O39pWtfGzC6xuSoHXgffW2j0B+PSdZe6PG9iEqZXDWXsirn6jzOD8/pY+B7xySUsk2hn9tiGb96D0kcCEg5XjmiGvtHlWy3+qbeg+yvyZ7FLqDmhDUkCOycIpmaMmVAf00F7dSc0h2SDayehwGZE7b8MvPKov5W47I8EVBzVquW+kxhd1hG6v1D1h8o+Ksye9t/Lqm90nzvyBz8Td+vXiUXFnzAmqe8U+YpL7tiBhz1Uh+ajQIUoAAFKDACApkvgxuBgXCXFKAABShAAQpQgAIUoAAFKFBYAq45ErGR79fje2Q+xagK0Npr8e1WP9e8gSM+qT7xN+1tO9Urtt0aj2vuwPtIrVMsP5PhOFq/vRoNVz2Jzvu2IPpakzlXc2JfJyKvHEH7TzfgyKWPo/O3W4vlkHkcBSrg7np9xt60//6hAjLxndYBu+fVFuiRc9hDJRD6115z096l9uaVNqcWkJK+qoWesNY1f+E/eS+gypFDpoZI7JMgcNj+e0is6/OEy8b7R3SD/P08GIQuHyXcC+2ROMdJlRIpPY5oEqFn9ttbib0oQAEKUIACQyDAAPAQoHKTFKAABShAAQpQgAIUoAAFSkFAZZC6T5TJd6USdOQle0dsxGXexZesL2rtlBb1yvyeWrlLsrOA2A57X/AmmqT84hYZj5ozeOl4ewMrkl6q/Gnj9c9a5SolpuFeBJRdpaHiRrndINluH5AMppkSsA8l0H7H62i5/WWzBGaRHD4Po8AEvF3lhaOrJYATsvf6jq6T569MHeycXCFl4KsK7Ig53KEUSBwOmhe7aH55+8/irV/NHw/5hjS2sRlGLDmUQ+S2cyigV7rhOWW0vHnIZ5CV9t4/jITM0dvV185nkOj6RnPELvm7OVC2cPqhuWZbFxWk1k9fxvsUoAAFKECB4RJgAHi4pLkfClCAAhSgAAUoQAEKUIACRShQcf1886jCKyTourP/L2DVXHvBRw0YbRK8mVkF77KBv6HXvA6UXz3b3EfwEQPJtv73obKAAn+SPvKFsP89U+AcK5GAEmnKt+W2lxDf1gZdEiMrrpeA70U6XNM0OKrlVitzFM7VUH6FjrIPypfTUj1TZbx1/GpTiQjxMPNNwLOwHp7TxsAIy1ysf5b3BrlApL8Wl1K9oSetPhXXzeuvK5eVoECiUZ5I0nRJDM0mWKe5JFu43AJLNlvbsH7jv/kukHofiLwoAfyuyh99jVn9jQz9Qz5HtMhnkCkV8F0wsa+uRx9PHn1OWQHdowsGuKOeg6ql1rd+478UoAAFKECB4RVgAHh4vbk3ClCAAhSgAAUoQAEKUIACRSWgAjjlH5YArQRcAw9Z2b0qw6ZnS7RIYPb3EiTeKF/M+52o+dqptr+gL79yJtyLR5lZfx2/kW1s6719tb/4HgOdsjzZIF/uTq1A5ScX9BxGUf8efmqfWeJZKwPK/0MCvnV9f2HtmiHzFF4my+W/zvu3Ir5XUirZKDACAtW3LpILFjxmWefOB2Qu1iO9X98qcBNZJ6/v+2RZTObivGgS7GTv9XU4RjSByKtHEPz7LgT+thPhlYeQDMiGc9iSbVGEnz9ozisb/MduRNY0SICb2aU5JO61Kc3jMB8zBnMqU+t0baPXxvlAXgqoMvDlH50rZQHkM8gf5DPIi5kvJEm2ymeQ/zVkSgT5sycXltV8XT6DSJWQgdrR55RUOsmmpZ6DqfWzWZd9KUABClCAArkScOZqQ9wOBShAAQpQgAIUoAAFKEABCpSmQMX/mW+WzQw89AbCkp2nMnGc0w0z69SISUDnkARnd4uNxD70Gg9qv7MErqmVtrE0p26u0/KVVYi8fMT8klevNSTIK9sr15AMyj5k6ka1H9Wcs6pQ970zoJe5rAdK5N/OB7eZR+o9V4NeOfAX264pkhF8onwhvla+GP/jdlTdfGKJSPEw80nAMdqPuv85C823vIjE/qBkpMt7xwR5fY+XQI1bXt/tctHHDonvtFuj9r1zEqq/tHhQh5CQ7M6Ouzcj9Nhuswx6t404pWT8OeNQKVUNnBMrui3K5pfYm21o/8VGKTMrb0g9LobRypxSmWAqKq6ZI69RdzabZV8bAg5V8UHe+pLN8nyReenV88dOU5UljJCsKhcn6VU8L3bM8qlPhQoAy3y7nQ9sRfhp+QyyyvoMYmbhSuA2cVg+g+ySEctnEE1ed7XfPh2umV0pugMciGOcXFElLSHVB8wnl/nbwP+ofaqWWt/6jf9SgAIUoAAFhleAAeDh9ebeKEABClCAAhSgAAUoQAEKFJ2Apmuo+vQJMhffKLTf+Trib7YjJlk2MZWSk2qSaeN/92RUfHweHPW+1KO2f+oyD3DtD9+G4F93oOM3m+UL/gii8iW/mfbTtRUVXCn/0CyUXznLzPCxvfEi6JhoCsu8x62AxLzdVlVuW0flPkkzA8DhFw5JANjWKuxEgZwLuKZXYdR956Hjns0I/HmHXNCRNC/qSH99OyaUofLj822Vbc00wMi6RrR8eSWSrVFzsSosP1WihSpndJ+8V21Q85P/ez8iyw+i6raT4b9w4PKwPfcT+MsOtP1gnRX4lZp7zinqohc5ioTEniQglDgcl0oIb0gZ672olYtU3HNkIVvOBNTfCfcJdYiub0JUqk14TrK36eh6q59nicw5r9kLGtvbMnsNh4A6Z5U3HA/3yfIZ5I4N5jQIsQ099iyfJTK1aAAAQABJREFUQXwXTTQv8FAXndhtniVjza6xN+Q1HDDkwrKBnx9GUi6sWm99/vGeYa1vd3/sRwEKUIACFMilAAPAudTMYluRSAQej0y4lGVrampCKCSXJUqbMGFClmuzOwUoQAEKUIACFKAABShAgaET8J5xHNQttqNdvvxshApKqvKHzvFl8Jw6RrJ1jy0jV5VrLPvAdPjfOw3RDU1SCrpVgjkRM5POKRnFnkWjoLlKc6aj+D6rhLNjjOQoSSaj3eY4TnpK98TBgFmeVmVbs1FgJARURmzVpxfKRSLzzVLmCSlLngzGZe5qD1zza48pWBrd0oLmT6+QrNAkTpYn/E3QMUk98dNakwSBfyUpgk/Ekmj9fy/Le4kEjJbZ/94l8MhOtH13rblF98mA92zJxPd330fisMyD/riqWBBG043LUf/rZXBNsV8NIW24vNuHQNllM8wAcPhZA64ZEoCv6H4Oeq6WaJLA/yorWKfWZStcAa98zlC32C75DCIXfJjz76rPIMepzyCjB5V175Sscu9ZxyG84iBC/zJQ9r7+n09KL/KSBIubJPtXffbpCiAXripHTgEKUIAChSzAAPAwnr0//elPuPvuu7FmzRo0NDRg9uzZOOWUU3D99dfjzDPPtDWSa665Bn//+9/NvmoOHDYKUIACFKAABShAAQpQgAL5JuCaVgl1G6qmAsGeE+vN21Dto9C2a0igTDUty+uMzWw3l/y/pSRFGpGEBI8ZAC60c19s49V9TvjOHpezwzIkoNvylZfM4O9FEvT9nAR/9R7BX7WzOnnsS5IPPFmCwL+UW+s3XoV7QZ2tigVqDu2271nBX99F8v60KHOQyDFGk/m5geBfpKz1ljhavvqymfmsqiiw5UZAzQ0dkEoR0Vcb0PmggfIrJAhcndk30SDl72XuevX+53v7RKg57dkKX0BdVJHLCysqb1wgc4Y3ILYxjqAvCd+FGvp6zUZelQsKpAy1alWfXci/qYX/dOIRUIACFChoAf6f3TCcvkAggI985CO47LLL8Pjjj+PIkSNQwdstW7bggQcewNlnn42bb775aGbvMAyJu6AABShAAQpQgAIUoAAFKECBIhJw1HnNo0m2ZXdQRtgKfsAjQbESmzM5Oyn2LlSBoGTmJg4EME0O4LN9BH/Tj+1K6XOWBIONUAKd921NX9Tn/Y67N8kkowbcC6XscB/B39TK6gIW/yWSHSxTkMa3tyH01L7UIv7MkUDtN0+T8tsVSDYA7XcZCD0jJcUl+1rNSa/mBo7vl0zsJ5Lo+LUB9Z7pWlA76HmlczRkbiaPBZyTKlDzjVPliaLLhQVAxy9lnuF18tyR+clVuWdVGjq6xZA5iJMISYa/mv1CBY29Z6oSG2wUoAAFKECBkRNgBvAw2N966624//77j+6prKwMo0ePxq5du8xAcDKZxI9+9CP84x//MAPEU6dOPdqXdyhAAQpQgAIUoAAFKEABClCAAgMJqBLYmt8pJS/jSLQacPSR8dZzO7Ht1iPuebU9F/F3ChSswJ5v7j869nNefBMvyG8flsCuM0Pm79GOaXeulb4rkIDvkd3YFayHnjYv7KTbxqf1tDLnw88dMB9TZZ/tNFVe2nMGEPqnBCdlPuDBzDdsZz+l2kev8pjltVu/tVqyMWVeZ3kCRF6wsjK7mcjp8l8yVeY/l0xNt5oNmo0CmQVUMLf+zrPR8rVXkNgXQOjv8trN0FWrcqP6cycOeq7yDJvkQxSgAAUoQIFBCzADeNB09lZct24d7rjjDrPzmDFj8Le//Q3t7e3YsWMHWlpa8N3vfhdVVVXm8m3btmHp0qXYuXOnvY2zFwUoQAEKUIACFKAABShAAQpQQATU3Mfec6yyuZEVGQIdGZRU5lK4Kyjiu2Bihh58iAKFLZCU6murWjvMsO9pNoO/6oinSl+ZThuN0Ti2B8L9IsQki9cIJ6Dm39ar7AWA1QZdM63NRl9r7Hf7XDg4AVXRoPa/Tkf9r5bKvPFT4ZhQLunZUvzbK3PCTq5A2eUzMOr+8yXzdxGDv4MjLrm13MfXYfTvL0T1bYvlAo6x0FXlDcno1yXo615Yh8qbFmDMw+9g8Lfknhk8YApQgAL5K8AM4CE+Nz//+c+RSCTgdDrxxBNPYOFCqQfU1VTg9/Of/zz+4z/+A+985zuxfv167NmzB+eddx5WrlwJFTBmowAFKEABClCAAhSgAAUoQAEK2BGo+OhcM5swul4ygCcaMkdy38EoNS1R6DEpXSklUh3jy+B/1xQ7u2AfChSUgArgJuR6CKm2DF8WAWB1kGPldlhuByMxzCr3qYcytkSjlQeoW9f2Z+yT6UG9Ql6fupSQbY9JaeKkeRFHpn587NgEVNBO3dgokAsBzanDf/EU85aL7XEbFKAABShAgaEUYAB4KHVl25s3bzb3cNVVV3UL/qbv9rjjjsPy5cvxnve8B88995yZAXzxxReb91W56JFu3//+9/GTn/wEqlT1sTY1/7FqKvuZjQIUoAAFKEABClCAAhSgAAVyJ+AcX46qW05C23fWmOUpk0cMqJK0mrd7IDjRIsHfJ2QeTFX+2a3L3IaSGykZxGwUKDaBMof1vO4/hzfzUVthXSC1jcy9JPveZ321ZsT66pH5cUNFptXXLE55faobGwUoQAEKUIACFKAABXIowABwDjEzbWrr1q3mw4sXL860+OhjlZWVeOyxx45m/65evRqXX345HnnkETgcIzsPiSpNvW/fvqNjzcWdaDSai81wGxSgAAUoQAEKUIACFKAABSiQJlAm81ka0QTaf/IaIi8biKwx4JwqGcEyxa+RABJyTW5ir6wgsSet0o3ab50G99yatC3wLgWKR6DM6cBotwtHojHskSf9JJtZwBHpu7uLYarf0y+IUzLoVUsckpeVlFXXdHvB3MRBa7Pqwg0tbY5h61H+SwEKUIACFKAABShAgWMTYAD42PwGXDsV6PT7/QP29fl8ZsB3yZIl2L59O/75z3/ipptuwp133jngukPZ4a677sLXvvY1qBJhx9ouvPBCbNy4keWtjxWS61OAAhSgAAUoQAEKUIACFOhDoPyyGXAvqEPHz1+XIPARxN8A4ul9JdvX/45JqLhuHhyj+i5tm74K71OgUAUuGl2Ne/c14B+SbvsJ2LvA/ikJAEfkgE+vLkedBJD7ayqAq+aUje/uQGybJNXP6a/3W8uia63vWNRcomwUoAAFKEABClCAAhTItQADwLkW7bG9mTNn4pVXXsGmTZt6LMn8a319PR5//HGoIHBDQwPUHMIzZszAzTffnHmFYXhUXYmqylTnornd7lxshtugAAUoQAEKUIACFKAABShAgX4E3HNqUPeTs6DmJ42ua0SiQQraytyFzrF+uBePhu7n1wH98HFREQncNHUs7pMA8F8kqHuu3GYPkAXcKH3uNmszA5+eau+7kLIrZqDtu2sRfkoy7ifJ1L7+/rOA47sNRF8TZIeGsg9MKyJtHgoFKEABClCAAhSgQL4IcJKfIT4TKgCs2u9+9zs0Nzfb2tv06dPNTGCVEazaLbfcgvvvv9/WuuxEAQpQgAIUoAAFKEABClCAAhRICTjqffCdPxHlV86Cygz2njWOwd8UDn+WhMDCyjJ8YvIYqCl6v4wENkqAt6+2X5bdIn1apMN59ZW49DipnW6j+d89Ba55NUi2AoEHDSTb+95HbIeBwB9kufxXfvVsqAxiNgpQgAIUoAAFKEABCuRagJf85lq0x/auuuoqPPjggzhy5AjU/fvuu89W+ePTTz/dDBpfeumlSCaTuPbaa7Fz507zfo9d8FcKUIACFKAABShAAQpQgAIUoAAFKECBPgR+MG8ydgYjeKyhFTdKgHey9JOceLTJLSm3KrmpMOw+ualy6Qsq/Hho0Szbc/Nqkl1f+99L0PiJ55DYF0D7zw14TjHgmq1BV1Nsq/m3DwPR9QZim+V3ad7zJ6DiY/OsX0r03/iBAIJ/3YnwykNIyH01f7m6aMW9sA4+KVPvPZ3lsUv0qcHDpgAFKEABClAgBwIMAOcAsb9NXHzxxTj//PPx1FNP4YknnsDcuXNxySWXYPHixbjxxhv7WxXve9/7zPl/P/GJT5iB39tvvx26zqTtftG4kAIUoAAFKEABClCAAhSgAAUoQAEKpAm45LuUPyyeibNf3Ii17UHsTlum7jZ23dT9CV43Hj1lNmpc2X1lpgKXo+4+F63fWo3wcwcQeRFyy5AJ7NZRce0clH9kju0AsxpXMTUjaaDjV5vQ+dutEnHvbpQ4FERI3Z7YC/eiUai5/RTOVV5MJ5/HQgEKUIACFKDAsAlk92l22IZVXDu666678N73vhcbNmxAS0sL7r33XnNe4IECwErh+uuvh8fjwXXXXYd4PM4M4OJ6avBoKEABClCAAhSgAAUoQAEKUIACFMixwKTbxnfbososbfrM84hK8BdyXb17kdyO1+AYLd3k96TM2BXdbCDykmQBh6OYvu0N1N91Dhy13m7bGegXvdKN2u8sQXRjM0KP70FkbYPMvx2GJkFfx3F+eJeMhf/iKbJfa8qvgbZXjMtV8LflKy8h/Ox+qOmY3SfIbaGcC5XsK99SqjLaMYkLR1bJPMlrGtDwn0+j/ufnwDmBpbKL8fnAY6IABShAAQpQYOgEGAAeOtujW542bRpefvllcy5fFfwNBAIYN27c0eUD3bnmmmtw8skn44YbbsCKFSsG6s7lFKAABShAAQpQgAIUoAAFKEABClCAAl0Cbd9fh+jaRmiVUur5Cgk2jpHIY1pTgWDfaA2ek6z5eRP7OtHy5VWok8Cjpnfvm7Zan3fd82uhbmy9BTp+uckM/moSAy+7VINzcndfRx3gOEOCwicBwT8ZiO8Oo/nzL2LUvedB8zh6b5CPUIACFKAABShAAQpkFGA94YwsuX/Q6/XiZz/7GVpbW7Fy5UozGJzNXo4//ngsX77cnENYzQ9cWSn/18JGAQpQgAIUoAAFKEABClCgBAWMhGTqrWtE5x+2o/2XG9H5+zcQXnUIRkzN5slGAQpQ4C2B6KZmBB/dZWaXln+wd/D3rZ6SDFypoexKDVqFZAS/1iRliPekL+b9YxSI7+9E5+8kvVdivmWX9Q7+pm9e98m5kGC9Xi9Vond1mO/36ct5nwIUoAAFKEABClCgfwFmAPfvk/OlTqcTKoA72Hb11VdD3dgoQAEKUIACFKAABShAAQqUmoAK/Ab/sgMd92yWkq2RXoevlTlRftUs86Z5mSnWC4gPUKAEBQJ/etM8as9pklkqWb4DNb1Mg+9cyT79m2QD//FN+N85eaBVuNymQPCvO805f90LJR4/aeBzobnlXFwIBB6UcyHnseLDs23uid0oQAEKUIACFKAABZgBzOcABShAAQpQgAIUoAAFKEABCuS9QLIzhubPPo+2H6wzg7+6lAl1nwx4z5GyradKYEfmjzQCcXT8ahMarn8GiSMy1ycbBShQ8gKRFw+ZBmqeWbvNNVd6umQu2s0tSLT0vtjE7nbYr7tAeOUgzsU0yciWInjJIyHEtrd13yB/owAFKEABClCAAhToU4AZwH3ScAEFKEABClCAAhSgAAUoQAEK5IOAEU+i+UsrEV3dAK0M8F+swTUrPZhj3Y/vkQzhv8uckdva0PTp51H/62XQyySKw0YBCpSkQDIYR7ItagZzHbXp7xn9c2hOKRVdbyBxEEgcCMBR4+l/BS61JZDYHzD7qQt2smmOMZI43C7n4mAArhlV2azKvhSgAAUoQAEKUKBkBZgBXLKnngdOAQpQgAIUoAAFKEABClCgMATUHL9m8LccqPjPnsHft45BlRQtl+X6KGvOyPY7Nry1kPcoQIGSEzAiCfOYtcFcB9K1jhG1tlFyeDk+YMMw3pqnPct0lNT5S53PHA+Nm6MABShAAQpQgAJFKcAAcFGeVh4UBShAAQpQgAIUoAAFKECB4hAwwgl03r/VPBj/JRLcreo/i0/3aii7VPrI/+0GH9mF+CGWgi6OZwKPggLZC+jVbqkPr8GQtwEjYmS1gWSr1d1R781qPXbOLKBp8v5da1mmbDP37P1ossV6TK/39V7IRyhAAQpQgAIUoAAFMgowAJyRhQ9SgAIUoAAFKEABClCAAhSgQD4IhF8+DEPm/3WMkyquU/sP/qbG66iTLGE1h2fCQPjZ/amH+ZMCFCgxARV0dJ8gE4ZLi71h/+DjhyRbVUoO63VeOCZI6QG2nAh4Tuw6F9vsby7ZLqW41dTBbh2uOdX2V2RPClCAAhSgAAUoUOICDACX+BOAh08BClCAAhSgAAUoQAEKUCCfBWKbrNQv1wx7wd/UsbimW/1jm7tSx1IL+JMCFCgpAd/bJ5nHG14hQd24vSzg8DNWP98FE6GCyGy5EfBdaJ2LyEoDybDNc/Gc9JP/fOeMg+7NsnZ0bobNrVCAAhSgAAUoQIGCFGAAuCBPGwdNAQpQgAIUoAAFKEABClCgNASSLWHzQLWK7I431T/RbK2f3drsTQEKFIuA/+LJcE6uQLJJlYWXIHCy/8Bj6Nkk4m8CWpkT5VfPLhaGvDgO79uOMzOyjYCci4fVnMD9n4vIqwai62XoLh0V183Pi2PgIChAAQpQgAIUoEChCPDSuUI5UxwnBShAAQpQgAIUoAAFhkggcTiI8KrDSBwMwIgm4RjlhfukUXDPqRmiPeZ+s4aU+o2ub0R0YzOSEvDT/C44J5bDu2SMzBnryf0OucVhE1DnUjUjkt0uU/31Mmv97NZmbwpQoFgENKeOmm+djsaPPYPYpjg6paSw70LAOa57Zm+iRUrG/9tAbIscuSyq+fqpcNTw70eunwfKteHapxHfGUHHPQb8b5dzMbn7uUh2yLmQzN/oOmvv1V88yfybnuuxcHsUoAAFKEABClCgmAUYAC7ms8tjowAFKEABClCAAhSgQD8C8d0daPvZBkSeP5ixl8qYqvzk8fCeJZOv5mkzDEMyunah49ebkGzMkOkpNY/875qCio/Ph0PmcmQrPAHnZGv+zcQ+lSnWPUjQ39FY/SWwMCnL1OH+NsplFKBAQQq4plWi7o6z0fyFF5HYF0bnbwzotQYco+Vw5O9EslmmDFfzzErTfA7UfO1UeM84znqA/+ZUwDHGj/pfnIOmW+Rc7O1E5wNyLqrlXIyR3ci3lMlWORcH5L56y3dqqP7SIvgvniK/sFGAAhSgAAUoQAEKZCPAAHA2WuxLAQpQgAIUoAAFKECBIhEILT+A1v/3MoxwQkoryn8zIF++SnBNffkqWVCxbYAKEDd/YSXKPjgTlZ9akHfzIKqxt9z+smQJqW+K5Tv8OjmO6fLlfZUch2SLxvcbkmGkSn7uQviFQ6j93hlwzy2crOYieaod82GoIEwb1iL2hjw32yRQoM7vAM2ISubYBquTKjnKRgEKUEC9/49+8AIJOG6Tvws7JegbNQO/KRkV+PWdPxEVH5srgWF/6mH+HAIBdWHOqPvPQ+Ch7Qg8/KZ5AZcK/B5tbh3es8eh8uPzJPOXF/EcdeEdClCAAhSgAAUokIUAA8BZYLErBShAAQpQgAIUoAAFikEgsq4RLbeukhQbA64FkC+8Nehl6UE1DcbbJYD2KhCScpiBh94wM6IqJYs2X5rK/G35xitm8FeTxF7fRRrc89KPQY1UQ6LZQOifEgjeFUbTZ57HqN8sg3O8lVGaL8fCcfQv4Bjtg+/tExF6Yi+C/zDkggQ5s3rPc919G6EnZW5JmWPSfUKdeeu+lL9RgAKlKqBXuFF5w/GouH4+YltbJOs3aP4t1OV9RgWINbejVGmG/bh1rxMV18xB+UdmI/5GG+IHZBqKSEKmofDBJedC9/Ery2E/KdwhBShAAQpQgAJFJSCFbtgoQAEKUIACFKAABShAgVIRMKIJtErWrAr+ek4Dyi7RewR/LQkVYPOcqqHscgm0yf81dN6zBdHNLXnDpIKB4af3Q5PpGcuvyRT8tYbqqJVjuEqDc6ZUk2yPovW/VufNMXAg9gUqb1gAXebijO+QjO4/SXA3rGqD9m5GXEqCP5ZEdK0s8zhQdcuJvTvl4SPxpjDi+zrzcGQcEgWKU0BzqL8btfJ3cIx1W1jP4O8InWpN0+CaVQ3f0vEyH/AkeBaNYvB3hM4Fd0sBClCAAhSgQHEJ8HK64jqfPBoKUIACFKAABShAAQr0KxD8+y4kDofMufa8kvk7UHNNl0Dw6QYiL8KcZ7fuB2cOtMqwLFdz/qrme7sGR33/x6GC2WXvBdrvkKzmtY2IrGkwv2AeloFyJzkRUFnAqoR302efl/LkMfNcuhcZcE6V7HVJ6DYkiS++Vyp/r5HgcJvsUsqH1nz9VLhmVudk/0Oxkc4/SunTB9+wMhDTdqBVuc0ytJU3nwBd5zXbaTS8S4GcCERWH0HgLzsRefkwjI6YuU1NLhhxLx4F/0WT4T13fN5NeZCTA+dGKEABClCAAhSgAAVKSoAB4JI63TxYClCAAhSgAAUoQIFSFwj9e79J4DlDs/0Ft2eJhshKCQK/dBjJzpgE3GTS4BFs0S1StnN/AFqlzPkrJaztNM0j2V6L5RhWqLLW+xgAtoOWZ33c82ulhPe5aP32GkQliB95QQK+L/TOBHbOqkL1lxbn7XzP8eYwGv/zaSTlQoyjTV5SmlSeNcJya4siKHNihuRijdofnQnPSaOOduMdClBg8ALJQAyt33j16Lzx5pbcqqS8eu0l5EKnQ+bNJe81tf91mlwoxXmAB6/NNSlAAQpQgAIUoAAFRlqAAeCRPgPcPwUoQAEKUIACFKAABYZRICbBU9Wc0+zvVPdJlu04Q4KuBmJvtsEjpTJHssW2tpq7d02VL+6ldKTd5pomgewVcgxdBnbXY7/8EXBOKEf9HWdDzWMdfnofYjJvZLIlAl2yZp1TKuA9Zxw8S8Zm9bwYzqNTwd+G9z9uznMJCTx5T5fSp3IRg6PGeh4nQ+r5CYSfV5nMCTR9cjlqf3im9Bs7nMPkvihQdAIq+Nt4/bOIv9ku5eHltScXNrnltadXdb32gvLa22y99mIbm9EgF2nU/0rmjB9XVnQWPCAKUIACFKAABShAgdIQYAC4NM4zj5ICFKAABShAAQpQgAJQ8/8awbhEm+RLbwnqZtNUmd2ErKCCbSPdUmPQZEzZtFT/1PrZrMu++SXgObEe6lZoremjT5vBX71G5t++Ui6skDmq05t6XXpOkgrW84DAnw0JVgHNn38RYx97l2TeS8SYjQIUGJSAyvxVwV+9TuaNl9eeXt3jteeX195iqSox35pnPL4rguYvvIhR954HzclS7INC50oUoAAFKEABClCAAiMqwE+xI8rPnVOAAhSgAAUoQAEKUGD4BDS3RH498r8AEsk1Yr1L5/Y3ElWaVjW9YmTLP6ePITUmc2A2/kn11/LgGGwMl12KTCDwlx0y36+UfZaXUKbgb/rhqpLlZZdKkEpVf44baLn9lfTFvD8EAvG9nej8w3a0/Wi9lBlfjXaZZzys5oiNJ4dgb9zkcApEXj1iln3WJPM3U/A3fSy6V157l8lrr1ZeehIwDv51Z/pi3qcABShAAQpQgAIUoEDBCDADuGBOFQdKAQpQgAIUoAAFKECBYxdwTq5AfFsb4nslDmWzDLQhAaj4AWvfzkkVxz6IY9yCOgbV1DFk0xJd/V1TZPJgNgoMs0Dnb7eZe/ScLkn4PTJ/Mw1Fc2nwnSeZwA/J3NWrDmfqwsdyIBDb1Y72/9kg85wfyrg1vd6Liuvmoew9UzMu54P5LxD46w5zkJ4zemf+Zhq9ugDDK6+94B8NqHXLLp2eqRsfowAFKEABClCAAhSgQF4LMAM4r08PB0cBClCAAhSgAAUoQIHcCnjPGmduMPKq/Qzg6GuySkwCxnNr4Bjly+2ABrE1t5T+VVm8ySMSBN5j7ziMpATRVlt9vWcdN4i9chUKHJtA4mDA3IB7QffSs/1t1SlxJ80vPRLy/F0jT3i2nAqEVxxA47VPm8FfxXwBNHwSOj4nt6vk/hR5LNkYRtu316Dl/74klROYDZzTEzBMG0tdQOE+3v4OXTPltScZwyoLONEomftsFKAABShAAQpQgAIUKDABBoAL7IRxuBSgAAUoQAEKUIACFDgWgbIPTJeAklOygIHo6wMHTxMtBsLPWP3KPzzrWHads3XVfIzlV8q389KC/zBghAc+jvByA8kmybycUA7v0vE5Gws3RAE7AsnOqNRdl54Oe9m/qW1qmswTrMpAS4ttbbXu8N+cCEQ3NKH5KxLUDSdwoQR7fy8n51a5XSrBX5lxGdfJ/XvgxFflvgoOh57ch7bvrc3JvrmR4RNIdsZgBOIy/YFMYVBl/+ILTZds4a5pxhOHgsM3YO6JAhSgAAUoQAEKUIACORJgADhHkNwMBShAAQpQgAIUoAAFCkHAUeNB5U0LzKEGH7GyYg0jcwA1vt9A5wMSYJXkJ5U161s2IW8OsfzKWXDOqDKDumqMKlCdqRmSORl6OonI87LUoaH6SydBBZDZKDCcAsloV+boYJ56Xesw+zR3Z0zN69vy9Vclqp7E+yX4+2UJ9lbKz0ztXAkA/1iWS/wQwUd3IfziwUzd+Fi+CiSs1552LK89+TvCRgEKUIACFKAABShAgUIT4BzAhXbGOF4KUIACFKAABShAAQoco0DZe6chcTiEznu3IPSYgagktblPkOyo0VLyUv4PIdkicZEthmQcWjtSJZerbz/1GPea29U1rwO13zsDTZ9egcSeTnT8woD7eEOCwpK1JVP8GhGpmrtfspzXS+avSpxUwd8vL4ZnsRwkGwWGWcBZ67X2KKXUkx0G9IrMwcZMw0o2W486p3Pu6kw+g3ks9K+9SOzrxCRZ+QYJ8A7UZkpw+Drp9zMk0XH3ZnjPYBn5gczyZblW6ZY/cLpcyJREMiSvPZ+91566MCr12suHqQ/yxZPjoAAFKEABClCAAhQoHAEGgAvnXHGkBSyw55vy7SMbBShAAQpQgAI5FZh0G8v4Hgto5fXz4Zpehbb/eQ2JQyGEDmXIcJIvzcuvmImKj8/Ly6xZ51g/Rv16Gdp+/JoEsndLsNcK+PZ0cU6rRNXnT4JHAtlsFBgpAb3OKxnrYcQ2SzVam9dTxA9KEKpNRiwxK8+SsSM19ILfb8//H3vvK9vxdzmqyyWo6+gj87fnQb9b+v1GHgxuasELX9mBiT6VEzz4xr9hg7fLZk1VRt2zaBTUPMDma2+RvbUTe+VCIpm22yF/Z5zjyuytxF4UoAAFKEABClCAAhTIIwEGgPPoZHAoFKAABShAAQpQgAIUGE4B3/kTzNLO4RUHEV55CImDAagys456H9wn1cN37njz/nCOKdt96RVu1Hz1ZFR8ZLaUet6P6MZmydoKQytzwanm+5XS1Z7TxkDN58hGgZEU8F00CYEHtkkJYQMuqcI+UCaiykAM/9u6MMM1pwa6PnCm6kgeXyHte1170BzuYpvBX9XZLX0XyE1mDYZa/1gDwIXkVehj9V802QwAh5+XShHz5XoKT/9/D4ykTB3wjPXa88m6bBSgAAUoQAEKUIACFChEAQaAC/GsccwUoAAFKEABClCAAhTIkYDmcUAFgtWtkJtzUgUqrplTyIfAsRe5QNUNCxB8eAeMzjiCfzJQdnnfgSgV/A39y0B8l6BIrKrm6zZThovcMFeH1xCVWtzSarLcYG1X/8au9bNcnd1HSMArf99cv39DMoBbEHhYXnuXysvKnTkIbAZ/ZWoElQGs13pQftXMERo1d0sBClCAAhSgAAUoQIFjE2AA+Nj8uDYFKEABClCAAhSgAAUoQAEKUMCWQN3Pzkbjx55GfDfQ8WsD3vMA1ywJRqVlqMf3S+bv0xL8lT6qVX7qBDOb3fqN/+ZCoNblxMFIDO2ysVFZbFD1V61G1s/HlgzGJdP1EKIbmpBoDEuWuROO8WXwnnkcXDOq8nHIwzImVQa65r9OQ+NHn0F8RwTt8trznGjAiMqc3OqkJiXYWyGvQ6n0HN0iv+6Tx1w6ar+zBLpUk2CjAAUoQAEKUIACFKBAIQrk5/+1FKIkx0wBClCAAhSgAAUoQAEKUIACFOhHwD23BnV3noOmT61AsiVpZgJDppJ1jJJys1LhOdki8452dG1AEhQrP32COQ93P5vkokEIzKvwmQHg16Sc83k2y0AnpO8Guak2r9w3iL0O3SpGwkDg99vQcd9WyTC3spvT99bxi41wLx6Fqs8sLNlAsPO4MtT/cikab1yO5OGQXGSRLtT9vlbmRN0P3wb3grruC/gbBShAAQpQgAIUoAAFCkiAkwgV0MniUClAAQpQgAIUoAAFKEABClCgsAU8C+sx9ol3S/avlF2XLENEgIRkHCb2dAV/5SHX/FqMfvgdDP4O0am+ZIxVzPlhlfppsz0twV+VLDpHgr+z8igAnAzF0XzLC2i/43Uz+OuQp5V3mQb/+zT4LtbgXiSZrRKvjq5uQMPHnkHo2f02j7j4uoWXH0DySMg8MK0S8JwO+N8tVpdo8Jwl12DUW8dsBKRM++O7oUqxs1GAAhSgAAUoQAEKUKBQBZgBXKhnjuOmAAUoQAEKUIACFKAABShAgYIU0L1O1H7zNHPs0S0t5tykRjQB57RKM1NT13mt9lCe2GsmjsK3tu/HZikD/b8SBL5CpV/30w5J8PeOrmDxl6eP66fn8C5SAcrWr70iZZ8Pm+WLVSDTNa3H3LYnaTDOlTmlnzIQXZdAy1dfguOOc+A+obSyW4OP7Ub7TzdINFwC5OdIwPcMuetIt9LgPVuMXgNCMgdw8C87pSy0G5WfOH54Tyr3RgEKUIACFKAABShAgRwJ9P9/OTnaCTdDAQpQgAIUoAAFKEABClCAAhSgQG8B95walL1vmpnt6z1lDBj87W2U60f8DgfuXDDV3OwvJLB7DxKId5V37rmvTfL4p2R5myx456hqXDW+K020Z8cR+D305D6EnzsAzQuUfyRD8LdrTJpXslzfpcNzqjwQN9DyzVdhxO1nP4/AoeV0l4mWCNq+v87cpu+dEug9S+sR/LV2p+YK9izUUPZBCQzLt2Wd929FbGtrTsfCjVHgWASMpIGEZLHH3mg1f6rf2UZGQF2Ak2iUc7G9DfFDwZJ6Tx0Zce6VAhSgAAUGI8AM4MGocR0KUIACFKAABShAAQpQgAIUoAAFCkJg0m3jM4xzPKr+7EfbD9bhfgmiPClB3gskPXSW3CSeioNye0GCv6u6AsPuhXVY+4MzMbnMlWFbI/NQ5282mzv2XaDBUZuezZp5PN7zNcTelKDF3k7JCN4H/zsmZe5YZI8G/nc7jGAczplS9nnRwE6uKRIIPs1AZCXQcc9m1H5nSZGJ8HAKTSC+twMdckFCePlBGO3Ro8PXq9ySuT4O5R+eBefEiqOP887QCSSOBNH5wDaEntmPZFP46I40vxPeM8fKuZgN18zqo4/zDgUoQAEKUGAkBRgAHkl97psCFKAABShAAQpQgAIUoAAFKECBEREoe/90OCdXoO2H63FwRzvuN4O93TPqNLeOsitnoeJjc6E586eIWmxXO+K7O6D5Zc7oE+zxaboENiULWJU4DstcwKUSAFbHqpr39IGDvylJz2malNYWp5VSADyckCxrR2oRf1JgWAU6HtiKjrs2ykTx1nuTVi7ly+V1bwSBZFsUwUd3IfjP3ai4fj4qJPjINnQCgUd2mhcNIWpVUFDnQZ0PQ+LARnscqiqDurim7KpZqLzheKj3XDYKUIACFKDASAowADyS+tx3yQhkvuK8ZA6fB0oBClCAAhSgAAUoQAEKUCAvBTyLR2PUA+cj8uoRRF48hPj+AIxIAo56rzlPrsquc9SqnOD8anEpO6qac7IEIKR0sd3mnGL1jL1prW93vULtp0pdq0C5KunsmGj/KPRyDXqdgWSjrL+vE64ZVfZXZk8K5Eig7aevIfDgG/IiB9yLJINdLkxw1L31ek80Sab6SzJ39VoDHXe+jmRrBFU32bwiJEdjLJXNdD64zZpHXA7YNV8uKDlDzsWYt85FslXOxatyewUI/G6bvHeEUHO7qrvPRgEKUIACFBg5AQaAR86ee6YABShAAQpQgAIUoAAFKEABClBghAVUlpb31DHmbYSHYnv3KvNPNZWBlk1L9U+tn826hdg3dZyaT6yyzMbTyyTDslFlWUYK8dA55gIXCD29zwr+SvJ52aUyx/fMt4KNqUNTwWD/RbJshoHAw3KTYLH7+Fr4lk1IdeHPHAhE1jag/WcbzC353m3NFd5zs3q1Bp+U2XfNMtD5kIHQE3slUFyL8stm9OzK3ylAAQpQgALDJsAA8LBRc0cUoAAFKEABClCAAhSgAAUoQAEK5JuAYUgG3fomKwP4QKdZ8tdRJxnAC+vhfdtx0Cvd+TZkqLk/VVNlYLNpRsjqnVo/m3ULsW/q3KnjVuc5m2zpZJetXuUpxEPnmAtYQGWuHw04Xpg5+Jt+eK5ZEny8QMq7P26YWares8blVcn69LEW4v32/3lN3kAkA/ssuS3sHYhPPybnJAnKXwIE/yhZ2b/aJAH6ydDzaO749LHyPgUoQAEKFL8AA8DFf455hBSgAAUoQAEKUIACFKAABShAAQpkEIisb0T7j9YjtrW119LgI7ug+Zwo//Asuc3Oq4CKc5pVkji+J7vAZnyXdZiurvV7HXSRPaC5dDgmlSOxpxOJvVIye5K9A0wGVPln6StzQDsmSCowGwWGUSCyugGJg0EpQ26Vfraza/dimOWH1XqRNQ0FVdHAzvGNVJ+YlNuPbWmFJm8DquyzneaeLXOITzLkfSeG8HMHzCCwnfXYhwIUoAAFKJBrAZkFhY0CFKAABShAAQpQgAIUoAAFKEABCpSWQPDRXWj65HIz+KtVSGbXEsD/fg1lV0g2nWTdOadKcDUUR8cvN6Hps88jGYznDZBrWqUEJsthBIDY6/aGpTJgIy9LGps07znj7K1UBL1854w3j0LNlWq3mU7S3XvaGOhe5k7YdWO/3AhEXjlibsg1T0qX25zjW/VzzbX2H+1aPzejKe2tHD0Xs+RcuOwFgJWYe57VN7V+aSvy6ClAAQpQYKQEGAAeKXnulwIUoAAFKEABClCAAhSgAAUoQIEREQivPITWb68GEoYZ+K38pAR9z9PNL+3VXJueUzWUf0iXzF8NWjkQfbUBrbe/bJYRHpEBZ9hpxbVzzEdDT0qmWevAwc3w01ZWq2N8mQS4J2bYYnE+VPbBGZLJ7ZBAv5zH1wZ2iu+VQPkqy6L8Gsu4OGV4VPkqkDxi1R9Xc/xm0xz1Vv/E4Sxrw2ezkxLrm+g6F3qXrd3D1+utnokjXXX37a7IfhSgAAUoQIEcCjAAnENMbooCFKAABShAAQpQgAIUoAAFKECB/BYwwgkJ/q4x53T0LrUCv5ozc6DFOVkCwVdLENgHhFccRPipfXlzcL53TILnzLHmPMCd9xqI784c3DSiBoKPJxFZKUN3aKi+dXFelbMealBHrReVn1lo7ib4qIHwSgNGMrNV9HUDnQ/KsgRQduVMuSCgdqiHx+1TIPcCNrOGc7/jYtxi19+GzG8ZxXjAPCYKUIACFCgiAdaxKaKTyUOhAAUoQAEKUIACFKAABShAAQpQoH+B4D93I9kQguM4Kft8Zv991VJHrQbv+UBIgocd926B74L8yJ7VdA01XzsVzV9ciajMGdr5gAHnFLlJBrOupgiOAfEDBmKbJNYtpaLVfLY1Xz0ZnkWj1GGVVCt7z1QkmyPouGsjwv82EJX4v2ueAcdoCe5IakSyWbg2Syb1IYvFd9FkVN64oKSMeLD5I+AY4zcHk2hUUcfMF6dkGq3VX96zRssVK2w5EXCMsSyTWZ6LZIO1+9T6ORkMN0IBClCAAhTIUoAB4CzB2J0CFKAABShAAQpQgAIUoAAFKECBwhUIP7ffHLwq82x3fk23xALDT0lAdUc74ns74ZwodaHzoOllLtT9+G0S/N0qt22I74rLrXeqmmtBLapuPhHuOTV5MOqRGUKFlHN2za5G24/XI7GnE5EX1Di6W+m1HlRcPx8qYMxGgZES8JwyGp2/3WZevOE9x7D1PqXm+FYXe6im1mfLjUDKMrZN3i1ici5szgMc3WS9t3hOHZObgXArFKAABShAgUEIMAA8CDSuQgEKUIACFKAABShAAQpQgAIUoEBhCsR2tpsDd062P36VbeuYIGWW35BMUVk/XwLA6gg0p46Ka+ei7NLpCL9wSOa5bZKM1jA0r0PGXA7vGWNZyrjrVHuXjJX5nccgurYBkZcOI35Q5kqVeaBVxqR78Sh4ZZlyY6PASAq4JUtfzdWd2B+Q+cdVQHfg0ah+KpNdrafWZ8uNgGt6lVQLqJHgegvCzxvwLRs4IzuqqgnslffmKje8Z0mpCTYKUIACFKDACAkwADxC8NwtBShAAQpQgAIUoAAFKEABClCAAsMvkGyLmjvVrCqrtgegd/U3uta3veIwddQr3PDLvMDqxta3gCbzIHtOHm3e+u7FJRQYOQF1UYcqQd7y5VUIPSlZpxVSwX1O34HH6BbD7KdGXHnTgpKa43s4zlLlp05A0w3PmVUD9CpDyuj3fS5iUoEh+IiV/Vv58flQVRrYKEABClCAAiMlIDOdsFGAAhSgAAUoQAEKUIACFKAABShAgdIQ0Ks95oEandkdb1LNoytNr3Zbd/gvBShAgSES8C0dj/IPz5a0XiD4JwkqPppEoqF7yXL1u3pcLVf9yq+eDd8544doRKW7Wc/CeqggsGqhfxoI/Ckp1QN6nItmORdPJBF4UB6X+dfVPOJl759Wumg8cgpQgAIUyAsBZgDnxWngIChAAQpQgAIUoAAFKEABClCAAhQYDgHXjCpEjoQQ2yWlVU+0t0dDygTHpaSnak5Zn40CFKDAUAtU3nA89Bo32u98HdH1hnnT/JIRLNUIDKlerm5mc2pQfcuvnDXUQyrZ7ZdfMROqykLrd9citiUhNzkPXrnJdPBGSG5dFwhBkoPLPzLbnEu8ZLF44BSgAAUokDcCDADnzangQChAAQpQgAIUoAAFKEABClCAAhQYagHfsvGIvHhI5oA14F4o8zRqfZfzTI0lulbuRQDX7Go4jytLPcyfFKAABYZUQAV1vZLV2/nAVoSfO4BkS+Ro4Fev8ciycWamsHMc35eG9ETIxv2S1es5dTQ6f7cNoaf3IykXEhlha69ahQvetx2H8v+YDde0yqEeCrdPAQpQgAIUsCXAALAtJnaiAAUoQAEKUIACFKAABShAAQpQoBgEfG+fhI57tiBxIIDwvw34zu8/AJw4IvNrPm2V+6z46NxiIOAxUIACBSSggrvVX1wE4wsnmQFgNY+5XuWW7GCPrQtYCuhQ836ojnofqj690LwlWiPm+dAl+KvXeqHp/f8tyfuD4wApQAEKUKDoBBgALrpTygOiAAUoQAEKUIACFKAABSgwsgJGXObH29WBRFNYSiQ6oL68dozyjeyguHcKdAloLh3VXz0ZTTcuR2SVASOShO88TZ6rvb+8j21Vc2xK8Dcqczq+YxK8Z42jIwUoQIEREVDVChwSaFQ3tpEXcMh88urGRgEKUIACFMhXAQaA8/XMcFwUoAAFKEABClCAAhSgAAUKTCAh5RA77t2M0FP7YHTEuo1ezZtafvkM+C6ezCyZbjL8ZSQEPCfWo+Ybp6Ll9lcQXZtEbLMB11wDjrESCHYByVYgts1A4pA1OlVmtfrLi0ZiqNwnBShAAQpQgAIUoAAFKECBrAUYAM6ajCtQgAIUoAAFKEABClCAAhSgQE+B0NP70PqNV2U+vIS5SK+BlKcEDIkDJ44A8e1taP3WagQe2Yna/17CDKaegPx92AV8yybAObECbT9ej+jqBgkEqyFYpZ5Tg9Gr3aj46Dz4PzCNpVZTKPxJAQpQgAIUoAAFKEABCuS9AAPAeX+KOEAKUIACFKAABShAAQpQgAL5LRB6ci9a/u/L5iBdcwDvUilTWf9WOV0jYSC2BQjJfKux15vReP1zGHX3MuiV7vw+MI6u6AVckple/7OzEdvRjvALB815gY1IAo46L9wn1MFz6hhoHkfRO/AAKUABClCAAhSgAAUoQIHiEmAAuLjOJ4+GAhSgAAUoQAEKUIACFKDAsArE93Wi5Zuvmvv0nqvBe8Zbgd/UQDSHBvd8wDkVCDwoZXVlHZUNXPudJaku/EmBERVwTauEurFRgAIUoAAFKEABClCAAhQoBgEGgIvhLPIYKEABClCAAhSgAAUoQAEKjJBAx682AdEkXAsk81eCv4kWyfLdLCWf9xgwOmVQMp+qKgXtmqHBNQsou1xD+y8MhJ87gOhrTWaW5QgNnbulAAUoQAEKFIRAZH0jws/uR+zNdiTbItCrPHBNr5SKG+PhWVhfEMfAQVKAAhSgAAUoMLwCDAAPrzf3RgEKUIACFKAABShAAQpQoGgEkqE4QvKFNCTp1/s2IPhYEtE1cnjdp1FFYi8Qe82AVgX4LtTgOQWIvKD672YAuGieDTwQClCAAhTItUB8dwda/3uNzFHe2GvT0VeOIPDQdrhPqkf1lxbBOamiVx8+QAEKUIACFKBA6QowAFy6555HPkICe74pX5DZaJNuG3+0l911jq5wjHcGs+/BrNPXMFPbSj/uTI/1tX7q8WNZJ7WN9J+ZxqOWpz+e3l/dT41B3c/UL3256qNapn7WksH/m74fu9tPXyfTnlPbsdsv0zbUY+nrZ9pm6rH09VPrpC9LPZbeL9Py9MfS+9q9n2k/mdZN30/6OumPp9ZLX556LFO/1DL1M7XOQP3srpPanuqfzTZT2z+W9QezbjbrpPr2dVwDLU8do92fqe2l9x+ufafvM5txpNYbzDqpddXP1Prpx5t6LL1f+vLU45n6pZapn4NZJ3193qcABYZGQM3nq7J/9bESzP0zkDgs+5FgsMoGds3SoFfL7zF5/JAEfNcZSB6Rfn804D7ZGk9kTcPQDIxbpQAFKEABChS4QGRtA5q/sFKqacSg+QH3iTKVwmQNWplcZxWQShu7DQkMy59hCQ43fPQZ1H7vDHhOZDZwgZ92Dp8CFKAABSiQMwEGgHNGyQ1RoG+B9C+t07/gTj2e/lhqK6ll6vf05emPp/qmlqcvSz2W6qN+Zlqe6bH0ddK3k943vU/Pbfdc1tfvfW07tZ/05X1to+fjmdZJfyzTtlOPqW2l3++57fTfB+qX2mdf/QZanr6vnvdT66rHM20/tTzTsp7b6u/39PUzbTPTY5m2l+qnlqVvM9XX7mOp/unbGWjbx7o8tc++tpN6PNMxpJaljze1PfXT7vJM207fZqbtpD+Wvs9M20r1zbQsfd1Uv4H2rZan901tI7X9/pb1XDe1Tmob6cszLUtfnr5O6n6mfatlfW0rtV6mn31ty872+ls3fV/p/eyOcTDrpO8z034G2mb68vRtpe4PtM1Uv/SfmdZJX877FKBA/ggkGkLmYIx2IBmUUs+1VolnR333eYCdk+SLa8n6jb4ChJ6UL6ytKYOR7Fo/f46II6EABShAAQqMvEB8fyeav2gFf11zAf+7JPDr6f631TVdg/dMA8G/q6kXYhIsfhGj7j0PznESIWajAAUoQAEKUKDkBfSSFyAABShAAQpQgAIUoAAFKEABCgxOwGn9L6UhwV9NKk+WX62hZ/A3tWFNk9LPp2rwvfOtL7AN51v3U/34kwIUoAAFKFDqAu0/eQ1GR0yqaUjw9/29g78pHxUUVstVP9W//cfrU4v4kwIUoAAFKECBEhdgBnCJPwF4+MMvkJ7VlClrKn15anSZHkstUz/7W97XskyPpx5LH1fqsfT9DXQ/0/qZHhvMtgfad/o2U/v8/+zdB3wc1Z0H8N9sL+qy5N4LrhTjggsY2xQfJVSTkNBTLpwDBBIuBZKDUEJCDpLckZBcgBBIIAkECIRuim2aAWPj3m25qndt37n/m9XKK1ll11pJu9rf+7BsmTcz731nZ1fe//zfa++1rrYTXbejeu1tM/a16OPY7URfU9uMfRzdR7Rue8tUnejyaP2O7qPrx1u/o+3Evn4s24x3/13Vi+47tj3Rx50tU3USWR5tR3vrtPdatA3qPrquehytG71Xr8WW2Lqxr7d93NH68dSLd121rWjd2HZFX2u7r7bPO6oXfT12m7GPo9uJ1os+V/ftvRa7bnR57Gux67f3OLpOe8vUa9FtdVWvvfXbWye6vfbqJ/Ja7Lbb22bs8uh2Y1+Ld53YerHrd7bN9upF6ydyH7ud2HZEH8cuT2S7rEsBCvSegGWwjEnZXNTcvqasrgO69ukaAht1GbpSMoYd/Cdp1I/3FKAABShAASWg5v31rjwkQ2cAznMl+CsXUHVW1HLnuTLjwh7dWE+tbxnJ+YA7M+MyClCAAhSgQCYIaLqUTOgo+5gaAtOnT8dnn32GCy+8EM8991xqNKoXWhE6b04v7IW7oAAFKEABCmSWQDRQnFm9Zm8pkFoC/u01qLhqObQsIOemrn+kjrbev1mGrHxWh3mgEwOfPyf6Mu8pQAEKUIACGS/Q8ORW1D20AbYTJPv3/PgHb2x6MQy/JADnLJuKrCuOy3hHAlCAAhToTwIHTnmmP3Wny75ceeWVePLJJ/HEE0/giiuu6LI+K7QvEP9fEe2vz1cpQAEKUIACFKAABShAAQpQIEMFQgcajZ5bhsoQ0F1kKMUSWYZFnum+UOzLfEwBClCAAhTIeIGAZPCqYh7WeeZvW6ho/WBJQ9tFfE4BClCAAhSgQAYKMACcgQedXaYABShAAQpQgAIUoAAFKJAMAb0hYGxGcyS2tWj9sCeY2IqsTQEKUIACFOjnAnpD5Lsx+l0Zb3ej9cPN383xrsd6FKAABShAAQr0TwFOuNQ/jyt7RQEKUIACFKAABSjQCwK+NeXwvn0A/q3VCFf7YMq2wTIqG47ThsBx6hBo5sQyN3qhydwFBZIqYMq3G9sLR5KV4t52tL45P8HIcdx7YEUKUIACFKBAegpEv1v1BL9bo/Wj66dn79lqClCAAhSgAAWSJcAAcLIkuR0KUIACFKAABShAgYwRCB5oQM29a+CXAHBsCaERgc3V8LxSAsvIbOT+YDrsJwyIrcLHFOhXAtbj8oz+BPcBekCHZo3voofgrgiDdWJ+v/JgZyhAAQpQgALdFbBNykfTc0Bglw77rPi+V9U+Azt1Y9c2frd29xBwfQpQgAIUoEC/EOAQ0P3iMLITFKAABShAAQpQgAK9JeDfVIXy6942gr+aE7DPB7Ku0pD9HxqyrtXgOEODSWJaQZm/rXLZCjS9LpExFgr0UwHzACdsJxTKr86Ab3V8ndRDOnwfRn6kdi6WyYNZKEABClCAAhRoEbDPHwxYTQjulL8nD0e+L1sWdvBA1VP1YTPBfqqsz0IBClCAAhSgQMYLMACc8W8BAlCAAhSgAAUoQAEKxCsQqvCg6j8/gF7nh2UCkLNMg/N0EywjNJgLNFiGSgD4FAkGX6/BPke2KoGumrs+hn9DZby7YD0KpJ1A9tcnG232rpAfn0s6/6Fa13V4/qUjXANYxuTAsWhY2vWXDaYABShAAQr0pIBZpldwLx0rQ2sATf+Q70xP59+t4SbdqKfa5L50LMx5kekZerKN3DYFKEABClCAAqkvwABw6h8jtpACFKAABShAAQpQIEUE6h7eiHClV+b5VT+wadAc7Q/Lp5kkMLxYMjBmS8ODEgS+/zOowBcLBfqjgP3kYri/NE4ueAAa/izZvZ/o0MNHv9/DtToa/6bD/znk3DEj/46ZUOdKJheVDa0uEPG8sQ9Nr+wVuzL5oT+YySTsOwUoQAEKiIC6uMoyIRfhKvlufbTjC6zUhVcNj0mQWOqp+tGLslIVUQ+G4VtXYYyQ0/RqCXwynYrukz8gWChAAQpQgAIUSLoA5wBOOik3SAEKUIACFK0bEhQAAEAASURBVKAABSjQHwVC1T6Z23cvIJdQOs+V4G8cgSvHQg3+zfKj3bZa+D8uk3ncBvZHGvaJAsj51vHQ/WHJQNoFz6s6vO/L6JXjdJjyNGNu4NAhuRZit0DJb7xathUF982BdXxk/uBM5AvX+9Hwp61ofGE39HoZPzu2yPCdztOHIvsb8uP/0KzYJXxMAQpQgAIZImByWFD43/OMkWcCm6vlO0OHebAOy0j5HnXLd2uj/H0pf5aq71dVrDJvcMH9c6HWS8USqvFJIHszml7eK21vfaGTuijMccYw5EjQ21zsSsXms00UoAAFKECBtBRIzb8K0pKSjaYABShAAQpQgAIU6M8CvvcPA2HJrpBER3N+fFmLmkWT+VElI3Il4F11iAHg/vwGyfC+aWYNebeeBPvMYtT9dgNCJQ0yT7ZCickEltPGefZwZH9zKiyDMvcHXv+WauMH/XC5x3jXmAbIZ0qxPDTLR4xkcIUOhuGRucM97xxA/u0z4DxzuFGP/6MABShAgcwSMA9wYsBvF6DhL9tkhI1tEuwNNgd8j3y3am4Lsq6YgKzLJ0CzyxdJChaV8Vv9/Q9k+ge/0TqTfOeZi+Sh/F0QlllSQodC8Ly0F97l8r33k1lwqDmQWShAAQpQgAIU6LYAA8DdJuQGKEABClCAAhSgAAUyQSC4r97opmVYfMHfqImaF9gnQbDgvoboS7ynQL8VUJmr6qaCnH75wTdc4TWGezZLJqt99kC5eCKz5yUM7KlD5bIV0JuCMMv0x86zZe7wwa0/U8J1Mk/y2zoC68Oo/vFqGXVADSnPuZL77UnDjlGAAhToREAFdbOvnYSsr0wwpgkI7KxDuNYPU64N1rE5sM8ohmZLzcCv6pZfspcrb5QrIWWUEMto+d47S5Pgb+vvvVC1jBzypnzvbQ2i6nvvo+CB+XDI3wwsFKAABShAAQp0T4AB4O75cW0KUIACFKAABShAgQwRUAEbVTRbYh3WmuNd0fUTW5u1KZCeAraJ+VA3liMCar7f6ts+MoK/1kmA60IZSl4yp9sWU44G9wUavMXyg/hymUP87k9gm1YoWcLOtlX5nAIUoAAFMkRABXkdcwcbt3Tpsu4PofqHHxrBX9uJzVOoaEd/76mRddxLNXjekvmBZQqJ6h99hIHPLIEpJ8E/utMFhu2kAAUoQAEK9JKAzGDGQgEKUIACFKAABShAAQp0JWAqiERyw/VHht3rah21PFwXqWXK8MzHeKxYhwL9WcDzWgmCu+pgkri46wvtB39j+++Yo8mcjjKItjeE+sc2xy7iYwpQgAIUoEDKCzQ+twuhw00wSzKv8xz53msn+BvbCcdCGRVDsoT1+gAantwWu4iPKUABClCAAhQ4BgEGgI8BjatQgAIUoAAFKEABCmSegHVygdHpwI7E+h7YGQkYW6dE1k9sbdamAAX6i4Ca11cV+zz5Edx6dAZUe/10nB6p51m+H3pQJiFnoQAFKEABCqSJQMv33mnyvSfTGXRVVIDYsaD5e+/1kq6qczkFKEABClCAAl0IMADcBRAXU4ACFKAABShAAQpQQAnYpxdJ5p4d4XLIHGXxZQGHqmQ+s42ysvyW5Vw4lJAUoEAGC6g5kVWxTogfwVyowSTXjqhsqOCeyDzk8a/NmhSgAAUoQIG+EdADYQQ2Vcs89vK9Nzb+Npjlz2XNBYRKPXJrin9F1qQABShAAQpQ4CgBBoCPIuELFKAABShAAQpQgAIUOFpAs5iQfZ2Mxyql6SUdKrjbWdG9OpqelTohNefZSFiGZXVWncsoQIF+LBBuDBhDOUOmMzS5us6CiqUw5UWehSo8sS/zMQUoQAEKUCBlBUKVXqNtmvz5q1ni/95TWcBHvvci20jZTrJhFKAABShAgRQXsKR4+9g8ClCAAhSgAAUoQAEKpIyA6+Ix8H54GL73DqPhMR3OJZLVMFl+2Gozp1mwRIK//9IRrgQsI7ORe9MJKdOH/tyQ4KFGI9tE/ehoclthGZ4FNfS2Zo7/h8f+7MO+9Z2AZjdHdh6UbF5dP+ozo7OW6YHIUs3Bf7535sRlFKAABSiQOgKao/l7r/k7LJGWtXzvRb87E1mZdSlAAQpQgAIUaBHgvyBbKPiAAhSgAAUoQAEKUIACnQuo+cvy75qNmjs+hnfFQTQ9p8P0tgR5R0tAxy2BHUlUCMk0n6HSyHYs43NReP9cmLKsnW+YS7sl4FtdirrfbYwMNdhmS6Y8G9xfHI+sL41Hy4+RberwKQV6WkCNIGAe6DSGtAyXQR7Ht0c9LBeSSH1VLENkTEwWClCAAhSgQBoImHJtMpSzBXpTEOFa+Xs5N76L8XS/fO9VSQdlzErzYH7vpcGhZhMpQAEKUCCFBTgEdAofHDaNAhSgAAUoQAEKUCD1BExOC/LvOwV5t50M8yAXwjWA/zPAt0ruP4kEfzUJ+GZ/YzKKfr9QAj388aqnjqIKjtX+6nNU3rQqEvy1R+ZXtc2U++Plt8NCyPHxo16Cw+VfewsqQ5iFAn0lYJ87yNi1b23nw8fHti+wRS4s8Unwd2wOzMX8LIm14WMKUIACFEhdATU6jn1O5HvPvy7+dvrXS12ZPsV2wgBjNJf412RNClCAAhSgAAXaCjADuK0In1OAAhSgAAUoQAEKUKALAfWjluu8UcbcvoFN1QhsrZFAow8q8GsdlQ3b9CKZ74zXWnbB2O3Fdb/+HI1/3SEpIoBjgfzQOOvoeeaCe2U47ld0BHfWoXLZCgx4dBHMeRIpZqFALwu4LxmLpud3w79GftiepktGb+fZUOEmHZ7lkWCx+7Jxvdxa7o4CFKAABSjQPQH30rHwLt8P7we6MWWKeUAX33t1Orzv8nuve+pcmwIUoAAFKHBEgL9KHbHgIwpQgAIUoAAFKEABCiQkoALBNplj1i1zA2dfNwlZEqSxzxrI4G9CisdW2fvB4Zbgb9aXNTjmauJ+9A+LlpEasq/VYB4qCSWHmlD7M0nXZqFAHwhYx+bCvVQCuZLZ1PhXuShhf8eZwOF6HY1/0aHXSja7fMa4zh3VBy3mLilAAQpQgALHLmCXLF7nv40AZB7gBvlOC5V2/L0XqtaNOnoT5G/pYjhPlz/cWChAAQpQgAIU6JYAM4C7xceVKUABClCAAhSgAAUoQIG+EKj77QZjt45FGlSQt7Oi2TW4LwXqfiOZJe8cgH9LNWwT8ztbhcso0CMCOTdMQ3BfA3xyAUPD47oMcSm3aRpMxZK9LpnsIZn3MLBFh2+17N4vye3D3Cj42RxZ1vl7vEcay41SgAIUoAAFuimQ973pCB1shH9dJeofle+8E+U2VS7MK5INy1dbqFK+9zbJ955Mo4JgZMqD/Ltmd3OvXJ0CFKAABShAASXAADDfBxSgAAUoQAEKUIACFKBAWgkE99YjuL0WmkyJap8RX9NN2TJE9HT5gfEjwPPGPgaA42NjrSQLqKHhC+6fi/qHN6Dhqe3wy3zA6tZecZw2BHk/PBmmXFt7i/kaBShAAQpQIOUFNLsZhf9zGmp/uU6mQdgF/6dyfdOn7X/vOc8ajlwJGJtc/Lk65Q8sG0gBClCAAmkhwG/UtDhMbCQFKEABClCAAhSgAAUoEBXwr5d0ESmW0SprMv7MSMt4TQLAOgIbJM2ShQJ9JKDesznLpsF1wWg0/XMPvB8dNoYnRzAM0wCnXKhQZAyZqYbOZKEABShAAQqku4BmNSHv1pNkNJaxaHpxj4xyUYrQYRnrWeLA5iInbDOKjKkObJM4Oku6H2u2nwIUoAAFUkuAAeDUOh5sDQUoQAEKUIACFKAABSjQhUCo0mvUMOV2UbHNYlNO5IXo+m0W8ykFelXAMiwLOf8x1bj16o65MwpQgAIUoEAfCFhH5yD3xuP7YM/cJQUoQAEKUCAzBRgAzszjzl5TgAIUoAAFKECBPheo9AfwdmUdSjw+hCUDYJjDhtMLczBI7lko0JmA5oz8M0YPdFarnWXN9TWHTLbK0qMCap5b/+eVMrefB2r4R8vQLNhOLoKp+dj16M65cQpQgAIUoAAFKEABClCAAhSgQIYLMACc4W8Adp8CFKAABShAAQr0tsDORi9u21qCfxyqQridnS8pysO9E4fj+Bx3O0v5EgVk6OdhkfdG6GBiGsHm+irzkqVnBHyflKHutxsQ2FR99A5sJrjOH4Xsr06GOd9+9HK+QgEKUIACFKAABShAAQpQgAIUoEBSBBgATgojN0IBClCAAhSgAAUoEI/A84ercPXaHWgMhWGVFU6GBpnGVf4P7JPbpzIZ2KvlNVheUYuHpo7GdSOK5VUWCrQWsE+X94VklYYOhBAq02Eujm8eYP9aSTWX4pg3uPUG+azbArquo/53G9Hw+FZjW5pDAvVjAFOeTPEnmdehw3LbH0bTs7vgffcgCn42B7bJBd3eLzdAAQpQgAIUoAAFKEABClCAAhSgwNECDAAfbcJXKEABClCAAhSgAAV6QEAFdb+4ZhtCEoNbLCHf62FCoRH6PbKzegkAPyp5wc9LMOkb63fBZTbhS0MHHKnARxQQATWEs/ui0Wh8egeaXtaRdaW8Zu48COz7VJeAsQQkCx1wnDmMjkkWqP/D5kjw1yQB9gUa7LPlmFhaH5NQhQ7PKzqCe72ovGkVih5ZCMuI7CS3hJujAAUoQAEKUIACFKAABShAAQpQQP55zkIBClCAAhSgAAUoQIGeFWgIhnDFZ9uN4O/lEvS9Heajgr+qBdmy7CZZdoMEh1X5+ue7cNDrNx7zfxSIFci+ZhLMg5ySVQo0/k2H7o1k96o6Khs1tvjWSODxtchrud8+ASYHr4ON9enuY//6SjQ8ulmi64D7Mk0yrLWjgr9qH+YBGtxf0WCdKMeoIYDq/1p91LHqblu4PgUo0HsCerj1Z23v7Zl7ogAFKEABClCAAhSgAAW6EuAvH10JcTkFKEABClCAAhSgQLcF/nfPYZT7g5gqW/p6c3C3s41eLHXWSTbwinAY9+04gF/LcNBtS8ndks6ZYBlx+9AE12D1VBUw5dpQcP88VN6wAsGdftT+WocpWwLBjRJc9EqrrTo0l9xLfEKvi/Qi++uT4TyD2b/JPqZ1v99obNI+V9jHtc76bbsvzaTBdQFQd1BHYEsNvCsOwrmA52VbJz6nQCoK6N4Qml7aA8/bBxDYUSufrX5o2VZYR+fAcfoQuL4wGia3muCBhQIUoAAFKEABClCAAhToawFmAPf1EeD+KUABClCAAhSgQAYI/O1gpdHLKyWwK7mBcfX46uZA8TOHqhBuk9EZ1wZYqd8LWMflIkuCusZbShLFw/I2M4K/qucy76xeeyT4a52Yh+zrJvV7k97uYKjaB/+n5ZLeK0M/z4nv3NasaojoSF3Pm5LCzUIBCqS8gPejUpQufRW1/70W/jXlRvBXNVqvD8D/eSXqfr0eZUtfg+edxC/OSvnOs4EUoAAFKEABClCAAhRIQwFmAKfhQWOTKUABClCAAhSgQDoJeENhfF7fBJUTND3O4K/q3xipq2b/LfMHsNfjw2iXQ73MkmICfZmJ3fDsTtT9Yq0hYsoH7BKAtI6TeLCaVlYCwkGJQ/hl+OfAFokHS7Zp2ZVvoPiJM1NMML2bE9hSLREgyFy+4m6PLwCseqyOk/cNOS4bq9IbgK2nQAYINL1agpq7PparbORaj8HyWXuKBssoOedllAV10U1wL+BbLfOsl/hQ/YMPEf7uiXBfMjYDZNhFClCAAhSgAAUoQAEKpK4AM4BT99iwZRSgAAUoQAEKUKBfCJT6JBVTSoHcLAkEgNU6Rep/UqLbiDzj/ykggd0dNaiTTDRVrDK2ePa/S1bpdA2mHMkx1+QmwUjrGJlz9lITXEslMCmXvgZ31KH6jtXkS6JAuFKNty3T/+YkttFo/VBVZP3E1mZtClCgtwT8cpFHzb2fGsFfx2kasq7TYJsin7XuyGetySnPJ2rIvsoEx5mRi0BqH1gLn2QJs1CAAhSgAAUoQAEKUIACfSfAAHDf2XPPFKAABShAAQpQICMEcqwyNqwUmZo14eJpXiPbEtlGwhvgCnEJqCCcyvCqf3Qz6h7eiMZ/7ERgV/PEuXFtofcrVd/2USTzdAxkTlkJRFg6zj61HSfzzp4fWe55bR+Ch47l3dj7fUyHPWruyKBSui+x1kbrm1xqbAAWClAgVQXqHlwnqfph2GbKMO8SAFYX2HRUHDK0u/1UWSqZwioIrIdleAAWClCAAhSgAAUoQAEKUKBPBCL/Wu+TXXOnFKAABShAAQpQgAKZIJBvtaBAblWBIPbLWLHD4swCrpe6+wTIIj82j3Lak0IV73DFI24fmpT9pfpGggcaUPfbDfC+JWMlt/M7vWVCLnKWTYNj1sCU6kqw3CNDjTYYc/86l3QekIg2XGWs+T/TEdwD1P1mAwrumh1dxPtuCFiGq/G2Jbv6YGIbCTXXtwzPSmxF1qYABXpNILC9xpjfVw317FzYceA3tkGO+fJZ+7l81u6sg39thYzMEB3LI7YWH1OAAhSgAAUoQAEKUIACPS3ADOCeFub2KUABClCAAhSgAAVw3kCZoFXKP1VaUJzlZYlIhqTuwsIcuJkBHKda/NW8HxxG+VXL4V1+AFYJ/s6RwPyVcrsOJiyRe3XEgttqUXXTKiMrOP4t93zNxmd2GjsxD5f5KAviC0qoFWwnROr6OTRp0g6SdVwuzAOd0CVhPLCjnasIOtiT79NIXft8mVCUhQIUSEkB9T2hinWSXG9ji++zVjOrIaIj3fE1rx95xv9TgAIUoAAFKEABClCAAr0pwAzg3tTmvihAAQpQgAIUoECGCnx79CA8sb8cz0lQ93S5Te4iC3if1HmiOVh8y5jeDxDFmykceziPJWv4WPYTu89jffxhdT0WfbAJuq5jgRyLGyToW9jmmATkGDwjt0fkODQ8vgX/+UEDfjh+2LHustV63e33JZ+U4QXZomVQq812+cTcnMhsrfGju23ocmd9UOFY3oPJaKb7yxOghon1vKbDLMnzak7Qzop/g8oOlICSDB/t/sKozqpyGQUo0IcCoYNNxt7NAzs/p9s20TxI1Zfz/CCH229rw+cUoAAFKEABClCAAhToLQEGgHtLmvuhAAUoQAEKUIACGSxwfI4bN0oQ+Fe7D+MHktf7XxJwnC639spW+dH4R1JH/Wy8dHAhzizKa69ayr2WLgFFfziMKz7bAb8Efy+UoO9NaH9+Zassu1xuo0T6dgkC/3jbfpxTnI8Tc919bu8JNWeSJ/qvmeb6Iel7qhfVRtXPrDTIfndfNAYemUM6sLkajU/qcC+VIHBe+wEj/zodTS9H/HNuOB6m3OQM757qx5Pto0A6Cuh+NQ6HXKyR4GdttL7uj3/Uj3T0YZspQAEKUIACFKAABSiQygIJ/hmfyl1h2yhAAQpQgAIUoAAFUlng55NGosTjx3OHq/AdCSjOl0DvGUaAUTNCwSrr9225vSU39ZPxaQXZeOSEMancpbRs2+OSib3H48Noaf23OgjCx3ZsjtS5VI7J3+R2pwSBn5t5XOziPnk8onlO6HB1YruP1neZ2w96J7a15Nfe2uDBb/YexstlNdjT5BNxwG02YW5+Nr40pBBXDCuCWWs/sJr81sS/Rc1qQsHP5qBi2QqE9sm80g/rsJ2kwzpezm11/UYQCB0CfBL8DZVEtpt1xQS4L1DvQhYKUCBVBcyFDqNpoWr1aRT/Z0+o+bPZPCCyfqr2j+2iAAUoQAEKUIACFKBAfxZgALg/H132jQIUoAAFKEABCqSQgApc/W36ePx0xwG5HcQqyURdZYS4WjfSKvVuGjUI904cDqup/Szh1mvwWSICfz9YaVS/XAK75jh/0P+y1H1GsrJfLa9BfTCE7D7OSv3y0EL8YV8ZArtkkNGADs0aX2AisC2SeTo125UIWY/XDUu2721b9+GBXQcRijTRCM2r3NhGyQJ+o6LWuN2/6xCelnMo1dqvgMxFThQ9shC1v1gLz+v74P8YcmvuTIygKc+GnG8dD9e5I2Ne5UMKUCAVBWwnDQCe3CbzwUvrFsTfwmDzZ63tRFmfhQIUoAAFKEABClCAAhToEwEGgPuEnTulAAUoQAEKUIACmSmgSXBXzSN73fBi/OVgBd4sr0WJ1y9BLx3DHDYsLMzBl4cOwCgXs4Z66h3ySW1kTsZZcQZ/VTtype4Eud8ix+nzuibMk+zsviynFeYiSzJjG3xh+D4AHKd13ZpQlQ7/2ki97/TBvNIdtVAFf7+0Zjv+IZnxKi/5fLE+V8K/4+WxSR7XykUSH8jtz5IXv0UyhOe9twGvz56E2ZIV3Lb01jDkHc01bMq2If/OWci68rhIEHhdBUKVXmgOMyxD3LDPHQTnmcNhclvbNp3PKUCBFBSwzyiGqcCOUKkP/k2S2T+564ttArtk7t+9kTm+HfMGp2Cv2CQKUIACFKAABShAAQpkhgADwJlxnNlLClCAAhSgAAUokFICgyTYe8uYIcYtpRrWzxuj5v+tkwxe9Y8AFdRNpAww6uso8wcSWa3H6t4jGeI3bdwL70odpmLANrHj/oQbdTT+XbJRZTrLsS47LhhU0GPtSnTDd28/YAR/VTj3HgkBT2tzXNRxWiK3RXL7uQSBl0tG8MWfbMO6BcdjgC01A6nWcblQNxYKUCC9BTSbGdnfmILa+9ag6SX5rM0HLIM7/qwNVcgc389HMv+zrp4IU1Zqfkal91Fh6ylAAQpQgAIUoAAFKBCfAMfUi8+JtShAAQpQgAIUoAAFKJD2AjYZUttu0tSUrIjMMBt/lyJ5wxI47uPhn6MtXjZqsJExrkYRb3pGh+eNMMJNkcBDtI4u2bX+zTrq/yDzSpfD6Pvbc6ZEF/f5/T6Zi/lnOw8Y7fiJ5Pu2Df7GNtAmAeAfSJ0T5b5UgvD3SOCYhQIUoEBPC6i5up1nDpMx3YGGx3V4P9CNofdj96sHdfhkyPf6R2VZk3zWSrZ/1lfUuBEsFKAABShAAQpQgAIUoEBfCTADuK/kuV8KUIACFKAABShAAQr0gcBxbic+r2/CRomcTpdgYjwlIHW3qkirlAnu1Bme+41TJuPc1Zvxmgwl7vtIgtqrdZiHSpZajswN7JOE30NyL8EIVdS8xe/PnYIhkn2eKuXx/eXwhXUslONwogR3uypqzuYbpd51ksr8mMyBfN/EEbDLUNgsFKAABXpSIO/HM6G5rGh6YTe8yyUI/K5kAstnreaWz1gPENwve28eHEIFi/N+OAOaXGzEQgEKUIACFKAABShAAQr0nQB/Leg7e+6ZAhSgAAUoQAEKUIACvS5w/kAZw1PKC80B3Xga8KbUVXHUk3JcGOa0x7NKr9X516xJ+POJ41Bsk2tbJUYdkkBEYJMEJHZGgr9WmXf6SplXuvTMkzEp29Vr7YpnR6+V1xjVzo4zEK8qj5a6Kq+uQYaCfr+63lif/6MABSjQkwKaxYS8709Hwa/mw3Z8oXzAyn97mz9rd8ueJfhrnZyPgp/PQf5PZhvzfvdke7htClCAAhSgAAUoQAEKUKBrAWYAd23EGhSgAAUoQAEKUIACFOg3AtePHIgHdx/CCgkgvitzyi7oIvO0VKKqv5N6qtw6dkhKOnxRArzqtq/Ji+dKq7Fb7vOtFszLz8HiotSdi3ZPk6QpSxmbQABY1R8j9bfJcdkrQ0izUIACFOgtAcesgVC3UJUXwR21CNf6oeXaYB2VA3Oxs7eawf1QgAIUoAAFKEABClCAAnEIMAAcBxKrUIACFKAABShAAQpQoL8IDJIhkH8qQwfftHEP7pHArozeiSUdBIF3SJDxRzLccK2qU5SHpYMl8yuFy3CXAzeOHpzCLWzdtIDMUaxKov8oszZvxi/DR7P0vEDYE4TeGIApzw6VCclCgUwXMBc4YJ7V89MBhJvk3GviuZfp7zf2nwIUoAAFKEABClDg2AQS/a3h2PbCtShAAQpQgAIUoAAFKECBlBFYNmqQkT36wK5D+JkEgV+U29kSBB4nmaUquHhQAr8r5fa23FTu7+y8LPzlJFkqwymzJE9giN2GCn8QB2STeQlsdn9z3VSazziB5qdF1WBJPRqe3g7vqkMIl3tb2mw9Lg+OxcPgvmQsTC7+c7oFhg8okCSBwJ46ND4l5957hxGubD735KtHnXvOM4bDdckYmBw895LEzc1QgAIUoAAFKEABCvRjAf7V3I8PLrtGAQpQgAIUoAAFKECBjgR+PmkkpsmcuN/bvBebJAi5yQj1tq5tkYDvt2TIaJUxbDcz87G1TvefLSjMwef1TVgh9lNgjmuDNRKUXy83swRE5hVkx7UOK8UvoEtWdv3/bULDn7bKhNLNGdZyVYQmU1/rjTLV6dYa46YCVPl3zIRdhsNloQAFui+gy4gG9b/dgIa/bEPL11HsubdFzj25qQsz8u+cBfv0ou7vlFugAAUoQAEKUIACFKBAPxZgALgfH1x2jQIUoAAFKEABClCAAp0JXDmsCBcPKsA/DlfhlbIaIyvYFw5DZZaeWpCDy2TI55EuiXyx9IjAV2Te4v/Zcxj/lIDuRXIbFMdcwI9KZCQorbmgON+Y57hHGpbBG6256xN4XimBGhXdNh2wn6zBPDCS+a5LQDi4G5KZqCO0z4fKm1ch/+7ZcC4clsFi7DoFui+gLryo/vFqeJfvj5x7M+Xcmy7nXlHzuRdsPvdWyrl30IvKG1ei4L45cMxPnyH/u6/ELVCAAhSgAAUoQAEKUCAxAQaAE/NibQpQgAIUoAAFKEABCvQrAbfFDBUIVjeW3hWYIUNrq3mV/36oErfLXMv3SxZwfidB4Ock+PuiBIqtkpl913HDe7exGbC3hr9ujwR/bYD7MhkOfVQk+BTtuiZp19ZxMmfzWAkCv6PD9x5QfecnsI7JhWUks7GjTrynQKICDU9uM4K/mkwrrM49y4g2555Fzr3xcu7J+ed9U869jyIB46Inz4BliDvR3bE+BShAAQpQgAIUoAAFMkKAAeCMOMzsJAUoQAEKUIACFKCAEhhx+9C0hyi5+0Da9+FYOpCKxy4Zx+LhaaPxeV0jtjZ68e8SBP53ST1dIEFgS0wgWM3J/EcJ/r4h96o8NHU0Jsvw3W1LKhq1bWOqPg/X+lH/h81G89wXHh38jW23mgvbuVBDuD6MwOch1P1mAwp+Nie2Ch+noYCae9b3wWEEDzRC94ZgHuCA7YQBkgVeBM0W3xDtadjtPm9yqMqLhsci557roqODv7ENNM69M5vPvU1B1MmQ0QV3zY6twscUoAAFKEABClCAAhSgQLMAA8B8K1CAAhSgAAUoQAEKUIACFOgjgVyrBW/PmYJzV2/BZxIIvlsCvQ9KWyTRDXYJApdK0Hdvc9skCQ7/d/wYydYu7qPW9t/demToWb0hAMsYwDqhdfZhR712LtYQ2KTDu+IgQpVemAslfZEl7QQCu+pQ98t18H1c1k7bt8KUb0f21ybDddFoqAAkS3IFPK/tg+4JwSIZvtax8fk6z5Bzb4uce28fgLp4w5QrafssFKAABShAAQpQgAIUoEArAQaAW3HwCQUoQAEKUIACFKBAughkarZjpvY7Fd+XyToW3vcOoWqVN9JFiX80SqLvOuNZJOPXSAaWhzINJq7P8eCH35XZgh3MSEzme8L3UamxOdvU+AJQqrLJLdmKY2Ru0m0wgoeuJSOS2SRuqxcEPO8cQPUdH8sBDEGT6c6tEwHzIHkPWIFwjRzb7UCo1Ifa+z+D79My5P/XTGYDJ/m4+FY3n3vTEjj3cuTcGyXHZ5cMBy3HxbmI83An+bBwcxSgAAUoQAEKUIAC/UCAAeB+cBDZBQpQgAIUoAAFKEABClAgPQX8m6pQ9cMPAX8Y1qmA8ywJggQl+FQN6AFAy5KAlEzPHNwJNL0oGW8rD6H67k9QcDeHPU3mEQ+VNhmbMyU4FbZxbCQAHDrcmMzmcFu9IOBbV4HqH31kXFlhOwFwyNDCJkdsEFIeny6n5mYdnpfk3HvrAGrkwov8H83shdZlzi5ChyLnnjnBgQ2Mc2+XCtBH1s8cMfaUAhSgAAUoQAEKUIAC8QmY4qvGWhSgAAUoQAEKUIACFKAABSiQTAE9pKPmrk+M4K/tZMB9oQkmlwShVHbbSJmHdpzcSzaiZpbHMixx1tUSkJIsRa8MV6yGLGZJnoAeDBsb0xL9F3K0vhxLlvQRUMfbOPckrd4u11K4zpdzr1Xw90hfbJPk3LtKzj3JCva8XCIXYRw8spCPui2gh2NGOkhka83nnq6GRmChAAUoQAEKUIACFKAABY4SiP5z9agFfIECFKAABShAAQpQgAIUoAAFek7A+9Z+BPfUyxyjzZm/XezKPECDmvtSlfpHNnVRm4sTEYgOqR2qSmQtydSujNQ3FToTW5G1+1TA81oJQgcaYRogmb8yl3NXxTxQzr1Fzefeo5u7qs7lCQiYiyLnTvgYzz1zMc+9BLhZlQIUoAAFKEABClAggwQ4BHQGHWx2lQIUoAAFKEABCvQngZK7DyTcnWTN2ZrwjvvxCjwOx35w1fyjqthnRbJ849mSGqrW+5aMWru7HsG99ZIpnN2y2rEci5aVE3jQH86jtlanHQzgfTEIbNKhMj7jKbpf5iCVoblVeei1OnxpQ+R49gefSK/67/89bzefe6fIuWeK73jbpksG8DvyHtlSg+ChRlgGu/svUC/2zD6jCP415cZQ29bx8R2LsFdHYHekkfbpCY7b3ot9464oQAEKUIACFKAABSjQlwLMAO5Lfe6bAhSgAAUoQAEKUIACFMhYgcC2WqPvltHxE6hglWVkpH5ge2T9+NdmzY4EgnpkGNmAJHcGD8Q3pKx3lQ7dF9limV8mbGZJG4HouWMdFX+T1VDsluGR+sEdPPfil+u8pvMsQRXbwHo59w7Hee69K/XklLPPKpY50pkB3Lkwl1KAAhSgAAUoQAEKZKoAA8CZeuTZbwpQgAIUoAAFKEABClCgTwXCtZHooZZgImG0fnT9Pu1EP9l5ffMcwKo7jc/oCFV2HojyrdPhk5ThaL5ihT/YTyQyoxvhmuZzLyux/pqaz9VwjT+xFVm7QwHL0Cy4Lx0LyCnX+Hc596q6OPc+1eH/WDYnQeOc/5jW4Xa5gAIUoAAFKEABClCAApkuwABwpr8D2H8KUIACFKAABShAAQpQoE8ETDk2Y7+6J7HdR+tH109sbdZuT6DAGpkdaZws1OuBhkd1eD+UDF8Zaja2qOBU4z/D8LwYeT0afoquH1uXj1NXwJTbfO41JdbGcPO5quVYE1uRtTsVyFk2DbbjC6FLYrU693yrVXZ9m3OvQs695+TceyXyeu4tJ8J6XF6n2+VCClCAAhSgAAUoQAEKZLIA5wDO5KPPvlOAAhSgAAUoQAEKUKCbArHznbadV1VtOnZ5N3fV71a3jM5B6ECjzOUryWwF8XVPl6GKgyWRump9luQITM524r3qesyVnF41yu/bEnzyvik3mW/ZNECH5ogEhsPVkf2pf0jfBBNeQNh4Qa3Pkj4CVjl3fOVe41yyTY2v3XpYslP3Repax/Dci08tvlqa1YSCX85HzZ0fw/vuQXhe1+F5Uz4XiyTYa5dzrw4I1zRvy2ZC3vemw3XOyPg2zloUoAAFKEABClCAAhTIUAEGgDP0wLPbFKAABShAAQpQIN0FGFhMvSPIY5LYMXEuGALfqkPwfazDdqIMJ6xFBxTueDtqjlq9QQIjQ92wjsvtuCKXJCRwwcAC/F9JGV6RcWifhBn/JvdPy22tBP3CZUc2pUYMPk2CxFdK8Fe9vENuuRYzTi9kQPCIUuo/cqhzb3WZkWlqm9r1ead6pOaoVdn3ltHZMhdwdup3Ms1aaHJaUHDfHHjfO4SGv2yHf205QqVHOqHJiAnORUORfc1EmAe6jizgIwpQgAIUoAAFKEABClCgXQEGgNtl4YsUoAAFKEABClCAAhSgAAV6VsB59gjUP7IZocNN8K7Q4VzQeSAqXCdZca9Fhj/NvnpizzYuw7Z+dlEupue6saa2Ef8jWb3fkSDwTDFolCDwIeMeyJf7oXIzSwC4Xl7/OULyDPjOmMGwmTi7koGRJv9znTMK9Y9tQeigVwKOOhzzOj/3QtUqIzVy7mXx3OvRo+yYN1iOx2CEGwJyfBoRbgzAXOiQi16yoMm8vywUoAAFKEABClCAAhSgQHwC/FdqfE6sRQEKUIACFKAABShAAQpQIKkCatjTvB9MlzGGAd9KwPNGGHowEmRqu6PgAR31j8u8mI0yIuqsYjjP5fCnbY2681xlX/9u2hg4JZD7kgR3fybB3Sa5d0uwd5zcTpDbCLmp4O8eef1GWX5AdqiCxreMGdKdXXPdPhDQHGbkfV/OPYknet+W4O7bnZx7+3Q0/EnOPcn+tc8fDOdZapBwlp4WMGVZYZ2QB/tJRbCMyGbwt6fBuX0KUIACFKAABShAgX4nwAzgfndI2SEKUIACFKAABShAAQpQIF0E7LMGIu+2Gai591P4PtLh3yTDQU/VYR6iQbPKvJe1MvTsdpn3V401LMV2fCHy754NzcRMuIhI8v5/kgRzn54+Hpd/th2vhsL4QIK8Z0iEcIrc3LKbcrmtluDvKrmpmX+nyry/z884Dg4zr6tO3lHovS2pLNNcmUu29v7P4JMsYP+G5nNvUPO5J3POBrbJubcr0ibb9CLk3zEzrqHae68X3BMFKEABClCAAhSgAAUoQIH2BRgAbt+Fr1KAAhSgAAUoQAEKUIACFOgVAdc5I2VO0SzU/vdaBLbWwPeB2m2bTGCbCVmXj0f2VydLYJgBx546MOcOzMf786bixg27saKqHs/KcVC32GKRbOFvjijGvRNHIEvm/2VJXwH3BaNhGZltnHvBHbUSCFZ9aX28Vbaw+ysTjLlnNQvPvfQ92mw5BShAAQpQgAIUoAAFMkuAAeDMOt7sLQUoQAEKUIACFKAABSiQggK2aYUY8Ngi+NdVShDqEIL7ZfZZbxAmmftSLXOcNgTmfHsKtrz/NWlqtgtvzZmCj2sa8GJpNbY1elAXCKHYbsXMvCxcOKgAQx22/tfxDO2R/cQBKHp8MfxrK+B9/zBCB5rPvQEO2E8YAMepg2HK5bmXoW8PdpsCFKAABShAAQpQgAJpK8AAcNoeOjacAhSgAAUoQAEKZLZAyd1qBs7Eyojbhya2AmtToBOBY3kPdrK5mEUFgFvdml9aL/frK2KW82FvCKhgr7qx9H8BNaS6XYZ4VjcWClCAAhSgAAUoQAEKUIAC/UGAAeD+cBTZBwpQgAIUoAAFKEABClCAAnEIeGVu21fKa7C8ohb7PD5jDZXNunhALv6tOA8uM4c0joORVShAAQpQgAItAqFKL7zvHoR/YyXClT5oTgssw9ywzx9sjCTQUpEPKBCngH9zNbwrDyJYUg+9PgCTjAJjnZQPx4KhsAxyxbkVVqMABShAgUwXYAA4098B7D8FKEABClCAAhSgAAUokBECf95fjh9sKcFBX+Co/v6+pAwDbVbcPXE4rh1efNRyvkABClCAAhSgQGsB3RdC3e83ovHvO4FAuPVCedbw5DZYJ+cj9zsnwjZZRvZgoUAXAoE9daj9xVr4Py0/qqbntX2o+5/1cJ0/CjnLpsGUZT2qDl+gAAUoQAEKxAokJQBcU1ODX/3qV7j66qsxatSo2O3zMQUoQAEKUIACFKAABShAAQr0scBNG3fjoT2lRivGyf8XwYSRcq/JrURubyGMbf4Avv75LnxY3YCHp42GpqmlLBSgAAUoQAEKtBUI1fhQdct7CEimpvoytUwArOM0mTMc0P1A6KAOv0zhENhUjYpvvov8H82A88zhbTfD5xRoEfB+VIrqH3wI3ROULHJ5P02V99VwDZpMQx9uAII7dQS26Gh6fjf8n1Wg4JfzmQ3coscHFKAABSjQnkBSAsA+nw933HEH7rzzTixYsADXXHMNLr30Urjd0Umr2ts1X6MABShAAQpQgAIUoMCxC3A+32O345q9KxD7Xo133uD21on3tba9++mOA0bw1yYLbpbA7xK5xZY58uSL8tqbEgT+hdwe2SfZwHYrfnJc//2hOtYy1oKPKUABClCAAl0J6MEwqn/4oRH8NeUDrks0CcS1uWhqkgbHaTo8b0kg+GOpf+fHMA1wwH4S5xrvyjcTlwd21Erw9wMJ/oaMwK9riQR+Ha3fU/YTNIQqJQD8Dx3BvfWo+u57GPB/C2GSIcdZKEABClCAAu0JJPUbQtd1vPPOO8Zt2bJlRhBYBYNVUJhXj7fHz9coQAEKUIACFKAABSiQGgKhKi9Ch5ugyxCGZvmB0jI0KzUalsKtiAYRuwrqdrW8vS7GrhPvftrbzvZGD+7Yts/I9P2JBHlntwn+xq5zhixTA1T+pwSBVdD4siGFmJrNeeZijdL1cfBgI0LlHmgWE8yDXTAXONK1K2x3hgiE6/2SQdmEcGMA5kIHzMOyoJlbB0MyhILdTEGBaAamlg1kXS1Zv1ntvzc1qwbX2RLIs4Th+0BHzU/XoPgvZxqfxSnYLTapDwVqfrYmEvw9HnB/ofWFerHNMhdqyLoKqH9MgsA769Dwp63I+fcpsVX4mAIUoAAFKNAikJQAcFFREZ5//nn86U9/wksvvQS/34/GxkY8/vjjxk0NC62Gh77qqqswZsyYlp3zAQUoQAEKUIACFKAABSjQdwJ6SDJTXt6Lxmd3IrC1plVDTEVOuJaMQNYVE2DKUbmjLOkocP/Og5DDjPMlBNxZ8Dfat+kSBL4QOp6V289l3T+dOC66iPdpJhBuCKDhz9vgeWUvQqWeVq23jM+F+6IxxjyCKijMQoFUEfCuOoSGv2yDf12FjHl6pFVathXOhUORde0kDnl6hIWP+kBAJb/U/2mLsWfXv3Uc/I1tmmOhhsA2HaF9DZIRfACus/rvCBux/ebj+AR8n5YhsKEKmgykqTJ/uyqaXS4sOF/mmJYgcOPT2+UihONgciTlJ/6uds3lFKAABSiQZgJJ+ZeeyWTCBRdcgGeffRaHDh3Cb37zG5xyyiktFHv27DGGhx43bpyRDfzYY4+hoUEmL2ChAAUoQAEKUIACFKAABfpEQGUDVnzjbdTc+2kk+CsxXvNguclvkpok/4ZlecMTW1G69DX4Pinrkzam+k5Vlm5spm5se1XWbvQW+3pvPlY/Uv+zVOYmlHJpJ5m/bdsUrfuSrBsMS/SYJe0EfBI8K7vsNTT8cYsR/FU/Kqtz2zxEuiLnenB7LWp//hnKv/oWgpL5z0KBvhYINwVR9f0PUHXr+8bclmrYAvNAuY0ATHkyp2p9AE3/3IOyL76Gpn/t7evmcv8ZLKDm9A2Xe433pXVC18E6RaWZNNhnROp6VxzIYD12vT0B77sHjZdtJ8l7xRbfe8oyVIN5qHw2ekMyxDj/Tm/Pla9RgAIUoIDMJZ9shIKCAlx//fXGbfv27UZW8JNPPgkVBFY/QKxYscK43XDDDbj44ouN+YIXLlzIIaKTfSC4PQpQgAIUoAAFKEABCnQgEKr2SfD3HWPIZ1Mu4FikwTpRfnSKGV4zeECH920ZXm6PH5XfXoXCB+bBPkt+jWdpEYgOzdzyQgcPYut1FDDuYFXj5fbWiW6zvWXRbZX7g6iQmxxijDAGgY4u6fx+kNRVMxSWB0M44PVjpMve+QpcmlICvs/KUXnjSony6kbwzCmZZ5bhR35QVpn/gW2AV+alDG6rRcXX30bRY4tk6HdnSvWDjckcAd0fku+ZlQislww4GZ3csUCDTYZBVVlu0aLmvfSulPfuhjBq7v4Eui8I98Vjo4t5T4FeEwjurjP2ZZGLExIplpGR2sFdkfUTWZd1+7dAoOU9deQzL54eq/dUSK4nCMh7ynGqusKLhQIUoAAFKNBaICkZwK03eeTZ+PHjcdddd2HXrl1499138bWvfQ3FxcVGBTVE9BNPPIHFixdj9OjR+PGPf4zdu3cfWZmPKEABClCAAhSgAAUoQIEeEai5Y7UR/FWZA1lfkx/ap8j8dDHBX7VTlVng/opkrMyWJxIwqrr9I6jAMUv6CFQFgkZjc46hydF1qpu3cQyb4Cp9IBCu86P6hx8awV/byXJ+X9k6+KuapM512yQN2V+V7CEJYIQrvKj+0eo+aC13SYGIQN1DG4zgr7ogKes6+d6ZKd9JMcFfVUvNe+m+0ASnDLmrSu0D646ausBYwP9RoIcF1OesKlqC18xE64frAj3cQm4+3QRa3lOuxFquOSOfh9H1E1ubtSlAAQpQIBMEkp4B3B6apmk47bTTjNvvfvc7fPjhh3juueeMoaKbmpqwd+9eI1B89913Y9GiRfjWt75lDCmt1mOhAAUoQAEKUIACFKAABZIn4P2oFL7VZcYPl+7LZO665h+P2tuD+nvccYbEfyskU3CnzCf62Gbk3nJie1X5WjcEotm8x7KJ2HXbZgMX2SL/3Ks+hg1H1xnQvI1j2ARX6QMBNWx7uMYPlRXklHkEO/s3teaQgNpSoP5hHf61FfCsOAjnacwg6oPDltG7DB5oMOahV4MUqO8kc0HnvwPZT9YQlmxg32oddQ+tR+GvT81oP3a+9wVMeZFRMcKNie07Wt+UJ+Pws1AgRsAs7yl1yZ6e4GyJeqNubCX6nozZJB9SgAIUoAAFDIEezQBua+zxePDSSy/hD3/4A/74xz9CBX9jixoievny5bjoooswY8YMlJSUxC7mYwpQgAIUoAAFKEABClCgmwKel/caW7DPkeCvu/Mf2lVFFUByLo7Ua3ptH9TwsSzJFVCB27a3ZOyh0GbFUIcN6vfE7Yj/uO2VulWyjgr+DpH1WdJDQP17uumVyL+hHXLOdhb8jfZIXQDimBc5v6OfDdFlvKdAbwh45HtFjTJhnabm/O36O0m1yXGa1LMCPpn3Us1nz0KB3hSwjlcTK8hAC3skYCefu/EWVV8V63iZ1JqFAjEClub3RHBP/O8ntXpwd2Qj0fdkzCb5kAIUoAAFKGAI9HgAOBQK4fXXX8dVV11lDP98wQUX4LHHHkNFRYXRADVnsMr4ffXVV/Hd734XgwYNMl5fs2YNZs2ahY8//piHigIUoAAFKEABClCAAhRIkoDvkzJjS2rO33iLuViCxQXyQ6cMexjcURvvaqyXAgIXDZIDJ+VphONuTbTuhbKuiaMyxe3W1xWDe+slM9ILTWITliHxBdJUm62TIi33fVre113g/jNQIPq+U8OSx1tU9rp1dKS2bw3ft/G6sV5yBFQA1zzMbWRrBjbEt01d5mRXWeuqOBbK/BssFIgRcDa/J/yfybQMnviCwIHdOkKlcqFmthX2kyPTLcZskg8pQAEKUIAChkCPDQGtArhPPvkknnrqKRw+fLgVt9lsxllnnYVrr70WX/jCF2C3R4ZPOfvss3HvvffijjvuMO5LS0uNoLCaP5iFAhSgAAUoQAEKUIACFOiegB4MI1wl8/jK7+ym/MS2ZSqUH6UkLTRU1gTrccxeSUzvSO3YIZuPvJqcR+1tO1RWAG3pq3jLH8ZsCQKfhc6vAX5H6ryqsoUtGv754HS8PMSdnMZxKz0uECqLZEKaIzH/uPdnypYPBKsuwYyA/PAclGHhe+xngrjbxIqZIxDN4FUXGSVS1HeSKtH3feQZ/0+B3hHIvm4San7yCTyv6TBLPLerocs9r8hnbJ18tU7IhePUwb3TSO4lbQRsUwpgnz0QPpmmpekFXYbDlz/VTfLd3EEJN8iIHy9GAsXZVx0Hzdr533YdbIYvU4ACFKBABggk9RtCzeWrAriTJ0/GySefjAcffLBV8HfChAn46U9/asz5+/LLL2Pp0qUtwd+otdVqxT333IO5c+caL73//vuoq5O/klgoQAEKUIACFKAABShAge4JqB+T1L8A1G9G8SUYHNlfNIHUktR/QhzZPh/1iIC52Imc5nmb75Pg7pNyC7Rz8IPymsr8vUtuquTccLxkkTL42yMHpYc2qpmbfyyOnquJ7Kd5nc5+cE5kc6xLgXgFOnrfhutl7vm9OgLb5f6gBM8kg7JVib5n5WIVFgr0toBzyQgZinwIdC/Q8Ed5n+5o8/5sblBY5mhtfDYM/zoJ6DnMyL99RlzD8/d2f7i/vhfI/d5JMoKHTUbaARqf0hGubf89Fdyno/6xyAUFthMK4f7S+L5vPFtAAQpQgAIpK5CUS3vr6+tx7rnnYtWqVUfNf5GdnY0vfvGLRrZvNKgbj4Ya/lkFf4PBIPbt24cpU6bEsxrrUIACFKAABShAAQpQgAIdCKjgjrnYhdDhJoRlRhZzAiPGhZpH2TQPdHWwdb6cqgLuC0bLD4k+1P92Ix6RAO8L0tAFkgY+Qm4qdFIiwd+VcpORBI2S9dVJyLpsXPMz3qWLgHlQ5NwMybmt5qWMZw5g1bdQlfzIHFKjAtih2c3p0l22s58IqPdtcE+9zOUr78EBEkjbJHP7fiBDm7YeSM6Y89c6QTfm/zUXakZ9RcDvpH7yRkizbqjP17w7ZqL6to/k/XoYjU9LJvBgmct6vHyv5khn/DI/q1y4ENgqjwMS/M2youCe2Zz/N82Oc2821zLYjcIH5qHqVvktfLcPdb9R7yd5Xw2X95RDvtfr5a20Sz4bSyKtsk4rQMHP5kDjhZm9eZi4LwpQgAJpJ5CUAHBTUxNWrlzZ0nn1h9Dpp59uBH0vueQSuFyJ/0hUU1NjbE8ND33ccce1bJsPKEABClCAAhSgAAUoQIFjF1BDzDW9sBv+9Tqci+PLnFJZWGroQlORE9Yx6pdNlnQTyL5qImwT81H7689RsbMOz0rAt20auGVUNnJuPB6OOYPSrXtsrwhYhmYZ81KG9jciuEviZWPjY1GfBaqozwYWCvS2gDHs6Yel8K3V4V8rQTN57xrFJsFd+SjS5D4s3z9hmb4+sFFum1QQWLKC90gtyXq3z0jgSqbIlvl/CiRFQA2XX/CLuWj82w7JyNyC0CG/3I7O2lRDPqvvVsuwrKTslxvpvwK2yQUo+uNiCf5ukOHFSxDYIp95W1q/pzSnGVlfmYAs+buOQz/33/cCe0YBClAgWQJJCQBHGzNq1ChcffXVxm306NHRl4/pftmyZbj55psxcuRIWCxJbeYxtedYVyoqKjoqK/pYt9V2vYoKubSbhQIUoAAFKEABClCAAgkIuCQbVAWAfR8DthMks2BA50FgNeym583Ij0/uC7v3N34CzWTVHhCwzxqIoifOkABKtRz/UoRKZc5YObTmgU4jiGKdKvMFy8W8LOkroLK96x6SH47lnLWMkOCZtfPjGarWZc7BSH9dPL/T98CnccudZw1H3e82ILQrMqaz5gYcizTYpsr7NzqsufQvXKfDu0qCxGsA77uRDjvPHApTjkSIWSjQRwJqZJUsGYLXfeEY43vVv6EKoUovTC6LXJCTBce8QcbFOX3UPO42DQXMcrFl/n/NRM71U+Uz7xCCJfUI1wdknmk7rHIhn/2UgTC5rWnYMzaZAhSgAAX6QiApkdWsrCy8/vrrOOOMM5L2g8GMGTP6wiPp+6yqqkI4HPmHTNI33osbVMHmZPQjEJCxb1goQAEKUIACFKAABfpMwDYpH85zRsLz8l5jyEL35RIAlOE02yt6QEfT8zLc3CGpM9gF9+WcZ6w9p3R6TQV4bVMKjFs6tZttjU/AvXQcGv+5B6F9DTLvpA73xSqDsv3zWwV/1TyDaqhSx+JhsJ8wIL6dsBYFkihgLnDIyBK5xoUppgIg6wpNgrpHv2fVa65zNFiGy/fSC5GLkhyLhiWxJdwUBY5dQM3v6zh1iHE79q1wTQocETAXO+U7fMyRF/iIAhSgAAUocAwCSQkAqyGeb731VgwfPtzI/lXDPvPK8cjRUENjX3vttdi2bVvL4Rk0aBDM5vSZW+n666/Hww8/3NL+ZDwoLY3OMJaMrXEbFKAABShAAQpQgAKJCOTdepIBfEcmAABAAElEQVQMn1ln/OBe/4gMp3mKDBd7vAR58yI/uuu+yLx13pU6wtUSQFJz1/18LtRwhywUoEDqCqg5fAvvn4vyb7yD4A4/6n+vwz5fzu+JMoS7I3J+h2sli3K9ZFHKPKvwydDRE3KR98OTU7ZTaj5j30el8K44KPMiSiZUnR+mPMmEknY7Fw6D7fjClG07G9a1QHBvvQxxKl80JsB9WfvB39it2Kap+X/lPfE+jKF3nacPjV3MxxToE4HArjp4lu9HYEOlkQGsSQawGvLZMW+wDFk+JC2G6tUDYeNz1vueZJ3ub4DeFJQLBOUCjamFMmXIME4B0ifvLO6UAhSgAAUo0D2BpPyCo4Kc69atM26bN2/GpZde2r1W9aO1586diw8//BBLlizB6tWrjZ5dd911uOeee9Kml2po74EDByZlKOvKSvljOBSCzcZhmtLmDcCGUoACFKAABSjQ7wRUpkrhQ6eh9qdr4Hl9n/zgJ0NrrpBu2nUZclNGBW460mWLzPlb8NNTZDjZ7CMv8hEFKJCyApaR2Sh6dCGqfvghgttq4XlJhnF/SS7kcMlc3iFptgR9o8WxcCjybp9hDFcafS2V7v0SGKy9bw0CW2uOapZ/TbmMYrADtpnFyPv+dFiGyNjBLGkn0PTGPhnfWaYkOFEuQupiSoJo5xzzNfg+kQsZPqtA8HATLINc0UW8p0CvCqgLUmofWCvztcr7uE0JrK+C55USmOWzKfe7J8IxRya1TtHiff8Qav97HUIHG1u1MLizDr7VZWh4dDOcZw9H7i0nctj1VkJ8QgEKUIACFEhtgaQEgDdu3NjSy3PPPbflMR9EBPLz8/HGG2/glFNOgQqQ33fffVi8eDEWLVqUFkTf+973oG7JKNOnT8dnn30GZcJCAQpQgAIUoAAFKNB3AiaHBfl3zoJLhpdrenYnvB+WQpc5xoyBNS0yTLAMB+v6txFwLhnZah7Gvmsx90wBCsQrYBmahaLHFhsXeKjh3n1rK+TCjugcqxaZQ3CQMbSkfXpRvJvs9Xpq7sOq2z6UIarD0OT6E/t0Gf53hASynRIvbIBkA6sAoCz+uAzl176FwgfnwTZZxhBmSSsBFchXxTrx6GGfO+qIGtbcOkZGqtgix1/e25Yl8sZgoUAvC6iLDypvWImQZMtCLp6znSDv4/Eqi10upJOh9YMH1ftTptGQoGrVd95DzrdPQNZl43q5lV3vruFvO1D3y3XSaEnEl68E24nyWTtETR+g5t4GAtvls1YWqyC3f2M1BvzvqTAP5EUXXcuyBgUoQAEKUKDvBZISAJ48eXJLT2pra1se88ERgZycHDzyyCOYP3++MZfulVdeaQSD1essFKAABShAAQpQgAIU6CsBNe9ndO7PcIMEgP0hmPLtnNKlrw4I90uBJAloJpkzVQJj6qaGUQ7X+I1hSE0ypHuql8COWlT/6CMj+GubDjjP0qDJhSnRYi6WQMsYDfZ5kflgg9v9qLr1fRT9cTHMRRIhZkkbgVC512irmv83kWJqvqY8VO5JZDXWpUBSBHRvyPjMUcFfsyT2ui+VwG/zNBrRHViGy4Urs2TQBRmu3PuOjroH18Ey2JVS8wR7Vx402gX5eHUsks/UORL41WI+awdGgtqOuTJn/DMSzJb+VqrP2t8vhBpNhoUCFKAABShAgdQWkFlWul9UUHP06NHGhl544QWUlJR0f6P9cAtz5szBDTfcYPTs4MGD+N///d9+2Et2iQIUoAAFKEABClAgXQVUYMhc4Gj141+69oXtpgAFjgioH/TNcmFHOgR/Vatr7/8MKsCihgV2nWNqFfw90qvIvMbupZKtJj9HhKt8qPvNhtjFfJwGApq1OdikhidPpDTX1yxJ+VkrkT2zLgXQ8NftMs96LUwyBXnWFUcHf6NE6rPXMU9uiyPv85r710L3Jfpmj24tuffqM1a1RxXVPsdcudAmJvgbuzcV3Db6KRdqBLfXouFv22MX8zEFKEABClCAAikqkJS/lM1mM9566y3MnDkTNTU1mDZtGn75y18ac9+qOV9ZjgiouX+jwfIHHngADQ0yVAwLBShAAQpQgAIUoAAFKEABClCAAvCvr4T/80qZsziS+dsViZHpfJ4EVyQZzfNaCZgR2pVYai03D4rM3RwqTaxdobJIfbNkVLJQoDcF9JCOhqciAVDXORI0dTRfxNBJI+yz5SNqsFyoIhnrntePni+4k1V7bJFH5t9W7VHtUu3rqqh+OqW/qjT+ZbvMKW9MGtLValxOAQpQgAIUoEAfCiRlCOi6ujrcfffdmDJlCrZu3Qr1/Oabb27pVm5uLrKyslqet/fglltugbr19+J2u/HUU0/hxRdfNLq6e/duI2De3/vN/lGAAhSgAAUoQAEKUIACFKAABboS8K48ZFSxTVNzUHYdWFGVTbkyJ+w4mRN2qwy1+v5huC8Y3dVuuDxFBOxzBsL3wWEJ/OuwTY3veIdrdAT3SgfMMmTtDBkPnIUCvSjg31AJvdZvZP9aRsb3nlWZtWo4e8+/dKj5zV3nj+rFFre/KzX8syq2kzvO/G27pnWUZDsXypQClX4oh+gUIm3r8TkFKEABClCAAqkhkJQAsMfjMea37ahLal7gruYGrq+v72j1fvf67NmzoW4sFKAABShAAQpQgAIUoAAFKEABChwRCJZEfhswD48vsBJdU9UPbFWBwcz5bSHa93S+d501HPW/24jgziD8cvxsx3V+3NV81k2vSeah/Oc8e3jaDGuezseIbW8tEP2MUXP8JlKi9aPrJ7JuT9QNlkRGJLQMS2zrqr5fBntU/WAAODE71qYABShAAQr0tkBSAsDqSrYBAwZ0q+0uF4ft6RYgV6YABShAAQpQgAIUoAAFKEABCqS5QLgxYPRAsyfWkWh9vXn9xNZm7b4SMOXakf2NKah7cB2antehXQpYx7YfBNbDOjyvSJBfRt/Vsq3I+fcpfdVs7jeDBaKfMdHPnHgpovWjn3HxrtdT9cIN/KztKVtulwIUoAAFKJAqAkkJABcXF6O8vDxV+sR2UIACFKAABShAAQpQgAIUoAAFKJCGAub8SORXTzCRN1rf1Lx+GnY9Y5ucddk4BHfUounFPWh8Wod1mg77dA3mIRLoNWkIeyTou1OG935Php5VPz3ZTCi49xSYi5lIkLFvmj7suCnfYew9nOBnVLR+qnxGmQrsMpSzF6pdpuz4QcORxGFEHeJfkzUpQAEKUIACFOhtgaQEgHu70dwfBShAAQpQgAIUoAAFKEABClCAAv1PwDqpAJ439iOwU4YDPr79TND2eq3qq2KdlN/eYr6W4gK5P5guAV8X6h/dgsDnYblFjiesch9JVDR6YB7qRv5ds2HjcU7xI9p/mxd97wV3y0jkkpWuLlKIp6iLGFSJrh951nf/V+0Ibq81Lq6wyMUW8RTVX9VvVWyT+VkbkeD/KUABClCAAqkrYErdprFlFKAABShAAQpQgAIUoAAFKEABCmSSgON0iUTILxWBzUCoqjkI2AVAYI+O0AHJFnVbYJ89sIvaXJyKAmpqsexrJqH4r2fBffl4mIdnAWYJrEnwV3OYYTu5CLnfOwnFT5+VMgG0VHRkm3pewDIyG5axOdA9Mhfumvj2p/t0+D6OfJ45Fyc46W58u0i4lqO5Hapdqn3xFP+nEvSWfqv+W0YkkDYcz8ZZhwIUoAAFKECBpAukRAbw4cOHUVFRgalTpya9g9wgBShAAQpQgAIUoAAFKEABClCAAukhYBnshuv80Wh6YTcan9GRfbUEAO0dZ9iF63SpGwleZF11HEyOlPiZIz2wU7CV6vjn3ni8cVPZhrovBJOTxzQFD1VGN0nNW139vQ/geVM3hiq3DOn4M0q9jxtlfmu9SbJmTyiEfVZqXKTikHao9vjXVaJRPkPdMv92Z9nMwYMyB/fyyGct59/O6Lc/O08BClCAAmkkkPS/og8cOIBnn30WZWVl8Pv9CIfDrThCoRDULRgMoqamBvv378f777+P22+/nQHgVlJ8QgEKUIACFKAABShAAQpQgAIUyDyBnBumwb+2AsG99TIksC4BYck4G3Z0gCWwQ4K/L0lgReaktJ00AFlfnpB5WP24xyoYpTH424+PcPp2zXnaEPi+MApN/9yDhid0OM+Sz6ATJYAqmeyxJVQpn1H/khEKSmRZjg15P5oRu7jPH6v2lF/3NoLb/Gj8s/TjHEm8L2zdB13X5fMY8Lwuwd8g4JJ+O06Nc8zoPuphuM4P/8YqhMo9cgGRGZYhblgnF0BTowqwUIACFKAABTJIIKkB4G9961v4/e9/j0AgZoKWDMJkVylAAQpQgAIUoAAFKEABClCAAhTonoDJbUXBL+ej6tb3EdxRi4Y/qiw7HZbhEkRxaQg3ROahDFdE9mObUYSCe0+BZuEsV92T59oUoEC8Arm3ngQ9JFmx/9orNx3elTIH+TgdphwNul+CvgclXrpXtiZxU9MABwrunwvLUBnaPIWKak/hr5o/a/d6Uf+wfM6OjGQ1azb5rK3VZT526UJdpNHOc0dC9TtVS0C+L+p+txG+Dw7LHAKRbOVoW1UA3n3xGGRdMQHqO4aFAhSgAAUokAkCSQsAP/7443jooYcSNjObzZg1axZOOeWUhNflChSgAAUoQAEKUIACFKAABShAAQr0PwHLIBcG/N/paHhyGxqf2i7BlKARUDGiKc3dNeXbkXXNRONHfQZ/+997gD2iQCoLqM+c/NtnwHHKQCPoGNrf2DwncEzg0aIZQ9pnf30yzPJ5lYrFNjEfRY8vRv0fNqHpxT0IypzqwT2qpUf6YR7mhhr22XmGXIWToqXx2Z2ofXBdJPAr1wJZRkrgPV96ITlKoVIgXOGXi4m2wPNaiRGMt47NTdGesFkUoAAFKECB5AkkJQCshnm+5ZZbWlp12WWXYcmSJRg4cCCWLl2KpqYm3HnnnZg2bRqqqqqwevVqPPHEE/B4PFi4cCHeeOONlnX5gAIUoAAFKEABClCAAhSgAAUoQAEKqPl8c742GdlXHgffp2UI7q6HGtrTlGeHdUKuzF85gFm/fJtQgAJ9KqCCoo7FwxDYUgP/+kqEq7wyUoFFhq3Pgn32wLTINjUXOJD3n9OR8x/T4FtdiuD+BpmzOAhToQO2qYWwTsw7anjrPkVvs/PGf+xC7S9knGoptpmQIao1mGS0iNgSPCDZ2q9KZvahJlQsW4GiRxcZQ0PH1uFjClCAAhSgQH8TSEoAeN++fUZgV+F885vfxG9/+9sWp/nz5+P1119HY2MjLrroIuP1r371q/jyl7+M8847D2+++SaeeuopXH755S3r8AEFKEABClCAAhSgAAUoQAEKUIACFFACag5Hx9zBgLqxUIACFEgxATX3r21SvnFLsaYl1BxTlhXORcMSWqevKwf21KH2gUjw13meBvuJrQO/0fZZhmrIuhpofEYynHf4Uf3j1Sj6w8LoYt5TgAIUoAAF+qVAUibI2bZtWwvO97///ZbH6sG8efOM58uXL2/1+oIFC4zMX/VH0s0334yamppWy/mEAhSgAAUoQAEKUIACFKBAvALej0pRfc8nKPvKGzi85EWUXvwKKr+9Cg1/34Fwo4z/x0IBClCAAhSgAAUo0K8E6n+/yRj22TYdHQZ/ox3WZEhu90UaNJmKObCxCp4VMlEzCwUoQAEKUKAfCyQlALxjxw6DyOVyYeRImWQhpkyaNMl4tnHjRoRCoZglMOb9VcNCl5aW4q9//WurZXxCAQpQgAIUoAAFKEABClCgK4HgoUZUXP8uqiTY63lpL4K76hCu9RtD/PkkKFz3wDqUXfoqml4t6WpTXE4BClCAAhSgAAUokCYCYRmm2rvqkAwTIcM+n9Z+5m/brmh2yRKeE6nreZ1/G7b14XMKUIACFOhfAkkJAKvAryr5+flH6UyYMMF4zev1IjZTOFpRZQKrsn79+uhLvKcABShAAQpQgAIUoAAFKNClQGB7DcqvfQv+tRUy3578+He6DO/3NQ05t2jIXqbBdaEG8wggXONHzZ0fo/4RyRJhoQAFKEABClCAAhRIe4HAlmpJ5Q3DPAQwZcUXAFadtkZ+qob/88q0N2AHKEABClCAAp0JJCUAPHHiRGMfZWVl0HW91f7Gjx8PNcyzKuvWrWu1TD1RGcCqMABsMPB/FKAABShAAQpQgAIUoEAcAirLt/LW96HLvWUckCMBX8d8DZZBGkwuCfzmy3x8UyUQfJUJznPl3yPyL5/6P2yG5819cWydVShAAQpQgAIUoAAFUlkgXOk1mmfKTayV0frhKt9Rv2MntiXWpgAFKEABCqS2QFIDwIFAACtWrGjVY5UdPGSIXIol5ZNPPmm1TD1ZtWqV8VpVVdVRy/gCBShAAQpQgAIUoAAFKECB9gTq/7gZ4VIPzMMA91KZz02G9Ouo2E/S4Dw7srz2wXUIe4IdVeXrSRIIlTUZwfaGp7ej8fld8K0uhe5vPSVQknbFzVCAAhSgAAUokIECmsNs9FoPJNj55vqa3dyStJTgFlidAhSgAAUokBYClmS0Mjc3F6NGjcKePXvw7W9/Gy+//DIGDx7csumTTjoJBw4cMOb5ve2221qGig6Hw0ZdVXHMmDEt9fmAAhSgAAUoQAEKUIACFKBARwK6N4TG53Ybi13nSPDX3HHwN7oN+8maDPWnI3TAB++b++E6f1R0Ee+TKOBbV4H6hzcaw3K33azmNMuw3GOQfc1EmHJsbRfzOQUoQAEKUIACFIhbwDw0y6gbOgwjkzc6AmVXGwjKtMGqmIe4Iw/4fwpQgAIUoEA/FUhKBrCy+dWvfmUQrV27FpMmTcKyZctayK655hrj8f79+3Heeefh+eefxzvvvINLLrkEFRUVxrLoUNAtK/EBBShAAQpQgAIUoAAFKECBdgR8a8oAXwjmofLjXXHXwd/oJmwnRup632v+5S+6gPdJEah/dDMqv/luJPgr8V2LzLFnn/X/7J0HgFTV9cbPlO2NLewufZdeBawUFcWIxF7QWPI3dsUWNCZWjCYkGnus0WgSG1YUTYLBikpRQEC69LLAsr2X2Z2Z/3fezCyzy+zOm2WALd/Ry7x579777v2992Zn3vfOOSKRo3Gc8HywuxrC/VsbJe/yz6VuQ0lY9slOSIAESIAESIAEOieBiL6JYsuMFXe5SP1m8wwcKzzpC6PHZ5pvxJokQAIkQAIk0A4JhE0APvvss+Xyyy83EJSWlspHH33UgOO8884TzQWstnDhQtH3J598siEE67rExES59dZbdZFGAiRAAiRAAiRAAiRAAiRAAi0SqM+pNLbbPJlmWqzrv9HurV+fU+G/msthIFD+r/VS/ve1ItDYo04QSZpmkfiLkH95klViz7BKwtUo1yI3M0J2a+juglu+lfpdPA5hQM8uSIAESIAESKDTEoi7qJ8x9+pP3eKu9Qi7LcGo2+KWujWoEYHvJ4hKQiMBEiABEiCBjkwgbAKwQnrhhRcMT+D+/fs3CulstVpl7ty5MnAgHgFvYjExMfLiiy9Kenp6ky18SwIkQAIkQAIkQAIkQAIkQAL7E3B7c/haIvbf1uIab30NIU0LHwHH2iIpfxF3UyH+xk1BvuUJVrFE7u+ZbcuAKPx/FrHj2WB3mUOKf78kfINgTyRAAiRAAiRAAp2OQNwF/cTeL1FcRSIVb7nFVdm8CFy32S2Vs7Ad/ydcOVjs8B6mkQAJkAAJkEBHJhCWHMA+QLGxsYYn7y233CIbN270rTZes7OzDe/f119/3Qj/rKGfNTfw1KlTZejQoY3q8g0JkAAJkAAJkAAJkAAJkAAJNEfAlhptbHKVNlcj8HpffV/7wLW4NlQC5S/B8xcWNRYONYP2F379+9N8zXHniZQ9rx44RVLz7W6JPiFEV27/DrlMAiRAAiRAAiTQaQlYIm2S8ug4KZj6tThzqqUc3y8ij3Ub30dsXaD11otojmDHj/jesc6DKea0XhJ/xeBOy4wTJwESIAES6DwEwioA+7BZLJaA3r6pqakybdo0o/jq8pUESIAESIAESIAESIAESIAEQiEQOSLVqF6/BTf2nG5RUdGM1W/0eIVEeNubacM6LRNwldZK7ZK9SPIrEj3O3HFQ7+CoMSI1n7ul+vMcCsAtI+ZWEiABEiABEiCBFgjYu8VJ139MlJIZP0jtolyp/VZQAngCRyIdxVVDJP7yQaL3rmkkQAIkQAIk0NEJHBQBuKND4/xIgARIgARIgARIgARIgAQOHwF7nwSxD0yS+g2lEB8hPEJMDGaucrfULvfUivkZEtHSwkLAsbYYSX1F7FmIAB1t/mZqRH8VgOGRsxoxG2kkQAIkQAIkQAIkcAAEbCnRkvrEeHzXy5fq/+2Ax2+hOAuqkZLCJrbucXhILVNiz8wSW3rMAeyFTUmABEiABEigfRGgANy+jhdHSwIkQAIkQAIkQAIkQAIkAAKJNwyXotsXSM1XbrFlIvRwVvPio7sWOd/ehydIHcTik3pI5OBkMgwTAVdhjdGTNTG0Dq1Jnvq+9qG1Zm0SIAESIAESIAES2J9A1OiuooVGAiRAAiRAAiSAB7VDgfDWW2/J9OnTQ2liuu6tt95q5A823YAVSYAESIAESIAESIAESIAEOi2B6LGZEndxf6l8e5NUvuWW6AnIQXssvFDtjYXgum0IM/yJW1yFiFLcLVa63DW60zLzTdwJ0bZ2SZ4486oQQxtcMmIl6qiuYusauleMJdbzk9Lt8PVu7tVX39feXCvWIgESIAESIAESIAESIAESIAESIAESMEMgJAG4rKxMNm/ebKbfkOsUFyN0GI0ESIAESIAESIAESIAESIAETBJIvOUIKL4WCMAbpeZLt9TM11DEblFvVHetiHMXohN7Iwzb+yVKyqPjxJoUZbL3jletbmuZlD2/Wmrn7wk4uagxGZJ40wiJ6O91zw1Yq/FKe894Y0V94C4bV/Z759zteWPrGee3loskQAIkQAIkQAIkQAIkQAIkQAIkQALhIBCSAGy32yU+3vMDPxw79+8jMjLS/y2XSYAESIAESIAESIAESIAESKBFAharRZJuPULUG7jspTVSh3yy9RsaN7F2iYSn8ACJ/8UA5Ki1Nd7Yid5Vzd0hJX/+AUl3NWEv/s+G5683QqKrANGxt4rUfrdX8pfmwUv6SIk9I8sUHfuAJLHCc9iVXy11m90S0a+xB3ZzndQug+sxLHp8t+aqcD0JkAAJkAAJkAAJkAAJkAAJkAAJkEArCYQkAF999dWihUYCJEACJEACJEACJEACJEACbYVA1DHp0hWlPrdK6tYWiYY4tsZFiL1XvEQMSxEVijuz1Xy7W0oeXGKEe44cBdF1okWssY2ZuKrhQT3PLY4f3FIy4wexxNglZmLPoNgs8MCOv6S/lD29SqrnusV+FZyyoxv33bQTxzq31G9EPYSPjj07u+lmvicBEiABEiABEiABEiABEiABEiABEjhAAiEJwAe4LzYnARIgARIgARIgARIggcNCwF0Pr0ebBdGCWxamDsvguNOwEbBnxooW2j4CrjKHFP9xqSH+Rp9kkejjA18D1hiLxP4cwnAyhODPPSJw5Kg0saVE7+usmaW4C/pJ1Sc7IOqWSsVMt8RdKGJNCLwfxxq3VP3b4/2bOHW42JI7b0huf5xuN5g43chhbfVfzWUSaNME9G9rez9njWsPXxEs+I5AIwESIAESIAESIAESIIGORIACcEc6mpwLCZAACZAACZAACZBAA4Hqr3dJ9f92iuPHAnEVIyGs3SK2bnFGuOC48/uKvU9CQ10ukEBHJVAxc6O4y+vE3heev82Iv/5zjx5jkfrt6qFbLxVvbDBCbPtvD7RsibRJyiPjpPCmb8S5uxJ5ht0SdRTCQQ+CoIx0wu56aJvIEez4Ef1u8fQQd1F/iZvSL1B3nWZd3aZSqfxwi9R+v1ec8F4XF/JXQ3CPHJ0msaf3MT6rOg0MTrRdEHBV10vVR1sRLWCX1OGBD3dVPaIF2PD5kiTRE7pL3Hl9xRof0ebn4lhfLFUfbzXC3jvzqj3XXmo0Pre6Soxee8dmtPk5cIAkQAIkQAIkQAIkQAIkEIxAmxCAc3NzpaCgQIYPHx5svNxOAiRAAiRAAiRAAiRAAi0SqN9TKcX3LzbywTZUVMeeerc4d1ZI5c5NUjlrs6gAlXjTCHr9NEDiQkckUP1FjjEtM+Kvb/7RJ1ikYqNbtK3mWDZj6nnd9R8nS8lDy6Tm690QVjSnsMfT17+9JSFC1PNXhaLOau46l5Q+uUKqZm81PLMbOOBzyoXw5TWf5xglEmJU8oPHig3CFI0EDjeBmkW5CA+/VFxFeKDKa5pV3VntlLo1RUap1IdGfjdaYk4JHj7e18ehfHXXOqXkseVS/Z/tjXer115BDcLY7zRK1HEZ0uX3xzBCQWNKfEcCJEACJEACJEACJNDOCIRdAN61a5fMmjVL8vLyxOFwiMuFWDp+5nQ6RUt9fb2UlJRITk6OLFy4UO677z4KwH6cuEgCJEACJEACJEACJBA6gfrt5VJwwzxxlTjEEg+Px3EWeCEitGMi+sLXUmcuvBBXIs/pcrdUvrURno7lhuciQz+Gzpot2j4BV7lDnDkVIpGIgN7L/Hjt3REuPcYtLnjGOQuqxZYWY6qxNSlKUh4eKw6IQdWfebzvNR+zJcou9h5xEjUuU2In9xZrIgbUSc3tcErhtPn4DCrAQRF4HIpEHIHoBF0BBNGfXSUideshni/SfMz5kn/ll5L20kkMbd5Jz5dDOe0dM3Y1u7vXcvLl6h83iz7SMRTlFzhZjxTk/0apxNofUd5HWa4h5+/7Xu6fmSu3ZHcL2F/v+3oEXH+wV7prnFJwyzeeh8NwJyzqaHw0jkCUAr32VAAuxrW3zvPginrlF1zlufZsXc19/h3s8bN/EiABEiABEiABEiABEgiVQFgF4JtvvlleeuklqaurC3UcrE8CJEACJEACJEACJEACB0TAVVMvhXcsNMRfDXcbdwFErCjc1fUZxBY77jvbe1gk8ggIwO+4pXZhrpS9sFqSbh7hq8VXEugwBHyeelY8DBFq/msrHppwamRUePuZFYB94CKHpYgW2v4ESh9fYYi/+lBK/C8g/Gb4fUahui0ZZSyEqZEile9p1IJqKfrdQnhXT2z3uVb3p8E17YHAkpIKuX7lFkP8vQrC7//pkwp+Fgf1dJxRRD7Ak1bPoNy+drsMS4iViWmIAd9GrOThHwzx19oF3w8uxrWX1uTaw0eWbbz32nsX197uKim6axEewDiZkULayDHkMEiABEiABEiABEiABEIj0Pibe2htG9V+9dVX5bnnngtZ/LXZbDJ27FgZM2ZMo/74hgRIgARIgARIgARIgARCIVD59kbD29Gajpu7FzYRf5t0pCJw3EW4+Ytvw9qufmd5kxp8SwLtn4AlzvO8r9sR+lzc3iivvj5C74EtmhLw5B3dhqdQIP6qANVE/PWvb42FdyUEYisE4XrkWjXCRftX4DIJHCICt6/dJnVut0yByNtU/G06hPPxR/UKFPUUvm3NNqS13j8MfNM2h+K9Y2WhEdpZkJ447pL9xV//MVjj8f0AdTR/ed3aYqmes91/M5dJgATaAQH9e1vxzkYpe26VlL28Vqr+u100IgmNBEiABEiABDobgbB4AGuY59tvv72B3UUXXSSTJ0+WjIwMufDCC6WqqkoefPBBGTFihBQVFcnixYvl9ddfl+rqajn55JPls88+a2jLBRIgARIgARIgARIgARIIlYAbN5krZ20xmsWeBvE3orFnT6D+7D3hCTzSGw76w62mc50G6ovrSKAtErCmRIsKuO6KenjGu8XaJfh1ofNwVSD8M0IRS5RNbOmxbXFq7XJMVR94PqOijoGnYXrwY2GJtkjMzzyewJXvI2/5lH7tct4cdPslsLy0UhYVVwicZkW9f83YZRCK/4eKayqq5evCMjm5DXgBV36w2Rh6FPwObKnBrz1rjEWiJ4pUfajfLTZL7FlZZqbOOiRAAoeZQM23uyH6rjZSvAQaSvQpPSTxxhFi7x4XaDPXkQAJkAAJkECHI2DuG3yQae/cudMQdrXaDTfcIO+8845ceeWVcvrpp8vxxx9vtK6srJTzzjtPrr76annxxRflk08+kfj4ePn888/lrbfeCrIHbiYBEiABEiABEiABEiCB5gnUbyoVV0GN4bFj7xP85q6vp0jk3lSr/Q7JgWkk0MEIWKwQMZB3V612mXlPPMcyD4jo4zLwMEVYfjJ6Ouzk/9Ys8nzO+D53zOCwD0D4bqQg1Xzl9blVZpqwDgmEjcDcfH0SRGQCRN0YFDNmR71TvHX/521vpt3BrNOaay9iMEaEdOV1P5WIs4iegwfz+LBvEjhQAm6XW0qf/BEpExYZfy8tCbh8jxQ8yIHvQSdaxD4Qe0AqmJovdkn+5Z9LDfJ800iABEiABEigMxAIy6/5DRs2NLC66667GpZ1Yfx4JFGBffHFF8ar758JEyYYnr+ai+q2226TkhLPDwvfdr6SAAmQAAmQAAmQAAmQgFkC9Xs8wog1w2wLTz2bRxszcv2F1pK1SaB9EIi7VO96QgD+HiLi7uAisHOvW2oWeerFXQr1kRYWAu46l/GQijpRWtPMd6kivrWrp75zd6X5hqxJAmEgsLXKEwu+v0nx17dLX/3t1d5Y8r4Nh+HVVVkn7rI6Q8y1JZsTsXWYFpuGivYM2On9jnEYhs9dkgAJmCBQ/rc1UvnuJkPkjZlkkcRbLBJ7uhUPwXkE4PiLrJJ4s0X0wQ53ZT2E4oXiWFtkomdWIQESIAESIIH2TSAsAvCmTfgjC4uNjZU+ffo0IjJkyBDj/Zo1a8TpdDbapnl/NSz03r17Da/hRhv5hgRIgARIgARIgARIgATMEnC4jJoWPN0fknnru+tdomGkaSTQ0QhEDk72hA7GT7HKt9xSt63587x+p1sqZmI7tBINeRo1MgSlsqOBC/N8VAA2DJ85+hB0KGbxJm5q6COUxqxLAgdAoBbpvtSQOjck89WvdTb/eRNShwdQ2e37ftCaBGi+7wiOxveyDmA4bEoCJBBmAprju+L1n/B0FXJ8X2yRqGORCgYPTzU1awLye0+xGp7Bgs+F4geWiH7/p5EACZAACZBARyYQFgFYhV+15OTk/VgNHOh54rympkb8PYV9FdUTWG3VqlW+VXwlARIgARIgARIgARIggZAIWLtGG/VdxSE1E199aypypYYoyoS2J9YmgcNHIPHXR0j0Cd3EXQ0R+A3ktHzXBc8XtzjzUPKRB3sd1r3vkopX3fCMQerfMRmS9NvRh2/AHXDP1lgExkVRcd1VGZoo5vucsqV5Puc6IB5OqY0S6B6NGMiw3RLaObvbO59u0T4p2LviMLxYu2AOdou4ESjEXRPaPIxc6BizrSvisNNIgATaJIGyl9ca44pCAMqI7P2F36aDjpmMyBqpIs6dFVI9d2fTzXxPAiRAAiRAAh2KQFgE4MGDNTmKSF5e3n6eEwMGDGi4mfbjjz/uB089gNUoAO+HhitIgARIgARIgARIgARMEogchAcRo2zizIW4Umr+Bm8dHAbUokbT09FDgv92RAIWu1WSHx4rCdcNNa6TOmTwqfrALeUvobzolqpZ8Axej5lHWiX+ysGS8th45v49CCdC5CjP54zvc8fMLlSkVwHYmhQp9qxEM01YhwTCRuCEFCTShM0PUQCeLx6vuhNTDv85qw93NVx7+7KXBWWkIfPd5bj28ICZrUdc0PqsQAIkcOgJuEprxfFDnhH6OXpMcPFXR6jewVFjPXWrv8g59IPmHkmABEiABEjgEBIIqwBcV1cn33zzTaPhq3dw9+7djXVLly5ttE3fzJ8/31hXVMTcC/vB4QoSIAESIAESIAESIAFTBCzRNok5uYdRt/orcwKwq8ottd956sac1tvUfliJBNorAb3hmXDlEMmYNVkSbz3C8PK1900Ue3aCsZx48wjJeA/brhtm5L5sr/Nsy+OOnez5nKlZAGHJYe5zqvpL72fUpF48Lm354HbQsZ2SliSZURGyBfP70ivqBpvqYtRbiUpJdpucnt4lWPVDsr3h2vsW115d8GtPU0LUeL9LxOL7ASOEHJLDxJ2QQMgE6n4qwZOfcPLvCWE3ypwArDuJ6OvZVd36EEMHhTxCNiABEiABEiCBw0sgLAJwUlKSZGVlGTOZNm2a7Nmzp9GsRo/2hA975513pLh43x9XF/LJzJkzx6jbt6/3r2+jlnxDAiRAAiRAAiRAAiRAAuYIJFwL70Z4MNatFqnxCrvNtXTXashb3AhGSMjII7tK9NjM5qpyPQl0KAI2hDuPv2SApD55vKS/eaqkz5xkLMdfNlBs6QxzejAPdvTPekrEoC7iLkUobnhgu+tbFqKq57mkfhNuaiN0dPwVnqhbB3N87JsEmhKItFrlDwN7Gasfg8qyLogn8FZs/5OqMbB7B/SQxIjWJN41mof1n5jJfUQfeFFv+qrZuPaC5Cau+cIt9Vtx7SVESPwvB4V1LOyMBEggfAScxbVGZ5b40Pq0eIIbiKukdr9IlqH1xNokQAIkQAIk0LYJhEUA1in+9a9/NWa6YsUKGTJkiNx0000NM7/iiiuM5ZycHDnzzDNl9uzZMm/ePLngggukoKDA2OYLBd3QiAskQAIkQAIkQAIkQAIkEAIBe/c46XLv0UaLms8h8H7oEmdxY4FFvXrqNiHs7T+Q+3QHQjsip2byg8eEsBdWJQESIIHWEVAvwuQ/HSeWxEhD2K34Jz6PtjX+jNKenYWePM21GiwLDk3JfzhWbCnM/9s66mx1oASu6p0ul/ZIE6QQl2nilJkQeKubCMGQUOR9rL8J28tQ76z0ZJmW3e1Adx229habRVL+PEYs8RGiIdgr/gWBd0eAaw850SvediE6CHatbWYcZ4RfD9tA2BEJkEBYCVjxkIaauya0bn319TOBHv6hsWNtEiABEiCB9kUgbI9jnn322XL55ZfLa6+9JqWlpfLRRx/Jc889Z9A477zzRHMBb9y4URYuXCj63t8SExPl1ltv9V/FZRIgARIgARIgARIgARIImUCshkmFYFI8Y6nUrXGhuMWa7hZbMm4O1UNY2YvXCk+36g2U8ug4saXR6zFk0GxAAiTQKgL2HvGS9uIEKfrtQnHmVErlG24IwviM6gqt14bPKGRGcnmekRZLjN0Qf6PHtx0hrVWTZqN2T+AfR/STRIR0/tv2vfJ3CL2vYkbqF5uMJxTg0C7rIQB7/PBELoNY/NKIvmLVP8ZtyOx9EiTtBe+1t6dKKl7DtZfkufYErhGuQk/RIasolAzxN+rYjDY0Aw6FBEigKQG9rtWcu/D93oVrGukuzJgzx1PL3tvrCmymEeuQAAmQAAmQQDskEDYBWOf+wgsvyFFHHSXPPPOMdOu270eqFWGD5s6dK5MnT5YNGzY0whQTEyMvvviipKenN1rPNyRAAiRAAiRAAiRAAiTQGgIxp/aSiOEpUv7yOuTwyxFXnhNlX0+2brESd2E/ibugn1giobjQSIAESOAQEojISpSur/9MKt/ehEgFW/D5VC316jbpNUucXWLwMEvCVUP4gIoPCl8PKwE7RJVnh2fLlG4pMmPjLvmmsExWGSPa50U7Ljle7u7fQ34O79+2ahH9k6QrQt9XztwglR9vFVd+jdSrgu01DfmsOX/jrxxMr3sfFL6SQBsmoA9V2bMTELK9HA99Iq3LCHODrV3q+eyKPnHfvWtzLVmLBEiABEiABNoXgbAKwLGxsYYn7y233GJ4+/qjyM7ONrx/X3/9dSP8s4Z+1tzAU6dOlaFDka+NRgIkQAIkQAIkQAIkQAJhImDvFifJ048W952jpW5jqTjzq8USZRMNE+3zFgjTrtgNCZAACYRMwBptlwTk9dVSt6VMnLmV4q5zwRM4RiIGdhGLPWzZmkIeGxuQQHMETkpNEi0FjjpZU15tvKYgz+/QhBjJiIpsrlmbWm9FTu2Ea4ZK/NVDpN649qqMnMCaA10FYl57bepwcTAkEJRA/P8NkpI/LJVqpH+x90F6l8SWvYAdPyIE/GaPp3/cOX2D9s8KJEACJEACJNCeCYRVAPaB0PwJAwcO9L1teE1NTZVp06YZpWElF0iABEiABEiABEiABEjgIBFQD9/IYSkHqXd2SwIkQAIHTiAC4ei10EigvRBIi4yQCame3JvtZcxNx6n3rSL6JRml6Ta+JwESaD8EYuC1X/3JDqldkicVr7slbgpSeGfsLwK73W5x/CBS/anH+zdp2hHM8d1+DjNHSgIkQAIk0EoCB0UAbuVY2IwESIAESIAESIAESIAESIAESIAESIAESIAESIAESIAEghLQvL/JfzpOCqfNl7q1xUgB45aIoSiDLGLtgub1yBGcK+JY6TZetcMERACIPSNLF2kkQAIkQAIk0KEJHBIBeO/evfLmm2/KTz/9JPrE1aBBg+Tiiy+WHj16dGi4nBwJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkAAJkMDBIWBNiJS05ydI2fOrpXLWZuQDdhul6d6sCPWe9OsjJGZiz6ab+J4ESIAESIAEOiSBVgvA9fX18vbbb8sbb7whq1evluXLl0vXrl33g/TEE0/IvffeKzU1NY223XPPPXLTTTfJo48+KjabrdE2viEBEiABEiABEiABEiABEiABEiABEiABEiABEiABEiCBYAQsUTZJum2kxF0yQGq+yJHaFQXiKqwRS6RVbN3jJHpcpkSf0F20Ho0ESIAESIAEOguBVgnAO3bskNNPP13WrFnTwKmwsHA/AfiRRx6RO++8s6GO/4LD4ZAnn3xSNm7cKLNnz6YI7A+HyyRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAiRAAqYJ2DNjJf6ygUYx3YgVSYAESIAESKCDEghZAC4oKJDx48dLTk5OIyQlJSWN3quwO3369IZ1/fv3l0suuUSGDBkiH3/8sXz00UdSXV0t//nPf+Tpp5+W2267raEuF0iABEiABEiABEiABEiABEiABMJPwO1yi2NVodQuyUMuvCoRt4gtI0aijkmXyCPSxGKzhH+n7JEESIAESIAESIAESIAESIAESIAESOCQEghZANbQzT7xNyEhQWbMmCFnn322ZGVlNRr4Aw88IOrlqzZq1CiZP3++xMXFGe9VCJ41a5ZMmTLFeH///ffL1VdfLYmJicZ7/kMCJEACJEACJEACJEACJEACJBBeAjWLcqXsryulfnv5fh1X/HO92HrFS9ItI4wQiftV4AoSIAESIAESIAESIAESIAESIAESIIF2Q8Aaykj37t0rr7zyitEkOTlZFi9eLLfeeut+4m9lZaUR1tnX92OPPdYg/vrWXXDBBXLVVVcZbysqKgxPYN82vpIACZAACZAACZAACZAACZAACYSPQPkra6Xo9gWG+GtNEokaIxJzpkVizrJI1FgRa7KIc2eFFP1ukZT9bXX4dsyeSIAESIAESIAESIAESIAESIAESIAEDjmBkATgTz75RFwulzFIDdk8ePDggAP+7LPPpKoK4cRg6hl8yimnBKx35ZVXNqyfM2dOwzIXSIAESIAESIAESIAESIAESIAEwkOgctZmKX95nQiiO0efYpGEmyD8/swqUaMg/o7E8ilWSZiK10mogF+IFa/+JBVvbQjPztkLCZAACZAACZAACZAACZAACZAACZDAIScQkgCsYZx99qtf/cq3uN/rV1991bDurLPOalhuujB06NCGVdu2bWtY5gIJkAAJkAAJkAAJkAAJkAAJkMCBE3DurZLSp1caHcWea5HosRaxWCH0NjFdF3WsRWLP92wre2611OdUNKnFtyRAAiRAAiQQfgLuOpfU76mUum1l4qqoC/8O2CMJkAAJkAAJkAAJdEICIeUA1hDQana7XXr06NEsLn8BeOLEic3W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fsVHRWBZSekV+//XWDdbXhrXWa0EwJe88ErBk+veMwwqKR+MdS+PdslzOM9dsqQYmnt1223Sr08aHgHulBih4Mlov40rPMbtsW6+KnYdPKDN3ti7x++DXPL7Nd+0kduyknJbcYSUdlunfyWrW4cAAQIECBAgQIAAAQIECBAg0C0FBMDdstmcNAECBAgQWCawZcxbenuEwFdOnZ5+EwHWvREET41eloMaGtIW/RvTu2O+3w9uMKzVsKYrLXP4e0QMRfuHl6YVkd07I8Q5KB5tEieVY94XY7klAptLIqDLc+DucvND6frdtko5YKqkHBFzx37nyRfTubH96asZcnjF/eQhlM+PdXM5sh3zzq64j858nEPdh/fZLuUA77II4h6MeVzzPMVDezakbeJayCF/DjEbYvjnaioLohfvAzPnpvyH50Vh/Eh8z31E3xPtfUC090bxOJ/xs7FcH/6/i3VujOWpWPJtC1MWLCrmdN4owu3VlXztL47rKfcwzsNIV1p2aV73jtdyv/naKC113bUdTkNi3U2D57HomZ/bcrd1Vj8PY10E9R+I98+ZT00p3nunVvDeWxxtfWHze+9f1297zudN+zUW81vndv99bJtvLGirvBzr/TGWXI6skd7ebZl4nQABAgQIECBAgAABAgQIECingAC4nO2qVgQIECBQQwK5V+R7Rg4plu5W7dzzN4e/ua/q/0RItO1KIU6euzUHO4fE8l8RDt0XQeB7756Y7tpzm9RYQe/cL4xbL/08hpW+K+afPS96Lx7bShCV+x7+MI7xWBwz9xz+9w3XrUrOHO4evcHwYqnKE1zFSeWhn3OpjyWHv1n2m/HTRiu197h4flw8/65oi5OjvZ6Mn/vGkstL0fatBcD5xodchq+0z+LJVr7kYadzySFzUwTIrfUyXrZm9/66cOnS9NqiJUUYv047rUbE+o9F2+S2aKt8edz66bxnX063RPh/cbyvWuuVvTT2+Z1YZ3LsdOO+vdNHRo9oa/fF66duPjodfOej6ZzYNofTOxW3kax609lxjK/GNbUgXn7/qCFVNTz6qs/YswQIECBAgAABAgQIECBAgACBNReobHy8Nd+/LQkQIECAAAECqxTI8/zmYZ/zHyOrCn9X3GhABE+nNfcUfXT2vPSjp3Lf4LbL0JjD98IdNilirvMjAPrvCICmxveVS5459ksRIl0R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AQIECJREQABckoZUDQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAiAXQMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoiYAAuCQNqRoECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQALsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBIBAXBJGlI1CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIAB2DRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAkAg0lqUe3q8aCBQtS7969233er776apo3b16x3QYbbNDu7W1AgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB5BfQAXott+9vf/jYddNBBaeTIkamxsTFtueWW6Zhjjkm33HJLxWdx7LHHptGjRxdLxRtZkQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmhAQAK+FZp4zZ0760Ic+lA4//PB07bXXpqlTp6ampqb06KOPpgsvvDDtvffe6cQTT1zes3ctnJJDECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQQgEB8Fpo1JNPPjldcMEFy4/Ur1+/NHbs2NSjR4/iuaVLl6bvfe97afvtt0+TJ09evp4HBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaI+AALg9Wmuw7v3335/OPPPMYss89PPll1+eZs6cmZ588sk0ffr0dPrpp6dBgwYVrz/22GNp3333FQKvgbNNCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBISQDcyVfBWWedlZYsWZIaGhrSn/70p/Se97wn1dUtY8/B7+c///n0yCOPpO222644k2eeeSbtv//+acqUKZ18ZnZPgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDZBATAndyiOdzN5aijjloe8q58yFGjRqUbb7wx7bPPPsVLeRjoQw45JOW5gxUCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUKiAArlRqDdebOHFiseVOO+3U6h4GDhyYrrnmmrTbbrsV691zzz3pAx/4QNF7uNUNvUiAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmAQFwJ18KCxcuLI7Qt2/fNo/U2NiYrrjiirTJJpsU61599dXp05/+dJvbWYEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJZQADcydfBpptuWhxhwoQJFR1p2LBh6dprr03Dhw8v1s9zCH/3u9+taFsrESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQ2wIC4E5u/5YA+KKLLkrTpk2r6Gjjxo0regLnHsG5fO5zn0sXXHBBRdtaiQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB2hUQAHdy2x911FHFEaZOnZry4ylTplR0xF133TXl0Liuri41NTWlD3/4w+nrX/96Wrp0aUXbW4kAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoTaKi9Kq/dGh9yyCHp7W9/e7ruuuvSn/70p7TlllumQw89NO20007phBNOaPVk3ve+96Wf/OQn6ZOf/GQR/J5yyilFINzqRp3wYh6S+vzzzy+C6De7+8mTJxe7mDdv3pvdle0JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEFhJQAC8Ekhn/Hj22Wen9773vemhhx5K06dPT+edd16666672gyA87kcd9xxqXfv3unjH/94Wrx4cZf0AP7pT3+aLr/88g6lmTFjRofuz84IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEEhJALwWroKNN9443XnnncVcvjn8nTNnTlpvvfUqPvKxxx6b3vKWt6Tjjz8+3XTTTRVv11Er5gD76KOP7pDw+Re/+EXRE/qwww7rqNOzHwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmgUEwGvpUujTp0/68Y9/nL7//e+nu+++O82cObNdR956663TjTfemC644IJ01llnpQkTJrRr+zez8siRI9Phhx/+ZnaxfNvbb7+9CIAbGlx6y1E8IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINBBAlK4DoKsdDc5+Nx1110rXf0N6x1zzDEpLwoBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRWFqhb+Qk/EyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgED3FNADuArb7fTTT0/33ntvcWY/+tGP0vDhw6vwLJ0SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAA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AQIECHSRgAC4i+AdlgABAgQIECBAgAABAgQIECBAgAABAgQIECCoQCncAAA50ElEQVRAgAABAh0tIADuaFH7I0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBcJCIC7CN5hCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0NECAuCOFrU/AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdJGAALiL4B2WAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECHS0gAO5oUfsjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAFwkIgLsI3mEJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQ0QIC4I4WtT8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0kYAAuIvgHZYAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIdLSAA7mhR+yNAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAXCQiAuwjeYQkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINDRAgLgjha1PwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHSRgAC4i+AdlgABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAh0tIADuaFH7I0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBcJCIC7CN5hCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0NECAuCOFrU/AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdJGAALiL4B2WAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECHS0gAO5oUfsjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAFwkIgLsI3mEJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQ0QIC4I4WtT8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0kYAAuIvgHZYAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIdLSAA7mhR+yNAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAXCQiAuwjeYQkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINDRAgLgjha1PwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHSRgAC4i+AdlgABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAh0tIADuaFH7I0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQBcJNHTRcR22xgW++c1vprPPPrvTFBYtWpQmT56cevTokerr6zvtOHZMgED1C+TfB/l3QUOD/+VVf2s5QwKdJ7B48eJi534XdJ6xPRPoDgL5d0FTU1Pq2bNndzhd50iAQCcJLFmyJC1durT4N0L+t4JCgEBtCuTfA/n3Qf43gt8FtXkNqDWBLNDyu2DkyJFp8ODBUKpA4IUXXqiCs+j+p+DT8O7fht2qBhtttFFxvlOnTk15WRsl/yGnECBQ2wL5g96FCxfWNoLaEyBQCPhd4EIgQCAL+F3gOiBAIAvkm0UVAgQI+F3gGiBAIAu89NJLxUKjOgTyjTkbbrhhdZxMNz2LHvGheFM3PXen3U0FJk2a1On/yLrrrrvSMccck7baaqt0+umnd1Mpp02AwJsVmDJlSvrIRz6Shg8fns4777w3uzvbEyDQjQUOOeSQ4uyvuuqqblwLp06AwJsVOPbYY9PLL7+czj333JTv8FcIEKhNgS9+8Yvp4YcfTnl0sm233bY2EdSaAIH03e9+N/31r39Nn/nMZ9IBBxxAhACBGhW46KKL0sUXX5w+9alPpRNOOKFGFaqv2v37908bbLBB9Z1YNzojPYC7UWOV5VTHjRvX6VVp6V08dOjQdPDBB3f68RyAAIHqFHj66aeLE2tsbPS7oDqbyFkRWOsC/i5Y6+QOSKCqBPr161cEwG9729tSy+hEVXWCToYAgbUi0HKj+K677pr23XfftXJMByFAoPoELr300uKktt9+e58ZVF/zOCMCa03gzjvvLI6VO5BsscUWa+24DkSgswXqOvsA9k+AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECa0dAALx2nB2FAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECnS4gAO50YgcgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDA2hEQAK8dZ0chQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBApwsIgDud2AEIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCwdgQEwGvH2VEIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQ6QIC4E4ndgACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAisHQEB8NpxdhQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0uoAAuNOJHYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJrR0AAvHacHYUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKdLiAA7nRiByBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMDaERAArx1nRyFAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgECnCwiAO53YAQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQILB2BATAa8fZUQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINDpAgLgTid2AAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECKwdAQHw2nF2FAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHS6QEOnH8EBCHSBwMCBA4ujDho0qAuO7pAECFSLQP/+/VN9fX3yu6BaWsR5EOg6gfy3QVNTU9edgCMTIFAVAvl3QV1dXcp/IygECNSuQMu/D1q+166EmhOobYGWzw9bvte2htoTqF2Blt8B/i6o3WugrDXvER+E+SSsrK1b4/X661//msaPH59GjRpV4xKqT6C2BW677bY0YsSING7cuNqGUHsCNS7w4IMPFgLbbrttjUuoPoHaFpg0aVKaOnVq2m233WobQu0J1LjAiy++mCZMmJD233//GpdQfQK1LTBjxox08803p4MOOqi4Qay2NdSeQO0KLFiwIP35z39OBx54YOrdu3ftQqh56QQEwKVrUhUiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBWBcwBXKstr94ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJROQABcuiZVIQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEalVAAFyrLa/eBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUTkAAXLomVSECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGpVQABcqy2v3gQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlE5AAFy6JlUhAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqVUAAXKstr94ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJROQABcuiZVIQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEalVAAFyrLa/eBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUTkAAXLomVSECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGpVQABcqy2v3gQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlE5AAFy6JlUhAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqVUAAXKstr94ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJROQABcuiZVIQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEalVAAFyrLa/eBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUTkAAXLomVSECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGpVQABcqy2v3gQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlE5AAFy6JlUhAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqVUAAXKstr94ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJROQABcuiZVIQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEalVAAFyrLa/eBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUTkAAXLomVSECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGpVQABcqy2v3gQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlE5AAFy6JlUhAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqVUAAXKstr94ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJROQABcuiZVoZUFLrvssvS+970vbbnllqmxsTGNHj06vfOd70wXXnhhWrJkycqr+5kAgZIKXHXVVenoo49Ob33rW9M666yTRo4cmfbee+903HHHpfvvv7+ktVYtAgTaErj11ltT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AQIECBAgQIAAAQIECBAgQIAAgUwEFIAzSaQwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgoADsHiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAmAgrAmSRSGAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEFAAdg8QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEAgEwEF4EwSKQwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgoALsHCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkImAAnAmiRQGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEFIDdAwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEMhEQAE4k0QKgwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgrA7gECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhkIqAAnEkihUGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEFYPcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEMhFQAM4kkcIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQICAArB7gAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABApkIKABnkkhhECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAQAHYPUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFMBBSAM0mkMAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIKAA7B4gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAJgIKwJkkUhgECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBQAHYPECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAIBMBBeBMEikMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIKAC7BwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIJCJgAJwJokUBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBBSA3QMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIREABOJNECoMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIKwO4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIZCKgAJxJIoVBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABBWD3AAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBDIRUADOJJHCIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgAKwe4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKZCCgAZ5JIYRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAB2D1AgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBTAQUgDNJpDAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCgAOweIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQCYCCsCZJFIYBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQUAB2DxAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQCATAQXgTBIpDAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECCgAuwcIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCQiYACcCaJFAYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQUgN0DBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQyERAATiTRAqDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECCsDuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECGQioACcSSKFQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQVg9wABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQyEVAAziSRwiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgIACsHuAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECmQgoAGeSSGEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBAAdg9QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgUwEFIAzSaQwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgoADsHiBAgAABAgQIECBAgAABAs0U2Lp1a/Tr1y969OhR/BszZkwzz3QYAQIECBAgQIAAAQIECBA4MAKttv9nOTBv5V0IECBAgAABAgQIECBAgEB1C8yaNStGjBhRBtGmTZt46aWX4rDDDiu3aRAgQIAAAQIECBAgQIAAgf+lgBHA/0t9702AAAECBAgQIECAAAECVSVwxx13FP3t2rVr8bply5a49dZbqyoGnSVAgAABAgQIECBAgACBvAUUgPPOr+gIECBAgAABAgQIECBAYB8JrFmzJqZPn15c7cILL4xevXoV7dtuuy1SIdhCgAABAgQIECBAgAABAgRagoACcEvIgj4QIECAAAECBAgQIECAQIsXuPvuu2Pz5s1FP4cPHx5nnnlm0X7llVdixowZLb7/OkiAAAECBAgQIECAAAECtSHgGcC1kWdREiBAgAABAgQIECBAgMBeCvTr1y8WLlwYHTt2jLVr18YzzzwTAwYMKK766U9/OmbPnr2X7+B0AgQIECBAgAABAgQIECCw9wIKwHtv6AoECBAgQIAAAQIECBAgkLnAvHnz4qSTTiqiPOOMM+K+++4r2scff3wsWrQoWrVqFc8//3z07t27WRJvv/12pBHFv/rVr2Lx4sVRV1dXXH/QoEHxpS99qSgyX3bZZfHvf/87PvKRj8T48eMbve4///nP+O1vfxvp9emnn462bdtG//79i39pquoePXo0eq4dBAgQIECAAAECBAgQIJCfgAJwfjkVEQECBAgQIECAAAECBAjsY4FUlL355puLq6ai7TnnnFO0r7/++rj66quL9uWXXx433HBDk++cCsXDhg2LpUuXNnhsKiqnZw2n0cXr1q2Lc889N375y1++49ht27bFD3/4w5gwYUI5NfXOB73vfe+LW2+9NT73uc/tvMs6AQIECBAgQIAAAQIECGQqoACcaWKFRYAAAQIECBAgQIAAAQL7RmDjxo1x6KGHxvr16+OQQw6J1157Ldq1a1dc/NVXX40jjzwytm7dGl27do0VK1aU+xp692XLlhUjelevXl3sPuaYY+L000+PY489NhYsWBC/+93vYuXKlcW13njjjWJkcGMF4BEjRsSsWbOK67Rv3z5Gjx5djPrdtGlTPPnkk8W1tmzZUuyfOHFiXHrppQ11yTYCBAgQIECAAAECBAgQyEygTWbxCIcAAQIECBAgQIAAAQIECOxTgXvvvbco/qaLppG/leJvWu/Zs2cMHTo0HnzwweK5wNOmTYvzzz8/7WpwSUXYSvH3zDPPjDvvvDM6dOhQHnvttdfG2WefHY888ki5bfv27WW70kijkCvF3xNPPDHS+6Yicv0lXWPUqFGxatWq+Na3vlX0PfXXQoAAAQIECBAgQIAAAQJ5C7TOOzzRESBAgAABAgQIECBAgACBvRO4/fbbywuMGzeubFca9bdNnjy5svkdr+n5vPfff3+x/Ygjjoh77rlnh+Jv2tG9e/di5G6nTp3ecX5lQ3ou8JVXXlmsppG/v/nNb95R/E07TznllOI5w6n91ltvxVVXXZWaFgIECBAgQIAAAQIECBDIXEABOPMEC48AAQIECBAgQIAAAQIE9lxgyZIl8de//rW4wAc+8IE4+eST33Gx9Hzdzp07F9sff/zxSIXehpZK8Tft++Y3vxlt27Zt6LDiWldccUWD+9LGGTNmxPLly4v9abRxnz59Gj02jU5OzxROS3qOcF1dXaPH2kGAAAECBAgQIECAAAECeQgoAOeRR1EQIECAAAECBAgQIECAwH4QmDJlSlSmYK4/0rf+W6VCbnr+bmW56aabKs0dXufMmVOuDx48uGw31BgyZEhDm4ttzz//fLnvYx/7WNlurHHSSScVu9JzipcuXdrYYbYTIECAAAECBAgQIECAQCYCngGcSSKFQYAAAQIECBAgQIAAAQL7VmDbtm0xderU8qJp6uXGirutW//3+9W/+MUv4kc/+lF07NixPDc1XnnllXL9qKOOKtsNNY4++uiGNhfbXnjhhXJfGil8zTXXlOsNNTZs2FBuTuemkcwWAgQIECBAgAABAgQIEMhXQAE439yKjAABAgQIECBAgAABAgT2QmD27NmxYsWK8grf/e53y/auGm+++WakIvAll1yyw2Fr164t1jt06BDp2b27WtKzgFu1alWOPq5/7Isvvliurl69umw3p7F48eLmHOYYAgQIECBAgAABAgQIEKhiAQXgKk6erhMgQIAAAQIECBAgQIDA/hO444479vjiaaTwzgXgnj17xvr16yMViNO/VAhubEmF3crU0zsf8973vrfcNGHChOjatWu53lSjOVNGN3UN+wkQIECAAAECBAgQIECgZQsoALfs/OgdAQIECBAgQIAAAQIECPwPBNJo3d///vfFO7dr1y7S1Mm7KtimA19//fU47rjjYvPmzbFgwYJ47LHHYtCgQWXvjz322HjuueeK9eXLl8cHP/jBct/OjZdffnnnTeV6nz594o9//GOxnp7vO3z48HKfBgECBAgQIECAAAECBAgQ+O9DilgQIECAAAECBAgQIECAAAEChUCawrmurq5of/azn43DDz88DjnkkF3+O+aYY2LkyJGl4OTJk8t2atR/9u7f/va3HfbtvJKKx40tqQBcWf7xj39Umo2+zp8/P5544olYuXJlo6OKGz3ZDgIECBAgQIAAAQIECBCoOgEF4KpLmQ4TIECAAAECBAgQIECAwP4WqD/98/nnn9/stxs/fnx57LRp02LNmjXl+he/+MV417veVaz/4Ac/iC1btpT76jc2bdoU119/ff1NO7RPPvnkcn3SpEnxxhtvlOs7NzZu3FiMEE7n9OjRoxyBvPNx1gkQIECAAAECBAgQIEAgHwEF4HxyKRICBAgQIECAAAECBAgQ2AcCTz31VDGFc7pUt27dYtiwYc2+ajo2Pes3LW+//XZMmTKlPDdND33eeecV60uWLImLLrooUrG3/pKeDTxmzJh49dVX62/eoT1w4MAYNWpUsS0dd9lll8XWrVt3OKaycuWVVxYjf9P6kCFDom/fvpVdXgkQIECAAAECBAgQIEAgUwEF4EwTKywCBAgQIECAAAECBAgQ2DOB22+/vTzxnHPOiYMOOqhcb6qRRviOHTu2POyWW27ZYdrlCRMmRPfu3Yv9U6dOjQ9/+MNx9dVXF4Xib3zjG9G/f/9II4fbtGlTXqNVq1Zlu9K48cYb4z3veU+xetttt8XgwYPjL3/5S2zYsKEoBj/zzDPxhS98IX7+858Xx6Rjv//971dO90qAAAECBAgQIECAAAECGQu02v6fJeP4hEaAAAECBAgQIECAAAECBJotkEbkHnroobFu3brinLlz50Yacbs7y4svvhjHHntsecrDDz8cQ4cOLddXrFgRn//85yONNG5oSUXgq666KkaPHl3sTtNKpyLvzsucOXPiggsuiJdffrnclYrFqQhdf3rpVMCePn36bo1kLi+oQYAAAQIECBAgQIAAAQJVJ2AEcNWlTIcJECBAgAABAgQIECBAYH8J3HfffWXxt0+fPrtd/E396t27d5xyyillFydPnly2U+Pwww+PRx99NCZOnBjnnntucXyXLl3iM5/5THzve9+Lxx57rDimclKnTp0qzR1eTz311Fi4cGFcfPHF0blz52Jf+o53pfibCsFpOulnn31W8XcHOSsECBAgQIAAAQIECBDIW8AI4LzzKzoCBAgQIECAAAECBAgQqEKBmTNnxsiRI4ueX3vttfHtb3+7ySjS84BTQfitt96KY445pvjXsWPHJs9zAAECBAgQIECAAAECBAjkJfDfhwrlFZdoCBAgQIAAAQIECBAgQIBAixKYN29ePPTQQ5FGFn/iE58onwXcUCf//ve/l5uPO+64sr2rRs+ePSP9sxAgQIAAAQIECBAgQIBAbQsYAVzb+Rc9AQIECBAgQIAAAQIECBwggVQAPumkk4p3S6N7Z8yY0eA7p2cIf+hDH4qNGzdG69atY9WqVdG1a9cGj7WRAAECBAgQIECAAAECBAjsLOAZwDuLWCdAgAABAgQIECBAgAABAvtBoG/fvtGuXbviyg888EBMmTIl1q9fv8M7vfbaazFu3Lii+Jt2nHHGGYq/OwhZIUCAAAECBAgQIECAAIGmBIwAbkrIfgIECBAgQIAAAQIECBAgsI8E7rrrrhg7dmx5tTZt2sTAgQOjV69esXz58nj88cejrq6u2H/00UdHGjXcrVu38ngNAgQIECBAgAABAgQIECDQlIACcFNC9hMgQIAAAQIECBAgQIAAgX0oMGnSpLjuuuti5cqVDV61VatWcdZZZ8Utt9wSnTt3bvAYGwkQIECAAAECBAgQIECAQGMCCsCNydhOgAABAgQIECBAgAABAgT2k8CmTZti2rRpsWjRoli2bFm8+eabceihh0bv3r3j7LPPjqOOOmo/vbPLEiBAgAABAgQIECBAgEDuAgrAuWdYfAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1IxA65qJVKAECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIXEABOPMEC48AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoRUACunVyLlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBzAUUgDNPsPAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgdAQXg2sm1SAkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQyFxAATjzBAuPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHaEVAArp1ci5QAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgcwFFIAzT7DwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoHQEF4NrJtUgJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEMhcQAE48wQLjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB2hFQAK6dXIuUAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHMBRSAM0+w8AgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqB0BBeDaybVICRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIXEABOPMEC48AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoRUACunVyLlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBzAUUgDNPsPAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgdAQXg2sm1SAkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQyFxAATjzBAuPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHaEVAArp1ci5QAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgcwFFIAzT7DwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoHQEF4NrJtUgJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEMhcQAE48wQLjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB2hFQAK6dXIuUAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHMBRSAM0+w8AgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqB0BBeDaybVICRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIXEABOPMEC48AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoRUACunVyLlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBzAUUgDNPsPAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgdAQXg2sm1SAkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQyFxAATjzBAuPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHaEVAArp1ci5QAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgcwFFIAzT7DwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoHQEF4NrJtUgJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEMhcQAE48wQLjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB2hFQAK6dXIuUAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHMBRSAM0+w8AgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqB0BBeDaybVICRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIXEABOPMEC48AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoRUACunVyLlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBzAUUgDNPsPAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgdAQXg2sm1SAkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQyFzg/wBPDp7rdFgXLwAAAABJRU5ErkJggg==">

<h3 id="predictionmodeltopic-9">Visualising the Test set results - Decision Tree</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
library(ElemStatLearn)
set = test_set

X1 = seq(min(set[, 1]) - 1, max(set[, 1]) + 1, by = 0.01)
X2 = seq(min(set[, 2]) - 1, max(set[, 2]) + 1, by = 0.01)
grid_set = expand.grid(X1, X2)

colnames(grid_set) = c('Age', 'EstimatedSalary')
# NOTE we need class here because we have a y_grid is a matrix!
y_grid = predict(classifier, newdata = grid_set, type = 'class')

plot(set[, -3], main = 'Random Forest classification (Test set)',
xlab = 'Age', ylab = 'Estimated Salary',
xlim = range(X1), ylim = range(X2))

contour(X1, X2, matrix(as.numeric(y_grid), length(X1), length(X2)), add = TRUE)
points(grid_set, pch = '.', col = ifelse(y_grid == 1, 'springgreen3', 'tomato'))
points(set, pch = 21, bg = ifelse(set[, 3] == 1, 'green4', 'red3'))

<img class="lazy" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVACAYAAACp1UVbAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N0JvBxFnTjwCkkgEu47gIgQCSCXgBy6XF7ggaKgrAqiHF6siqL+RVA/qOCJoOuxirh+RFDkUFcUlFM2KoiACCoIuByCXHIECCEkmX9XYz9npnvem3kz/TKv+9ufzU5PdXV11bd6+uH8pqqmNJIt2AgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBg0gssM+lboAEECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkAoIALsRCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBEBAeCKdKRmECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAQADYPUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGKCAgAV6QjNYMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQICwO4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVERAALgiHakZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQEAB2DxAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAiAgLAFelIzSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgIAAsHuAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECFREQAK5IR2oGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEBIDdAwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiIgABwRTpSMwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQICAA7B4gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBARQQEgCvSkZpBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAWD3AAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCoiIABckY7UDAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAgAuwcIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQEQEB4Ip0pGYQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBAANg9QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYoICABXpCM1gwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgLA7gECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUREAAuCIdqRkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQAHYPECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoCICAsAV6UjNIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgACwe4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIVERAArkhHagYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQEgN0DBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqIiAAHBFOlIzCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIADsHiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBFBASAK9KRmkGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEBYPcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiIgAFyRjtQMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQICAC7BwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFARAQHginSkZhAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAA2D1AgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBiggIAFekIzWDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAsDuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFREQAC4Ih2pGQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAAdg8QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgIgICwBXpSM0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQICAALB7gAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAhUREACuSEdqBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBASA3QMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoiIAAcEU6UjMIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAgAOweIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQEUEBIAr0pGaQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQFg9wABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqIiAAXJGO1AwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgIALsHCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBEBAeCKdKRmECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAQADYPUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGKCAgAV6QjNYMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQICwO4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVERAALgiHakZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQEAB2DxAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAiAgLAFelIzSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgIAAsHuAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECFREQAK5IR2oGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEBIDdAwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiIgABwRTpSMwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQICAA7B4gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBARQQEgCvSkZpBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAWD3AAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCoi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QIAAgUoJGAFcqe7UGAIECBAgQIAAAQIECBAgQIDA5BLYeuutwyGHHDJS6TgN9FlnnTXy3g6BQQl87WtfGwn+xjKPO+64IPg7KF3lECBAgAABAsMkYATwMPWGuhAgQIAAAQIECBAgQIAAAQIEaihw7733hmc961lh3rx5aeuf+9znht/+9rc1lNDksgQeeeSRsP7664/cY9tss0246qqrWtagLuvayiVAgAABAgQITLSAEcATLe56BAgQIECAAAECBAgQIECAAAECLQJrrbVWOOaYY0bSrrzyyjB37tyR93YI9CvwzW9+cyT4G8s64YQTBH/7RXU+AQIECBAgMLQCRgAPbdeoGAECBAgQIECAAAECBAgQIECgPgKLFy8ODz744EiD49S8T3va00be2yHQj0AcXb5w4cK0iClTpoTVV1+9n+KcS4AAAQIECBAYagEB4KHuHpUjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA9wKmgO7eSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMtYAA8FB3j8oRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewEB4O6t5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBQCwgAD3X3qBwBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6FxAA7t5KTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAy1gADwUHePyhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB7AQHg7q3kJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwFALCAAPdfeoHAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBLoXEADu3kpOAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIDLWAAPBQd4/KESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHsBAeDureQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAUAsIAA9196gcAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEuhcQAO7eSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMtYAA8FB3j8oRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewEB4O6t5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBQCwgAD3X3qBwBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6FxAA7t5KTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAy1gADwUHePyhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB7AQHg7q3kJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwFALCAAPdfeoHAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBLoXEADu3kpOAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIDLWAAPBQd4/KESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHsBAeDureQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAUAsIAA9196gcAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEuhcQAO7eSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMtYAA8FB3j8oRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewEB4O6t5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBQCwgAD3X3qBwBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6FxAA7t5KTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAy1gADwUHePyhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB7AQHg7q3kJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwFALCAAPdfeoHAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBLoXEADu3kpOAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIDLWAAPBQd4/KESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHsBAeDureQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAUAsIAA9196gcAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEuhcQAO7eSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMtYAA8FB3j8oRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewEB4O6t5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBQCwgAD3X3qBwBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6FxAA7t5KTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAy1gADwUHePyhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB7AQHg7q3kJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwFALCAAPdfeoHAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBLoXEADu3kpOAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIDLWAAPBQd4/KESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHsBAeDureQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAUAsIAA9196gcAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEuhcQAO7eSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMtYAA8FB3j8oRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewEB4O6t5CRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBQCwgAD3X3qBwBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6FxAA7t5KTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAy1wLShrp3KVU7g9ttvD1/+8pfDk08+Wbm2aRABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB/AiuvvHL4wAc+EGbOnNlfQTU+WwC4xp2/NJoeg7+f+9znlsalXZMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGASCGy22WZh//33nwQ1Hc4qCgAPZ79UtlbZyN999tkn7LbbbpVtp4YRIECAAAECBAgQIECAAAECBAgQIECAAAECBAj0JvDd7343XHXVVWaS7Y0tl1sAOEciYSIEYvD3iCOOmIhLuQYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgMAkEIjB3/jP1p/AMv2d7mwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBYBAeBh6Qn1IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQJ8CAsB9AjqdAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECwyIgADwsPaEeBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6FNAALhPQKcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgWAQEgIelJ9SDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfQoIAPcJ6HQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMi4AA8LD0hHoQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgTwEB4D4BnU6AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFhERAAHpaeUA8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj0KSAA3Ceg0wkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDAsAgLAw9IT6kGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIE+BQSA+wR0OgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBIZFQAB4WHpCPQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINCngABwn4BOJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLAICAAPS0+oBwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBPoUEADuE9DpBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBYBAeBh6Qn1IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQJ8CAsB9AjqdAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECwyIgADwsPaEeBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6FNAALhPQKcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgWAQEgIelJ9SDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfQoIAPcJ6HQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgMi4AA8LD0hHoQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgTwEB4D4BnU6AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFhERAAHpaeUA8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj0KSAA3Ceg0wkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDAsAgLAw9IT6kGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIE+BQSA+wR0OgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBIZFQAB4WHpCPQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINCngABwn4BOJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLAICAAPS0+oBwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBPoUEADuE9DpBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBaBacNSEfUgUGWB9S7fr8rN0zYCBAgOylgBAABAAElEQVQQIECAAAECBAgQIECAAAECBAgQIECgBIE7dzqrhFIVWXUBI4Cr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFBICr3sPaR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQQEgGvT1RpKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDVBQSAq97D2keAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQG0EBIBr09UaSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QUEgKvew9pHgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBtBASAa9PVGkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQNUFplW9gZO1fX//+9/DzTffHB577LGwzTbbhHXWWWeyNkW9CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCYIAEjgCcIOrvME088EW688cbwwAMPZEktr9ddd114xSteEdZdd92w6667hpe+9KVh1qxZYb311gtf+MIXQqPRaMnvDQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBDIBAeBMouTXBx98MLztbW8Lq666ath0003DWmutFXbZZZfwta99beTKMfgbg74//elPR9KynbvuuisceeSR4SUveUm4++67s2SvBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGBEwBfQIRXk7jz/+eNh7773Dr371q5GLLF68OMydOzf9FxPf8Y53hDe84Q3hoYceSvMsv/zyYcsttwxrr712+OMf/xj++te/pqN/L7zwwnDggQeGCy64YKQsOwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEIgCRgCXfB/EQO/+++8/EvxdZZVVwu677x622267MH369PTq7373u8Nxxx0Xrr/++vR9DATfcccd4fLLLw8//vGP07WAf/Ob36Qjh2OGGAQ+9dRT07z+HwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBDIBAeBMoqTX008/PfzkJz9JS3/Tm96UBnYvueSS8Lvf/S7d33bbbcOiRYvCMccck+Z52cteFk477bSw2mqrtdRoxx13DL/+9a/TtYHjgaOOOqrluDcECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAwBXTJ90AM5sZt6623DqecckqYNu1f5HF65/PPPz9suOGGYf78+Wm+E044IX0t+n9x/eATTzwxHVF85513hnvvvTddS7go7yDTvv/974eTTz45LFmypO9i43TWcfvLX/7Sd1kKIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgVeBf0cjWdO8GJJAFPF//+te3BH+z4tdcc81wwAEHhG984xthxRVXDHPmzMkOFb7uscceI+mx7LXWWmvkfVk755xzTrj44osHWvyVV1450PIURoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACALAJd8F999/f3qF9ddfv+OVtt9++zQAPHPmzDBlypSO+eKBGDCeMWNGWLBgQYijgCdiiyOXDz/88NBoNPq+3GGHHZauaTyaR98XUQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmgoIAJfc8XF65xtuuCENena6VBz1O2vWrHD33XeHhx9+OKy88sqdsobbb789Df7GDBtvvHHHfIM8EEcm77bbbgMpMpZlI0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgHIFlyilWqZnApptumu7GUbSPPvpoltzyuuuuu4a77rorXQd4hRVWaDnW/uZLX/rSSNLmm28+sm+HAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAsAl3wMHHXRQeoU77rgjvOpVrxp12uY4tfPUqVM71igGf7/4xS+mx1/0oheNOlK4YyEOECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQWQEB4JK7dp999gm77757epWLL744bLLJJmHvvfcOV111VVdXvueee8IJJ5wQdthhh/Ce97wnLFq0KEyfPj00jwTuqiCZCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCovIAA8AR08fe///3w/Oc/P73S/Pnzw7nnnhseeOCBrq582WWXhfe///3hyiuvTPNPmzYtnHjiiWGzzTbr6nyZCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoj4AA8AT09dprrx0uueSScMwxx4SnP/3p6RW32mqrrq680UYbjeRbb731QhxFfPjhh4+k2SFAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAmIACcSZT8Gqdt/sQnPhFuu+22cPnll4cYFO5mmz17dvjoRz8a5s6dG2699dawyy67dHOaPAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI1FBgWg3bvFSbPGXKlLDjjjt2XYeVV145HHvssV3nl5EAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgfoKGAFc377XcgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiYgAFyxDtUcAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqKyAAXN++13ICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBComIABcsQ7VHAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE6isgAFzfvtdyAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqJiAAXLEO1RwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBOorIABc377XcgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiYgAFyxDtUcAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqKyAAXN++13ICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBComIABcsQ7VHAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE6isgAFzfvtdyAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqJiAAXLEO1RwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBOorIABc377XcgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiYgAFyxDtUcAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqKyAAXN++13ICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBComIABcsQ7VHAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE6isgAFzfvtdyAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqJiAAXLEO1RwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBOorIABc377XcgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiYgAFyxDtUcAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqKyAAXN++13ICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBComIABcsQ7VHAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE6isgAFzfvtdyAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqJiAAXLEO1RwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBOorIABc377XcgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKiYgAFyxDtUcAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqKyAAXN++13ICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCom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IECAAAECBAgQIECAAAECBAgQIECAAAECBKpGQAC4aqZKRwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDC6gADw6D5SCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUDUCAsBVM1U6SoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdEFBIBH95FKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBqhEQAK6aqdJRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIjC4gADy6j1QCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUjYAAcNVMlY4SIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgdAEB4NF9pBIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBqBASAq2aqdJQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKjCwgAj+4jlQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAlUjIABcNVOlowQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBhdQAB4dB+pBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqBoBAeCqmSodJUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwOgCAsCj+0glQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA1QgIAFfNVOkoAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIERhcQAB7dRyoBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqRkAAuGqmSkcJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAwuoAA8Og+UgkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFA1AgLAVTNVOkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHRBQSAR/eRSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgaoREACumqnSUQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECIwukBs9WSoBAgQIECBAgAABAgQIECBAgMCOCvT/fmP03bEmBp/uiUxDXdTt2RqNRy+IulmNO1q18gQIECBAgAABAgQIENhKQAB4Kw4XBAgQIECAAAECBAgQIECAAIGJE+i56cnY+Nm7YuDBDc+tNNmXrfkP9o4Zb39e5HZveW66OwQIECBAgAABAgQIENgOAQHg7UBThAABAgQIECBAgAABAgQIECAwmkChUIhNl90VHV+7v5gt0xpRv19EdnYmCgOFGHwyYuDhiO6rV0TPDU/GnI8dG41HLRitSmkECBAgQIAAAQIECBCoSEAAuCImmQgQIECAAAECBAgQIECAAAEClQts+tLyoeBvssq36ZRMst1zRKYus7mCoff8hkISAC5E//398czF18e8y0+OhoNmV96InAQIECBAgAABAgQIEBhBIPlniIMAAQIECBAgQIAAAQIECBAgQGCiBPruWRsdSQA4kjhv62sz0XRcpiz4+2wr2ZmZaHlNJhpemNzry8e6v7o5WR2cfzaDMwIECBAgQIAAAQIECGyHgADwdqApQoAAAQIECBAgQIAAAQIECBDYlsCmL95TTGo8Ptn2ef/Sqt+Rc2cymWh+eSaycyMGH+sobgk9ck53CRAgQIAAAQIECBAgUJmAAHBlTnIRIECAAAECBAgQIECAAAECBMYUyG/si95bVicP+41oTFb+VnKkW0OX8nb/7PFKishDgAABAgQIECBAgACBbQoIAG+TRgIBAgQIECBAgAABAgQIECBAYHwC/Q+sT5byFqJuYRIDbqosAJy2UL/fUDv9964bX4NyEyBAgAABAgQIECBAYJiAAPAwEJcECBAgQIAAAQIECBAgQIAAge0VyK/rLRbNzhhfDZm2ofxp+UK+ML7CchMgQIAAAQIECBAgQKBMIFd27pQAAQIECBAgQIDAtBQoDORj8OmeiN7ByM5rimxr/bQcp0ERIECAwK4XyGz+HVMYigNX3qG+oayZllxkspWvHK68ATkJECBAgAABAgQIEKgVAQHgWplp4yRAgAABAgQI1KBAz6+fis7/enDoWYx9+S0Cuf3ao/lli6L1Nfsl23P6K/EWGCcECBAgsMMCuUVDS3kHV0ZxJW+lwdyBFUNN5/YZ59LhHe6xCggQIECAAAECBAgQmG4CtoCebjNqPAQIECBAgAABApHvGoi1778x1r73uui9/smI/nxk2pNnMc5JcJLFvwMPbYxNl90Vq19zdfTd9QwxAgQIECAwYQK5hW2RWzIjCsnGE/33VF5t761D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x/hrUIIAAQIECBDYmQJ+Y+9MbW0RIECAAAECBAgQIECAAAECBAgQmIICbW88MDKt9bHhn+6Mq/vzcXUS6E2fDjw3eXUkr8eTV+npry2vWBIzL35BZLLjW0WaVOHYhQLZmQ2RmVEfhU39MbiuEHWzK5u/fE8h8s8kHU9WDdft3rILR6BpAgQIECBAoFIBAeBKpeQjQIAAAQIECBAgQIAAAQIECBAgMI0FWs/aNxqP3S06vnJvdF/zRKze2BerS+NtyEbj0btF2xsPiMbnzyvd9V5FAplMJpqO3z26r14RfbcXovnUygLAfXcmg0yi/42Hz4/s5lXEVTRsXSVAgAABAjUpIABck9Nu0AQIECBAgAABAgQIECBAgAABAgSeK5DbozVm/eURMfPPD4/BJzsjv643Mm31kdu9NTJNdc8t4E5VCbS+fmkxANz764j6gwuR22P0IPDg2kL0Xju09rv1DUuraqw6S4AAAQIEalnAM4BrefaNnQABAgQIECBAgAABAgQIECBAgMAIAplku9/cwrZoeN7cqF/cLvg7glE13mo4aHa0JCu9kx2+o/PfCzGworSx93NHM/hUITq/XohCb0TTyQuj6bjdn5vJHQIECBAgQGBKClgBPCWnRacIECBAgAABAgQIECBAgAABAgQIECAw8QIzL3p+srq7K3pvfDI6vlqI+kMKSaA/E9n5Ecku0TGYPO+3/55C9P02aTufrBReNidmfejIie+IGgkQIECAAIFJExAAnjRaFRMgQIAAAQIECBAgQIAAAQIECBAgQGBqCWRy2ZjzieNj0xfviY5/uz/6784nrxFWAierwFtfvW+0X7AsMg22/55as6g3BAgQIEBgdAEB4NF9pBIgQIAAAQIECBAgQIAAAQIECBAgQGBaCaRbfLe//dBoeeWS6P7Ro9H769XFVcFRKER2QXM0HrkgWl6+KHKLZkyrcRsMAQIECBCoFQEB4FqZaeMkQIAAAQIECBAgQIAAAQIECBAgQIBAmUBu95aYcd7BxVfZbacECBAgQIBAlQsIAO+iCezt7Y3GxsZxt/7MM89Ed3d3sdxee+017vIKECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAwfQWy03doU29k3/jGN+IP//APY7fddovm5uY4+OCD49xzz43rr7++4s6ed955sffeexdfFReSkQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBmhAQAN4J09zZ2RlvetOb4jWveU386Ec/itWrVyeP0yjEvffeG1deeWWceOKJcdFFF21Z2bsTuqQJAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSmoYAA8E6Y1A984APx1a9+dUtLra2tsWTJkshkMsV7+Xw+/umf/ile8IIXxMMPP7wlnxMCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiMR0AAeDxa25H3jjvuiM9+9rPFkunWz9/5zndi48aN8fvf/z7WrVsXf/d3fxczZ84spt9///1x8sknCwJvh7MiBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhE5CBMrsDnPve5GBwcjFwuF1dffXU8//nP39JgGvh93/veF2984xuLzwa+884747HHHouXvOQlceONNxafFbwlsxMCBAgQIECAAAECBAgQIECAAIGdKvDYpSt3SnuLLlm4U9rRCAECBAgQIECAQG0ICABP8jwvX7682MLZZ5+9VfC3vNk99tgjrr322jjzzDPjl7/8ZXEF8Omnn148T7eL3tVHGsB+9NFHi88t3tG+9Pb27mgVyhMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsA0BAeBtwEzU7fvuu69Y1RFHHDFqle3t7fHDH/5wy+rfW2+9NV772tfGd7/73airqxu17GQnvvWtb42vfOUrE9rMqlWrJrQ+lREgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgYAvoSf8Z6OvrK7bR0tIyZlvNzc3FgO9xxx0XDz74YPzgBz+ICy64IC677LIxy05mhsMPPzyuv/76yOfzO9zMihUrIjWpxGOHG1MBAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRoTsAJ4kid86dKlccstt8Q999xTUUvz5s2LH/3oR5EGgdesWRPpM4T333//uOiiiyoqPxmZ0iB0+pqIIw0m33777ZE+/9hBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMDECmQntjq1DRdIA8Dp8fWvfz3Wrl07PHnE6/3226+4EjhdEZweF198cXz1q18dMa+bBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKAkIAJckJun97LPPLta8evXqSM+feuqpilo69thji0HjbDYbhUIhzj///PjIRz4yIdswV9QBmQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqDoBAeBJnrLTTz89TjvttGIrV199dRx88MHFYO5nPvOZMVs+66yzis//zWQyxcDvhz/84eL20GMWlIEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoUEADeCdN++eWXx7Jly4otrVu3Lr7yla/E5z//+Ypaftvb3hZf/vKXI5cbelxzPp+vqJxMBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjUnsBQVLH2xr1TR7zvvvvGzTffXHyWbxr87ezsjD333LPiPpx33nlx5JFHxjvf+c741a9+VXE5GQkQIECAAAECBAgQIECAAAECBLZfYNElC7e/sJIECBAgQIAAAQIEdpGAFcA7Cb6pqSnSbZ/Xr18fN954YzEYPJ6mn/e858W1114bV1xxRaTPB25vbx9PcXkJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgBASuAd/Ikp1s5pwHc7T3OPffcSF8OAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIDBewAni4iGsCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUqYAAcJVOnG4TIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBguIAA8HAR1wQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKhSAQHgKp043SZAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBwAQHg4SKuCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUKUCAsBVOnG6TYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeECAsDDRVwTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgSgUEgKt04nSbAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECwwUEgIeLuCZAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgECVCggAV+nE6TYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSGCwgADxdxTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSoVEACu0onTbQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAwXEAAeLuKaAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECVSogAFylE6fbBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGC4gADxcxDUBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqVEAAuEonTrcJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAwXEAAeLiIawIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFSpgABwlU6cbhMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGC4gADwcBHXBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqFIBAeAqnTjdJkCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwHABAeDhIq4JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQpQICwFU6cbpNgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB4QK54TdcEyAw8QKPXbpy4itVIwECBAgQILDDAosuWbjDdaiAAAECBGpPYKr9G8/vs9r7GTRiAgQIECBAgAABAqMJWAE8mo40AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVJGAAHAVTZauEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAYDQBAeDRdKQRIECAAAECBAgQIECAAAECBAgQIECAAAECCt3iugAAQABJREFUBAgQIECgigQEgKtosnSVAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECowkIAI+mI40AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJVJJCror7qKgECBAgQIECAAAECBAgQIEBglwssumThLu+DDhAgQIAAAQIECBAgQGBbAgLA25Jxn8AECvhwYAIxVUWAAAECBAgQIECAAAECBAgQIECAAAECBAgQILBNAVtAb5NGAgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBKpLwArg6povvSVAgAABAgQIECBAgAABAgQIENgOgcJgIXp+/nh0/2Jl9D+wPvLreiM7oyFyS9qj6aQ9o+XliyLTWLcdNStCgAABAgQIECBAYGoJCABPrfnQGwIE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AgQIVCSQqctE04v3LL4qKiATAQIECBAgQIDAuASy48otMwECBAgQIECAAAECBGpIYNYHjojsvKa4PQnuXpA8q/CB5H34kW77/O0k8HtRkt6bJLa8ckk0n7jn8GyuCRAgQIAAAQIECBAgQIAAAQI7RcAK4J3CrBECBAgQIECAAAECBKpRoG5+c8z99Itj7cU3xP0rO+PPkiDvQclADk5WArck76uTV/rM33WbB9fyiiUx8/+8YPOVNwIECBAgQIAAAQIECBAgQIDAzhcQAN755lokQIAAAQIECBAgQKCKBNLnEM7/ykui44p7o/ObD8W93YNx77CVwLklMyLd9rn5pIVVNDJdJUCAAAECBAgQIECAAAECBKajgADwdJxVYyJAgAABAgQIECBAYEIFsm310f6uZTHjrYdE721rYmBFRxS6BiI7pzEanjc36vdtn9D2VEaAAAECBAgQIECAAAECBAgQ2F4BAeDtlVOOAAECBAgQIECAAIGaE8g01kXTcbtHHFdzQzdgAgQIECBAgAABAgQIECBAoEoEslXST90kQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgTEEBIDHAJJMgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBahEQAK6WmdJPAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIjCEgADwGkGQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUi4AAcLXMlH4SIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgDIHcGOmSCRAgQIAAAQIECExbgccuXVnR2BZdsrCifDIRIECAwMQLFPKF6PvdMzHw8MbIb+yL7MzGqF86M+oPnh2ZTGbiG1QjAQIECBAgQIAAAQIEqlxAALjKJ1D3CRAgQIAAAQIECEwHgUqD8eVjFZgv13BOYPoJFAby0fnNh6Ljq/dFfm3vcwZYt1tztJ1/cLT88eLIZAWCnwPkBgECBAgQIECAAAECNSsgAFyzU2/gBAgQIECAAAECBAgQIEBgagoMruuNde+/Mfp++0yxg9k5Ebl9IjLNEYXOiIFHIgaf6o4NH78ten75RMz+6NGRba2fmoPRKwIECBAgQIAAAQIECOxkAQHgnQyuOQIECBAgQIAAAQIECBAgQGDbAoWewVh70XXRf+/6yLRH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eVx1zzXpc66fqbSIfAQIECBQowITEgCuUTvDJkCAAAECBAgQIECAAAECBAgQIEBgigqkK33Tl4PAVBPIP91T7FJ25vh6VsqfXztUfnyl5SZAgACBWhIQAK6l2TZWAgQIECBAgACBrQQeu3TlVtfbulh0ycJtJblPYIcFKv053OGGVECAAAECBAgQIDAlBDJNdcV+FPrH151S/kzjUPnxlZabAAECBGpJIHnKwK4/nnzyybjrrrt2fUf0gAABAgQIECBAgAABAgQIECBAgAABAgQITKJA3cLWYu2Dq8bXyGDy2OD0KJUfuvInAQIECBB4rsCErwBeuXJlfPOb34zVq1dHX19f5PP5rVodHByM9DUwMBDr16+Pxx9/PG644Ya45JJL4nnPe95WeV0QIECAAAECBAgQmEwBK3snU1fdOyJQ/rNphfCOSE5+2fK5mvzWtECAAAECBAhMB4H6g2ZHdnZj5Nf1xsBjhcgtquw5wH23F4rDb3rR7tOBwRgIECBAYBIFJjQA/O53vzu+8IUvRH//OPeumMQBqpoAAQIECBAgQIAAAQJTWaA8gLizgr2lNndWe1PZX98IECBAgAABAjtbIJPNROtr9otNX7gnun5UiBnnR2TqRw8C9z9QiP77knzJ9tEtf7xkZ3dZewQIECBQZQITtgX0FVdcEZ/97GfHHfytq6uL4447Lo499tgqo9NdAgQIECBAgAABAgQIECBAgAABAgQIECAwfoHWNyyN3D4zIr86ovM/CpHvHlrdO1JNafC387+H0mf86SFRN7dppGzuESBAgACBLQITsgI43eb5oosu2lLpa1/72nj5y18eu+22W7zmNa+Jrq6u+MhHPhLLli2LtWvXxs033xxXXnlldHd3xymnnBI/+clPtpR1QoAAAQIECBAgQIAAgVoSKF+Fu7NW5pa3WbIutZ1ej5ReyuedAAECBAgQIEBgxwWyTbmY84nj4ul3XhsDj/TEpssK0XhMRP3SiOysiEKyyWb6jOC+O4ZW/qYttpy5ONrOPmDHG1cDAQIECEx7gQkJAK9YsaIY2E213v72t8fnPve5LXAnnHBC/PjHP47Ozs4466yzivff8pa3xNlnnx1nnHFG/PSnP42rrroq3vCGN2wp44QAAQIECBAgQIAAAQK1IlAeeC2NeaR7pbT0fTwB2lJdY5UZK728fecECBAgQIAAAQI7LpDbe0bM//Kpse6vb4m+36yJnmsKyeu59abbPs/4s0Oi7Q2Cv8/VcYcAAQIERhKYkC2g77///i11v//9799ynp686EUvKl7/7Gc/2+r+SSedVFz5m8lk4sILL4z169dvle6CAAECBAgQIECAAAECBAgQIECAAAECBAhMZ4G6+c0x79MnxtxPvTiaz9gn6ha1RaYlF9k5jVG/bE7MeNshseAbLxf8nc4/BMZGgACBSRCYkBXADz74YLFrLS0tsc8++2zVzYMPPrh4fffdd8fg4GCkz/wtHelzf9NtoX/729/Gf/zHf8Tb3va2UpJ3AgQIECBAgAABAgQIENiGQGlVb5pcWrk70r3y4uXp5fdHOi/VOVKaewQIECBAgAABAhMv0HjUgkhfDgIECBAgMBECExIATgO/6TF79uzn9OmAA4a2pejp6Yl0pXApIFzKmK4ETgPAv/vd70q3vBMgQIAAAQIECBAgQIDAKAIjBWhHujdKFZIIECBAgAABAgQIECBAgACBaSowIVtAH3TQQUWe1atXR6FQ2Ipq6dKlkW7znB533nnnVmnpRboCOD0EgIsM/iBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMB2C0zICuBSALi/vz+uvfbaSFf1lo50dfCee+4ZK1eujN/85jfx+te/vpRUfL/uuuuK72vXrt3qvgsCBAgQIECAAAECBAgQGFlgPNs5j1zD6Hcnu/7RW5dKgAABAgQIECBAgAABAgQI7IjAhKwAnjlzZixevLjYj/e+972xatWqrfr0whe+sHidPud33bp1W9Ly+Xz84Ac/KF7vu+++W+47IUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHxC0xIADht9pOf/GSx9TvuuKP4nN93vetdW3pz3nnnFc8ff/zxOOOMM+Lb3/52XHPNNfGqV70qnn766WJaaSvoLYWcECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMC4BCYsAHzmmWfGueeeW2x8w4YN8Z3vfGdLR84666xInwWcHjfccEOk16ecckoxEJzea29vj/e85z3pqYMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEtlNgQp4BXGr7c5/7XBxxxBHx6U9/OvbYY4/S7chms3H11VfHy1/+8rj//vu33E9Pmpub4/LLL48FCxZsdX+6XMyfPz8KhcKkDKe0enpSKlcpAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJVJzChAeCWlpbiSt4LLrggHnjgga0wlixZUlz9e+WVVxa3f06Dl+mzgd/xjnfEIYccslXe6XSxdu3aSJ91XM3HbbfdFt/4xjcmJJC9cuXKIkV/f381k+g7AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSkpMKEB4NIIM5lMHHDAAaXLLe9z586N9773vcXXlpvT/ORXv/pVnH/++VutfN59992jrq6uakb+oQ99KP7nf/5nQvv7xBNPTGh9KiNAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAIGJSAsBgnxU4/vjj46abbipuf33zzTcXE9785jfHxz72sWczTfGzT3ziE3HiiSdOyErmT33qU7Fq1apYuHDhFB+17hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoPgEB4J0wZ7Nnz46f/OQnceyxx8by5cvj4x//eLzkJS+JU089dSe0vuNNHHzwwZG+JuL4z//8z2IAOJfzozcRnuogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUC4wrijcVVddFR/84AfLy0/Y+Xve857i84MnrMIpVlF7e3t86UtfihNOOKG4kvacc84pBoPT+w4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhMhMC4AsAbN26Mhx56aCLafU4d69ate8696XbjuOOOiwsuuCA++clPRvoM3M985jPxgQ98YLoN03gIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIENhFAuMKAKfb9ra1tU1KVxsaGial3qlWafrs3+9+97vx8MMPxz/+4z8WVz1PlulUG7v+ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAwuQLjCgC/5S1vifTl2H6B1tbWSLfS/t73vlesJA0EL1u2bPsrVJIAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKbBcYVAKY2MQLHHHNMpC8HAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEJlIgO5GVqYsAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEdp3AlAgAP/nkk3HXXXftOgUtEyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAYBoITPgW0CtXroxvfvObsXr16ujr64t8Pv//2bsPAKmK+w/g3613u9cLx9GP3gVEEUVBMAajiCKK7R+jEo1RRNQEjS0STaKxt2A3irFXoigIigiIdKT3drTr/bbv/zdvd4/rt4sLt3f7HX27r8x7b+azy+7e+72ZqcHkdruhJpfLhaKiImRnZ2Pp0qW47777MGDAgBp5uUABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAsELhDUAPGXKFLz88stwOp3Bl4A5KUABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClAgLAJhCwC/+eabeOGFF0IulMFgwLBhwzB8+PCQ9+UOFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFKAABShwVCAsAWDVzfMdd9xRddRJkybhvPPOQ9u2bXHZZZehoqICM2bMwMCBA1FQUIDly5dj1qxZqKysxOjRo/HNN99U7csZClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhQ4NoGwBID379+vBXZVEW666SbMnDmzqjRnnnkm5s2bh/LyckyYMEFbP3nyZFx11VUYN24c5s+fj3fffRdXXnll1T6coQAFKEABClCAAhSgAAUoQAEKUIACFKAABShAAQpQgAIUoAAFKECB0AX0oe9Sd49t27ZVrbz77rur5tXMiBEjtOUFCxbUWD9q1Cit5a9Op8Ptt9+OoqKiGtu5QAEKUIACFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACoQmEJQC8Y8cO7axWqxVdunSpUYK+fftqyxs3boTb7a6xTY37q7qFPnLkCN5///0a27hAAQpQgAIUoAAFKEABClCAAhRoTMCVXQb7qhzYV+TAtbe0sazcRgEKUIACFKAABShAAQpQgAIUiBqBsHQBrQK/KqWkpNSB69Wrl7bOZrNBtRQOBIQDGVVL4J9//hnr168PrOIzBShAAQpQgAIUoAAFKEABClCgXgGPzYXy93eg4vPdcB+qqJFH38YC6wVdEP9/vaCPM9XYxgUKUIACFKAABShAAQpQgAIUoEC0CISlBXCfPn00r5ycHHi93hp2PXv2hOrmWaV169bV2KYWVAtglRgA1hj4QAEKUIACFKAABShAAQpQgAINCDh3FiP3qm9Q+qL0MCXBX10cYJROqIxZgC4B8ORWouw/W5Bz+Tw4NhY0cBSupgAFKEABClCAAhSgAAUoQAEKtG6BsAaAnU4nFi1aVENMtQ5u3769tm7lypU1tqmFxYsXa+sKCvjHeR0crqAABShAAQpQgAIUoAAFKEABTcC5pwR5f1ioBX4NmUDc1TokTtMh/rd6afGrR9Jt8vw7HQwdJRCcb0Pezd/DsYl/Z/LtQwEKUIACFKAABShAAQpQgALRJxCWAHBSUhKysrI0vWnTpuHQoUM1JIcMGaItq3F+CwsLq7Z5PB7MmTNHW+7WrVvVes5QgAIUoAAFKEABClCAAhSgAAUCAl6XB4V3L4O33AVTbyD+Wh1MXXVVvU0F8hk7SUD4Gh3Mg2SNw4MC2Ud1Gc1EAQpQgAIUoAAFKEABClCAAhSIJoGwBIAV2DPPPKO5rV27Vhvn95ZbbqlyvPbaa7X57OxsjBs3Dp999hkWLlyIiRMnIi8vT9sW6Aq6aifOUIACFKAABShAAQpQgAIUoAAFRKDiiz1w7S2FPg2wXiyBX6NvmKH6cHR6HSwXSEtg6YhKdQmtxgtmogAFKEABClCAAhSgAAUoQAEKRJNA2ALA48ePxzXXXKPZFRcX4/PPP69ynDBhAtRYwCotXboUann06NFaIFitS0xMxNSpU9UsEwUoQAEKUIACFKAABShAAQpQoIZA5Vf7tOXYkRL8NTUc/A3spILAsWf78gX2DWzjMwUoQAEKUIACFKAABShAAQpQoLULhC0ArKBmzpyptQTu0aMHqnfprNfrMXfuXPTq1auOp8ViwUsvvYSMjIw627iCAhSgAAUoQAEKUIACFKAABaJbwOv0wLE+H5C/Xk11/6RsEMeYBehiobUcdhfYGszHDRSgAAUoQAEKUIACFKAABShAgdYmYAxnhaxWq9aS99Zbb8X27dtrHLpr165a699Zs2Zp3T+rrp/V2MB//OMf0a9fvxp5uUABClCAAhSgAAUoQAEKUIACFFAC7rxKwCvB3ESZgmj9G1BTrYD1yV64D8sxciphSJVoMBMFKEABClCAAhSgAAUoQAEKUCAKBMIaAA546XS6elv7pqWlYdq0adoUyMtnClCAAhSgAAUoQAEKUIACFKBAQwI6k7/jKndDORpe7/XvU3WMhrNyCwUoQAEKUIACFKAABShAAQpQoNUIhLUL6FajwopQgAIUoAAFKEABClCAAhSgQEQI6FOk5a5ZD2854CmXpsBBJq/TC0+hZJahgA1trUHuxWwUoAAFKEABClCAAhSgAAUoQIGWL3BcWgDXZjly5Aj++9//YuvWrfB6vejduzeuuOIKdOjQoXZWLlOAAhSgAAUoQAEKUIACFKAABaoEdAYdYoa1hX3xITg2ALGnVW1qdMa5WTa7ZNzgganQx5sazcuNFKAABShAAQpQgAIUoAAFKECB1iRwzAFgl8uF9957D2+//TY2bNiANWvWoE2bNnVsnnzySdx7772w2Ww1tt1zzz245ZZb8Nhjj8FgMNTYxgUKUIACFKAABShAAQpQgAIUoEBAIG5CVy0AbF/shbkvoE+UZr2NJE+FF5ULfa2F4yZ0ayQnN1GAAhSgAAUoQAEKUIACFKAABVqfwDEFgPft24fzzz8fGzdurBLJz8+vEwD+17/+hbvuuqsqT/UZh8OBp556Ctu3b8dnn33GIHB1HM5TgAIUoAAFKEABClCAAhSgQJVA7BntEHN6Juw/HkbZu17EXyFB4KT6g8Cqm+jyD7zwlkjr3wGpsIztXHUczlCAAhSgAAUoQAEKUIACFKAABaJBIOQxgPPy8jBixIgawV8FVVRUVMNLBXbvv//+qnU9evTQlt955x2t+2eLxaJt++KLL/Dss89W5eMMBShAAQpQgAIUoEDkCKjhO3ZV2LC4oAQri8qQ53BGTuFCKEm+lHtVcZlWj53lNm1YkhB2Z1YKUCACBFJmnApjVgI8uUDpy17YpDWwu/DomMCeElm3zIvSl2T9ARn3N9OK1H8Oh05ff6A4AqrEIoQg4LG54NxRDPvqXDh3l8DrcIewN7NSoKaAev+o95H2fpL3ladS+otnogAFKEABClCAAhSgQCsSCLkFsOq6OTs7WyNISEjAww8/jPHjxyMrK6sGy4MPPgjVylelwYMHY/HixYiLi9OWr7zySnz88ce49NJLteUHHngAkydPRmJiorbMBwpQgAIUoAAFKECB5hVQAdN/7TyIdw/k4aC9ZtD31KQ43JKVias6pEOvi9zAigpev3swH8/vOYzlEryuntrFmHBF+3S4i9JhSI6pvonzFKBAhAroE8xIf2U0ih5aCduig7BJF8+2hVJYowSB1UdRtY8q8yltkDJjGAypsRFaGxYrWAHHxgKU/mcL7MuPAA5P1W66WANiRmQi4dq+MPVIqlrPGQo0JqCCvmVvbIZtyWF4K6oFfU16GWs8AwnX9IH5pLTGDsFtFKAABShAAQpQgAIUaBECIQWAjxw5gtdee02rWEpKCpYuXYo+ffrUqWh5ebnWrXNgw+OPP14V/A2smzhxIq6//nq8/vrrKCsrg2oJfNVVVwU285kCFKAABShAAQpQoJkE5uYW4erV21Hk8rWuSpdyZMqkbu3bJ9OK4nJcu24nXtmXgw+H9kKGBFMjLeVK0HrS6m34oaBUK5oKAalOYM0yHZbpkGx/avch6C6bi5S/DUOsdC3LRAEKRL6APt6E1EdPh31VDio+3y1BwRx4in03HusSTIgZmgHrhV2guoxmatkCXrcXJc/9jPL3d/gqIkF+vXwh6ayAtxzw5LthW3AAtm8PIOH6voif3Be6CL4pqWW/Gq2j9KVvbpHeA2QoM/99BPpUeT/Fy/upUlbleWCXoLCarJd0Q9Ltg6AzhtxpXuuAYi0oQAEKUIACFKAABVqFQEgB4K+++goej++X8u23315v8FepfPPNN6ioqNCAVMvgc845p16s6667TgsAq41z5sxhALheJa6kAAUoQAEKUIACJ05gTk4hLl6xVbs2eqo0qZsMPXprTet8ZXDAi4UyvSI5lhSWYuTSjfjxzAFIMYX0s/K4VqjI6cKoHzdim3T1rILXqg5jpA7mavXYKnV4XeqwvMyJgjuXaAGl2LPaH9dy8eAUoED4BFSgV00qeW1urVt3vSVyPofCV9PoPVLRQytQOXe/9OUNGf9ZplN10Mcd7XVCdfltly6/7SukS/DXNsMjn+dJ0wZFLxhr3qhAyQvrUfb2Nq23APOpQOxweT9VG0fcU+GFYyVgW+pFxSe74CmyI+Xh03hTQaOq3EgBClCAAhSgAAUoEMkCIf2FrLpxDqTf/e53gdk6z999913VugsvvLBqvvZMv379qlbt2bOnap4zFKAABShAAQpQgAInXuCgzaG1/FW3+7kOK4AAAEAASURBVF0lwdIb1FX3WkkFUX8t0zCZpsON7TI+8GRpDfzJKb1r5Wy+xRt+3qUFf7tLER6TOqRIWWsnFdR+VLa9JnV4W7qKLvzrCmS8dy4MGdK0jIkCFGhRAqor4Lr/yltUFVjYWgLlEoDTgr/SbUP8VToYO9Z9hfWJOlh+Ldu6e1H+gUzSUlh13WsZ07HW0bjYXAL7HpbBuE9A6nxfh0bPYvvhoC/4Kw164y7TwdSznveTVYfYkdKjfA+g/L/Svby0LC//YAfiL+/Z6LG5kQIUoAAFKEABClCAApEqEFJ/NqoLaJWMRiM6dGj4B3b1APCYMWMarHtqairatfN1zRU4doOZuYECFKAABShAAQpQ4LgKPLQ9G6VuD0ZIKKW+4G/1kydLnr9LADVOVs4+UohF+SXVNzfb/FLp8vnTwwWwSAn+6Q/+5kpr3y+lte8rEux9Xqb3ZH6jrFP/TZY8I6Uu3koXSl/d3Gzl5okpQAEKUMAn4FGfx69IN72SrBfWH/z15fQ9mrr7AsFqqeSFDVBdRzNRICDg9XhR/Px6bdHyq/qDv4G86tnYXgfrxb4AsdayvLza4OLVMzYx7y6woeKLPSh5cSOKn16H0llbYV8jv0j4/mxCjpspQAEKUIACFKAABcIlEFIL4MLCQu286enpMBjqtghRG3Nzc7FhwwYtn16vx6hRo7T5hh4qK2WwFUlmsxqRjYkCFKAABShAAQpQoDkEHDLMx3sH87VT3yRdJgeT2kjg9FLJ+6YEVN/KzsXItMRgdjuued46kKsdf6KUTY0K+oAEfH+QQG/N5FtWHT7/Xsr/B5kWSb7Kb/Yj6c7B0MXU/zu35jG4RAEKUIACx0PAvvSwdL/rgEE+pM1967bUrO+c5pMh3UED7oPlcKzLQ8zJberLxnVRKODcWAD3vjLp7lneT6cEB6BaCBs6e2U/J2w/HIL1vM7B7Si53EcqUPLvDdpvijo/P2S7PsOCxBv7w3pBl6CPyYwUoAAFKEABClCAAhQ4FoHgru75j9ytWzdtrqCgQBtjqb4TqvF/vdKNnkonn3wyUlJS6sumrdu9ezeKioq0eRVUZqIABShAAQpQgAIUaB6BVcXlKHW5obpN7ijB02DTKH/e7yKkBfB3ecVa0dOkXDf6g78xska18lXB3ltkmiDzmbLuoEx/k+C1ahGsOnhU44g6NvtueJRFJgpQgAIUaAYB+yrfjTymfsF/F+l00rKzj6+w9pU5zVBqnjJSBeyrfO8Hk4xUodMH/54K3HwQ2D+Y+qkWvjnXLEDlvP0S6ZXWxL1krOGzpWvpc3WIGSarUgFPTiWKHl6JwgeXw+tUg24wUYACFKAABShAAQpQ4PgIhNQCePDgwZg1axYcDofW0jcjI6NOqebOnVu17te//nXVfH0za9asqVqdmakuwzFRgAIUoAAFKEABCjSHwAEZ/1elUIK/vvzablDjB6ubANVF+OZMgXr8W4K6qtPG0RLsnSJXYVPluXqaIs1y5sj0nOT7nzwHRox0y4VZJgpQgAIUaD4Bd67vc9ggwbJQkj5Nfc5Lq03//qHsy7ytV8CdY9Mqp0+t+TugqRqrYK1KKmAbTHLuKkHBnUu1ISXUOMLW83VQ41QfTSoQ7IVTOsyr+MrrG+PaqEfKfUE2Sz56IM5RgAIUoAAFKEABClAgKIGQWgAPGjSo6qAfffRR1XxgpqKiAnPmzAksYuzYsVXz9c0sXLiwavXIkSOr5jlDAQpQgAIUoAAFKHBiBQz+wK07xNMG2q4Y5Bpncwd/VdEDP25V8PciCfo+IGP81g7++vLpME5yPy7bTbIiW62UpFMVYaIABShAgWYTCHwOewNfMMGWxJ8/lFaewR6a+VquQOD9JPcGhJYC+Q2BXxYN765ugCv62wot+GsaAMRdXjv469tX/U4yD9Qh/hr5rSE/Piq/3IvKRao/EiYKUIACFKAABShAAQqEXyDkFsDqB6v6cfvYY49h4sSJaNu2bVWpnn32WeTl5WnLXbt2xVlnnVW1rfbM9u3b8dJLL1WtPv/886vmOUMBClCAAhSgAAUocGIFOlvM2gl3h3iFdLe/mJ0tqqPl5k/JJiMq7E50kqLcWhUObrhcAyVI/DvJ96q0BFbJkGltODO3UKCVCNhX56Jyfjacm2VszAI79HFGGDsnIPbMdrCc24njYLeS17mlVsPQ1vc57FE9Qfu7dQ6mLu5cX8TO0I6f48F4HUseT6kDFV/vgxqn2SXjLcPuhj7dAvOgNO2zw9yn4SHAjuV84dgn8L3ue38Ef5OXO8d3dkOmpcliqHGCnVuLoEuUlr/jdE3eEGfM1MFyjgSAv/ai9JVNsIyUAa+ZKECBiBdw59vk3+0+2H46AvehCsDlgUHG9TbLuPOWsZ1gypIPASYKUIACFKBABAmEFABOS0vDNddcgzfffBN79uzBaaedhjvvvBNqbOAFCxbgmWeeqaratGnTGvzRu3r1alxyySVaV9Jqh4svvhgqYMxEAQpQgAIUoAAFKNA8AkMS45BuNuKAw4UtEgTuI4HRYNJ8f+D03DZJwWQ/7nli9L6WOpdLUNcQZB0ukXxvSclUJ9h6uYjDRIHWKuA6XKGNPenwj7EaqKe6/cG1uxS27w+i5OVNSP7zYMSexYBEwIfPJ1YgZnhblH+wA44NXsScGVzvEl6XdK272VfOmGFHb1I/sSVv3Wcr/2wXSv69Ad5S1cfG0eQ+UgnnxgKUv7Mdsed0QPL0k6XrY99NZUdzNd9czGnyfnh+PZxbpINw6YJZZ2r6941q9KDefypp+zdRfNu3vn5EYoZJ8NfY9PHV4cwnQz5z5bN3RzFc+0th7JTQxFm4mQIUaC4B9ZlQNmsryt6Qv5JsNftLcstvK8fP+Sh7awusF3ZF0rRB0MUamquoPC8FKEABClCghkBIAWC15yOPPIJvv/0W+/fvx969ezF16tQaB1QLZ5xxBqZMmVJjvd1uxz//+U98+OGH2LRpU9W2uLg4PP3001XLnKEABShAAQpQgAIUOPECeunlZXKnDDy68yCehxtPS/jU2EQAVbUWni2TutT5+06RccG9zO27KHNqE2WvLmyRvANkWi11ce0shrENg8DVfTjfOgScEmTIv/UHeIrsUO1TLpb3/Glyo0S6zEs7PmzS/j17sE3GTy2Y/iMSbzsJ8Vf0bB2VZy1alEDMqRkwtI+DW1qYOlZIAG5Y08W3LfbCWya96vZOhqlv5LVCbboGkZ2j+Kl1WlBeldLYVYKXg3QwtJPgvFxR8hRBWr96YV8jAc0FB5C7tRjpL4zUWsVFQq1MPZJg6p+qBalti7zS8rbpAK1D6uKRFsDqprDY0zObrIZziyBIMnVrMmtVBtVVubGL3LgggWnVepgB4CoazlAgogS8Hi8KH1gun2++Gz1MveTf+knyGZghxZT7Tj0F8m94i9w0sk7G9/58t8wXIu35kdDHq0FmmChAAQpQgALNK+BrIhFCGTIzM7F06VKceuqp9e51zjnn4Msvv4Te3/oikMktF+NmzJhRI/ibmpqKuXPnokuXLoFsfKYABShAAQpQgAIUaCaB6d3bo0OsGRvl/P+Qlr0OCQg1lPbKtr9IoFi1A/p95wwMTIyMLjcLnC6tyGkNFbyB9YH8nkJ7Azm4mgItV8BTbEfBn5Zowd9hEvj9r9zgcZ1M/WQ+Q6auMl0gVzFflHV/lGcVHil55mfYFh9quZVmyVusgM6oR+LUgVr5K+fLRfWNDX8XqUz2VRJ8XCwzcnVD3bgQCePRa4VvJQ9lH+7wBX8l2GudIOPXXq2HeYAEP9JknNskFcSU7ox/La/ZTbJOYqXu7DIU3LUUXmeogzgfP7AkeV/AoIP9R3m/LG/8/eSQQE7lXF+epFtloAhz0y351I01KuniQ6tDIL+bvz1Cg2NuCpxAgdKXNmrBX52MdhN3pQ5xk+QzsI983qXKlKyTGz90sJ6vR8IN8pko9x+pGzoK7//pBJaQp6IABShAAQo0LBByAFgdqmPHjli+fDm+/vprTJ8+HVdeeSVuv/12zJs3D/Pnz0dycnKdM1qtVsTH+34Nq+DwpEmTsGzZMowYMaJOXq6gAAUoQAEKUIACFDjxAkkyfu4np/RCvEGP7yTA+3sJ8C6QQHBltUDwIZl/XdbfJNMRKeKIlAQ83S/rxBe2gTMmG+UKtaTSBrY3tDqQn3frNyTE9S1ZoPT1LVDdtPaXSjwsUbJ4LcRbt0bSeSkmyfYbVSRNUvETa+F11OzqsO5eXEOB8AtYRnVA/HUyALDEECs+9aL8Ew9c2dLKV7rhVEm1yHLtlS4535PvqK986xJvG4SYIW3CX5goPqK7wIbSmeq2MAn+XqSDuX/DrWdVMDjuan8ARFrEln+6K2LkzAPTkHTHYK08lfPkffOuB8498n6S95FK6n3lOiDvs888qPhI1snHXvz/9YLlV5207U096BJ8Lf28tqZy1tweyK9PiJwus2uWkEsUiG4B195SlP13m3aDUdzlEuzt3vBnoCFdbpD5P/klJffE2pcdQaW/a/joFmTtKUABClCguQV8V8iOsRRjx46FmoJNDz30EFQL4uHDhyMrKyvY3ZiPAhSgAAUoQAEKUOAECQxNiseSEQMwadU2bC23SbDIo4WK1O19aozc8mrl+G2HdMwc2A0xEjCOlNQ33oLFhaVYL4HqsxoIctUuq1vyqu5vVTJmqc5xmSjQegQ8lS4JauzS/jXcKS18TUH8u5gkeeYLwU4Z165y4UFYfx1cEKT1qLEmkSCQeGN/aWUai+Jnf4ZzkwTsNsnntDTG1FkkcFchJfQ3MNVZjUiaPgTWsZ0joditqgwVs3fDK58hRuny1Ny34cBHoNJ6i2oNLL8V3pdg6rvbgaHS8jZCUtwl3aTFshlFj6yW4R6cMsn7SX6+6KzyfqqUQgbudTFLa+abByD+8uC7wDd2SZCWz+Uylq+8RVODr7Bb8quk9meiAAUiT6BMxqOH2wvzUPl32jmIz0C5ESZ2NFD5pdxoIuOiW8Z0jLxKsUQUoAAFKBBVAr8oAByq1LRp00LdhfkpQAEKUIACFKAABU6wQP8EK9aNHIT/ZOfgnQN5WCIB1UJffBQpJgPOa5OMW7Lkpj5p/RtpaXxmihYA/lQLAAdXum8lb4lkNWYlyBh8IfbfGNwpmIsCzSZgXyEDWTo8Ms41tK6egymI6gRadQn9rETY7EsOMQAcDBrzHBeBuIndETuyvbT03Q7b9wfhPlCujfWrTqaCZrFnd0DcFT2kG07pm5Mp7AK2xYe1Y8ac3HTgI3ByYw8JqsrPA7fcQLK+pCJihohQ5bOc0xExp2RABXVs32XDtbu06v1kaGdF7Kj22tjnhrahDWsRe1Z7+aw8DMdKCRRJzDuYbsid273wFEsMuo0Fpj51e9ELePKZAhRoPgH1G0gl85DgPwPN8oOrcq50Bb2xAKp7d0MKv5+a7xXkmSlAAQpQ4IQGgMlNAQpQgAIUoAAFKNAyBIx6nYzt21abPNI1Yq7DiVgZxkN1Ex3JaXKnDDyy4yDWyFjAsyV4Nd7flW1DZc6V4O9MfzOy+Gt6N5SN6ynQYgXUeJwq9Q2i5W/1Svbx53ft9+1ffRvnKXAiBQwSIEu69SRt8trd8JQ4oJeAr84UOb1PnEiPE3muwL9/Q/vgz6qCn8b2XhkHE9hRYYuoALCqhWoFnHhDP21S4xSrMdJVF8y6mKbH+m1IwXpeZ5S+thnuQ5XaOMOxZzSU07feU+5Fxde+O+tUV9PBBIwbPyK3UoAC4RZQnw9q+Az1p4QxM/gAsM4kYwNneOE+KDfCHCxnADjcLwyPRwEKUIACIQnwL6aQuJiZAhSgAAUoQAEKRJ+AXi7mto0xR3zwV70yKkD9bP8s7UV6RgK7H8jk8XfvrK2s9rBd1k+VPh8LZV3MsAxYxrL70Go8nG0lAp4Kl1YTS4gB4ED7N69//1bCwWq0cAEVpFMBYQZ/T8wLqbp/VkkX6hC1/vxlrkC/yiemvKGeRb2PDOnyfvoFwV/NR/ZPvmuIQAG2b72wLTo6vnDtMrnzpGvYt2S7tP41DUyF6pqaiQIUiDyBwO+fkD//pCo6f6Nfb7kz8irGElGAAhSgQFQJRHYTjqh6KVhZClCAAhSgAAUoEH0CDo8H3+WXYIN0E5knrXbTJYCruqAek54Is7Q4PpZ0hYxNvM9mxz1b9mute7+Sg4yV2/fVaH7SZgyHJPC7RKZFMqn2N6b+qUh5+DTopNUzU8sW8Mo4bY51edLyrAge6XZPl2DSuolVAX59bHT+6WNIjdVe1Bzt3R786xvIr5cxWJkoQIHoFDCkxmgt4DwyTkIoY9t61bgKktrGmHwzUfAYO6Idkv40GMVPrNUCwI4N0m3sIHFr5wugq+6eVbfPzk2CIeNXG3skIfWR06EzHttvnSggZRUp0KwCukT5/DLq4LXJ3wsOr9wIE/zfCerfu0r8DeVz4CMFKEABCjSfQHReBWk+b56ZAhSgAAUoQAEKUEAE7G4Pnt59CI/tPIiieloIJRkN+FP39ri9azvEGkK/ODq9ewf0jbfijk17sLvCjpfU1dZaySwtm00ydmTiTf3los6xd/1Y67BcbAYBr0e60/xsF0pf3wJPvq1OCVTrrrjLuiP+2j7Qx0VPQEJBmAekah4rJADslskQZEvgZf6AcWD/OqhcQQEKtHoBk3x+uI8cgGuHBDKHBVddjwRLXPslr3x1n5IUH9xOrSRX3CXdoUuKQfEjq+EpcMo4w75unmtXT92UlCLBX72Fl+Rq23CZApEioLpmN/dLhePnfDjlM9DcL7iSuQtkfO8CufEj3ncTYnB7MRcFKEABClDg+Ajw1+bxceVRKUABClCAAhSgAAUaEDhid+CSldvwU5FvbNEekm+IBKWSZSqWoNMambZLUPj+rfsx+3ABPj2lNzJjQ+1/EriwbQrGtknClzlF+CqnEHskEFwpLY7bSXfWZ6YmYGK7NJw+tWsDpeTqliLgke71Cu9fLuMuHtaK3EkeT5X3UppMZfJeWi/TBhk3tOztbahcdBBpj4+AsVP0BCVMvZJh6ByPvH1lmCMWF4pLU0mNjf2lTCpZzunYVHZupwAFWqmA5VedYFtwALZlXpiHSEBDxrZsKtmXyGeH3HMVM7wtUs3RdcnJsbEAJU+uhbdMun0VKp36qlH3sKmPU3n2ynCisMv/y3NQ8vQ6JP1Zfv2wBbCgMFEgMgUs53bSAsC2xV6Y+si/6SB6C7L94Pv9FHt2e/77jsyXlaWiAAUoEFUC0fVrPKpeWlaWAhSgAAUoQAEKRJ5ApbT8Hb9iK1YVlyNTineXXBEdrF0drVnWdXK19F/SXnGF5Bu3YgsWndEfVkPorXRVN9ITMlO1qeYZuNQaBFTL38L7foJ92REkSYX+JO+lM+t5P6nxntX7aYcEQfOn/oD0N8bAkOwfoK01QDRRh8Q/9EfhvT/hBYnK9JSoRJ9GgsCVYvVXsZIYBWLHdIAKIDNRgALRKRA7qr0EPZLh3FIkvSx4YZ3YeADEudUrn8c+q4Qb+wMfV0QNnGtfKfKnLdaCv0a5t8zyG510m10zYO71yjAFa4DKedJrxew90qxabn6bfnLUGLGiFGhpAtbxWSj77za4D1egcq4XlvPkM1BaBjeU7Kulm/f1slXGF0+4vm9D2bieAhSgAAUocMIEQu9P74QVjSeiAAUoQAEKUIACFGhtAn/bnq0Ff9tLxV6UzmjrC/6qOg+SANW/ZbtqzblWxgd+cFu2Ws1EgRoC5R/v1IK/KkQ5U94v9QV/1Q4q6PmcbFe996mLeGqMxmhKljEdYb0wSwvqTpPg7mcSCFbdQddOqrX0zbJls2wwtLNqrdNq5+EyBSgQPQIq0JHyt2FaV6bOrZCeFKQr+dy6nx1epxeV33tQ/pFsk/8T5KYTc9+U6IGSmhbOkI72peWvaiUYd2Xd4K/CUJ4xJ+sQ/1sJIElzjIpPd8O29FBUObGyFGhJAmqImJSHT5P+n/VwrALKP5DPwKK6n4Gq6/uKuR5UzvFtS75rCIzt4lpSVVlWClCAAhRopQJsAdxKX1hWiwIUoAAFKEABCkSaQL7Diedk3F+VHpBgXFIjrRBVHrVd5btRAlLP7z6MP3drjzYx0TV+q3Jgql/A6/Kg7I0t2sY/S6vfdk28n2Jl+4Pyfvo/eT/Z5mfDKS0zTF0T6z94K1ybNF313yoBB2l19owEgP8jdRwqK9rIc7lMGyVqs1ueVTJ2TUCqdJUdTa2kfTXnIwUoUFvA2CkBac+dhYI/L4V7nw2lL8lY4h1kkm48dHJFyVMEONWHh8O3Z8Lv+yJBxluPpmRbcgjOTYVal8/W8bomu4k1dtDBMsbXErj05U2IPaNdNHGxrhRoUQLm/qna8CEF9y6Da7sTpTvk86+TTBnyGSjNqtwy3q9rj1TJJZO06k+6YzCsF2TJAhMFKEABClCg+QXYArj5XwOWgAIUoAAFKEABCkSFgBqL1yZd9qrxWXurSFQQqYfkO00mh3Sb+L8jhUHswSzRIuBYnQtPoR1dpcJn1NPtc30ObeS9NNb/3rN9m11flla7To0zmfyXoUh59HQYuyfKeNvAtxL0fV+mL/zBX12CCSp4k/7aGBjbs+VKq30zsGIUCFHA3CcFGW//CnGTesjgvga4D0i8V1rD2X+S4K+0DFbBX/NJaUh7cRQSJqu+FqIrVS7wfZ/EDJPgrzm43zfmoRI8ilV+RXAdKIsuMNaWAi1MIObUDO0z0HJBFy3I694nH3sr1XjeEvfdIZWR4K8a97zN62MQd0m3FlY7FpcCFKAABVqzgNyvyUQBClCAAhSgAAUoQIHjL7CyyHeBUzqTDOlkKv8yCVCtLC7D9ZDb7ZkoIAKOLb4bAtQNBaEklf9/8n5ybI7OGwosI9tDTc49JVqLNU+BTeve1dg5QQvgqEAxEwUoQIHaAvqkGCTdPgiJfxwA+5pcuA+Ww2t3Q58WC/OgdBgzrbV3iZplp//7xNQ9+CrrpKWgsYuMFyoBdOfmIhg7xAe/M3NSgAInXMCQYUXKfadon4PqJkSXDCkCl7QEbmOB+eR0GfNb7uhgogAFKEABCkSYAAPAEfaCsDgUoAAFKEABClCgtQrkSBfQKqWHWME0f/4cu2//EHdn9lYq4CmwazVLDzEAHMivWg9HczJlJUJNTBSgAAVCEdDFGhB7uvT/zFQlEPg+0SVUrQpqJpDfXWgLKj8zUYACzS+gjzMh9qz2zV8QloACFKAABSgQhEBIAeDVq1djzpw5QRw29CwjR46EmpgoQAEKUIACFKAABVqnQKLRoFUs1I4O1fikKiWZQvrp6tvpBD56yp1w51ZCZ9LDkG6BTrrJZDp+Avp433jQ0gYtpJME8qsLeEwUoAAFKECBXyqgU99HxQ54VRw3hIbQXv99SIHvs19aDu5PAQpQgAIUoAAFKECB6gIhXUVbsWIF7r///ur7h23+wQcfZAA4bJo8EAUoQAEKUIACFIg8gd5xFq1QGyRgNy6E4qn8KvWOj7yu1bwON8o/3oWKr/fCtU2NqupP0rVjzMltYJVxwCxndwis5XMYBYxdfE2tNoR4zMD7KbB/iLszOwUoQAEKUKCGgOpC332gHO5sGR40tcamRhdUfpXU/kwUoAAFKEABClCAAhQItwAHeAq3KI9HAQpQgAIUoAAFKFCvwIVtU7T1iySgWxhkq81iybfQn3dchm//eg/eDCud24qQc8U8lDz7sxb8jZEydJKpnUx6txf2FTko/Msy5E39AZ7i6O5u+Hi8PDHD28qVdh3WyPtjX5DvJ2mfha/8eWPOUq8UEwUoQAEKUOCXCcT6v0/sq4LvkcK50wuPDEWvxlA29Yus3ze/TIN7U4ACFKAABShAAQpEikBILYDHjh2Lzz77rMGyf/DBB3jnnXe07V27dsUtt9yCPn36oGPHjkhPT8fhw4exd+9efPvtt3j11Vdht9sxaNAgvP/++8jM5BgyDcJyAwUoQAEKUIACFGgFAr3iLRgvQeDZRwrxBDx4CHoZvVXXYM28Eqh7UvJVSI4LMpLRLyGEfhUbPGp4Njg2FyL/5u+lu0c3usshr5e6nCp1MfnrUyZlXyDTm1L+QgkE5964EG1eGQ19ojk8BeBRoE8ww3pxV1RIC+x/wY2nYKjyb4jnJXk9cmSjqXcyYk7NaCgb11OAAhSgAAWCFrD8pjNKX9ssrYBtsC/3ImZYw79t1EE9lV5Ufu0LFsdf3RM6XeP5gy4IM1KAAhSgAAUoQAEKUKCaQEgB4KysLKipvvTDDz/go48+0jY9+eSTuPXWW2E01jx8hw4dMHToUFxyySW46667cNFFF2HNmjWYPn06Pv744/oOy3UUoAAFKEABClCAAq1I4PF+XfBDQQmWON0SAPbgTxI4tdYTBK6U4KkKEqvWwkkydvAT/bIiRkGN9VswfakW/P2VlH261CEQ+A0UMl7WXyTTmTLdJcHJnfvKUPjQSqQ9dkYgC5/DIJB4Qz/YlxzCxsOVuFveL/fLa5Es5rWTU95HKvj7iTxDxmhO+vMQXnCvjcRlClCAAhQ4JgF9rBFJfxqs9fpR+Y3cvuYGYoaj3u8Zd6EX5R/6Wv+a+qYgbqK6jYyJAhSgAAUoQAEKUIAC4RcIWxfQV199NRwOB+644w7cfvvtdYK/tYveqVMnfPrpp0hOTsbs2bOhWg8zUYACFKAABShAAQq0boFu1lh8PLQ3EiWo+50E466S4OhrMq2S4NxOWVbPavlqmVQL2gSDHh8N7YUecZEz/m/ZO9vhybOhn7xUd9cT/K3+CqZJMPKf0jI1XlbaFx+CfaVqf8oULgF9UgxSHx+hdaG5Wt4v6n3zgkzL/e+ntbLubZn/raz7WOZV8Dflr6fC3D+EQRrDVVgehwIUoAAFWq2A5ewOSJw6EOqrxrbAi9KXvbD95IVrv0yHvXBu86LiCw9KX5Tgr/wUUOPQpz56OnRmQ6s1YcUoQIFjE3DuKUH57N0ofWMzyt7dhsrvD8BT4Tq2g3EvClCAAhSIaoGaTXSPkWLnzp3Yv3+/trcK/gabunTpAtWttOoCesmSJbjqqquC3ZX5KEABClCAAhSgAAVaqMDItET8OGIAblq/S1oDl0qATgXpfF0hVq/SiJQEvDiwK/pGUNfPqnwV/9ujFfMmCewa6mltqm2s9tBG8lwugeLXJBCp9o05hV0PV+P5xbOm7klo8/oYFD22BhUSZP9I3ktqqp2MPZKQfPfJDP7WhuEyBShAAQqERSD+yl4wdkpA8ZNr4T5UAZu0Bq6TpJMKy/ldkHTHIOjjTHU2cwUFKBC9ArZlh1EycwNc24rrIshNjNZxWUj4fV8YUiPnxti6BeUaClCAAhSIJIGwBIAXL16s1UmN86vG+w0l9eun2k4Ay5YtC2U35qUABShAAQpQgAIUaMECvWU84O9O749F+SX49HABNpRWIM/hQprZiAES8L04MwVnpyVFXA3VHfme3Eq0kZINDCL4G6jAGMn7mizYZTxgpvALGDIsWvfaamxm27fZcGwtgqfApo0TbMxKQOxZ7aQ7zkzo9HW7hw5/aXhEClCAAhSIVoHYM+X75rS2sC06CJsMUeA+UC5j/rpgSIuFeWAaLOd01Fr/RqsP600BCtQV8Hq8KHlhPcqllyGVdFbpJaAboE+WBSfgOgS498uNpJ/u0j5bVO8B7M1Go+IDBShAAQo0IRCWALDbLQOcSMrPz0dxcTGSkoK/WLd+/XptX4vFoj3zgQIUoAAFKEABClAgegRUa2A1NVfa9/CBkE79TW4RfiN7dA4h+KtO0F7yq3Y+zkI7ts/Yjxjp2prpeAlI984ZavIfXy6c4VuPTAeP1wl53F8g0Pm+Dr9gb+5KAQpQIPIEdNJSTwV61cREAQpQoCmB0pc2+oK/0iN87Nk6xAyTILCh5k2L7nwvKr+SLuX32JA/bTHavDqaN5M0BcvtFKAABSggfdGFIfXs2VM7itfrxXvvvRf0EVXX0fPmzdPy9+3bN+j9mJECFKAABShAAQpQgAIUoAAFKEABClCAAhSgAAUo0FIF7OvyUPbWVmnuC8RdrkPs6bo6wV9VN0OaDnFXyQ2lcvncW+ZE4YPLoa7DM1GAAhSgAAUaEwhLC+DTTz8dajzfvXv3Ytq0aejTpw9GjRrV2HmRnZ2Niy++GCUlJVq+G264odH83EgBClCAAhSgAAUoQIHmFugYa9aKsK+eMWYbK9tBya8aoraRLq7Z+rcxKW6LNoFQW+FHm8+JrC9bY59I7ZZ5Lq/djcrvD8K+9BBcB8uhlg3pFpgH+bs27hDfMivGUlOAAhRoJgHV+lel2LMkuNutZqvf2kVSQ5lYxwMl2fJ3xZYirTtoyyj2pFLbicsUoAAFKHBUICwtgI1GI+69917tqDabDWeffTbOP/98zJ49Gxs2bEBRUREcDgdUi99vv/0WU6dORY8ePbRtaqdLL70Uw4ZJ/xZMFKAABShAAQpQgAIUiGCBPjJ2cfsYE3KljBtCCAJ/6897TnrwQ6VEMAOLRgEKUIACUSZQ+V02jlw2F0V/XY7KufvhXF8A17ZiCQYfRunMjciZNA9F/1oDj80VZTKsLgUoQIFjE3Dn2+BYkycD/kLGDg/uGDqTdBE93Bcoti3IDm4n5qIABShAgagVCEsLYKWnWvCqYO+zzz6rYX711VdQU1NJtR5+6623msrG7RSgAAUoQAEKUIACFGh2AZ1Oh+s6ZeDvOw5gJtx4Fgb5r/G79XMl+Ps+ZAxaSdfLvkwUoAAFKECBliRQ+vpmlL6ySSuyGgDsN9JXaU/57ouR+UPyHbdEpvkeLyo+3QXHxnykP3sW9ElqKxMFKEABCjQk4NxcqG0ydpYxf82N/z1R/Rim7oDtG8Cxybd/9W2cpwAFKEABClQXCEsL4MABn376abzxxhvIzMwMrGrw2Ww244EHHsB3330Hi8XSYD5uoAAFKEABClCAAhSgQCQJ/Kl7e60VsLoU/qgEdl3+1r31lbFAtv1FAsVlsnFcRjLGsAVwfUxcRwEKUIACESpQMWevFvxVF4+mSuD3JbntaYI8D5AAsAoCj5T5v8i612XqJHlUq+CCvyyD182xKSP0JWWxKECBCBFwF9i0kugTQytQIL9HWhAzUYACFKAABRoTCFsLYHUS1SLi2muvxaRJkzB//nzMmTMHmzdvRk5ODlTX0G3btkXHjh1x3nnnaeP/pqenN1Y2bqMABShAAQpQgAIUiBKBYqcL+TKlmYxIkimSU4LRgE9O6Y0xyzbhG7cHuyTAO1kugJ8qF8KNMqlUJoFf1e3zfyRArO7N7xUXizcG99C28YECFKBAKAIcmzcULeYNp4Cn1IHip9dph7xTvufOl6mh1EW+/56WIPAf5DsxT7o0rfhij2Q1N5Sd6ylAAQpEvYA+zqQZeO2hUQTy6/z7h7Y3c1OAAhSgQDQJHJera1arFePHj9emaMJkXSlAAQpQgAIUoAAFghfIrrTjiV2H8NnhAuy3Oap27BhrxsWZqbizWzt0skRmF5KnJMdj0en9cemqbdgp9bhHAr2xUgPVwbMa/fCITG6ZVBqTloh3T+6JlAgPbPtKy0cKUIACFKCAT6Di893wljoxVIK7jQV/A16pkm+KBIkflO/Esre3AYMGBDbxmQIUoAAFagkYO8Vra1wHam1oYjGQ39jZt38T2bmZAhSgAAWiWOC4BICj2JNVpwAFKEABClCAAhQIQuDFvYfxp017YZMxA1WyypQkU7FM2RIMfn7PYbyy7wj+1bcLbslqengR2e2Ep8FJcdgwahBmSl3ePpCHdSUV2OcvhVF6xjknLQF/6NwWl7RLO+Fl4wkpQIHWI7Dv4RCvDDdQ9eoties7ZvXtDRyCq6NMwPbDIa3GF/t7twim+mdJ3hTJWJhdhi3dK9EnnkN+BePGPBSgQPQJmHolQ59hgSenEs4dXph6BDcOsGOV7++n2DPbRR8aa0wBClCAAiEJHNcAcG5uLrZv365NpaWlmDJlila4nTt3okOHDoiNVe0kmChAAQpQgAIUoAAFokngoW3ZmLE9W6vyGLlQPElaC/WudnF5m3Sd/KG0HpovweHbNu5Bjt2JGb3VyIKRl2INetzerb02qW6sD0rw2qzXo4O0YlbbmChAAQo0t0AgsFtf0Le5y8bzR7aAa1+pVsD+1b6jmyqxXvL2k2mJfJdvLWMAuCkvbqcABaJbIP7qXih5ah0q53ph6ADoLY0HgR3rvHDtlmEYE0ywjsuKbjzWngIUoAAFmhQ4Llel3nvvPWRlZSEjIwMjRozQxgV+8MEHqwrz+OOPo3PnzlDrnE5n1XrOUIACFKAABShAAQq0boE5OYVa8Ncg1bxPAr/3y3iB1YO/qva95MLxvbL+Admu8v19xwHMPlKgNkV0UmMX902woruM98vgb0S/VCwcBShAAQoEIeAp812vCbWT0Tj/sYtdgcEQgjgZs1CAAhSIQoG4Cd1g6psCTyFQ/rYX7iJf6976KOyrvaiY49uedNtJ0CdynPX6nLiOAhSgAAWOCoS1BfDu3btxzTXXYPHixUfPUM/cnj17oFoHz5gxAytXrsSHH34Ii4XdAtVDxVUUoAAFKEABClCg1Qi4vV6t22dVoRskuHuOTF75T0YJxC55LpHnRJm6SgC4tzyPlu358vyCtAaevmkfzm+TAqO+8bviJTsTBShAAQpUE2gNLX+98v3h3FQI164SeEoc0CebpavMZJh6J1erKWfDLaBPiYUntxJ5cuBQOhpV+VXKMJt8M3ykAAUoQIF6BXQmPVIfPR15UxbBva8MpTO9MA+R7qB76uS7DvDKfThu6Y3fsVaCw/4RIeKv6wPrBVn1Ho8rKUABClCAAtUFwhYAdrlcuPzyy7FixQrt+AkJCVrrX7V+/vz51c+JTp2OduH35Zdf4uabb8Ybb7xRIw8XKEABClCAAhSgAAVal8APBSXYVm5De6nWBJm+kMDuLJly6qlmG1n3fxIAHi/Pn8u0o8KGhbL/r9LVSMFMFKAABSgQDQJelwcVn+1G6VtbJBBpq1NlQzsrEib3heU3XaDjDUJ1fH7pCrO0SrNJAHiF3KQ1Xm7OCiZVSt4NMqnsJycF2gIHsyfzUIACFIhOAUMbC9q8NgbFj6+RrqD3w7FSAr4r67YE1qfGIHHqSbCO7RydUKw1BShAAQqELBC2LqBVa95A8Pf666+HauX71Vdf4YorrqhTqJdffhk//fQT2rXz3UM6a9YsbZzgOhm5ggIUoAAFKEABClCg1QjMzy3W6nK6PN4nF4ef8Ad/28ryWLlSPEkm9ayWc2V6SrbfI/nOkHmV5ucW+Wb4SAEKUIACrV7AU2xH/tQfUPzEWi34q1pCmQcBMcMB00CJL0qXEe5DFSh6eBUK7voRnnIOLxXuN0XsOR21Q74v38dOFdQNIn0o+RySzzw4HRkxbAEcBBmzUIACFIA+3oSUB4ehzdu/Qvzv+kgr4HQYOsfD2DMJsWd3QPI9Q5Hx0XkM/vK9QgEKUIACIQmEpQWwauWrxvVVaezYsXjllVeg1zceWx42bJjWMvikk06C2+3Gq6++ikcffTSkwjMzBShAAQpQgAIUoEDLEdhnU5eEIS2JgH1ygThFnm+TVr6jZKqdfpCLzSoAvEryBVoI76v07V87L5cpQAEKUKB1CXjtbuTfsUTr9lmXAFh/o4OpV80WqL5uoYHKr72wLz6EwnuWIfXJM6Ez1MzXumRObG0sEgAu+89mHNxdiiflO3m6fF/r5L+GkoTq8ZZMKiXc2F+6+rA3lJXrKUABClCgHgFT9ySoiYkCFKAABSgQDoGwBIC3bNkCm83XHdMTTzzRZPA3UPB+/frhoosuwieffIJt27YFVvOZAhSgAAUoQAEKUKAVCnhkDEeV9smULtPzMEhr3/ovJJ8lF5n7yLYpcGO/2kmSJ8jWR77cfKQABShAgVAETtRYwZ3v69BksUpf3aQFf1Wr3/hrZRzE+LrfFTqdDmaJMRraQ4KUEgRenoPy97ajYHdck8cPR4Zg6nGs5zmW1+J4lEcF01NmDEPejQvxtc0NGYFZu3Ero9Z3t1u+n2fL9G/Z7pZKx13dCzHSAhhf+AesPFYI7kcBClCAAhSgAAUoQAEKHLNAWALAa9eu1Qqgxv3t27dvSIVRLYBVAHjXrl0h7cfMFKAABShAAQpQgAItS6CN+ehPz/sbCf4GatVGLjCrfLdql5OBNiZ2JRmw4TMFKECB1irgLrCh7IMdWvWsE33BX1e2F86tXrhzAW+ldP9slcCvjBdg6qODMVMH60VA+TtelL65BRUjBsNqMLRWnkbr5dhSCNvCA3DuKIanyAF9kllrSRY7qr0Ey1Mb3behjaaeyUh9/AwU/mUZlpY6pRcPN4bK93NP2SFGng9J4PcnmfL8B4i7rDsSbx7Q0OG4ngIUoAAFKEABClCAAhQ4QQJHr8L9ghPa7b5ufcxmc9CtfwOnKy0t1Wbj4k7MXbqB8/KZAhSgAAUoQAEKUODEClj8F+QHywXjk2QKJg2QfCfLtFouLseyW89gyJiHAhSgQEQLNNW69dV9R3CTwyPjHkqg1yyte9/2wLWnbpVc2yFdP3slnxfW83QwSMNi9wEn5sp48xMyjy3YWfcsoa1pqm6hHS343HsqbDhp/AJ8nVtUZyf70sMom7UVv0pPwgsDuqJ7XGxVnmBbDccMzUDC1JNQ8uRaOCvdWCbfycu0o9QcFzjmrHZInDIQOn1w3/FVBeEMBShAAQpQgAIUoAAFKBB2gbAEgAcNGqQVLD8/H/v370enTp2CLuiqVau0vAMG8A7RoNGYkQIUoAAFKEABCrRAgTKX6hgSGB5k8DdQxdP9AeByt29cwcB6PlOAAhSgQOsT+LGwTKuUXgaKL3vdC6/cb54oa86T7wJ1A1GSTAUSgFQ3Bs2VqUICwaUHvTD1VgFg4KfC0hMSAA4Ee4MNoh6vV2p5URkuXL4F+U4X4uUkY8VniEwpMhWJz1qZvpJpfl4xhi9Zj89O6YMRqTKwcgip7L/bUPL8em0PncTWjZkyW62RtVdeMhWkt/9wCHk3L0LaUyOgT5DoPRMFKEABClCAAhSgAAUo0GwCYQkAq+CtQVp0uN1uzJgxA6+++mpQFfr666+xcOFCLS8DwEGRMRMFKEABClCAAhRosQI5DqdW9owQaxDIn+twhbgns1OAAhSgQEsTyLH7visca6TkMjtaApl3yLjw8fJ8NOlwpiz8TgKbf5dxZ1eUSxfRG31bD/v3P5r3+M4FAsHH9yz1Hz270o6LVviCv+pmqbvFKbGW0xmy6zXi9C9x+sHpxoSVW7H8zAHIssYimLJ/cDAPV62RLrmFP3aMDjHDZVbGX66dXIclGP+Reh0KMPCqRfhyWB+VsXa247IcTD1+yYmbO8j/S8rOfSlAgcgTOJ6fWfy8irzXmyWiAAUo0JwC+nCcPDY2Fpdccol2qNdeew2PPfYYPJ7GW2h89913uO6667R9rFYrxo0bF46i8BgUoAAFKEABClCAAhEqEO/vAlqGbwwpVfhzxxvC8tM1pHMzMwUoQAEKnFiBOKP/s16CvyMl6nh/neDv0fKo1sD/lO1qqADVUlilBGO1pqm+Va328c+b90HdHHWq1P+hOsHfo9VWwfMHZfsZ8lwgLYXv3LT36MZG5kok760b9mg5LGN1iD1dV2/wV2VQYzHHXyPbZXSvb6S18X8P5Gn78YECFKAABShAAQpQgAIUaB6BsF1FmzlzJtq1a6fVYvr06Rg+fDj+/ve/Y+3atdo6r1e6HpL5N954A5MmTcKYMWNw+PBhbds//vEPdOvWrXkEeFYKUIACFKAABShAgRMi0NM/7uBmaYkUStriz9+j2riFoezPvBSgAAUo0HIEkoy+jsokjog7JWgpIcVGC2+Q7dMlX6B7s3RzYK7R3Vr8xl0y7u+Hh/IRIzVR9VcOjSUl+SfJZ5FMnx8pxJaypm/Hen1/rta1tLELEHNK48dX59Yn6mA515fvkR3SHzcTBShAAQpQgAIUoAAFKNBsAmH7yygtLQ1vvvmm1hK4rKwMK1as0KZAzQoKCjBkyJDAYtXz+eefj6lTp1Ytc4YCFKAABShAAQpQoHUKXNA2Bfdu3Y+FEtD9g0w1u/Osv87lku87fwD4ggwZEJKJAhSgAAVauYDvJqFzJGBZszvjhqvdVvKOkOl7+b5Qgc5oSF9IEFels6S+6UHWWY0LfLZMakzg/8n+feJVOLjhNPtIgbbRHETwN3AUU3/p+XkesLXchm0SZO7VxDkC+/GZAhSgAAUoQAEKUIACFAivQNhaAKtinXvuudi6dSt++9vfNtgtUKD4mZmZWsD4iy++aDJvYB8+U4ACFKAABShAAQq0XIEBCVb8Kj0JZVKF52QswmDSC5KvRDKOTkvE4CTVHoyJAhSgAAVas0CZ2/f9MDDIoGbAIpA/X7otjoa02d+CN1DvYOscyB/Yv7H9AnmMnRrLVXObGh/Y0MG3bkt5062Ma+7NJQpQgAIUoAAFKEABClAgXAJhawEcKFD79u3x1ltv4Y477sDSpUuxfft2bcrNzUXXrl3Rq1cvbRo/fjwSExMDu/GZAhSgAAUoQAEKUCAKBJ7s1wWnL9mAeXKBPxZuTJG2WqZ6LvK7pHWSCv6qVkpWGfv3qf5ZUaDDKlKAAhSgQLHTrSEkhEgRyF8YJQHgIr9T/DE6FQfhFDiHrvGGwnVKEMgf2L9OBq6gAAUoQAEKUIACFKAABY67QFgCwE6nE0uWLNEKe8YZZ8BsNmPw4MHa1FQNPvzwQ2zatAmDBg3CxRdf3FR2bqcABShAAQpQgAIUaMEC/aQV8DtDeuLy1dsw2+PFCgkCT5Ag8BAJAidJvYplWitB308l+HtQ5mP0Orw9pAdU62EmClCAAhRo/QKBMXzzQ6xqIH+G2RTini0zexv/WMe+TpqDr0PAKT0IJ3WOg3YnvKXSrXNy8Ofwqq4+JAXK6FviIwUoQAEKUIACFKAABShwIgXCEgBW4/uOHj1aK/ehQ4eguncONk2ePBmlpaW44YYbGAAOFo35KEABClCAAhSgQAsWUGMBLzy9P37/805sKK3EvxvoDrq/jBv4yqDuGJYcavumFozDolOAAhSIcoGh0t3/2wfysFJuBjo/BAuVX6WTo2S4gEA9Vb0vPU5OQ5PicTCnEM7dckPWkOBO4nV64drnyzs4kUM3BKfGXBSgAAUoQAEKUIACFAi/QFgCwMdarMrKSqhJpfz8wH2ox3o07kcBClCAAhSgAAUo0FIETpGg7uqzTsLnRwrx6eECrC+pQL7DiTRpkTQgwYKLM1MxQSa9jCXIRAEKUIAC0SNwkXz237lpLxZJYDNbpo71DBNQW2OL5Fstk0Wvx28yQmiqWvtALWh5nNxMZZbvyOVeL3ZI3XsE4bRH8i2VySj7jZf9m0oT26XifxIAtv/ohXmQtAKWXjmaSvYVkkOGYT4zJQHtYs1NZef2agL7Hj5Qben4zXa+zz9I8/E7BY9MAQpQgAIUoAAFKBABAiEHgD/55BMcPKg65DuaVAveQHrjjTeQkJAQWGzw2W6346uvvoLLJX8ZSOrfv3+DebmBAhSgAAUoQAEKUKD1CajgrgryqomJAhSgAAUooAQ6W2JwfecMvLovB3+TYQKegQGWRoKbxRLQfEjyqXRb10wkm0K+zKHt29IeVBfOt2Rl4qndh7T6Py9OCY04lYuT8vRIRW8S32CCs1e0T8c/dhzAtgIbKud6Yf1N4wFgV7YXtu99LbEf6NWxpZGyvBSgAAUoQAEKUIACFGhVAiH/ZeR2u3Hrrbc2iHDPPfc0uK2xDaeddlpjm7mNAhSgAAUoQAEKUIACFKAABShAgSgQeKRPZ3yfX4Lt5TbcIkHLv0hws2c9wc31EtR8RLarW9RV19H39oyuoOODEmRdkFeMn0srcLPfqV89TlvF6Z+yfa849ZPhFf4uvsEko7T4fXNwD5z940bYV3nhrfDAMlYHfXzNQLBXWiE71gI2CRLLaTBFAtNj0pOCOQXzUIACFKAABShAAQpQgALHSSDkAPBll12Gc889F998803YinT33XfjggsuCNvxeCAKUIACFKBAtAocsDnwmXSnu6ywFEfsTiQYDegeF4sLMlIwMlXahbA73Wh9a7DeFKAABShAgRYjoFrxzhnWB+NXbMXmskrcKFHFQRLYlF6IkSTPhRLQVF0+b/LX6FQJ/n56Sm9YDPoWU8dwFDROfud9IU4XrdiCNTKUggqWD5ADDxajFJmKxGitTOv9JxuYYMXsU3trvw+DPf+pMmTDx0N748o121C62QPndi9MPbwwtNNBZ5J4b6GM+bsd8BT5jji5Uwae6Ncl2MMzHwUoQAEKUIACFKAABShwnARCDgCrcrz66qv49ttvq4pUUlKC2267TVt++umnkZTU+J2e6uJzbGws4uPjta6fs7Kyqo7FGQpQgAIUoAAFQheokB467t2yHy/uPQKntMKonZ7cdUhrGfNs/yycJmOyMVGAAhSgAAUoQIFIFuhqjcXSEQPw9+3ZeH7PYazzeLFOK/DR3znxEvC9s1t7/Ll7e8RGWfA38Nq1l3F2F50xAI/uPAD1e2+D24MNEvSFNvlyqbGRVffYf+nRASpoHGo6T8ZVXnnmSbh7yz58KjcaOrdApqOvgzpeV2sM/t67EyZJt9FMxybAsXmPzY17UaClCfDfekt7xVheClCAAi1X4JgCwJ07d8a1115bVesjR45UBYAvv/xyZGZmVm3jDAUoQAEKUIACx1cgR1r6nr98M9ZKyw/V7mWktPgYLlOGzFfKtFkuAM6TaVVxuXThtwlvDOqOKzrw4tzxfVV4dApQgAIUoAAFfqmA6snkkb5dtK6d5+YWYaN0dVzgdCHdZMJJiVb8uk1y1LX6rc9UtXx+sFcn/FmC4fOkS+gN8pswz+lEmjgNSLBoTvHHEPitfi7Vo8yHQ3shu9KOr+W12F1hR4UEm1UAeoTcXDg8JR569jRTnYzzFKAABShAAQpQgAIUaFaBYwoA1y5xQkICVMtflRITE2tv5jIFKEABClCAAsdJwOnxYOKqrVrwt5Oc40EZI6+bBH+rpzNl4XcSAH4ZHnwsrYOvXbdTu1g3Mo3f2dWdOE8BClCAAhSgQGQKqEDwpe3StCkySxgZpVKteydkpmrT8SpRR0sMft+57fE6PI9LAQpQgAIUoAAFKEABCoRJICwBYKvVWtUCOEzl4mEoQAEKUIACFAhC4N/S5fOPhWVQl+GeleBvcq3gb+AQZlk/RbabZWy4dyUI/If1u7B+5CAY9TWDxYH8fKYABShAgegQKJHWlCpoZGDLvWZ9wT3y3VzqciNJxr5logAFKEABClCAAhSgAAUoQAEK/FKBiPjr8vDhw8jLy8OAAQN+aX24PwUoQAEKUCBqBNTF4n/tPKjV9w7p/Lmh4G91kMmSb7EEgbeX2/Dx4XxcznHaqvNwngIUoECrF7BLl62v7s/BhwfzsaK4DHYZV1XdCtRdxlsd1zYFt2ZloouM5cl0/AUO2Rza2LazjxRia1ml9NMBmCQQPyQpDhOlFedNXdoe03itx7/kPAMFKEABClCAAhSgAAUoQAEKRLpA2APABw4cwMcff4ycnBw4HA54pGvK6sntdkNNLpcLRUVFyM7OxtKlS3HfffcxAFwdivMUoAAFKECBJgR+KirDERn/t4PkG6aN/tvEDrLZIJf5J0jeZ+Uy82eHCxkAbpqMOShAAQq0GoElBaX4vzXbsV8Cj4FklRmbTDsqbHh69yH8e89hPNCrI+7uob5dmI6XwExxvmvLPm0M1apzSNzdafdiuXy/q+mJXQfxxuAeGCvj3DJRgAIUoAAFKEABClCAAhSgAAUm7Jn9AABAAElEQVRCEQhrAHjKlCl4+eWX4XQ6QykD81KAAhSgAAUocAwCm0ortb0GNdDtc0OHPMmff3NZRUNZuJ4CFKAABVqZwJycQkxcuQ1O6T2ip9TtKrkZaJh8H1hlcss48Vtl3Wy5OWiebL9v637sqbTjxYHdWplCZFTnXgn8PurvwcPUB4g5VQdDJ0AnwzJ4nV64dktQfqkXOdkuXLh8C96SIPAVHdIjo/AsBQWiUGDfwwdaVa0738cbfFrVC8rKUIACFKAABShAgQYEwhYAfvPNN/HCCy80cJqGVxsMBgwbNgzDhw9vOBO3UIACFKAABShQR6BQxm1UKaHOlsZXJPo3FzrdjWfkVgpQgAIUaBUCu6R179Wrt2vB34kS8L1Zgr96/81AqoKqd4h+8txP5kZLEPhBmV7dl4PBiVbphjizVRhESiVU19ta8FcPWC/WwdxPdcB9NOlMOph6SVfQvXSwLfJq0+Sfd6JfggUnJcYdzcg5ClCAAhSgAAUoQAEKUIACFKBAIwJhCQCrbp7vuOOOqtNMmjQJ5513Htq2bYvLLrsMFRUVmDFjBgYOHIiCggIsX74cs2bNQmVlJUaPHo1vvvmmal/OUIACFKAABSgQnEAbs+9rvCC47FW5AvkD+1dt4AwFKEABCrRKgXu37EepjP17tgR6p0iQt7F0moSG75YMKgh8v7QEvkLGik82heXPxsZOGxXbbPIa/HnzXq2ulrF1g7+1EWJH6uAp88K+2qvtN/c0FaZnogAFwiGwX3o5WFdSgTyHU/uM6xdvQS+ZmChAAQpQgAIUoAAFKNBaBMLyl/z+/fu1wK5CuemmmzBz5swqnzPPPBPz5s1DeXk5JkyYoK2fPHkyrrrqKowbNw7z58/Hu+++iyuvvLJqH85QgAIUoAAFKNC0wCB/S6A10nWn+k9XrTVXY3uvkrwqBfZvLC+3UYACFKBAyxZQwY2PD+XDJNW4RYK7waRRku9k+a5YLT1FfCAtVm/s0jaY3ZinCYEvpBvubBl/2SCc5pObyOzfHDtGB+dGLxbklWBHuQ094mKD25G5KECBegW+kn+Hf9uWjRXF5XW295EA8F+6t8dV0uW6TlezdX6dzFxBAQpQgAIUoAAFKECBCBcI7gpAE5XYtm1bVY6771b3ix9NI0aM0BYWLFhwdKXMjRo1Smv5q35U33777SgqKqqxnQsUoAAFKEABCjQuMDgpDt2sMciTbPP9Qd3G9wDsku9TadWl0iWZqU1l53YKUIACFGjhAgvyirVP/ZPlJiEJaQRdm3P9eefl8u+0oNGayBiwNA2UW7aCDC7pY3UwSpfQKgX29y3xkQIUCEXAKT3X3SjdqV+4Yqsv+GsGjN3lZoxB8iz/xnTS+HdLWSV+t24nxkueEv9QK6Gcg3kpQAEKUIACFKAABSgQSQJhCQDv2LFDq5PVakWXLl1q1K9v377a8saNG+F21xxrUI37q7qFPnLkCN5///0a+3GBAhSgAAUoQIGmBR7o2VHL9Jxc3s9uIgisWgk/LvlUwPgUCR6fn5Hc9AmYgwIUoAAFWrTAngq7Vv5uIdaiuz8AvEe6SWUKj8Bev6UhI7TjGTJ8gXu+FqG5MTcFqgtcJ4Hd1/fnQif94Fl+rUPSHTrEX6mH9UI94ifpkXi7DtaL5OYMK/CV3PiigsAqaMxEAQpQgAIUoAAFKECBlioQlgCwCvyqlJKSUsehVy/f7co2mw3VWwoHMqqWwCqtX78+sIrPFKAABShAAQoEKXC1dFF3cdsUlEr+KXDjR3/r3tq750vw937ZploKxxv0eG2QXNoPsvVR7WNxmQIUoAAFWo6A0+vr9j/UsX8C+Z0e3/4tp8aRW9KApa7xYZjrVCCQP7B/nQxcQQEKNCrwxv4cvCfd2euk1W/c73SIGSaBXmPNHhF0ehmXW1rnJ1wv2xKAxYWl+Nv2A40elxspQAEKUIACFKAABSgQyQKBv+t/URn79Omj7Z+TkwOvXGCofkG5Z8+e2rJav27dOgRaBAdOqFoAq8QAcECEzxSgAAUoQIHgBdR37puDe+DKNdsxJ6cI90iQt6dMw6XlVoZMlXKozRL0XSqTasOVYjLgw6G90D/Bd/NW8GdiTgpQgAIUaIkC7WMk4iEp1DDGAfneUKlDrG9/bYEPv0ignd/SXSBdznbxHcqd64VzK+DOk346bIA+DjBk6mDqLfOJvgCVu4CvxS+C585RLaBa8T6wdb9mYLlAulRvVzPwWxtHn6xD3KVA2RtePLXrIG7NykRGjBpFnYkCFKAABShAAQpQgAItSyAsLYADAWCn04lFixbVEFCtg9u3b6+tW7lyZY1tamHx4sXauoIC+SuYiQIUoAAFKECBkAXijAZ8dkpvPNWvC9JMRmyXI8ySC/dPSCD43zJ95w/+TpQxf1ecORBnpyWFfA7uQAEKUIACLVNgVFqiVvDl8l1g8wd1g6nJ9/68I/37B7MP8zQucLbf0rnFC3ehF2Xve1D6krwuCyUIvAFwychKjnVA5VwvSp7zomKOB54KD5zbfMfla9G4L7dSoD6B7wtKccjuhD5dxvvt33jwN7C/sYMEinsANukB4fMjvFYVcOEzBShAAQpQgAIUoEDLEghLADgpKQlZWVlazadNm4ZDhw7VUBgyZIi2rMb5LSwsrNrmkTsx58yZoy1369ataj1nKEABClCAAhQITUAvLYFv7doO+845GZ9LMPjeHh0wuVMGbuuaiecHZGHXmCF4X1r+ZlljQzswc1OAAhSgQIsW6B4Xi9NT4lEmtXhHbgoKJu2Q4O+3Mhnlu+WK9mnB7MI8QQhMkBux4mQYBtdOaV34ihcuuWNL9ccxTnrs+Av0+IdMf5LpbFnWS6Nfx2qg9EXAWwL0ltfx1CRpHsxEAQqEJLCkQP4BSTL5RicLel9Tb1+weLEEkJkoQAEKUIACFKAABSjQEgXCEgBWFX/mmWe0+q9du1br5vmWW26p8rj22mu1+ezsbIwbNw6fffYZFi5ciIkTJyIvL0/bFugKumonzlCAAhSgAAUoELJAjFxYvkDGBJ7RuxNeOqkbnuiXhZu6ZKKzJSbkY3EHClCAAhRoHQL/7NNZQorA21pgt/Eg8GHJc5+MKa9y3dylLW8cCuNbIN1s0m7OUof0OoAR8qq8AwPulOnXEvg9XaYLZPqrLP9HJmmACG+FrwB/7dWpxlBLvrV8pAAFmhJQrX9VUl07h5L0/g5zDtvlHysTBShAAQpQgAIUoAAFWqBA2ALA48ePxzXXXKMRFBcX4/PPP6/imDBhAtRYwCotXboUann06NFaIFitS0xMxNSpU9UsEwUoQAEKUIACFKAABShAAQqIgNvrhUemX5rOTE3Ew3JjkDrSQxLafUoCvLnaknQ77H+2y/P/ZNsfZNsRyTc8OR4qcMwUXoFNZZXaAc+S4O9DEuxN0kLzdc8h4V48K0Hgrv5Nq4tVG+5fltR7ySVd2jJRIJoErHrfZS+vLw4cfNVdvqwW//7B78ickSrgdctY6/wMjNSXh+WiAAUoQAEKUOA4CBjDecyZM2di6NCheO6559CuXbuqQ+vlB/PcuXNx3nnnYds2/wBG/q0WiwUvvfQSMjIyqvJzhgIUoAAFKEABClCAAhSgQDQKLMovwX+yc7EgrxiHbL6WZx1izTgnPQnXS9f+Z6QmHBPLXTI0gFV6ibhz017MlmDvbAn0qrCIaukbaBcXCA2Oy0jGrCE9oXqVYAqfwIqiMsyX1zVeDjld9HVV8vWfwyLb75Eg8A3yWj235zDukdcw0RTan/Brisvxyr4jmJdbjP02u9xQALSNMUGNR/zbjm0wtk1y/SfnWgq0EoFu/uFP3IfVJ1zg067pyrkO+T4Ru3L4lKaxIjiHfW0eKv63B/YVOfDk+27A0adbEDMsA3EXdoX5JA5zEMEvH4tGAQpQgAIUoMAvFAjtr8cmTma1WrWWvLfeeiu2b5cBjaqlrl27aq1/Z82apXX/rLp+VmMD//GPf0S/fv2q5eQsBShAAQpQgAIUoAAFKECB6BIodrowed3/s3cf8FGU6R/An/TeSEIqIbTQu4iKSFEUK9bDXs6K/m3oqdhRRPT0sLfT48SKnh5nL6igKF2Q3gmEJJBGSO/5/57Jbgwhyc4mm7b7e/lMdnfmnZl3vrM7IfvM8767ZOHBQ7UHruFXDUGkIBCsQWGdLooJlzfQxX+Qp0dtPbNPjg8Lkng/b9lXXBNY1uCvbqWyzga8Me7vRASbm7P9Opvh0wYEFh7IMeZORhAq0GQgqjfqDcO0DpHbbxHEvcjkmMwllVVy66Y9Mi8ls7YlGvrS6QC6xP0wLduYTsG5nj+st3RFUJiFAs4ocDpuaLljM3o72IYbXoqqxd3fdhBYM0XLN9RonIH1WTqfQFVBueTOWi0lS9L+bLyeevxSrcooluIv9hqT78lxEjpjpLgH8Br4JxSfUYACFKAABSjgLAIODQBbUdzwpUFSUpL1Ze1jeHi43HHHHcZUO5NPKEABClCAAhSgAAUoQAEKuLBATlmFnLRsk2xF98ABcLgQ2aETEaqLs5ik4PEH5Op+gm+uP07PNuotPn6AhNiRDaoZxVNWbZUSBBK7Y3uXYB/HYh9hmLT7582Y/odpCboJno4s4T1FpTJ3YKKlBXxwhMCm/JoBfYcaYVjzW9T663BuNmL9i8R2tloxgr+nrtgsyw4ViDd2cy7Wn4Tz3QPPNf6RjmkJtrcA7ynNSD5u6Qb5Zcwg0UxzFgo4m0CvAF85HZnuX2fmSvH31RIwxXYAuGQput/PFRkQ6GfcEONsJs5+PFWHyyTrpsVSkZwvehH0GY2HgW7i3qXmyKtwL07ZxmopXSlS8kOqZKFexKvjxD2I10Bnf2/w+ChAAQpQgAKuJsA+vVztjPN4KUABClCAAhSgAAUoQIEOJXDJ2u1GULcnWvUv5ORejWBdAkJ1HpYpEY/X4tVbmHRU3g0IBF65bqfpY9hXXCpT12w3gr9nYVu6ndOwDw3+avHB43C8fhTzH8OjfgWuXQ7/a1+GsZw/HCOQgyxvLY2N+9vYXkIsC6zrN1bPOv/mDbuN4G8UZryOczoNk2YS6/tJO56Ow3Qpnr2NOdoX1z5kmJ+/epsx5rR1G3ykgDMJ/H1AdwlAl/aa1Vv0bVWT48CWLEdg8BfBJ0TkOdwE44EEB5bOJXDooRVG8Nc9UiT4RjfxG+cuHhHodN+9ZtLnfuPdJegGXBMjkB2+K08OPbKqcx0kW0sBClCAAhSgAAVMCDAAbAKJVShAAQpQgAIUoAAFKEABCrSGwKfI6P0hKw/BWJGnEZDriuBcYyUGy7ROMCp8mZErX2X82V10Y+vo/Ae3pUhuRaWMwfrTEdbQQGBjZSyW322EPkRmbN0neZagZWP1nX1+PtyWYFzmj9KyDO/tyNJubonwruliNBfZt/YUa/0Ib9sdeK04lC/vpGaJL3bwFM603jzQWAnFsjmoE4MKazBW8LwUBvwbs+L8zi3QD5m872Jcc28EAMsQ58t/HUHetdVSmVst1RXI9s2vlrJN1ZI/r0pKFtV8Pp9H8Fe7w2fpXALFi1ON8X7d/EUCL0WAN6Txa6BHKLrjvwRBYT+R0mUHpORX7R+BhQIUoAAFKEABCjiPgO2/IO081i1btsiKFStk9+7dkpmZKdXoQsxMOeuss0QnFgpQgAIUoAAFKEABClCAAq4i8Oreg8ahatZveBPBOqtHFOpcgbovo/veV5MPyhldNXTceNHupRcgeKl/+N2G9fBVd+OVLUu0u+AvsP31CP5+nJ4j1yZ0tbmOs1XYkFckj25PQdA3V8rr/U3b299X7uwZI9d26yqeCCiZLYOD/OUzjPH8OwLAY82uhHpaX4uub6u8Ynk/XYjz3N3EuQ5CnRtwvmfifL+C99N1CZo3zEIB5xM4OypMfjhugFyzbpfszC6R4i8b/q4qCuNhvzKoh0yJtvQX7HwUTn1EhZ/uNo7P9yQEf4NsX581QOyLC3Lxd9VS+J9d4jtGb4lhoQAFKEABClCAAs4h4LAAcH5+vtx5550yb948qaqqslsnOjqaAWC71bgCBShAAQpQgAIUoAAFKNBZBYoqK+XnnDzkYIqcbCJYZz3OSaj7Cl78kH1YyvG3l5d74x07LcrKRde+IqOwTlPZxdZtWx+1i+j1CAp+g3EzXS0A/NzudLlny14cfU03sAPwqIF3HcF3G4KxO4tK5JaNe2T+/kz5ZGSSRJscO/c8BJSe2Jkq32EbV2HSDFxbRcdm3ohK/ui+9jSMY2qrfIvzpWUyzp/ZciLaoWNPr0fX4unoDjrG5PGY3T7rUaCjCBwfFiQbxw2VD3BTzCfofWEdbvTILCuXMIynPjDIT86J6iJXx0dKgKdelVk6m0B1SaWU/Z5pXLi9B5lvvRfqFn+PLOA1SGIprxI3L/PXT/N7YU0KUIACFKAABSjQ9gIOCwDfe++98tZbb7X9EXCPFKAABShAAQpQgAIUoAAFOqHA/uIyIzgbj7YHmAgGWg9Rx5DF0IaSUVUt6aXlkuDnY1101GMyxv/V0vuoJU3P0DFjtSQj2OlK5e+70oyur/WYL4DB5Qik1g3UYvRQ+RWTZmCvyC2Qics3y7IxgyQEASRbZVhIgJyNjO3P0XX3bKz/JLbdVHfc+djPk1JpbHY6Mo5tBaUK0V11FjK+tftnHefXbPFE3e6ovBmTvl8YADYrx3qdUUCz9q9AkFcnFucSqMxEF/2448kdHWO4+Zq/Brr7o2+MYHQHfrhKKrOKxTNGb4lhoQAFKEABClCAAp1fwPZfqSaOMTk5WV577bXamtdcc42ce+65EhERId7e3rXzm3oSGxvb1GIuowAFKEABClCAAhSgAAUo4FQCpQjgaqkZGda+Q7OuU2qj96VSTf9txj7+3H7N+va1rnPW1vFz78e4xxo2eBDB2YkNZNFqJ9pjMQ3BdBeCs9sLS+RmZAO/h/FFzZQXBiXKiqX5sgqB2nsQBL4X+2goM3sHgr+PY/v7sdHhwf5yb684m5tv2ftJjxrjotp4P9lsBCtQgAIUaCeB6rKaG2aMMQ/sbIMbkr6N33Zl9vdoaOeuWJ0CFKAABShAAQq0mYBDAsDr16+vHev3gQcekFmzZrXZAXBHFKAABShAAQpQgAIUoAAFOqNArG9NmFVHAa7EV89NZYPWPb5y1EUnl0aJ9Wn6httYS3e+aXU3YOJ5Ws1X4WJd38Qqnb7KA9tSjKO+FMHdhoK/dQ9Qs7Bn4YxdjTO3IC1b7u4ZK8OR4WurdEO29ufH9pMpq7bJ78jevgLrj8G2BmMKwsrZmNagFass/kMR/P3fqH7ihy6gbZUu3p7ig+zGfNxYoNnDOr6v2ZJu2Z+t95PZ7bEeBShAgbYW8IjwM3ZZdRjBXFwH3UyO0V6NG6Wq8mpa6x6hfSiwUIACFKAABShAAecQsP1XpInjTElJqa111VVX1T7nEwpQgAIUoAAFKEABClCAAhRoWCDc20v6B/oZY8uutQTgGq555NyVqFuGWSMQcLTVLfDYLhpWFKlZx3w27y+W9ljXNzbixD9SMfbt4uw8o/vkyxrI/G3o0KMRYD3LEmTVMUXNlpEhgbLyxMFyaVyEcR5/gvULyAZ+AtNrmDT4q4Hcu9Ht8y8nDLQrCH9Sl2CjGUst589Mm7ajbgYqRvt4SZ8ABj/MmLEOBSjQ8QTcQ7zFsyeugfgFWbHHfPsqdqNuhYhnUoi4B1j7vzC/PmtSgAIUoAAFKECBjirgkADwyJEjjeNzc3OTuDjbXVN1VAy2iwIUoAAFKEABClCAAhSgQFsKXIYgoJZ/IfCnWcC2SgXqzENdLdZ1m1onCQHmUQgUa3LTAhPb120lo94iTB5IIJ0aW9O+pvbhDMt+zalJ/xqJgK6/HZmzJ1qCxUtz8u1i0Mzq+cN6y+6Jw+WFgYkyrXuUXBwbLrclRsu8ob0k5eSRMqd/d/H3QL+kdhTre+IdvEdKTJxvjHopb1reT5fgXOvf9CwUoAAFOquA3+QEo+kli3F1swyz0NSxaPav1tXib1m3qfpcRgEKUIACFKAABTqTgEMCwMccc4wEBgYa3UCvW7euMx0/20oBClCAAhSgAAUoQAEKUKDdBG7rES2xyLzcghbMRSCuqomgnQaI/44au1A3EV0J35QQZards/vVfCH+b6y7FFNTJRP7eBChaB1J8Xpsv7eLZISmlZQbLDFN4TSwLNYyLw0ZxM0pCTiPNyPo++KgHvIuxhH+B4LBV8RHinbn3JyiWcVDgvwlHSvPwrkua+L9pNv/J+poxnGop4fc19t6NM3ZM9ehAAUo0P4CARf1EvdIP6nERbD4q6aDwBogLv6yWioxDoNHtL8EnN+r/Q+ALaAABShAAQpQgAIOFHBIANjT01OuvPJKo1n3339/7XjADmwnN0UBClCAAhSgAAUoQAEKUMDpBDTD8+ORSUaXv18iEHcXAnLaJW/9sgXz7kBY9js8+rm716xjYlxY3c6EiBB5qE+cEfp9GD9fwXZy6+1DM4u/w7IbsSwV62j30n9HBqqrFF9Nd0axN4xrre+Lc9IRijsyeBeM7GMEdH/FOb0V5/OPeuda26lZ3jOw7AM8asvfH9FHtEtyFgpQgAKdWcDd11O6PHmciLe7lCE/pfC9aqlIP/p3akVatRS8g+EU1uNofTwkDOu44ZGFAhSgAAUoQAEKOJNA824rbkDghRdekKysLPnoo4/ktNNOk2eeeUaGDBnSQE3OogAFKEABClCAAhSgAAUoQAGrwOiwIPlu9AC5cM02WVdWYQRhdWCdBHRFrF9b78VPzejUouO0fnpMXxmOAK095ZGkbqJByge3pcjH2N4nCP4lYQOR2EchHrdhnj5qOQUB4w8QEPQzGWCuWatz/0z0qxn7dochbv5Ydlrq9/D3Mb9SK9fsE+AnizF28Hmrt8n2olLjxoGu2GcPnGv9AiAFbd5naUMwMn/fR+bxqZGhrdwqbp4CFKBA2wh4D+wiES+eJDn3LZOKvaVS8BZudAnDpCMa4JdqVTamQzVtcQ/3lS5PHS/e/cLapnHcCwUoQAEKUIACFGhDAYcFgD1w5/q7774rmzdvlu+//16GDh0qAQEBkpiYaHQPbeuYrrvuOtGJhQIUoAAFKEABClCAAhSggKsJjOkSJJvGDZM5u1Jl/v5MSUUgOLVOMLIrsjOv6RYp9/SKlRCv5v0Zd2/vOJncNVQe275fvs7Ila3V1bK1zj606+C7sf1LMBatq40FOy482Mis3lJVZQTcuyNYaqZ8bfFT145UBuFcrhs7RObuSZd/7suQVHRRnVHnXGuXz5egu+gHkRke5ePdkZrOtlCAAhRosYD3kHDp+uGpkj9/G7qC3ouAb2lt0Fc37h7mI/5n4fvKK5LEPYjXwBaDcwMUoAAFKEABCnRIgeZ9c9DAoZSUlMgtt9wiGzdurF1aWFgomzZtqn3d1JPJkyc3tZjLKEABClCAAhSgAAUoQAEKOLWAjvv6NLpdnoMxe9fnFUkKgnYahuzm5y2DEdDT7n1bWoYGB8gnyCDOr6g09nGwtEyCEVBOwli/Oh6tqxbNdv5rQqS8nHxQnkNX2M+gY2QPG0HgX1BvJYKqmkV7OYKpHa0EoF0P9ok3pk35RbK3uFTKMeZlPN5PQ4MCxNO95e+njnbMbA8FKEABq4B7sLeE/N9gCb55kFTsPIyxfosEdzeJR5SfePYKETdeA61UfKQABShAAQpQwEkFHBYAnjp1qnz22WdOysTDogAFKEABClCAAhSgAAUo0DYCGugdhi6edWqtEoTgoGYds/wp8GDvePkkPUfWlZbLEwju3ocgsHcjQeBlWD4bk5bH0L12Rx8/dyBuINCJhQIUoICrCWig1ysp1Jhc7dh5vBSgAAUoQAEKuLaAQwLAmv377bffGpIhISHywAMPyNlnny2xsbHi7W2uKxVPT4c0xbXPJo+eAhSgAAUo4EQC2wqKjWylCnRRGu/rLdqdpSOy35yIiIdCAQpQgAIOFIi0jK982vLN8lNllWzBOMmXIAh8HILAmt9bimkLMn6/wPSTpTvl6xK6yv/1iHZgK7gpClCAAhSgAAUoQAEKUIACFKBAywUcEnVdtmyZlJbqn8Mir7/+umg2MAsFKEABClCAAhSwV6AYX7g/j/EK39h3UPYVlx2xeji6KL08PkJmYAzLCIyFyUIBClCAAhRwtMCxoYHy25hBctnanbIe3SbPtWT5amfJ1XV25ouMspnI/L0LYyazUIACFKAABShAAQpQgAIUoAAFOpqAQwLAO3bsqD2u008/vfY5n1CAAhSgAAUoQAGzApvxRft5q7fJrqKam8rCsWIPZF154DEFX7unlVcgOHxA5u/PlA9HJMnJESFmN816FKAABShAAdMC/dHjxOqxg+U/6dmyIC1blucWSAa6hQ7AOMG9MVbymV3D5MbuURKH3ilYKEABClCAAhSgAAUoQAEKUIACHVHAIQHg448/vvbYDh06JMHBwbWv+YQCFKAABShAAQrYEthZWCLjlm2SQ+WV0guVb0aXm8MR/NV/1rITQeA3kIm1CnXOWLlFvjm2v0xgENjKw0cKUIACFHCggA458JfYCGPSzVZhOAIOQ+BAYG6KAhSgAAUoQAEKUIACFKAABVpVwN0RWx80aJBEROioSCLffPONIzbJbVCAAhSgAAUo4CIC+qX61N+3G8Hf4xHwfQU5vyMQAK4b/FWK3pjzFOZfiMdK9MM59fcdWKfCRZR4mBSgAAUo0J4CDP62pz73TQEKUIACFKAABShAAQpQgAL2CjgkAOyGu6NvvvlmY99PP/20bNmyxd52uGz9tLQ02bhxo6xcuVIWL14sy5cvN/xSU1OlpKTEZV144BSgAAUo4DoC76dmyR95RRKDQ34IAV5vBHgbKxoU1uzgEXjMQfD36V1pjVXlfApQgAIUoAAFKEABClCAAhSgAAUoQAEKUIACLingkC6gVW7mzJmSmZkpr776qowePVo0EDx58mTp3r27aICYpUYgPz9f5s+fL++9954R+NXXjRVPT08ZPHiw4XnWWWfJGWecQcvGsDifAhSgAAU6rcC7CABruQKBXb8mgr/WA9Qg8HWoe7NUynsYD3h23278/WjF4SMFKEABClCAAhSgAAUoQAEKUIACFKAABSjg8gIOCQDn5eXJbbfdJtXowtHHx0c0qDlt2jQDV4O/QUFB4uXl1ST2PffcIzo5azl48KA89thj8s477xg+Zo6zoqJC1q5da0yvvfaaaFfbc+bMkTPPPNPM6qxDAQpQgAIU6PAC+n+Hn3PyjHaONRH8tR5Qf9TVwSfSSstlV1Gp9A7wtS7iIwUoQAEKUIACFKAABShAAQpQgAIUoAAFKEABlxZwSAC4uLhY3n777QYh9YtdDRDbKroNZy2HDh2SSZMmyYYNG2oPUQPjMTExkpCQIJGRkeLn52cEzzXoq10/q1lKSors3btXSktLjfW0q+hzzjlHnn32Wbnjjjtqt8UnFKAABShAgc4qoN04l1VVSzAOINCOALAebywmzR1OKyljAFhBWChAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEKQMAhAWB3d3eJj49vEWhwsH7163ylsLDQyNi1Bn9HjRol06dPl5NPPtkI/No64vLycmN8YO02et68eaKv77zzTklKSjK6hLa1PpdTgAIUoAAFOrKAN/4PoaW8GY20ruPtzqEmmsHHVShAAQpQgAIUoAAFKEABClCAAhSgAAUoQAEnFXBIAFgzWDVbleVogY8++kiWLVtmLLj44ouNsX81YG62aNfZY8aMMaYpU6bIueeeawSB77vvPmOMZXu2ZXafrEcBClCAAhRoK4EgTw8J8/KQQ+WVki7VEmMyC7gCdfdZGpno59NWzeV+KEABClCAAhSgAAUoQAEKUIACFKAABShAAQp0eAHzkcgOfygds4G//fab0bAhQ4aIZvG2JGB7xhlnyDPPPGNsTzOK9+zZ0zEPmq2iAAUoQAEK2CFwWmSoUftbqTK91q8IABei9pAgf4n29Ta9HitSgAIUoAAFKEABClCAAhSgAAUoQAEKUIACFHB2AYdkADs7UkuO79dffzVWP/vss0WzeVtaLrjgArn99tuNzWzfvl169erV0k3aXP/JJ5+UuXPnSlWV+S/mG9tobm6usUjHRWahAAUoQAEKqMC07tHyYVq2fISg7imY4m1kARegzuuWYPG0xCgiUoACFKAABShAAQpQgAIUoAAFKEABClCAAhSgQB0BBoDrYLTG0/379xub7datm0M2Hx4ebgSSdSzg4uJih2zT1ka0e+/MzExb1exaXlZWZld9VqYABShAAecVGNMlSC6ODTeCwPdKpTwpHpLQSBD4MIK/D6JOOjhGhATIX7t1dV4YHhkFKEABClCAAhSgAAUoQAEKUIACFKAABShAgWYI2BUAnjdvntx5553GbgYMGCDW7o0zMjIkKSmpGbv/cxUd01YnZyuaobtu3TpjHOAbb7yxxYen5hr81TJ8+PAWb8/MBl555RWZNWuWQzKAJ06cKNp9dVQUM7bM2LMOBShAAVcReGNIT9lVWCKrDhfKDQjwXoAA8CRxRyBY8NNNDiDwuwTTh8j81b4k4tHt86cjk8TDzc1ViHicFKAABSjQDgIVVdWytbBYDpaWS6CHu/T095VIn5b37NQOh9Lpd5lfUSk78H+F7LJyifT2kqRAX/H38Oj0x8UDoAAFKEABClCAAhSgAAUo0BoCdgWANWvz8OHDRjvy8vJq21NdXV07v3amnU9KS0vtXKNzVB85cqQRAF6wYIFcc801Mm7cuGY3XLtPvuuuu4z1u3TpIj169Gj2tuxdUffniOLpaddbzhG75DYoQAEKUKATCOgXuD8cP0Bu3rBH3k3NkvcR7H0fgWB3tF2nijrHMCE8WN4Z1ptj/9Yx4VMKUIACFHCswN6iUpm1c798mp4jhxF4rFtGhwbKnT1j5MKY8Lqz+byVBJbm5MmcnWnyQ9ZhKcd3D9bi4+4mkyND5YE+8UavINb5fKQABShAAQpQgAIUoAAFKEABEbuicUFBQZKYmGi4xcXF1fp54Etb6/zamXY+CQ0NtXONzlF9xowZMn/+fCkpKZEpU6bIU089ZQSCvb297ToAzSK+4YYbjGCyrnjTTTfZtT4rU4ACFKAABTq6gAaB/43A7s2J0fLPfQflu8zDklZSZgR/I7w9ZTwCv1fGR8oZXcM6+qGwfRSgAAUo0IkF5u/PlGkbdkspsn+1xGPqit4oinFz0m48X5FbIBf/vkNOjciQ90f0kVAvu/6s1k2ymBDQ7Os7NifLa3sPGrU117c3phCci0M4F3uw/H8HDxnTfb1i5fG+3cTNjT2DmKBlFQpQgAIUoAAFKEABClDABQTs+kv10ksvFZ3ql4iICNmzZ0/92XwNAe0Cevbs2fK3v/3NyJLWwK0+10zgYcOGGVm82h2yn5+f+Pr6SkVFhREs1gxrHXt3586d8vPPP8vGjRtrPU899VR5/PHHa1/zCQUoQAEKUMCZBI5FZpVOWvTL30pk+/ig200WClCAAhSgQGsL6A1I09AbhZZTEGi8Gv1QxOHRWkoReFyE6U0MSfAdMlInLd8sS04YyK6IrUAOfLxi3U75OD1b9Nbpy3AezsN5CKpzLjQI/DHOw0d4nLMrzcjUfnFQ2/WS5cBD5aYoQAEKUIACFKAABShAAQo4XMCuALDD9+4iG7z77rslPDxcbrnlFikuLpb8/Hz54osvjMlegsmTJ8t7770n7u78ItxeO9anAAUoQIHOJ+CJ7h0963zZ2/mOgC2mAAUoQIHOIrA+r1Bu3ZhsNPdOBBzPMQYhOLL1PviddCamUZjuwlAFa/OK5M5Ne+V1jGXP4jiBl5MPGMHfAGzyWfGQvg38XyAM827AsmMQBJ6B6VVkCo/tEiR/iY1wXEO4JQpQgAIUoAAFKEABClCAAp1UwCFRxPLyclm8eLEx6TjB9pSPP/5YZs6cKQsXLrRntU5XV8f/3bt3r9x///0SHR1tV/t9fHyM7qM///xz+frrr8VR4/Ha1QhWpgAFKEABClCAAhSgAAUo4MQCD2xNkQr0OqGZpg0Ff+seunYJ/QSCj3pH9b9SMmRLflHdxXzeAoECjLk8c/t+Ywv3IQjfUPC37uZHoM5tlmD9DD2H6D2EhQIUoAAFKEABClCAAhSggKsLOCQDOCcnRyZMmGBYpqen2xXgvPbaa42M2Ouvv17OPfdcpz4fkZGR8sQTTxhTcnKyLF++XHbs2CHa3fPhw4cNBy8vLwkMDJTg4GCj++gBAwbI0KFDjXlOjcODowAFKEABClCAAhSgAAUo0E4CGaXl8k1mrtHd8DUNZP421KwEBIFPx/Q5uiB+LzVLZvVLaKga59kp8FXGIckpr5CBWO9Ek+dCz8MC1N9bXCo/5+TJxIgQO/fK6hSgAAUoQAEKUIACFKAABZxLwCEB4OaSaHfIOmnJzs5u7mY65XqJiYmiEwsFKEABClCAAhSgAAUoQAEKtK+ABg01b3Q4Aol1x5m11apxlgDw4uw8W1W53KSA1fIkk8Ff3aw7zsNYTO/jLOr6DACbxGY1ClCAAhSgAAUoQAEKUMBpBewOAH/66aeSlpZ2BIiOaWst8+bNk6CgIOvLRh9LS0uN7owrKiqMOgMH6v29LBSgAAUoQAEKUIACFKAABShAgbYVSCupGcoo3s7dxiPoqCXVsr6dq7N6AwItOxfVPBcNmHIWBShAAQpQgAIUoAAFKOB6AnYHgCsrK+XWW29tVErHuG1OGT16dHNW4zoUoAAFKEABClCAAhSgAAUoQIEWCXi61QRya25PNr8pa30v95r1za/Jmo0JWM9FZWMVGpnPc9EIDGdTgAIUoAAFKEABClCAAi4pYHcA+KKLLpJJkybJ999/7zCw++67T84880yHbY8bogAFKEABClCAAk0J/JqTLx+mZcmyQ/mSjnEf/T3cpZe/r5zRNVSuiI+UMC+7/4vU1O64jAIUoAAFOrhAgp+P0cLdRkfQ5hu7x1K/u2V982uyZmMCf54LQbfO5ov13PFcmDdjTQpQgAIUoAAFKEABClDAeQWa9e3mm2++KT/++GOtSl5entx+++3G6+eee05CQkJqlzX0xA13V/v6+kpgYKBo188cC7chJc6jAAUoQAEKUMDRAgdLy+T69bvlq4zcoza9p6hUFmUdlse275cn+yfI9QlRR9XhDApQgAIUcE6B8eHB4o2/UzdVV0sagrqxlq6dbR3td5YA8KmRobaqcrlJgdNwM9YLyQfkB6mSy3EePEyci1Kch59rz0XT30eYbAarUYACFKAABShAAQpQgAIU6NQCzQoAJyQkyNVXX1174AcPHqwNAE+dOlWio6Nrl/EJBShAAQpQgAIU6AgCu4tKZOKyzbIf4zQGoEHn4gvlE8Rd9H8tJZi24YvjrzCtrqiUaRv2yNaCYnl2QCKWsFCAAhSggLMLBHp6yKVxEfLv/ZnyIgKPs/H7wc1G4HEN6v2C3xt+7u5yOdZlcYzAyeEh6JXDR3bhxqxP4XuRjfOge52Pc5GDx2NCAmRkSKBjGsKtUIACFKAABShAAQpQgAIU6MQCzQoA1z/eoKAg0cxfLcHBwfUX8zUFKEABClCAAhRoV4Hiyio5d9U2I/g7CC15DPlEYfW+UNZsrwlY9iO+RH4K0/N7DkhSgJ/c2J2ZwO168rhzClCAAm0kMLNvN/nfwRxZXl4pc/F74HYEgRvLPt2AwOSjqKPl/j5xEuPr3UatdP7deGI85WdwA9Z5q7fJ6zDWfN5TcS4aK5+gzvs4Hx4Yhpk3bjWmxPkUoAAFKEABClCAAhSggKsJOCQA7O/vX5sB7GqAPF4KUIACFKAABTq+wHN70mUzMnoT0dSn8XW+X73gb90jmGj5kvlxfKE8Y+s+uTCmi4R7e9WtwucUcFqBw+UVsre4VAoqqhDQ8pJEjGuqw7ewUMAVBOIQxF0wIknOXrVVPq+qls1SiS6I3WU0fmdYf2/sRKDxC/x++AKPlUDR3xH39Yp1BZ42Pcazo8Lk0aR4eVSHZYC3ZlpfiHOhN3FpUL4Cr//A9CGm1Zi0PD8wUcZ0CTKe8wcFKEABClCAAhSgAAUoQAFXF3BIALg+YjXGTaqoqBAvryO/LN2yZYt89dVXsnjxYgkLC5Pzzz9fpkyZwi+V6gPyNQUoQAEKUIACDhOowv9LXkAAWMvtNoK/1p1qEFjHdVyB7qDnpWTK3fxy30rDRycVWHggx/icLM3JR6jlzxLt4yVTY8Pl3l5x0hXPWSjg7AITI0Lkp+MHyqW/75BduBlipuUToWFFHS6g3AKg+aj34HfDLGQN8yYJC4qDHx7sEy8xPt4yfXOyLEVPHksRcld37eC5AJP1WhWK7rtfG9ITwfhwB7eAm6MABShAAQpQgAIUoAAFKNB5BRrvR6kZx5SWliaPPPKI9OzZU3766acjtrBo0SIZPHiw3H333fLFF1/IO++8I+edd94RYwkfsQJfUIACFKAABShAAQcIrMotkMyyConDtoY1kflbf1dnWep+lXGo/iK+poDTCGjG79krt8qFa7bLzwj+euDIemIagElHND1QWl7THfpPa+V/CBKzUMAVBI4NDZTN44fKi8goPTEsSLyQBZ+PA9fgbzyyhG9MiJL144bK7H4J4s4M+VZ9S1yb0FW2TxhmZFn3C/Qzcn3zLHscEuQvjyBIvGPicAZ/W/UscOMUoAAFKEABClCAAhSgQGcUcFgGcGlpqUyePFk2bNhgOOzatavWIyUlRS6++GKprNROso4s8+fPl6FDh8r06dOPXMBXFKAABShAAQpQwAECu4tKja30syP4qyv0tdTfWag5XywUcD6BIvzf/JTlm2VtXpEE4/D+ity6U/G+t3Z1q0e8A+GWecizW4bsuwsQJH5/eG/5S6yGhlko4NwC3u7uMi0x2pi0h6tDGBc4wMNdfDCxtK1AFLKAZyHYrlMFuubORW9jYV6eGPOX3dO37Zng3ihAAQpQgAIUoAAFKECBziTgsL9e77///trgr3aB5Y4/mK3ltddek+zsbOPlsGHDZOnSpaIZwSNGjDDm3XPPPbJp0yZrdT5SgAIUoAAFKEABhwkUWG5A87Nzi9b6BQh8sVDAGQVu25hsBH/jcXBvIPd3CgLAdYO/esx9EBCejWXXGh2vIkj8xy7hTRHO+G7gMTUloH/fdvH2ZPC3KaQ2Wubp7iYR3l4M/raRN3dDAQpQgAIUoAAFKEABCnReAYdkAGtm78svv2woaFD3zTfflOHDh9eqfPjhh7XP//Wvf9Uu0yBwYmKi5OXlGUHhgQMH1tbjEwpQgAIUoAAFKOAIgSjLuKUH7dyYtX4Mxz21U47VO4PABmT9vr0/U3RU3ycQ4I2ykSF/OQLAKcgG/g7Zdw9tS5EPRvTpDIfJNlKgwwvkY6z57zJzZWtBsZFlHIlA8/CQABkfHiyahcxCAQpQgAIUoAAFKEABClCAAhRojoBDAsDa3bN2Aa3lvvvuqw3w6utt27bJ7t279an07dv3iGVhYWFy4YUXigaFf//9d6MOf1CAAhSgAAUoQAFHCozGWI7aSeQfCF4VYfK3Eeiy7ns56mo5DuM/slDA2QTeSc003uE61nWCyc/EDQgC/yCVshBjAedh7OBgdMHKQgEKNE9Ax9+etSNVXtl7QEpxY0X90gWfrxm9Y+XWxBjRrFcWClCAAhSgAAUoQAEKUIACFKCAPQIOuaV48+bNxj49PDxk0qRJR+z/66+/rn19+umn1z63PtEMYC1r1641HvmDAhSgAAUoQAEKOFJAxw6cgEyqMmz0A4xlaqYUIDT2saXu1NhwM6uwDgU6lcBPWYeN9o63dO1spvHhCBQPQsVyjIe69FC+mVVYhwIUaEBgR2GxHPfrRpm7J13KEPwdijqX4/M1DZ/Hv+CxF17nIED8ty375PSVW5AZXNHAVjiLAhSgAAUoQAEKUIACFKAABSjQuIBDbtvft2+fsYe4uDgJDQ09Ym91A8CnnXbaEcv0RXl5uTGvooJ/1B6FwxkUoAAFKEABCjhE4LG+3eTH3zbJ+wjs9kdg94Qmgl5lqPMY6mh47KQuQXJq5JH/t3FIg7gRCrSzQGpJzf/Bdfxfe0o3BKc0mz61RG+pYKEABewVyCorl8krtsre4lKMsS1yD7pg743PVf2yEr+Hnsb0U3aeXLRmu3xzbH9mAtdH4msKUIACFKAABShAAQpQgAIUaFTAIRnA8fE1Xx1lZGQcsaPi4mL5+eefjXm+vr4ybty4I5bri61btxrzEhISjlrGGRSgAAUoQAEKUMARAtqN86NJ8fgqXeQh/Pw3urEtRhCrftmGebdh2So86jiM/x7Wu34VvqaAUwh4WOJN5nLi/zxka32PBgJWf9biMwpQoDGBOzYlG8HfAajwQiPBX133WNyo9CqWR+D5YgSBn0O2MAsFKEABClCAAhSgAAUoQAEKUMCsgEMygHv3rvlytKSkRBYtWiSnnHKKsf8FCxaIztMyYcIE8fPzM55bf+zZs0cWLlxovOzRo4d1Nh8pQAEKUIACFKCAwwUe6B0nOsziYzv2y9sI8C5AoHcEgljR2JP+b0WDv7sse+3h7yMLj+krCX4+Dm8HN0iBjiCg7+300nJJxvs+wo5g7h7U19LNz7sjHAbbQIFOJbC1oFg+TMsW/fQ8guCur43PXiSW34dA8N24cWnOzlT5v8Ro8fWw7x7uDHzO30/Nku8yc43AcwW6cI/z9Zbx4SFySVy49Ak48m/05oCuPVyI48qS39A1fDp6FwhAG3v6+8oZUaFycWyEBHl6NGezXIcCFKAABShAAQpQgAIUoAAFWiDgkADw4MGDpX///rJlyxa59tpr5cUXX5SCggKZPn16bdOuuOKK2uf6ZNmyZXL55ZfXdgF91VVXHbGcLyhAAQpQgAIUoIAjBdzc3ORhZAGfHBEiD27bJ7/k5MtvlmCWdT/B+JJ6WvcoubdXrAR7OeS/SdZN85ECHUpgUmSIrMgtkEX4DBxjsmWpqLsFdf3c3eXELsEm12I1ClDAKvBperbx9BQEdrvaCP5a1xmJAHASAsDbKyrlB4zdfWZUmHVRk4/VCPQ+uztdHsdNT4WV1tz9mlV2FZXKz/gd+MTO/XJDQpT8vX93uwPLuqWcsgq5eeNu+U96zlFt2YRg9+cZh+ShbSnyDLZ/eXzkUXU4gwIUoAAFKEABClCAAhSgAAVaT8Ah32waX6g+/LBccsklouMBT5ky5YgWn3TSSXLBBRfUzhs/frwsWbKk9vU555wjw4YNq33NJxSgAAUoQAEKUKC1BMZgXN+fjh9ojGG6zMhWKkO2kof0DPCRMegq2gvBLRYKOLvAlQjGPLUzTb5HkOgcBHYH2AhGVaPOS0Yn6iKXxUeIn51ZiM7uyeOjgBmB35Epq2WUjc9b/W1p/e34DOr6ZgLAVfhcX7FupyxAtrGWE7D+JEw9MWku7n5sawmm71Dv1b0HZQ22+82x/ey68SkFYxifsnyzaDDZF9s8E9segykak7VXja9wzdiAIPHVf+ySLQgIP9EvQZvDQgEKUIACFKAABShAAQpQgAJtIOCQALC28+KLL5bS0lK5/vrra7N6db5mBms3z97ef3YTFxISoouMctZZZ8m7775rfclHClCAAhSgAAUo0CYC2gXmhTHhbbIv7oQCHU1Au2e9vUe0PIMMwQfRHfrTCAv1RuCmoVKJQNELCOQsx2OYl4c80ie+oWqcRwEK2BDIKCs3aoQ38llrbPWa+tViXb+xetb5DyPrVoO/gZjxEDKIdTzhuiUO+x+NGRfhM/0APv8r0RuABoz/N6pf3WqNPi9FRvF5q7cZwd++qPU4rh/aXXXd0gOvJ2O/X+Pa8Q9MT+1Kk94BvnJNt651q/E5BShAAQpQgAIUoAAFKEABCrSSgMMCwNo+7cb51FNPNbJ7k5OTjXF/R40aJe71Mmk021e7pJo6daqRNVx/eSsdKzdLAQpQgAIUoAAFKECBVhPIRnAntaRMvPF/33jcYBDYwce9nNU3QdbnFcl36Fb2FgSBLkDA5kwEbDQ4pKUMwaGVmN5B8GY7XnujG/UFI5IkBsfGQgEK2C8QahlaoACfK6kTMK3A60zMKcAUiklvTXKvs1zna7GuX/Oq4Z/bkWn7991pRqbvLPwcWmc79dfQIO0/UOdGfP6/zMiV/x7IkfOiu9SvdtTrl/cekHW4duitIM9g/cAm9nE6jkS/dJiN68jfNu+Vc7H9MA6xcJQpZ1CAAhSgAAUoQAEKUIACFHC0gEMDwNq4mJgYIxu4qYbOnDmzqcVcRgEKUIACFKAABShAgU4hUIxMuBeT0+Xd/VmyGYEXa9F8uxPR3fhNGFP6ImSa65ApHa14ursh46+v3L4pWd7YlyEfIAj1AQJBAWioH6ZDmCotje6GoO8HI/rIcegmnYUCFGieQN8AP/lKcmUDPmvHYxM78Pg+AqMr8Pjn1UNER/kdi6DqpQieRuFR62vphwxaW+WF5ANSiernYL2mgr/W7WiXzddiP3PRjrkIHNsKAOuN3HPRc4CW27BeU8Ff6z4mod53OIbVGMd4XkqGTO8Za13ERwpQgAIUoAAFKEABClCAAhRoJYEj+4JqpZ1wsxSgAAUoQAEKUIACFHA2gdXoNrX/4nVy/9YUI/jrjwPsiakbJh1n8+ecfLl07U6ZiHEyM0trun7F7A5VdMzrVwb3lBUnDpLL4iKMLp51lNIsTBr8HRUSIM8O6C5bxg9j8LdDnTk2pjMKnB2loV1Bt8jarXql3IBpsSX4G4X5vTFp/q3efPEZ5l+B5fMx/Y7nHriH5PSuNetjcaPli4O6tsjZCLqaLaciCKx5/csOFYj2ZNBU+T2vUNJxPYtGJfT11VTVI5adjX1osbbviIV8QQEKUIACFKAABShAAQpQgAIOF7ArA7i4uFgOHz5sNCIsLEx8fHxa1CDtJvrRRx81tnHuueeKTiwUoAAFKEABClCAAhTo6AIrDuXLyQjsllRVSxIaqxl0IxHg8LAEOYoRsPkR0zxk1f2CQPCJv22U38YMknBvrw55aCNDAuXtYRp+QvCpvEIKkakX5eMlGiBmoQAFHCNwUniwHBcaKMtx88h/cX3QP8YvwjXjPFw/6o6huwfLNDN4kXENqcn+vbFblHTxbvrPdx2bdz+6oderTGNjejd0JL5oQw8s2IZpd1Fpk9epnYUlxib6W651DW2voXnW+jss6zdUh/MoQAEKUIACFKAABShAAQpQwHECdn2jM3/+fKOLZ+3m+fvvv2+0FVu2bJGlS5caU6OVsCA7O1vefvttY/rjjz+aqsplFKAABShAAQpQgAIU6BAChxEgvWDNdiP4OxlBkFcQ9j0WARxr8Fcb6Yf5Op7uPzFXA8S7EFS5at2uDtF+W43Q8Tnj/XwY/LUFxeUUaIbAWHQNr0V7DJiL68MNmOoGf3WZjs37AObPwDXE2nn8qZEhuqjJkl9Z02m7duFub/G37CkfN380VazLtf32FO1aXot1/ZpX/EkBClCAAhSgAAUoQAEKUIACrSXQ9C3Ezdzr/fffLwsXLjTW1jGCWChAAQpQgAIUoAAFHC+Qha46v888LMnFpVJWVSWxGKf1pC7B0jewOV//O759zrrFZzD+5QF0gToIB3h3vcBv/WMOQ1BlNgI516Ab128yc3G+cmVSZGj9ai7zendRiSzOyjOyFLVL2+4INJ8SESLReO+yUMDZBfTmkTcxBq4WDe4Oqg3vNnzkp6JOGha9jWzgJ3amypRo7SC68RKOmzf0c5WHP8FLkD2smb1mSwbqa9HM/6ZKlE/NZ7XmKJqqeeQya/1oy/pHLuUrClCAAhSgAAUoQAEKiTqGqwAAQABJREFUUIACFHC0QKsEgB3dSG6PAhSgAAUoQAEKUOBPgT0Ioj2AcWc/Ts+2fGX/5zJ9NhLjts7plyATEFhjcayA3tz4b0sAZxoCu3WzfhvbUziCMBcjkPNPBHHmpWS6ZAB4ObrMvm/LPlmKx4bKORgbdTbes/1480JDPJznJAL/w/i8h8orZSiO50RcE8yUS3H9+AwVfz9cKOsx/u6QYGsu7dFru7m5ybHoYlrH8l2J3w4nmQwAp6JuKjYX4ukhfQOavoFIxwXXsh7raFf32tuBmbICdbUcGxZopjrrUIACFKAABShAAQpQgAIUoEALBcz91dnCnXB1ClCAAhSgAAUoQAHHCHyTkSsjf9kgHyH4q3fyHYcv3y/DdBWCCZPwGIx5axAomLRiizy2fb9jdsqt1ApsLSiWdGT/dsWcASYDH7ryREvdH7MP127LVZ48h4zpk37bZAR/NXSkFldhuhzTGEw+mPcZAmOj8L7+D97XLBRwVoEfsmo+/xNMBn/VwdvyOdHn1vX1eWPlLzHhxqL3cMNJpSXo2lhd6/z5qKvlPGQYe7o3HdDVbP1x6GmiFPUXmNy+Boo/suzD2j5jh/xBAQpQgAIUoAAFKEABClCAAq0mwAzgVqPlhilAAQpQgAIUoIBjBTSL8vzV26QMWaia2fV/CCLUHzuyDF+065fy/8aX7Y/t2C++6A/0nl5xjm2IC28tpaTMOPoE+NtTolFfO1bNKquQ0soq8fFwjfsw39x3UO7esteg0kzGy/GerZ8xmIv362t4v36Lbswv/X2HhBzr4ZJZ0va8n1i3cwqk1l4/7Gt/zfWm2ug63daa1ydEyT9w08V27OtlfK5uQz8FTZUvUec7fAa9kT38YB9zvyse69tNxi3bJO9i3QHYuI6B3lipwLafQL0cVBiN7OSzkO3PQgEKUIACFKAABShAAQpQgAKtL9D4X2qtv2/ugQIUoAAFKEABClDApICO8Xv52p1G8PdcBNJm4kv9+sFf3ZRmi12BL+NnYtIQpXYVvSGvyOReWM2WgDXsW9OZqa3aRy63roM4i0uUZHRVfuvGZONY78X78Xq8Z+sHf3VhKN6p92GZZgRrHuKV63ZKQUWlsR5/UMCZBKwffeu1wOyxWeu7GVf1ptfyxc0l7w3vI1640PwXwdeHkQdsHd+37poFWPYylj1jfOpEXh7cQxL9fetWafT5mC5BMqN3HNYWuR/rv49Jbz6qX/Zg3nTU+hWPYV4eMn9Y7/pV+JoCFKAABShAAQpQgAIUoAAFWkmAGcCtBMvNUoACFKAABShAAUcK/BtjxyYXl0pPbFQzf20VHV/yAnzp/h9Mmgn88cgkW6s45fJCBBI/OZAjX2Uckj1FpVKM7NtYdGE6JixIpsaGS5KdY85289MOi0X2wtWeomNsVmCFrt5e4u1u+/zZs+2OWveJnalSjmz10xC0mmziPftX1FmHYNFGZEm/nHxA7kWAiYUCziQQj2uPlr2YRhjPzP2wXm+6+dWsb2utExCgXTiqr1yCjPpfcA38DZ+rofgc9sCK+gXAfkxrcE0qwSM6iZDnBiTKNd20Y3vz5bGkeKnE5/vpXWnG+OYfYtVjsI9oPOp2t2H7my2bi8Nx//eYvtIrwFyA2bIaHyhAAQpQgAIUoAAFKEABClCgBQKu8e1TC4C4KgUoQAEKUIACFOgIAh9bxka9BEEyDxNZYNrmS1FX/7OnwU8NhLpa+SA1S5J+Wid//WMXxpbNMcZG3owxfBdhHM6ZCIoPWvKH3LB+l13Zpv0QMNYgThYw19sRBP7RUveUyBCXOA0VVdXyX5hr0W6fzRTNbtTsdS3W97uZ9ViHAp1FYFJkqNHUHyxZt2baXYJrh2bQajklwvz14zTs684eMUYmsF79f8c2PsGkQwTo9jRIqxnJF8dGyHUJ9gV/sZq4IcN4dr8E+XZ0fzkmJEDyMe8nbPcDTJp5rMFfX4wnfGtitPw+drCMQB0WClCAAhSgAAUoQAEKUIACFGg7AWYAt50190QBClCAAhSgAAWaLbAqt8BY91iTwV+tHIa6vfG4HcG4DflFchyyXl2lPLh1n8xBZpqW/phOR2AxCR6aP5eO4IQGQHTcy38hs3pVbqF8hyBGpI+O0mu7/BWZcppV/Sqy6l5EON7Txjk5iP0ssAR8rrUzy852azpmjV3o/jkXNx3EoHnxNnzqHsFw1NURS9eh2/JydHvu5SLZ0nUN+Nx5Bc7B+LcR3p6yCVnuP+GaMMHEzRHvoN5hkOj4uQOD/E3hVCMz9/r1u+Xf+zON+kPwsxc+W/rHv4aSdTqAn7/h8T3cKLMPvUt8MaqfBHg2PV4wqh9VTkZQ+uQTB8uuwhL5DePUp5eWib+7h/QM8JEJ4SHi5yLjnR8FwxkUoAAFKEABClCAAhSgAAXaWYAB4HY+Adw9BShAAQpQgAIUsCVQgm6LCzBpeDLYjmCablfHCd6OL/oPlpbb2o3TLH9rX4YR/NX/6N6BAMuZ9YIsPWByApZdDJeHEMTV4PhFa7bLD8cPQHeomhPXdJneM0bmpWTI1pIymY3gzH3Yvo693FDJxD5mYB+FWHgugj/jwoMbquZ086zvt0g7j8wLjpojmY0pE0Ey7a6bhQLOIhCIAOvjfbvJtA175GlcOzSfd0S961PdY/0Mdd7HNUTz4v/ev3vdRU0+n7Uj1Qj++qHWDKw9tpF9aDfNeg38JSdfrkFPCR+1YKgA7d6ZXTw3eVq4kAIUoAAFKEABClCAAhSgQJsKMADcptzcGQUoQAEKUIACFLBfwBcZVF4ITOp4qmX4wr6xYGNDW67JGxYJ8bI/s6uh7XX0edll5fK3LXuNZt6DoMekRgIfWqEbgo3/QL7pTQiALEXmmgZ1r0uIsnmIGsT5FONZTli2SX5CYH4P1r8G+zkO27Oem8M4T4swzUcAJw9b7I+uo98a2svmtp2lgvX9poFve4t1nZBmZCPauy/Wp0BbC1yPa8xK9OgwD70P3IPrw9m4TpyP64dej7RU499WPL6PZUvxXMvcgYmi4/qaKZqJq+Nva9D4Mfw8xnjW8Jp9sc+5lmvgpxgr/cuDh+RM3KjCQgEKHCmQ8ODRY9Lvm5V6ZCW8qluvoeVHrcAZFKAABShAAQpQgAIUaEUBBoBbEZebpgAFKEABClCAAo4SSEJ21SaMX6vjKg4zudFyBA80+1dLnwDNBXP+8iayf/PQ9fBoBDaaCv5aJbqg3i0IkDyKYMszu9JNBYB13eEYz3LpmEFy4ertshPdHT+C9TVDWzNeNddaxwiukRc5DeP+vju8D4LwrvNf757+vuKJmxaScdNCASQCLcEtsDRZdqGujk0ai+64m9MdbZMb50IKdBCBNwb3xHvcW55EoHYh3vMLcROJZgNr/wA6crb1JogA3PzzyqAeclm8XlnMlReS06UCn7sz8JlrKvhr3Voc6ukNLC/qNXB3GgPAVhg+UqCOQFPBXAZ960DxKQUoQAEKUIACFKBAhxLQG4NZKEABClCAAhSgAAU6uMBZlqws7RLUbPkegYViVB6BYGWci3Sl+zky2LRMMRlw1LpjUVdz3jSQuxVBdrNlEMbjXD9uiDyP7LxRMNbAr446rKNuerm7yemRobIQmcJfHttfwlwo+Kt+QcjeHRcehLCWyJd4H5ot/7O8v63vd7PrsR4FOpOAG26OmNm3m/xx0hC5CsHdcFwfdJzfFEwa/O3u5yPa1fz2CcPsCv6qwZ/XQPN/6p+Oa6DewPIruoI+VF6hm2GhAAUoQAEKUIACFKAABShAgU4u0Ow0hH/+85+yaNGiBg9/w4YNtfPvuOOO2uf1n2RkZNSfxdcUoAAFKEABClCAAg0I3JIYLS/sOSA/VVXJRATJTmyiW09d/SCCbm9Ygml3I5DgKmU7uj/VMsCOALA76vbH9BvMthcWSz9012y2eLu7i54bnYoqKyW9pFy8EfyNRgarF5a5crm7Z6z8kJVndIN9PHwTbJyTtXi/foVz4IGecO/o4TrvWVd+j7j6sffHTSTaNXw1MnZ1zGsNvnbFtaO5N4yUokv6fcVlRjC3jx24fvhs9kD97Zi0C+ljQgPtWJtVKeA6AnWzfa1HXTc7uO7yuvOtdflIAQpQgAIUoAAFKECBthRodgD4s88+M9XO559/3lQ9VqIABShAAQpQgAIUaFwgFhm8s/p1k7s275XHESi7G1Ub6+JYu9F9CLmXmlE2GVmoF8WEN75hJ1ui3T9rCbDzuKz188pr1rdzdaO6v4eH9ApwjbGWzfhMwntvamy4LEjLlul4Pz6GsUYbC8wvxXt6NibVf6BXnCTZEYQ30xbWoUBHFtCMYA386tSSko+bULToLSxuNm64MCrW+VHTTXu1HLZcQ+ss4lMKUMAiYCuoa2s5ISlAAQpQgAIUoAAFKNCWAs0OALdlI7kvClCAAhSgAAUoQAGR25EVuaeoVF5KPmAEyxYiYNYHX/J7A8faMbRm/v5meX0ssrjeG95bNLjgKqWrt6eklZYbY/BG23HQ2m2zlpYGYGq2wp9WgTeH9JIMnI+fsvMw1nKljMP7dTymeEwaqkrG+1W7Kl+DScsVcRHyaFK88Zw/KNARBLbkF8mK3AI5gPdxIG7y6I3x2MeHB4svxuftaKULupLWDPp8fJzK8JnyxufMbMm0fAajWhiENrs/1qMABShAAQpQgAIUoAAFKECB1hWwKwA8evRomTNnTqu06MQTT2yV7XKjFKAABShAAQpQwJkEnsN4swl+3vLQthTZXFUtmy1f2tc/xguiu8jbw3p3yCBF/bY68rUGvRdiHOCVcDnHZPCjEHU3YdJwjo6XzOI4AT8Eyb7GGMiPbE+R5/akyxK8Z5c08J4NwZjBGvi9lV0/Ow6fW2qRwBe4juh1dgMCwPWLP97X07pHyYzecRLagcb3dsfNPiNDAmUlAtar8DkbY/IaeAB1dfxhHbs7CQFuFgpQgAIUoAAFKEABClCAAhTo/AJ2BYCHDRsmOrFQgAIUoAAFKEABCrSPwOLswzJnZ5qUIpCmAcsh+IK/Fx41CzgV02p8ka/hik8P5MgxyBT+W69YvHKdchG6HNYA8ALkRE+GjZkMOK1bDqJTIkIkwrtlXbC6jrT5I/XEmMhP9EuQmzFO8oK0LFmMbOD9GKdU5yega3PtKvovOG/NHffUfEtYkwK2BSoxHu8dm5Ll1b0Hjcqh+HkMriVd8ViMaQuusVsx1u6zu9Plk/Qc+d+ovjIQY/l2lHJRTBcjAPwermsnoN1muoJ+x9KHxJSoMIxh3vEymzuKLdtBAQpQgAIUoAAFKEABClCgMwnYFQDuTAfGtlKAAhSgAAUoQAFnE/j9cKGctXKrlCD4exy+1r8NIeAYPNYtxQhOvI8v89/D44yt+8QHQbbbXCirUsc7nr0jVTYVFMuzcLgXRu71jOp6rUKd92GlhV0P15Vx/PM4BHun94w1JsdvnVukgGME7rQEf/Wmmhtw9ZiC64dnvWvITlwznkUn5luLS+XU5VtkxYmDJN7PxzENaOFWbkRm8j8QnN6CLqvfwPXtRoy93VT5HnW+wvF4Inv4oT7sfr0pKy6jAAUoQAEKUIACFKAABSjQmQR4e29nOltsKwUoQAEKUIACLitQgaDvpb/vMIK/ZyAYMbuB4K/i+GHZtfjC/0Es13L35r2iY1i6StEuUN8d3kcC0EXrdwhq3I/ghnZvWr+UY55m/s7ApGPR3o+uXI8LC6pfja8pQAEXEvg645C8gsxfDf4+g+voBbiO1g/+KgdGVpfnsVwzgw+Wlcu163d1GCV/jFP8DsZ+14Duh7jOPYErXE4D10C9WegtLJuNa6CW5wZ2l17s/rnDnEc2hAIUoAAFKEABClCAAhSgQEsFmAHcUkGuTwEKUIACFKAABdpAYP7+TNlZVCIJ2NedCErY6tZzIupswBf8CzHN3LFfPhyR1Aat7Bi7GBzsL18c208uXL1dVpRXyKUIcnRB0zQkrqEOfczHVIJJy109Y2Qmxp9loQAFXFvgYYz5q+V6XCUG4yrbVNHu5R9CvctxffkhK0+WoGvzceHBTa3SZsvGh4fIghF95Mp1O2URuqv+GW0cifb2RAs0H3g/phX43VCIRz3KOeii/abu0XjGQgEKNCSQ8GBcQ7ObnLdvlg7MwUIBClCAAhSgAAUoQIH2E6hJDWm//XPPFKAABShAAQpQgAImBD5KzzZqXYaAQ0MZaQ1t4nLU1S/3v8CYuEWVmufqOmVsl2CZjaCGZgJr/q/qZdZ51OCv2pyDMS8fTeombsiWY6EABVxXYGdhiazNKxLtB0C7fTZTglHvPEvdj9JqrtFm1muLOlOiu8jqsYPlfDzqGOfLcCXUoQHmY/oRkwZ/x6DXgyXHD5S7XGys+Lbw5z4oQAEKUIACFKAABShAAQq0twAzgNv7DHD/FKAABShAAQpQwITAitwCo9Zok4EJrRyOur3xuAPdR29AYGO0C3VxPBtZzw9v1zw3kV6YJiMY3gceOkpnOoIfv2L6CdNnCI6PX7ZJvhndX8K8+F9j9WKhgCsKrLRcYzVT1suO6+xoXFvmI8N2Za72K9CxSp8AP/loZJJkYDzgRVmHZS/GLNbhBHQ87vERwdLT37djNZitoQAFKEABClCAAhSgAAUoQAGHCfBbLodRckMUoAAFKEABClCgdQRK0IVnfkUlghIiIXYEJrQ1XVF/BwKdBxAAcJXyLrrL1uCvdnV6M4IzmqFXt8vsfng1AcsuhctDCNysOVwoU9dsN4LAOoYwCwUo4HoCB0rLjIOOtPPQrfUPduBrbFcfL7k0LsLOI2N1ClCAAhSgAAUoQAEKUIACFOjMAuwCujOfPbadAhSgAAUoQAGXEPBxR0YaApMawi1H0NKeot18agn21HCo85dcjPl75+Zk40B1rOTzMdUN/tYV6IklzyNMrOMD/4jxO99B4JiFAq4koDeX7ENWqH5uOmupqq6WgwjeppeUSSWeN7dYr5FFdm6g2FI/yEWusXbysDoFKEABClCAAhSgAAUoQAEKtJMAM4DbCZ67pQAFKEABClCAAmYFdHza3gG+sqWgWLZipcEmV6xAsFizf7X0wfquUN7clyGHyitFu3E9E8FfWyUC9W5BvcelSp7elSZXdetqaxUup0CnFshDsPel5APycXqObMj/M9wZ6e0pZ2FM7Dt7xMiAIP8Of4z/O5Ajb6VkyA/o2rgU3Rpr8cS1cnx4sFwdHylTY9EJvh0Z/XqN1bLZzptsrPWT0N0yCwUoQAEKUIACFKAABShAAQpQoKMI2P5WrKO0lO2gAAUoQAEKUIACLixwZtdQ4+g/Q6DSbPkRgQzNAB4a7C/xfjr6rfOXzzGmr5ZzEdg1W8ajbggqbysske0IsrNQwFkFvs3MlaTF64wu0jX4q93K6y0PAZgyyypkXkqmDPt5vczYuk80s7Yjlkx0tTxp+Wa5AN22f5WRawR/w9BQzeTXDGAd6/bydTvlhF83Sgqym82WE8OCJRRZvHuwwiY7gsDWa/KZUTXXaLP7Yz0KUIACFKAABShAAQpQgAIUoEBrCjAA3Jq63DYFKEABClCAAhRwkMAtidGiXUEvQmBihYkgcBbqvW6pNx0Zfa5StloCuIPtCABrJ9EDLPU1CMxCAWcU+E96tpy9cqtkIdA7FAf4d2S+f40u0BeIp3yB6W08Px+fA7114u/Ihr8CQdTqDhYE1uCvBnZ/QpftGvS9DcewEO3+FO3/BNNneH435mlQexXG9j5u6UbZW2QuCOyJ6+utPaKxpsg/MDZ4sYkg8H9xjd2C+tEcY9dw4w8KUIACFKAABShAAQpQgAIU6DgCDAB3nHPBllCAAhSgAAUoQIFGBbohg/fhPvHG8pkIOvzcRBB4HwIX0xHAyEHtiegO9dK4iEa362wLcitqxjINtPPArPUPd+KxUO08ZFZ3IQG9MeKadbuMq8aVCPE+h2DpMQiUelhufFCKBDy/FXPmYtLPw4K0bPnH7vQOpXTx7ztkD7J6+6JVb6Gd5+EYQuocQyCea9fvumwYnh8sK0em8DbTYwPf1TNW+gX6yW5s/x7jGtp4FvSn0HzJch1+bmCi+Hu4xjjrHeoNwcZQgAIUoAAFKEABClCAAhSgQKMCDAA3SsMFFKAABShAAQpQoGMJ3Ns7Tq7FGLXaSfEjCDz8DQGKRXjcg4BvKqaVeP4s5l2LKQV1tOvnD0ck2TUOZnsc8Tpk6r27P1OeQ7DpHTyuxevmlq7e2qmtSJadG8i21I9EJh8LBZxN4H506VxcVSWnISh6DYKjTRXNnn8QQVQts3buR8ZweVPV22zZp8hgXpJTk/n7JI4hDO1srGggeBaOIRYV1uUVoWvrjMaqHjE/EF1ALzymr3Tz9ZaNWHI5rqWvYlqHa2sarrG7MH2B59OkQl7Eo3bIP7tfN7kwJvyI7fAFBShAAQpQgAIUoAAFKEABClCgvQU827sB3D8FKEABClCAAhSggHmB14f0lCEI7D68LUVWV1TKagQk6hcN3WigeO7A7h02K03HF52PYO+sHamS3MA4nd2R8fwAAt5Xd4sUd7fGAz31j/2YkED5POOQrILLWU0EiOqup129bsSkexkerKOhslDAeQQOlpbJZxgb2xuHdJMlsGvr6Eaj3mh8JlZUVBmZwNoFfXuXtyxB3CvRtqaCv9Z2BuATfS3qPo4w7Zv7MuS6hCjroiYfewf4yooTB8tNG3Ybbh/BQaf6JRY3i8xF5u8FDP7Wp+FrClCAAhSgAAUoQAEKUIACFOgAAgwAd4CTwCZQgAIUoAAFKEABewQ0GHNJbIR8kJYl32bmSjLGuCxFdl8cstbGdgmWS9Dls3Zj2lFLHrpZvmztTvkabdeiHVRrd62heNQ5fyDYshdB4RsQgPnkQLa8P7yPhHiZ+2/rhTFdjADwAgR9JmObnkZYFxttovwH+yvD8vHoLrsrM4CbkOKizijwQ1ae0exjjM+Y+ZspTkb9FfhsLMo8LO0dAK6oqpYfcRza+okmPtPW83Qi6vrixWr0KnAI150wk9cRvQ58ikzgVbkFRgB8RW6+HMD4w4Ho5rkPAsRndg2Vv+Aa7OfBDrWs1nykAAUoQAEKUIACFKAABShAgY4lYO6btI7VZraGAhSgAAUoQAEKuLxAF29PIyjT3oEZe0+EBnIuWLNdfsrOw9idIrchQ28CgjT6z1qqEXRagukFBHG/RfDpvNXb5NvR/cXL3Xaw5WIEv2fvTJVthSUY57RK7sL2627bug/r4zrsZz7qaXkkqWaMZesyPlLAGQT2WTLsE+08mB6Wz6TejNHeRcfyLUevAXqzSHCda4WtdnmjrnYDrWP6puA4zAaArdsdFRooOrFQgAIUoAAFKEABClCAAhSgAAU6mwADwJ3tjLG9FKAABShAAQpQoBMLPL0r1Qj+6oiZL2Ecz+gGgjkasB2PqT+m/8P4mz/n5MucnWnykIkArQe6i54/vLeM+22TfIlgcx6Cuxpkjqi3n0oEfj/H9CqWV6At03vGGNnTnZiWTadAgwKVCJxqsX37xJGrW+tX4XPS3sV6DH/eJmK+RdZ1Ktv/MMw3mjUp0EYCCQ/Gteqe9s1KbdXtWzfe2sdh3Y89j81pU1t52XMcrEsBClCAAhSgAAUo0HkFGADuvOeOLacABShAAQpQgAKdSkC7fv777jSjzQ82Evyte0BRCNo+jHq3IQj8DNa7tUe0hJrownUkxgFeOKqfTEWm8S8YJ3kF1h+FbfXB5IMdpCGgtRxTpmVnN3ePkjn9Eurums8p4DQC8egaXkuKnUeUYgn8xvvqp6Z9Swy6ZNaAdA6mIrTLv94NHY21Tm/0SLcstDo0VpfzKUABClCAAhSgAAUoQAEKUIACziRgvbHbmY6Jx0IBClCAAhSgAAUo0AEFdMzf/IoqGYrgjY75a6YMRr0RmAorq+TLg4fMrGLUOSUiRNaMHSwXxYRLOeb8ikDQv5Ht+zomzfzV4G8SxvL8eGSSvDCoh7gjc5iFAs4oMD5cO1sXWYX3fSEms2Wxpe4EjI3d3kW7f9fxzSvRkF/sOIaVqFuEdQYF+Ukkx/du79PI/VOAAhSgAAUoQAEKUIACFKBAGwowA7gNsbkrClCAAhSgAAUo4MoCyw4VGId/vMngr9XqONT/HYGcZbkFcll8pHW2zcdEf1/5YEQfea60uzGW8O6iEilGIDkWGZFjwoLkGI7tadOQFTq/QHd/HxmPIO5ijLut411PQ1a9rbIZnzcNAPu4u8nUWO2wvf3LVd0iZUlOnryNYxiLa4KtLOAytP8t1NVylR3XjfY/UraAAhSgAAUoQAEKUIACFKAABSjQcgEGgFtuyC1QgAIUoAAFKEABCpgQOFBaZtTqaqJu3SpRlhcHSzWX1/4S5eMtVzIAZD8c13AaAe3ifMxvG+UjjAccj6Do2U2MCLwXgdOHjVxbkTt6xEi8X/t3Aa0n4vK4CHlhT7qsyyuSR3EMM3EMfo3cTKLB39moswvr9UQA/Obu0U5zLnkgFKAABShAAQpQgAIUoAAFKEABMwLsAtqMEutQgAIUoAAFKEABCrRYINCjJvOw2M4tWesHePC/rnbSsToFDAHNdn9uQKLx/B8IjD6OAG8ygqR1Sx5ef4Bl07AsGwsmImt4ZlK3ulWa9bysqkoycfNGFYLPLSnaTbt22R7h7Wl0Z30j2vkL2ltR5zh0zN+VmHczli3B80BcMz49pq/4tPDaUY22Z5WVSwl6EGChAAXaTuBQeYUUVGjn7ywUoAAFKEABClCAAhSggL0CzAC2V4z1KUABClCAAhSgAAWaJdAbY+5q2YrAzBl2bEHra7Gub8eqrEoBClgEpiVGS4Cnh0zbsFt+rKqWHxEk1Q7VddJxclMwWcMslyLb9o3BPcUTXUA3p+xBd+vP7zkgn2Pc7r3FpcYmPLCp4cEBxrjcN3WPMtpi77Z7oFv3X08YJOet3iabC4qRqVyFrqBF4jBpS1MxFWLS0gOZv5+O7Ivxf7WG/aUUwd43UzJkQVqWrMwtlApLADsOXcif2TVUboVn/2Zu2/7WcA0KuIaA3myxIC1b3knNlCXotr4E1yotXbw85bTIELkR144TMR44CwUoQAEKUIACFKAABShgW4BpFLaNWIMCFKAABShAAQpQwAECZ3YNM7aiY4sWWIK6tjZbiHo/Wupa17e1DpdTgAINC2hX6NvGD5MbEroambSZqLYZUzImzbDVAMt3o/vL/GG9xbeZWbOzd+yXAYv/kJeSDxjBX73jWMM1GsdZfbhQ7t26T/ouXic/ZB3GXPtLL9xIsmbsYHlhYKIMDfY3gtc7sJntmDT42z/QT55Cl9cbThoqg7G8OWXFoXwZsOQPuX1TsvyGscs1+KvH4IUptaRM3tiXIUN/Xi/3bdnb4szm5rSP61DAGQX0xpHRv26Uy9ftlG8zDxvBXze9bwwfvBxkAn+AwPD4ZZvlsrU7pJBZwc74FuAxUYACFKAABShAAQo4WIAZwA4G5eYoQAEKUIACFKAABRoW0GCMdiv7I7J6Xkbm3r1S0yV0w7Vr5r6Cenl4Og4ZP8NDApqqymUUoIAJAR3T9xVk9740qIckIztXx9YORmZwIuZrhnBLyk3ILn4TwVHNxj0dP6dgnN4kPHfDPx2XdzWm9/CZ3ox9nrFyi3wwvI+cHxNu9y693N3lZmTg6qTdS6cgKKtdTMcjOzcaU0uKBqbPWbVVShGx7oUNXYFjOBbtt443vAvH8AWO4XM8PrM7XfYUlcqHI/qIGwLoLBSgQPMEtiOjf+xvmyQbgV63EBHfE93Eqx9uTPGr+VxVHqqW8g0ipctrMoR3FpbIT8cPEH/L0BLN2yvXogAFKEABClCAAhSggHMLMAPYuc8vj44CFKAABShAAQp0KIF/IGvPH5mF3yB48jw6nK07fmfdhupYni9h+Vd49EOwZ+7A7nUX8zkFKNBCAc347YkulY8PC5KB6Mq4pcHf1/ceNIK/mrA3B0HTe3CDR18j9FsTwPHG8xMw/yXMvxTPK5ERfNW6XbINgZ+WlEgfLxmBm0N0nOOWBn81u3fqmu1G8PcctPF1tHUc2mwN/mo7e2H+7Zg/F1MQXn9yIEee3KmdT7NQgALNEdCxtc9Ft+4a/PXEXRfBN7iJz3C32uCvbtMjzE18T3KTwOswH52JrEFvAjeu392c3XEdClCAAhSgAAUoQAEKuIwAA8Auc6p5oBSgAAUoQAEKUKD9BXQ8zneH9xYfjC26EMHdqxDk/QTZdLvxPAfTHkz/xeurjfnV4o0g1XzUH4KxQ1laV0AzKLXr2w9Ss+Sf+w4a47dmILuShQK2BA4jcPPQthSj2r1Gxmzjf2ZqNvD1CJ6ehsfiqiqZgS6hO0p5BMeQi65lj0fb7sBxeOCxsTIYyx5BHS1P7kyTdASPWShAAfsFXkZ38duR0euOAckDLsQVwqfxz51HFzcJuAR10C20dgm9DL+zWChAAQpQgAIUoAAFKECBhgXYBXTDLpxLAQpQgAIUoAAFKNBKAudEdUHXjQPl2j92yRZk/72EgG9DpR/G8nxzSE85DhmKLK0nUFRZKXPRle2L+BI+q6ziiB3p1/AnR4TIY327ybHIsGShQEMCn6TnGGN0DkVQdLwlKNpQvbrzbkK9xbjR47ODh4zgaUwLu26uu+3mPC9A4Pd93PygId1b8VMD1bbKSNQ7CTet/IxA9rtY92+9Ym2twuUUoEA9gddxw5EWv1M0sGv7c6dBYO/R1VK6VOQN9DygvRiwUIACFKAABShAAQpQgAJHCzAAfLQJ51CAAhSgAAUoQAEKtLKABhPXnTRE/ovuUz9F8GhjfpERfAz39hTNEj4/ugvGBu0iHhxXs1XPhI6jqF1vbrV0wxuPvWm3vX54PIBpPYJbizAmqk6PIwg8o3dcq7aHG++cAt9l5RoNn2QiaGo9wlDUHYVpKd5j3+P9dWU80v/asSzG2ORlyIIfgjbE2HEcesw/4xi+y8xlALgdzx933TkFduF30G6Mo+2GTj48e5o/Bu/BbggA43OHa4czlYQH+TvWmc4nj4UCFKAABShAAQq0twADwO19Brh/ClCAAhSgAAUo4KICGty9MCbcmFyUoF0PW7usnbhsk6Shm+ceaMkd6PB2SL3AVyECW+8jQ/sDPFq7+GUQuF1PW4fc+V4EcLT0rPf+sdVYjfcgiU+s69uq35rL9xU37xh6WI55r2X91mwjt00BZxOwfu48IkTc7LjhyyMcmcLu1XIQv7/KkIHPQgEKUIACFKAABShAAQocLaA9XLFQgAIUoAAFKEABClCAAi4moF1wa/B3KI775QaCv8oRgOCWjtc60+gSV4wgsI4TzEKBugLlyJzVYu/dxdYxdiss69fdZls/t7bBw84dW4+5vKrGwM7VWZ0CLi1gvXbg14z9xfJtlvWza/8GuAYFKEABClCAAhSgAAWcW4ABYOc+vzw6ClCAAhSgAAUoQAEKHCWwBN3dateZOqrvTHzz7mcjc3MsAsCXWepYM4GP2ihnuKxAvGX83hRkittT9lvqx7Xz+L/a5lhLG/bbcwCoaz2GeD9vO9dkdQpQwPrZr8qxz6IqD9caDFnv5+4u/h7NiR7btz/WpgAFKEABClCAAhSgQGcUYAC4M541tpkCFKAABShAAQpQgAItEPgwLctY+wIEdUNsBH+tu7kEQWAfvPgRweMD6D6ahQJWgXHhwcZTHQvXbClF3RWW+uMt65tdtzXqndQl2PgkrEWb8uw4jiWWuuOwPgsFKGCfQG9/H+NzV4VhxCvSzV8/yrfW7CfQk19p2SfO2hSgAAUoQAEKUIACriTA/y270tnmsVKAAhSgAAUoQAEKUAACv+XUdON8PIK6Zos/vqYfagkWL88tMLsa67mAwF9iI8TH3U00GLrZZPD0A4wtnQeb0aGBkhTo1+5KXX285PSuoaK3NsxD28yUfTjWrzFhNFK5LA6DmLJQgAJ2CWwpKKm9YpT8WC3VJrqDryqulpJfa4LFhysq7dofK1OAAhSgAAUoQAEKUMCVBMx/4+NKKjxWClCAAhSgAAUoQAEKOLFAOsb+1RJt5zFa6x8oZQawnXROXV27cb2jR4xxjI9IpdjqCvoHBFjnWwKnc/ondBibWX27iaebmyxE2xbaCAJnoM79OFb0QivXJnSV/kH+HeY42BAKdBaBA5bfRXovUsUekeLvmg4CV5dWS+HHqFOII8SdF2UYe7uAQeDOcrrZTgpQgAIUoAAFKECBNhZgALiNwbk7ClCAAhSgAAUoQAEKtESgEF92m8mSamofAR41fwaUNFWpgWWllnkcc7EBHBefNTOpm2hXztq5+DQERv+DAGpRbW5fDc4BvH4Wy2ZhmebvacB1bAfqOnlIcIC8NCjRaOzzaOMstLV+MFu7rv4Cy27AslTUHBESIHMH1KxjrMgfFKCAaQF/y+8id02gx6+lslUihe9VS0Xqkd1BVyPQW7a1WvLfrJbKfYj96gD2qKLZ974YB5iFAhSgQF0B/X9yVbHeosVCAQpQgAIUcG0BT9c+fB49BShAAQpQgAIUoAAFOraAZje9se+gfJKeI3/kFUoJvgj3QpbigCA/mRLVRW5OjJIIby+7DqJXgK+kYBzfbfgGPcrSrbOZDWh9LT0xbiMLBeoKeKIL6M9G9ZW//rFL/oP36ssIkr6BCj0wBeI9lon3ToplBc2yfXZAd7kl0ZpTXndL7fv8uoQoI6B044bd8gM+az8g0BuLJunnpBjHsBvPrfnvkyND5b3hvcXPEsRq35Zz7xTofAL6u0hL9WGRgItFiv6LTOBkkYJ56Fo9qFo8umAZenmuysSj5Q4k964I+k5A3f9n7z4A7KjK/o//btveN5veO4EECL1IVUFQESvvXyxYsGMDBUXxVRBUVPRVEQs2fFVEkfKiCEqviaGENBLS+26217u3/J8zdy9sNrvZu2E3e8v3wOTeO3Nm5pzP7J2dnWfOOX+Sphbmy517SAgggEC0vlNtt72kzoe3K7LJhjqJ2DVrvl+huRUqPH2yis6fIX8Bt8H5SUEAAQQQyC0BfvPl1vGmtggggAACCCCAAAIZJHDP7gZ9yAJqu8OvtGJwt8s7rWXDc83t3vT9Ddt1g7VAfN8UuyueYnqDBa4e3NOseyygdUqK67ixXTda3spQQMdXlKa4FtlyScC1DP/j4rn6u/3cXv/SDj1S36wXPYDEgwOlwYDePK5SV86ZpDnFoz/u70DH5sLJNTrFWjNfs3abPXixR9vtIYzt9vPvkgs1HW/jFn925gS9bUK1N49/EEDgwARc9/GLrPv051usv4AOn0o/LnU9bq19X7CAr4vfJIar9zbur7FYzlE+5S1OdBXtZp5j43aTEEAAgbY7Nqj5B8/ZeaTXuODu2ciumLqX13tT6+9fVMVXj1bBseMAQwABBBBAIGcECADnzKGmoggggAACCCCAAAKZJPC7rbVea0oXdjrMpgusf8zFFn4qtClswajlNt1m05ORmD74/Hptt7EUr5g9KaUqvn9Kja5Zt01PWWDrIWupearre3M/yXV7e4O1hHTp49PG0+JqP1Yskt4wttKbGrojeqmtU032czYuP6S51tovL0O6a3UtC29aNFM/PmyGXmzrkBurtMQC2K71+1Bb3PMzgQACAwtcMmO8PmS/wzruj6v0Q/Y77ky/Cs6w7lsbrOVvsz10EbDeoS3O6y9NtPSNbLUA8TKvx2j7fUQgZ2BZliCQGwLNP1+p1ptXeZUNzZXyjvEpONWdO3yKh+Pqtq47up6w7uO3dar+s4+q8mvHqvB1U3IDh1oigAACCOS8AAHgnP8RAAABBBBAAAEEEEAg3QT+09Sqi+2GuAv+fsCCs+/pE6DNsyDwUd4k/cMCuN+x6StrtmihtaR6o7WwHCxVW5fR18ybok+t2Khv2rouDRQEbrFSfM3yrLU8syz4deks1yEuCYHBBSpDQR1trWUzObnuZRfY92oBjd4z+TBS9jQWeK+1uL95y2493tCqtv+Nq/idFtwt93ndP7suoHunyOa42v5svxnt19ZnrBX+IfbdJCGAQO4KdDy4LRH8tecYi95kPQQs3LtLeF+ezZsvheZZ7zkPx9X1iNRw9VIFZ5QpNLs8d+GoOQIIIIBAzgjs/1H/nGGgoggggAACCCCAAAIIpI/ApSs3qdu6eX6rBXn7Bn/7lvJsCw5/pCdA/PmVG9UdSwR0++br+/ljNv7qJ2z8YDeeqQvwXmEtfB+1VzdWa6tN62z6nX2+0OYvs/fjLGh8xzHz5brxJSGAAAIIIDAcAn4bE/y2o+Z5PQREd0ktP42r418xRbZZK+AOm1pdCz4L/P4tptbfxq2LV+k8e9Dp2vlTh2P3bAMBBDJUIB6OWrfPz3ulL3zdvsHf3tXy2Xmm8FS/14W8wjE1/TCxXu88vEcAAQQQQCAbBWgBnI1HlTohgAACCCCAAAIIZKzAChsL8ZH6FpVZDT7Yp+XvQJV6mwWK77aFL7V36b66JhsXcfBWwG5bPzh0hubZWKxfXrPZ60r6SQv09pdOs/FQf334LE22bnFJCCCAAAIIDKfAWOsi/vGTDtNHl6/XbTvqrbvWRJetffeRZy3yL5s5UVfNnSwXOE6mzVdvS7496K9Tr+x/6IX+ytRf3v7yjXQl+ivHSO+T7SMw3AKdj+9UdGe7/GOt2+ejU9t6wRk+da+wbuSX7FZkS6uCUzK7l5LUak0uBBBAAIFcFiAAnMtHn7ojgAACCCCAAAIIpJ3AvbWNXplOtqBukU2ppIDle50Fi2+2Frtu/VQDwG7bH7eWwO+cWK1fbanVPbsbvDFbW6MxTbAb8idUluqCSWP02jF0k5fKcSAPAggggMCBCVRYl/F/XDxXTze26pattXpoT7ONbR9WyOfXdBt+4Kyacr1/8lhNs/cHOyUDpv0Fa3vPS+brXb7+5rnlvdfrnZ/3CCCQmkDXk9ZlgCXX7bNr4ZtK8hfY+MBzrVeB5dYl9JM7VTJldiqrkQcBBBBAAIGMFSAAnLGHjoIjgAACCCCAAAIIZKPARmvF69LsFIO/SYNZPW829ayfnJ/K6xjr3vkyG9vXTSQEEEAAAQRGS+BYGzfcTSQEEEBgfwLRHW3e4oC1AB5KCoyzVsDL44ruaB/KauRFAAEEEEAgIwUIAGfkYaPQCCCAAAIIIIAAAtkqELaxf10a6oV6Mn841n83ztnqRb0QQAABBBAYSYFka92BWvMm953Ml/zsXvub13s57xFA4MAE4t2xxIqBoa1vnQokUqRn/aGtTm4EEEAAAQQySiB5nyijCk1hEUAAAQQQQAABBBDIVoGJ+Xle1bYNMB7vQPVOjoA4oSCx/kD5mI8AAggggAACqQskA7+9g7n9zUt9i+REAIFXKxAYW+htItZgL9NT31q0IfGgpH9MQeorkRMBBBBAAIEMFUg+95ShxafYCCCAAAIIIIAAAghkl8Cp1WVehR6zAHBsCEHgR3vyntazfnapUBsEEEAAAQQQQAABBBICeUfWeG+6V6fe803cesmJvJhYP79nfTwRQAABBBDIZgFaAGfz0aVuCCCAAAIIIIAAAhkncHJVqaYX5mtjR5f+bkHdc1MYC3iphYqXWd6yYEBvGleZcXWmwAgggAACCKSrQO+Wv8ky9jcvucy99tdCODnPLU+u3988t5yEAAL7Fyg4daKaf/CcIi9FFdkUV3Cab/8r2NLwf6RYkxSYUqLQYVWD5icDAggggAACmS5AADjTjyDlRwABBBBAAAEEEMgqgYDPp2/On6L/98w6/dACu5MsAHzEfoLAGyzw+w3L59IVsyepIsQlflb9QFAZBBBAAIGME0gGeHsXPNV5vdfhPQII9C8QqMhXyYXz1PLzlWr7a1wl77HA7piBg8Dd6+PquD/RWrjs44fJZ9fbJAQQQAABBLJdgC6gs/0IUz8EEEAAgbQUiMfjchMJAQSySyA2TN/rd04co49MHaew8VyqqH5pU3NPF89JsQ77/GcL/H7CWyadO7ZCn585IbmYVwQQQAABBBDIAQF37cHfFTlwoKniPgIl75uv/OPGKd4mtfwqrq6n7bvQvfff2LF2C/z+O6a2P9r8qFT8rtkqPG3SPttiBgIIIIAAAtkoQPOAbDyq1AkBBBBAIC0FljS26uYtu3V/XZO2dIQtdBPXpII8nVFdrvdPqdHJVYlxP9Oy8BQKAQQGFLi3tlG3bK3VQ3uatbOrW0G/T9OsC+ezair04aljdWhp0YDr7m/B/xw2XWWhgL7z0nbdYueLP9hdq9m2QpW1BnbB4LX23gWIXbpw0hjdtHCm/LRmSIDwLwIIIIAAAlks8OCeJv1mS60etGuP7V1h+e3aYEphnl5v1x4fnDJWR5YXZ3HtqRoCCQFfwKeq605Q4zeXquO+rer4pwv2Wkvg8XH5CqV4q8V8d1renphwyfvnq/TiBfAhgAACCCCQMwIEgHPmUFNRBBBAAIHREmiLRPXxFzbo99vq9inCZgsE/9oCR246f3yVfrFopsrpvnUfJ2YgkI4COzvDeu+z6/Rvu/maTK4zuXDMgrNtnTbt1E827tTHpo/T9YdMU8g/tM53XDD32vlT9RYb0/fqtdu8h0fWeC2ME3ex3L5eY+MFX27dPrtgMwkBBBBAAAEEhl+g9zi9w7/1oW0x1hRWw9VL1fXkjpdXdNcDUYtwrW/v0k837fKmwjdOU8WlR8qXH3g5H28QyEYBX0FAlV8/ToVnT1Xrb9YovHyPolt71TToU/7x41X6wUOUN7+y1wLeIoAAAgggkP0CBICz/xhTQwQQQACBURRoseDvGU+s0DPN7cq3crzVns4/057Rn2rvXShoi00PWBeut9lNm9t31mtVa4ceOmGBqvNCtoSEAALpKrC5o0unPL5CWy0I7Nruv8u+0afY99t1wGy9y2m9Tffad/tu+27/eOMurWrp0N3HzlfeEIPAthkdV1mqu2zd5u6IVto5ojYcUZU9KDKvpEBjOFc4IhICCCCAQBoKHEjgtL9xctOwaqNSpGh9p+o+8qAFt9rk2ve+0649TrNrD9eZbcymjTbdb+9ut2uPjrs3KbKhRdU/eo38Bdz6MxpSlgsUnDhBboo2dCmyuUXxZmsZX1Wg4PRS+Yv52zrLDz/VQwABBBAYQICrwAFgmI0AAggggMBwCHzguZe84O9k29i1Cmiy3aTpnabbh4ts/rl2o+YKCxuttuDOfy1bq38eT9dUvZ14j0A6CXTHYjp/6Rov+HuYFexq+w6X9/puu7Y2870poHN6vtuulfDnVm7Sjw6bccBVKbOg7/EWDCYhgAACCCCAQG4JuDF+G6540gv+zrWqX2PXHmP6XHvMsflzbL679rjc/q7YuaJeTdcuU+V/H5tbWNQ2pwUClflyEwkBBBBAAAEEEo2PcEAAAQQQQACBERBwY/26Vr3uCf1v282YvsHf3rscazdwXB7XKZULFN22Y0/vxbxHAIE0EvjZ5t16zlr1uxY37sGO3sHfvsWcY9/t6yyPa3dwk3XL+FxzW98sKX9eaw+I/HDDDl26cqO+a+MCP9t04NtKeadkRAABBBBAAIFRF+i4d4vCz++xoK/0Lbuu6B387Vu4aT1/V9gQqDYm6hZ1PbfvMDR91+EzAggggAACCCCAQPYJ0AI4+44pNUIAAQQQSBMBN/anS++27tkm9HpCf6DiVVueiyzv96zrthuty9i3T6geKCvzEUBgFAWS3+2P2fe1JIXv9mzLc55Nrqt3NzbfjQtnDqn0P964Q19bs1UN1qV831Qc8OtTM8br6nmuY3kSAggggAACCGSjQNuf13nV+pBde1SkcO0xxfK44Sl+bX9XtN32kvIPd6FjEgIIIIAAAggggEAuCbjhB0kIIIAAAgggMMwCUeum7b7aJm+rZ6Vwkya5+zMtr3s665H6ZrX2E+xJ5uMVAQRGR2Bje6fWtHV64/4eP4Tv9tl2E9alf+xuTLngYetq+qiHn9enV2zygr+uFfFCm9xYw0fYVGDv26IxXbduu2b8a5nqbWxgEgIIIIAAAghkl0CsqUvdKxvkOrU9fUjXHomhZ7qeSDyUml0q1AYBBBBAAAEEEEBgMAFaAA8mxHIEEEAAAQQOQGBXV7c6LHjj2vBWDeFGTZHlnWjrbLZpS0eXDiktOoC9swoCCIyUwIb2Lm/TM+27GhjCd9uN/OtCwFs7w4rE4gr69x4PvL/yHm7B37UWbHYX7O+1td9m+3PniGQKW4vie2z6ubXu2WLbPeTBZ7XltYuV5+cZz6QRrwgggAACCGS6QGRHu1cF19dHXq/rgMHqNc7yllim1raIYs1h+cvyBluF5QgggAACCCCAAAJZJMDdoSw6mFQFAQQQQCB9BLos+OuSa7E31JS8NdNpQSISAgikl0Bnz3c7+T1NtXR+uwnrzgfuWx2OJ84P+1v348vXe8Ff19rn+xZqfo8FgHsHf9267ibwW2z+jba8wj7v6Y7oTU+vdotICCCAAAIIIJAtAuHEdcNQrz1c9ZPrxMP7DiORLTzUAwEEEEAAAQQQQKB/AVoA9+/CXAQQQAABBF6VwPj8xO2WPbYV10ov1af1Y5Y32UnbxIIDCR+/qmKzMgIIDCIwsSDx3d7hhXIHydxrcb3ld22Hy4IBFQUCvZbs+7YzEtMvN+/2FnzGAryHDdLaZ6otv8ryfdZaAv9rT7NeslbDs4pdB9EkBBBId4FN1qvA3bsbtKq1Qw32EEdNXkiLy4t17tgKVdt7EgIIIOCvSfxO3z5Eig679vAGnrCmH/5KrguGyEd2BPYRiNswT6479q4ndyqy01rmR+IK1BQqb/EY5R89Vr7gq29nFeuMqOupXQo/v0exPZ3y5QcUmFSsghMnKDS7fJ8yMQMBBBBAAIH9CRAA3p8OyxBAAAEEEDhAgcKAX0fbDdylTW162m6+nDxIACe5m+ctb6t9mF1UoHE9QeTkMl4RQGD0BQ4tKVJlKKAt3VFtsu/rtBS/249aXpdOqSodtBI/3rRTrp3OFJtSHUP8CAsAH237WGrTteu26ReHzxp0P2RAAIHRE9hu3bZ/YdUm/XG7e1Rs35Rv3cR/Yvp4XTVnsortwRESAgjkrkBwQrEC4wrVsKtDK+33/IIUrz2esLyu7XDewmr5Aq8MIZG7ktQcgQMX6HqmVk03PKfIi037buR3a+QfW6iyjx2morOn7rs8hTlx6/2r7c/r1HLzasWty/a+qeXGFco7cozKP3u4QnNc3z8kBBBAAAEEBhcgADy4ETkQQAABBBA4IIF3TxrjBYB/bbdejrcbNcFBbta41r+/9G7TSG5dEgIIpJ+AG7v3nRPG6KbNu/QL+75+w7pfHiy5Fji/f/m7XTNYdv2ftQZ0yT044v5LNbn8LgD8SH1zqquQDwEERkHgP02tevPTa7Qr3O11z3qSfXcX2eQeD3HhYPc9XmI3gr+3fofur23S3cfOV7L3gVEoLrtE4IAFNl+97YDXZcW9BQrPmqrW367x/la43h76Guz6wPVA5P4GcanwAANSe5eATwjkrkDrrevU/IPn5L5S7q/0U+0bONMmd1N9q7v2tmnj7g41/vcShZ+tU/kXjpTP/mZINcU7o6r/ylPqenSHt0pgog0lNdcnvzX4jXdL0Z3W8niV9Sz2TJ1qP/SAKq86RoVnTE518+RDAAEEEMhhAQLAOXzwqToCCCCAwMgKXDx1nH64cadesu4dv2N/LX7BbtYE7A/F/lLc/mj8H8vzgi0cZ10+fmbmhP6yMQ8BBNJA4Mo5k3TLtlo9Go3pt/a9fa99twdK7gbs1y2P69D5KOsV4O0TqgbK+vL8XV12p8fSxAHOFy9n7PPG7hV5qcFaJ5MQQCA9BTZ3dOmNNlZ3bTiio+w7/kU7f9T0+a6/04q+zl8ID14AAEAASURBVDt3RPV8S7vOW7JaD5146KDdx6dnjSkVAggMh0DJu+eq/W8btMxaBv7Uris+up8gcMTOH9dZni2248DUEhW9cfpwFIFtIJCTAh33b1Hz9y34a+k99vv6Qvvu9R3e6SL7zt1r0w32vWu/Y4P8pSGVfWJhyl4N1yz1gr++QqnozT5r4dv3noFP8TPj6rg/bkHgmBq++rT8VQXKP4KHxlNGJiMCCCCQowID363KURCqjQACCCCAwHAJ5Fs30LcunqtCv1//tD8IP2uduq6x175pvc37gv2x+Dd7Dfl8+tNRc1RKd499mfiMQNoITLBxgH97xGyvPL+y7+5V9t3e1s93+1mb9wlb9qS9VoWC+sPiOfLZd3ywlNfTYmDfzt/2v2YyvzuPkBBAID0FLnlhgxf8PdZuIn+rn+BvstSzbfmP7bEx177nmeZ2fWvdUEf/TG6JVwQQyAYBf1meKq85zgbz9elWu674kl1/uKEo+ibXRfSn7drjAXv1FQZVde0JwzIuad/98BmBXBCINYXV+K1nvKpeYr+zP2C/l/sGf91C1yL/bFt+nS13fQO13vKiwqsSPfp4K+/nn44Ht6nz/q1SvlTyvv6Cv4mVffk+FZ3rV/7x9jlq43t/w/oLiSRa+e9n8yxCAAEEEMhxAVoA5/gPANVHAAEEEBhZgSOtxd/9xx+it/3nRS23Vn0ftRsyk2yX070/E6XNdnNmc08RXIDoVgv+nlxVNrKFYusIIPCqBc4bX6U/HzVX73t2nR62lsAP23d7lm11kn23Xftd92DHrp69zCzK1x1Hz9NMG9s7lTStMF/LWzq8FoCp5E/mWdfzZlx+KDmLVwQQSCOBZ5vadPfuRhVZmb5kN4oH6hUkWeRSO59cYbncgyTf37BDX5g1kfGAkzi8IpCDAvlHj1XV905Sw5VP6cnWbnvALGp/U0hT7Fzh+v7YaNceyUdF/DWFqvr2CQrN5O+KHPxRocrDJODG5I3bd+0Y+46db7+3B0tHWL4LbPq9fRdbbl6l6u+cONgqavml9e1sqfBMnwJjBn+Is8Dydb8UV3R7mzru3WxB4ene+vyDAAIIIIBAfwKD//bqby3mIYAAAggggEDKAsdVluqFUw/XZXbjdkxe0FoKSo/ZH4WP2uSCv5WhgD41fbxWWJ7Tqm2gHxICCGSEwPkWBF5p39sPTKlRibX4f8lK/bB9r5+wyQV/J1og9r/nTtazpyzSIaUu5JNa+vDUsV5Gd45osymVFLV891trIJfelkI306lskzwIIDC8ArfvrPc2eJbdHC63KZW0wPK5TiTb7UGTe2sbU1mFPAggkMUCBceN09g/vV5Fb7MRSEtCFvSVN/7o43Yd4IK//sp8a0U4X2P/8Drlza/MYgmqhsDIC7jWuS69K8Xf2S7v2y1Q7G62dz21S7GOiJs1YIpsa1VkXZN89oxo3hEDZttrgetNKP+4xDVEx4PJRz72ysIHBBBAAAEEXhagBfDLFLxBAAEEEEBg5AQqrHXvtfOn6pp5U/SsdeW4xcYAdKGaKdaV7BFlxQr2dPk6ciVgywggMBICk6217s8WzdKPDpuhZda6b1tnWHnW7ft0m39YaWFKXT73Lde546pUYd3AN0aiusnOFJ/zOpPrm2vvz3+yG7/WeZzXjfznZyRHA947D58QQGB0BZbbeL4uHTmEG8nJ/MvtO+7Wf+uEam8b/IMAArkrELCxPysuPVLlnzlc3WsaFa3tkC9grQfHFSk42x4v4e+K3P3hoObDJhC3bpYjG5q9YO7hQ/i9XWF5Z1gpXuqOKbq5Vf55FQOWqduCvy4Fplg30kP43ganJTYZWcuDYQkJ/kUAAQQQGEiAAPBAMsxHAAEEEEBgBAT89sTuYusW2k0kBBDIHgEX9D3eWvsPV7px4Qz91zPrdJcFfSqsY8eL7PaTG1+sv3SnBYl/0dP698o5k1QQpJOf/pyYh8BoC9SFXQfxsu90/9/lgcqXyB9XXXj/LYkGWp/5CIyWwNQr3cAnpJES8Nnv+7xDq0Zq82wXgZwWiLeG5S6vS0wheIC/t6NNXdrfwCyxRtuHJf8Qbw0k87sxikkIIIAAAgjsT4C7Q/vTYRkCCCCAAAIIIIAAAqMg8I6JY/TJ6eO8Pf/OgsAfsyDwA3YXqtneu9Rur0/Y50tt/vft1c09p6ZCX54z2VvOPwggkH4CVdYbiEtNPd/jVEuYaB8kJddPdT3yIYAAAggggMCBCfhK8qxZrtRqq7uhVoaSkr/n/WW2jf0kf3lieTzRQch+cu69KJnfN8j2916LTwgggAACuShAC+BcPOrUGQEEEEAAAQQQQCDtBW44dIYmFuTrytWbtcZK+3XXDMGSe4Iz8c776LVJ+Ni0cfqhdUNNQgCB9BU41MYCv3t3o561G8knD6GYLr9LC8tSH0t8CJsnKwIIIIAAAgj0EXDdqgenlSqysUXLbVmKQ/R6D2uud9sK2vpTXPvhgVNoVpm3MLJFisfiKXcDHdmc2GZoZmL9gffAEgQQQACBXBegBXCu/wRQfwQQQAABBBBAAIG0FfjCrIna+bqj9bbxVSq3cYFdSgZ/iwN+vX5MudadfgTB37Q9ghQMgVcEzrfvsUv3WkC3JcXWRGst33M2FdjYgGdZK38SAggggAACCBwcgYJTE93Y3/by1ffg+73dfme7a/X8Y8ZZ18776wDaYsRTShWcUap4hxR2UeYUUjweV9dTiQfDCk6jm/0UyMiCAAII5LQALYBz+vBTeQQQQAABBBBAAIF0F6jKC+pPR819uZidkRjj/L6swRsEMkfg6IoSvc4e2rivrknfttvDX9/P2N6uVq6r929ax5MufXL6eJX2PATizeAfBBBAAAEEEBhRgeJ3zVbbrev0WEdEf7ff22/w+uEZeJcr7ff273uCxaXvnz9wxl5LSt5/iBqvelqd98ctICwFqqzf6f2krkesS+pdlm9coYreMHU/OVmEAAIIIIBAogc5HBBAAAEEEEAAAQQQQCBDBAqCdOKTIYeKYiKwj8CPrKv2ylBAj9pN4ivtJnGjvfaXNtv8Syz4u9EWLigpZHzv/pCYhwACCCCAwAgKBCrzVf75w709XG+/s/9g00DjAT9kyy6zpd2Wu/gds5S3qDqlkhW+brIKTpnotQJu/W1c3Rv7vy6Id8fVcV9MnQ/bcvtToPxLR8mXl+gdKKUdkQkBBBBAICcFaAGck4edSiOAAAIIIIAAAggggAACCBxsgVnFBfrb0fN1/tI1erw7ov9nN4tPt5G8F9lUaoXZY9NSC/4+ZpNr+zvP8t95zDxa/x7sA8X+EEAAAQQQMIGic6cruqdTLTeu0M8syHu3zTvDfmfPtMndVN9q08M2f7W9ulR41hSVXbIo8SGFf30+nyquOkb1lz+h8JLdarvFWgJPjys01yd/uY0NbBHl6I64wivsfatt0MYWrrjiKBUcOy6FrZMFAQQQQCDXBQgA5/pPAPVHAAEEEEAAAQQQQAABBBA4aAInVZXqqZMP0+dXbtKduxp0jwV73dQ7BawHyI9MGadvzp+i8hB/tve24T0CCCCAAAIHU6D0vfMVmlOh5h88r+2bWnSL9zt779/b/op8lX54gYrfOnPIRfMXBVX9/ZPV+rvVNr2oyMaITXtv3200dEiltUg+QnmHVg15H6yAAAIIIJCbAvwlmZvHnVojgAACCCCAAAIIIIAAAgiMksCMogL99eh5WtXS7gWBV7V2qNFaBNfkh3RkWbHOG1+lSQV5o1Q6dosAAggggAACvQUKThivfGt1G15Wq86ndim6s02KxBWoKVTeUTXKP36c/AUHfpvdZ09+ldp4wMVvm6XOx3Yq/HydYnWd8hUEFJhYooKTxitvYWrdSvcuN+8RQAABBHJb4MB/M+W2G7VHAAEEEEAAAQQQQAABBBBA4FUJHFJaJDeREEAAAQQQQCC9BVyQNv+Ysd40UiX1l+ap6Oyp3jRS+2C7CCCAAAK5I2DDxpMQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBLJBgABwNhxF6oAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgiYAAFgfgwQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQACBLBEgAJwlB5JqIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAgSA+RlAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEskSAAHCWHEiqgQACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggAACCBAA5mcAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQyBIBAsBZciCpBgIIIIAAAggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIEAAmJ8BBBBAAAEEEEAAAQQQQAABBBBAAAEEEEAAAQQQQAABBBBAIEsECABnyYGkGggggAACCCCAAAIIIIAAAggggAACCCCAAAIIIIAAAggggEAQAgQQQAABBBBAAAEEEEAAAQQQQAABBBAYHoFoXYc6H9+p6LY2xTsi8lcXKG9htfIOHyNfwDc8O2ErCCCAAAIIIIAAAgjsR4AA8H5whmNRTU2N4vH4cGxqn23U1dXtM48ZCCCAAAIIIIAAAggggAACCCCAAAIHXyCyo03NP3lBnfdv7Xfn/ppClV28QEVvnN7vcmYigAACCCCAAAIIIDBcAgSAh0tygO3U19crFosNsJTZCCCAAAIIIIAAAggggAACCCCAAAKZLtC1rFb1lz+heEu3FJBCs+1lok++kBRriqt7nb3Wdqjxmv+o6+ldqrjyaPnyLCMJAQQQQAABBBBAAIERECAAPAKovTf5yCOP6KKLLtKLL7748uzx48crEOAi/2UQ3iCAAAIIIIAAAggggAACCCCAAAIZKtD9UpPqL33MunuOKjhHKnqDT/6y3l09+1TwWgsCr5Da/x5Xx33WQjjkV+VXjsnQGlNsBBBAAAEEEEAAgXQXIAA8wkfoxBNP1JNPPqmzzz5bTz/9tLe3D3zgA7rmmmtGeM9sHgEEEEAAAQQQQAABBBBAAAEEEEBgJAXcsF8NX1/iBX9DCy34+2Zr9evrHfxN7N3NyzvMWgXXSC2/tiDwPZtVcMpEFZ46aSSLx7YRQAABBBBAAAEEclTAn6P1PqjVrqys1H333adDDjnE2+91112nf//73we1DOwMAQQQQAABBBBIN4GY3TD9y449uvCZtTri4ec05f7/eK/vts+32fyoLSchgAACCCCAAALpLND58HZFXmySr8yCv+f2H/ztXf7AOJ8KX5sIELf8fGXvRbxHAAEEEEAAAQQQQGDYBAgADxvl/jdUVlamX/7yl/L7/d6YwO95z3vU3Ny8/5VYigACCCCAAAIIZKnAksZWHfnw83rXsrX64/Y9eqGlQzu6ur3XP9nnC2y+W/5UQ0uWClAtBBBAAAEEEMgGgc4HtnnVyD/Ogr/BfVv+9lfHvCMlX6EUealZkS1c6/RnxDwEEEAAAQQQQACBVydAF9Cvzm9Ia59wwgn61Kc+pR/84Afavn27fvSjH+lLX/rSkLYxGpnr6ur0+OOPe4HrV7v/xsZGbxOuiyQSAggggAACCOSmwN27Gizw+6K6YnFNMIK3yq8j5FOFvW+y6RnFdbtiWtnaodOfWKk/LJ6j88ZX5SYWtUYAAQQQQACBtBboXp24zxGakXoxfX6fgtNsTODVUveaRgWnlKa+MjkRQAABBBBAAAEEEEhBgABwCkjDmcWN/XvnnXdqw4YN+t73vqdLLrlEJSUlw7mLYd/WxRdfrNtvv31Yt7t169Zh3R4bQwABBBBAAIHMEFjZ0i7XxbML/p5nQd9PWvA3aK/JNMbezLLPb7HpJxYEvt0eGrvwmXV6/KTDtLCsKJmNVwQQQAABBBBAIC0Eog1dXjl8Q7y1k8wfrU+snxaVoRAIIIAAAggggAACWSNAAPggH8ri4mL94Q9/0F133eXt2QWCFy5ceJBLMbTdXXTRRd4Kw9Fq94EHHlBTU5Oqq6uHVghyI4AAAggggEBWCHx25Ua1RWM6ywK8n1FgwDq5oPAltrxLUd0Ti8mtd//xCwbMzwIEEEAAAQQQyB6BaF2HorWd8oX8CowrlL80L20r5y8LKdocVrzTijiEZ9W8/LaKvyx965a26BQMAQQQQAABBBBAYFABAsCDEg1/huOOO05uypT0pje9SW4ajrR48WI988wzKioawl9Fw7FjtoEAAggggAACoy6wvLld/6prlmsg41r+ppI+bvketSDwg3ua9WxTm44oL05lNfIggAACCCCAQIYJxDoiavvjWrX/fbOiW1r3Kn3o0CoVv3WmCs+eKtd9cjql4PQyRbe2KbJZCgxhxIrIlkQtgtPp/jmdjidlQQABBBBAAAEEskUgtTtv2VJb6oEAAggggAACCCAwagL/t7vB2/fp1rq3xKZUUrHlc/ldSq6fynrkQQABBBBAAIHMEQivqNfud96rlp+t9IK/vgILpk6w1rFjrQ7WdKHbljd+Y6nqLn5QrnVwOqWC11hBLYWXxpVqz2ndL1reJqtfTaFC8yrSqTqUBQEEEEAAAQQQQCBLBGgBnCUHkmoggAACCCCAAALpLrCuzfWNKM1PMfibrI/Lf4fiWtuzfnI+rwgggAACCCCQ+QLh5XtU98mHLYIaU2CSVHCaT8Hpks+XeAAs3h1X9yqp40F7tUBw3Ycf1Jibz1CgMj8tKl901lS1/HKVojs71PW4lf+k/Rcr1hZX+z/iXqbS9857uZ77X4ulCCCAAAIIIIAAAggMTYAWwEPzOii5v/3tb+uCCy7wptra2oOyT3aCAAIIIIAAAgiMtEBrNOrtonCIO0oOHOHGDiYhgAACCCCAQPYIxFq7VX/5E17wN+8IqeR9PoVm+PYKivpCPuUt8qn0Qz4vQBzd2a6Gq55OGwRffkAVXzzSItZS5wNxdTwUUzyWCPD2LWS0Nq7W31jr32ZZnapV9JYZfbPwGQEEEEAAAQQQQACBYRGgBfCwMA7vRh555BHdfffd3kavu+461dTUDO8O2BoCCCCAAAIIIJCigBt399H6Fm3vCqvA79eMonydVVOhsfmhFLfwSrbx+Xneh92vzErpXTL/uAPYZ0o7IBMCCGSkwMb2Tt1f16QtHWG5x0MmF+TpjDFlmlM81MdMMrL6FBqBrBBo/d0axeq7FJgqFZ5jgd/9jO/rL/Kp+J1Sy01xhZfsVucTO1Vwwvi0cCg4cYLKLztSTdc/o65HrMvqF+LKOzzRjbXPLn9i1t1z91prwbzSimux4eDcclVed4J8QdplpMUBpBAIIIAAAggggEAWChAAzsKDSpUQQAABBBBAAIFXK3D3rgZdsXqzVrXuO86e65Dx7ROqde38KZpeZIP0pZiOryjRjyzvE3bn810pruOyufwuufVJCCCAgHsw5YurN+lfddaErp90YmWJvnXINJ1QWdrPUmYhgEC6CLjxctvv2eQVp/DM/Qd/k2X2F/uUf6K1tL3f1r17Y9oEgF35is+fqeDUEgsCP6vIxhZ1WpfV+6SABbEtX+knDpO/gFty+/gwAwEEEEAAAQQQQGDYBLjaHDZKNoQAAggggAACCGS+gLsZe+mqTfrBhp1eZcbYv8dZn4YTbQpbIHatfV5qr3/esUf/rG3UHxfP0eusRXAq6Q1jK1QS8Os568r5OdvG4a6vxEHScsu3zKZiW+/ccZWD5GYxAghku8BvtuzWR5dvULedq1z38O78NN0mdzbZYueKJ216vKFVpz6+QtcvmKZLZkzIdhLqh0DGCkQ2tShW1ylfmbWInTT4NUGyonmHuACw1LU02UdIcsnov+YfNVY1t7xOXU/tVOdjOxXd1qZ4R0T+6gLlLaxSwemTFRzvzl4kBBBAAAEEEEAAAQRGVoAA8Mj6snUEEEAAAQQQQCCjBL6yZosX/HUXiR+VX2+xsErAC628Uo06C7D8j3W4+nAkqvOXrtGDJxyqo1NonVseCuqyWRN11YtbdbWi1ho4oHF9tv3KXqTdtp9vWD6XPjdzgiptfRICCOSuwN921uuDz6/3ANy56YN2jirpcw7psPPGLXZ++l97/dzKTSoNBnTRlLG5i0bNEUhjgejuRC8jgeqhFdJfbsHioBtHt1vxzqh8BYGhbWCEc/usla/rEtpNJAQQQAABBBBAAAEERkuAwUZGS579IoAAAggggAACaSbwREOLrntpu4VlpesssPI2m/oGf12Rx1jA5Wu27E322hmL6z3PrlPEXlNJX5w1SadWlanOMn/UgrsPeiN37rvmQzbfLa+1Ra+pKtWXZk/aNxNzEEAgZwTqwxF98LmXvPp+xM4/n7azU9/gr1tYaOelD9uyyyyPS598YYONEdzlvecfBBBILwGfr6fVb2qXEHsXPrkOd7X2duETAggggAACCCCAAAI9Alwq86OAAAIIIIAAAggg4An8t7XMdendFkA5qid44s3o5x/X4eqnLc8UW7a2rVP/u92FdAdPQb9Pfz16rs6qKVejZf9vC/S+SxFda8HeG21yrxfY56/Z/AZb/rox5br96HkK+blsHVyXHAhkr8ANG3aoyXodOMbOPRcMcn5yCudYnjMtb5c9nHLduu3ZC0PNEMhggcD4Qq/0UbuEcENQpJqi9ZbXOgjxV+bLl5derX9TrQP5EEAAAQQQQAABBBAYaQHupI20MNtHAAEEEEAAAQQyQGBPuFv/rmtSyMr6zhSCK65KrnVwMhBzm40JnGpyXUHfdcx8/WzhTE0rzLeunqV/Wnett9rkXnfZ5ykFefrpwhm6+9j5qqDr51RpyYdA1gokzzHvTvH85CCSef+6c49iQwguZS0iFUMgzQSCU0oVsPFw461SZFPqhetekcibfyzdu6euRk4EEEAAAQQQQACBXBNgILU0POJ+a+ESDCYOzctdIqVhOSkSAggggAACCGSPwLPN7V5nzAutSsUW2E01udZ4Li1tbEt1FS+f37p9/MDUsd60rKlNy5vbtKc7omoL9h5WVqTFZVaKZNeQQ9oymRFAINsEWq3l74vW00CBVcydo1JNM+z8NMYy11r30Vs6wppWlJ/qquRDAIGDJFB03gy13LRCnffHFXy/5Avu/xok1hhX5xOJ1sJuXRICCCCAAAIIIIAAAgj0L0AAuH+XUZ17xx13jOr+2TkCCCCAAAII5J5AbVe3V+nqIQR/3QrVPVS11oLYdd94IEHbxeXFchMJAQQQ6E9gt51fXKq0yX8A5yjXQb3bBgFgp0hCIL0Eii+YrfY7Nyi6o13tt8dV9BYLAof6DwLHmuJq/aMFf8NSwWmTlH9kTXpVhtIggAACCCCAAAIIIJBGAnQBnUYHg6IggAACCCCAAAKjJVAWSoyhZ70wDikl2/2WBa1DaFrsDsmOzAggkJpAuZ1fXBrq+an3OslteBviHwQQSBsBf0FQVd85Ub7ioLrXSC0/jyu8Iq54+JUxgWOt1ur3ybi3LGZPdARnlaniyqPSpg4UBAEEEEAAAQQQQACBdBSgBXA6HhXKhAACCCCAAAIIHGSB+SWF3h5X2xi8UZvc+L6ppBcsr0vzetZPZR3yIIAAAkMRqM4Led3Du27iN9s5Z2qK56cGy7vddlTg92mqjTdOQgCB9BQIzSrXmF+croYrnlRkY4vXEth9zX2ldo0RleLJp82s+PknT1DlVcfIXxxKz8pQKgQQQAABBBBAAAEE0kSAFsBpciAoBgIIIIAAAgggMJoCM4sKtMCCuM1WiAd6grqplOeOnrxvHuc6ZyUhgAACIyPwpp5zzB3eaOWp7eNOOz+5R1ReX1OhggB/+qamRi4ERkcgNL1MNb97rcovX6y8RYkBJuJ2UeIFf/MDKnjNBFV9/yRVW2thfwnB39E5SuwVAQQQQAABBBBAIJMEaAGcSUeLsiKAAAIIIIAAAiMocNmsibrouZf0EwuwHG5Nb2oGaWX3T8v3lIVXXPfPH546dgRLxqYRQCDXBT43c4J+u7VW7qGT19h0xCDnp7WW5w89weJLZ07MdT7qj0BGCPiCfhWfN8Ob4pGYYns6pZBf/op8+awlPwkBBBBAAAEEEEAAAQRSF+Ax6NStyIkAAggggAACCGS1wLsnjdGZY8rUYLX8jPW5uN4CKP0l16buTgusfLsnuPLdBdPkumglIYAAAiMlsKC0SO4hFesNVl+2fx/rOf/0t79ltuxSy9NlCz9kD6ecWFXaXzbmIYBAGgu4YHBgXJECVQUEf9P4OFE0BBBAAAEEEEAAgfQVoAVw+h4bSoYAAggggAACCBxUAb/Ppz8unqs3PLVKS5va9GELoJxhrexOsmmCTWErzToL/v7Dgisv9pTsyjmTdNGUA2/9G43H9Wh9i5Y3t2tPd7eN8xnSYWWFOrmyTEFa+xzU48/OEEh3gW/Mm6KtnWH9fludrrTz0GI7H51p56bpNrm2gVvss+vC/kmbXHrj2Ar9z6HTvff8M7ICK1va9XhDi3Z0dqvIutueWVyg144pV6n1EEFCIN0E4rG4wsv3KLK2SdHGLvlLQwrNKFPeYuv7xALPJAQQQAABBBBAAAEEskGAAHA2HEXqgAACCCCAAAIIDJNAZSioB084VJev3qyfbtql+y1Ae39PMKX3Libmh/TdBdP1jomJcfp6L0vlfXcspp/Y9q9dt0114cg+q1RbOS6fPVGfmD5eeX5uxu4DxAwEclDAPaTymyNm6+jyYn3txa1aFolqWT/np2ILQF4+e5K+aC2G3TqkkRO4Z3eDvrx6i5ZbALhvCpn9+6fU6GtzJ2tcfl7fxXxG4KALxKNxtd+xQS2/WqVYnXUv3Sf5bGzhknfPUckFc+Ur4OGFPjx8RAABBBBAAAEEEMgwAQLAGXbAKC4CCCCAAAIIIDDSAgUWPLnBWs19ZsZ43baj3lroNmt7V7cKrEXu9KICnVNTofPGV6nQ8h1Iqgt36x3/eVGPWMtfl6bZdKS13yu3qcmCOc/atLE7ostWbdbtO+v1l6PmqcYCziQEEEDACXxqxgRdOLlGf7Xz0311jdrSEVbMHlaZXJivM6rL9PYJ1ZwzRvhHxXlftmqTfrBhp7enSvv3GDuHj7dXF1ZzvUQ8b3l+vnm37tzZoL8ePVfHVdIVt7GQRkkg1tathiufUteTu7wS+O2HNjhD8pf4FOuIK7pZiu7qVstNK9X54HZVfftEBcYWjlJp2S0CCCCAAAIIIIAAAq9egADwqzdkCwgggAACCCCAQFYKuGDvpdaCzk3DlbqiMZ23ZI2eamxVjW30Uvl1rE190xLr3vW7Nj3e0Ko3L1mtB6xVsgtMkxBAAAEn4Hor+KCN7+sm0sEXuMJ6iXDBX/dozsV2Dn+LBX+DNvVOW+1hnu/beXyZPfRzztOr9fhJh2leCQG13ka8PzgCruVv/RVPKrxkt3zFUuE5PuXN6/3zmngf2WwthO+Oq3tNo/Z85hGN+fnp8hfzANrBOUrsBQEEEEAAAQQQQGC4BbiLNtyibA8BBBBAAAEEEEBgQIGrrctnF/x1rcR+qkC/wV+38jEWULjRlrvQ8xIbj/jra7e62SQEEEAAgVEWeGhPs767foedoaVv2bn67Tb1Df66Ik62gPC3bdmp9tpk3XW/91kbRd5aBZMQONgCbX9cmwj+lkilF/UN/r5SmuBUn0o+4JPfnlCLbGhR84+Xv7KQdwgggAACCCCAAAIIZJgAAeAMO2AUFwEEEEAAAQQQyFSBBuvW+QYLGrj0FQsdVPVpLda3XpW2/KteiEH64YYdNlZwd98sfEYAAQQQOMgCV63Z4u3x/RbcPdKm/aWAnccvtzxjLNN/7GGeO3c17C87yxAYdoF4Z1Qtv1ntbbfozRbcrejd8nff3fkLfCp+u+WxH+32OzcqsnPf8a33XYs5CCCAAAIIIIAAAgikn8D+/1pLv/JSIgQQQAABBBBAAIEMFfg/u/HfEYvpKAsILBgk+Jus4jzLd6xNnbG47iZwkGThFQEEEBgVge2dYT3a0KIC2/vbUzyPF1i+d/YEiv+8Y8+olJud5q5A15Jdird0K2BdioRm7j/4m1QKVPsUmm+frOvozge3JWfzigACCCCAAAIIIIBARgkQAM6ow0VhEUAAAQQQQACBzBV42rp+dum4FIMGyZq6ALBLSxrbkrN4RQABBBAYBYGlTYnz+CI7L7vAbqrplfN4Yv1U1yMfAq9WILwy0eo8OGtoWwrNTvx8d6+sH9qK5EYAAQQQQAABBBBAIE0ECACnyYGgGAgggAACCCCAQLYL7O7pwtmG1htSSuZPrj+klcmMAAIIIDBsAru7El3xJ8/LqW44mX9Xz/qprkc+BF6tQKy+09uEvzT1BxbcCr7SxJ6j9V2JN/yLAAIIIIAAAggggECGCQQzrLwUFwEEEEAAAQQQyCiB+nBE9Tb27Zi8oCpCuX3pVRoMeMeubYhHMDn6XnL9Ia5OdgQQQACBYRIo6zmPJ8/LqW42ed5Prp/qeuRLT4G4dY0ca+hUvCsqf3WB/AXpe33jKw55iPHw0CzjPXFff8/6Q1ub3AgggAACCCCAAAIIjL5A+l6lj74NJUAAAQQQQAABBA5IYH17p65/abvusDFre7d2mlqYp/PHV+nzMydqYkHeAW07k1eaV1zoFX+l4jp3CBVZYfldmlvsRp0kIYAAAgiMlsCcnvN48rycajnced+luSWJ3wOprke+9BLoWlartlvXqespG1e3M/py4ULzKlR41hQVv3WWfPmJh71eXjjKb/xV+V4Jolvdz2DqrYCj2xI/s77C9KrPKHOyewQQQAABBBBAAIEMEqAL6Aw6WBQVAQQQQAABBNJf4DsW+F3w4HP62ebdXvC3xIo80aZimzZ3hPWDDTs174FndbMtz7X0xnGVXpUftEBAU08wYDCDZsv3QE/e5PqDrcNyBBBAAIGRETiirEiT7AEm9xvsKcVS3smdyfP42MTvgZRXJGNaCMQ6rTeTrzylPZ94WJ0PbfeCvz67wPFXWPEsPtq9plHNP1yu3e+6V+EV6TlmbvdaKdaUCOoOhhoPxxV+frBcLEcAAQQQQAABBBBAIL0FCACn9/GhdAgggAACCCCQQQKfX7lRV6zerGg8rnOslcnNdlf0LgX1e5vutumn9vk0m98Ri+ni5evlgsW5lOZby69zxlbIdR16Q4qBgx9YPtd16Fk15TqstCiXuKgrAgggkHYCPp/PerGY4JXrh3Z+dg/pDJbusXzLLF+VDYNw0ZTkaMCDrcXydBFw3Tzv+eQj6rx/q2SdlxSc5lPZp30q/4xfZZ/0q/wLPhW/y6fAeCm6q0N1H39IXc/WpUvxFUuO4WsNltvviStu12iDpY77LV9Pv+W9WzoPth7LEUAAAQQQQAABBBBIJwECwOl0NCgLAggggAACCGSswB+31Xmte91Ic9fIr8ss2DujT1eD8+zzVTb/i7bcdUL4JQsW/6uuKWPrfCAF/+6CaXJjQLpWwNcqKhtBsN/NdNn862z5v+21NODX9xZM7zcfMxFAAAEEDq7AR6eN09HlxXKPMH3OztM7BjiPu1LdacHf79nk0vfs/F9uQWBSZgk0fe9ZdVurXtfat/RDPhWc7JO/9JWulH0Bn0JzfCr5gE95R1rdwjE1XPGEog09g+iOcnXjbd2JEljwOvKSBYFvs+BuV//XHm5s4/Z7Ywovs1V6en6OtfasP8r1YPcIIIAAAggggAACCAxVgADwUMXIjwACCCCAAAII9BHoisZ0uQVzXfq0BXdPsGl/6WxbfpFN7vbjpSs3pdQaZX/by6RlbvzIPx81V8UW1P2nCVxowYPfWnBgub3fbJN7/Z19dvPvtfdFlu9Wyz+PcSMz6TBTVgQQyGKBPL9ffz16nubZuOwWT9P77Xz9fZtcl9D2G01rbLrL3n9MEZsfsyXSV+dM1oWTaf2baT8W3eua1H7XRi8Y6rXyrXol8Nu3Lj6/T4Xn+BScYV0tN4bV+qtVfbOMymd/ZYG337wFNgKwve1eIzX/OK6OB2OKbIoruieuiI0P3Pl4XC03WtfPSyy7BX/zFieKG+gZQ3hUCs9OEUAAAQQQQAABBBB4FQI8fvsq8FgVAQQQQAABBBBwAvfWNWprZ1iz7L3r+jmVdIHlu9MyLm9p15KmNh1b4UYLzo105phyPXbSYbr4+fV6urFVv7IAwa/6qbprYfazRTO1qMyNoExCAAEEEEgXgYk2DvDjdh6/ZMVG/d56wHBj/CbH+e1dxgn5Ia8Hh3dMrO49m/cZIuAFf+1pNRcMDdQMfn3juggvfL3UcpO1pL1nk8ouWSRfcP8PxY00RWhBYtzpaK28Vsrtd1vQ157Z63rUTfu2BPaPlYrO9anr6cSy0CGJ9Ue6nGwfAQQQQAABBBBAAIHhFiAAPNyibA8BBBBAAAEEck7g/tpEN85nWKteX4oB4JDlO9Wmv9hN8/tqG3MqAOx+QNx4vi544Op++856LxC+JxxRdV7QW/aW8VU27q/1N0lCAAEEEEhLAded82+OmK0vzJqoP23foycaWrSjq9vruWFmUb6N+V6pt0+oss89femmZS0o1P4Eup7e5S3OO2zw4G9yOy5Q7B8bV2x3RN0rG5S3aHSD//nHjpWvOKjotohidrlW+l6/1/I3vMoCwVY9N9avr9AC3GOk0DxrwTzHWjA3WEth14DZYtcFp01KVo1XBBBAAAEEEEAAAQQySoAAcEYdLgqLAAIIIIAAAukosKUj7BVr2hALN80LFse1xVoP52p6nQV53URCAAEEEMhMgUPtgZ6vzyvKzMJT6v0KRHd3eMtdcHQoyeWP7ZYFWNtttdENAPsLgip533y1/OQFtd8ZV+lFUnCaBXpt6i+58YHb/2Ktf23o6qI3T1dwAr2Q9OfEPAQQQAABBBBAAIH0FxjdvnjS34cSIoAAAggggAACgwrErRWvS/3fShx49WT+WDyx/sA5WYIAAggggAACCBxkgVjP9UnygiXV3ffkT5fLm5L/mqO8I8co3mLdU98cV/e6/q+73FjAbrlrGRycVqqyTy1KtcbkQwABBBBAAAEEEEAg7QRoAZx2h4QCIYAAAggggECmCUwqyPeKvGWIBd/SEzie0rP+EFcnOwIIIIAAAggg8LLAksbWxLAKze2qC3fbsAohG1ahUG5YheMrS1/Ol+qbwLgi6y65RdE9FhCdkOpa1ni2LpE3MNb6Vk6D5MYhrvrWCar/0pMKL61V2x/j8o+JKzjDenku8SneEVfExgWObk8UNjirTFXXn2TLQmlQeoqAAAIIIIAAAggggMCBCRAAPjA31kIAAQQQQAABBF4WOGNMmW7avEsPWH+B73IDxqWQohb8fbgnAHzGmPIU1iALAggggAACCCCwr8D69k59cvkG/bPOBrntk/5R26jr1+/QGdVl+vHCGZpTnHpQNu/oGi8A3L3CgqUTUmsGHK1PtKD1FQaUt6CyT2lG76O/NE/V3z9ZbX9dr9Zfr7YgdZfCXqD6ldbAvqKgii+Yo5L3zJXrOpqEAAIIIIAAAggggEAmC3BFm8lHj7IjgAACCCCAQFoIvGFshcZZK5s11trmXxYEPjOFIPBfLfi700o/r7hAJ1SWpEU9KAQCCCCAAAIIZJbAkw0tevOSNarvjshXIOUdbq11p/vks2GZ4zYEb2RTXOHnpH/vadYJj72gvx09TydXlaVUyaJzp9t4uOvVtdS2e1RcgcrBg8Ad9yUCqoVnTZUvL5DSfg5WJtcSuOSds1X81plmUqfuF5sUa+ySvzSk4Mwy5R81Vr789CrzwbJhPwgggAACCCCAAALZJ0AAOPuOKTVCAAEEEEAAgYMsUBQI6Bvzpuji5et1vQWAq23/R+wnCPyI5bnJJpe+dcg0+X2D31D1MvMPAggggAACCCDQI7Clo0vnL00Ef4NzpaI3+eQv3PuaIjTHp4KT42q/O67G1VEv/9MnL9SMIosWD5LyDqlU4VlT1HHvFq/b5JL/Z10ml++9/eQm4jbgb+f91pXyWslXHFTpBw9JLkq7VxcIdsFeN5EQQAABBBBAAAEEEMhWgdT6KMzW2lMvBBBAAAEEEEBgmAQ+MHWsLppSo07b3qUW3L1RUe3q6eI5uYut9vl6m/9VWx61mVfMnqQ3jkuf7hGT5eQVAQQQQAABBNJf4LJVm1Qbjig4Syp+x77B32QNfAU+Fb3Np5AFiRu6o/rcik3JRYO+ln9hsW2/TDEbB7jll3FrDRxXvOuVbpNd4DeyOa62W2zZU7a5gE+VVx+nwJjUu5oetBBkQAABBBBAAAEEEEAAgSEL0AJ4yGSsgAACCCCAAAII9C9w08KZXlfQ33ppu261YO+tFuYdb1ldR4sNNtX2rBa0Fr/Xzp+iz86c2DOHFwQQQAABBBBAIHUBN+7vbTvqrb9na/n7RuvyeZDeRNzywnOtS+iNcd21u0GrWqx/6BSS38bFHXPjqWr46tPqenKXOv4RV8c/rSVwZVy+kKwLZetq2j39ZslfkecFf2lZm/DgXwQQQAABBBBAAAEERlOAAPBo6rNvBBBAAAEEEMgqAdeV89Xzp+qdE6vlgsD37G7UzkjUG+vXVbQyFNB546p0ubX8nW1j/5IQQAABBBBAAIEDEbhrl3u0TArNt8Braf/dMvfdrr/YWgEvsDGBn5UXBO67fKDP/tI8VX//ZHU8vF1tt66z9eusRfArrYADk4pV+PopKvl/c+UvsagwCQEEEEAAAQQQQAABBEZdgADwqB8CCoAAAggggAAC2SawqKxYvz9yjrpjMW3pDKveumesyQtpcmGe9YyY2k3abDOhPggggAACCCAwfAKrWzu8jQWnDO26IuDyPxvX6taeZrtDKFLhKRPlplhHRNFd7dbyN6pATaEC1TzUNgRGsiKAAAIIIIAAAgggcFAECAAfFGZ2ggACCCCAAAK5KBDy+zWzqMCmXKw9dUYAAQQQQACBkRJotLF8XfINMfaazN/UHTngovkLg/JPdwNckBBAAAEEEEAAAQQQQCBdBfzpWjDKhQACCCCAAAIIIIAAAggggAACCCCwr0BNXuJ5/ljrvsv2Nyfeklg6xnomISGAAAIIIIAAAggggED2ChAAzt5jS80QQAABBBBAAAEEEEAAAQQQQCALBY4qL/ZqFVn/yli8qVQzmT+5firrkAcBBBBAAAEEEEAAAQQyT4AAcOYdM0qMAAIIIIAAAggggAACCCCAAAI5LHDuuErl+32KvCRFdqYWBI7WxtW9Vgr6fHqzrU9CAAEEEEAAAQQQQACB7BUgAJy9x5aaIYAAAggggAACCCCAAAIIIIBAFgq4Lpw/OX28V7P2v8YV69h/EDjeGVeb5ZP9/9Fp4zS+IC8LVagSAggggAACCCCAAAIIJAUIACcleEUAAQQQQAABBBBAAAEEEEAAAQQyROCquZN1eFmRYvVS681xRbb0HwSObIur5VcWJK6VDi0p1DfmTcmQGlJMBBBAAAEEEEAAAQQQOFCB4IGuyHoIIIAAAggggAACCCCAAAIIIIAAAqMjUBQI6O5j5uu8pWu0rKFNrb+JKzApruB0yV/sU6zNgsKbpOjWRPkWlRbpzmPmqTQYGJ0Cp7DXWFNYnY9sV9eyWkXrOuUL+BSYUKyCE8Yp//jx8oVox5ACI1kQyEmB8Ip67/wR2diiWHNY/sp8heZVqPC0SQpOLc1JEyqNAAIIIJDbAgSAc/v4U3sEEEAAAQQQQAABBBBAAAEEEMhQgQnWlfNDJxyq77y0Xd9bv12t22KKbnOVeaU1cFHAr8/MmKDLZ0+UCxqnY4rH4mq9ZY0Fsdco3h7Zp4jtt69XYHyRyj69yAvm7JOBGQggkLMC3Rub1XT9swr/x7o56JM6/71NLTeuUOFZU+z8cbgCFhQmIYAAAgggkCsCBIBz5UhTTwQQQAABBBBAAAEEEEAAAQQQyDqBQgvwftW6g75s1kTdV9eo5c3tqgtHVJ0X1GHW6vf1NeWjEvjdfLUXiR7Uuysa0zuWvah7djd6eYMzpNB8n7Xes48xa8G8Wwovjyu6s10NVzypT86ZpKvmvtKN9dQrJw26DzIggEB2CnQt2a36y5/wHhzxFUp5C6XAVJ98BfYYTJsUWR9X+AWp494tCj9Xp+obXqPgNFoDZ+dPA7VCAAEEEOgrQAC4rwifEUAAAQQQQAABBBBAAAEEEEAAgQwTcIHgN4+r8qZMKvpHlq/3gr++IqnofJ9CM3x7FT80W8o/wYLASyyIc19c31i7TZOs5fOHpo7bKx8fEEAgtwRcy99k8Dd0qJ0/3uACv3ufP/IO9anglLjabreHSLZ2aM/nH1PNzWfIX5aXW1jUFgEEEEAgJwUYPCUnDzuVRgABBBBAAAEEEEAAAQSkhu6IItb1KgkBBBAYDYF/1jbqlm118lkspuTCfYO/yTL5fD7lH+tT0ZsTwZ3Pr9yk3V3dycW8IoBADgo0fedZr+WvC/4Wn+/fJ/ibJPGX+7zzS2CC9SiwrU0tv1iZXMQrAggggAACWS1AADirDy+VQwABBBBAAAEEEEAAAQReEei0rlb/Z8MOnfL4Cyq85ynV/HOpCv7+lOY+8Iw+t2KjNrR3vpKZdwgggMAIC3xr3XZvD/mn+BQYu3fLvf52nbfQgsTzpDY7l/1o487+sjAPAQRyQCD8wh6Fl9XKdftcdM7g5w5fsOcBEsvaZmOKx5rDOaBEFRFAAAEEcl2ALqBz/SeA+iOAAAIIIIAAAggggEBOCDxa36wLn1mnrZ2v3PQssZq327S+vUs/tGDKjZt26Ss2vuaX5kzOCRMqiQACIycw2Ni8saawdv692QbstC6eF6dejrxjfOpeE9e3Yy36NeP/pg5HTgSySKDz4R1ebfIWSb78wQPALnOgxqfgjLg3LnDn4ztVdPbULBKhKggggAACCOwrQAB4XxPmIIAAAggggAACCCCAAAJZJfB/uxr09v+8qO54XHOtZu+WX8fIp0KbYoprjc27097da8u/+uJWbezo0s8WzcoqAyqDAALpJRDZ3CI77SgwyQI4eakFcFwNglMS9YhsalHcurD3+VNfN70EKA0CCByoQPcGe3jEUnDq0L7/Ln9kvQWBbfxgEgIIIIAAAtkuQBfQ2X6EqR8CCCCAAAIIIIAAAgjktMB669b53c+s9YK/b7eA743W3O4UCwC74K9LNmqeDrHpizb/Om++dPOWWv2E7lVz+ueGyiMw0gKxlkRvBL6Coe3JF7Bzl40ZrGhc8Y7I0FYmNwIIZIVAPHn+sC6gh5KS55tYM2OID8WNvAgggAACmSlAADgzjxulRgABBBBAAAEEEEAAAQRSEvjS6s1qtfEyT7cg7ycsyOsCvgOlY23p5Ta59NU1W9TQTXBlICvmI4DAqxPwV+R7G4i3DW078e645GLHIb/8xaGhrUxuBBDICoHk+SPWOrTqxNrs/GHJX5k4/wxtbXIjgAACCCCQWQIEgDPreFFaBBBAAAEEEEAAAQQQQCBlgbpwt/6yo14uRPKJnsDuYCu71sGLLUjcGInqz9v3DJad5QgggMABCQSnl3lB3Ogu6wm6PRGUSWVDkQ2JXKE55alkJw8CCGShQGhuhVeryIbUzx1uhZfPH3M5f2ThjwVVQgABBBDoI0AAuA8IHxFAAAEEEEAAAQQQQACBbBG4v7bJRviVjrKAbvV+Wv72re/re/LeW9vYdxGfEUAAgWER8BcFlX/cOLmTVNeTqQdxOp9I5C083QYPJiGAQE4KFPR8/8PL7QGSltTOH5HNcUW32pjjyXNPTspRaQQQQACBXBIgAJxLR5u6IoAAAggggAACCCCAQE4JbOro8uo7Y4i1ntkTAE6uP8TVyY4AAgikJFD6wUO8fF1PSt3rBw/idD5iAZwtie5bi946K6V9kAkBBLJPIDSjTAVn2kMgNlJF2+02Hnhk/+cP1/Vz+52JPCXvnit/QTD7UKgRAggggAACfQQIAPcB4SMCCCCAAAIIIIAAAgggkC0C3fHEzc6h3uZM5u+O7f+GarY4UQ8EEBgdgbz5lSp5/3xrwmdBnD/F1bXUAjn9nHfiXRa8+UdMnQ/ZOcmGMa+48ii5FsQkBBDIXYHyzx4hf02hopul1t/ZwyF7+r9miWyJq/VXccWsU5PQoVUquXBu7qJRcwQQQACBnBLgajmnDjeVRQABBBBAAIGDJbCqpV137GrQCntt6I5qTF5Qh5cV6S3jqzSjqOBgFYP9IIBAjgtMKsjzBLYO0WGr13G0lFx/iKuTHQEEEEhZoPTiBYq3R9R26zp1/MOCwNYaODQ3Ln+VRXotMBzdFVf3GusputM2GfKr4orFKjhxQsrbJyMCCGSnQKC6QNU3nKz6zz+m6LZ2tdwUV3CmTVN88hXaOaPVehawMYJdrwEuueBv1bdPkC8vkJjBvwgggAACCGS5AAHgLD/AVA8BBBBAAAEEDq7AZutu9fMrN+n2nfX77PiWbdIXVm3WhZPG6DsLpllQOLRPHmYggAACwylwanWZt7klFtDtsKkwxXGAH+4JACfXH84ysS0EEECgt4DP51P5Zw9X3pFj1Pzj5TZGZ5u6nnY59m7N55aXXbJIrtUwCQEEEHACoZllqvn1GWq+aYV18bxRkXVxb+qt4ysMyHX7XPKeeQR/e8PwHgEEEEAg6wUIAGf9IaaCCCCAAAIIIHCwBJ5ubNV5S1arNhyxIIt0ugVaDrep3N432PQfu5H5kE2/21anh+tb9H/Hztf8EpeThAACCIyMwEzrceDEyhI93tCq/7WmdB/U4K1e1tp56t82BS0o866J1SNTMLaKAAII9BEoPG2SCk6ZqPDyPQo/U6tobad8Qb8CE4qUf/w4haYnHmjpsxofEUAgxwX85fmq+MJilV58qLoe26nIxmbFWrrlr8hXaH6F8o8bJ38ht8Bz/MeE6iOAAAI5KcBvv5w87FQaAQQQQAABBIZbwLX8TQZ/j7Wg7xflV1WflnZn204/aEGVqxXVCsv/JgsWP3XSQlVZ99AkBBBAYKQEvj53il771Cr93s4/0ywI/Fo7Pw2Utluer9g5ynpd1bsmVGk6XdYPRMV8BBAYAQGf36f8w8d40whsnk0igEAWCwQs4Ft07rQsriFVQwABBBBAYGgCA//lP7TtkBsBBBBAAAEEEMhpgc+u2Oi1/HXB32/2E/xN4oy35d+zFniH2IwN7V26cs3m5CJeEUAAgREReMp6J3DJdaZ6jYV2v2sB3l3eJ2+290+nfb7Dln3MW5aYv6rVOo2O790F6ytr8A4BBBBAAAEEEEAAAQQQQAABBNJVgABwuh4ZyoUAAggggAACGSOwsqVdd+xq8Lp9vtyCv4E+LX/7ViTPll9huVxHrL/cslu7u7r7ZuEzAgggMCwC3bGYrl+/3dvWW+3c4/4AvNuCvRdYoPciRXSZvX7cXs+z1xssANxsy0+waYxNzza36x+1jfaOhAACCCCAAAIIIIAAAggggAACmSRAADiTjhZlRQABBBBAAIG0FHDBX5fOtOBK5SDB32QFpli+42yKWuO6u3vWTy7jFQEEEBgugYdsvPGG7qhm2QY/ZY+d/Nqm19q5p8A+b7RpqQWDV9mrewzlUJu+YSHibypoAeHEn4p/25k4v9kiEgIIIIAAAggggAACCCCAAAIIZIgAA85lyIGimAgggAACCCCQvgIvWAtglw5PMfibrInL/7gFX1a0JtZPzucVAQQQGC4B10OBS8nzk3v45MsWBA7buWezzW+w12KbN8nel/c6hyXzr+T85PhICCCAAAIIIIAAAggggAACCGSUAAHgjDpcFBYBBBBAAAEE0lGgIRzxilU2xMIl89f3rD/E1cmOAAIIDCpQ3508P/n2yuu6op/tzdmDG61yAABAAElEQVR7fjJTec8bzk9JEV4RQAABBBBAAAEEEEAAAQQQyBwBAsCZc6woKQIIIIAAAgikqUB1XuKSaqgjZSbzj8kLpWnNKBYCmSdQF+72xq6ttbG1y0MBzS8p1Mwi1+FxbqYxocT5pdFa+g4lJTt+5vw0FDXyIoAAAggggAACCCCAAAIIIJAeAgSA0+M4UAoEEEAAAQQQyGCBw8uK9Yfte7TMAiyvH0I9XH6XDi8rGsJaZEUAgf4EHq1v1tdf3KoH9zQr1ifDoRYE/uLsSfqvidXy+fpv8dpnlaz5uKjn/PKfIQaAl/UoJtfPGhAqggACCCCAAAIIIIAAAggggEAOCPhzoI5UEQEEEEAAAQQQGFGBt4yv8rb/gAVYdqcYZHnJ8i21Kc+CUeeMrRzR8rFxBLJZIBaP64urNum0J1bq3xb8dU+4uvFrz7TpWJtK7fOK1g6999l1euOS1Wrq6RI5m0161+2kqlKNtV4GttjMJ/YJjffO+cr7Djs33dVzLntrz/ntlaW8QwABBBBAAAEEEEAAAQQQQACBdBcgAJzuR4jyIYAAAggggEDaC8wuLvBaFoatpFcrqnBP4GSggrfZcpfPtf/9xPTxqurpQnqg/MxHAIGBBT6zYqO+u36HF/i9SH7droBusOlKm75lk/t8hc2vsE3cW9ukc55era5o3zbCA28/05cE7CGTL1nrZ5e+awHg2kHOT3Fb/h3L57qAPqmyVKePSY4G7G2CfxBAAAEEEEAAAQQQQAABBBBAIAMECABnwEGiiAgggAACCCCQ/gLXL5imyQV5Wm5F/ZwFd7cNEGRZb/M/acs3Wj7XLe1X505O/8pRQgTSVOCvO/boJ5t2Kc/K9x0L9L7XAr1F1uq3dwrY59fb/Jts+Xhb8FRjq65c49rD5k766LRxOr26THusyp+w88/zA5yf6m3+lRb8db0ZlAUD+tmimbmDRE0RQAABBBBAAAEEEEAAAQQQyCIBxgDOooNJVRBAAAEEEEBg9ATG5efpnmPn601L1mhFR5feZ0GWEyzw5Lqide3n6m1yY/4uscm1/F1gwd+7LH+pBVlICCAwdIG4df385Z5A7sctwHtEn8Bv3y2OteVftyDwR+y7+aONO/XpGeM1uTC/b7as/Bz0+3TrUXN1vp2fHm1o0afNYJHV9Fhzq7HXNptW2pnpUZs67X1VKKi/HD1X8+w8RUIAAQQQQAABBBBAAAEEEEAAgcwTIACceceMEiOAAAIIIIBAmgosKC3SUycfpi+v3qJfbdntBVNcQKV3cmP+fmz6OH1t7hSCv71heI/AEAWWNLVpbVunxtl6bxwk+Jvc9BzLd6pND1rw+C876y0IPCG5KOtfKy2oe9/xh+jbL23Xd2x63rrBfr6fMYHfZmP+fuuQqZpeVJD1JlQQAQQQQAABBBBAAAEEEEAAgWwVIACcrUeWeiGAAAIIIIDAqAiMyQvpJus29WvWtfPduxu0oqVD9d0R1dg4v4eXFevcsRWqtjz/n707AZOjqvcG/J9kQvaNJGYhLIGwg3BBIMiVoER2leVjkQsRBOSieB9FRMWrgnpVFIELyCJLkE1wQfZdroKAEHZCkEAIEggmYUsgZE++PgXdTuJMZpJ0T09Xv8UzmeqqU6fOeU89zXT9uqpMBAisnsBf3pydVZCutE+3eW7rtFMKgNPVrm8WroStowA4+XTp1Cm+veHw+K9Cv2+f8XaMn/VuTJ+/MLvd80aFZ5nvM7h/jBD8tvVQUo4AAQIECBAgQIAAAQIECHRYAQFwhx0aDSNAgAABAgRqWWBo4XnAx6yTrk00ESBQCYHX5i3Mqh2yEuFv2mDYB+WnzVtQiWbVRJ3p1vMHDhuQ/dREgzWSAAECBAgQIECAAAECBAgQWCmBTitVWmECBAgQIECAAAECBAh0AIFund//KLOyMe78D27L3v2D7TtAVzSBAAECBAgQIECAAAECBAgQIFBWAQFwWTlVRoAAAQIECBAgQIBAewiM6N41280Lyz1nu7V9P/9BgfU+2L618tYTIECAAAECBAgQIECAAAECBGpNQABcayOmvQQIECBAgAABAgQIxB6F52mn6aFCAPxmG0PgpYVyd8SSbLvi9tkL/xAgQIAAAQIECBAgQIAAAQIEciQgAM7RYOoKAQIECBAgQIAAgXoRGFZ4zvZ+Q9aM+YUOn/tBqNta368rBMAvFgqt032N+NSH+rdW3HoCBAgQIECAAAECBAgQIECAQE0KCIBrctg0mgABAgQIECBAgACBH2+yTvQuPMv3/wrB7v/G4sJ/S1tEubUQEp//QVD8883Wi66eAdyilRUECBAgQIAAAQIECBAgQIBAbQs01nbztZ4AAQIECBAgQIAAgVoRWLx0aTw9+714Zd6CaGxoyK7E3ax3j1Vu/sie3eLqbTaM//fopLh+ydJ4vBABHxKd4iPREGsWap1T+Hm6EApfX/gZ/0E4/P2NhmdXDq/yTm1IgAABAgQIECBAgAABAgQIEOjgAgLgDj5AmkeAAAECBAgQIECg1gVeX7AwfvT8q3HVq6/HGwsXLdOdtQq3cj5mnQ/FV0cMjZ6NnZdZ15YXexZu5XzPqM1i7BMvxOT35sdpLdwOul+h7jM3Xy8OHz6oLdUqQ4AAAQIECBAgQIAAAQIECBCoWQEBcM0OnYYTIECAAAECBAgQ6PgC97w+Kw5+bFK8tXBx1tjhhX+HF67QTa9eKlyV+2rhauBTJr0S46bOjOs/snFs2WflrwjeoX/vmDB6qyxg/t1rb8Zjs+bEzELo3LdL59ikZ/f49JD+hZB5cPTv4uNPxz9itJAAAQIECBAgQIAAAQIECBBYXQFnQFZX0PYECBAgQIAAAQIECDQr8Kc3ZsVeD/8tFhVu/bxdIfQ9tnB75g0Kv5tOTxZC4PMKcfCkufNjlwefiQd22iI27tW9aZE2zXfp1CmOWPtD2U/aYGlhnw2F20ybCBAgQIAAAQIECBAgQIAAAQL1JtCp3jqsvwQIECBAgAABAgQIVF7g7cKtng9+9Pks/D2gEPqe1kz4m1qxVWHdOdE5/r3we9aixXFQ4Xm+6VnBqzsJf1dX0PYECBAgQIAAAQIECBAgQIBArQoIgGt15LSbAAECBAgQIECAQAcWOH3ytOx5v1sXgt0vFcLfhsJ/LU1rFNb9d6HMWoUCz7w7N654ZWZLRS0nQIAAAQIECBAgQIAAAQIECBBoRUAA3AqQ1QQIECBAgAABAgQIrLzAVa++nm10dCvhb7HmroUQeGyhbJqu/GDb4jq/CRAgQIAAAQIECBAgQIAAAQIE2i4gAG67lZIECBAgQIAAAQIECLRB4KX35sXUeQtizULZzVdw5e/yVe1UKJuuE/7Lm+/EkjLcBnr5+r0mQIAAAQIECBAgQIAAAQIECNSDgAC4HkZZHwkQIECAAAECBAi0o8Cr8xZmexu2kvvsWYh/+xW2WVQIf2cueL+OlaxCcQIECBAgQIAAAQIECBAgQIBA3QsIgOv+EABAgAABAgQIECBAoLwCXTu9/7zfBatQbXGbrp18VFkFPpsQIECAAAECBAgQIECAAAECBD54yBYIAgQIECBAgAABAgQIlElg3e5ds5peLvy7IJa2udbphbJzCqX7NHaOfl0a27ydggQIECBAgAABAgQIECBAgAABAv8U8LX6f1qYI0CAAAECBAgQIECgDAKDunaJbfv2jHmFuu5biQD4jg/K7jEo3QjaRIAAAQIECBAgQIAAAQIECBAgsCoCAuBVUbMNAQIECBAgQIAAAQIrFDhu3cHZ+otiScxuQwj8aqHMNYWyaTpuvfe3zV74hwABAgQIECBAgAABAgQIECBAYKUEBMArxaUwAQIECBAgQIAAAQJtERg7fFBs369XTC8U/mYsjrdWEAJPLaw7qVBmbqHsQUMHxMfW7NOWXShDgAABAgQIECBAgAABAgQIECDQjIAAuBkUiwgQIECAAAECBAgQWD2BTg0N8bttN4p1u68RzxaqOqIQ8F5duMJ3WiHsTf8tLvxMKfz8sjB3TOFnWqHMRwq3jb7ow+uv3o5tTYAAAQIECBAgQIAAAQIECBCoc4HGOu+/7hMgQIAAAQIECBAgUCGBYd3WiL/utGWMfeKFuOv1WZFuB31RYV+dCz9LCz/v3/D5/Z0fttbAOG/LEdGjc1prIkCAAAECBAgQIECAAAECBAgQWFUBAfCqytmOAAECBAgQIECAAIFWBQZ17RK37bBp3Dnz7fjVKzPjT2/MjunzF0a6FdHahYD4k4P6xjHrDI7tCreLNhEgQIAAAQIECBAgQIAAAQIECKy+gAB49Q3VQIAAAQIECBAgQIBAKwK7DeoX6SdNC5csiXSL6M6FHxMBAgQIECBAgAABAgQIECBAgEB5BQTA5fVUGwECBAgQIECAAAECrQh06ZSu/zURIECAAAECBAgQIECAAAECBAhUQsCZl0qoqpMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJVEBAAVwHdLgkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAJAQFwJVTVSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSoICICrgG6XBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqISAALgSquokQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAFQQEwFVAt0sCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUQkAAXAlVdRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAKAgLgKqDbJQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCohIACuhKo6CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUAUBAXAV0O2SAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEClRAQAFdCVZ0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCogoAAuArodkmAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFKCAiAK6GqTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFRBQABcBXS7JECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQCUEBMCVUFUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqiAgAK4Cul0SIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgEgIC4EqoqpMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJVEBAAVwHdLgkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAJAQFwJVTVSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSoICICrgG6XBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqISAALgSquokQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAFQQEwFVAt0sCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUQkAAXAlVdRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAKAgLgKqDbJQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCoh0FiJStXZusD8+fOja9eurRdcrsQbb7wRc+fOzZYOHz58ubVeEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQzwKuAG7H0f/d734Xe+65ZwwePDi6d+8em266aYwdOzbuv//+NrfiiCOOiLXXXjv7afNGChIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUBcCAuB2GOY5c+bE5z73uTjwwAPj9ttvjxkzZsTSpUvjb3/7W1xxxRWx8847xwknnFC6srcdmmQXBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAjkUEAA3A6DevLJJ8fll19e2lPPnj1jxIgR0dDQkC1bsmRJnHnmmbH11lvHlClTSuXMECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAYGUEBMAro7UKZZ944on4xS9+kW2Zbv18ww03xOzZs+PFF1+Mt956K376059G3759s/WTJk2KXXbZRQi8Cs42IUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEAgQgBc4aPg/PPPj8WLF0djY2Pccccd8elPfzo6dXqfPQW/X//61+PZZ5+NrbbaKmvJyy+/HLvuumtMnz69wi1TPQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECeRMQAFd4RFO4m6ZDDz20FPIuv8uhQ4fGvffeG6NHj85WpdtA77333pGeHWwiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAWwUEwG2VWsVyzz33XLbltttuu8Ia+vTpE7fddlvsuOOOWblHH300DjrooOzq4RVuaCUBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQ+EBAAV/hQWLBgQbaHHj16tLqn7t27x4033hgjR47Myt56663x5S9/udXtFCBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEASEABX+DjYcMMNsz1MnDixTXsaOHBg3H777TFo0KCsfHqG8BlnnNGmbRUiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKC+BQTAFR7/YgB81VVXxZtvvtmmvW2wwQbZlcDpiuA0nXjiiXH55Ze3aVuFCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXwEBcIXH/tBDD832MGPGjEjz06dPb9MeR40aFSk07tSpUyxdujSOPPLIOPXUU2PJkiVt2l4hAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqT6Cx/rrcvj3ee++9Y8yYMXH33XfHHXfcEZtuuml85jOfiW233TaOP/74FTZmv/32i/POOy+OO+64LPg95ZRTskB4hRtVYOUf/vCHuPTSS7MgenWrnzx5clbFe++9t7pV2Z4AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeUEBMDLgVTi5YUXXhj77rtvPP300/HWW2/FZZddFuPHj281AE5tOfbYY6Nr165xzDHHxKJFi6pyBfCVV14ZN998c1lp3n333bLWpzICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBCIEwO1wFKy//vrx8MMPZ8/yTeHvnDlzYtiwYW3e8xFHHBEf+chH4otf/GLcd999bd6uXAUvvvjiOOqoo8pyBfAFF1yQhckHHHBAuZqnHgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEPhAQALfTodCtW7c499xz46yzzopHHnkkZs+evVJ73mKLLeLee++Nyy+/PM4///yYOHHiSm2/OoX79+8fe+211+pUUdo23Qo7TenZxiYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBMorIAAur2ertTU2NsaoUaNaLddSgbFjx0b6MREgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGB5AZdhLi/iNQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBGpUwBXAHXDgfvrTn8Zjjz2Wteycc86JQYMGdcBWahIBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAh1NwBXAHW1ECu2577774tprr81+5syZ0wFbqEkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHREAQFwRxwVbSJAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgMAqCAiAVwHNJgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOiIAgLgjjgq2kSAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFVEBAArwKaTQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINARBQTAHXFUtIkAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKrICAAXgU0mxAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAjCjR2xEbVe5s6deoUjY3vD01DQ0O9c+g/AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJtFBAAtxGqPYvdcMMN7bk7+yJAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAICcCbgGdk4HUDQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAiAHQMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIiYAAOCcDqRsECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQADsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkBMBAXBOBlI3CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIAB2DBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQCAnAgLgnAykbhAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAA7BggQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBATgQEwDkZSN0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE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CBAgQIAAAQIECBAQADsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkBMBAXBOBlI3CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0IiAAIHKC3S++cHK78QeCBAgQIAAAQIECBAgQIBAGwVebWM5xQgQIECAAAECBAgQqD0BVwDX3phpMQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoVEAA3y2IhAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEak9AAFx7Y6bFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFZAANwsi4UECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoPQEBcO2NmRYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgWQEBcLMsFhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD2BATAtTdmWkyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmBQTAzbJYSIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoTEADX3phpMQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoVEAA3y2IhAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEak9AAFx7Y6bFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFZAANwsi4UECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoPQEBcO2NmRYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgWQEBcLMsFhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD2BATAtTdmWkyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmBQTAzbJYSIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoTEADX3phpMQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoVEAA3y2IhAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEak9AAFx7Y6bFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFZAANwsi4UECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoPQEBcO2NmRYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgWQEBcLMsFhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD2BATAtTdmWkyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmBQTAzbJYSIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoTEADX3phpMQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoVEAA3y2IhAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEak9AAFx7Y6bFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFZAANwsi4UECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoPQEBcO2NmRYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgWQEBcLMsFhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKD2BATAtTdmWkyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmBQTAzbJYSIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdoTEADX3phpMQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoVaGx2qYUEKizw4x//OC688MIK72Xlqp82bVq888470djYGA0NDSu3sdIECOROYOnSpbFo0aLo3LlzdOrk+1K5G2AdIrAKAgsXLszeD9L7gokAAQKLFy+OJUuWRJcuXWAQIEAgez9I7wvOKTgYCBBIAsVzCul8gs8PjgkCBJJAOs+Y3hNGjhwJpBWBlNWYVl9AALz6hmpYCYH11lsvKz1jxoxIPx1xSid3TQQIECgKpD/OTAQIECgKpBO76cdEgACBosCCBQuKs34TIEAgnFNwEBAg0FTA54emGuYJEEhfIP3b3/4Gog0C6SK9ddddtw0lFWlJoKHwbaSlLa20nEAlBCZPntwhPxCNHTs2xo8fHz/60Y9iq622qkTX1UmAQA0J/OEPf4iLL7449t133zjmmGNqqOWaSoBAJQReffXV+MIXvhDDhg2Liy66qBK7UCcBAjUmkP4+SN9MT3c2Gj58eI21XnMJECi3QPr74Prrr4+jjjoq9t9//3JXrz4CBGpM4KmnnopvfetbscUWW8Rpp51WY63XXAIEKiGQ/j6YP39+PProo9GjR49K7CJXdfbq1cvnrNUcUVcAryagzVdeYIMNNlj5jdphi969e2d72WGHHeITn/hEO+zRLggQ6MgCzz33XNa8ESNGxF577dWRm6ptBAi0g8Dzzz+f7aVnz57eE9rB2y4I1IJA8fPD6NGjY+ONN66FJmsjAQIVFLjnnnuy2jfddFN/K1TQWdUEakWgGO4MHDjQe0KtDJp2EqiwQHpMRAqA02eHdG7BRKDSAh5qWGlh9RMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCdBATA7QRtNwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKi0gAC40sLqJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQDsJCIDbCdpuCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUGkBAXClhdVPgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBdhIQALcTtN0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg0gIC4EoLq58AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLtJCAAbidouyFAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEClBQTAlRZWPwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBNpJQADcTtB2Q4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgUoLCIArLax+AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItJOAALidoO2GAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEClRYQAFdaWP0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBoJwEBcDtB2w0BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqLSAArrSw+gkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINBOAgLgdoK2GwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFRaoLHSO1A/gVoR6NOnT9bU4u9aabd2EiBQGYG+fftmFXtPqIyvWgnUmkDv3r2joaEhvCfU2shpL4HKCaT3g/S+kN4fTAQIECj+jVD8HEGEAIH6Fii+JxR/17eG3hMgkATS+8HixYtjjTXWAEKgXQQalhamdtmTnRDo4AL/+Mc/YsKECTFmzJgO3lLNI0CgPQQWLVoUt912W+y6667Ro0eP9tilfRAg0MEF7r///hg2bFiMGDGig7dU8wgQaA+BKVOmxLRp02KnnXZqj93ZBwECHVzgvffeiz/+8Y+xxx57RJcuXTp4azWPAIH2ELj77rtjiy22iCFDhrTH7uyDAIEOLjBx4sSYN29ebLPNNh28pZqXFwEBcF5GUj8IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKh7Ac8ArvtDAAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnkREADnZST1gwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhcQANf9IQCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8CAiA8zKS+kGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQN0LCIDr/hAAQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAXgQEwHkZSf0gQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDuBQTAdX8IACBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAIC8CAuC8jKR+ECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQ9wIC4Lo/BAAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIJAXAQFwXkZSPwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqHsBAXDdHwIACBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIi4AAOC8jqR8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNS9gAC47g8BAAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQI5EVAAJyXkdQPAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqXkAAXPeHAAACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBPIiIADOy0jqBwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECdS8gAK77QwAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5ERAA52Uk9YMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgboXEADX/SEAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBvAgIgPMykvpBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDdCwiA6/4QAECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQF4EBMB5GUn9IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg7gUEwHV/CAAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQCAvAgLgvIykfhAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUPcCAuC6PwQAECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCQFwEBcF5GUj/KJjBjxoz42te+Fh/72Mdi0KBB0adPn9hiiy3ixBNPjOeee65s+1ERAQK1IfDGG2/Et7/97dhjjz1igw02iB49esTmm28e+++/f5x55pmxYMGC2uiIVhIgUDGBBx54IDp37hwDBw6s2D5UTIBAxxCYPHlyHH300fFv//Zv2eeEzTbbLHs9bty4mDNnTsdopFYQIFBVgT333DMaGhri3HPPrWo77JwAgfYXcP6g/c3tkUBHF7j++utjv/32i0033TS6d+8ea6+9dnaO8YorrojFixd39OZrX40LNCwtTDXeB80nUDaBiy66KAt6Z8+e3WydPXv2jN///vex++67N7veQgIE8iVw9tlnx/e+9714++23W+zYxhtvHBdccEHssssuLZaxggCB/Aq89dZbMWrUqJg0aVIMGDAgXn/99fx2Vs8I1LnA6aefHieffHIsXLiwWYkdd9wxbrnllujfv3+z6y0kQCD/Auedd1586Utfyjp6zjnnxPHHH5//TushAQKZgPMHDgQCBJoKTJ8+PQ455JD405/+1HTxMvOf+tSn4tprr82C4WVWeEGgTAIC4DJBqqb2BdLJmvSmW/xOxMEHHxyjR4+Orl27xvjx4+OSSy7JTvZ06dIlLrvssjj00ENrv9N6QIBAiwJXXXVVHHbYYaX16Zv86c4Aw4YNixdeeCGuu+66mDhxYrY+fYPvkUceiXQVkIkAgfoRSF8YGzNmTPZ3Quq1ALh+xl5P608gXeH7+c9/Put4t27dIn1WSIHv1KlT4+abb44nn3wyW7flllvGXXfdFYMHD64/JD0mUOcCV199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ffv2zTq0ZMmSUvibTvCkW0WncPjII4+s/Q7rAQECzQo888wzzS63kAABAgQIEKhfgfQoiPQomJNPPrn0WIh0xW9x2nLLLeOWW27JTvIUl/lNgAABAgQI5FvA+YN8j6/eEVgdgS9+8Yvx5JNPRgp4i1PT8DfdJjrdYfSuu+7y7N8ikN9lF2go3GP8/ZuMl71qFRKoXYEU/L744ovZrZ/nzp0bm2++eWy00UaRQmATAQIECBAgQIAAAQL1LTBlypR4/PHHo3v37tnnhBEjRmS3f65vFb0nQIAAAQIECBAgQGB5gVmzZmUXlU2ePDl7PnDKGj70oQ8tX8xrAmUXEACXnVSFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQqI6AW0BXx91eCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUHYBAXDZSVVIgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6ggIgKvjbq8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAou4AAuOykKiRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB1BATA1XG3VwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJRdQABcdlIVEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDoCAuDquNsrAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEyi4gAC47qQoJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQHQEBcHXc7ZUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJlFxAAl51UhQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiOgAC4Ou72SoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgbILCIDLTqpCAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVEdAAFwdd3slQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA2QUEwGUnVSEBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqIyAAro67vRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDsAgLgspOqkAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtUREABXx91eCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUHYBAXDZSVVIgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6ggIgKvjbq8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAou4AAuOykKiRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB1BATA1XG3VwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJRdQABcdlIVEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDoCAuDquNsrAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEyi4gAC47qQoJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQHQEBcHXc7ZUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJlFxAAl51UhQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiOgAC4Ou72SoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgbILCIDLTqpCAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVEdAAFwdd3slQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA2QUEwGUnVSEBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqIyAAro67vRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDsAgLgspOqkAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtUREABXx91eCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUHYBAXDZSVVIgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6ggIgKvjbq8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAou4AAuOykKiRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB1BATA1XG3VwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJRdQABcdlIVEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDoCAuDquNsrAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEyi4gAC47qQoJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQHQEBcHXc7ZUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJlFxAAl51UhQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKiOgAC4Ou72SoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgbILCIDLTqpCAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVEdAAFwdd3slQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA2QUEwGUnVSEBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgSqIyAAro67vRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDsAgLgspOqkAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAtUREABXx91eCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUHYBAXDZSVVIgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB6ggIgKvjbq8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAou4AAuOykKiRAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB1BATA1XG3VwIECBAgQIAAAQIECBCoQYHFixfHlltuGUOGDMl+xo4dW4O90GQCBAgQIECAAAECBAgQyLNAw9LClOcO6hsBAgQIECBAgAABAgQIECiXwK233hp77713qbrGxsZ46aWXYq211iotM0OAAAECBAgQIECAAAECBKop4ArgaurbNwECBAgQIECAAAECBAjUlMCll16atXfAgAHZ70WLFsVFF11UU33QWAIECBAgQIAAAQIECBDIt4AAON/jq3cECBAgQIAAAQIECBAgUCaB119/PW688castqOPPjpGjBiRzV988cWRgmATAQIECBAgQIAAAQIECBDoCAIC4I4wCtpAgAABAgQIECBAgAABAh1e4IorroiFCxdm7dxzzz1j//33z+ZfffXVuOmmmzp8+zWQAAECBAgQIECAAAECBOpDwDOA62Oc9ZIAAQIECBAgQIAAAQIEVlNgyy23jAkTJkTv3r3jjTfeiKeffjq23XbbrNZPfvKTceedd67mHmxOgAABAgQIECBAgAABAgRWX0AAvPqGaiBAgAABAgQIECBAgACBnAuMHz8+tt9++6yX++23X1x33XXZ/Oabbx4TJ06MhoaGmDRpUowcObJNEvPnz490RfE111wTkydPjgULFmT1f/SjH43//M//zELmE044Id57773Ybrvt4qijjmqx3ieeeCJ+97vfRfr95JNPRteuXWPrrbfOftKtqocMGdLitlYQIECAAAECBAgQIECAQP4EBMD5G1M9IkCAAAECBAgQIECAAIEyC6RQ9sILL8xqTaHtwQcfnM2fdtpp8c1vfjOb/9rXvhann356q3tOQfEee+wRU6ZMabZsCpXTs4bT1cVvv/12HHLIIfHrX//6X8ouWbIkfvKTn8Qpp5xSujX18oUGDRoUF110UXzmM59ZfpXXBAgQIECAAAECBAgQIJBTAQFwTgdWtwgQIECAAAECBAgQIECgPAJz586NoUOHxqxZs6Jfv37x2muvRbdu3bLKp02bFuuss04sXrw4BgwYEK+88kppXXN7//vf/55d0Ttz5sxs9frrrx+f/vSnY8MNN4ynnnoqrr/++pg+fXpW1zvvvJNdGdxSALz33nvHrbfemtXTvXv3+OxnP5td9Ttv3rx4+OGHs7oWLVqUrT/jjDPiq1/9anNNsowAAQIECBAgQIAAAQIEcibQmLP+6A4BAgQIECBAgAABAgQIECirwO9///ss/E2Vpit/i+Fvej1s2LDYbbfd4rbbbsueC/zb3/42Dj/88LSq2SmFsMXwd//9949f/epX0atXr1LZU089NQ466KC49957S8uWLl1ami/OpKuQi+HvVlttFWm/KURuOqU6DjzwwJgxY0Z85zvfydqe2msiQIAAAQIECBAgQIAAgXwLdMp39/SOAAECBAgQIECAAAECBAisnsAll1xSquCII44ozRdnmi47//zzi4v/5Xd6Pu8f/vCHbPnaa68dV1999TLhb1oxePDg7Mrdvn37/sv2xQXpucAnnXRS9jJd+fub3/zmX8LftHLnnXfOnjOc5ufMmRPf+MY30qyJAAECBAgQIECAAAECBHIuIADO+QDrHgECBAgQIECAAAECBAisusCLL74Yf/7zn7MKNt544xg1atS/VJaer9u/f/9s+YMPPhgp6G1uKoa/ad23v/3t6Nq1a3PFsrpOPPHEZtelhTfddFNMnTo1W5+uNt5oo41aLJuuTk7PFE5Teo7wggULWixrBQECBAgQIECAAAECBAjkQ0AAnI9x1AsCBAgQIECAAAECBAgQqIDAuHHjongL5qZX+jbdVQpy0/N3i9MFF1xQnF3m9z333FN6PXr06NJ8czNjxoxpbnG2bNKkSaV1O+20U2m+pZntt98+W5WeUzxlypSWillOgAABAgQIECBAgAABAjkR8AzgnAykbhAgQIAAAQIECBAgQIBAeQWWLFkSl112WanSdOvllsLdTp3++f3qK6+8Mn76059G7969S9ummVdffbX0et111y3NNzez3nrrNbc4W/b888+X1qUrhU8++eTS6+ZmZs+eXVqctk1XMpsIECBAgAABAgQIECBAIL8CAuD8jq2eESBAgAABAgQIECBAgMBqCNx5553xyiuvlGr4wQ9+UJpf0cy7774bKQQ+7rjjlin2xhtvZK979eoV6dm9K5rSs4AbGhpKVx83LfvCCy+UXs6cObM035aZyZMnt6WYMgQIECBAgAABAgQIECBQwwIC4BoePE0nQIAAAQIECBAgQIAAgcoJXHrppatcebpSePkAeNiwYTFr1qxIAXH6SUFwS1MKdou3nl6+TM+ePUuLTjnllBgwYEDpdWszbblldGt1WE+AAAECBAgQIECAAAECHVtAANyxx0frCBAgQIAAAQIECBAgQKAKAulq3RtuuCHbc7du3SLdOnlFgW0q+Oabb8Ymm2wSCxcujKeeeioeeOCB+OhHP1pq/YYbbhjPPvts9nrq1Kmx6aabltYtP/Pyyy8vv6j0eqONNoq77747e52e77vnnnuW1pkhQIAAAQIECBAgQIAAAQL/fEgRCwIECBAgQIAAAQIECBAgQCATSLdwXrBgQTb/qU99KoYPHx79+vVb4c/6668f++yzT0nw/PPPL82nmabP3r3//vuXWbf8ixQetzSlALg4PfbYY8XZFn8//vjj8dBDD8X06dNbvKq4xY2tIECAAAECBAgQIECAAIGaExAA19yQaTABAgQIECBAgAABAgQIVFqg6e2fDz/88Dbv7qijjiqV/e1vfxuvv/566fXnP//56Ny5c/b6xz/+cSxatKi0runMvHnz4rTTTmu6aJn5UaNGlV6fd9558c4775ReLz8zd+7c7ArhtM2QIUNKVyAvX85rAgQIECBAgAABAgQIEMiPgAA4P2OpJwQIECBAgAABAgQIECBQBoFHH300u4VzqmrgwIGxxx57tLnWVDY96zdN8+fPj3HjxpW2TbeHPuyww7LXL774YhxzzDGRwt6mU3o28NixY2PatGlNFy8zv8MOO8SBBx6YLUvlTjjhhFi8ePEyZYovTjrppOzK3/R6zJgxsdlmmxVX+U2AAAECBAgQIECAAAECORUQAOd0YHWLAAECBAgQIECAAAECBFZN4JJLLiltePDBB0eXLl1Kr1ubSVf4fu5znysV++Uvf7nMbZdPOeWUGDx4cLb+sssui2222Sa++c1vZkHx17/+9dh6660jXTnc2NhYqqOhoaE0X5z5+c9/Hj169MheXnzxxTF69Oj405/+FLNnz87C4KeffjoOPfTQOPfcc7MyqeyPfvSj4uZ+EyBAgAABAgQIECBAgECOBRqWFqYc90/XCBAgQIAAAQIECBAgQIBAmwXSFblDhw6Nt99+O9vmr3/9a6QrbldmeuGFF2LDDTcsbXLHHXfEbrvtVnr9yiuvxL777hvpSuPmphQCf+Mb34jPfvaz2ep0W+kU8i4/3XPPPXHkkUfGyy+/XFqVwuIUQje9vXQKsG+88caVupK5VKEZAgQIECBAgAABAgQIEKg5AVcA19yQaTABAgQIECBAgAABAgQIVErguuuuK4W/G2200UqHv6ldI0eOjJ133rnUxPPPP780n2aGDx8e9913X5xxxhlxyCGHZOXXXHPN2H333eOHP/xhPPDAA1mZ4kZ9+/Ytzi7z+xOf+ERMmDAhjj322Ojfv3+2Ln3Huxj+piA43U76mWeeEf4uI+cFAQIECBAgQIAAAQIE8i3gCuB8j6/eESBAgAABAgQIECBAgEANCtxyyy2xzz77ZC0/9dRT47vf/W6rvUjPA06B8Jw5c2L99dfPfnr37t3qdgoQIECAAAECBAgQIECAQL4E/vlQoXz1S28IECBAgAABAgQIECBAgECHEhg/fnzcfvvtka4s3mWXXUrPAm6ukY888khp8SabbFKaX9HMsGHDIv2YCBAgQIAAAQIECBAgQKC+BVwBXN/jr/cECBAgQIAAAQIECBAg0E4CKQDefvvts72lq3tvuummZvecniH84Q9/OObOnRudOnWKGTNmxIABA5otayEBAgQIECBAgAABAgQIEFhewDOAlxfxmgABAgQIECBAgAABAgQIVEBgs802i27dumU133zzzTFu3LiYNWvWMnt67bXX4ogjjsjC37Riv/32E/4uI+QFAQIECBAgQIAAAQIECLQm4Arg1oSsJ0CAAAECBAgQIECAAAECZRK4/PLL43Of+1yptsbGxthhhx1ixIgRMXXq1HjwwQdjwYIF2fr11lsv0lXDAwcOLJU3Q4AAAQIECBAgQIAAAQIEWhMQALcmZD0BAgQIECBAgAABAgQIECijwHnnnRff//73Y/r06c3W2tDQEAcccED88pe/jP79+zdbxkICBAgQIECAAAECBAgQINCSgAC4JRnLCRAgQIAAAQIECBAgQIBAhQTmzZsXv/3tb2PixInx97//Pd59990YOnRojBw5Mg466KBYd911K7Rn1RIgQIAAAQIECBAgQIBA3gUEwHkfYf0jQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBuBDrVTU91lAABAgQIECBAgAABAgQIECBAgMD/b8+OCQAAABCE9W9tD1wE5wkBAgQIECBAgAABAnEBATh+sHkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPwICMA/X1tKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBcQACOH2weAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI/AgLwz9eWEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAQFxCA4webR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAj4AA/PO1pQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIxAUE4PjB5hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg8CMgAP98bSkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnEBATh+sHkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPwICMA/X1tKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBcQACOH2weAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI/AgLwz9eWEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAQFxCA4webR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAj4AA/PO1pQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIxAUE4PjB5hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg8CMgAP98bSkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnEBATh+sHkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPwICMA/X1tKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBcQACOH2weAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI/AgLwz9eWEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAQFxCA4webR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAj4AA/PO1pQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIxAUE4PjB5hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg8CMgAP98bSkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnEBATh+sHkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPwICMA/X1tKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBcQACOH2weAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI/AgLwz9eWEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAQFxCA4webR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAj4AA/PO1pQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIxAUE4PjB5hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg8CMgAP98bSkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnEBATh+sHkECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPwICMA/X1tKgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBcQACOH2weAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI/AgLwz9eWEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAQFxCA4webR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAj4AA/PO1pQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIxAUE4PjB5hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg8CMgAP98bSkBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnGBAQR0I4KIY+G/AAAAAElFTkSuQmCC">
<h3 id="predictionmodeltopic-10">Added bonus let’s visualize the Decsion Trees</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
However we need to take the feature scaling out so we can read the splits :D

dataset = read.csv('Social_Network_Ads.csv')
dataset = dataset[3:5]
dataset$Purchased = factor(dataset$Purchased, levels = c(0, 1))

# install.packages('caTools')
library(caTools)
set.seed(123)

split = sample.split(dataset$Purchased, SplitRatio = 0.75)
training_set = subset(dataset, split == TRUE)
test_set = subset(dataset, split == FALSE)

# install.packages('rpart')
library(randomForest)
classifier = randomForest(x = training_set[-3],

y = training_set$Purchased,
ntree = 500, random_state = 0)
Plotting the tree; hmm… not sure what to make of that, it’s interesting.

plot(classifier)
<img class="lazy" data-src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAVACAYAAACp1UVbAAAEGWlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPrtzZyMkzlNsNIV0qD8NJQ2TVjShtLp/3d02bpZJNtoi6GT27s6Yyc44M7v9oU9FUHwx6psUxL+3gCAo9Q/bPrQvlQol2tQgKD60+INQ6Ium65k7M5lpurHeZe58853vnnvuuWfvBei5qliWkRQBFpquLRcy4nOHj4g9K5CEh6AXBqFXUR0rXalMAjZPC3e1W99Dwntf2dXd/p+tt0YdFSBxH2Kz5qgLiI8B8KdVy3YBevqRHz/qWh72Yui3MUDEL3q44WPXw3M+fo1pZuQs4tOIBVVTaoiXEI/MxfhGDPsxsNZfoE1q66ro5aJim3XdoLFw72H+n23BaIXzbcOnz5mfPoTvYVz7KzUl5+FRxEuqkp9G/Ajia219thzg25abkRE/BpDc3pqvphHvRFys2weqvp+krbWKIX7nhDbzLOItiM8358pTwdirqpPFnMF2xLc1WvLyOwTAibpbmvHHcvttU57y5+XqNZrLe3lE/Pq8eUj2fXKfOe3pfOjzhJYtB/yll5SDFcSDiH+hRkH25+L+sdxKEAMZahrlSX8ukqMOWy/jXW2m6M9LDBc31B9LFuv6gVKg/0Szi3KAr1kGq1GMjU/aLbnq6/lRxc4XfJ98hTargX++DbMJBSiYMIe9Ck1YAxFkKEAG3xbYaKmDDgYyFK0UGYpfoWYXG+fAPPI6tJnNwb7ClP7IyF+D+bjOtCpkhz6CFrIa/I6sFtNl8auFXGMTP34sNwI/JhkgEtmDz14ySfaRcTIBInmKPE32kxyyE2Tv+thKbEVePDfW/byMM1Kmm0XdObS7oGD/MypMXFPXrCwOtoYjyyn7BV29/MZfsVzpLDdRtuIZnbpXzvlf+ev8MvYr/Gqk4H/kV/G3csdazLuyTMPsbFhzd1UabQbjFvDRmcWJxR3zcfHkVw9GfpbJmeev9F08WW8uDkaslwX6avlWGU6NRKz0g/SHtCy9J30o/ca9zX3Kfc19zn3BXQKRO8ud477hLnAfc1/G9mrzGlrfexZ5GLdn6ZZrrEohI2wVHhZywjbhUWEy8icMCGNCUdiBlq3r+xafL549HQ5jH+an+1y+LlYBifuxAvRN/lVVVOlwlCkdVm9NOL5BE4wkQ2SMlDZU97hX86EilU/lUmkQUztTE6mx1EEPh7OmdqBtAvv8HdWpbrJS6tJj3n0CWdM6busNzRV3S9KTYhqvNiqWmuroiKgYhshMjmhTh9ptWhsF7970j/SbMrsPE1suR5z7DMC+P/Hs+y7ijrQAlhyAgccjbhjPygfeBTjzhNqy28EdkUh8C+DU9+z2v/oyeH791OncxHOs5y2AtTc7nb/f73TWPkD/qwBnjX8BoJ98VQNcC+8AAEAASURBVHgB7N15fB9VvT/+d9KkCy0tUEpXtrIjtCCbylJRQAQEFEH0etlUZLteZPsh4sJF9IoCyiYoP5VivYBwL4iICIJUtCBLgUKBspalpYXutEmTNPn2DORjkk/Spm3SfJbn8IifmTNnzpzzPOMfPF7MmYqm5VvYCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDoBSqLfgQGQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKZgADYg0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESERAAl8hEGgYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQEwJ4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlIiAALhEJtIwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIAD2DBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBEBATAJTKRhkGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEBsGeAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJSIgAC6RiTQMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQICIA9AwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECgRAQFwiUykYRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAA7BkgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAiQgIgEtkIg2DAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAmDPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEpEQABcIhNpGAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAAewYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQIgIC4BKZSMMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQICAANgzQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRIREACXyEQaBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBATAngECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUiIAAuEQm0jAIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECAgAPYMECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoEQEBMAlMpGGQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQGwZ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlIiAALpGJNAwCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgIgD0DBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKBEBAXCJTKRhECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAQADsGSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgECJCAiAS2QiDYMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQICYM8AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESkRAAFwiE2kYBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQEAB7BggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAiAgLgEplIwyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgIAA2DNAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEhEQAJfIRBoGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEBMCeAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJSIgAC4RCbSMAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQICAA9gwQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgRAQEwCUykYZBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAbBngAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUiIAAukYk0DAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAiAPQMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoEQEBcIlMpGEQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBAAOwZIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQIkICIBLZCINgwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgJgzwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKREAAXCITaRgECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQAHsGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUCICAuASmUjDIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgADYM0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESERAAl8hEGgYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQEwJ4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlIiAALhEJtIwCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgIAD2DBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBEBATAJTKRhkGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEBsGeAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECJSIgAC6RiTQMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQICIA9AwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECgRAQFwiUykYRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAA7BkgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAiQgIgEtkIg2DAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECAmDPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEpEQABcIhNpGAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEBAAewYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQIgJVJTIOwyBAgAABAgQIECBAgACBEhF47bXXYvz48Xmj+cY3vhG9evXKKy/ngtWxWrx4cdx7773x8MMPZ3/PPPNMjBw5MrbZZpvsb+zYsXH44YfH6rRdznNh7AQIECBAgAABAgQIECgUgYqm5VuhdEY/CBAgQIAAAQIECBAgQIDAxIkTY9y4cXkQS5cujd69e+eVl3PBqlo9++yzWbg7bdq0Dtn23nvvSO2uatsdNugEAQIECBAgQIAAAQIECKxVAUtAr1VuNyNAgAABAgQIECBAgAABAj0jUFdXF5/97GdjReFv6tnOO+/cMx10VwIECBAgQIAAAQIECBDoEgEBcJcwaoQAAQIECBAgQIAAAQIECBS2wIMPPhhTp05daSc/+MEPrrSOCgQIECBAgAABAgQIECBQuAK+AVy4c6NnBAgQIECAAAECBAgQIECgywQmTZrUblvnnntuHHnkkVFVVRWvvvpq7LHHHu3WU0iAAAECBAgQIECAAAECxSEgAC6OedJLAgQIECBAgAABAgQIECCQJ7D11lvHddddl1eewty22zvvvNO2KHbbbbf4wQ9+kCsfM2ZMbn9V2s5dZIcAAQIECBAgQIAAAQIEelwg/98Ie7xLOkCAAAECBAgQIECAAAECBAh0RmDYsGHxpS99qTNVY+HChXn1Nttss7yy5oJVabv5Gr8ECBAgQIAAAQIECBAg0PMCAuCenwM9IECAAAECBAgQIECAQEkKzJ8/P5555pmYNWtWjBo1KjbddNPYaKONoqKiolvHu2jRopgxY0b2N3v27Ojfv39ssMEGMWTIkNhqq61W695pLK+99lpMnz49li1bFkOHDo0UkA4fPjz69u1bMG2uqCONjY15p3v37p1X1pUFdXV18fTTT8frr78e2223XWy55ZZRWVnZJbdI8/DQQw9lwfY222wTo0eP7pJ2NUKAAAECBAgQIECAAIFiFxAAF/sM6j8BAgQIECBAgAABAgQKSODJJ5+Mb33rWzF58uR444038nqWgthTTjklvva1r2WBbF6F1SxIYeDtt98eV155Zdx///0dtjJixIg4+OCD4/zzz49NNtmkw3rpxNy5c+PHP/5xXHPNNTFv3rx266YA9fDDD48TTzwxPvaxj6003O7qNlMAethhh+X1LdlXV1fHd7/73fjZz36WnW/vDeBbb7017rnnntz1J5xw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r3wl77pUkN4eTt/8TQF22625rDvabHuvnj7ef//9Iy2x3XJbuHBhXHrppS2LcvspiB83blxsscUWMWDAgNh1112z7zg//PDDuTod7XQU2HdUXzkBAgQIECBAgAABAgTKUUAAXI6zbswECBAgQIAAAQIECBDoIoEf/OAH0adPn1atpdAzhae/+93vYsmSJdm59HvBBRfE1Vdf3apuOvj3f//3WJ03O1OA2HabOHFiPPHEE22L41vf+lb8/e9/zytvuSx06sO2224b6U3dltuDDz4Y48ePb1mU20/fB54xY0buuHmnORjvjjab71EovykwP/HEE/O6c+GFF8aECRNaldfU1ET6RnJz8J6ei7Rc9q233hrtLSXd6mIHBAgQIECAAAECBAgQINApAR/P6RSTSgQIECBAgAABAgQIECDQnkAKYc8666y46KKLWp1O38E96qijsmB3+PDhMXPmzEjBcNtt0KBBcdJJJ7Ut7tTxBz/4wbx6KVj86Ec/mvUpvVWcvkeclqTu6O3SuXPnZmFk+i5v2k4//fQspG5oaGjV9rHHHpst97zXXnvFRhttlC0n/eijj8Ztt93Wql46SEtbjxo1KlfeHW3mGi+QnfQMpHC/OdhN3Urh7he/+MW44oorYvfdd8+C8rvuuiv3HwW07HpaVju52ggQIECAAAECBAgQIEBgzQUEwGtuqAUCBAgQIECAAAECBAiUtcB5552XvcHZ/K3clhgp9H3jjTdaFuX2q6qq4pZbbonNNtssV7YqOynoTUsJP/DAA60uW7BgQfbGb6vC9w9S0NsypEzfoE3LVadv+6YtvYV64403xtFHHx1tQ+A777wz0t+KtrT080033dSqSne02eoGBXCQvgV91VVXtbtcdgrfOwrgU9f33nvvOP/88wtgFLpAgAABAgQIECBAgACB0hCwBHRpzKNRECBAgAABAgQIECBAoMcE0vdf09uwp5xySnT2G63p26/XXXdd7Lfffqvd7/QN3rQ085AhQ1baRnoj9+67747Pfe5zeXXbBrZHHHFEFuL2798/r+6KCrbbbru4/fbbY9iwYXnVuqPNvJv0cEFa2vnaa6/N+x7wirq17777RnorOD0PNgIECBAgQIAAAQIECBDoGgEBcNc4aoUAAQIECBAgQIAAAQJlLZDC0vQG6J///OfYdddd874L3IyTwuKzzz47XnnllUjLKq/ptskmm0R68zgtI50C4bbbwIED4/jjj48pU6bEAQccEJ/5zGfaVonf/va3kd4EbrmleunN5R/+8IetlnNuWad5f/To0fHrX/86u0cae0dbd7TZ0b16qjx9Czi9UZ3mdv311++wG2lJ6PT297333hurGrR32KgTBAgQIECAAAECBAgQIJAJVCz/l9zW/5YLhgABAgQIECBAgAABAgQIrKFAWvr5hRdeyELRefPmZUsrp6WQN91006iurl7D1tu/PN0nhcHPP/989O3bN3bZZZfYcsstO/1WcvutRjQ2Nsabb76ZfU84fVP4nXfeibTUc1q6Ov2tKOhcm212dK+eKk9LaKc3w1OQPnv27CzoTc9AMkvBvY0AAQIECBAgQIAAAQIEukdAANw9rlolQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAWhfIXx9rrXfBDQkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgKwQEwF2hqA0CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgUgIAAuAAmQRcIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQFQIC4K5Q1AYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQKQEAAXACToAsECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoCgEBcFcoaoMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIFICAALoBJ0AUCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0hYAAuCsUtUGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIECEBAAF8Ak6AIBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6QkAA3BWK2iBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEABCAiAC2ASdIEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJdISAA7gpFbRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAABATABTAJukCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGuEBAAd4WiNggQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAAAgLgApgEXSBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBXCAiAu0JRGwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECgAAQFwAUyCLhAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKArBATAXaGoDQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBSAgAC4ACZBFwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQINAVAgLgrlDUBgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBApAQABcAJOgCwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOgKAQFwVyhqgwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgUgIAAugEnQBQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHSFgAC4KxS1QYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgQIQEAAXwCToAgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBLpCQADcFYraIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQAEICIALYBJ0gQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAl0hIADuCkVtECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAAEBMAFMAm6QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAga4QEAB3haI2CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUAACAuACmARdIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQFcICIC7QlEbBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKAABAXABTIIuECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoCsEBMBdoagNAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIFICAALgAJkEXCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0BUCAuCuUNQGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECkBAAFwAk6ALBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6AoBAXBXKGqDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBSAgAC6ASdAFAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdIWAALgrFLVBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBAhAQABfAJOgCAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEukJAANwVitogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAAQgIgAtgEnSBAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECXSEgAO4KRW0QIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgAAQEwAUwCbpAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBrhAQAHeFojYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQAAJVBdAHXWghsHjx4njmmWdiypQpMWfOnNhqq61i2223ja233jp69erVoqZdAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQItBYQALf26PKj++67L5566qms3RNPPDHWWWeddu9RV1cX3//+97O/+vr6vDrbbLNN/PCHP4zDDjss75wCAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIJIGKpuUbiu4TOPnkk+Oaa67JbjBz5swYNmxY3s2mT58ehxxySDz99NN559oWHHTQQXH77bdHVZXsvq2NYwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLlLiBF7OEnIOXvxx13XKvwd+edd46xY8fGJptsEikcnjp1ajzyyCNZT//4xz/GGWecEZdffnkP99ztCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoNAEBcA/PyJVXXhl//etfs16kt4Ovvvrq+PSnP53Xq/vvvz9OPfXUePbZZ+OKK66IXXbZJY499ti8egoIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChfgcryHXphjPyGG27IOlJRURE333xzu+FvqrDvvvtmQXHzEtKXXnppYQxALwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKBgBAXAPTsWyZctiypQpWQ+OOuqo2HvvvVfYm4022ih+8pOfZHXSstA1NTUrrO8kAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLlJSAA7sH5fvXVV6O2tjbrwe67796pnqQ3gdPW0NAQTzzxRKeuUYkAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgfIQEAD34DwPHTo00tLPaUtv93ZmGzJkSPTt2zerOn369M5cog4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAmUiIADuwYkeMGBAbLLJJlkPJk2a1KmetHxreIsttujUNSoRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAeAgLgtTjPTz75ZG7J5+bbfuUrX8l277vvvmhqamou7vD3kksuyZ3bZpttcvt2CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIVg7QkceOCBUVVVFR/4wAdil112iV133TU+9KEPxcCBA+O5556Ls846K1oGvC17lsLhyy67LH72s59lxelbwOk6GwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBJoFKpYHiyt/7bS5tt9VFjjllFNyoW1nLr7++uvjmGOOyVWdM2dOXHnllXH77bfH5MmTs/JevXrF448/HmPGjMnVs0OAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAFvAHfzM5DC26997WtZePvEE09E89/s2bPbvXN9fX2r8jfeeCO++93v5soqKirie9/7nvA3J2KHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFmAW8AN0us5d8ZM2bkwuAUCqe3e1966aW4995742Mf+1iuNzNnzowRI0Zkx4MHD47x48fHQQcdlDtvhwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAs0CAuBmiQL4XbRoUfTu3Tv69OmT601DQ0N885vfjP333z/22muv6Nu3b+5cMe689tpr2ZLWbd90Lsax6DMBAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDXCgwaNCjOPvvs6N+/f9c2XEatCYDLaLILYajnnHNO/OhHPyqErugDAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAAQrceOON8bnPfa4Ae1YcXfIN4OKYp5LpZfObv4cffniMGzeuZMZlIAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAmsm8Jvf/CYee+yxaM6T1qy18r1aANxDc7906dJWSz13thtz5syJmpqarPqoUaM6e1nB1Uvh7+mnn15w/dIhAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBnhFI4W/6s62ZQOWaXe7qVRG45ZZb4pOf/GQMHTo0+vXrF9ttt10cc8wx8fe//73TzRx33HGx8cYbZ3+dvkhFAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTKQkAAvBamefHixXHsscfGkUceGX/6059i9uzZ0dTUFM8991zccMMNsc8++8QZZ5yRe7N3LXTJLQgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKEEBAfBamNTzzjsvxo8fn7tT//79Y/PNN4+KioqsrLGxMS677LLYaaed4pVXXsnVs0OAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFVERAAr4rWatR94okn4qqrrsquTEs/33777bFw4cJ4+eWXY968eXHxxRfHoEGDsvPTpk2Lj370o0Lg1XB2CQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECEQLgbn4Kfvazn8WyZcuiqqoq7r777jj00EOjsvI99hT8nn322fHss8/G2LFjs5689tpr8fGPfzxmzZrVzT3TPAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECpSYgAO7mGU3hbtq+8IUv5ELetrccPnx4TJw4McaNG5edSstAH3zwwZG+HWwjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAZwUEwJ2VWs16zz//fHblLrvsssIWBg4cGHfddVd8+MMfzuo99thjcdRRR2VvD6/wQicJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDwvoAAuJsfhbq6uuwO66yzzkrv1K9fv/j9738fW265ZVb3j3/8Y/zHf/zHSq9TgQABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAklAANzNz8FWW22V3WHq1KmdutOGG24Yf/rTn2LIkCFZ/fQN4UsvvbRT16pEgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB5CwiAu3n+mwPgCRMmxNy5czt1ty222CJ7Ezi9EZy2s846K8aPH9+pa7urUmNjY7Yc9bJly9boN7VjI0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgewQEwN3jmmv1C1/4QrY/e/bsSPuzZs3KnVvRzoc+9KFIoXFlZWU0NTXF8ccfHxdccEH0RIB6zjnnRK9evaKqqmqN/y6//PJs2A888MCKhu8cAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKrISAAXg20Vbnk4IMPjv322y+75O67747tttsuC3OvvPLKlTbz6U9/Oq6++uqoqKjIgt/vfve72fLQK72wiytUV1dnwW8Ko9f0r7lr77zzTvOuXwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEukhAANxFkCtq5tprr40dd9wxqzJv3rz49a9/Hddcc82KLsmd++pXvxq//OUvswA2FfbEG8AXXXRR1NfXr9HSz81LR++8887Z2NK3jm0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHStgAC4az3bbW306NHxz3/+M0499dTo379/VmfEiBHt1m2v8LjjjovJkyfH3nvv3d5pZQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEMgEBMBr6UHo27dvpGWf58+fH5MmTYqzzjprle68ww47xMSJE+P666+P9H3ggQMHrtL1KhMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUPoCVaU/xMIaYVVVVRbgrm6vjjnmmEh/NgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLQV8AZwWxHHBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKFIBAXCRTpxuEyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoK2AJaDbihTwcX19fcyaNSvXw1GjRuX27RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEAAXETPwFNPPRW77rprrsdNTU25fTsECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCwBLRngAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUiIAAukYk0DAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFgCuoiegbFjx8Zbb71VRD3WVQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE1qaAAHhtaq/hvaqqqmLo0KFr2IrLCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoVQFLQJfqzBoXAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJlJyAALrspN2ACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEpVwBLQPTyzM2bMiLlz58aSJUuyv759+8agQYNi4MCBMXjw4EjHNgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHRGQADcGaUurLNo0aIYP358TJgwIZ5++ulIxx1t6Zu/O+64Y+yxxx5xyCGHxEEHHRQVFRUdVVdOgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgECZC1gCei09ALNmzYpTTz01Ro4cGaeddlpMmjRpheFv6lZDQ0NMnjw5rrnmmiwAHjNmTNx5551rqcduQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAsQl4A3gtzNi8efNi//33jylTpuTult7kHT58eGyyySYxZMiQ6NevX/Tp0ycLfWtra2PhwoXx+uuvx/Tp02Pp0qXZdemN4UMPPTQuueSSOP3003Nt2SFAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEASEAB383OwePHiOPjgg3Ph72677RZnnHFGfPzjH8+C35Xdvr6+Pv75z39my0b/6le/inT89a9/PbbeeutsSeiVXe88AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLlI2AJ6G6e65tvvjlb7jnd5uijj46HHnoo+01v/XZmq66ujj333DOuvfbauO222yIdp+3cc8+NxsbGzjShDgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECZSIgAO7mif7HP/6R3SF9v3f8+PFRWbn65AcddFD8+Mc/ztpLy0m/8sor3dx7zRMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUEwCq59GFtMoe7Cvf//737O7f+pTn8q9vbsm3TniiCNyl0+bNi23b6e0BW55+zfxiSm7x+tLXy3tgRodAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAGgkIgNeIb+UXv/HGG1mljTfeeOWVO1Fj8ODBuSC5pqamE1eoUgoC986/M55eMjkef/efpTAcYyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOgmAQFwN8E2N7vFFltku5MmTWouWqPftKR0fX191sbOO++8Rm25uHgEqit6Z51taHpv7oun53pKgAABAgQIECBAgAABAgQIECBAgAABAgQIECCwNgUEwN2svcsuu2R3uOmmm+KBBx5Yo7vNnz8/zjzzzKyNDTbYIDbffPM1as/FxSMwuHpI1tkBlesWT6f1lAABAgQIECBAgAABAgQIECBAgAABAgQIECBAYK0LCIC7mfwb3/hGtmRzbW1tHHbYYXHttddGXV3dKt/1iSeeiAMOOCDSb9pOOumkVW7DBcUrcM6oC+J3290bB6z/qeIdhJ4TIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0u0BVt9+hzG+QloD+/ve/H2effXYsWLAgC27T/rhx42KnnXbK3uIdOnRo9OvXL/r27RsNDQ2RwuKFCxfG66+/Hi+++GJMnDgxnn766ZxkCoIvvPDC3LGd0hdYp1f/+MjAcaU/UCMkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBYIwEB8Brxde7is846KwYPHhynnnpq1NTUxKJFi+IPf/hD9te5Fv5V68ADD4wJEyZEZaWXt/+lYo8AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSQgRVxLz8Hxxx8f06dPj/POOy+GDRu2Snft06dPtnz0HXfcEXfddVek7//aCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0FbAG8BtRbrxeMiQIXHRRRdlf6+++mo89NBD8cILL2TLPaflodObwdXV1TFgwIAYOHBgpOWjt99++xg7dmxW1o1d03SBC7xQ82y8Uz87PmwZ6AKfKd0jQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECPSsgAC4h/w322yzSH82Ap0R+PK0o+Kl2udjyi5vxfpV3gDvjJk6BAgQIECAAAECBAgQIECAAAECBAgQIECAAIFyFLAEdDnOujEXncC8hjnRtPyf15e+UnR912ECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIG1JyAAXnvW7kRgtQXqm+qya/809/er3YYLCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESl9AAFz6c2yEJSCwbq9B2Sjq3g+CS2BIhkCAAAECBAgQIECAAAECBAgQIECAAAECBAgQINANAgLgbkDVJIGuFjh+6ClZkw1N9V3dtPYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRKSEAAXEKTaSilK7DLunvE+lUbxM4Ddi/dQRoZAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAGgtUrXELGiBAoNsFdl93r3h6l1ndfh83IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKG4BbwAX9/zpPQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBHICAuAchR0CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgUt4AAuLjnT+8JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCQExAA5yjsEChMgYamhjjnlZPjxrd/XZgd1CsCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGCERAAF8xU6AiB9gVerpkWE2ZfF9fNvLz9CkoJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIvC8gAPYoEChwgdqmmqyHz9ZMicve/F6B91b3CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEelJAANyT+u5NoBMCdY11uVqPLpqU27dDgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoK2AALitiGMCBSYwuu9WsWmf0Vmvli3/HrCNAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQEcCAuCOZJQTKBCBDao3jMtGX5f1pimaCqRXukGAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFCIAlWF2Cl9IkCgtcBOA3aPE4edHvuu94nWJxwRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaCEgAG6BYZdAoQr0qewT39n0R4XaPf0iQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoEAFLQBfIROgGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE1lRAALymgq4nQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAgQgIgAtkInSDwIoE6hvrV3TaOQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKZgADYg0CgwAX+Ov/PMfqRAXHT29cXeE91jwABAgQIECBAgAABAgQIECBAgAABAgQIECBAoKcFBMA9PQPuT2AlAlOXPBmNy//507zb49Xal1ZS22kCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFyFhAAl/PsG3tRCCxtWpr188/z7ohjnz+8KPqskwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAj0jIADuGXd3JdBpgcamxlzd+Q1zc/t2CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLQVEAC3FXFMoMAEjh5yXBy70UlZrxqa6gusd7pDgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQSAIC4EKaDX0h0I7AyD6bxHc2/XH0regbA3oNbKeGIgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLvCVSBIECg8AX6VPaJu3Z4OPpW9iv8zuohAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAjwkIgHuM3o0JrJrA1utsv2oXqE2AAAECBAgQIECAAAECBAgQIECAAAECBAgQIFB2ApaALrspN2ACBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBEpVQABcqjNrXAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlJ2AALjsptyAi01gxtI34u65vy+2busvAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBADwgIgHsA3S0JrIrA+dP/M0544Yh4dNGkVblMXQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgTIUEACX4aQbcnEJLGiYn3X4V7Oujh++/u3i6rzeEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIrFWBqrV6NzcjQGCVBeqalmbX3Dbnxuz3K8P+MzaoHrzK7biAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECg9AW8AVz6c2yERS4wqNd6UbH8n+qK6mwkzYFwkQ9L9wkQIECAAAECBAgQIECAAAECBAgQIECAAAECBLpBQADcDaiaJNCVAldt+Zu4f8yTMaR6WNbssqaGrmxeWwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAiUkYAnoEppMQylNgUFV60X622vgvjF58SMxuHqj0hyoUREgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECKyxgAB4jQk1QGDtCFy2xf+/dm7kLgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAkUrYAnoop06HSdAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBrAQFwaw9HBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKFoBAXDRTp2OEyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoLWAALi1hyMCBSfww9e/HT9+44KC65cOESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIFJ6AALjw5kSPCOQEljUti8tn/CCumPHfuTI7BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBDoSEAB3JKOcQAEI1DUuzXpRVVEd//36t2L7R4fEG0unF0DPdIEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAQBQTAhTgr+kTgfYG6prpsr3dF73hq8WOxYNn8eLHmeT4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE2hWoardUIQECBSGwbq+Bsce6e8emfTaPOQ1vZ31qaGooiL7pBAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQOEJCIALb070iEBOoLKiMv53+/uy469MOyr7bYqm3Hk7BAgQIECl+KbLAABAAElEQVSAAAECBAgQIECAAAECBAgQIECAAAECBFoKCIBbatgnUMACJw4/PYb1HhkfGTiugHupawQIECBAgAABAgQIECBAgAABAgQIECBAgAABAj0pIADuSX33JrAKArut+5FIfzYCBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECHQlUdnRCOQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgUl4AAuLjmS28JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQoYAAuEMaJwgUhsDSxqWF0RG9IECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKHgBAXDBT5EOlrPASzXTYvtHN4zvvfaNcmYwdgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgU4KCIA7CaUagZ4QeLH2+ahtqo0Xa56NmsaauGfenVHfWN8TXXFPAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBIhAQABfBJOli+QrUN9Zlg+9d2SeunXlpHDft8LjpnV+XL4iREyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIrFBAALxCHicJ9KxAYzRmHehXuU4sWbYk259XP6dnO+XuBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBSsgAC7YqdExAhEfW+/A+I8R58bJw8+M6orqjKQhGtAQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFegqt1ShQQIFITAgF7rxrkbX5j15R8L/5r9rttrYEH0TScIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQKT0AAXHhzokcE2hU4ZuhJse06O8bu6+7Z7nmFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBATAngECRSJQVVEVHxk4rkh6q5sECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI9IeAbwD2h7p4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoBgEBcDegapIAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI9ISAA7gl19yTQSYEFDfPj/975n1jauLSTV6hGgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQzgIC4HKefWMveIGrZvwoTnvpmPjfd35b8H3VQQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZ4XEAD3/BzoAYEOBRYsm5edq2+qi7n178TXX/pSPLLo7x3Wn1U3MxqbGjs87wQBAgQIECBAgAABAgQIECBAgAABAgQIECBAgEBpCwiAS3t+ja7IBeob67IR9K7sE39beF/c/M74uH7Wte2O6qGFE+ODkzeJH79xQbvnFRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJS+gAC49OfYCItYYFDV+lnvh1ePjMrl/6QtvQ3c3vbskilZ8fyGue2dVkaAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAGAgLgMphkQyxegXM3/l78eYdHY9x6+0dVRVU2kPqm+nYHNLt+VlY+pPfQds8rJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKH0BAXDpz7ERFrFAn+VLP3+g/9hsBNuvMyaGVg+P3dfds90RLV72blY+vPeods8rJECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKH2B914pLP1xGiGBohfYtO/oePyDr3U4jpNHnBmbLa9z2ODPdVjHCQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgdIWEACX9vwaXRkJDO89Mk4YdloZjdhQCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE2gpYArqtiGMCRSzwwPx74tFFk4p4BLpOgAABAgQIECBAgAABAgQIECBAgAABAgQIECCwJgLeAF4TPdcSKCCB2sba+OLzh8QGVRvGk7u8WUA90xUCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIG1JeAN4LUl7T4EVkPg+lnXxJkvfyUamhpWenVFVETj8n8WLJu30roqECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlKaAALg059WoSkTgFzN/Gje+/et4c+lrKx1Rn8o+WZ36pvpoampaaX0VCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESk9AAFx6c2pEJSSwtKk2G01VRVUsbFgQH3x8k/j6S1/KG2FNY01cOeOHUV1RHetXDc47r4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKA8BATA5THPRlmkAnWNdVnPey9/u3d2/cyYtfzvsXcfzhvNn+fdET94/fzYd9An4v4xT0ZFRUVeHQUECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKlL1BV+kM0QgLFK7Df+gfH9NqXYnDVkHh32aJsIA3Ll3huu71V92ZWtHGfzWNI9dC2px0TIECAAAECBAgQIECAAAECBAgQIECAAAECBAiUiYAAuEwm2jCLU+CS0T/PdbxPRd9svynyv+/7dv3s7NxGvYW/OTA7BAgQIECAAAECBAgQIECAAAECBAgQIECAAIEyFBAAl+GkG3JxCozoMyrOGvWdGN1367wBDK0elpWN6b9r3jkFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC5SMgAC6fuTbSEhD4+sjz2x3FV4b/Zxw95PhYt2pgu+cVEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQIlIdAZXkM0ygJlL6A8Lf059gICRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIrExAAr0zIeQJFJPD7Ob+LY54/NOY1zC2iXusqAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVwkIgLtKUjsEukFgaePSaGxq7HTL//fOb+Mv8++KRxdN6vQ1KhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECJSOgAC4dObSSEpMYPGyd2PXyZvFcdMO7/TIqit7Z3VrG2s6fY2KBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECpSMgAC6duTSSEhOYVT8z5ja8Ey/XvJAb2bNLpsTTi5/IHbfd6VvZLyuqa1ra9pRjAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBMhAQAJfBJBticQrULV/+OW3Nb/Wm/SOf3S8Onzqu1bLQ02tfjr2f3D4mzL4uDljvU7H9OmNip/67peo2AgQIECBAgAABAgQIECBAgAABAgQIECBAgACBMhMQAJfZhBtu8Qg0RVPW2XUq++c6XbNsSdQ0LomlLd7wfXjRg/Fy7QuRfg8ZfETcs+NjsUW/rXPX2CFAgAABAgQIECBAgAABAgQIECBAgAABAgQIECgfgaryGaqREigugW377RDnbXxR7Dxgj1zHe1Us/7/s8ly4obE+4v3lnt+ufys7P6R6aK6eHQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgfIUEACX57wbdREIVFRUxKkjzmnV0w2rN4qGuvpWy0LPbZiT1dmoelirug4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgTKT0AAXH5zbsRFLHDzdn/OloDuW9k3N4pDNjgiXqt9JQ7a4NO5MjsECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLlKSAALs95N+oiFRjVZ9O8nu88YPf4xdY355UrIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKD+ByvIbshETKG2B+Q3zSnuARkeAAAECBAgQIECAAAECBAgQIECAAAECBAgQINChgAC4QxonCBSfwCOL/hE7PDY0Ln3jwuLrvB4TIECAAAECBAgQIECAAAECBAgQIECAAAECBAissYAAeI0JNUCgewTqGuvi1ncmxNz6OZ2+wYy6N6Jp+T/TaqZ2+hoVCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESkdAAFw6c2kkJSZw25wb42svHRdXzby40yPrW9E3q7u0sbbT16hIgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQOgIC4NKZSyMpMYGFy+ZnI6pvrM+N7A9zbo1vvHJapLeDm7dHF02Kd5ctyg7791o3+01vAdsIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTKT0AAXH5zbsRFIlDXuDTrae/K3rkeX/vWZTF+9rXx7JKnsrJJCx+Iw6buE9+ZfmZ2/KGBe8f5G/93nD3qgtw1dggQIECAAAECBAgQIECAAAECBAgQIECAAAECBMpHoKp8hmqkBIpLYP2qwVmHh/cemet4Zbz332zUNb0XDr9S++L7595747eqoipOHvFeGJy7yA4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgEDZCAiAy2aqDbTYBI4ecnyM6b9LbLfOjrmuV1VUZ/sNTQ3Z78JlC7Lfgb3Wy9WxQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUL4CloAu37k38gIXqKioiA/0HxuVFf/6v+meAz8aI3tvEqP7bp31vvr9QHhI9dACH43uESBAgAABAgQIECBAgAABAgQIECBAgAABAgQIrA0BbwCvDWX3INBFAmeM+lakv+btixudGBv32Tz2GbRfc5FfAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBMhYQAJfx5Bt68Qv0qewTB6x/SPEPxAgIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6ROBfa8t2SXMaIUCgpwUmLrg3Hlxwf093w/0JECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6QMAbwD2A7pYEulPg2OcPW/7d4F7x0m4Lu/M22iZAgAABAgQIECBAgAABAgQIECBAgAABAgQIEChAAW8AF+Ck6BKBJHD3vDviS9M+G3Pr56wSyLKmZVHbWBP1jfWrdJ3KBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECxS8gAC7+OTSCEhW4cfYv40/zbo/H33241QibmppaHbc96FvZLyta2lTb9pRjAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBEhcQAJf4BBte8QrULH+LN23VFdW5Qdww6+ex5SMD49FFk7KyO+bcEj98/dvRMhTeuM9msW6vgcuv6527zg4BAgQIECBAgAABAgQIECBAgAABAgQIECBAgEB5CAiAy2OejbIIBeqb3lvCuXflv4Lcp5c8EbXL3+yduuSpbEQXv/HtuHzGD+L1pa/mRvh/2/81Hhz7bPSp7JMrs0OAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFAeAlXlMUyjJFB8Ah9f78B4d9nC2KbfDrnOV73/NvCypoasbNHy82nrU9k3+03/M7BqUG7fDgECBAgQIECAAAECBAgQIECAAAECBAgQIECAQHkJeAO4vObbaItI4JQRZ8fdOz4SG1QPzvW67/tBb1O89x3gJcsWZ+fWqeyfq2OHAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgfAW8AVy+c2/kRSjw+SEnRG1jbRy8wRFZ78f0/2Ckt4DXrRpYhKPRZQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAga4WEAB3taj2CHSjwJb9tomLNvtp7g63bP+X3L4dAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABApaA9gwQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgRAQEwCUykYZBoFngT3Nvj6OfPTDeqpvRXOSXAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgTAQEwGUy0YZZfALvLlsUTU1Nq9zx38/9Xfxt4V/ioUV/W+VrXUCAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFDcAgLg4p4/vS9RgRdrno8dHxsW35r+9VUeYZ+KPtk1tY01q3ytCwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBIpbQABc3POn9yUqMK1matQ11cXMujdajbChqSHunndHpLeDO9r6VvbLTtU1Lu2oinICBAgQIECAAAECBAgQIECAAAECBAgQIECAAIESFRAAl+jEGlZxC8xvmJsNYL2q9VsN5PY5N8UJ0z4TP33zB/FizXOxw/K3hH8+8yet6hyw/qdih3V2jt3X3bNVuQMCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHSF6gq/SEaIYHiE2hevnlw1UatOl/TuCQ7TgHxlMWTY17DnHhi8aOt6uy73ici/dkIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTKT0AAXH5zbsRFIHD44M/HgmXz4+ghx7fqbVVFdXa8bPlS0EsaF2f7/SsHtKrjgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHwFBMDlO/dGXsACG1QPjq+PPD+vhxu+/0bwulWDYmljbXZ+QK918+opIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQKE8BAXB5zrtRF6nAfusfFLdt/9fsG79zly///MySp+Lzbd4SLtKh6TYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgEAXCAiAuwBREwTWpsBu6+6Z3W5kr3XiktE/X5u3di8CBAgQIECAAAECBAgQIECAAAECBAgQIECAAIECF6gs8P7pHgECqyEwt/6daGxqXI0rXUKAAAECBAgQIECAAAECBAgQIECAAAECBAgQIFDMAgLgYp49fSfQjsCUxZNj7OMj48LX/r92zioiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoZQEBcCnPrrEVrcDEBffG3xbct1r9n1U3MxqX//NizXOrdb2LCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEilfAN4CLd+70vEQFljUti2OePzR6V/SJabvNW+VR9q3sl12ztKl2la91AQECBAgQIECAAAECBAgQIECAAAECBAgQIECAQHELeAO4uOdP70tQYH7D3Khvqo/elb3zRlfbWBvnvHJy/HHu/8VbdTPi0UWT8uoM6DUgK2uKprxzCggQIECAwP9j787j5KrKhAG/VV29JelO0p0NSAIhgIBAgICIiggMioAgoogZh8VlXMD5VNBBRh2dEVwG9w3GcRAcVNAZwQ3cRsVBFmUHCSSQPWTvbL1vX9cNaRJ6767qdHU/t35F3XuW95zz3MY/fDn3EiBAgAABAgQIECBAgAABAgQIECBAYHQL2AE8uu+v1RWgwOaWHbt+JxVVdZn9E3WPxE3r/iOerHs8MqniuGfbnXH3vKdidtmczrbzxh8Tn9r3y3FMxUs7y5wQIECAAAECBAgQIECAAAECBAgQIECAAAECBAiMDQEJ4LFxn62ygATGFY2P4o7k7gHlL+oy63Ts2LTf1N4Um1o2JPXZ812PVCoVF894765FzgkQIECAAAECBAgQIECAAAECBAgQIECAAAECBMaIgATwGLnRllk4AnuV7BP3HLk4JmW67gAuSu34V7al4xHRda21yaLGpccXzuLMlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAIK8C3gGcV17BCQxOYEbJ3lGWLuvSed/S/WNu2UHxsspXRWlHfUmqJCZ3kyju0lEBAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAmBCwA3hM3GaLHC0CFZnKuHPe48ly3jb9kqht2x7lReNGy/KsgwABAgQIECBAgAABAgQIECBAgAABAgQIECBAYIgCEsBDBNSdwJ4S2Lds/z01tHEJECBAgAABAgQIECBAgAABAgQIECBAgAABAgRGqIBHQI/QG2NaBIYi8Mct/xu/qfnFUELoS4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUIACdgAX4E0zZQJ9Cbxr0Ztje+u2WHzs1ihJl/TVXD0BAgQIECBAgAABAgQIECBAgAABAgQIECBAgMAoEbADeJTcSMsYPQLfW/ftePMTr47NLTWDXlR7tEdrx6eurXbQMXQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoPAEJ4MK7Z2Y8ygVuXn9D/N/W38Wi+ie6XWl7e3u35bsWlqXLk8vGtoZdi50TIECAAAECBAgQIECAAAECBAgQIECAAAECBAiMcgGPgB7lN9jyCk+gpmVTMulJmcldJp9N/p706LyoKKqMQ8YdHmdWvTFeOfGULu1ml+6fPAJ6XHp8lzoFBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECo1dAAnj03lsrK1CBra2bk5lPLOqaAG5qb+rcGfzA9ntjffPabhPA3z/4F1HfVhcVmcoCVTBtAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBwQhIAA9GTR8CeRQ4d8rfxrONK2NayYwuo2RSu/8rW5Yq69ImWzCuaHzy7bZSIQECBAgQIECAAAECBAgQIECAAAECBAgQIECAwKgV2D2bNGqXaWEECkfgY7M/2+Nki1JFkf20dnyyRzbR6yBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCwUyC988QvAQKFIXDVfl+Jd8z4h5icqY7jK04sjEmbJQECBAgQIECAAAECBAgQIECAAAECBAgQIECAwLAI2AE8LMwGIZA7gb+b/vdJsE/u+/ncBRWJAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgVAjYATwqbqNFECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAIEIC2F8BgVEo8NvNt8cb/npyLGt4ZhSuzpIIECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6EpAA7klGOYE9JLC8YcmQR75j021x77Y/xl1bfzfkWAIQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgUjoAEcOHcKzMdAwK3rL8xjn/4oPju2n8f0mpL0qVJ/4a2+iHF0ZkAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCwBCSAC+t+me0oF1hUvzBZ4eaWTT2udGnD03HP1jt7rM9WlKfLk/rGtsZe26kkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAYXQISwKPrflpNgQvsTPxOylT1uJJ3L14Q5z5xShx2/4xY17Sm23anTjojjhx/bLxi4knd1iskQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAYnQKZ0bksqyJQmALN7U3JxKcVz+hxATsf61zTsjFWN62IaSVd2x5XeUL8/LA/9RhDBQECBAgQIECAAAECBAgQIECAAAECBAgQIECAwOgUkAAenffVqgpU4PKZ/xzHVBwfp0w+vccVZOL5f23HF03osZ0KAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBsSfgEdBj755b8QgWmFm6b7x12jsjk3o+yfvC6U4pntpZNKGosvPcCQECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGes0xsCBAYkQLfOOCmuG3jLbGltSb2KtlnRM7RpAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBPaMgATwnnE3KoFBC1QVT4mLZ7x30P11JECAAAECBAgQIECAAAECBAgQIECAAAECBAgQGL0CHgE9eu+tlY1xgQ3N66KlvWWMK1g+AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGBsCUgAj637bbVjRGBx/cI4+oHZccWSS8bIii2TAAECBAgQIECAAAECBAgQIECAAAECBAgQIEAgKyAB7O+AwAgS+K9134r/2/K7Ic9offPaaO34PNOwaMixBCBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECgcAe8ALpx7ZaajXGBV4/L4xyXvjQPKDo4/zHt0SKstS5cn/RvbGoYUR2cCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHCErADuLDul9mOYoGalk3J6opTxb2u8q4tv49/ePqiWN24ssd2E4oqeqxTQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMHoF7AAevffWygpMoK5tezLj8X0kb29a/x9x28abY1vLlrj+RT/udpUHlh8S18y5Lg4Zd3i39QoJECBAgAABAgQIECBAgAABAgQIECBAgAABAgRGp4AE8Oi8r1ZVgAJTiqdHdvfvoX0kbdPPvbq7ub2511W+Zdrbeq1XSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMPoEJIBH3z21ogIV2L/swHjk6Gejr8c373xE9Lii8QW6UtMmQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIl4B3AOdLVlwCgxCozEyMdKr3fy3nV7w0ibxXycxBjKALAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAaBawA3gP393Vq1fHpk2boq6uLvmWlZXFxIkTo7KyMqqrqyN77SCwq8Bbp70zXlT+4jhs/FG7FjsnQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBLAw/xHsG3btrjxxhvjpptuisceeyyy1z0dmUwmDj/88DjuuOPizDPPjNNPPz1SqVRPzZWPIYFjK142hlZrqQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAv0V6P1Zs/2Nol2fAmvXro1LLrkk9tlnn7j00kvj7rvv7jX5mw3Y0tISDz74YFx77bVJAviII46In//8532OpQGBrMC9W/8Yt268GQYBAgQIECBAgAABAgQIECBAgAABAgQIECBAgMAYErADeBhudk1NTZx66qnx6KOPdo6W3cm71157xezZs2Pq1KlRXl4epaWlSdK3oaEhtm7dGitWrIhly5ZFY2Nj0i+7Y/iss86Kz3/+8/H+97+/M5YTAt0JfPCZd8bSxqfjFZUnxZTiad01UUaAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDDKBCSA83xDa2tr44wzzuhM/h577LHxwQ9+ME455ZQk8dvX8M3NzXHfffclj42+/vrrI3v9gQ98IA466KDkkdB99VdfOAK3rL8xvrXmy/GfB/13zCrdb8gTT8WOx4Vvbd0iATxkTQEIECBAgAABAgQIECBAgAABAgQIECBAgAABAoUh4BHQeb5Pt9xyS/K45+ww559/ftxzzz3Jb3bXb3+O4uLiePnLXx7XXXdd3HrrrZG9zh5XXHFFtLW19SeENgUicHvNrfHXukfir7WP5GTGZenyJE59a11O4glCgAABAgQIECBAgAABAgQIECBAgAABAgQIECAw8gUkgPN8j/70pz8lI2Tf33vjjTdGOj148tNPPz2uueaaJF72cdJLlizJ8+yFH06B2tZtyXDjiibkZNj9yw+MklRJTM5U5yReLoJ8Z+0349LFF0RzW3MuwolBgAABAgQIECBAgAABAgQIECBAgAABAgQIECDwAoHBZyNfEMhl9wJ33XVXUvG6172uc/du9y37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ECBAgAABAgQIECBAgAABAgQIECBAgACBghaQAC7o22fyBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQeF5AAvh5C2cECORIYGPz+vj0io/G8oYlOYooDAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQH8EJID7o6QNAQIDEvifDd+Lr63+bNy0/tsD6qcxAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDA0AQkgIfmpzeBUSfQ2NYYqxqXD2ldG1rWJ/3Hp8f3K86aptXxaO0D/WqrEQECBAgQIECAAAECBAgQIECAAAECBAgQIECAQM8CEsA926ghMCYFrljy3jjuoQPiybrHB73+mpaNSd/Jmep+xfj7RW+O1z720sgmgh0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKDF5AAHrydngRGpcC65jXR3vFZ1bRi0Ovbt3ROZFKZOHz8Uf2K0dremoy5eghj9msgjQgQIECAAAECBAgQIECAAAECBAgQIECAAAECo1xAAniU32DLIzBQgZJ0adKlua1poF0721+y94fjqWM2x5ETju0s6+1kcqYqqa5p2dRbM3UECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ9CEgA9wGkmsBYE6goqkyWnE4VDWnppc8lkvsTZJ/S2UmzVKT601wbAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBHgQyPZQrJkBgjAp8eOYn46UVJ8RJk17Tp8Cvan4WyxqeTtoVp0viDdULojIzsc9+L2zwT7M+HadPPideOfFvXljlmgABAgQIECBAgAABAgQIECBAgAABAgQIECBAYAACEsADwNKUwFgQmFm6byyY9vY+l7qpeUNc/NQ5u7Xb3ro1Lt37H3cr689FNml84qRT+9NUGwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgV4EJIB7wVFFgEDPAlXFU+JT+34pljY+kzQqTpXEuVPe2nMHNQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAnkXkADOO7EBCIxegYtnXJLzxTW1NcX7nr4gjqt4RbxtxqU5jy8gAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGA0C6RH8+KsjQCBwhNY1bQ8frbpv+M/13y98CZvxgQIECBAgAABAgQIECBAgAABAgQIECBAgACB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nRF2G+YoRslpKed0pmnU9XMC7PZNva59NVR2sXVdxh2+6g79gAAIgAAIgAAIgAAIgEC3IZAW3lvXytbdCXLMSv51RzhWrxFhq73IICh/jbBCGfcIHBA7QShgJ7hX2WAtR5b5I2LGEv/6s3TGc1umKZuuz7D1OsBz5f2wqzNu9edpY2wg0GMJQAHcY596TDwQCGgtgHm8bAVcWlpKnJ6UlERFRUVyGsr9M99AASyR4A8I+IzAdBEHid3+jI45wGd9oiMQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQcETA4qDdUS7SQQAEupSA1gKYB2LvBlopgNPS0qzjVDGAVV1rBi5AAAS8QuDYxMn0/IB3pBtkr3SARkEABEAABEAABEAABEAABEAABEAABEAABEAABEAABEDABQJQALsAC0VBwNcElBJXKXXtFcAFBQVySFoL4MjISDKZTDI2MMcHhoAACIAACIAACIAACIAACIAACIAACIAACIAACIAACIAACIAACPQcAlAA95znGjMNQAJ6LqB5Gip906ZNclb9+vWTj+oP3EArEngEARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAgZ5FAArgnvV8Y7YBRqAjC+ANGzbIGQ0aNMhmZlAA2+DADQh4hcCvFfPpx/JvvdI2GgUBEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABdwmEulsR9UAABLxPoCMFcF5enhzEwIEDbQajXEaXlZXZpOMGBEDAcwQuzjudGlrrafO4agoJCvFcw2gJBEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABDpBABbAnYCHqiDgbQLK1bOK/aseOd1sNtPmzZvlEAYMGGAzFGUBrBTINpm4AQEQ8BiB5tZm2lK/kbbWW9yxe6xhNAQCIAACIAACIAACIAACIAACIAACIAACIAACIAACIAACbhKABbCb4FANBHxBQClwlUWvVgG8bds2amhooIyMDIqOjrYZjlIAwwLYBgtuQMCjBCKCI6nGXE2TV0+gemEJvHpMEUUER3i0DzQGAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAq4SgAWwq8RQHgR8SMCZBbCj+L88PCiAffgkoaseS6B/xACKDo6hanMV1ZvrqMnc2GNZYOIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAL+QwAKYP95LjASELAh0NjYSHV1dRQWFkZRUVEyT2sB7Cj+LxdUFsOwALZBihsQ8CiBOUO+oT9H5lGw+GEJCw73aPtoDARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAATcIQAX0O5QQx0Q8AEBe/fP3KVWAWzEAli14YPhogsQ6HEEokKiiX9Nwu1zcGsImYJMPY4BJgwCIAACIAACIAACIAACIAACIAACIAACIAACIAACIOB/BKAA9r/nBCMCAUnA3v0zJyrLXs6rrKyU5QYOHCgftX/gAlpLA9cg4F0CHw6ZR2bxExQU5N2O0DoIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIGCAABbABSCgCAl1BQFnvKqUvj0FZAHNecXGxHNagQYPaDQ8K4HZIkAACXiMwImas19pGwyAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiDgKgHEAHaVGMqDgI8IOFMAs/J369atFBISQjk5Oe1GpJTGiAHcDg0SQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQKBbE4ACuFs/vZhcIBPQcwEdGxsrp7R582ZqaWmh7OxsCg8PbzfNpKQkmVZYWNguDwkgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAALdlwAUwN33ucXMApyAMwvg1tZWOTu9+L+cwW6hw8LCaMOGDVRdXW1D4vvvv6ePP/7YJs1XN8uXL6eZM2dSc3Ozr7pEPyDgNQK/VsynU9YcTpvq8rzWBxoGARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAAVcJQAHsKjGUBwEfEVAKYBX3l7uNiYmRbp/VEPTi/3KeyWSi/fbbj8xmMy1ZskQVl4rXqVOn0hlnnEFFRUXWdF9dzJgxg66//nr6+eeffdUl+gEBrxH4rux/9E/Vb8SKYAgIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAI+AsBKID95ZnAOEDAjoByAa3i+apsrULYkQUwlx03bpyssmjRIlWVli1bRlVVVcQWxAsXLrSm++pi+/btsqtt27b5qkv0AwJeIxARHCHbnlvyIf1c/p3X+kHDIAACIAACIAACIAACIAACIAACIAACIAACIAACIAACIOAKASiAXaGFsiDgQwLKAtiZAtiRBTAPc+zYsXK0WkXvggULrDPQplsTvXyRn58ve9i1a5eXe0LzIOB9AhHBkbKTRdV/0KM77/Z+h+gBBEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABAwQgALYACQUAYGuIKAsgLUWvzwO7b0RC2Ctove3336zTkWbbk304gXHImbrYxalCPZid2gaBLxOYFL8cZQbMVj2E0z4d+p14OgABEAABEAABEAABEAABEAABEAABEAABEAABEAABEDAEAHsWBvChEIg4HsCHVkAh4eHU3Z2tsOBDRs2jCIjI2nTpk1UVlYmy/3+++/W8lrX0NZEL15olb6wAPYiaDTtMwKjYvanx/u/JPsLCwr3Wb/oCARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAAScEYAC2Bkd5IFAFxLoSAGck5NDISEhDkfIeaNGjZL5rOzdsGEDFRYWUnp6OiUnJ1NRURH5MhavVumrvXY4AWSAQAAQyDRlU3RwDO0XPToARoshggAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAI9AQCUAD3hGcZcwxIAkoBnJCQYDN+5QLaWfxfVWHcuHHykt09q/i/48ePJ5XuSytgrdJXaw2sxopHEAhEAhmmLFozdg/d3++pQBw+xgwCIAACIAACIAACIAACIAACIAACIAACIAACIAACINANCUAB3A2fVEypexCor6+XEzGZTDYTUgpgZ/F/VYWxY8fKS1b0qvi/rABW6b6MA6xV+rL1cUtLixomHkEgoAmEBoUG9PgxeBAAARAAARAAARAAARAAARAAARAAARAAARAAARAAge5FAArg7vV8YjbdiEBDQ4OcTUREhM2sDjjgAAoLC6NJkybZpOvdKEtfVvRqFcDadL163kjTWgCbzWYqKCjwRjdoEwRAAARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAAR6NAGYLfXopx+T92cCjiyAzznnHJo2bRoFB3d8foPdRMfGxtLOnTvlVGNiYmjkyJGUkZEh7xcvXkytra0UFBTkdRRaBTB3xhbBahxe7xwdgICXCJQ07aFeIXEUHhzupR7QLAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAi4RqBjDZJr7aE0CICAhwg4sgDm5o0of7kcK3bHjBnDl1IOOuggCgkJofT0dMrMzKSKigrKy8tT2V59VC6gVUxje4WwVztH4yDgBQIFjbto7NJ+9O+N07zQOpoEARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAAfcIQAHsHjfUAgGvE1AKYPsYwK52rNw9cz2O/6tEpXN8YF+IUviq+MNKIeyLvtEHCHiDQHlzKTW2NtLm+g3eaB5tggAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgIBbBKAAdgsbKoGA9wk0NjbKTjjeb2dEKXq5Da0CWCliOT6wL2T37t2yG9WvUgj7om/0AQLeIBARHCmb3VyfR/PKvvRGF2gTBEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABFwmAAWwy8hQAQS8T4Ctf81mM4WHh0uXzZ3pUSlcQ0ND6cADD7Q2pRTDvlAAFxcXE8+J3T/n5ubKMUABbH0qcBGgBGJF7F+W5tZmWlj1e4DOAsMGARAAARAAARAAARAAARAAARAAARAAARAAARAAARDobgRCu9uEMB8Q6A4ElPvniIiITk+nX79+NGPGDEpJSaGoqChre0oxvHTpUnrttddkOitop06dKmMHWwt64EK5e+7Tpw9lZGTIFlWaB5pHEyDQJQQSw5JpWspF9P6eNygsKLxLxoBOQQAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQAAEQMCeABTA9kRwDwJ+QEApgDsb/1dN5dFHH1WX1kdW9g4cOJA2bNhAl156qTX9u+++o6OOOsp674kLZe3Lyl9WArOoNE+0jzZAoKsIpIdbXs+mYFNXDQH9ggAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgIANASiAbXDgBgT8g0B9fb0ciKcUwI5m9dxzz9Gnn35Kra2ttGDBAlq3bh15wzJXKXu1FsAqzdHYkA4CgUDgxMSplFe3hk5MPC0QhosxggAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAI9AACUAD3gCcZUww8AsoC2BMuoJ3N/phjjiH+ZbnhhhukAri0tNRZFbfylLKXLYCTkpKIFdtlZWVUV1dHkZGRbrWJSiDgDwQGRw2jVwZ+4A9DwRhAAARAAARAAARAAARAAARAAARAAARAAARAAARAAARAQBIIBgcQAAH/I+ArC2DtzNklNAsrZj0tyqpYuX/u3bu37EIphj3dH9oDARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAARAAgZ5KAArgnvrMY95+TcBXFsBaCImJifLWmxbASgHMlsAsSjEsb/AHBEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABEAABECg0wSgAO40QjQAAp4noBTA3o4BrB25LyyAleJXKYJhAax9BnAdiASWVy+i94veCMShY8wgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAAIgAALdlABiAHfTJxbTCmwCygW0t2MAayl1hQUwFMDaZwDXgUjg7m030KLqP2l0zAE0JGp4IE4BYwYBEAABEAABEAABEAABEAABEAABEAABEAABEAABEOhmBGAB3M2eUEynexDoSgtgT7uAbm5upqKiIgoODqb09HT5BCkLYLiA7h6v1549iyA5/aqWip6NAbMHARAAARAAARAAARAAARAAARAAARAAARAAARAAARDwGwJQAPvNU4GBgMBeAsoC2JcuoJUFcFlZ2d6BeOCqoKCAzGYzpaWlUUhIiGxRKYBhAewBwGiiSwlEBkfI/uvMdV06DnQOAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAiAAAooAFMCKBB5BwI8IKAvg7uACWil5ldKXMatYwCrPj9BjKCDgEoGJcUdRlqk/5UYMdqkeCoMACIAACIAACIAACIAACIAACIAACIAACIAACIAACICAtwhAAewtsmgXBDpBoCssgOPi4uSIKyoqqLW1tROjt62qlLxK6cu5ShkMF9C2rHAXeASu6HMT/TkyjzJMfQNv8BgxCIAACIAACIAACIAACIAACIAACIDA/9k7E3g7iiqNV4AECGGTQGCGsIaQABESnCCbiMi+OsgimywOggvoKC7AiOKCCy4MKuAAIhBAQXZEhAFZlQyQsO8JSRiBEBmSEIIk5E19pd/l3Hrdffve232399Xv915313Kq6t99e6lT55QIiIAIiIAIiEBPEpACuCdPqzrV7QTaYQG8zDLLOCiB33nnHQclcFGBSl4qfSGX+1QOF1WX5IiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIjAQCcgBfBAvwLU/44kQAVwK9cABohVV1018ChyHWAqean0RQXDhg1zK620klu4cKErsq7QeP0TAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQgQFMQArgAXzy1fXOJUAX0K1cAxg03vOe9wQor732WmFwaAFsXUBDOBXCVBAXVqEEiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiMAAJiAF8AA++ep65xJotwVwkQpgKnip8CV1KoSZznhtRUAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEGicgBXDj7FRSBEoj0G4L4CLdMs+aNStwosKX0KgQZjrjtRUBERABERABERABERABERABERABERABERABERABERABERABEWicgBTAjbNTSREojUCvWAAvWLDAPfvss27w4MFuo402quK16aabhuMpU6ZUxetABERABERABERABERABERABERABERABERABERABERABERABESgcQJSADfOTiVFoDQCtABedtllS6sjSTDXAC7KAhjK3XfeeceNGzfOxesZ/8u//Etowv/8z/8kNUVxIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACDRCQArgBaCoiAmUToAVwrDQtu14qgItaA5jK3fe97339mr7lllu6QYMGuYcfftgtWrSoX7oiREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAE6icgBXD9zFRCBEon0C4L4FVXXTX0rSgLYCqAae1rwa288spu9OjRDn197LHHbJL2RUAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEGiQgBXCD4FRMBMok0GsWwEkKYPCjZTAVxWUylWwREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERGAgEpAAeCGdZfew6AlQAt3oN4CItgF9//XX3/PPPu+WXX95tuummieeAimEpgBPxKFIEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAE6iYgBXDdyFRABMonQBfQ3bwG8AMPPOD6+vrc+PHj3TLLLJMITQrgRCyKFAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIGGCUgB3DA6FRSB8gi02wL4tddea7pztOqlm+ckgVQOP/74427hwoVJWRQnAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiJQBwEpgOuApawi0CoCtAButQvo97znPaGL//d//9d0V6kAppVvkkC6h168eLGbOnVqUhbFiYAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAI1EFACuA6YCmrCLSKAC2AW+0CetiwYW7w4MFuwYIFbtGiRU11N48CGBXQQpj5m6pUhUVABERABERABERABERABERABERABERABERABERABERABERggBOQAniAXwDqfmcSaJcFMGisuuqqAUozbqBffvll9+KLL7qVVlrJjR49OhMyLYSlAM7EpEQREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERyEVACuBcmJRJBFpLoF0WwOgl3UA3owB+4IEHAjBY9w4aNCgTnhTAmXiUKAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAJ1EZACuC5cyiwCrSFABXCr1wBG72gB3Mw6wLTmpXvnLGrjxo1z6Oczzzzj5s2bl5VVaSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAjUILFMjXckiIAJtIEAX0K1eAxhdrccCeO7cuW7FFVd0Sy1VPZeECmBa92YhxJrDm2++uZs8ebK74YYbKmsCp5VZd911XTu4pLWn2XgwhMtshjXXXNOtvPLKPGzZdvHixQ5W32ussUbL6lRFIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACxROQArh4ppIoAk0ToAK4nRbAtVxAv/DCC27MmDFur732cldddVVVn+tRAKMgFMVQAB922GFVcpIOtt9+e3fXXXclJXVdHM7zqFGj3Jw5cypthwJ21qxZbsiQIZW4Vux84hOfcJMmTXKPPPKIGzt2bCuqVB0iIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIlEJACuASoEikCzRKgC+h2WLrSAriWC2goYdHO2267zfX19VXW+oViGArN1Vdf3cFaN0844ogj3D333OOo+E4r89xzz7l7773XLViwwK2wwgpp2bomfsqUKYHV0KFD3ciRI4Pid/bs2e7hhx8OSvFWduTWW291sAJ+6qmnpABuJXjVJQIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIFE6j221qwcIkTARGon8A777zj8Ddo0CC39NJL1y+gyRJcA7iWBTCtfOHCGOv3MjA+j/tnlpk4caKbOnVqUD5CAZn2B1fRS5YscQ899BCLdvWWrD72sY+FPh9wwAGhP4xvVedeeukl95e//CVUV+u8t6pNqkcEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAERKAxAlIAN8ZNpUSgNAK0gl1++eVLqyNLcF4LYKukfOCBByoiGV+PArhSuMYOZbKOGtk7Ppn9YL+4ZXyrOmDrq2X53ao2qR4REAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIHGCEgB3Bg3lRKBpgjcd999bvr06Yky2un+GQ3KYwG8aNGi4KaYHbAKRO5Tmck8RWwpk3UUIbOdMtgP9otbxreqbbY+WQC3irrqEQEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIFyCEgBXA5XSRWBVAIvvvii22677dz++++fmIcWwMsuu2xietmReSyAH3vssbBe71JL/f0WQgUi1gJ+8MEHQxPf9773Fd5UymR9hVfQQoHz5s0LrrNxnseNGxdqhovrwYMHuyeffDKsc9yq5liesgBuFXXVIwIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIAIiIALlEJACuByukioCqQSmTZvmoCidNWtWYp52WwBTAZxlCUqF4W677Rb6MGXKFLd48WL39NNPu/nz57uRI0e6ESNGJPavmcjNNtvMwTX2888/77pdUQlFOa4DKn3BBcrg9773vWGdYyrSm+GVt6x14Z113vPKUz4REAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIH2EZACuH3sVfMAJfCXv/wl9BwKTCgA40AFcLssgOkCOkvBSgXwLrvs4kaNGuUWLlzoHn/8ccd4ujKO+9bs8dJLL+3Gjx8fxFilZbNy21E+jRXZtap/mJDw17/+tYIg67xXMmlHBERABERABERABERABERABERABERABERABERABERABESgYwlIAdyxp0YN61UC//u//xu69s4777i5c+f26yZdQC+33HL90loRUY8FMJSVVmGZptQsst2sj3UVKbuVsth+9od1t9rNNRXNa665ZmiCLIB5JrQVAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQge4kIAVwd543tbqLCdACGF2wlpfsUqdbANPal9a4VmGZptRk34rYUmHKuoqQ2Q4ZbD/7wzbwmOmML2vLenbeeedQhSyAyyItuSIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiLQGgJSALeGs2oRgQoBqwBOsrakBXC7XEAPHjzYDRs2LKzpi/V84zB16tSQtummm4b1eKmwvO+++xzSBg0a5Lbccsu4WGHHrI+Ky8IEt1DQq6++6mbMmBE4jxkzpqpmcB06dGhY5zjp+qjKXMABOe66665BWivqLKDZEiECIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIpBCQArgFDCKFoGyCFgFcJYFcLtcQKPfXAc4SRlIhSEVsRMmTHCwBn700UcdlNdYE3iVVVYpC5/baKON3Morr+zgSvvll18urZ4yBdPtMhTlSy1VfRumZTXqZ76y2rJkyRL34IMPBvE77bRTUN7PmzfPIV5BBERABERABERABERABERABERABERABERABERABERABESgOwlUax66sw9qtQh0FQGuAYxGJymA220BjHZxHeAkd8CxAniFFVZwY8eORbEQqBjmcdFba2HMthRdR9ny2G66z47rI8OyFcBPPfWUe+ONN9y6667rsAYwFPdQ/r7++utxk3QsAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiIgAiLQJQSkAO6SE6Vm9g6Bl156qdKZJAUw1wBupwUwFcB5LIDRGSos4/1KRwveYX1UpBYsvnRxbDf7EVdIxTDzxelFHVPBzHZknfei6pQcERABERABERABERABERABERABERABERABERABERABERCBcglIAVwuX0kXgSoCsKx88803K3FJCtZOsACmC+hXXnkluHVGm/A3e/Zs98wzzzisTzxu3LhKP6iwRASViZXEEnZYR5qCtK+vr4RaixPJdrMfsWTGM1+cvmjRosp5wX6jgfJ5/njekyy/WUdZbG2feL1h+/bbb7NqbUVABERABERABERABERABERABERABERABERABERABERABHIQkAI4ByRlEYGiCFj3z5CZZAEMpRdCOy2AqQg85JBD3PLLL1/5GzFihIMCcIsttnCDBw8O7cQ/Kizt+rWVxBJ2qLCkBaut4oQTTggurGfNmmWjm97fY4893OjRo5tWSM6cOdNBsQ5r2w022CCxXXadY2sxjsznn39+UMDzvOA6ufzyyxPlIBLX04Ybbuj23XfffnkmT54c4nj+eN6TJiYg4/333++GDh3qzjrrrH6ymom44oorwvXOPtktJhuceuqpzYhXWREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREYUASkAB5Qp1udbTeBv/zlL1VNSFIA0wU0FF/tCjvvvLNbccUVg1IOCkb7hzV/Dz300KqmQSEMpezBBx8cFIRViSUcYM3aYcOGuTlz5vRbr/aOO+4IcbfffnthNc+bN8/9/ve/d88++6ybMmVKU3KptKbSNUkY1jneZJNNQtJzzz1XlQX9ghIeCvghQ4aENXuvvvrqqjz2APVNmzbN3XTTTW7BggWVJFjcPvzwww51UaFOF9BpFsCwGIZCGYyLDNdcc03oB/pjrzX+Bq666qoiq5MsERABERABERABERABERABERABERABERABERABERABEehpAlIA9/TpVec6jQAVwMOHDw9NS7K0pAIYirB2hYMOOshB6blw4cJ+f2+88Yb77Gc/W9U0KCOhHLz00kur4ss8+Od//ucgnkxZF4/p3pjxzWwfeuihoHSFjGblsnyWAhj11OofFNJURlMmysWBCud33nnHoR8Mjz76qMO1BqvmlVZaKURTAZx0XSIDFcOxJTtlNrpl+x988MGq623+/PnB2hlux3E9KoiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACNQmIAVwbUbKIQKFEaBykuvndqoFcGEdLlFQkoIU1qlUXlLxWUQTqKCELLvfiGy2K68COFa28hj9HzNmTLCEnjFjhnv11VcTm2Pby7ptP2w7armAJltex4kV1hmJ38D06dMdLMvHjh1bVRoTC2BdDotn2/aqTDoQAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQARGoIiAFcBUOHYhAuQSoOMtSAHMNYLq/LbdF3Sv9n/7pn0LjqRDFAflif+rUqQ5ujosIVolq9+uVbRWZdLucJoP9s31CXq4JjPSlllrKbbnllkFEmoLUtjdp3yqAaQFMS9+4bYzHGsZLliyJkxs6ZrvHjx/vsIZ0HNg+5ovTdSwCIiACIiACIiACIiACIiACIiACIiACIiACIiACIiACIlBNQArgah46EoFSCVBZSQUwLSptpZ3gAtq2p1P3kxSk5Is2gyPcHBcRrOL06aefdnBN3EjAer6vv/66Q9vZ/jQ5SRbOc+fODev4Yv1jrNGMQEWybSNloi67hrDNw30qWFEmrwUw3Em//PLLrKapbVI7rMCs/tl82hcBERABERABERABERABERABERABERABERABERABERABEfg7ASmAdSWIQAsJ0JoTrm5h7QiF3uLFi6taIAvgKhypB1SQWqUv+bIQlYs8bmQ7Z84c98ILLwQXxRMmTAiWr3Yt3Xpksj1W6ZpWngpi2z/us+8oS1mUbeVhTV1YHUOJuvzyywdlMKx4sbbzE0884ZZZZpngYpllalkA2wkLMWvKqHfLdrMfcXnGM1+crmMREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIFqAlIAV/PQkQiUSoBKMyjwqGyzSjVULgvgfKeAClIyRSnuDx06NAgpQmlI18NwtbzVVls1JZftoVIzCEv5l9U/pqEoZVG2Fce4rbfe2sHFMgL6M2XKlDDxYNNNNw2KYZZJuyaZThfQOCZrpjW6ZRvZj1hOnnWO4zI6FgEREAEREAEREAEREAEREAEREAEREAEREAEREAEREIGBTEAK4IF89tX3lhKAJSbd5q611lputcpw3uAAAEAASURBVNVWC/WnKYC1BnD26aEVrFVE0kJ25513DoWpvM2WlJ1KBSWsaKmkZFx2yf6pbA/l9M/xbgyVvLZ/3GffkXuDDTYIkwmwLu+sWbPeFeD32E7UxzrRBhtvC9AFtFX02nR7rZK1Ta93H/3Bmsaod8MNN0wsbtc5ZrsTMypSBERABERABERABERABERABERABERABERABERABERABEQgEJACWBeCCLSIwOzZs92iRYvc8OHDHZS7VAD/9a9/rWoBXUAvt9xyVfE6qCZABalVRFJBuueeewb3xo8//nhwd1xdsr4jKh2tEpVx9UjCurl0Hc11bbPKY41f/L355pth3WDkZV/Zd5a3yl3GYct2Ip11Is7G2/y1LICxpjADWfO4kS3bgbYNGjQoVURa/1ILKEEEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEBjABKYAH8MlX11tLgAozKu+obIsVwHQBLQvg7PMDK2ooDWFVvWTJkpCZjEeNGuXg3hjrK8PdcTOBSkooIbF28worrOCmT5/u4vNWqw6suQtlLi12a+VHOq8V9otbxlOGVe4yDhMOYBG80koruY033rhiAZylAM6yAEbbOTkBdVAZzfoa2ZIt258mgwpg5k/Lp3gREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAHnpADWVSACLSIQK+9oAWzd6qIpVLJJAZx9YoYMGRKsqaHkffXVV0NmKiWhIC1Cafjiiy8GBTNdFC+99NJuwoQJoa56lZHMz3Zl9+7vqXT1zH5xy3jKoEzWgXjuY+1iKMpHjx7tVl55ZYc+PfPMMw4W5pttthlFhC3WTsZ1t3Dhwsp1yAyxW2hez0xvZMs2sv1pMqggZv60fIoXAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQARGQAljXgAi0jAAVZlTeUQEcW5LSAlguoGufGlrCUjFKxkUpgJPW7KWykmm1W/n3HFResnyecuwf+8Ut4ymDMtEmrDWNwPqoPIUSGMpghs0339wNHjyYh5UtrYDjiQk8hhIcgW2pFGxghwzZ/jQRsJrG7yVpneO0MooXAREQAREQAREQAREQAREQAREQAREQAREQAREQAREQgYFKQBbAA/XMq98tJ0AlJZV3aS6gZQGc/9SQJZSRc+fODS6WuXYulYpUMuaX+m7OWImKFCpUmfZu7uw9toPtys7991ROFqCylVvGUwY44A9r9D733HMhmu2z9aXtUw62vC5ji18eb7TRRiE7r2dbtp79adOmOSiV11xzTbf22mvXLNoo95qClUEEREAEREAEREAEREAEREAEREAEREAEREAEREAEREAEeoyAFMA9dkLVnc4lQOUdlZayAG7+XFERCmUkFZLkC/fGsKKGu2MohxsJWUpUpuWR+/bbb7tHHnnELbXUUhUX0nnKsS/oGyx7sd4xAtY/jgOVu1Q0c8t45E/bt7KoAKbFL9N4DAUwLIdxTGt15qlnS362TVnlmY/lsvIqTQREQAREQAREQAREQAREQAREQAREQAREQAREQAREQAQGMoFlBnLn1XcRaCWBNAUwFWtsiyyASaL2lgpSsI0VwFBSws3x/fff7+BCeJll6r/d0T03lY9o0YYbbujgJvmll14KdVIJHbcWCtgDDjggWCW/8847DkrgTTbZxA0bNizOmnps+zd79my3aNGisO4x1j+OAyxkr7vuOnfssce6E088MayLPHz4cLfeeutVstKKFhG2T5UMfocuoGnxyzRep5i4AAX0zJkzgxvo9ddfn1kSt5/61Kfcb3/7235pb775ZoizbeqXyUQw309+8hN34YUXmpTs3VVWWcXdcsstVRyySzSeeuWVV7qTTz7ZYbvFFltUBGESwp577unmzZsX4uCO+4QTTgh5K5l6dOfII490N998cyG9AzdcT1/72tdS5Z100knukksuqbhCx2/gtttuS5w0kSpECSIgAiIgAiLQJQRuvPFGd9xxx4V3xCKavM4667g//vGPboUVVihCnGSIgAiIgAiIgAiIgAiIgAiIgAi0kUD9GpE2NlZVi0A3E6CCkgpDWlpSyci+0apSawCTSPrWKkipYCdflNp7772DApjKy3RJ6SlQ5FmZUEJBGXnrrbeGdXZtmpUCJeALL7xgo0J7qiJqHFC2VXAzLi666667utNPP9298cYb4Q/pe+21V1W2dddd1733ve91CxcudBtvvHFVGg+oAI6ZUSGM6xZtgAIY13SWAhhK7wsuuCAovynfbqGU32233WxU6v62224blNNoBydJpGY2CVCcY3D0M5/5jIktZ/eGG24ILrih8LYKYCjm6ZqbNf/iF7/oeQUwrkUoY5csWcJuN7297LLLMhXAkyZNCmtFsyKc/9///vfuqKOOYpS2IiACIiACItAzBC6++OLKJMgiOoXn5r333ut22WWXIsRJhgiIgAiIgAiIgAiIgAiIgAiIQBsJSAHcRviqemARoIKSSstaLqCXXXbZgQWogd5SGQpFZMwX4k455ZRgFQEL3EYDFfW2PKxnqQDeb7/9bFJln66KobDaaaedgvtnWCPWE3itpPXPykKboLSlZS0U1Un1TZkyJVhHwh11UmB/qfBlHiqEoSBmu8iceeIt3F5DCTxmzBh35513xslu+eWXd1izOU9AX8Bh/vz5ebKHPBgUhUUoz0Xugg1mJLO4Ph6fffbZwSp81KhRbsaMGcFKe/XVV2+wts4v9uCDDwbl74QJE5q2Aob1NNyPZ11z+J1j4BrX9qxZs9z555/vTjvttHD+pQDu/OtFLRQBERABEaifAJf8uPvuu93o0aPrF2BKfP3rX3fnnHNOeG5KAWzAaFcEREAEREAEREAEREAEREAEupSAFMBdeuLU7O4iANe9r776qlt66aXdGmusERpPBTAVa+wRrRtlAUwi6VuriKRiiEphliJnHhexpftk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4YYbQlU8tvUyDtcLLKx7KUARi79VVlnFxZbPzfST1xwVvbEsxjMf08m6zPPPurQVAREQAREQgVYQ4DONz7gi66RM1lGkbMkSAREQAREQAREQAREQAREQARFoHQEpgFvHWjWJQD8CtACmgo0WwHIB3Q9VaoRV9rRCQWobkjRAxsEyKodt/kb2bf/sfiOy8pbhxARel1a5SRlkTaUb47GlUhPud+G2ut2B54nK+TLaQ1Zgx/reeeedUFXStQB++IOy/LnnniujSW2TaX8DgwYNKqwda621VpCFNQ/jgHsnzgHWAOd9lXl4Pso8/6xLWxEQAREQARFoBYEHH3wwVMNnXJF1Uqaem0VSlSwREAEREAEREAEREAEREAERaD0BKYBbz1w1ikCFABUVsQWwXEBXENXcoSISGe1+zYIFZOAAGRVeUEJhDWDrdrjZalZfffWKErVV/aMbaCo1uaViGH2iMjpJAUwe5NMsg2bLUwHLdjUrL6m8VZJvueWWYb1k5kvjwPgy28U2tHLL/rB/RdUNi3Jcm/CUMGfOnCqxvA6hJI6Vzq04/1WN0YEIiIAIiIAIlEgAXlbwboalQfg+VmR1em4WSVOyREAEREAEREAEREAEREAERKB9BKQAbh971SwCjgo1KoBlAVz/RWGVomUMgmW1CIo+rMn7yCOPuLfffttNnTrVLVq0yG2yySZu6NChWUVzp0E+LR9b1T9el1RqckvFMBpP7kkuoMtSAOaGFmUcNWpUUBzCcjSpvVH2hg6tkhxrJY8ePTrIwblLO29UkPaahU2Z558s4/NIBTDT7UmEG3Ioj2FpzWvZpmtfBERABERABLqJQJnPWXDg+wmsjJcsWdJNaNRWERABERABERABERABERABERABQ6D9vjlNY7QrAgONgCyAmz/jWGcUytY333yzopRsXmo+CSuuuGJQ9D311FNu4sSJ7o033ggFOXCWT0rtXFC2zpo1q2X9o6KXSk1uqRhGi6kApuLN9qLsgUlbV959WLPceuutbuedd3bDhg1LLQbr0SOPPNIdf/zxVXm+8pWvuNtvv70St95667lLL700uBxGJBmRHep7+umnK4OolYJmhxY2v/zlL90999xjUrJ3cd2hzDrrrJOd0acuXrzYHXrooW769Ok180JZfdlll7kVVlihkvdPf/qT+9a3vuW+973vuc0226wSn7VDhXbRvwPUiesOVva47jbffPNKM6gQ5nVZSfA7cEM+fvx4d99997ntt9++sMkZrGPEiBGBG85LUeH00093N954Y6I43PMuvvjiYPmVmEGRPUvgiiuucD/5yU+kkGnyDOOd4bzzznMbb7xxU5LOOussd//997tf/epXbvDgwU3JylMYv/trr73WXXTRRW6llVbKU6T0PK+++qo7/PDD3dFHH+0OPPDAqvoQh+fKt7/97ap4e/Cb3/zG/ehHP6pc0zg3//Vf/+U22mijSjbc7z/5yU+6f/u3f3P77LNPJT5r58c//nFYjgLnJm0piilTprhTTz3VfeMb33B8HscysZQD3gnwvPniF79Ylfyd73wnnI+qyBYdcCmEMp6z6AK8z+AdY+bMmQ7vuJjYWCvgHRis9txzT3fUUUdVZf/CF77g7r777qq4Mg7wjP/hD39YJfr8888P11RfX19VfKMHH/7whx3OfZ6APn/3u98NbRozZkylyCuvvBJ+N1gGpNUBHKZNmxbehTjBNE8b8I6De8/IkSMTs2OC3WGHHeYOPvjg0LfETD7ym9/8prvhhhvSkivxmLh3zjnn5Lr2KoW0IwJtIIBn3HXXXZdYM57VeA7ZCarPPvus+/znP+9wX9xxxx0TyylSBHqBAAwjPv7xj7utttrKnXjiiVVdwvgCxifwjI69d1Vl1IEIiIAIiEAxBPxHgIIItIyAH4TH13fffvvt17I6O7mixx9/PPAYO3ZsaKYf8A/He+yxRyc3u+Pa5gfA+vxAQZ8fSGl52z71qU+Fc4brmn+XXHJJoe3wg6hBtlesFio3TdgJJ5wQ6vODViGLf0EPx1/96lcrRSZPnhzivHVlJQ47flAyxHsr2D5vNVKV1s4DP1gX2sVzlLX1g1tVTZ03b16ft8TuV94rOiv5DjjggJDuFTQhzn/MhGM/CF3JE+94pXGfH+zuJzerbUz7wQ9+EItLPL733nvrkn/99ddXyfGDuaG8H/iuik878Fa2Ib93S5mWpal4tgd8bfADvqFeXLtJ4ZRTTqmLAznn3V511VVJ1TYc5ycpZLb35z//ecOyVbB7CXglVeZ1kfd6VT7X5xV/TV8IfhJfOB933XVX07LyCMC7Is5d0febPHWn5eGzbqeddqrK4iflhLZ65Wufn6BXlWYP/KBgv2v6tNNOs1n6fvrTn4Y8fqC8Kj7tAO8efjJWKINnYFr4zGc+E/Icd9xxaVn6vII/5PHKrz6vDK7k85Or+vxkqZDWzt+TVzBW2lT0zkc/+tHQP6/0yyXaT04I+b3Xlar83stRSznh3coGtKfIc+SXeenzym5bRer+xz72sVA33kFs8IrNQttUZP+yZJ155pm2G1X7kyZNCn3aZpttquLjA/yWsuqwaX5yRlxcxyLQcQT4vLHXrt33k8Wq2ozrGun7779/VbwORKDXCOAdBdc63pdt8J7z+pZddtmQ5id22yTti4AIiEA/An6CYbhfFD3O3q+iHo+QBbB/IrUzYFY7LMdgvYg/rP0K96GYLQjrUK0F286zU37dsgAuhjEsO2F5gN9OqwOssWDlQhd5mLGe11Iyb1u9ssedfPLJbsMNN8xbpKl8cG2NQEteus21FsDvfe97g8XTk08+6RYsWFCxGmWZeB3cphpUQOEvf/nLbvfddw8uurPEwbID1tawzoBlJwKshHB+x40b5y644IJgBeQH/IM7abIiI1oAH3PMMc4PiLt11103tTrkxSxwWq+mZjQJN998s/OD45VzY5ISd2mN6wcZHBikhXPPPdddeOGFQe7ee+9dycbyPK+VhJQd5ivLKokz6GNmtERnetw8WHiBASyiiwy4HmBJCE6QX0TwEw7C/QyW2HfccUeVyGuuucadccYZ4TzFVupVGXXQcwSwzACWG8CyALj/DBkypOf62IoOwSIPVje8VzVaJ6wWuHwHZMHysMwwf/784FUCdaC+ou43zbaZzwjegymPx7jnYnmMrbfemkmVLSxDHn744WD5ceeddwZr6pNOOqnfueG5gjti/11e01IE6+PymYyyXiFVqdPusO2Ub9O4zzzk75XwIYnvPnjGX3nllcze0i28QVhL6aIrx3PcTzYI5wMWPLUCWZE/34dw3hDwvgSLzrKCV+S7hx56KDyP4e0FAdcBln/Au/kf//jHmtdOrbbhfR9eSFBPnt88mcTXGI/xXtaO3zIs98EkyyOOZfG73/3Off3rX+/327R52Ff+9m0a9/Gtht8SLP1xPtIC33Xid720/IoXgXYRWLhwYbjP4J0s9ubkJ9UGL0r8vbON/K3E8UzXVgR6hQCvcbwvw/PEBhtsELqG75m//e1vYR95sFyTggiIgAiIQLkEpAAul28/6fjogQs3P0s2fEDiOC3AZRkUDnCZsddeezlv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e91114Uy8XtJLIjvTbD8lfVvTEfHIiACIiACIiACIiACaQSkAE4jo3gREAEREAEREAEREIFSCKy55ppu7bXXdrDanTRpUqiDg6HccoAzbwPyun+GvFjhW2vgNW8blE8EREAEREAEREAEahGgQvfJJ58MWeP3krj8hAkT3FJLLeVgFHDPPfeEZL4vxXl1LAIiIAIiIAIiIAIiIAIkIAUwSWgrAiIgAiIgAiIgAiLQMgIcuLzwwgtDnRwMZXy9CmBaAOdR5i6//PLB/SI7W2vglfm0FQEREAEREAEREIFmCfBdh3JqvYcMGzbMjR071mFZsEsvvTQU43sTZWgrAiIgAiIgAiIgAiIgAjEBKYBjIh18vPnmm4d1YrBWDP4UREAEREAEREAERKBbCXDwc86cOaELPOYW6wPXE+qxAIZcDrZizeG11lqrnqqUVwREQAREQAREQAQaJsB3HQrIM3mNZeL3JsrQVgREQAREQAREQAREQARiAlIAx0Q6+HiZZZZxI0aMqPx1cFPVNBEQAREQAREQARHIJMCBTGSCW8Mtt9wy5B8/frxbeuml3aOPPhrWAs4UYhKpAM4ziIpiVAAPHz7cDRkyxEjSrgiIgAiIgAiIgAiURwDvKnbyGd9Jsmq0701x+axyShMBERABERABERABERi4BKQAHrjnXj0XAREQAREQAREQgbYRgMIX1rcIY8aMcXBviDB06FC3ySabuMWLF7upU6eGuDz/6AI6zyAq5FFRnDd/njYojwiIgAiIgAiIgAjkIUCF7rLLLutWW221mkWsy2eWrVlIGURABERABERABERABAY0gWUGdO/VeREQAREQAREQAREQgbYQWHXVVd2GG27onnvuORcPZOIYFsBnn322y7sW8MMPPxz6kVehy3zctgWCKhUBERABERABERiQBKDQvf766yseSWpBwJJggwcPDusAx+9NtcoqXQREQAREQAREQAREYGASkAK4zecd7gpfe+019+abb4a/5ZZbzq288spupZVWCrNAcawgAiIgAiIgAiIgAr1IYOLEiUEBjK0NOL7wwgvdZZddFv5sWq39kSNH1soS0pmP21yFlEkEREAEREAEREAECiDAd5+87yGwFIYS+IEHHnAsW0AzJEIEREAEREAEREAERKCHCUgB3OKTO3/+fHfxxRe7SZMmuccee8zhOC1gzd9x48a5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WPb0r6uKAAECBAgQIECAAAECBGpSQAC4JptVpSpeYPDglUVctGjNRS1NAW0N4DX7OEuAAAECBAgQIECAAAECBAgQIECAAAECBAgQILBGAQHgNbI4SaCHBYa8GQBe2E4AuDQFdFNTDxdE9gQIECBAgAABAgQIECBAgAABAgQIECBAgAABArUkIABcS62pLtUj0NkRwALA1dOmSkqAAAECBAgQIECAAAECBAgQIECAAAECBAgQqAABAeAKaARFqEOBN9cAjvbWAF6xYiWKAHAd/uNQZQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAugv0Xfdb3UmAwLoKNAwcGNHYELHkjSg0N0dDY+vfYjR85J8jiusAN7zrwHV9hPsIECBAgAABAgQIECBAgAABAgQIECBAgAABAgTqUEAAuA4bXZUrRCBNA71gYWSjgIcNa1WoxiPeE5FeNgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJdEGg97LALN0pKgEA3BUpB3zfe6GZGbidAgAABAgQIECBAgAABAgQIECBAgAABAgQIECCwUsAIYP8SCKwngcZzvxyFp/4vGkaOXE8l8FgCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFaExAArrUWVZ+qEWj8lw9XTVkVlAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDoETAFdHe2klAQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOhQQAC4QyIJCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUB0CAsDV0U5KSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgQ4FBIA7JJKAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC1SEgAFwd7aSUdSbQfPMt0XzJZXVWa9UlQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoroAAcHcF3U+gBwSaTz4lmv99chReeqkHcpclAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBArQoIANdqy6pXdQssXryy/A0N1V0PpSdAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOhVAQHgXuX2MAKrBArPPRcr/vXEKEyfsepkaW/p0pV7TU2lM94JECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdCggANwhkQQEekagcNsdUbhqSjT/54/aPmDZspXn+vVre80ZAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAu0ICAC3A+M0gR4XGDhw5SMWLGj7KCOA25o4Q4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0KGAAHCHRBIQ6CGBwYNXZrxwYasHFJqbI5oLEY0N0dDof6KtcBwQIECAAAECBAgQIECAAAECBAgQIECAAAECBAisVUB0aa08LhLoQYEhbwaAF73e+iFG/7b2cESAAAECBAgQIECAAAECBAgQIECAAAECBAgQINBpAQHgTlNJSCBfgYY3RwAXVhsBHKUAsPV/8wWXGwECBAgQIECAAAECBAgQIECAAAECBAgQIECgDgQEgOugkVWxQgWGDFlZsEWLWhdw2bKVx01Nrc87IkCAAAECBAgQIECAAAECBAgQIECAAAECBAgQINCBgABwB0AuE+gxgcGDVma9cLUAsBHAPUYuYwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBArQsIANd6C6tf5QoYAVy5baNkBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEqFRAArtKGU+waEHhzDeBYfQ3gjTaK2GRkNIzZtQYqqQoECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQK9KdC3Nx/mWQQItBAYVJwCuqF4vHhxFAqFaGhIB8VTxZHBfWY/FdGvX3bsPwQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQ6K2AEcGelpCOQs0AW8E1B4EIx40Wt1wFuaGoqB4RzfqzsCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEaljACOAablxVq3yBhveMi8Ksv0ekQLCNAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQDcFBIC7Ceh2At0R6PPf13fndvcSIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQaCVgCuhWHA4IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQvQICwNXbdkpOgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBVgICwK04HBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKB6BQSAq7ftlJwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtBASAW3E4IFAZAoUZD0XhjTcqozBKQYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUDUCAsBV01QKWi8Czb/6dazYY59o/sJ/1EuV1ZMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQCAnAQHgnCBlQyA3gWefW5nVy6/klqWMCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE6kNAALg+2lktK1SgsGxZNN98SxQWLVpVwqVLV+43Na06Z48AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAJwQEgDuBJAmBnhIoXH1NNB/9gSh8+6JVjygGhbOtX79V5+wRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6ISAAHAnkCQh0GMCbwZ7C8/PXfWIpW8GgJsEgFeh2CNAgAABAgQIECBAgAABAgQIECBAgAABAgQIEOiMgABwZ5SkIdBTAkOGrMy55RTQRgD3lLZ8CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1LyAAXPNNrIIVLTB48MriLVy4qpjWAF5lYY8AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBLAgLAXeKSmEDOAkPeDAAver2cceHNAHCDNYDLJnYIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQ6J9C3c8mk6i2BRcWpgB955JGYOXNmzJs3L972trfFjjvuGKNHj44+ffr0VjE8p5cEGt4cAVxoOQK4NAV0U1MvlcJjCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEakVAALiHW/Kuu+6Kv/zlL9lTTjzxxBg0aNAan7i0OOrzvPPOy17LSgHAFil32GGH+MY3vhETJ05scdZu1QusaQ1gU0BXfbOqAAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgfQkIAPew/I033hiXX3559pTjjjtujQHgWbNmxYQJE+Lhhx9utzR/+9vf4uijj47x48fHzTffHH37arp2sarpwuA3fxCwcNGqUi9bvnK/nzZehWKPAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgMwIiTJ1R6sE0hUIhPvrRj7YK/u6xxx4xZsyYGDVqVKTg8F//+tf405/+lJXi9ttvj8mTJ8d3v/vdHiyVrHtNYE0jgPu/OfXzBhv0WjE8iAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDYEBIDXcztecsklcffdd2el2GyzzeKyyy6LY445pk2pfvvb38akSZPi0Ucfje9973sxduzY+Jd/+Zc26ZyoMoE31wCOFmsAN571uSjsOTYa3t/230GV1U5xCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEelmgsZef53GrCVxzzTXZmYaGhrjhhhvWGPxNCQ4++OAsUJyCxGm78MILs3f/qXKBFABuKNZh0aJIo8HT1rDRRtF43LHR0K9fduw/BAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBDorIADcWakeSLdixYqYOXNmlvOxxx4bBxxwwFqfsskmm8R3vvOdLE2aFnrx4sVrTe9i5Qs0NBb/J7jllhEpENzcXPkFVkICBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGKFhAAXo/N88wzz8SSJUuyEuy9996dKkkaCZy25cuXx4wZMzp1j0SVLdDn3t9Gnxn3R0OfPpVdUKUjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoeAEB4PXYRJtuummkqZ/Tlkb3dmYbOXJkDBgwIEs6a9asztwiTYULNIwaFQ3bbVfhpVQ8AgQIECBAgAABAgQIECBAgAABAgQIECBAgACBahAQAF6PrTRkyJAYVQz+pW3q1KmdKknLUcPbCRp2ykwiAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAvUiIADciy390EMPlad8Lj32E5/4RLZ71113RaFQKJ1u9/2CCy4oX9thhx3K+3YIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQF0HvCRx++OHRt2/f2HnnnWPs2LGx5557xr777hvDhg2Lxx57LE477bRoGeBtWbIUHL7ooovi+9//fnY6rQWc7rMRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgJCAAXJLooffSGr+l7JcvXx5pJHB6XXnllaXT2fuFF14YY8aMiY985CPl8/PmzYtLLrkkbr755pg+fXp2vk+fPvGd73ynnMYOAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEkoAAcA//O0jB209/+tNZ8HbGjBlRer3wwgtrfPKyZctanZ8zZ06cc8455XMpoPy1r30tdtttt/I5O7UlsOJzZ0XhN3dFn3v+NxoGD66tyqkNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAjwoIAPcob0RjY2PsuOOO2euDH/xg+WnPPvtsORicgsJpdO9TTz0V2267bTlN2tlkk03KxyNGjIgpU6bE+PHjy+fs1J5A4ZbbIh79W8TfZ0e8fcfaq6AaESBAgAABAgQIECBAgAABAgQIECBAgAABAgQI9JiAAHCP0a494y222CLSq2Uwd8GCBdHU1NTqxpEjR8YZZ5wR48aNi//3//5fDBgwoNV1B7UhUChODd5QXB8625a+OQq8qV9tVE4tCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEek2gsdee5EEdCgwdOjT69+/fKl3fYlDwG9/4Rhx66KGCv61kauegcN/UWDFog2j+3qUrK7V06cr3fgLAtdPKakKAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6B0BAeDecfYUAu0KFP7v6Yhly6Pwxz+tTFNaB3q10eDtZuACAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgTcFTAG9nv8ppLWAX3755Xj99dezV5riefjw4TFs2LBIa/6a8nk9N1BvPL7Y1tk2f/7K91IA2Ajg3tD3DAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBATQkIAPdyc6Z1fqdMmRLXXnttPPzww5GO29vS9M+77rpr7LPPPjFhwoRsveCGhob2kjtfrQLDhq4s+YKFK99LU0AbAVytLarcBAgQIECAAAECBAgQIECAAAECBAgQIECAAIH1JmAK6F6inzt3bkyaNCm23HLLOPnkk2Pq1KlrDf6mYi1fvjymT58el19+eRYA3m233eK2227rpRJ7TG8JNBTXfk5boTQCuBQANgK4t5rAcwgQIECAAAECBAgQIECAAAECBAgQIECAAAECNSNgBHAvNOUrr7wS48aNi5kzZ5aflkbybr755jFq1KgYOXJkDBw4MPr3758FfZcsWRLzi8HA2bNnx6xZs+KNN97I7ksjht/73vfGBRdcEKeccko5LztVLlCeAvrN0eClKaCNAK7yhlV8AgQIECBAgAABAgQIECBAgAABAgQIECBAgEDvCwgA97D5okWL4sgjjywHf/faa6+YPHlyHHLIIVngt6PHLysGA++///5s2uirrroq0vFnP/vZGD16dDYldEf3u14FAkOHrCxkcTrwwooVEc2FiD6N0dBogH4VtJ4iEiBAgAABAgQIECBAgAABAgQIECBAgAABAgQqSkCEqYeb44Ybbsime06POe6442LatGnZexr125mtX3Ea4P333z+uuOKKuOmmmyIdp+3MM8+M5ubmzmQhTaULlEcAz49ihH9laU3/XOmtpnwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYoUEADu4Wa57777siek9XunTJkSjd0Y1Tl+/Pj49re/neWXppN++umne7j0su8NgYZBg7IRv7F4SURx+u9sK04HbiNAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQVQEB4K6KdTH9vffem91x1FFHlUfvdjGLVsnf//73l48ff/zx8r6dKhcYOnRlBQqFaJj86Wg863NVXiHFJ0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQWB8C1gDuYfU5c+ZkT9h6661zedKIESOyQHJaC3jx4sW55CmTChBI00C/+lrE/PnR54JvVkCBFIEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAaBYwA7uFW22677bInTJ06NZcnpSmlU/A3bXvssUcuecqkAgQ23GBlIZa8UQGFUQQCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFqFRAA7uGWGzt2bPaE66+/Pn73u99162mvvvpqnHrqqVkeG220UWy77bbdys/NlSPQ+K3zo/H8r0aMflvlFEpJCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEqk7AFNA93GSf//znY8qUKbFkyZKYOHFifOMb34gTTjghmpqauvTkGTNmxIknnhjpPW0nnXRSl+7vTuKf/exn8cMf/jCam5u7k01275NPPpm9L1q0qNt51VIGjeMOjUgvGwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFuCAgAdwOvM7emKaDPO++8OP300+O1117LArdp/6CDDordd989G8W76aabxsCBA2PAgAGxfPnyLFg8v7gW7OzZsyMFTO+55554+OGHy4877LDD4qtfLY4W7aXtuuuui1/96le5Pk0AOFdOmREgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDIBASAe+EfwmmnnRYjRoyISZMmxeLFi2PBggVx6623Zq+uPv7www+Pa6+9Nhobe2/27h/96EdZ4LpQKHS1uG3SX3bZZXHTTTfF+9///jbXnCBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoHsCAsDd8+v03Wna5wkTJsR3vvOduPLKK+P555/v9L39+/ePFPj9+Mc/nuXR6RtzSjh8+PA49NB8pie+/fbbs1L1ZgA7JwbZECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKh4AQHgXmyikSNHxrnnnpu9nnnmmZg2bVo88cQTkaZ7TtNDp5HB/fr1iyFDhsSwYcMiTR+90047xZgxY7JzvVhUjyJAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoAoFBIDXU6O95S1vifSyEWgpUFiyJJq/dn40vndCNOy9V8tL9gkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0KNB7C8l2WBQJCBAo3P27KJz7jWg+/5swCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHRZQAC4y2RuINCDAouXrMy8oaEHHyJrAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBWhUwBXQVteyyZcti7ty55RJvtdVW5X071S1QKK7/3PzxkyKKbZxtxbWgbQQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6KiAA3FWx9Zj+L3/5S+y5557lEhQKhfK+nSoXmPlwFG7471WVaGpatW+PAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQCcFTAHdSSjJCPSowODBrbM3Ari1hyMCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFOCQgAd4pJIgI9LDBsaOsHGAHc2sMRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBApwRMAd0ppspINGbMmHj++ecrozBKka/AsGGt8xMAbu3hiAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoFMCAsCdYqqMRH379o1NN920MgqjFPkKDF1tBHA//9PMF1huBAgQIECAAAECBAgQIECAAAECBAgQIECAAIH6EDAFdH20s1pWuEBDGvHbv/gqbUYAlyS8EyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdEFAALgLWJIS6FGBlqOA+/Xr0UfJnAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoDYFzDO7ntv12WefjZdffjlef/317DVgwIAYPnx4DCuuCTtixIhIx7Y6EUjrAL80L6tsNiK4TqqtmgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAvkJCADnZ9mpnBYsWBBTpkyJa6+9Nh5++OFIx+1tac3fXXfdNfbZZ5+YMGFCjB8/PhoaGtpL7ny1CwwdsrIGjcU2HrNbtddG+QkQIECAAAECBAgQIECAAAECBAgQIECAAAECBNaDgCmgewl97ty5MWnSpNhyyy3j5JNPjqlTp641+JuKtXz58pg+fXpcfvnlWQB4t912i9tuu62XSuwxvS6QRgAXt8Zf3xaNRx3Z64/3QAIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgeoXMAK4F9rwlVdeiXHjxsXMmTPLT0sjeTfffPMYNWpUjBw5MgYOHBj9+/fPgr5LliyJ+fPnx+zZs2PWrFnxxhtvZPelEcPvfe9744ILLohTTjmlnJed2hBoGDY0CqkqS1a2d23USi0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgR6U0AAuIe1Fy1aFEceeWQ5+LvXXnvF5MmT45BDDskCvx09ftmyZXH//fdn00ZfddVVkY4/+9nPxujRo7MpoTu63/XqEWg4ZmIU5vwjGnbduXoKraQECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIVJWAK6B5ujhtuuCGb7jk95rjjjotp06Zl72nUb2e2fv36xf777x9XXHFF3HTTTZGO03bmmWdGc3NzZ7KQpkoEGj92QvSd8adoKI4KtxEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBYFwEB4HVR68I99913X5Y6rd87ZcqUaGxcd/Lx48fHt7/97Sy/NJ30008/3YWSSEqAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQK0LrHs0stZlcqrfvffem+V01FFHlUfvdifr97///eXbH3/88fK+HQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECAgA9/C/gTlz5mRP2HrrrXN50ogRI8qB5MWLF+eSp0wIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgNAQHgHm7H7bbbLnvC1KlTc3lSmlJ62bJlWV577LFHLnnKhAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB2hAQAO7hdhw7dmz2hOuvvz5+97vfdetpr776apx66qlZHhtttFFsu+223crPzZUnUJg/PwozH668gikRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVQgIAPdwM33+85/PpmxesmRJTJw4Ma644opYunRpl586Y8aMOOywwyK9p+2kk07qch5uqHyB5hM+ESt22zMKjz5W+YVVQgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYoT6FtxJaqxAqUpoM8777w4/fTT47XXXssCt2n/oIMOit133z0bxbvpppvGwIEDY8CAAbF8+fJIweL5xZGgs2fPjieffDLuueeeePjhVaNCUyD4q1/9ao1JqU4SKDz3/EqI4mhvGwECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGuCggAd1VsHdKfdtppMWLEiJg0aVIsXrw4FixYELfeemv26mp2hx9+eFx77bXR2GjwdlftqiJ98d9HtvXrVxXFVUgCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHKEhBF7KX2OOGEE2LWrFlx1llnxWabbdalp/bv3z+bPvqWW26JO+64I9L6v7baEyjMmxcx4y8rK9bUVHsVVCMCBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEeFzACuMeJVz1g5MiRce6552avZ555JqZNmxZPPPFENt1zmh46jQzuVxz5OWTIkBg2bFik6aN32mmnGDNmTHZuVU72alKgT59V1TICeJWFPQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgU4LCAB3mirfhG95y1sivWwEygJDh5Z3o8kU0Ksw7BEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHRWwBTQnZWSjkAPCzSkEcCDBq58ihHAPawtewIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAbQoIANdmu6pVtQpsvPHKkhenAbcRIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6KqAKaC7KiY9gR4U6PNfV0fhhRejYaONevApsiZAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKhVAQHgWm1Z9apKgYb994uGqiy5QhMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECFSCgCmgK6EVlIEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI5CAgA54AoCwIECBAgQIAAAQIECBAg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AeDKbRslI0CAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQJcEBIC7xCUxAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKldAALhy20bJCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0CUBAeAucUlMgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACByhUQAK7ctlEyAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdElAALhLXBITIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgcgUEgCu3bZSMAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECXRIQAO4Sl8QECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoXAEB4MptGyUjQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAlwQEgLvEJTEBAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqV0AAuHLbRskIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQJQEB4C5xSUyAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHKFRAArty2UTICBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAh0SUAAuEtcEhMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKByBQSAK7dtlIwAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJdEhAA7hKXxAQ6LzB8+PAs8bBhwzp/k5QECBCoAoFSv1bq56qgyIpIgACBTgno3zrFJBEBAlUoMHjw4OjTp0+U+rkqrIIiEyBAYI0Cffv2jUGDBunf1qjjJAEC1S6QPrs1NTXFwIEDq70qyr8eBBoKxW09PNcjCdS8QHNzc9xxxx1xwAEH+BBa862tggTqT+BXv/pVvOMd74iRI0fWX+XVmACBmha4++67Y/vtt4+tttqqpuupcgQI1J/AtGnTYuONN876uPqrvRoTIFDLAjNmzIgUCN5ll11quZrqRoBAHQo89thjsXDhwthzzz3rsPaq3F0BAeDuCrqfAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECFSJgCugKaQjFIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAQHcFBIC7K+h+AgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIVIiAAHCFNIRiECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoLsCAsDdFXQ/AQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEKkRAALhCGkIxCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0F0BAeDuCrqfAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECFSIgAFwhDaEYBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6K6AAHB3Bd1PgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBChEQAK6QhlAMAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIdFdAALi7gu4nQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAhQgIAFdIQygGAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEuisgANxdQfcTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECgQgQEgCukIRSDAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAEC3RUQAO6uoPsJECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBQIQICwBXSEIpBgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACB7goIAHdX0P0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoEAEB4AppCMUgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAdwUEgLsr6H4CBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAhUiIAAcIU0hGIQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECguwICwN0VdD8BAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQqREAAuEIaQjEIECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECDQXQEB4O4Kup8AAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIVIiAAXCENoRgECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoroAAcHcF3U+AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAIEKERAA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yvvFaaJjypQpUVxzLoqjScrnV9/Jq1/KK5/Vy+eYAAEC6yqw0UYbxR133BFnnXVWpP20lb5/S/u77rprFEfkZd/DpeP2Nv1bezLOEyDQVYEzzzwziuuSx8EHH1y+tfT5rTirS+y2225RnM0qvvvd70Y6bm/Tv7Un4/y6CjSkyPG63uw+AgTWLFBc8zdmzJgRf//73+Otb31rFBd2j+HDh685sbMECBCoIoG8+re88qkiOkUlQKDCBfLql/LKp8K5FI8AgV4QeO211yL98OWpp56KFPjdeeedY5NNNunyk/Pql/LKp8sVcAMBAgTWIvD000/H9OnTY+DAgTF69OjYdtttozgN61ruaHtJ/9bWxBkCBNZNYP78+fG3v/0t+/y2zTbbRHGq+qx/Wpfc9G/rouaelgICwC017BMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCKBbr2c6gqrqiiEyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoNYFBIBrvYXVjwABAgQIECBAgAABAgQIECBAgAABAgQIECBAgACBuhEQAK6bplZRAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAgRqXUAAuNZbWP0IECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEKgbAQHgumlqFSVAgAABAgQIECBAgACB9gSeeeaZ9i45T4AAAQIECBAgQIAAAQIEqkpAALiqmkthCRAgQIAAAQIECBAgQCBPgUWLFsWZZ54Z++23X57ZyosAAQIECBAgQIAAAQIECKw3gb7r7ckeTIAAAQIECBAgQIAAAQIE1rPAgQceGA8++GCMGDFiPZfE4wkQIECAAAECBAgQIECAQD4CRgDn4ygXAgQIECBAgAABAgQIEKhCgZdffjkrdUNDQxWWXpEJECBAgAABAgQIECBAgEBbAQHgtibOECBAgAABAgQIECBAgAABAgQIECBAgAABAgQIECBAoCoFBICrstkUmgABAgQIECBAgAABAgQIECBAgAABAgQIECBAgAABAm0FrAHc1sQZAgQIECBAgAABAgQIEKhxgcmTJ8frr78e8+bNy2q6cOHCOOmkk7L90aNHR7qetrvvvjuuu+66bP/rX/96vPbaa5Heb7vtthg8eHAcdthhceqpp8aoUaOyNKX/zJgxI372s59Fen/ooYeif//+sfvuu2evj3/847HZZpuVkq71vbv5PPPMM3HJJZfEn//853jyySejUCjETjvtlL3233//OPbYY9f6fBcJECBAgAABAgQIECBAoPoEGop//BWqr9hKTIAAAQIECBAgQIAAAQIE1l1gww03jFdffXWNGbzrXe+K3/72t9m1Sy+9NE4++eRsPwVy3/ve98asWbNa3fejH/0o/vVf/zU719zcnAWIzznnnFi2bFmrdKWDkSNHxg9+8IOYOHFi6VSb9zzySYHfU045JVasWNEm/9KJCRMmRCr/JptsUjrlnQABAgQIECBAgAABAgSqXEAAuMobUPEJECBAgAABAgQIECBAoOsCaYTv4sWL49prr40FCxbEgAED4qMf/WiWURoB/NnPfjbbbxkAHjduXNx5553Z+T59+mSB1UGDBsXzzz8fQ4cOzc4feeSRcfvtt2f7AwcOjA9+8IPZqN8lS5bE/fffHzfddFMsX748u37hhReWn5OdaPGf7uZzyy23xNFHHx0pkDx8+PD48Ic/HG9/+9uz41SHu+66K9Ko57SlkcnTp09v8XS7BAgQIECAAAECBAgQIFDNAgLA1dx6yk6AAAECBAgQIECAAAEC3RLYdtttI02TvPHGG8eLL77YJq+WAeB0cbvttouLL744Dj300Gxq53RvaRrlNFV0CvimbcyYMXHjjTfG2972tuy49J977rknPvCBD8QLL7yQTSH9+OOPxxZbbFG6nL3nkc973vOe+PWvf50Ff1NwN9Wz5ZaC3qlsc+fOzU4/+OCDsccee7RMYp8AAQIECBAgQIAAAQIEqlSgsUrLrdgECBAgQIAAAQIECBAgQKBXBRobG+Pqq6+ONDo3rem79957l4O/aT3hM844IytPGvl7ww03tAn+posHHnhgXHPNNVm6RYsWxec+97lsv/SfPPJJo37vu+++LMsU1F09+JsupBHL//Ef/5HVY8cdd8zWKi6VwTsBAgQIECBAgAABAgQIVLeAAHB1t5/SEyBAgAABAgQIECBAgEAvCYwdOzb233//NT4tTbk8e/bs7FqabjlNI93edthhh8XOO++cXf7pT38aS5cuLSfNI58UqN5ss82yPKdNm5ZNPV1+QIudT37yk5ECzo8++miccMIJLa7YJUCAAAECBAgQIECAAIFqFhAArubWU3YCBAgQIECAAAECBAgQ6DWB7bffvt1npamcS1t7QeLS9fSeRg+nbcWKFfH0009n++k/eeWTpoBOW1p7OJXnuOOOy0Yep6mnS1tDQ0OkYLGNAAECBAgQIECAAAECBGpLoG9tVUdtCBAgQIAAAQIECBAgQIBAzwisvp5vy6c88cQT5cPTTjstzjrrrPLxmnbmz59fPp3u3WGHHbLjvPI5++yzY+rUqZHW9l2+fHlcf/312SsFfd/xjnfEEUccEUcffXSkUc02AgQIECBAgAABAgQIEKgtAQHg2mpPtSFAgAABAgQIECBAgACBHhLYaqut2s35ySefLF978cUXy/ud2XnqqafKyfLKJ00Bfc8998TJJ58caZrpN954I3tGoVCIBx54IHt97Wtfy6ai/slPfhK77757uQx2CBAgQIAAAQIECBAgQKC6BQSAq7v9lJ4AAQIECBAgQIAAAQIEeklgbdMlDx48uFyKc845J0aMGFE+7min5ZTReeWTnpnyuuqqq+Kiiy6KtLbwr371q7jzzjuj5TTQjzzySOy3335x7bXXxjHHHNNRUV0nQIAAAQIECBAgQIAAgSoQEACugkZSRAIECBAgQIAAAQIECBCobIHRo0fHb37zm6yQaX3fNMXyumx55dPy2RtssEF8+MMfzl5pBHCaFvrWW2+NH/zgB/GPf/wjFi9eHF/5ylcEgFui2SdAgAABAgQIECBAgEAVCzRWcdkVnQABAgQIECBAgAABAgQIVIRACtyWthRg7WibPn16/PGPf4y5c+dGCsqWtrzymTNnTjba9+9//3sp6+w9rQGc1v390pe+FA899FBsueWW2fm0//zzz7dK64AAAQIECBAgQIAAAQIEqlNAALg6202pCRAgQIAAAQIECBAgQCAHgT59+mS5rFixolu57bvvvuX7L7vssliwYEH5ePWdNOI2jRBO96S1eh999NFykjzySdM5b7311nHYYYdFKkt7W5qmeq+99soupyB0ChrbCBAgQIAAAQIECBAgQKD6BQSAq78N1YAAAQIECBAgQIAAAQIE1lGgtOZuCtguWbJkHXOJ2GeffeIDH/hAdv+zzz4bkydPjvaCymeccUY28jclPvTQQ2OnnXYqPzePfI466qjo379/luePfvSjWH0UcOlhr7zySkydOjU7HDhwYOywww6lS94JECBAgAABAgQIECBAoIoFBICruPEUnQABAgQIECBAgAABAgS6J7DppptmGSxfvjwmTJgQF110UVx55ZXrlOkFF1wQgwYNyu794Q9/GAcddFDcfffdMX/+/CwYPHPmzDj++OPjkksuydKktOedd16bZ3U3n2HDhsUJJ5yQ5fvSSy/FwQcfHD/96U9j3rx52bmFCxdm00On4HOagjptJ510UgwdOjTb9x8CBAgQIECAAAECBAgQqG6BhuI0T6sWG6ruuig9AQIECBAgQIAAAQIECBDoksCll14aJ598cqt7Ro4cGS+88EJ2ruX1FNT92Mc+1irt6gd33XVXFnxtOeo2rbubpppOQebS1q9fv/jFL34Rhx9+eOlUq/fu5rN06dJ497vfHffee2+rfAcMGNBmpPPpp58eX//616Ox0W/EW2E5IECAAAECBAgQIECAQJUK+OuuShtOsQkQIECAAAECBAgQIECg+wKTJk2KL3zhC1EaCZxyfPHFF8ujZbv6hBR0ffjhh+Pf/u3fYsMNN8xuT7+7LgV/UyD4Ix/5SDzyyCPtBn/TTd3Np6mpKX7961/HhRdeGFtssUW5GqVprtP1PfbYI9J6wd/85jcFf8tCdggQIECAAAECBAgQIFD9AkYAV38bqgEBAgQIECBAgAABAgQI5CAwZ86cSGsBjxo1KkprA3c327QecAoIL1q0KN761rdmr3WZark7+aTg8+zZs7O1gNOUz9tvv33ssssukYLANgIECBAgQIAAAQIECBCoPQEB4NprUzUiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBOBUwBXacNr9oECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNSegABw7bWpGhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUKcCAsB12vCqTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA7QkIANdem6oRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1KiAAXKcNr9oECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNSegABw7bWpGhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUKcCAsB12vCqTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA7QkIANdem6oRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1KiAAXKcNr9oECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNSegABw7bWpGhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUKcCAsB12vCqTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA7QkIANdem6oRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1KiAAXKcNr9oECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNSegABw7bWpGhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUKcCAsB12vCqTYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA7QkIANdem6oRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ1KiAAXKcNr9oECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECNSegABw7bWpGhEgQIDA/2/PjgkAAAAQhPVvbQ9ZBOcJAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBUQgKPHm02AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJ+AAPz3qUUECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEQFBODo8WYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIPAnIAD/fWoRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJRAQE4erzZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj8CQjAf59aRIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVEAAjh5vNgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfwIC8N+nFhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBUQgKPHm02AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJ+AAPz3qUUECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEQFBODo8WYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIPAnIAD/fWoRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJRAQE4erzZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj8CQjAf59aRIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVEAAjh5vNgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfwIC8N+nFhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBUQgKPHm02AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJ+AAPz3qUUECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEQFBODo8WYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIPAnIAD/fWoRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJRAQE4erzZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj8CQjAf59aRIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVEAAjh5vNgECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECfwIC8N+nFhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBUQgKPHm02AAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAwJ+AAPz3qUUECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECEQFBODo8WYTIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIPAnIAD/fWoRAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJRAQE4erzZBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAj8CQzFzGUwSP7MAAAAAABJRU5ErkJggg==">
=========================

Github files; <a href="https://github.com/ghettocounselor">https://github.com/ghettocounselor</a>
Useful PDF for common questions in Lectures;
<a href="https://github.com/ghettocounselor/Machine_Learning/blob/master/Machine-Learning-A-Z-Q-A.pdf">https://github.com/ghettocounselor/Machine_Learning/blob/master/Machine-Learning-A-Z-Q-A.pdf</a>

<b>Random Forests tutorials</b>
<a href="Decision Trees.html" class="whitebut ">Decision Trees</a>
<a href="http://en.wikipedia.org/wiki/Decision_tree_learning">Decision tree learning</a>
<a href="http://machinelearningmastery.com/classification-and-regression-trees-for-machine-learning/">classification and regression trees for machine learning</a>
<a href="http://documents.software.dell.com/statistics/textbook/classification-and-regression-trees">classification and regression trees</a>
<a href="http://www.stat.berkeley.edu/~breiman/RandomForests/cc_home.htm">Random Forests</a>
<a href="http://www.listendata.com/2014/11/random-forest-with-r.html" class="goldbut">Random Forest In R</a>
<a href="http://bayesianquest.wordpress.com/category/random-forest/">Random Forest</a>


<h2>R Random Forest Tutorial with Example</h2>
<div id="RandomForestTuttoc" class="toc"><a href="#RandomForestTuttopic-0" target="_self"><span class="orange">What is Random Forest in R?</span></a><br><a href="#RandomForestTuttopic-1" target="_self"><span class="orange"><k>Step 1)</k> Import the data</span></a><br><a href="#RandomForestTuttopic-2" target="_self"><span class="orange"><k>Step 2) </k>Train the model</span></a><br><a href="#RandomForestTuttopic-3" target="_self">Grid Search definition</a><br><a href="#RandomForestTuttopic-4" target="_self">Random Search definition</a><br><a href="#RandomForestTuttopic-5" target="_self">Set the control parameter</a><br><a href="#RandomForestTuttopic-6" target="_self">Default setting</a><br><a href="#RandomForestTuttopic-7" target="_self"><span class="orange"><k>Step 3)</k> Search the best maxnodes</span></a><br><a href="#RandomForestTuttopic-8" target="_self"><span class="orange"><k>Step 4)</k> Search the best ntrees</span></a><br><a href="#RandomForestTuttopic-9" target="_self"><span class="orange"><k>Step 5)</k> Evaluate the model</span></a><br><a href="#RandomForestTuttopic-10" target="_self"><span class="orange"><k>Step 6)</k> Visualize Result</span></a><br><a href="#RandomForestTuttopic-11" target="_self"><span class="orange">Summary</span></a><br></div></center>
<h3 id="RandomForestTuttopic-0"><span class="orange">What is Random Forest in R?</span></h3>
Random forests are based on a simple idea: 'the wisdom of the crowd'.
Aggregate of the results of multiple predictors gives a better prediction than the best individual predictor.
A group of predictors is called an <k>ensemble</k>.
Thus, this technique is called <k>Ensemble Learning</k>.

In earlier tutorial, you learned how to use <k>Decision trees</k> to make a binary prediction.
To improve our technique, we can train a group of <k>Decision Tree classifiers</k>, each on a different random subset of the train set.
To make a prediction, we just obtain the predictions of all individuals trees, then predict the class that gets the most votes.
This technique is called <k>Random Forest</k>.

<h3 id="RandomForestTuttopic-1"><span class="orange"><k>Step 1)</k> Import the data</span></h3>
To make sure you have the same dataset as in the tutorial for decision trees, the train test and test set are stored on the internet.
You can import them without make any change.

<small>library(dplyr)
data_train &lt;- read.csv("https://raw.githubusercontent.com/guru99-edu/R-Programming/master/train.csv")
glimpse(data_train)
data_test &lt;- read.csv("https://raw.githubusercontent.com/guru99-edu/R-Programming/master/test.csv") 
glimpse(data_test)
</small>
<h3 id="RandomForestTuttopic-2"><span class="orange"><k>Step 2) </k>Train the model</span></h3>
One way to evaluate the performance of a model is to train it on a number of different smaller datasets and evaluate them over the other smaller testing set.
This is called the <k>F-fold cross-validation</k> feature.
R has a function to randomly split  number of datasets of almost the same size.
For example, if k=9, the model is evaluated over the nine folder and tested on the remaining test set.
This process is repeated until all the subsets have been evaluated.
This technique is widely used for model selection, especially when the model has parameters to tune.

Now that we have a way to evaluate our model, we need to figure out how to choose the parameters that generalized best the data.

Random forest chooses a random subset of features and builds many Decision Trees.
The model averages out all the predictions of the Decisions trees.

Random forest has some parameters that can be changed to improve the generalization of the prediction.
You will use the function RandomForest() to train the model.

Syntax for Randon Forest is

RandomForest(formula, ntree=n, mtry=FALSE, maxnodes = NULL)
Arguments:
- Formula: Formula of the fitted model
- ntree: number of trees in the forest
- mtry: Number of candidates draw to feed the algorithm.
By default, it is the square of the number of columns.
- maxnodes: Set the maximum amount of terminal nodes in the forest
- importance=TRUE: Whether independent variables importance in the random forest be assessed

<k>Note</k>: Random forest can be trained on more parameters.
You can refer to the <a href="https://cran.r-project.org/web/packages/randomForest/randomForest.pdf" data-lasso-id="209881">vignette</a> to see the different parameters.

Tuning a model is very tedious work.
There are lot of combination possible between the parameters.
You don't necessarily have the time to try all of them.
A good alternative is to let the machine find the best combination for you.
There are two methods available:

<k>Random Search
Grid Search</k>

We will define both methods but during the tutorial, we will train the model using grid search

<h3 id="RandomForestTuttopic-3">Grid Search definition</h3>
The grid search method is simple, the model will be evaluated over all the combination you pass in the function, using cross-validation.

For instance, you want to try the model with 10, 20, 30 number of trees and each tree will be tested over a number of mtry equals to 1, 2, 3, 4, 5.
Then the machine will test 15 different models:
<small>
    .mtry ntrees
 1      1     10
 2      2     10
 3      3     10
 4      4     10
 5      5     10
 6      1     20
 7      2     20
 8      3     20
 9      4     20
 10     5     20
 11     1     30
 12     2     30
 13     3     30
 14     4     30
 15     5     30	
</small>
The algorithm will evaluate:
<small>
RandomForest(formula, ntree=10, mtry=1)
RandomForest(formula, ntree=10, mtry=2)
RandomForest(formula, ntree=10, mtry=3)
RandomForest(formula, ntree=20, mtry=2)
...
</small>
Each time, the random forest experiments with a cross-validation.
One shortcoming of the grid search is the number of experimentations.
It can become very easily explosive when the number of combination is high.
To overcome this issue, you can use the random search

<h3 id="RandomForestTuttopic-4">Random Search definition</h3>
The big difference between random search and grid search is, random search will not evaluate all the combination of hyperparameter in the searching space.
Instead, it will randomly choose combination at every iteration.
The advantage is it lower the computational cost.

<h3 id="RandomForestTuttopic-5">Set the control parameter</h3>
You will proceed as follow to construct and evaluate the model:
<ul><li>Evaluate the model with the default setting</li>
<li>Find the best number of mtry</li>
<li>Find the best number of maxnodes</li>
<li>Find the best number of ntrees</li>
<li>Evaluate the model on the test dataset</li>
</ul>
Before you begin with the parameters exploration, you need to install two libraries.

<ul><li>caret: R machine learning library.
If you have install R with r-essential.
It is already in the library
<ul><li><a href="https://anaconda.org/r/r-caret" data-lasso-id="209882">Anaconda</a>: conda install -c r r-caret</li>
</ul></li>
<li>e1071: R machine learning library.
<ul><li><a href="https://anaconda.org/r/r-caret" data-lasso-id="209883">Anaconda</a>: conda install -c r r-e1071</li>
</ul></li>
</ul>
You can import them along with RandomForest
<small>
library(randomForest)
library(caret)
library(e1071)
</small>
<h3 id="RandomForestTuttopic-6">Default setting</h3>
K-fold cross validation is controlled by the trainControl() function
<small>
trainControl(method = "cv", number = n, search ="grid")
arguments
- method = "cv": The method used to resample the dataset.

- number = n: Number of folders to create
- search = "grid": Use the search grid method.</small>
For randomized method, use "grid"
Note: You can refer to the vignette to see the other arguments of the function.

You can try to run the model with the default parameters and see the accuracy score.

<k>Note</k>: You will use the same controls during all the tutorial.
<small>
# Define the control
trControl &lt;- trainControl(method = "cv",
    number = 10,
    search = "grid")
</small>
You will use caret library to evaluate your model.
The library has one function called train() to evaluate almost all machine learning algorithm.
Say differently, you can use this function to train other algorithms.

The basic syntax is:
<small>
train(formula, df, method = "rf", metric= "Accuracy", trControl = trainControl(), tuneGrid = NULL)
argument
- `formula`: Define the formula of the algorithm
- `method`: Define which model to train.
Note, at the end of the tutorial, there is a list of all the models that can be trained
- `metric` = "Accuracy": Define how to select the optimal model
- `trControl = trainControl()`: Define the control parameters
- `tuneGrid = NULL`: Return a data frame with all the possible combination
</small>
Let's try the build the model with the default values.
<small>
set.seed(1234)
# Run the model
rf_default &lt;- train(survived~.,
    data = data_train,
    method = "rf",
    metric = "Accuracy",
    trControl = trControl)
# Print the results
print(rf_default)
</small>
<r>Code Explanation</r>
<ul><li>trainControl(method=”cv”, number=10, search=”grid”): Evaluate the model with a grid search of 10 folder</li>
<li>train(…): Train a random forest model.
Best model is chosen with the accuracy measure.</li>
</ul>
<k>Output:</k>

## Random Forest 
## 
## 836 samples
##   7 predictor
##   2 classes: 'No', 'Yes' 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 753, 752, 753, 752, 752, 752, ...

## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    2    0.7919248  0.5536486
##    6    0.7811245  0.5391611
##   10    0.7572002  0.4939620
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.

The algorithm uses 500 trees and tested three different values of mtry: 2, 6, 10.

The final value used for the model was mtry = 2 with an accuracy of 0.78.
Let's try to get a higher score.

<k>Step 2)</k> Search best mtry

You can test the model with values of mtry from 1 to 10

set.seed(1234)
tuneGrid &lt;- expand.grid(.mtry = c(1: 10))
rf_mtry &lt;- train(survived~.,
    data = data_train,
    method = "rf",
    metric = "Accuracy",
    tuneGrid = tuneGrid,
    trControl = trControl,
    importance = TRUE,
    nodesize = 14,
    ntree = 300)
print(rf_mtry)

<r>Code Explanation</r>
<ul><li>tuneGrid &lt;- expand.grid(.mtry=c(3:10)): Construct a vector with value from 3:10</li>
</ul>
The final value used for the model was mtry = 4.
<small>
## Random Forest 
## 
## 836 samples
##   7 predictor
##   2 classes: 'No', 'Yes' 
## 
## No pre-processing
## Resampling: Cross-Validated (10 fold) 
## Summary of sample sizes: 753, 752, 753, 752, 752, 752, ...

## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa    
##    1    0.7572576  0.4647368
##    2    0.7979346  0.5662364
##    3    0.8075158  0.5884815
##    4    0.8110729  0.5970664
##    5    0.8074727  0.5900030
##    6    0.8099111  0.5949342
##    7    0.8050918  0.5866415
##    8    0.8050918  0.5855399
##    9    0.8050631  0.5855035
##   10    0.7978916  0.5707336
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 4.
</small>
The best value of mtry is stored in:

<small>rf_mtry$bestTune$mtry</small>
You can store it and use it when you need to tune the other parameters.
<small>
max(rf_mtry$results$Accuracy)</small>
<k>Output:</k>

## [1] 0.8110729
best_mtry &lt;- rf_mtry$bestTune$mtry 
best_mtry

<k>Output:</k>

## [1] 4
<h3 id="RandomForestTuttopic-7"><span class="orange"><k>Step 3)</k> Search the best maxnodes</span></h3>
You need to create a loop to evaluate the different values of maxnodes.
In the following code, you will:

<ul><li>Create a list</li>
<li>Create a variable with the best value of the parameter mtry; Compulsory</li>
<li>Create the loop</li>
<li>Store the current value of maxnode</li>
<li>Summarize the results</li>
</ul>
store_maxnode &lt;- list()
tuneGrid &lt;- expand.grid(.mtry = best_mtry)
for (maxnodes in c(5: 15)) {
    set.seed(1234)
    rf_maxnode &lt;- train(survived~.,
        data = data_train,
        method = "rf",
        metric = "Accuracy",
        tuneGrid = tuneGrid,
        trControl = trControl,
        importance = TRUE,
        nodesize = 14,
        maxnodes = maxnodes,
        ntree = 300)
    current_iteration &lt;- toString(maxnodes)
    store_maxnode[[current_iteration]] &lt;- rf_maxnode
}
results_mtry &lt;- resamples(store_maxnode)
summary(results_mtry)

<r>Code explanation</r>:

<ul><li>store_maxnode &lt;- list(): The results of the model will be stored in this list</li>
<li>expand.grid(.mtry=best_mtry): Use the best value of mtry</li>
<li>for (maxnodes in c(15:25)) { … }: Compute the model with values of maxnodes starting from 15 to 25.</li>
<li>maxnodes=maxnodes: For each iteration, maxnodes is equal to the current value of maxnodes.
i.e 15, 16, 17, …</li>
<li>key &lt;- toString(maxnodes): Store as a string variable the value of maxnode.</li>
<li>store_maxnode[[key]] &lt;- rf_maxnode: Save the result of the model in the list.</li>
<li>resamples(store_maxnode): Arrange the results of the model</li>
<li>summary(results_mtry): Print the summary of all the combination.</li>
</ul>
<k>Output:</k>

## 
## Call:
## summary.resamples(object = results_mtry)
## 
## Models: 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 
## Number of resamples: 10 
## 
## Accuracy 
##         Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 5  0.6785714 0.7529762 0.7903758 0.7799771 0.8168388 0.8433735    0
## 6  0.6904762 0.7648810 0.7784710 0.7811962 0.8125000 0.8313253    0
## 7  0.6904762 0.7619048 0.7738095 0.7788009 0.8102410 0.8333333    0
## 8  0.6904762 0.7627295 0.7844234 0.7847820 0.8184524 0.8433735    0
## 9  0.7261905 0.7747418 0.8083764 0.7955250 0.8258749 0.8333333    0
## 10 0.6904762 0.7837780 0.7904475 0.7895869 0.8214286 0.8433735    0
## 11 0.7023810 0.7791523 0.8024240 0.7943775 0.8184524 0.8433735    0
## 12 0.7380952 0.7910929 0.8144005 0.8051205 0.8288511 0.8452381    0
## 13 0.7142857 0.8005952 0.8192771 0.8075158 0.8403614 0.8452381    0
## 14 0.7380952 0.7941050 0.8203528 0.8098967 0.8403614 0.8452381    0
## 15 0.7142857 0.8000215 0.8203528 0.8075301 0.8378873 0.8554217    0
## 
## Kappa 
##         Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 5  0.3297872 0.4640436 0.5459706 0.5270773 0.6068751 0.6717371    0
## 6  0.3576471 0.4981484 0.5248805 0.5366310 0.6031287 0.6480921    0
## 7  0.3576471 0.4927448 0.5192771 0.5297159 0.5996437 0.6508314    0
## 8  0.3576471 0.4848320 0.5408159 0.5427127 0.6200253 0.6717371    0
## 9  0.4236277 0.5074421 0.5859472 0.5601687 0.6228626 0.6480921    0
## 10 0.3576471 0.5255698 0.5527057 0.5497490 0.6204819 0.6717371    0
## 11 0.3794326 0.5235007 0.5783191 0.5600467 0.6126720 0.6717371    0
## 12 0.4460432 0.5480930 0.5999072 0.5808134 0.6296780 0.6717371    0
## 13 0.4014252 0.5725752 0.6087279 0.5875305 0.6576219 0.6678832    0
## 14 0.4460432 0.5585005 0.6117973 0.5911995 0.6590982 0.6717371    0
## 15 0.4014252 0.5689401 0.6117973 0.5867010 0.6507194 0.6955990    0

The last value of maxnode has the highest accuracy.
You can try with higher values to see if you can get a higher score.

store_maxnode &lt;- list()
tuneGrid &lt;- expand.grid(.mtry = best_mtry)
for (maxnodes in c(20: 30)) {
    set.seed(1234)
    rf_maxnode &lt;- train(survived~.,
        data = data_train,
        method = "rf",
        metric = "Accuracy",
        tuneGrid = tuneGrid,
        trControl = trControl,
        importance = TRUE,
        nodesize = 14,
        maxnodes = maxnodes,
        ntree = 300)
    key &lt;- toString(maxnodes)
    store_maxnode[[key]] &lt;- rf_maxnode
}
results_node &lt;- resamples(store_maxnode)
summary(results_node)

<k>Output:</k>

## 
## Call:
## summary.resamples(object = results_node)
## 
## Models: 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 
## Number of resamples: 10 
## 
## Accuracy 
##         Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 20 0.7142857 0.7821644 0.8144005 0.8075301 0.8447719 0.8571429    0
## 21 0.7142857 0.8000215 0.8144005 0.8075014 0.8403614 0.8571429    0
## 22 0.7023810 0.7941050 0.8263769 0.8099254 0.8328313 0.8690476    0
## 23 0.7023810 0.7941050 0.8263769 0.8111302 0.8447719 0.8571429    0
## 24 0.7142857 0.7946429 0.8313253 0.8135112 0.8417599 0.8690476    0
## 25 0.7142857 0.7916667 0.8313253 0.8099398 0.8408635 0.8690476    0
## 26 0.7142857 0.7941050 0.8203528 0.8123207 0.8528758 0.8571429    0
## 27 0.7023810 0.8060456 0.8313253 0.8135112 0.8333333 0.8690476    0
## 28 0.7261905 0.7941050 0.8203528 0.8111015 0.8328313 0.8690476    0
## 29 0.7142857 0.7910929 0.8313253 0.8087063 0.8333333 0.8571429    0
## 30 0.6785714 0.7910929 0.8263769 0.8063253 0.8403614 0.8690476    0
## 
## Kappa 
##         Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 20 0.3956835 0.5316120 0.5961830 0.5854366 0.6661120 0.6955990    0
## 21 0.3956835 0.5699332 0.5960343 0.5853247 0.6590982 0.6919315    0
## 22 0.3735084 0.5560661 0.6221836 0.5914492 0.6422128 0.7189781    0
## 23 0.3735084 0.5594228 0.6228827 0.5939786 0.6657372 0.6955990    0
## 24 0.3956835 0.5600352 0.6337821 0.5992188 0.6604703 0.7189781    0
## 25 0.3956835 0.5530760 0.6354875 0.5912239 0.6554912 0.7189781    0
## 26 0.3956835 0.5589331 0.6136074 0.5969142 0.6822128 0.6955990    0
## 27 0.3735084 0.5852459 0.6368425 0.5998148 0.6426088 0.7189781    0
## 28 0.4290780 0.5589331 0.6154905 0.5946859 0.6356141 0.7189781    0
## 29 0.4070588 0.5534173 0.6337821 0.5901173 0.6423101 0.6919315    0
## 30 0.3297872 0.5534173 0.6202632 0.5843432 0.6590982 0.7189781    0

The highest accuracy score is obtained with a value of maxnode equals to 22.

<h3 id="RandomForestTuttopic-8"><span class="orange"><k>Step 4)</k> Search the best ntrees</span></h3>
Now that you have the best value of mtry and maxnode, you can tune the number of trees.
The method is exactly the same as maxnode.

store_maxtrees &lt;- list()
for (ntree in c(250, 300, 350, 400, 450, 500, 550, 600, 800, 1000, 2000)) {
    set.seed(5678)
    rf_maxtrees &lt;- train(survived~.,
        data = data_train,
        method = "rf",
        metric = "Accuracy",
        tuneGrid = tuneGrid,
        trControl = trControl,
        importance = TRUE,
        nodesize = 14,
        maxnodes = 24,
        ntree = ntree)
    key &lt;- toString(ntree)
    store_maxtrees[[key]] &lt;- rf_maxtrees
}
results_tree &lt;- resamples(store_maxtrees)
summary(results_tree)

<k>Output:</k>

## 
## Call:
## summary.resamples(object = results_tree)
## 
## Models: 250, 300, 350, 400, 450, 500, 550, 600, 800, 1000, 2000 
## Number of resamples: 10 
## 
## Accuracy 
##           Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 250  0.7380952 0.7976190 0.8083764 0.8087010 0.8292683 0.8674699    0
## 300  0.7500000 0.7886905 0.8024240 0.8027199 0.8203397 0.8452381    0
## 350  0.7500000 0.7886905 0.8024240 0.8027056 0.8277623 0.8452381    0
## 400  0.7500000 0.7886905 0.8083764 0.8051009 0.8292683 0.8452381    0
## 450  0.7500000 0.7886905 0.8024240 0.8039104 0.8292683 0.8452381    0
## 500  0.7619048 0.7886905 0.8024240 0.8062914 0.8292683 0.8571429    0
## 550  0.7619048 0.7886905 0.8083764 0.8099062 0.8323171 0.8571429    0
## 600  0.7619048 0.7886905 0.8083764 0.8099205 0.8323171 0.8674699    0
## 800  0.7619048 0.7976190 0.8083764 0.8110820 0.8292683 0.8674699    0
## 1000 0.7619048 0.7976190 0.8121510 0.8086723 0.8303571 0.8452381    0
## 2000 0.7619048 0.7886905 0.8121510 0.8086723 0.8333333 0.8452381    0
## 
## Kappa 
##           Min.
  1st Qu.
   Median      Mean   3rd Qu.
     Max.
NA's
## 250  0.4061697 0.5667400 0.5836013 0.5856103 0.6335363 0.7196807    0
## 300  0.4302326 0.5449376 0.5780349 0.5723307 0.6130767 0.6710843    0
## 350  0.4302326 0.5449376 0.5780349 0.5723185 0.6291592 0.6710843    0
## 400  0.4302326 0.5482030 0.5836013 0.5774782 0.6335363 0.6710843    0
## 450  0.4302326 0.5449376 0.5780349 0.5750587 0.6335363 0.6710843    0
## 500  0.4601542 0.5449376 0.5780349 0.5804340 0.6335363 0.6949153    0
## 550  0.4601542 0.5482030 0.5857118 0.5884507 0.6396872 0.6949153    0
## 600  0.4601542 0.5482030 0.5857118 0.5884374 0.6396872 0.7196807    0
## 800  0.4601542 0.5667400 0.5836013 0.5910088 0.6335363 0.7196807    0
## 1000 0.4601542 0.5667400 0.5961590 0.5857446 0.6343666 0.6678832    0
## 2000 0.4601542 0.5482030 0.5961590 0.5862151 0.6440678 0.6656337    0

You have your final model.
You can train the random forest with the following parameters:

<ul><li>ntree =800: 800 trees will be trained</li>
<li>mtry=4: 4 features is chosen for each iteration</li>
<li>maxnodes = 24: Maximum 24 nodes in the terminal nodes (leaves)</li>
</ul>
fit_rf &lt;- train(survived~.,
    data_train,
    method = "rf",
    metric = "Accuracy",
    tuneGrid = tuneGrid,
    trControl = trControl,
    importance = TRUE,
    nodesize = 14,
    ntree = 800,
    maxnodes = 24)

<h3 id="RandomForestTuttopic-9"><span class="orange"><k>Step 5)</k> Evaluate the model</span></h3>
The library caret has a function to make prediction.

predict(model, newdata= df)
argument
- `model`: Define the model evaluated before.

- `newdata`: Define the dataset to make prediction

prediction &lt;-predict(fit_rf, data_test)
You can use the prediction to compute the confusion matrix and see the accuracy score

confusionMatrix(prediction, data_test$survived)
<k>Output:</k>

## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  No Yes
##        No  110  32
##        Yes  11  56
##                                          
##                Accuracy : 0.7943         
##                  95% CI : (0.733, 0.8469)
##     No Information Rate : 0.5789         
##     P-Value [Acc > NIR] : 3.959e-11      
##                                          
##                   Kappa : 0.5638         
##  Mcnemar's Test P-Value : 0.002289       
##                                          
##             Sensitivity : 0.9091         
##             Specificity : 0.6364         
##          Pos Pred Value : 0.7746         
##          Neg Pred Value : 0.8358         
##              Prevalence : 0.5789         
##          Detection Rate : 0.5263         
##    Detection Prevalence : 0.6794         
##       Balanced Accuracy : 0.7727         
##                                          
##        'Positive' Class : No             
## 

You have an accuracy of 0.7943 percent, which is higher than the default value

<h3 id="RandomForestTuttopic-10"><span class="orange"><k>Step 6)</k> Visualize Result</span></h3>
Lastly, you can look at the feature importance with the function varImp().
It seems that the most important features are the sex and age.
That is not surprising because the important features are likely to appear closer to the root of the tree, while less important features will often appear closed to the leaves.

varImpPlot(fit_rf)
<k>Output:</k>

varImp(fit_rf)
## rf variable importance
## 
##              Importance
## sexmale         100.000
## age              28.014
## pclassMiddle     27.016
## fare             21.557
## pclassUpper      16.324
## sibsp            11.246
## parch             5.522
## embarkedC         4.908
## embarkedQ         1.420
## embarkedS         0.000		

<h3 id="RandomForestTuttopic-11"><span class="orange">Summary</span></h3>
We can summarize how to train and evaluate a random forest with the table below:
<table>
<thead><tr><th>Library</th><th>Objective</th><th>Function</th><th>Parameter</th></tr></thead>
<tbody>
<tr><td>randomForest</td><td>Create a Random forest</td><td>RandomForest()</td><td>formula, ntree=n, mtry=FALSE, maxnodes = NULL</td></tr>
<tr><td>caret</td><td>Create K folder cross validation</td><td>trainControl()</td><td>method = “cv”, number = n, search =”grid”</td></tr>
<tr><td>caret</td><td>Train a Random Forest</td><td>train()</td><td>formula, df, method = “rf”, metric= “Accuracy”, trControl = trainControl(), tuneGrid = NULL</td></tr>
<tr><td>caret</td><td>Predict out of sample</td><td>predict</td><td>model, newdata= df</td></tr>
<tr><td>caret</td><td>Confusion Matrix and Statistics</td><td>confusionMatrix()</td><td>model, y test</td></tr>
<tr><td>caret</td><td>variable importance</td><td>cvarImp()</td><td>model</td></tr>
</tbody></table>

<h2>Decision Tree in R: Classification Tree</h2>

<div id="DecisionTreetoc" class="toc"><a href="#DecisionTreetopic-0" target="_self"><span class="orange">What are Decision Trees?</span></a><br><a href="#DecisionTreetopic-1" target="_self">Training and Visualizing a decision trees in R</a><br><a href="#DecisionTreetopic-2" target="_self"><span class="orange"><k>Step 1) </k>Import the data</span></a><br><a href="#DecisionTreetopic-3" target="_self"><span class="orange"><k>Step 2) </k>Clean the dataset</span></a><br><a href="#DecisionTreetopic-4" target="_self"><span class="orange"><k>Step 3)</k> Create train/test set</span></a><br><a href="#DecisionTreetopic-5" target="_self">Install rpart.plot</a><br><a href="#DecisionTreetopic-6" target="_self"><span class="orange"><k>Step 4) </k>Build the model</span></a><br><a href="#DecisionTreetopic-7" target="_self"><span class="orange"><k>Step 5)</k> Make a prediction</span></a><br><a href="#DecisionTreetopic-8" target="_self"><span class="orange"><k>Step 6)</k> Measure performance</span></a><br><a href="#DecisionTreetopic-9" target="_self"><span class="orange"><k>Step 7) </k>Tune the hyper-parameters</span></a><br><a href="#DecisionTreetopic-10" target="_self">Summary</a><br></div></center>

<h3 id="DecisionTreetopic-0"><span class="orange">What are Decision Trees?</span></h3>
<k>Decision Trees</k> are versatile Machine Learning algorithm that can perform both classification and regression tasks.
They are very powerful algorithms, capable of fitting complex datasets.
Besides, decision trees are fundamental components of random forests, which are among the most potent Machine Learning algorithms available today.

<h3 id="DecisionTreetopic-1">Training and Visualizing a decision trees in R</h3>

<h3 id="DecisionTreetopic-2"><span class="orange"><k>Step 1) </k>Import the data</span></h3>
If you are curious about the fate of the titanic, you can watch this video on <a href="https://www.youtube.com/watch?v=9xoqXVjBEF8" data-lasso-id="209454">Youtube</a>.
The purpose of this dataset is to predict which people are more likely to survive after the collision with the iceberg.
The dataset contains 13 variables and 1309 observations.
The dataset is ordered by the variable X.<br>

set.seed(678)
path &lt;- 'https://raw.githubusercontent.com/guru99-edu/R-Programming/master/titanic_data.csv'
titanic &lt;-read.csv(path)
head(titanic)

<span class="smallsize"><k>Output:</k>
##   X pclass survived                                            name    sex
## 1 1      1        1                   Allen, Miss. Elisabeth Walton female
## 2 2      1        1                  Allison, Master. Hudson Trevor   male
## 3 3      1        0                    Allison, Miss. Helen Loraine female
## 4 4      1        0            Allison, Mr. Hudson Joshua Creighton   male
## 5 5      1        0 Allison, Mrs. Hudson J C (Bessie Waldo Daniels) female
## 6 6      1        1                             Anderson, Mr. Harry   male
##       age sibsp parch ticket     fare   cabin embarked
## 1 29.0000     0     0  24160 211.3375      B5        S
## 2  0.9167     1     2 113781 151.5500 C22 C26        S
## 3  2.0000     1     2 113781 151.5500 C22 C26        S
## 4 30.0000     1     2 113781 151.5500 C22 C26        S
## 5 25.0000     1     2 113781 151.5500 C22 C26        S
## 6 48.0000     0     0  19952  26.5500     E12        S
##                         home.dest
## 1                    St Louis, MO
## 2 Montreal, PQ / Chesterville, ON
## 3 Montreal, PQ / Chesterville, ON
## 4 Montreal, PQ / Chesterville, ON
## 5 Montreal, PQ / Chesterville, ON
## 6                    New York, NY

tail(titanic)
</span>
<span class="smallsize"><k>Output:</k>
##         X pclass survived                      name    sex  age sibsp
## 1304 1304      3        0     Yousseff, Mr. Gerious   male   NA     0
## 1305 1305      3        0      Zabour, Miss. Hileni female 14.5     1
## 1306 1306      3        0     Zabour, Miss. Thamine female   NA     1
## 1307 1307      3        0 Zakarian, Mr. Mapriededer   male 26.5     0
## 1308 1308      3        0       Zakarian, Mr. Ortin   male 27.0     0
## 1309 1309      3        0        Zimmerman, Mr. Leo   male 29.0     0
##      parch ticket    fare cabin embarked home.dest
## 1304     0   2627 14.4583              C          
## 1305     0   2665 14.4542              C          
## 1306     0   2665 14.4542              C          
## 1307     0   2656  7.2250              C          
## 1308     0   2670  7.2250              C          
## 1309     0 315082  7.8750              S
</span>
From the head and tail output, you can notice the data is not shuffled.
This is a big issue! When you will split your data between a train set and test set, you will select <k>only</k> the passenger from class 1 and 2 (No passenger from class 3 are in the top 80 percent of the observations), which means the algorithm will never see the features of passenger of class 3.
This mistake will lead to poor prediction.<br>

To overcome this issue, you can use the function sample().
shuffle_index &lt;- sample(1:nrow(titanic))
head(shuffle_index)
Decision tree R <r>code Explanation</r>
<ul><li>sample(1:nrow(titanic)): Generate a random list of index from 1 to 1309 (i.e. the maximum number of rows).</li>
</ul>
<span class="smallsize"><k>Output:</k>
## [1]  288  874 1078  633  887  992
</span>
You will use this index to shuffle the titanic dataset.
titanic &lt;- titanic[shuffle_index, ]

head(titanic)
<span class="smallsize"><k>Output:</k>
##         X pclass survived
## 288   288      1        0
## 874   874      3        0
## 1078 1078      3        1
## 633   633      3        0
## 887   887      3        1
## 992   992      3        1
##                                                           name    sex age
## 288
  Sutton, Mr. Frederick   male  61
## 874
  Humblen, Mr. Adolf Mathias Nicolai Olsen   male  42
## 1078
  O'Driscoll, Miss. Bridget female  NA
## 633
  Andersson, Mrs. Anders Johan (Alfrida Konstantia Brogren) female  39
## 887
  Jermyn, Miss. Annie female  NA
## 992
  Mamee, Mr. Hanna   male  NA
##      sibsp parch ticket    fare cabin embarked           home.dest
## 288      0     0  36963 32.3208   D50        S     Haddenfield, NJ
## 874      0     0 348121  7.6500 F G63        S                    
## 1078     0     0  14311  7.7500              Q                    
## 633      1     5 347082 31.2750              S Sweden Winnipeg, MN
## 887      0     0  14313  7.7500              Q                    
## 992      0     0   2677  7.2292              C	
</span>
<h3 id="DecisionTreetopic-3"><span class="orange"><k>Step 2) </k>Clean the dataset</span></h3>
The structure of the data shows some variables have NA’s.
Data clean up to be done as follows
<ul><li>Drop variables home.dest,cabin, name, X and ticket</li>
<li>Create factor variables for pclass and survived</li>
<li>Drop the NA</li>
</ul>
library(dplyr)
# Drop variables
clean_titanic &lt;- titanic %>%
select(-c(home.dest, cabin, name, x, ticket)) %>% 
#Convert to factor level
mutate(pclass = factor(pclass,
			 levels = c(1, 2, 3),
			 labels = c('Upper', 'Middle', 'Lower')),
survived = factor(survived, levels = c(0, 1),
			 labels = c('No', 'Yes'))) %>%
na.omit()
glimpse(clean_titanic)

<r>Code Explanation</r>
<ul><li> select(-c(home.dest, cabin, name, X, ticket)): Drop unnecessary variables</li>
<li>pclass = factor(pclass, levels = c(1,2,3), labels= c(‘Upper’, ‘Middle’, ‘Lower’)): Add label to the variable pclass.
1 becomes Upper, 2 becomes MIddle and 3 becomes lower</li>
<li>factor(survived, levels = c(0,1), labels = c(‘No’, ‘Yes’)): Add label to the variable survived.
1 Becomes No and 2 becomes Yes</li>
<li>na.omit(): Remove the NA observations</li>
</ul>
<span class="smallsize"><k>Output:</k>
## Observations: 1,045
## Variables: 8
## $ pclass   &lt;fctr> Upper, Lower, Lower, Upper, Middle, Upper, Middle, U...
## $ survived &lt;fctr> No, No, No, Yes, No, Yes, Yes, No, No, No, No, No, Y...
## $ sex      &lt;fctr> male, male, female, female, male, male, female, male...
## $ age      &lt;dbl> 61.0, 42.0, 39.0, 49.0, 29.0, 37.0, 20.0, 54.0, 2.0, ...
## $ sibsp    &lt;int> 0, 0, 1, 0, 0, 1, 0, 0, 4, 0, 0, 1, 1, 0, 0, 0, 1, 1,...
## $ parch    &lt;int> 0, 0, 5, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 2, 0, 4, 0,...
## $ fare     &lt;dbl> 32.3208, 7.6500, 31.2750, 25.9292, 10.5000, 52.5542, ...
## $ embarked &lt;fctr> S, S, S, S, S, S, S, S, S, C, S, S, S, Q, C, S, S, C...		
</span>
<h3 id="DecisionTreetopic-4"><span class="orange"><k>Step 3)</k> Create train/test set</span></h3>
Before you train your model, you need to perform two steps:
<ul><li>Create a train and test set: You train the model on the train set and test the prediction on the test set (i.e. unseen data)</li>
<li>Install rpart.plot from the console</li>
</ul>
The common practice is to split the data 80/20, 80 percent of the data serves to train the model, and 20 percent to make predictions.
You need to create two separate data frames.
You don’t want to touch the test set until you finish building your model.
You can create a function name create_train_test() that takes three arguments.
<mm>create_train_test(df, size = 0.8, train = TRUE)</mm>
arguments:
-df: Dataset used to train the model.
-size: Size of the split.
By default, 0.8.
Numerical value
-train: If set to `TRUE`, the function creates the train set, otherwise the test set.
Default value sets to `TRUE`.
Boolean value.You need to add a Boolean parameter because R does not allow to return two data frames simultaneously.
<mm>create_train_test &lt;- function(data, size = 0.8, train = TRUE) {
    n_row = nrow(data)
    total_row = size * n_row
    train_sample &lt;- 1:total_row
    if (train == TRUE) {
        return (data[train_sample, ])
    } else {
        return (data[-train_sample, ])
    }
}</mm>

<r>Code Explanation</r>
<ul><li>function(data, size=0.8, train = TRUE): Add the arguments in the function</li>
<li>n_row = nrow(data): Count number of rows in the dataset</li>
<li>total_row = size*n_row: Return the nth row to construct the train set</li>
<li>train_sample &lt;- 1:total_row: Select the first row to the nth rows</li>
<li>if (train ==TRUE){ } else { }: If condition sets to true, return the train set, else the test set.</li>
</ul>
You can test your function and check the dimension.
data_train &lt;- create_train_test(clean_titanic, 0.8, train = TRUE)
data_test &lt;- create_train_test(clean_titanic, 0.8, train = FALSE)
dim(data_train)
<span class="smallsize"><k>Output:</k>
## [1] 836   8</span>
dim(data_test)
<span class="smallsize"><k>Output:</k>
## [1] 209   8</span>
The train dataset has 1046 rows while the test dataset has 262 rows.
You use the function prop.table() combined with table() to verify if the randomization process is correct.
prop.table(table(data_train$survived))
<span class="smallsize"><k>Output:</k>
##
##        No       Yes 
## 0.5944976 0.4055024
</span>
prop.table(table(data_test$survived))
<span class="smallsize"><k>Output:</k>
## 
##        No       Yes 
## 0.5789474 0.4210526
</span>
In both dataset, the amount of survivors is the same, about 40 percent.
<h3 id="DecisionTreetopic-5">Install rpart.plot</h3>
rpart.plot is not available from conda libraries.
You can install it from the console:
install.packages("rpart.plot")
<h3 id="DecisionTreetopic-6"><span class="orange"><k>Step 4) </k>Build the model</span></h3>
You are ready to build the model.
The syntax for Rpart decision tree function is:
rpart(formula, data=, method='')
arguments:			
- formula: The function to predict
- data: Specifies the data frame- method: 			
- "class" for a classification tree 			
- "anova" for a regression tree	

You use the class method because you predict a class.
library(rpart)
library(rpart.plot)
fit &lt;- rpart(survived~., data = data_train, method = 'class')
rpart.plot(fit, extra = 106
<r>Code Explanation</r>
<ul><li>rpart(): Function to fit the model.
The arguments are:
<ul><li>survived ~.: Formula of the Decision Trees</li>
<li>data = data_train: Dataset</li>
<li>method = ‘class’: Fit a binary model</li>
</ul>
</li>
<li>rpart.plot(fit, extra= 106): Plot the tree.
The extra features are set to 101 to display the probability of the 2nd class (useful for binary responses).
You can refer to the <a href="https://cran.r-project.org/web/packages/rpart.plot/rpart.plot.pdf" data-lasso-id="209458">vignette</a> for more information about the other choices.</li>
</ul>
<span class="smallsize"><k>Output:</k></span>
<img class="lazy" data-src="https://www.guru99.com/images/r_programming/032918_0938_DecisionTre1.png">
You start at the root node (depth 0 over 3, the top of the graph):
<ol>
<li>At the top, it is the overall probability of survival.
It shows the proportion of passenger that survived the crash.
41 percent of passenger survived.</li>
<li>This node asks whether the gender of the passenger is male.
If yes, then you go down to the root’s left child node (depth 2).
63 percent are males with a survival probability of 21 percent.</li>
<li>In the second node, you ask if the male passenger is above 3.5 years old.
If yes, then the chance of survival is 19 percent.</li>
<li>You keep on going like that to understand what features impact the likelihood of survival.</li>
</ol>
Note that, one of the many qualities of Decision Trees is that they require very little data preparation.
In particular, they don’t require feature scaling or centering.
By default, rpart() function uses the <k>Gini</k> impurity measure to split the note.
The higher the Gini coefficient, the more different instances within the node.
<h3 id="DecisionTreetopic-7"><span class="orange"><k>Step 5)</k> Make a prediction</span></h3>
You can predict your test dataset.
To make a prediction, you can use the predict() function.
The basic syntax of predict for R decision tree is:
predict(fitted_model, df, type = 'class')
arguments:
- fitted_model: This is the object stored after model estimation.

- df: Data frame used to make the prediction
- type: Type of prediction			
    - 'class': for classification			
    - 'prob': to compute the probability of each class			
    - 'vector': Predict the mean response at the node level	

You want to predict which passengers are more likely to survive after the collision from the test set.
It means, you will know among those 209 passengers, which one will survive or not.
predict_unseen &lt;-predict(fit, data_test, type = 'class')
<r>Code Explanation</r>
<ul><li>predict(fit, data_test, type = ‘class’): Predict the class (0/1) of the test set</li>
</ul>
Testing the passenger who didn’t make it and those who did.
table_mat &lt;- table(data_test<k>$</k>survived, predict_unseen)
table_mat
<r>Code Explanation</r>
<ul><li>table(data_test$survived, predict_unseen): Create a  table to count how many passengers are classified as survivors and passed away compare to the correct decision tree classification in R</li>
</ul>
<span class="smallsize"><k>Output:</k>
##      predict_unseen
##        No Yes
##   No  106  15
##   Yes  30  58
</span>
The model correctly predicted 106 dead passengers but classified 15 survivors as dead.
By analogy, the model misclassified 30 passengers as survivors while they turned out to be dead.
<h3 id="DecisionTreetopic-8"><span class="orange"><k>Step 6)</k> Measure performance</span></h3>
You can compute an accuracy measure for classification task with the <k><a href="/confusion-matrix-machine-learning-example.html" data-lasso-id="209461">confusion matrix</a></k>:
The <k>confusion matrix</k> is a better choice to evaluate the classification performance.
The general idea is to count the number of times True instances are classified are False.
<img class="lazy" data-src="https://www.guru99.com/images/r_programming/032918_0938_DecisionTre2.png">
Each row in a confusion matrix represents an actual target, while each column represents a predicted target.
The first row of this matrix considers dead passengers (the False class): 106 were correctly classified as dead (<k>True negative</k>), while the remaining one was wrongly classified as a survivor (<k>False positive</k>).
The second row considers the survivors, the positive class were 58 (<k>True positive</k>), while the <k>True negative</k> was 30.
You can compute the <k>accuracy test</k> from the confusion matrix:
<img class="lazy" data-src="https://www.guru99.com/images/r_programming/032918_0938_DecisionTre3.jpg">
It is the proportion of true positive and true negative over the sum of the matrix.
With R, you can code as follow:
accuracy_Test &lt;- sum(diag(table_mat)) / sum(table_mat)
<r>Code Explanation</r>
<ul><li>sum(diag(table_mat)): Sum of the diagonal</li>
<li>sum(table_mat): Sum of the matrix.</li>
</ul>
You can print the accuracy of the test set:
print(paste('Accuracy for test', accuracy_Test))
<span class="smallsize"><k>Output:</k>
## [1] "Accuracy for test 0.784688995215311"</span>
You have a score of 78 percent for the test set.
You can replicate the same exercise with the training dataset.
<h3 id="DecisionTreetopic-9"><span class="orange"><k>Step 7) </k>Tune the hyper-parameters</span></h3>
Decision tree in R has various parameters that control aspects of the fit.
In rpart decision tree library, you can control the parameters using the rpart.control() function.
In the following code, you introduce the parameters you will tune.
You can refer to the <a href="https://cran.r-project.org/web/packages/rpart/rpart.pdf" data-lasso-id="209463">vignette</a> for other parameters.
rpart.control(minsplit = 20, minbucket = round(minsplit/3), maxdepth = 30)
Arguments:
-minsplit: Set the minimum number of observations in the node before the algorithm perform a split
-minbucket:  Set the minimum number of observations in the final note i.e. the leaf
-maxdepth: Set the maximum depth of any node of the final tree.
The root node is treated a depth 0
We will proceed as follow:
<ul><li>Construct function to return accuracy</li>
<li>Tune the maximum depth</li>
<li>Tune the minimum number of sample a node must have before it can split</li>
<li>Tune the minimum number of sample a leaf node must have</li>
</ul>
You can write a function to display the accuracy.
You simply wrap the code you used before:
<ol>
<li>predict: predict_unseen &lt;- predict(fit, data_test, type = ‘class’)</li>
<li>Produce table: table_mat &lt;- table(data_test$survived, predict_unseen)</li>
<li>Compute accuracy: accuracy_Test &lt;- sum(diag(table_mat))/sum(table_mat)</li>
</ol>
accuracy_tune &lt;- function(fit) {
    predict_unseen &lt;- predict(fit, data_test, type = 'class')
    table_mat &lt;- table(data_test$survived, predict_unseen)
    accuracy_Test &lt;- sum(diag(table_mat)) / sum(table_mat)
    accuracy_Test
}

You can try to tune the parameters and see if you can improve the model over the default value.
As a reminder, you need to get an accuracy higher than 0.78
control &lt;- rpart.control(minsplit = 4,
    minbucket = round(5 / 3),
    maxdepth = 3,
    cp = 0)
tune_fit &lt;- rpart(survived~., data = data_train, method = 'class', control = control)
accuracy_tune(tune_fit)
<span class="smallsize"><k>Output:</k>
## [1] 0.7990431</span>
With the following parameter:
minsplit = 4
minbucket= round(5/3)
maxdepth = 3cp=0
You get a higher performance than the previous model.
Congratulation!
<h3 id="DecisionTreetopic-10">Summary</h3>
We can summarize the functions to train a decision tree algorithm in R
<table><thead><tr><th>Library</th><th>Objective</th><th>Function</th><th>Class</th><th>Parameters</th><th>Details</th></tr></thead><tbody>
<tr><td>rpart</td><td>Train classification tree in R</td><td>rpart()</td><td>class</td><td>formula, df, method</td><td></td></tr>
<tr><td>rpart</td><td>Train regression tree</td><td>rpart()</td><td>anova</td><td>formula, df, method</td><td></td></tr>
<tr><td>rpart</td><td>Plot the trees</td><td>rpart.plot()</td><td></td><td>fitted model</td><td></td></tr>
<tr><td>base</td><td>predict</td><td>predict()</td><td>class</td><td>fitted model, type</td><td></td></tr>
<tr><td>base</td><td>predict</td><td>predict()</td><td>prob</td><td>fitted model, type</td><td></td></tr>
<tr><td>base</td><td>predict</td><td>predict()</td><td>vector</td><td>fitted model, type</td><td></td></tr>
<tr><td>rpart</td><td>Control parameters</td><td>rpart.control()</td><td></td><td>minsplit</td><td>Set the minimum number of observations in the node before the algorithm perform a split</td></tr>
<tr><td></td><td></td><td></td><td></td><td>minbucket</td><td>Set the minimum number of observations in the final note i.e. the leaf</td></tr>
<tr><td></td><td></td><td></td><td></td><td>maxdepth</td><td>Set the maximum depth of any node of the final tree.
The root node is treated a depth 0</td></tr>
<tr><td>rpart</td><td>Train model with control parameter</td><td>rpart()</td><td></td><td>formula, df, method, control</td><td></td></tr>
</tbody></table>
Note : Train the model on a training data and test the performance on an unseen dataset, i.e. test set.

<h2>Random Forest with Key Predictors</h2>
The process of using <mm>randomForest</mm> package to build an RF model is the same as the decision tree package <mm>rpart</mm>. Note also if a dependent (response) variable is a factor, classification is assumed, otherwise, regression is assumed. So to uses <mm>randomForest</mm>, we need to convert the dependent variable into a factor.

<mm># convert variables into factor
# convert other attributes which really are categorical data but in form of numbers
train$Group_size &lt;- as.factor(train$Group_size)
#confirm types
sapply(train, class)</mm>

<mm>##  PassengerId     Survived       Pclass          Sex          Age        SibSp 
##    "integer"     "factor"     "factor"     "factor"    "numeric"    "integer" 
##        Parch       Ticket     Embarked  HasCabinNum  Friend_size      Fare_pp 
##    "integer"     "factor"     "factor"     "factor"    "integer"    "numeric" 
##        Title         Deck Ticket_class  Family_size   Group_size    Age_group 
##     "factor"     "factor"     "factor"    "integer"     "factor"     "factor"</mm>
Let us use the same five most related attributes: <em>Pclass</em>, <em>Sex</em>, <em>HasCabinNum</em>, <em>Deck</em> and <em>Fare_pp</em> in the decision tree model2. We use all default parameters of the <mm>randomForest</mm>.

<mm># Build the random forest model uses pclass, sex, HasCabinNum, Deck and Fare_pp
set.seed(1234) #for reproduction 
 RF_model1 &lt;- randomForest(as.factor(Survived) ~ Sex + Pclass + HasCabinNum + Deck + Fare_pp, data=train, importance=TRUE)
 save(RF_model1, file = "./data/RF_model1.rda")</mm>

Let us check model’s prediction accuracy.

<mm>load("./data/RF_model1.rda")
RF_model1</mm>

<mm>## 
## Call:
##  randomForest(formula = as.factor(Survived) ~ Sex + Pclass + HasCabinNum +      Deck + Fare_pp, data = train, importance = TRUE) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 2
## 
##         OOB estimate of  error rate: 19.3%
## Confusion matrix:
##     0   1 class.error
## 0 505  44  0.08014572
## 1 128 214  0.37426901</mm>
We can see that the model uses default parameters: <mm>ntree = 500</mm> and <mm>mtry = 1</mm>. The model’s estimated accuracy is <k>80.7%</k>. It is 1 - 19.3% (<mm>OOB error</mm>).

Let us make a prediction on the training dataset and check the accuracy.

<mm># Make your prediction using the validate dataset
RF_prediction1 &lt;- predict(RF_model1, train)
#check up
conMat&lt;- confusionMatrix(RF_prediction1, train$Survived)
conMat$table</mm>

<mm>##           Reference
## Prediction   0   1
##          0 521 112
##          1  28 230</mm>
<mm># Misclassification error
paste('Accuracy =', round(conMat$overall["Accuracy"],2))</mm>

<mm>## [1] "Accuracy = 0.84"</mm>
<mm>paste('Error =', round(mean(train$Survived != RF_prediction1), 2))</mm>

<mm>## [1] "Error = 0.16"</mm>
We can see that prediction on the training dataset has achieved <k>84%</k> accuracy.
It has made 107 wrong predictions and 516 correct predictions on death. The prediction on survived is 33 wrong predictions out of 235 correct predictions.

The model has an accuracy of 80% after learning, but our evaluation of the training dataset achieves 84%. It has been increased. Compare with the decision tree model2, in which the same attributes were used and the prediction accuracy on the train data was 81%, the accuracy is also increased. Let us make a prediction on the test dataset and submit it to Kaggle to obtain an accuracy score.

<mm># produce a submit with Kaggle required format that is only two attributes: PassengerId and Survived
test$Pclass &lt;- as.factor(test$Pclass)
test$Group_size &lt;- as.factor(test$Group_size)

#make prediction
RF_prediction &lt;- predict(RF_model1, test)
submit &lt;- data.frame(PassengerId = test$PassengerId, Survived = RF_prediction)
# Write it into a file "RF_Result.CSV"
write.csv(submit, file = "./data/RF_Result1.CSV", row.names = FALSE)</mm>

We can see our random forest model has scored <k>0.76555</k> by the Kaggle competition. It is interesting to know that the random forest model has not improved on the test dataset compare with the decision tree model with the same predictors. The accuracy was also 0.76555.

Let us record these accuracies,

<mm># Record the results
RF_model1_accuracy &lt;- c(80, 84, 76.555)</mm>

<a href="https://www.youtube.com/watch?v=acFviblzijU" class="whitebut ">Random Forest Model in R</a>

<h2>simple randomForest sample</h2>
install.packages("stats")
library(stats)
library(dplyr)
library(randomForest)
mydata = iris
View(mydata)
str(mydata)
index = sample(2, nrow(mydata), replace = TRUE, prob=c(0.7,0.3))
Training = mydata[index==1,]
Testing = mydata[index==2,]
RFM = randomForest(Species~., data=Training)
Species_Pred = predict(RFM, Testing)
Testing$Species_Pred = Species_Pred
str(Testing)
CFM = table(Testing$Species, Testing$Species_Pred)
clasification_Accuracy = sum(diag(CFM) / sum(CFM))

Other Example:
<mm>data(iris)
y <- as.factor(ifelse(iris$Species == "setosa" | 
               iris$Species == "virginica", 1, 0) )
xdata <- iris[,1:4] 

rf.mdl <- randomForest(xdata, y, ntree=501) 

library(rfUtilities)
ua <- rf.class.sensitivity(rf.mdl, xdata=xdata, nperm=20, ntree=501, plot=TRUE)

data(iris)
set.seed(4543)
iris.rf <- randomForest(Species ~ ., data=iris, importance=TRUE)
importance(iris.rf)

<a href="https://www.youtube.com/watch?v=-2DlAMYioqY" class="whitebut ">Variable Importance for Random Forest Models</a>
<a href="https://www.youtube.com/watch?v=HeTT73WxKIc" class="whitebut ">Random Forest Tutorial</a>

</mm>
<h2>no applicable method applied to an object of class</h2>

<div id="noapplicabletoc" class="toc"><a href="#noapplicabletopic-0" target="_self" onclick="jumpto(0)">Creating Example Data</a><br><a href="#noapplicabletopic-1" target="_self" onclick="jumpto(1)">Example 1: Reproduce the Error in UseMethod(“predict”)</a><br><a href="#noapplicabletopic-2" target="_self" onclick="jumpto(2)">Example 2: Fix the Error in UseMethod(“predict”)</a><br></div></center>

<h3 id="noapplicabletopic-0">Creating Example Data</h3> <a href="#top" target="_self"><b>⇧</b></a><br>
First, let’s create some example data:
<mm>set.seed(538946)                          # Create train data
data_train &lt;- data.frame(x = rnorm(10),

y = rnorm(10))
head(data_train)                          # Print head of train data
</mm>
<img src="https://statisticsglobe.com/wp-content/uploads/2022/05/table-1-data-frame-r-error-usemethod-no-applicable-method-for-predict.png">

Table 1 visualizes the output of the RStudio console that got returned by the previous code and illustrates that our example data is composed of two numerical columns. 
This data frame will be used to <a href="https://developers.google.com/machine-learning/crash-course/training-and-test-sets/splitting-data" target="_blank">train our model</a>.
Next, we also have to create a test data frame:
<mm>
data_test &lt;- data.frame(x = rnorm(10))    # Create test data
head(data_test)                           # Print head of test data
</mm>
<img src="https://statisticsglobe.com/wp-content/uploads/2022/05/table-2-data-frame-r-error-usemethod-no-applicable-method-for-predict.png">

As shown in Table 2, the previous R programming syntax has created another data frame that contains only the predictor column x.
<h3 id="noapplicabletopic-1">Example 1: Reproduce the Error in UseMethod(“predict”)</h3> <a href="#top" target="_self"><b>⇧</b></a><br>: no applicable method for ‘predict’ applied to an object of class “c(‘double’, ‘numeric’)”
This section illustrates how to replicate the error message Error in UseMethod(“predict”) : no applicable method for ‘predict’ applied to an object of class “c(‘double’, ‘numeric’)”.

Let’s assume that we want to make predictions based on our data using the predict() function. 
Then, we might try to use the predict function as shown below:
<mm>predict(data_test$x, data_test)           # Try to predict values for test data

# Error in UseMethod("predict") : 
#   no applicable method for 'predict' applied to an object of class "c('double', 'numeric')"
</mm>
Unfortunately, the previous R code has returned the Error in UseMethod(“predict”) : no applicable method for ‘predict’ applied to an object of class “c(‘double’, ‘numeric’)”.

This is because we have inserted a numeric column as first argument to the predict function instead of a model object.
Let’s solve this problem!
<h3 id="noapplicabletopic-2">Example 2: Fix the Error in UseMethod(“predict”)</h3> <a href="#top" target="_self"><b>⇧</b></a><br>: no applicable method for ‘predict’ applied to an object of class “c(‘double’, ‘numeric’)”

Example 2 shows how to debug the Error in UseMethod(“predict”) : no applicable method for ‘predict’ applied to an object of class “c(‘double’, ‘numeric’)”.
For this, we first have to estimate a linear regression model based on our train data:
<mm>mod &lt;- lm(y ~ x, data_train)              # Estimate linear regression model
summary(mod)                              # Summary of linear regression model
# Call:
# lm(formula = y ~ x, data = data_train)

# 
# Residuals:
#      Min       1Q   Median       3Q      Max 

# -1.79523 -1.09487  0.05202  0.53017  2.10266 
# 
# Coefficients:

#             Estimate Std. 
Error t value Pr(&gt;|t|)
# (Intercept) -0.05067    0.44588  -0.114    0.912

# x            0.11632    0.47348   0.246    0.812
# 
# Residual standard error: 1.384 on 8 degrees of freedom

# Multiple R-squared:  0.007488,	Adjusted R-squared:  -0.1166 
# F-statistic: 0.06035 on 1 and 8 DF,  p-value: 0.8121
</mm>
Next, we can apply the predict function to our model output and to our test data:
<mm>
predict(mod, data_test)                   # Properly to predict values for test data
#            1            2            3            4            5            6 
#  0.033310908 -0.071341113 -0.067580482 -0.048135709 -0.151354152 -0.159618208 

#            7            8            9           10 
#  0.019528408 -0.160007711  0.003183706  0.035468402
</mm>
This time, the predict function worked perfectly.

Note that this error message may appear with small modifications. 
For instance, the error message <k>Error in UseMethod(“predict”) : no applicable method for ‘predict’ applied to an object of class “train”</k> occurrs when applying the predict function to a train object created by the <a href="https://topepo.github.io/caret/" target="_blank">caret package</a> (<a href="https://stackoverflow.com/questions/38623624/usemethodpredict-no-applicable-method-for-predict-applied-to-an-object-o" target="_blank">see here</a>), and the error message <k>Error in UseMethod(“predict”) : no applicable method for ‘predict’ applied to an object of class “c(‘elnet’, ‘glmnet’)”</k> is returned when applying the predict function to an elnet object (<a href="https://github.com/tidymodels/parsnip/issues/249" target="_blank">see here</a>).

<h2>randomForest document</h2>
<div id="randomForestPDFtoc" class="toc">
<a href="#randomForestPDFtopic-01" target="_self" >classCenter</a><br><a href="#randomForestPDFtopic-0" target="_self" >combine</a><br><a href="#randomForestPDFtopic-1" target="_self" >getTree</a><br><a href="#randomForestPDFtopic-2" target="_self" >grow</a><br><a href="#randomForestPDFtopic-3" target="_self" >importance</a><br><a href="#randomForestPDFtopic-4" target="_self" >imports85</a><br><a href="#randomForestPDFtopic-5" target="_self" >margin</a><br><a href="#randomForestPDFtopic-6" target="_self" >MDSplot</a><br><a href="#randomForestPDFtopic-7" target="_self" >na.roughfix</a><br><a href="#randomForestPDFtopic-8" target="_self" >outlier</a><br><a href="#randomForestPDFtopic-9" target="_self" >partialPlot</a><br><a href="#randomForestPDFtopic-10" target="_self" >plot</a><br><a href="#randomForestPDFtopic-11" target="_self" >predict</a><br><a href="#randomForestPDFtopic-12" target="_self" ><r>randomForest</r></a><br><a href="#randomForestPDFtopic-13" target="_self" >rfcv</a><br><a href="#randomForestPDFtopic-14" target="_self" >rfImpute</a><br><a href="#randomForestPDFtopic-15" target="_self" >rfNews</a><br><a href="#randomForestPDFtopic-16" target="_self" >treesize</a><br><a href="#randomForestPDFtopic-17" target="_self" >tuneRF</a><br><a href="#randomForestPDFtopic-18" target="_self" >varImpPlot</a><br><a href="#randomForestPDFtopic-19" target="_self" >varUsed</a><br></div></center>
<h3 id="randomForestPDFtopic-01">classCenter</h3>
<k>Description</k>
  Prototypes are ‘representative’ cases of a group of data points, given the similarity matrix among the points. They are very similar to medoids. The function is named ‘classCenter’ to avoid conflict with the function prototype in the methods package.
<k>Usage</k>
  classCenter(x, label, prox, nNbr = min(table(label))-1)
<k>Arguments</k>
  x                   a matrix or data frame
  label               group labels of the rows in x
  prox                the proximity (or similarity) matrix, assumed to be symmetric with 1 on the diagonal and in [0, 1] off the diagonal (the order of row/column must match that of x)
  nNbr                number of nearest neighbors used to find the prototypes.

<k>Details</k>
This version only computes one prototype per class. 
For each case in x, the nNbr nearest neighors are found. 
Then, for each class, the case that has most neighbors of that class is identified. 

The pro- totype for that class is then the medoid of these neighbors (coordinate-wise medians for numerical variables and modes for categorical variables). 
This version only computes one prototype per class. 
In the future more prototypes may be computed (by removing the ‘neighbors’ used, then iterate).

<k>Value</k>
  A data frame containing one prototype in each row.
<k>Examples</k>
    data(iris)
    iris.rf &lt;- randomForest(iris[,-5], iris[,5], prox=TRUE)
    iris.p &lt;- classCenter(iris[,-5], iris[,5], iris.rf$prox)
    plot(iris[,3], iris[,4], pch=21, xlab=names(iris)[3], ylab=names(iris)[4],
      bg=c("red", "blue", "green")[as.numeric(factor(iris$Species))],
      main="Iris Data with Prototypes")
    points(iris.p[,3], iris.p[,4], pch=21, cex=2, bg=c("red", "blue", "green"))


<h3 id="randomForestPDFtopic-0">combine</h3>
Combine Ensembles of Trees
<k>Description</k>
    Combine two more more ensembles of trees into one.
<k>Usage</k>
    combine(...)
<k>Arguments</k>
    ...               two or more objects of class randomForest, to be combined into one.
<k>Value</k>
    An object of class randomForest.
<k>Note</k>
    The confusion, err.rate, mse and rsq components (as well as the corresponding components in
    the test compnent, if exist) of the combined object will be NULL.
<k>Examples</k>
  data(iris)
  rf1 &lt;- randomForest(Species ~ ., iris, ntree=50, norm.votes=FALSE)
  rf2 &lt;- randomForest(Species ~ ., iris, ntree=50, norm.votes=FALSE)
  rf3 &lt;- randomForest(Species ~ ., iris, ntree=50, norm.votes=FALSE)
  rf.all &lt;- combine(rf1, rf2, rf3)
  print(rf.all)

<h3 id="randomForestPDFtopic-1">getTree</h3>
Extract a single tree from a forest.
<k>Description</k>
  This function extract the structure of a tree from a randomForest object.
<k>Usage</k>
  getTree(rfobj, k=1, labelVar=FALSE)
<k>Arguments</k>
  rfobj               a randomForest object.
  k                   which tree to extract?
  labelVar            Should better labels be used for splitting variables and predicted class?
<k>Details</k>
  For numerical predictors, data with values of the variable less than or equal to the splitting point go
  to the left daughter node.
  For categorical predictors, the splitting point is represented by an integer, whose binary expansion
  gives the identities of the categories that goes to left or right. For example, if a predictor has
  four categories, and the split point is 13. The binary expansion of 13 is (1, 0, 1, 1) (because
  13 = 1 <u+2217> 20 + 0 <u+2217> 21 + 1 <u+2217> 22 + 1 <u+2217> 23 ), so cases with categories 1, 3, or 4 in this predictor get sent
  to the left, and the rest to the right.
<k>Value</k>
  A matrix (or data frame, if labelVar=TRUE) with six columns and number of rows equal to total
  number of nodes in the tree. The six columns are:
  left daughter       the row where the left daughter node is; 0 if the node is terminal
  right daughter the row where the right daughter node is; 0 if the node is terminal
  split var           which variable was used to split the node; 0 if the node is terminal
  split point         where the best split is; see Details for categorical predictor
  status              is the node terminal (-1) or not (1)
  prediction          the prediction for the node; 0 if the node is not terminal
<k>Examples</k>
    data(iris)
    ## Look at the third trees in the forest.
    getTree(randomForest(iris[,-5], iris[,5], ntree=10), 3, labelVar=TRUE)

<h3 id="randomForestPDFtopic-2">grow</h3>
Add trees to an ensemble
<k>Description</k>
    Add additional trees to an existing ensemble of trees.
<k>Usage</k>
    ## S3 method for class 'randomForest'
    grow(x, how.many, ...)
<k>Arguments</k>
    x                  an object of class randomForest, which contains a forest component.
    how.many           number of trees to add to the randomForest object.
    ...                currently ignored.
<k>Value</k>
    An object of class randomForest, containing how.many additional trees.
<k>Note</k>
    The confusion, err.rate, mse and rsq components (as well as the corresponding components in the test compnent, if exist) of the combined object will be NULL.
<k>Examples</k>
  data(iris)
  iris.rf &lt;- randomForest(Species ~ ., iris, ntree=50, norm.votes=FALSE)
  iris.rf &lt;- grow(iris.rf, 50)
  print(iris.rf)

<h3 id="randomForestPDFtopic-3">importance</h3>
Extract variable importance measure
<k>Description</k>
  This is the extractor function for variable importance measures as produced by randomForest.
<k>Usage</k>
  ## S3 method for class 'randomForest'
  importance(x, type=NULL, class=NULL, scale=TRUE, ...)
<k>Arguments</k>
  x                   an object of class randomForest.
  type                either 1 or 2, specifying the type of importance measure (1=mean decrease in accuracy, 2=mean decrease in node impurity).
  class               for classification problem, which class-specific measure to return.
  scale               For permutation based measures, should the measures be divided their “standard errors”?
  ...                 not used.
<k>Details</k>
Here are the definitions of the variable importance measures. 
The first measure is computed from permuting OOB data: For each tree, the prediction error on the out-of-bag portion of the data is recorded (error rate for classification, MSE for regression). 
Then the same is done after permuting each predictor variable. 

The difference between the two are then averaged over all trees, and nor- malized by the standard deviation of the differences. 
If the standard deviation of the differences is equal to 0 for a variable, the division is not done (but the average is almost always equal to 0 in that case). 
The second measure is the total decrease in node impurities from splitting on the variable, averaged over all trees. 

For classification, the node impurity is measured by the Gini index. 
For regression, it is measured by residual sum of squares.
<k>Value</k>
A matrix of importance measure, one row for each predictor variable. 
The column(s) are different importance measures.
<k>Examples</k>
    set.seed(4543)
    data(mtcars)
    mtcars.rf &lt;- randomForest(mpg ~ ., data=mtcars, ntree=1000,
                           keep.forest=FALSE, importance=TRUE)
    importance(mtcars.rf)
    importance(mtcars.rf, type=1)

<h3 id="randomForestPDFtopic-4">imports85</h3>
The Automobile Data
<k>Description</k>
This is the ‘Automobile’ data from the UCI Machine Learning Repository.
<k>Usage</k>
    data(imports85)
Format
imports85 is a data frame with 205 cases (rows) and 26 variables (columns). 
This data set consists of three types of entities: (a) the specification of an auto in terms of various characteristics, (b) its assigned insurance risk rating, (c) its normalized losses in use as compared to other cars. 
The second rating corresponds to the degree to which the auto is more risky than its price indicates. 

Cars are initially assigned a risk factor symbol associated with its price. 
Then, if it is more risky (or less), this symbol is adjusted by moving it up (or down) the scale. 
Actuarians call this process ‘symboling’. 

A value of +3 indicates that the auto is risky, -3 that it is probably pretty safe. 
The third factor is the relative average loss payment per insured vehicle year. 
This value is normal- ized for all autos within a particular size classification (two-door small, station wagons, sports/speciality, etc...), and represents the average loss per car per year.

Source
Originally created by Jeffrey C. Schlimmer, from 1985 Model Import Car and Truck Specifica- tions, 1985 Ward’s Automotive Yearbook, Personal Auto Manuals, Insurance Services Office, and Insurance Collision Report, Insurance Institute for Highway Safety. 
The original data is at http://www.ics.uci.edu/~mlearn/MLSummary.html.

References
  1985 Model Import Car and Truck Specifications, 1985 Ward’s Automotive Yearbook.
  Personal Auto Manuals, Insurance Services Office, 160 Water Street, New York, NY 10038
  Insurance Collision Report, Insurance Institute for Highway Safety, Watergate 600, Washington,
  DC 20037
<k>Examples</k>
  data(imports85)
  imp85 &lt;- imports85[,-2] # Too many NAs in normalizedLosses.
  imp85 &lt;- imp85[complete.cases(imp85), ]
  ## Drop empty levels for factors.
  imp85[] &lt;- lapply(imp85, function(x) if (is.factor(x)) x[, drop=TRUE] else x)
  stopifnot(require(randomForest))
  price.rf &lt;- randomForest(price ~ ., imp85, do.trace=10, ntree=100)
  print(price.rf)
  numDoors.rf &lt;- randomForest(numOfDoors ~ ., imp85, do.trace=10, ntree=100)
  print(numDoors.rf)

<h3 id="randomForestPDFtopic-5">margin</h3>
Margins of randomForest Classifier
<k>Description</k>
Compute or plot the margin of predictions from a randomForest classifier.
<k>Usage</k>
  ## S3 method for class 'randomForest'
  margin(x, ...)
  ## Default S3 method:
  margin(x, observed, ...)
  ## S3 method for class 'margin'
  plot(x, sort=TRUE, ...)
<k>Arguments</k>
  x                  an object of class randomForest, whose type is not regression, or a matrix of
                     predicted probabilities, one column per class and one row per observation. For
                     the plot method, x should be an object returned by margin.
  observed           the true response corresponding to the data in x.
  sort               Should the data be sorted by their class labels?
  ...                other graphical parameters to be passed to plot.default.
<k>Value</k>
For margin, the margin of observations from the randomForest classifier (or whatever classifier that produced the predicted probability matrix given to margin). 
The margin of a data point is defined as the proportion of votes for the correct class minus maximum proportion of votes for the other classes. 
Thus under majority votes, positive margin means correct classification, and vice versa.

<k>Examples</k>
    set.seed(1)
    data(iris)
    iris.rf &lt;- randomForest(Species ~ ., iris, keep.forest=FALSE)
    plot(margin(iris.rf))


<h3 id="randomForestPDFtopic-6">MDSplot</h3>
Multi-dimensional Scaling Plot of Proximity matrix from randomForest
<k>Description</k>
    Plot the scaling coordinates of the proximity matrix from randomForest.
<k>Usage</k>
    MDSplot(rf, fac, k=2, palette=NULL, pch=20, ...)
<k>Arguments</k>
    rf                 an object of class randomForest that contains the proximity component.
    fac                a factor that was used as response to train rf.
    k                  number of dimensions for the scaling coordinates.
    palette            colors to use to distinguish the classes; length must be the equal to the number
                    of levels.
    pch                plotting symbols to use.
    ...                other graphical parameters.
<k>Value</k>
    The output of cmdscale on 1 - rf$proximity is returned invisibly.
<k>Note</k>
   If k &gt; 2, pairs is used to produce the scatterplot matrix of the coordinates.
<k>Examples</k>
   set.seed(1)
   data(iris)
   iris.rf &lt;- randomForest(Species ~ ., iris, proximity=TRUE,
                           keep.forest=FALSE)
   MDSplot(iris.rf, iris$Species)
   ## Using different symbols for the classes:
   MDSplot(iris.rf, iris$Species, palette=rep(1, 3), pch=as.numeric(iris$Species))

<h3 id="randomForestPDFtopic-7">na.roughfix</h3>
Rough Imputation of Missing Values
<k>Description</k>
   Impute Missing Values by median/mode.
<k>Usage</k>
   na.roughfix(object, ...)
<k>Arguments</k>
   object             a data frame or numeric matrix.
   ...                further <k>arguments</k> special methods could require.
<k>Value</k>
A completed data matrix or data frame. 
For numeric variables, NAs are replaced with column medi- ans. 
For factor variables, NAs are replaced with the most frequent levels (breaking ties at random). 

If object contains no NAs, it is returned unaltered.
<k>Note</k>
   This is used as a starting point for imputing missing values by random forest.
<k>Examples</k>
    data(iris)
    iris.na &lt;- iris
    set.seed(111)
    ## artificially drop some data values.
    for (i in 1:4) iris.na[sample(150, sample(20, 1)), i] &lt;- NA
    iris.roughfix &lt;- na.roughfix(iris.na)
    iris.narf &lt;- randomForest(Species ~ ., iris.na, na.action=na.roughfix)
    print(iris.narf)

<h3 id="randomForestPDFtopic-8">outlier</h3>
Compute outlying measures
<k>Description</k>
    Compute outlying measures based on a proximity matrix.
<k>Usage</k>
    ## Default S3 method:
    outlier(x, cls=NULL, ...)
    ## S3 method for class 'randomForest'
    outlier(x, ...)
<k>Arguments</k>
    x                 a proximity matrix (a square matrix with 1 on the diagonal and values between 0
                   and 1 in the off-diagonal positions); or an object of class randomForest, whose
                   type is not regression.
    cls               the classes the rows in the proximity matrix belong to. If not given, all data are
                   assumed to come from the same class.
    ...               <k>arguments</k> for other methods.
<k>Value</k>
A numeric vector containing the outlying measures. 
The outlying measure of a case is computed as n / sum(squared proximity), normalized by subtracting the median and divided by the MAD, within each class.
<k>Examples</k>
   set.seed(1)
   iris.rf &lt;- randomForest(iris[,-5], iris[,5], proximity=TRUE)
   plot(outlier(iris.rf), type="h",
        col=c("red", "green", "blue")[as.numeric(iris$Species)])

<h3 id="randomForestPDFtopic-9">partialPlot</h3>
Partial dependence plot
<k>Description</k>
Partial dependence plot gives a graphical depiction of the marginal effect of a variable on the class probability (classification) or response (regression).
<k>Usage</k>
   ## S3 method for class 'randomForest'
   partialPlot(x, pred.data, x.var, which.class,
         w, plot = TRUE, add = FALSE,
         n.pt = min(length(unique(pred.data[, xname])), 51),
         rug = TRUE, xlab=deparse(substitute(x.var)), ylab="",
         main=paste("Partial Dependence on", deparse(substitute(x.var))),
         ...)
<k>Arguments</k>
   x                  an object of class randomForest, which contains a forest component.
   pred.data          a data frame used for contructing the plot, usually the training data used to con-
                      truct the random forest.
   x.var              name of the variable for which partial dependence is to be examined.
   which.class        For classification data, the class to focus on (default the first class).
   w                  weights to be used in averaging; if not supplied, mean is not weighted
   plot               whether the plot should be shown on the graphic device.
   add                whether to add to existing plot (TRUE).
   n.pt               if x.var is continuous, the number of points on the grid for evaluating partial
                      dependence.
   rug                whether to draw hash marks at the bottom of the plot indicating the deciles of
                      x.var.
   xlab               label for the x-axis.
   ylab               label for the y-axis.
   main               main title for the plot.
   ...                other graphical parameters to be passed on to plot or lines.
<k>Details</k>
    The function being plotted is defined as:
plotted is defined as:

    where x is the variable for which partial dependence is sought, and xiC is the other variables in
    the data. The summand is the predicted regression function for regression, and logits (i.e., log of
    fraction of votes) for which.class for classification:
                                                          K
                                                       1 X
                                f (x) = log pk (x) <u+2212>         log pj (x),
                                                       K j=1
    where K is the number of classes, k is which.class, and pj is the proportion of votes for class j.
<k>Value</k>
    A list with two components: x and y, which are the values used in the plot.
<k>Note</k>
    The randomForest object must contain the forest component; i.e., created with randomForest(...,
    keep.forest=TRUE).
    This function runs quite slow for large data sets.
References
    Friedman, J. (2001). Greedy function approximation: the gradient boosting machine, Ann. of Stat.
<k>Examples</k>
    data(iris)
    set.seed(543)
    iris.rf &lt;- randomForest(Species~., iris)
    partialPlot(iris.rf, iris, Petal.Width, "versicolor")
    ## Looping over variables ranked by importance:
    data(airquality)
    airquality &lt;- na.omit(airquality)
    set.seed(131)
    ozone.rf &lt;- randomForest(Ozone ~ ., airquality, importance=TRUE)
    imp &lt;- importance(ozone.rf)
   impvar &lt;- rownames(imp)[order(imp[, 1], decreasing=TRUE)]
   op &lt;- par(mfrow=c(2, 3))
   for (i in seq_along(impvar)) {
       partialPlot(ozone.rf, airquality, impvar[i], xlab=impvar[i],
                   main=paste("Partial Dependence on", impvar[i]),
                   ylim=c(30, 70))
   }
   par(op)

<h3 id="randomForestPDFtopic-10">plot</h3>
randomForest           Plot method for randomForest objects
<k>Description</k>
   Plot the error rates or MSE of a randomForest object
<k>Usage</k>
   ## S3 method for class 'randomForest'
   plot(x, type="l", main=deparse(substitute(x)), ...)
<k>Arguments</k>
   x                   an object of class randomForest.
   type                type of plot.
   main                main title of the plot.
   ...                 other graphical parameters.
<k>Value</k>
   Invisibly, the error rates or MSE of the randomForest object. If the object has a non-null test
   component, then the returned object is a matrix where the first column is the out-of-bag estimate of
   error, and the second column is for the test set.
<k>Note</k>
   This function does not work for randomForest objects that have type=unsupervised.
   If the x has a non-null test component, then the test set errors are also plotted.
<k>Examples</k>
    data(mtcars)
    plot(randomForest(mpg ~ ., mtcars, keep.forest=FALSE, ntree=100), log="y")

<h3 id="randomForestPDFtopic-11">predict</h3>
randomForest        predict method for random forest objects
<k>Description</k>
    Prediction of test data using random forest.
<k>Usage</k>
    ## S3 method for class 'randomForest'
    predict(object, newdata, type="response",
   norm.votes=TRUE, predict.all=FALSE, proximity=FALSE, nodes=FALSE,
   cutoff, ...)
<k>Arguments</k>
    object             an object of class randomForest, as that created by the function randomForest.
    newdata            a data frame or matrix containing new data. (Note: If not given, the out-of-bag
                    prediction in object is returned.
    type               one of response, prob. or votes, indicating the type of output: predicted val-
                    ues, matrix of class probabilities, or matrix of vote counts. class is allowed,
                    but automatically converted to "response", for backward compatibility.
    norm.votes         Should the vote counts be normalized (i.e., expressed as fractions)? Ignored if
                    object$type is regression.
    predict.all        Should the predictions of all trees be kept?
    proximity          Should proximity measures be computed? An error is issued if object$type is
                    regression.
    nodes              Should the terminal node indicators (an n by ntree matrix) be return? If so, it is
                    in the “nodes” attribute of the returned object.
    cutoff             (Classification only) A vector of length equal to number of classes. The ‘win-
                    ning’ class for an observation is the one with the maximum ratio of proportion of
                    votes to cutoff. Default is taken from the forest$cutoff component of object
                    (i.e., the setting used when running randomForest).
    ...                not used currently.
<k>Value</k>
  If object$type is regression, a vector of predicted values is returned. If predict.all=TRUE,
  then the returned object is a list of two components: aggregate, which is the vector of predicted
  values by the forest, and individual, which is a matrix where each column contains prediction by
  a tree in the forest.
  If object$type is classification, the object returned depends on the argument type:
  response          predicted classes (the classes with majority vote).
  prob              matrix of class probabilities (one column for each class and one row for each
                    input).
  vote              matrix of vote counts (one column for each class and one row for each new
                    input); either in raw counts or in fractions (if norm.votes=TRUE).
  If predict.all=TRUE, then the individual component of the returned object is a character matrix
  where each column contains the predicted class by a tree in the forest.
  If proximity=TRUE, the returned object is a list with two components: pred is the prediction (as
  described above) and proximity is the proximitry matrix. An error is issued if object$type is
  regression.
  If nodes=TRUE, the returned object has a “nodes” attribute, which is an n by ntree matrix, each
  column containing the node number that the cases fall in for that tree.
  NOTE: If the object inherits from randomForest.formula, then any data with NA are silently
  omitted from the prediction. The returned value will contain NA correspondingly in the aggregated
  and individual tree predictions (if requested), but not in the proximity or node matrices.
  NOTE2: Any ties are broken at random, so if this is undesirable, avoid it by using odd number
  ntree in randomForest().
  on original Fortran code by Leo Breiman and Adele Cutler.
References
  Breiman, L. (2001), Random Forests, Machine Learning 45(1), 5-32.
<k>Examples</k>
  data(iris)
  set.seed(111)
  ind &lt;- sample(2, nrow(iris), replace = TRUE, prob=c(0.8, 0.2))
  iris.rf &lt;- randomForest(Species ~ ., data=iris[ind == 1,])
  iris.pred &lt;- predict(iris.rf, iris[ind == 2,])
  table(observed = iris[ind==2, "Species"], predicted = iris.pred)
  ## Get prediction for all trees.
    predict(iris.rf, iris[ind == 2,], predict.all=TRUE)
    ## Proximities.
    predict(iris.rf, iris[ind == 2,], proximity=TRUE)
    ## Nodes matrix.
    str(attr(predict(iris.rf, iris[ind == 2,], nodes=TRUE), "nodes"))

<h3 id="randomForestPDFtopic-12">randomForest</h3>
Classification and Regression with Random Forest
<k>Description</k>
randomForest implements Breiman’s random forest algorithm (based on Breiman and Cutler’s original Fortran code) for classification and regression.
It can also be used in unsupervised mode for assessing proximities among data points.
<k>Usage</k>
    ## S3 method for class 'formula'
    randomForest(formula, data=NULL, ..., subset, na.action=na.fail)
    ## Default S3 method:
    randomForest(x, y=NULL, xtest=NULL, ytest=NULL, ntree=500,
     mtry=if (!is.null(y) && !is.factor(y))
     max(floor(ncol(x)/3), 1) else floor(sqrt(ncol(x))),
     weights=NULL,
     replace=TRUE, classwt=NULL, cutoff, strata,
     sampsize = if (replace) nrow(x) else ceiling(.632*nrow(x)),
     nodesize = if (!is.null(y) && !is.factor(y)) 5 else 1,
     maxnodes = NULL,
     importance=FALSE, localImp=FALSE, nPerm=1,
     proximity, oob.prox=proximity,
     norm.votes=TRUE, do.trace=FALSE,
     keep.forest=!is.null(y) && is.null(xtest), corr.bias=FALSE,
     keep.inbag=FALSE, ...)
    ## S3 method for class 'randomForest'
    print(x, ...)
<k>Arguments</k>
    data  an optional data frame containing the variables in the model.
          By default the variables are taken from the environment which randomForest is called from.

    subset  an index vector indicating which rows should be used. (NOTE: If given, this argument must be named.)

    na.action  A function to specify the action to be taken if NAs are found. (NOTE: If given, this argument must be named.)

    x, formula  a data frame or a matrix of predictors, or a formula describing the model to be fitted (for the print method, an randomForest object).
  y  A response vector. If a factor, classification is assumed, otherwise regression is assumed. If omitted, randomForest will run in unsupervised mode.

  xtest         a data frame or matrix (like x) containing predictors for the test set.
  ytest         response for the test set.
  ntree         Number of trees to grow. This should not be set to too small a number, to ensure that every input row gets predicted at least a few times.
  mtry          Number of variables randomly sampled as candidates at each split. Note that the default values are different for classification (sqrt(p) where p is number of variables in x) and regression (p/3)
  weights       A vector of length same as y that are positive weights used only in sampling data to grow each tree (not used in any other calculation)
  replace       Should sampling of cases be done with or without replacement?
  classwt       Priors of the classes. Need not add up to one. Ignored for regression.
  cutoff        (Classification only) A vector of length equal to number of classes. The ‘win-ning’ class for an observation is the one with the maximum ratio of proportion of votes to cutoff. Default is 1/k where k is the number of classes (i.e., majority vote wins).
  strata        A (factor) variable that is used for stratified sampling.
  sampsize      Size(s) of sample to draw. For classification, if sampsize is a vector of the length the number of strata, then sampling is stratified by strata, and the elements of sampsize indicate the numbers to be drawn from the strata.
  nodesize      Minimum size of terminal nodes. Setting this number larger causes smaller trees to be grown (and thus take less time). Note that the default values are different for classification (1) and regression (5).
  maxnodes      Maximum number of terminal nodes trees in the forest can have. If not given, trees are grown to the maximum possible (subject to limits by nodesize). If set larger than maximum possible, a warning is issued.
  importance  Should importance of predictors be assessed?
  localImp  Should casewise importance measure be computed? (Setting this to TRUE will override importance.)
  nPerm  Number of times the OOB data are permuted per tree for assessing variable importance. Number larger than 1 gives slightly more stable estimate, but not very effective. Currently only implemented for regression.
  proximity  Should proximity measure among the rows be calculated?
  oob.prox  Should proximity be calculated only on “out-of-bag” data?
  norm.votes  If TRUE (default), the final result of votes are expressed as fractions. If FALSE, raw vote counts are returned (useful for combining results from different runs). Ignored for regression.
  do.trace      If set to TRUE, give a more verbose output as randomForest is run. If set to some integer, then running output is printed for every do.trace trees.
  keep.forest   If set to FALSE, the forest will not be retained in the output object. If xtest is given, defaults to FALSE.
   corr.bias         perform bias correction for regression? Note: Experimental. Use at your own risk.
   keep.inbag        Should an n by ntree matrix be returned that keeps track of which samples are “in-bag” in which trees (but not how many times, if sampling with replacement)
   ...               optional parameters to be passed to the low level function randomForest.default.
<k>Value</k>
   An object of class randomForest, which is a list with the following components:
   call              the original call to randomForest
   type              one of regression, classification, or unsupervised.
   predicted         the predicted values of the input data based on out-of-bag samples.
   importance        a matrix with nclass + 2 (for classification) or two (for regression) columns.
                  For classification, the first nclass columns are the class-specific measures com-
                  puted as mean descrease in accuracy. The nclass + 1st column is the mean
                  descrease in accuracy over all classes. The last column is the mean decrease
                  in Gini index. For Regression, the first column is the mean decrease in accu-
                  racy and the second the mean decrease in MSE. If importance=FALSE, the last
                  measure is still returned as a vector.
   importanceSD      The “standard errors” of the permutation-based importance measure. For classi-
                  fication, a p by nclass + 1 matrix corresponding to the first nclass + 1 columns
                  of the importance matrix. For regression, a length p vector.
   localImp          a p by n matrix containing the casewise importance measures, the [i,j] ele-
                  ment of which is the importance of i-th variable on the j-th case. NULL if
                  localImp=FALSE.
   ntree             number of trees grown.
   mtry              number of predictors sampled for spliting at each node.
   forest            (a list that contains the entire forest; NULL if randomForest is run in unsuper-
                  vised mode or if keep.forest=FALSE.
   err.rate          (classification only) vector error rates of the prediction on the input data, the i-th
                  element being the (OOB) error rate for all trees up to the i-th.
   confusion         (classification only) the confusion matrix of the prediction (based on OOB data).
   votes             (classification only) a matrix with one row for each input data point and one
                  column for each class, giving the fraction or number of (OOB) ‘votes’ from the
                  random forest.
   oob.times         number of times cases are ‘out-of-bag’ (and thus used in computing OOB error
                  estimate)
   proximity         if proximity=TRUE when randomForest is called, a matrix of proximity mea-
                  sures among the input (based on the frequency that pairs of data points are in the
                  same terminal nodes).
   mse               (regression only) vector of mean square errors: sum of squared residuals divided
                  by n.
   rsq               (regression only) “pseudo R-squared”: 1 - mse / Var(y).
  test                if test set is given (through the xtest or additionally ytest <k>arguments</k>), this
                      component is a list which contains the corresponding predicted, err.rate,
                      confusion, votes (for classification) or predicted, mse and rsq (for regres-
                      sion) for the test set. If proximity=TRUE, there is also a component, proximity,
                      which contains the proximity among the test set as well as proximity between
                      test and training data.
<k>Note</k>
  The forest structure is slightly different between classification and regression. For details on how
  the trees are stored, see the help page for getTree.
  If xtest is given, prediction of the test set is done “in place” as the trees are grown. If ytest is also
  given, and do.trace is set to some positive integer, then for every do.trace trees, the test set error
  is printed. Results for the test set is returned in the test component of the resulting randomForest
  object. For classification, the votes component (for training or test set data) contain the votes the
  cases received for the classes. If norm.votes=TRUE, the fraction is given, which can be taken as
  predicted probabilities for the classes.
  For large data sets, especially those with large number of variables, calling randomForest via the
  formula interface is not advised: There may be too much overhead in handling the formula.
  The “local” (or casewise) variable importance is computed as follows: For classification, it is the
  increase in percent of times a case is OOB and misclassified when the variable is permuted. For
  regression, it is the average increase in squared OOB residuals when the variable is permuted.
  on original Fortran code by Leo Breiman and Adele Cutler.
References
  Breiman, L. (2001), Random Forests, Machine Learning 45(1), 5-32.
  Breiman, L (2002), “Manual On Setting Up, Using, And Understanding Random Forests V3.1”,
  https://www.stat.berkeley.edu/~breiman/Using_random_forests_V3.1.pdf.
<k>Examples</k>
  ## Classification:
  ##data(iris)
  set.seed(71)
  iris.rf &lt;- randomForest(Species ~ ., data=iris, importance=TRUE,
                          proximity=TRUE)
  print(iris.rf)
  ## Look at variable importance:
  round(importance(iris.rf), 2)
  ## Do MDS on 1 - proximity:
   iris.mds &lt;- cmdscale(1 - iris.rf$proximity, eig=TRUE)
   op &lt;- par(pty="s")
   pairs(cbind(iris[,1:4], iris.mds$points), cex=0.6, gap=0,
      col=c("red", "green", "blue")[as.numeric(iris$Species)],
      main="Iris Data: Predictors and MDS of Proximity Based on RandomForest")
   par(op)
   print(iris.mds$GOF)
   ## The `unsupervised' case:
   set.seed(17)
   iris.urf &lt;- randomForest(iris[, -5])
   MDSplot(iris.urf, iris$Species)
   ## stratified sampling: draw 20, 30, and 20 of the species to grow each tree.
   (iris.rf2 &lt;- randomForest(iris[1:4], iris$Species,
                          sampsize=c(20, 30, 20)))
   ## Regression:
   ## data(airquality)
   set.seed(131)
   ozone.rf &lt;- randomForest(Ozone ~ ., data=airquality, mtry=3,
                         importance=TRUE, na.action=na.omit)
   print(ozone.rf)
   ## Show "importance" of variables: higher value mean more important:
   round(importance(ozone.rf), 2)
   ## "x" can be a matrix instead of a data frame:
   set.seed(17)
   x &lt;- matrix(runif(5e2), 100)
   y &lt;- gl(2, 50)
   (myrf &lt;- randomForest(x, y))
   (predict(myrf, x))
   ## "complicated" formula:
   (swiss.rf &lt;- randomForest(sqrt(Fertility) ~ . - Catholic + I(Catholic &lt; 50),
                          data=swiss))
   (predict(swiss.rf, swiss))
   ## Test use of 32-level factor as a predictor:
   set.seed(1)
   x &lt;- data.frame(x1=gl(53, 10), x2=runif(530), y=rnorm(530))
   (rf1 &lt;- randomForest(x[-3], x[[3]], ntree=10))
   ## Grow no more than 4 nodes per tree:
   (treesize(randomForest(Species ~ ., data=iris, maxnodes=4, ntree=30)))
   ## test proximity in regression
   iris.rrf &lt;- randomForest(iris[-1], iris[[1]], ntree=101, proximity=TRUE, oob.prox=FALSE)
   str(iris.rrf$proximity)
   ## Using weights: make versicolors having 3 times larger weights
   iris_wt &lt;- ifelse( iris$Species == "versicolor", 3, 1 )
   set.seed(15)
   iris.wcrf &lt;- randomForest(iris[-5], iris[[5]], weights=iris_wt, keep.inbag=TRUE)
   print(rowSums(iris.wcrf$inbag))
   set.seed(15)
   iris.wrrf &lt;- randomForest(iris[-1], iris[[1]], weights=iris_wt, keep.inbag=TRUE)
   print(rowSums(iris.wrrf$inbag))

<h3 id="randomForestPDFtopic-13">rfcv</h3>
Random Forest Cross-Valdidation for feature selection
<k>Description</k>
   This function shows the cross-validated prediction performance of models with sequentially re-
   duced number of predictors (ranked by variable importance) via a nested cross-validation proce-
   dure.
<k>Usage</k>
   rfcv(trainx, trainy, cv.fold=5, scale="log", step=0.5,
        mtry=function(p) max(1, floor(sqrt(p))), recursive=FALSE, ...)
<k>Arguments</k>
   trainx             matrix or data frame containing columns of predictor variables
   trainy             vector of response, must have length equal to the number of rows in trainx
   cv.fold            number of folds in the cross-validation
   scale              if "log", reduce a fixed proportion (step) of variables at each step, otherwise
                      reduce step variables at a time
   step               if log=TRUE, the fraction of variables to remove at each step, else remove this
                      many variables at a time
   mtry               a function of number of remaining predictor variables to use as the mtry param-
                      eter in the randomForest call
   recursive          whether variable importance is (re-)assessed at each step of variable reduction
   ...                other <k>arguments</k> passed on to randomForest
<k>Value</k>
   A list with the following components:
   list(n.var=n.var, error.cv=error.cv, predicted=cv.pred)
   n.var              vector of number of variables used at each step
   error.cv           corresponding vector of error rates or MSEs at each step
   predicted          list of n.var components, each containing the predicted values from the cross-
                      validation
References
    Svetnik, V., Liaw, A., Tong, C. and Wang, T., “Application of Breiman’s Random Forest to Mod-
    eling Structure-Activity Relationships of Pharmaceutical Molecules”, MCS 2004, Roli, F. and
    Windeatt, T. (Eds.) pp. 334-343.
<k>Examples</k>
    set.seed(647)
    myiris &lt;- cbind(iris[1:4], matrix(runif(96 * nrow(iris)), nrow(iris), 96))
    result &lt;- rfcv(myiris, iris$Species, cv.fold=3)
    with(result, plot(n.var, error.cv, log="x", type="o", lwd=2))
    ## The following can take a while to run, so if you really want to try
    ## it, copy and paste the code into R.
    ## Not run:
    result &lt;- replicate(5, rfcv(myiris, iris$Species), simplify=FALSE)
    error.cv &lt;- sapply(result, "[[", "error.cv")
    matplot(result[[1]]$n.var, cbind(rowMeans(error.cv), error.cv), type="l",
         lwd=c(2, rep(1, ncol(error.cv))), col=1, lty=1, log="x",
         xlab="Number of variables", ylab="CV Error")
    ## End(Not run)

<h3 id="randomForestPDFtopic-14">rfImpute</h3>
Missing Value Imputations by randomForest
<k>Description</k>
    Impute missing values in predictor data using proximity from randomForest.
<k>Usage</k>
    ## Default S3 method:
    rfImpute(x, y, iter=5, ntree=300, ...)
    ## S3 method for class 'formula'
    rfImpute(x, data, ..., subset)
<k>Arguments</k>
    x                 A data frame or matrix of predictors, some containing NAs, or a formula.
    y                 Response vector (NA’s not allowed).
    data              A data frame containing the predictors and response.
  iter               Number of iterations to run the imputation.
  ntree              Number of trees to grow in each iteration of randomForest.
  ...                Other <k>arguments</k> to be passed to randomForest.
  subset             A logical vector indicating which observations to use.
<k>Details</k>
  The algorithm starts by imputing NAs using na.roughfix. Then randomForest is called with the
  completed data. The proximity matrix from the randomForest is used to update the imputation of
  the NAs. For continuous predictors, the imputed value is the weighted average of the non-missing
  obervations, where the weights are the proximities. For categorical predictors, the imputed value is
  the category with the largest average proximity. This process is iterated iter times.
  Note: Imputation has not (yet) been implemented for the unsupervised case. Also, Breiman (2003)
  notes that the OOB estimate of error from randomForest tend to be optimistic when run on the data
  matrix with imputed values.
<k>Value</k>
  A data frame or matrix containing the completed data matrix, where NAs are imputed using proxim-
  ity from randomForest. The first column contains the response.
References
  Leo Breiman (2003). Manual for Setting Up, Using, and Understanding Random Forest V4.0.
  https://www.stat.berkeley.edu/~breiman/Using_random_forests_v4.0.pdf
<k>Examples</k>
  data(iris)
  iris.na &lt;- iris
  set.seed(111)
  ## artificially drop some data values.
  for (i in 1:4) iris.na[sample(150, sample(20, 1)), i] &lt;- NA
  set.seed(222)
  iris.imputed &lt;- rfImpute(Species ~ ., iris.na)
  set.seed(333)
  iris.rf &lt;- randomForest(Species ~ ., iris.imputed)
  print(iris.rf)

<h3 id="randomForestPDFtopic-15">rfNews</h3>
Show the NEWS file
<k>Description</k>
    Show the NEWS file of the randomForest package.
<k>Usage</k>
    rfNews()
<k>Value</k>
    None.

<h3 id="randomForestPDFtopic-16">treesize</h3>
Size of trees in an ensemble
<k>Description</k>
    Size of trees (number of nodes) in and ensemble.
<k>Usage</k>
    treesize(x, terminal=TRUE)
<k>Arguments</k>
    x                 an object of class randomForest, which contains a forest component.
    terminal          count terminal nodes only (TRUE) or all nodes (FALSE
<k>Value</k>
    A vector containing number of nodes for the trees in the randomForest object.
<k>Note</k>
    The randomForest object must contain the forest component; i.e., created with randomForest(...,
    keep.forest=TRUE).
<k>Examples</k>
   data(iris)
   iris.rf &lt;- randomForest(Species ~ ., iris)
   hist(treesize(iris.rf))

<h3 id="randomForestPDFtopic-17">tuneRF</h3>
Tune randomForest for the optimal mtry parameter
<k>Description</k>
   Starting with the default value of mtry, search for the optimal value (with respect to Out-of-Bag
   error estimate) of mtry for randomForest.
<k>Usage</k>
   tuneRF(x, y, mtryStart, ntreeTry=50, stepFactor=2, improve=0.05,
          trace=TRUE, plot=TRUE, doBest=FALSE, ...)
<k>Arguments</k>
   x                  matrix or data frame of predictor variables
   y                  response vector (factor for classification, numeric for regression)
   mtryStart          starting value of mtry; default is the same as in randomForest
   ntreeTry           number of trees used at the tuning step
   stepFactor         at each iteration, mtry is inflated (or deflated) by this <k>value</k>
   improve            the (relative) improvement in OOB error must be by this much for the search to
                      continue
   trace              whether to print the progress of the search
   plot               whether to plot the OOB error as function of mtry
   doBest             whether to run a forest using the optimal mtry found
   ...                options to be given to randomForest
<k>Value</k>
   If doBest=FALSE (default), it returns a matrix whose first column contains the mtry values searched,
   and the second column the corresponding OOB error.
   If doBest=TRUE, it returns the randomForest object produced with the optimal mtry.
<k>Examples</k>
   data(fgl, package="MASS")
   fgl.res &lt;- tuneRF(fgl[,-10], fgl[,10], stepFactor=1.5)

<h3 id="randomForestPDFtopic-18">varImpPlot</h3>
Variable Importance Plot
<k>Description</k>
    Dotchart of variable importance as measured by a Random Forest
<k>Usage</k>
    varImpPlot(x, sort=TRUE, n.var=min(30, nrow(x$importance)),
            type=NULL, class=NULL, scale=TRUE,
            main=deparse(substitute(x)), ...)
<k>Arguments</k>
    x                   An object of class randomForest.
    sort                Should the variables be sorted in decreasing order of importance?
    n.var           How many variables to show? (Ignored if sort=FALSE.)
    type, class, scale
                 <k>arguments</k> to be passed on to importance
    main                plot title.
    ...                 Other graphical parameters to be passed on to dotchart.
<k>Value</k>
    Invisibly, the importance of the variables that were plotted.
<k>Examples</k>
    set.seed(4543)
    data(mtcars)
    mtcars.rf &lt;- randomForest(mpg ~ ., data=mtcars, ntree=1000, keep.forest=FALSE,
                           importance=TRUE)
    varImpPlot(mtcars.rf)

<h3 id="randomForestPDFtopic-19">varUsed</h3>
Variables used in a random forest
<k>Description</k>
   Find out which predictor variables are actually used in the random forest.
<k>Usage</k>
   varUsed(x, by.tree=FALSE, count=TRUE)
<k>Arguments</k>
   x                  An object of class randomForest.
   by.tree            Should the list of variables used be broken down by trees in the forest?
   count              Should the frequencies that variables appear in trees be returned?
<k>Value</k>
   If count=TRUE and by.tree=FALSE, a integer vector containing frequencies that variables are used
   in the forest. If by.tree=TRUE, a matrix is returned, breaking down the counts by tree (each column
   corresponding to one tree and each row to a variable).
   If count=FALSE and by.tree=TRUE, a list of integer indices is returned giving the variables used in
   the trees, else if by.tree=FALSE, a vector of integer indices giving the variables used in the entire
   forest.
<k>Examples</k>
   data(iris)
   set.seed(17)
   varUsed(randomForest(Species~., iris, ntree=100))

<a href="randomForest.pdf" class="whitebut ">randomForest document</a>

<h2>find unused factor levels</h2>
f <- factor(letters[1:2], levels = letters[1:4])
f
[1] a b
Levels: a b c d
levels(f)
[1] "a" "b" "c" "d"

To see the unused levels:
setdiff(levels(f), f)
[1] "c" "d"

#more efficient for long vectors 
setdiff(levels(f), unique(f))

<h2>excluding child class</h2>
<k>xml_remove</k> function
library(rvest)

#read page
url<-"https://forums.vwvortex.com/showthread.php?8829402-atlas-v6-oil-change-routine"
review <- read_html(url)  

#find parent nodes
threads<- review %>% html_nodes("blockquote.postcontent.restore:not(.quote_container)")

#find children nodes to exclude
toremove <- threads %>% html_node("div.bbcode_container") 

#remove nodes
xml_remove(toremove)  

#convert the parent nodes to text
threads %>% html_text(trim=true) 

<h2>remove last character of string</h2>
  i = substr(i, 1, nchar(i)-1)





<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});

//d3.selectAll("h2").style("color", function() {
//   return "hsl(" + Math.random() * 360 + ",80%,50%)";
//});

</script>
</body>
</html>
