<html><head><base target="_blank"><title>Javascript Array Processing</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script type="text/javascript" src="https://williamkpchan.github.io//mainscript.js"></script>
<script>
  var showTopicNumber = true;
</script>
<style>
body{width:80%;margin-left: 10%; font-size:22px;}
strong, h1, h2 {color: gold;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>Javascript Array Processing, ONE DIMENSION</h1>
<br>
<div id="toc"> <a href="#topic-1" target="_self"></a><br> <a href="#topic-2" target="_self">Add/remove items</a><br> <a href="#topic-3" target="_self"> - splice</a><br> <a href="#topic-4" target="_self"> - slice</a><br> <a href="#topic-5" target="_self"> - concat</a><br> <a href="#topic-6" target="_self"></a><br> <a href="#topic-7" target="_self">Iterate: forEach</a><br> <a href="#topic-8" target="_self"></a><br> <a href="#topic-9" target="_self">Searching in array</a><br> <a href="#topic-10" target="_self"> - indexOf/lastIndexOf and includes</a><br> <a href="#topic-11" target="_self"> - find and findIndex</a><br> <a href="#topic-12" target="_self"> - filter</a><br> <a href="#topic-13" target="_self"></a><br> <a href="#topic-14" target="_self">Transform an array</a><br> <a href="#topic-15" target="_self"> - map</a><br> <a href="#topic-16" target="_self"> - sort(fn)</a><br> <a href="#topic-17" target="_self"> - reverse</a><br> <a href="#topic-18" target="_self"> - split and join</a><br> <a href="#topic-19" target="_self"> - reduce/reduceRight</a><br> <a href="#topic-20" target="_self"></a><br> <a href="#topic-21" target="_self">Array.isArray</a><br> <a href="#topic-22" target="_self"></a><br> <a href="#topic-23" target="_self">Most methods support “thisArg”</a><br> <a href="#topic-24" target="_self"></a><br> <a href="#topic-25" target="_self">Summary</a><br><br>
<a href="#arraytopic-1" target="_self">JavaScript 陣列處理方法</a><br> <a href="#arraytopic-2" target="_self">Array.prototype.filter()</a><br> <a href="#arraytopic-3" target="_self">Array.prototype.find()</a><br> <a href="#arraytopic-4" target="_self">Array.prototype.forEach()</a><br> <a href="#arraytopic-5" target="_self">Array.prototype.map()</a><br> <a href="#arraytopic-6" target="_self">Array.prototype.every()</a><br> <a href="#arraytopic-7" target="_self">Array.prototype.some()</a><br> <a href="#arraytopic-8" target="_self">Array.prototype.reduce()</a><br>
</div></center>
<pre>
<h2 id="topic-1"></h2>
<h2 id="topic-2">Add/remove items</h2>
We already know methods that add and remove items from the beginning or the end:
<code>arr.push(...items)</code> – adds items to the end,
<code>arr.pop()</code> – extracts an item from the end,
<code>arr.shift()</code> – extracts an item from the beginning,
<code>arr.unshift(...items)</code> – adds items to the beginning.
Here are a few others.

<h2 id="topic-3"> - splice</h2>
How to delete an element from the array?
The arrays are objects, so we can try to use <code>delete</code>:
<code>let arr = ["I", "go", "home"];
delete arr[1]; // remove "go"
alert( arr[1] ); // undefined
// now arr = ["I",, "home"];
alert( arr.length ); // 3</code>

The element was removed, but the array still has 3 elements, we can see that <code>arr.length == 3</code>.
That’s natural, because <code>delete obj.key</code> removes a value by the <code>key</code>. 
It’s all it does. 
Fine for objects. 
But for arrays we usually want the rest of elements to shift and occupy the freed place. 
We expect to have a shorter array now.
So, special methods should be used.
The arr.splice(start) method is a swiss army knife for arrays. 
It can do everything: insert, remove and replace elements.
The syntax is:
<code>arr.splice(index[, deleteCount, elem1, ..., elemN])</code>

It starts from the position <code>index</code>: removes <code>deleteCount</code> elements and then inserts <code>elem1, ..., elemN</code> at their place. 
Returns the array of removed elements.

This method is easy to grasp by examples.
Let’s start with the deletion:
<code>let arr = ["I", "study", "JavaScript"];
arr.splice(1, 1); // from index 1 remove 1 element
alert( arr ); // ["I", "JavaScript"]</code>

Easy, right? Starting from the index <code>1</code> it removed <code>1</code> element.
In the next example we remove 3 elements and replace them with the other two:
<code>let arr = ["I", "study", "JavaScript", "right", "now"];
// remove 3 first elements and replace them with another
arr.splice(0, 3, "Let's", "dance");
alert( arr ) // now ["Let's", "dance", "right", "now"]</code>

Here we can see that <code>splice</code> returns the array of removed elements:
<code>let arr = ["I", "study", "JavaScript", "right", "now"];
// remove 2 first elements
let removed = arr.splice(0, 2);
alert( removed ); // "I", "study" &lt;-- array of removed elements</code>

The <code>splice</code> method is also able to insert the elements without any removals. 
For that we need to set <code>deleteCount</code> to <code>0</code>:
<code>let arr = ["I", "study", "JavaScript"];
// from index 2
// delete 0
// then insert "complex" and "language"
arr.splice(2, 0, "complex", "language");
alert( arr ); // "I", "study", "complex", "language", "JavaScript"</code>

Here and in other array methods, negative indexes are allowed. 
They specify the position from the end of the array, like here:
<code>let arr = [1, 2, 5];
// from index -1 (one step from the end)
// delete 0 elements,
// then insert 3 and 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5</code>

<h2 id="topic-4"> - slice</h2>
The method arr.slice is much simpler than similar-looking <code>arr.splice</code>.
The syntax is:
<code>arr.slice([start], [end])</code>

It returns a new array copying to it all items from index <code>start</code> to <code>end</code> (not including <code>end</code>). 
Both <code>start</code> and <code>end</code> can be negative, in that case position from array end is assumed.
It’s similar to a string method <code>str.slice</code>, but instead of substrings it makes subarrays.
For instance:
<code>let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)
alert( arr.slice(-2) ); // s,t (copy from -2 till the end)</code>

We can also call it without arguments: <code>arr.slice()</code> creates a copy of <code>arr</code>. 
That’s often used to obtain a copy for further transformations that should not affect the original array.
<h2 id="topic-5"> - concat</h2>
The method arr.concat creates a new array that includes values from other arrays and additional items.
The syntax is:
<code>arr.concat(arg1, arg2...)</code>

It accepts any number of arguments – either arrays or values.
The result is a new array containing items from <code>arr</code>, then <code>arg1</code>, <code>arg2</code> etc.
If an argument <code>argN</code> is an array, then all its elements are copied. 
Otherwise, the argument itself is copied.
For instance:
<code>let arr = [1, 2];
// create an array from: arr and [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4
// create an array from: arr and [3,4] and [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6
// create an array from: arr and [3,4], then add values 5 and 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6</code>

Normally, it only copies elements from arrays. 
Other objects, even if they look like arrays, are added as a whole:
<code>let arr = [1, 2];
let arrayLike = {
0: "something",
length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]</code>

…But if an array-like object has a special <code>Symbol.isConcatSpreadable</code> property, then it’s treated as an array by <code>concat</code>: its elements are added instead:
<code>let arr = [1, 2];
let arrayLike = {
0: "something",
1: "else",
[Symbol.isConcatSpreadable]: true,
length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,something,else</code>

<h2 id="topic-6"></h2>
<h2 id="topic-7">Iterate: forEach</h2>
The arr.forEach method allows to run a function for every element of the array.
The syntax:
<code>arr.forEach(function(item, index, array) {
// ... 
do something with item
});</code>

For instance, this shows each element of the array:
<code>// for each element call alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);</code>

And this code is more elaborate about their positions in the target array:
<code>["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) =&gt; {
alert(`${item} is at index ${index} in ${array}`);
});</code>

The result of the function (if it returns any) is thrown away and ignored.
<h2 id="topic-8"></h2>
<h2 id="topic-9">Searching in array</h2>
Now let’s cover methods that search in an array.
<h2 id="topic-10"> - indexOf/lastIndexOf and includes</h2>
The methods arr.indexOf, arr.lastIndexOf and arr.includes have the same syntax and do essentially the same as their string counterparts, but operate on items instead of characters:
<code>arr.indexOf(item, from)</code> – looks for <code>item</code> starting from index <code>from</code>, and returns the index where it was found, otherwise <code>-1</code>.
<code>arr.lastIndexOf(item, from)</code> – same, but looks for from right to left.
<code>arr.includes(item, from)</code> – looks for <code>item</code> starting from index <code>from</code>, returns <code>true</code> if found.
For instance:
<code>let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
alert( arr.includes(1) ); // true</code>

Note that the methods use <code>===</code> comparison. 
So, if we look for <code>false</code>, it finds exactly <code>false</code> and not the zero.
If we want to check for inclusion, and don’t want to know the exact index, then <code>arr.includes</code> is preferred.
Also, a very minor difference of <code>includes</code> is that it correctly handles <code>NaN</code>, unlike <code>indexOf/lastIndexOf</code>:
<code>const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (should be 0, but === equality doesn't work for NaN)
alert( arr.includes(NaN) );// true (correct)</code>

<h2 id="topic-11"> - find and findIndex</h2>
Imagine we have an array of objects. 
How do we find an object with the specific condition?
Here the arr.find(fn) method comes in handy.
The syntax is:
<code>let result = arr.find(function(item, index, array) {
// if true is returned, item is returned and iteration is stopped
// for falsy scenario returns undefined
});</code>

The function is called for elements of the array, one after another:
<code>item</code> is the element.
<code>index</code> is its index.
<code>array</code> is the array itself.
If it returns <code>true</code>, the search is stopped, the <code>item</code> is returned. 
If nothing found, <code>undefined</code> is returned.
For example, we have an array of users, each with the fields <code>id</code> and <code>name</code>. 
Let’s find the one with <code>id == 1</code>:
<code>let users = [
{id: 1, name: "John"},
{id: 2, name: "Pete"},
{id: 3, name: "Mary"}
];
let user = users.find(item =&gt; item.id == 1);
alert(user.name); // John</code>

In real life arrays of objects is a common thing, so the <code>find</code> method is very useful.
Note that in the example we provide to <code>find</code> the function <code>item =&gt; item.id == 1</code> with one argument. 
That’s typical, other arguments of this function are rarely used.
The arr.findIndex method is essentially the same, but it returns the index where the element was found instead of the element itself and <code>-1</code> is returned when nothing is found.
<h2 id="topic-12"> - filter</h2>
The <code>find</code> method looks for a single (first) element that makes the function return <code>true</code>.
If there may be many, we can use arr.filter(fn).
The syntax is similar to <code>find</code>, but <code>filter</code> returns an array of all matching elements:
<code>let results = arr.filter(function(item, index, array) {
// if true item is pushed to results and the iteration continues
// returns empty array if nothing found
});</code>

For instance:
<code>let users = [
{id: 1, name: "John"},
{id: 2, name: "Pete"},
{id: 3, name: "Mary"}
];
// returns array of the first two users
let someUsers = users.filter(item =&gt; item.id &lt; 3);
alert(someUsers.length); // 2</code>

<h2 id="topic-13"></h2>
<h2 id="topic-14">Transform an array</h2>
Let’s move on to methods that transform and reorder an array.
<h2 id="topic-15"> - map</h2>
The arr.map method is one of the most useful and often used.
It calls the function for each element of the array and returns the array of results.
The syntax is:
<code>let result = arr.map(function(item, index, array) {
// returns the new value instead of item
});</code>

For instance, here we transform each element into its length:
<code>let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item =&gt; item.length);
alert(lengths); // 5,7,6</code>

<h2 id="topic-16"> - sort(fn)</h2>
The call to arr.sort() sorts the array <em>in place</em>, changing its element order.
It also returns the sorted array, but the returned value is usually ignored, as <code>arr</code> itself is modified.
For instance:
<code>let arr = [ 1, 2, 15 ];
// the method reorders the content of arr
arr.sort();
alert( arr );// 1, 15, 2</code>

Did you notice anything strange in the outcome?
The order became <code>1, 15, 2</code>. 
Incorrect. 
But why?
<strong>The items are sorted as strings by default.</strong>
Literally, all elements are converted to strings for comparisons. 
For strings, lexicographic ordering is applied and indeed <code>"2" &gt; "15"</code>.
To use our own sorting order, we need to supply a function as the argument of <code>arr.sort()</code>.
The function should compare two arbitrary values and return:
<code>function compare(a, b) {
if (a &gt; b) return 1; // if the first value is greater than the second
if (a == b) return 0; // if values are equal
if (a &lt; b) return -1; // if the first value is less than the second
}</code>

For instance, to sort as numbers:
<code>function compareNumeric(a, b) {
if (a &gt; b) return 1;
if (a == b) return 0;
if (a &lt; b) return -1;
}
let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);// 1, 2, 15</code>

Now it works as intended.
Let’s step aside and think what’s happening. 
The <code>arr</code> can be array of anything, right? It may contain numbers or strings or objects or whatever. 
We have a set of <em>some items</em>. 
To sort it, we need an <em>ordering function</em> that knows how to compare its elements. 
The default is a string order.
The <code>arr.sort(fn)</code> method implements a generic sorting algorithm. 
We don’t need to care how it internally works (an optimized quicksort most of the time). 
It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the <code>fn</code> which does the comparison.
By the way, if we ever want to know which elements are compared – nothing prevents from alerting them:
<code>[1, -2, 15, 2, 0, 8].sort(function(a, b) {
alert( a + " &lt;&gt; " + b );
});</code>

The algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.
Actually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.
That allows to write shorter functions:
<code>let arr = [ 1, 2, 15 ];
arr.sort(function(a, b) { return a - b; });
alert(arr);// 1, 2, 15</code>

Remember arrow functions? We can use them here for neater sorting:
<code>arr.sort( (a, b) =&gt; a - b );</code>

This works exactly the same as the longer version above.
Remember strings comparison algorithm? It compares letters by their codes by default.
For many alphabets, it’s better to use <code>str.localeCompare</code> method to correctly sort letters, such as <code>Ö</code>.
For example, let’s sort a few countries in German:
<code>let countries = ['Österreich', 'Andorra', 'Vietnam'];
alert( countries.sort( (a, b) =&gt; a &gt; b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)
alert( countries.sort( (a, b) =&gt; a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)</code>

<h2 id="topic-17"> - reverse</h2>
The method arr.reverse reverses the order of elements in <code>arr</code>.
For instance:
<code>let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1</code>

It also returns the array <code>arr</code> after the reversal.
<h2 id="topic-18"> - split and join</h2>
Here’s the situation from real life. 
We are writing a messaging app, and the person enters the comma-delimited list of receivers: <code>John, Pete, Mary</code>. 
But for us an array of names would be much more comfortable than a single string. 
How to get it?
The str.split(delim) method does exactly that. 
It splits the string into an array by the given delimiter <code>delim</code>.
In the example below, we split by a comma followed by space:
<code>let names = 'Bilbo, Gandalf, Nazgul';
let arr = names.split(', ');
for (let name of arr) {
alert( `A message to ${name}.` ); // A message to Bilbo(and other names)
}</code>

The <code>split</code> method has an optional second numeric argument – a limit on the array length. 
If it is provided, then the extra elements are ignored. 
In practice it is rarely used though:
<code>let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);
alert(arr); // Bilbo, Gandalf</code>

The call to <code>split(s)</code> with an empty <code>s</code> would split the string into an array of letters:
<code>let str = "test";
alert( str.split('') ); // t,e,s,t</code>

The call arr.join(glue) does the reverse to <code>split</code>. 
It creates a string of <code>arr</code> items joined by <code>glue</code> between them.
For instance:
<code>let arr = ['Bilbo', 'Gandalf', 'Nazgul'];
let str = arr.join(';'); // glue the array into a string using ;
alert( str ); // Bilbo;Gandalf;Nazgul</code>

<h2 id="topic-19"> - reduce/reduceRight</h2>
When we need to iterate over an array – we can use <code>forEach</code>, <code>for</code> or <code>for..of</code>.
When we need to iterate and return the data for each element – we can use <code>map</code>.
The methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. 
They are used to calculate a single value based on the array.
The syntax is:
<code>let value = arr.reduce(function(accumulator, item, index, array) {
// ...
}, [initial]);</code>

The function is applied to all array elements one after another and “carries on” its result to the next call.
Arguments:
<code>accumulator</code> – is the result of the previous function call, equals <code>initial</code> the first time (if <code>initial</code> is provided).
<code>item</code> – is the current array item.
<code>index</code> – is its position.
<code>array</code> – is the array.
As function is applied, the result of the previous function call is passed to the next one as the first argument.
So, the first argument is essentially the accumulator that stores the combined result of all previous executions. 
And at the end it becomes the result of <code>reduce</code>.
Sounds complicated?
The easiest way to grasp that is by example.
Here we get a sum of an array in one line:
<code>let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) =&gt; sum + current, 0);
alert(result); // 15</code>

The function passed to <code>reduce</code> uses only 2 arguments, that’s typically enough.
Let’s see the details of what’s going on.
<ol>
On the first run, <code>sum</code> is the <code>initial</code> value (the last argument of <code>reduce</code>), equals <code>0</code>, and <code>current</code> is the first array element, equals <code>1</code>. 
So the function result is <code>1</code>.
On the second run, <code>sum = 1</code>, we add the second array element (<code>2</code>) to it and return.
On the 3rd run, <code>sum = 3</code> and we add one more element to it, and so on…
</ol>
The calculation flow:
<figure>
<object type="image/svg+xml" data="https://javascript.info/article/array-methods/reduce.svg" width="620" height="129">
<img src="https://javascript.info/article/array-methods/reduce.svg" alt="" width="620" height="129">
</object>

</figure>
Or in the form of a table, where each row represents a function call on the next array element:
<table>
<thead>
<tr>
<th></th>
<th><code>sum</code></th>
<th><code>current</code></th>
<th>result</th>
</tr>
</thead>
<tbody>
<tr>
<td>the first call</td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>the second call</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td>the third call</td>
<td><code>3</code></td>
<td><code>3</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td>the fourth call</td>
<td><code>6</code></td>
<td><code>4</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td>the fifth call</td>
<td><code>10</code></td>
<td><code>5</code></td>
<td><code>15</code></td>
</tr>
</tbody>
</table>
Here we can clearly see how the result of the previous call becomes the first argument of the next one.
We also can omit the initial value:
<code>let arr = [1, 2, 3, 4, 5];
// removed initial value from reduce (no 0)
let result = arr.reduce((sum, current) =&gt; sum + current);
alert( result ); // 15</code>

The result is the same. 
That’s because if there’s no initial, then <code>reduce</code> takes the first element of the array as the initial value and starts the iteration from the 2nd element.
The calculation table is the same as above, minus the first row.
But such use requires an extreme care. 
If the array is empty, then <code>reduce</code> call without initial value gives an error.
Here’s an example:
<code>let arr = [];
// Error: Reduce of empty array with no initial value
// if the initial value existed, reduce would return it for the empty arr.
arr.reduce((sum, current) =&gt; sum + current);</code>

So it’s advised to always specify the initial value.
The method arr.reduceRight does the same, but goes from right to left.
<h2 id="topic-20"></h2>
<h2 id="topic-21">Array.isArray</h2>
Arrays do not form a separate language type. 
They are based on objects.
So <code>typeof</code> does not help to distinguish a plain object from an array:
<code>alert(typeof {}); // object
alert(typeof []); // same</code>

…But arrays are used so often that there’s a special method for that: Array.isArray(value). 
It returns <code>true</code> if the <code>value</code> is an array, and <code>false</code> otherwise.
<code>alert(Array.isArray({})); // false
alert(Array.isArray([])); // true</code>

<h2 id="topic-22"></h2>
<h2 id="topic-23">Most methods support “thisArg”</h2>
Almost all array methods that call functions – like <code>find</code>, <code>filter</code>, <code>map</code>, with a notable exception of <code>sort</code>, accept an optional additional parameter <code>thisArg</code>.
That parameter is not explained in the sections above, because it’s rarely used. 
But for completeness we have to cover it.
Here’s the full syntax of these methods:
<code>arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg is the optional last argument</code>

The value of <code>thisArg</code> parameter becomes <code>this</code> for <code>func</code>.
For example, here we use a method of <code>army</code> object as a filter, and <code>thisArg</code> passes the context:
<code>let army = {
minAge: 18,
maxAge: 27,
canJoin(user) {
return user.age &gt;= this.minAge &amp;&amp; user.age &lt; this.maxAge;
}
};
let users = [
{age: 16},
{age: 20},
{age: 23},
{age: 30}
];
// find users, for who army.canJoin returns true
let soldiers = users.filter(army.canJoin, army);
alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23</code>

If in the example above we used <code>users.filter(army.canJoin)</code>, then <code>army.canJoin</code> would be called as a standalone function, with <code>this=undefined</code>, thus leading to an instant error.
A call to <code>users.filter(army.canJoin, army)</code> can be replaced with <code>users.filter(user =&gt; army.canJoin(user))</code>, that does the same. 
The former is used more often, as it’s a bit easier to understand for most people.
<h2 id="topic-24"></h2>
<h2 id="topic-25">Summary</h2>
A cheat sheet of array methods:

To add/remove elements:
<code>push(...items)</code> – adds items to the end,
<code>pop()</code> – extracts an item from the end,
<code>shift()</code> – extracts an item from the beginning,
<code>unshift(...items)</code> – adds items to the beginning.
<code>splice(pos, deleteCount, ...items)</code> – at index <code>pos</code> delete <code>deleteCount</code> elements and insert <code>items</code>.
<code>slice(start, end)</code> – creates a new array, copies elements from position <code>start</code> till <code>end</code> (not inclusive) into it.
<code>concat(...items)</code> – returns a new array: copies all members of the current one and adds <code>items</code> to it. 
If any of <code>items</code> is an array, then its elements are taken.


To search among elements:
<code>indexOf/lastIndexOf(item, pos)</code> – look for <code>item</code> starting from position <code>pos</code>, return the index or <code>-1</code> if not found.
<code>includes(value)</code> – returns <code>true</code> if the array has <code>value</code>, otherwise <code>false</code>.
<code>find/filter(func)</code> – filter elements through the function, return first/all values that make it return <code>true</code>.
<code>findIndex</code> is like <code>find</code>, but returns the index instead of a value.


To iterate over elements:
<code>forEach(func)</code> – calls <code>func</code> for every element, does not return anything.


To transform the array:
<code>map(func)</code> – creates a new array from results of calling <code>func</code> for every element.
<code>sort(func)</code> – sorts the array in-place, then returns it.
<code>reverse()</code> – reverses the array in-place, then returns it.
<code>split/join</code> – convert a string to array and back.
<code>reduce(func, initial)</code> – calculate a single value over the array by calling <code>func</code> for each element and passing an intermediate result between the calls.


Additionally:
<code>Array.isArray(arr)</code> checks <code>arr</code> for being an array.

Please note that methods <code>sort</code>, <code>reverse</code> and <code>splice</code> modify the array itself.
These methods are the most used ones, they cover 99% of use cases. 
But there are few others:

arr.some(fn)/arr.every(fn) checks the array.
The function <code>fn</code> is called on each element of the array similar to <code>map</code>. 
If any/all results are <code>true</code>, returns <code>true</code>, otherwise <code>false</code>.


arr.fill(value, start, end) – fills the array with repeating <code>value</code> from index <code>start</code> to <code>end</code>.


arr.copyWithin(target, start, end) – copies its elements from position <code>start</code> till position <code>end</code> into <em>itself</em>, at position <code>target</code> (overwrites existing).

For the full list, see the manual.
From the first sight it may seem that there are so many methods, quite difficult to remember. 
But actually that’s much easier.
Look through the cheat sheet just to be aware of them. 
Then solve the tasks of this chapter to practice, so that you have experience with array methods.
Afterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. 
Examples will help you to write it correctly. 
Soon you’ll automatically remember the methods, without specific efforts from your side.
Write the function <code>camelize(str)</code> that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.
That is: removes all dashes, each word after dash becomes uppercased.
Examples:
<code>camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';</code>

P.S. 
Hint: use <code>split</code> to split the string into an array, transform it and <code>join</code> back.

<code>function camelize(str) {
return str
.split('-') // splits 'my-long-word' into array ['my', 'long', 'word']
.map(
// capitalizes first letters of all array items except the first one
// converts ['my', 'long', 'word'] into ['my', 'Long', 'Word']
(word, index) =&gt; index == 0 ? word : word[0].toUpperCase() + word.slice(1)
)
.join(''); // joins ['my', 'Long', 'Word'] into 'myLongWord'
}</code>

Write a function <code>filterRange(arr, a, b)</code> that gets an array <code>arr</code>, looks for elements between <code>a</code> and <code>b</code> in it and returns an array of them.
The function should not modify the array. 
It should return the new array.
For instance:
<code>let arr = [5, 3, 8, 1];
let filtered = filterRange(arr, 1, 4);
alert( filtered ); // 3,1 (matching values)
alert( arr ); // 5,3,8,1 (not modified)</code>


<code>function filterRange(arr, a, b) {
// added brackets around the expression for better readability
return arr.filter(item =&gt; (a &lt;= item &amp;&amp; item &lt;= b));
}
let arr = [5, 3, 8, 1];
let filtered = filterRange(arr, 1, 4);
alert( filtered ); // 3,1 (matching values)
alert( arr ); // 5,3,8,1 (not modified)</code>

Write a function <code>filterRangeInPlace(arr, a, b)</code> that gets an array <code>arr</code> and removes from it all values except those that are between <code>a</code> and <code>b</code>. 
The test is: <code>a ≤ arr[i] ≤ b</code>.
The function should only modify the array. 
It should not return anything.
For instance:
<code>let arr = [5, 3, 8, 1];
filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4
alert( arr ); // [3, 1]</code>


<code>function filterRangeInPlace(arr, a, b) {
for (let i = 0; i &lt; arr.length; i++) {
let val = arr[i];
// remove if outside of the interval
if (val &lt; a || val &gt; b) {
arr.splice(i, 1);
i--;
}
}
}
let arr = [5, 3, 8, 1];
filterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4
alert( arr ); // [3, 1]</code>

<code>let arr = [5, 2, 1, -10, 8];
// ... 
your code to sort it in decreasing order
alert( arr ); // 8, 5, 2, 1, -10</code>

<code>let arr = [5, 2, 1, -10, 8];
arr.sort((a, b) =&gt; b - a);
alert( arr );</code>

We have an array of strings <code>arr</code>. 
We’d like to have a sorted copy of it, but keep <code>arr</code> unmodified.
Create a function <code>copySorted(arr)</code> that returns such a copy.
<code>let arr = ["HTML", "JavaScript", "CSS"];
let sorted = copySorted(arr);
alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (no changes)</code>


We can use <code>slice()</code> to make a copy and run the sort on it:
<code>function copySorted(arr) {
return arr.slice().sort();
}
let arr = ["HTML", "JavaScript", "CSS"];
let sorted = copySorted(arr);
alert( sorted );
alert( arr );</code>

Create a constructor function <code>Calculator</code> that creates “extendable” calculator objects.
The task consists of two parts.
<ol>

First, implement the method <code>calculate(str)</code> that takes a string like <code>"1 + 2"</code> in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. 
Should understand plus <code>+</code> and minus <code>-</code>.
Usage example:
<code>let calc = new Calculator;
alert( calc.calculate("3 + 7") ); // 10</code>



Then add the method <code>addMethod(name, func)</code> that teaches the calculator a new operation. 
It takes the operator <code>name</code> and the two-argument function <code>func(a,b)</code> that implements it.
For instance, let’s add the multiplication <code>*</code>, division <code>/</code> and power <code>**</code>:
<code>let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) =&gt; a * b);
powerCalc.addMethod("/", (a, b) =&gt; a / b);
powerCalc.addMethod("**", (a, b) =&gt; a ** b);
let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8</code>


</ol>
No parentheses or complex expressions in this task.
The numbers and the operator are delimited with exactly one space.
There may be error handling if you’d like to add it.


All tests and numeric conversions are done in the <code>calculate</code> method. 
In future it may be extended to support more complex expressions.
<code>function Calculator() {
this.methods = {"-": (a, b) =&gt; a - b,
                "+": (a, b) =&gt; a + b};
this.calculate = function(str) {
let split = str.split(' '),
a = +split[0],
op = split[1],
b = +split[2]
if (!this.methods[op] || isNaN(a) || isNaN(b)) {
return NaN;
}
return this.methods[op](a, b);
}
this.addMethod = function(name, func) {
this.methods[name] = func;
};
}</code>

You have an array of <code>user</code> objects, each one has <code>user.name</code>. 
Write the code that converts it into an array of names.
For instance:
<code>let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };
let users = [ john, pete, mary ];
let names = /* ... 
your code */
alert( names ); // John, Pete, Mary</code>

<code>let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };
let users = [ john, pete, mary ];
let names = users.map(item =&gt; item.name);
alert( names ); // John, Pete, Mary</code>

You have an array of <code>user</code> objects, each one has <code>name</code>, <code>surname</code> and <code>id</code>.
Write the code to create another array from it, of objects with <code>id</code> and <code>fullName</code>, where <code>fullName</code> is generated from <code>name</code> and <code>surname</code>.
For instance:
<code>let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };
let users = [ john, pete, mary ];
let usersMapped = /* ... 
your code ... 
*/
/*
usersMapped = [
{ fullName: "John Smith", id: 1 },
{ fullName: "Pete Hunt", id: 2 },
{ fullName: "Mary Key", id: 3 }
]
*/
alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith</code>

So, actually you need to map one array of objects to another. 
Try using <code>=&gt;</code> here. 
There’s a small catch.
<code>let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };
let users = [ john, pete, mary ];
let usersMapped = users.map(user =&gt; ({
fullName: `${user.name} ${user.surname}`,
id: user.id
}));
/*
usersMapped = [
{ fullName: "John Smith", id: 1 },
{ fullName: "Pete Hunt", id: 2 },
{ fullName: "Mary Key", id: 3 }
]
*/
alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith</code>

Please note that in for the arrow functions we need to use additional brackets.
We can’t write like this:
<code>let usersMapped = users.map(user =&gt; {
fullName: `${user.name} ${user.surname}`,
id: user.id
});</code>

As we remember, there are two arrow functions: without body <code>value =&gt; expr</code> and with body <code>value =&gt; {...}</code>.
Here JavaScript would treat <code>{</code> as the start of function body, not the start of the object. 
The workaround is to wrap them in the “normal” brackets:
<code>let usersMapped = users.map(user =&gt; ({
fullName: `${user.name} ${user.surname}`,
id: user.id
}));</code>

Now fine.
Write the function <code>sortByAge(users)</code> that gets an array of objects with the <code>age</code> property and sorts them by <code>age</code>.
For instance:
<code>let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };
let arr = [ pete, john, mary ];
sortByAge(arr);
// now: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete</code>

<code>function sortByAge(arr) {
arr.sort((a, b) =&gt; a.age &gt; b.age ? 1 : -1);
}
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };
let arr = [ pete, john, mary ];
sortByAge(arr);
// now sorted is: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete</code>

Write the function <code>shuffle(array)</code> that shuffles (randomly reorders) elements of the array.
Multiple runs of <code>shuffle</code> may lead to different orders of elements. 
For instance:
<code>let arr = [1, 2, 3];
shuffle(arr);
// arr = [3, 2, 1]
shuffle(arr);
// arr = [2, 1, 3]
shuffle(arr);
// arr = [3, 1, 2]
// ...</code>

All element orders should have an equal probability. 
For instance, <code>[1,2,3]</code> can be reordered as <code>[1,2,3]</code> or <code>[1,3,2]</code> or <code>[3,1,2]</code> etc, with equal probability of each case.

The simple solution could be:
<code>function shuffle(array) {
array.sort(() =&gt; Math.random() - 0.5);
}
let arr = [1, 2, 3];
shuffle(arr);
alert(arr);</code>

That somewhat works, because <code>Math.random() - 0.5</code> is a random number that may be positive or negative, so the sorting function reorders elements randomly.
But because the sorting function is not meant to be used this way, not all permutations have the same probability.
For instance, consider the code below. 
It runs <code>shuffle</code> 1000000 times and counts appearances of all possible results:
<code>function shuffle(array) {
array.sort(() =&gt; Math.random() - 0.5);
}
// counts of appearances for all possible permutations
let count = {
'123': 0,
'132': 0,
'213': 0,
'231': 0,
'321': 0,
'312': 0
};
for (let i = 0; i &lt; 1000000; i++) {
let array = [1, 2, 3];
shuffle(array);
count[array.join('')]++;
}
// show counts of all possible permutations
for (let key in count) {
alert(`${key}: ${count[key]}`);
}</code>

An example result (depends on JS engine):
<code>123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223</code>

We can see the bias clearly: <code>123</code> and <code>213</code> appear much more often than others.
The result of the code may vary between JavaScript engines, but we can already see that the approach is unreliable.
Why it doesn’t work? Generally speaking, <code>sort</code> is a “black box”: we throw an array and a comparison function into it and expect the array to be sorted. 
But due to the utter randomness of the comparison the black box goes mad, and how exactly it goes mad depends on the concrete implementation that differs between engines.
There are other good ways to do the task. 
For instance, there’s a great algorithm called Fisher-Yates shuffle. 
The idea is to walk the array in the reverse order and swap each element with a random one before it:
<code>function shuffle(array) {
for (let i = array.length - 1; i &gt; 0; i--) {
let j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i
// swap elements array[i] and array[j]
// we use "destructuring assignment" syntax to achieve that
// you'll find more details about that syntax in later chapters
// same can be written as:
// let t = array[i]; array[i] = array[j]; array[j] = t
[array[i], array[j]] = [array[j], array[i]];
}
}</code>

Let’s test it the same way:
<code>function shuffle(array) {
for (let i = array.length - 1; i &gt; 0; i--) {
let j = Math.floor(Math.random() * (i + 1));
[array[i], array[j]] = [array[j], array[i]];
}
}
// counts of appearances for all possible permutations
let count = {
'123': 0,
'132': 0,
'213': 0,
'231': 0,
'321': 0,
'312': 0
};
for (let i = 0; i &lt; 1000000; i++) {
let array = [1, 2, 3];
shuffle(array);
count[array.join('')]++;
}
// show counts of all possible permutations
for (let key in count) {
alert(`${key}: ${count[key]}`);
}</code>

The example output:
<code>123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316</code>

Looks good now: all permutations appear with the same probability.
Also, performance-wise the Fisher-Yates algorithm is much better, there’s no “sorting” overhead.
Write the function <code>getAverageAge(users)</code> that gets an array of objects with property <code>age</code> and returns the average age.
The formula for the average is <code>(age1 + age2 + ... 
+ ageN) / N</code>.
For instance:
<code>let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };
let arr = [ john, pete, mary ];
alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28</code>

<code>function getAverageAge(users) {
return users.reduce((prev, user) =&gt; prev + user.age, 0) / users.length;
}
let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };
let arr = [ john, pete, mary ];
alert( getAverageAge(arr) ); // 28</code>

Let <code>arr</code> be an array.
Create a function <code>unique(arr)</code> that should return an array with unique items of <code>arr</code>.
For instance:
<code>function unique(arr) {
/* your code */
}
let strings = ["Hare", "Krishna", "Hare", "Krishna",
"Krishna", "Krishna", "Hare", "Hare", ":-O"
];
alert( unique(strings) ); // Hare, Krishna, :-O</code>



Let’s walk the array items:
For each item we’ll check if the resulting array already has that item.
If it is so, then ignore, otherwise add to results.
<code>function unique(arr) {
let result = [];
for (let str of arr) {
if (!result.includes(str)) {
result.push(str);
}
}
return result;
}
let strings = ["Hare", "Krishna", "Hare", "Krishna",
"Krishna", "Krishna", "Hare", "Hare", ":-O"
];
alert( unique(strings) ); // Hare, Krishna, :-O</code>

The code works, but there’s a potential performance problem in it.
The method <code>result.includes(str)</code> internally walks the array <code>result</code> and compares each element against <code>str</code> to find the match.
So if there are <code>100</code> elements in <code>result</code> and no one matches <code>str</code>, then it will walk the whole <code>result</code> and do exactly <code>100</code> comparisons. 
And if <code>result</code> is large, like <code>10000</code>, then there would be <code>10000</code> comparisons.
That’s not a problem by itself, because JavaScript engines are very fast, so walk <code>10000</code> array is a matter of microseconds.
But we do such test for each element of <code>arr</code>, in the <code>for</code> loop.
So if <code>arr.length</code> is <code>10000</code> we’ll have something like <code>10000*10000</code> = 100 millions of comparisons. 
That’s a lot.
So the solution is only good for small arrays.
Further in the chapter Map and Set we’ll see how to optimize it.

Let’s say we received an array of users in the form <code>{id:..., name:..., age... 
}</code>.
Create a function <code>groupById(arr)</code> that creates an object from it, with <code>id</code> as the key, and array items as values.
For example:
<code>let users = [
{id: 'john', name: "John Smith", age: 20},
{id: 'ann', name: "Ann Smith", age: 24},
{id: 'pete', name: "Pete Peterson", age: 31},
];
let usersById = groupById(users);
/*
// after the call we should have:
usersById = {
john: {id: 'john', name: "John Smith", age: 20}
ann: {id: 'ann', name: "Ann Smith", age: 24},
pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/</code>

Such function is really handy when working with server data.
In this task we assume that <code>id</code> is unique. 
There may be no two array items with the same <code>id</code>.
Please use array <code>.reduce</code> method in the solution.

<code>function groupById(array) {
return array.reduce((obj, value) =&gt; {
obj[value.id] = value;
return obj;
}, {})
}</code>
<br>



<h2 id="arraytopic-1">JavaScript 陣列處理方法</h2>
[filter(), find(), forEach(), map(), every(), some(), reduce()]

// 相同的陣列
var people = [
  { name: 'Casper', like: '鍋燒意麵', age:   },
  { name: 'Wang', like: '炒麵', age:   },
  { name: 'Bobo', like: '蘿蔔泥', age:   },
  { name: '滷蛋', like: '蘿蔔泥', age:   }
];

<h2 id="arraytopic-2">Array.prototype.filter()</h2>
filter() 會回傳一個陣列，其條件是 return 後方為 true 的物件，很適合用在搜尋符合條件的資料。

var filterEmpty = people.filter(function(item, index, array){
});
console.log(filterEmpty);    // 沒有條件，會是一個空陣列

var filterAgeThan5 = people.filter(function(item, index, array){
  return item.age &gt; 5;       // 取得大於五歲的
});
console.log(filterAgeThan5); // Casper, Wang 這兩個物件

var filterDouble = people.filter(function(item, index, array){
  return index % 2 === 1;    // 取得陣列中雙數的物件
});
console.log(filterDouble);   // Wang, 滷蛋 這兩個物件

<h2 id="arraytopic-3">Array.prototype.find()</h2>
find() 與 filter() 很像，但 find() <strong>只會回傳一次值</strong>，且是第一次為 true 的值。

var findEmpty = people.find(function(item, index, array){
});
console.log(findEmpty);  // 沒有條件，會是 undefined

var findAgeThan5 = people.find(function(item, index, array){
  return item.age &gt; 5;   // 取得大於五歲的
});
console.log(findAgeThan5);       // 雖然答案有兩個，但只會回傳 Casper 這一個物件

var findLike = people.find(function(item, index, array){
  return item.like === '蘿蔔泥';  // 取得陣列 like === '蘿蔔泥'
});
console.log(findLike);   // 雖然答案有兩個，但只會回傳第一個 Bobo 物件

<h2 id="arraytopic-4">Array.prototype.forEach()</h2>
forEach 是這幾個陣列函式最單純的一個，不會額外回傳值，只單純執行每個陣列內的物件或值。

var forEachIt = people.forEach(function(item, index, array){
  console.log(item, index, array); // 物件, 索引, 全部陣列
  return item;     // forEach 沒在 return 的，所以這邊寫了也沒用
});
console.log(forEachIt);    // undefined

people.forEach(function(item, index, array){
  item.age = item.age + 1; // forEach 就如同 for，不過寫法更容易
});

console.log(people);       // 全部 age + 
<h2 id="arraytopic-5">Array.prototype.map()</h2>
使用 map() 時他需要回傳一個值，他會透過函式內所回傳的值組合成一個陣列。

如果不回傳則是 <code>undefined</code>
回傳數量等於原始陣列的長度

這很適合將原始的變數運算後重新組合一個新的陣列。

var mapEmpty = people.map(function(item, index, array){
});
console.log(mapEmpty);    // [undefined, undefined, undefined, undefined]

var mapAgeThan5 = people.map(function(item, index, array){
  return item.age &gt; 5;    // 比較大於五歲的
});
console.log(mapAgeThan5); // [true, true, false, false]

var mapAgeThan5_2 = people.map(function(item, index, array){
  // 錯誤示範
  if (item.age &gt; 5) { return item;      // 回傳大於五歲的
  }
  return false;       // 別以為空的或是 false 就不會回傳
});

console.log(mapAgeThan5_2);   // [{name: 'Casper'...}, {name: 'Wang'...}, false, false]

var mapEat = people.map(function(item, index, array){
  if (item.like !== '蘿蔔泥') { return `${item.like} 好吃`;
  } else { return `${item.like} 不好吃`;
  }
});

console.log(mapEat);  // ["鍋燒意麵 好吃", "炒麵 好吃", "蘿蔔泥 不好吃", "蘿蔔泥 不好吃"]

<h2 id="arraytopic-6">Array.prototype.every()</h2>
every() 可以檢查所有的陣列是否符合條件，這僅會回傳一個值 <code>true</code> or <code>false</code>，可以用來檢查陣列中的內容是否符合特定條件。

var array = [
  { name: 'Casper', like: '鍋燒意麵', age:   },
  { name: 'Wang', like: '炒麵', age:   },
  { name: 'Bobo', like: '蘿蔔泥', age:   },
  { name: '滷蛋', like: '蘿蔔泥', age:   }
];

var ans = array.every(function(item, index, array){
  console.log(item, index, array); // 物件, 索引, 全部陣列
  return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true
});
console.log(ans); // false: 只要有部分不符合，則為 false

var ans2 = array.every(function(item, index, array){
  return item.age &lt; });
console.log(ans2); // true: 全部 age 都小於 
<h2 id="arraytopic-7">Array.prototype.some()</h2>
some() 與 every() 非常接近，都是回傳 true or false，差異僅在 every() 需完全符合，some() 僅需要部分符合。

var ans = people.some(function(item, index, array){
  return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true
});
console.log(ans);  // true: 只要有部分符合，則為 true

var ans2 = people.some(function(item, index, array){
  return item.age &lt; });
console.log(ans2); // true: 只要有部分符合，則為 true  

var ans2 = people.some(function(item, index, array){
  return item.age &gt; });
console.log(ans2); // false: 全部都不符合則為 false

<h2 id="arraytopic-8">Array.prototype.reduce()</h2>
reduce() 和其他幾個差異就很大了，他可以與前一個回傳的值再次作運算，參數包含以下：

accumulator: 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值
currentValue: 當前變數
currentIndex: 當前索引
array: 全部陣列

var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array){
});
console.log(reduceEmpty); // 沒有條件，會是 undefined

var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array){
  // 分別為前一個回傳值, 目前值, 當前索引值
  console.log(accumulator, currentValue, currentIndex);
  return accumulator + currentValue.age;  // 與前一個值相加
}, 0);    // 傳入初始化值為 console.log(reducePlus);  // 總和為 
var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array){
  console.log('reduce', accumulator, currentValue, currentIndex)
  return Math.max( accumulator, currentValue.age ); // 與前一個值比較哪個大
}, 0);
console.log(reducePlus);  // 最大值為 

reduce() 的使用方法更為豐富

<h3>其它</h3>預設的陣列行為內的 this 是指向 window <em>(本篇中除了 reduce() 是傳入初始資料)</em>，如果要改，可以在 function 後傳入。

// arr.forEach(function callback(currentValue, index, array) {
// your iterator
// }[, thisArg]);

var ans3 = people.forEach(function(item, index, array){
  console.log(this) // 這邊的 this 就會使用後方傳入的
  return item.age &lt; }, people); // 傳入的物件，替代 this，如果無則是 window

</pre></body></html>
