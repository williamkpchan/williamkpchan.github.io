<base target="_blank"><html><head><title>C Notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="https://williamkpchan.github.io/maincss.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5/jquery.js"></script>
<script src="https://williamkpchan.github.io/lazyload.min.js"></script>
<script src='https://williamkpchan.github.io/mainscript.js'></script>
<script src="https://williamkpchan.github.io/commonfunctions.js"></script>
<script>
  var showTopicNumber = true;
  var topicEnd = "<br>";
  var bookid = "C Notes"
  var markerName = "h2"
</script>
<style>
body{width:80%;margin-left: 10%; font-size:24px;}
h1, h2 {color: gold;}
strong {color: orange;}
img {max-width:90%; display: inline-block; margin-top: 2%;margin-bottom: 1%; border-radius:3px;}
</style></head><body onkeypress="chkKey()"><center>
<h1>C Notes</h1>
<a href="#mustWatch" class="red goldbs" target="_self">Must Watch!</a><br>
<div id="toc"></div></center><br>
<div id="mustWatch"><center><span class="red">MustWatch</span></center>

<a href="c-programming Intro.html" class="bluebut white purpleblackgrad">c-programming Intro</a><a href="learnC.html" class="bluebut white purpleblackgrad">learnC</a><a href="https://www.programiz.com/c-programming/examples" class="whitebut ">examples</a><a href="https://www.programiz.com/c-programming/c-input-output" class="whitebut ">c-input-output</a>
<a href="https://www.youtube.com/watch?v=KJgsSFOSQv0" class="whitebut red whitets whitebs dimbrownback">C Programming Tutorial for Beginners</a>

<a href="Inline Assembly in C.html" class="goldbut redbs whitets">Inline <b>Assembly</b> in C</a>
<a href="Ctutorial.html" class="goldbut red whiteblackgrad">C tutorial</a>

<a href="https://www.geeksforgeeks.org/use-bash-shell-natively-windows-10/" class="whitebut ">How To Use Bash Shell Natively On Windows 10</a>

<a href="https://geekflare.com/best-online-c-compilers/" class="whitebut ">10 Online C Compilers</a>

<a href="https://stackoverflow.com/questions/8250064/fastest-way-to-write-compile-a-c-c-program-in-windows" class="whitebut ">Fastest way to write C/C++ program</a>

<a href="https://www.dummies.com/programming/cpp/10-ways-to-customize-codeblocks/" class="white bordred1 borRad10">10 Ways to Customize Code::Blocks</a>
<a href="C Programming Language.html" class="whitebut ">C Programming Language<br></a>
<a href="cExample.html" class="whitebut ">cExample</a>

<a href="https://itsourcecode.com/free-projects/c-projects/school-billing-system-in-c-with-source-code/" class="whitebut ">School Billing System in C with Source Code</a>

<a href="https://itsourcecode.com/free-projects/c-projects/mini-project-for-phonebook-in-c-with-source-code/" class="whitebut ">Mini Project for Phonebook in C with Source Code</a>

</div>
<pre>
<h2>Compile and Run C program using Sublime Text</h2>

#=================
<a href="https://www.youtube.com/watch?v=SkK7hp_ZVJ0&t=45s">Compile and Run C program using Sublime Text</a>

mingw: http://www.mingw.org/

<a href="http://www.mingw.org/wiki/Getting_Started">MingW Getting_Started</a>
D:\KPC\CodeBlocks\MinGW\libexec\mingw-get\guimain.exe
<a href="https://www.windows-commandline.com/gcc-not-recognized-internal-external-command/">GCC is not recognized as internal or external command</a>

build code:
{
"cmd" : "gcc $file_name -o ${file_base_name} && ${file_base_name}",
"selector" : "source.c",
"shell": true,
"working_dir" : "$file_path"
}

C:\MinGW\bin
C:\MinGW\bin\mingw-get.exe

<h2>sublime text IDE for C</h2>

<a href="http://www.mingw.org/wiki/Getting_Started">MingW Getting_Started</a>
<a href="https://www.windows-commandline.com/gcc-not-recognized-internal-external-command/">GCC is not recognized as internal or external command</a>

D:\KPC\CodeBlocks\MinGW\libexec\mingw-get\guimain.exe

1 download mingw compiler
2 install  mingw compiler
3 run the  mingw manager to install the  mingw base package, and apply the changes
4 then go to set path environment in PC, add the path of mingw
5 goto sublime text, tools->build system->new build system and copy build code:
{
"cmd" : "gcc $file_name -o ${file_base_name} && ${file_base_name}",
"selector" : "source.c",
"shell": true,
"working_dir" : "$file_path"
}

save with any name, 
then write codes and build it
goto tools->build system-> select the newly created
<h2>C call batch file</h2>
C executable and batch file are in same directory then

system("batchfilename.bat arg1 arg2");
where arg1 and arg2 are the arguments for this batch file.

If the batch file is in another directory

system("f:\\bin\\batchfilename.bat arg1 arg2");
where arg1 and arg2 are the arguments for this batch file.

C code:

#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{

#include &lt;stdio.h>
 
int main () {
   for( ; ; ) {
    system("killtask.bat");
   }
}

<h2><span class="orange">Features of C language</span></h2>
The C programming language is a <b>feature-rich</b> programming language. 
It has all the required features that a developer (beginner or expert) would want a programming language to have.
Here is a simple chart to list the <b>main features of the C language</b>.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631529119-1.png" src="LAZY_IMG_PLACEHOLDER">
Let's talk about all these features one by one.
<h2>&emsp;Simple and Efficient</h2>
The C Language is a simple language that is easy to learn even for a beginner and is super efficient to use both in terms of the time of development and time of execution.
Yes, if you want to create software using C language you can do so in quite less time depending upon the size of the software that you want to code.
The learning curve for C language is less.
The scope of C language is also less so you won't get confused like in Python which has many popular libraries (you keep thinking about which one to learn).
<h2>&emsp;Portability</h2>
C Language program runs the same way everywhere. 
It means if you have written a simple <a href="https://www.studytonight.com/c/programs/" target="_blank">C program</a> like a <a href="https://www.studytonight.com/c/programs/numbers/sum-of-n-numbers" target="_blank">program to find sum of N numbers in C</a>, on your Windows operating system and then compiled it and run it, you can then take the compiled code and run it on any other operating system or machine, like, Linux or macOS, etc., your C program will always return the same result.
If you have a software written in the C language for Unix OS, and you now want to run it on Windows OS, you can <b>easily adapt the software</b> (with <em>some modifications or no modifications at all</em>) for Windows OS, and that is the power of the C language.
Hence, we can say that the C language is portable.
<h2>&emsp;Structured Programming language</h2>
C language is a structured programming language because we can <a href="https://www.studytonight.com/c/user-defined-functions-in-c.php" target="_blank">create functions in the C language</a>.
Using functions we can separate a particular operation from the main program and then use it again and again.
A structured language is not just about having the ability to create functions, but it supports <b>loops</b>, <b>conditional statements</b>, etc.
<h2>&emsp;Powerful</h2>
It has a broad range of features like support for many <b>data types, operators, keywords, etc.</b>, that allows the structuring of code using <b>functions</b>, <b>loops</b>, <b>decision-making statements</b>, etc.
Then there are complex data structures like <b>structures</b>, <b>arrays</b>, etc., and <b>pointers</b>, which makes C quite resourceful.
Using the C language you can <b>easily read, write and create files</b>.
<h2>&emsp;Rich Standard Library</h2>
C supports various inbuilt functions and libraries that create development fast.
The <b>standard library support</b> for the C language is superb and you will see that a lot of keywords or ready-made operations that you will use while writing code in C language are already pre-defined.
You just have to use them, without worrying about how they work.
These libraries are called <b>Header files</b> in C language.
<h2>&emsp;Multithreaded</h2>
C language supports multi-threading, which means multiple code processes can run in parallel.
This feature was introduced in <b>C11</b>.
A new header file <b>threads.h</b> was added for multithreading support.
Another header file <b>subatomic.h</b> for supporting atomic operations.
<h2>&emsp;Libraries Support</h2>
There is not just the standard library for C language but also a <b>large ecosystem of 3rd party libraries</b>, which are created by developers/coders around the world, and anyone can use them.
Even you can write your own C language library and distribute it online through your GitHub profile. 
You never know, people around the world might need your solution.
<h2>&emsp;Separate Compilation</h2>
C language code is compiled and then it is run. 
You will learn <a href="https://www.studytonight.com/c/compile-and-run-c-program.php" target="_blank">how the C language code is compiled</a> in another tutorial.
For now, just assume that the code is compiled. 
Obviously, the compilation of code will take some time.
A small piece of code will compile faster while a large code will take time to get compiled.
In C language you can <b>break your code and put it in multiple source code files</b>. 
C language will compile the files separately and then link them together for execution. 
This makes <b>compilation fast</b>.
Another plus point of this is, <b>multiple programmers/developers</b> can work on different code files while working on a single project.
<h2>&emsp;Middle-Level Language</h2>
The C programming language brings together the best of both worlds.
A low-level language is generally fast, and powerful but hard to understand and write code in.
Whereas a <b>High-level Language</b> is easy for us to understand and write code in, it is also highly portable, but it is generally slow and is unable to directly talk to the system hardware.
The C programming language is said to be a <b>Middle-level</b> programming language, as it allows manipulation of bits, bytes, and addresses, hence providing low-level access to the computer systems, while being easy to use, portable, and supporting all other features of a High-level language, etc.
<h2>&emsp;10. 
Synt&emsp;ax-based Language</h2>
There are <b>proper rules for writing the code</b>, and the C language strictly follows them.
If you write anything that is not allowed, you will get a compile-time error, which happens when the compiler is unable to compile your code because of some incorrect code syntax.
<h2>&emsp;11. 
Form&emsp;at Free Language</h2>
The C language is a format-free language.
There are no line numbers needed in the C language code, or we can say that the line number holds no significance.
There is no need to place statements on a specified location on a line.
<h2>&emsp;12. 
Comp&emsp;iled Language</h2>
The C language uses a Compiler to compile the code into <b>object code</b>, which is nothing but <b>machine code</b> that the computer understands. 
Hence to run a C language program we have to install a C language compiler first.
<h2>&emsp;13. 
Case&emsp;-sensitive Language</h2>
In C, the uppercase and lowercase characters are different. 
That means <k>if</k> is not the same as <k>IF</k> in C language.
<h2>&emsp;Frequently Asked Questions(FAQ)</h2>
Here are some frequently asked questions, that beginners have when they learn about features of the C language.
<h4>What are the main features of the C language?</h4>
The main features of the C language are, it is <b>simple(easy to learn) yet powerful</b>, <b>Portable</b>, <b>Mid-level language</b>, which is <b>structured</b> and needs a <b>Compiler</b> for execution. 
The C language also has a <b>rich standard library</b> with the support of <b>extensive 3rd party libraries</b>.
<h4>What is the main reason behind the popularity of the C language?</h4>
The main reason behind the popularity of the C language is that it has a rich feature set, making it a suitable language for a wide range of use cases. 
You can create an operating system using C language or any other simple software. 
The C language is a general-purpose programming language.
<h4>Why is C considered a Powerful Programming Language?</h4>
It is considered a powerful language because it provides a broad range of features like support for many <b>data types, operators, keywords, etc.</b>, allows structuring of code using <b>functions</b>, <b>loops</b>, <b>decision-making statements</b>, then there are complex data-structures like <b>structures</b>, <b>arrays</b>, etc., and <b>pointers</b>, which makes C quite resourceful and powerful, etc.
<h4>Is C language Portable?</h4>
Yes, the C language code is <b>portable</b>. 
If you have software written in the C language for Unix OS, and you now want to run it on Windows OS, you can easily adapt the software for Windows OS, and that is the power of the C language.
<h4>What are the advantages of C Language?</h4>
Given below are some of the advantages of the C language:
a) C is a Portable language.
b) It provides rich support of built-in functions.
c) It is a powerful and efficient language.
d) C language is a structured language, with features of both High-level language and Low-level language.
<h2><span class="orange">Introduction - C Programming Language</span></h2>
C programming language was developed by <b>Dennis Ritchie at AT & T's Bell Laboratories</b> in 1972.
In 1989, the C language was standardized, where C language features were defined, as the <b>1989 ANSI standard</b> for C, hence it is also called <b>C89</b>, because of the 1989 ANSI standard.
The <em>current latest version</em> of the C language is <b>C17</b>, which was released in June 2018. 
No new features were added to this version only a few basic corrections were made and some bugs in the C11 version were fixed.
A new standard revision of C programming language is expected in 2023 which will be called <b>C23</b> or <b>C2x</b>. 

There are two types of programming languages:
<b>High-level</b> language which is problem oriented
<b>Low-level</b> language which is machine oriented
C Language is a <b>middle-level</b> programming language that has features of both low-level programming language and high-level programming languages.
C language <b>compiler</b> converts the readable C language code into machine instructions.
<h2>&emsp;Versions of C Language</h2>
Following are the different versions of the C programming language released till now:
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;"><tbody>
<tr><td><b>C language Version</b></td><td><b>Year</b></td></tr>
<tr><td>C89</td><td>1989</td></tr>
<tr><td>C99</td><td>1999</td></tr>
<tr><td>C11 or C1x</td><td>2011</td></tr>
<tr><td>C17</td><td>2018</td></tr>
<tr><td>C23 or C2x</td><td>2023</td></tr></tbody></table>
<img class="lazy" data-src="https://s3.studytonight.com/curious/uploads/pictures/1685527251-.png">
<h2>&emsp;Latest Version of C</h2>
The current version of the C language is <b>C17</b>, which was <b>introduced in 2018</b>. 
It is supported by all the standard C language compilers, but many compilers still do not support this.
Featurewise C17 is the same as the previous C version <b>C11</b>.
The <b>most widely used version</b> of the C language is still <b>C89</b>, <b>C99</b>, and <b>C11</b>.
The <b>C23</b> version is expected to launch in <b>2023</b>.
<h2>&emsp;Why is C Language so popular?</h2>
C language is a good language to introduce yourself to the programming world, because it is simple, easy to learn, and covers all the basic concepts of programming.
The scope of C language is limited, so it is good for beginners to start programming.
Initially, C language can be used for writing <b>system-level programs</b>, like designing Operating Systems, OS kernels, etc.
C language can be used to develop simple software, like <b>Text Editors, Compilers, Network Drivers</b>, and many traditional PoS(Point of Sale) software like <b>Restaurant Billing systems</b>, etc.
Some popular applications build using C language are <b>Adobe Photoshop</b>, <b>MySQL Database</b>, <b>Chromium browser</b>, etc.
If you are in college, you can clear college placement interviews by learning C language, and get a job in good service-based companies like TCS, Infosys, IBM, Accenture, etc.

<h2>&emsp;Features of C Language</h2>
The following are the features of the C programming language:
It has an easy-to-learn and <b>simple</b> syntax.
It is highly <b>portable</b>. 
You can write your code on your machine, compile it and run it anywhere.
C is a structured programming language. 
You can write code in C language using functions, to give your program proper structure.
There are many libraries and header files available in C language and the community for C language is very large.
It is a compiled language.
It is case-sensitive.

Here are all the <a href="https://www.studytonight.com/c/features-of-c.php" target="_blank">features of C language</a> listed in detail.
<h2>&emsp;Hello World Program in C</h2>
Here is a simple Hello World program in C programming:
<k>#include &lt;stdio.h>
int main() {
printf("Hello, World!");
return 0;
}</k>

Hello, World!
The basic program structure for C programs is:
<k>preprocessor directives
macros
global declarations
int main() {
    program logic
}</k>
<h2>&emsp;Write Code in C and execute it</h2>
You can write C code in any editor, or you can use <b>Turbo C/C++</b> which is an IDE for C language.
The programs are stored in files with <b>.c</b> extension.
C compiler is used to compile the C code and generate the <b>object code</b> which is stored in <b>.o</b> extension file.
The object code is then run to get the output.
C language is <b>case-sensitive</b>, so you have to be careful while writing code.
Every line of code in a C program must end with a semicolon (<k>;</k>). 
If you miss the semicolon, then the compiler will give an error.
If you write anything incorrect while writing a C program, the C compiler will give an error and stop the program execution.

To understand how C programs are compiled, read this - <b><a href="https://www.studytonight.com/c/c-compilation-process.php" target="_blank">C program compilation</a></b>
<h2>&emsp;Keywords in C</h2>
Keywords are words that have special meanings, stored in the standard installation of C programming language and the C compiler knows what is the meaning of all these keywords.
C programming has <b>32 keywords</b>.
<k>auto        double      int         struct 
break       else        long        switch 
case        enum        register    typedef 
char        extern      return      union 
const       float       short       unsigned 
continue    for         signed      void 
default     goto        sizeof      volatile 
do          if          static      while</k>
<h2>&emsp;Datatypes and Variables</h2>
C language has 5 default datatypes. 
They are,
<k>int</k>
<k>char</k>
<k>long</k>
<k>float</k>
<k>double</k>
A datatype defines the type of data, values allowed, and what operations can be performed on that data.
A variable is used to store data in it. 
You can create a variable of any datatype in C language. 
Once defined the variable can only store the value of that datatype.

Here is a simple C program where we have created a variable and assigned it a value,
<k>#include &lt;stdio.h>
int main() {
    // variable of integer datatype
int x;
    x = 77;
return 0;
}</k>
Learn more about data types and variables - <b><a href="https://www.studytonight.com/c/datatype-in-c.php">Datatypes in C</a></b> and <b><a href="https://www.studytonight.com/c/variables-in-c.php">Variables in C</a></b>.
<h2>&emsp;Print anything on the console</h2>
To print anything on the console or to give output from a C program you can use the <k>printf()</k> function.
The <k>printf</k> function is defined in the <b>stdio.h</b> header file.
So to use the <k>printf</k> function, you have to include the <b>stdio.h</b> header file in your C program.
You can provide any text message to the <k>printf</k> function to print it on the console.

Here is a simple code example,
<k>#include &lt;stdio.h>
int main() {
printf("Welcome to Studytonight");
return 0;
}</k>
To learn more about <k>printf</k> function, check this out: <b><a href="https://www.studytonight.com/c/c-input-output-function.php">C Input & Output</a></b>
<h2>&emsp;Take user input from keyboard</h2>
To take user input in the C program you can use the <k>scanf()</k> function. 
The <k>scanf</k> function is also defined in the <b>stdio.h</b> header file.
You can use <k>scanf</k> function to take input of a specific type of value.
For example, if you have to take an integer value input, then:
You need a variable of type integer to store the input value in.
You will have to specify a placeholder to inform the <k>scanf</k> function which type of value it should expect.
If you provide a value of some other type, the C compiler will give an error.

<b>Placeholders</b> are special characters for different datatype values to inform the C compiler, which type of value to expect.
<k>%d</k> for <em>integer</em> type
<k>%c</k> for <em>character</em> type
<k>%d</k> for <em>double</em>, etc.
Here is a code example,
<k>#include &lt;stdio.h>
int main() {
    int x;
scanf("%d", &amp;x);
return 0;
}</k>
The <k>&amp;</k> operator is used to get the memory address of the variable to store the input value in it.
To learn more about <k>scanf</k> function, check this out: <b><a href="https://www.studytonight.com/c/c-input-output-function.php">C Input & Output</a></b>
<h2>&emsp;C Programs to start practice</h2>
Here are some simple programs that will help you practice writing code in the C programming language:
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;"><tbody>
<tr><td><a href="https://www.studytonight.com/c/programs/basic/hello-world">Hello World program in C</a></td></tr>
<tr><td><a href="https://www.studytonight.com/c/programs/basic/ascii-value-of-character">ASCII value of characters</a></td></tr>
<tr><td><a href="https://www.studytonight.com/c/programs/basic/different-data-type-input">Program to take user input in C</a></td></tr>
</tbody></table>Here are more <a href="https://www.studytonight.com/c/programs/">C programs</a> for you to practice.
<h2>&emsp;Frequently Asked Questions (FAQ)</h2>
Here are some frequently asked questions, that beginners have when they start learning the C language.
<h4>What is the C language?</h4>
It is a computer programming language developed in the early 1970s by Ken Thompson and Dennis Ritchie at Bell Laboratories.
It is a programming language that was developed to do system programming for the operating system UNIX, but later it was used for developing software and programs for daily usage. 
It is still being used to develop operating systems and for creating system-level programs, by big tech companies (FAANG companies).
<h4>What are the features of the C language?</h4>
C is one of the most popular programming languages. 
It has many features:
<b>Modularity:</b> It allows the reusability of modules. 
It has header files with readymade functions that you can use.
<b>Middle-Level language:</b> It combines both the advantages of low-level and high-level languages. 
(<a href="https://www.studytonight.com/c/arrays-in-c.php">C arrays</a>, <a href="https://www.studytonight.com/c/pointers-in-c.php">C Pointers</a>, etc.)
<b>General-purpose programming language:</b> It can be used to implement any kind of application, just like Python. 
(<b><a href="https://www.studytonight.com/python/" target="_blank">Learn Python</a></b>)
<b>Portability: </b> C program can be compiled or executed in any operating system (Unix, DOS, Windows). 
You can compile the program in Windows and then run it on a Unix machine, it will run without any issue.
<b>Powerful programming language:</b> It is a very efficient and powerful programming language. 
It is best used for <a href="https://www.studytonight.com/data-structures/">data structures</a> and designing system software.
<b>C is a case-sensitive language</b>.

C programming language is <b>structured programming language</b>, that <b>needs a compiler</b> for compiling the code into object code (.o extension) which can be executed easily.
We have listed down all the features of the C language in the next tutorial - <a href="https://www.studytonight.com/c/features-of-c.php" target="_blank">Features of C Language</a>
<h4>What is the C language used for?</h4>
It is one of the most portable languages and is mainly used for creating system applications that form a major part of Windows, UNIX, and Linux operating systems.
C is a <b>general-purpose</b> programming language. 
It is used for coding simple software, enterprise applications, games, graphics, and applications requiring calculations, simple software, etc.<b> </b>
<h4>Where is C used today?</h4>
C is used for developing operating systems and Kernel-level programs.
It is used for the production of Compilers. 
We can develop desktop as well as mobile phone operating systems with the help of C, for example, Android.
<h4>Who created C language and Why?</h4>
C language has evolved from three different structured languages <b>ALGOL, BCPL, and B Language</b>. 
It uses many concepts from these languages while introducing many new concepts such as <a href="https://www.studytonight.com/c/datatype-in-c.php">datatypes</a>, <a href="https://www.studytonight.com/c/structures-in-c.php">struct</a>, <a href="https://www.studytonight.com/c/pointers-in-c.php">pointers</a>, etc.
<b>BCPL</b> was developed by <b>Martin Richards</b>, based on which the <b>B language</b> was created by <b>Ken Thompson</b>. 
And then the B language was the language using which the C language was created.
In 1989, the language was formalized by <b>American National Standard Institute</b>(ANSI).
In 1990, a version of the C language was approved by the <b>International Standard Organisation</b>(ISO), and that version of C is also referred to as <b>C89</b>.

After the C language was accepted worldwide and programmers around the world started using it, soon, to improve C language further, the work on the development of C++ language started.
The <b>idea behind</b> creating C language was to create an <b>easy language</b> that requires a <b>simple compiler</b> (to translate the code from English to binary (0's and 1's that computer understands)) and to enable programmers to <b>write complex programs</b> in a language that is close to English because earlier programmers had to write Machine instructions which were very difficult to remember.
<hr>The most popular IDE for C language for beginners is Turbo C/C++. 
In this tutorial, we will cover the installation steps for Turbo C and will also share a few other IDE(integrated development environment) that you can use for C programming.
<h2>&emsp;What is an IDE?</h2>
An IDE or <b>Integrated Development environment</b> is a software, which has a code editor, along with the compiler of the programming language too, hence you do not need to install anything else.
An IDE has all the required features to manage your source code, like File handling, Edit options, etc. 
while it also has the support for different programming language environments too, for which it has in-built compilers/interpreters installed.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631950708-1.png" src="LAZY_IMG_PLACEHOLDER">
Many IDEs allow installing 3rd party plugins to further enhance the features of the IDE.
<b>Turbo C</b> is an IDE used for writing code in the C language. 
And you can also, compile and run your code using Turbo C itself. 
<b>Turbo C++ is the upgraded version</b> of Turbo C, which can also be used for C language programming.
The C++ compiler supports the C language syntax as the C++ language is built on top of the C language.
There are other IDEs too that you can use for C programming, like:

Dev-C++ (Download from here: <a href="https://sourceforge.net/projects/orwelldevcpp/">Download Dev-C++</a>)Eclipse (<a href="https://www.eclipse.org/downloads/">Download Eclipse IDE</a>)If you are a beginner, we recommend using Turbo C or Turbo C++.
<h2>&emsp;Installing Turbo C/C++ for Windows 7/8/10</h2>
Let's see how we can install Turbo C for writing C programs.
<h2>&emsp;Step 1. 
Star&emsp;t by downloading the IDE installer</h2>
You can download the Zip file from this link: <a href="https://developerinsider.co/download-turbo-c-for-windows-7-8-8-1-and-windows-10-32-64-bit-full-screen/">Download Turbo C</a>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631946551-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
<h2>&emsp;Step 2. 
Unzi&emsp;p the file to see the Installer file</h2>
Next use WinRar or any other software to see what is there in the zip file you downloaded.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631946652-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
<h2>&emsp;Step 3. 
Star&emsp;t the Installation</h2>
If you are a Windows OS user, click on the <b>.msi</b> file for starting the installation.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631946754-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
You will see the InstallShield Wizard for Turbo C/C++, click on the <b>Next</b> button.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631946831-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
And the installation should start. 
Now sit back and wait for the installation to get complete.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631946893-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
Once the installation is complete, you will see the following window, check on the <b>Launch the program</b> checkbox(if not already checked) and you click on the <b>Finish</b> to start the Turbo C/C++ IDE, to start writing the C language code.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631947043-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
<h2>&emsp;Step 4. 
Star&emsp;t Turbo C/C++ IDE</h2>
To start the IDE, you can either <b>create a shortcut on your desktop</b> to easily start the IDE every time. 
Or open the <b>Start</b> menu, and <b>search for Turbo C</b> and you will the application there.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631947434-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
Click on the <b>Turbo C++ app option</b> and you will see the following Window. 
Then click on the <b>Start Turbo C++</b> button to launch the IDE application.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631947470-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
And this is how it will look. 
<b>Bluuueee!</b>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631947506-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
<h2>&emsp;Other IDEs for C Programming</h2>
You can use the <b>Dev-C++</b> IDE or the <b>Eclipse IDE</b> for C programming. 
We have shared the download link for both in the introduction of IDE.
If you want a more modern C/C++ IDE for writing C programs then you should try Dev-C++ as it is not as complex as the Eclipse IDE, while has many features which the basic Turbo C/C++ IDE lacks.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631947535-1.png" src="LAZY_IMG_PLACEHOLDER" style="width: 700px;">
<h2>&emsp;Conclusion:</h2>
In this tutorial, we learned what is an IDE or Integrated development environment, which IDEs can be used for C programming and how to install the most popular C language IDE which is Turbo C/C++ step by step.
<h2><span class="orange">First C Program and its Structure</span></h2>
Let's start with a <b>simple</b> and <b>basic Hello World program</b> in C language.
To create a "<em>Hello World!</em>" program in C language, you have to use the <k>printf</k> function.
<k>#include &lt;stdio.h>
int main()
{
    printf("Hello World");
    return 0;
}</k>

Hello, World
<a href="https://www.studytonight.com/code/playground/c/?id=kB7XiP" target="_blank">Run Code ยกรบ</a>
To run the above code on your local machine, you will have to install a C language compiler on your Computer/Laptop. 
If you need help, here is a step-by-step guide - <a href="https://www.studytonight.com/c/compile-and-run-c-program.php" target="_blank">Compile and Run C Code</a>.
If you do not want to install the C compiler on your computer, don't worry. 
You can use our <a href="https://www.studytonight.com/code/playground/c/"><b>Online C Compiler</b></a> to run C programs and Practice. 
Click on the <b>Run Code button</b> above to open the compiler.
<h2>&emsp;Understanding the Structure of C Program</h2>
Given below are some of the different parts of a C Program:
Pre-processor
Header file
main() <a href="https://www.studytonight.com/c/user-defined-functions-in-c.php">function</a>
<a href="https://www.studytonight.com/c/variables-in-c.php">Variables in C</a>
<a href="https://www.studytonight.com/c/decision-making-in-c.php">Statements & expressions in C</a>
All these are essential parts of a C language program. 
Don't worry about all this, we will learn about everything one by one and will clear all your confusion.
Let's start with a basic introduction to various code statements that we used in the above Hello World program.
<h2>&emsp;Pre-processor</h2>
The <k>#include</k> is the first statement of any C program. 
It is known as a <b>pre-processor</b>.
The task of a pre-processor is to initialize the environment of the program, i.e. 
to link the program with the header files required.
As its name suggests, this line of code is <b>responsible for doing pre-processing</b>, before the actual code (logic) is executed.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631609728-1.png" src="LAZY_IMG_PLACEHOLDER">
So, when we say <k>#include&lt;stdio.h></k>, it is to inform the compiler to include the <b>stdio.h</b> header file which is the <b>standard I/O library</b> into the program before executing the program.
The <b>standard I/O library</b> lets you read input from the keyboard(i.e. 
standard in) and then write the output to the console screen (i.e. 
standard out).
By <b>Console screen</b>, we mean <b>CMD</b> or command prompt in the case of Windows OS and <b>Terminal</b> in case you use Linux/Ubuntu/macOS.
We can include any number of header files in a C program.
The <k>#include</k> is not the only pre-processor. 
Whenever you see any piece of code starting with a <k>#</k> symbol, that means it's a pre-processor in the C language.
<h2>&emsp;Header file</h2>
A <b>Header file</b> is a set or <b>collection of built-in(readymade) functions</b>, that we can directly use in our program.
Header files contain <b>definitions of the functions </b>which can be used in any C program
To use a header file you must import it into your program by using pre-processor <k>#include</k> statement along with the name of the header file.
There are some standard header files that come along with default C installation, like <b>stdio.h</b> header file.
All header files will have <b>.h</b> extension.
With time, you will have a clear picture of what header files are, as of now consider them as a readymade collection of functions that comes packaged with the C language.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631609771-1.png" src="LAZY_IMG_PLACEHOLDER">
To use any of the standard library functions, the appropriate header file must be included. 
This is done at the beginning of the C source code.
For example, to use the <k>printf()</k> function in a C program, which is used to <b>display anything</b> on the console screen, the line <k>#include &lt;stdio.h></k> is required, because the header file <b>stdio.h</b> contains the <k>printf()</k> function definition.
<h2>&emsp;The <k>main()</k> Function</h2>
The <k>main()</k> function is a function that <b>must be there in every C program</b>.
Everything inside this function in a C program will be executed, hence the actual logic or the code is always written inside the <k>main()</k> function.
As the name suggests, this is the main(<em>of prime importance or center of attraction</em>) function.
Let's see a code example,
<k>#include &lt;stdio.h>
int main()
{
    printf("Hello World");
    return 0;
}</k>
In the Hello World code example above, there was <k>int</k> written before the <k>main()</k> function, remember? Well, that is the <b>return type</b> of the <k>main()</k> function.
The curly braces <k>{ }</k> just after the <k>main()</k> function encloses the <b>body</b> of the <k>main()</k> function.
<h2>&emsp;The <k>printf()</k> Function</h2>
The <k>printf()</k> is a function that is used to print(show) anything on the console as output.
This function is defined in the <b>stdio.h</b> header file, which we have included in our C program.
<h2>&emsp;Return Statement</h2>
A <k>return</k> statement is used to return a response to the caller function.
It is generally the last statement of any C language function.
<h2>&emsp;Semicolon</h2>
It is important to note that every statement in C should end with a <b>semicolon</b>(<k>;</k>).
If you miss adding any semicolon, the compiler will give an error.
Semicolon (<k>;</k>) is called the statement terminator in C programming.
<h2>&emsp;How to write a C program on my Computer?</h2>
All the C programs can be written and edited in normal text editors like <b>Notepad</b> or <b>Notepad++</b> and must be saved with a file name and <b>.c</b> extension.
For example, <b>helloworld.c</b> can be the file name for the Hello World program.
If you do not add the extension <b>.c</b> then the compiler will not recognize it as a C language program file.
<h2>&emsp;Frequently Asked Questions (FAQ)</h2>
Here are some frequently asked questions, that beginners have when they learn how to write Hello world program in C programming.
<h4>Name different preprocessors in C programming Language?</h4>
Different preprocessors in the C language are <k>#include</k>, <k>#if</k>, <k>#define</k>, <k>#ifdef</k>, <k>#undef</k>, etc. 
and many more. 
A pre-processor is a statement that is executed before the main code for the C program is executed.
<h4>What do you understand by the main() function in C language?</h4>
The <k>main()</k> function in the C language acts as the entry point of any program or we can say that the execution of the code starts from here. 
The source code which is inside the <k>main()</k> function gets executed.
<h4>How comments can be added to a C program?</h4>
In order to add the single line comment, you can use slash <k><b>//</b></k> followed by the comment and for multiline comments, you can use the following:<b> /* comment here */</b>.
<h4>What is stdio.h in C program?</h4>
The <b>stdio</b> stands for <b>standard input and output</b> and <b>.h</b> is the extension of the file indicating that it is a <b>header file</b>.
The main use of this header file is, that it helps to get the input from the user(Keyboard) and return the output result text to the monitor(screen). 
There are readymade functions in this header file that we can use in our program, for example, <k>printf()</k> and <k>scanf()</k> functions are defined in the <b>stdio.h</b> header file.
<h2><span class="orange">Compile and Run C Program</span></h2>
To compile and run a <a href="https://www.studytonight.com/c/first-c-program.php" target="_blank">C language program</a>, you need a C compiler. 
A <b>compiler</b> is software that is used to compile and execute programs. 
To set up a C language compiler on your Computer/laptop, there are two ways:
Download a full-fledged IDE like Turbo C++ or Microsoft Visual C++ or DevC++, which comes along with a C language compiler.
Or, you can use any text editor to edit the program files and download the C compiler separately and then run the C program using the command line.
If you haven't already installed an IDE for the C language - Follow this step-by-step guide to <b><a href="https://www.studytonight.com/c/installing-c-language-compiler-and-ide.php">Install Turbo C++ for C Language</a></b>
<h2>&emsp;Using an IDE - Turbo C</h2>
We will recommend you to use <b>Turbo C or Turbo C++</b> IDE, which is the oldest IDE for C programming. 
It is freely available over the Internet and is good for a beginner.
<b>Step 1:</b> Open turbo C IDE(Integrated Development Environment), click on <b>File,</b> and then click on <b>New</b>
<img class="lazy" data-src="https://www.studytonight.com/c/images/first-c-program-step1.jpg" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
<b>Step 2:</b> Write a Hello World program that we created in the previous article - <b><a href="http://www.studytonight.com/c/first-c-program.php">C Hello World program</a></b>.
<img class="lazy" data-src="https://www.studytonight.com/c/images/first-c-program-step2.jpg" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
<b>Step 3:</b> Click on <b>Compile</b> menu and then on <b>Compile</b> option, or press the keys and press <b>Alt + F9</b> to compile the code.
<img class="lazy" data-src="https://www.studytonight.com/c/images/first-c-program-step3.jpg" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
<b>Step 4:</b> Click on <b>Run</b> or press <b>Ctrl + F9 </b>to run the code. 
Yes, C programs are first compiled to generate the object code and then that object code is Run.
<img class="lazy" data-src="https://www.studytonight.com/c/images/first-c-program-step4.jpg" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
<b>Step 5:</b> Output is here.
<img class="lazy" data-src="https://www.studytonight.com/c/images/first-c-program-step5.jpg" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
<h2>&emsp;Run C Program Without using any IDE</h2>
If you do not wish to set up an IDE and prefer the old-school way, then download the C compiler which is called <k>gcc</k> from the GCC website <a href="https://gcc.gnu.org/install/" target="_blank">https://gcc.gnu.org/install/</a>
Once you have downloaded and installed the <k>gcc</k> compiler, all you have to do is, <b>open any text editor</b>, copy and paste the C program code for <a href="https://www.studytonight.com/c/first-c-program.php" target="_blank">C Hello World Program</a>, and save it with the name the <b>helloworld.c</b> like any other file you save with a name.
Now, Open the <b>Command prompt or Terminal</b>(if you use Ubuntu or Mac OS), and go to the directory where you have saved the <b>helloworld.c</b> program file.
Type the command <k>gcc hello.c</k> to compile the code. 
This will compile the code, and if there are no errors then it will produce an output file with name <b>a.out</b>(default name)
Now, to run the program, type in <k>./a.out</k> and you will see <b>Hello, World</b> displayed on your screen.
<k>$ gcc hello.c
$ ./a.out</k>
Hello, World
<h2>&emsp;Difference between Compile and Run in C?</h2>
You must be thinking about why it is a 2 step process, first, we compile the code and then we run the code. 
We did the same thing with Turbo C and the same is with the command line or Terminal too.
Well, the <b>compilation</b> is the process where the compiler checks whether the <b>program is correct syntax-wise</b> and whether there are no errors in the syntax, and if the code is fine converts the C language source code into machine-understandable object code.
When we <b>run a compiled program</b>, it is just the already compiled code that is run.
This difference is clear when we run a C program using the command line.
When you compile the code, a <b>.out</b> file is generated, which is then <b>Run</b> to execute the program.
Once a <b>.out</b> file is generated, and then you make any <b>changes to your program</b> in the source code file, you will have to <b>again compile the code</b>, otherwise, the <b>.out file will have the old source code</b> and will keep running the old program itself.
<h2>&emsp;Frequently Asked Questions(FAQ)</h2>
Here are some frequently asked questions, that beginners have when they learn how to write Hello world program in C programming.
<h4>What do you understand by the process of compilation?</h4>
It is a process where the compiler checks whether the program is syntactically correct or not. 
If there is any mistake found in the syntax then it will throw the errors. 
The error thrown at the time of compilation is called a <b>Compile-time error</b>.
<h4>Name the keys used in Turbo C to compile the code.</h4>
<b>ALT + F9</b> is used in turbo C in order to compile the code.
<h4>How is a C program run?</h4>
During the compilation and execution of the C program, the compiler generates output files with the same name as that of the <b>C program</b> file but with different extensions.
The <b>.c</b> extension file is called the source file that keeps the code of the <b>program</b>. 
Now, when we compile the file, then the <b>C</b> compiler looks for errors.
<h4>Where can I write and run the C program?</h4>
You can use an IDE to write and run the C program by following these steps:
Step 1: Open turbo <b>C</b> IDE(Integrated Development Environment), click on <b>File,</b> and then click on <b>New</b>.
Step 2: <b>Write</b> the C program code.
Step 3: Click on <b>Compile</b> or press <b>Alt + F9</b> to <b>compile</b> the code.
Step 4: Click on <b>Run</b> or press <b>Ctrl + F9</b> to <b>run</b> the code.
Step 5: And turbo C will open the console to show you the output of the program.
<h2><span class="orange">What happens when C code is compiled?</span></h2>
The C source code compilation process is a <b>multi-step process</b>, which involves the following steps: 
<b>pre-processing</b>,
<b>compiling of code</b>,
<b>linking of libraries</b>.
In this tutorial, we will learn how the C code is compiled into object code.
The process of converting the source code written in any <b>programming language</b>(generally, mid-level or high-level language) into <b>machine-level language</b> that is understandable by the computer is known as <b>Compilation</b>. 
The software that is used for this conversion is known as a <b>Compiler</b>.
In C language, through compilation, the C language <b>source code</b> is converted into <b>object code</b>.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1631951897-1.png" src="LAZY_IMG_PLACEHOLDER">
The compiler takes the<b> input</b> which is the <b>source code</b> and provides the <b>output</b> in the form of<b> object code</b>. 
The complete process of compilation in the C language is further divided into four phases:
<b>Pre-processing</b>,
<b>Compiling</b>,
<b>Assembling</b>, and
<b>Linking</b>
The compiler checks the source code for any <b>syntax</b> or <b>structural errors</b> and after checking, if the source code is found error-free, it then generates the object code that has an extension <b>.obj</b> (for Windows) or <b>.o</b> (for Linux).
Let us now take a look at the different stages of the compilation process in the C language.
<h2>&emsp;Compilation Process</h2>
As mentioned above, the different stages of the compilation process are as follows:
Pre-processing
Compiling
Assembling
Linking
In the flow chart below we have explained how the compilation process work and what are the different stages of compiling the C language source code.
<img class="lazy" data-src="https://s3.ap-south-1.amazonaws.com/s3.studytonight.com/tutorials/uploads/pictures/1621501647-71449.png">
Let's discuss all these stages of the C language source code compilation in the order they are performed.
<h2>&emsp;Step 0: Pre-processing of the source file</h2>
In this phase, pre-processing of the source file is done. 
The <b>Pre-processor</b> is a program that accepts the C source code file and then it performs the following tasks:
It will remove the comments from the source code.
It will perform the <b>Macro expansion</b> if any Macro is used (Do not worry about Macros, we will learn about them later)
It will perform the expansion of the included header files.
<h2>&emsp;Step 1: Preprocessor</h2>
It is a program that processes the source program before passing them on to the compiler. 
At this step the pre-processors used in any C program are handled and the source code is made ready for compilation.
Each preprocessing statement must start with<b> </b><k>#</k>, where<b> <k>#</k> </b>is called the <b>preprocessor directive</b>.
Each preprocessing directive is a single-line code statement.
The word after <k>#</k> is called the <b>preprocessor command</b>.
Some of the preprocessor directives are as follows:
<h4>#include</h4>
To include a particular header using the name of the header file into the C language program code.
<h4>#define</h4>
This is used to define a MACRO in the C language.
<h4>#error</h4>
This preprocessor command is used to print the error message.
Just like the above three, there are many other preprocessors, we will cover them in detail in a separate tutorial.
Hence, the preprocessor expands the source code(adds the required information) and then this expanded source code is passed on to the compiler.
It gives the (<b>.i</b>) extension to the <b>source code file</b> which is initially with (<b>.c</b>) extension.
<h2>&emsp;Step 2: Compiler</h2>
The expanded code by the preprocessor is then passed on to the compiler.
A compiler is a program that converts the <b>high-level language</b>(or <b>mid-level language</b>) code to the <b>assembly code</b>, which is then converted into the machine code, which the machine can understand.
Therefore the preprocessed code given by the preprocessor to the compiler is then converted into assembly code by the compiler, which is then passed on to the <b>Assembler</b>.
The source file which got the (<b>.i</b>) extension in the previous step gets converted into (<b>.s</b>) extension by the compiler.
<h2>&emsp;Step 3: Assembler</h2>
The assembler converts the assembly code that it gets from the compiler into the <b>object code</b>.
The extension of the file in this step becomes (<b>.obj</b>).
Don't think that Assembler is a separate program generating the object code. 
The Assembler is part of the compilation process of the C language source code.
When in layman language, we say, the C code is compiled, it means the complete compilation process, covering all these steps, is done.
<h2>&emsp;Step 4: Linker</h2>
A linker is a tool that is used to <b>link all the parts of a program together</b> in order of execution.
The code after this stage becomes <b>Executable Machine code</b>.
There might be some situations when our program refers to the functions that are defined in some other files. 
Or, if the code for some program is too big, we can break it into two files, which will be compiled separately and then linked using the Linker.
In the C language compilation process, the Linker plays a very important role.
If your C program includes a <b>header file</b>, and you are using some function defined in that header file, then the Linker will <b>link the required object code</b> for the function in the library, to the <b>object code of your program</b> and package them together.
Similarly, if your program code is too big and you break it into two files, then both the source code files will be converted into object code separately and then the Linker will link them and make the code ready for execution. 
This is also called <b>Separate Compilation</b>.
<h2>&emsp;Frequently Asked Questions</h2>
Here are some frequently asked questions related to the C language compilation process.
<h4>Q1. 
What do you understand by the term Compiler?</h4>
It is a computer program that is used to translate the source code that is in a high-level programming language or a mid-level programming language into machine code, which can be executed and the machine can understand what to do.
<h4>Q2. 
What is a preprocessor?</h4>
The preprocessor is a directive used to instruct the compiler to preprocess the source code before the start of the actual compilation. 
There are some parts of the C language program that can be specified using the preprocessor, which is nothing but statements to be executed at the beginning of compilation.
<h4>Q3. 
What is the other name of the .c file?</h4>
The C language code files which have extension <b>.c</b> are also called the <b>source code file</b>.
<h4>Q4. 
What is the role of Linker?</h4>
The linker is used to link all the parts of the program together in order for the execution.
If your C program includes a <b>header file</b>, and you are using some function defined in that header file, then the Linker will <b>link the required object code</b> for the function in the library, to the <b>object code of your program</b> and package them together.
Similarly, if your program code is too big and you break it into two files, then both the source code files will be converted into object code separately and then the Linker will link them and make the code ready for execution. 
This is also called <b>Separate Compilation</b>.
<h4>Q5. 
What are the steps of compilation in the C Language?</h4>
Following are the steps of compilation in the C language:
Preprocessor (preprocessing)
Compiler (compiling)
Assembler (assembly)
Linker (linking)
<h2><span class="orange">C Language Basic Syntax Rules</span></h2>
The C programming syntax specifies the rules for writing the code in the C language. 
In simple words, these rules inform how to form code statements in a C program:
How should the line of code start,
how it should end,
where to use double quotes,
where to use curly brackets,
where to use parenthesis, etc.
<h2>&emsp;What is Syntax?</h2>
Any language, be it English or Hindi, or Spanish, has a <b>grammar</b>.
The grammar defines the <b>rules for using the language</b>, for example <em>how to form a sentence</em>, what different <em>words mean</em>, etc.
In a normal spoken language or a computer programming language, syntax means how to arrange words, characters, special characters, to make a meaningful statement, or expression, etc.
If you don't follow the rules properly then your code will give error.
<h4>What is Syntax error?</h4>
If someone says there is a <b>syntax error</b> in the program, that means you have not written the program correctly.
You might have missed some semicolon or some other general mistake in typing the code for the program.
Having a <b>syntax error</b> doesn't mean your code's logic is incorrect, it means you have written it incorrectly.
Once the <b>syntax is correct</b>, then only the <b>code is compiled and then run</b>.
<h2>&emsp;The C Tokens</h2>
The smallest individual unit in the C program is known as <b>C Token</b>.
Tokens are either <b><a href="https://www.studytonight.com/c/keywords-and-identifier.php" target="_blank">keywords or identifiers</a></b>, <b>constants</b>, <b><a href="https://www.studytonight.com/c/variables-in-c.php" target="_blank">variables</a></b>, or any other symbol which has some meaning in C language.
The C program can also be called a<b> collection of various tokens</b>.
Hence the syntax for C language defines how to use these tokens together while writing the C language code.
Let's take an example,
<k>#include &lt;stdio.h>
int main()
{
    printf("Hello,World");
    return 0;
}</k>
In the above code, if we take the <k>printf</k> statement:
<k>printf("Hello,World");</k>
Then the tokens in this statement are:
<k>printf</k>,
<k>(</k>,
<k>"Hello,World"</k>,
<k>)</k>
and <k>;</k>
So the C <b>tokens</b> are basically the <b>building blocks of a C program</b>.
The picture below shows token in the entire Hello World Program:
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632221462-1.png" src="LAZY_IMG_PLACEHOLDER">
Now let's see some important syntax rules, which you must remember always while writing code in the C language.
<h2>&emsp;Statement ends with Semicolon (<k>;</k>)</h2>
A semicolon <b><k>;</k></b> is used to mark the end of a statement and the beginning of another statement in the C language.
The absence of a semicolon at the end of any statement will mislead the compiler to think that this statement is not yet finished.
And it will add the next consecutive statement after it, which may lead to a <b>compilation(syntax) error</b>.
Here is an example of code with a missing semicolon,
<k>#include &lt;stdio.h>
int main()
{
    printf("Hello,World")
    return 0;
}</k>

error: expected ';' before 'return'
return 0;
^
command terminated with exit code 1
In the above program, we dont' have the semicolon after the <k>printf("...")</k> statement, hence the compiler will think that starting from <k>printf</k> up untill the semicolon after <k>return 0</k> is a single statement and this will lead to compilation error.
<h2>&emsp;Adding Comments to Code</h2>
Comments are plain simple text in a C program that is not compiled in the compilation process.
We can write comments in a program, to explain various parts of the program.
Although writing comments is not compulsory, but it is recommended to make your program more descriptive, and easier for others to understand.
Adding comments makes the code more readable.
There are <b>two ways</b> in which we can write comments.
Using <b><k>//</k></b>: This is used to write a<b> single-line comment</b>.

Using <b><k>/* */</k></b>: Anything enclosed within <k>/*</k> and <k>*/</k> , will treated as<b> multi-line comments</b>.

You can use both these two techniques in one program.
<h2>&emsp;Example of comments in C language:</h2>
Here is a simple program to show how to use comments:
<k>/* 
    This is my first program.
    I am very excited!
*/
#include &lt;stdio.h>
int main()
{
    // Printing Hello World
    printf("Hello,World");
    // printf("Useless piece of code.");
    return 0;
}</k>
As you can see in the above code, we have added comments, and have also, commented a <k>printf()</k> statement, which will not get executed.
<h2>&emsp;More Syntax rules for the C Language</h2>
This is just the beginning, as we will learn more concepts in the C language, we will learn the syntax for using all of them along with examples.
Everything has a way of writing and use when it comes to writing code, and that way is its syntax.
C is a <b>case-sensitive language</b> so all C instructions must be written in lower case letters. 
<b>main</b> is not the same as <b>MAIN</b>.
All C statements must end with a <b>semicolon</b>.
<b>Whitespace</b> is used in C to add blank space and tabs.
You do not have to worry about the indentation of the code.
When we write a function, its body is enclosed in <b>curly braces</b>, like for the <k>main()</k> function. 
We will learn this in detail when we cover functions.
The picture below shows you the structure of the C program.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632223822-1.png" src="LAZY_IMG_PLACEHOLDER">
<h2>&emsp;Frequently Asked Questions (FAQ)</h2>
Here are some frequently asked questions related to the C language syntax.
<h4>Q1. 
What do you understand by tokens in C language?</h4>
The smallest individual unit in the C program is known as <b>C Token</b>. 
Tokens are either <b><a href="https://www.studytonight.com/c/keywords-and-identifier.php" target="_blank">keywords or identifiers</a></b>, <b>constants</b>, <b><a href="https://www.studytonight.com/c/variables-in-c.php" target="_blank">variables</a></b>, or any other symbol which has some meaning in C language. 
The C program can also be called a<b> collection of various tokens</b>.
<h4>Q2. 
What will happen if we forgot to use a semicolon at the end of the statement in C?</h4>
If we forgot to put the <b>semicolon at the end</b> of any <b>statement</b> in the C language then it will lead to a syntax error. 
In that case, an error message is issued by the compiler that<b> a semicolon is expected</b>.
<h4>Q3. 
What is a Compilation Error?</h4>
A compilation error, or compile-time error, is the error returned by the compiler if the syntax of the C program is incorrect. 
When you try to compile a program with some syntax mistake, then the compiler will give an error, which is called a <b>Compile-time error</b>.
<h4>Q4. 
How to add comments in C?</h4>
We can add single-line comments using the <k>//</k> at the starting of the comment text, and multi-line comment by enclosing the text within <k>/*</k> and <k>*/</k> in the C program.
<h4>Q5. 
Can a program run without the <k>main()</k> function in C?</h4>
In the C language, the <k>main()</k> function defines the starting point of execution. 
If a C program doesn't have a <k>main()</k> function then no code statement will be executed in that program. 
In most cases the compiler gives an error, if it cannot find the <k>main()</k> function.
<h2><span class="orange">C Keywords and Identifiers</span></h2>
Keywords and Identifiers are the building blocks of any program in C programming.
<b>Keywords are reserved words</b>, that have some special meaning in C programming.
<b>Identifiers are names</b>, given to variables, functions, pointers, etc. 
in a program.
There are 32 keywords in the C programming language.
Keywords cannot be used as Identifiers in C programming.
<h2>&emsp;C Keywords</h2>
In C programming language there are some reserved words that are used internally and have some special purpose and meaning, such words are called <b>Keywords</b> or just <b>Reserved Keywords</b>.
The meaning and purpose of the keywords cannot be changed.
Each Keyword is unique.
There are only 32 keywords in C programming.
You cannot use keywords as name for variables, functions, pointers, etc. 
because if you do so, the compiler will get confused and give you an error.
In the last tutorial, where we learned <b><a href="https://www.studytonight.com/c/c-syntax.php">C language syntax</a></b>, we learned that everything in the C program is a <b>Token</b>.
Yes, <b>Keywords are also tokens</b>.
<h2>&emsp;Code Example</h2>
Let's see a simple C program in which keywords are used,
<k>int main() {
    int num = 7;
    char ch = 'Z';
    float pi = 3.14;
    return 0;
}
</k>
In the above code example, <k>int</k>, <k>char</k>, <k>float</k>, and <k>return</k> are keywords.
<h2>&emsp;Common Keywords</h2>
Some of the most commonly used and seen keywords in C programs are:
<k>int</k> - represents integer datatype
<k>char</k> - represents character datatype
<k>float</k> - represents floating-point value datatype
<k>return</k> - Used to return a result from a function
<k>if</k> and <k>else</k> - Used in conditional statements
<k>for</k>, <k>while</k>, and <k>do-while</k> - Used to implement Loops
<k>void</k>, etc
<h2>&emsp;All C Keywords</h2>
Here are all the C keywords:
<k>auto        double      int         struct 
break       else        long        switch 
case        enum        register    typedef 
char        extern      return      union 
const       float       short       unsigned 
continue    for         signed      void 
default     goto        sizeof      volatile 
do          if          static      while</k>
All these keywords were defined in the C89 standard, which was the <a href="https://www.studytonight.com/c/overview-of-c.php">first version of the C language</a>, while some <b>more keywords</b> were <b>added in the later C99</b> standard.
The keywords added by C99 are:
<k>_Bool    _Imaginary   restrict
_Complexinline
</k>
<h2>&emsp;Important Points to Note:</h2>
Here are some useful points to remember about Keywords.
A keyword can not be used as an Identifier (<em>remember this always</em>).
Keywords must be written in lowercase. 
Apart from some <b>C99</b> keywords, all other keywords are in lowercase.
Keywords hold special meaning for the C compiler, so respect that, otherwise you will get a compile-time error.
<k>main</k> is not a keyword, but you should treat it as a keyword only. 
Because this function is a special function. 
If you name any variable as main, you may confuse the Compiler.
<h2>&emsp;C Identifiers</h2>
Identifiers are names used for variables, functions, structures, pointers, etc. 
in a program.
Identifiers are not-predefined. 
You define them. 
The names you give to the variables, functions, etc. 
in C programs are identifiers.
Just like you have a name, similarly in C programming, when we <a href="http://www.studytonight.com/c/variables-in-c.php">define a variable</a> or a <a href="https://www.studytonight.com/c/user-defined-functions-in-c.php">function</a>, or a <a href="https://www.studytonight.com/c/structures-in-c.php">structure</a>, etc. 
we name them so that it becomes easier for us to identify them and use them whenever required. 
These names are called <b>Identifiers</b>.
<b>Identifiers are also tokens</b>. 
Again, because every meaningful symbol, word, etc. 
in the C language are C Tokens.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632476876-1.png" src="LAZY_LOAD">
<h2>&emsp;Code Example</h2>
Here is a code example in which we have used some identifiers:
<k>int main() {
    int count = 25;
    float price = 78.5;
    return 0;
}
</k>
In the above code example, <b>count</b> and <b>price</b> are identifiers.
<h2>&emsp;Rules for defining an Identifier:</h2>
An identifier can only have <b>alphanumeric characters</b>(a-z , A-Z , 0-9) and <b>underscore</b>(<k>_</k>).
The <b>first character</b> of an identifier can only contain <b>alphabet</b>(a-z, A-Z) or <b>underscore</b> (<k>_</k>).
Identifiers are case-sensitive in the C language. 
For example, <b>name</b> and <b>Name</b> will be treated as two different identifiers.
Keywords are not allowed to be used as Identifiers.
<b>No special characters</b>, such as a <b>semicolon</b>, <b>period</b>, <b>whitespaces</b>, <b>slash</b>, or <b>comma</b> are permitted to be used in or as an Identifier.
<h2>&emsp;Naming Conventions for Identifiers</h2>
You can follow the above rules and use any name, but here are some conventions that C programmers follow:
You should use meaningful names, instead of single-character names.
For multi-word names, you can use an underscore, like <b>product_code</b>.
You should use lowercase characters only.
<h2>&emsp;Using Identifiers and Keywords:</h2>
Let's see a few examples where we'll use keywords and identifiers. 
We will <a href="https://www.studytonight.com/c/variables-in-c.php">define a C variable</a> and name it using an identifier.
When we declare a variable or any function in any C language program, to use it we must provide a name to it, that name is then used throughout the program, for example:
<k>int myvariable = "Studytonight";</k>
Here <k>myvariable</k> is the name or <b>identifier</b> for the variable which stores the value "<b>Studytonight</b>" in it. 
And <k>int</k> is the keyword.
Let's have another example,
<k>int money;
double salary;</k>
<h2>&emsp;Example of Valid Identifiers:</h2>
Here are some valid identifiers,
<k>total, avg1, difference_1;</k>
<h2>&emsp;Example of Invalid Identifiers:</h2>
Here are some invalid identifiers,
<k>$myvar; // incorrect
x!y;  // again incorrect</k>
<h2>&emsp;Using Keywords as Identifiers</h2>
What happens when we use keywords as identifiers?
<k>#include &lt;stdio.h>
int main() {
   // using void as name of variable (identifier)
   int void = 0;
   return 0;
}</k>

error: two or more data types in declaration specifiers
int void = 0;
^
<a href="https://www.studytonight.com/code/playground/c/?id=R9EMul" target="_blank">Run Code ยกรบ</a>
The C language compiler will think that we have mistakenly used two data types together and will give an error. 
Because <k>void</k> is also a <a href="https://www.studytonight.com/c/datatype-in-c.php">data type in the C language</a>(hence it is a keyword).
<h2>&emsp;Frequently Asked Questions</h2>
Here are some frequently asked questions related to keywords and identifiers.
<h4>Q1. 
What is the difference between Identifier and Variable?</h4>
The <b>identifier is just the name</b> given to the variable, while a variable represents a <b>memory field</b> where some data is stored based on its data type. 
It's just like what is the difference between you and your name? Your name is just a word that people use to call you, while you are a human being.
<h4>Q2. 
Are Identifiers case-sensitive?</h4>
Yes, identifiers are case-sensitive. 
Everything in C programming is case-sensitive. 
<b>Age</b> and <b>age</b> are considered as different identifiers.
<h4>Q3. 
Can I use special characters in Identifiers?</h4>
You can only use an underscore <k>_</k> special character in identifiers. 
You cannot use other special characters like <k>#</k>, <k>$</k>, <k>%</k>, <k>&amp;</k>, etc.
Q4. 
Can I use a number at the start of an Identifier?
No, you cannot use a number as the first character in an identifier. 
You can only use an alphabet or an underscore <k>_</k> symbol.

<h2><span class="orange">Data Types in C Language</span></h2>
As the name suggests, a Datatype defines the <b>type of data</b> being used.
Whenever we <a href="http://www.studytonight.com/c/variables-in-c.php">define a variable</a> or use any data in the C programming, we have to specify the <b>type of the data</b>, so that the compiler knows what type of data to expect.
For example, you may want to use a <b>number</b> like <b>1</b>, <b>2</b>, <b>100</b>, or a <b>decimal points</b> number like <b>99.95</b>, <b>10.5</b>, or a <b>text</b>, like <b>"Studytonight"</b>, all these values are <b>handled differently by the C compiler</b>, hence, we use data types to define the type of data used in any program.
Each data type occupies some memory.
Each datatype has its own valid range of values.
There are a set of operations that are allowed for every datatype.
For code examples, check out <a href="https://www.studytonight.com/c/using-datatypes-examples.php">using C Datatypes</a> tutorial.
<h2>&emsp;Data Types in C</h2>
Broadly, there are 5 different categories of data types in the C language, they are:
<table cellpadding="10" style="width:100%;">
<thead><tr><th scope="col">Type</th>
<th scope="col">Example</th></tr></thead>
<tbody>
<tr><td>Basic</td><td>character, integer, floating-point, double.</td></tr>
<tr><td>Derived</td><td>Array, structure, union, etc.</td></tr>
<tr><td>Enumeration</td><td>enums</td></tr>
<tr><td>Bool type</td><td>true or false</td></tr>
<tr><td>void</td><td>Empty value</td></tr>
</tbody>
</table>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632837224-1.png" src="LAZY_IMG_PLACEHOLDER">
<h2>&emsp;Primary Data Types in C Programming</h2>
The C language has 5 basic (primary or primitive) data types, they are:
<h2>&emsp;Character (<k>char</k>):</h2>
We use the keyword <k>char</k> for the character data type.
It is used to store single-bit characters and occupies <b>1 byte</b> of memory.
You can store alphabets from <b>A-Z</b>(and <b>a-z</b>) and <b>0-9</b> digits using <k>char</k> datatype. 
For example,
 
<k>
char b = 'A'; 
char c = '0';
char d = 0; // ERROR
</k>
For <k>char</k> datatype, it is necessary to enclose the data within <b>single quotes</b>.
You can perform <b>addition</b> and <b>subtraction</b> operations on <k>char</k> datatype values.
The ASCII value of a <k>char</k> datatype value should not exceed <b>127</b>.
<h3 &emsp;dir="ltr" role="presentation">Integer (<k>int</k>):</h2>
We use the keyword <k>int</k> for the integer data type.
The <k>int</k> data type is used to store non-fractional numbers which include positive, negative, and zero values.
The range of <k>int</k> is <b>-2,147,483,648 to 2,147,483,647</b> and it occupies 2 or 4 bytes of memory, depending on the system youยกยฏre using. 
For example,
 
<k>int a = 5550; 
int b = -90, 
int c = 0; 
int d = -0.5; //invalid</k>
We can perform <em>addition</em>, <em>subtraction</em>, <em>division</em>, <em>multiplication</em>, <em>bitwise</em>, and <em>modulo</em> operations on <k>int</k> data type.
<h3 &emsp;dir="ltr" role="presentation">Floating-point (<k>float</k>):</h2>
We use the keyword <k>float</k> for a floating-point data type.
The keyword <k>float</k> is used to store <b>decimal numbers</b>.
It occupies 4 bytes of memory and ranges from <b>1e-37 to 1e+37</b>.
For example,
<k>float a = 0.05; 
float b = -0.005.
float c = 1;  // it will become c = 1.000000 because of type-casting</k>
We can perform addition, subtraction, division, and multiplication operations on <k>float</k> data type.
 
<h3 &emsp;dir="ltr" role="presentation">Double (<k>double</k>):</h2>
 We use the keyword <k>double</k> for the double data type.
The double datatype is used to store <b>decimal numbers</b>.
It occupies <b>8 bytes</b> of memory and ranges from <b>1e-37 to 1e+37</b>.
Here is how we use it in code,
 
<k>double a = 10.09;
double b = -67.9;</k>
The <k>double</k> datatype has more precision than <k>float</k> so <k>double</k> gives more accurate results as compared to <k>float</k>.
We can perform addition, subtraction, division, and multiplication operations on <k>double</k> data type.
<h3 &emsp;dir="ltr" role="presentation">Void (<k>void</k>):</h2>
 This means no value.
This data type is mostly used when we define functions.
The <k>void</k> datatype is used when a function does not return any result.
It occupies <b>0 bytes</b> of memory.
We use the <k>void</k> keyword for void data type.
Here is how we use the <k>void</k> type with functions,
<k>void function() {
   //your code goes here
}</k>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632837298-1.png" src="LAZY_IMG_PLACEHOLDER">
Each data type has a size defined in <b>bits/bytes</b> and has a <b>range</b> for the values that these datatypes can hold.
<h2>&emsp;Size of different Datatypes in C</h2>
The size of different data types depends on the compiler and processor types.
In short, it depends on the Computer on which you are running the C language and the version of the C compiler that you have installed.
<h2>&emsp;char is 1 byte</h2>
The <k>char</k> datatype is <b>1 byte</b> in size or <b>8 bits</b>.
This is mostly the same and is not affected by the processor or the compiler used.
<h2>&emsp;int can be 2 bytes/4 bytes</h2>
There is a very easy way to remember the size of <k>int</k> datatype.
The size of <k>int</k> datatype is usually equal to the word length of the execution environment of the program.
In simpler words, for a <b>16-bit environment</b>, <k>int</k> is <b>16 bits</b> or <b>2 bytes</b>, and for a <b>32-bit environment</b>, <k>int</k> is <b>32 bits</b> or <b>4 bytes</b>.
<h2>&emsp;float is 4 bytes</h2>
The <k>float</k> datatype is <b>4 bytes</b> or <b>32 bits</b> in size.
It is a <b>single-precision data type</b> that is used to hold decimal values.
It is used for storing large values.
<k>float</k> is a faster data type compared to <k>double</k>, because <k>double</k> data type works with very large values, hence it is slow.
<h2>&emsp;double is 8 bytes</h2>
The <k>double</k> datatype is <b>8 bytes</b> or <b>64 bits</b> in size.
It can store values that are <b>double the size of what a float data type can store</b>, hence it is called <k>double</k>.
In the 64 bits, <b>1 bit</b> is for <b>sign</b> representation, <b>11 bits</b> for the <b>exponent</b>, and the rest <b>52 bits</b> are used for the <b>mantissa</b>.
The <k>double</k> data type can hold approximately <b>15 to 17 digits</b>, before the decimal and after the decimal.
<h2>&emsp;void is 0 bytes</h2>
The <k>void</k> datatype means nothing, hence it doesn't have a size.
<table border="1" cellpadding="20" cellspacing="1" style="width:100%;"><tbody><tr><td style="text-align: center;"><b>Good Read: <a href="https://www.studytonight.com/post/understanding-what-are-bits-and-bytes-and-the-difference-between-them">Understand what are Bits and Bytes</a></b></td></tr></tbody></table>
Before moving on to the range of values for these data types, there is one more important concept to learn, which is <b>Datatype modifiers</b>.
<h2>&emsp;C Data type Modifiers:</h2>
There are <b>4 datatype modifiers</b> in C programming that are used along with the basic data types to categorize them further.
For example, if you say, there is a playground, it can be a park, a playground, or a stadium, but if you say, there is a Cricket ground or a Football stadium, that would make it even more precise.
Similarly, there are modifiers in the C language, to <b>make the primary data types more specific</b>.
The following are the modifiers:
signed
unsigned
long
short
As the name suggests,
<b>signed</b> and <b>unsigned</b> are used to represent the <b>signed(+ and -)</b> and <b>unsigned(only +) values</b> for any data type.
And <b>long</b> and <b>short</b> affects the <b>range of the values</b> for any datatype.
For example, <b>signed int</b>, <b>unsigned int</b>, <b>short int</b>, <b>long int</b>, etc. 
are all valid data types in the C language.
<k>long long num = 123456789987654321; // we cannot store a value this big value using int data type.</k>
Now let's see the range for different data types formed as a result of the 5 primary data types along with the modifiers specified above.
<h2>&emsp;C Data type Value Range</h2>
In the table below we have the range for different data types in the C language.
<table cellpadding="10" style="width:100%;">
<thead><tr><th scope="col">Type</th>
<th scope="col">Typical Size in Bits</th>
<th scope="col">Minimal Range</th>
<th scope="col">Format Specifier</th></tr></thead>
<tbody>
<tr><td><k>char</k></td><td>8</td><td>-127 to 127</td><td><k>%c</k></td></tr>
<tr><td>
<k>unsigned</k> <k>char</k>
</td><td>8</td><td>0 to 255</td><td><k>%c</k></td></tr>
<tr><td>
<k>signed</k> <k>char</k>
</td><td>8</td><td>-127 to 127</td><td><k>%c</k></td></tr>
<tr><td><k>int</k></td><td>16 or 32</td><td>-32,767 to 32,767</td><td>
<k>%d</k>, <k>%i</k>
</td></tr>
<tr><td>
<k>unsigned</k> <k>int</k>
</td><td>16 or 32</td><td>0 to 65,535</td><td><k>%u</k></td></tr>
<tr><td>
<k>signed</k> <k>int</k>
</td><td>16 or 32</td><td>Same as int</td><td>
<k>%d</k>, <k>%i</k>
</td></tr>
<tr><td>
<k>short</k> <k>int</k>
</td><td>16</td><td>-32,767 to 32,767</td><td><k>%hd</k></td></tr>
<tr><td>
<k>unsigned</k> <k>short</k> <k>int</k>
</td><td>16</td><td>0 to 65,535</td><td><k>%hu</k></td></tr>
<tr><td>
<k>signed</k> <k>short</k> <k>int</k>
</td><td>16</td><td>Same as short int</td><td><k>%hd</k></td></tr>
<tr><td>
<k>long</k> <k>int</k>
</td><td>32</td><td>-2,147,483,647 to 2,147,483,647</td><td>
<k>%ld</k>, <k>%li</k>
</td></tr>
<tr><td>
<k>long</k> <k>long</k> <k>int</k>
</td><td>64</td><td>-(2<sup>63</sup> - 1) to 2<sup>63</sup> - 1 (Added by C99 standard)</td><td>
<k>%lld</k>, <k>%lli</k>
</td></tr>
<tr><td>
<k>signed</k> <k>long</k> <k>int</k>
</td><td>32</td><td>Same as long int</td><td>
<k>%ld</k>, <k>%li</k>
</td></tr>
<tr><td>
<k>unsigned</k> <k>long</k> <k>int</k>
</td><td>32</td><td>0 to 4,294,967,295</td><td><k>%lu</k></td></tr>
<tr><td>
<k>unsigned</k> <k>long</k> <k>long</k> <k>int</k>
</td><td>64</td><td>2<sup>64</sup> - 1 (Added by C99 standard)</td><td><k>%llu</k></td></tr>
<tr><td><k>float</k></td><td>32</td><td>1E-37 to 1E+37 with six digits of precision</td><td><k>%f</k></td></tr>
<tr><td><k>double</k></td><td>64</td><td>1E-37 to 1E+37 with ten digits of precision</td><td><k>%lf</k></td></tr>
<tr><td>
<k>long</k> <k>double</k>
</td><td>80</td><td>1E-37 to 1E+37 with ten digits of precision</td><td><k>%Lf</k></td></tr>
</tbody>
</table>
As you can see in the table above, with different combinations of the datatype and modifiers the range of value changes.
When we want to <b>print the value for any variable</b> with any datatype, we have to use a <b>format specifier</b> in the <k>printf()</k> statement.
<h2>&emsp;What happens if the value is out of Range?</h2>
Well, if you try to assign a value to any datatype which is more than the allowed range of value, then the C language compiler will give an error. 
Here is a simple code example to show this,
<k>#include &lt;stdio.h>
int main() {
   // allowed value up to 65535
   unsigned short int x = 65536;
  
   return 0;
}</k>

warning: large integer implicitly truncated to unsigned type [-Woverflow]
unsigned short int x = 65536;
^
<a href="https://www.studytonight.com/code/playground/c/?id=1UZFrt" target="_blank">Run Code ยกรบ</a>
When a <b>type modifier is used without any data type</b>, then the <k>int</k> data type is set as the default data type. 
So, <k>unsigned</k> means <k>unsigned</k> <k>int</k>, <k>signed</k> means <k>signed</k> <k>int</k>, <k>long</k> means <k>long</k> <k>int</k>, and <k>short</k> means <k>short</k> <k>int</k>.
<h2>&emsp;What does <k>signed</k> and <k>unsigned</k> means?</h2>
This is a little tricky to explain, but let's try.
In simple words, the <k>unsigned</k> modifier means <b>all positive values</b>, while the <k>signed</k> modifier means <b>both positive and negative values</b>.
When the compiler gets a numeric value, it converts that value into a binary number, which means a combination of 0 and 1. 
For example, <b>32767</b> in binary is <b>01111111 11111111</b>, <b>1</b> in binary is<b> 01 (or 0001)</b>, <b>2</b> is <b>0010</b>, and so on.
In the case of a <b>signed integer</b>, the <b>highest order bit</b> or the first digit from left (in binary) is used as the <b>sign flag</b>.
If the <b>sign flag is 0</b>, the number is <b>positive</b>, and if it is <b>1</b>, the number is <b>negative</b>.
And because one bit is used for showing if the number is positive or negative, hence there is one less bit to represent the number itself, hence the range is less.
For <b>signed int</b>, <b>11111111 11111111 means -32,767,</b> and because the first bit is a <b>sign flag</b> to mark it as a negative number, and the rest represents the number.
Whereas in the case of <b>unsigned int</b>, <b>11111111 11111111</b> means <b>65,535</b>.
<h2>&emsp;Derived Data types in C</h2>
While there are 5 primary data types, there are some derived data types too in the C language which are used to store complex data.
Derived data types are nothing but primary data types but a little twisted or grouped together like an <b><a href="https://www.studytonight.com/c/arrays-in-c.php" target="_blank">array</a></b>, <b><a href="https://www.studytonight.com/c/structures-in-c.php" target="_blank">structure</a></b>, <b><a href="https://www.studytonight.com/c/unions-in-c.php" target="_blank">union</a>,</b> and <b><a href="https://www.studytonight.com/c/pointers-in-c.php" target="_blank">pointers</a></b>.
<h2><span class="orange">Using C Datatypes (with Examples)</span></h2>
The Datatype defines the <b>type of data</b> being used. 
We have covered <b><a href="https://www.studytonight.com/c/datatype-in-c.php">C datatypes</a></b> in detail in the previous tutorial.
The C language has 5 basic (primary or primitive) data types, they are:
<b>Character</b> - <k>char</k>
<b>Integer</b> - <k>int</k>
<b>Floating-point</b> - <k>float</k>
<b>Double</b> - <k>double</k>
<b>Void</b> - <k>void</k>
Let's learn about each one of them one by one.
To learn about the <b>size of data types</b>, <b>range of values</b> for datatypes, and various <b>type modifiers</b> like <k>signed</k>, <k>unsigned</k>, <k>long</k>, and <k>short</k> - Visit <b><a href="http://www.studytonight.com/c/datatype-in-c.php">C datatypes in detail</a></b>
<h2>&emsp;<k>char</k> Datatype</h2>
The <k>char</k> datatype refers to character values, enclosed in single quotes,
The range of value for character datatype is from <b>-127 to 127</b>.
As it's clear from the range, we can even use <b>small integer values</b> in the <k>char</k> datatype.
For example,
<k>char status = 'Y';</k>
<h2>&emsp;int Datatype</h2>
The <k>int</k> datatype is used to store whole numbers.
Whole numbers are values without any decimal part or exponent part.
The <k>int</k> datatype can store <b>decimal</b> (base 10), <b>octal</b> (base 8), and <b>hexadecimal</b> (base 16) values.
<k>// simple int value
int a = 100;
// negative value
a = -100;
// unsigned int value - with suffix U or u
int x = 1000U;
// long int value
long int long_val = 3500L;</k>
With the value of <k>int</k> data type, we can use <b>suffix</b> <k>U</k> or <k>u</k>, to tell the compiler that the value is for <k>unsigned</k> <k>int</k> data type and <b>suffix</b> <k>L</k> or <k>l</k> for a <k>long</k> <k>int</k> value.Learn more about type identifiers(<k>signed</k>, <k>unsigned</k>, <k>long</k>, and <k>short</k>) and how they change the primary datatypes when used with them - Visit <b><a href="http://www.studytonight.com/c/datatype-in-c.php">C datatypes guide for beginners</a></b>
<h2>&emsp;float Datatype</h2>
The <k>float</k> data type is used to store <b>real numbers</b> which may have a decimal (fraction) part or an exponential part.
It is a single-precision number.
Let's see some examples for <k>float</k> value,
<k>float x = 127.675;
// with suffix F or f
float y = 1000.5454F;</k>
Just like <k>int</k> datatype, the <k>float</k> can also <b>be used with type modifiers</b> - To learn more about it, visit <b><a href="http://www.studytonight.com/c/datatype-in-c.php">C datatypes guide for beginners</a></b>
<h2>&emsp;double Datatype</h2>
The real numbers are big enough that they cannot be stored in <k>float</k> datatype, are stored as <k>double</k> datatype.
It is a double-precision number.
 A double datatype value can hold above 15 to 17 digits before the decimal point and 15 to 17 digits after the decimal point.
Here is an example,
<k>double x = 424455236424564.24663224663322;</k>
We should only use the <k>double</k> datatype when we need such large numbers, otherwise not, because using <k>double</k> datatype <b>makes the program slow</b>.
<h2><span class="orange">Variables in C (with Examples)</span></h2>
A variable is like a <b>container (storage space) with a name</b> in which you can store data.
When you create a variable in C programming a new memory space gets assigned to the variable.
While creating a new variable you have to provide it a name and specify datatype for the variable.
Once you have created the variable, you cannot change its datatype.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632807040-.png" src="LAZY_IMG_PLACEHOLDER">
When we create a variable in a C program, the C compiler <b>allocates a storage space</b>, depending upon the data type of the variable(<b>8 bits</b> for <k>char</k>, <b>16/32 bits</b> for <k>int</k>, etc.)
Then that storage space is given a name which is the <b>variable name</b>.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632808071-.png" src="LAZY_IMG_PLACEHOLDER">
Once a variable is created, we can store value in it.
We can change the value stored in a variable, but we cannot change the datatype of the value stored in it.
<h2>&emsp;Syntax for using Variable:</h2>
Here is how you can <b>create or declare</b> a new variable in the C language,
<k>data_type var_name;</k>
where, <b>data_type</b> is a <b>valid data type</b> (along with <a href="https://www.studytonight.com/c/datatype-in-c.php">datatype modifiers</a>, if required) and <b>var_name</b> is the <b>name of the variable</b>.
For example,
<k>int marks;</k>
Here, <k>marks</k> is the name of the variable, and it can store values of <k>int</k> type.
<h2>&emsp;Assign value to Variable</h2>
Once we have declared or created the variable, then we can assign a value to it. 
This is called <b>variable definition</b>.
<k>// variable declaration
int marks;
// variable definition
marks = 10;</k>
We can do <b>declaration and definition in a single step</b> too, like this (recommended).
<k>int marks = 10;</k>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1632808033-.png" src="LAZY_IMG_PLACEHOLDER">
You can <b>change the value of the variable</b>, whenever you want. 
But make sure the <b>value is of the correct data type</b>.
<k>// variable defined
int marks = 10;
// assign a new value
marks = 33;</k>
<h2>&emsp;Datatype of the Variable</h2>
A <b>variable</b> in C language must be given a type, which defines what type of data can be stored in the variable.
If you do not provide any datatype, then the C compiler will give <b>compile-time</b> error or syntax error.
The datatype can be <k>char</k>, <k>int</k>, <k>float</k>, <k>double</k>, or <k>short</k> <k>int</k>, <k>long</k> <k>int</k>, etc. 
data type along with modifiers.
You can learn about <b><a href="https://www.studytonight.com/c/datatype-in-c.php">C Datatypes</a></b> to see the list of various data types supported in the C language.
Let's take an example,
<k>// char type variable
char status = 'Y';
// int type variable
int marks = 95;
// float type variable
float percentage = 94.6;
// double type variable
double long = 76.997429;</k>
If you try to assign an <b>incorrect datatype value</b> to a variable, then the compiler may give an error, or it will automatically <b>convert the value into the datatype of the variable</b>.
For example,
<k>#include &lt;stdio.h>
int main() {
   // assign incorrect value
   int x = 10.58;
   printf("Value is %d", x);
   return 0;
}</k>

Value is 10
<a href="https://www.studytonight.com/code/playground/c/?id=HPlEdX" target="_blank">Run Code ยกรบ</a>
As you can see in the output, the C compiler <b>removed the part after the decimal</b>, because <k>int</k> datatype can only store whole numbers.
<h2>&emsp;Datatype cannot be changed</h2>
Once we define a variable with some datatype then <b>we cannot change the datatype</b> of that variable.
For example,
<k>// int variable
int marks = 10;
float marks;    // error
</k>
<h2>&emsp;Rules to Name a Variable</h2>
When you create a variable, you should always give a meaningful name to the variable. 
And follow the below rules for naming the variable:
Variable names must <b>not start with a digit</b>.
The variable name can consist of alphabets, digits, and special symbols like underscore <k>_</k>.
Blank or spaces are not allowed in the variable name.
<a href="https://www.studytonight.com/c/keywords-and-identifier.php" target="_blank">Keywords</a> are not allowed as a variable name.
Upper and lowercase names are treated as different, as <b>C is case-sensitive</b>, so it is suggested to keep the variable names in lowercase.
Let's see a few examples of incorrect names as per the above rules:
<k>int 1var;    // incorrect - should not start with number
int var1;    // correct
int my$var    // incorrect - special characters not allowed
int my_var1;    // correct
int my var;    // incorrect - spaces not allowed
char else;    // can't use Keywords
int count;    // valid variable name
int Count;    // new variable
int COUNT;    // new variable</k>
<h2>&emsp;Creating a Variable - Behind the Scenes</h2>
<b>Declaration</b> of variables must be done before they are used in the program. 
The declaration does the following things.
It tells the compiler what the variable name is.
It specifies what type of data the variable will hold.
Until the variable is defined the compiler doesn't have to worry about allocating memory space to the variable.
The declaration is more like informing the compiler that there exists a variable with the following datatype which is used in the program.
We can even declare a variable outside the <k>main()</k> function, using the <k>extern</k> keyword.
<k>extern int a;
extern float b;
extern double c, d;</k>
<b>Defining</b> or <b>Initializing</b> a variable means the compiler has to now assign storage to the variable because it will be used in the program.
We can even <b>declare multiple variables</b> of the same data type in a single line by using a comma to separate them.
For example,
<k>int a;
float b, c;</k>
<b>Initializing</b> a variable means providing it with a value.
<k>int a = 10;</k>
<h2>&emsp;Difference between a Variable and an Identifier?</h2>
An Identifier is a name given to any variable, function, structure, pointer, or any other entity in a programming language. 
While a variable, as we have just learned in this tutorial is a named memory location to store data that is used in the program.
<table cellpadding="10" style="width:100%;"><tbody>
<tr><th>Identifier</th>
<th>Variable</th></tr>
<tr><td>The identifier is the <b>name given to a variable</b>, function, etc.</td><td>While a variable is used to name a memory location that stores data.</td></tr>
<tr><td>An identifier can be a variable, but not all identifiers are variables.</td><td>All variable names are identifiers.</td></tr>
<tr><td>Example:
<k>// studytonight is identifier for a variable
int studytonight;
// studytonight is identifier for a function
int studytonight() { 
    ... 

}</k>
</td><td>Example:
<k>// int variable
int a;
// float variable
float a;</k>
</td></tr>
</tbody></table>
<h2><span class="orange">C Literals/Constants</span></h2>
If we want to use some data value in a C program, we can also <b>directly use a value</b>, instead of creating a variable to store the value.
When we use a value directly in C program <b>without creating a variable</b>, it is known as a <b>Literal</b>.
A literal is used when we want to <b>use a fixed value</b> in the program, hence literals are also called <b>Constants</b>.
For example, <b>1</b>, <b>100</b>, <b>'Y'</b>, <b>10.5</b>, etc. 
Whereas, when we use a <a href="https://www.studytonight.com/c/variables-in-c.php">variable in C</a>, we can change the value stored in the variable.
In the language, literals can be of 5 types, they are:
Integer Literal
Character Literal
Floating-point Literal
String Literals
Backslash Character Literals (Escape Sequences)
<h2>&emsp;Integer Literal</h2>
Any <b>numeric value without any decimal</b> or exponential part, used in the C program is an integer literal.
Integer literals are of 3 types:
Decimal Numer (base 10)
Octal Number (base 8) - Uses digits <b>0 up to 7</b>. 
Number 10 is the same as 8 for the octal system.
Hexadecimal Number (base 16) - Uses digits <b>0 up to 9</b>, and alphabets <b>A to F</b>. 
(A, B, C, D, E, F stands for 10, 11, 12, 13, 14, and 15)
For example,
<k>Decimal: 7, -10 etc
Octal: 023, 045 etc
Hexadecimal: 0x2a, 0x521 etc</k>
In the C language, the <b>octal</b> number starts with a <b>0</b>,
and the <b>hexadecimal</b> number starts with a <b>0x</b>.
You can also <b>use type suffixes</b> with integer values to make it easier for the compiler to understand the type of the integer value.
If you follow the value with <k>L</k>, the compiler will treat it as a <k>long</k> value. 

If you add <k>U</k> after the value, the compiler treats the value as <b>unsigned</b>.
For example,
<k>3500L, 14l    // long value
99U, 89u    // unsigned int value</k>
<h2>&emsp;Floating-point Literals</h2>
Any valid <b>floating-point value</b> when used directly in a C program, is called a floating-point literal.
The floating-point numbers have a decimal part (fraction) or an exponential part.
For example,
<k>100.50
0.000127
-0.77E-5</k>
E-5 stands for 10<sup>-5</sup>
If we <b>add a type suffix</b> <k>F</k> or <k>f</k> after the value, then the compiler will treat the value as <k>float</k> type by default.
For example,
<k>127.7F, 40f etc.</k>
<h2>&emsp;Character Literals</h2>
A valid character datatype value when used directly in the C program is called a character literal.
The character values are enclosed within a single quote.
For example,
<k>'A', 'B', 'c', '#', etc.</k>
<h2>&emsp;String Literals</h2>
A <b>sequence of characters</b> is called a <b>String</b>.
A string literal is a value with multiple characters enclosed within double quotes.
There is no special datatype for a string in C programming, so you cannot create a variable of type string directly.
For example,
<k>"study", "tonight", "c programming", etc.</k>
<h2>&emsp;Backslash Character Literals</h2>
These are also known as <b>Escape sequences</b>.
The combination of characters with the backslash character <k>\</k> have special meaning for the C compiler.
A backslash character is used to <b>escape characters with special meaning</b> and make them normal characters for the compiler.
For example, if you use a single quotation mark, the compiler will think that it is the starting or end of a character value, but what if you want a single quote character?
<k>'\''    \\ this is character with value '</k>
In the example above the <b>first and the last single quote</b> marks the <b>start and end of the character value</b>, whereas the backslash escape character informs the compiler to treat the single quotation after it as a normal character.
<table cellpadding="10" style="width:100%;">
<thead><tr><th scope="col">Code</th>
<th scope="col">Meaning</th></tr></thead>
<tbody>
<tr><td>\b</td><td>Backspace</td></tr>
<tr><td>\f</td><td>Form feed</td></tr>
<tr><td>\n</td><td>New line</td></tr>
<tr><td>\r</td><td>Carriage return</td></tr>
<tr><td>\t</td><td>Horizontal tab</td></tr>
<tr><td>\"</td><td>Double quote</td></tr>
<tr><td>\'</td><td>Single quote</td></tr>
<tr><td>\\</td><td>Backslash</td></tr>
<tr><td>\v</td><td>Vertical tab</td></tr>
<tr><td>\a</td><td>Alert</td></tr>
<tr><td>\?</td><td>Question mark</td></tr>
<tr><td>\N</td><td>Octal contant</td></tr>
<tr><td>\xN</td><td>Hexadecimal constant</td></tr>
</tbody>
</table>
The <b>newline</b> and <b>horizontal tab</b> codes are quite <b>commonly used</b>, and you will be using them a lot as you start coding in the C language.
So remember <k>\n</k> is for <b>Newline</b> and <k>\t</k> is for the <b>horizontal tab</b>.
<h2><span class="orange">C Constant value Variables - <k>const</k> Keyword</span></h2>
In C programming, a constant value is a value that cannot be changed.
Using constants, you can assign a fixed value to a variable, so that the value of the variable is not changed by mistake during program execution.
To define a constant value variable you can use the <k>const</k> keyword.
<h2>&emsp;Types of Constants</h2>
In C programming <a href="https://www.studytonight.com/c/c-literals.php">Literals</a> are constants. 
Following are the different types of constants in C programming:
<h2>&emsp;Integer Constants</h2>
Integer values are values that have no fractional part or decimal point. 
For example, 7, 0, -7, etc.
<h2>&emsp;Floating-point Constants</h2>
Floating-point values are real numbers with fractional parts or decimal point. 
For example, 3.14, -2.65, etc.
<h2>&emsp;Character Constants</h2>
These are single-character constants enclosed within single quotes, for example, 'A', 'a', '#', etc.
<h2>&emsp;String Constants</h2>
These are set of characters, or text, enclosed within double quotes, for example, "Studytonight", "I love C", etc.
<h2>&emsp;Enumeration Constants</h2>
An enumeration in C language is a set of named integer values. 
Enumeration or Enum is called user-defined constants.
<h2>&emsp;Using <k>const</k> Keyword</h2>
The <k>const</k> keyword is used to create a variable as a constant.
When you create a variable using the <k>const</k> keyword, you have to assign it a value while creating the variable.
Once you have assigned a value to a <k>const</k> variable, the value stored in the variable cannot be changed.
You can use the <k>const</k> keyword with any type of variable.
Here is a simple example of using the <k>const</k> keyword,
<k>const int totalmarks = 100;</k>
In the above code, we have defined a variable <b>totalmarks</b> of type <k>int</k> and assigned it a value of <b>100</b>. 
Because we have used the <k>const</k> keyword while defining the variable hence we cannot change the value of the <k>totalmarks</k> variable.
<h2>&emsp;Change <k>const</k> Variable value</h2>
If you will try to change the value of the <k>const</k> variable in the program after it has been defined, then the compiler will give an error.
For example,
<k>#include &lt;stdio.h>
int main() {
   // initialize a constant variable 
   const int total_marks = 10;
   // try changing value
   total_marks = 80;
   
   return 0;
}</k>

error: assignment of read-only variable 'total_marks'
total_marks = 80;
^
<a href="https://www.studytonight.com/code/playground/c/?id=XVJFxP" target="_blank">Run Code ยกรบ</a>
As you can see in the error message, the compiler says that the variable is a <b>read-only variable</b>, hence its <b>value cannot be changed</b>.
Because <k>const</k> variables are read-only variables, the compiler can place these variables into the <b>read-only memory</b> (<b>ROM</b>).
When we define a variable as a <k>const</k>, then nothing in that program can change the value of that variable.
Hence, if the value of the <k>const</k> variable <b>changes</b>, then you can say that something outside of the program changed the value, it can be the hardware device or any external event.
<h2>&emsp;Code Examples</h2>
Here are a few code examples.
1. 
Creating a <k>const</k> variable,
<k>const int DAY_IN_WEEK = 7;</k>
2. 
Using a constant variable in expression,
<k>const int DAY_IN_WEEK = 7;
int num_of_weeks = 10;
int total_duration = num_of_weeks * DAY_IN_WEEK;</k>
3. 
Declaring a constant pointer,
<k>int x = 7007;
const int* ptr = &amp;x;</k>
<h2>&emsp;Frequently Asked Questions (FAQ)</h2>
<h4>Q1. 
Can I use constants to set array sizes?</h4>
A. 
Yes, you can use constants to define array sizes. 
You can define the array sizes at the start of the program, and then use it wherever required. 
In case you want to change the value, you will have to change only a single line of code.
<h4>Q2. 
Should I create a constant variable or use the value directly in the program?</h4>
A. 
You can use a value directly in the program but it is good practice to define a constant value at the beginning of the program by creating a constant variable and then using it in the program. 
Using a constant variable is a better approach also because it makes updating the constant value, if required, easy, because you just have to update the value of the variable.
<h4>Q3. 
What is the difference between a Constant and a Variable?</h4>
A constant has a fixed value that cannot be changed whereas a variable's value can be changed.
<h2><span class="orange">C Input and Output - <k>printf()</k>/<k>scanf()</k>, and more.</span></h2>
<b>Input</b> means to provide the program with some data to be used in it. 

<b>Output</b> means to display data on the screen or write the data to a printer or a file.
The C programming provides standard library functions to read any given input and display output on the console.
Before moving forward with input and output in C language, check these topics to understand the concept better:
<a href="https://www.studytonight.com/c/c-syntax.php">C Syntax Rules</a>
<a href="https://www.studytonight.com/c/compile-and-run-c-program.php">Compile and Run C Program</a>
<a href="https://www.studytonight.com/c/datatype-in-c.php">Data Types in C</a>
<a href="https://www.studytonight.com/c/variables-in-c.php">Variables in C</a>
While dealing with input-output operations in C, we use the following two streams:

<b>Standard Input (stdin)</b>
<b>Standard Output (stdout)</b>
<b>Standard input</b> or <b>stdin</b> is used for taking input.
<b>Standard output</b> or <b>stdout</b> is used for giving output.
The functions used for standard input and output are present in the <b>stdio.h</b> header file.
Hence, to use those functions, we need to include the <b>stdio.h</b> header file in our program, as shown below.
<k>#include &lt;stdio.h></k>
<h2>&emsp;Functions Used for Input and Output</h2>
C language offers us several built-in functions for performing input/output operations. 
The following are the functions used for standard input and output:
<k>printf()</k> function - <b>Show Output</b>
<k>scanf()</k> function - <b>Take Input</b>
<k>getchar()</k> and <k>putchar()</k> function
<k>gets()</k> and <k>puts()</k> function
In C Language, output devices like computer monitors, printers, etc. 
are treated as <b>files</b> and the same process is followed to write output to these devices as would have been followed to write the output to a file.
<h2>&emsp;The <k>printf()</k> function</h2>
The <k>printf()</k> function is the most used function in the C language.
This function is defined in the <b>stdio.h</b> header file and is used to show output on the console (standard output).
Following is how the <k>printf()</k> function is defined in the C <b>stdio.h</b> library.
<k>int printf(const char *format, ...);</k>
It writes the C string pointed by the format pointer to the standard output (stdout).
On success, the <b>total number of characters written</b> is returned.
This function is used to <b>print a simple text sentence</b> or <b>value of any variable</b> which can be of <k>int</k>, <k>char</k>, <k>float</k>, or any other datatype.
<h2>&emsp;
<k>p&emsp;rintf()</k> Code Examples</h2>
Let's start with a simple example.
<b>1. 
Print a sentence</b>
Let's print a simple sentence using the <k>printf()</k> function.
<k>#include &lt;stdio.h>
int main() {
   // using printf()
   printf("Welcome to Studytonight");
   return 0;
}</k>

Welcome to Studytonight
<a href="https://www.studytonight.com/code/playground/c/?id=m6SxJw">Run Code ยกรบ</a>
This one is a very common code example.
To understand the complete code and structure of a basic C language program, check <b><a href="https://www.studytonight.com/c/first-c-program.php">Hello World Program in C</a></b>.
<b>2. 
Print an Integer value</b>
We can use the <k>printf()</k> function to print an integer value coming from a variable using the <k>%d</k> <b>format specifier</b>.
For example,
<k>#include &lt;stdio.h>
int main() {  
   int x = 10;
   // using printf()
   printf("Value of x is: %d", x);
   return 0;
}</k>

Value of x is: 10
<a href="https://www.studytonight.com/code/playground/c/?id=WIedQ1" target="_blank">Run Code ยกรบ</a>
In the program, above we have used the <k>%d</k> format specifier, to specify the type of value that will be added there.
The format specifiers <k>%d</k> and <k>%i</k> are used for integer values.
<b>3. 
Print a Character value</b>
The <k>%c</k> format specifier is used to print character variable values using the <k>printf()</k> function.
<k>#include &lt;stdio.h>
int main() {
   // using printf()
   char gender = 'M';
      
   printf("John's Gender is: %c", gender);
   return 0;
}</k>

John's Gender is: M
<a href="https://www.studytonight.com/code/playground/c/?id=hesLZb" target="_blank">Run Code ยกรบ</a>
<b>4. 
Print a Float and a Double value</b>
In the code example below, we have used the <k>printf()</k> function to print values of a <k>float</k> and <k>double</k> type variable.
For <k>float</k> value we use the <k>%f</k> format specifier and for <k>double</k> value we use the <k>%lf</k> format specifier.
<k>#include &lt;stdio.h>
int main() {
   // using printf() 
   float num1 = 15.50;
   double num2 = 15556522.0978678;
   
   printf("Value of num1 is: %f \n", num1);
   printf("Value of num2 is: %lf", num2);
   return 0;
}</k>

Value of num1 is: 15.500000
Value of num2 is: 15556522.097868
<a href="https://www.studytonight.com/code/playground/c/?id=HXGWy8" target="_blank">Run Code ยกรบ</a>
We have used the <k>\n</k> Escape sequence which is used for a <b>newline</b> at the end of the first <k>printf()</k> statement so that the next <k>printf()</k> statement output is <b>shown in the next line</b>.
<b>5. 
Print multiple outputs</b>
We can use a single <k>printf()</k> function to display values of multiple variables.
<k>#include &lt;stdio.h>
int main() {
   // using printf() for multiple outputs 
   int day = 20;
   int month = 11;
   int year = 2021;
   
   printf("The date is: %d-%d-%d", day, month, year);
   return 0;
}</k>

The date is: 20-11-2021
<a href="https://www.studytonight.com/code/playground/c/?id=jRo5BL" target="_blank">Run Code ยกรบ</a>
As you can see in the code example above, we can <b>do the formatting </b>and print values of multiple variables using the <k>printf()</k> function.
We can also perform some simple calculations inside <k>printf()</k>. 
Here is a simple example of that,
<k>#include &lt;stdio.h>
int main()
{
    int a = 5, b = 6;
    printf("%d", a + b);
    return 0;
}</k>

11
<h2>&emsp;Format Specifiers</h2>
To print values of different data types using the <k>printf()</k> statement and while taking input using the <k>scanf()</k> function, it is mandatory to use <b>format specifiers</b>.
It is a way to tell the compiler what type of data is in a variable.
Some examples are <k>%c</k>, <k>%d</k>, <k>%f</k>, etc.
Here is a list of all the format specifiers.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Datatype</th>
<th scope="col">Format Specifier</th></tr></thead>
<tbody>
<tr><td><k>int</k></td><td>
<k>%d</k>, <k>%i</k>
</td></tr>
<tr><td><k>char</k></td><td><k>%c</k></td></tr>
<tr><td><k>float</k></td><td><k>%f</k></td></tr>
<tr><td><k>double</k></td><td><k>%lf</k></td></tr>
<tr><td>
<k>short</k> <k>int</k>
</td><td><k>%hd</k></td></tr>
<tr><td>
<k>unsigned</k> <k>int</k>
</td><td><k>%u</k></td></tr>
<tr><td>
<k>long</k> <k>int</k>
</td><td><k>%li</k></td></tr>
<tr><td>
<k>long</k> <k>long</k> <k>int</k>
</td><td><k>%lli</k></td></tr>
<tr><td>
<k>unsigned</k> <k>long</k> <k>int</k>
</td><td><k>%lu</k></td></tr>
<tr><td>
<k>unsigned</k> <k>long</k> <k>long</k> <k>int</k>
</td><td><k>%llu</k></td></tr>
<tr><td>
<k>signed</k> <k>char</k>
</td><td><k>%c</k></td></tr>
<tr><td>
<k>unsigned</k> <k>char</k>
</td><td><k>%c</k></td></tr>
<tr><td>
<k>long</k> <k>double</k>
</td><td><k>%Lf</k></td></tr>
</tbody>
</table>
<h2>&emsp;The <k>scanf()</k> function</h2>
When we want to take input from the user, we use the <k>scanf()</k> function and store the input value into a variable.
Following is how the <k>scanf()</k> function is defined in the C <b>stdio.h</b> library.
<k>int scanf(const char *format, ...);</k>
It reads data from stdin and stores it according to the parameter format into the locations pointed by the additional arguments.
On success, the function returns the <b>number of items of the argument list</b> successfully filled.
The <k>scanf()</k> function can be used to take input of any type from the user. 

All you have to take care of is that the variable in which you store the value should have the same data type.
Here is the <b>syntax</b> for <k>scanf()</k>:
<k>scanf("%x", &amp;variable);</k>
where, <k>%x</k> is the format specifier.
Using the format specifier, we tell the compiler what type of data to expect from the user.
The <k>&amp;</k> is the <b>address operator</b> which tells the compiler the address of the variable so that the compiler can store the user input value at that address.
<h2>&emsp;
<k>s&emsp;canf()</k> Code Examples</h2>
Let's start with a simple example.
<b>1. 
Input Integer value</b>
If we have to take an integer value input from the user, we have to define an integer variable and then use the <k>scanf()</k> function.
<k>#include &lt;stdio.h>
int main() {
   // using scanf() 
   int user_input;
   
   printf("Please enter a number: ");
   scanf("%d", &amp;user_input);
   printf("You entered: %d", user_input);
   return 0;
}</k>
<a href="https://www.studytonight.com/code/playground/c/?id=IGtyxk" target="_blank">Run Code ยกรบ</a>

Please enter a number: 7
You entered: 7
<u><b>NOTE:</b></u> If you use our compiler, then while running the code example above, there is a button for Input at the top-right corner of the editor, you can click on it and provide custom value for input.
In the above code example, we have used <k>%d</k> format specifier to inform the <k>scanf()</k> function that user input will be of type <b>int</b>.
And we have also used <k>&amp;</k> symbol before the name of the variable, because <k>&amp;user_input</k> refers to the address of the <k>user_input</k> variable where the input value will be stored.
<b>2. 
Input Float value</b>
Just like integer value, we can take input for any different datatype. 
Let's see an example of <k>float</k> type value.
<k>#include &lt;stdio.h>
int main() {
   // using scanf() 
   float user_input;
   
   printf("Please enter a decimal number: ");
   scanf("%f", &amp;user_input);
   printf("You entered: %f", user_input);
   return 0;
}</k>

Please enter a decimal number: 7.007
You entered: 7.007
We have used the <k>%f</k> format specifier and defined a <k>float</k> type variable.
Try doing the same for taking a <k>double</k> type value as user input.
The format specifier for <k>double</k> is <k>%lf</k>.
<b>3. 
Input Character value</b>
Let's see how we can take a simple character input from the user.
<k>#include &lt;stdio.h>
int main() {
   // using scanf() 
   char gender;
   
   printf("Please enter your gender (M, F or O): ");
   scanf("%c", &amp;gender);
   printf("Your gender: %c", gender);
   return 0;
}</k>

Please enter your gender (M, F or O): M
Your gender: M
<b>4. 
Take Multiple Inputs from the User</b>
In the below code example, we are taking multiple inputs from the user and saving them into different variables.
<k>#include &lt;stdio.h>
int main() {
   // using scanf() for multiple inputs
   char gender;
   int age;
   printf("Enter your age and then gender(M, F or O): ");
   scanf("%d %c", &amp;age, &amp;gender);
   printf("You entered: %d and %c", age, gender);
   return 0;
}</k>

Enter your age and then gender(M, F or O): 32 M
You entered: 32 and M
<h2>&emsp;Return Value of <k>printf()</k> & <k>scanf()</k></h2>
The <k>printf()</k> function returns the <b>number of characters printed by it</b>,
and <k>scanf()</k> function returns the <b>number of characters read by it</b>.
<k>int i = printf("studytonight");
printf("Value of i is: %d", i);</k>

studytonightValue of i is: 12
In this program <k>printf("studytonight");</k> will return <k>12</k> as a result, which will be stored in the variable <k>i</k>, because the word <b>studytonight</b> has 12 characters.
The first <k>printf()</k> statement will print the statement <b>studytonight</b> on the output too.
<h2>&emsp;<k>getchar()</k> & <k>putchar()</k> functions</h2>
The <k>getchar</k> and <k>putchar</k> functions are used for taking character input from the user and printing the character as output.
<h2>&emsp;The getchar() function</h2>
The <k>getchar()</k> function reads a character from the terminal and returns it as an <b>integer</b>.
This function reads only a single character at a time.
Here is the syntax for the <k>getchar()</k> function:
<k>int getchar(void);</k>
You can use this method in a <a href="https://www.studytonight.com/c/loops-in-c.php">loop</a> if you want to read more than one character.
<h2>&emsp;The putchar() function</h2>
The <k>putchar()</k> function displays the character passed to it on the screen and returns the same character.
This function too displays only a single character at a time.
Here is the syntax for the <k>putchar()</k> function:
<k>int putchar(int character);</k>
In case you want to display more than one character, use <k>putchar()</k> method in a loop.
<k>#include &lt;stdio.h>
void main( )
{
    int c;
    printf("Enter a character");
    /*
        Take a character as input and 
        store it in variable c
    */
    c = getchar();
    /*
        display the character stored 
        in variable c 
    */
    putchar(c);
}</k>

Enter a character: Studytonight
S
When you will compile the above code, it will ask you to enter a value. 
When you will enter the value, it will display the value you have entered.
<h2>&emsp;<k>gets()</k> & <k>puts()</k> functions</h2>
The <k>gets</k> and <k>puts</k> functions are used for taking string input and giving string output.
<h2>&emsp;The gets() function</h2>
The <k>gets()</k> function reads a line of text from <b>stdin</b>(standard input) into the buffer pointed to by <k>str</k> <a href="https://www.studytonight.com/c/pointers-in-c.php">pointer</a>, until either a terminating newline or EOF (end of file) occurs.
Here is the syntax for the <k>gets()</k> function:
<k>char* gets(char* str);</k>
<h2>&emsp;The puts() function</h2>
The <k>puts()</k> function writes the string <k>str</k> with a newline character ('\n') at the end to <b>stdout</b>. 
On success, a non-negative value is returned.
Here is the syntax for the <k>gets()</k> function:
<k>int puts(const char* str);</k>
<k>str</k> is the pointer to an array of <b>chars</b> where the C string is stored (Don't worry if you are not able to understand this now.)
<k>#include &lt;stdio.h>
void main()
{
    /* character array of length 100 */
    char str[100];
    printf("Enter a string: ");
    gets(str);
    puts(str);
    getch();
    return 0;
}</k>

Enter a string: Studytonight
Studytonight
When you will compile the above code, it will ask you to enter a string.
When you will enter the string, it will display the value you have entered.
The <k>gets()</k> function is considered dangerous to use and should be avoided. 
We get a warning when we compile any code in which we have used <k>gets()</k> function. 
This is because the function doesn't know how big the buffer is, so it continues reading until it finds a newline or encounters EOF, and may overflow the bounds of the buffer it was given. 
We can use alternatives to <k>gets()</k> function, like the <k>fgets()</k> function.
<h2>&emsp;The <k>fgets()</k> function</h2>
Here is the syntax for the <k>fgets()</k> function:
<k>char* fgets(char* str, int num, FILE* stream);</k>
It reads characters and stores them as a C string into <k>str</k> until <b>(num-1)</b> characters have been read or either a newline or the end-of-file is reached, whichever happens first.
A newline character makes <k>fgets</k> stop reading, but it is considered a valid character by the function and included in the string copied to <k>str</k>.
On success, the function returns the <k>str</k>.
For example,
<k>#include &lt;stdio.h>
#define MAX 10
int main()
{
    char str[MAX];
    fgets(str, MAX, stdin);
    printf("The string is: %s", str);
    return 0;
}</k>

abcdefghijkl
The string is: abcdefghij
<h2>&emsp;Difference between <k>scanf()</k> and <k>gets()</k></h2>
The main difference between these two functions is that <k>scanf()</k> <b>stops reading characters when it encounters a space</b>, but <k>gets()</k> <b>reads space as a character too</b>.
If you enter a name as <b>Study Tonight</b> using <k>scanf()</k> it will only read and store <b>Study</b> and will leave the part of the string after space. 
But <k>gets()</k> function will read it completely.
Let's see the <k>scanf()</k> function in action:
<k>#include &lt;stdio.h>
int main() {
   // using scanf() 
   char n1[50], n2[50];
   printf("Please enter n1: ");
   scanf("%s", n1);
   printf("You entered: %s", n1);
   return 0;
}</k>

Please enter n1: study tonight
You entered: study
Now let's see the <k>gets()</k> function in action:
<k>#include &lt;stdio.h>
int main() {
   // using scanf() 
   char n1[50], n2[50];
   printf("Please enter n1: ");
   gets(n1);
   printf("You entered: %s", n1);
   return 0;
}</k>

Please enter n1: study tonight
You entered: study tonight
<h2><span class="orange">C Operators (with Live Examples)</span></h2>
The C language supports a rich set of built-in operators.
An <b>operator</b> is a <b>symbol</b> that tells the compiler to perform a certain operation (arithmetic, comparison, etc.) using the values provided along with the operator.
Operators are used in programs to manipulate data and variables.
Before moving forward with Operators in C language, we recommend you learn about C variables and datatypes:
<a href="https://www.studytonight.com/c/variables-in-c.php" target="_blank">C Variables</a>
<a href="https://www.studytonight.com/c/c-literals.php">C Literals</a>
<a href="https://www.studytonight.com/c/datatype-in-c.php">C Datatypes</a>
<a href="https://www.studytonight.com/c/using-datatypes-examples.php">Using C Datatypes (Examples)</a>
<a href="https://www.studytonight.com/c/compile-and-run-c-program.php" target="_blank">Compile and run C Program</a>
<h2>&emsp;Type of C Operators</h2>
C operators can be classified into the following types:
Arithmetic operators
Relational operators
Logical operators
Bitwise operators
Assignment operators
Conditional operators
Special operators
Let's understand each one of these operator types, one by one with working code examples.
<h2>&emsp;What is an Operand?</h2>
Every operator works with some values.
The value with which an operator works is called as <b>Operand</b>.
For example, when we say <b>4+5</b>, numbers <b>4</b> and <b>5</b> are operands whereas <b>+</b> is an operator.
Different operators work with <b>different numbers of operands</b> like the <k>+</k> operator requires two operands or values, the increment operator <k>++</k> requires a single operand.
<h2>&emsp;Arithmetic Operators in C</h2>
The C language supports all the basic arithmetic operators such as <b>addition</b>, <b>subtraction</b>, <b>multiplication</b>, <b>division</b>, etc.
The following table shows all the basic arithmetic operators along with their descriptions.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">
Example
(where <k>a</k> and <k>b</k> are variables with some integer value)
</th></tr></thead>
<tbody>
<tr><td><k>+</k></td><td>adds two operands (values)</td><td><k>a+b</k></td></tr>
<tr><td><k>-</k></td><td>subtract second operands from first</td><td><k>a-b</k></td></tr>
<tr><td><k>*</k></td><td>multiply two operands</td><td><k>a*b</k></td></tr>
<tr><td><k>/</k></td><td>divide the numerator by the denominator, i.e. 
divide the operand on the left side with the operand on the right side</td><td><k>a/b</k></td></tr>
<tr><td><k>%</k></td><td>This is the <b>modulus operato</b>r, it returns the remainder of the division of two operands as the result</td><td><k>a%b</k></td></tr>
<tr><td><k>++</k></td><td>This is the <b>Increment operator</b> - increases the integer value by one. 
This operator needs only a <b>single operand</b>.</td><td>
<k>a++</k> or <k>++a</k>
</td></tr>
<tr><td><k>--</k></td><td>This is the <b>Decrement operator</b> - decreases integer value by one. 
This operator needs only a <b>single operand</b>.</td><td>
<k>--b</k> or <k>b--</k>
</td></tr>
</tbody>
</table>
To learn in what order the arithmetic operators are executed, visit <a href="https://www.studytonight.com/c/c-operators-precedence.php">C Operator Precedence</a>.
<h4>Code Example: Basic Arithmetic Operators</h4>
Let's see a code example to understand the use of the basic arithmetic operators in C programs.
<k>#include &lt;stdio.h>
int main() {
    int a = 50, b = 23, result;
    // addition
    result = a+b;
    printf("Addition of a & b = %d \n",result);
    // subtraction
    result = a-b;
    printf("Subtraction of a & b = %d \n",result);
    // multiplication
    result = a*b;
    printf("Multiplication of a & b = %d \n",result);
    // division
    result = a/b;
    printf("Division of a & b = %d \n",result);
    return 0;
}</k>

Addition of a & b = 73
Subtraction of a & b = 27
Multiplication of a & b = 1150
Division of a & b = 2
<a href="https://www.studytonight.com/code/playground/c/?id=vYShXF" target="_blank">Run Code ยกรบ</a>
<h4>Code Example: Using Modulus Operator (<k>%</k>)</h4>
The modulus operator returns the <b>remainder value after the division</b> of the provided values.
<k>#include &lt;stdio.h>
int main() {
   int a = 23, b = 20, result;
   // Using Modulus operator
   result = a%b;
   printf("result = %d",result);
   return 0;
}</k>

result = 3
<a href="https://www.studytonight.com/code/playground/c/?id=EY3OAS" target="_blank">Run Code ยกรบ</a>
<h4>Code Example: Using Increment and Decrement Operators</h4>
The increment operator is used to increase the value of any numeric value by 1.
The decrement operator is used to decrease the value of any numeric value by 1.
<k>#include &lt;stdio.h>
int main() {
   int a = 10, b = 20, c, d;
   /* 
      Using increment operator
   */
   printf("Incrementing value of a = %d \n", ++a);
   /* 
      Using decrement operator
   */
   printf("Decrementing value of b = %d \n", --b);
   // first print value of a, then decrement a
   printf("Decrementing value of a = %d \n", a--);
   printf("Value of a = %d \n", a);
   // first print value of b, then increment b
   printf("Incrementing value of b = %d \n", b++);
   printf("Value of b = %d \n", b);
   return 0;
}</k>

Incrementing value of a = 11
Decrementing value of b = 19
Decrementing value of a = 11
Value of a = 10
Incrementing value of b = 19
Value of b = 20
<a href="https://www.studytonight.com/code/playground/c/?id=JW7nhy" target="_blank">Run Code ยกรบ</a>
In the code example above, we have used the increment operator as <k>++a</k> and <k>b++</k>, while the decrement operator as <k>--b</k> and <k>a--</k>.
When we use the increment and decrement operator as a <b>prefix</b> (means before the operand), then, first the increment operation is done and that value is used, like in the first two <k>printf()</k> functions, we get the updated values of <k>a</k> and <k>b</k>.
Whereas when we use the increment and decrement operators as <b>postfix</b> (means after the operand), then, first the larger expression is evaluated which is <k>printf()</k> in this case and then the value of the operand is updated.
<h2>&emsp;Relational operators in C</h2>
The relational operators (or <b>comparison</b> operators) are used to check the relationship between two operands.
It checks whether two operands are <b>equal</b> or <b>not equal</b> or <b>less than</b> or <b>greater than</b>, etc.
It returns <b>1</b> if the relationship checks <b>pass</b>, otherwise, it returns <b>0</b>.
For example, if we have <b>two numbers 14 and 7</b>, if we say <b>14 is greater than 7</b>, this is <b>true</b>, hence this check will <b>return 1</b> as the result with relationship operators.
On the other hand, if we say <b>14 is less than 7</b>, this is <b>false</b>, hence it will <b>return 0</b>.
The following table shows all relational operators supported in the C language.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">
Example
(<k>a</k> and <k>b</k>, where <k>a</k> = 10 and <k>b</k> = 11)
</th></tr></thead>
<tbody>
<tr><td>==</td><td>Check if the two operands are equal</td><td>
<k>a == b</k>, returns 0</td></tr>
<tr><td>!=</td><td>Check if the two operands are not equal.</td><td>
<k>a != b</k>, returns 1 because <k>a</k> is not equal to <k>b</k>
</td></tr>
<tr><td>></td><td>Check if the operand on the left is greater than the operand on the right</td><td>
<k>a > b</k>, returns 0</td></tr>
<tr><td>&lt;</td><td>Check operand on the left is smaller than the right operand</td><td>
<k>a &lt; b</k>, returns 1</td></tr>
<tr><td>>=</td><td>check left operand is greater than or equal to the right operand</td><td>
<k>a >= b</k>, returns 0</td></tr>
<tr><td>&lt;=</td><td>Check if the operand on the left is smaller than or equal to the right operand</td><td>
<k>a &lt;= b</k>, returns 1</td></tr>
</tbody>
</table>
To learn in what order the relational operators are executed, visit <a href="https://www.studytonight.com/c/c-operators-precedence.php">C Operator Precedence</a>.
<h4>Code Example: Relational Operators</h4>
When we use relational operators, we get the output based on the result of the comparison.
If it's <b>true</b>, then the output is <b>1</b> and if it's <b>false</b>, then the output is <b>0</b>.
We will see the same in the example below.
<k>#include &lt;stdio.h>
int main() {
   int a = 10, b = 20, result;
   // Equal
   result = (a==b);
   printf("(a == b) = %d \n",result);
   // less than
   result = (a&lt;b);
   printf("(a &lt; b) = %d \n",result);
   // greater than
   result = (a>b);
   printf("(a > b) = %d \n",result);
   // less than equal to
   result = (a&lt;=b);
   printf("(a &lt;= b) = %d \n",result);
   return 0;
}</k>

(a == b) = 0
(a &lt; b) = 1
(a > b) = 0
(a &lt;= b) = 1
<a href="https://www.studytonight.com/code/playground/c/?id=CEzeKF" target="_blank">Run Code ยกรบ</a>
In the code example above, <k>a</k> has a value <b>10</b>, and <k>b</k> has a value <b>20</b>, and then different comparisons are done between them.
In the C language, <b>true</b> is any value <b>other than zero</b>. 
And <b>false</b> is <b>zero</b>.
<h2>&emsp;Logical Operators in C</h2>
C language supports the following 3 logical operators.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">
Example
(<k>a</k> and <k>b</k>, where <k>a</k> = 1 and <k>b</k> = 0)
</th></tr></thead>
<tbody>
<tr><td><k>&amp;&amp;</k></td><td>Logical AND</td><td>
<k>a &amp;& b</k>, returns 0</td></tr>
<tr><td><k>||</k></td><td>Logical OR</td><td>
<k>a || b</k>, returns 1</td></tr>
<tr><td><k>!</k></td><td>Logical NOT</td><td>
<k>!a</k>, returns 0</td></tr>
</tbody>
</table>
These operators are used to perform logical operations and are used with conditional statements like <a href="https://www.studytonight.com/c/decision-making-in-c.php">C if-else statements</a>.
With the <b>AND</b> operator, only <b>if both operands are true</b>, the <b>result is true</b>.
With the <b>OR</b> operator, if a <b>single operand is true</b>, then the <b>result will be true</b>.
The <b>NOT</b> operator <b>changes true to false</b>, and <b>false to true</b>.
<h4>Code Example: Logical Operators</h4>
In the code example below, we have used the logical operators.
<k>#include &lt;stdio.h>
int main() {
   int a = 1, b = 0, result;
   // And
   result = (a &amp;& b);
   printf("a &amp;& b = %d \n",result);
   // Or
   result = (a || b);
   printf("a || b = %d \n",result);
   // Not
   result = !a;
   printf("!a = %d \n",result);
   return 0;
}</k>

(a &amp;& b) = 0
(a || b) = 1
(!a) = 0
<a href="https://www.studytonight.com/code/playground/c/?id=iNQwHa" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;Bitwise Operators in C</h2>
Bitwise operators perform manipulations of data at the bit level.
These operators also perform the <b>shifting of bits from right to left</b>.
Bitwise operators are not applied to <k>float</k> or <k>double</k>, <k>long</k> <k>double</k>, <k>void</k>, etc. 
(Learn about <a href="http://www.studytonight.com/c/datatype-in-c.php">C float and double datatype</a>).
There are <b>6 bitwise operators</b> in C programming.
The following table contains the bitwise operators.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">Example</th></tr></thead>
<tbody>
<tr><td><k>&amp;</k></td><td>Bitwise AND</td><td> </td></tr>
<tr><td><k>|</k></td><td>Bitwise OR</td><td> </td></tr>
<tr><td><k>^</k></td><td>Bitwise Exclusive OR (XOR)</td><td> </td></tr>
<tr><td><k>~</k></td><td>One's complement (NOT)</td><td> </td></tr>
<tr><td><k>>></k></td><td>Shift right</td><td> </td></tr>
<tr><td><k>&lt;&lt;</k></td><td>Shift left</td><td> </td></tr>
</tbody>
</table>
The bitwise AND, OR, and NOT operator works the same way as the Logical AND, OR, and NOT operators, except that the bitwise operators work <b>bit by bit</b>.
Below we have a <b>truth table</b> for showing how these operators work with different values.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">a</th>
<th scope="col">b</th>
<th scope="col">a & b</th>
<th scope="col">a | b</th>
<th scope="col">a ^ b</th></tr></thead>
<tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
</tbody>
</table>
Bitwise operators can produce any arbitrary value as a result. 
It is not mandatory that the result will either be 0 or 1.
<h2>&emsp;Bitwise <k>>></k> and <k>&lt;&lt;</k> operators</h2>
The bitwise shift operator <b>shifts the bit value</b>, either to the left or right.
The <b>left operand</b> specifies the <b>value to be shifted</b> and the <b>right operand</b> specifies the <b>number of positions</b> that the bits in the value have to be shifted.
Both operands have the same precedence.
Understand, how bits shift from left to right and vice versa.
<k>a = 00010000
b = 2
a &lt;&lt; b = 01000000 
a >> b = 00000100</k>
In case of <k>a &lt;&lt; b</k>, <b>2 bits</b> are shifted to left in <b>00010000</b> and additional zeros are added to the opposite end, that is right, hence the value becomes <b>01000000</b>
And for <k>a >> b</k>, <b>2 bits</b> are shifted from the right, hence two zeros are removed from the right and two are added on the left, hence the value becomes <b>00000100</b>
Please note, shift doesn't work like rotating, which means, the bits shifted are not added at the other end. 
The <b>bits that are shifted are lost</b>.
<h2>&emsp;Bitwise One's Complement (<k>~</k>) Operator</h2>
The one's complement operator will change all the 1's in the operand to 0, and all the 0's are set to 1.
For example, if the original byte is <b>00101100</b>, then after one's complement it will become <b>11010011</b>.
<h4>Code Example: Bitwise Left & Right shift Operators</h4>
Let's see an example to understand the bitwise operators in C programs.
<k>#include &lt;stdio.h>
int main() {
   int a = 0001000, b = 2, result;
   // &lt;&lt;
   result = a&lt;&lt;b;
   printf("a &lt;&lt; b = %d \n",result);
   // >>
   result = a>>b;
   printf("a >> b = %d \n",result);
   return 0;
}</k>

a &lt;&lt; b = 2048
a >> b = 128
<a href="https://www.studytonight.com/code/playground/c/?id=Oe08vf" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;Assignment Operators in C</h2>
The assignment operators are used to assign value to a variable.
For example, if we want to assign a value <b>10</b> to a variable <k>x</k> then we can do this by using the assignment operator like: <k>x = 10;</k> Here, <k>=</k> (equal to) operator is used to assign the value.
In the C language, the <k>=</k> (equal to) operator is <b>used for assignment</b> however it has several other variants such as <k>+=</k>, <k>-=</k> to combine two operations in a single statement.
You can see all the assignment operators in the table given below.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">
Example
(<k>a</k> and <k>b</k> are two variables, with where a=10 and b=5)
</th></tr></thead>
<tbody>
<tr><td><k>=</k></td><td>assigns values from right side operand to left side operand</td><td>
<k>a=b</k>, <k>a</k> gets value 5</td></tr>
<tr><td><k>+=</k></td><td>adds right operand to the left operand and assign the result to left operand</td><td>
<k>a+=b</k>, is same as <k>a=a+b</k>, value of <k>a</k> becomes 15</td></tr>
<tr><td><k>-=</k></td><td>subtracts right operand from the left operand and assign the result to left operand</td><td>
<k>a-=b</k>, is same as <k>a=a-b</k>, value of <k>a</k> becomes 5</td></tr>
<tr><td><k>*=</k></td><td>mutiply left operand with the right operand and assign the result to left operand</td><td>
<k>a*=b</k>, is same as <k>a=a*b</k>, value of <k>a</k> becomes 50</td></tr>
<tr><td><k>/=</k></td><td>divides left operand with the right operand and assign the result to left operand</td><td>
<k>a/=b</k>, is same as <k>a=a/b</k>, value of <k>a</k> becomes 2</td></tr>
<tr><td><k>%=</k></td><td>calculate modulus using two operands and assign the result to left operand</td><td>
<k>a%=b</k>, is same as <k>a=a%b</k>, value of <k>a</k> becomes 0</td></tr>
</tbody>
</table>
When we combine the arithmetic operators with the assignment operator <k>=</k>, then we get the <b>shorthand form</b> of all the arthmetic operators.
<h4>Code Example: Using Assignment Operators</h4>
Below we have a code example in which we have used all the different forms of assignment operators, starting from the basic assignment.
<k>#include &lt;stdio.h>
int main() {
   int a = 10;
   // Assign
   int result = a;
   printf("result = %d \n",result);
   // += operator
   result += a;
   printf("result = %d \n",result);
   // -= operator
   result -= a;
   printf("result = %d \n",result);
   // *= operator
   result *= a;
   printf("result = %d \n",result);
   return 0;
}</k>

result = 10
result = 20
result = 10
result = 100
<a href="https://www.studytonight.com/code/playground/c/?id=TW4xIA" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;Ternary Operator (<k>?</k>) in C</h2>
The ternary operator, also known as the conditional operator in the C language can be used for statements of the form if-then-else.
The <b>basic syntax</b> for using ternary operator is:
<k>(Expression1)? Expression2 : Expression3;</k>
Here is how it works:
The question mark <k>?</k> in the syntax represents the if part.
The first expression (expression 1) returns either <b>true</b> or <b>false</b>, based on which it is decided whether (expression 2) will be executed or (expression 3)
If (expression 1) returns <b>true</b> then the (expression 2) is executed.
If (expression 1) returns <b>false</b> then the expression on the right side of <k>:</k> i.e (expression 3) is executed.
<h4>Code Example: Using Ternary Operator</h4>
Here is a code example to show how to use the ternary operator.
<k>#include &lt;stdio.h>
int main() {
   int a = 20, b = 20, result;
   /* Using ternary operator
      - If a == b then store a+b in result
      - otherwise store a-b in result
   */
   result = (a==b)?(a+b):(a-b);
   printf("result = %d",result);
   return 0;
}</k>

result = 40
<a href="https://www.studytonight.com/code/playground/c/?id=i86U2H" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;C Special Operator - <k>&amp;</k>, <k>*</k>, <k>sizeof</k>, etc.</h2>
Apart from arithmetic, relational, logical, assignment, etc. 
operators, C language uses some other operators such as:
<k>sizeof</k> operator
<k>&amp;</k> operator
<k>*</k> operator
The <k>.</k> (dot) and <k>-></k> (arrow) operators
<k>[]</k> operator, etc.
<k>sizeof</k> to find size of any entity(variable, array, etc.), <k>&amp;</k> operator to find the address of a variable, etc. 
You can see a list of such operators in the below table.
<table border="1" cellpadding="10" cellspacing="1" style="width:100%;">
<thead><tr><th scope="col">Operator</th>
<th scope="col">Description</th>
<th scope="col">Example</th></tr></thead>
<tbody>
<tr><td><k>sizeof</k></td><td>returns the <b>size(length in bytes) of the entity</b>, for eg. 
a variable or an array, etc.</td><td>
<k>sizeof(x)</k> will return the size of the variable <k>x</k>
</td></tr>
<tr><td><k>&amp;</k></td><td>returns the memory address of the variable</td><td>
<k>&amp;x</k> will return the address of the variable <k>x</k>
</td></tr>
<tr><td><k>*</k></td><td>represents a pointer to an object. 
The <k>*</k> operator returns the value stored at a memory address.</td><td>
<k>m = &amp;x</k> (memory address of the variable <k>x</k>)
<k>*m</k> will return the value stored at the memory address <k>m</k>
</td></tr>
<tr><td>
<k>.</k> (dot) operator</td><td>used to access individual elements of a <a href="https://www.studytonight.com/c/structures-in-c.php">C structure</a> or <a href="https://www.studytonight.com/c/unions-in-c.php">C union</a>.</td><td>If <k>emp</k> is a structure with an element <k>int age</k> in it, then <k>emp.age</k> will return the value of age.</td></tr>
<tr><td>
<k>-></k> (arrow) operator</td><td>used to access structure or union elements using a pointer to the structure or union.</td><td>If <k>p</k> is a pointer to the <k>emp</k> structure, then we can access <k>age</k> element using <k>p->age</k>
</td></tr>
<tr><td>
<k>[]</k> operator</td><td>used to access array elements using indexing</td><td>if <k>arr</k> is an array, then we can access its values using <k>arr[index]</k>, where <k>index</k> represents the array index starting from zero</td></tr>
</tbody>
</table>
We will learn about <k>*</k>, dot operator, arrow operator and <k>[]</k> operator as we move on in this tutorial series, for now, let's see how to use the <k>sizeof</k> and <k>&amp;</k> operators.
<h4>Code Example: Using <k>sizeof</k> and <k>&amp;</k> Operators</h4>
Here is a code example, try running in the live code compiler using the <b>Run code</b> button.
<k>#include &lt;stdio.h>
int main() {
   int a = 20;
   char b = 'B';
   double c = 17349494.249324;
   // sizeof operator
   printf("Size of a is: %d \n", sizeof(a));
   printf("Size of b is: %d \n", sizeof(b));
   printf("Size of c is: %d \n", sizeof(c));
   // & operator
   printf("Memory address of a: %d \n", &amp;a);
   return 0;
}</k>

Size of a is: 4
Size of b is: 1
Size of c is: 8
Memory address of a: 1684270284
<a href="https://www.studytonight.com/code/playground/c/?id=DBsrE2" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;Frequently Asked Questions (FAQ)</h2>
Here are some frequently asked questions for C operators.
<h4>Q1. 
What are operators in C?</h4>
Operators are symbols known to the C compiler, which are used to perform operations on data. 
Operators can be used to perform operation directly on some value(<a href="https://www.studytonight.com/c/c-literals.php">C Literals</a>) or on <a href="https://www.studytonight.com/c/variables-in-c.php">C variables</a>. 
In the C language we can perform arithmetic operations, logical and relational operations, bitwise operations, etc. 
using the C operators on data.
<h4>Q2. 
What are the different types of operators C supports?</h4>
The C language supports the following type of operators:
Arithmetic operators
Relational operators
Logical operators
Bitwise operators
Assignment operators
Ternary operator
Special operators like <k>sizeof</k>, <k>&amp;</k>, <k>*</k>, <k>.</k> (dot) operator, <k>-></k> (arrow) operator, <k>[]</k> (square bracket) operator, etc.
<h4>Q3. 
What does <k>*</k> operator do in C?</h4>
The * operator in the C language is a unary operator that returns the value of the object located at the <b>address</b>, specified after the <k>*</k> operator. 
For example <k>q = *m</k> will store the value stored at the memory address <k>m</k> in the <k>q</k> variable, if <k>m</k> contains a memory address.
The <k>*</k> operator is also used to perform the <b>multiplication</b> of two values, where it acts as an <b>arithmetic operator</b>.
<h4>Q4. 
What does <k>!=</k> mean in C?</h4>
It is a symbol of not equal to(<k>!=</k>) operator and used to check whether two values are not equal to each other or not. 
It is a <b>relational operator</b> and its opposite operator is an equal(<k>==</k>) operator which is used to check equality between two values or variables.
If two values are not equal, then we will get <b>1</b> as the result of the comparison.
<h4>Q5. 
What is <k>&amp;</k> and <k>*</k> operators in C?</h4>
Both are special types of operators and are used to perform memory-related operations. 
The <k>&amp;</k> operator is used to get the <b>address of a variable</b> and the <k>*</k> operator is the <b>complement</b> of the <k>&amp;</k> operator and is used to <b>get the value of the object</b> for located at a memory address.
<h4>Q6. 
What does %d do in C?</h4>
It is a <b>format specifier</b> that is used to print formatted output to the console. 
In the C language, it is used with the <k>printf()</k> function(<a href="https://www.studytonight.com/c/c-input-output-function.php">C Input Output</a>) to display integer value to the console. 
To print <k>float</k>, C provides <k>%f</k>, for <k>char</k> we use <k>%c</k>, for <k>double</k> we use <k>%lf</k>, etc.
<h2><span class="orange">Decision making in C</span></h2>
Decision making is about deciding the order of execution of statements based on certain conditions or repeat a group of statements until certain specified conditions are met. 
C language handles decision-making by supporting the following statements,

<k>if</k> statement
<k>switch</k> statementconditional operator statement (<k>? :</k> operator)
<k>g&emsp;oto</k> statement<h2>Decision making with <k>if</k> statement</h2>
The <k>if</k> statement may be implemented in different forms depending on the complexity of conditions to be tested. 
The different forms are,

Simple <k>if</k> statement
<k>i&emsp;f....else</k> statementNested <k>if....else </k> statementUsing <k>else if</k> statement<h2>Simple <k>if</k> statement</h2>
The general form of a simple <k>if</k> statement is, 
<k>if(expression)
{
    statement inside;
}
    statement outside;</k>
If the <i>expression</i> returns true, then the <b>statement-inside</b> will be executed, otherwise <b>statement-inside</b> is skipped and only the <b>statement-outside</b> is executed.
<b>Example:</b> 
<k>#include &lt;stdio.h>
void main( )
{
    int x, y;
    x = 15;
    y = 13;
    if (x > y )
    {
        printf("x is greater than y");
    }
}</k>
x is greater than y
<h2>&emsp;
<k>i&emsp;f...else</k> statement</h2>
The general form of a simple <k>if...else</k> statement is,
<k>if(expression)
{
    statement block1;
}
else
{
    statement block2;
}</k>
If the <i>expression</i> is true, the <b>statement-block1</b> is executed, else <b>statement-block1</b> is skipped and <b>statement-block2</b> is executed. 

<b>Example:</b>
<k>#include &lt;stdio.h>
void main( )
{
    int x, y;
    x = 15;
    y = 18;
    if (x > y )
    {
        printf("x is greater than y");
    }
    else
    {
        printf("y is greater than x");
    }
}</k>
y is greater than x
<h2>&emsp;Nested <k>if....else</k> statement</h2>
The general form of a nested <k>if...else</k> statement is,
<k>if( expression )
{
    if( expression1 )
    {
        statement block1;
    }
    else 
    {
        statement block2;
    }
}
else
{
    statement block3;
}</k>
if <i>expression</i> is false then <b>statement-block3</b> will be executed, otherwise the execution continues and enters inside the first <k>if</k> to perform the check for the next <k>if</k> block, where if <i>expression 1</i> is true the <b>statement-block1</b> is executed otherwise <b>statement-block2</b> is executed. 

<b>Example:</b>
<k>#include &lt;stdio.h>
void main( )
{
    int a, b, c;
    printf("Enter 3 numbers...");
    scanf("%d%d%d",&amp;a, &amp;b, &amp;c);
    if(a > b)
    { 
        if(a > c)
        {
            printf("a is the greatest");
        }
        else 
        {
            printf("c is the greatest");
        }
    }
    else
    {
        if(b > c)
        {
            printf("b is the greatest");
        }
        else
        {
            printf("c is the greatest");
        }
    }
} </k>
<h2><k>else if</k> ladder</h2>
The general form of else-if ladder is,
<k>if(expression1)
{
    statement block1;
}
else if(expression2) 
{
    statement block2;
}
else if(expression3 ) 
{
    statement block3;
}
else 
    default statement;</k>
The expression is tested from the top(of the ladder) downwards. 
As soon as a <b>true</b> condition is found, the statement associated with it is executed.
<b>Example :</b>
<k>
#include &lt;stdio.h>
void main( )
{
    int a;
    printf("Enter a number...");
    scanf("%d", &amp;a);
    if(a%5 == 0 &amp;& a%8 == 0)
    {
        printf("Divisible by both 5 and 8");
    }  
    else if(a%8 == 0)
    {
        printf("Divisible by 8");
    }
    else if(a%5 == 0)
    {
        printf("Divisible by 5");
    }
    else 
    {
        printf("Divisible by none");
    }
}</k>
<h2>Points to Remember</h2>

In <k>if</k> statement, a single statement can be included without enclosing it into curly braces <k>{ ... 
}</k>
<k>int a = 5;
if(a > 4)
    printf("success");</k>
No curly braces are required in the above case, but if we have more than one statement inside <k>if</k> condition, then we must enclose them inside curly braces.

<k>==</k> must be used for comparison in the expression of <k>if</k> condition, if you use <k>=</k> the expression will always return <b>true</b>, because it performs assignment not comparison.Other than <b>0(zero)</b>, all other values are considered as <b>true</b>.
<k>if(27)
    printf("hello");</k>
In above example, <b>hello</b> will be printed.
<h2><span class="orange">Switch statement in C</span></h2>
When you want to solve multiple option type problems, for example: Menu like program, where one value is associated with each option and you need to choose only one at a time, then, <k>switch</k> statement is used.
Switch statement is a control statement that allows us to choose only one choice among the many given choices. 
The expression in <k>switch</k> evaluates to return an integral value, which is then compared to the values present in different cases. 
It executes that block of code which matches the case value. 
If there is no match, then <b>default</b> block is executed(if present). 
The general form of <k>switch</k> statement is,
<k>switch(expression)
{
    case value-1:
    block-1;
    break;
    case value-2:
    block-2;
    break;
    case value-3:
    block-3;
    break;
    case value-4:
    block-4;
       break;
    default:
       default-block;
    break;
}</k>
<h2>&emsp;Rules for using <k>switch</k> statement</h2>

The &emsp;expression (after switch keyword) must yield an <b>integer</b> value i.e the expression should be an integer or a variable or an expression that evaluates to an integer.The case <b>label</b> values must be unique.The case label must end with a colon(:)The next line, after the <b>case</b> statement, can be any valid C statement.<h2>Points to Remember</h2>

We don't use those expressions to evaluate switch case, which may return floating point values or strings or characters.
<k>break</k> statements are used to <b>exit</b> the switch block. 
It isn't necessary to use <k>break</k> after each block, but if you do not use it, then all the consecutive blocks of code will get executed after the matching block.
<k>int i = 1;
switch(i)
{
    case 1:    
        printf("A");        // No break
    case 2:
        printf("B");        // No break
    case 3:
        printf("C");
        break;
}</k>
A B C
The output was supposed to be only <b>A</b> because only the first case matches, but as there is no <k>break</k> statement after that block, the next blocks are executed too, until it a <k>break</k> statement in encountered or the execution reaches the end of the <k>switch</k> block.

<b>default</b> case is executed when none of the mentioned case matches the <k>switch</k> expression. 
The default case can be placed anywhere in the <k>switch</k> case. 
Even if we don't include the default case, <k>switch</k> statement works.Nesting of <k>switch</k> statements are allowed, which means you can have <k>switch</k> statements inside another <k>switch</k> block. 
Howe&emsp;ver, nested <k>switch</k> statements should be avoided as it makes the program more complex and less readable.<h2>Example of <k>switch</k> statement</h2>
<k>#include&lt;stdio.h>
void main( )
{
    int a, b, c, choice;
    while(choice != 3)
    {
        /* Printing the available options */
        printf("\n 1. 
Press 1 for addition");
        printf("\n 2. 
Press 2 for subtraction");
        printf("\n Enter your choice");
        /* Taking users input */
        scanf("%d", &amp;choice);
        
        switch(choice)
        {
            case 1:
                printf("Enter 2 numbers");
                scanf("%d%d", &amp;a, &amp;b);
                c = a + b;
                printf("%d", c);
                break;
            case 2:
                printf("Enter 2 numbers");
                scanf("%d%d", &amp;a, &amp;b);
                c = a - b;
                printf("%d", c);
                break;
            default:
                printf("you have passed a wrong key");
                printf("\n press any key to continue");
        }
    } 
} </k>
<h2>&emsp;Difference between <k>switch</k> and <k>if</k></h2>

<k><a href="decision-making-in-c.php" target="_blank">if</a></k> statements can evaluate <k>float</k> conditions. 
<k>switch</k> statements cannot evaluate <k>float</k> conditions.
<k>if</k> statement can evaluate relational operators. 
<k>switch</k> statement cannot evaluate relational operators i.e they are not allowed in <k>switch</k> statement.
<h2><span class="orange">Loops in C</span></h2>
During programming, sometimes we might need to execute a certain code statement <b>again and again</b>. 
We can write the code statement as many times as we need it to execute but that would be very inefficient, because what if you want a code statement to execute a 100 times? This is why we use loops.
In any programming language including C language, loops are used to execute a single statement or a set of statements, repeatedly, until a particular condition is satisfied.
<h2>&emsp;How Loops in C works?</h2>
The below diagram depicts a loop execution,
<img class="lazy" data-src="https://static.studytonight.com/c/images/loops-in-c.jpg">
As per the above diagram, if the Test Condition is <b>true</b>, then the loop is executed, and if it is <b>false</b> then the execution breaks out of the loop. 
After the loop is successfully executed the execution again starts from the Loop entry and again checks for the Test condition, and this keeps on repeating.
The sequence of statements to be executed is kept inside the curly braces <k>{ }</k> known as the <b>Loop body</b>. 
After every execution of the loop body, <b>condition</b> is verified, and if it is found to be <b>true</b> the loop body is executed again. 
When the condition check returns <b>false</b>, the loop body is not executed, and execution breaks out of the loop.
Loops are broadly classified into two types:
<b>1. 
Entry controlled loops</b>
In this kind of loop, the condition is checked before executing the loop's body. 
So, if the condition is never true, it won't execute even once. 
For example, <k>for</k> and <k>while</k> loop.
<b>2. 
Exit controlled loops</b>
In this kind of loop, the condition is checked after the loop's body is executed, i.e., in the end. 
Hence, even if the condition is not fulfilled, this loop will execute one time. 
The do-while loop is an example of exit controlled loop.
<h2>&emsp;Types of Loop in C</h2>
There are 3 types of Loop in C language, namely:


<k>while</k> loop
<k>for</k> loop
<k>d&emsp;o while</k> loop<h2><k>while</k> loop in C</h2>
The <k>while</k> loop is an <b>entry controlled</b> loop. 
It is completed in 3 steps.
Variable initialization.(e.g <k>int x = 0;</k>)condition(e.g <k>while(x &lt;= 10)</k>)Variable increment or decrement ( <k>x++</k> or <k>x--</k> or <k>x = x + 2</k> )<b>Syntax of <k>while</k> Loop:</b>
<k>variable initialization;
while(condition)
{
    statements;
    variable increment or decrement; 
}</k>
The following flowchart shows the flow of execution when we use a <k>while</k> loop.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1655986763-131495.jpg" src="LAZY_IMG_PLACEHOLDER">
Here, we can see that firstly, we initialize our iterator. 
Then we check the condition of <k>while</k> loop. 
If it is <b>false</b>, we exit the loop and if it is <b>true</b>, we enter the loop. 
After entering the loop, we execute the statements inside the <k>while</k> loop, update the iterator and then again check the condition. 
We do the same thing unless the condition is <b>false</b>.
<b>Program to print your name n times using <k>while</k> loop</b>
In this program we will use the <k>while</k> looop to print a word a given number of time.
<k>#include &lt;stdio.h>
int main()
{
    int n;
    printf("Enter the number of times you want to print your name:");
    scanf("%d", &amp;n);
    char name[30];
    printf("Enter your name:");
    scanf("%s", name);
    while(n) {    
        //here we are checking if n is non-zero
        printf("%s\n", name);
        n--;    //decrementing n
    }
    return 0;
}</k>

Enter the number of times you want to print your name:3
Enter your name:studytonight
studytonight
studytonight
studytonight
<a href="https://www.studytonight.com/code/playground/c/?id=YCTBpM" target="_blank">Run Code ยกรบ</a>
Let's dry run of the above code:
Firstly, we input <b>n = 3</b>, then <b>name = studytonight?</b>.
Now, we reach the <k>while</k> loop so we check the condition; n = 3, which is nonzero, so we enter the loop. 
We execute the <k>printf()</k> statement and print name on the console and then decrement <k>n</k>, so now n = 2. 
We again check the condition; n = 2, which is nonzero, so we enter the loop and print name and decrement <k>n</k>. 
Now n = 1. 
We check the condition again; n is 1 which is nonzero so we again enter the loop and execute the statements. 
Now we have <b>n = 0</b>. 
We check the condition; n is zero now so we don't enter the loop. 
We exit the loop and start executing the statements after it.
Let's see another example.
<b>Program to print first 10 natural numbers using <k>while</k> loop</b>
<k>#include&lt;stdio.h>
void main( )
{
    int x;
    x = 1;
    while(x &lt;= 10)
    {
        printf("%d\t", x);
        /* below statement means, do x = x+1, increment x by 1 */
        x++;
    }
}</k>

1 2 3 4 5 6 7 8 9 10
<h2>&emsp;<k>for</k> loop in C</h2>
The <k>for</k> loop in C is used to execute a set of statements repeatedly until a particular condition is satisfied. 
We can say it is an <b>open ended loop</b>. 
General format is,
<k>for(initialization; condition; increment/decrement)
{
    statement-block;
}</k>
In the <k>for</k> loop in C language, we have exactly two mandatory semicolons, one after <b>initialization</b> and second after the <b>condition</b>. 
In this loop we can have more than one initialization or increment/decrement as well, separated using comma operator. 
But it can have <b>only one condition</b>.
The <k>for</k> loop is executed as follows:

It first evaluates the initialization code.Then it checks the condition expression.If it is <b>true</b>, it executes the for-loop body.Then it evaluate the increment/decrement condition and again follows from step 2.When the condition expression becomes <b>false</b>, it exits the loop.Following is a flowchart explaining how the <k>for</k> loop executes.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1655986728-131495.jpg" src="LAZY_IMG_PLACEHOLDER">
We first initialize our iterator. 
Then we check the condition of the loop. 
If it is <b>false</b>, we exit the loop and if it is <b>true</b>, we enter the loop. 
After entering the loop, we execute the statements inside the <k>for</k> loop, update the iterator and then again check the condition. 
We do the same thing unless the test condition returns <b>false</b>.
<b>Program to print your name n times using <k>for</k> loop</b>
<k>#include &lt;stdio.h>
int main()
{
   int n;
   printf("Enter the number of times you want to print your name:");
   scanf("%d", &amp;n);
   char name[25];
   printf("Enter your name:");
   scanf("%s", name);
   for(int i = 1; i &lt;= n; i++) {    //here we are checking if n is non-zero
       printf("%s\n", name);
   }
   return 0;
}</k>

Enter the number of times you want to print your name:4
Enter your name:studytonight
studytonight
studytonight
<a href="https://www.studytonight.com/code/playground/c/?id=ePUodD" target="_blank">Run Code ยกรบ</a>
Let's dry run of the above code:
Firstly, we input n = 3, then name = studytonight.
Now, we reach the <k>for</k> loop so we initialize <b>i</b> with 1. 
We check the condition; 1 &lt;= 3, so we enter the loop. 
We execute the <k>printf()</k> statement and print name on the console. 
We again reach the <k>for</k> loop. 
We increment <b>i</b> by 1; so now i = 2. 
We again check the condition; 2 &lt;= 3, so we enter the loop and print name. 
Now i is incremented again to 3. 
We check the condition again; 3 &lt;= 3, so we enter the loop and execute the statements. 
Now we have i = 4. 
We check the condition; 4 > 3, so we don't enter the loop. 
We exit the loop and start executing the statements after it.
<b>Program to print first 10 natural numbers using <k>for</k> loop</b>
<k>
#include&lt;stdio.h>
void main( )
{
    int x;
    for(x = 1; x &lt;= 10; x++)
    {
        printf("%d\t", x);
    }
}</k>

1 2 3 4 5 6 7 8 9 10
<h2>&emsp;Nested <k>for</k> loop in C</h2>
We can also have nested <k>for</k> loops, i.e one <k>for</k> loop inside another <k>for</k> loop in C language. 
This type of loop is generally used while working with multi-dimensional arrays. 
To learn more about arrays and how <k>for</k> loops are used in arrays, check out our tutorial on <a href="/c/arrays-in-c.php">arrays in C</a>. 
Basic syntax for nested <k>for</k> loop is,
<k>for(initialization; condition; increment/decrement)
{
    for(initialization; condition; increment/decrement)
    {
        statement ;
    }
}</k>
<b>Program to print half Pyramid of numbers using Nested loops</b>
<k>#include&lt;stdio.h>
void main( )
{
    int i, j;
    /* first for loop */
    for(i = 1; i &lt; 5; i++)
    {
        printf("\n");
        /* second for loop inside the first */
        for(j = i; j > 0; j--)
        {
            printf("%d", j);
        }
    }
}</k>
1
21
321
4321
54321
<h2>&emsp;<k>do while</k> loop in C</h2>
In some situations it is necessary to execute body of the loop once before testing the condition. 
Such situations can be handled with the help of <k>do-while</k> loop. 
The <k>do</k> statement evaluates the body of the loop first and at the end, the condition is checked using <k>while</k> statement. 
It means that the body of the loop will be executed at least once, even though the starting condition inside <k>while</k> is initialized to be <b>false</b>. 
General syntax is,
<k>do
{
    .....
    .....
}
while(condition)</k>
Remember that the semicolon at the end of do-while loop is mandatory. 
It denotes end of the loop.
Following is the flowchart for do-while loop:
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1655986675-131495.jpg" src="LAZY_IMG_PLACEHOLDER">
We initialize our iterator. 
Then we enter body of the do-while loop. 
We execute the statement and then reach the end. 
At the end, we check the condition of the loop. 
If it is <b>false</b>, we exit the loop and if it is <b>true</b>, we enter the loop. 
We keep repeating the same thing unless the condition turns <b>false</b>.
<b>Program to print your name N times using <k>do-while</k> loop</b>
<k>#include &lt;stdio.h>
int main()
{
    int n;
    printf("Enter the number of times you want to print your name:");
    scanf("%d", &amp;n);
    char name[25];
    printf("\nEnter your name:");
    scanf("%s", name);
    do{
        printf("%s\n", name);
        n--;
    }while(n &lt; 0);
    return 0;
}</k>

Enter the number of times you want to print your name: 10
Enter your name: studytonight
studytonight
<a href="https://www.studytonight.com/code/playground/c/?id=7AKXhy" target="_blank">Run Code ยกรบ</a>
Dry run of the above code:
Firstly, we input n = 10, then name = studytonight.
Now, we enter the do-while loop because we check the condition only at the end. 
When we reach the end, we check the condition; n = 10, which is greater than zero, so we exit the loop and start executing the statements after it. 
Here we can see that even if the condition was always <b>false</b>, the loop got executed once.
<b>Program to print first 10 multiples of 5 using <k>do-while</k> loop</b>
<k>#include&lt;stdio.h>
void main()
{
    int a, i;
    a = 5;
    i = 1;
    do
    {
        printf("%d\t", a*i);
        i++;
    } 
    while(i &lt;= 10);
}</k>

5 10 15 20 25 30 35 40 45 50
<h2>&emsp;Infinite Loops in C</h2>
We come across infinite loops in our code when the compiler does not know where to stop. 
It does not have an exit. 
This means that either there is no condition to be checked or the condition is incorrect. 
This is why an iterator is very important in our loops. 
And a proper condition that ends.
Let's see a few examples of infinite loops in C:
<k>#include &lt;stdio.h>
int main()
{
    for(int i = 0; ; i++)
        printf("Infinite loop\n");
    return 0;
}</k>
The above code has no condition in place, hence it will keep on executing.
<k>#include &lt;stdio.h>
int main()
{
    int i = 0;
    while(i == 0)
        printf("Infinite loop\n");
    return 0;
}</k>
In the code above, we are not changing the value on <k>i</k>, hence the condition in the <k>while</k> loop will never fail.
<k>#include &lt;stdio.h>
int main()
{
    do{
        printf("Infinite loop\n");
    } while(1);
    return 0;
}</k>
Another example, with a constant value as condition, which is always <b>true</b> hence the code will keep on executing.
<h2>&emsp;Jumping Out of Loops in C</h2>
Sometimes, while executing a loop, it becomes necessary to skip a part of the loop or to leave the loop as soon as certain condition becomes <b>true</b>. 
This is known as jumping out of loop.
<h2>&emsp;break statement in C</h2>
When <k>break</k> statement is encountered inside a loop, the loop is <b>immediately exited</b> and the program continues to execute with the statements after the loop.
<img class="lazy" data-src="https://static.studytonight.com/c/images/break-statement-in-loops.gif">
Let's see a code example,
<k>#include &lt;stdio.h>
int main()
{
   int n;
   printf("Enter the number of times you want to print your name:");
   scanf("%d", &amp;n);
   char name[25];
   printf("\nEnter your name:");
   scanf("%s", name);
   for(int i = 1; i &lt;= n; i++) {
        if(i % 5 == 0)
            break;
        printf("%s\n", name);
   }
   return 0;
}</k>

Enter the number of times you want to print your name:7
Enter your name:studytonight
studytonight
studytonight
studytonight
studytonight
In the above code, as soon as we find an index which is divisible by <b>5</b>, the loop breaks and control is shifted out of the loop.
<h2>&emsp;continue statement in C</h2> 
It causes the control to go directly to the test-condition and then continue the loop execution. 
On encountering <k>continue</k>, the execution leaves the current cycle of loop, and starts with the next cycle.
<img class="lazy" data-src="https://static.studytonight.com/c/images/continue-statement-in-loops.gif">
Let's see a code example,
<k>#include &lt;stdio.h>
int main()
{
   int n;
   printf("Enter the number of times you want to print your name:");
   scanf("%d", &amp;n);
   char name[25];
   printf("\nEnter your name:");
   scanf("%s", name);
   for(int i = 1; i &lt;= n; i++) {
        if(i % 2 == 0)
            continue;
        printf("%d : %s\n",i,name);
   }
   return 0;
}</k>

Enter the number of times you want to print your name:5
Enter your name:studytonight
1 : studytonight
3 : studytonight
5 : studytonight
In the above example, whenever we come across an even index, we move on to the next index because of the continue statement.
<h2>&emsp;Conclusion</h2>
In this tutorial, we have learned about <k>for</k>, <k>while</k> and <k>do-while</k> loops in C and why they are important, along with seeing them in action with multiple code examples. 
We also learnt about <k>break</k> and <k>continue</k> statements.
<h2><span class="orange">Arrays in C</span></h2>
In C language, <k>arrays</k> are referred to as structured <a href="datatype-in-c.php" target="_blank">data types</a>. 
An array is defined as <b>finite ordered collection of homogenous</b> data, stored in contiguous memory locations.
Here the words,

<b>finite</b> <i>means</i> data range must be defined.
<b>ordered</b> <i>means</i> data must be stored in continuous memory addresses.
<b>h&emsp;omogenous</b> <i>means</i> data must be of similar data type.<h2>Some uses of Arrays in C</h2>
Following are some usecases where using an array will make things simpler:
to store list of Employee or Student names,to store marks of students,or to store list of numbers or characters etc.Since arrays provide an easy way to represent data, it is classified amongst the <a href="introduction-to-data-structures.php">data structures</a> in C. 
Other data structures in c are <b>structure</b>, <b>lists</b>, <b>queues</b>, <b>trees</b> etc.
Array is a <b>linear data structure</b> which means that the elements in an array are stored in a continuous manner in the memory. 
This makes accessing the elements easier. 
Array elements are indexed in an order, starting from <b>0 to n-1</b>, where <b>n</b> is the size of the array.
Suppose we have a classroom of 50 students. 
Our array will consist of 50 elements with indexes from <b>0 to 49</b>, where one place will be there for every student's data.
Arrays can be <b>single</b> or <b>multi dimensional</b>. 
The number of dimensions in an array is equal to the number of indexing. 
A 2-D array (also called a matrix) has two indexes(one for row and other for column) and so on.
Arrays make our work easy because instead of declaring 100 variables, we can declare an array of size 100.
<h2>&emsp;Advantages of Arrays</h2>
In one go, we can initialise storage for more than one value. 
Because you can create an array of 10, 100 or 1000 values.
    They make accessing elements easier by providing random access. 
By random access we mean you can directly access any element in an array if you know its index.
    Sort&emsp;ing and searching operations are easy on arrays.<h2>Disadvantages of Arrays</h2>
Due to its fixed size, we cannot increase the size of an array during runtime. 
That means once you have created an array, then it's size cannot be changed.
    Inse&emsp;rtion and deletion of elements can be costly, in terms of time taken.<h2>Declaring Arrays in C</h2>
Like any other variable, arrays must be declared(created) before they are used. 
General form of array declaration is,
<k>data-type variable-name[size];</k>
Let's see some code example real quick,
<k>/* Example of array declaration */
char a[5];    /* char type value array */
float ar[9];  /* float type value array */
int arr[10];  /* int type value array */</k>
<img class="lazy" data-src="https://static.studytonight.com/c/images/array-declaraction-in-c.jpg">
In the code above, in the first line, <k>char</k> is the data type, <k>a</k> is the name of array and 5 is the size.
In the next line, <k>float</k> is the data type, <k>ar</k> is the name of the array and size of array is 9.
And in the last line of code, <k>int</k> is the data types, and <k>arr</k> is the name of the array and 10 is the size of array. 
It means array <k>arr</k> can only contain 10 elements of <k>int</k> type.
The <b>index</b> of an array starts from <k>0</k> to <b>size-1</b> i.e first element of any array will be stored at <k>arr[0]</k> address and the last element will be at <k>arr[size - 1]</k>.
<h2>&emsp;Initialization of Array in C</h2>
After an array is declared it must be initialized. 
Otherwise, it will contain <b>garbage</b> value(any random value). 
An array can be initialized at either <b>compile time</b> or at <b>runtime</b>. 
That means, either we can provide values to the array in the code itself, or we can add user input value into the array.
<h2>&emsp;Compile time Array initialization in C</h2>
Compile time initialization of array means we provide the value for the array in the code, when we create the array,
<k>data-type array-name[size] = { list of values };</k>
Let's see a few simple examples,
/* Here are a few examples */
int marks[4] = { 67, 87, 56, 77 };    // integer array initialization
float area[5] = { 23.4, 6.8, 5.5 };   // float array initialization
int marks[4] = { 67, 87, 56, 77, 59 };    // Compile time error
One important thing to remember is that when you will give more values(array elements) than the declared array size than the <b>compiler</b> will give an error.
<k>#include&lt;stdio.h>
void main()
{
    int i;
    int arr[] = {2, 3, 4};      // Compile time array initialization
    for(i = 0 ; i &lt; 3 ; i++) 
    {
        printf("%d\t",arr[i]);
    }
}</k>
2  3  4
<h2>&emsp;Runtime Array initialization in C</h2>
An array can also be initialized at runtime using <k>scanf()</k> function. 
This approach is usually used for initializing large arrays, or to initialize arrays with user specified values.
 
To input elements in an array, we can use a <k>for</k> loop or insert elements at a specific index.
For example, to insert element at specific index,
<k>scanf("%d", &amp;arr[3]); // will insert element at index 3, i.e. 
4th position</k>
Let's suppose we have an array <k>Arr</k> of <b>10 elements</b> of type <k>int</k>.
To <b>insert elements at each index</b>,
<k>for(int i = 0; i &lt; 10; i++)
    Arr[i] = i;</k>
Here <b>i</b> refers to the index of the elements, starting from <b>0</b> and ending at <b>9</b> which is less than 10. 
In each element, we store the value of its index.
To <b>insert elements at each index according to user</b>, we can do the following,
<k>for(int i = 0; i &lt; 10; i++)
    scanf("%d", &amp;Arr[i]);</k>
To <b>insert elements at alternate index</b>,
<k>for(int i = 0; i &lt; 10; i+=2)
    scanf("%d", &amp;Arr[i]);</k>
Notice that in the above example, we are incrementing <b>i</b> by 2 each time, <k>i+=2</k> means <b>i = i + 2</b>. 
So we input only even indexed elements like Arrr[0], Arr[2], and so on.
<h2>&emsp;Accessing Array elements in C</h2>
We already know how to access array elements. 
Yes, it is using the indexes. 
So let's see a few examples where we will print entire arrays or some specific values, etc.
To print all elements,
<k>for(int i = 0; i &lt; 10; i++)
    printf("%d", Arr[i]);</k>
To <b>access and print elements at specified index</b>,
<k>printf("%d", Arr[0]); //prints first element of the array
printf("%d", Arr[5]); //prints sixth element of the array</k>
To access elements at alternate index,
<k>for(int i = 0; i &lt; 10; i+=2)
    printf("%d", Arr[i]);</k>
If we try to access elements, on index which is more than the size of an array or less than 0, we won't get an error but we will get wrong output (some random garbage value).
<h2>&emsp;Array Programs in C</h2>
Let's see a few basic programs where we will be using arrays.
<h4>Calculate sum of all array elements</h4>
The following program is used to calculate the sum of all elements of an array.
<k>#include&lt;stdio.h>
void main(){
    int arr[5];
    printf("Enter array elements:"");
    for(int i = 0; i &lt; 5; i++)
        scanf("%d", &amp;arr[i]);
    printf("Array elements are:"");
    for(int i = 0; i &lt; 5; i++)
        printf("%d ", arr[i]);
    int sum = 0;
    for(int i = 0; i &lt; 5; i++)
        sum += arr[i];
    printf("Sum =%d", sum);
}</k>

Enter array elements:3 2 4 1 5
Array elements are:3 2 4 1 5
Sum =15
<h4>Copy data from one array to another</h4>
This program will copy all the elements of one array into another, we use a <k>for</k> loop.
<k>#include &lt;stdio.h>
int main()
{
    float arr1[5] = {1.5, 2.1, 3.7, 4.2, 5.5}, arr2[5];
    for(int i = 0; i &lt; 5; i++)
        arr2[i] = arr1[i];
    for(int i = 0; i &lt; 5; i++)
        printf("%d ", arr2[i]);
    return 0;
}</k>

1.5 2.1 3.7 4.2 5.5
If you were thinking that we can assign values from an array to another using an <b>assignment operator</b>, like we do in variables, <b>NO you can't</b>.
<k>Array1 = Array2;  // error</k>
We can also create boolean arrays in C. 
Unlike other data types, boolean arrays have only two values, i.e., true(1) and false(0).
Please note that in order to use bool, we use &lt;stdbool.h> header file in our code. 
Also, there is no format specifier for bool in C. 
We use <b>%d</b> for input/output.
Suppose a teacher wants to store the data of assignment submission of her class of 5 students. 
To do so, she makes use of a boolean array where she inputs "yes" or "no" corresponding to the respective roll numbers. 
Following is the code for this example.
<k>#include &lt;stdio.h>
#include &lt;stdbool.h>
int main()
{
    bool submitted[5] = {'0', '1', '1', '0', '1'};
    printf("Submission details are:\n");
    for(int i = 0; i &lt; 5; i++)
        printf("%d : %d\n",i + 1, submitted[i]);
    return 0;
}</k>

1 : 0
2 : 1
3 : 1
4 : 0
5 : 1
<h2>&emsp;Two dimensional Arrays</h2>
C language supports multidimensional arrays too. 
The simplest form of a multidimensional array is the two-dimensional array. 
Here, we have a row index and a column index. 
Both the row's and column's index begins from <b>0</b>.
Just like a single-dimensional array, we can do Compile time initialization of two dimensional arrays or runtime initialization of two dimensional arrays.
Two-dimensional arrays are declared as follows,
data-type array-name[row-size][column-size]
Please note and remember, the first <k>[]</k> holds row count and second <k>[]</k> holds column count.
<k>double arr[5][5];
int a[3][4];</k>
<img class="lazy" data-src="https://static.studytonight.com/c/images/two-dimensional-array.jpg">
<h2>&emsp;Compile-time initialization of a two dimensional Array</h2>
If you want to do Compile time initialization of two dimensional array, then here is an example,
<k>int arr[][3] = {
    {0,0,0},
    {1,1,1}
};
char a[][2] = {
{'a', 'b'},
{'c', 'd'}
};</k>
<b>Note:</b> We have not assigned any <b>row value</b> to our arrays in the above example. 
It means we can initialize any number of rows. 
But, we must always specify <b>number of columns</b>, else it will give a compile time error. 
Here, a <k>2*3</k> multi-dimensional matrix is created.
Let's see a few more examples,
<k>int arr1[2][2] = {1, 2, 3, 4}; // equivalent to {{1, 2},{3, 4}}
int arr2[2][3] = {1, 2, 3, 4}; // equivalent to {{1, 2, 3},{4}}
int arr3[2][4] = {1, 2, 3, 4}; // equivalent to {{1,2,3,4}}</k>
As you can see in the example above, first the values are stored in columns, and then if there is any extra value, it goes to next row.
<h2>&emsp;Runtime initialization of a two dimensional Array</h2>
Now let's see how we can initialize a two dimensional array at runtime.
<k>#include&lt;stdio.h>
void main()
{
    int arr[3][4];
    int i, j, k;
    printf("Enter array elements:\n");
    for(i = 0; i &lt; 3;i++)
    {
        for(j = 0; j &lt; 4; j++)
        {
            scanf("%d", &amp;arr[i][j]);
        }
    }
    for(i = 0; i &lt; 3; i++)
    {
        for(j = 0; j &lt; 4; j++)
        {
           printf("%d", arr[i][j]);
        }
    }
}</k>

Enter array elements:
1 2 3 4 5 6 7 8 9 10 11 12
1 2 3 4 5 6 7 8 9 10 11 12
Using the first <k>for</k> loop, we first access the row of the matrix(2D array) and in that particular row, we traverse each column using the inner <k>for</k> loop.
Understanding how we access elements in a 2-D array can be tricky. 
Let us suppose we have an array arr[2][3] with 2 rows and 3 columns.
We use <b>i</b> to access the rows of our matrix. 
In the outer loop(line 7), we initialize <b>i</b> as 0 which means we are accessing the first row currently. 
Now in this <k>for</k> loop, we have an inner loop(line 9) which iterates over <b>j</b> and is used to access columns. 
So for <b>i = 0</b> (the first row), we traverse across <b>j</b> (from 0 to 2). 
When we enter the inner loop, we have already fixed the value of <b>i</b> as 0 and now we iterate over <b>j</b> and keep incrementing the values.
So, we have <b>arr[0][0]</b>, then we increment <b>j</b> by 1 to access <b>arr[0][1]</b>, then <b>arr[0][2]</b>.
On line 12, we come out of the inner loop when <b>j = number of columns</b>. 
We check the condition of the outer loop. 
If <b>i = number of rows</b>, we exit the loop otherwise we enter it again with an incremented <b>i</b>. 
In the similar way, we access all elements of a matrix.
To <b>print the elements of different rows</b> in different lines,
<k>for(int i = 0; i &lt; 3; i++)
{
    for(int j = 0; j &lt; 4; j++)
    {
         printf("%d", arr[i][j]);
    }
    printf(ยกยฐ\nยกยฑ);
}</k>
<h2>&emsp;Using 2D Array in Program in C</h2>
Let's suppose we want to calculate the total marks of all students in a class. 
We can do it by using a matrix. 
Here, the number of rows will represent the number of students and the number of columns will represent the subjects.
So first we'll input marks for the first student in all 3 subjects, then the second and so on. 
We'll sum the marks rowwise and store it in a separate array.
<k>#include &lt;stdio.h>
int main()
{
     float marks[2][3], total[2];
     for(int i = 0; i &lt; 2; i++) {
         for(int j = 0; j &lt; 3; j++){
              scanf("%f", &amp;marks[i][j]);
         }  
     }
     for(int i = 0; i &lt; 2; i++) {
         float sum = 0;
         for(int j = 0; j &lt; 3; j++){
              sum += marks[i][j];
         }
         total[i] = sum;
     }
     for(int i = 0; i &lt; 2; i++)
         printf("%d : %f\n", i + 1, total[i]);
     return 0;
}</k>

1.2 2.3 4.5 6.7 7.8
1 : 8.000000
2 : 17.900002
Similarly, we can reverse an array, find out the maximum and minimum in an array and perform many other operations.
If you want to learn about string and char arrays, click <a href="https://www.studytonight.com/c/string-and-character-array.php">here</a>.
You can find more <a href="https://www.studytonight.com/c/programs/">programs for array in C</a> to practice.
<h2><span class="orange">String and Character Array</span></h2>
<b>String</b> is a sequence of characters that are treated as a single data item and terminated by a null character <k>'\0'</k>. 
Remember that the <a href="https://www.studytonight.com/c/overview-of-c" target="_blank">C language</a> does not support strings as a data type. 
A <b>string</b> is actually a one-dimensional array of characters in C language. 
These are often used to create meaningful and readable programs.
If you don't know what an array in C means, you can check the <a href="https://www.studytonight.com/c/arrays-in-c" target="_blank">C Array</a> tutorial to know about Array in the C language. 
Before proceeding further, check the following articles:
<a href="https://www.studytonight.com/c/types-of-function-calls.php">C Function Calls</a>
<a href="https://www.studytonight.com/c/variables-in-c.php">C Variables</a>
<a href="https://www.studytonight.com/c/datatype-in-c.php">C Datatypes</a>
<a href="https://www.studytonight.com/c/c-syntax.php">C Syntax Rules</a>
<b>For example:</b> The string "home" contains 5 characters including the <k>'\0'</k> character which is automatically added by the compiler at the end of the string.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613480979-79873.png">
<h2>&emsp;Declaring and Initializing a string variables:</h2>
<k>// valid
char name[13] = "StudyTonight";        
char name[10] = {'c','o','d','e','\0'};      
// Illegal
char ch[3] = "hello";    
char str[4];
str = "hello";  </k>
<h2>&emsp;String Input and Output:</h2>
    <b>%s</b> format specifier to read a string input from the terminal.
    But <a href="https://www.studytonight.com/c/c-input-output-function.php">scanf()</a> function, terminates its input on the first white space it encounters.
    <b>edit set conversion code %[..]</b> that can be used to read a line containing a variety of characters, including white spaces.
    The <k>gets()</k> function can also be used to read character string with white spaces
<k>char str[20];
printf("Enter a string");
scanf("%[^\n]", &amp;str); 
printf("%s", str);
</k>
<k>char text[20];
gets(text);
printf("%s", text);</k>
<h2>&emsp;String Handling Functions:</h2>
<a href="https://www.studytonight.com/c/overview-of-c" target="_blank">C language</a> supports a large number of string handling functions that can be used to carry out many of the string manipulations. 
These functions are packaged in the <b>string.h</b> library. 
Hence, you must include <b>string.h</b> header file in your programs to use these functions.
The following are the most commonly used string handling functions.
<table border="1" cellpadding="10" style="width:100%"><tbody>
<tr><th>Method</th>
            <th>Description</th>
        </tr>
<tr><td><k>strcat()</k></td>
            <td>It is used to concatenate(combine) two strings</td>
        </tr>
<tr><td><k>strlen()</k></td>
            <td>It is used to show the length of a string</td>
        </tr>
<tr><td><k><k>strrev()</k></k></td>
            <td>It is used to show the reverse of a string</td>
        </tr>
<tr><td><k>strcpy()</k></td>
            <td>Copies one string into another</td>
        </tr>
<tr><td><k>strcmp()</k></td>
            <td>It is used to compare two string</td>
        </tr>
</tbody></table>
<h2>&emsp;
<k>s&emsp;trcat()</k> function in C:</h2>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613479392-79873.png">
<h4>Syntax:</h4>
<k>strcat("hello", "world");</k>
<k>strcat()</k> will add the string <b>"world"</b> to <b>"hello"</b> i.e ouput = helloworld.
<h2>&emsp;
<k>s&emsp;trlen()</k> and <k>strcmp()</k> function:</h2>
<k>strlen()</k> will return the length of the string passed to it and <k>strcmp()</k> will return the ASCII difference between first unmatching character of two strings.
<k> int j = strlen("studytonight");
 int i=strcmp("study ", "tonight");
printf("%d %d",j,i);</k>

12 -1
<h2>&emsp;
<k>s&emsp;trcpy()</k> function:</h2>
It copies the second string argument to the first string argument.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613477914-79873.png">
<h4>Example of <k>strcpy()</k> function:</h4>
<k>#include&lt;stdio.h>
#include&lt;string.h>
int main()
{
    char s1[50], s2[50];
    strcpy(s1, "StudyTonight");     
    strcpy(s2, s1);     
    printf("%s\n", s2);
    return(0);
}</k>

StudyTonight
<h2>&emsp;
<k>s&emsp;trrev()</k> function:</h2>
It is used to reverse the given string expression.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613478610-79873.png">
<h4>Code snippet for <k>strrev()</k>:</h4>
<k>#include &lt;stdio.h>
int main()
{ 
    char s1[50]; 
  
    printf("Enter your string: "); 
    gets(s1);  
    printf("\nYour reverse string is: %s",strrev(s1)); 
    return(0); 
}</k>

Enter your string: studytonight
Your reverse string is: thginotyduts
<u><b>Related Tutorials:</b></u>
<a href="https://www.studytonight.com/c/arrays-in-c.php">C Array</a>
<a href="https://www.studytonight.com/c/user-defined-functions-in-c.php">C Functions</a>
<a href="https://www.studytonight.com/c/pointers-in-c.php">C Pointers</a>
<a href="https://www.studytonight.com/c/structures-in-c.php">C Structures</a>
<h2><span class="orange">Storage classes in C</span></h2>
In C language, each variable has a storage class which decides the following things:

<b>scope</b> i.e where the value of the variable would be available inside a program.
<b>default initial value</b> i.e if we do not explicitly initialize that variable, what will be its default initial value.
<b>lifetime</b> of that variable i.e for how long will that variable exist.The following storage classes are most oftenly used in C programming,

<b>A&emsp;utomatic variables</b><b>External variables</b><b>Static variables</b><b>Register variables</b>
<h2>Automatic variables: <k>auto</k></h2>
<b>Scope:</b> Variable defined with <k>auto</k> storage class are local to the function block inside which they are defined.
<b>Default Initial Value:</b> Any random value i.e garbage value.
  
<b>Lifetime:</b> Till the end of the function/method block where the variable is defined.
A variable declared inside a function without any storage class specification, is by default an <b>automatic variable</b>. 
They are created when a function is called and are destroyed <b>automatically</b> when the function's execution is completed. 
Automatic variables can also be called <b>local variables</b> because they are local to a function. 
By default they are assigned <b>garbage value</b> by the compiler.
 
<k>#include&lt;stdio.h>
void main()
{
    int detail;
    // or 
    auto int details;    //Both are same
}</k>
<h2>&emsp;External or Global variable</h2>
<b>Scope:</b> Global i.e everywhere in the program. 
These variables are not bound by any function, they are available everywhere.
<b>Default initial value:</b> 0(zero).
<b>Lifetime:</b> Till the program doesn't finish its execution, you can access global variables.
A variable that is declared outside any function is a <b>Global Variable</b>. 
Global variables remain available throughout the program execution. 
By default, initial value of the Global variable is 0(zero). 
One important thing to remember about global variable is that their values can be changed by any function in the program.
<k>#include&lt;stdio.h>
int number;     // global variable
void main()
{
    number = 10;
    printf("I am in main function. 
My value is %d\n", number);
    fun1();     //function calling, discussed in next topic
    fun2();     //function calling, discussed in next topic
}
/* This is function 1 */
fun1()
{
    number = 20;
    printf("I am in function fun1. 
My value is %d", number);
}
/* This is function 1 */
fun2()
{
    printf("\nI am in function fun2. 
My value is %d", number);
}</k>
I am in function main. 
My value is 10
I am in function fun1. 
My value is 20
I am in function fun2. 
My value is 20
Here the global variable <k>number</k> is available to all three functions and thus, if one function changes the value of the variable, it gets changed in every function.
<b>Note:</b> Declaring the storage class as global or external for all the variables in a program can waste a lot of memory space because these variables have a lifetime till the end of the program. 
Thus, variables, which are not needed till the end of the program, will still occupy the memory and thus, memory will be wasted.
<h2>&emsp;
<k>e&emsp;xtern</k> keyword</h2>
The <k>extern</k> keyword is used with a variable to inform the compiler that this variable is declared somewhere else. 
The <k>extern</k> declaration does not allocate storage for variables.
<img class="lazy" data-src="https://static.studytonight.com/c/images/extern-keyword-in-c.gif">
<h4>Problem when extern is not used</h4>
<k>int main()
{
    a = 10;     //Error: cannot find definition of variable 'a'
    printf("%d", a);    
}</k>
<h4>Example using extern in same file</h4>
<k>int main()
{
    extern int x;   //informs the compiler that it is defined somewhere else
    x = 10;      
    printf("%d", x);    
}
int x;      //Global variable x</k>
<h2>&emsp;Static variables</h2>
<b>Scope:</b> Local to the block in which the variable is defined
<b>Default initial value:</b> 0(Zero).
<b>Lifetime:</b> Till the whole program doesn't finish its execution.
A <k>static</k> variable tells the compiler to persist/save the variable until the end of program. 
Instead of creating and destroying a variable every time when it comes into and goes out of scope, <k>static</k> variable is initialized only once and remains into existence till the end of the program. 
A <k>static</k> variable can either be internal or external depending upon the place of declaration. 
Scope of <b>internal static</b> variable remains inside the function in which it is defined. 
<b>External static</b> variables remain restricted to scope of file in which they are declared.
They are assigned <b>0 (zero)</b> as default value by the compiler.
<k>#include&lt;stdio.h>
void test();    //Function declaration (discussed in next topic)
 
int main()
{
    test();
    test();
    test();
}
void test()
{
    static int a = 0;       //a static variable
    a = a + 1;
    printf("%d\t",a);
}</k>
1  2  3
<h2>&emsp;Register variable</h2>
<b>Scope:</b> Local to the function in which it is declared.
<b>Default initial value:</b> Any random value i.e garbage value
<b>Lifetime:</b> Till the end of function/method block, in which the variable is defined.
Register variables inform the compiler to store the variable in CPU register instead of memory. 
Register variables have faster accessibility than a normal variable. 
Generally, the frequently used variables are kept in registers. 
But only a few variables can be placed inside registers. 
One application of register storage class can be in using loops, where the variable gets used a number of times in the program, in a very short span of time.
<b>NOTE:</b> We can never get the address of such variables.
<b>Syntax :</b>
<k>register int number;</k>
<b>Note:</b> Even though we have declared the storage class of our variable <k>number</k> as register, we cannot surely say that the value of the variable would be stored in a register. 
This is because the number of registers in a CPU are limited. 
Also, CPU registers are meant to do a lot of important work. 
Thus, sometimes they may not be free. 
In such scenario, the variable works as if its storage class is <k>auto</k>.
<h2>&emsp;Which storage class should be used and when</h2>
To improve the speed of execution of the program and to carefully use the memory space occupied by the variables, following points should be kept in mind while using storage classes:
We should use <k>static</k> storage class only when we want the value of the variable to remain same every time we call it using different function calls.We should use <k>register</k> storage class only for those variables that are used in our program very oftenly. 
CPU registers are limited and thus should be used carefully.We should use external or global storage class only for those variables that are being used by almost all the functions in the program.If we do not have the purpose of any of the above mentioned storage classes, then we should use the automatic storage class.
<h2><span class="orange">Functions in C</span></h2>
A <b>function</b> is a block of code that performs a particular task.
 
There are many situations where we might need to write same line of code for more than once in a program. 
This may lead to unnecessary repetition of code, bugs and even becomes boring for the programmer. 
So, C language provides an approach in which you can declare and define a group of statements once in the form of a function and it can be called and used whenever required.
These functions defined by the user are also know as <b>User-defined Functions</b>
C functions can be classified into two categories,

<b>Library functions</b> 
<b>User-defined functions</b><img class="lazy" data-src="https://static.studytonight.com/c/images/types-of-function-in-c.gif">
<b>Library functions</b> are those functions which are already defined in C library, example <k>printf()</k>, <k>scanf()</k>, <k>strcat()</k> etc. 
You just need to include appropriate header files to use these functions. 
These are already declared and defined in C libraries.
A <b>User-defined functions</b> on the other hand, are those functions which are defined by the user at the time of writing program. 
These functions are made for code reusability and for saving time and space.
<h2>&emsp;Benefits of Using Functions</h2>

It provides modularity to your program's structure.It makes your code reusable. 
You &emsp;just have to call the function by its name to use it, wherever required.In case of large programs with thousands of code lines, debugging and editing becomes easier if you use functions.It makes the program more readable and easy to understand.<h2>Function Declaration</h2>
General syntax for function declaration is,
<k>returntype functionName(type1 parameter1, type2 parameter2,...);</k>
Like any variable or an array, a function must also be declared before its used. 
Function declaration informs the compiler about the function name, parameters is accept, and its return type. 
The actual body of the function can be defined separately. 
It's also called as <b>Function Prototyping</b>. 
Function declaration consists of 4 parts.
returntypefunction nameparameter listterminating semicolon<h4>returntype</h4> 
When a function is declared to perform some sort of calculation or any operation and is expected to provide with some result at the end, in such cases, a <k>return</k> statement is added at the end of function body. 
Return type specifies the type of value(<k>int</k>, <k>float</k>, <k>char</k>, <k>double</k>) that function is expected to return to the program which called the function.
<b>Note:</b> In case your function doesn't return any value, the return type would be <k>void</k>.
<h4>functionName</h4>  
Function name is an <a href="/c/keywords-and-identifier.php" target="_blank">identifier</a> and it specifies the name of the function. 
The function name is any valid C identifier and therefore must follow the same naming rules like other variables in C language.
<h4>parameter list</h4>
The parameter list declares the type and number of arguments that the function expects when it is called. 
Also, the parameters in the parameter list receives the argument values when the function is called. 
They are often referred as <b>formal parameters</b>.
<h2>&emsp;Time for an Example</h2>
Let's write a simple program with a <k>main()</k> function, and a user defined function to multiply two numbers, which will be called from the <k>main()</k> function.
<k>#include&lt;stdio.h>
int multiply(int a, int b);     // function declaration
int main() 
{
    int i, j, result;
    printf("Please enter 2 numbers you want to multiply...");
    scanf("%d%d", &amp;i, &amp;j);
    result = multiply(i, j);        // function call
    printf("The result of muliplication is: %d", result);
    return 0;
}
int multiply(int a, int b)
{
    return (a*b);       // function defintion, this can be done in one line
}</k>
<h2>&emsp;Function definition Syntax</h2>
Just like in the example above, the general syntax of function definition is,
<k>returntype functionName(type1 parameter1, type2 parameter2,...)
{
    // function body goes here
}</k>
The first line <i>returntype</i> <b>functionName(type1 parameter1, type2 parameter2,...)</b> is known as <b>function header</b> and the statement(s) within curly braces is called <b>function body</b>.
<b>Note:</b> While defining a function, there is no semicolon(<k>;</k>) after the parenthesis in the function header, unlike while declaring the function or calling the function.
<h4>functionbody</h4> 
The function body contains the declarations and the statements(algorithm) necessary for performing the required task. 
The body is enclosed within curly braces <k>{ ... 
}</k> and consists of three parts.

<b>local</b> variable declaration(if required).
<b>f&emsp;unction statements</b> to perform the task inside the function.a <b>return</b> statement to return the result evaluated by the function(if return type is <k>void</k>, then no return statement is required).<h2>Calling a function</h2>
When a function is called, control of the program gets transferred to the function.
<k>functionName(argument1, argument2,...);</k>
In the example above, the statement <k>multiply(i, j);</k> inside the <k>main()</k> function is function call.
<h2>&emsp;Passing Arguments to a function</h2>
Arguments are the values specified during the function call, for which the formal parameters are declared while defining the function.
<img class="lazy" data-src="https://static.studytonight.com/c/images/functions-and-arguments.gif">
It is possible to have a function with parameters but no return type. 
It is not necessary, that if a function accepts parameter(s), it must return a result too.
<img class="lazy" data-src="https://static.studytonight.com/c/images/passing-argument-c-functions.jpg">
While declaring the function, we have declared two parameters <k>a</k> and <k>b</k> of type <k>int</k>. 
Therefore, while calling that function, we need to pass two arguments, else we will get compilation error. 
And the two arguments passed should be received in the function definition, which means that the function header in the function definition should have the two parameters to hold the argument values. 
These received arguments are also known as <b>formal parameters</b>. 
The name of the variables while declaring, calling and defining a function can be different.
<h2>&emsp;Returning a value from function</h2>
A function may or may not return a result. 
But if it does, we must use the <k>return</k> statement to output the result. 
<k>return</k> statement also ends the function execution, hence it must be the last statement of any function. 
If you write any statement after the <k>return</k> statement, it won't be executed.
<img class="lazy" data-src="https://static.studytonight.com/c/images/return-statement-c-functions.jpg">
The datatype of the value returned using the <k>return</k> statement should be same as the return type mentioned at function declaration and definition. 
If any of it mismatches, you will get compilation error.
In the next tutorial, we will learn about the different types of user defined functions in C language and the concept of Nesting of functions which is used in recursion.
<h2><span class="orange">Type of User-defined Functions in C</span></h2>
There can be 4 different types of user-defined <a href="user-defined-functions-in-c.php" target="_blank">functions</a>, they are:

Function with no arguments and no return value
    Function with no arguments and a return value
    Function with arguments and no return value
    Function with arguments and a return valueBelow, we will discuss about all these types, along with program examples.
<h2>&emsp;Function with no arguments and no return value</h2>
Such functions can either be used to display information or they are completely dependent on user inputs.
Below is an example of a function, which takes 2 numbers as input from user, and display which is the greater number.
<k>#include&lt;stdio.h>
void greatNum();       // function declaration
int main()
{
    greatNum();        // function call
    return 0;
}
void greatNum()        // function definition
{
    int i, j;
    printf("Enter 2 numbers that you want to compare...");
    scanf("%d%d", &amp;i, &amp;j);
    if(i > j) {
        printf("The greater number is: %d", i);
    }
    else {
        printf("The greater number is: %d", j);
    }
}</k>
<h2>&emsp;Function with no arguments and a return value</h2>
We have modified the above example to make the function <k>greatNum()</k> return the number which is greater amongst the 2 input numbers.
<k>#include&lt;stdio.h>
int greatNum();       // function declaration
int main()
{
    int result;
    result = greatNum();        // function call
    printf("The greater number is: %d", result);
    return 0;
}
int greatNum()        // function definition
{
    int i, j, greaterNum;
    printf("Enter 2 numbers that you want to compare...");
    scanf("%d%d", &amp;i, &amp;j);
    if(i > j) {
        greaterNum = i;
    }
    else {
        greaterNum = j;
    }
    // returning the result
    return greaterNum;
}</k>
<h2>&emsp;Function with arguments and no return value</h2>
We are using the same function as example again and again, to demonstrate that to solve a problem there can be many different ways.
This time, we have modified the above example to make the function <k>greatNum()</k> take two <k>int</k> values as arguments, but it will not be returning anything.
<k>#include&lt;stdio.h>
void greatNum(int a, int b);       // function declaration
int main()
{
    int i, j;
    printf("Enter 2 numbers that you want to compare...");
    scanf("%d%d", &amp;i, &amp;j);
    greatNum(i, j);        // function call
    return 0;
}
void greatNum(int x, int y)        // function definition
{
    if(x > y) {
        printf("The greater number is: %d", x);
    }
    else {
        printf("The greater number is: %d", y);
    }
}</k>
<h2>&emsp;Function with arguments and a return value</h2>
This is the best type, as this makes the function completely independent of inputs and outputs, and only the logic is defined inside the function body.
<k>#include&lt;stdio.h>
int greatNum(int a, int b);       // function declaration
int main()
{
    int i, j, result;
    printf("Enter 2 numbers that you want to compare...");
    scanf("%d%d", &amp;i, &amp;j);
    result = greatNum(i, j); // function call
    printf("The greater number is: %d", result);
    return 0;
}
int greatNum(int x, int y)        // function definition
{
    if(x > y) {
        return x;
    }
    else {
        return y;
    }
}</k>
<h2>&emsp;Nesting of Functions</h2>
C language also allows nesting of functions i.e to use/call one function inside another function's body. 
We must be careful while using nested functions, because it may lead to infinite nesting.
<k>
function1()
{
    // function1 body here
    function2();
    // function1 body here
}</k>
If function2() also has a call for function1() inside it, then in that case, it will lead to an infinite nesting. 
They will keep calling each other and the program will never terminate.
Not able to understand? Lets consider that inside the <k>main()</k> function, function1() is called and its execution starts, then inside function1(), we have a call for function2(), so the control of program will go to the function2(). 
But as function2() also has a call to function1() in its body, it will call function1(), which will again call function2(), and this will go on for infinite times, until you forcefully exit from program execution.
<h2>&emsp;What is Recursion?</h2>
Recursion is a special way of nesting functions, where a function calls itself inside it. 
We must have certain conditions in the function to break out of the recursion, otherwise recursion will occur infinite times.
<k>function1()
{   
    // function1 body
    function1();
    // function1 body
}</k><h4>Example: Factorial of a number using Recursion</h4>
<k>#include&lt;stdio.h>
int factorial(int x);       //declaring the function
void main()
{
    int a, b;
    printf("Enter a number...");
    scanf("%d", &amp;a);
    b = factorial(a);       //calling the function named factorial
    printf("%d", b);
}
int factorial(int x) //defining the function
{
    int r = 1;
    if(x == 1) 
        return 1;
    else 
        r = x*factorial(x-1);       //recursion, since the function calls itself
    return r;
}</k>
Similarly, there are many more applications of recursion in C language. 
Go to the <a href="programs/" target="_blank">programs section</a>, to find out more programs using recursion.
Now that we have learned about the Stack in Data Structure, you can also check out these topics:
<a href="types-of-function-calls.php" target="_blank">Types of Function calls</a>
<a href="array-in-function-in-c.php" target="_blank">Passing Array to function</a>
<h2><span class="orange">Types of Function calls in C</span></h2>
<a href="user-defined-functions-in-c.php" target="_blank">Functions </a> are called by their names, we all know that, then what is this tutorial for? Well if the function does not have any arguments, then to call a function you can directly use its name. 
But for functions with arguments, we can call a function in two different ways, based on how we specify the arguments, and these two ways are:

Call&emsp; by ValueCall by Reference<h2>Call by Value</h2>
Calling a function by value means, we pass the values of the arguments which are stored or copied into the formal parameters of the function. 
Hence, the original values are unchanged only the parameters inside the function changes. 

<k>#include&lt;stdio.h>
void calc(int x);
int main()
{
    int x = 10;
    calc(x);
    // this will print the value of 'x'
    printf("\nvalue of x in main is %d", x);
    return 0;
}
void calc(int x)
{
    // changing the value of 'x'
    x = x + 10 ;
    printf("value of x in calc function is %d ", x);
}</k>
value of x in calc function is 20
value of x in main is 10
In this case, the actual <a href="variables-in-c.php" target="_blank">variable</a> <k>x</k> is not changed. 
This is because we are passing the argument by value, hence a copy of <k>x</k> is passed to the function, which is updated during function execution, and that copied value in the function is destroyed when the function ends(goes out of scope). 
So the variable <k>x</k> inside the <k>main()</k> function is never changed and hence, still holds a value of <k>10</k>.
But we can change this program to let the function modify the original <k>x</k> variable, by making the function <k>calc()</k> return a value, and storing that value in x.
<k>#include&lt;stdio.h>
int calc(int x);
int main()
{
    int x = 10;
    x = calc(x);
    printf("value of x is %d", x);
    return 0;
}
int calc(int x)
{
    x = x + 10 ;
    return x;
}</k>
value of x is 20
<h2>&emsp;Call by Reference</h2>
In call by reference we pass the address(reference) of a variable as argument to any function. 
When we pass the address of any variable as argument, then the function will have access to our variable, as it now knows where it is stored and hence can easily update its value.
 
In this case the formal parameter can be taken as a <b>reference</b> or a <b><a href="pointers-in-c.php" target="_blank">pointers </a></b>(don't worry about pointers, we will soon learn about them), in both the cases they will change the values of the original variable. 

<k>#include&lt;stdio.h>
void calc(int *p);      // functin taking pointer as argument
int main()
{
    int x = 10;
    calc(&amp;x);       // passing address of 'x' as argument
    printf("value of x is %d", x);
    return(0);
}
void calc(int *p)       //receiving the address in a reference pointer variable
{
    /*
        changing the value directly that is 
        stored at the address passed
    */
    *p = *p + 10; 
}</k>
value of x is 20
<b>NOTE:</b> If you do not have any prior knowledge of pointers, do study <a href="pointers-in-c.php" target="_blank">Pointers</a> first. 
Or just go over this topic and come back again to revise this, once you have learned about pointers.
<h2><span class="orange">How to pass Array to a Function in C</span></h2>
Whenever we need to pass a list of elements as argument to any <a href="user-defined-functions-in-c.php" target="_blank">functions</a> in C language, it is prefered to do so using an <k>array</k>. 
But how can we pass an array as argument to a function? Let's see how its done.
<h2>&emsp;Declaring Function with array as a parameter</h2>
There are two possible ways to do so, one by using call by value and other by using call by reference.

We can either have an <a href="arrays-in-c.php" target="_blank">array</a> as a parameter.
<k>int sum (int arr[]);</k>
Or, we can have a <a href="pointers-in-c.php" target="_blank">pointers</a> in the parameter list, to hold the base address of our array.
<k>int sum (int* ptr);</k>
We will study the second way in details later when we will study pointers.
<h2>&emsp;Returning an Array from a function</h2>
We don't return an array from functions, rather we return a pointer holding the base address of the array to be returned. 
But we must, make sure that the array exists after the function ends i.e. 
the array is not local to the function.
<k>int* sum (int x[])
{
    // statements
    return x ;
}</k>
We will discuss about this when we will study pointers with arrays.
<h2>&emsp;Passing arrays as parameter to function</h2>
Now let's see a few examples where we will pass a single array element as argument to a function, a one dimensional array to a function and a multidimensional array to a function.
<h4>Passing a single array element to a function</h4>
Let's write a very simple program, where we will declare and define an array of integers in our <k>main()</k> function and pass one of the array element to a function, which will just print the value of the element.
<k>#include&lt;stdio.h>
void giveMeArray(int a);
int main()
{
    int myArray[] = { 2, 3, 4 };
    giveMeArray(myArray[2]);        //Passing array element myArray[2] only.
    return 0;
}
void giveMeArray(int a)
{
    printf("%d", a);
}</k>
4
<h4>Passing a complete One-dimensional array to a function</h4>
To understand how this is done, let's write a function to find out average of all the elements of the array and print it.
We will only send in the name of the array as argument, which is nothing but the address of the starting element of the array, or we can say the starting memory address.
<k>#include&lt;stdio.h>
float findAverage(int marks[]);
int main()
{
    float avg;
    int marks[] = {99, 90, 96, 93, 95};
    avg = findAverage(marks);       // name of the array is passed as argument.
    printf("Average marks = %.1f", avg);
    return 0;
}
float findAverage(int marks[])
{
    int i, sum = 0;
    float avg;
    for (i = 0; i &lt;= 4; i++) {
        sum += marks[i];
    }
    avg = (sum / 5);
    return avg;
}</k>
94.6
<h4>Passing a Multi-dimensional array to a function</h4>
Here again, we will only pass the name of the array as argument.
<k>#include&lt;stdio.h>
void displayArray(int arr[3][3]);
int main()
{
    int arr[3][3], i, j;
    printf("Please enter 9 numbers for the array: \n");
    for (i = 0; i &lt; 3; ++i)
    {
        for (j = 0; j &lt; 3; ++j)
        {    
            scanf("%d", &amp;arr[i][j]);
        }
    }
    // passing the array as argument
    displayArray(arr);
    return 0;
}
void displayArray(int arr[3][3])
{
    int i, j;
    printf("The complete array is: \n");
    for (i = 0; i &lt; 3; ++i)
    {
        // getting cursor to new line
        printf("\n");
        for (j = 0; j &lt; 3; ++j)
        {       
            // \t is used to provide tab space
            printf("%d\t", arr[i][j]);
        }
    }
}</k>
Please enter 9 numbers for the array:
1
2
3
4
5
6
7
8
9
The complete array is:
1   2   3
4   5   6
7   8   9
<h2><span class="orange">C Structures</span></h2>
Structure is a user-defined datatype in <a href="overview-of-c.php" target="_blank">C language</a> which allows us to combine data of different types together. 
Structure helps to construct a complex data type which is more meaningful. 
It is somewhat similar to an <a href="arrays-in-c.php" target="_blank">Array</a>, but an array holds data of similar type only. 
But structure on the other hand, can store data of any type, which is practical more useful.
<b>For example:</b> If I have to write a program to store Student information, which will have Student's name, age, branch, permanent address, father's name etc, which included string values, integer values etc, how can I use arrays for this problem, I will require something which can hold data of different types together.
In structure, data is stored in form of <b>records</b>.
<h2>&emsp;Defining a structure</h2>
<k>struct</k> keyword is used to define a structure. 
<k>struct</k> defines a new data type which is a collection of primary and derived <a href="datatype-in-c.php" target="_blank">data types</a>.
<b>Syntax:</b>
<k>struct [structure_tag]
{
    //member variable 1
    //member variable 2
    //member variable 3
    ...
}[structure_variables];</k>
As you can see in the syntax above, we start with the <k>struct</k> keyword, then it's optional to provide your structure a name, we suggest you to give it a name, then inside the curly braces, we have to mention all the member variables, which are nothing but normal C language variables of different types like <k>int</k>, <k>float</k>, <k>array</k> etc.
After the closing curly brace, we can specify one or more structure variables, again this is optional.
<b>Note:</b> The closing curly brace in the structure type declaration must be followed by a semicolon(<k>;</k>).
<h2>&emsp;Example of Structure</h2>
<k>struct Student
{
    char name[25];
    int age;
    char branch[10];
    // F for female and M for male
    char gender;
};</k>
Here <k>struct Student</k> declares a structure to hold the details of a student which consists of 4 data fields, namely <k>name</k>, <k>age</k>, <k>branch</k> and <k>gender</k>. 
These fields are called <b>structure elements or members</b>.
 
Each member can have different datatype, like in this case, <k>name</k> is an array of <k>char</k> type and <k>age</k> is of <k>int</k> type etc. 
<b>Student</b> is the name of the structure and is called as the <b>structure tag</b>.
<h2>&emsp;Declaring Structure Variables</h2>
It is possible to declare variables of a <b>structure</b>, either along with structure definition or after the structure is defined. 
<b>Structure</b> <a href="variables-in-c.php" target="_blank">variable</a> declaration is similar to the declaration of any normal variable of any other datatype. 
Structure variables can be declared in following two ways:
<h4>Declaring Structure variables separately</h4>
<k>struct Student
{
    char name[25];
    int age;
    char branch[10];
    //F for female and M for male
    char gender;
};
struct Student S1, S2;      //declaring variables of struct Student</k><h4>Declaring Structure variables with structure definition</h4>
<k>struct <b>Student</b>
{
    char name[25];
    int age;
    char branch[10];
    //F for female and M for male
    char gender;
}S1, S2;</k>
Here <k>S1</k> and <k>S2</k> are variables of structure <k>Student</k>. 
However this approach is not much recommended.
<h2>&emsp;Accessing Structure Members</h2>
Structure members can be accessed and assigned values in a number of ways. 
Structure members have no meaning individually without the structure. 
In order to assign a value to any structure member, the member name must be linked with the <b>structure</b> variable using a dot <k>.</k> operator also called <b>period</b> or <b>member access</b> operator.
<b>For example:</b>
<k>#include&lt;stdio.h>
#include&lt;string.h>
struct Student
{
    char name[25];
    int age;
    char branch[10];
    //F for female and M for male
    char gender;
};
int main()
{
    struct Student s1;
    /*
        s1 is a variable of Student type and 
        age is a member of Student
    */
    s1.age = 18;
    /*
        using string function to add name
    */
    strcpy(s1.name, "Viraaj");
    /*
        displaying the stored values
    */
    printf("Name of Student 1: %s\n", s1.name);
    printf("Age of Student 1: %d\n", s1.age);
    return 0;
}</k>
Name of Student 1: Viraaj
Age of Student 1: 18
We can also use <k>scanf()</k> to give values to structure members through terminal.
<k>scanf(" %s ", s1.name);
scanf(" %d ", &amp;s1.age);</k>
<h2>&emsp;Structure Initialization</h2>
Like a variable of any other datatype, structure variable can also be initialized at compile time.
<k>struct <b>Patient</b>
{
    float height;
    int weight;  
    int age; 
};
struct Patient p1 = { 180.75 , 73, 23 };    //initialization</k>
or,
<k>struct Patient p1;
p1.height = 180.75;     //initialization of each member separately
p1.weight = 73;
p1.age = 23;</k>
<h2>Array of Structure</h2>
We can also declare an array of <b>structure</b> variables. 
in which each element of the <a href="arrays-in-c.php" target="_blank">array</a> will represent a <b>structure</b> variable. 
<b>Example :</b>  <k>struct employee emp[5];</k>
The below program defines an array <k>emp</k> of size 5. 
Each element of the array <k>emp</k> is of type <k>Employee</k>.
<k>#include&lt;stdio.h>
struct Employee
{
    char ename[10];
    int sal;
};
struct Employee emp[5];
int i, j;
void ask()
{
    for(i = 0; i &lt; 3; i++)
    {
        printf("\nEnter %dst Employee record:\n", i+1);
        printf("\nEmployee name:\t");
        scanf("%s", emp[i].ename);
        printf("\nEnter Salary:\t");
        scanf("%d", &amp;emp[i].sal);
    }
    printf("\nDisplaying Employee record:\n");
    for(i = 0; i &lt; 3; i++)
    {
        printf("\nEmployee name is %s", emp[i].ename);
        printf("\nSlary is %d", emp[i].sal);
    }
}
void main()
{
    ask();
}</k>
<h2>&emsp;Nested Structures</h2>
Nesting of structures, is also permitted in C language. 
Nested structures means, that one structure has another stucture as member <a href="variables-in-c.php" target="_blank">variable</a>.
<b>Example:</b>
<k>struct Student
{
    char[30] name;
    int age;
    /* here Address is a structure */
    struct Address
    {
        char[50] locality;
        char[50] city;
        int pincode;
    }addr;
};</k>
<h2>&emsp;Structure as Function Arguments</h2>
We can pass a structure as a function argument just like we pass any other variable or an array as a function argument.
<b>Example:</b>
<k>#include&lt;stdio.h>
struct Student
{
    char name[10];
    int roll;
};
void show(struct Student st);
void main()
{
    struct Student std;
    printf("\nEnter Student record:\n");
    printf("\nStudent name:\t");
    scanf("%s", std.name);
    printf("\nEnter Student rollno.:\t");
    scanf("%d", &amp;std.roll);
    show(std);
}
void show(struct Student st)
{
    printf("\nstudent name is %s", st.name);
    printf("\nroll is %d", st.roll);
}</k>
<h2><span class="orange"><k>typedef</k> in C</h2>
<k>typedef</k> is a <a href="keywords-and-identifier.php" target="_blank">keyword</a> used in C language to assign alternative names to existing <a href="datatype-in-c.php" target="_blank">datatypes</a>. 
Its mostly used with user defined datatypes, when names of the datatypes become slightly complicated to use in programs. 
Following is the general syntax for using <k>typedef</k>,
<k>typedef &lt;existing_name> &lt;alias_name></k>
Lets take an example and see how <k>typedef</k> actually works.
<k>typedef unsigned long ulong;</k>
The above statement define a term <k>ulong</k> for an <k>unsigned long</k> datatype. 
Now this <k>ulong</k> identifier can be used to define <k>unsigned long</k> type variables.
<k>ulong i, j;</k>
<h2>Application of typedef</h2>
<k>typedef</k> can be used to give a name to user defined data type as well. 
Lets see its use with <a href="structures-in-c.php" target="_blank">structures</a>.
<k>
typedef struct
{
    type member1;
    type member2;
    type member3;
} type_name;</k>
Here <b>type_name</b> represents the stucture definition associated with it. 
Now this <b>type_name</b> can be used to declare a variable of this stucture type.
<k>type_name t1, t2;</k>
<h2>&emsp;Structure definition using typedef</h2>
Let's take a simple code example to understand how we can define a structure in C using <k>typedef</k> keyword.
<k>#include&lt;stdio.h>
#include&lt;string.h>
 
typedef struct employee
{
    char name[50];
    int salary;
}emp;
 
void main( )
{
    emp e1;
    printf("\nEnter Employee record:\n");
    printf("\nEmployee name:\t");
    scanf("%s", e1.name);
    printf("\nEnter Employee salary: \t");
    scanf("%d", &amp;e1.salary);
    printf("\nstudent name is %s", e1.name);
    printf("\nroll is %d", e1.salary);
}</k>
<h2>&emsp;
<k>t&emsp;ypedef</k> and Pointers</h2>
<k>typedef</k> can be used to give an alias name to <a href="pointers-in-c.php" target="_blank">pointers</a> also. 
Here we have a case in which use of <k>typedef</k> is beneficial during pointer declaration.
In Pointers <k>*</k> binds to the right and not on the left.
<k>int* x, y;</k>
By this declaration statement, we are actually declaring <k>x</k> as a pointer of type <k>int</k>, whereas <k>y</k> will be declared as a plain <k>int</k> variable.
<k>typedef int* IntPtr;
IntPtr x, y, z;</k>
But if we use <k>typedef</k> like we have used in the example above, we can declare any number of pointers in a single statement.
<b>NOTE:</b> If you do not have any prior knowledge of pointers, do study <a href="pointers-in-c.php" target="_blank">Pointers</a> first.
<h2><span class="orange">C Unions</span></h2>
<b>Unions</b> are conceptually similar to <b><a href="/c/structures-in-c.php">structures in C</a></b>. 
The syntax to declare/define a union is also similar to that of a structure. 
The only differences is in terms of <b>storage</b>. 
In <b>structure</b> each member has its own storage location, whereas all members of <b>union</b> uses a <b>single shared memory</b> location which is equal to the size of its largest data member.
 
<img class="lazy" data-src="https://static.studytonight.com/c/images/union-and-structure-storage-comparison.gif">
This implies that although a <b>union</b> may contain many members of different types, it <b>cannot handle all the members at the same time</b>.
 
<h2>&emsp;Declaring a Union in C</h2>
A <b>union</b> is declared using the <k>union</k> <a href="keywords-and-identifier.php">keyword in C</a>.
The <b>syntax</b> is as follows
<k>union tag_name {
   member definition;
   member definition;
   ...
   member definition;
} union variable(s); </k>
For example,
<k>union item
{
    int m;
    float x;
    char c;
} It1;</k>
This declares a variable <k>It1</k> of type <k>union</k> item. 
This <k>union</k> contains three members each with a different <a href="datatype-in-c.php">data type</a>. 
However only one of them can be used at a time. 
This is due to the fact that only one location is allocated for all the <k>union</k> variables, irrespective of their size. 
The compiler allocates the storage that is large enough to hold the largest variable type in the union.
 
In the union declared above the member <k>x</k> requires <b>4 bytes</b> which is largest amongst the members for a 16-bit machine. 
Other members of union will share the same memory address.
To define variables of a union, we use <k>union</k> keyword as follows:
<k>union item it2, it3;</k>
<h2>&emsp;Accessing a Union Member in C</h2>
We use <b>member access operator</b> (<k>.</k>) to access members of a union in C. 
It is used between the union variable name and the union member that we want to access. 
Syntax for accessing any union member is similar to accessing <a href="/c/structures-in-c.php">structure members</a>.
<k>union test
{
    int a;
    float b;
    char c;
}t;
t.a;    //to access members of union t
t.b;     
t.c;</k>
In unions, if we change the value of any one member, the value of other members gets affected.
<h2>&emsp;Using Union in C Program</h2>
Here is a program to understand how compiler decides size of a union:
<k>#include &lt;stdio.h>
  
union one {
    int x;
    char y;
} one1;
  
union two {
    int x;
    char y;
    long z;
} two2;
  
union three {
    int arr[100];
    char y;
    double d[5];
} three3;
  
int main()
{
    printf("sizeof(one) = %lu, sizeof(two) = %lu, sizeof(three) = %lu", sizeof(one1), sizeof(two2), sizeof(three3));
    return 0;
}</k>

sizeof(one) = 4, sizeof(two) = 8, sizeof(three) = 400
<a href="https://www.studytonight.com/code/playground/c/?id=BzuOEU" target="_blank">Run Code ยกรบ</a>
Let's see another code example,
<k>// defining and printing members of a union
#include &lt;stdio.h>
union item
{
    int a;
    float b;
    char ch;
};
int main( )
{
    union item it;
    it.a = 12;
    it.b = 20.2;
    it.ch = 'z';
    printf("%d\n", it.a);
    printf("%f\n", it.b);
    printf("%c\n", it.ch);
    return 0;
}</k>

1101109626
20.199940
z
We can also create an <b>array of <k>union</k> type</b> values. 
So let's see a code example,
<k>#include &lt;stdio.h>
union item
{
    int a;
    float b;
    char ch;
};
int main( )
{
    union item it[10];
    int n;
    printf("Enter the number of records:");
    scanf("%d", &amp;n);
    for(int i = 0; i &lt; n; i++) {
        printf("Enter record %d: ", i + 1);
        scanf("%d %f %c", &amp;it[i].a, &amp;it[i].b, &amp;it[i].ch);
    }
    for(int i = 0; i &lt; n; i++) {
        printf("\nRecord no. 
%d:\n", i + 1);
        printf("%d %f %c", it[i].a, it[i].b, it[i].ch);
    }
    return 0;
}</k>

Enter the number of records:2
Enter record 1: 1
3
a
Enter record 2: 2
4
d
Record no. 
1:
1077936225 3.000023 a
Record no. 
2:
1082130532 4.000048 d
As you can see here, the values of <k>int</k> and <k>float</k> get corrupted and only <k>char</k> variable prints the expected result. 
This is because in union, the memory is shared among different data types.
In the above example, value of the <k>char</k> variable was stored at last, hence the value of other variables is lost.
<h2>&emsp;Difference Between Structure and Union in C</h2>
In union, we can only initializa the first data member whereas in a structure, we can initialize many data members at once.
    Compiler allocates memory for each member of a structure while for a union, it allocates memory equal to the size of the largest data member.
    Union members share a memory location while structure members have a unique storage location each.
    In a structure, we can access individual members simultaneously while in a union, we can only access one member at a time.
    If w&emsp;e change the value of a member in a structure, it won't affect its other members but in a union, changing the value of one member will affect the others.<h2>Difference in the size of Structure and Union in C</h2>
Let's look at the following example to understand better.
<k>#include &lt;stdio.h>
  
struct one {
    int x;
    char y;
    long z;
} one1;
  
union two {
    int x;
    char y;
    long z;
} two2;
  
int main()
{
    printf("sizeof(struct) = %lu, sizeof(union) = %lu",sizeof(one1), sizeof(two2));
    return 0;
}</k>

sizeof(struct) = 16, sizeof(union) = 8
We can see that the size of structure is greater than the sum of size of its members while the size of union is equal to the size of its largest member. 
This is why there is a difference in the size of structure and union with exactly the same data members. 
Union members share memory while structure members have their own unique memory.
<h2><span class="orange">Introduction to C Pointers</span></h2>
A Pointer in C language is a variable that holds a memory address. 
This memory address is the address of another variable(mostly) of same <a href="datatype-in-c.php" target="_blank">data type</a>.
In simple words, if one variable stores the address of second variable then the first variable can be said to <b>point towards</b> the second variable.
Before we start understanding what pointers are and what they can do, let's start by understanding what does <b>"Address of a memory location"</b> means?
<h2>&emsp;What is a Memory Address in C?</h2>
Whenever a <a href="variables-in-c.php">variable</a> is defined in C language, a memory location is assigned for it, in which it's value gets stored. 
We can check this memory address, using the <k>&amp;</k> symbol.
If <k>var</k> is the name of the variable, then <k>&amp;var</k> will give it's address.
Let's write a small program to see memory address of any variable that we define in our program.
<k>#include&lt;stdio.h>
void main()
{
    int var = 7;
    printf("Value of the variable var is: %d\n", var);
    printf("Memory address of the variable var is: %x\n", &amp;var);
}</k>
Value of the variable var is: 7
Memory address of the variable var is: bcc7a00
Also while using the <k>scanf()</k> function, we mention <k>&amp;var</k> to take user input for any variable <k>var</k>.
<k>scanf("%d", &amp;var);</k>
This is used to store the user input value to the memory address of the variable <k>var</k>.
<h2>&emsp;What is a Pointer in C?</h2>
Like we mentioned earlier, a Pointer in C language is a variable that holds a memory address.
Pointers are used to access memory of a variable and manipulate the value stored in it.
Pointers are one of the most distinct and exciting features of C language. 
It provides power and flexibility to the language. 
Although pointers may appear a little confusing and complicated in the beginning, but trust me, once you understand the concept, you will be able to do so much more with C language.
Whenever a <b>variable</b> is declared in a program, system allocates a location i.e an address to that variable in the memory, to hold the assigned value. 
This location has its own address number, which we saw in the program above.
Let us assume that system has allocated memory location <k>80F</k> for a variable <k>a</k>.
<k>int a = 10;</k>
 
<img class="lazy" data-src="https://static.studytonight.com/c/images/variable-storage-in-c.gif">
We can access the value <k>10</k> either by using the variable name <k>a</k> or by using its address <k>80F</k>.
 
The question is how we can access a variable using it's address? Since the memory addresses are also just numbers, they can also be assigned to some other variable. 
The variables which are used to hold memory addresses are called <b>Pointer variables</b>.
 
A <b>pointer</b> variable is therefore nothing but a variable which holds an address of some other variable. 
And the value of a <b>pointer variable</b> gets stored in another memory location.
<img class="lazy" data-src="https://static.studytonight.com/c/images/pointer-to-variable.gif">
<h2>&emsp;Pointer Variable in C</h2>
Like we mentioned above that a pointer is also a variable, but with a little twist, that is, it only stores address of other variables.
So if you have to define a pointer variable, the syntax is a little different.
Following is the <b>syntax</b> for declaring a variable as a pointer:
<k>type *name;</k>
Here, <b>type</b> is the data type of the pointer, and the <b>name</b> is the name of the pointer variable.
And the <k>*</k> operator with the name, informs the compiler that the variable is a pointer.
The data type of the pointer variable should be the same as of the variable to which the pointer is pointing.
<h2>&emsp;Pointer Operators in C</h2>
There are two pointer operators in C, they are:


<k>*</k> operator
<k>&amp;</k> operatorWe have covered <a href="/c/operators-in-c.php">operators in C</a> in detail separately.
The <k>&amp;</k> operator returns the memory address of its operand. 
For example,
<k>a = &amp;b;</k>
In the variable <k>a</k> the memory address of the variable <k>b</k> will get stored.
The <k>*</k> operators is the complement of <k>&amp;</k>. 
Thiss operator returns the value located at the given address.
For example, if <k>a</k> contains the memory address of the variable <k>b</k>, then the code,
<k>c = *a;</k>
will store the value of the variable <k>b</k> into <k>c</k>.
<h2>&emsp;Pointers in C Example</h2>
Let's see a basic code example where we will create a pointer and assign it a value.
<k>#include&lt;stdio.h>
int main(void)
{
    int x = 99;
    // declare a pointer
    int *ptr;
    // assign value to pointer
    ptr = &amp;x;
    printf("Value at ptr is: %d \n", *ptr);
    printf("Address pointed by ptr is: %p \n", ptr);
    return 0;
}</k>

Value at ptr is: 99
Address pointed by ptr is: 0x7fff99c0e6c4
<a href="https://www.studytonight.com/code/playground/c/?id=NehD7r" target="_blank">Run Code ยกรบ</a>
The <k>%p</k> format specifier is used for pointer variable.
<h2>&emsp;Benefits of using pointers in C</h2>
Below we have listed a few benefits of using pointers:

Pointers are more efficient in handling <a href="/c/arrays-in-c.php">Arrays in C</a> and <a href="/c/structures-in-c.php">Structures in C</a>.Pointers allow references to function and thereby helps in passing of function as arguments to other functions.Pointers also provide means by which a <a href="/c/user-defined-functions-in-c.php">function in C</a> can change its calling arguments.It reduces length of the program and its execution time as well.It allows C language to support Dynamic Memory management.In the next tutorial we will learn syntax of pointers, how to declare and define a pointer, and using a pointer. 
See you in the next tutorial.
<h2><span class="orange">Using Pointers in C</span></h2>
In this tutorial, we will learn how to declare, initialize and use a <a href="https://www.studytonight.com/c/pointers-in-c.php">pointer in C language</a>.
Before you continue, check these topics out:
<a href="https://www.studytonight.com/c/pointers-in-c.php">Introduction to Pointers</a>
<a href="https://www.studytonight.com/c/arrays-in-c.php">C Arrays</a>
<a href="https://www.studytonight.com/c/loops-in-c.php">C Loops - <k>while</k>, <k>do while</k>, <k>for</k> loops</a>
<a href="https://www.studytonight.com/c/user-defined-functions-in-c.php">C Functions</a>
    A pointer is a variable used to store memory address. 
Hence, we have to declare and initialise(assign it a value) it just like any other variable. 
Pointers can be very useful in some use-cases, like:
They make accessing array elements easier.
    We can implement linked lists, trees, and graphs using pointers.
    We use pointers for accessing dynamically allocated memory.
    We can return more than one value from a function using pointers.So let's see how we can create pointers, assign values to pointers, perform pointer coversions, pointer arithmetic and pointer comparisons.
<h2>&emsp;Declaring a Pointer in C</h2>
The general syntax of pointer declaration is,
<k>type *pointer_name;</k>
Here, <b>pointer_name</b> is the name of the pointer and that should be a valid <a href="https://www.studytonight.com/c/keywords-and-identifier.php">C identifier</a>.
 
The <a href="https://www.studytonight.com/c/datatype-in-c.php">datatype</a> of the pointer and the <a href="https://www.studytonight.com/c/variables-in-c.php">variable</a> to which the pointer variable is pointing must be the same.
Following are some examples of declaring a pointer in C:
<k>int *ptr;     //pointer to int
float *ptr;   //pointer to float
char *ptr;    //pointer to char
double *ptr;  //pointer to double</k>
Just like a variable, pointer is declared in the same way, just with an additional pointer operator <k>*</k>.
<h2>&emsp;Assigning Value to a Pointer Variable</h2>
When we declare a pointer, it contains <b>garbage value</b>, which means it could be pointing anywhere in the memory. 
<b>Pointer Initialization</b> is the process of assigning the address of a variable to a pointer. 
In C language, the address operator <k>&amp;</k> is used to determine the address of a variable. 
The <k>&amp;</k> (immediately preceding a variable name) returns the address of the variable associated with it.
For example,
<k>#include&lt;stdio.h>
int main(void)
{
    int a = 10;
    // declare a pointer
    int *ptr;
    // assign value to pointer
    ptr = &amp;a;
    printf("Value at ptr is: %d \n", *ptr);
    printf("Address pointed by ptr is: %p \n", ptr);
    return 0;
}</k>

Value at ptr is: 10
Address pointed by ptr is: 0x7fff99c0e6c4
<a href="https://www.studytonight.com/code/playground/c/?id=NehD7r" target="_blank">Run Code ยกรบ</a>
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613545250-79873.png">
Pointer variables must always point to variables of the same datatype.
For example, if we have a <k>float</k> type variable and an <k>int</k> type pointer, then C compiler will give error.
<k>#include&lt;stdio.h>
int main(void)
{
    float a = 10;
    // declare a pointer
    int *ptr;
    // assign value to pointer
    ptr = &amp;a;
    printf("Value at ptr is: %d \n", *ptr);
    printf("Address pointed by ptr is: %p \n", ptr);
    return 0;
}</k>

warning: assignment from incompatible pointer type
ptr = &amp;x;
^
<a href="https://www.studytonight.com/code/playground/c/?id=vm9TGV" target="_blank">Run Code ยกรบ</a>
While declaring a pointer variable, if it is not assigned to anything then it contains <b>garbage value</b>. 
And that can lead to unexpected errors in your program. 
Hence, it is recommended to assign a <k>NULL</k> value to it.
When we assign <k>NULL</k> to a pointer, it means that it does not point to any valid address. 
<k>NULL</k> denotes the value 'zero'.
<img class="lazy" data-src="https://s3.studytonight.com/tutorials/uploads/pictures/1613545890-79873.png">
A pointer that is assigned a <k>NULL</k> value is called a <a href="https://www.studytonight.com/c/programs/pointer/null-pointer-program"><b>NULL pointer in C</b></a>.
We can give a pointer a null value by assigning it zero to it. 
For example,
<k> int *ptr = 0;</k>
The above code will initialize the <k>ptr</k> pointer will a null value.
We can also use the <b>NULL</b> macro, which is nothing but a predefined constant for null pointer. 
This is defined in the <b>&lt;stdio.h></b> header library.
<k> int *ptr = NULL;</k>
<h2>&emsp;Pointer to Pointer Assignment in C</h2>
We can use an assignment operator to assign value of a pointer to another pointer variable. 
But for such assignment, types of both the pointer should be same.
Let's take a code example,
<k>#include&lt;stdio.h>
int main(void)
{
    float a = 10;
    // declare two pointers
    int *p1, *p2;
    // assign value to pointer
    p1 = &amp;a;
    // assign value from one pointer to another
    p2 = p1;
    printf("Value at p1 and p2: %d %d \n", *p1, *p2);
    printf("Address pointed by p1 and p2: %p %p \n", p1, p2);
    return 0;
}</k>

Value at p1 and p2: 10 10
Address pointed by p1 and p2: 0x7fff99c0e6c4 0x7fff99c0e6c4
As you can see in the code example above, multiple pointers can point to the same variable but they should be of the same data type.
<h2>&emsp;Pointer Type Conversion in C</h2>
We can assign a pointer of one type to a pointer of another type by doing pointer type conversion.
<h2>&emsp;<k>void *</k> pointer</h2>
The pointers of type <k>void *</k> are known as <b>Generic pointers</b>, and they can be assigned to any other type of pointer. 
Also, any other type of pointer can be assigned to a <k>void *</k> pointer.
<h2>&emsp;Pointer type conversion</h2>
For pointer type other than <k>void *</k>, we have to explicitly cast pointer from one type to another. 
But this can lead to unexpected behaviour for incompatible datatypes.
For example, if we have a variable of type <k>double</k>, and we want to use a pointer of type <k>int</k> to point to this variable. 
Even after using explicit cast, the pointer will work as if it is pointing to a <k>int</k> type value. 
Now, a <k>double</k> type is of <b>8 bytes</b> whereas an <k>int</k> type is of <b>4 bytes</b>, hence, 4 bytes of information will be lost.
Let's see how we can use explicit cast for pointer conversion.
<k>#include&lt;stdio.h>
int main(void)
{
    double a = 1000.10;
    double b;
    // declare a pointer
    int *p1;
    // assign value to pointer with casting
    p1 = (int *) &amp;a;
    // value of 'b' should be same as 'a', but it won't be
    b = *p1;
    printf("Value of a is: %f \n", b);
    return 0;
}</k>

Value of a is: -858993459.000000
<a href="https://www.studytonight.com/code/playground/c/?id=82Cbgc" target="_blank">Run Code ยกรบ</a>
<h2>&emsp;Pointer and Arrays</h2>
<h2>&emsp;Derefrencing Pointer in C</h2>
Once a pointer has been assigned the address of a variable, the pointer is <b>dereferenced</b>, using the <b>indirection operator</b> or <b>dereferencing operator</b>, which is a <k>*</k>, to access the value of the variable.
For example, if we have,
<k>int a  = 5;
int *ptr1 = &amp;a;
float b = 5.5;
float *ptr2 = &amp;b;
// *ptr1 = 2 is equivalent to a = 2
// (*ptr1)++ is equivalent to a++
// float z = *ptr2 + 4.2 is equivalent to float z = b + 4.2;</k>
Here is one complete program,
<k>#include &lt;stdio.h>
int main()
{
    int a;  
    a = 10;
    int *p = &amp;a;     // declaring and initializing the pointer
    //prints the value of 'a'
    printf("%d\n", *p);  
    printf("%d\n", *&amp;a);  
    //prints the address of 'a'
    printf("%u\n", &amp;a);    
    printf("%u\n", p);     
    printf("%u\n", &amp;p);    //prints address of 'p'
    return 0;
}</k>

10
10
3795480300
3795480300
3795480304
<h2>&emsp;Points to Remember while using Pointers</h2>

    A pointer variable stores the address of a variable. 
We use <k>*</k> to declare and identify a pointer.
    We can find the address of any variable using the <k>&amp;</k> (ampersand) operator.
    The declaration <k>int *a</k> doesn't mean that <k>a</k> is going to contain an integer value. 
It means that <k>a</k> is going to contain the address of a variable of <k>int</k> type.
    We can dereference a pointer variable using a <k>*</k> operator. 
Here, the <k>*</k> can be read as <b>'value at'</b>.
    Since you have now learned the basics of Pointers in C, you can check out some <a href="https://www.studytonight.com/c/programs">C Pointer Programs</a> where pointers are used for different use-cases.
<u><b>Read More:</b></u>

<a href="https://www.studytonight.com/c/programs/pointer/simple-pointer-program">Simple Pointer Program</a>
<a href="https://www.studytonight.com/c/programs/pointer/array-of-pointers">Array of Pointer Program</a>
<a href="https://www.studytonight.com/c/pointer-to-pointer.php">What is Double Pointer?</a>
<a href="https://www.studytonight.com/c/pointer-with-function-in-c.php">Pointer with Function</a>
<h2><span class="orange">Pointer to a Pointer in C(Double Pointer)</span></h2>
<a href="pointers-in-c.php" target="_blank">Pointers</a> are used to store the address of other variables of similar <a href="datatype-in-c.php" target="_blank">datatype</a>. 
But if you want to store the address of a pointer variable, then you again need a pointer to store it. 
Thus, when one pointer variable stores the address of another pointer variable, it is known as <b>Pointer to Pointer</b> variable or <b>Double Pointer</b>.
<b>Syntax:</b>
<k>int **p1;</k>
Here, we have used two indirection operator(<k>*</k>) which stores and points to the address of a pointer variable i.e, <k>int *</k>. 
If we want to store the address of this (double pointer) variable <k>p1</k>, then the syntax would become:
<k>int ***p2</k>
<h2>&emsp;Simple program to represent Pointer to a Pointer</h2>
<k>#include &lt;stdio.h>
int main() {
    int  a = 10;
    int  *p1;       //this can store the address of variable a
    int  **p2; 
    /*
        this can store the address of pointer variable p1 only. 

        It cannot store the address of variable 'a' 
    */
    p1 = &amp;a;
    p2 = &amp;p1;
    printf("Address of a = %u\n", &amp;a);
    printf("Address of p1 = %u\n", &amp;p1);
    printf("Address of p2 = %u\n\n", &amp;p2);
    // below print statement will give the address of 'a'
    printf("Value at the address stored by p2 = %u\n", *p2);
    printf("Value at the address stored by p1 = %d\n\n", *p1);
    printf("Value of **p2 = %d\n", **p2); //read this *(*p2)
    /*
        This is not allowed, it will give a compile time error-
        p2 = &amp;a;
        printf("%u", p2);
    */
    return 0;
}</k>
Address of a = 2686724
Address of p1 = 2686728
Address of p2 = 2686732
Value at the address stored by p2 = 2686724
Value at the address stored by p1 = 10
Value of **p2 = 10
<h2>&emsp;Explanation of the above program</h2>
<img class="lazy" data-src="https://static.studytonight.com/c/images/pointer-to-pointer-1.png">

<k>p1</k> pointer variable can only hold the address of the variable <k>a</k> (i.e Number of indirection operator(*)-1 variable). 
Similarly, <k>p2</k> variable can only hold the address of variable <k>p1</k>. 
It cannot hold the address of variable <k>a</k>. 

<k>*p2</k> gives us the value at an address stored by the <k>p2</k> pointer. 
<k>p2</k> stores the address of <k>p1</k> pointer and value at the address of <k>p1</k> is the address of variable <k>a</k>. 
Thus, <k>*p2</k> prints address of <k>a</k>.
<k>**p2</k> can be read as <k>*(*p2)</k>. 
Hence, it gives us the value stored at the address <k>*p2</k>. 
From above statement, you know <k>*p2</k> means the address of variable a. 
Hence, the value at the address <k>*p2</k> is 10. 
Thus, <k>**p2</k> prints <k>10</k>.
<h2><span class="orange">Pointer and Arrays in C</span></h2>
Before you start with Pointer and Arrays in C, learn about these topics in prior:
<a href="https://www.studytonight.com/c/arrays-in-c.php" target="_blank">Array in C</a>
<a href="https://www.studytonight.com/c/pointers-in-c.php" target="_blank">Pointer in C</a>
    When an <a href="https://www.studytonight.com/c/arrays-in-c.php" target="_blank">array in C language</a> is declared, compiler allocates sufficient memory to contain all its elements. 
Its base address is also allocated by the compiler.
Declare an array <k>arr</k>,
<k>int arr[5] = { 1, 2, 3, 4, 5 };</k>
Suppose the base address of <k>arr</k> is 1000 and each integer requires two bytes, the five elements will be stored as follows:
<img class="lazy" data-src="https://www.studytonight.com/c/images/array-in-pointer.jpg">
Variable <k>arr</k> will give the base address, which is a constant <a href="https://www.studytonight.com/c/pointers-in-c.php" target="_blank">pointer</a> pointing to <k>arr[0]</k>. 
Hence <k>arr</k> contains the address of <k>arr[0]</k> i.e <k>1000</k>.
<k>arr</k> has two purpose -
It is the name of the array
    It acts as a pointer pointing towards the first element in the array.<blockquote>
<k>arr</k> is equal to <k>&amp;arr[0]</k> by default</blockquote>
For better understanding of the declaration and initialization of the pointer - <a href="https://www.studytonight.com/c/pointers-in-c.php">click here.</a> and refer to the <a href="https://www.studytonight.com/c/programs/pointer/simple-pointer-program">program</a> for its implementation.
<b>NOTE:</b>
You cannot decrement a pointer once incremented. 
<k>p&emsp;--</k> won't work.<h2>Pointer to Array</h2>
Use a <a href="https://www.studytonight.com/c/pointer-to-pointer.php" target="_blank">pointer to an array</a>, and then use that pointer to access the array elements. 
For example,
<k>#include&lt;stdio.h>
void main()
{
   int a[3] = {1, 2, 3};
   int *p = a;    
   for (int i = 0; i &lt; 3; i++)
   {
      printf("%d", *p);
      p++;
   }
  return 0;
}
  </k>

1 2 3
<img class="lazy" data-src="https://www.studytonight.com/c/images/pointer-to-array-details.gif">
<b>Syntax:</b>
<k>*(a+i)  //pointer with an array</k>
is same as:
<k>a[i]</k>
<h2>&emsp;Pointer to Multidimensional Array</h2>
Let's see how to make a pointer point to a multidimensional array. 
In <k>a[i][j]</k>, <k>a</k> will give the base address of this array, even <k>a + 0 + 0</k> will also give the base address, that is the address of <k>a[0][0]</k> element.
<h4>Syntax:</h4>
<k>*(*(a + i) + j)</k>
<h2>&emsp;Pointer and Character strings</h2>
Pointer is used to create strings. 
Pointer variables of <k>char</k> type are treated as string.
<k>char *str = "Hello";</k>
The above code creates a string and stores its address in the pointer variable <k>str</k>. 
The pointer <k>str</k> now points to the first character of the string "Hello".
The string created using <k>char</k> pointer can be assigned a value at <b>runtime</b>.
<k>char *str;
str = "hello";    
</k>
The content of the string can be printed using <k>printf()</k> and <k>puts()</k>.
<k>printf("%s", str);
puts(str);</k>
<k>str</k> is a pointer to the string and also name of the string. 
Ther&emsp;efore we do not need to use indirection operator <k>*</k>.<h2>Array of Pointers</h2>
Pointers are very helpful in handling character arrays with rows of varying lengths.
<k>char *name[3] = { 
    "Adam",
    "chris",
    "Deniel"
};
//without pointer
char name[3][20] = { 
    "Adam",
    "chris",
    "Deniel"
};</k>
<img class="lazy" data-src="https://www.studytonight.com/c/images/benefit-of-pointer-with-char-array.gif">
In the second approach memory wastage is more, hence it is preferred to use <a href="https://www.studytonight.com/c/pointers-in-c.php" target="_blank">pointer</a> in such cases.
<u><b>Suggested Tutorials:</b></u>
<a href="https://www.studytonight.com/c/pointer-with-function-in-c.php">Pointers with Function</a>
<a href="https://www.studytonight.com/c/pointers-to-structure-in-c.php">Pointer to Structure</a>
<a href="https://www.studytonight.com/c/pointer-arithmetic-in-c.php">Pointer Arithmetic</a>
<a href="https://www.studytonight.com/c/programs/pointer/array-of-pointers">Pointer to Array Program</a>
<h2><span class="orange">Pointer to Array of Structures in C</span></h2>
Like we have array of integers, <a href="pointers-with-array.php" target="_blank">array of pointers</a> etc, we can also have array of structure variables. 
And to use the array of structure variables efficiently, we use <b>pointers of structure type</b>. 
We can also have pointer to a single structure variable, but it is mostly used when we are dealing with array of structure variables.
<k>#include &lt;stdio.h>
struct Book
{
    char name[10];
    int price;
}
int main()
{
    struct Book a;      //Single structure variable
    struct Book* ptr;   //Pointer of Structure type
    ptr = &amp;a;
 
    struct Book b[10];  //Array of structure variables
    struct Book* p;     //Pointer of Structure type
    p = &amp;b;  
    return 0;
}</k>
<img class="lazy" data-src="https://static.studytonight.com/c/images/pointer-to-structure.gif">
<h2>&emsp;Accessing Structure Members with Pointer</h2>
To access members of structure using the structure variable, we used the dot <k>.</k> operator. 
But when we have a pointer of structure type, we use arrow <k>-></k> to access structure members.
<k>#include &lt;stdio.h>
struct my_structure {
    char name[20];
    int number;
    int rank;
};
int main()
{
    struct my_structure variable = {"StudyTonight", 35, 1};
    struct my_structure *ptr;
    ptr = &amp;variable;
    printf("NAME: %s\n", ptr->name);
    printf("NUMBER: %d\n", ptr->number);
    printf("RANK: %d", ptr->rank);
    return 0;
}</k>
NAME: StudyTonight
NUMBER: 35
RANK: 1
<h2><span class="orange">Pointer Arithmetic in C</span></h2>
If you want to have complete knowledge of <a href="pointers-in-c.php" target="_blank">pointers</a>, pointer arithmetic is very important to understand. 
In this topic we will study how the memory addresses change when you increment a pointer.
<h2>&emsp;bit Machine <small>(Turbo C)</small></h2>
In a 16 bit machine, size of all types of pointer, be it <k>int*</k>, <k>float*</k>, <k>char*</k> or <k>double*</k> is always <b>2 bytes</b>. 
But when we perform any arithmetic function like increment on a pointer, changes occur as per the size of their primitive data type.
<b>Size of datatypes on 16-bit Machine:</b>
<table>
<tr><th>Type</th>
        <th>Size (in bytes)</th>
    </tr>
<tr><td>int or signed int</td>
        <td>2</td>
    </tr>
<tr><td>char</td>
        <td>1</td>
    </tr>
<tr><td>long</td>
        <td>4</td>
    </tr>
<tr><td>float</td>
        <td>4</td>
    </tr>
<tr><td>double</td>
        <td>8</td>
    </tr>
<tr><td>long double</td>
        <td>10</td>
    </tr>
</table>
<h2>Examples for Pointer Arithmetic</h2>
Now lets take a few examples and understand this more clearly.
<k>int* i;
i++;</k>
In the above case, pointer will be of 2 bytes. 
And when we increment it, it will increment by 2 bytes because <k>int</k> is also of 2 bytes.
<k>float* i;
i++;</k>
In this case, size of pointer is still 2 bytes initially. 
But now, when we increment it, it will increment by 4 bytes because <k>float</k> <a href="datatype-in-c.php" target="_blank">datatype</a> is of 4 bytes.
<k>double* i;
i++;</k>
Similarly, in this case, size of pointer is still 2 bytes. 
But now, when we increment it, it will increment by 8 bytes because its data type is <k>double</k>.
<h2>&emsp;bit Machine <small>(Visual Basic C++)</small></h2>
The concept of pointer arithmetic remains exact same, but the size of pointer and various datatypes is different in a 32 bit machine. 
Pointer in 32 bit machine is of <b>4 bytes</b>.
And, following is a table for <b>Size of datatypes on 32-bit Machine :</b>
<table>
<tr><th>Type</th>
        <th>Size (in bytes)</th>
    </tr>
<tr><td>int or signed int</td>
        <td>4</td>
    </tr>
<tr><td>char</td>
        <td>2</td>
    </tr>
<tr><td>long</td>
        <td>8</td>
    </tr>
<tr><td>float</td>
        <td>8</td>
    </tr>
<tr><td>double</td>
        <td>16</td>
    </tr>
</table>
<b>Note:</b> We cannot add two pointers. 
This is because pointers contain addresses, adding two addresses makes no sense, because you have no idea what it would point to.
 
But we can subtract two pointers. 
This is because difference between two pointers gives the number of elements of its data type that can be stored between the two pointers.
<h2>&emsp;Program for pointer arithmetic(32-bit machine)</h2>
<k>#include &lt;stdio.h>
int main()
{
    int m = 5, n = 10, o = 0;
    int *p1;
    int *p2;
    int *p3;
    p1 = &amp;m;    //printing the address of m
    p2 = &amp;n;    //printing the address of n
    printf("p1 = %d\n", p1);
    printf("p2 = %d\n", p2);
    o = *p1+*p2;
    printf("*p1+*p2 = %d\n", o);//point 1
    p3 = p1-p2;
    printf("p1 - p2 = %d\n", p3); //point 2
    p1++;
    printf("p1++ = %d\n", p1); //point 3
    p2--;
    printf("p2-- = %d\n", p2); //point 4
    //Below line will give ERROR
    printf("p1+p2 = %d\n", p1+p2); //point 5
    return 0;
}</k>
p1 = 2680016
p2 = 2680012
*p1+*p2 = 15
p1-p2 = 1
p1++ = 2680020
p2-- = 2680008
<h2>&emsp;Explanation of the above program:</h2>


<b>Point 1:</b> Here, <k>*</k> means 'value at the given address'. 
Thus, it adds the value of m and n which is 15.
<b>Point 2:</b> It subtracts the addresses of the two variables and then divides it by the size of the pointer datatype (here integer, which has size of 4 bytes) which gives us the number of elements of integer data type that can be stored within it.
<b>Point 3:</b> It increments the address stored by the pointer by the size of its datatype(here 4).
<b>Point 4:</b> It decrements the address stored by the pointer by the size of its datatype(here 4).
<b>Point 5:</b> Addition of two pointers is not allowed.
<h2><span class="orange">Pointers as Function Argument in C</span></h2>
Pointer as a function parameter is used to hold addresses of arguments passed during function call. 
This is also known as <b>call by reference</b>. 
When a function is called by reference any change made to the reference variable will effect the original variable.
<h2>&emsp;Example Time: Swapping two numbers using Pointer</h2>
<k>#include &lt;stdio.h>
void swap(int *a, int *b);
int main()
{
    int m = 10, n = 20;
    printf("m = %d\n", m);
    printf("n = %d\n\n", n);
    swap(&amp;m, &amp;n);    //passing address of m and n to the swap function
    printf("After Swapping:\n\n");
    printf("m = %d\n", m);
    printf("n = %d", n);
    return 0;
}
/*
    pointer 'a' and 'b' holds and 
    points to the address of 'm' and 'n'
*/
void swap(int *a, int *b) 
{
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}</k>
m = 10
n = 20
After Swapping:
m = 20
n = 10
<h2>&emsp;Functions returning Pointer variables</h2>
A function can also <k>return</k> a pointer to the calling function. 
In this case you must be careful, because local variables of function doesn't live outside the function. 
They have scope only inside the function. 
Hence if you return a pointer connected to a local variable, that pointer will be pointing to nothing when the function ends.
<k>#include &lt;stdio.h>
int* larger(int*, int*);
void main()
{
    int a = 15;
    int b = 92;
    int *p;
    p = larger(&amp;a, &amp;b);
    printf("%d is larger",*p);
}
int* larger(int *x, int *y)
{
    if(*x > *y)
        return x;
    else
        return y;
}</k>
92 is larger
<h2>&emsp;Safe ways to return a valid Pointer.</h2>

Either use <b>argument with functions</b>. 
Because argument passed to the functions are declared inside the calling function, hence they will live outside the function as well.Or, use <k>static</k> <b>local variables</b> inside the function and return them. 
As s&emsp;tatic variables have a lifetime until the <k>main()</k> function exits, therefore they will be available througout the program.<h2>Pointer to functions</h2>
It is possible to declare a pointer pointing to a function which can then be used as an argument in another function. 
A pointer to a function is declared as follows,
 
<k>type (*pointer-name)(parameter);</k>
Here is an example :
<k>int (*sum)();   //legal declaration of pointer to function
int *sum();     //This is not a declaration of pointer to function</k>
A function pointer can point to a specific function when it is assigned the name of that function.
<k>int sum(int, int);
int (*s)(int, int);
s = sum;</k>
Here <k>s</k> is a pointer to a function <k>sum</k>. 
Now <k>sum</k> can be called using function pointer <k>s</k> along with providing the required argument values.
<k>s (10, 20);</k>
<h2>&emsp;Example of Pointer to Function</h2>
<k>#include &lt;stdio.h>
int sum(int x, int y)
{
    return x+y;
}
int main( )
{
    int (*fp)(int, int);
    fp = sum;
    int s = fp(10, 15);
    printf("Sum is %d", s);
    return 0;
}</k>
25
<h2>&emsp;Complicated Function Pointer example</h2>
You will find a lot of complex <a href="user-defined-functions-in-c.php" target="_blank">function</a> <a href="pointers-in-c.php" target="_blank">pointer</a> examples around, lets see one such example and try to understand it.
<k>void *(*foo) (int*);</k>
It appears complex but it is very simple. 
In this case <k>(*foo)</k> is a pointer to the function, whose argument is of <k>int*</k> type and return type is <k>void*</k>.
<h2><span class="orange">File Input/Output in C</span></h2>
A <b>file</b> represents a sequence of bytes on the disk where a group of related data is stored. 
File is created for permanent storage of data. 
It is a ready made structure.
 
In C language, we use a structure <b>pointer of file type</b> to declare a file.
<k>FILE *fp;</k> 
C provides a number of functions that helps to perform basic file operations. 
Following are the functions,
<table>
<tr><th>Function</th>
<th>description</th></tr>
<tr><td>fopen()</td><td>create a new file or open a existing file</td></tr>
<tr><td>fclose()</td><td>closes a file</td></tr>
<tr><td>getc()</td><td>reads a character from a file</td></tr>
<tr><td>putc()</td><td>writes a character to a file</td></tr>
<tr><td>fscanf()</td><td>reads a set of data from a file</td></tr>
<tr><td>fprintf()</td><td>writes a set of data to a file</td></tr>
<tr><td>getw()</td><td>reads a integer from a file</td></tr>
<tr><td>putw()</td><td>writes a integer to a file</td></tr>
<tr><td>fseek()</td><td>set the position to desire point</td></tr>
<tr><td>ftell()</td><td>gives current position in the file</td></tr>
<tr><td>rewind()</td><td>set the position to the begining point</td></tr>
</table>
<h2>Opening a File or Creating a File</h2>
The <k>fopen()</k> function is used to create a new file or to open an existing file.
 
<b>General Syntax:</b>
<k>*fp = FILE *fopen(const char *filename, const char *mode);</k>
Here, <k>*fp</k> is the FILE pointer (<k>FILE *fp</k>), which will hold the reference to the opened(or created) file.
<b>filename</b> is the name of the file to be opened and <b>mode</b> specifies the purpose of opening the file. 
Mode can be of following types,
<table>
<tr><th>mode</th>
<th>description</th></tr>
<tr><td>r</td><td>opens a text file in reading mode</td></tr>
<tr><td>w</td><td>opens or create a text file in writing mode.</td></tr>
<tr><td>a</td><td>opens a text file in append mode</td></tr>
<tr><td>r+</td><td>opens a text file in both reading and writing mode</td></tr>
<tr><td>w+</td><td>opens a text file in both reading and writing mode</td></tr>
<tr><td>a+</td><td>opens a text file in both reading and writing mode</td></tr>
<tr><td>rb</td><td>opens a binary file in reading mode</td></tr>
<tr><td>wb</td><td>opens or create a binary file in writing mode</td></tr>
<tr><td>ab</td><td>opens a binary file in append mode</td></tr>
<tr><td>rb+</td><td>opens a binary file in both reading and writing mode</td></tr>
<tr><td>wb+</td><td>opens a binary file in both reading and writing mode</td></tr>
<tr><td>ab+</td><td>opens a binary file in both reading and writing mode</td></tr>
</table>
<h2>Closing a File</h2>
The <k>fclose()</k> function is used to close an already opened file.
 
<b>General Syntax :</b>
<k>int fclose( FILE *fp);</k>
Here <k>fclose()</k> function closes the file and returns <b>zero</b> on success, or <b>EOF</b> if there is an error in closing the file. 
This <b>EOF</b> is a constant defined in the header file <b>stdio.h</b>.
<h2>&emsp;Input/Output operation on File</h2>
In the above table we have discussed about various file I/O functions to perform reading and writing on file. 
<k>getc()</k> and <k>putc()</k> are the simplest functions which can be used to read and write individual characters to a file.
<k>#include&lt;stdio.h>
int main()
{
    FILE *fp;
    char ch;
    fp = fopen("one.txt", "w");
    printf("Enter data...");
    while( (ch = getchar()) != EOF) {
        putc(ch, fp);
    }
    fclose(fp);
    fp = fopen("one.txt", "r");
 
    while( (ch = <b>getc</b>(fp)! = EOF)
    printf("%c",ch);
    // closing the file pointer
    fclose(fp);
    return 0;
}</k> 
<h2>&emsp;Reading and Writing to File using <k>fprintf()</k> and <k>fscanf()</k></h2>
<k>#include&lt;stdio.h>
struct emp
{
    char name[10];
    int age;
};
void main()
{
    struct emp e;
    FILE *p,*q;
    p = fopen("one.txt", "a");
    q = fopen("one.txt", "r");
    printf("Enter Name and Age:");
    scanf("%s %d", e.name, &amp;e.age);
    fprintf(p,"%s %d", e.name, e.age);
    fclose(p);
    do
    {
        fscanf(q,"%s %d", e.name, e.age);
        printf("%s %d", e.name, e.age);
    }
    while(!feof(q));
}</k>
In this program, we have created two FILE pointers and both are refering to the same file but in different modes.
 
<k>fprintf()</k> function directly writes into the file, while <k>fscanf()</k> reads from the file, which can then be printed on the console using standard <k>printf()</k> function.
<h2>&emsp;Difference between Append and Write Mode</h2>
Write (w) mode and Append (a) mode, while opening a file are almost the same. 
Both are used to write in a file. 
In both the modes, new file is created if it doesn't exists already.
The only difference they have is, when you <b>open</b> a file in the <b>write</b> mode, the file is reset, resulting in deletion of any data already present in the file. 
While in <b>append</b> mode this will not happen. 
Append mode is used to append or add data to the existing data of file(if any). 
Hence, when you open a file in Append(a) mode, the cursor is positioned at the end of the present data in the file.
<h2>&emsp;Reading and Writing in a Binary File</h2>
A Binary file is similar to a text file, but it contains only large numerical data. 
The Opening modes are mentioned in the table for opening modes above.
<k>fread()</k> and <k>fwrite()</k> functions are used to read and write is a binary file.
<k>fwrite(data-element-to-be-written, size_of_elements, number_of_elements, pointer-to-file);</k>
<k>fread()</k> is also used in the same way, with the same arguments like <k>fwrite()</k> function. 
Below mentioned is a simple example of writing into a binary file
<k>const char *mytext = "The quick brown fox jumps over the lazy dog";   
FILE *bfp= fopen("test.txt", "wb");   
if (bfp) 
{     
    fwrite(mytext, sizeof(char), strlen(mytext), bfp);     
    fclose(bfp);   
}</k>
<h2><k>fseek()</k>, <k>ftell()</k> and <k>rewind()</k> functions</h2>

<k>fseek()</k>: It is used to move the reading control to different positions using fseek function.
<k>ftell()</k>: It tells the byte location of current position of cursor in file pointer.
<k>r&emsp;ewind()</k>: It moves the control to beginning of the file.<h2>Some File Handling Program Examples</h2>
<a href="/c/programs/files-and-streams/program-to-list-files-in-directory" target="_blank">List all the Files present in a Directory</a><a href="/c/programs/files-and-streams/program-to-read-data-from-file" target="_blank">Read Content of a File and Display it on screen</a><a href="/c/programs/files-and-streams/program-to-find-size-of-file" target="_blank">Finding Size of a File</a><a href="/c/programs/files-and-streams/program-to-write-in-file" target="_blank">Create a File and store Information in it</a><a href="/c/programs/files-and-streams/program-to-reverse-content-of-file" target="_blank">Reverse the Content of File and Print it</a><a href="/c/programs/files-and-streams/program-copy-file-to-another-file" target="_blank">Copy Content of one File into Another File</a>
<h2><span class="orange">Error Handling in C</span></h2>
C language does not provide any direct support for error handling. 
However a few methods and variables defined in <b>error.h</b> header file can be used to point out error using the return statement in a <a href="user-defined-functions-in-c.php" target="_blank">function</a>. 
In C language, a function returns <k>-1</k> or <k>NULL</k> value in case of any error and a global <a href="variables-in-c.php" target="_blank">variable</a> <b>errno</b> is set with the error code. 
So the return value can be used to check error while programming. 
 
<h2>&emsp;What is errno?</h2>
Whenever a function call is made in C language, a variable named <k>errno</k> is associated with it. 
It is a global variable, which can be used to identify which type of error was encountered while function execution, based on its value. 
Below we have the list of Error numbers and what does they mean.
<table>
<tr><th>errno value</th>
<th>Error</th></tr>
<tr><td>1</td><td>Operation not permitted</td></tr>
<tr><td>2</td><td>No such file or directory</td></tr>
<tr><td>3</td><td>No such process</td></tr>
<tr><td>4</td><td>Interrupted system call</td></tr>
<tr><td>5</td><td>I/O error</td></tr>
<tr><td>6</td><td>No such device or address</td></tr>
<tr><td>7</td><td>Argument list too long</td></tr>
<tr><td>8</td><td>Exec format error</td></tr>
<tr><td>9</td><td>Bad file number</td></tr>
<tr><td>10</td><td>No child processes</td></tr>
<tr><td>11</td><td>Try again</td></tr>
<tr><td>12</td><td>Out of memory</td></tr>
<tr><td>13</td><td>Permission denied</td></tr>
</table>
C language uses the following functions to represent error messages associated with <b>errno</b>:

<k>perror()</k>: returns the string passed to it along with the textual represention of the current errno value.
<k>strerror()</k> is defined in <b>string.h</b> library. 
This&emsp; method returns a pointer to the string representation of the current errno value.<h2>Time for an Example</h2>
<k>#include &lt;stdio.h>       
#include &lt;errno.h>       
#include &lt;string.h> 
 
int main ()
{
    FILE *fp;
 
    /* 
        If a file, which does not exists, is opened,
        we will get an error
    */ 
    fp = fopen("IWillReturnError.txt", "r");
 
    printf("Value of errno: %d\n ", errno);
    printf("The error message is : %s\n", strerror(errno));
    perror("Message from perror");
 
    return 0;
}</k>
Value of errno: 2
The error message is: No such file or directory
Message from perror: No such file or directory
<h2>&emsp;Other ways of Error Handling</h2>
We can also use <b>Exit Status</b> constants in the <k>exit()</k> function to inform the calling function about the error. 
The two constant values available for use are <k>EXIT_SUCCESS</k> and <k>EXIT_FAILURE</k>. 
These are nothing but macros defined <b>stdlib.h</b> header file.
<k>#include &lt;stdio.h>       
#include &lt;errno.h>       
#include &lt;stdlib.h>       
#include &lt;string.h>       
 
extern int errno;
 
void main()
{
    char *ptr = malloc( 1000000000UL);  //requesting to allocate 1gb memory space
    if (ptr == NULL)    //if memory not available, it will return null 
    {  
        puts("malloc failed");
        puts(strerror(errno));
        exit(EXIT_FAILURE);     //exit status failure
    }
    else
    {
        free( ptr);
        exit(EXIT_SUCCESS);     //exit status Success      
    }
}</k>
Here exit function is used to indicate exit status. 
Its always a good practice to exit a program with a exit status. 
<b>EXIT_SUCCESS</b> and <b>EXIT_FAILURE</b> are two macro used to show exit status. 
In case of program coming out after a successful operation <b>EXIT_SUCCESS</b> is used to show successful exit. 
It is defined as 0. 
<b>EXIT_Failure</b> is used in case of any failure in the program. 
It is defined as -1.
<h2>&emsp;Division by Zero</h2>
There are some situation where nothing can be done to handle the error. 
In C language one such situation is division by zero. 
All you can do is avoid doing this, becasue if you do so, C language is not able to understand what happened, and gives a runtime error.
Best way to avoid this is, to check the value of the divisor before using it in the division operations. 
You can use <k>if</k> condition, and if it is found to be zero, just display a message and return from the function.
<h2><span class="orange">Dynamic Memory Allocation in C</span></h2>
In C language, the process of allocating memory at runtime is known as <b>dynamic memory allocation</b>. 
Library functions known as <b>memory management functions</b> are used for assigning (allocating) and freeing memory, during execution of a program. 
These functions are defined in the <b>stdlib.h</b> header file.
These functions allocate memory from a memory area known as <b>heap</b> and when the memory is not in use, it is freed to be used for some other purpose. 
We access the dynamically allocated memory using <a href="https://www.studytonight.com/c/declaring-and-initializing-pointer.php">pointers</a>
We have done static memory allocation till now. 
The memory requirement was fixed. 
It could not be increased or decreased during execution of the program. 
This type of allocation has a drawback. 
We cannot predict how much memory will be required. 
For example, if we declare an array, like this:
<k>int marks[50];</k>
We might only store data for <b>25 students</b>. 
As a result, memory will be wasted. 
Or we may need to store data for <b>60 students</b>, in that case we will have less memory. 
The solution to these problems is dynamic memory allocation.
<h2>&emsp;Difference between Static and Dynamic Memory Allocation</h2>
Before we move on to study dynamic memory allocation in detail, letยกยฏs take a look at the differences between static and dynamic memory allocation.
<table><tbody>
<tr><td>
            <b>Static Memory Allocation</b>
            </td>
            <td>
            <b>Dynamic Memory Allocation</b>
            </td>
        </tr>
<tr><td>
                Allocation is done before execution of the program(at compile time).
            </td>
            <td>
                Allocation is done during execution of the program(at runtime).
            </td>
        </tr>
<tr><td>
                Here, variables are allocated memory permanently.
            </td>
            <td>
                Here, memory is allocated only when the program is active.
            </td>
        </tr>
<tr><td>
                It uses <b>stack</b> for managing memory allocation.
            </td>
            <td>
                It uses <b>heap</b> for managing memory allocation.
            </td>
        </tr>
<tr><td>
                We cannot reuse the memory.
            </td>
            <td>
                We can reuse the memory and free it after usage.
            </td>
        </tr>
<tr><td>
                Execution is faster than dynamic memory allocation.
            </td>
            <td>
                Execution is slower than static memory allocation.
            </td>
        </tr>
<tr><td>
                It is less efficient.
            </td>
            <td>
                It is more efficient.
            </td>
        </tr>
<tr><td>
                            It is simple to use.
            
</td>
            <td>
                It can be complicated to use.
            </td>
        </tr>
</tbody></table>
<table>
<tr><th>Function</th>
<th>Description</th></tr>
<tr><td><k>malloc()</k></td><td>allocates requested size of bytes and returns a void pointer pointing to the first byte of the allocated space</td></tr>
<tr><td><k>calloc()</k></td><td>allocates space for an array of elements, initialize them to zero and then returns a void pointer to the memory</td></tr>
<tr><td><k>free</k></td><td>releases previously allocated memory</td></tr>
<tr><td><k>realloc</k></td><td>modify the size of previously allocated space</td></tr>
</table>
<h2>&emsp;Memory Allocation Process</h2>
<b>Global</b> variables, <k>static</k> variables and program instructions get their memory in <b>permanent</b> storage area whereas <b>local</b> variables are stored in a memory area called <b>Stack</b>.
 
The memory space between these two region is known as <b>Heap</b> area. 
This region is used for dynamic memory allocation during execution of the program. 
The size of heap keeps changing. 
 
<img class="lazy" data-src="https://static.studytonight.com/c/images/memory-allocation-in-c.jpg">
<h2>&emsp;Allocating block of Memory</h2>
Now let's see how the different functions for dynamic memory allocation works.
<h2>&emsp;<k>malloc()</k> Function</h2>
<k>malloc()</k> function is used for allocating block of memory at runtime. 
This function reserves a block of memory of the given size and returns a <b>pointer</b> of type <k>void</k>. 
This means that we can assign it to any type of pointer using typecasting. 
If it fails to allocate enough space as specified, it returns a <k>NULL</k> pointer.
 
<b>Syntax:</b>
Here is the syntax of this function,
<k>void* malloc(size_t size)</k>
In <b>stdlib.h</b>, <k>size_t</k> is defined as <k>unsigned int</k>.
The memory allocated by <k>malloc()</k> contains garbage value.
We use this function like this,
<k>data_type *ptr;
ptr = (data_type *)malloc(specified size);</k>
Here, we typecast the pointer returned by <k>malloc()</k> function using (<b>data_type *</b>).
For example:
<k>void main(){
    int *x;
    float *y;
    x = (int*)malloc(50);     //50 contiguous bytes of memory are allocated and the address of the first byte is stored in x.
    y = (float*)malloc(5 * sizeof(float);    // This allocates memory to store 5 decimal numbers.
    // we should always check the value returned.
    if(x == NULL)
        printf(ยกยฐMemory unavailable\nยกยฑ);
    if(y == NULL)
        printf(ยกยฐMemory unavailable\nยกยฑ);
}</k>
Let's take another example:
<k>#include&lt;stdio.h>
#include &lt;stdlib.h>
int main(){
    int *ptr;
    ptr = malloc(5 * sizeof(int)); /* a block of 5 integers */
    if (ptr != NULL) {
        *(ptr + 1) = 10; /* assign 10 to second integer */
        printf("Value of the 2nd integer is %d",*(ptr + 1));
    }
    return 0;
}</k>

Value of the 2nd integer is 10
<h2>&emsp;<k>calloc()</k> Function</h2>
<k>calloc()</k> is another memory allocation function that is used for allocating memory at runtime. 
<k>calloc</k> function is normally used for allocating memory to derived data types such as <b><a href="/c/arrays-in-c.php">arrays</a></b> and <b><a href="/c/structures-in-c.php">structures</a></b>. 
If it fails to allocate enough space as specified, it returns a <k>NULL</k> <a href="/c/pointers-in-c.php">pointer</a>.
 
The memory allocated by calloc() is initialized to zero.
<b>Syntax:</b>
Let's see the syntax for this function,
<k>void *calloc(number of items, size_t size);</k>
<h2>Time for an Example: <k>calloc()</k> function</h2>
Here is a simple code example,
<k>char * ptr;
ptr = (char*)calloc(5, sizeof(char);</k>
Let's look at another example,
<k>struct employee
{
    char *name;
    int salary;
};
typedef struct employee emp;
emp *e1;
e1 = (emp*)calloc(30, sizeof(emp));</k>
<h2>&emsp;<k>realloc()</k> Function</h2>
The <k>realloc()</k> function is used to change the memory size that is already allocated dynamically to a variable.
If we want to change the size of memory allocated by <k>malloc()</k> or <k>calloc()</k> function, we use <k>realloc()</k> function. 
Without losing the old data, it changes the size of the memory block. 
The <b>first argument of this function is a pointer</b> pointing to the block of memory we allocated before and the <b>second argument is the updated size</b> of the memory block. 
On failure, it returns <b>NULL</b>.
If the <b>new size</b>(of memory required) is larger than the old size, it retains the data and newly allocated bytes are uninitialized. 
It might move the old data to a new block of memory with increased size if there's not enough space at the old address.
<b>Syntax:</b>
Let's see the syntax for this function,
<k>void* realloc(void *pointer, size_t new-size);</k>
<h2>&emsp;Time for an Example: <k>realloc()</k> function</h2>
Let's see, how we can use this function.
<k>int *x;
x = (int*)malloc(50 * sizeof(int));
x = (int*)realloc(x, 100);   //allocated a new memory to variable x</k>
Another example depicting the use of <k>realloc()</k> function.
<k>#include &lt;stdio.h>
#include &lt;stdlib.h>
int main()
{
    int x,*ptr;
    ptr = (int*)malloc(5 * sizeof(int));
    if(ptr == NULL){
        printf("Memory not available");
        exit (1);
    }
    for(int i = 0; i &lt; 5; i++)
        scanf("%d", ptr + i);
    ptr = (int*)realloc(ptr, 7 * sizeof(int));
    if(ptr == NULL){
        printf("Memory not available");
        exit (1);
    }
    for(int i = 5; i &lt; 7; i++)
        scanf("%d", ptr + i);
    for(int i = 0; i &lt; 7; i++)
        printf("%d : %d\n",i + 1, *(ptr + i));
    free(ptr);
    return 0;
}</k>

5 4 6 7 8 3 2
1 : 5
2 : 4
3 : 6
4 : 7
5 : 8
6 : 3
7 : 2
<h2>&emsp;Diffrence between <k>malloc()</k> and <k>calloc()</k></h2>
<table>
<thead><tr><th style="center">
<k>calloc()</k> Function</th>
<th style="center">
<k>malloc()</k> Function</th></tr></thead>
<tbody>
<tr><td>
<k>calloc()</k> function initializes the allocated memory with <b>0</b> value.</td><td>
<k>malloc()</k> function initializes the allocated memory with <b>garbage</b> values.</td></tr>
<tr><td>Number of arguments is 2</td><td>Number of argument is 1</td></tr>
<tr><td>
<b>Syntax:</b>
(cast_type *)calloc(blocks, size_of_block); </td><td>
<b>Syntax:</b>
(cast_type *)malloc(size_in_bytes);
</td></tr>
</tbody>
</table>
<h2><k>free()</k> Function</h2>
Let's start by knowing the syntax of this function:
<k>void free(void *p);</k>
The memory we allocate dynamically exists till the end of the program. 
As a programmer, it is our duty to <b>release that memory</b> so that it can be used for other purposes and does not cause memory leaks. 
We do it as follows:
<k>int *x;
x = (int*)malloc(50 * sizeof(int));
free(x);</k>
When we allocate dynamic memory in functions, if the function does not return address of the memory dynamically allocated, the memory should be free within that function itself. 
But if the function returns the dynamically allocated memory's address, then the momory has to be freed in the calling function.
<h2>&emsp;Program to represent Dynamic Memory Allocation(using calloc())</h2>
<k>#include &lt;stdio.h>
#include &lt;stdlib.h>
int main()
{
    int i, n;
    int *element;
    printf("Enter total number of elements: ");
    scanf("%d", &amp;n);
    /*
        returns a void pointer(which is type-casted to int*)
        pointing to the first block of the allocated space
    */
    element = (int*) calloc(n,sizeof(int)); 
    /*
        If it fails to allocate enough space as specified, 
        it returns a NULL pointer.
    */
    if(element == NULL) 
    {
        printf("Error.Not enough space available");
        exit(0);
    }
    for(i = 0; i &lt; n; i++)
    {
        /*
            storing elements from the user 
            in the allocated space
        */
       scanf("%d", element+i); 
    }
    for(i = 1; i &lt; n; i++)
    {
       if(*element > *(element+i))
       {
            *element = *(element+i);
        }
    }
    printf("Smallest element is %d", *element);
    return 0;
}</k>
Enter total number of elements: 5
4 2 1 5 3
Smallest element is 1
In this way, we can make use of dynamic memory allocation in our program.
So this was all about dynamic memory allocation in C language where we used <k>malloc()</k> function, <k>calloc()</k> function, <k>realloc()</k> function, and <k>free()</k> function.
<h2><span class="orange">Command Line Argument in C</span></h2>
So far we have seen how to input values in C code during compile-time and runtime. 
To do that, we declared variables in the main() and then worked on them but there is a way to input values without declaring it in the main().
C offers us a feature called <b>"command line argument"</b> using which we can enter values from the command line at the time of execution. 
Command line argument is a parameter supplied to the program when it is invoked or run.
<h2>&emsp;Use of Command Line arguments in C</h2>
They are used when we need to control our program from outside instead of hard-coding it.
    They make installation of programs easier.Command line argument is an important concept in C programming. 
Command line arguments are passed to the <k>main()</k> method.
<b>Syntax:</b>
<k>int main(int argc, char *argv[])</k>
Here, <k>argc</k> counts the <b>number of arguments</b> on the command line and <k>argv[ ]</k> is a <a href="pointers-with-array.php">pointer array</a> which holds pointers of type <k>char</k> which points to the arguments passed to the program.
Let's see a simple code example to check whether any command line arguments is provided to the code or not.
<k>#include&lt;stdio.h>
int main(int argc, char *argv[])
{
    if(argc &lt; 2)
        printf("No argument supplied. 
The only argument here is %s", argv[0]);
    return 0;
}</k>
Compile the above code using: <k>gcc filename.c -o filename</k>
Then run it using: <b>./filename</b>
Or you can just use our <a href="/code/playground/c/">Online C compiler</a>, but you need to Login to try it out.
<a href="https://www.studytonight.com/code/playground/c/?id=FZabl9">Run Code ยกรบ</a>

No argument supplied. 
The only argument here is ./a.out
From the above example, we can infer that the <b>first command line argument is the program file name</b>, which is always added by default by the compiler.
Hence, <b>argv[0] = name of our file</b> and <b>argc = 1</b>.
We compiled the above code using command, <k>gcc filename.c -o filename</k>. 
We provided the <k>-o</k> flag so that the output file is given the name that we provided.)
<h2>&emsp;Example for Command Line Argument</h2>
If we want to print all the arguments in our program, we can do it as follows.
<k>#include &lt;stdio.h>
#include &lt;conio.h>
int main(int argc, char *argv[])
{
    int i;
    if( argc >= 2 )
    {
        printf("The arguments supplied are:\n");
        for(i = 1; i &lt; argc; i++)
        {
            printf("%s\t", argv[i]);
        }
    }
    else
    {
        printf("argument list is empty.\n");
    }
    return 0;
}</k>
Compile the above code using command: <k>gcc name_of_file.c</k>, then run it using: <k>./a.out Welcome to Studytonight</k>, we have provided command line argument while running the compiled code.

1 : Welcome
2 : to
3 : Studytonight
We provided 3 words seperated by space as arguments, while running the code. 
So, they will be considered as three separate arguments.
Remember that <k>argv[0]</k> holds the name of the program and <k>argv[1]</k> points to the first command line argument and <k>argv[argc-1]</k> gives the last argument. 
If no argument is supplied, <k>argc</k> will be 1.
<h2>&emsp;Some more examples...</h2>
Let's see how inclusion of <b>quotes</b> changes the output of the same program.
Compile the above code again: <k>gcc name_of_file.c</k>
Run it using: <k>./a.out "welcome to studytonight"</k>

1 : welcome to studytonight
Here, we have provided all the 3 words enclosed in a <b>double quote</b>. 
So, it is considered as a <b>single argument</b>. 
Same thing happens with single quotes.
Compile the same code again: <k>gcc name_of_file.c</k>
Then, run it using: <k>./a.out 'welcome to studytonight'</k>

1 : welcome to studytonight
Similarly, we can give <k>int</k> and <k>float</k> type arguments but they will be treated as <k>strings</k>.
Again compile the above code: <k>gcc name_of_file.c</k>
And run it using: <k>./a.out 1 0 a 5.07</k>

1 : 1
2 : 0
3 : a
4 : 5.07
<h2>&emsp;Conclusion</h2>
In this way, we can use command line arguments in C. 
Command Line arguments in C is a great way to provide input to the program at runtime making the program resuable with different input values.

<h2>The Infinite Loop</h2>
A loop becomes an infinite loop if a condition never becomes false. 
The for loop is traditionally used for this purpose. 
Since none of the three expressions that form the 'for' loop are required, you can make an endless loop by leaving the conditional expression empty.

NOTE โ You can terminate an infinite loop by pressing Ctrl + C keys.

<h2>Hello World Program</h2>
Below is a simple program printing Hello World in C language.

<k>printf()</k> is a system defined function under the header file <b>stdio.h</b>, used to print data onto the screen

<k>\n</k> is used to move the control onto the next line

<k>\t</k> is used to give a horizontal tab i.e. continuous five spaces

<k>#include &lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int num;
    printf("\nHello world!\nWelcome to Studytonight: Best place to learn\n");
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/hello-world-1-1.png">

<h2>take input of various datatypes in C</h2>
Below is a program to explain how to take input from user for different datatypes available in C language. 
The different datatypes are <k>int</k>(integer values), <k>float</k>(decimal values) and <k>char</k>(character values).

Here is the C language tutorial explaining various datatypes &rarr; <a href="/c/datatype-in-c.php" target="_blank">Datatypes in C</a>

<k>printf()</k> is used to display text onto the screen

<k>&</k> is used to assign the input value to the variable and store it at that particular location.

<k>scanf()</k> is uded to take input from the user using format specifier discussed in upcoming tutorials

<k>%d</k> and <k>%i</k>, both are used to take numbers as input from the user.

<k>%f</k> is the format specifier to take float as input from the user

<k>%s</k> is the format specifier to take character as input from the user

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int num1, num2;  
    float fraction;     
    char character;

    printf("Enter two numbers number\n");
    // Taking integer as input from user
    scanf("%d%i", &num1, &num2);
    printf("\n\nThe two numbers You have entered are %d and %i\n\n", num1, num2);

    // Taking float or fraction as input from the user
    printf("\n\nEnter a Decimal number\n");
    scanf("%f", &fraction); 
    printf("\n\nThe float or fraction that you have entered is %f", fraction);

    // Taking Character as input from the user
    printf("\n\nEnter a Character\n");
    scanf("%c",&character);
    printf("\n\nThe character that you have entered is %c", character);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/different-data-type-input-1-1.png">

<h2>ASCII value of Character</h2>
Below is a program to find ASCII value of any input character.

<k>%c</k> is the format specifier to take character as input

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    char c;
    printf("Enter a character : ");
    scanf("%c" , &c);
    printf("\n\nASCII value of %c = %d",c,c);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/ascii-value-of-character-1.png">

<h2>How to use <k>gets()</k> function</h2>
Some of the important points about <k>scanf()</k> and <k>gets()</k> are:

<k>scanf()</k> and <k>gets()</k> both are used to take input from the user.
<k>scanf()</k> can only take input until it encounters a space. 
The words after space are ignored by it.
<k>gets()</k> is used to take a single input at a time but can be used to input a complete sentence with spaces unlike scanf().

Below is a program on use of <k>gets()</k>.

<k>gets()</k> takes only a single line at a time i.e all the words before hitting \n(enter key).

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    char str[50];   // char array of size 50
    printf("Enter your complete name:\n\n\n");

    gets(str);
    printf("\n\nWelcome to Studytonight  %s\n\n\n", str);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/use-of-gets-1.png">

<h2>Basic <k>if</k><k>else</k> condition program</h2>
Below is a program on <k>if</k>-<k>else</k>.

Here is the C language tutorial explaining If Else &rarr; <a href="/c/decision-making-in-c.php" target="_blank">If Else in C</a>

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int number;
    printf("Please enter a number:\n");
    scanf("%d",&number);
    /*
        For single statements we can skip the curly brackets
    */
    if(number &lt; 100)
        printf("Number is less than 100!\n");
    else if(number == 100)
        printf("Number is 100!\n");
    else
        printf("Number is greater than 100!\n");

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/if-else-1-1.png">

<h2>Switch Case with <k>break</k></h2>
Below is a program on switch case with break.

<k>switch()</k> can only contain <k>char</k> and <k>int</k>.

<k>break</k> is used to exit from <b>switch</b> statement.

<b>switch</b> case can be without <b>default</b> case.

Another piece of information here is that a <k>char</k> variable is always initialized within <k>''</k>(single quotes).

Here is the C language tutorial explaining Switch Case &rarr; <a href="/c/switch-statement-in-c.php" target="_blank">Switch Case in C</a>

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    // Local Variable Definition
    char grade;
    printf("Enter your grade:\n");
    scanf("%c", &grade);

    switch(grade)
    {
        case 'A':
            printf("Excellent\n");
            break;
        case 'B':
            printf("Keep it up!\n\n");
            break;
        case 'C':
            printf("Well done\nbreak keyword takes execution to exit the switch case\n\n");
            break;
        case 'D':
            printf("You passed\n");
            break;
        case 'F':
            printf("Better luck next time\n");
            break;
        default:
            printf("Invalid grade\n");
    }
    printf("Your grade is %c\n",grade);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>
<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/switch-case-1.png">

<hr>
<h2>Switch Case without <k>break</k></h2>
Below is a program on switch case without break.

If there is no <k>break</k> statement then the cases following the matched case other than <k>default</k> will get executed.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    /* Local Variable Definition */
    char grade;
    printf("Enter your grade:\n");
    scanf("%c", &grade);

    switch(grade)
    {
        case 'A':
            printf("Excellent\n");
        case 'B':
            printf("\n\n\nKeep it up!\n\nNo break statement\n\nHence all the case following this(but not the ones above this) except the default case will get executed !\n\n");
        case 'C':
            printf("\n\n\t\tCase C : Well done !\n\n");
        case 'D':
            printf("\t\tCase D : You passed!\n\n");
        case 'F':
            printf("\t\tCase E : Better luck next time\n\n\n");
        default:
            printf("\t\tDefault Case : Invalid grade\n\n\n");
    }
    printf("Your grade is %c\n",grade);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/switch-case-2.png">

<h2>check if input character is a vowel using Switch Case</h2>
Below is a program to check vowel using switch case.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    char ch;
    printf("Input a Character :  ");
    scanf("%c", &ch);

    switch(ch)
    {
        case 'a':
        case 'A':
        case 'e':
        case 'E':
        case 'i':
        case 'I':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            printf("\n\n%c is a vowel.\n\n", ch);
            break;
        default:
            printf("%c is not a vowel.\n\n", ch);
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/checking-vowel.png">

<h3>Explanation:</h3>
If <k>break</k> statement is not used for a case then all the cases following the valid case are executed and evaluated. 
This way you can make your code easier to understand by writing only <k>break</k> statement only once to check multiple conditions in one go.
<k>default</k> is executed only if none of the above cases are true. 
It is similar to the <k>else</k> statement of the if-else code.

<h2>reverse the case of input character</h2>
Below is a program to reverse the case of input character.

<k>getchar()</k> is similar to <k>scanf()</k>.

<k>islower()</k> is system defined function under <b>ctype.h</b> header file to check if the character is in lowercase or not.

<k>toupper()</k> converts the input parameter into equivalent uppercase char.

<k>putchar()</k> is similar to <k>printf()</k>.

<k>#include&lt;stdio.h>
#include&lt;ctype.h> // to use system defined function islower & toupper

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    char alphabet;
    printf("Enter an alphabet : ");
    putchar('\n');  // to move to next Line

    alphabet=getchar();

    printf("\n\nReverse case of %c is :  ",alphabet);

    if(islower(alphabet))
        putchar(toupper(alphabet));

    else 
        // must be an uppercase character
        printf("%c",tolower(alphabet)) ;

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/reverse-case-of-character.png">

<h2>Swapping two Numbers using a Temporary Variable</h2>
Below is a program to swap two numbers using temporary variable.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void main()
{
    int x = 10, y = 15, temp;
    temp = x;
    x = y;
    y = temp;
    printf("x = %d and y = %d", x, y);
    getch();
}</k>

x = 15 and y = 10

<hr />
<h2>Swapping tow Numbers without using a Temporary Variable</h2>
Below is a program to swap two numbers without using any temporary variable.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void main()
{
    int x = 10, y = 15;
    x = x + y - (y = x);
    printf("x = %d and y = %d",x,y);
    getch();
}</k>

x = 15 and y = 10

<hr />
<h2>Swapping two Numbers using Bitwise Operator</h2>
Below is a program to swap two numbers using bitwise operator.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void main()
{
    int x = 6, y = 4;
    x = x^y;
    y = x^y;
    x = x^y;
    printf("x = %d and y = %d", x, y);
    getch();
}</k>

x = 4 and y = 6

<hr />
<h2>Swapping two Numbers using Multiplication and Division</h2>
Below is a program to swap two numbers using multiplication and division.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void main()
{
    int x = 6, y = 4;
    x = x*y;
    y = x/y;
    x = x/y;
    printf("x = %d and y = %d", x, y);
    getch();
}</k>

x = 4 and y = 6

<h2>print the Largest and Smallest using Global Declaration</h2>
Some important points about Global variable declaration are:

It can be done anywhere within the program.
Unlike local variables that can be used within the scope of a particular function.
<k>&</k> is used to assign the input value to the variable and store it at that particular location.
<k>%0nd</k> is used to represent numbers in <k>n</k> digit format with leading 0's.

Below is a program to find largest and smallest value using global declaration.

<k>#include&lt;stdio.h>

int a,b;
int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    printf("\n\nEnter the two values to find the greatest and smallest number: \n");
    scanf("%d%d", &a, &b);

    if(a == b)
        printf("Both are equal\n");
        
    else if(a &lt; b)
    {
        printf("\n\nThe largest number is %03d\n", b);
        printf("\nThe smallest number is %03d\n", a);
        printf("\nThe largest number is %03d\n", b);
    }
    else    //Only possibility remaining
    {
        printf("The largest number is %03d\n", a);
        printf("The smallest number is %03d\n", b);
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/largest-and-smallest-using-global-declaration.png">

<h2>Basic <k>for</k> Loop Program</h2>
Every loop consists of three parts in a sequence

<b>Initialization</b>: Use to initialize the loop variable.
<b>Condition</b>: It is checked after each iteration as an entry point to the loop.
<b>Updation</b>: Incrementing the loop variable to eventually terminate the loop not satisfying the loop condition.

Remember that the loop condition checks the conditional statement before it loops again.

<b>Syntax:</b>

<k>for(initialization, condition, incrementation)
{ 
    code statements;
}</k>
Below is a simple program on <k>for</k> loop.

Here is the C language tutorial explaining <k>for</k> Loop &rarr; <a href="/c/loops-in-c.php" target="_blank">For Loop in C</a>

#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    /* 
        Always declare the variables before using them 
    */
<k>    int i = 0;  // declaration and initialization at the same time
    for(i = 0; i < 10; i++)
    {
        printf("i = %d\n", i);
     }
</k>
        /*
            consequently, when i equals 10, the loop breaks.
            i is updated before the condition is checked-
            hence the value of i after exiting the loop is 10 
        */

    printf("\n\The value of i after exiting the loop is %d\n\n", i);
    printf("\nRemember that the loop condition checks the conditional statement before it loops again.\n\n");
    printf("Consequently, when i equals 10, the loop breaks.\n\n");
    printf("i is updated before the condition is checked- hence the value of i after exiting the loop is 10 .\n\n");
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/for-loop.png">

<h2>Simple <k>while</k> Loop Program</h2>
Every loop consists of three parts in sequence

<b>Initialization</b>: Use to initialize the loop variable.
<b>Condition</b>: It is checked after each iteration as an entry point to the loop.
<b>Updation</b>: Incrementing the loop variable to eventually terminate the loop not satisfying the loop condition.

Below is a simple program on <k>while</k> loop.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    /* 
        always declare the variables before using them 
    */
    int i = 0;  // declaration and initialization at the same time

    printf("\nPrinting numbers using while loop from 0 to 9\n\n");

    /* 
        while i is less than 10 
    */
    while(i&lt;10)
    {
        printf("%d\n",i);

        /* 
            Update i so the condition can be met eventually 
            to terminate the loop 
        */
        i++;    // same as i=i+1;
      }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/while-loop.png">

<h2>Basic <k>do while</k> Loop Program</h2>
Every loop consists of three parts in sequence:

<b>Initialization</b>: Use to initialize the loop variable.
<b>Condition</b>: It is checked after each iteration as an entry point to the loop.
<b>Updation</b>: Incrementing the loop variable to eventually terminate the loop not satisfying the loop condition.

Do while loop is used when the actual code must be executed atleast <b>once</b>. 
For example: Incase of menu driven functions.

Below is a simple program on do while loop.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    /* 
        always declare the variables before using them 
    */
    int i = 10;     // declaration and initialization at the same time

    do // do contains the actual code and the updation
    {
        printf("i = %d\n",i);
        i = i-1;    // updation
    }
    // while loop doesn't contain any code but just the condition
    while(i > 0);
    printf("\n\The value of i after exiting the loop is %d\n\n", i);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/do-while-loop.png">

<h2>Basic program to show use of nested <k>for</k> Loops</h2>
Nested loops are usually used to print a pattern in C. 
They are also used to print out the matrix using a 2 dimensional array and a lot of other patterns like pyramid of numbers etc.

Using a loop inside another loop is called <b>nested loop</b>.

Below is a simple program on nested loops.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    printf("\n\nNested loops are usually used to print a pattern in c. \n\n");
    printf("\n\nThey are also used to print out the matrix using a 2 dimensional array. \n\n");

    int i,j,k;
    printf("\n\nOutput of the nested loop is :\n\n");
    for(i = 0; i &lt; 5; i++)
    {
        printf("\t\t\t\t");
        for(j = 0; j &lt; 5; j++)
        printf("* ");

        printf("\n");
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/nested-loops.png">

<h2>print Factorial of a Number</h2>
Below is a program to find factorial of a number using <k>for</k> loop.

<k>#include&lt;stdio.h>
#include&lt;conio.h>
void main()
{
   int fact, i, n;
   fact = 1;
   printf("Enter the number\t");
   scanf("%d" , &n);
   for(i = 1; i <= n; i++)
   {
       fact = fact*i;
   }
   printf("Factorial of %d is %d", n , fact);
   getch();
}</k>

Enter the number 5
Factorial of 5 is 120

<h2>print the Fibonacci Series</h2>
Below is a program to print the Fibonacci series using <k>while</k> loop.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void fibonacci(int num);
void main()
{
    int num = 0;
    clrscr();
    printf("Enter number of terms\t");
    scanf("%d", &num);
    fibonacci(num);
    getch();
}

void fibonacci(int num)
{
   int a, b, c, i = 3;
   a = 0;
   b = 1;
   if(num == 1)
   printf("%d",a);

   if(num >= 2)
   printf("%d\t%d",a,b);

   while(i &lt;= num)
   {
      c = a+b;
      printf("\t%d", c);
      a = b;
      b = c;
      i++;
   }
}</k>

Enter number of terms 6
0 1	1	2	3	5

<h2>check whether a Number is a Palindrome</h2>
Below is a program to check whether a number is a palindrome or not.

A <b>palindrome</b> is a number or a string which is similar when read from the front and from the rear. 
For example: 121 or Oppo etc.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void main()
{
    int a, b, c, s = 0;
    clrscr();
    printf("Enter a number:\t");
    scanf("%d", &a);
    c = a;

   // the number is reversed inside the while loop.
   while(a > 0)
   {
      b = a%10;
      s = (s*10)+b;
      a = a/10;
   }

   // here the reversed number is compared with the given number.
   if(s == c)
   {
      printf("The number %d is a palindrome", c);
   }
   else
   {
      printf("The number %d is not a palindrome", c);
   }
  getch();
}</k>

Enter the number: 121
The number 121 is a palindrome

<h2>find Sum of Digits of a Number</h2>
Below is a program for sum of digits of a number.

<k>#include&lt;stdio.h>

int main()
{
	printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

	int n, sum = 0, c, remainder;

    	printf("Enter the number you want to add digits of:  ");
    	scanf("%d", &n);

	while(n != 0)
    	{
        	remainder = n%10;
        	sum += remainder;
        	n = n/10;
    	}

    	printf("\n\nSum of the digits of the entered number is  =  %d\n\n", sum);
    	printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    	return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/sum-of-digits-program-1.png">

<h2>reverse a String</h2>
Below is a program to reverse a string in C language.

<k>#include&lt;stdio.h>
#include&lt;conio.h>
void main()
{
    int i, j, k;
    char str[100];
    char rev[100];
    printf("Enter a string:\t");
    scanf("%s", str);
    printf("The original string is %s\n", str);
    for(i = 0; str[i] != '\0'; i++);
    {
        k = i-1;
    }
    for(j = 0; j <= i-1; j++)
    {
        rev[j] = str[k];
        k--;
    }
    printf("The reverse string is %s\n", rev);
    getch();
}</k>

Enter a string: studytonight
The original string is studytonight
The reverse string is thginotyduts

<h2>find average of N Numbers</h2>
Below is a program to calculate average of <b>n</b> numbers.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int n, i;
    float sum = 0, x;

    printf("Enter number of elements:  ");
    scanf("%d", &n);
    printf("\n\n\nEnter %d elements\n\n", n);
    for(i = 0; i &lt; n; i++)
    {
        scanf("%f", &x);
        sum += x;
    }
    printf("\n\n\nAverage of the entered numbers is =  %f", (sum/n));
    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/average-of-n-numbers-1.png">

<h2>find Armstrong Number between 1 to 500</h2>
An <b>Armstrong number</b> or <b>Narcissistic number</b> is a <b>n</b> digit number such that the sum of its digits raised to the nth power is equal to the number itself.

For example, Let's take an armstrong number: <k>153</k>, which is 3 digit number, here <k>1<sup>3</sup> + 5<sup>3</sup> + 3<sup>3</sup></k> is <k>1 + 125 + 27</k> which is equal to <b>153</b>.

Below is a program to find armstrong numbers between 1 to 500.

<k>#include&lt;stdio.h>
#include&lt;math.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n,sum,i,t,a;
    printf("\n\n\nThe Armstrong numbers in between 1 to 500 are : \n\n\n");

    for(i = 1; i &lt;= 500; i++)
    {
        t = i;  // as we need to retain the original number
        sum = 0;
        while(t != 0)
        {
            a = t%10;
            sum += a*a*a;
            t = t/10;
        }

        if(sum == i)
        printf("\n\t\t\t%d", i);
    }

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/armstrong-number-program-1.png">

<hr />
<h2>check whether a number is Armstrong Number</h2>
Below is a program to check whether a number is armstrong or not.

<k>#include&lt;stdio.h>
#include&lt;math.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int n, sum = 0, c, t, a;

    printf("Enter a number:  ");
    scanf("%d", &n);

    t = n;  // as need to retain the original number
    while(n != 0)
    {
        a = n%10;
        sum += a*a*a;
        n = n/10;
    }

    printf("\n\n\n\t\t\tsum = %d", sum);

    if(sum == t)
        printf("\n\n\t\t%d is an armstrong number\n", t);
    else
        printf("\n\n\t\t%d is not an armstrong number\n", t);

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/armstrong-number-program-2.png">

<h2>Checking for Odd and Even Numbers using Bitwise Operator</h2>
Below is a program to find whether a number is even or odd using bitwise operator.

<k>x&1</k> returns <b>true</b> if the LSB(Least significant Bit) of binary representation of an integer x is 1. 
It returns <b>false</b> if the LSB or the Right most bit in a binary sequence is 0.

In binary representation of an integer, if LSB is 1 then it is <b>odd</b> and if LSB is 0 then it is <b>even</b>.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int x;
    for(x = 0; x &lt;= 10; x++)
    {
        if(x&1) // if number is odd
            printf("\t\t\t%d is odd\n",x);
        else if(!(x&1)) // ! is used inside if to reverse the boolean value
            printf("\t\t\t%d is even\n",x);
    }

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/checking-for-odd-or-even-1.png">

<hr>
We have used a simple <k>for</k> loop to input numbers and show how to use the Bitwise operator. 
You can take input from user using <k>scanf()</k> and use th same logic to find if the input number is odd or even.
<h2>Checking if inout number is Odd or Even without using <k>%</k>(Mod) Operator</h2>
Below is a program to find whether a number is even or odd without using <k>%</k>(Mod) operator.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n;
    printf("Enter a number:  ");
    scanf("%d",&n);

    if((n/2)*2 == n)
        printf("\n\n\t\t %d is Even\n", n);
    else
        printf("\n\n\t\t %d is Odd\n", n);

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/checking-for-odd-or-even-2.png">

<h2>find Factors of a Number</h2>
Below is a program to find factors of a number.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int  num, i;
    printf("Enter the number to find the factors of :  ");
    scanf("%d",&num);
    printf("\n\n\nFactors of %d are \n\n", num);

    for(i = 1; i &lt;= num/2; i++)
    {
        if(num%i == 0)
            printf("\t\t\t%d\n", i);
    }

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/factors-of-a-number-2.png">

<h2>find Sum of <k>N</k> input Numbers in C</h2>
Below is a program on sum of n numbers.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n,sum=0,c,value;

    printf("\n\nEnter the number of integers you want to add:  ");
    scanf("%d", &n);

    printf("Enter %d integers\n\n",n);
    for(c = 1; c &lt;= n; c++)
    {
        scanf("%d", &value);
        /* 
            need to initialise sum before using otherwise 
            garbage value will get printed
        */
        sum += value;
    }

    printf("\n\n\nsum of entered numbers  = %d", sum);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/sum-of-n-numbers-1.png">

<h2>find first <k>N</k> Prime Numbers</h2>
Below is a program to find first <k>n</k> prime numbers using nested <k>for</k> loops, where the value of <k>n</k> is input by the user.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n,i = 3, count, c;

    printf("\nEnter the number of prime numbers required :  ");
    scanf("%d", &n);

    if(n >= 1)
    {
        printf("\n\nFirst %d prime numbers are :  ", n);
        printf("2 ");
    }

    // iteration for n prime numbers
    // i is the number to be checked in each iteration starting from 3
    for(count = 2; count &lt;= n; i++)  
    {
        // iteration to check c is prime or not
        for(c = 2; c &lt; i; c++)
        {
            if(i%c == 0)
                break;
        }

        if(c == i)  // c is prime
        {
            printf("%d ", i);
            count++;    // increment the count of prime numbers
        }

    }
    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/first-n-prime-numbers-1.png">

<h2>find the Largest number among <k>n</k> input Numbers</h2>
Below is a program to find largest number among <k>n</k> user input numbers.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n,i;
    float c,big;

    printf("\n\nEnter the number of elements you wish to find the greatest element of: ");
    scanf("%d", &n);
    printf("\n\nEnter %d numbers :\n", n);

    printf("\n\n\t\t\tElement 1: ");

    //Important step- always initialize big to the first element
    scanf("%f", &big);

    for(i = 2; i &lt;= n; i++)
    {
        printf("\n\t\t\tElement %d  : ", i);
        scanf("%f", &c);
        /* 
            if input number is larger than the 
            current largest number
        */
        if(big &lt; c)  
            big = c;    // update big to the larger value
    }

    printf("\n\n\nThe largest of the %d numbers is  %f ", n, big);
    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/largest-of-n-numbers-1.png">

<h2>find exponential without using <k>pow()</k> method</h2>
Below is a program to find exponential without using <k>pow()</k> method.

<k>long long int</k> is of double the size of <k>long int</k>.

<k>%lld</k> is the format specifier for <k>long long int</k>.

<k>#include&lt;stdio.h>
int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int n, exp, exp1;
    long long int value = 1;

    printf("Enter the number and its exponential:\n\n");
    scanf("%d%d",&n, &exp);

    exp1 = exp;   // storing original value for future use

    // same as while((--exp)!=-1)
    while(exp-- > 0)
    {
        value *= n; // multiply n to itself exp times
    }

    printf("\n\n %d^%d = %lld\n\n", n, exp1, value);
    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/finding-exponential-without-pow()-method-1.png">

<h2>check if input Number is <k>int</k> or <k>float</k></h2>
Below is a program to check whether the user input number is of integer or float datatype.

<k>strlen()</k> does not count the null character '\0'.

<k>#include&lt;stdio.h>

#include&lt;conio.h>
#include&lt;string.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    char number[10];
    int flag = 0;
    int length, i = 0;

    printf("\n\nEnter a number: ");
    scanf("%s", number);

    length = strlen(number);

    // till string does not end
    while(number[i++] != '\0')    // same as while(length-->0)
    {
        if(number[i] == '.')    // decimal point is present
        {
            flag = 1;
            break;
        }
    }

    // if(0) is same as if(false)
    if(flag)
        printf("\n\n\n\tEntered Number is a Floating point Number\n\n");
    else
        printf("\n\n\n\tEntered Number is a integer Number\n\n");

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/input-number-is-int-or-float-1.png">

<h2>print the Multiplication Table of any Number</h2>
Below is a program to print the multiplication table of any user input number.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n,i;

    printf("Enter an integer you need to print the table of: ");
    scanf("%d", &n);
    printf("\n\n\n");

    for(i = 1; i &lt;= 10; i++)
    {
        printf("\n\t\t\t%d * %d   =   %d \n", n, i, n*i);
    }

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/multiplication-table-of-a-number-1.png">

<h2>print the reverse of an Array</h2>
Below is a simple program to reverse an array.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int c, d, n, a[100], b[100];
    printf("\n\nEnter number of elements in array :");
    scanf("%d", &n);
    printf("\n\nEnter %d elements\n", n);

    for(c = 0; c &lt; n; c++)
        scanf("%d", &a[c]);

    /*
        temporarily storing elements into array b 
        starting from end of array a
    */
    for(c = n-1, d = 0; c >= 0; c--, d++)
        b[d] = a[c];

    /*
        copying reversed array into original.
        Here we are modifying original array to reverse it.
    */

    for(c = 0; c &lt; n; c++)
        a[c] = b[c];

    printf("\n\n Resultant array is: ");
    for(c = 0; c &lt; n; c++)
        printf("%d", a[c]);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/reverse-an-array.png">

<h2>insert an element in an Array</h2>
Below is a simple program to insert an element in an array.

Here is the C language tutorial explaining Arrays &rarr; <a href="/c/arrays-in-c.php" target="_blank">Arrays in C</a>

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int array[100], position, c, n, value;

    printf("\n\nEnter number of elements in array:");
    scanf("%d", &n);

    printf("\n\nEnter %d elements\n", n);
    for(c = 0; c &lt; n; c++)
        scanf("%d", &array[c]);

    printf("\n\nEnter the location where you want to insert new element:  ");
    scanf("%d", &position);

    printf("\n\nEnter the value to insert: ");
    scanf("%d", &value);

    // shifting the elements from (position to n) to right
    for(c = n-1; c >= position-1; c--)
        array[c+1] = array[c];

    array[position - 1] = value;    // inserting the given value

    printf("\n\nResultant array is: ");
    /* 
        the array size gets increased by 1 
        after insertion of the element
    */
    for(c = 0; c &lt;= n; c++) 
        printf("%d  ", array[c]);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

In the above program we take an array as user input and then ask the user for a new number that they wish to add to the original array, and the position where they want to add the new number.

The we shift the existing numbers from the index <b>position</b> to the end of the array one position to the right, therby vacating a space for the new element. 
And then we add the new number at the user specified <b>position</b> index.

<br />
<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/insert-an-element.png">

<h2>Delete an Element from Array in C</h2>
Below is a simple program to delete an element from array, where the position of element to be deleted is given by user.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int array[100], position, c, n;
    printf("\n\nEnter number of elements in array:");
    scanf("%d", &n);

    printf("\n\nEnter %d elements\n", n);
    for(c = 0; c &lt; n; c++)
        scanf("%d", &array[c]);

    printf("\n\nEnter the location where you want to delete element from:  ");
    scanf("%d", &position);

    if(position >= n+1)
        printf("\n\nDeletion not possible\n\n");
    else 
        // updating the locations with next elements
        for(c = position-1; c &lt; n-1; c++)
        array[c] = array[c+1];

    printf("\n\nResultant array is: ");
    /* 
        the array size gets reduced by 1 
        after deletion of the element
    */
    for(c = 0; c &lt; n-1; c++) 
        printf("%d  ", array[c]);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/delete-an-element.png">

<hr>
<h2>Delete an element from array based on value</h2>
Below is a simple program to delete an element from array, where the element to be deleted is given by user:

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int array[10], element, c, n, pos;
    /* 
        initialization as garbage value is 
        stored by default in c variables
    */
    int found = 0; 
    printf("\n\nEnter number of elements in array:");
    scanf("%d", &n);

    printf("\n\nEnter %d elements\n", n);

    for(c = 0; c &lt; n; c++)
        scanf("%d", &array[c]);

    printf("\n\nThe input array is: ");
    for(c = 0; c &lt; n; c++)
    printf("%d", array[c]);

    printf("\n\nEnter the element to be deleted: ");
    scanf("%d", &element);

    // check the element to be deleted is in array or not
    for(c = 0; c &lt; n; c++)
    {
        if(array[c] == element)
        {
            found = 1;
            pos = c;
            break;  // terminate the loop
        }
    }
    if(found == 1) // the element to be deleted exists in the array
    {
        for(c = pos; c &lt; n-1; c++)
            array[c] = array[c+1];
    }
    else
        printf("\n\nElement %d is not found in the array\n\n", element);

    printf("\n\nResultant array is: ");
    /* 
        the array size gets reduced by 1 
        after deletion of the element
    */
    for(c = 0; c &lt; n-1; c++) 
        printf("%d  ",array[c]);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/delete-an-element-2.png">

<h2>find Largest and Smallest Element in an Array</h2>
Below is a program to find the largest and smallest elements in array.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int a[50], size, i, big, small;

    printf("\nEnter the size of the array: ");
    scanf("%d", &size);

    printf("\n\nEnter the %d elements of the array: \n\n", size);
    for(i = 0; i &lt; size; i++)
    scanf("%d", &a[i]);

    big = a[0]; // initializing
    /* 
        from 2nd element to the last element 
        find the bigger element than big and 
        update the value of big
    */
    for(i = 1; i &lt; size; i++)
    {
        if(big &lt; a[i])   // if larger value is encountered
        {
            big = a[i]; // update the value of big
        }
    }
    printf("\n\nThe largest element is: %d", big);

    small = a[0];   // initializing
    /*
        from 2nd element to the last element 
        find the smaller element than small and 
        update the value of small
    */
    for(i = 1; i &lt; size; i++)
    {
        if(small>a[i])   // if smaller value is encountered
        {
            small = a[i];   // update the value of small
        }
    }
    printf("\n\nThe smallest element is: %d", small);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</b></h3>
<img src="https://www.studytonight.com/c/programs/output/largest-and-smallest-array.png">

<h2>find Sum of N input Numbers using Array</h2>
Below is a program to find and print the sum of n numbers using arrays.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n, sum = 0, c, array[100];

    printf("Enter the number of integers you want to add: ");
    scanf("%d", &n);

    printf("\n\nEnter %d integers \n\n", n);

    for(c = 0; c &lt; n; c++)
    {
        scanf("%d", &array[c]);
        sum += array[c];    // same as sum = sum + array[c]
    }

    printf("\n\nSum = %d\n\n", sum);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/sum-of-n-numbers-using-arrays-1.png">

<h2>Simple Program to Sort Array elements</h2>
Below is a program to sort array elements in an array.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

void sorting(int *x, int y);

void main()
{
    int a[20], i, c, n;
    clrscr();
    printf("Enter number of elements you want to sort: ");
    scanf("%d", &n);

    for(i = 0; i &lt; n; i++)
    scanf("%d", &a[i]);

    sorting(a, n);

    for(i = 0; i &lt;n; i++)
    printf("%d\t", a[i]);

    getch();
}

void sorting(int *x, int y)
{
    int i, j, temp;
    for(i = 1; i &lt;= y-1; i++)
    {
        for(j = 0; j &lt; y-i; j++)
        {
            if(*(x+j) > *(x+j+1))
            {
                temp = *(x+j);
                *(x+j) = *(x+j+1);
                *(x+j+1) = temp;
            }
        }
    }
}</k>

Enter number of elements you want to sort: 6
5 3 4 2 1 6
1 2 3 5 6

<h2>Simple Program to remove Duplicate Element in an Array</h2>
Below is a program to find and remove any duplicate element present in the specified array.

<k>#include&lt;stdio.h>
#include&lt;conio.h>
void main()
{
    int a[20], i, j, k, n;
    clrscr();

    printf("\nEnter array size: ");
    scanf("%d", &n);

    printf("\nEnter %d array element: ", n);
    for(i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    printf("\nOriginal array is: ");
    for(i = 0; i < n; i++)
    {
        printf(" %d", a[i]);
    }

    printf("\nNew array is: ");
    for(i = 0; i < n; i++)
    {
        for(j = i+1; j < n; )
        {
            if(a[j] == a[i])
            {
                for(k = j; k < n; k++)
                {
                    a[k] = a[k+1];
                }
                n--;
            }
            else
            {
                j++;
            }
        }
    }

    for(i = 0; i < n; i++)
    {
        printf("%d ", a[i]);
    }
    getch();
}</k>

Enter array size: 5
Enter 5 array element: 11 13 11 12 13
Original array is: 11 13 11 12 13
New array is: 11 13 12

<h2>check whether a two dimensional array is a Sparse Matrix</h2>
A Sparse Matrix is a matrix(two-dimensional array) in which number of 0's is greater than the number of non-zero elements.

Below is a program to check whether a matrix is sparse or not.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n, m, c, d, matrix[10][10];
    int counter = 0;
    printf("\nEnter the number of rows and columns of the matrix \n\n");
    scanf("%d%d",&m,&n);

    printf("\nEnter the %d elements of the matrix \n\n", m*n);
    for(c = 0; c &lt; m; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            scanf("%d", &matrix[c][d]);
            if(matrix[c][d] == 0)
            counter++;  // same as counter=counter +1
        }
    }

    // printing the matrix
    printf("\n\nThe entered matrix is: \n\n");
    for(c = 0; c &lt; m; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            printf("%d\t", matrix[c][d]);
        }
    printf("\n"); // to take the control to the next row
    }

    // checking if the matrix is sparse or not
    if(counter > (m*n)/2)
        printf("\n\nThe entered matrix is a sparse matrix\n\n");
    else
        printf("\n\nThe entered matrix is not a sparse matrix\n\n");

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/sparse-matrix.png">

<h2>check whether given Square Matrix is symmetric or not</h2>
Few important points to remember:

A Square Matrix is said to be symmetric if it is equal to it's <b>transpose</b>.
Transpose of a matrix is achieved by exchanging <b>indices</b> of rows and columns.
Transpose is only defined for a square matrix.
Below is a program to check whether sqaure matrix is symmetric or not.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int c, d, a[10][10], b[10][10], n, temp;
    printf("\nEnter the dimension of the matrix: \n\n");
    scanf("%d", &n);

    printf("\nEnter the %d elements of the matrix: \n\n",n*n);
    for(c = 0; c &lt; n; c++) // to iterate the rows
        for(d = 0; d &lt; n; d++) // to iterate the columns
            scanf("%d", &a[c][d]);

    // finding transpose of a matrix and storing it in b[][]
    for(c = 0; c &lt; n; c++) // to iterate the rows
        for(d = 0; d &lt; n; d++) //to iterate the columns
            b[d][c] = a[c][d];

    // printing the original matrix
    printf("\n\nThe original matrix is: \n\n");
    for(c = 0; c &lt; n; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            printf("%d\t", a[c][d]);
        }
    printf("\n");
    }

    // printing the transpose of the entered matrix
    printf("\n\nThe Transpose matrix is: \n\n");
    for(c = 0; c &lt; n; c++) // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            printf("%d\t", b[c][d]);
        }
        printf("\n");
    }

    // checking if the original matrix is same as its transpose
    for(c = 0; c &lt; n; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            /* 
                even if they differ by a single element, 
                the matrix is not symmetric
            */
            if(a[c][d] != b[c][d]) 
            {
                printf("\n\nMatrix is not Symmetric\n\n");
                exit(0);    // a system defined method to terminate the program
            }
        }
    }

    /* 
        if the program is not terminated yet, 
        it means the matrix is symmetric
    */
    printf("\n\nMatrix is Symmetric\n\n");
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/symmetric-matrix-1.png">

<h2>find Deteminant of 2x2 Matrix</h2>
Below is a program to find the <b>determinant</b> of a 2x2 matrix.

Please note that, when we say a 2x2 matrix, we mean an array of 2x2.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int a[2][2], i, j;
    long determinant;

    printf("\n\nEnter the 4 elements of the array\n");
    for(i = 0; i &lt; 2; i++)
    for(j = 0; j &lt; 2; j++)
    scanf("%d", &a[i][j]);

    printf("\n\nThe entered matrix is: \n\n");
    for(i = 0; i &lt; 2; i++)
    {
        for(j = 0; j &lt; 2; j++)
        {
            printf("%d\t", a[i][j]);   // to print the complete row
        }
        printf("\n"); // to move to the next row
    }

    // finding the determinant of a 2x2 matrix
    determinant = a[0][0]*a[1][1] - a[1][0]*a[0][1];
    printf("\n\nDterminant of 2x2 matrix is : %d - %d =  %d", a[0][0]*a[1][1], a[1][0]*a[0][1], determinant);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/determinant-matrix.png">

<h2>find Normal and Trace of a Square Matrix</h2>
Few important points to remember:

<b>Normal</b> and <b>Trace</b> are only defined for a square matrix.
<b>Square Matrix</b>: Matrix in which, the number of rows = number of columns.

<b>Normal</b>: Square root of the sum of the squares of each element of the matrix.
<b>Trace</b>: Sum of the diagonal elements of a matrix.
<b>Diagonal Element</b>: An element having same indices for row and column.
Let's have a simple example to understand these terms better:

<img src="https://www.studytonight.com/c/programs/images/trace-and-normal-of-matrix.jpg" />

Below is a program to find Normal and Trace of Square Matrix.

<k>#include&lt;stdio.h>
/* 
    to use the sqrt method to find 
    the square root of a number we include
    math.h header file
*/
#include&lt;math.h>  

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int i, j, n, aj[10][10], sum = 0, sum1 = 0, a = 0, normal;

    printf("\nEnter the number of rows (columns) of the matrix: \n\n");
    scanf("%d", &n);

    printf("\nEnter the %d elements of the first matrix: \n\n", n*n);

    for(i = 0; i &lt; n; i++)   // to iterate the rows
    {
        for(j = 0; j &lt; n; j++)   // to iterate the columns
        {
            scanf("%d", &aj[i][j]);
            a = aj[i][j]*aj[i][j];  // finding square of each element
            sum1 += a;  // same as sum1 = sum1 + a
        }
    }
    normal = sqrt((double)sum1);    // typecasting to double value

    printf("\n\nThe normal of the given matrix is: %d", normal);
    for(i = 0; i &lt; n; i++)
    {
        sum = sum + aj[i][i];   // sum of the diagonal elements
    }
    printf("\n\nThe Trace of the given matrix is: %d", sum);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/normal-and-trace.png">

<h2>perform addition and subtraction of Matrices</h2>
Below is a program to perform Addition and Subtraction on two matrices.

<k>\n</k> is used to take the control to the next row.

<k>\t</k> is used to take control 5 spaces(tab) ahead.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int n, m, c, d, first[10][10], second[10][10], sum[10][10], diff[10][10];
    printf("\nEnter the number of rows and columns of the first matrix \n\n");
    scanf("%d%d", &m, &n);

    printf("\nEnter the %d elements of the first matrix \n\n", m*n);
    for(c = 0; c &lt; m; c++)   // to iterate the rows
        for(d = 0; d &lt; n; d++)   // to iterate the columns
            scanf("%d", &first[c][d]);

    printf("\nEnter the %d elements of the second matrix \n\n", m*n);
    for(c = 0; c &lt; m; c++)   // to iterate the rows
        for(d = 0; d &lt; n; d++)   // to iterate the columns
            scanf("%d", &second[c][d]);

    /*
        printing the first matrix
    */
    printf("\n\nThe first matrix is: \n\n");
    for(c = 0; c &lt; m; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            printf("%d\t", first[c][d]);
        }
    printf("\n");
    }

    /* 
        printing the second matrix
    */
    printf("\n\nThe second matrix is: \n\n");
    for(c = 0; c &lt; m; c++)   // to iterate the rows
    {
        for(d = 0; d &lt; n; d++)   // to iterate the columns
        {
            printf("%d\t", second[c][d]);
        }
    printf("\n");
    }

    /* 
        finding the SUM of the two matrices 
        and storing in another matrix sum of the same size
    */
    for(c = 0; c &lt; m; c++)
        for(d = 0; d &lt; n; d++)
            sum[c][d] = first[c][d] + second[c][d];

    // printing the elements of the sum matrix
    printf("\n\nThe sum of the two entered matrices is: \n\n");
    for(c = 0; c &lt; m; c++)
    {
        for(d = 0; d &lt; n; d++)
        {
            printf("%d\t", sum[c][d]);
        }
        printf("\n");
    }

    /*
        finding the DIFFERENCE of the two matrices 
        and storing in another matrix difference of the same size
    */
    for(c = 0; c &lt; m; c++)
        for(d = 0; d &lt; n; d++)
            diff[c][d] = first[c][d] - second[c][d];

    // printing the elements of the diff matrix
    printf("\n\nThe difference(subtraction) of the two entered matrices is: \n\n");
    for(c = 0; c &lt; m; c++)
    {
        for(d = 0; d &lt; n; d++)
        {
            printf("%d\t", diff[c][d]);
        }
        printf("\n");
    }

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/addition-and-subtraction-1.png">

<h2>for Matrix Multiplication</h2>
Below is a program on Matrix Multiplication.

Two matrices with a given order can be multiplied only when number of columns of first matrix is equal to the number of rows of the second matrix.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int n, m, c, d, p, q, k, first[10][10], second[10][10], pro[10][10],sum = 0;

    printf("\nEnter the number of rows and columns of the first matrix: \n\n");
    scanf("%d%d", &m, &n);

    printf("\nEnter the %d elements of the first matrix: \n\n", m*n);
    for(c = 0; c &lt; m; c++)   // to iterate the rows
        for(d = 0; d &lt; n; d++)   // to iterate the columns
            scanf("%d", &first[c][d]);

    printf("\nEnter the number of rows and columns of the first matrix: \n\n");
    scanf("%d%d", &p, &q);

    if(n != p)
        printf("Matrices with the given order cannot be multiplied with each other.\n\n");

    else    // matrices can be multiplied
    {
        printf("\nEnter the %d elements of the second matrix: \n\n",m*n);

        for(c = 0; c &lt; p; c++)   // to iterate the rows
            for(d = 0; d &lt; q; d++)   // to iterate the columns
                scanf("%d", &second[c][d]);

        // printing the first matrix
        printf("\n\nThe first matrix is: \n\n");
        for(c = 0; c &lt; m; c++)   // to iterate the rows
        {
            for(d = 0; d &lt; n; d++)   // to iterate the columns
            {
                printf("%d\t", first[c][d]);
            }
            printf("\n");
        }

        // printing the second matrix
        printf("\n\nThe second matrix is: \n\n");
        for(c = 0; c &lt; p; c++)   // to iterate the rows
        {
            for(d = 0; d &lt; q; d++)   // to iterate the columns
            {
                printf("%d\t", second[c][d]);
            }
            printf("\n");
        }

        for(c = 0; c &lt; m; c++)   // to iterate the rows
        {
            for(d = 0; d &lt; q; d++)   // to iterate the columns
            {
                for(k = 0; k &lt; p; k++)
                {
                    sum = sum + first[c][k]*second[k][d];
                }
            pro[c][d] = sum;    // resultant element of pro after multiplication
            sum = 0;    // to find the next element from scratch
            }
        }

        // printing the elements of the product matrix
        printf("\n\nThe multiplication of the two entered matrices is: \n\n");
        for(c = 0; c &lt; m; c++)   // to iterate the rows
        {
            for(d = 0; d &lt; q; d++)   // to iterate the columns
            {
                printf("%d\t", pro[c][d]);
            }
            printf("\n"); // to take the control to the next row
        }
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/matrix-multiplication.png">

<h2>Basic Program for Pointers</h2>
Few important points to remember:

<k>*</k> is used to access the value stored in the pointer variable.
<k>&</k> is used to store the address of a given variable.
Here is the C language tutorial on Pointers in C &rarr; <a href="/c/pointers-in-c.php" target="_blank">Pointers in C</a>

Below is a simple program on pointer.

<k>int *p;</k> is a pointer variable declaration where <k>p</k> is a pointer to an <k>int</k> variable i.e. it stores the location of an integer.

<k>%x</k> is a format specifier to print hexadecimal value. 
It is usually used to print the location.

<k>#include &lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int var = 24;   // actual variable declaration
    int *p;

    p = &var;   // storing address of int variable var in pointer p

    printf("\n\nAddress of var variable is: %x \n\n", &var);

    // address stored in pointer variable
    printf("\n\nAddress stored in pointer variable p is: %x", p);

    // access the value using the pointer variable
    printf("\n\nValue of var variable or the value stored at address p is   %d ", *p);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/simple-pointer-program.png">

<h2>Program for Dynamic Memory Allocation using <k>malloc()</k></h2>
Below is a program on dynamic memory allocation using <k>malloc()</k> and clearing out memory space using <k>free()</k>.

<k>sizeof()</k> returns the number of bytes occupied by any datatype, in this case by an integer.

<k>#include &lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n, i, *ptr, sum = 0;

    printf("\n\nEnter number of elements: ");
    scanf("%d", &n);

    // dynamic memory allocation using malloc()
    ptr = (int *) malloc(n*sizeof(int));

    if(ptr == NULL) // if empty array
    {
        printf("\n\nError! Memory not allocated\n");
        return 0;   // end of program
    }

    printf("\n\nEnter elements of array: \n\n");
    for(i = 0; i &lt; n; i++)
    {
        // storing elements at contiguous memory locations
        scanf("%d", ptr+i);    
        sum = sum + *(ptr + i);
    }

    // printing the array elements using pointer to the location
    printf("\n\nThe elements of the array are: ");
    for(i = 0; i &lt; n; i++)
    {
        printf("%d  ",ptr[i]);    // ptr[i] is same as *(ptr + i)
    }

    /* 
        freeing memory of ptr allocated by malloc 
        using the free() method
    */
    free(ptr);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/memory-management-program.png">

<h2>Accessing array elements(Traversing array) by incrementing a Pointer</h2>
Name of the array refers to the <b>base address</b> of the array.

Here we have a tutorial to understand <a href="/c/pointer-arithmetic-in-c.php" target="_blank">How Pointer arithmetic works?</a>

Below is a program to access elements of an array using pointer increment.

<k>#include &lt;stdio.h>

const int MAX = 3;  // Global declaration
int main()
{
	printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
	int var[] = {100, 200, 300};
    int i, *ptr;

    /* 
        storing address of the first element 
        of the array in pointer variable
    */
    ptr = var;

    for(i = 0; i &lt; MAX; i++)
    {
        printf("\n\n\nAddress of var[%d] = %x ", i, ptr);
        printf("\nValue of var[%d] = %d ", i, *ptr);

       // move to the next location
        ptr++;
    }
	printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/pointer-increment.png">

<hr>
<h2>Traversing array elements by decrementing a Pointer</h2>
Below is a program to access elements of an array using pointer decrement.

<k>#include &lt;stdio.h>

const int MAX = 3;  // Global declaration
int main()
{
	printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
	int var[] = {100, 200, 300};
    int i, *ptr;

    /* 
        storing address of the last element 
        of the array in pointer variable
    */
    ptr = &var[MAX-1];

	for(i = MAX; i > 0; i--)
    {
    	printf("\n\n\nAddress of var[%d] = %x ", i, ptr);
        printf("\nValue of var[%d] = %d ", i, *ptr);

		// move to the previous location
        ptr--;
	}
	printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/pointer-decrement.png">

<h2>Pointer Comparison in C</h2>
In C language pointers can be compared if the two pointers are pointing to the same array.

All relational operators can be used for pointer comparison, but a pointer cannot Multiplied or Divided.

Below is a program on pointer comparison for same type of pointer:

<k>#include &lt;stdio.h>

int main()
{
    int *ptrA,*ptrB;

    ptrA = (int *)1;
    ptrB = (int *)2;
    if(ptr2 > ptr1)
        printf("PtrB is greater than ptrA");

return(0);
}</k>
<br />
Below is a program on pointer comparison for different type of pointer:

<k>#include &lt;stdio.h>

int main()
{
    int *ptrA;
    float *ptrB;
    ptrA = (int *)1000;
    ptrB = (float *)2000;
    if(ptrB > ptrA)
       printf("PtrB is greater than ptrA");
    return(0);
}</k>

<h2>Basic C Program for Pointer to a Pointer</h2>
A pointer variable stores the address of a value. 
Similarly, a pointer to a pointer stores the address of the pointer variable. 
Pointer to a pointer is executed making use of <k>**</k>.

Below is a program on pointer to a pointer.

<k>int var;</k> is a integer variable which stores value.

<k>int *ptr;</k> is a pointer variable which stores the address of an integer variable.

<k>int **pptr;</k> is a pointer to a pointer variable which stores the address of a pointer variable.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int var;
    int *ptr;
    int **pptr;

    var = 50;

    // take the address of the variable var
    ptr = &var;

    // taking the address of ptr using address of operator-&
    pptr = &ptr;

    // take the value using the pptr
    printf("\n\nValue of var = %d\n\n", var);

    printf("\n\nValue available at *ptr = %d\n\n", *ptr);

    printf("\n\nValue available at **pptr = %d\n\n", **pptr);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/pointer-to-a-pointer.png">

<h2>Reverse a String using Pointer</h2>
Below is a program to reverse a string using pointer:

<k>#include &lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    char str[100];
    char rev[100];
    char *sptr = str; // sptr stores the base address of the str
    char *rptr = rev; // rptr stores the base address of the reverse

    int i = -1;

    printf("\n\nEnter a string: ");
    scanf("%s", str);

    // storing the ending address of str in sptr
    while(*sptr)
    {
        sptr++;
        i++; // i is the index of the end location
    }

    // storing the string str in rev in reverse order
    while(i >= 0)
    {
        /*
            First decrementing then using as it stores 
            the location after the end location due to above while loop
        */
        sptr--; 
        *rptr = *sptr;  // storing the value in sptr in rptr
        rptr++; // pointing to next location
        i--;    // decrementing the index
    }
    /*
        String should always end with '\0' so explicitly 
        putting it at the end of the string
    */
    *rptr = '\0'; 
    rptr = rev; // restoring the base address of the reverse string

    // storing the reverse string in the original string
    while(*rptr)
    {
        *sptr = *rptr;
        sptr++;
        rptr++;
    }

    // printing the reverse string
    printf("\n\nReverse of the string is: %s ", str);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/reverse-a-string-using-pointer.png">

<h2>Swap Two Numbers using Pointers</h2>
Below is a program to swap two numbers using pointers.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    int a, b;
    int *ptra, *ptrb;
    int temp;

    printf("Enter value for a: ");
    scanf("%d", &a);

    printf("\n\nEnter value for b: ");
    scanf("%d", &b);

    printf("\n\nThe values before swapping are: a = %d     b = %d", a, b);

    ptra = &a;    // to store the location of a
    ptrb = &b;    // to store the location of b

    temp = *ptra;   // temp stores the value at location ptra
    *ptra = *ptrb;  // assigning value at location  ptrb to ptra
    *ptrb = temp;   // assign value of themp to  the variable at location ptrb

    printf("\n\nThe values after swapping are: a = %d    b = %d", a, b);

    printf("\n\n\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;

}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/swapping-two-numbers-using-pointers-1.png">

<h2>for Pointer to a Function</h2>
Below is a program on pointer to a function.

Here is the C language tutorial explaining Pointer with Functions &rarr; <a href="/c/pointer-with-function-in-c.php" target="_blank">Pointer to a Function</a>

<k>#include&lt;stdio.h>

int func(int a, int b)  // function definition
{
    printf("\n\n a = %d \n", a);
    printf("\n\n b = %d \n", b);
}

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");

    // function pointer
    int(*fptr)(int , int);

    // assign address to function pointer
    fptr = func;

    // function calling
    func(2,3);
    fptr(2,3);  // calling a function referring to pointer to a function

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/pointer-to-a-function.png">

<h2>Null Pointer Program</h2>
Null pointer is a special reserved value of a pointer. 
A pointer of any type has this reserved value. 
Formally, each specific pointer type<b>(int *, char *, etc)</b> has its own dedicated null-pointer value. 
Conceptually, when a pointer has that Null value it is not pointing anywhere.

Void pointer is a specific pointer type. 
<k>void *</k> which is a pointer that points to some data location in storage, which doesn't have any specific type.

<b>Null pointer</b> is a value whereas, <b>Void pointer</b> is a type.

Below is a program on NULL pointer.

<k>#include&lt;stdio.h>

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int *ptr = NULL;    // ptr is a NULL pointer

    printf("\n\n The value of ptr is: %x ", ptr);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/null-pointer.png">

<h2>for Adding Two Numbers Using Recursion</h2>
Below is a program on adding two numbers using recursion.

<k>#include&lt;stdio.h>

int y;

/*
    Function to add two numbers and
    return the result
*/
int add(int m, int n)
{
    if(n == 0)
        return m;

    /*
        Recursion: adding 1, n times and 
        then at the end adding m to it
    */
    y = add(m, n-1) + 1;
    return y;   // return the result
}

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int a, b, r;
    printf("Enter the two numbers:\n");
    scanf("%d%d", &a, &b);
    r = add(a, b);     // function call
    printf("\n\nSum of two numbers is: %d\n\n", r);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/adding-two-numbers-recursion.png">

<h2>find Factorial of a Number using Recursion</h2>
Below is a program for finding factorial of a given number using recursion.

<k>#include&lt;stdio.h>
// declaring the function
int fact(int);

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int num, f;
    printf("\n\nEnter a number: ");
    scanf("%d", &num);
    f= fact(num);
    printf("\n\nFactorial of  %d is  %d\n\n", num, f);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

int fact(int aj)
{
    if(aj==1 || aj==0)
        return 1;
    else
        return (aj*fact(aj-1));
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/factorial-using-recursion.png">

<h2>print Fibonacci Series using Recursion</h2>
A Fibonacci series is defined as a series in which each number is the sum of the previous two numbers with 1, 1 being the first two elements of the series.

<k>static</k> keyword is used to initialize the variables only once.

Below is a program to print the fibonacci series using recursion.

<k>#include&lt;stdio.h>
// declaring the function
void printFibo(int );

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int k, n;
    long int i = 0, j = 1;
    printf("Enter the length of the Fibonacci series: ");
    scanf("%d", &n);
    printf("\n\nfirst %d terms of Fibonacci series are:\n\n\n",n);
    printf("%d ", 1);
    printFibo(n);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

void printFibo(int aj)
{
    static long int first = 0, second = 1, sum;
    if(aj > 1)
    {
        sum = first + second;
        first = second;
        second = sum;
        printf("%ld ", sum);
        printFibo(aj-1);    // recursive call
    }
    else
    {
        // after the elements, for line break
        printf("\n\n\n");
    }
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/fibonacci-series-using-recursion.png">

<h2>find Sum of First N Numbers</h2>
Below is a program to find sum of the first <k>n</k> numbers using recursion, where the value of <k>n</k> is provided by the user.

<k>#include&lt;stdio.h>
// declaring the recursive function
int getSum(int);

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int n, sum;
    printf("\n\nEnter the range of n: ");
    scanf("%d", &n);
    sum = getSum(n);
    printf("\n\nThe sum of first %d numbers is %d\n", n, sum);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

// function definition
int getSum(int aj)
{
    /*
        static variables hold their values
        till the end of the program
    */
    static int sum = 0;
    if(aj > 0)
    {
        sum = sum + aj;
        getSum(aj-1);
    }
    return sum ;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/sum-of-first-n-numbers.png">

<h2>find Sum of digits of a Number using Recursion</h2>
Below is a program to find sum of digits of a given number using recursion.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

//declaring the recursive function
int sumOfDigit(int num);

void main()
{
    int num, sum;
    clrscr();
    printf("Enter a number:\t");
    scanf("%d", &num);
    sum = sumOfDigit(num);
    printf("The sum of digits of %d is: %d", num, sum);
    getch();
}

int sumOfDigit(int num)
{
    int s, a;
    s = s + (num%10);
    a = num/10;
    if(a > 0)
    {
        sumOfDigit(a);
    }
    return s;
}</k>

Enter a number: 108
The sum of digits of 108 is: 9

<h2>find Palindrome using Recursion</h2>
A Palindrome is a sequence that if reversed looks identical to the original sequence Eg : abba, level, 999 etc.

Below is a simple C program to find whether the user input number is a palindrome or not using recursion:

<k>#include&lt;stdio.h>

// declaring the recursive function
int isPal(int );

/*
    global declaration to use the same value 
    in both the functions
*/
int n;

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int palindrome;
    printf("\n\nEnter a number to check for Palindrome: ");
    scanf("%d", &n);
    palindrome = isPal(n);
    if(palindrome == 1)
        printf("\n\n\n%d is palindrome\n\n", n);
    else
        printf("\n\n\n%d is not palindrome\n\n", n);

    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

int isPal(int aj)
{
    static int sum = 0;
    if(aj != 0)
    {
        sum = sum *10 + aj%10;
        isPal(aj/10);   // recursive call same as while(n!=0) using loop
    }
    else if(sum == n)
        return 1;
    else
        return 0;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/palindrome-using-recursion.png">

<h2>calculate a Number raised to the Power of N using Recursion</h2>
Below is a program to calculate the result of a given number, raised to the power of <k>n</k> using recursion.

<k>#include&lt;stdio.h>

// function prototype declaration
int power(int n1, int n2);

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int base, exp;
    printf("Enter base number: ");
    scanf("%d", &base);
    printf("\n\nEnter Power factor: ");
    scanf("%d", &exp);
    printf("\n\n\n\t\t\t%d^%d = %d", base, exp, power(base, exp));
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

int power(int b, int e)
{
    if(e == 0)
        return 1;

    return (b*power(b, e-1));
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/power-of-n-using-recursion.png">

<h2>find the largest Element in an Array using Recursion</h2>
Below is a program to find the largest array element in a given array using recursion.

<k>#define</k> is used to initialize a value which is more like a constant.

<k>#include&lt;stdio.h>

#define MAX 100

int getMaxElement(int []);  // takes array of int as parameter
int size;

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int arr[MAX], max, i;
    printf("\n\nEnter the size of the array: ");
    scanf("%d", &size);
    printf("\n\nEnter %d elements\n\n", size);

    for(i = 0; i &lt; size; i++)
    {
        scanf("%d", &arr[i]);
    }
    max = getMaxElement(arr);   // passing the complete array as parameter
    printf("\n\nLargest element of the array is %d\n\n", max);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

int getMaxElement(int a[])
{
    static int i = 0, max =- 9999;  // static int max=a[0] is invalid
    if(i &lt; size)   // till the last element
    {
        if(max &lt; a[i])
        max = a[i];

        i++;    // to check the next element in the next iteration
        getMaxElement(a);   // recursive call
    }
    return max;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/largest-array-element-using-recursion.png">

<h2>find whether a Number is Prime Or Composite using Recursion</h2>
<b>Prime Number:</b> A number that is only divisible by 1 and itself.
<b>Composite Number:</b> A number that is not a prime number.<blockquote><i><b>Note:</b> 1 is neither prime nor composite.</i></blockquote>

Below is a program to find whether the user input number is a prime number or a composite number using recursion.

<k>#include&lt;stdio.h>

// declaring the recursive function
int isPrime(int, int);

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int num, prime;
    printf("Enter a positive number to check if Prime: ");
    scanf("%d", &num);
    prime = isPrime(num, num/2);
    if(prime == 1)
    {
        printf("\n\n%d is a prime number\n\n", num);
    }
    else
    {
        printf("\n\n%d is a Composite number\n\n", num);
    }
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

// function definition
int isPrime(int n, int i)
{
    if(i == 1)
        return 1;   // return statement terminates the recursive funtion
    else
    {
        if(n%i == 0)
            return 0;
        else
            isPrime(n, i-1);    // recursive call not using return statement
    }
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/prime-and-composite-using-recursion.png">

<h2>find LCM of two Numbers using Recursion</h2>
<b>LCM:</b> Least Common Multiple of two numbers is the number that is a common multiple of the both the numbers.

Below is a program to find LCM of two numbers using recursion.

<k>#include&lt;stdio.h>

int find_lcm(int, int);   // function prototype declaration

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int a, b, lcm;
    printf("\n\nEnter 2 integers to find LCM of:\n");
    scanf("%d%d", &a, &b);
    lcm = find_lcm(a,b);    // function call
    printf("\n\n LCM of %d and %d is: %d\n\n", a, b, lcm);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

int find_lcm(int a, int b)  // function definition
{
    /*
        static variable is initialized only once 
        for each function call
    */
    static int temp = 1;    
    if(temp%a == 0 & temp%b == 0)
    {
        return temp;
    }
    else
    {
        temp++;
        find_lcm(a,b);
        return temp;
    }
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/lcm-of-two-numbers-using-recursion.png">

<h2>find GCD of two Numbers using Recursion</h2>
<b>Greatest Common Divisor(GCD)</b> of two numbers is a number that divides both of them.

Below is a program to the GCD of the two user input numbers using recursion.

<k>#include&lt;stdio.h>

// declaring the recursive function
int find_gcd(int , int );

int main()
{
    printf("\n\n\t\tStudytonight - Best place to learn\n\n\n");
    int a, b, gcd;
    printf("\n\nEnter two numbers to find GCD of \n");
    scanf("%d%d", &a, &b);
    gcd = find_gcd(a, b);
    printf("\n\nGCD of %d and %d is: %d\n\n", a, b, gcd);
    printf("\n\n\t\t\tCoding is Fun !\n\n\n");
    return 0;
}

// defining the function
int find_gcd(int x, int y)
{
    if(x > y)
        find_gcd(x-y, y);

    else if(y > x)
        find_gcd(x, y-x);
    else
    return x;
}</k>

<h3>Output:</h3>
<img src="https://www.studytonight.com/c/programs/output/gcd-of-two-numbers-using-recursion-1.png">

<h2>Reverse a String Using Recursion</h2>
Below is a program to reverse a user input string using recursion in C language.

<k>#include&lt;stdio.h>
#include&lt;conio.h>

// declaring recursive function
char* reverse(char* str);

void main()
{
    int i, j, k;
    char str[100];
    char *rev;
    printf("Enter the string:\t");
    scanf("%s", str);
    printf("The original string is: %s\n", str);
    rev = reverse(str);
    printf("The reversed string is: %s\n", rev);
    getch();
}

// defining the function
char* reverse(char *str)
{
    static int i = 0;
    static char rev[100];
    if(*str)
    {
        reverse(str+1);
        rev[i++] = *str;
    }
    return rev;
}</k>

Enter the string: studytonight
The original string is: studytonight
The reverse string is: thginotyduts

<h2>C "Hello, World!" Program</h2>
<h3>Program to Display "Hello, World!"</h3>

<k>#include &lt;stdio.h>
int main()
{
   // printf() displays the string inside quotation
   printf("Hello, World!");
   return 0;
}
</k>
<r>Output</r>
<k>Hello, World!</k>
<r>How "Hello, World!" program works?</r>

The <k>#include &lt;stdio.h></k> is a preprocessor command. 
This command tells compiler to include the contents of <k>stdio.h</k> (standard input and output) file in the program.<br />
The <k>stdio.h</k> file contains functions such as <k>scanf()</k> and <k>print()</k> to take input and display output respectively.<br />
If you use <k>printf()</k> function without writing <k>#include &lt;stdio.h></k>, the program will not be compiled.
The execution of a C program starts from the <k>main()</k> function.
The <k>printf()</k> is a library function to send formatted output to the screen. 
In this program, the <k>printf()</k> displays <k>Hello, World!</k> text on the screen.
The <k>return 0;</k> statement is the "Exit status" of the program. 
In simple terms, program ends with this statement.
<h2>Print an Integer (Entered by the User)</h2>
In this program, integer entered by the user is stored in a variable. 
Then, that variable is displayed on the screen using printf() function.

<h3>Program to Print an Integer</h3>

<k>#include &lt;stdio.h>
int main()
{
    int number;

    // printf() dislpays the formatted output 
    printf("Enter an integer: ");  
    // scanf() reads the formatted input and stores them
    scanf("%d", &number);  
    // printf() displays the formatted output
    printf("You entered: %d", number);
    return 0;
}
</k>
<r>Output</r>
<k>Enter a integer: 25
You entered: 25</k>
In this program, an integer variable <mk>number</mk> is declared.

The <k>printf()</k> function displays <k>Enter an integer: </k> on the screen. 
Then, the <k>scanf()</k> function reads an integer data from the user and stores in variable <mk>number</mk>.

Finally, the value stored in the variable <mk>number</mk> is displayed on the screen using <k>printf()</k> function.

<h2>Add Two Integers</h2>
In this program, user is asked to enter two integers. 
Then, the sum of those two integers is stored in a variable and displayed on the screen.
<h3>Program to Add Two Integers</h3>

<k>#include &lt;stdio.h>
int main()
{
    int firstNumber, secondNumber, sumOfTwoNumbers;
    printf("Enter two integers: ");

    // Two integers entered by user is stored using scanf() function
    scanf("%d %d", &firstNumber, &secondNumber);

    // sum of two numbers in stored in variable sumOfTwoNumbers
    sumOfTwoNumbers = firstNumber + secondNumber;

    // Displays sum      
    printf("%d + %d = %d", firstNumber, secondNumber, sumOfTwoNumbers);

    return 0;
}
</k>
<r>Output</r>
<k>Enter two integers: 12
11
12 + 11 = 23</k>

In this program, user is asked to enter two integers. 
Two integers entered by the user is stored in variables <mk>firstNumber</mk> and <mk>secondNumber</mk> respectively. 
This is done using <k>scanf()</k> function.

Then, variables <mk>firstNumber </mk>and <mk>secondNumber</mk> are added using + operator and the result is stored in <mk>sumOfTwoNumbers</mk>.

Finally, the <mk>sumofTwoNumbers</mk> is displayed on the screen using <k>printf()</k> function.

<h2>Multiply two Floating Point Numbers</h2>
In this program, user is asked to enter two numbers (floating point numbers). 
Then, the product of those two numbers is stored in a variable and displayed on the screen.
<h3>Program to Multiply Two Numbers</h3>

<k>#include &lt;stdio.h>
int main()
{
    double firstNumber, secondNumber, product;
    printf("Enter two numbers: ");

    // Stores two floating point numbers in variable firstNumber and secondNumber respectively
    scanf("%lf %lf", &firstNumber, &secondNumber);  
 
    // Performs multiplication and stores the result in variable productOfTwoNumbers
    product = firstNumber * secondNumber;  

    // Result up to 2 decimal point is displayed using %.2lf
    printf("Product = %.2lf", product);
    return 0;
}</k>

<r>Output</r>

<k>Enter two numbers: 2.4
1.12
Product = 2.69</k>

In this program, user is asked to enter two numbers. 
These two numbers entered by the user is stored in variable <mk>firstNumber</mk> and <mk>secondNumber</mk> respectively. 
This is done using <k>scanf()</k> function.

Then, the product of <mk>firstNumber</mk> and <mk>secondNumber</mk> is evaluated and the result is stored in variable <mk>productOfTwoNumbers</mk>.

Finally, the <mk>productOfTwoNumbers</mk> is displayed on the screen using <k>printf()</k> function.

Notice that, the result is round to second decimal place using <k>%.2lf</k> conversion character.

<h2>Find ASCII Value of a Character</h2>
In C programming, a character variable holds ASCII value (an integer number between 0 an 127) rather than character itself. 
You will learn how to find ASCII value of a character in this program.

<r>For example</r>, ASCII value of &#39;A&#39; is 65.

What this means is that, if you assign &#39;A&#39; to a character variable, 65 is stored in that variable rather than &#39;A&#39; itself.
<h3>Program to Print ASCII Value</h3>

<k>#include &lt;stdio.h>
int main()
{
    char c;
    printf("Enter a character: ");

    // Reads character input from the user
    scanf("%c", &c);  
    // %d displays the integer value of a character
    // %c displays the actual character
    printf("ASCII value of %c = %d", c, c);
    return 0;
}
</k>
<r>Output</r>
Enter a character: G
ASCII value of G = 71

In this program, user is asked to enter a character which is stored in variable <mk>c.</mk> The ASCII value of that character is stored in variable<mk> c</mk> rather than that variable itself.

When %d format string is used, 71 (ASCII value of &#39;G&#39;) is displayed.

When %c format string is used, &#39;G&#39; itself is displayed.

<h2>Compute Quotient and Remainder </h2>
This program evaluates the quotient and remainder when an integer is divided by another integer. 
<h3>Program to Compute Quotient and Remainder</h3>

<k>#include &lt;stdio.h>
int main(){

    int dividend, divisor, quotient, remainder;

    printf("Enter dividend: ");
    scanf("%d", &dividend);

    printf("Enter divisor: ");
    scanf("%d", &divisor);

    // Computes quotient
    quotient = dividend / divisor;

    // Computes remainder
    remainder = dividend % divisor;

    printf("Quotient = %d\n", quotient);
    printf("Remainder = %d", remainder);

    return 0;
}
</k>
<r>Output</r>
Enter dividend: 25
Enter divisor: 4
Quotient = 6
Remainder = 1
In this program, user is asked to enter two integers (dividend and divisor) which is stored in variable <mk>dividend</mk> and <mk>divisor </mk>respectively.

Then the quotient is evaluated using division / operator and stored in variable <mk>quotient</mk>.

Similarly, the remainder is evaluated using modulus % operator and stored in <mk>remainder</mk> variable.

Finally, the quotient and remainder are displayed using <k>printf()</k> function.

Learn more on <a href="/c-programming/c-operators#arithmetic">how division / and modulus operator % operator works in C programming</a>.

<h2>Find the Size of int, float, double and char</h2>
This program declares 4 variables of type int, float, double and char. 
Then, the size of each variable is evaluated using sizeof operator.
<h3>Program to Find the Size of a variable</h3>

<k>#include &lt;stdio.h>
int main()
{
    int integerType;
    float floatType;
    double doubleType;
    char charType;

    // Sizeof operator is used to evaluate the size of a variable
    printf("Size of int: %ld bytes\n",sizeof(integerType));
    printf("Size of float: %ld bytes\n",sizeof(floatType));
    printf("Size of double: %ld bytes\n",sizeof(doubleType));
    printf("Size of char: %ld byte\n",sizeof(charType));

    return 0;
}
</k>
<r>Output</r>
<k>Size of int: 4 bytes
Size of float: 4 bytes
Size of double: 8 bytes
Size of char: 1 byte</k>
In this program, 4 variables <mk>integerType</mk>, <mk>floatType</mk>, <mk>doubleType</mk> and <mk>charType</mk> are declared having int, float, double and char type respectively.

Then, the size of each variable is ascertained using sizeof operator. 

<h2>Demonstrate the Working of Keyword long</h2>
The long is a size modifier, indicated by keyword long, that may increase the size of a variable during declaration. 
This program will demonstrate the working of long keyword.
<h3>Program to Demonstrate the Working of long</h3>
<k>#include &lt;stdio.h>
int main()
{
    int a;
    long b;
    long long c;

    double e;
    long double f;

    printf("Size of int = %ld bytes \n", sizeof(a));
    printf("Size of long = %ld bytes\n", sizeof(b));
    printf("Size of long long = %ld bytes\n", sizeof(c));

    printf("Size of double = %ld bytes\n", sizeof(e));
    printf("Size of long double = %ld bytes\n", sizeof(f));

    return 0;
}
</k>
<r>Output</r>
Size of int = 4 bytes 
Size of long = 8 bytes
Size of long long = 8 bytes
Size of double = 8 bytes
Size of long double = 16 bytes
In this program, the <k>sizeof</k> operator is used to find the size of <k>int</k>, <k>long</k>, <k>long long</k>, <k>double</k> and <k>long double</k>.

The long keyword cannot be used with <k>float</k> and <k>char</k> type variables.

<h2>Swap Two Numbers</h2>
This example contains two different techniques to swap numbers in C programming. 
The first program uses temporary variable to swap numbers, whereas the second program doesn't use temporary variables.
<h3>Example 1: Program to Swap Numbers Using Temporary Variable</h3>

<k>#include &lt;stdio.h>
int main()
{
      double firstNumber, secondNumber, temporaryVariable;

      printf("Enter first number: ");
      scanf("%lf", &firstNumber);

      printf("Enter second number: ");
      scanf("%lf",&secondNumber);

      // Value of firstNumber is assigned to temporaryVariable
      temporaryVariable = firstNumber;

      // Value of secondNumber is assigned to firstNumber
      firstNumber = secondNumber;

      // Value of temporaryVariable (which contains the initial value of firstNumber) is assigned to secondNumber
      secondNumber = temporaryVariable;

      printf("\nAfter swapping, firstNumber = %.2lf\n", firstNumber);
      printf("After swapping, secondNumber = %.2lf", secondNumber);

      return 0;
}
</k>

<r>Output</r>
<k>Enter first number: 1.20
Enter second number: 2.45

After swapping, firstNumber = 2.45
After swapping, secondNumber = 1.20</k>

In the above program, the <mk>temporaryVariable</mk> is assigned the value of <mk>firstNumber</mk>.<br />
Then, the value of <mk>firstNumber</mk> is assigned to <mk>secondNumber</mk>.<br />
Finally, the <mk>temporaryVariable</mk> (which holds the initial value of <mk>firstNumber</mk>) is assigned to <mk>secondNumber</mk> which completes the swapping process.

Here, <mk>temporaryVariable</mk> is used to hold the value of firstNumber and doesn&#39;t have any other use except that. 
You can also write the swapping program without using <mk>temporaryVariable</mk>.
<h3>Example 2: Program to Swap Number Without Using Temporary Variables</h3>

<k>#include &lt;stdio.h>
int main()
{
    double firstNumber, secondNumber;

    printf("Enter first number: ");
    scanf("%lf", &firstNumber);

    printf("Enter second number: ");
    scanf("%lf",&secondNumber);

    // Swapping process

    firstNumber = firstNumber - secondNumber;
    secondNumber = firstNumber + secondNumber;
    firstNumber = secondNumber - firstNumber;

    printf("\nAfter swapping, firstNumber = %.2lf\n", firstNumber);
    printf("After swapping, secondNumber = %.2lf", secondNumber);

    return 0;
}</k>
<b>Output</b>

<k>Enter first number: 10.25
Enter second number: -12.5

After swapping, firstNumber = -12.50
After swapping, secondNumber = 10.25</k>

<h2>Check Whether a Number is Even or Odd</h2>
In this example, if...else statement is used to check whether a number entered by the user is even or odd.

An odd number is an integer that is not exactly divisible by 2. 
Example: 1, 7, -11, 15
<h3>Example #1: Program to Check Even or Odd</h3>

<k>#include &lt;stdio.h>
int main()
{
    int number;

    printf("Enter an integer: ");
    scanf("%d", &number);

    // True if the number is perfectly divisible by 2
    if(number % 2 == 0)
printf("%d is even.", number);
    else
printf("%d is odd.", number);

    return 0;
}
</k>
<r>Output</r>
<k>Enter an integer: -7
-7 is odd.</k>
In the program, integer entered by the user is stored in variable <mk>number</mk>.

Then, whether the number is perfectly divisible by 2 or not is checked using modulus operator.

If the number is perfectly divisible by 2, test expression <k>number%2 == 0</k> evaluates to 1 (true) and the number is even.

However, if the test expression evaluates to 0 (false), the number is odd.
<h3>Example #2: Program to Check Odd or Even Using Conditional Operator</h3>

<k>#include &lt;stdio.h>
int main()
{
    int number;

    printf("Enter an integer: ");
    scanf("%d", &number);

    (number % 2 == 0) ? printf("%d is even.", number) : printf("%d is odd.", number);

    return 0;
}
</k>

<h2>Check Whether a Character is Vowel or Consonant</h2>
In this example, if...else statement is used to check whether an alphabet entered by the user is a vowel or a constant.

This program assumes that the user will always enter an alphabet character.
<h3>Example #1: Program to Check Vowel or consonant</h3>

<k>#include &lt;stdio.h>
int main()
{
    char c;
    int isLowercaseVowel, isUppercaseVowel;

    printf("Enter an alphabet: ");
    scanf("%c",&c);

    // evaluates to 1 (true) if c is a lowercase vowel
    isLowercaseVowel = (c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39;);

    // evaluates to 1 (true) if c is an uppercase vowel
    isUppercaseVowel = (c == &#39;A&#39; || c == &#39;E&#39; || c == &#39;I&#39; || c == &#39;O&#39; || c == &#39;U&#39;);

    // evaluates to 1 (true) if either isLowercaseVowel or isUppercaseVowel is true
    if (isLowercaseVowel || isUppercaseVowel)
printf("%c is a vowel.", c);
    else
printf("%c is a consonant.", c);
    return 0;
}</k>

<r>Output</r>

<k>Enter an alphabet: G
G is a consonant.</k>

The character entered by the user is stored in variable <mk>c</mk>.

The <mk>isLowerCaseVowel</mk> evaluates to 1 (true) if <mk>c</mk> is a lowercase vowel and 0 (false) for any other character.

Similarly, <mk>isUpperCaseVowel</mk> evaluates to 1(true) if <mk>c</mk> is an uppercase vowel and 0 (false) for any other character.

If both <mk>isLowercaseVowel</mk> and <mk>isUppercaseVowel</mk> is equal to 0, the test expression evaluates to 0 (false) and the entered character is a consonant.

However, if either <mk>isLowercaseVowel</mk> or <mk>isUppercaseVowel</mk> is 1 (true), the test expression evaluates to 1 (true) and the entered character is a vowel.

The program above assumes that the user always enters an alphabet. 
If the user enters any other character other than an alphabet, the program will not work as intended.
<h3>Example #2: Program to Check Vowel or consonant</h3>
The program below asks the user to enter a character until the user enters an alphabet. 
Then, the program checks whether it is a vowel or a consonant.

<k>#include &lt;stdio.h>
#include &lt;ctype.h>

int main()
{
    char c;
    int isLowercaseVowel, isUppercaseVowel;

    do {
printf("Enter an alphabet: ");
scanf(" %c", &c);
    }
    // isalpha() returns 0 if the passed character is not an alphabet
    while (!isalpha(c));

    // evaluates to 1 (true) if c is a lowercase vowel
    isLowercaseVowel = (c == &#39;a&#39; || c == &#39;e&#39; || c == &#39;i&#39; || c == &#39;o&#39; || c == &#39;u&#39;);

    // evaluates to 1 (true) if c is an uppercase vowel
    isUppercaseVowel = (c == &#39;A&#39; || c == &#39;E&#39; || c == &#39;I&#39; || c == &#39;O&#39; || c == &#39;U&#39;);

    // evaluates to 1 (true) if either isLowercaseVowel or isUppercaseVowel is true
    if (isLowercaseVowel || isUppercaseVowel)
printf("%c is a vowel.", c);
    else
printf("%c is a consonant.", c);
    return 0;
}
</k>

<h2>Find the Largest Number Among Three Numbers</h2>
In this example, the largest number among three numbers (entered by the user) is found using three different methods.
<h3>Example #1</h3>

<k>#include &lt;stdio.h>
int main()
{
    double n1, n2, n3;

    printf("Enter three different numbers: ");
    scanf("%lf %lf %lf", &n1, &n2, &n3);

    if( n1>=n2 & n1>=n3 )
printf("%.2f is the largest number.", n1);

    if( n2>=n1 & n2>=n3 )
printf("%.2f is the largest number.", n2);

    if( n3>=n1 & n3>=n2 )
printf("%.2f is the largest number.", n3);

    return 0;
}</k>

This program uses if...else statement to find the largest number.
<h3>Example #2</h3>

<k>#include &lt;stdio.h>
int main()
{
    double n1, n2, n3;

    printf("Enter three numbers: ");
    scanf("%lf %lf %lf", &n1, &n2, &n3);

    if (n1>=n2)
    {
if(n1>=n3)
printf("%.2lf is the largest number.", n1);
else
printf("%.2lf is the largest number.", n3);
    }
    else
    {
if(n2>=n3)
printf("%.2lf is the largest number.", n2);
else
printf("%.2lf is the largest number.",n3);
    }
    return 0;
}
</k>

This program uses nested if...else statement to find the largest number.
<h3>Example #3</h3>

<k>#include &lt;stdio.h>
int main()
{
    double n1, n2, n3;

    printf("Enter three numbers: ");
    scanf("%lf %lf %lf", &n1, &n2, &n3);

    if( n1>=n2 & n1>=n3)
printf("%.2lf is the largest number.", n1);

    else if (n2>=n1 & n2>=n3)
printf("%.2lf is the largest number.", n2);

    else
printf("%.2lf is the largest number.", n3);

    return 0;
}
</k>

Though, the largest number among three numbers is found using multiple ways, the output of all these program will be same.

<k>Enter three numbers: -4.5
3.9
5.6
5.60 is the largest number.
</k>

<h2>Find all Roots of a Quadratic Equation</h2>
This program accepts coefficients of a quadratic equation from the user and displays the roots (both real and complex roots depending upon the discriminant ).

ax<sup>2</sup> + bx + c = 0, where
a, b and c are real numbers and
a &ne; 0

The term <k>b<sup>2</sup>-4ac</k> is known as the discriminant of a quadratic equation. 
The discriminant tells the nature of the roots.

If discriminant is greater than 0, the roots are real and different.
If discriminant is equal to 0, the roots are real and equal.
If discriminant is less than 0, the roots are complex and different.

<h3>Program to Find Roots of a Quadratic Equation</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

int main()
{
    double a, b, c, discriminant, root1, root2, realPart, imaginaryPart;

    printf("Enter coefficients a, b and c: ");
    scanf("%lf %lf %lf",&a, &b, &c);

    discriminant = b*b-4*a*c;

    // condition for real and different roots
    if (discriminant > 0)
    {
    // sqrt() function returns square root
root1 = (-b+sqrt(discriminant))/(2*a);
root2 = (-b-sqrt(discriminant))/(2*a);

printf("root1 = %.2lf and root2 = %.2lf",root1 , root2);
    }

    //condition for real and equal roots
    else if (discriminant == 0)
    {
root1 = root2 = -b/(2*a);

printf("root1 = root2 = %.2lf;", root1);
    }

    // if roots are not real 
    else
    {
realPart = -b/(2*a);
imaginaryPart = sqrt(-discriminant)/(2*a);
printf("root1 = %.2lf+%.2lfi and root2 = %.2f-%.2fi", realPart, imaginaryPart, realPart, imaginaryPart);
    }

    return 0;
}   
</k>

<r>Output </r>

<k>Enter coefficients a, b and c: 2.3
4
5.6
Roots are: -0.87+1.30i and -0.87-1.30i</k>

In this program, library function <k>sqrt()</k> is used to find the square root of a number. 
To learn more, visit:  <a href="/c-programming/library-function/math.h/sqrt">sqrt() function</a>.

<h2>Check Leap Year</h2>
This program checks whether an year (integer) entered by the user is a leap year or not.
<h3>Program to Check Leap Year</h3>
<k>#include &lt;stdio.h>

int main()
{
    int year;

    printf("Enter a year: ");
    scanf("%d",&year);

    if(year%4 == 0)
    {
if( year%100 == 0)
{
// year is divisible by 400, hence the year is a leap year
if ( year%400 == 0)
    printf("%d is a leap year.", year);
else
    printf("%d is not a leap year.", year);
}
else
printf("%d is a leap year.", year );
    }
    else
printf("%d is not a leap year.", year);
    return 0;
}</k><k>
</k>

<r>Output 1</r>

<k>Enter a year: 1900
1900 is not a leap year.
</k>

<r>Output 2</r>

<k>Enter a year: 2012
2012 is a leap year.
</k>

<h2>Check Whether a Number is Positive or Negative</h2>
In this example, you will learn to check whether a number (entered by the user) is negative or positive. 
<h3>Example #1: Check if a Number is Positive or Negative Using if...else</h3>

<k>#include &lt;stdio.h>
int main()
{
    double number;

    printf("Enter a number: ");
    scanf("%lf", &number);

    if (number &lt;= 0.0)
    {
if (number == 0.0)
printf("You entered 0.");
else
printf("You entered a negative number.");
    }
    else
printf("You entered a positive number.");
    return 0;
}</k>

You can also solve this problem using <a href="/c-programming/c-if-else-statement">nested if else statement</a>.
<h3>Example #2: Check if a Number is Positive or Negative Using Nested if...else</h3>

<k>#include &lt;stdio.h>
int main()
{
    double number;

    printf("Enter a number: ");
    scanf("%lf", &number);

    // true if number is less than 0
    if (number &lt; 0.0)
printf("You entered a negative number.");

    // true if number is greater than 0
    else if ( number > 0.0)
printf("You entered a positive number.");

    // if both test expression is evaluated to false
    else
printf("You entered 0.");
    return 0;
}
</k>

<r>Output 1</r>

<k>Enter a number: 12.3
You entered a positive number.</k><k>
</k>
<r>Output 2</r>

<k>Enter a number: 0
You entered 0.
</k>

<h2>Check Whether a Character is an Alphabet or not</h2>
In this example, you will learn to check whether a character entered by the user is an alphabet or not.
<h3>Program to Check Alphabet</h3>

<k>#include &lt;stdio.h>
int main()
{
    char c;
    printf("Enter a character: ");
    scanf("%c",&c);

    if( (c>=&#39;a&#39; & c&lt;=&#39;z&#39;) || (c>=&#39;A&#39; & c&lt;=&#39;Z&#39;))
printf("%c is an alphabet.",c);
    else
printf("%c is not an alphabet.",c);

    return 0;
}</k>

<r>Output </r>

<k>Enter a character: *
* is not an alphabet</k>
In C programming, a character variable holds ASCII value (an integer number between 0 and 127) rather than that character itself.

The ASCII value of lowercase alphabets are from 97 to 122. 
And, the ASCII value of uppercase alphabets are from 65 to 90.

If the ASCII value of the character entered by the user lies in the range from 97 to 122 or from 65 to 90, that number is an alphabet. 
In the program,&#39;a&#39; is used instead of 97 and &#39;z&#39; is used instead of 122. 
Similarly, &#39;A&#39; is used instead of 65 and &#39;Z&#39; is used instead of 90.

You can also check whether a character is an alphabet or not using <a href="/c-programming/library-function/ctype.h/isalpha">isalpha()</a> function.

<h2>Calculate the Sum of Natural Numbers</h2>
To compute the sum of natural numbers from 1 to n (entered by the user), loops can be used. 
You will learn how to use for loop and while loop to solve this problem.
<h3>Example #1: Sum of Natural Numbers Using for Loop</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i, sum = 0;
    printf("Enter a positive integer: ");
    scanf("%d",&n);

    for(i=1; i &lt;= n; ++i)
    {
sum += i;   // sum = sum+i;
    }

    printf("Sum = %d",sum);

    return 0;
}
</k>

The above program takes the input from the user and stores in variable <mk>n</mk>. 
Then, for loop is used to calculate the sum upto the given number.
<h3>Example #2: Sum of Natural Numbers Using while Loop</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i, sum = 0;
    printf("Enter a positive integer: ");
    scanf("%d",&n);

    i = 1;
    while ( i &lt;=n )
    {
sum += i;
++i;
    }

    printf("Sum = %d",sum);

    return 0;
}</k>

<r>Output</r>
<k>Enter a positive integer: 100
Sum = 5050</k>
In both programs, the loop is iterated <mk>n</mk> number of times. 
And, in each iteration, the value of <mk>i</mk> is added to <mk>sum</mk> and <mk>i</mk> is incremented by 1.

Though both programs are technically correct, it is better to use for loop in this case. 
It&#39;s because the number of iteration is known.

The above programs doesn&#39;t work properly if the user enters a negative integer. 
Here&#39;s a little modification of the above program to take input from the user until positive integer is entered.
<h3>Example #3: Program to Read Input Until User Enters a Positive Integer</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i, sum = 0;

    do {
printf("Enter a positive integer: ");
scanf("%d",&n);
    }
    while (n &lt;= 0);

    for(i=1; i &lt;= n; ++i)
    {
sum += i;   // sum = sum+i;
    }

    printf("Sum = %d",sum);

    return 0;
}</k>
Visit this page to learn <a href="/c-programming/examples/natural-number-sum-recursion">how to find the sum of natural number using recursion</a>.

<h2>Find Factorial of a Number</h2>
The factorial of a positive integer n is equal to 1*2*3*...n. 
You will learn to calculate the factorial of a number using for loop in this example.

factorial of n (n!) = 1*2*3*4....n

The factorial of a negative number doesn&#39;t exist. 
And, the factorial of 0 is 1, <k>0! = 1</k>
<h3>Factorial of a Number</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i;
    unsigned long long factorial = 1;

    printf("Enter an integer: ");
    scanf("%d",&n);

    // show error if the user enters a negative integer
    if (n &lt; 0)
printf("Error! Factorial of a negative number doesn&#39;t exist.");

    else
    {
for(i=1; i&lt;=n; ++i)
{
factorial *= i;  // factorial = factorial*i;
}
printf("Factorial of %d = %llu", n, factorial);
    }

    return 0;
}</k>
<r>Output</r>
Enter an integer: 10
Factorial of 10 = 3628800

This program takes a positive integer from the user and computes factorial using for loop.

Since the factorial of a number may be very large, the type of <mk>factorial</mk> variable is declared as <k>unsigned long long</k>.

If the user enters negative number, the program displays error message.

You can also find the <a href="/c-programming/examples/factorial-recursion">factorial of a number using recursion</a>.

<h2>Generate Multiplication Table</h2>
Example to generate the multiplication table of a number (entered by the user) using for loop.
<h3>Example #1: Multiplication Table Up to 10</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i;

    printf("Enter an integer: ");
    scanf("%d",&n);

    for(i=1; i&lt;=10; ++i)
    {
printf("%d * %d = %d \n", n, i, n*i);
    }
    return 0;
}
</k>
<r>Output</r>
<k>Enter an integer: 9
9 * 1 = 9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
9 * 10 = 90
</k>

Here&#39;s a little modification of the above program to generate the multiplication table up to a range (where <mk>range</mk> is also a positive integer entered by the user).
<h3>Example #2: Multiplication Table Up to a range (entered by the user)</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i, range;

    printf("Enter an integer: ");
    scanf("%d",&n);

    printf("Enter the range: ");
    scanf("%d", &range);

    for(i=1; i &lt;= range; ++i)
    {
printf("%d * %d = %d \n", n, i, n*i);
    }

    return 0;
}
</k>
<r>Output</r>
<k>Enter an integer: 12
Enter the range: 8
12 * 1 = 12 
12 * 2 = 24 
12 * 3 = 36 
12 * 4 = 48 
12 * 5 = 60 
12 * 6 = 72 
12 * 7 = 84 
12 * 8 = 96 
</k>

<h2>Display Fibonacci Sequence</h2>
Example on how to display the Fibonacci sequence of first n numbers (entered by the user) using loop. 
Also in different example, you learn to generate the Fibonacci sequence up to a certain number.

The Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21

Visit this page to learn about <a href="http://www.mathsisfun.com/numbers/fibonacci-sequence.html">Fibonacci sequence</a>.
<h3>Example #1: Fibonacci Series up to n number of terms</h3>

<k>#include &lt;stdio.h>
int main()
{
    int i, n, t1 = 0, t2 = 1, nextTerm;

    printf("Enter the number of terms: ");
    scanf("%d", &n);

    printf("Fibonacci Series: ");

    for (i = 1; i &lt;= n; ++i)
    {
printf("%d, ", t1);
nextTerm = t1 + t2;
t1 = t2;
t2 = nextTerm;
    }
    return 0;
}
</k>

<r>Output</r>

<k>Enter the number of terms: 10
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, </k>
<h3>Example #2: Fibonacci Sequence Up to a Certain Number</h3>

<k>#include &lt;stdio.h>
int main()
{
    int t1 = 0, t2 = 1, nextTerm = 0, n;

    printf("Enter a positive number: ");
    scanf("%d", &n);

    // displays the first two terms which is always 0 and 1
    printf("Fibonacci Series: %d, %d, ", t1, t2);

    nextTerm = t1 + t2;

    while(nextTerm &lt;= n)
    {
printf("%d, ",nextTerm);
t1 = t2;
t2 = nextTerm;
nextTerm = t1 + t2;
    }
    return 0;
}
</k>

<r>Output</r>

<k>Enter a positive integer: 100
Fibonacci Series: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, </k>

<h2> C Program to Find GCD of two Numbers</h2>
Examples on different ways to calculate GCD of two integers (for both positive and negative integers) using loops and decision making statements.

There are many ways to find the greatest common divisor in C programming.
<h3>Example #1: GCD Using for loop and if Statement</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n1, n2, i, gcd;

    printf("Enter two integers: ");
    scanf("%d %d", &n1, &n2);

    for(i=1; i &lt;= n1 & i &lt;= n2; ++i)
    {
// Checks if i is factor of both integers
if(n1%i==0 & n2%i==0)
gcd = i;
    }

    printf("G.C.D of %d and %d is %d", n1, n2, gcd);

    return 0;
}</k>

In this program, two integers entered by the user are stored in variable <mk>n1</mk> and <mk>n2</mk>.Then, <k>for</k> loop is iterated until <mk>i</mk> is less than <mk>n1</mk> and <mk>n2</mk>.

In each iteration, if both <mk>n1</mk> and <mk>n2</mk> are exactly divisible by <mk>i</mk>, the value of <mk>i</mk> is assigned to <mk>gcd</mk>.

When the <k>for</k> loop is completed, the greatest common divisor of two numbers is stored in variable <mk>gcd</mk>.
<h3>Example #2: GCD Using while loop and if...else Statement</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n1, n2;
    printf("Enter two positive integers: ");
    scanf("%d %d",&n1,&n2);

    while(n1!=n2)
    {
if(n1 > n2)
n1 -= n2;
else
n2 -= n1;
    }
    printf("GCD = %d",n1);

    return 0;
}</k>

<b>Output</b>

<k>Enter two positive integers: 81
153
GCD = 9</k>
This is a better way to find the GCD. 
In this method, smaller integer is subtracted from the larger integer, and the result is assigned to the variable holding larger integer. 
This process is continued until <mk>n1</mk> and <mk>n2</mk> are equal.

The above two programs works as intended only if the user enters positive integers. 
Here&#39;s a little modification of the second example to find the GCD for both positive and negative integers.
<h3>Example #3: GCD for both positive and negative numbers</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n1, n2;

    printf("Enter two integers: ");
    scanf("%d %d",&n1,&n2);

    // if user enters negative number, sign of the number is changed to positive
    n1 = ( n1 > 0) ? n1 : -n1;
    n2 = ( n2 > 0) ? n2 : -n2;

    while(n1!=n2)
    {
if(n1 > n2)
n1 -= n2;
else
n2 -= n1;
    }
    printf("GCD = %d",n1);

    return 0;
}</k>
<b>Output</b>

<k>Enter two integers: 81
-153
GCD = 9</k>
You can also use <a href="/c-programming/examples/hcf-recursion">recursion to find the GCD</a>.

<h2>Find LCM of two Numbers</h2>
Examples on different ways to calculate the LCM (Lowest Common Multiple) of two integers using loops and decision making statements.
<h3>Example #1: LCM using while Loop and if Statement</h3>

<k>
#include &lt;stdio.h>
int main()
{
    int n1, n2, minMultiple;
    printf("Enter two positive integers: ");
    scanf("%d %d", &n1, &n2);

    // maximum number between n1 and n2 is stored in minMultiple
    minMultiple = (n1>n2) ? n1 : n2;

    // Always true
    while(1)
    {
if( minMultiple%n1==0 & minMultiple%n2==0 )
{
printf("The LCM of %d and %d is %d.", n1, n2,minMultiple);
break;
}
++minMultiple;
    }
    return 0;
}
</k>
<b>Output</b>

<k>Enter two positive integers: 72
120
The LCM of 72 and 120 is 360.</k>
In this program, the integers entered by the user are stored in variable <mk>n1</mk> and <mk>n2</mk> respectively.

The largest number among <mk>n1</mk> and <mk>n2</mk> is stored in <mk>minMultiple</mk>. 
The LCM of two numbers cannot be less than <mk>minMultiple</mk>.

The test expression of while loop is always true (1). 
In each iteration, whether <mk>minMultiple</mk> is perfectly divisible by <mk>n1</mk> and <mk>n2</mk> is checked. 
If this test condition is not true, <mk>minMultiple</mk> is incremented by 1 and the iteration continues until the test expression of if statement is true.

The LCM of two numbers can also be found using the formula:

LCM = (num1*num2)/GCD

Learn more on, how to find the <a href="/c-programming/examples/hcf-gcd">GCD of two numbers in C programming</a>.
<h3>Example #2: LCM Calculation by Finding GCD</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n1, n2, i, gcd, lcm;

    printf("Enter two positive integers: ");
    scanf("%d %d",&n1,&n2);

    for(i=1; i &lt;= n1 & i &lt;= n2; ++i)
    {
// Checks if i is factor of both integers
if(n1%i==0 & n2%i==0)
gcd = i;
    }

    lcm = (n1*n2)/gcd;
    printf("The LCM of two numbers %d and %d is %d.", n1, n2, lcm);

    return 0;
}
</k>

<h2>Display Characters from A to Z Using Loop</h2>
You will learn to display the English alphabets using for loop in this example.
<h3>Example #1: Program to Print English Alphabets</h3>

<k>#include &lt;stdio.h>
int main()
{
    char c;

    for(c = &#39;A&#39;; c &lt;= &#39;Z&#39;; ++c)
       printf("%c ", c);
    return 0;
}
</k>

<r>Output</r>

<k>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</k>

In this program, the for loop is used to display the English alphabets in uppercase.

Here&#39;s a little modification of the above program. 
The program displays the English alphabets in either uppercase or lowercase depending upon the input from the user.
<h3>Example #2: Program to either Uppercase and Lowercase characters</h3>

<k>#include &lt;stdio.h>
int main()
{
    char c;

    printf("Enter u to display alphabets in uppercase.\n");
    printf("Enter l to display alphabets in lowercase. 
\n");
    scanf("%c", &c);

    if(c== &#39;U&#39; || c== &#39;u&#39;)
    {
       for(c = &#39;A&#39;; c &lt;= &#39;Z&#39;; ++c)
 printf("%c ", c);
    }
    else if (c == &#39;L&#39; || c == &#39;l&#39;)
    {
for(c = &#39;a&#39;; c &lt;= &#39;z&#39;; ++c)
 printf("%c ", c);
    }
    else
       printf("Error! You entered an invalid character.");
    return 0;
}
</k>

<r>Output</r>

<k>Enter u to display alphabets in uppercase. 

Enter l to display alphabets in lowercase: l
a b c d e f g h i j k l m n o p q r s t u v w x y z </k>

<h2>Count Number of Digits in an Integer</h2>
Example to count the number of digits in an integer entered by the user. 
The while loop is used to solve this program.
<h3>Example #1: Program to Count Number of Digits in an Integer</h3>

<k>#include &lt;stdio.h>
int main()
{
    long long n;
    int count = 0;

    printf("Enter an integer: ");
    scanf("%lld", &n);

    while(n != 0)
    {
// n = n/10
n /= 10;
++count;
    }

    printf("Number of digits: %d", count);
}
</k>
<r>Output</r>
<k>Enter an integer: 3452
Number of digits: 4</k>

The integer entered by the user is stored in variable <mk>n</mk>. 
Then the <a href="/c-programming/c-do-while-loops">while loop</a> is iterated until the test expression <k>n != 0</k> is evaluated to 0 (false).

After first iteration, the value of <mk>n</mk> will be 345 and the <mk>count</mk> is incremented to 1.
After second iteration, the value of <mk>n</mk> will be 34 and the <mk>count</mk> is incremented to 2.
After third iteration, the value of <mk>n</mk> will be 3 and the <mk>count</mk> is incremented to 3.
After fourth iteration, the value of <mk>n</mk> will be 0 and the <mk>count</mk> is incremented to 4.
Then the test expression is evaluated to false and the loop terminates.

<h2>Reverse a Number </h2>
Example to reverse an integer entered by the user. 
This problem is solved using while loop in this example.
<h3>Reverse an Integer</h3>
<k>#include &lt;stdio.h>
int main()
{
    int n, reversedNumber = 0, remainder;

    printf("Enter an integer: ");
    scanf("%d", &n);

    while(n != 0)
    {
remainder = n%10;
reversedNumber = reversedNumber*10 + remainder;
n /= 10;
    }

    printf("Reversed Number = %d", reversedNumber);

    return 0;
}
</k>
<r>Output</r>
<k>Enter an integer: 2345
Reversed Number = 5432</k>
This program takes an integer input from the user. 
Then the while loop is used until <k>n != 0</k> is false.

In each iteration of while loop, the remainder when <mk>n</mk> is divided by 10 is calculated and the value of <mk>n</mk> is reduced by times. 

<h2>Calculate the Power of a Number</h2>
Example on how to calculate the power of a number if the exponent is an integer. 
Also, you will learn to compute the power using pow() function.

<r>For example:</r> In case of 2<sup>3</sup>

2 is the base number
3 is the exponent
And, the power is equal to 2*2*2

<h3>Example #1: Power of a Number Using while Loop</h3>

<k>#include &lt;stdio.h>
int main()
{
    int base, exponent;

    long long result = 1;

    printf("Enter a base number: ");
    scanf("%d", &base);

    printf("Enter an exponent: ");
    scanf("%d", &exponent);

    while (exponent != 0)
    {
result *= base;
--exponent;
    }

    printf("Answer = %lld", result);

    return 0;
}
</k>
<r>Output</r>
<k>Enter a base number: 3
Enter an exponent: 4
Answer = 81</k>

The above technique works only if the exponent is a positive integer.

If you need to find the power of a number with any real number as an exponent, you can use <a href="/c-programming/library-function/math.h/pow">pow() function</a>. 
<h3>Example #2: Power Using pow() Function</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

int main()
{
    double base, exponent, result;

    printf("Enter a base number: ");
    scanf("%lf", &base);

    printf("Enter an exponent: ");
    scanf("%lf", &exponent);

    // calculates the power
    result = pow(base, exponent);

    printf("%.1lf^%.1lf = %.2lf", base, exponent, result);

    return 0;
}
</k>
<b>Output</b>

<k>Enter a base number: 2.3
Enter an exponent: 4.5
2.3^4.5 = 42.44</k>

<h2>Check Whether a Number is Palindrome or Not</h2>
This program reverses an integer (entered by the user) using while loop. 
Then, if statement is used to check whether the reversed number is equal to the original number or not.
<h3>Program to Check Palindrome</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, reversedInteger = 0, remainder, originalInteger;

    printf("Enter an integer: ");
    scanf("%d", &n);

    originalInteger = n;

    // reversed integer is stored in variable 
    while( n!=0 )
    {
remainder = n%10;
reversedInteger = reversedInteger*10 + remainder;
n /= 10;
    }

    // palindrome if orignalInteger and reversedInteger are equal
    if (originalInteger == reversedInteger)
printf("%d is a palindrome.", originalInteger);
    else
printf("%d is not a palindrome.", originalInteger);
    return 0;
}</k>
<r>Output</r>
<k>Enter an integer: 1001
1001 is a palindrome.</k>

<h2>Check Whether a Number is Prime or Not</h2>
Example to check whether an integer (entered by the user) is a prime number or not using for loop and if...else statement.
<h3>Program to Check Prime Number</h3>

<k>#include &lt;stdio.h>
int main()
{
    int n, i, flag = 0;

    printf("Enter a positive integer: ");
    scanf("%d", &n);

    for(i = 2; i <= n/2; ++i)
    {
// condition for nonprime number
if(n%i == 0)
{
flag = 1;
break;
}
    }

    if (n == 1) 
    {
      printf("1 is neither a prime nor a composite number.");
    }
    else 
    {
if (flag == 0)
  printf("%d is a prime number.", n);
else
  printf("%d is not a prime number.", n);
    }
    return 0;
}</k>

<r>Output</r>

<k>Enter a positive integer: 29
29 is a prime number.</k>

If the <k>for</k> loop terminates when the test expression of loop <k>i &lt;= n/2</k> is false, the entered number is a prime number. 
The value of <mk>flag</mk> is equal to 0 in this case.

If the loop terminates because of <k>break</k> statement inside the <k>if</k> statement, the entered number is a nonprime number. 
The value of flag is 1 in this case.

Visit this page to learn, how you can <a href="/c-programming/examples/prime-number-intervals">display all prime numbers between two intervals entered by the user</a>.

<h2>Display Prime Numbers Between Two Intervals</h2>
Example to print all prime numbers between two numbers (entered by the user). 
This problem is solved using nested for loop and if...else statement. 
<h3>Example #1: Display Prime Numbers Between two Intervals</h3>

<k>#include &lt;stdio.h>
int main()
{
    int low, high, i, flag;
    printf("Enter two numbers(intervals): ");
    scanf("%d %d", &low, &high);

    printf("Prime numbers between %d and %d are: ", low, high);

    while (low &lt; high)
    {
flag = 0;

for(i = 2; i &lt;= low/2; ++i)
{
if(low % i == 0)
{
    flag = 1;
    break;
}
}

if (flag == 0)
printf("%d ", low);

++low;
    }

    return 0;
}</k>
<b>Output</b>

<k>Enter two numbers(intervals): 20 
50
Prime numbers between 20 and 50 are: 23 29 31 37 41 43 47</k>
In this program, the while loop is iterated <k>(high - low - 1)</k> times.

In each iteration, whether <mk>low</mk> is a prime number or not is checked and the value of <mk>low</mk> is incremented by 1 until <mk>low</mk> is equal to <mk>high</mk>.

Visit this page to learn more on how to <a href="/c-programming/examples/prime-number">check whether a number is prime or not</a>.

If the user enters larger number first, this program doesn&#39;t work as intended. 
You can solve this issue by <a href="/c-programming/examples/swapping">swapping the numbers</a> if the user enters larger number first.
<h3>Example #2: Display Prime Numbers Between two Intervals When Larger Number is Entered first</h3>

<k>#include &lt;stdio.h>
int main()
{
    int low, high, i, flag, temp;
    printf("Enter two numbers(intevals): ");
    scanf("%d %d", &low, &high);

    //swapping numbers if low is greater than high
    if (low > high) {
temp = low;
low = high;
high = temp;
    }

    printf("Prime numbers between %d and %d are: ", low, high);

    while (low &lt; high)
    {
flag = 0;

for(i = 2; i &lt;= low/2; ++i)
{
if(low % i == 0)
{
    flag = 1;
    break;
}
}

if (flag == 0)
printf("%d ", low);

++low;
    }

    return 0;
}</k>
Visit this page to learn how you can <a href="/c-programming/examples/prime-interval-function">display all prime numbers between two intervals by using a user-defined function</a>.

<h2>Check Armstrong Number</h2>
Example to check whether an integer (entered by the user) is an Armstrong number or not using while loop and if...else statement.

abcd... = a<sup>n</sup> + b<sup>n</sup> + c<sup>n</sup> + d<sup>n</sup> + ...
In case of an Armstrong number of 3 digits, the sum of cubes of each digits is equal to the number itself. 
For example:

153 = 1*1*1 + 5*5*5 + 3*3*3  // 153 is an Armstrong number.

<h3>Example #1: Check Armstrong Number of three digits</h3>

<k>#include &lt;stdio.h>
int main()
{
    int number, originalNumber, remainder, result = 0;

    printf("Enter a three digit integer: ");
    scanf("%d", &number);

    originalNumber = number;

    while (originalNumber != 0)
    {
remainder = originalNumber%10;
result += remainder*remainder*remainder;
originalNumber /= 10;
    }

    if(result == number)
printf("%d is an Armstrong number.",number);
    else
printf("%d is not an Armstrong number.",number);

    return 0;
}</k>
<r>Output</r>
<k>Enter a three digit integer: 371
371 is an Armstrong number.</k>

<h3>Example #2: Check Armstrong Number of n digits</h3>

<k>
#include &lt;stdio.h>
#include &lt;math.h>

int main()
{
    int number, originalNumber, remainder, result = 0, n = 0 ;

    printf("Enter an integer: ");
    scanf("%d", &number);

     originalNumber = number;
    while (originalNumber != 0)
    {
originalNumber /= 10;
++n;
    }

    originalNumber = number;

    while (originalNumber != 0)
    {
remainder = originalNumber%10;
result += pow(remainder, n);
originalNumber /= 10;
    }

    if(result == number)
printf("%d is an Armstrong number.", number);
    else
printf("%d is not an Armstrong number.", number);

    return 0;
}</k>

<r>Output</r>
<k>Enter an integer: 1634
1634 is an Armstrong number.</k>
In this program, the <a href="/c-programming/examples/digits-count">number of digits of an integer</a> is calculated first and stored in <mk>n</mk> variable. 
And, the <a href="/c-programming/library-function/math.h/pow">pow()</a> function is used to compute the power of individual digits in each iteration of the <mk>while</mk> loop.

<h2>Display Armstrong Number Between Two Intervals</h2>
Example to find all Armstrong numbers between two integers (entered by the user) using loops and if...else statement.

abcd... 
= a<sup>n</sup> + b<sup>n</sup> + c<sup>n</sup> + d<sup>n</sup> + ...
In case of an Armstrong number of 3 digits, the sum of cubes of each digits is equal to the number itself. 
For example:

153 = 1*1*1 + 5*5*5 + 3*3*3  // 153 is an Armstrong number.

This program is built on the concept of <a href="/c-programming/examples/check-armstrong-number">how to check whether an integer is an Armstrong number or not</a>.
<h3>Armstrong Numbers Between Two Integers</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

int main()
{
    int low, high, i, temp1, temp2, remainder, n = 0, result = 0;

    printf("Enter two numbers(intervals): ");
    scanf("%d %d", &low, &high);
    printf("Armstrong numbers between %d an %d are: ", low, high);

    for(i = low + 1; i &lt; high; ++i)
    {
temp2 = i;
temp1 = i;

// number of digits calculation
while (temp1 != 0)
{
temp1 /= 10;
++n;
}

// result contains sum of nth power of its digits
while (temp2 != 0)
{
remainder = temp2 % 10;
result += pow(remainder, n);
temp2 /= 10;
}

// checks if number i is equal to the sum of nth power of its digits
if (result == i) {
printf("%d ", i);
}

// resetting the values to check Armstrong number for next iteration
n = 0;
result = 0;

    }
    return 0;
}
</k>
<b>Output</b>

<k>Enter two numbers(intervals): 999
99999
Armstrong numbers between 999 an 99999 are: 1634 8208 9474 54748 92727 93084</k>

<h2>Display Factors of a Number</h2>
Example to find all factors of an integer (entered by the user) using for loop and if statement.
<h3>Factors of a Positive Integer</h3>

<k>#include &lt;stdio.h>
int main()
{
    int number, i;

    printf("Enter a positive integer: ");
    scanf("%d",&number);

    printf("Factors of %d are: ", number);
    for(i=1; i &lt;= number; ++i)
    {
if (number%i == 0)
{
printf("%d ",i);
}
    }

    return 0;
}
</k>

<r>Output</r>

<k>Enter a positive integer: 60
Factors of 60 are: 1 2 3 4 5 6 10 12 15 20 30 60</k>

In the program, a positive integer entered by the user is stored in variable <mk>number</mk>.

The <k>for</k> loop is iterated until <k>i &lt;= number</k> is false. 
In each iteration, whether <mk>number</mk> is exactly divisible by <mk>i</mk> is checked (condition for <mk>i</mk> to be the factor of <mk>number</mk>) and the value of <mk>i</mk> is incremented by 1.

<h2>C Programming Code To Create Pyramid and Pattern</h2>
Examples to print half pyramid, pyramid, inverted pyramid, Pascal's Triangle and Floyd's triangle in C Programming using control statements.

List of Source Code
<a href="#triangle">print triangles using *, digits and characters</a>
<a href="#inverted_triangle">print inverted triangles using * and digits</a>
<a href="#pyramid">print full pyramids</a>
<a href="#pascal_triangle">print Pascal&#39;s triangle</a>
<a href="#floyd_triangle">print Floyd&#39;s triangle</a>
<h3><a name="triangle"></a> Programs to print triangles using *, numbers and characters</h3>
<hr />
<h3>Example 1: Program to print half pyramid using *</h3>

<k>*
* *
* * *
* * * *
* * * * *</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("* ");
}
printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 2: Program to print half pyramid a using numbers</h3>

<k>1
1 2
1 2 3
1 2 3 4
1 2 3 4 5</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("%d ",j);
}
printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 3: Program to print half pyramid using alphabets</h3>

<k>A
B B
C C C
D D D D
E E E E E</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j;
    char input, alphabet = &#39;A&#39;;

    printf("Enter the uppercase character you want to print in last row: ");
    scanf("%c",&input);

    for(i=1; i &lt;= (input-&#39;A&#39;+1); ++i)
    {
for(j=1;j&lt;=i;++j)
{
printf("%c", alphabet);
}
++alphabet;

printf("\n");
    }
    return 0;
}</k>
<h3><a name="inverted_triangle"></a>Programs to print inverted half pyramid using * and numbers</h3>
<hr />
<h3>Example 4: Inverted half pyramid using *</h3>

<k>* * * * *
* * * *
* * * 
* *
*</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("* ");
}
printf("\n");
    }
    return 0;
}</k>

<hr />
<h3>Example 5: Inverted half pyramid using numbers</h3>

<k>1 2 3 4 5
1 2 3 4 
1 2 3
1 2
1</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("%d ",j);
}
printf("\n");
    }

    return 0;
}</k>
<h3><a name="pyramid"></a> Programs to display pyramid and inverted pyramid using * and digits</h3>
<hr />
<h3>Example 6: Program to print full pyramid using *</h3>

<k>*
      * * *
    * * * * *
  * * * * * * *
* * * * * * * * *</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, space, rows, k=0;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i, k=0)
    {
for(space=1; space&lt;=rows-i; ++space)
{
printf("  ");
}

while(k != 2*i-1)
{
printf("* ");
++k;
}

printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 7: Program to print pyramid using numbers</h3>

<k>
1
      2 3 2
    3 4 5 4 3
  4 5 6 7 6 5 4
5 6 7 8 9 8 7 6 5</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, space, rows, k=0, count = 0, count1 = 0;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(space=1; space &lt;= rows-i; ++space)
{
printf("  ");
++count;
}

while(k != 2*i-1)
{
if (count &lt;= rows-1)
{
    printf("%d ", i+k);
    ++count;
}
else
{
    ++count1;
    printf("%d ", (i+k-2*count1));
}
++k;
}
count1 = count = k = 0;

printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 8: Inverted full pyramid using *</h3>

<k>
* * * * * * * * *
  * * * * * * *
    * * * * *
      * * *
*</k>

<b>Source Code</b>

<k>#include&lt;stdio.h>
int main()
{
    int rows, i, j, space;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(space=0; space &lt; rows-i; ++space)
printf("  ");

for(j=i; j &lt;= 2*i-1; ++j)
printf("* ");

for(j=0; j &lt; i-1; ++j)
printf("* ");

printf("\n");
    }

    return 0;
}</k>

<hr />
<h3><a name="pascal_triangle"></a>Example 9: Print Pascal&#39;s triangle</h3>

<k>
   1
 1   1
       1   2   1
     1   3   3    1
   1  4    6   4   1
 1  5   10   10  5   1 </k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int rows, coef = 1, space, i, j;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=0; i&lt;rows; i++)
    {
for(space=1; space &lt;= rows-i; space++)
printf("  ");

for(j=0; j &lt;= i; j++)
{
if (j==0 || i==0)
    coef = 1;
else
    coef = coef*(i-j+1)/j;

printf("%4d", coef);
}
printf("\n");
    }

    return 0;
}</k>

<hr />
<h3><a name="floyd_triangle"></a>Example 10: Print Floyd&#39;s Triangle.</h3>

<k>1
2 3
4 5 6
7 8 9 10</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int rows, i, j, number= 1;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i &lt;= rows; i++)
    {
for(j=1; j &lt;= i; ++j)
{
printf("%d ", number);
++number;
}

printf("\n");
    }

    return 0;
}</k>

<h2>Make a Simple Calculator Using switch...case</h2>
Example to create a simple calculator to add, subtract, multiply and divide using switch and break statement.
<h3>Simple Calculator using switch Statement</h3>

<k>
// Performs addition, subtraction, multiplication or division depending the input from user

# include &lt;stdio.h>

int main() {

    char operator;
    double firstNumber,secondNumber;

    printf("Enter an operator (+, -, *,): ");
    scanf("%c", &operator);

    printf("Enter two operands: ");
    scanf("%lf %lf",&firstNumber, &secondNumber);

    switch(operator)
    {
case &#39;+&#39;:
printf("%.1lf + %.1lf = %.1lf",firstNumber, secondNumber, firstNumber + secondNumber);
break;

case &#39;-&#39;:
printf("%.1lf - %.1lf = %.1lf",firstNumber, secondNumber, firstNumber - secondNumber);
break;

case &#39;*&#39;:
printf("%.1lf * %.1lf = %.1lf",firstNumber, secondNumber, firstNumber * secondNumber);
break;

case &#39;/&#39;:
printf("%.1lf / %.1lf = %.1lf",firstNumber, secondNumber, firstNumber / secondNumber);
break;

// operator doesn&#39;t match any case constant (+, -, *, /)
default:
printf("Error! operator is not correct");
    }
    return 0;
}
</k>

<r>Output</r>

<k>Enter an operator (+, -, *,): *
Enter two operands: 1.5
4.5
1.5 * 4.5 = 6.8</k>

The <k>*</k> operator entered by the user is stored in the <mk>operator</mk> variable. 
And, the two operands, 1.5 and 4.5 are stored in variables <mk>firstNumber</mk> and <mk>secondNumber</mk> respectively.

Since, the operator <k>*</k> matches the case <k>case &#39;*&#39;:</k>, the control of the program jumps to

printf("%.1lf * %.1lf = %.1lf",firstNumber, secondNumber, firstNumber * secondNumber);

This statement calculates the product and displays it on the screen.

Finally, the <k>break</k>; statement ends the switch statement.

<h2>Display Prime Numbers Between Intervals Using Function</h2>
Example to print all prime numbers between two numbers (entered by the user) by making a user-defined function.
<h3>Prime Numbers Between Two Integers</h3>

<k>#include &lt;stdio.h>

int checkPrimeNumber(int n);
int main()
{
    int n1, n2, i, flag;

    printf("Enter two positive integers: ");
    scanf("%d %d", &n1, &n2);
    printf("Prime numbers between %d and %d are: ", n1, n2);

    for(i=n1+1; i&lt;n2; ++i)
    {
// i is a prime number, flag will be equal to 1
flag = checkPrimeNumber(i);

if(flag == 1)
printf("%d ",i);
    }
    return 0;
}

// user-defined function to check prime number
int checkPrimeNumber(int n)
{
    int j, flag = 1;

    for(j=2; j &lt;= n/2; ++j)
    {
if (n%j == 0)
{
flag =0;
break;
}
    }
    return flag;
}</k>
<b>Output</b>

<k>Enter two positive integers: 12
30
Prime numbers between 12 and 30 are: 13 17 19 23 29
</k>

If the user enters larger number first, this program will not work as intended. 
To solve this issue, you need to <a href="/c-programming/examples/swapping">swap numbers</a> first.

<h2>Check Prime or Armstrong Number Using User-defined Function</h2>
Example to check whether an integer is a prime number or an Armstrong or both by creating two separate functions. 

The <k>checkPrimeNumber()</k> returns 1 if the number entered by the user is a prime number. 
Similarly, <k>checkArmstrongNumber()</k> returns 1 if the number entered by the user is an Armstrong number.

Visit these pages to learn to check whether a number is

<a href="/c-programming/examples/prime-number">a prime number or not</a>
<a href="/c-programming/examples/check-armstrong-number">an Armstrong number or not</a>

<h3>Check Prime and Armstrong Number</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

int checkPrimeNumber(int n);
int checkArmstrongNumber(int n);

int main()
{
    int n, flag;

    printf("Enter a positive integer: ");
    scanf("%d", &n);

    // Check prime number
    flag = checkPrimeNumber(n);
    if (flag == 1)
printf("%d is a prime number.\n", n);
    else
printf("%d is not a prime number.\n", n);

    // Check Armstrong number
    flag = checkArmstrongNumber(n);
    if (flag == 1)
printf("%d is an Armstrong number.", n);
    else
printf("%d is not an Armstrong number.",n);
    return 0;
}

int checkPrimeNumber(int n)
{
    int i, flag = 1;

    for(i=2; i&lt;=n/2; ++i)
    {

    // condition for non-prime number
if(n%i == 0)
{
flag = 0;
break;
}
    }
    return flag;
}

int checkArmstrongNumber(int number)
{
    int originalNumber, remainder, result = 0, n = 0, flag;

    originalNumber = number;

    while (originalNumber != 0)
    {
originalNumber /= 10;
++n;
    }

    originalNumber = number;

    while (originalNumber != 0)
    {
remainder = originalNumber%10;
result += pow(remainder, n);
originalNumber /= 10;
    }

    // condition for Armstrong number
    if(result == number)
flag = 1;
    else
flag = 0;

    return flag;
}</k>
<r>Output</r>
<k>Enter a positive integer: 407
407 is not a prime number.
407 is an Armstrong number.</k>

<h2>Check Whether a Number can be Expressed as Sum of Two Prime Numbers</h2>
Example to check if an integer (entered by the user) can be expressed as the sum of two prime numbers of all possible combinations with the use of functions.

The <k>checkPrime()</k> returns 1 if the number passed to the function is a <a href="/c-programming/examples/prime-number">prime number</a>. 
<h3>Integer as a Sum of Two Prime Numbers</h3>

<k>#include &lt;stdio.h>
int checkPrime(int n);
int main()
{
    int n, i, flag = 0;

    printf("Enter a positive integer: ");
    scanf("%d", &n);

    for(i = 2; i <= n/2; ++i)
    {
// condition for i to be a prime number
if (checkPrime(i) == 1)
{
// condition for n-i to be a prime number
if (checkPrime(n-i) == 1)
{
    // n = primeNumber1 + primeNumber2
    printf("%d = %d + %d\n", n, i, n - i);
    flag = 1;
}

}
    }

    if (flag == 0)
printf("%d cannot be expressed as the sum of two prime numbers.", n);

    return 0;
}

// Function to check prime number
int checkPrime(int n)
{
    int i, isPrime = 1;

    for(i = 2; i <= n/2; ++i)
    {
if(n % i == 0)
{
isPrime = 0;
break;
}  
    }

    return isPrime;
}
</k>

<r>Output</r>

<k>Enter a positive integer: 34
34 = 3 + 31
34 = 5 + 29
34 = 11 + 23
34 = 17 + 17</k>

<h2>Find the Sum of Natural Numbers using Recursion</h2>
Example to find the sum of natural numbers by using a recursive function.

You can <a href="/c-programming/examples/sum-natural-numbers">find the sum of natural numbers using loop</a> as well. 
However, you will learn to solve this problem using recursion here.
<h3>Sum of Natural Numbers Using Recursion</h3>

<k>#include &lt;stdio.h>
int addNumbers(int n);

int main()
{
    int num;
    printf("Enter a positive integer: ");
    scanf("%d", &num);
    printf("Sum = %d",addNumbers(num));
    return 0;
}

int addNumbers(int n)
{
    if(n != 0)
return n + addNumbers(n-1);
    else
return n;
}</k>
<r>Output</r>
<k>Enter a positive integer: 20
Sum = 210</k>
Suppose the user entered 20.

Initially, the <k>addNumbers()</k> is called from the <k>main()</k> function with 20 passed as an argument.

The number (20) is added to the result of <k>addNumbers(19)</k>.

In the next function call from <k>addNumbers()</k> to <k>addNumbers()</k>, 19 is passed which is added to the result of <k>addNumbers(18)</k>. 
This process continues until <mk>n</mk> is equal to 0.

When <mk>n</mk> is equal to 0, there is no recursive call and this returns the sum of integers to the <k>main()</k> function.

<h2>Find Factorial of a Number Using Recursion</h2>
Example to find factorial of a non-negative integer (entered by the user) using recursion.

factorial of n (n!) = 1*2*3*4....n
The factorial of a negative number doesn&#39;t exist. 
And the factorial of 0 is 1.

You will learn to find the factorial of a number using recursion in this example. 
Visit this page to learn, how you can find the <a href="/c-programming/examples/factorial">factorial of a number using loop</a>.
<h3>Factorial of a Number Using Recursion</h3>

<k>#include &lt;stdio.h>
long int multiplyNumbers(int n);

int main()
{
    int n;
    printf("Enter a positive integer: ");
    scanf("%d", &n);
    printf("Factorial of %d = %ld", n, multiplyNumbers(n));
    return 0;
}
long int multiplyNumbers(int n)
{
    if (n >= 1)
return n*multiplyNumbers(n-1);
    else
return 1;
}
</k>
<r>Output</r>
<k>Enter a positive integer: 6
Factorial of 6 = 720</k>

Suppose the user entered 6.

Initially, the <k>multiplyNumbers()</k> is called from the <k>main()</k> function with 6 passed as an argument.

Then, 5 is passed to the <k>multiplyNumbers()</k> function from the same function (recursive call). 
In each recursive call, the value of argument <mk>n</mk> is decreased by 1.

When the value of <mk>n</mk> is less than 1, there is no recursive call.

<h2>Find G.C.D Using Recursion</h2>
Example to find the GCD of two positive integers (entered by the user) using recursion in C programming.

Visit this page to learn how you can <a href="/c-programming/examples/hcf-gcd">calculate the <abbr>GCD</abbr> using loops</a>.
<h3>GCD of Two Numbers using Recursion</h3>

<k>#include &lt;stdio.h>
int hcf(int n1, int n2);
int main()
{
   int n1, n2;
   printf("Enter two positive integers: ");
   scanf("%d %d", &n1, &n2);

   printf("G.C.D of %d and %d is %d.", n1, n2, hcf(n1,n2));
   return 0;
}

int hcf(int n1, int n2)
{
    if (n2 != 0)
       return hcf(n2, n1%n2);
    else 
       return n1;
}
</k>

<r>Output</r>
<k>Enter two positive integers: 366
60
G.C.D of 366 and 60 is 6.</k>

<h2>Convert Binary Number to Decimal and vice-versa</h2>
In this example, you will learn to convert binary number to decimal and decimal number to binary manually by creating a user-defined function.
<h3>Example 1: Program to convert binary number to decimal</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>
int convertBinaryToDecimal(long long n);

int main()
{
    long long n;
    printf("Enter a binary number: ");
    scanf("%lld", &n);
    printf("%lld in binary = %d in decimal", n, convertBinaryToDecimal(n));
    return 0;
}

int convertBinaryToDecimal(long long n)
{
    int decimalNumber = 0, i = 0, remainder;
    while (n!=0)
    {
remainder = n%10;
n /= 10;
decimalNumber += remainder*pow(2,i);
++i;
    }
    return decimalNumber;
}
</k>
<r>Output</r>
<k>Enter a binary number: 110110111
110110111 in binary = 439
</k>

Visit this page to learn, <a href="http://www.wikihow.com/Convert-from-Decimal-to-Binary">how to convert decimal number to binary</a>.
<h3>Example 2: Program to convert decimal number to binary</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>
long long convertDecimalToBinary(int n);

int main()
{
    int n;
    printf("Enter a decimal number: ");
    scanf("%d", &n);
    printf("%d in decimal = %lld in binary", n, convertDecimalToBinary(n));
    return 0;
}

long long convertDecimalToBinary(int n)
{
    long long binaryNumber = 0;
    int remainder, i = 1, step = 1;

    while (n!=0)
    {
remainder = n%2;
printf("Step %d: %d/2, Remainder = %d, Quotient = %d\n", step++, n, remainder, n/2);
n /= 2;
binaryNumber += remainder*i;
i *= 10;
    }
    return binaryNumber;
}
</k>
<r>Output</r>
<k>Enter a decimal number: 19
Step 1: 19/2, Remainder = 1, Quotient = 9
Step 2: 9/2, Remainder = 1, Quotient = 4
Step 3: 4/2, Remainder = 0, Quotient = 2
Step 4: 2/2, Remainder = 0, Quotient = 1
Step 5: 1/2, Remainder = 1, Quotient = 0
19 in decimal = 10011 in binary</k>

<h2>Convert Octal Number to Decimal and vice-versa</h2>
In this example, you will learn to convert octal number to decimal and decimal number to octal manually by creating a user-defined function.
<h3>Example 1: Program to Convert Decimal to Octal</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

int convertDecimalToOctal(int decimalNumber);
int main()
{
    int decimalNumber;

    printf("Enter a decimal number: ");
    scanf("%d", &decimalNumber);

    printf("%d in decimal = %d in octal", decimalNumber, convertDecimalToOctal(decimalNumber));

    return 0;
}

int convertDecimalToOctal(int decimalNumber)
{
    int octalNumber = 0, i = 1;

    while (decimalNumber != 0)
    {
octalNumber += (decimalNumber % 8) * i;
decimalNumber /= 8;
i *= 10;
    }

    return octalNumber;
}
</k>
<r>Output</r>
<k>Enter a decimal number: 78
78 in decimal = 116 in octal</k>

<h3>Example 2: Program to Convert Octal to Decimal</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

long long convertOctalToDecimal(int octalNumber);
int main()
{
    int octalNumber;

    printf("Enter an octal number: ");
    scanf("%d", &octalNumber);

    printf("%d in octal = %lld in decimal", octalNumber, convertOctalToDecimal(octalNumber));

    return 0;
}

long long convertOctalToDecimal(int octalNumber)
{
    int decimalNumber = 0, i = 0;

    while(octalNumber != 0)
    {
decimalNumber += (octalNumber%10) * pow(8,i);
++i;
octalNumber/=10;
    }

    i = 1;

    return decimalNumber;
}

</k>
<r>Output</r>
<k>Enter an octal number: 116
116 in octal = 78 in decimal
</k>

<h2>Convert Binary Number to Octal and vice-versa</h2>
In this example, you will learn to convert binary number to octal and octal number to binary manually by creating a user-defined function.
<h3>Example 1: Program to Convert Binary to Octal</h3>
In this program, we will first convert binary number to decimal. 
Then, the decimal number is converted to octal.

<k>#include &lt;stdio.h>
#include &lt;math.h>

int convertBinarytoOctal(long long binaryNumber);
int main()
{
    long long binaryNumber;

    printf("Enter a binary number: ");
    scanf("%lld", &binaryNumber);

    printf("%lld in binary = %d in octal", binaryNumber, convertBinarytoOctal(binaryNumber));

    return 0;
}

int convertBinarytoOctal(long long binaryNumber)
{
    int octalNumber = 0, decimalNumber = 0, i = 0;

    while(binaryNumber != 0)
    {
decimalNumber += (binaryNumber%10) * pow(2,i);
++i;
binaryNumber/=10;
    }

    i = 1;

    while (decimalNumber != 0)
    {
octalNumber += (decimalNumber % 8) * i;
decimalNumber /= 8;
i *= 10;
    }

    return octalNumber;
}

</k>
<r>Output</r>
<k>Enter a binary number: 101001
101001 in binary = 51 in octal</k>

<h3>Example 2: Program to Convert Octal to Binary</h3>

In this program, the octal number to decimal to decimal at first. 
Then, the decimal number is converted to binary number.

<k>#include &lt;stdio.h>
#include &lt;math.h>

long long convertOctalToBinary(int octalNumber);
int main()
{
    int octalNumber;

    printf("Enter an octal number: ");
    scanf("%d", &octalNumber);

    printf("%d in octal = %lld in binary", octalNumber, convertOctalToBinary(octalNumber));

    return 0;
}

long long convertOctalToBinary(int octalNumber)
{
    int decimalNumber = 0, i = 0;
    long long binaryNumber = 0;

    while(octalNumber != 0)
    {
decimalNumber += (octalNumber%10) * pow(8,i);
++i;
octalNumber/=10;
    }

    i = 1;

    while (decimalNumber != 0)
    {
binaryNumber += (decimalNumber % 2) * i;
decimalNumber /= 2;
i *= 10;
    }

    return binaryNumber;
}
</k>
<r>Output</r>
<k>Enter an octal number: 67
67 in octal = 110111 in binary
</k>

<h2>Reverse a Sentence Using Recursion</h2>
This program takes a sentence from user and reverses that sentence using recursion. 
This program does not use string to reverse the sentence or store the sentence.
<h3>Reverse a sentence using recursion</h3>

<k>/* Example to reverse a sentence entered by user without using strings. 
*/

#include &lt;stdio.h>
void reverseSentence();

int main()
{
    printf("Enter a sentence: ");
    reverseSentence();

    return 0;
}

void reverseSentence()
{
    char c;
    scanf("%c", &c);

    if( c != &#39;\n&#39;)
    {
reverseSentence();
printf("%c",c);
    }
}
</k>
<r>Output</r>
<k>Enter a sentence: margorp emosewa
awesome program</k>

This program first prints "Enter a sentence: ". 
Then, immediately <k>reverseSentence()</k> function is called.

This function stores the first letter entered by user in variable <mk>c</mk>. 
If the variable is any character other than &#39;\n&#39; [ enter character], <k>reverseSentence()</k> function is called again.

When <k>reverseSentence()</k> is called the second time, the second letter entered by the user is stored in <mk>c</mk> again.

But, the variable <mk>c</mk> in the second function isn&#39;t the same as the first. 
They both take different space in the memory.

This process goes on until user enters &#39;\n&#39;.

When, the user finally enters &#39;\n&#39;, the last function <k>reverseSentence()</k> function prints the last character because of <k>printf("%c", c);</k> and returns to the second last <k>reverseSentence()</k> function.

Again, the second last <k>reverseSentence()</k> function prints the second last character and returns to the third last <k>reverseSentence()</k> function.

This process goes on and the final output will be the reversed sentence.

<h2>calculate the power using recursion</h2>
This program calculates the power of a number using recursion.
<h3>Program to calculate power using recursion</h3>

<k>
#include &lt;stdio.h>

int power(int n1, int n2);

int main()
{
    int base, powerRaised, result;

    printf("Enter base number: ");
    scanf("%d",&base);

    printf("Enter power number(positive integer): ");
    scanf("%d",&powerRaised);

    result = power(base, powerRaised);

    printf("%d^%d = %d", base, powerRaised, result);
    return 0;
}

int power(int base, int powerRaised)
{
    if (powerRaised != 0)
return (base*power(base, powerRaised-1));
    else
return 1;
}
</k>

<r>Output</r>

<k>Enter base number: 3
Enter power number(positive integer): 4
3^4 = 81</k>

You can also <a href="/c-programming/examples/power-number">compute power of a number using loops</a>.

If you need to calculate the power of a number raised to a decimal value, you can use <a href="/c-programming/library-function/math.h/pow">pow() library function</a>.

<h2>Calculate Average Using Arrays</h2>
This program takes n number of element from user (where, n is specified by user), stores data in an array and calculates the average of those numbers.
<h3>Source Code to Calculate Average Using Arrays</h3>

<k>#include &lt;stdio.h>

int main()
{
    int n, i;
    float num[100], sum = 0.0, average;

    printf("Enter the numbers of elements: ");
    scanf("%d", &n);

    while (n > 100 || n &lt;= 0)
    {
printf("Error! number should in range of (1 to 100).\n");
printf("Enter the number again: ");
scanf("%d", &n);
    }

    for(i = 0; i &lt; n; ++i)
    {
printf("%d. 
Enter number: ", i+1);
scanf("%f", &num[i]);
sum += num[i];
    }

    average = sum / n;
    printf("Average = %.2f", average);

    return 0;
}
</k>
<r>Output</r>
<k>Enter the numbers of elements: 6
1. 
Enter number: 45.3
2. 
Enter number: 67.5
3. 
Enter number: -45.6
4. 
Enter number: 20.34
5. 
Enter number: 33
6. 
Enter number: 45.6
Average = 27.69
</k>
This program takes the number of elements in the array and stores in the variable <mk>n</mk>.

Then, the for loop gets all the elements from the user and stores the sum of the entered numbers in <mk>sum</mk>.

Finally, the average is calculated by dividing <mk>sum</mk> by the number of elements <mk>n</mk>.

<h2>Find Largest Element of an Array</h2>
This program takes n number of element from user (where, n is specified by user) and stores data in an array. 
Then, this program displays the largest element of that array using loops.
<h3>Display Largest Element of an array</h3>

<k>#include &lt;stdio.h>

int main()
{
    int i, n;
    float arr[100];

    printf("Enter total number of elements(1 to 100): ");
    scanf("%d", &n);
    printf("\n");

    // Stores number entered by the user
    for(i = 0; i &lt; n; ++i)
    {
       printf("Enter Number %d: ", i+1);
       scanf("%f", &arr[i]);
    }

    // Loop to store largest number to arr[0]
    for(i = 1; i &lt; n; ++i)
    {
       // Change &lt; to > if you want to find the smallest element
       if(arr[0] &lt; arr[i])
   arr[0] = arr[i];
    }
    printf("Largest element = %.2f", arr[0]);

    return 0;
}
</k>

<r>Output</r>

<k>Enter total number of elements(1 to 100): 8

Enter Number 1: 23.4
Enter Number 2: -34.5
Enter Number 3: 50
Enter Number 4: 33.5
Enter Number 5: 55.5
Enter Number 6: 43.7
Enter Number 7: 5.7
Enter Number 8: -66.5
</k>

This program takes <mk>n</mk> number of elements from user and stores it in array <mk>arr[]</mk>.

To find the largest element, the first two elements of array are checked and largest of these two element is placed in <mk>arr[0]</mk>.

Then, the first and third elements are checked and largest of these two element is placed in <mk>arr[0]</mk>.

This process continues until and first and last elements are checked.

Finally, the largest element of an array will be in <mk>arr[0]</mk> position.

<hr />
The above program works fine, however, it alters the original array as well. 
The program below computes the largest element of an array without modifying the original array.

<k>#include &lt;stdio.h>

int main()
{
    int i, n;
    float arr[100], temp;

    printf("Enter total number of elements(1 to 100): ");
    scanf("%d", &n);
    printf("\n");

    // Stores number entered by the user
    for(i = 0; i < n; ++i)
    {
       printf("Enter Number %d: ", i+1);
       scanf("%f", &arr[i]);
    }

    // Loop to store largest number to arr[0]
    for(i = 1; i < n; ++i)
    {
       // Change < to > if you want to find the smallest element
       if(arr[0] < arr[i]) 
       {
   temp = arr[0];
   arr[0] = arr[i];
   arr[i] = temp;
       }
  
    }
    printf("Largest element = %.2f", arr[0]);

    return 0;
}</k>
<h2>Calculate Standard Deviation</h2>
This program calculates the standard deviation of 10 data using arrays.

To calculate the standard deviation, <k>calculateSD()</k> function is created. 
The array containing 10 elements is passed to the function and this function calculates the standard deviation and returns it to the <k>main()</k> function.
<h3>Program to Calculate Standard Deviation</h3>

<k>#include &lt;stdio.h>
#include &lt;math.h>

float calculateSD(float data[]);

int main()
{
    int i;
    float data[10];

    printf("Enter 10 elements: ");
    for(i=0; i &lt; 10; ++i)
scanf("%f", &data[i]);

    printf("\nStandard Deviation = %.6f", calculateSD(data));

    return 0;
}

float calculateSD(float data[])
{
    float sum = 0.0, mean, standardDeviation = 0.0;

    int i;

    for(i=0; i&lt;10; ++i)
    {
sum += data[i];
    }

    mean = sum/10;

    for(i=0; i&lt;10; ++i)
standardDeviation += pow(data[i] - mean, 2);

    return sqrt(standardDeviation/10);
}
</k>

<r>Output</r>
<k>
Enter 10 elements: 1
2
3
4
5
6
7
8
9
10

Standard Deviation = 2.872281
</k>

<h2>Add Two Matrix Using Multi-dimensional Arrays</h2>
<a href="https://www.programiz.com/c-programming/c-multi-dimensional-arrays" class="whitebut ">C Multidimensional Arrays</a>

This program takes two matrices of order r*c  and stores it in two-dimensional array. 
Then, the program adds these two matrices and displays it on the screen.

The user is asked to enter elements of two matrices (of order r*c).

Then, the program adds these two matrices, saves it in another matrix (two-dimensional array) and displays it on the screen.
<h3>Program to Add Two Matrices</h3>

<k>#include &lt;stdio.h>
int main(){
    int r, c, a[100][100], b[100][100], sum[100][100], i, j;

    printf("Enter number of rows (between 1 and 100): ");
    scanf("%d", &r);
    printf("Enter number of columns (between 1 and 100): ");
    scanf("%d", &c);

    printf("\nEnter elements of 1st matrix:\n");

    for(i=0; i&lt;r; ++i)
for(j=0; j&lt;c; ++j)
{
printf("Enter element a%d%d: ",i+1,j+1);
scanf("%d",&a[i][j]);
}

    printf("Enter elements of 2nd matrix:\n");
    for(i=0; i&lt;r; ++i)
for(j=0; j&lt;c; ++j)
{
printf("Enter element a%d%d: ",i+1, j+1);
scanf("%d", &b[i][j]);
}

    // Adding Two matrices

    for(i=0;i&lt;r;++i)
for(j=0;j&lt;c;++j)
{
sum[i][j]=a[i][j]+b[i][j];
}

    // Displaying the result
    printf("\nSum of two matrix is: \n\n");

    for(i=0;i&lt;r;++i)
for(j=0;j&lt;c;++j)
{

printf("%d   ",sum[i][j]);

if(j==c-1)
{
    printf("\n\n");
}
}
    return 0;
}
</k>
<r>Output</r>
<k>Enter number of rows (between 1 and 100): 2
Enter number of columns (between 1 and 100): 3

Enter elements of 1st matrix:
Enter element a11: 2
Enter element a12: 3
Enter element a13: 4
Enter element a21: 5
Enter element a22: 2
Enter element a23: 3
Enter elements of 2nd matrix:
Enter element a11: -4
Enter element a12: 5
Enter element a13: 3
Enter element a21: 5
Enter element a22: 6
Enter element a23: 3

Sum of two matrix is: 

-2   8   7   

10   8   6  
</k>

<h2>Multiply to Matrix Using Multi-dimensional Arrays</h2>
This program takes two matrices of order r1*c1 and  r2*c2 respectively. 
Then, the program multiplies these two matrices (if possible) and displays it on the screen.
<h3>Program to Multiply Two Matrices</h3>

<k>#include &lt;stdio.h>

int main()
{
    int a[10][10], b[10][10], result[10][10], r1, c1, r2, c2, i, j, k;

    printf("Enter rows and column for first matrix: ");
    scanf("%d %d", &r1, &c1);

    printf("Enter rows and column for second matrix: ");
    scanf("%d %d",&r2, &c2);

    // Column of first matrix should be equal to column of second matrix and
    while (c1 != r2)
    {
printf("Error! column of first matrix not equal to row of second.\n\n");
printf("Enter rows and column for first matrix: ");
scanf("%d %d", &r1, &c1);
printf("Enter rows and column for second matrix: ");
scanf("%d %d",&r2, &c2);
    }

    // Storing elements of first matrix.
    printf("\nEnter elements of matrix 1:\n");
    for(i=0; i&lt;r1; ++i)
for(j=0; j&lt;c1; ++j)
{
printf("Enter elements a%d%d: ",i+1, j+1);
scanf("%d", &a[i][j]);
}

    // Storing elements of second matrix.
    printf("\nEnter elements of matrix 2:\n");
    for(i=0; i&lt;r2; ++i)
for(j=0; j&lt;c2; ++j)
{
printf("Enter elements b%d%d: ",i+1, j+1);
scanf("%d",&b[i][j]);
}

    // Initializing all elements of result matrix to 0
    for(i=0; i&lt;r1; ++i)
for(j=0; j&lt;c2; ++j)
{
result[i][j] = 0;
}

    // Multiplying matrices a and b and
    // storing result in result matrix
    for(i=0; i&lt;r1; ++i)
for(j=0; j&lt;c2; ++j)
for(k=0; k&lt;c1; ++k)
{
    result[i][j]+=a[i][k]*b[k][j];
}

    // Displaying the result
    printf("\nOutput Matrix:\n");
    for(i=0; i&lt;r1; ++i)
for(j=0; j&lt;c2; ++j)
{
printf("%d  ", result[i][j]);
if(j == c2-1)
    printf("\n\n");
}
    return 0;
}
</k>

<r>Output</r>

<k>Enter rows and column for first matrix: 3
2
Enter rows and column for second matrix: 3
2
Error! column of first matrix not equal to row of second.

Enter rows and column for first matrix: 2
3
Enter rows and column for second matrix: 3
2

Enter elements of matrix 1:
Enter elements a11: 3
Enter elements a12: -2
Enter elements a13: 5
Enter elements a21: 3
Enter elements a22: 0
Enter elements a23: 4

Enter elements of matrix 2:
Enter elements b11: 2
Enter elements b12: 3
Enter elements b21: -9
Enter elements b22: 0
Enter elements b31: 0
Enter elements b32: 4

Output Matrix:
24  29

6  25</k>

It is better to solve this program by passing it to a function. 
Visit this page to learn how you can <a href="/c-programming/examples/matrix-multiplication-function">multiplying matrices by passing arrays to a function</a>.

<h2>Find Transpose of a Matrix</h2>
This program takes a matrix of order r*c from the user and computes the transpose of that matrix.

The user is asked to enter elements of the matrix (of order r*c).

Then, the program computes the transpose of the matrix and displays it on the screen.
<h3>Program to Find Transpose of a Matrix</h3>

<k>#include &lt;stdio.h>

int main()
{
    int a[10][10], transpose[10][10], r, c, i, j;
    printf("Enter rows and columns of matrix: ");
    scanf("%d %d", &r, &c);

    // Storing elements of the matrix
    printf("\nEnter elements of matrix:\n");
    for(i=0; i&lt;r; ++i)
for(j=0; j&lt;c; ++j)
{
printf("Enter element a%d%d: ",i+1, j+1);
scanf("%d", &a[i][j]);
}

    // Displaying the matrix a[][] */
    printf("\nEntered Matrix: \n");
    for(i=0; i&lt;r; ++i)
for(j=0; j&lt;c; ++j)
{
printf("%d  ", a[i][j]);
if (j == c-1)
    printf("\n\n");
}

    // Finding the transpose of matrix a
    for(i=0; i&lt;r; ++i)
for(j=0; j&lt;c; ++j)
{
transpose[j][i] = a[i][j];
}

    // Displaying the transpose of matrix a
    printf("\nTranspose of Matrix:\n");
    for(i=0; i&lt;c; ++i)
for(j=0; j&lt;r; ++j)
{
printf("%d  ",transpose[i][j]);
if(j==r-1)
    printf("\n\n");
}

    return 0;
}

</k>
<r>Output</r>
<k>Enter rows and columns of matrix: 2
3

Enter element of matrix:
Enter element a11: 2
Enter element a12: 3
Enter element a13: 4
Enter element a21: 5
Enter element a22: 6
Enter element a23: 4

Entered Matrix: 
2  3  4  

5  6  4  

Transpose of Matrix:
2  5  

3  6  

4  4  </k>

<h2>Multiply two Matrices by Passing Matrix to a Function</h2>
In this example, you'll learn to multiply two matrices and display it using user defined function.

Then, it asks the user to enter the elements of those matrices and finally adds and displays the result.

To perform this task three functions are made:

To takes matrix elements from user <k>enterData()</k>
To multiply two matrix <k>multiplyMatrices()</k>
To display the resultant matrix after multiplication <k>display()</k>

<h3>Multiply Matrices by Passing it to a Function</h3>

<k>#include &lt;stdio.h>

void enterData(int firstMatrix[][10], int secondMatrix[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond);
void multiplyMatrices(int firstMatrix[][10], int secondMatrix[][10], int multResult[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond);
void display(int mult[][10], int rowFirst, int columnSecond);

int main()
{
int firstMatrix[10][10], secondMatrix[10][10], mult[10][10], rowFirst, columnFirst, rowSecond, columnSecond, i, j, k;

printf("Enter rows and column for first matrix: ");
scanf("%d %d", &rowFirst, &columnFirst);

printf("Enter rows and column for second matrix: ");
scanf("%d %d", &rowSecond, &columnSecond);

// If colum of first matrix in not equal to row of second matrix, asking user to enter the size of matrix again.
while (columnFirst != rowSecond)
{
printf("Error! column of first matrix not equal to row of second.\n");
printf("Enter rows and column for first matrix: ");
scanf("%d%d", &rowFirst, &columnFirst);
printf("Enter rows and column for second matrix: ");
scanf("%d%d", &rowSecond, &columnSecond);
}

// Function to take matrices data
enterData(firstMatrix, secondMatrix, rowFirst, columnFirst, rowSecond, columnSecond);

// Function to multiply two matrices.
multiplyMatrices(firstMatrix, secondMatrix, mult, rowFirst, columnFirst, rowSecond, columnSecond);

// Function to display resultant matrix after multiplication.
display(mult, rowFirst, columnSecond);

return 0;
}

void enterData(int firstMatrix[][10], int secondMatrix[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond)
{
int i, j;
printf("\nEnter elements of matrix 1:\n");
for(i = 0; i &lt; rowFirst; ++i)
{
for(j = 0; j &lt; columnFirst; ++j)
{
printf("Enter elements a%d%d: ", i + 1, j + 1);
scanf("%d", &firstMatrix[i][j]);
}
}

printf("\nEnter elements of matrix 2:\n");
for(i = 0; i &lt; rowSecond; ++i)
{
for(j = 0; j &lt; columnSecond; ++j)
{
printf("Enter elements b%d%d: ", i + 1, j + 1);
scanf("%d", &secondMatrix[i][j]);
}
}
}

void multiplyMatrices(int firstMatrix[][10], int secondMatrix[][10], int mult[][10], int rowFirst, int columnFirst, int rowSecond, int columnSecond)
{
int i, j, k;

// Initializing elements of matrix mult to 0.
for(i = 0; i &lt; rowFirst; ++i)
{
for(j = 0; j &lt; columnSecond; ++j)
{
mult[i][j] = 0;
}
}

// Multiplying matrix firstMatrix and secondMatrix and storing in array mult.
for(i = 0; i &lt; rowFirst; ++i)
{
for(j = 0; j &lt; columnSecond; ++j)
{
for(k=0; k&lt;columnFirst; ++k)
{
mult[i][j] += firstMatrix[i][k] * secondMatrix[k][j];
}
}
}
}

void display(int mult[][10], int rowFirst, int columnSecond)
{
int i, j;
printf("\nOutput Matrix:\n");
for(i = 0; i &lt; rowFirst; ++i)
{
for(j = 0; j &lt; columnSecond; ++j)
{
printf("%d  ", mult[i][j]);
if(j == columnSecond - 1)
printf("\n\n");
}
}
}
</k>
<r>Output</r>
<k>Enter rows and column for first matrix: 3
2
Enter rows and column for second matrix: 3
2
Error! column of first matrix not equal to row of second.

Enter rows and column for first matrix: 2
3
Enter rows and column for second matrix: 3
2

Enter elements of matrix 1:
Enter elements a11: 3
Enter elements a12: -2
Enter elements a13: 5
Enter elements a21: 3
Enter elements a22: 0
Enter elements a23: 4

Enter elements of matrix 2:
Enter elements b11: 2
Enter elements b12: 3
Enter elements b21: -9
Enter elements b22: 0
Enter elements b31: 0
Enter elements b32: 4

Output Matrix:
24  29

6  25</k>

<h2>Access Elements of an Array Using Pointer</h2>
This program declares the array of five element and the elements of that array are accessed using pointer.
<h3>Access Array Elements Using Pointers</h3>

<k>#include &lt;stdio.h>

int main()
{
   int data[5], i;
   printf("Enter elements: ");

   for(i = 0; i &lt; 5; ++i)
     scanf("%d", data + i);

   printf("You entered: \n");
   for(i = 0; i &lt; 5; ++i)
      printf("%d\n", *(data + i));

   return 0;
}
</k>

<r>Output</r>

<k>Enter elements: 1
2
3
5
4
You entered: 
1
2
3
5
4</k>

In this program, the elements are stored in the integer array data.

Then, using the for loop, each element in data is traversed and print using the pointer method.

Visit this page to learn about <a href="/c-programming/c-pointers-arrays">relationship between pointer and arrays</a>.

<h2>Swap Numbers in Cyclic Order Using Call by Reference</h2>
This program takes three integers from the user and swaps them in cyclic order using pointers.

Then, these variables are passed to the function <k>cyclicSwap()</k>. 
Instead of passing the actual variables, addresses of these variables are passed.

When these variables are swapped in cyclic order in the <k>cyclicSwap()</k> function, variables <mk>a</mk>, <mk>b</mk> and <mk>c</mk> in the <k>main</k> function are also automatically swapped.
<h3>Program to Swap Elements Using Call by Reference</h3>

<k>#include&lt;stdio.h>
void cyclicSwap(int *a,int *b,int *c);

int main()
{
    int a, b, c;

    printf("Enter a, b and c respectively: ");
    scanf("%d %d %d",&a,&b,&c);

    printf("Value before swapping:\n");
    printf("a = %d \nb = %d \nc = %d\n",a,b,c);

    cyclicSwap(&a, &b, &c);

    printf("Value after swapping:\n");
    printf("a = %d \nb = %d \nc = %d",a, b, c);

    return 0;
}
void cyclicSwap(int *a,int *b,int *c)
{

    int temp;

    // swapping in cyclic order
    temp = *b;
    *b = *a;
    *a = *c;
    *c = temp;
}</k>

<r>Output</r>
Enter a, b and c respectively: 1
2
3
Value before swapping:
a = 1 
b = 2 
c = 3
Value after swapping:
a = 3 
b = 1 
c = 2
Notice that we haven&#39;t returned any values from the <k>cyclicSwap()</k> function.

<h2>Find Largest Number Using Dynamic Memory Allocation</h2>
In this program, you'll learn to use calloc() function to allocate the memory dynamically to find the largest element.
<h3>Find Largest Element Using Dynamic Memory Allocation - calloc()</h3>

<k>#include &lt;stdio.h>
#include &lt;stdlib.h>

int main()
{
    int i, num;
    float *data;

    printf("Enter total number of elements(1 to 100): ");
    scanf("%d", &num);

    // Allocates the memory for &#39;num&#39; elements.
    data = (float*) calloc(num, sizeof(float));

    if(data == NULL)
    {
printf("Error!!! memory not allocated.");
exit(0);
    }

    printf("\n");

    // Stores the number entered by the user.
    for(i = 0; i &lt; num; ++i)
    {
       printf("Enter Number %d: ", i + 1);
       scanf("%f", data + i);
    }

    // Loop to store largest number at address data
    for(i = 1; i &lt; num; ++i)
    {
       // Change &lt; to > if you want to find the smallest number
       if(*data &lt; *(data + i))
   *data = *(data + i);
    }

    printf("Largest element = %.2f", *data);

    return 0;
}</k>

<r>Output</r>
<k>Enter total number of elements(1 to 100): 10

Enter Number 1: 2.34
Enter Number 2: 3.43
Enter Number 3: 6.78
Enter Number 4: 2.45
Enter Number 5: 7.64
Enter Number 6: 9.05
Enter Number 7: -3.45
Enter Number 8: -9.99
Enter Number 9: 5.67
Enter Number 10: 34.95
Largest element: 34.95
</k>

<h2>Find the Frequency of Characters in a String</h2>
This program asks user to enter a string and a character and checks how many times the character is repeated in the string.
<h3>Find the Frequency of Characters</h3>

<k>#include &lt;stdio.h>

int main()
{
   char str[1000], ch;
   int i, frequency = 0;

   printf("Enter a string: ");
   gets(str);

   printf("Enter a character to find the frequency: ");
   scanf("%c",&ch);

   for(i = 0; str[i] != &#39;\0&#39;; ++i)
   {
       if(ch == str[i])
   ++frequency;
   }

   printf("Frequency of %c = %d", ch, frequency);

   return 0;
}
</k>
<r>Output</r>
<k>Enter a string: This website is awesome.
Enter a character to find the frequency: e
Frequency of e = 4</k>
In this program, the string entered by the user is stored in variable <mk>str</mk>.

Then, the user is asked to enter the character whose frequency is to be found. 
This is stored in variable <mk>ch</mk>.

Now, using the for loop, each character in the string is checked for the entered character.

If, the character is found, the <mk>frequency</mk> is increased. 
If not, the loop continues.

Finally, the frequency is printed.

<h2>Count the Number of Vowels, Consonants and so on</h2>
This program counts the number of vowels, consonants, digits and white-spaces in a string which is entered by the user.
<h3>Program to count vowels, consonants etc.</h3>

<k>#include &lt;stdio.h>

int main()
{
    char line[150];
    int i, vowels, consonants, digits, spaces;

    vowels =  consonants = digits = spaces = 0;

    printf("Enter a line of string: ");
    scanf("%[^\n]", line);

    for(i=0; line[i]!=&#39;\0&#39;; ++i)
    {
if(line[i]==&#39;a&#39; || line[i]==&#39;e&#39; || line[i]==&#39;i&#39; ||
   line[i]==&#39;o&#39; || line[i]==&#39;u&#39; || line[i]==&#39;A&#39; ||
   line[i]==&#39;E&#39; || line[i]==&#39;I&#39; || line[i]==&#39;O&#39; ||
   line[i]==&#39;U&#39;)
{
++vowels;
}
else if((line[i]>=&#39;a&#39;& line[i]&lt;=&#39;z&#39;) || (line[i]>=&#39;A&#39;& line[i]&lt;=&#39;Z&#39;))
{
++consonants;
}
else if(line[i]>=&#39;0&#39; & line[i]&lt;=&#39;9&#39;)
{
++digits;
}
else if (line[i]==&#39; &#39;)
{
++spaces;
}
    }

    printf("Vowels: %d",vowels);
    printf("\nConsonants: %d",consonants);
    printf("\nDigits: %d",digits);
    printf("\nWhite spaces: %d", spaces);

    return 0;
}
</k>

<r>Output</r>

<k>Enter a line of string: adfslkj34 34lkj343 34lk
Vowels: 1
Consonants: 11
Digits: 9
White spaces: 2</k>

This program takes string input from the user and stores in variable <mk>line</mk>.

Initially, the variables <mk>vowels</mk>, <mk>consonants</mk>, <mk>digits</mk> and <mk>spaces</mk> are initialized to 0.

When the vowel character is found, <mk>vowel</mk> variable is incremented by 1. 
Similarly, <mk>consonants</mk>, <mk>digits</mk> and <mk>spaces</mk> are incremented when these characters are found.

Finally, the count is displayed on the screen.

<h2>Remove all Characters in a String Except Alphabet</h2>
This program takes a strings from user and removes all characters in that string except alphabets.
<h3>Remove Characters in String Except Alphabets</h3>

<k>#include&lt;stdio.h>

int main()
{
    char line[150];
    int i, j;
    printf("Enter a string: ");
    gets(line);

    for(i = 0; line[i] != &#39;\0&#39;; ++i)
    {
while (!( (line[i] >= &#39;a&#39; & line[i] &lt;= &#39;z&#39;) || (line[i] >= &#39;A&#39; & line[i] &lt;= &#39;Z&#39;) || line[i] == &#39;\0&#39;) )
{
for(j = i; line[j] != &#39;\0&#39;; ++j)
{
    line[j] = line[j+1];
}
line[j] = &#39;\0&#39;;
}
    }
    printf("Output String: ");
    puts(line);
    return 0;
}
</k>
<r>Output</r>
Enter a string: p2&#39;r-o@gram84iz./
Output String: programiz
This program takes a string from the user and stored in the variable <mk>line</mk>.

The, within the for loop, each character in the string is checked if it&#39;s an alphabet or not.

If any character inside a string is not a alphabet, all characters after it including the null character is shifted by 1 position to the left.

<h2>Find the Length of a String</h2>
In this article, you'll learn to find the length of a string without using strlen() function.
<h3>Calculate Length of String without Using strlen() Function</h3>

<k>#include &lt;stdio.h>
int main()
{
    char s[1000];
    int i;

    printf("Enter a string: ");
    scanf("%s", s);

    for(i = 0; s[i] != &#39;\0&#39;; ++i);

    printf("Length of string: %d", i);
    return 0;
}</k>

<r>Output</r>

<k>Enter a string: Programiz
Length of string: 9</k>

This program asks user to enter a string and computes the length of string manually using <a href="/c-programming/c-for-loop">for loop</a>.

<h2>Concatenate Two Strings</h2>
In this article, you'll learn to easily concatenate two strings without using standard library function strcat().
<h3>Concatenate Two Strings Without Using strcat()</h3>

<k>#include &lt;stdio.h>
int main()
{
    char s1[100], s2[100], i, j;

    printf("Enter first string: ");
    scanf("%s", s1);

    printf("Enter second string: ");
    scanf("%s", s2);

    // calculate the length of string s1
    // and store it in i
    for(i = 0; s1[i] != &#39;\0&#39;; ++i);

    for(j = 0; s2[j] != &#39;\0&#39;; ++j, ++i)
    {
s1[i] = s2[j];
    }

    s1[i] = &#39;\0&#39;;
    printf("After concatenation: %s", s1);

    return 0;
}</k>

<r>Output</r>

<k>Enter first string: lol
Enter second string: :)
After concatenation: lol:)</k>

<h2>Copy String Without Using strcpy()</h2>
In this article, you'll learn to copy string without using the library function strcpy().
<h3>Copy String Manually Without Using strcpy()</h3>

<k>#include &lt;stdio.h>
int main()
{
    char s1[100], s2[100], i;

    printf("Enter string s1: ");
    scanf("%s",s1);

    for(i = 0; s1[i] != &#39;\0&#39;; ++i)
    {
s2[i] = s1[i];
    }

    s2[i] = &#39;\0&#39;;
    printf("String s2: %s", s2);

    return 0;
}</k>

<r>Output</r>

<k>Enter String s1: programiz 
String s2: programiz</k>

This above program copies the content of string <mk>s1</mk> to string <mk>s2</mk> manually.

<h2>Sort Elements in Lexicographical Order (Dictionary Order)</h2>
This program sorts the 10 strings (entered by the user) in lexicographical order (dictionary order).
<h3>Program to Sort Strings in Dictionary Order</h3>

<k>#include&lt;stdio.h>
#include &lt;string.h>

int main()
{
    int i, j;
    char str[10][50], temp[50];

    printf("Enter 10 words:\n");

    for(i=0; i&lt;10; ++i)
scanf("%s[^\n]",str[i]);

    for(i=0; i&lt;9; ++i)
for(j=i+1; j&lt;10 ; ++j)
{
if(strcmp(str[i], str[j])>0)
{
    strcpy(temp, str[i]);
    strcpy(str[i], str[j]);
    strcpy(str[j], temp);
}
}

    printf("\nIn lexicographical order: \n");
    for(i=0; i&lt;10; ++i)
    {
puts(str[i]);
    }

    return 0;
}</k>
<r>Output</r>
<k>Enter 10 words:
C
C++
Java
PHP
Python
Perl
Ruby
R
JavaScript
PHP

In lexicographical order: 
C
C++
Java
JavaScript
PHP
PHP
Perl
Python
R
Ruby
</k>
To solve this program, a two-dimensional string <mk>str</mk> is created.

This string can hold maximum of 10 strings and each string can have maximum of 50 characters (including null character).

To compare two strings, <a href="/c-programming/library-function/string.h/strcmp">strcmp() function</a> is used. 
Also, we used <a href="/c-programming/library-function/string.h/strcpy">strcpy() function</a> to copy string to a temporary string <mk>temp</mk>.

<h2>How to use the typedef struct in C</h2>
<div id="structtoc"><a href="#structtopic-0" target="_self">Syntax</a><br><a href="#structtopic-1" target="_self">Examples</a><br><a href="#structtopic-2" target="_self">1. Variable declaration without using <k>typedef</k>:</a><br><a href="#structtopic-3" target="_self">2. Using the <k>typedef</k> keyword:</a><br><a href="#structtopic-4" target="_self">Method one:</a><br><a href="#structtopic-5" target="_self">Method two:</a><br></div></center><br>

The C language contains the <r><k>typedef</k> keyword</r> to allow users to provide alternative names for the primitive (e.g.,โ int) and user-definedโ (e.g struct) data types.

Remember, this keyword adds a new name for some existing data type but does not create a new type.

<h3 id="structtopic-0">Syntax</h3>
Using <k>typedef struct</k> results in a  cleaner, more readable code, and saves the programmer keystrokesโ. However, it also leads to a more cluttered global namespace which can be problematic for large programs.

<h3 id="structtopic-1">Examples</h3>
The following code snippets illustrate how to use the <k>typedef struct</k>.

<h3 id="structtopic-2">1. Variable declaration without using <k>typedef</k>:</h3>

#include&lt;stdio.h>

struct Point{
  int x;
  int y;
};
int main() {
    struct Point p1;
    p1.x = 1;
    p1.y = 3;
    printf("%d \n", p1.x);
    printf("%d \n", p1.y);
    return 0;
}

<h3 id="structtopic-3">2. Using the <k>typedef</k> keyword:</h3>

Note that there is no longer a need to type <k>struct</k> again and again with every declaration of the variable of this type.

<h3 id="structtopic-4">Method one:</h3>
#include&lt;stdio.h>

struct Point{
  int x;
  int y;
};
typedef struct Point Point;
int main() {
    Point p1;
    p1.x = 1;
    p1.y = 3;
    printf("%d \n", p1.x);
    printf("%d \n", p1.y);
    return 0;
}

<h3 id="structtopic-5">Method two:</h3>

#include&lt;stdio.h>

typedef struct Point{
  int x;
  int y;
} Point;
int main() {
    Point p1;
    p1.x = 1;
    p1.y = 3;
    printf("%d \n", p1.x);
    printf("%d \n", p1.y);
    return 0;
}

<h2>Store Information of a Student Using Structure</h2>
This program stores the information (name, roll and marks) of a student and displays it on the screen using structures.

This structure has three members: <mk>name</mk> (string), <mk>roll</mk> (integer) and <mk>marks</mk> (float).

Then, a structure variable <mk>s</mk> is created to store information and display it on the screen.
<h3>Store Information and Display it Using Structure</h3>

<k>#include &lt;stdio.h>
struct student
{
    char name[50];
    int roll;
    float marks;
} s;

int main()
{
    printf("Enter information:\n");

    printf("Enter name: ");
    scanf("%s", s.name);

    printf("Enter roll number: ");
    scanf("%d", &s.roll);

    printf("Enter marks: ");
    scanf("%f", &s.marks);

    printf("Displaying Information:\n");

    printf("Name: ");
    puts(s.name);

    printf("Roll number: %d\n",s.roll);

    printf("Marks: %.1f\n", s.marks);

    return 0;
}</k>

<r>Output</r>

<k>Enter information:
Enter name: Jack
Enter roll number: 23
Enter marks: 34.5
Displaying Information:
Name: Jack
Roll number: 23
Marks: 34.5</k>

<h2>Add Two Distances (in inch-feet) System Using Structures</h2>
This program takes two distances (in inch-feet system), adds them and displays the result on the screen.
<h3>Program to add two distances in inch-feet system</h3>

<k>#include &lt;stdio.h>

struct Distance
{
    int feet;
    float inch;
} d1, d2, sumOfDistances;

int main()
{
    printf("Enter information for 1st distance\n");
    printf("Enter feet: ");
    scanf("%d", &d1.feet);
    printf("Enter inch: ");
    scanf("%f", &d1.inch);

    printf("\nEnter information for 2nd distance\n");
    printf("Enter feet: ");
    scanf("%d", &d2.feet);
    printf("Enter inch: ");
    scanf("%f", &d2.inch);

    sumOfDistances.feet = d1.feet+d2.feet;
    sumOfDistances.inch = d1.inch+d2.inch;

    // If inch is greater than 12, changing it to feet.

    if (sumOfDistances.inch>12.0)
    {
sumOfDistances.inch = sumOfDistances.inch-12.0;
++sumOfDistances.feet;
    }

    printf("\nSum of distances = %d\&#39;-%.1f\",sumOfDistances.feet, sumOfDistances.inch);
    return 0;
}
</k>
<r>Output</r>
<k>Enter information for 1st distance
Enter feet: 23
Enter inch: 8.6

Enter information for 2nd distance
Enter feet: 34
Enter inch: 2.4

Sum of distances = 57&#39;-11.0"
</k>
In this program, a structure <k>Distance</k> is defined. 
The structure has two members <k>inch</k> (a float) and <k>feet</k> (an integer).

Two variables (<mk>d1</mk> and <mk>d2</mk>) are created which stores two distances (in inch and feet). 
Then, the sum of two distances is stored in <mk>sumOfDistances</mk> structure and displayed on the screen.

<h2>Add Two Complex Numbers by Passing Structure to a Function</h2>
This program takes two complex numbers as structures and adds them with the use of functions.
<h3>Add Two Complex Numbers</h3>

<k>#include &lt;stdio.h>
typedef struct complex
{
    float real;
    float imag;
} complex;
complex add(complex n1,complex n2);

int main()
{
    complex n1, n2, temp;

    printf("For 1st complex number \n");
    printf("Enter real and imaginary part respectively:\n");
    scanf("%f %f", &n1.real, &n1.imag);

    printf("\nFor 2nd complex number \n");
    printf("Enter real and imaginary part respectively:\n");
    scanf("%f %f", &n2.real, &n2.imag);

    temp = add(n1, n2);
    printf("Sum = %.1f + %.1fi", temp.real, temp.imag);

    return 0;
}

complex add(complex n1, complex n2)
{
      complex temp;

      temp.real = n1.real + n2.real;
      temp.imag = n1.imag + n2.imag;

      return(temp);
}</k>
<r>Output</r>
<k>For 1st complex number
Enter real and imaginary part respectively: 2.3
4.5

For 2nd complex number
Enter real and imaginary part respectively: 3.4
5
Sum = 5.7 + 9.5i</k>
In this program, structures <mk>n1</mk> and <mk>n2</mk> are passed as an argument of function <k>add()</k>.

This function computes the sum and returns the structure variable <mk>temp</mk> to the <k>main()</k> function.

<h2>Calculate Difference Between Two Time Periods</h2>
In this example, you'll learn to calculate the difference between two time periods using user defined - differenceBetweenTimePeriod function.
<h3>Calculate Difference Between Two Time Periods</h3>

<k>#include &lt;stdio.h>
struct TIME
{
  int seconds;
  int minutes;
  int hours;
};
void differenceBetweenTimePeriod(struct TIME t1, struct TIME t2, struct TIME *diff);

int main()
{
    struct TIME startTime, stopTime, diff;

    printf("Enter start time: \n");
    printf("Enter hours, minutes and seconds respectively: ");
    scanf("%d %d %d", &startTime.hours, &startTime.minutes, &startTime.seconds);

    printf("Enter stop time: \n");
    printf("Enter hours, minutes and seconds respectively: ");
    scanf("%d %d %d", &stopTime.hours, &stopTime.minutes, &stopTime.seconds);

    // Calculate the difference between the start and stop time period.
    differenceBetweenTimePeriod(startTime, stopTime, &diff);

    printf("\nTIME DIFFERENCE: %d:%d:%d - ", startTime.hours, startTime.minutes, startTime.seconds);
    printf("%d:%d:%d ", stopTime.hours, stopTime.minutes, stopTime.seconds);
    printf("= %d:%d:%d\n", diff.hours, diff.minutes, diff.seconds);

    return 0;
}

void differenceBetweenTimePeriod(struct TIME start, struct TIME stop, struct TIME *diff)
{
    if(stop.seconds > start.seconds){
--start.minutes;
start.seconds += 60;
    }

    diff->seconds = start.seconds - stop.seconds;
    if(stop.minutes > start.minutes){
--start.hours;
start.minutes += 60;
    }

    diff->minutes = start.minutes - stop.minutes;
    diff->hours = start.hours - stop.hours;
}</k>
<r>Output</r>
<k>Enter start time:
Enter hours, minutes and seconds respectively: 12
34
55
Enter stop time:
Enter hours, minutes and seconds respectively:8
12
15

TIME DIFFERENCE: 12:34:55 - 8:12:15 = 4:22:40
</k>
In this program, user is asked to enter two time periods and these two periods are stored in structure variables <mk>startTime</mk> and <mk>stopTime</mk> respectively.

Then, the function <k>differenceBetweenTimePeriod</k> calculates the difference between the time periods and the result is displayed in <k>main()</k> function without returning it (Using call by reference technique).

<h2>Store Information of Students Using Structure</h2>
This program stores the information (name, roll and marks) of 10 students using structures.

This structure has three members: <mk>name</mk> (string), <mk>roll</mk> (integer) and <mk>marks</mk> (float).

Then, we created a structure array of size 10 to store information of 10 students.

Using for loop, the program takes the information of 10 students from the user and displays it on the screen.
<h3>Store Information in Structure and Display it</h3>

<k>#include &lt;stdio.h>
struct student
{
    char name[50];
    int roll;
    float marks;
} s[10];

int main()
{
    int i;

    printf("Enter information of students:\n");

    // storing information
    for(i=0; i&lt;10; ++i)
    {
s[i].roll = i+1;

printf("\nFor roll number%d,\n",s[i].roll);

printf("Enter name: ");
scanf("%s",s[i].name);

printf("Enter marks: ");
scanf("%f",&s[i].marks);

printf("\n");
    }

    printf("Displaying Information:\n\n");
    // displaying information
    for(i=0; i&lt;10; ++i)
    {
printf("\nRoll number: %d\n",i+1);
printf("Name: ");
puts(s[i].name);
printf("Marks: %.1f",s[i].marks);
printf("\n");
    }
    return 0;
}
</k>

<r>Output</r>
<k>Enter information of students: 

For roll number1,
Enter name: Tom
Enter marks: 98

For roll number2,
Enter name: Jerry
Enter marks: 89
.
.
.
Displaying Information:

Roll number: 1
Name: Tom
Marks: 98
.
.
.
</k>

<h2>Store Information Using Structures with Dynamically Memory Allocation</h2>
In this example, you'll learn to store information using structures by allocation dynamic memory using malloc().
<h3>Demonstrate the Dynamic Memory Allocation for Structure</h3>

<k>#include &lt;stdio.h>
#include&lt;stdlib.h>

struct course
{
   int marks;
   char subject[30];
};

int main()
{
   struct course *ptr;
   int i, noOfRecords;
   printf("Enter number of records: ");
   scanf("%d", &noOfRecords);

   // Allocates the memory for noOfRecords structures with pointer ptr pointing to the base address.
   ptr = (struct course*) malloc (noOfRecords * sizeof(struct course));

   for(i = 0; i &lt; noOfRecords; ++i)
   {
       printf("Enter name of the subject and marks respectively:\n");
       scanf("%s %d", &(ptr+i)->subject, &(ptr+i)->marks);
   }

   printf("Displaying Information:\n");

   for(i = 0; i &lt; noOfRecords ; ++i)
       printf("%s\t%d\n", (ptr+i)->subject, (ptr+i)->marks);

   return 0;
}</k>

<r>Output</r>

<k>Enter number of records: 2
Enter name of the subject and marks respectively:
Programming
22
Enter name of the subject and marks respectively:
Structure
33

Displaying Information:
Programming      22
Structure33</k>

<h2>Write a Sentence to a File</h2>
In this example, you'll learn to write a sentence to a file using fprintf() statement.

<k>#include &lt;stdio.h>
#include &lt;stdlib.h>  /* For exit() function */
int main()
{
   char sentence[1000];
   FILE *fptr;

   fptr = fopen("program.txt", "w");
   if(fptr == NULL)
   {
      printf("Error!");
      exit(1);
   }
   
   printf("Enter a sentence:\n");
   gets(sentence);

   fprintf(fptr,"%s", sentence);
   fclose(fptr);

   return 0;
}</k>
<r>Output</r>
<k>Enter sentence: 
I am awesome and so are files.</k>
After termination of this program, you can see a text file program.txt created in the same location where this program is located. 

If you open and see the content, you can see the sentence: <k>I am awesome and so are files.</k>

In this program, a file is opened using opening mode "w".

In this mode, if the file exists, its contents are overwritten and if the file does not exist, it will be created.

Then, user is asked to enter a sentence. 
This sentence will be stored in file program.txt using <k>fprintf()</k> function.

<h2>Read a Line From a File and Display it</h2>
This program reads text from a file and stores it in a string until enter 'newline' character is encountered. 
<h3>Program to read text from a file</h3>

<k>
#include &lt;stdio.h>
#include &lt;stdlib.h> // For exit() function
int main()
{
    char c[1000];
    FILE *fptr;

    if ((fptr = fopen("program.txt", "r")) == NULL)
    {
printf("Error! opening file");
// Program exits if file pointer returns NULL.
exit(1); 
    }

    // reads text until newline 
    fscanf(fptr,"%[^\n]", c);

    printf("Data from the file:\n%s", c);
    fclose(fptr);
    return 0;
}</k>
If the file <k>program.txt</k> is not found, this program prints error message.

If the file is found, the program saves the content of the file to a string <mk>c</mk> until &#39;\n&#39; newline is encountered.

Suppose, the <k>program.txt</k> file contains following text.

C programming is awesome.
I love C programming.
How are you doing?
The output of the program will be:

<k>Data from the file: C programming is awesome.</k>

<h2>Display its own Source Code as Output</h2>
In this example, you'll learn to display source of the program using __FILE__ macro.

A predefined macro __FILE__ contains the location of a C programming file, it is working on. 
For example:

#include &lt;stdio.h>
int main(){
   printf("%s",__FILE__);
}

The output of this program is the location of this C programming file.
<h3>C program to display its own source code using __FILE__</h3>

<k>#include &lt;stdio.h>
int main() {
    FILE *fp;
    int c;
    fp = fopen(__FILE__,"r");
    do {
 c = getc(fp);
 putchar(c);
    }
    while(c != EOF);
    fclose(fp);
    return 0;
}</k>

This program displays the content of this particular C programming file(source code) because __FILE__ contains the location of this C programming file in a string.

<h2>Create Pyramid and Pattern</h2>
Examples to print half pyramid, pyramid, inverted pyramid, Pascal's Triangle and Floyd's triangle in C Programming using control statements.

<thead>
<tr>
<th scope="col">List of Source Code</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#triangle">Code to print triangles using *, digits and characters</a></td>
</tr>
<tr>
<td><a href="#inverted_triangle">Code to print inverted triangles using * and digits</a></td>
</tr>
<tr>
<td><a href="#pyramid">Code to print full pyramids</a></td>
</tr>
<tr>
<td><a href="#pascal_triangle">Code to print Pascal&#39;s triangle</a></td>
</tr>
<tr>
<td><a href="#floyd_triangle">Code to print Floyd&#39;s triangle</a></td>
</tr>
</tbody>
</table>
<h3><a name="triangle"></a> Programs to print triangles using *, numbers and characters</h3>
<hr />
<h3>Example 1: Program to print half pyramid using *</h3>

<k>*
* *
* * *
* * * *
* * * * *</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("* ");
}
printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 2: Program to print half pyramid a using numbers</h3>

<k>1
1 2
1 2 3
1 2 3 4
1 2 3 4 5</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("%d ",j);
}
printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 3: Program to print half pyramid using alphabets</h3>

<k>A
B B
C C C
D D D D
E E E E E</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j;
    char input, alphabet = &#39;A&#39;;

    printf("Enter the uppercase character you want to print in last row: ");
    scanf("%c",&input);

    for(i=1; i &lt;= (input-&#39;A&#39;+1); ++i)
    {
for(j=1;j&lt;=i;++j)
{
printf("%c", alphabet);
}
++alphabet;

printf("\n");
    }
    return 0;
}</k>
<h3><a name="inverted_triangle"></a>Programs to print inverted half pyramid using * and numbers</h3>
<hr />
<h3>Example 4: Inverted half pyramid using *</h3>

<k>* * * * *
* * * *
* * * 
* *
*</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("* ");
}
printf("\n");
    }
    return 0;
}</k>

<hr />
<h3>Example 5: Inverted half pyramid using numbers</h3>

<k>1 2 3 4 5
1 2 3 4 
1 2 3
1 2
1</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, j, rows;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(j=1; j&lt;=i; ++j)
{
printf("%d ",j);
}
printf("\n");
    }

    return 0;
}</k>
<h3><a name="pyramid"></a> Programs to display pyramid and inverted pyramid using * and digits</h3>
<hr />
<h3>Example 6: Program to print full pyramid using *</h3>

<k>*
      * * *
    * * * * *
  * * * * * * *
* * * * * * * * *</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, space, rows, k=0;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i, k=0)
    {
for(space=1; space&lt;=rows-i; ++space)
{
printf("  ");
}

while(k != 2*i-1)
{
printf("* ");
++k;
}

printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 7: Program to print pyramid using numbers</h3>

<k>
1
      2 3 2
    3 4 5 4 3
  4 5 6 7 6 5 4
5 6 7 8 9 8 7 6 5</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int i, space, rows, k=0, count = 0, count1 = 0;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i&lt;=rows; ++i)
    {
for(space=1; space &lt;= rows-i; ++space)
{
printf("  ");
++count;
}

while(k != 2*i-1)
{
if (count &lt;= rows-1)
{
    printf("%d ", i+k);
    ++count;
}
else
{
    ++count1;
    printf("%d ", (i+k-2*count1));
}
++k;
}
count1 = count = k = 0;

printf("\n");
    }
    return 0;
}
</k>

<hr />
<h3>Example 8: Inverted full pyramid using *</h3>

<k>
* * * * * * * * *
  * * * * * * *
    * * * * *
      * * *
*</k>

<b>Source Code</b>

<k>#include&lt;stdio.h>
int main()
{
    int rows, i, j, space;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=rows; i>=1; --i)
    {
for(space=0; space &lt; rows-i; ++space)
printf("  ");

for(j=i; j &lt;= 2*i-1; ++j)
printf("* ");

for(j=0; j &lt; i-1; ++j)
printf("* ");

printf("\n");
    }

    return 0;
}</k>

<hr />
<h3><a name="pascal_triangle"></a>Example 9: Print Pascal&#39;s triangle</h3>

<k>
   1
 1   1
       1   2   1
     1   3   3    1
   1  4    6   4   1
 1  5   10   10  5   1 </k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int rows, coef = 1, space, i, j;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=0; i&lt;rows; i++)
    {
for(space=1; space &lt;= rows-i; space++)
printf("  ");

for(j=0; j &lt;= i; j++)
{
if (j==0 || i==0)
    coef = 1;
else
    coef = coef*(i-j+1)/j;

printf("%4d", coef);
}
printf("\n");
    }

    return 0;
}</k>

<hr />
<h3><a name="floyd_triangle"></a>Example 10: Print Floyd&#39;s Triangle.</h3>

<k>1
2 3
4 5 6
7 8 9 10</k>

<b>Source Code</b>

<k>#include &lt;stdio.h>
int main()
{
    int rows, i, j, number= 1;

    printf("Enter number of rows: ");
    scanf("%d",&rows);

    for(i=1; i &lt;= rows; i++)
    {
for(j=1; j &lt;= i; ++j)
{
printf("%d ", number);
++number;
}

printf("\n");
    }

    return 0;
}</k>

<h2>C Library - &lt;assert.h></h2>
The <b>assert.h</b> header file of the C Standard Library provides a macro called <b>assert</b> which can be used to verify assumptions made by the program and print a diagnostic message if this assumption is false.
The defined macro <b>assert</b> refers  to another macro <b>NDEBUG</b> which is not a part of &lt;assert.h>. If NDEBUG is defined as a macro name in the source file, at the point where &lt;assert.h> is included, the <b>assert</b> macro is defined as follows -
#define assert(ignore) ((void)0)
<h3>Library Macros</h3>
Following is the only function defined in the header assert.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_assert.htm">void assert(int expression)</a>
This is actually a macro and not a function, which can be used to add diagnostics in your C program.
<h2>C Library - &lt;ctype.h></h2>
The <b>ctype.h</b> header file of the C Standard Library declares several functions that are useful for testing and mapping characters.
All the functions accepts <b>int</b> as a parameter, whose value must be EOF or representable as an unsigned char.
All the functions return non-zero (true) if the argument c satisfies the condition described, and zero(false) if not.
<h3>Library Functions</h3>
Following are the functions defined in the header ctype.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isalnum.htm">int isalnum(int c)</a> 
This function checks whether the passed character is alphanumeric.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isalpha.htm">int isalpha(int c)</a>
This function checks whether the passed character is alphabetic.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_iscntrl.htm">int iscntrl(int c)</a>
This function checks whether the passed character is control character.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isdigit.htm">int isdigit(int c)</a>
This function checks whether the passed character is  decimal digit.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isgraph.htm">int isgraph(int c)</a>
This function checks whether the passed character has graphical representation using locale.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_islower.htm">int islower(int c)</a>
This function checks whether the passed character is  lowercase letter.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isprint.htm">int isprint(int c)</a>
This function checks whether the passed character is printable.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ispunct.htm">int ispunct(int c)</a>
This function checks whether the passed character is a punctuation character.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isspace.htm">int isspace(int c)</a>
This function checks whether the passed character is white-space.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isupper.htm">int isupper(int c)</a>
This function checks whether the passed character is an uppercase letter.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_isxdigit.htm">int isxdigit(int c)</a>
This function checks whether the passed character is a hexadecimal digit.
The library also contains two conversion functions that accepts and returns an "int".
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_tolower.htm">int tolower(int c)</a>
This function converts uppercase letters to lowercase.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_toupper.htm">int toupper(int c)</a>
This function converts lowercase letters to uppercase.
<h3>Character Classes</h3>
Character Class & Description
<b>Digits</b>
This is a set of whole numbers { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }.
<b>Hexadecimal digits</b>
This is the set of { 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f }.
<b>Lowercase letters</b>
This is a set of lowercase letters { a b c d e f g h i j k l m n o p q r s t u v w x y z }.
<b>Uppercase letters</b>
This is a set of uppercase letters {A B C D E F G H I J K L M N O P Q R S T U V W X Y Z }.
<b>Letters</b>
This is a set of lowercase and uppercase letters.
<b>Alphanumeric characters</b>
This is a set of Digits, Lowercase letters and Uppercase letters.
<b>Punctuation characters</b>
This is a set of ! " # $ % & ' ( ) * + , - . / : ; &lt; = > ? @ [ \ ] ^ _ ` { | } ~
<b>Graphical characters</b>
This is a set of Alphanumeric characters and Punctuation characters.
<b>Space characters</b>
This is a set of  tab, newline, vertical tab, form feed, carriage return, and space.
<b>Printable characters</b>
This is a set of Alphanumeric characters, Punctuation characters and Space characters.
<b>Control characters</b>
In ASCII, these characters have octal codes 000 through 037, and 177 (DEL).
<b>Blank characters</b>
These are spaces and tabs.
<b>Alphabetic characters</b>
This is a set of Lowercase letters and Uppercase letters.
<h2>C Library - &lt;errno.h></h2>
The <b>errno.h</b> header file of the C Standard Library defines the integer variable <b>errno</b>, which is set by system calls and some library functions in the event of an error to indicate what went wrong. This macro expands to a modifiable lvalue of type int, therefore it can be both read and modified by a program.
The <b>errno</b> is set to zero at program startup. Certain functions of the standard C library modify its value to other than zero to signal some types of error. You can also modify its value or reset to zero at your convenience.
The <b>errno.h</b> header file also defines a list of macros indicating different error codes, which will expand to integer constant expressions with type <b>int</b>.
<h3>Library Macros</h3>
Following are the macros defined in the header errno.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_errno.htm">extern int errno</a>
This is the macro set by system calls and some library functions in the event of an error to indicate what went wrong.
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_edom.htm">EDOM Domain Error</a>
This macro represents a domain error, which occurs if an input argument is outside the domain, over which the mathematical function is defined and errno is set to EDOM.
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_erange.htm">ERANGE Range Error</a>
This macro represents a range error, which occurs if an input argument is outside the range, over which the mathematical function is defined and errno is set to ERANGE.
<h2>C Library - &lt;float.h></h2>
The <b>float.h</b> header file of the C Standard Library contains a set of various platform-dependent constants related to floating point values. These constants are proposed by ANSI C. They allow making more portable programs. Before checking all the constants, it is good to understand that floating-point number is composed of following four elements -
Component & Component Description
<b>S</b>
sign ( +/- )
<b>b</b>
base or radix of the exponent representation, 2 for binary, 10 for decimal, 16 for hexadecimal, and so on...
<b>e</b>
exponent, an integer between a minimum <b>e<sub>min</sub></b> and a maximum <b>e<sub>max</sub></b>.
<b>p</b>
precision, the number of base-b digits in the significand.
Based on the above 4 components, a floating point will have its value as follows -
floating-point = ( S ) p x b<sup>e</sup>
or
floating-point = (+/-) precision x base<sup>exponent</sup>
<h3>Library Macros</h3>
The following values are implementation-specific and defined with the #define directive, but these values may not be any lower than what is given here. Note that in all instances FLT refers to type <b>float</b>, DBL refers to <b>double</b>, and LDBL refers to <b>long double</b>.
<b>FLT_ROUNDS</b>
Defines the rounding mode for floating point addition and it can have any of the following values -
-1 - indeterminable
0 - towards zero
1 - to nearest
2 - towards positive infinity
3 - towards negative infinity
<b>FLT_RADIX 2</b>
This defines the base radix representation of the exponent. A base-2 is binary, base-10 is the normal decimal representation, base-16 is Hex.
<b>FLT_MANT_DIG</b>
<b>DBL_MANT_DIG</b>
<b>LDBL_MANT_DIG</b>
These macros define the number of digits in the number (in the FLT_RADIX base).
<b>FLT_DIG 6</b>
<b>DBL_DIG 10</b>
<b>LDBL_DIG 10</b>
These macros define the maximum number decimal digits (base-10) that can be represented without change after rounding.
<b>FLT_MIN_EXP</b>
<b>DBL_MIN_EXP</b>
<b>LDBL_MIN_EXP</b>
These macros define the minimum negative integer value for an exponent in base FLT_RADIX.
<b>FLT_MIN_10_EXP -37</b>
<b>DBL_MIN_10_EXP -37</b>
<b>LDBL_MIN_10_EXP -37</b>
These macros define the minimum negative integer value for an exponent in base 10.
<b>FLT_MAX_EXP</b>
<b>DBL_MAX_EXP</b>
<b>LDBL_MAX_EXP</b>
These macros define the maximum integer value for an exponent in base FLT_RADIX.
<b>FLT_MAX_10_EXP +37</b>
<b>DBL_MAX_10_EXP +37</b>
<b>LDBL_MAX_10_EXP +37</b>
These macros define the maximum integer value for an exponent in base 10.
<b>FLT_MAX 1E+37</b>
<b>DBL_MAX 1E+37</b>
<b>LDBL_MAX 1E+37</b>
These macros define the maximum finite floating-point value.
<b>FLT_EPSILON 1E-5</b>
<b>DBL_EPSILON 1E-9</b>
<b>LDBL_EPSILON 1E-9</b>
These macros define the least significant digit representable.
<b>FLT_MIN 1E-37</b>
<b>DBL_MIN 1E-37</b>
<b>LDBL_MIN 1E-37</b>
These macros define the minimum floating-point values.
<h3>Example</h3>
The following example shows the usage of few of the constants defined in float.h file.
<a href="http://tpcg.io/FK5Hwy" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>
#include &lt;stdio.h>
#include &lt;float.h>
int main () {
   printf("The maximum value of float = %.10e\n", FLT_MAX);
   printf("The minimum value of float = %.10e\n", FLT_MIN);
   printf("The number of digits in the number = %.10e\n", FLT_MANT_DIG);
}
Let us compile and run the above program that will produce the following result -
The maximum value of float = 3.4028234664e+38
The minimum value of float = 1.1754943508e-38
The number of digits in the number = 7.2996655210e-312
<h2>C Library - &lt;limits.h></h2>
The <b>limits.h</b> header determines various properties of the various variable types. The macros defined in this header, limits the values of various variable types like char, int and long.
These limits specify that a variable cannot store any value beyond these limits, for example an unsigned character can store up to a maximum value of 255.
<h3>Library Macros</h3>
The following values are implementation-specific and defined with the #define directive, but these values may not be any lower than what is given here.
Macro
Value
Description
CHAR_BIT
Defines the number of bits in a byte.
SCHAR_MIN
-128
Defines the minimum value for a signed char.
SCHAR_MAX
+127
Defines the maximum value for a signed char.
UCHAR_MAX
Defines the maximum value for an unsigned char.
CHAR_MIN
-128
Defines the minimum value for type char and its value will be equal to SCHAR_MIN if char represents negative values, otherwise zero.
CHAR_MAX
+127
Defines the value for type char and its value will be equal to SCHAR_MAX if char represents negative values, otherwise UCHAR_MAX.
MB_LEN_MAX
Defines the maximum number of bytes in a multi-byte character.
SHRT_MIN
-32768
Defines the minimum value for a short int.
SHRT_MAX
+32767
Defines the maximum value for a short int.
USHRT_MAX
Defines the maximum value for an unsigned short int.
INT_MIN
-2147483648
Defines the minimum value for an int.
INT_MAX
+2147483647
Defines the maximum value for an int.
UINT_MAX
Defines the maximum value for an unsigned int.
LONG_MIN
-9223372036854775808
Defines the minimum value for a long int.
LONG_MAX
+9223372036854775807
Defines the maximum value for a long int.
ULONG_MAX
Defines the maximum value for an unsigned long int.
<h3>Example</h3>
The following example shows the usage of few of the constants defined in <b>limits.h</b> file.
<a href="http://tpcg.io/MYWu7P" target="_blank" rel="nofollow" class="demo"><i class="fa-external-link"></i> Live Demo</a>
#include &lt;stdio.h>
#include &lt;limits.h>
int main() {
   printf("The number of bits in a byte %d\n", CHAR_BIT);
   printf("The minimum value of SIGNED CHAR = %d\n", SCHAR_MIN);
   printf("The maximum value of SIGNED CHAR = %d\n", SCHAR_MAX);
   printf("The maximum value of UNSIGNED CHAR = %d\n", UCHAR_MAX);
   printf("The minimum value of SHORT INT = %d\n", SHRT_MIN);
   printf("The maximum value of SHORT INT = %d\n", SHRT_MAX); 
   printf("The minimum value of INT = %d\n", INT_MIN);
   printf("The maximum value of INT = %d\n", INT_MAX);
   printf("The minimum value of CHAR = %d\n", CHAR_MIN);
   printf("The maximum value of CHAR = %d\n", CHAR_MAX);
   printf("The minimum value of LONG = %ld\n", LONG_MIN);
   printf("The maximum value of LONG = %ld\n", LONG_MAX);
  
   return(0);
}
Let us compile and run the above program that will produce the following result -
The number of bits in a byte 8
The minimum value of SIGNED CHAR = -128
The maximum value of SIGNED CHAR = 127
The maximum value of UNSIGNED CHAR = 255
The minimum value of SHORT INT = -32768
The maximum value of SHORT INT = 32767
The minimum value of INT = -2147483648
The maximum value of INT = 2147483647
The minimum value of CHAR = -128
The maximum value of CHAR = 127
The minimum value of LONG = -9223372036854775808
The maximum value of LONG = 9223372036854775807
<h2>C Library - &lt;locale.h></h2>
The <b>locale.h</b> header defines the location specific settings, such as date formats and currency symbols. You will find several macros defined along with an important structure <b>struct lconv</b> and two important functions listed below.
<h3>Library Macros</h3>
Following are the macros defined in the header and these macros will be used in two functions listed below -
<b>LC_ALL</b>
Sets everything.
<b>LC_COLLATE</b>
Affects strcoll and strxfrm functions.
<b>LC_CTYPE</b>
Affects all character functions.
<b>LC_MONETARY</b>
Affects the monetary information provided by localeconv function.
<b>LC_NUMERIC</b>
Affects decimal-point formatting and the information provided by localeconv function.
<b>LC_TIME</b>
Affects the strftime function.
<h3>Library Functions</h3>
Following are the functions defined in the header locale.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_setlocale.htm">char *setlocale(int category, const char *locale)</a>
Sets or reads location dependent information.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_localeconv.htm">struct lconv *localeconv(void)</a>
Sets or reads location dependent information.
<h3>Library Structure</h3>
typedef struct {
   char *decimal_point;
   char *thousands_sep;
   char *grouping;	
   char *int_curr_symbol;
   char *currency_symbol;
   char *mon_decimal_point;
   char *mon_thousands_sep;
   char *mon_grouping;
   char *positive_sign;
   char *negative_sign;
   char int_frac_digits;
   char frac_digits;
   char p_cs_precedes;
   char p_sep_by_space;
   char n_cs_precedes;
   char n_sep_by_space;
   char p_sign_posn;
   char n_sign_posn;
} lconv
Following is the description of each of the fields -
Field & Description
<b>decimal_point</b>
Decimal point character used for non-monetary values.
<b>thousands_sep</b>
Thousands place separator character used for non-monetary values.
<b>grouping</b>
A string that indicates the size of each group of digits in non-monetary quantities. Each character represents an integer value, which designates the number of digits in the current group. A value of 0 means that the previous value is to be used for the rest of the groups.
<b>int_curr_symbol</b>
It is a string of the international currency symbols used. The first three characters are those specified by ISO 4217:1987 and the fourth is the character, which separates the currency symbol from the monetary quantity.
<b>currency_symbol</b>
The local symbol used for currency.
<b>mon_decimal_point</b>
The decimal point character used for monetary values.
<b>mon_thousands_sep</b>
The thousands place grouping character used for monetary values.
<b>mon_grouping</b>
A string whose elements defines the size of the grouping of digits in monetary values. Each character represents an integer value which designates the number of digits in the current group. A value of 0 means that the previous value is to be used for the rest of the groups.
<b>positive_sign</b>
The character used for positive monetary values.
<b>negative_sign</b>
The character used for negative monetary values.
<b>int_frac_digits</b>
Number of digits to show after the decimal point in international monetary values.
<b>frac_digits</b>
Number of digits to show after the decimal point in monetary values.
<b>p_cs_precedes</b>
If equals to 1, then the currency_symbol appears before a positive monetary value. If equals to 0, then the currency_symbol appears after a positive monetary value.
<b>p_sep_by_space</b>
If equals to 1, then the currency_symbol is separated by a space from a positive monetary value. If equals to 0, then there is no space between the currency_symbol and a positive monetary value.
<b>n_cs_precedes</b>
If equals to 1, then the currency_symbol precedes a negative monetary value. If equals to 0, then the currency_symbol succeeds a negative monetary value.
<b>n_sep_by_space</b>
If equals to 1, then the currency_symbol is separated by a space from a negative monetary value. If equals to 0, then there is no space between the currency_symbol and a negative monetary value.
<b>p_sign_posn</b>
Represents the position of the positive_sign in a positive monetary value.
<b>n_sign_posn</b>
Represents the position of the negative_sign in a negative monetary value.
The following values are used for <b>p_sign_posn</b> and <b>n_sign_posn</b> -
Value
Description
Parentheses encapsulates the value and the currency_symbol.
The sign precedes the value and currency_symbol.
The sign succeeds the value and currency_symbol.
The sign immediately precedes the value and currency_symbol.
The sign immediately succeeds the value and currency_symbol.
<h2>C Library - &lt;math.h></h2>
The <b>math.h</b> header defines various mathematical functions and one macro. All the functions available in this library take <b>double</b> as an argument and return <b>double</b> as the result.
<h3>Library Macros</h3>
There is only one macro defined in this library -
<b>HUGE_VAL</b>
This macro is used when the result of a function may not be representable as a floating point number. If magnitude of the correct result is too large to be represented, the function sets errno to ERANGE to indicate a range error, and returns a particular, very large value named by the macro HUGE_VAL or its negation (- HUGE_VAL).
If the magnitude of the result is too small, a value of zero is returned instead. In this case, errno might or might not be set to ERANGE.
<h3>Library Functions</h3>
Following are the functions defined in the header math.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_acos.htm">double acos(double x)</a>
Returns the arc cosine of x in radians.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_asin.htm">double asin(double x)</a>
Returns the arc sine of x in radians.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atan.htm">double atan(double x)</a>
Returns the arc tangent of x in radians.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atan2.htm">double atan2(double y, double x)</a>
Returns the arc tangent in radians of y/x based on the signs of both values to determine the correct quadrant.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_cos.htm">double cos(double x)</a>
Returns the cosine of a radian angle x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_cosh.htm">double cosh(double x)</a>
Returns the hyperbolic cosine of x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_sin.htm">double sin(double x)</a>
Returns the sine of a radian angle x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_sinh.htm">double sinh(double x)</a>
Returns the hyperbolic sine of x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_tanh.htm">double tanh(double x)</a>
Returns the hyperbolic tangent of x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_exp.htm">double exp(double x)</a>
Returns the value of <b>e</b> raised to the xth power.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_frexp.htm">double frexp(double x, int *exponent)</a>
The returned value is the mantissa and the integer pointed to by exponent is the exponent. The resultant value is x = mantissa * 2 ^ exponent.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ldexp.htm">double ldexp(double x, int exponent)</a>
Returns <b>x</b> multiplied by 2 raised to the power of exponent.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_log.htm">double log(double x)</a>
Returns the natural logarithm (base-e logarithm) of <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_log10.htm">double log10(double x)</a>
Returns the common logarithm (base-10 logarithm) of <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_modf.htm">double modf(double x, double *integer)</a>
The returned value is the fraction component (part after the decimal), and sets integer to the integer component.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_pow.htm">double pow(double x, double y)</a>
Returns x raised to the power of <b>y</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_sqrt.htm">double sqrt(double x)</a>
Returns the square root of <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ceil.htm">double ceil(double x)</a>
Returns the smallest integer value greater than or equal to <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fabs.htm">double fabs(double x)</a>
Returns the absolute value of <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_floor.htm">double floor(double x)</a>
Returns the largest integer value less than or equal to <b>x</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fmod.htm">double fmod(double x, double y)</a>
Returns the remainder of x divided by <b>y</b>.
<h2>C Library - &lt;setjmp.h></h2>
The <b>setjmp.h</b> header defines the macro <b>setjmp()</b>, one function <b>longjmp()</b>, and one variable type <b>jmp_buf</b>, for bypassing the normal function call and return discipline.
<h3>Library Variables</h3>
Following is the variable type defined in the header setjmp.h -
Variable & Description
<b>jmp_buf</b>
This is an array type used for holding information for macro <b>setjmp()</b> and function <b>longjmp()</b>.
<h3>Library Macros</h3>
There is only one macro defined in this library -
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_setjmp.htm">int setjmp(jmp_buf environment)</a>
This macro saves the current <i>environment</i> into the variable <b>environment</b> for later use by the function <b>longjmp()</b>. If this macro returns directly from the macro invocation, it returns zero but if it returns from a <b>longjmp()</b> function call, then a non-zero value is returned.
<h3>Library Functions</h3>
Following is the only one function defined in the header setjmp.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_longjmp.htm">void longjmp(jmp_buf environment, int value)</a>
This function restores the environment saved by the most recent call to <b>setjmp()</b> macro in the same invocation of the program with the corresponding <b>jmp_buf</b> argument.
<h2>C Library - &lt;signal.h></h2>
The <b>signal.h</b> header defines a variable type <b>sig_atomic_t</b>, two function calls, and several macros to handle different signals reported during a program's execution.
<h3>Library Variables</h3>
Following is the variable type defined in the header signal.h -
Variable & Description
<b>sig_atomic_t</b>
This is of <b>int</b> type and is used as a variable in a signal handler. This is an integral type of an object that can be accessed as an atomic entity, even in the presence of asynchronous signals.
<h3>Library Macros</h3>
Following are the macros defined in the header signal.h and these macros will be used in two functions listed below. The <b>SIG_</b> macros are used with the signal function to define signal functions.
<b>SIG_DFL</b>
Default signal handler.
<b>SIG_ERR</b>
Represents a signal error.
<b>SIG_IGN</b>
Signal ignore.
The <b>SIG</b> macros are used to represent a signal number in the following conditions -
<b>SIGABRT</b>
Abnormal program termination.
<b>SIGFPE</b>
Floating-point error like division by zero.
<b>SIGILL</b>
Illegal operation.
<b>SIGINT</b>
Interrupt signal such as ctrl-C.
<b>SIGSEGV</b>
Invalid access to storage like segment violation.
<b>SIGTERM</b>
Termination request.
<h3>Library Functions</h3>
Following are the functions defined in the header signal.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm">void (*signal(int sig, void (*func)(int)))(int)</a>
This function sets a function to handle signal i.e. a signal handler.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_raise.htm">int raise(int sig)</a>
This function causes signal <b>sig</b> to be generated. The sig argument is compatible with the SIG macros.
<h2>C Library - &lt;stdarg.h></h2>
The <b>stdarg.h</b> header defines a variable type <b>va_list</b> and three macros which can be used to get the arguments in a function when the number of arguments are not known i.e. variable number of arguments.
A function of variable arguments is defined with the ellipsis (,...) at the end of the parameter list.
<h3>Library Variables</h3>
Following is the variable type defined in the header stdarg.h -
Variable & Description
<b>va_list</b>
This is a type suitable for holding information needed by the three macros <b>va_start(), va_arg()</b> and <b>va_end()</b>.
<h3>Library Macros</h3>
Following are the macros defined in the header stdarg.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_start.htm">void va_start(va_list ap, last_arg)</a>
This macro initializes <b>ap</b> variable to be used with the <b>va_arg</b> and <b>va_end</b> macros. The <b>last_arg</b> is the last known fixed argument being passed to the function i.e. the argument before the ellipsis.
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_arg.htm">type va_arg(va_list ap, type)</a>
This macro retrieves the next argument in the parameter list of the function with type <b>type</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_va_end.htm">void va_end(va_list ap)</a>
This macro allows a function with variable arguments which used the <b>va_start</b> macro to return. If <b>va_end</b> is not called before returning from the function, the result is undefined.
<h2>C Library - &lt;stddef.h></h2>
The <b>stddef.h</b> header defines various variable types and macros. Many of these definitions also appear in other headers.
<h3>Library Variables</h3>
Following are the variable types defined in the header stddef.h -
Variable & Description
<b>ptrdiff_t</b>
This is the signed integral type and is the result of subtracting two pointers.
<b>size_t</b>
This is the unsigned integral type and is the result of the <b>sizeof</b> keyword.
<b>wchar_t</b>
This is an integral type of the size of a wide character constant.
<h3>Library Macros</h3>
Following are the macros defined in the header stddef.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_null.htm">NULL</a>
This macro is the value of a null pointer constant.
<a href="https://www.tutorialspoint.com/c_standard_library/c_macro_offsetof.htm">offsetof(type, member-designator)</a>
This results in a constant integer of type size_t which is the offset in bytes of a structure member from the beginning of the structure. The member is given by <i>member-designator</i>, and the name of the structure is given in <i>type</i>.
<h2>C Library - &lt;stdio.h></h2>
The <b>stdio.h</b> header defines three variable types, several macros, and various functions for performing input and output.
<h3>Library Variables</h3>
Following are the variable types defined in the header stdio.h -
Variable & Description
<b>size_t</b>
This is the unsigned integral type and is the result of the <b>sizeof</b> keyword.
<b>FILE</b>
This is an object type suitable for storing information for a file stream.
<b>fpos_t</b>
This is an object type suitable for storing any position in a file.
<h3>Library Macros</h3>
Following are the macros defined in the header stdio.h -
<b>NULL</b>
This macro is the value of a null pointer constant.
<b>_IOFBF, _IOLBF</b> and <b> _IONBF</b>
These are the macros which expand to integral constant expressions with distinct values and suitable for the use as third argument to the <b>setvbuf</b> function.
<b>BUFSIZ</b>
This macro is an integer, which represents the size of the buffer used by the <b>setbuf</b> function.
<b>EOF</b>
This macro is a negative integer, which indicates that the end-of-file has been reached.
<b>FOPEN_MAX</b>
This macro is an integer, which represents the maximum number of files that the system can guarantee to be opened simultaneously.
<b>FILENAME_MAX</b>
This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible filename. If the implementation imposes no limit, then this value should be the recommended maximum value.
<b>L_tmpnam</b>
This macro is an integer, which represents the longest length of a char array suitable for holding the longest possible temporary filename created by the <b>tmpnam</b> function.
<b>SEEK_CUR, SEEK_END,</b> and <b>SEEK_SET</b>
These macros are used in the <b>fseek</b> function to locate different positions in a file.
<b>TMP_MAX</b>
This macro is the maximum number of unique filenames that the function <b>tmpnam</b> can generate.
<b>stderr, stdin,</b> and <b>stdout</b>
These macros are pointers to FILE types which correspond to the standard error, standard input, and standard output streams.
<h3>Library Functions</h3>
Following are the functions defined in the header stdio.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fclose.htm">int fclose(FILE *stream)</a>
Closes the stream. All buffers are flushed.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_clearerr.htm">void clearerr(FILE *stream)</a>
Clears the end-of-file and error indicators for the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_feof.htm">int feof(FILE *stream)</a>
Tests the end-of-file indicator for the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ferror.htm">int ferror(FILE *stream)</a>
Tests the error indicator for the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fflush.htm">int fflush(FILE *stream)</a>
Flushes the output buffer of a stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fgetpos.htm">int fgetpos(FILE *stream, fpos_t *pos)</a>
Gets the current file position of the stream and writes it to pos.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm">FILE *fopen(const char *filename, const char *mode)</a>
Opens the filename pointed to by filename using the given mode.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fread.htm">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</a>
Reads data from the given stream into the array pointed to by ptr.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_freopen.htm">FILE *freopen(const char *filename, const char *mode, FILE *stream)</a>
Associates a new filename with the given open stream and same time closing the old file in stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fseek.htm">int fseek(FILE *stream, long int offset, int whence)</a>
Sets the file position of the stream to the given offset. The argument <i>offset</i> signifies the number of bytes to seek from the given <i>whence</i> position.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fsetpos.htm">int fsetpos(FILE *stream, const fpos_t *pos)</a>
Sets the file position of the given stream to the given position. The argument <i>pos</i> is a position given by the function fgetpos.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ftell.htm">long int ftell(FILE *stream)</a>
Returns the current file position of the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fwrite.htm">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)</a>
Writes data from the array pointed to by ptr to the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_remove.htm">int remove(const char *filename)</a>
Deletes the given filename so that it is no longer accessible.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_rename.htm">int rename(const char *old_filename, const char *new_filename)</a>
Causes the filename referred to, by old_filename to be changed to new_filename.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_rewind.htm">void rewind(FILE *stream)</a>
Sets the file position to the beginning of the file of the given stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_setbuf.htm">void setbuf(FILE *stream, char *buffer)</a>
Defines how a stream should be buffered.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_setvbuf.htm">int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</a>
Another function to define how a stream should be buffered.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_tmpfile.htm">FILE *tmpfile(void)</a>
Creates a temporary file in binary update mode (wb+).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_tmpnam.htm">char *tmpnam(char *str)</a>
Generates and returns a valid temporary filename which does not exist.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fprintf.htm">int fprintf(FILE *stream, const char *format, ...)</a>
Sends formatted output to a stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm">int printf(const char *format, ...)</a>
Sends formatted output to stdout.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_sprintf.htm">int sprintf(char *str, const char *format, ...)</a>
Sends formatted output to a string.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_vfprintf.htm">int vfprintf(FILE *stream, const char *format, va_list arg)</a>
Sends formatted output to a stream using an argument list.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_vprintf.htm">int vprintf(const char *format, va_list arg)</a>
Sends formatted output to stdout using an argument list.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_vsprintf.htm">int vsprintf(char *str, const char *format, va_list arg)</a>
Sends formatted output to a string using an argument list.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fscanf.htm">int fscanf(FILE *stream, const char *format, ...)</a>
Reads formatted input from a stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm">int scanf(const char *format, ...)</a>
Reads formatted input from stdin.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_sscanf.htm">int sscanf(const char *str, const char *format, ...)</a>
Reads formatted input from a string.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fgetc.htm">int fgetc(FILE *stream)</a>
Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm">char *fgets(char *str, int n, FILE *stream)</a>
Reads a line from the specified stream and stores it into the string pointed to by str. It stops when either (n-1) characters are read, the newline character is read, or the end-of-file is reached, whichever comes first.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fputc.htm">int fputc(int char, FILE *stream)</a>
Writes a character (an unsigned char) specified by the argument char to the specified stream and advances the position indicator for the stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_fputs.htm">int fputs(const char *str, FILE *stream)</a>
Writes a string to the specified stream up to but not including the null character.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_getc.htm">int getc(FILE *stream)</a>
Gets the next character (an unsigned char) from the specified stream and advances the position indicator for the stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_getchar.htm">int getchar(void)</a>
Gets a character (an unsigned char) from stdin.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_gets.htm">char *gets(char *str)</a>
Reads a line from stdin and stores it into the string pointed to by, str. It stops when either the newline character is read or when the end-of-file is reached, whichever comes first.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_putc.htm">int putc(int char, FILE *stream)</a>
Writes a character (an unsigned char) specified by the argument char to the specified stream and advances the position indicator for the stream.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_putchar.htm">int putchar(int char)</a>
Writes a character (an unsigned char) specified by the argument char to stdout.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_puts.htm">int puts(const char *str)</a>
Writes a string to stdout up to but not including the null character. A newline character is appended to the output.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ungetc.htm">int ungetc(int char, FILE *stream)</a>
Pushes the character char (an unsigned char) onto the specified stream so that the next character is read.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_perror.htm">void perror(const char *str)</a>
Prints a descriptive error message to stderr. First the string str is printed followed by a colon and then a space.
<h2>C Library - &lt;stdlib.h></h2>
The <b>stdlib.h</b> header defines four variable types, several macros, and various functions for performing general functions.
<h3>Library Variables</h3>
Following are the variable types defined in the header stdlib.h -
Variable & Description
<b>size_t</b>
This is the unsigned integral type and is the result of the <b>sizeof</b> keyword.
<b>wchar_t</b>
This is an integer type of the size of a <b>wide</b> character constant.
<b>div_t</b>
This is the structure returned by the <b>div</b> function.
<b>ldiv_t</b>
This is the structure returned by the <b>ldiv</b> function.
<h3>Library Macros</h3>
Following are the macros defined in the header stdlib.h -
<b>NULL</b>
This macro is the value of a null pointer constant.
<b>EXIT_FAILURE</b>
This is the value for the exit function to return in case of failure.
<b>EXIT_SUCCESS</b>
This is the value for the exit function to return in case of success.
<b>RAND_MAX</b>
This macro is the maximum value returned by the rand function.
<b>MB_CUR_MAX</b>
This macro is the maximum number of bytes in a multi-byte character set which cannot be larger than MB_LEN_MAX.
<h3>Library Functions</h3>
Following are the functions defined in the header stlib.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atof.htm">double atof(const char *str)</a>
Converts the string pointed to, by the argument <i>str</i> to a floating-point number (type double).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atoi.htm">int atoi(const char *str)</a>
Converts the string pointed to, by the argument <i>str</i> to an integer (type int).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atol.htm">long int atol(const char *str)</a>
Converts the string pointed to, by the argument <i>str</i> to a long integer (type long int).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strtod.htm">double strtod(const char *str, char **endptr)</a>
Converts the string pointed to, by the argument <i>str</i> to a floating-point number (type double).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strtol.htm">long int strtol(const char *str, char **endptr, int base)</a>
Converts the string pointed to, by the argument <i>str</i> to a long integer (type long int).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strtoul.htm">unsigned long int strtoul(const char *str, char **endptr, int base)</a>
Converts the string pointed to, by the argument <i>str</i> to an unsigned long integer (type unsigned long int).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_calloc.htm">void *calloc(size_t nitems, size_t size)</a>
Allocates the requested memory and returns a pointer to it.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_free.htm">void free(void *ptr</a>
Deallocates the memory previously allocated by a call to <i>calloc, malloc,</i> or <i>realloc</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm">void *malloc(size_t size)</a>
Allocates the requested memory and returns a pointer to it.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_realloc.htm">void *realloc(void *ptr, size_t size)</a>
Attempts to resize the memory block pointed to by ptr that was previously allocated with a call to <i>malloc</i> or <i>calloc</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_abort.htm">void abort(void)</a>
Causes an abnormal program termination.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_atexit.htm">int atexit(void (*func)(void))</a>
Causes the specified function <b>func</b> to be called when the program terminates normally.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_exit.htm">void exit(int status)</a>
Causes the program to terminate normally.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_getenv.htm">char *getenv(const char *name)</a>
Searches for the environment string pointed to by name and returns the associated value to the string.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_system.htm">int system(const char *string)</a>
The command specified by string is passed to the host environment to be executed by the command processor.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_bsearch.htm">void *bsearch(const void *key, const void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *))</a>
Performs a binary search.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_qsort.htm">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</a>
Sorts an array.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_abs.htm">int abs(int x)</a>
Returns the absolute value of x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_div.htm">div_t div(int numer, int denom)</a>
Divides numer (numerator) by denom (denominator).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_labs.htm">long int labs(long int x)</a>
Returns the absolute value of x.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ldiv.htm">ldiv_t ldiv(long int numer, long int denom)</a>
Divides numer (numerator) by denom (denominator).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_rand.htm">int rand(void)</a>
Returns a pseudo-random number in the range of 0 to <i>RAND_MAX</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_srand.htm">void srand(unsigned int seed)</a>
This function seeds the random number generator used by the function <b>rand</b>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_mblen.htm">int mblen(const char *str, size_t n)</a>
Returns the length of a multibyte character pointed to by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_mbstowcs.htm">size_t mbstowcs(schar_t *pwcs, const char *str, size_t n)</a>
Converts the string of multibyte characters pointed to by the argument <i>str</i> to the array pointed to by <i>pwcs</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_mbtowc.htm">int mbtowc(whcar_t *pwc, const char *str, size_t n)</a>
Examines the multibyte character pointed to by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_wcstombs.htm">size_t wcstombs(char *str, const wchar_t *pwcs, size_t n)</a>
Converts the codes stored in the array <i>pwcs</i> to multibyte characters and stores them in the string <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_wctomb.htm">int wctomb(char *str, wchar_t wchar)</a>
Examines the code which corresponds to a multibyte character given by the argument <i>wchar</i>.
<h2>C Library - &lt;string.h></h2>
The <b>string.h</b> header defines one variable type, one macro, and various functions for manipulating arrays of characters.
<h3>Library Variables</h3>
Following is the variable type defined in the header string.h -
Variable & Description
<b>size_t</b>
This is the unsigned integral type and is the result of the <b>sizeof</b> keyword.
<h3>Library Macros</h3>
Following is the macro defined in the header string.h -
<b>NULL</b>
This macro is the value of a null pointer constant.
<h3>Library Functions</h3>
Following are the functions defined in the header string.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_memchr.htm">void *memchr(const void *str, int c, size_t n)</a>
Searches for the first occurrence of the character c (an unsigned char) in the first n bytes of the string pointed to, by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_memcmp.htm">int memcmp(const void *str1, const void *str2, size_t n)</a>
Compares the first n bytes of <i>str1</i> and <i>str2</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_memcpy.htm">void *memcpy(void *dest, const void *src, size_t n)</a>
Copies n characters from src to <i>dest</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_memmove.htm">void *memmove(void *dest, const void *src, size_t n)</a>
Another function to copy n characters from <i>str2</i> to <i>str1</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_memset.htm">void *memset(void *str, int c, size_t n)</a>
Copies the character c (an unsigned char) to the first n characters of the string pointed to, by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcat.htm">char *strcat(char *dest, const char *src)</a>
Appends the string pointed to, by <i>src</i> to the end of the string pointed to by <i>dest</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strncat.htm">char *strncat(char *dest, const char *src, size_t n)</a>
Appends the string pointed to, by <i>src</i> to the end of the string pointed to, by <i>dest</i> up to n characters long.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strchr.htm">char *strchr(const char *str, int c)</a>
Searches for the first occurrence of the character c (an unsigned char) in the string pointed to, by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcmp.htm">int strcmp(const char *str1, const char *str2)</a>
Compares the string pointed to, by <i>str1</i> to the string pointed to by <i>str2</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strncmp.htm">int strncmp(const char *str1, const char *str2, size_t n)</a>
Compares at most the first n bytes of <i>str1</i> and <i>str2</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcoll.htm">int strcoll(const char *str1, const char *str2)</a>
Compares string <i>str1</i> to <i>str2</i>. The result is dependent on the LC_COLLATE setting of the location.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcpy.htm">char *strcpy(char *dest, const char *src)</a>
Copies the string pointed to, by <i>src</i> to <i>dest</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strncpy.htm">char *strncpy(char *dest, const char *src, size_t n)</a>
Copies up to n characters from the string pointed to, by <i>src</i> to <i>dest</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strcspn.htm">size_t strcspn(const char *str1, const char *str2)</a>
Calculates the length of the initial segment of str1 which consists entirely of characters not in str2.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strerror.htm">char *strerror(int errnum)</a>
Searches an internal array for the error number errnum and returns a pointer to an error message string.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strlen.htm">size_t strlen(const char *str)</a>
Computes the length of the string str up to but not including the terminating null character.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strpbrk.htm">char *strpbrk(const char *str1, const char *str2)</a>
Finds the first character in the string <i>str1</i> that matches any character specified in <i>str2</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strrchr.htm">char *strrchr(const char *str, int c)</a>
Searches for the last occurrence of the character c (an unsigned char) in the string pointed to by the argument <i>str</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strspn.htm">size_t strspn(const char *str1, const char *str2)</a>
Calculates the length of the initial segment of <i>str1</i> which consists entirely of characters in <i>str2</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm">char *strstr(const char *haystack, const char *needle)</a>
Finds the first occurrence of the entire string <i>needle</i> (not including the terminating null character) which appears in the string <i>haystack</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm">char *strtok(char *str, const char *delim)</a>
Breaks string <i>str</i> into a series of tokens separated by <i>delim</i>.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strxfrm.htm">size_t strxfrm(char *dest, const char *src, size_t n)</a>
Transforms the first <b>n</b> characters of the string <b>src</b> into current locale and places them in the string <b>dest</b>.
<h2>C Library - &lt;time.h></h2>
The <b>time.h</b> header defines four variable types, two macro and various functions for manipulating date and time.
<h3>Library Variables</h3>
Following are the variable types defined in the header time.h -
Variable & Description
<b>size_t</b>
This is the unsigned integral type and is the result of the <b>sizeof</b> keyword.
<b>clock_t</b>
This is a type suitable for storing the processor time.
<b>time_t is</b>
This is a type suitable for storing the calendar time.
<b>struct tm</b>
This is a structure used to hold the time and date.
The tm structure has the following definition -
struct tm {
   int tm_sec;         /* seconds,  range 0 to 59          */
   int tm_min;         /* minutes, range 0 to 59           */
   int tm_hour;        /* hours, range 0 to 23             */
   int tm_mday;        /* day of the month, range 1 to 31  */
   int tm_mon;         /* month, range 0 to 11             */
   int tm_year;        /* The number of years since 1900   */
   int tm_wday;        /* day of the week, range 0 to 6    */
   int tm_yday;        /* day in the year, range 0 to 365  */
   int tm_isdst;       /* daylight saving time             */
};
<h3>Library Macros</h3>
Following are the macros defined in the header time.h -
<b>NULL</b>
This macro is the value of a null pointer constant.
<b>CLOCKS_PER_SEC</b>
This macro represents the number of processor clocks per second.
<h3>Library Functions</h3>
Following are the functions defined in the header time.h -
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_asctime.htm">char *asctime(const struct tm *timeptr)</a>
Returns a pointer to a string which represents the day and time of the structure timeptr.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_clock.htm">clock_t clock(void)</a>
Returns the processor clock time used since the beginning of an implementation defined era (normally the beginning of the program).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_ctime.htm">char *ctime(const time_t *timer)</a>
Returns a string representing the localtime based on the argument timer.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_difftime.htm">double difftime(time_t time1, time_t time2)</a>
Returns the difference of seconds between time1 and time2 (time1-time2).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_gmtime.htm">struct tm *gmtime(const time_t *timer)</a>
The value of timer is broken up into the structure tm and expressed in Coordinated Universal Time (UTC) also known as Greenwich Mean Time (GMT).
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_localtime.htm">struct tm *localtime(const time_t *timer)</a>
The value of timer is broken up into the structure tm and expressed in the local time zone.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_mktime.htm">time_t mktime(struct tm *timeptr)</a>
Converts the structure pointed to by timeptr into a time_t value according to the local time zone.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_strftime.htm">size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr)</a>
Formats the time represented in the structure timeptr according to the formatting rules defined in format and stored into str.
<a href="https://www.tutorialspoint.com/c_standard_library/c_function_time.htm">time_t time(time_t *timer)</a>
Calculates the current calender time and encodes it into time_t format.

<h2>MIT Cheetah Mini open source software</h2>
<a href="https://github.com/mit-biomimetics/Cheetah-Software">MIT Cheetah Mini open source software</a>

<h2>C++ libraries</h2>
<a href="https://en.cppreference.com/w/" class="whitebut ">c++ reference</a>

<a href="https://en.cppreference.com/w/cpp/links/libs" class="whitebut ">open source C++ libraries</a>

<a href="https://en.cppreference.com/w/cpp/header" class="whitebut ">C++ Standard Library headers</a>
<h2>C++ Standard Library headers</h2>
The interface of C++ standard library is defined by the following collection of headers.
<h3> Concepts library</h3>
<a href="https://en.cppreference.com/w/cpp/header/concepts"> &lt;concepts></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/concepts">Fundamental library concepts</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_concepts&action=edit">&#91;edit&#93;</a>

<h3> Coroutines library</h3>
<a href="https://en.cppreference.com/w/cpp/header/coroutine"> &lt;coroutine></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/coroutine">Coroutine support library</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_coroutine&action=edit">&#91;edit&#93;</a>

<h3> Utilities library</h3>
<a href="https://en.cppreference.com/w/cpp/header/cstdlib"> &lt;cstdlib></a>
General purpose utilities: <a href="https://en.cppreference.com/w/cpp/utility/program"> program control</a>, <a href="https://en.cppreference.com/w/cpp/memory/c"> dynamic memory allocation</a>, <a href="https://en.cppreference.com/w/cpp/numeric/random#C_random_library"> random numbers</a>, <a href="https://en.cppreference.com/w/cpp/algorithm#C_library"> sort and search</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdlib&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/csignal"> &lt;csignal></a>
<a href="https://en.cppreference.com/w/cpp/utility/program"> Functions and macro constants for signal management</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_csignal&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/csetjmp"> &lt;csetjmp></a>
<a href="https://en.cppreference.com/w/cpp/utility/program/setjmp"> Macro (and function) that saves (and jumps) to an execution context</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_csetjmp&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdarg"> &lt;cstdarg></a>
<a href="https://en.cppreference.com/w/cpp/utility/variadic"> Handling of variable length argument lists</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdarg&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/typeinfo"> &lt;typeinfo></a>
<a href="https://en.cppreference.com/w/cpp/types"> Runtime type information utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_typeinfo&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/typeindex"> &lt;typeindex></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/types/type_index">std::type_index</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_typeindex&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/type_traits"> &lt;type_traits></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/types">Compile-time type information</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_type_traits&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/bitset"> &lt;bitset></a>
<a href="https://en.cppreference.com/w/cpp/utility/bitset">std::bitset</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_bitset&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/functional"> &lt;functional></a>
<a href="https://en.cppreference.com/w/cpp/utility/functional"> Function objects, Function invocations, Bind operations and Reference wrappers</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_functional&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/utility"> &lt;utility></a>
Various <a href="https://en.cppreference.com/w/cpp/utility"> utility components</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_utility&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ctime"> &lt;ctime></a>
<a href="https://en.cppreference.com/w/cpp/chrono/c"> C-style time/date utilites</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctime&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/chrono"> &lt;chrono></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/chrono"> C++ time utilites</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_chrono&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstddef"> &lt;cstddef></a>
<a href="https://en.cppreference.com/w/cpp/types"> Standard macros and typedefs</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstddef&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/initializer_list"> &lt;initializer_list></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/utility/initializer_list">std::initializer_list</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_initializer_list&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/tuple"> &lt;tuple></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/utility/tuple">std::tuple</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_tuple&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/any"> &lt;any></a>(C++17)
<a href="https://en.cppreference.com/w/cpp/utility/any">std::any</a> class <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_any&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/optional"> &lt;optional></a>(C++17)
<a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_optional&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/variant"> &lt;variant></a>(C++17)
<a href="https://en.cppreference.com/w/cpp/utility/variant">std::variant</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_variant&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/compare"> &lt;compare></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/language/operator_comparison#Three-way_comparison">Three-way comparison operator</a> support <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_compare&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/version"> &lt;version></a>(C++20)
Supplies implementation-dependent library information <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_version&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/source_location"> &lt;source_location></a>(C++20)
Supplies means to obtain <a href="https://en.cppreference.com/w/cpp/utility/source_location">source code location</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_source_location&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/stacktrace"> &lt;stacktrace></a>(C++23)
<a href="https://en.cppreference.com/w/cpp/utility/basic_stacktrace">Stacktrace</a> library <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stacktrace&action=edit">&#91;edit&#93;</a>

<h5>  Dynamic memory management </h5>
<a href="https://en.cppreference.com/w/cpp/header/new"> &lt;new></a>
<a href="https://en.cppreference.com/w/cpp/memory/new"> Low-level memory management utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_new&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/memory"> &lt;memory></a>
<a href="https://en.cppreference.com/w/cpp/memory">High-level memory management utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_memory&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/scoped_allocator"> &lt;scoped_allocator></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/memory/scoped_allocator_adaptor"> Nested allocator class</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_scoped_allocator&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/memory_resource"> &lt;memory_resource></a>(C++17)
<a href="https://en.cppreference.com/w/cpp/memory/memory_resource"> Polymorphic allocators and memory resources</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_memory_resource&action=edit">&#91;edit&#93;</a>

<h5>  Numeric limits </h5>
<a href="https://en.cppreference.com/w/cpp/header/climits"> &lt;climits></a>
<a href="https://en.cppreference.com/w/cpp/types/climits"> Limits of integral types</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_climits&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cfloat"> &lt;cfloat></a>
<a href="https://en.cppreference.com/w/cpp/types/climits"> Limits of floating-point types</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cfloat&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdint"> &lt;cstdint></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/types/integer"> Fixed-width integer types</a> and <a href="https://en.cppreference.com/w/cpp/types/climits"> limits of other types</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdint&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cinttypes"> &lt;cinttypes></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/types/integer#Format_macro_constants"> Formatting macros</a>, <k>intmax_t</k> and <k>uintmax_t</k> math and conversions <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cinttypes&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/limits"> &lt;limits></a>
<a href="https://en.cppreference.com/w/cpp/types/numeric_limits">Uniform way to query properties of arithmetic types</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_limits&action=edit">&#91;edit&#93;</a>

<h5>  Error handling </h5>
<a href="https://en.cppreference.com/w/cpp/header/exception"> &lt;exception></a>
<a href="https://en.cppreference.com/w/cpp/error#Exception_handling"> Exception handling utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_exception&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/stdexcept"> &lt;stdexcept></a>
<a href="https://en.cppreference.com/w/cpp/error#Exception_categories"> Standard exception objects</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdexcept&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cassert"> &lt;cassert></a>
<a href="https://en.cppreference.com/w/cpp/error/assert"> Conditionally compiled macro that compares its argument to zero</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cassert&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/system_error"> &lt;system_error></a>(C++11)
Defines <a href="https://en.cppreference.com/w/cpp/error/error_code">std::error_code</a>, a platform-dependent error code <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_system_error&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cerrno"> &lt;cerrno></a>
<a href="https://en.cppreference.com/w/cpp/error/errno"> Macro containing the last error number</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cerrno&action=edit">&#91;edit&#93;</a>

<h3> Strings library</h3>
<a href="https://en.cppreference.com/w/cpp/header/cctype"> &lt;cctype></a>
<a href="https://en.cppreference.com/w/cpp/string/byte"> Functions to determine the category of narrow characters</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cctype&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cwctype"> &lt;cwctype></a>
<a href="https://en.cppreference.com/w/cpp/string/wide"> Functions to determine the catagory of wide characters</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cwctype&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstring"> &lt;cstring></a>
Various <a href="https://en.cppreference.com/w/cpp/string/byte"> narrow character string handling functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstring&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cwchar"> &lt;cwchar></a>
Various <a href="https://en.cppreference.com/w/cpp/string/wide">wide</a> and <a href="https://en.cppreference.com/w/cpp/string/multibyte">multibyte</a> string handling functions <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cwchar&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cuchar"> &lt;cuchar></a>(C++11)
C-style <a href="https://en.cppreference.com/w/cpp/string/multibyte"> Unicode character conversion functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cuchar&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/string"> &lt;string></a>
<a href="https://en.cppreference.com/w/cpp/string/basic_string">std::basic_string</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/string_view"> &lt;string_view></a>(C++17)
<a href="https://en.cppreference.com/w/cpp/string/basic_string_view">std::basic_string_view</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string_view&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/charconv"> &lt;charconv></a>(C++17)
std::to_chars and std::from_chars  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_charconv&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/format"> &lt;format></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/utility/format">Formatting library</a> including <a href="https://en.cppreference.com/w/cpp/utility/format/format">std::format</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_format&action=edit">&#91;edit&#93;</a>

<h3> Containers library</h3>
<a href="https://en.cppreference.com/w/cpp/header/array"> &lt;array></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/container/array">std::array</a> container <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_array&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/vector"> &lt;vector></a>
<a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a> container <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_vector&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/deque"> &lt;deque></a>
<a href="https://en.cppreference.com/w/cpp/container/deque">std::deque</a> container <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_deque&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/list"> &lt;list></a>
<a href="https://en.cppreference.com/w/cpp/container/list">std::list</a> container <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_list&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/forward_list"> &lt;forward_list></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/container/forward_list">std::forward_list</a> container <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_forward_list&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/set"> &lt;set></a>
<a href="https://en.cppreference.com/w/cpp/container/set">std::set</a> and <a href="https://en.cppreference.com/w/cpp/container/multiset">std::multiset</a> associative containers <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_set&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/map"> &lt;map></a>
<a href="https://en.cppreference.com/w/cpp/container/map">std::map</a> and <a href="https://en.cppreference.com/w/cpp/container/multimap">std::multimap</a> associative containers <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_map&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/unordered_set"> &lt;unordered_set></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/container/unordered_set">std::unordered_set</a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_multiset">std::unordered_multiset</a> unordered associative containers <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_unordered_set&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/unordered_map"> &lt;unordered_map></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/container/unordered_map">std::unordered_map</a> and <a href="https://en.cppreference.com/w/cpp/container/unordered_multimap">std::unordered_multimap</a> unordered associative containers <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_unordered_map&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/stack"> &lt;stack></a>
<a href="https://en.cppreference.com/w/cpp/container/stack">std::stack</a> container adaptor  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stack&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/queue"> &lt;queue></a>
<a href="https://en.cppreference.com/w/cpp/container/queue">std::queue</a> and <a href="https://en.cppreference.com/w/cpp/container/priority_queue">std::priority_queue</a> container adaptors <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_queue&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/span"> &lt;&#115;pan></a>(C++20)
std::span view <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_span&action=edit">&#91;edit&#93;</a>

<h3> Iterators library</h3>
<a href="https://en.cppreference.com/w/cpp/header/iterator"> &lt;iterator></a>
<a href="https://en.cppreference.com/w/cpp/iterator"> Range iterators</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iterator&action=edit">&#91;edit&#93;</a>

<h3> Ranges library</h3>
<a href="https://en.cppreference.com/w/cpp/header/ranges"> &lt;ranges></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/ranges"> Range access, primitives, requirements, utilities and adaptors</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ranges&action=edit">&#91;edit&#93;</a>

<h3> Algorithms library</h3>
<a href="https://en.cppreference.com/w/cpp/header/algorithm"> &lt;algorithm></a>
<a href="https://en.cppreference.com/w/cpp/algorithm"> Algorithms that operate on ranges</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_algorithm&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/execution"> &lt;execution></a>(C++17)
Predefined execution policies for parallel versions of the algorithms <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_execution&action=edit">&#91;edit&#93;</a>

<h3> Numerics library</h3>
<a href="https://en.cppreference.com/w/cpp/header/cmath"> &lt;cmath></a>
<a href="https://en.cppreference.com/w/cpp/numeric/math"> Common mathematics functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cmath&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/complex"> &lt;complex></a>
<a href="https://en.cppreference.com/w/cpp/numeric/complex"> Complex number type</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_complex&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/valarray"> &lt;valarray></a>
<a href="https://en.cppreference.com/w/cpp/numeric/valarray"> Class for representing and manipulating arrays of values</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_valarray&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/random"> &lt;random></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/numeric/random"> Random number generators and distributions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_random&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/numeric"> &lt;numeric></a>
<a href="https://en.cppreference.com/w/cpp/numeric"> Numeric operations on values in ranges</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_numeric&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ratio"> &lt;ratio></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/numeric/ratio"> Compile-time rational arithmetic</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ratio&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cfenv"> &lt;cfenv></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/numeric/fenv"> Floating-point environment</a> access functions <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cfenv&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/bit"> &lt;bit></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/numeric#Bit_manipulation_.28since_C.2B.2B20.29"> Bit manipulation</a> functions <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_bit&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/numbers"> &lt;numbers></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/numeric/constants"> Math constants</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_numbers&action=edit">&#91;edit&#93;</a>

<h3> Localization library</h3>
<a href="https://en.cppreference.com/w/cpp/header/locale"> &lt;locale></a>
<a href="https://en.cppreference.com/w/cpp/locale"> Localization utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_locale&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/clocale"> &lt;clocale></a>
<a href="https://en.cppreference.com/w/cpp/locale#C_library_locales"> C localization utilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_clocale&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/codecvt"> &lt;codecvt></a>(C++11)(deprecated in C++17)
<a href="https://en.cppreference.com/w/cpp/locale"> Unicode conversion facilities</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_codecvt&action=edit">&#91;edit&#93;</a>

<h3> Input/output library</h3>
<a href="https://en.cppreference.com/w/cpp/header/iosfwd"> &lt;iosfwd></a>
Forward declarations of all classes in the input/output library <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iosfwd&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ios"> &lt;ios></a>
<a href="https://en.cppreference.com/w/cpp/io/ios_base">std::ios_base</a> class, <a href="https://en.cppreference.com/w/cpp/io/basic_ios">std::basic_ios</a> class template and several typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ios&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/istream"> &lt;istream></a>
<a href="https://en.cppreference.com/w/cpp/io/basic_istream">std::basic_istream</a> class template and several typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_istream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ostream"> &lt;ostream></a>
<a href="https://en.cppreference.com/w/cpp/io/basic_ostream">std::basic_ostream</a>, <a href="https://en.cppreference.com/w/cpp/io/basic_iostream">std::basic_iostream</a> class templates and several typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ostream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/iostream"> &lt;iostream></a>
Several standard stream objects <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iostream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/fstream"> &lt;fstream></a>
<a href="https://en.cppreference.com/w/cpp/io/basic_fstream">std::basic_fstream</a>, <a href="https://en.cppreference.com/w/cpp/io/basic_ifstream">std::basic_ifstream</a>, <a href="https://en.cppreference.com/w/cpp/io/basic_ofstream">std::basic_ofstream</a> class templates and several typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_fstream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/sstream"> &lt;sstream></a>
<a href="https://en.cppreference.com/w/cpp/io/basic_stringstream">std::basic_stringstream</a>, <a href="https://en.cppreference.com/w/cpp/io/basic_istringstream">std::basic_istringstream</a>, <a href="https://en.cppreference.com/w/cpp/io/basic_ostringstream">std::basic_ostringstream</a> class templates and several typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_sstream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/syncstream"> &lt;syncstream></a>(C++20)
std::basic_osyncstream, std::basic_syncbuf, and typedefs <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_syncstream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/strstream"> &lt;strstream></a>(deprecated in C++98)
<a href="https://en.cppreference.com/w/cpp/io/strstream">std::strstream</a>, <a href="https://en.cppreference.com/w/cpp/io/istrstream">std::istrstream</a>, <a href="https://en.cppreference.com/w/cpp/io/ostrstream">std::ostrstream</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_strstream&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/iomanip"> &lt;iomanip></a>
<a href="https://en.cppreference.com/w/cpp/io/manip"> Helper functions to control the format of input and output</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iomanip&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/streambuf"> &lt;streambuf></a>
<a href="https://en.cppreference.com/w/cpp/io/basic_streambuf">std::basic_streambuf</a> class template <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_streambuf&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdio"> &lt;cstdio></a>
<a href="https://en.cppreference.com/w/cpp/io/c"> C-style input-output functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdio&action=edit">&#91;edit&#93;</a>

<h3> Filesystem library</h3>
<a href="https://en.cppreference.com/w/cpp/header/filesystem"> &lt;filesystem></a>(C++17)
std::path class and <a href="https://en.cppreference.com/w/cpp/filesystem"> supporting functions</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_filesystem&action=edit">&#91;edit&#93;</a>

<h3> Regular Expressions library</h3>
<a href="https://en.cppreference.com/w/cpp/header/regex"> &lt;regex></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/regex"> Classes, algorithms and iterators to support regular expression processing</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_regex&action=edit">&#91;edit&#93;</a>

<h3> Atomic Operations library</h3>
<a href="https://en.cppreference.com/w/cpp/header/atomic"> &lt;atomic></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/atomic"> Atomic operations library</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_atomic&action=edit">&#91;edit&#93;</a>

<h3> Thread support library</h3>
<a href="https://en.cppreference.com/w/cpp/header/thread"> &lt;thread></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/thread/thread">std::thread</a> class and <a href="https://en.cppreference.com/w/cpp/thread"> supporting functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_thread&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/stop_token"> &lt;stop_token></a>(C++20)
Stop tokens for <a href="https://en.cppreference.com/w/cpp/thread/jthread">std::jthread</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stop_token&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/mutex"> &lt;mutex></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/thread">Mutual exclusion primitives</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_mutex&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/shared_mutex"> &lt;shared_mutex></a>(C++14)
<a href="https://en.cppreference.com/w/cpp/thread"> Shared mutual exclusion primitives</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_shared_mutex&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/future"> &lt;future></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/thread"> Primitives for asynchronous computations</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_future&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/condition_variable"> &lt;condition_variable></a>(C++11)
<a href="https://en.cppreference.com/w/cpp/thread">Thread waiting conditions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_condition_variable&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/semaphore"> &lt;semaphore></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore">Semaphores</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_semaphore&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/latch"> &lt;latch></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/thread/latch">Latches</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_latch&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/barrier"> &lt;barrier></a>(C++20)
<a href="https://en.cppreference.com/w/cpp/thread/barrier">Barriers</a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_barrier&action=edit">&#91;edit&#93;</a>

<h3>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=1">edit</a>] C compatibility headers</h3>
For some of the C standard library headers of the form xxx.h, the C++ standard library both includes an identically-named header and another header of the form cxxx (all meaningful cxxx headers are listed above).
With the exception of complex.h , each xxx.h header included in the C++ standard library places in the global namespace each name that the corresponding cxxx header would have placed in the std namespace.
These headers are allowed to also declare the same names in the std namespace, and the corresponding cxxx headers are allowed to also declare the same names in the global namespace: including &lt;cstdlib> definitely provides <a href="http://en.cppreference.com/w/cpp/memory/c/malloc">std::malloc</a> and may also provide ::malloc. Including &lt;stdlib.h> definitely provides ::malloc and may also provide <a href="http://en.cppreference.com/w/cpp/memory/c/malloc">std::malloc</a>. This applies even to functions and function overloads that are not part of C standard library.

<a href="https://en.cppreference.com/w/cpp/header/cassert"> &lt;assert.h></a>(deprecated)
Behaves same as <a href="https://en.cppreference.com/w/cpp/header/cassert">&lt;cassert></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_assert.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cctype"> &lt;ctype.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cctype">&lt;cctype></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctype.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cerrno"> &lt;errno.h></a>(deprecated)
Behaves same as <a href="https://en.cppreference.com/w/cpp/header/cerrno">&lt;cerrno></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_errno.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cfenv"> &lt;fenv.h></a>(C++11)(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cfenv">&lt;cfenv></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_fenv.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cfloat"> &lt;float.h></a>(deprecated)
Behaves same as <a href="https://en.cppreference.com/w/cpp/header/cfloat">&lt;cfloat></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_float.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cinttypes"> &lt;inttypes.h></a>(C++11)(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cinttypes">&lt;cinttypes></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_inttypes.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/climits"> &lt;limits.h></a>(deprecated)
Behaves same as <a href="https://en.cppreference.com/w/cpp/header/climits">&lt;climits></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_limits.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/clocale"> &lt;locale.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/clocale">&lt;clocale></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_locale.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cmath"> &lt;math.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cmath">&lt;cmath></a> is placed in global namespace,<br />except for names of <a href="https://en.cppreference.com/w/cpp/numeric/special_functions">mathematical special functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_math.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/csetjmp"> &lt;setjmp.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/csetjmp">&lt;csetjmp></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_setjmp.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/csignal"> &lt;signal.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/csignal">&lt;csignal></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_signal.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdarg"> &lt;stdarg.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstdarg">&lt;cstdarg></a> is placed in global namespace  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdarg.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstddef"> &lt;stddef.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstddef">&lt;cstddef></a> is placed in global namespace,<br />except for names of <a href="https://en.cppreference.com/w/cpp/types/byte"><k>std::byte</k> and related functions</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stddef.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdint"> &lt;stdint.h></a>(C++11)(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstdint">&lt;cstdint></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdint.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdio"> &lt;stdio.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstdio">&lt;cstdio></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdio.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdlib"> &lt;stdlib.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstdlib">&lt;cstdlib></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdlib.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstring"> &lt;string.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cstring">&lt;cstring></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_string.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ctime"> &lt;&#116;ime.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/ctime">&lt;ctime></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_time.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cuchar"> &lt;uchar.h></a>(C++11)(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cuchar">&lt;cuchar></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_uchar.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cwchar"> &lt;wchar.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cwchar">&lt;cwchar></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_wchar.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cwctype"> &lt;wctype.h></a>(deprecated)
Behaves as if each name from <a href="https://en.cppreference.com/w/cpp/header/cwctype">&lt;cwctype></a> is placed in global namespace <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_wctype.h&action=edit">&#91;edit&#93;</a>

<h4>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=2">edit</a>] Special C compatibility headers</h4>
The header <k>&lt;stdatomic.h></k> declares names which are also provided in the C standard library, and defines the <k>_Atomic</k> macro which is a <a href="https://en.cppreference.com/w/c/keyword/_Atomic">keyword</a> in C. Unlike other xxx.h headers, corresponding <k>&lt;cstdatomic></k> is not provided.

<a href="https://en.cppreference.com/w/cpp/header/stdatomic.h"> &lt;stdatomic.h></a>(C++23)
Defines <k>_Atomic</k> and provides corresponding components in the C standard library <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdatomic.h&action=edit">&#91;edit&#93;</a>

<h4>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=3">edit</a>] Empty C headers</h4>
The headers <k>&lt;complex.h></k>, <k>&lt;ccomplex></k>, <k>&lt;tgmath.h></k>, and <k>&lt;ctgmath></k> do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. The use of all these headers is deprecated in C++.

<a href="https://en.cppreference.com/w/cpp/header/ccomplex"> &lt;ccomplex></a>(C++11)(deprecated in C++17)(removed in C++20)
Simply includes the header <a href="https://en.cppreference.com/w/cpp/header/complex">&lt;complex></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ccomplex&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ccomplex"> &lt;complex.h></a>(C++11)(deprecated)
Simply includes the header <a href="https://en.cppreference.com/w/cpp/header/complex">&lt;complex></a>  <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_complex.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ctgmath"> &lt;ctgmath></a>(C++11)(deprecated in C++17)(removed in C++20)
Simply includes the headers <a href="https://en.cppreference.com/w/cpp/header/complex">&lt;complex></a> and <a href="https://en.cppreference.com/w/cpp/header/cmath">&lt;cmath></a>: the overloads equivalent to the contents of the C header <k>tgmath.h</k> are already provided by those headers <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ctgmath&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ctgmath"> &lt;tgmath.h></a>(C++11)(deprecated)
Simply includes the headers <a href="https://en.cppreference.com/w/cpp/header/complex">&lt;complex></a> and <a href="https://en.cppreference.com/w/cpp/header/cmath">&lt;cmath></a>   <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_tgmath.h&action=edit">&#91;edit&#93;</a>

<h4>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=4">edit</a>] Meaningless C headers</h4>
The headers <k>&lt;ciso646></k>, <k>&lt;cstdalign></k>, and <k>&lt;cstdbool></k> are meaningless in C++ because the macros they provide in C are language keywords in C++.

<a href="https://en.cppreference.com/w/cpp/header/ciso646"> &lt;ciso646></a>(removed in C++20)
Empty header. <a href="https://en.cppreference.com/w/c/language/operator_alternative">The macros that appear in <k>iso646.h</k> in C</a> are <a href="https://en.cppreference.com/w/cpp/language/operator_alternative">keywords in C++</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_ciso646&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/ciso646"> &lt;iso646.h></a>(deprecated)
Has no effect <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_iso646.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdalign"> &lt;cstdalign></a>(C++11)(deprecated in C++17)(removed in C++20)
Defines one <a href="https://en.cppreference.com/w/cpp/types">compatibility macro constant</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdalign&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdalign"> &lt;stdalign.h></a>(C++11)(deprecated)
Defines one <a href="https://en.cppreference.com/w/cpp/types">compatibility macro constant</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdalign.h&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdbool"> &lt;cstdbool></a>(C++11)(deprecated in C++17)(removed in C++20)
Defines one <a href="https://en.cppreference.com/w/cpp/types">compatibility macro constant</a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_cstdbool&action=edit">&#91;edit&#93;</a>
<a href="https://en.cppreference.com/w/cpp/header/cstdbool"> &lt;stdbool.h></a>(C++11)(deprecated)
Defines one <a href="https://en.cppreference.com/w/cpp/types">compatibility macro constant </a> <a href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/header/dsc_stdbool.h&action=edit">&#91;edit&#93;</a>

<h4>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=5">edit</a>] Unsupported C headers</h4>
The C headers <k>&lt;stdatomic.h></k>, (until C++23) <k>&lt;stdnoreturn.h></k>, and <k>&lt;threads.h></k> are not included in C++ and have no cxxx equivalents.
<h3>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=6">edit</a>] <a href="https://en.cppreference.com/w/cpp/header/experimental">Experimental libraries</a></h3>
<a href="https://en.cppreference.com/w/cpp/experimental">C++ TR's/TS's</a> also define several collections of headers.
<h3>[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/header&action=edit&section=7">edit</a>] See also</h3>
<a href="https://en.cppreference.com/w/c/header">C documentation</a> for C Standard Library headers

<h2>C++ library for web scraping</h2>
libcurl to download the html file
libtidy to convert to valid xml
libxml to parse/navigate the xml

can skip step 2, as libxml is able to handle HTML

<a href="https://www.rosettacode.org/wiki/Web_scraping#C" class="whitebut ">Web scraping</a>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;curl/curl.h>
#include &lt;sys/types.h>
#include &lt;regex.h>
 
#define BUFSIZE 16384
 
size_t lr = 0;
 
size_t filterit(void *ptr, size_t size, size_t nmemb, void *stream)
{
  if ( (lr + size*nmemb) > BUFSIZE ) return BUFSIZE;
  memcpy(stream+lr, ptr, size*nmemb);
  lr += size*nmemb;
  return size*nmemb;
}
 
int main()
{
  CURL *curlHandle;
  char buffer[BUFSIZE];
  regmatch_t amatch;
  regex_t cregex;
 
  curlHandle = curl_easy_init();
  curl_easy_setopt(curlHandle, CURLOPT_URL, "http://tycho.usno.navy.mil/cgi-bin/timer.pl");
  curl_easy_setopt(curlHandle, CURLOPT_FOLLOWLOCATION, 1);
  curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, filterit);
  curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, buffer);
  int success = curl_easy_perform(curlHandle);
  curl_easy_cleanup(curlHandle);
 
  buffer[lr] = 0;
 
  regcomp(&cregex, " UTC", REG_NEWLINE);
  regexec(&cregex, buffer, 1, &amatch, 0);
  int bi = amatch.rm_so;
  while ( bi-- > 0 )
    if ( memcmp(&buffer[bi], "&lt;br>", 4) == 0 ) break;
 
  buffer[amatch.rm_eo] = 0;
 
  printf("%s\n", &buffer[bi+4]);
 
  regfree(&cregex);
  return 0;
}

<h2>Arithmetic Operators</h2>
The following table shows all the arithmetic operators supported by the C language.
Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then -
<a href="https://www.tutorialspoint.com/cprogramming/c_arithmetic_operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
<tr><td>&plus;</td><td>Adds two operands.</td><td>A &plus; B = 30</td></tr>
<tr><td>-</td><td>Subtracts second operand from the first.</td><td>A - B = -10</td></tr>
<tr><td>*</td><td>Multiplies both operands.</td><td>A * B = 200</td></tr>
<tr><td>/</td><td>Divides numerator by de-numerator.</td><td>B / A = 2</td></tr>
<tr><td>%</td><td>Modulus Operator and remainder of after an integer division.</td>
<td>B % A = 0</td></tr>
<tr><td>++</td><td>Increment operator increases the integer value by one.</td>
<td>A++ = 11</td></tr>
<tr><td>--</td><td>Decrement operator decreases the integer value by one.</td>
<td>A-- = 9</td></tr>
</table>
<h2>Relational Operators</h2>
The following table shows all the relational operators supported by C.
Assume variable <b>A</b> holds 10 and variable <b>B</b> holds 20 then -
<a href="https://www.tutorialspoint.com/cprogramming/c_relational_operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
<tr><td>==</td><td>Checks if the values of two operands are equal or not.
If yes, then the condition becomes true.</td>
<td>(A == B) is not true.
</td></tr>
<tr><td>!=</td><td>Checks if the values of two operands are equal or not.
If the values are not equal, then the condition becomes true.</td>
<td>(A != B) is true.</td></tr>
<tr><td>></td><td>Checks if the value of left  operand is greater than the value of right operand.
If yes, then the condition becomes true.</td>
<td>(A > B) is not true.</td></tr>
<tr><td>&lt;</td><td>Checks if the value of left operand is less than the value of right operand.
If yes, then the condition becomes true.</td>
<td>(A &lt; B) is true.</td></tr>
<tr><td>>=</td><td>Checks if the value of left operand is greater than or equal to the value of right operand.
If yes, then the condition becomes true.</td>
<td>(A >= B) is not true.</td></tr>
<tr><td>&lt;=</td><td>Checks if the value of left operand is less than or equal to the value of right operand.
If yes, then the condition becomes true.</td>
<td>(A &lt;= B) is true.</td></tr>
</table>
<h2>Logical Operators</h2>
Following table shows all the logical operators supported by C language.
Assume variable <b>A</b> holds 1 and variable <b>B</b> holds 0, then -
<a href="https://www.tutorialspoint.com/cprogramming/c_logical_operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
<tr><td>&</td><td>Called Logical AND operator.
If both the operands are non-zero, then the condition becomes true.</td>
<td>(A & B) is false.</td></tr>
<tr><td>||</td><td>Called Logical OR Operator.
If any of the two operands is non-zero, then the condition becomes true.</td>
<td>(A || B) is true.</td></tr>
<tr><td>!</td><td>Called Logical NOT Operator.
It is used to reverse the logical state of its operand.
If a condition is true, then Logical NOT operator will make it false.</td>
<td>!(A & B) is true.</td></tr>
</table>
<h2>Bitwise Operators</h2>
Bitwise operator works on bits and perform bit-by-bit operation.
The truth tables for &, |, and ^ is as follows -
<table class="table table-bordered">
<tr><th style="width:20%;text-align:center;">p</th>
<th style="width:20%;text-align:center;">q</th>
<th style="width:20%;text-align:center;">p & q</th>
<th style="width:20%;text-align:center;">p | q</th>
<th style="width:20%;text-align:center;">p ^ q</th></tr>
<tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</table>
Assume A = 60 and B = 13 in binary format, they will be as follows -
A = 0011 1100
B = 0000 1101
-----------------
A&B = 0000 1100
A|B = 0011 1101
A^B = 0011 0001
~A = 1100 0011
The following table lists the bitwise operators supported by C.
Assume variable 'A' holds 60 and variable 'B' holds 13, then -
<a href="https://www.tutorialspoint.com/cprogramming/c_bitwise_operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
<tr><td>&</td><td>Binary AND Operator copies a bit to the result if it exists in both operands.
</td><td>(A & B) = 12, i.e., 0000 1100</td></tr>
<tr><td>|</td><td>Binary OR Operator copies a bit if it exists in either operand.</td><td>(A | B) = 61, i.e., 0011 1101</td></tr>
<tr><td>^</td><td>Binary XOR Operator copies the bit if it is set in one operand but not both.
</td><td>(A ^ B) = 49, i.e., 0011 0001</td></tr>
<tr><td>~</td>
<td style="vertical-align:middle;">Binary One's Complement Operator is unary and has the effect of 'flipping' bits.</td><td>(~A ) = ~(60), i.e,.
-0111101</td></tr>
<tr><td>&lt;&lt;</td><td>Binary Left Shift Operator.
The left operands value is moved left by the number of bits specified by the right operand.</td>
<td style="vertical-align:middle;">A &lt;&lt; 2 = 240 i.e., 1111 0000</td></tr>
<tr><td>>></td><td>Binary Right Shift Operator.
The left operands value is moved right by the number of bits specified by the right operand.</td>
<td style="vertical-align:middle;">A >> 2 = 15 i.e., 0000 1111</td></tr>
</table>
<h2>Assignment Operators</h2>
The following table lists the assignment operators supported by the C language -
<a href="https://www.tutorialspoint.com/cprogramming/c_assignment_operators.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th>Operator</th><th>Description</th><th>Example</th></tr>
<tr><td>=</td><td>Simple assignment operator.
Assigns values from right side operands to left side operand</td>
<td style="vertical-align:middle;">C = A + B will assign the value of A + B to C</td></tr>
<tr><td>+=</td><td>Add AND assignment operator.
It adds the right operand to the left operand and assign the result to the left operand.</td>
<td style="vertical-align:middle;">C += A is equivalent to C = C + A</td></tr>
<tr><td>-=</td><td>Subtract AND assignment operator.
It subtracts the right operand from the left operand and assigns the result to the left operand.</td>
<td style="vertical-align:middle;">C -= A is equivalent to C = C - A</td></tr>
<tr><td>*=</td><td>Multiply AND assignment operator.
It multiplies the right operand with the left operand and assigns the result to the left operand.</td>
<td style="vertical-align:middle;">C *= A is equivalent to C = C * A</td></tr>
<tr><td>/=</td><td>Divide AND assignment operator.
It divides the left operand with the right operand and assigns the result to the left operand.</td>
<td style="vertical-align:middle;">C /= A is equivalent to C = C / A</td></tr>
<tr><td>%=</td><td>Modulus AND assignment operator.
It takes modulus using two operands and assigns the result to the left operand.</td>
<td style="vertical-align:middle;">C %= A is equivalent to C = C % A</td></tr>
<tr><td>&lt;&lt;=</td><td>Left shift AND assignment operator.</td><td>C &lt;&lt;= 2 is same as  C = C &lt;&lt; 2</td></tr>
<tr><td>>>=</td><td>Right shift AND assignment operator.</td><td>C >>= 2 is same as  C = C >> 2</td></tr>
<tr><td>&=</td><td>Bitwise AND assignment operator.</td><td>C &= 2 is same as  C = C & 2</td></tr>
<tr><td>^=</td><td>Bitwise exclusive OR and assignment operator.</td><td>C ^= 2 is same as  C = C ^ 2</td></tr>
<tr><td>|=</td><td>Bitwise inclusive OR and assignment operator.</td><td>C |= 2 is same as  C = C | 2</td></tr>
</table>
<h2>Misc Operators &map; sizeof & ternary</h2>
Besides the operators discussed above, there are a few other important operators including <b>sizeof</b> and <b>? :</b> supported by the C Language.
<a href="https://www.tutorialspoint.com/cprogramming/c_sizeof_operator.htm">Show Examples</a>
<table class="table table-bordered">
<tr><th style="width:10%">Operator</th>
<th style="width:43%;">Description</th><th>Example</th></tr>
<tr><td>sizeof()</td>
<td style="vertical-align:middle;">Returns the size of a variable.</td><td>sizeof(a), where a is integer, will return 4.</td></tr>
<tr><td>&</td>
<td style="vertical-align:middle;">Returns the address of a variable.</td><td>&a; returns the actual address of the variable.</td></tr>
<tr><td>*</td><td>Pointer to a variable.</td><td>*a;</td></tr>
<tr><td>? :</td>
<td style="vertical-align:middle;">Conditional Expression.</td><td>If Condition is true ? then value X : otherwise value Y</td></tr>
</table>
<h2>Operators Precedence in C</h2>
Operator precedence determines the grouping of terms in an expression and decides how an expression is evaluated.
Certain operators have higher precedence than others; for example, the multiplication operator has a higher precedence than the addition operator.
For example, x = 7 + 3 * 2; here, x is assigned 13, not 20 because operator * has a higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.
Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom.
Within an expression, higher precedence operators will be evaluated first.
<a href="https://www.tutorialspoint.com/cprogramming/c_operators_precedence.htm">Show Examples</a>
<table class="table table-bordered">
<tr> <th>Category</th> <th>Operator</th><th>Associativity</th> </tr> 
<tr> <td>Postfix</td><td>() [] -> .
++ - -</td> <td>Left to right</td> </tr>
<tr> <td>Unary</td> <td>+  -  !  ~  ++  - -  (type)*  & sizeof</td> <td>Right to left</td></tr> 
<tr> <td>Multiplicative</td> <td>*  /  %</td><td>Left to right</td> </tr> 
<tr> <td>Additive</td><td>+  -</td> <td>Left to right</td> </tr>
<tr> <td>Shift</td> <td>&lt;&lt; >></td> <td>Left to right</td> </tr> 
<tr> <td>Relational</td><td>&lt; &lt;=  > >=</td> <td>Left to right</td> </tr>
<tr> <td>Equality</td> <td>==  !=</td> <td>Left to right</td> </tr> 
<tr> <td>Bitwise AND</td><td>&</td> <td>Left to right</td> </tr> 
<tr> <td>Bitwise XOR</td> <td>^</td> <td>Left to right</td></tr> 
<tr> <td>Bitwise OR</td> <td>|</td> <td>Left to right</td></tr> 
<tr> <td>Logical AND</td><td>&</td> <td>Left to right</td></tr>
<tr><td>Logical OR</td> <td>||</td> <td>Left to right</td></tr> 
<tr> <td>Conditional</td><td>?:</td> <td>Right to left</td> </tr>
<tr><td>Assignment</td> <td>=  +=  -=  *=  /=  %=>>=  &lt;&lt;=  &=  ^= |=</td><td>Right to left</td></tr>
<tr> <td>Comma</td> <td>,</td> <td>Left to right</td></tr> 
</table>

<h2>C++ Standard Template Library (STL)</h2>
The Standard Template Library (STL) is a set of C++ template classes to provide common programming data structures and functions such as lists, stacks, arrays, etc. 
It is a library of container classes, algorithms, and iterators. 
It is a generalized library and so, its components are parameterized. 
A working knowledge of <a href="https://www.geeksforgeeks.org/templates-cpp/">template classes</a> is a prerequisite  for working with STL.
<r>STL has four components</r>

Algorithms
Containers
Functions
Iterators

<r>Algorithms</r>
The header algorithm defines a collection of functions especially designed to be used on ranges of elements.They act on containers and provide means for various operations  for the contents of the containers.

Algorithm

<a href="http://quiz.geeksforgeeks.org/sort-algorithms-the-c-standard-template-library-stl/">Sorting</a>

<a href="http://quiz.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/">Searching</a>

<a href="https://www.geeksforgeeks.org/c-magicians-stl-algorithms/">Important STL Algorithms</a>

<a href="https://www.geeksforgeeks.org/useful-array-algorithms-in-c-stl/">Useful Array algorithms</a>

<a href="https://www.geeksforgeeks.org/stdpartition-in-c-stl/">Partition Operations</a>

Numeric

<a href="https://www.geeksforgeeks.org/std-valarray-class-c/">valarray class</a>

<r>Containers </r>

Containers or container classes store objects and data. 
There are in total seven standard &#8220;first-class&#8221; container classes  and three container adaptor classes and only seven header files that provide access to these containers or container adaptors.

Sequence Containers:  implement data structures which can be accessed in a sequential manner.

<a href="http://quiz.geeksforgeeks.org/vector-sequence-containers-the-c-standard-template-library-stl-set-1/">vector</a>

<a href="http://quiz.geeksforgeeks.org/list-sequence-containers-the-c-standard-template-library-stl/">list</a>

<a href="http://quiz.geeksforgeeks.org/deque-sequence-containers-the-c-standard-template-library-stl/">deque</a>

<a href="https://www.geeksforgeeks.org/array-class-c/">arrays</a>

<a href="https://www.geeksforgeeks.org/forward-list-c-set-1-introduction-important-functions/">forward_list</a>( Introduced in C++11)

Container Adaptors :  provide a different interface for sequential containers.

<a href="http://quiz.geeksforgeeks.org/queue-container-adaptors-the-c-standard-template-library-stl/">queue</a>

<a href="http://quiz.geeksforgeeks.org/priority-queue-container-adaptors-the-c-standard-template-library-stl/">priority_queue</a>

<a href="http://quiz.geeksforgeeks.org/stack-container-adaptors-the-c-standard-template-library-stl/">stack</a>

Associative Containers :  implement sorted data structures that can be quickly searched (<span class="texhtml">O(log n)</span> complexity).

<a href="http://quiz.geeksforgeeks.org/set-associative-containers-the-c-standard-template-library-stl/">set</a>

<a href="http://quiz.geeksforgeeks.org/multiset-associative-containers-the-c-standard-template-library-stl/">multiset</a>

<a href="http://quiz.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl/">map</a>

<a href="http://quiz.geeksforgeeks.org/multimap-associative-containers-the-c-standard-template-library-stl/">multimap</a>

Unordered Associative Containers :  implement unordered data structures that can be quickly searched

<a href="https://www.geeksforgeeks.org/unordered_set-in-cpp-stl/">unordered_set</a> (Introduced in C++11)
<a href="https://www.geeksforgeeks.org/unordered_multiset-and-its-uses/">unordered_multiset</a> (Introduced in C++11)

<a href="https://www.geeksforgeeks.org/unordered_map-in-cpp-stl/">unordered_map</a> (Introduced in C++11)

<a href="https://www.geeksforgeeks.org/unordered_multimap-and-its-application/">unordered_multimap</a> (Introduced in C++11)

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20191111161536/Screenshot-from-2019-11-11-16-13-18.png"><r> Flowchart of Adaptive Containers and Unordered Containers</r>

<img src="https://media.geeksforgeeks.org/wp-content/uploads/20191111161627/Screenshot-from-2019-11-11-16-15-07.png"><r> Flowchart of Sequence conatiners and ordered containers</r>

<r>Functions</r>
The STL includes classes that overload the function call operator. 
Instances of such classes are called function objects or functors. 
Functors allow the working of the associated function to be customized with the help of parameters to be passed.

<a href="https://www.geeksforgeeks.org/functors-in-cpp/">Functors</a>

<r>Iterators </r>
As the name suggests, iterators are used for working upon a sequence of values. 
They are the major feature that allow generality in STL.

<a href="https://www.geeksforgeeks.org/iterators-c-stl/">Iterators </a>

<r>Utility Library</r>
Defined in header &lt;utility>.

<a href="http://quiz.geeksforgeeks.org/pair-simple-containers-the-c-standard-template-library-stl/">pair</a>

<h2>find the circle center from 3 pts</h2> 

void findCircle(int x1, int y1, int x2, int y2, int x3, int y3) 
{ 
    int x12 = x1 - x2; 
    int x13 = x1 - x3; 
  
    int y12 = y1 - y2; 
    int y13 = y1 - y3; 
  
    int y31 = y3 - y1; 
    int y21 = y2 - y1; 
  
    int x31 = x3 - x1; 
    int x21 = x2 - x1; 
  
    // x1^2 - x3^2 
    int sx13 = pow(x1, 2) - pow(x3, 2); 
  
    // y1^2 - y3^2 
    int sy13 = pow(y1, 2) - pow(y3, 2); 
  
    int sx21 = pow(x2, 2) - pow(x1, 2); 
    int sy21 = pow(y2, 2) - pow(y1, 2); 
  
    int f = ((sx13) * (x12) 
             + (sy13) * (x12) 
             + (sx21) * (x13) 
             + (sy21) * (x13)) 
            / (2 * ((y31) * (x12) - (y21) * (x13))); 
    int g = ((sx13) * (y12) 
             + (sy13) * (y12) 
             + (sx21) * (y13) 
             + (sy21) * (y13)) 
            / (2 * ((x31) * (y12) - (x21) * (y13))); 
  
    int c = -pow(x1, 2) - pow(y1, 2) - 2 * g * x1 - 2 * f * y1; 
  
    // eqn of circle be x^2 + y^2 + 2*g*x + 2*f*y + c = 0 
    // where centre is (h = -g, k = -f) and radius r 
    // as r^2 = h^2 + k^2 - c 
    int h = -g; 
    int k = -f; 
    int sqr_of_r = h * h + k * k - c; 
  
    // r is the radius 
    float r = sqrt(sqr_of_r); 
  
    cout &lt;&lt; "Centre = (" &lt;&lt; h &lt;&lt; ", " &lt;&lt; k &lt;&lt; ")" &lt;&lt; endl; 
    cout &lt;&lt; "Radius = " &lt;&lt; r; 
} 
  
// Driver code 
int main() 
{ 
    int x1 = 1, y1 = 1; 
    int x2 = 2, y2 = 4; 
    int x3 = 5, y3 = 3; 
    findCircle(x1, y1, x2, y2, x3, y3); 
  
    return 0; 
} 

<h2>File read write</h2>
write to file
   FILE *fp;

   fp = fopen("/tmp/test.txt", "w+");
   fprintf(fp, "This is testing for fprintf...\n");
   fputs("This is testing for fputs...\n", fp);
   fclose(fp);

Read from a file
   FILE *fp;
   char buff[255];

   fp = fopen("/tmp/test.txt", "r");
   fscanf(fp, "%s", buff);
   printf("1 : %s\n", buff );

   fgets(buff, 255, (FILE*)fp);
   printf("2: %s\n", buff );
   
   fgets(buff, 255, (FILE*)fp);
   printf("3: %s\n", buff );
   fclose(fp);

<h2>read/write a file from a url</h2>
use libcurl, or just shell out and use wget or curl.

char command[1024];
snprintf(command, 1024, "wget -c '%s'", url);
system(command); // add error handling
That will take considerably less effort.

If using html parser, include curl lib:
#include &lt;curl/curl.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define FILE_SIZE 10000

int main(void)
{
  curl_global_init(CURL_GLOBAL_ALL);

  CURL * myHandle;
  CURLcode setop_result;
  FILE *file;

  if((file = fopen("webpage.html", "wb")) == NULL)
    {
      perror("Error");
      exit(EXIT_FAILURE);
    }

  if((myHandle = curl_easy_init()) == NULL)
    {
      perror("Error");
      exit(EXIT_FAILURE);
    }

  if((setop_result = curl_easy_setopt(myHandle,
      CURLOPT_URL,
      "http://cboard.cprogramming.com/")) != CURLE_OK)
    {
      perror("Error");
      exit(EXIT_FAILURE);
    }

  if((setop_result = curl_easy_setopt(myHandle,
      CURLOPT_WRITEDATA, file)) != CURLE_OK)
    {
      perror("Error");
      exit(EXIT_FAILURE);
    }

  if((setop_result = curl_easy_perform(myHandle)) != 0)
    {
      perror("Error");
      exit(EXIT_FAILURE);
    }
  curl_easy_cleanup(myHandle);
  fclose(file);
  puts("Webpage downloaded successfully to webpage.html");

  return 0;
}

<h2>Write to a binary file using fwrite()</h2>
#include &lt;stdio.h>
#include &lt;stdlib.h>

struct threeNum
{
   int n1, n2, n3;
};

int main()
{
   int n;
   struct threeNum num;
   FILE *fptr;

   if ((fptr = fopen("C:\\program.bin","wb")) == NULL){
       printf("Error! opening file");

       // Program exits if the file pointer returns NULL.
       exit(1);
   }

   for(n = 1; n < 5; ++n)
   {
      num.n1 = n;
      num.n2 = 5*n;
      num.n3 = 5*n + 1;
      fwrite(&num, sizeof(struct threeNum), 1, fptr); 
   }
   fclose(fptr); 
  
   return 0;
}

<h2>read/write a file from a url</h2>

use libcurl, or just shell out and use wget or curl

char command[1024];
snprintf(command, 1024, "wget -c '%s'", url);
system(command); // add error handling

You could use to create a fork() and execute a command like wget, curl with execl,execl,execlp and after you could use to read that file with fgets and add-line with fputs.

I think you are looking for some kind of html parser, there is a possibility to include curl lib:
#include &lt;curl/curl.h>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define FILE_SIZE 10000

int main(void)
{
curl_global_init(CURL_GLOBAL_ALL);

CURL * myHandle;
CURLcode setop_result;
FILE *file;

if((file = fopen("webpage.html", "wb")) == NULL)
{
    perror("Error");
    exit(EXIT_FAILURE);
}

if((myHandle = curl_easy_init()) == NULL)
{
    perror("Error");
    exit(EXIT_FAILURE);
}

if((setop_result = curl_easy_setopt(myHandle, CURLOPT_URL, "http://cboard.cprogramming.com/")) != CURLE_OK)
{
    perror("Error");
    exit(EXIT_FAILURE);
}

    if((setop_result = curl_easy_setopt(myHandle, CURLOPT_WRITEDATA, file))     != CURLE_OK)
{
    perror("Error");
    exit(EXIT_FAILURE);
}

if((setop_result = curl_easy_perform(myHandle)) != 0)
{
    perror("Error");
    exit(EXIT_FAILURE);
}
curl_easy_cleanup(myHandle);
fclose(file);
puts("Webpage downloaded successfully to webpage.html");

return 0;
}

<h2>scrape a web page using C</h2>

#define HTML_PAGE "codes.html"
#define START_BLOCK "<r>"
#define END_BLOCK "</r>"

int extract()
{
    FILE *html;
    int found = 0;
    char *line = NULL, *endTag, *startTag;
    size_t len = 0;
    ssize_t read;

    char searchFor[80];

    html = fopen(HTML_PAGE, "r");

    if (html)
    {
        while((read = getline(&line, &len, html)) != -1)
        {
            if (found) // found line with codes we are interested in
            {
                char   *ptr = line;
                size_t nlen = strlen (END_BLOCK);

                while (ptr != NULL) 
                {
                    sprintf(searchFor, START_BLOCK);
                    startTag = (char *)strstr(ptr, searchFor);
                    if(!startTag)
                    {
                        nlen = strlen (START_BLOCK);
                        ptr += nlen;
                        continue;
                    }

                    if (strncmp(startTag + strlen(searchFor), "CO1", 3) == 0 || strncmp(startTag + strlen(searchFor), "CO2", 3) == 0)
                        got_code(startTag + strlen(searchFor), code);
                    else {
                        nlen = strlen (START_BLOCK);
                        ptr += nlen;
                        continue;
                    }

                    sprintf(searchFor, END_BLOCK);
                    ptr = (char *)strstr(ptr, searchFor);

                    if (!ptr) { found = 0; break; }

                    nlen = strlen (END_BLOCK);                  
                    ptr += nlen;

                    if (ptr)
                    {
                        // look ahead to make sure we have more to pull out
                        sprintf(searchFor, END_BLOCK);
                        endTag = (char *)strstr(ptr, searchFor);
                        if (!endTag) { break; }
                    }
                }

                found = 0;
                break;
            }

            // find the section of the downloaded page we care about
            // the next line we read will be a blob containing the html we want
            if (strstr(line, "wiki-content") != NULL)
            {
                found = 1;
            }
        }

        fclose(html);
    }

    return 0;
}

got_code(char *html)
{
    char    code[8];
    char    *endTag;
    struct  _code_st    *currCode;
    int i;  

    endTag = (char *)strstr(html, "</r>");
    if(!endTag)return;

    sprintf(code, "%.7s", html);

    for(i=0 ; i<Data.Codes ; i++)
        if(strcasecmp(Data.Code[i].Code, code)==0)
            return;

    ADD_TO_LIST(currCode, _code_st, Data.Code, Data.Codes);
    currCode->Code = (char *)strdup(code);

    printf("Code: %s\n", code);
}
Not nearly as elegant or robust as my C# program but at least it pulls back all the information I want.

<h2>Difference between C and C++.</h2>
The main difference between both these languages is C is a procedural programming language and does not support classes and objects, while C++ is a combination of both procedural and object-oriented programming languages.
The following are the important differences between C and C++.
<table><thead><tr><th>Sr. No.</th><th>Key</th><th>C</th><th>C++</th></tr></thead><tbody><tr><td>1</td><td>Introduction</td><td>C was developed by Dennis Ritchie in around 1969 at AT&T Bell Labs.</td><td>C++ was developed by Bjarne Stroustrup in 1979.</td></tr><tr><td>2</td><td>Language Type</td><td>As mentioned before C is procedural programming.</td><td>On the other hand, C++ supports both procedural and object-oriented programming paradigms.</td></tr><tr><td>3</td><td>OOPs feature Support</td><td>As C does not support the OOPs concept so it has no support for polymorphism, encapsulation, and inheritance.</td><td>C++ has support for polymorphism, encapsulation, and inheritance as it is being an object-oriented programming language</td></tr><tr><td>4</td><td>Data Security</td><td>As C does not support encapsulation so data behave as a free entity and can be manipulated by outside code.</td><td>On another hand in the case of C++ encapsulation hides the data to ensure that data structures and operators are used as intended.</td></tr><tr><td>5</td><td>Driven type</td><td>C in general known as function-driven language.</td><td>On the other hand, C++ is known as object driven language.</td></tr><tr><td>6</td><td>Feature supported</td><td>C does not support function and operator overloading also do not have namespace feature and reference variable functionality.</td><td>On the other hand, C++ supports both function and operator overloading also have namespace feature and reference variable functionality.</td></tr></tbody></table>

<h2>Command line arguments in C/C++</h2>
The most important function of C/C++ is main() function. 
It is mostly defined with a return type of int and without parameters :

int main() { /* ... */ } 
We can also give command-line arguments in C and C++. 
Command-line arguments are given after the name of the program in command-line shell of Operating Systems.
To pass command line arguments, we typically define main() with two arguments : first argument is the number of command line arguments and second is list of command-line arguments.

int main(int argc, char *argv[]) { /* ... */ }
or
int main(int argc, char **argv) { /* ... */ }

argc (ARGument Count) is int and stores number of command-line arguments passed by the user including the name of the program. 
So if we pass a value to a program, value of argc would be 2 (one for argument and one for program name)
The value of argc should be non negative.
argv(ARGument Vector) is array of character pointers listing all the arguments.

If argc is greater than zero,the array elements from argv[0] to argv[argc-1] will contain pointers to strings.
Argv[0] is the name of the program , After that till argv[argc-1] every element is command -line arguments.

// Name of program mainreturn.cpp
#include &lt;iostream>
using namespace std;
  
int main(int argc, char** argv)
{
    cout << "You have entered " << argc
         << " arguments:" << "\n";
  
    for (int i = 0; i < argc; ++i)
        cout << argv[i] << "\n";
  
    return 0;
}

#include &lt;stdio.h>
int main( int argc, char *argv[] )  {
   if( argc == 2 ) {
      printf("The argument supplied is %s\n", argv[1]);
   }
   else if( argc > 2 ) {
      printf("Too many arguments supplied.\n");
   }
   else {
      printf("One argument expected.\n");
   }
}

$./a.out testing
The argument supplied is testing

<h2>C ่ฏญ่จๅ่ฐๅฝๆฐ๏ผC ๆๅทงๅฟๅค</h2>

<div id="callbacktoc" class="toc"><a href="#callbacktopic-0" target="_self"><span class="orange">1. ๆฆๅฟต</span></a><br><a href="#callbacktopic-1" target="_self">2. ๅฆไฝ็จๅฝๆฐๆ้่ฐ็จๅฝๆฐ</a><br><a href="#callbacktopic-2" target="_self">3. ๅฝๆฐๆ้ไฝไธบๆไธชๅฝๆฐ็ๅๆฐ</a><br><a href="#callbacktopic-3" target="_self">4. ๅฝๆฐๆ้ไฝไธบๅฝๆฐ่ฟๅ็ฑปๅ</a><br><a href="#callbacktopic-4" target="_self">5. ๅฝๆฐๆ้ๆฐ็ป</a><br><a href="#callbacktopic-5" target="_self">6. ๅฝๆฐๆ้ๆป็ป</a><br><a href="#callbacktopic-6" target="_self"><span class="orange">ไบใๅ่ฐๅฝๆฐ</span></a><br><a href="#callbacktopic-7" target="_self">1. ไปไนๆฏๅ่ฐๅฝๆฐ</a><br><a href="#callbacktopic-8" target="_self">2. ไธบไปไน่ฆ็จๅ่ฐๅฝi๏ผ</a><br><a href="#callbacktopic-9" target="_self">3. ๆไนไฝฟ็จๅ่ฐๅฝh4๏ผ</a><br><a href="#callbacktopic-10" target="_self">4. ไธ้ขๆฏไธไธชๅๅ่ฟ็ฎ็็ฎๅๅ่ฐๅฝๆฐไพๅญ๏ผ</a><br><a href="#callbacktopic-11" target="_self">5. ๅ่ฐๅฝๆฐๅฎไพ๏ผๅพๆ็จ๏ผ</a><br></div></center><br>

<h3><span class="orange">ไธใๅฝๆฐๆ้</span></h3>
ๅจ่ฎฒๅ่ฐๅฝๆฐไนๅ๏ผๆไปฌ้่ฆไบ่งฃๅฝๆฐๆ้ใ
ๆไปฌ้ฝ็ฅ้๏ผC่ฏญ่จ็็ต้ญๆฏๆ้๏ผๆไปฌ็ปๅธธไฝฟ็จๆดๅๆ้๏ผๅญ็ฌฆไธฒๆ้๏ผ็ปๆไฝๆ้็ญใ

<k>int *p1;
char *p2;
STRUCT *p3; // STRUCTไธบๆไปฌๅฎไน็็ปๆไฝ</k>
ไฝๆฏๅฅฝๅๆไปฌไธ่ฌๅพๅฐไฝฟ็จๅฝๆฐๆ้๏ผๆไปฌไธ่ฌไฝฟ็จๅฝๆฐ้ฝๆฏ็ดๆฅไฝฟ็จๅฝๆฐ่ฐ็จใ
ไธ้ขๆไปฌๆฅไบ่งฃไธไธๅฝๆฐๆ้็ๆฆๅฟตๅไฝฟ็จๆนๆณใ
<h3 id="callbacktopic-0"><span class="orange">1. ๆฆๅฟต</span></h3>
ๅฝๆฐๆ้ๆฏๆๅๅฝๆฐ็ๆ้ๅ้ใ
้ๅธธๆไปฌ่ฏด็ๆ้ๅ้ๆฏๆๅไธไธชๆดๅใๅญ็ฌฆๅๆๆฐ็ป็ญๅ้๏ผ่ๅฝๆฐๆ้ๆฏๆๅๅฝๆฐใ
ๅฝๆฐๆ้ๅฏไปฅๅไธ่ฌๅฝๆฐไธๆท๏ผ็จไบ่ฐ็จๅฝๆฐใไผ้ๅๆฐใ
ๅฝๆฐๆ้็ๅฎไนๆนๅผไธบ๏ผ
ๅฝๆฐ่ฟๅๅผ็ฑปๅ   (* ๆ้ๅ้ๅ) (ๅฝๆฐๅๆฐๅ่กจ);
โๅฝๆฐ่ฟๅๅผ็ฑปๅโ่กจ็คบ่ฏฅๆ้ๅ้ๅฏไปฅๆๅๅทๆไปไน่ฟๅๅผ็ฑปๅ็ๅฝๆฐ๏ผ
โๅฝๆฐๅๆฐๅ่กจโ่กจ็คบ่ฏฅๆ้ๅ้ๅฏไปฅๆๅๅทๆไปไนๅๆฐๅ่กจ็ๅฝๆฐใ
่ฟไธชๅๆฐๅ่กจไธญๅช้่ฆๅๅฝๆฐ็ๅๆฐ็ฑปๅๅณๅฏใ
ๆไปฌ็ๅฐ๏ผๅฝๆฐๆ้็ๅฎไนๅฐฑๆฏๅฐโๅฝๆฐๅฃฐๆโไธญ็โๅฝๆฐๅโๆนๆโ๏ผๆ้ๅ้ๅ๏ผโใ
ไฝๆฏ่ฟ้้่ฆๆณจๆ็ๆฏ๏ผโ๏ผๆ้ๅ้ๅ๏ผโไธค็ซฏ็ๆฌๅทไธ่ฝ็็ฅ๏ผๆฌๅทๆนๅไบ่ฟ็ฎ็ฌฆ็ไผๅ็บงใ
ๅฆๆ็็ฅไบๆฌๅท๏ผๅฐฑไธๆฏๅฎไนๅฝๆฐๆ้่ๆฏไธไธชๅฝๆฐๅฃฐๆไบ๏ผๅณๅฃฐๆไบไธไธช่ฟๅๅผ็ฑปๅไธบๆ้ๅ็ๅฝๆฐใ
้ฃไนๆไนๅคๆญไธไธชๆ้ๅ้ๆฏๆๅๅ้็ๆ้ๅ้่ฟๆฏๆๅๅฝๆฐ็ๆ้ๅ้ๅข๏ผ
้ฆๅ็ๅ้ๅๅ้ขๆๆฒกๆโโ๏ผๅฆๆๆโโ่ฏดๆๆฏๆ้ๅ้๏ผ
ๅถๆฌก็ๅ้ๅ็ๅ้ขๆๆฒกๆๅธฆๆๅฝขๅ็ฑปๅ็ๅๆฌๅท๏ผๅฆๆๆๅฐฑๆฏๆๅๅฝๆฐ็ๆ้ๅ้๏ผๅณๅฝๆฐๆ้๏ผๅฆๆๆฒกๆๅฐฑๆฏๆๅๅ้็ๆ้ๅ้ใ
ๆๅ้่ฆๆณจๆ็ๆฏ๏ผๆๅๅฝๆฐ็ๆ้ๅ้ๆฒกๆ ++ ๅ โ ่ฟ็ฎใ
ไธ่ฌไธบไบๆนไพฟไฝฟ็จ๏ผๆไปฌไผ้ๆฉ๏ผ
typedef  ๅฝๆฐ่ฟๅๅผ็ฑปๅ  (* ๆ้ๅ้ๅ) (ๅฝๆฐๅๆฐๅ่กจ);
ๆฏๅฆ๏ผ
<k>typedef int (*Fun1)(int); //ๅฃฐๆไนๅฏๅๆint (*Fun1)(int x)๏ผไฝไนๆฏไธไธ่ฌไธ่ฟๆทใ
typedef int (*Fun2)(int, int); //ๅๆฐไธบไธคไธชๆดๅ๏ผ่ฟๅๅผไธบๆดๅtypedef void (*Fun3)(void); //ๆๅๆฐๅ่ฟๅๅผtypedef void* (*Fun4)(void*); //ๅๆฐๅ่ฟๅๅผ้ฝไธบvoid*ๆ้</k>
<h4 id="callbacktopic-1">2. ๅฆไฝ็จๅฝๆฐๆ้่ฐ็จๅฝๆฐ</h4>
็ปๅคงๅฎถไธพไธไธชไพๅญ๏ผ
<k>int Func(int x);   /*ๅฃฐๆไธไธชๅฝๆฐ*/
int (*p) (int x);  /*ๅฎไนไธไธชๅฝๆฐๆ้*/
p = Func; /*ๅฐFuncๅฝๆฐ็้ฆๅฐๅ่ต็ปๆ้ๅ้p*/
p = &Func; /*ๅฐFuncๅฝๆฐ็้ฆๅฐๅ่ต็ปๆ้ๅ้p*/
</k>
่ตๅผๆถๅฝๆฐ Func ไธๅธฆๆฌๅท๏ผไนไธๅธฆๅๆฐใ
็ฑไบๅฝๆฐๅ Func ไปฃ่กจๅฝๆฐ็้ฆๅฐๅ๏ผๅๆญค็ป่ฟ่ตๅผไปฅๅ๏ผๆ้ๅ้ p ๅฐฑๆๅๅฝๆฐ Func() ไปฃ็็้ฆๅฐๅไบใ
ไธ้ขๆฅๅไธไธช็จๅบ๏ผ็ไบ่ฟไธช็จๅบไฝไปฌๅฐฑๆ็ฝๅฝๆฐๆ้ๆไนไฝฟ็จไบ๏ผ
<k>#include &lt;stdio.h>
int Max(int, int);  //ๅฝๆฐๅฃฐๆ
int main(void){
    int(*p)(int, int);  //ๅฎไนไธไธชๅฝๆฐๆ้
    int a, b, c;
    p = Max;  //ๆๅฝๆฐMax่ต็ปๆ้ๅ้p, ไฝฟpๆๅMaxๅฝๆฐ
    printf("please enter a and b:");
    scanf("%d%d", &a, &b);
    c = (*p)(a, b);  //้่ฟๅฝๆฐๆ้่ฐ็จMaxๅฝๆฐ
    printf("a = %d\nb = %d\nmax = %d\n", a, b, c);
    return 0;
}
int Max(int x, int y)  //ๅฎไนMaxๅฝๆฐ{
    int z;
    if (x > y)    {        z = x;
    }
    else    {        z = y;
    }
    return z;
}
</k>
็นๅซๆณจๆ็ๆฏ๏ผๅไธบๅฝๆฐๅๆฌ่บซๅฐฑๅฏไปฅ่กจ็คบ่ฏฅๅฝๆฐๅฐๅ๏ผๆ้๏ผ๏ผๅๆญคๅจ่ทๅๅฝๆฐๆ้ๆถ๏ผๅฏไปฅ็ดๆฅ็จๅฝๆฐๅ๏ผไนๅฏไปฅๅๅฝๆฐ็ๅฐๅใ

<k>p = Maxๅฏไปฅๆนๆ p = &Maxc = (*p)(a, b) ๅฏไปฅๆนๆ c = p(a, b)</k>
<h4 id="callbacktopic-2">3. ๅฝๆฐๆ้ไฝไธบๆไธชๅฝๆฐ็ๅๆฐ</h4>
ๆข็ถๅฝๆฐๆ้ๅ้ๆฏไธไธชๅ้๏ผๅฝ็ถไนๅฏไปฅไฝไธบๆไธชๅฝๆฐ็ๅๆฐๆฅไฝฟ็จ็ใ
็คบไพ๏ผ
<k>#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef void(*FunType)(int);
//ๅๅไธไธชtypedefๅณ้ฎๅญ๏ผ่ฟๆทๅฐฑๅฎไนไธไธชๅไธบFunTypeๅฝๆฐๆ้็ฑปๅ๏ผ่ไธๆฏไธไธชFunTypeๅ้ใ
//ๅฝขๅผๅ typedef int* PINT;
void myFun(int x);
void hisFun(int x);
void herFun(int x);
void callFun(FunType fp,int x);
int main(){    callFun(myFun,100);
//ไผๅฅๅฝๆฐๆ้ๅธธ้๏ผไฝไธบๅ่ฐๅฝๆฐ    callFun(hisFun,200);
    callFun(herFun,300);
    return 0;
}
void callFun(FunType fp,int x){    fp(x);
//้่ฟfp็ๆ้ๆง่กไผ้่ฟๆฅ็ๅฝๆฐ๏ผๆณจๆfpๆๆ็ๅฝๆฐๆไธไธชๅๆฐ}
void myFun(int x){
    printf("myFun: %d\n",x);
}
void hisFun(int x){
    printf("hisFun: %d\n",x);
}
void herFun(int x){
    printf("herFun: %d\n",x);
}
</k>
่พๅบ๏ผ
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/wqfIPAmgib2XOGmtb2WHcufMNUPn3gqibd1DcbLnouPMbdlNtOKp2pKgfxJvqXmoocwqqGTJxmcz5OAGsYEtfNbw/640">

<h4 id="callbacktopic-3">4. ๅฝๆฐๆ้ไฝไธบๅฝๆฐ่ฟๅ็ฑปๅ</h4>
ๆไบไธ้ข็ๅบ็ก๏ผ่ฆๅๅบ่ฟๅ็ฑปๅไธบๅฝๆฐๆ้็ๅฝๆฐๅบ่ฏฅไธ้พไบ๏ผไธ้ข่ฟไธชไพๅญๅฐฑๆฏ่ฟๅ็ฑปๅไธบๅฝๆฐๆ้็ๅฝๆฐ๏ผ
<k>void (* func5(int, int, float ))(int, int){    ...}
</k>
ๅจ่ฟ้๏ผ <em><k>func5</k></em> ไปฅ <em><k>(int, int, float)</k></em> ไธบๅๆฐ๏ผๅถ่ฟๅ็ฑปๅไธบ <em><k>void (\*)(int, int)</k></em> ใ
ๅจC่ฏญ่จไธญ๏ผๅ้ๆ่ๅฝๆฐ็ๅฃฐๆไนๆฏไธไธชๅคงๅญฆ้ฎ๏ผๆณ่ฆไบ่งฃๆดๅคๅณไบๅฃฐๆ็่ฏ้ข๏ผๅฏไปฅๅ่ๆไนๅ็ๆ็ซ - Cไธๅฎถ็ผ็จใ่ฏปไนฆ็ฌ่ฎฐ(1-3็ซ)ใ
่ฟๆฌไนฆ็็ฌฌไธ็ซ่ฑไบๆดๆดไธ็ซ็ๅๅฎนๆฅ่ฎฒ่งฃๅฆไฝ่ฏปๆC่ฏญ่จ็ๅฃฐๆใ
<h4 id="callbacktopic-4">5. ๅฝๆฐๆ้ๆฐ็ป</h4>ๅจๅผๅง่ฎฒ่งฃๅ่ฐๅฝๆฐๅ๏ผๆๅไป็ปไธไธๅฝๆฐๆ้ๆฐ็ปใ
ๆข็ถๅฝๆฐๆ้ไนๆฏๆ้๏ผ้ฃๆไปฌๅฐฑๅฏไปฅ็จๆฐ็ปๆฅๅญๆพๅฝๆฐๆ้ใ
ไธ้ขๆไปฌ็ไธไธชๅฝๆฐๆ้ๆฐ็ป็ไพๅญ๏ผ
<k>/* ๆนๆณ1 */
void (*func_array_1[5])(int, int, float);
/* ๆนๆณ2 */
typedef void (*p_func_array)(int, int, float);
p_func_array func_array_2[5];
</k>
ไธ้ขไธค็งๆนๆณ้ฝๅฏไปฅ็จๆฅๅฎไนๅฝๆฐๆ้ๆฐ็ป๏ผๅฎไปฌๅฎไนไบไธไธชๅ็ดไธชๆฐไธบ5๏ผ็ฑปๅๆฏ *  <k>void (\*)(int, int, float)</k>  * ็ๅฝๆฐๆ้ๆฐ็ปใ

<h4 id="callbacktopic-5">6. ๅฝๆฐๆ้ๆป็ป</h4>
ๅฝๆฐๆ้ๅธธ้ ๏ผMax๏ผ
ๅฝๆฐๆ้ๅ้๏ผp๏ผ

ๆฐๅ่ฐ็จๅฆๆ้ฝๅพๅฆ(*myFun)(10)่ฟๆท๏ผ้ฃไนฆๅไธ่ฏป่ตทๆฅ้ฝๆฏไธๆนไพฟๅไธไนๆฏ็ใ
ๆไปฅC่ฏญ่จ็่ฎพ่ฎก่ไปฌๆไผ่ฎพ่ฎกๆๅๅฏๅ่ฎธmyFun(10)่ฟ็งๅฝขๅผๅฐ่ฐ็จ๏ผ่ฟๆทๆนไพฟๅคไบ๏ผๅนถไธๆฐๅญฆไธญ็ๅฝๆฐๅฝขๅผไธๆท๏ผใ
ๅจๅฝๆฐๆ้ๅ้ไนๅฏไปฅๅญๅฅไธไธชๆฐ็ปๅใ
ๆฐ็ป็ๅฃฐๆๆนๆณ๏ผint (*fArray[10]) ( int );

<h3 id="callbacktopic-6"><span class="orange">ไบใๅ่ฐๅฝๆฐ</span></h3>
<h4 id="callbacktopic-7">1. ไปไนๆฏๅ่ฐๅฝๆฐ</h4>ๆไปฌๅๆฅ็็็พๅบฆ็พ็งๆฏๅฆไฝๅฎไนๅ่ฐๅฝๆฐ็๏ผ
ๅ่ฐๅฝๆฐๅฐฑๆฏไธไธช้่ฟๅฝๆฐๆ้่ฐ็จ็ๅฝๆฐใ
ๅฆๆไฝๆๅฝๆฐ็ๆ้๏ผๅฐๅ๏ผไฝไธบๅๆฐไผ้็ปๅฆไธไธชๅฝๆฐ๏ผๅฝ่ฟไธชๆ้่ขซ็จๆฅ่ฐ็จๅถๆๆๅ็ๅฝๆฐๆถ๏ผๆไปฌๅฐฑ่ฏด่ฟๆฏๅ่ฐๅฝๆฐใ
ๅ่ฐๅฝๆฐไธๆฏ็ฑ่ฏฅๅฝๆฐ็ๅฎ็ฐๆน็ดๆฅ่ฐ็จ๏ผ่ๆฏๅจ็นๅฎ็ไบไปถๆๆกไปถๅ็ๆถ็ฑๅฆๅค็ไธๆน่ฐ็จ็๏ผ็จไบๅฏน่ฏฅไบไปถๆๆกไปถ่ฟ่กๅๅบใ
่ฟๆฎต่ฏๆฏ่พ้ฟ๏ผไนๆฏ่พ็ปๅฃใ
ไธ้ขๆ้่ฟไธๅนๅพๆฅ่ฏดๆไปไนๆฏๅ่ฐ๏ผ
<img src="https://mmbiz.qpic.cn/mmbiz_png/wqfIPAmgib2XOGmtb2WHcufMNUPn3gqibdXnsvCOVnvvoALof6um1FWk78jxRBQa5Uibnus21nc9HopcHbBtJVYjA/640">

ๅ่ฎพๆไปฌ่ฆไฝฟ็จไธไธชๆๅบๅฝๆฐๆฅๅฏนๆฐ็ป่ฟ่กๆๅบ๏ผ้ฃไนๅจไธป็จๅบ(Main program)ไธญ๏ผๆไปฌๅ้่ฟๅบ๏ผ้ๆฉไธไธชๅบๆๅบๅฝๆฐ(Library function)ใ
ไฝๆๅบ็ฎๆณๆๅพๅค๏ผๆๅๆณกๆๅบ๏ผ้ๆฉๆๅบ๏ผๅฟซ้ๆๅบ๏ผๅฝๅนถๆๅบใ
ๅๆถ๏ผๆไปฌไนๅฏ่ฝ้่ฆๅฏน็นๆฎ็ๅฏน่ฑก่ฟ่กๆๅบ๏ผๆฏๅฆ็นๅฎ็็ปๆไฝ็ญใ
ๅบๅฝๆฐไผๆนๆฎๆไปฌ็้่ฆ้ๆฉไธ็งๆๅบ็ฎๆณ๏ผ็ถๅ่ฐ็จๅฎ็ฐ่ฏฅ็ฎๆณ็ๅฝๆฐๆฅๅฎๆๆๅบๅทฅไฝใ
่ฟไธช่ขซ่ฐ็จ็ๆๅบๅฝๆฐๅฐฑๆฏๅ่ฐๅฝๆฐ(Callback function)ใ
็ปๅ่ฟๅนๅพๅไธ้ขๅฏนๅ่ฐๅฝๆฐ็่งฃ้๏ผๆไปฌๅฏไปฅๅ็ฐ๏ผ่ฆๅฎ็ฐๅ่ฐๅฝๆฐ๏ผๆๅณ้ฎ็ไธ็นๅฐฑๆฏ่ฆๅฐๅฝๆฐ็ๆ้ไผ้็ปไธไธชๅฝๆฐ(ไธๅพไธญๆฏๅบๅฝๆฐ)๏ผ็ถๅ่ฟไธชๅฝๆฐๅฐฑๅฏไปฅ้่ฟ่ฟไธชๆ้ๆฅ่ฐ็จๅ่ฐๅฝๆฐไบใ
ๆณจๆ๏ผๅ่ฐๅฝๆฐๅนถไธๆฏC่ฏญ่จ็นๆ็๏ผๅไนไปปไฝ่ฏญ่จ้ฝๆๅ่ฐๅฝๆฐใ
ๅจC่ฏญ่จไธญ๏ผๆไปฌ้่ฟไฝฟ็จๅฝๆฐๆ้ๆฅๅฎ็ฐๅ่ฐๅฝๆฐใ
ๆ็็่งฃๆฏ๏ผๆไธๆฎตๅฏๆง่ก็ไปฃ็ๅๅๆฐไผ้้ฃๆทไผ็ปๅถไปไปฃ็๏ผ่่ฟๆฎตไปฃ็ไผๅจๆไธชๆถๅป่ขซ่ฐ็จๆง่ก๏ผ่ฟๅฐฑๅซๅๅ่ฐใ
ๅฆๆไปฃ็็ซๅณ่ขซๆง่กๅฐฑ็งฐไธบๅๆญฅๅ่ฐ๏ผๅฆๆ่ฟๅๅๆง่ก๏ผๅ็งฐไนไธบๅผๆญฅๅ่ฐใ
ๅ่ฐๅฝๆฐๅฐฑๆฏไธไธช้่ฟๅฝๆฐๆ้่ฐ็จ็ๅฝๆฐใ
ๅฆๆไฝๆๅฝๆฐ็ๆ้๏ผๅฐๅ๏ผไฝไธบๅๆฐไผ้็ปๅฆไธไธชๅฝๆฐ๏ผๅฝ่ฟไธชๆ้่ขซ็จๆฅ่ฐ็จๅถๆๆๅ็ๅฝๆฐๆถ๏ผๆไปฌๅฐฑ่ฏด่ฟๆฏๅ่ฐๅฝๆฐใ
ๅ่ฐๅฝๆฐไธๆฏ็ฑ่ฏฅๅฝๆฐ็ๅฎ็ฐๆน็ดๆฅ่ฐ็จ๏ผ่ๆฏๅจ็นๅฎ็ไบไปถๆๆกไปถๅ็ๆถ็ฑๅฆๅค็ไธๆน่ฐ็จ็๏ผ็จไบๅฏน่ฏฅไบไปถๆๆกไปถ่ฟ่กๅๅบใ

<h4 id="callbacktopic-8">2. ไธบไปไน่ฆ็จๅ่ฐๅฝi๏ผ</h4>
ๅไธบๅฏไปฅๆ่ฐ็จ่ไธ่ขซ่ฐ็จ่ๅๅผ๏ผๆไปฅ่ฐ็จ่ไธๅณๅฟ่ฐๆฏ่ขซ่ฐ็จ่ใ
ๅฎๅช้็ฅ้ๅญๅจไธไธชๅทๆ็นๅฎๅๅๅ้ๅถๆกไปถ็่ขซ่ฐ็จๅฝๆฐใ

็ฎ่่จไน๏ผๅ่ฐๅฝๆฐๅฐฑๆฏๅ่ฎธ็จๆทๆ้่ฆ่ฐ็จ็ๆนๆณ็ๆ้ไฝไธบๅๆฐไผ้็ปไธไธชๅฝๆฐ๏ผไปฅไพฟ่ฏฅๅฝๆฐๅจๅค็็ธไผผไบไปถ็ๆถๅๅฏไปฅ็ตๆดป็ไฝฟ็จไธๅ็ๆนๆณใ
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/wqfIPAmgib2XOGmtb2WHcufMNUPn3gqibdlrWqmeJkae6bMeJB6EMIia0SwTCSWKkic6Xff9w4w1j9w6VFqk8UrIkQ/640">

<k>int Callback()    // /&lt; ๅ่ฐๅฝๆฐ{    // TODO    return 0;
}
int main()     // /&lt;  ไธปๅฝๆฐ{    // TODO    Library(Callback);  // /&lt; ๅบๅฝๆฐ้่ฟๅฝๆฐๆ้่ฟ่กๅ่ฐ    // TODO    return 0;
}
</k>
ๅ่ฐไผผไนๅชๆฏๅฝๆฐ้ด็่ฐ็จ๏ผๅๆฎ้ๅฝๆฐ่ฐ็จๆฒกๅฅๅบๅซใ
ไฝไป็ป็๏ผๅฏไปฅๅ็ฐไธค่ไน้ด็ไธไธชๅณ้ฎ็ไธๅ๏ผๅจๅ่ฐไธญ๏ผไธป็จๅบๆๅ่ฐๅฝๆฐๅๅๆฐไธๆทไผๅฅๅบๅฝๆฐใ
่ฟๆทไธๆฅ๏ผๅช่ฆๆไปฌๆนๅไผ่ฟๅบๅฝๆฐ็ๅๆฐ๏ผๅฐฑๅฏไปฅๅฎ็ฐไธๅ็ๅ่ฝ๏ผ่ฟๆทๆๆฒกๆ่งๅพๅพ็ตๆดป๏ผ
ๅนถไธๅฝๅบๅฝๆฐๅพๅคๆๆ่ไธๅฏ่ง็ๆถๅๅฉ็จๅ่ฐๅฝๆฐๅฐฑๆพๅพๅๅไผ็งใ

<h4 id="callbacktopic-9">3. ๆไนไฝฟ็จๅ่ฐๅฝh4๏ผ</h4>
<k>int Callback_1(int a)   // /&lt; ๅ่ฐๅฝๆฐ1{
    printf("Hello, this is Callback_1: a = %d ", a);
    return 0;
}
int Callback_2(int b)  // /&lt; ๅ่ฐๅฝๆฐ2{
    printf("Hello, this is Callback_2: b = %d ", b);
    return 0;
}
int Callback_3(int c)   // /&lt; ๅ่ฐๅฝๆฐ3{
    printf("Hello, this is Callback_3: c = %d ", c);
    return 0;
}
int Handle(int x, int (*Callback)(int))  // /&lt; ๆณจๆ่ฟ้็จๅฐ็ๅฝๆฐๆ้ๅฎไน{    Callback(x);
}
int main(){    Handle(4, Callback_1);
    Handle(5, Callback_2);
    Handle(6, Callback_3);
    return 0;
}
</k>
Handle() ้้ข็ๅๆฐๆฏไธไธชๆ้๏ผๅจ  main() ๅฝๆฐ้่ฐ็จ Handle() ๅฝๆฐ็ๆถๅ๏ผ็ปๅฎไผๅฅไบๅฝๆฐ  Callback_1()/Callback_2()/Callback_3() ็ๅฝๆฐๅ๏ผ่ฟๆถๅ็ๅฝๆฐๅๅฐฑๆฏๅฏนๅบๅฝๆฐ็ๆ้๏ผไนๅฐฑๆฏ่ฏด๏ผๅ่ฐๅฝๆฐๅถๅฎๅฐฑๆฏๅฝๆฐๆ้็ไธ็ง็จๆณใ

<h4 id="callbacktopic-10">ๅๅ่ฟ็ฎ</h4>
<k>#include &lt;stdio.h>
#include &lt;stdlib.h>
/* * ๅฝๆฐๆ้็ปๆไฝ */
typedef struct _OP {    float (*p_add)(float, float);
     float (*p_sub)(float, float);
     float (*p_mul)(float, float);
     float (*p_div)(float, float); }
 OP; /* * ๅๅไน้คๅฝๆฐ */
float ADD(float a, float b) {    return a + b;
}
float SUB(float a, float b) {    return a - b;
}
float MUL(float a, float b) {    return a * b;
}
float DIV(float a, float b) {    return a / b;
}
/* * ๅๅงๅๅฝๆฐๆ้ */
void init_op(OP *op){    op->p_add = ADD;
    op->p_sub = SUB;
    op->p_mul = &MUL;
    op->p_div = &DIV;
}
/* * ๅบๅฝๆฐ */
float add_sub_mul_div(float a, float b, float (*op_func)(float, float)){    return (*op_func)(a, b);
}
int main(int argc, char *argv[]) {    OP *op = (OP *)malloc(sizeof(OP));
     init_op(op);
        /* ็ดๆฅไฝฟ็จๅฝๆฐๆ้่ฐ็จๅฝๆฐ */
 
    printf("ADD = %f, SUB = %f, MUL = %f, DIV = %f\n", (op->p_add)(1.3, 2.2), (*op->p_sub)(1.3, 2.2),             (op->p_mul)(1.3, 2.2), (*op->p_div)(1.3, 2.2));
         /* ่ฐ็จๅ่ฐๅฝๆฐ */
 
    printf("ADD = %f, SUB = %f, MUL = %f, DIV = %f\n",             add_sub_mul_div(1.3, 2.2, ADD),             add_sub_mul_div(1.3, 2.2, SUB),             add_sub_mul_div(1.3, 2.2, MUL),             add_sub_mul_div(1.3, 2.2, DIV));
    return 0; }
</k>
<h4 id="callbacktopic-11">ๅฎไพ</h4>
ไธไธช GPRS ๆจกๅ่็ฝ็ๅฐ้กน็ฎ๏ผไฝฟ็จ่ฟ็ๅๅญฆๅคงๆฆ็ฅ้ 2Gใ4GใNB ็ญๆจกๅ่ฆๆณๅฎ็ฐๆ็บฟ่็ฝๅ่ฝ้ฝ้่ฆ็ปๅๆจกๅไธ็ตๅๅงๅใๆณจๅ็ฝ็ปใๆฅ่ฏข็ฝ็ปไฟกๆฏ่ดจ้ใ่ฟๆฅๆๅกๅจ็ญๆญฅ้ชค๏ผ่ฟ้็็ไพๅญๅฐฑๆฏ๏ผๅฉ็จไธไธช็ถๆๆบๅฝๆฐ๏ผๆนๆฎไธๅ็ถๆไพๆฌก่ฐ็จไธๅๅฎ็ฐๆนๆณ็ๅฝๆฐ๏ผ๏ผ้่ฟๅ่ฐๅฝๆฐ็ๆนๅผไพๆฌก่ฐ็จไธๅ็ๅฝๆฐ๏ผๅฎ็ฐๆจกๅ่็ฝๅ่ฝ๏ผๅฆไธ๏ผ
<k>/*  ๅทฅไฝ็ถๆๅค็  */
typedef struct{    uint8_t mStatus;
    uint8_t (* Funtion)(void); //ๅฝๆฐๆ้็ๅฝขๅผ}
 M26_WorkStatus_TypeDef;   //M26็ๅทฅไฝ็ถๆ้ๅ่ฐ็จๅฝๆฐ/* >M26ๅทฅไฝ็ถๆ้ๅๅฝๆฐ*/
M26_WorkStatus_TypeDef M26_WorkStatus_Tab[] ={        {GPRS_NETWORK_CLOSE,  M26_PWRKEY_Off  }
,    //ๆจกๅๅณๆบ    {GPRS_NETWORK_OPEN,  M26_PWRKEY_On  }
,      //ๆจกๅๅผๆบ    {GPRS_NETWORK_Start,   M26_Work_Init  }
,    //็ฎก่ๅๅงๅ    {GPRS_NETWORK_CONF,  M26_NET_Config  }
,     //ATๆไปค้็ฝฎ    {GPRS_NETWORK_LINK_CTC,  M26_LINK_CTC  }
,   //่ฟๆฅ่ฐๅบฆไธญๅฟ      {GPRS_NETWORK_WAIT_CTC, M26_WAIT_CTC  }
,    //็ญๅพ่ฐๅบฆไธญๅฟๅๅค     {GPRS_NETWORK_LINK_FEM, M26_LINK_FEM  }
,    //่ฟๆฅๅ็ฝฎๆบ    {GPRS_NETWORK_WAIT_FEM, M26_WAIT_FEM  }
,    //็ญๅพๅ็ฝฎๆบๅๅค    {GPRS_NETWORK_COMM,  M26_COMM   }
,          //ๆญฃๅธธๅทฅไฝ        {GPRS_NETWORK_WAIT_Sig,  M26_WAIT_Sig  }
,   //็ญๅพไฟกๅทๅๅค    {GPRS_NETWORK_GetSignal,  M26_GetSignal  }
, //่ทๅไฟกๅทๅผ    {GPRS_NETWORK_RESTART,  M26_RESET   }
,      //ๆจกๅ้ๅฏ}
/* >M26ๆจกๅๅทฅไฝ็ถๆๆบ๏ผไพๆฌก่ฐ็จ้้ข็12ไธชๅฝๆฐ   */
uint8_t M26_WorkStatus_Call(uint8_t Start){    uint8_t i = 0;
    for(i = 0; i &lt; 12; i++)    {        if(Start == M26_WorkStatus_Tab[i].mStatus)        {                return M26_WorkStatus_Tab[i].Funtion();
        }
    }
    return 0;
}
</k>
ๆไปฅ๏ผๅฆๆๆไบบๆณๅไธช NB ๆจกๅ่็ฝ้กน็ฎ๏ผๅฏไปฅ copy ไธ้ข็ๆกๆถ๏ผๅช้่ฆไฟฎๆนๅ่ฐๅฝๆฐๅ้จ็ๅทไฝๅฎ็ฐ๏ผๆ่ๅขๅใๅๅฐๅ่ฐๅฝๆฐ๏ผๅฐฑๅฏไปฅๅพ็ฎๆดๅฟซ้็ๅฎ็ฐๆจกๅ่็ฝใ

<h2><span class="brown">SQL with C Test Program 1: Select a row with one column</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int value;
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

main () {

       strcpy ((char *)userid.arr, "mmani");
       userid.len = strlen ((char *)userid.arr);
       strcpy ((char *)passwd.arr, "mmani");
       passwd.len = strlen ((char *)passwd.arr);

       EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

       EXEC SQL select max (b) into :value from r;

       printf ("connected\n");

       printf ("max (b) = %d\n", value);
}

Ensure that your library path is set (refer slides), and make it, and then execute it. Note
that we need a table called r with at least one column called b for this.

<h2><span class="brown">SQL with C Test Program 2: Select a row with multiple columns</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int val1, val2;
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

void sqlerror ();
void sqlwarning ();

main () {

       strcpy ((char *)userid.arr, "mmani");

      userid.len = strlen ((char *)userid.arr);
      strcpy ((char *)passwd.arr, "mmani");
      passwd.len = strlen ((char *)passwd.arr);

      EXEC SQL WHENEVER SQLERROR DO sqlerror ();
      EXEC SQL WHENEVER SQLWARNING DO sqlwarning ();

      EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

      EXEC SQL SELECT a, b into :val1, :val2 from r where a = 2 and b =
10;

      printf ("val1 = %d::val2 = %d\n", val1, val2);

}

void sqlerror () {
      printf ("stop error:\t%25i\n", sqlca.sqlcode);
      return;
}

void sqlwarning () {
      printf ("stop warning:\t%25i\n", sqlca.sqlcode);
      return;
}

<h2><span class="brown">SQL with C Test Program 3: Introducing Cursors</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int pnumber;
      char pname [30];
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

void sqlerror ();
void sqlwarning ();

main () {

      strcpy ((char *)userid.arr, "mmani");
      userid.len = strlen ((char *)userid.arr);
      strcpy ((char *)passwd.arr, "mmani");
      passwd.len = strlen ((char *)passwd.arr);

      EXEC SQL WHENEVER SQLERROR DO sqlerror ();
      EXEC SQL WHENEVER SQLWARNING DO sqlwarning ();
      EXEC SQL WHENEVER NOT FOUND DO BREAK;

      EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

      EXEC SQL DECLARE myCursor CURSOR FOR select pNumber, pName from
professor;

      EXEC SQL OPEN myCursor;
      while (1) {
            EXEC SQL FETCH myCursor INTO :pnumber, :pname;

            printf ("number = %d::name = %s\n", pnumber, pname);
      }
      EXEC SQL CLOSE myCursor;

}

void sqlerror () {
      printf ("stop error:\t%25i\n", sqlca.sqlcode);
      return;
}

void sqlwarning () {
      printf ("stop warning:\t%25i\n", sqlca.sqlcode);
      return;
}

<h2><span class="brown">SQL with C Test Program 4: Updating with a cursor</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int pnumber;
      char pname [30];
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

void sqlerror ();
void sqlwarning ();

main () {

      int n = 0;

      strcpy ((char *)userid.arr, "mmani");
      userid.len = strlen ((char *)userid.arr);
      strcpy ((char *) passwd.arr, "mmani");
      passwd.len = strlen ((char *)passwd.arr);

      EXEC SQL WHENEVER SQLERROR DO sqlerror ();
      EXEC SQL WHENEVER SQLWARNING DO sqlwarning ();
      EXEC SQL WHENEVER NOT FOUND DO BREAK;

      EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

      EXEC SQL DECLARE myCursor CURSOR FOR select pNumber, pName from
professor FOR UPDATE OF pnumber;

      EXEC SQL OPEN myCursor;
      while (1) {

            EXEC SQL FETCH myCursor INTO :pnumber, :pname;

            pnumber = pnumber + 1;
            printf ("number = %d::name = %s\n", pnumber, pname);
            EXEC SQL UPDATE professor SET pnumber = :pnumber WHERE
CURRENT OF myCursor;

      }
      EXEC SQL CLOSE myCursor;
      EXEC SQL commit;

}

void sqlerror () {
      printf ("stop error:\t%25i\n", sqlca.sqlcode);
      exit (0);
}

void sqlwarning () {
      printf ("stop warning:\t%25i\n", sqlca.sqlcode);
      return;
}

<h2><span class="brown">SQL with C Test Program 5: DELETING Using cursors</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int pnumber;
      char pname [30];
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

void sqlerror ();
void sqlwarning ();

main () {

      int n = 0;

      strcpy ((char *) userid.arr, "mmani");
      userid.len = strlen ((char *) userid.arr);
      strcpy ((char *) passwd.arr, "mmani");
      passwd.len = strlen ((char *) passwd.arr);

      EXEC SQL WHENEVER SQLERROR DO sqlerror ();
      EXEC SQL WHENEVER SQLWARNING DO sqlwarning ();
      EXEC SQL WHENEVER NOT FOUND DO BREAK;

      EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

      EXEC SQL DECLARE myCursor CURSOR FOR select pNumber, pName from professor FOR UPDATE;

      EXEC SQL OPEN myCursor;
      while (1) {

             EXEC SQL FETCH myCursor INTO :pnumber, :pname;

             pnumber = pnumber + 1;
             printf ("number = %d::name = %s\n", pnumber, pname);
             if (pnumber >= 7) {
                   EXEC SQL DELETE FROM professor WHERE CURRENT OF
myCursor;
             }

      }
      EXEC SQL CLOSE myCursor;
      EXEC SQL commit;

}

void sqlerror () {
      printf ("stop error:\t%25i\n", sqlca.sqlcode);
      exit (0);
}

void sqlwarning () {
      printf ("stop warning:\t%25i\n", sqlca.sqlcode);
      return;
}

<h2><span class="brown">SQL with C Test Program 6: Handling Null values and also introducing scrollable cursors</span></h2>

#include &lt;stdio.h>
#include &lt;string.h>
#include &lt;stdlib.h>

EXEC SQL BEGIN DECLARE SECTION;
      VARCHAR userid[20];
      VARCHAR passwd[20];
      int pnumber;
      char pname [30];
      short isNullNumber;
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;

void sqlerror ();
void sqlwarning ();

main () {

      strcpy ((char *) userid.arr, "mmani");
      userid.len = strlen ((char *)userid.arr);
      strcpy ((char *)passwd.arr, "mmani");
      passwd.len = strlen ((char *)passwd.arr);

      EXEC SQL WHENEVER SQLERROR DO sqlerror ();
      EXEC SQL WHENEVER SQLWARNING DO sqlwarning ();
      EXEC SQL WHENEVER NOT FOUND DO BREAK;

      EXEC SQL CONNECT :userid IDENTIFIED BY :passwd;

      EXEC SQL DECLARE myCursor SCROLL CURSOR FOR select sNumber, sName
from student;

      EXEC SQL OPEN myCursor;
      while (1) {
            EXEC SQL FETCH RELATIVE 2 myCursor INTO
:pnumber:isNullNumber, :pname;

              if (isNullNumber == -1) { printf ("NULL value\n");
continue; }

            printf ("number = %d::name = %s\n", pnumber, pname);
      }
      EXEC SQL CLOSE myCursor;

}

void sqlerror () {
      /* printf ("stop error:\t%25i\n", sqlca.sqlcode); */
      return;
}

void sqlwarning () {
      printf ("stop warning:\t%25i\n", sqlca.sqlcode);
      return;
}

<h2>C++ ๅญฆ็ๆ็ปฉ็ฎก็็ณป็ป</h2>
็จc++ๅไธไธช็ฎๆ็็ๅญฆ็ๆ็ปฉ็ฎก็็ณป็ปใ
้ๆฑ๏ผ
ๆๆป็้ขๆๅผ็ฎๅฝ๏ผๆนไพฟ็จๆทไบ่งฃไฝฟ็จๅ่ฝใ
่ฝๆฅ่ฏขๆๆๆ็ปฉใ
่ฝๆทปๅไธไธชๆฐๆ็ปฉใ
่ฝๆฅ่ฏข็ณป็ปๅญๅจ็ๆ็ปฉ๏ผไธๅญๅจ็่ฏ็ปๅบๆๅผใ
่ฝๅ้ค็ณป็ปๅญๅจ็ๆ็ปฉ๏ผไธๅญๅจ็่ฏ็ปๅบๆๅผใ
่ฝไฟฎๆน็ณป็ปๅญๅจ็ๆ็ปฉ๏ผไธๅญๅจ็่ฏ็ปๅบๆๅผใ
่ฝ้ๅบ็ณป็ปใ

ๆป็ฎๅฝ็้ขๅฆไธ๏ผ
<img class="lazy" data-src="https://mmbiz.qpic.cn/mmbiz_png/7iczZAX6obSHBgjS1b555HEia1W24qb8FasJzzkqXavrZwNs8DSx0pwz8eyaq5IEGQ6dnrsJf6MHnhyqh3R9DbIw/640">

1ใๅฏผๅฅๆ้็ๅคดๆไปถ
<code>#include&lt;stdlib.h>
#include&lt;stdio.h>
#include&lt;string.h>
#include&lt;iostream></code>

2ใไฝฟ็จๅฝๅ็ฉบ้ดใๅฎไน็ปๆไฝstudent๏ผ็ปๆไฝไธญๅๅซๆดๅ็ผๅทidๅ้ๆบๅ้id๏ผไปฅๅๅญๆพๅๅญ็ๅญ็ฌฆๆฐ็ปname๏ผๅ็ฒพๅบฆๆตฎ็นๅๆฐๆฎchinese,math,englishๅๅซๅญๆพ่ฏญๆใๆฐๅญฆใ่ฑ่ฏญๆ็ปฉใ
ๅนถๅฃฐๆๅจๅฑๅ้็ปๆไฝๆฐ็ปstu[100]ๆฟๆฅๅญๆพๆดไธช็ญ็ๆ็ปฉ๏ผrecๅญๆพๆไฝ่ฎฐๅฝไฝ็ฝฎใ

<code>using namespace std;
struct student
{
   int id,rand_id;
   char name[10];
   double chinese,math,english;
       };
struct student stu[100];
intrec=0;</code>

3ใๆฅ่ฏขๆๆๆ็ปฉๅฝๆฐ
<code>void print_data()
{
  cout&lt;&lt;"้ๆบ็\t็ผๅท\tๅงๅ\t่ฏญๆ\tๆฐๅญฆ\t่ฑ่ฏญ"&lt;&lt;endl;
  for( int i=0;i&lt;rec;i++)
  {    
    cout&lt;&lt;stu[i].rand_id&lt;&lt;"\t"&lt;&lt;stu[i].id&lt;&lt;"\t"&lt;&lt;stu[i].name&lt;&lt;"\t"&lt;&lt;stu[i].chinese&lt;&lt;"\t"&lt;&lt;stu[i].math&lt;&lt;"\t"&lt;&lt;stu[i].english&lt;&lt;endl; 
       }
}</code>

4ใๆทปๅไธไธชๆ็ปฉๅฝๆฐ
<code>void append_data()
{
  cout&lt;&lt;"่ฏท่พๅฅ้่ฆๆทปๅ็ๆฐๆฎ\n็ผๅท\tๅงๅ\t่ฏญๆ\tๆฐๅญฆ\t่ฑ่ฏญ\n"; 
  cin>>stu[rec].id>>stu[rec].name>>stu[rec].chinese>>stu[rec].math>>stu[rec].english;
  stu[rec].rand_id=rand()*(9999-999)+999+1;
  rec++;  
     } </code>

5ใๆฅ่ฏขไธไธชๆ็ปฉๅฝๆฐ
<code>void find_data()
{
  char find_name[10];
  int find_flg=0;
  cout&lt;&lt;"่ฏท่พๅฅ้่ฆๆฅ่ฏข็ๅๅญ\n";
  cin>>find_name;
  for(int i=0;i&lt;rec;i++)
  {
    if( strcmp(stu[i].name,find_name)==0)
    {
    find_flg=1;
    cout&lt;&lt;"้ๆบ็\t็ผๅท\tๅงๅ\t่ฏญๆ\tๆฐๅญฆ\t่ฑ่ฏญ"&lt;&lt;endl;
    cout&lt;&lt;stu[i].rand_id&lt;&lt;"\t"&lt;&lt;stu[i].id&lt;&lt;"\t"&lt;&lt;stu[i].name&lt;&lt;"\t"&lt;&lt;stu[i].chinese&lt;&lt;"\t"&lt;&lt;stu[i].math&lt;&lt;"\t"&lt;&lt;stu[i].english&lt;&lt;endl; 
        }
      } 
  if(find_flg==0) 
  cout&lt;&lt;"็ณป็ปไธๅญๅจ่ฏฅๆฐๆฎ\n";            
}</code>

6ใๅ้คไธไธชๆ็ปฉๅฝๆฐ
<code>void del_data()
{
  char del_name[10];
  int del_flg=0;
  cout&lt;&lt;"่ฏท่พๅฅ้่ฆๅ้ค็ๅๅญ\n";
  cin>>del_name;
  for (int i=0;i&lt;rec;i++)
  {
    if( strcmp(stu[i].name,del_name)==0)
    {
      del_flg=1;
      for(;i&lt;rec;i++)
      {
        stu[i].rand_id=stu[i+1].rand_id;
        stu[i].id=stu[i+1].id;
        strcpy(stu[i].name,stu[i+1].name);
        stu[i].chinese=stu[i+1].chinese;
        stu[i].math=stu[i+1].math;
        stu[i].english=stu[i+1].english; 
                          
       }
    rec--;
     break;
     }
      } 
   if(del_flg==1) 
   cout&lt;&lt;"ๅ้คๆๅ\n";    
   else cout&lt;&lt;"็ณป็ปไธๅญๅจ่ฏฅๆฐๆฎ";                  
}</code>

7ใไฟฎๆนไธไธชๆ็ปฉๅฝๆฐ
<code>void update_data()
{
  char update_name[10];
  int update_flg=0;
  cout&lt;&lt;"่ฏท่พๅฅ้่ฆไฟฎๆน็ๅๅญ\n";
  cin>>update_name;
  for (int i=0;i&lt;rec;i++)
  {
    if( strcmp(stu[i].name,update_name)==0)
    {        
     update_flg=1;    
     cout&lt;&lt;"่ฏท่พๅฅ้่ฆไฟฎๆน็ๆฐๆฎ\n็ผๅท\tๅงๅ\t่ฏญๆ\tๆฐๅญฆ\t่ฑ่ฏญ\n"; 
     cin>>stu[i].id>>stu[i].name>>stu[i].chinese>>stu[i].math>>stu[i].english;                        
     break;
     }
     }
   if(update_flg==1){cout&lt;&lt;"ไฟฎๆนๆๅ\n";}   
   else{cout&lt;&lt;"็ณป็ปไธๅญๅจ่ฏฅๆฐๆฎ\n"; }                 
}</code>

8ใ็ฎๅฝๅฝๆฐ๏ผๆๅผๆไฝ
<code>void mulu()
{
    cout&lt;&lt;"ๆฌข่ฟไฝฟ็จๆ็ปฉ็ฎก็็ณป็ป\n"; 
    cout&lt;&lt;"1.ๆฅ่ฏขๆๆๆ็ปฉ\n"; 
    cout&lt;&lt;"2.ๆทปๅไธไธชๆ็ปฉ\n";
    cout&lt;&lt;"3.ๆฅ่ฏขไธไธชๆ็ปฉ\n";
    cout&lt;&lt;"4.ๅ้คไธไธชๆ็ปฉ\n";
    cout&lt;&lt;"5.ไฟฎๆนไธไธชๆ็ปฉ\n";
    cout&lt;&lt;"6.้ๅบ็ณป็ป\n";
     }</code>

9ใ็ผๅไธปๅฝๆฐ๏ผๅจไธปๅฝๆฐไธญๆ้่ฆ่ฐ็จๅ้ขๅฎไนๅฅฝ็ๅฝๆฐ
<code>int main()
{
    mulu();    
    int num;
    while(1)
    {
      cout&lt;&lt;"่ฏท่พๅฅๆไฝๅท1-6๏ผ\n";
      cin>>num;
      if(num==1) { cout&lt;&lt;"1.ๆฅ่ฏขๆๆๆ็ปฉ\n"; print_data();}
      else if(num==2) { cout&lt;&lt;"2.ๆทปๅไธไธชๆ็ปฉ\n";append_data();}
      else if(num==3) { cout&lt;&lt;"3.ๆฅ่ฏขไธไธชๆ็ปฉ\n"; find_data();}
      else if(num==4) { cout&lt;&lt;"4.ๅ้คไธไธชๆ็ปฉ\n"; del_data();}
      else if(num==5) { cout&lt;&lt;"5.ไฟฎๆนไธไธชๆ็ปฉ\n"; update_data();}
      else if(num==6) { cout&lt;&lt;"6.้ๅบ็ณป็ป\n"; break;}
    
    }
    //system("pause");
    return 0;
}</code>ๆไฝๆๆๆผ็คบ๏ผ
<iframe data-src="https://mp.weixin.qq.com/mp/readtemplate?t=pages/video_player_tmpl&amp;action=mpvideo&amp;auto=0&amp;vid=wxv_3183083377546215429"></iframe>ๆๅฑ๏ผ
ๆๅด่ถฃ็ๆๅไปฌ๏ผๅฏไปฅๆทปๅๆฐๆฎๅบ่ฟ่ก็ปๅฎๅฆ๏ผ่ฟๆทๅฐฑๅฏไปฅๅฎ็ฐๆฐๆฎ่ฏปๅไบๆญฃๅธธไฝฟ็จๆฅ็ฎก็ๅญฆ็ๆ็ปฉไบใ

<h2>็จC่ฏญ่จๆฅ่ฏปๅๆฅๆๅๆถ้ด</h2>
ๅฏไปฅไฝฟ็จๆๅCๅบไธญ็ๆไปถๆไฝๅ่ฝๅๆฅๆๆถ้ดๅค็ๅฝๆฐใ

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_LINE_LENGTH 100

int main() {
    // ่ฏปๅ้น้ๆฅๆๅๆถ้ด็ๆๆฌๆไปถ่ทฏๅพ
    char file_path[] = "path/to/alarms.txt";

    // ๅญๅจ้น้ๆฅๆๅๆถ้ด็ๆฐ็ป
    char alarms[100][MAX_LINE_LENGTH];
    int num_alarms = 0;

    // ๆๅผๆๆฌๆไปถๅนถ่ฏปๅ้น้ๆฅๆๅๆถ้ด
    FILE *file = fopen(file_path, "r");
    if (file == NULL) {
        printf("ๆๆณๆๅผๆไปถ๏ผ%s\n", file_path);
        return 1;
    }

    char line[MAX_LINE_LENGTH];
    while (fgets(line, sizeof(line), file) != NULL) {
        strcpy(alarms[num_alarms], line);
        num_alarms++;
    }

    fclose(file);

    // ๅค็ๆฏไธช้น้
    for (int i = 0; i < num_alarms; i++) {
        // ่ทๅๅฝๅๆฅๆๅๆถ้ด
        time_t current_time = time(NULL);

        // ๅฐ้น้ๆฅๆๅๆถ้ด่ฝฌๆขไธบtm็ปๆ
        struct tm alarm_tm;
        strptime(alarms[i], "%Y-%m-%d %H:%M:%S", &alarm_tm);
        time_t alarm_time = mktime(&alarm_tm);

        // ่ฎก็ฎไธไธไธช้น้ๆฅๆๅๆถ้ด
        time_t next_alarm;
        if (alarm_time < current_time) {
            next_alarm = alarm_time + 24 * 60 * 60; // ๅไธไธๅคฉ็็งๆฐ
        } else {
            next_alarm = alarm_time;
        }

        // ่ฎก็ฎ้น้่งฆๅๆถ้ด้ด้๏ผ็ง๏ผ
        double interval = difftime(next_alarm, current_time);

        // ็ญๅพๆถ้ด้ด้ๅนถ่งฆๅ้น้
        sleep(interval);
        printf("้น้ๆฅๆๅๆถ้ด๏ผ%s\n", alarms[i]);
        printf("้น้ๅ้๏ผ\n");
    }

    return 0;
}
ๅจ่ฟไธช็คบไพไปฃ็ไธญ๏ผๆจ้่ฆๅฐfile_pathๆฐ็ป่ฎพ็ฝฎไธบๅๅซ้น้ๆฅๆๅๆถ้ด็ๆๆฌๆไปถ็่ทฏๅพใ
ไปฃ็ๅฐๆๅผๆไปถๅนถ้่ก่ฏปๅ้น้็ๆฅๆๅๆถ้ด๏ผ็ถๅๅฐๅถๅญๅจๅจalarmsไบ็ปดๆฐ็ปไธญใ

ๆฏไธช้น้็ๆฅๆๅๆถ้ดๅบไปฅYYYY-MM-DD HH:MM:SS็ๆผๅผๅญๅจๅจๆๆฌๆไปถไธญ๏ผๆฏ่กไธไธช้น้ใ

ไปฃ็ๅค็ๆฏไธช้น้๏ผ่ฎก็ฎไธไธไธช้น้็ๆฅๆๅๆถ้ด๏ผๅนถไฝฟ็จsleepๅฝๆฐ็ญๅพๆถ้ด้ด้๏ผ็ถๅ่งฆๅ้น้ใ
ๅจ็คบไพไปฃ็ไธญ๏ผๆไฝฟ็จprintfๅฝๆฐๆฅๆพ็คบ้น้ๆฅๆๅๆถ้ดไปฅๅๅ้ๆ้๏ผๆจๅฏไปฅๆนๆฎ้่ฆ่ฟ่ก่ฐๆดใ

่ฏทๆณจๆ๏ผ็คบไพไปฃ็ไฝฟ็จไบๆๅCๅบไธญ็ๆถ้ดๅๆฅๆๅฝๆฐ๏ผ่ฆ็กฎไฟๅๅซstdio.hใstdlib.hๅtime.hๅคดๆไปถใ
ๅฆๅค๏ผไปฃ็ไฝฟ็จไบPOSIXๆๅ็sleepๅฝๆฐ๏ผๅฏไปฅๅจUnixๅ็ฑปUnix็ณป็ปไธญๆญฃๅธธๅทฅไฝ๏ผไฝๅจWindows็ณป็ปไธๅฏ่ฝ้่ฆไฝฟ็จๅถไป็ฑปไผผ็ๅฝๆฐๆฅๆฟไปฃใ

ๅจWindows็ณป็ปไธ๏ผๅฏไปฅไฝฟ็จ Sleep ๅฝๆฐๆฅๆฟไปฃๆๅCๅบไธญ็ sleep ๅฝๆฐใ
Sleep ๅฝๆฐไฝไบ windows.h ๅคดๆไปถไธญ๏ผๆไพไบไปฅๆฏซ็งไธบๅไฝ็ๅปถ่ฟๅ่ฝใ

#include <stdio.h>
#include <windows.h>

int main() {
    // ๅปถ่ฟๆถ้ด๏ผไปฅๆฏซ็งไธบๅไฝ๏ผ
    DWORD delay = 5000; // ๅปถ่ฟ5็ง

    printf("ๅผๅงๅปถ่ฟ...\n");
    Sleep(delay);
    printf("ๅปถ่ฟ็ปๆ๏ผ\n");

    return 0;
}

ๅจ่ฟไธช็คบไพไปฃ็ไธญ๏ผSleep ๅฝๆฐ่ขซ็จไบๅปถ่ฟไธๆฎตๆถ้ดใSleep ๅฝๆฐ็ๅๆฐไธบๅปถ่ฟ็ๆถ้ด๏ผไปฅๆฏซ็งไธบๅไฝ๏ผใ
ๅจ็คบไพไธญ๏ผๅปถ่ฟไบ5็ง๏ผ5000ๆฏซ็ง๏ผ๏ผ็ถๅ่พๅบ็ธๅบ็ๆ็คบไฟกๆฏใ

่ฏทๆณจๆ๏ผๅจWindows็ณป็ปไธ๏ผ่ฆ็กฎไฟๅๅซ windows.h ๅคดๆไปถ๏ผไปฅไพฟไฝฟ็จ Sleep ๅฝๆฐใ
ๅฆๅค๏ผSleep ๅฝๆฐๆฏ้ปๅก็๏ผๆๅณ็ๅจๅปถ่ฟๆ้ด็จๅบไผๆๅๆง่กใ
ๅฆๆ้่ฆ้้ปๅก็ๅปถ่ฟ๏ผๅฏไปฅ่่ไฝฟ็จๅถไปๆนๆณ๏ผๅฆๅฎๆถๅจๆๅค็บฟ็จใ

ไฝฟ็จๅฎๆถๅจๆๅค็บฟ็จๅฏไปฅๅฎ็ฐ้้ปๅก็ๅปถ่ฟๆๆใ
ไฝฟ็จๅฎๆถๅจ๏ผ

#include <stdio.h>
#include <windows.h>

void CALLBACK TimerCallback(PVOID lpParameter, BOOLEAN TimerOrWaitFired) {
    printf("ๅฎๆถๅจ่งฆๅ๏ผ\n");
}

int main() {
    // ๅปถ่ฟๆถ้ด๏ผไปฅๆฏซ็งไธบๅไฝ๏ผ
    DWORD delay = 5000; // ๅปถ่ฟ5็ง

    printf("ๅผๅงๅปถ่ฟ...\n");

    HANDLE hTimer;
    CreateTimerQueueTimer(&hTimer, NULL, TimerCallback, NULL, delay, 0, 0);
    SleepEx(INFINITE, TRUE); // ็ญๅพๅฎๆถๅจ่งฆๅ

    DeleteTimerQueueTimer(NULL, hTimer, NULL);
    CloseHandle(hTimer);

    printf("ๅปถ่ฟ็ปๆ๏ผ\n");

    return 0;
}
ๅจ่ฟไธช็คบไพไปฃ็ไธญ๏ผไฝฟ็จ CreateTimerQueueTimer ๅฝๆฐๅๅปบไธไธชๅฎๆถๅจ๏ผๅนถๆๅฎๅฎๆถๅจๅ่ฐๅฝๆฐไธบ TimerCallbackใ
ๅจๅ่ฐๅฝๆฐไธญ๏ผๅฏไปฅๆง่ก้่ฆๅปถ่ฟๅๆง่ก็ๆไฝใ
ไฝฟ็จ SleepEx ๅฝๆฐ็ญๅพๅฎๆถๅจ่งฆๅใ
INFINITE ่กจ็คบ็ญๅพๆถ้ดๆ้้ฟ๏ผTRUE ่กจ็คบๅ่ฎธ็ณป็ปๅค็ๅถไปไปปๅกใ

ไฝฟ็จๅค็บฟ็จ๏ผ

#include <stdio.h>
#include <windows.h>

DWORD WINAPI DelayThread(LPVOID lpParam) {
    DWORD delay = *(DWORD*)lpParam;
    Sleep(delay);
    printf("ๅปถ่ฟ็ปๆ๏ผ\n");
    return 0;
}

int main() {
    // ๅปถ่ฟๆถ้ด๏ผไปฅๆฏซ็งไธบๅไฝ๏ผ
    DWORD delay = 5000; // ๅปถ่ฟ5็ง

    printf("ๅผๅงๅปถ่ฟ...\n");

    HANDLE hThread = CreateThread(NULL, 0, DelayThread, &delay, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);

    CloseHandle(hThread);

    printf("ๅปถ่ฟ็ปๆ๏ผ\n");

    return 0;
}
ๅจ่ฟไธช็คบไพไปฃ็ไธญ๏ผไฝฟ็จ CreateThread ๅฝๆฐๅๅปบไธไธชๆฐ็บฟ็จ๏ผๅนถๆๅฎ็บฟ็จๅฝๆฐไธบ DelayThreadใ
ๅจ็บฟ็จๅฝๆฐไธญ๏ผไฝฟ็จ Sleep ๅฝๆฐ่ฟ่กๅปถ่ฟใ
ไฝฟ็จ WaitForSingleObject ๅฝๆฐ็ญๅพ็บฟ็จ็ๅฎๆใ

่ฏทๆณจๆ๏ผๅจไฝฟ็จๅค็บฟ็จๆถ๏ผ้่ฆไฝฟ็จ้ๅฝ็ๅๆญฅๆบๅถๆฅ็กฎไฟ็บฟ็จๅฎๅจใ
ๅจ็คบไพไธญ๏ผๆไปฌไฝฟ็จไบ WaitForSingleObject ๅฝๆฐ็ญๅพ็บฟ็จ็ๅฎๆ๏ผไปฅ็กฎไฟๅปถ่ฟ็ปๆๅๅ็ปง็ปญๆง่กๅ็ปญไปฃ็ใ

ๆ่ฎบๆฏไฝฟ็จๅฎๆถๅจ่ฟๆฏๅค็บฟ็จ๏ผ้ฝๅฏไปฅๅฎ็ฐ้้ปๅก็ๅปถ่ฟๆๆ๏ผๆจๅฏไปฅๆนๆฎๅทไฝ้ๆฑ้ๆฉ้ๅ็ๆนๆณใ

่ฆๅจWindows็ณป็ปไธ็กฎไฟๅๅซ windows.h ๅคดๆไปถ๏ผ
้่ฆ้ตๅพชไปฅไธๆญฅ้ชค๏ผ

็กฎ่ฎคๆจๅทฒ็ปๅฎ่ฃไบ้ๅฝ็ๅผๅๅทฅๅท๏ผๅฆ Visual Studio ๆ MinGW๏ผไปฅไพฟ่ฟ่กC่ฏญ่จ็ผ็จๅๆๅปบใ

ๅๅปบไธไธชๆฐ็Cๆบๆไปถ๏ผไพๅฆ main.cใ

ๅจๆบๆไปถ็ๅผๅคด๏ผๆทปๅ #include <windows.h>๏ผ่ฟๅฐๅๅซWindows APIๆ้็ๅคดๆไปถใ

็ผๅๆจ็Cไปฃ็๏ผไฝฟ็จWindows API็ๅ่ฝใ
ๅฏไปฅๆนๆฎๆจ็้ๆฑๆฅ้็ธๅณ็Windows APIๆๆกฃ๏ผไปฅไบ่งฃๅฆไฝไฝฟ็จ็นๅฎๅ่ฝใ

ไฝฟ็จ้ๅฝ็็ผ่ฏๅฝไปคๆฅๆๅปบๆจ็็จๅบใ
ไพๅฆ๏ผไฝฟ็จ Visual Studio ็ๅผๅ่ๅฝไปคๆ็คบ็ฌฆๆไฝฟ็จ MinGW ็ GCC ็ผ่ฏๅจใ

ๅฏนไบ Visual Studio๏ผๅฏไปฅไฝฟ็จไปฅไธๅฝไปคๆฅ็ผ่ฏๅ้พๆฅๆจ็ไปฃ็๏ผ
cl main.c

ๅฏนไบ MinGW๏ผๅฏไปฅไฝฟ็จไปฅไธๅฝไปคๆฅ็ผ่ฏๅ้พๆฅๆจ็ไปฃ็๏ผ
gcc main.c -o main.exe

ๅฆๆไธๅ้กบๅฉ๏ผๆจ็็จๅบๅฐไผ็ผ่ฏๅ้พๆฅๆๅ๏ผๅนถ็ๆๅฏๆง่กๆไปถ๏ผๅฆ main.exe๏ผใ
็ฐๅจ๏ผๆจๅฏไปฅๅจWindows็ณป็ปไธ่ฟ่ก่ฏฅๅฏๆง่กๆไปถใ

่ฏทๆณจๆ๏ผ็กฎไฟๅจ็ผ่ฏๅๆๅปบ่ฟ็จไธญ๏ผๆจ็ๅผๅ็ฏๅขๅทฒๆญฃ็กฎ้็ฝฎ๏ผๅนถไธๆ้็ๅคดๆไปถๅๅบๆไปถไฝ็ฝฎๅทฒๆญฃ็กฎ่ฎพ็ฝฎใๅทไฝๆไฝๅฏ่ฝๅๆจไฝฟ็จ็ๅผๅๅทฅๅทๅ็ฏๅข่ๆๆไธๅใ
ๅฆๆๅจๆๅปบ่ฟ็จไธญ้ๅฐไปปไฝ้่ฏฏ๏ผๆจๅฏ่ฝ้่ฆๆฃๆฅๅ่ฐๆด็ผ่ฏๅจๅๅผๅ็ฏๅข็้็ฝฎ่ฎพ็ฝฎใ

<h2>split a string by a tab</h2>
using the strtok function from the <string.h> library.

#include <stdio.h>
#include <string.h>

int main() {
    char inputString[] = "Hello\tWorld\t123"; // Input string with tabs
    char *token;

    // Split the string using tabs as the delimiter
    token = strtok(inputString, "\t");
    
    while (token != NULL) {
        printf("%s\n", token);
        token = strtok(NULL, "\t");
    }

    return 0;
}

In this example, the inputString variable contains the string you want to split, which contains tabs.
The strtok function is used to split the string using tabs as the delimiter.

The first call to strtok takes the inputString as the first argument and "\t" as the second argument.
It returns the first token found before the tab character.

Subsequent calls to strtok with a NULL first argument continue splitting the string using the same delimiter.
Each call returns the next token found, or NULL if there are no more tokens.

The loop continues until strtok returns NULL, printing each token on a new line using printf.

Make sure to include the necessary header files (<stdio.h> and <string.h>) at the top of your file to use the required functions and NULL constant.

<H2>EMBEDDED SQL IN C</H2>
<div class="toc">
<A HREF = "#sqlintroduction" target="_self">Introduction</A>
<A HREF = "#sqlsyntax" target="_self">Syntax</A>
<A HREF = "#sqlsqlca" target="_self"><TT>SQLCA</TT></A>
<A HREF = "#sqldclgen" target="_self">DEClaration GENerator</A>
<A HREF = "#sqlcursor" target="_self">The cursor</A>
<A HREF = "#sqlexample" target="_self">Example program</A>
<A HREF = "#sqlnote" target="_self">Final note on empty fields</A>
</div>

<A NAME = "sqlintroduction"></A>
<H3>1. INTRODUCTION</H3>
Embedded SQL is an embedding of the database language SQL into a procedural programming language (C in this document) referred to as the host language.

<A NAME = "sqlsyntax"></A>
<H3>2. SYNTAX</H3>
The syntax of a SQL database statement embedded in any host language is as follows:

(margin) EXEC SQL SQL_STATEMENT (terminator)

In C there is no specified margin, the terminator is ";".

<H3>2.1 An example program outline</H3>
Below is given a (very rough) outline of an example embedded SQL program which features the elements common to most embedded SQL applications.
The program retrieves an employee's <TT>name</TT> where <TT>emp_number</TT> is equal to <TT>10001</TT> from a table called <TT>employees</TT> contained in a database called <TT>frans</TT> and then prints them.

/* Begin program */

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION
         host_name character_string(20)
         host_emp_number integer
EXEC SQL END DECLARE SECTION

EXEC SQL WHENEVER SQLERROR STOP

EXEC SQL CONNECT frans

/* Formulate query, something like: */

EXEC SQL SELECT name emp_number
         INTO host_name host_emp_number
         FROM employees
         WHERE emp_number = 10001

/* Print host_name and host_emp_number */

EXEC SQL DISCONNECT

/* End program */


All statements that begin <TT>EXEC SQL</TT> are embedded SQL database statements.
The function of some of the above statements are obvious others require some additional explanation as follows:

 EXEC SQL INCLUDE SQLCA: Incorporates SQL's error handling mechanism (SQL Communications Area).
 DECLARE SECTION: Host variables must be declared to SQL prior to their use in any embedded SQL statements (the variable names used may be identical to those contained in the actual table).
 EXEC SQL WHENEVER SQLERROR STOP:
An error handling mechanism must precede all executable embedded SQL statements in a program.
 EXEC SQL CONNECT personnel: Initiates access to the <TT>frans</TT> data base.
A <TT>CONNECT</TT> statement must precede any references to a database.
 EXEC SQL SELECT: This is the familiar SQL <TT>select</TT> statement.
It is followed by an <TT>INTO</TT> clause.
This associates retrieved values with host variables in the program.
 EXEC SQL DISCONNECT: Severs the connection between the program and the database.

We are not limited to <TT>SELECT</TT> statements.
We can embed any statement available in standard SQL.
For example we can create a table as follows:

EXEC SQL CREATE TABLE employees
          (name c20,
          emp_number int)

This creates a table called <TT>employees</TT> that has two fields, <TT>name</TT> a character field with 20 characters and <TT>emp_number</TT> an integer field.


<A NAME = "sqlsqlca"></A>
<H3>3. SQLCA</H3>
One of the results of issuing an <TT>INCLUDE SQLCA</TT> statement is the declaration of the SQLCA structure, which can be used for error handling.
This structure is as follows:
 typedef struct {
        char sqlcaid[8];
        long sqlcabc;
        long sqlcode;
        struct {
                short sqlerrml;
                char sqlerrmc [70];
        } sqlerrm;
        struct {
                char sqlwarn0;
                char sqlwarn1;
                char sqlwarn2;
                char sqlwarn3;
                char sqlwarn4;
                char sqlwarn5;
                char sqlwarn6;
                char sqlwarn7;
        } sqlwarn
        char sqlext[8];
} IISQLCA; static IISQLCA sqlca = {0};

Many of the variables defined by the IISQLCA structure are not used.
However the following should be noted:

The SQLCA is initialised after the connect statement is issued.
The fields <TT>sqlcaid</TT> and <TT>sqlcabc</TT> are initialised to the string "SQCLA" and the constant 136, respectively.
These values do not change.
The nested structure <TT>sqlerrm</TT> is a varying length character string consisting of two variables <TT>sqlerrml</TT> and <TT>sqlerrmc</TT>.
If
<TT>sqlerrml</TT> is set to 1 an error has been encountered, otherwise it is set to 0.
<TT>sqlcode</TT> is an integer which is set as follows:
 0 = Statement executed successfully.
 &lt 0 = An error has occurred.
The value is the negative of the error number.
 &gt 0 = Statement executed successfully but some exceptional condition has occurred, e.g. no data processed (empty field encountered).

N.B.
<TT>sqlcode</TT> = 100: empty row encountered.
<TT>sqlcode</TT> = -40202: row containing empty fields encountered.

 The <TT>sqlerrd</TT> array is a set of six 4 byte integers.
Only sqlerrd(3) is used to indicate the number of rows affected by an
<TT>INSERT</TT>, <TT>UPDATE</TT> or <TT>DELETE</TT> statement.
 Variables <TT>sqlwarn0</TT> to <TT>sqlwarn7</TT> denote warnings.

Error handling with SQCLA can be done implicitly by using <TT>WHENEVER</TT> statements, or explicitly by checking the contents of the SQLCA fields
<TT>sqlcode</TT>, <TT>sqlerrml</TT> and <TT>sqlwarn[3]</TT>.


<A NAME = "sqldclgen"></A>
<H3>4. DCLGEN (DEClaration GENerator).</H3>
<TT>DCLGEN</TT> is a structure-generating utility that maps the columns of a database table into a structure that you can include in a variable declaration.
<TT>DCLGEN</TT> is invoked thus:
 dclgen language dbname tablename filename structurename
 where:

 <TT>language</TT> = The embedded SQL host language, for example <TT>C</TT>.
<TT>dbname</TT> = Name of database containing the table of interest, for example <TT>frans</TT>.
 <TT>tablename</TT> = Name of table, for example <TT>employees</TT>.
 <TT>filename</TT> = Output filename in which the output declaration is placed, for example </TT>employees.dcl</TT>.
 <TT>structurename</TT> = Name of the host language structure that the command generates, for example <TT>employees_struct</TT>.

Thus:
 dclgen c frans employees employees.dcl employees_struct

If you invoke this you should see output of the form:

INGRES DCLGEN -- Copyright (c) 1985, 1993 Ingres Corporation
DCLGEN: Working .
. .

DCLGEN: Describing table 'employees' .
. .

The file employees.dcl created by this command will contain a comment and two statements as follows:

/* Description of table employees from database frans */
  EXEC SQL DECLARE employees TABLE
        (emp_number     integer,
         name   c20);

  struct employees_struct_ {
        long    emp_number;
        char    name[21];
  } employees_struct;

Note that the structure tag is the structure name followed by an underscore character "_".
Note also that the length of the character buffers has been increased by 1 to accommodate the C null terminator.
To incorporate this file into a C program it must be compiled into c code using the <TT>esqlc</TT> compiler.
Thus:
 esqlc employees.dcl

This will produce a file <TT>employees.c</TT> as follows:

/* Description of table employees from database frans */
/* # line 6 "employees.dcl" */  /* host code */
  struct employees_struct_ {
        long    emp_number;
        char    name[21];
  } employees_struct;

No specific reference to this file will be made in the application embedded sql in C source code, however, it is required when this source code compiled.


<A NAME = "sqlcursor"></A>
<H3>5. THE CURSOR.</H3>
We have noted that data can be retrieved from an INGRES database using the <TT>select</TT>
SQL statement.
However the <TT>select</TT> statement is not in it self sufficient to perform this task in embedded SQL.
This is because an application needs to process each record, or row, individually.
The syntax of the <TT>select</TT> statement offers no way of doing this in an embedded setting.
To do this embedded SQL uses a cursor.
This can be thought of as a row marker.
Special cursor-oriented statements are available.
What ever the case a cursor must be declared before it can be used.
For example:

EXEC SQL DECLARE empcsr CURSOR FOR
        SELECT name, emp_number
        FROM employees
        WHERE emp_number = 10001;

Once declared we must "open" the cursor:

EXEC SQL OPEN empcsr;

<H3>5.1. "<TT>FETCHING</TT>" the data</H3>
The data retrieved using a <TT>select</TT> statement can be assigned to the host variables, a single row at a time, with the <TT>FETCH</TT> statement.
For example:

EXEC SQL FETCH empcsr
        INTO :host_name, :host_emp_number;
 where <TT>empcsr</TT> is the cursor name (declared earlier), <TT>host_name</TT> and <TT>host_emp_number</TT> are host variable names, note the use of the ":" symbol preceding each host name.
The statement performs two functions.
First it moves the cursor to the next row in the table, which becomes the current row.
Then it loads the values indicated in the <TT>SELECT</TT> part of the <TT>DECLARE CURSOR</TT> statement into the host variables.
The data can then be processed as required.
When a cursor is no longer required it should be "closed":

EXEC SQL CLOSE empcsr

<H3>5.2 The SQL <TT>WHENEVER</TT> statement</H3>
<TT>WHENEVER</TT> provides a convenient method for handling error and exception conditions arising from embedded SQL database statements.
It stipulates that some action occurs when the program attains a specific condition.
The following conditions may be tested for:

<TT>SQLWARNING</TT>.
Indicates that the last embedded SQL statement produced a warning condition.
<TT>SQLERROR</TT>.
Indicates that an error occurred in the last SQL statement.
<TT>NOTFOUND</TT>.
Indicates that an SQL <TT>SELECT</TT>, <TT>FETCH</TT>, <TT>UPDATE</TT> or <TT>DELETE</TT> statement affected no rows.

Possible actions may be one of the following:

<TT>COPY SQLERROR</TT>.
Allows access to the text of an error message.
If a program has determined that an error has occurred (<TT>sqlcode</TT> is negative) it can use this statement to put the text of the error message into a variable that can be printed.
<TT>CONTINUE</TT>.
<TT>STOP</TT>.
<TT>GOTO</TT>.
<TT>CALL</TT>

<H3>5.3 Putting The Above Together</H3>
Below the example outline embedded SQL program given in Section 2.1 has been extended to illustrate cursor processing (and to make it more <TT>c</TT> like).

/* Begin program */

EXEC SQL INCLUDE SQLCA;

EXEC SQL BEGIN DECLARE SECTION;
         host_name character_string(21);
         host_emp_number int;
EXEC SQL END DECLARE SECTION ;

EXEC SQL WHENEVER SQLERROR STOP;

EXEC SQL CONNECT frans;

/* Define and open cursor */

EXEC SQL DECLARE empcsr CURSOR FOR
        SELECT name, emp_number
        FROM employees
        WHERE emp_number = 10001;

EXEC SQL OPEN empcsr;

EXEC SQL WHENEVER NOT FOUND GOTO close_empcsr;

/* Loop indefinitely (the WHENEVER NOT FOUND statement will cause the loop to be terminated when the end of the table is encountered.
*/

/* Commence loop */
        EXEC SQL FETCH
                INTO :host_name, :host_emp_number;

        /* Print host_name and host_emp_number */

/* End loop */

/* Close and disconnect */
 close_empcsr:
        EXEC SQL CLOSE close_empcsr;

EXEC SQL DISCONNECT

/* End program */


<A NAME = "sqlexample"></A>
<H3>6. WRITING AN EMBEDDED SQL FILE IN C</H3>
To write an executable embedded SQL in C program the following sequence of steps should be followed:

Run the <TT>dclgen</TT> utility: dclgen language dbname tablename filname1 structurename
Compile the resulting <TT>.dcl</TT> file using the appropriate <TT>esql</TT> compiler, <TT>esqlc</TT> in the case of the C programming language: esqlc filename1.dcl
Write the C source code but give it the post fix <TT>.sc</TT> (not <TT>.c</TT>).
Compile the SQL routines in the .sc source file into C using the appropriate <TT>esql</TT> compiler (i.e.
<TT>esqlc</TT> this case): esqlc filename.sc
This creates a file <TT>filename.c</TT> which can be examined.
 Compile the <TT>.c</TT> file using cc -Aa -o filename filename.c /cs/apps3/ingres/ingres/lib/libingres.a -lm -lc or using the shorthand version: ingcc -o filename filename.c
This then creates a file <TT>filename</TT> which is the final executable.

<H3>6.1 An embedded SQL in C example program</H3>
We will now put all of the above together to produce a <TT></TT> program, <TT>tempest</TT>, that retrieves an employee's <TT>name</TT> where <TT>emp_number</TT> is equal to <TT>10001</TT> from a table called <TT>employees</TT> contained in a database called <TT>frans</TT> and then prints the result.
The <TT>.sc</TT> code is as follows:

/* ---------------------------------------- */
/*                                          */
/*      EMBEDDED SQL IN C TEST PROGRAM      */
/*                                          */
/*               Frans Coenen               */
/*             (20 March, 1998)             */
/*                                          */
/* ---------------------------------------- */

/* To compile (assuming an appropriate .dcl file exists):
"esqlc tempest.sc" and then "cc -Aa -o tempest tempest.c
/cs/apps3/ingres/ingres/lib/libingres.a -lm -lc" */

/* Include statements.
*/

#include<stdio.h>
EXEC SQL INCLUDE SQLCA;

/* Function prototypes */
 void cleanUp(void);

/* ------ MAIN ------ */

/* Top level function */
 void main(void)
{
EXEC SQL BEGIN DECLARE SECTION;
        char host_name[21];
        int host_emp_number;
        EXEC SQL INCLUDE "employees.dcl";
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE empcsr CURSOR FOR
        SELECT name, emp_number
        FROM employees
        WHERE emp_number = 10001;

/* An error when opening the frans database will cause the error to be printed and the program to be aborted */

EXEC SQL WHENEVER SQLERROR STOP;

EXEC SQL CONNECT frans;

/* Errors from here on will cause the program to clean up */

EXEC SQL WHENEVER SQLERROR CALL cleanUp;

EXEC SQL OPEN empcsr;
 printf("Some values from the /"employees/" table /n");

/* When ever no more rows are fetched, close the cursor */

EXEC SQL WHENEVER NOT FOUND GOTO close_empcsr;

/* The last executable SQL statement was OPEN so we know that the value of "sqlcode" cannot be SQLERROR or NOT FOUND */
 while(sqlca.sqlcode == 0) {     /* Loop is broken by NOT FOUND */
        EXEC SQL FETCH empcsr
                INTO :host_name, :host_emp_number;

/* This "printf" does not execute after the previous FETCH returns the
NOT FOUND condition */

        printf("%s %d/n",host_name,host_emp_number);
        }

/* From this point onwards the program ignore all errors.
Also turn off the NOT FOUND condition for consistency */

EXEC SQL WHENEVER SQLERROR CONTINUE;
EXEC SQL WHENEVER NOT FOUND CONTINUE;
 close_empcsr:
        EXEC SQL CLOSE empcsr;

EXEC SQL DISCONNECT;
}

/* ------ CLEAN UP ------ */

/* Error handling procedure (print error and disconnect) */
 void cleanUp(void)
{
EXEC SQL BEGIN DECLARE SECTION;
        char errmsg[10];
EXEC SQL END DECLARE SECTION;

EXEC SQL INQUIRE_SQL (:errmsg = ERRORTEXT); /* Get error message.
*/
/* Alternatively to get only the error number
EXEC SQL COPY SQLERROR INTO :errmsg WITH 256; */
 printf("Aborting because of error: /n%s/n",errmsg);

EXEC SQL DISCONNECT; exit(-1);
}

Remember that a label in C begins with an alphabetic character or an underscore, it must be the first word on the line and must be terminated with a ":", thus <TT>close_empcsr:</TT>.

Alternatively. to select all records in the <TT>employees</TT> table we would define the cursor as follows:

EXEC SQL DECLARE empcsr CURSOR FOR
          SELECT name, emp_number
          FROM employees;

<H3>6.2 Discussion</H3>
<TT>EXEC SQL INCLUDE</TT>: The <TT>INCLUDE</TT> statement provides a means of including external SQL files in the source code.
Here it is used to include the <TT>SQLCA</TT> structure and the <TT>papers.dcl</TT> files.
 <TT>EXEC SQL BEGIN ....
END DECLARE SECTION</TT>:
Host variables must be declared prior to their use.
The declaration types must match those in the .dcl file.
Also note the
<TT>EXEC SQL INCLUDE</TT> "papers.dcl" statement.
Host variables can be global or local.
 <TT>EXEC SQL DECLARE CURSOR</TT>: Names a cursor for use with a specified set of retrieval criteria.
Once declared the cursor can be opened, using an <TT>OPEN</TT> statement, which causes the select statement specified in <TT>DECLARE CURSOR</TT> to be executed.
The run time retrieval actually occurs when a <TT>FETCH</TT> is subsequently performed.
When all processing has been completed the cursor can be closed with the <TT>CLOSE</TT> statement.
 <TT>EXEC SQL WHENEVER SQLERROR STOP</TT>: The <TT>WHENEVER</TT> statement stipulates that some action occurs when a given condition is satisfied.
In this case the action is
<TT>STOP</TT> and the condition <TT>SQLERROR</TT>.
The <TT>SQLERROR</TT> condition is satisfied if <TT>sqlcode</TT> in the <TT>SQCLA</TT> structure is negative (this indicates that an error has occurred.) The <TT>STOP</TT> action simply terminates program execution after printing an error message.
 <TT>EXEC SQL CONNECT</TT>: Connects the program to the named database.
The statement must precede any statements using the database.
 <TT>EXEC SQL WHENEVER SQLERROR CALL</TT>: Similar to 4. The <TT>CALL</TT> action is used to call a host language procedure (<TT>cleanUp</TT> in this case).
No arguments can be passed to the procedure.
 <TT>EXEC SQL OPEN</TT>: Opens the cursor (<TT>empcsr</TT>) for processing.
A cursor must be opened before any data manipulation statements can be performed e.g. a <TT>FETCH</TT> statement.
 <TT>EXEC SQL WHENEVER NOT FOUND GOTO</TT>: Similar to 4 and 6. The <TT>NOT FOUND</TT> condition becomes true when
<TT>sqlcode</TT> in the SQLCA structure is set to a value of 100 thus indicating that (say) a <TT>FETCH</TT> statement affected no rows.
The <TT>GOTO</TT> action is the same as the "goto" statement in C (apologies to
Dijkstra!).
 <TT>EXEC SQL FETCH</TT>: Used by the cursor (<TT>empcsr</TT>).
It first advances the open cursor one row.
Next it loads the values indicated in the <TT>SELECT</TT> clause of the
<TT>DECLARE CURSOR</TT> statement into the host variables listed in its <TT>INTO</TT> clause.
Once loaded into the host variables  the values can be further processed.
 <TT>EXEC SQL WHENEVER SQLERROR CONTINUE</TT> and
EXEC SQL WHENEVER NOT FOUND CONTINUE: Similar to 4, 6 and 8. The <TT>CONTINUE</TT> action simply means that no action should be taken based on the associated condition, the program proceeds to the next statement.
 <TT>EXEC SQL CLOSE</TT>: Close the open cursor (<TT>empcsr</TT>)
 <TT>EXEC SQL DISCONNECT</TT>: Terminate access to the (<TT>frans</TT>) database.
 <TT>EXEC SQL COPY SQLERROR</TT>: Allows access to text of error messages.
Thus when an error occurs, i.e.
<TT>sqlcode</TT> is negative, the text of the error message can be put into the name variable <TT>errmsg</TT>) and printed.


<A NAME = "sqlnote"></A>
<H3>7. NOTE ON EMPTY FIELDS.</H3>
To list all fields in a table which includes empty fields will result in an error
(<TT>sqlcode</TT> = -40202) when ever an empty field is encountered.
We can test for this and over ride the error.
However the result is that the entry from the last occasion when an instantiated value for the field was encountered is printed.
This can not be tested for as entries for fields may correctly be repeated.
Further there is no indication of which fields are empty.
The error code only indicates that one or more empty field in a row have been encountered and not the position of the field or fields within the row.
At present the only solution would appear to be to include a null string in empty character fields and a value of zero in empty numeric fields.
This will be quite acceptable in the database under discussion here, however in some applications a numeric value of zero may be a legitimate value.
It is hoped that a solution will be found in the near future!







<script type='text/javascript' src='readbook.js'></script>
<script>
var lazyLoadInstance = new LazyLoad({
    elements_selector: ".lazy"
    // ... more custom settings?
});
</script>
</pre>

</body>
</html>
